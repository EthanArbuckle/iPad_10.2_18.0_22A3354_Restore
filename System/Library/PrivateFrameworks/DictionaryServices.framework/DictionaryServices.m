CFMutableArrayRef DCSSearchFoundationCopyResultsWithOptions(const __CFString *a1, const __CFArray *a2, const __CFString *a3)
{
  uint64_t v6;
  CFIndex Length;
  CFIndex v8;
  CFIndex MaximumSizeForEncoding;
  uint64_t v10;
  const char *v11;
  CFIndex v12;
  Class Class;
  Class v14;
  __CFArray *v15;
  CFIndex v16;
  const __CFString *v17;
  DCSDictionary **ValueAtIndex;
  const __CFArray *v19;
  const void *v20;
  id v21;
  CFStringRef v22;
  const __CFString *v23;
  const __CFArray *v24;
  DCSDictionary **v25;
  const void *Value;
  const void *v27;
  const void *v28;
  const __CFString *v29;
  const __CFString *v30;
  const __CFString *Identifier;
  CFIndex v32;
  DCSRecord *Title;
  id v34;
  id v35;
  uint64_t v36;
  const __CFArray *v37;
  const void *v38;
  CFArrayRef v39;
  CFStringRef v40;
  id v41;
  id v42;
  id v43;
  id v44;
  CFStringRef v45;
  const __CFDictionary *v46;
  CFStringRef v47;
  const CFArrayCallBacks *v48;
  CFArrayRef v49;
  const __CFArray *v50;
  const __CFArray *v51;
  CFIndex v52;
  CFMutableArrayRef v53;
  CFIndex v54;
  const __CFString *v55;
  const void *v56;
  const __CFString *v57;
  const __CFDictionary *v58;
  const void *v59;
  unint64_t v60;
  CFMutableArrayRef v61;
  __CFArray *v62;
  uint64_t v63;
  const __CFString *v64;
  CFIndex v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  const __CFString *v70;
  const __CFArray *v71;
  const __CFString *v72;
  uint64_t v73;
  __CFNumberFormatter *v74;
  CFIndex v75;
  const __CFNumber *v76;
  CFStringRef StringWithNumber;
  CFStringRef v78;
  __CFNumberFormatter *v79;
  const void *v80;
  const __CFString *v81;
  CFStringRef v82;
  id v83;
  CFStringRef v84;
  uint64_t v85;
  const __CFDictionary *Name;
  id v87;
  const __CFDictionary *v88;
  uint64_t v90;
  id v91;
  SEL v92;
  const __CFString *v93;
  const void *v94;
  const __CFString *v95;
  SEL v96;
  CFIndex v97;
  CFIndex v98;
  SEL v99;
  SEL v100;
  SEL v101;
  const __CFString *v102;
  const __CFString *v103;
  const __CFArray *v104;
  SEL v105;
  SEL v106;
  SEL v107;
  SEL v108;
  SEL v109;
  SEL v110;
  const __CFString *v111;
  SEL v112;
  SEL v113;
  SEL v114;
  SEL v115;
  Class v116;
  CFIndex v117;
  __CFArray *v118;
  CFMutableArrayRef Mutable;
  const __CFString *v120;
  const __CFString *v121;
  const __CFString *v122;
  const __CFString *v123;
  SEL v124;
  CFIndex Count;
  DCSDictionary **v126;
  const __CFArray *v127;
  id v128;
  DCSDictionary **v129;
  uint64_t v130;
  SEL v131;
  SEL v132;
  uint64_t v133;
  __CFArray *v134;
  unint64_t v135;
  const __CFString *v136;
  CFIndex valuePtr;
  void *v138[2];
  void *values[7];
  CFRange v140;
  CFRange v141;

  values[6] = *(void **)MEMORY[0x1E0C80C00];
  if (_GetSearchFoundationFrameworkInfo__DispatchOnceToken != -1)
    dispatch_once(&_GetSearchFoundationFrameworkInfo__DispatchOnceToken, &__block_literal_global_4);
  v6 = _GetSearchFoundationFrameworkInfo__InfoPtr;
  if (!_GetSearchFoundationFrameworkInfo__InfoPtr)
    return 0;
  v91 = (id)NewAutoReleasePool();
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  Length = CFStringGetLength(CFSTR("com.apple.dictionary"));
  if (a2)
    Count = CFArrayGetCount(a2);
  else
    Count = 0;
  v116 = *(Class *)v6;
  if (a3)
  {
    v8 = CFStringGetLength(a3);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v8, 0x8000100u);
    MEMORY[0x1E0C80A78](MaximumSizeForEncoding);
    v11 = (char *)&v90 - v10;
    if (CFStringGetCString(a3, (char *)&v90 - v10, v12, 0x8000100u))
    {
      Class = objc_getClass(v11);
      v14 = *(Class *)v6;
      v116 = Class;
      if ((-[objc_class isSubclassOfClass:](Class, "isSubclassOfClass:", v14) & 1) == 0)
        v116 = *(Class *)v6;
    }
  }
  if (Count >= 1)
  {
    v15 = 0;
    v16 = 0;
    v124 = sel_setIdentifier_;
    v115 = sel_setType_;
    v114 = sel_setIsQuickGlance_;
    v113 = sel_setSectionBundleIdentifier_;
    v112 = sel_setResultBundleId_;
    v17 = CFSTR("DCSTextElementKeyRecordID");
    v120 = CFSTR("DCSTextElementKeyHeadword");
    v111 = CFSTR("DCSTextElementKeySyllabifiedHeadword");
    v123 = CFSTR("DCSTextElementKeyPartOfSpeech");
    v122 = CFSTR("DCSTextElementKeyPronunciation");
    v98 = Length + 1;
    v97 = ~Length;
    v121 = CFSTR("DCSTextElementKeySensesWithAttributes");
    v106 = sel_setText_;
    v101 = sel_setIsBold_;
    v100 = sel_setFormattedTextPieces_;
    v95 = CFSTR("DCSTextElementSenseKeyIsExplicit");
    v94 = (const void *)*MEMORY[0x1E0C9AE50];
    v93 = CFSTR("DCSTextElementSenseKeyText");
    v105 = sel_setDescriptions_;
    v96 = sel_setTitle_;
    v110 = sel_setFootnote_;
    v109 = sel_setDictionaryID_;
    v108 = sel_setSearchString_;
    v107 = sel_setCard_;
    v99 = sel_textWithString_;
    v92 = sel_setMaxLines_;
    v104 = a2;
    v103 = a1;
    v102 = CFSTR("DCSTextElementKeyRecordID");
    while (1)
    {
      ValueAtIndex = (DCSDictionary **)CFArrayGetValueAtIndex(a2, v16);
      v140.length = CFStringGetLength(a1);
      v129 = ValueAtIndex;
      v140.location = 0;
      v19 = DCSCopyDefinitionRecords(ValueAtIndex, a1, v140, 2);
      if (v19)
        break;
LABEL_66:
      if (++v16 == Count)
        goto LABEL_67;
    }
    v127 = v19;
    v20 = CFArrayGetValueAtIndex(v19, 0);
    v21 = (id)objc_opt_new();
    v22 = CFStringCreateWithFormat(0, 0, CFSTR("local-dictionary-%d:%@"), v15, a1);
    objc_msgSend(v21, v124, v22);
    CFRelease(v22);
    objc_msgSend(v21, v115, 2);
    objc_msgSend(v21, v114, 1);
    objc_msgSend(v21, v113, CFSTR("com.apple.dictionary"));
    v128 = v21;
    objc_msgSend(v21, v112, CFSTR("com.apple.dictionary"));
    values[0] = (void *)v17;
    values[1] = (void *)v120;
    v23 = v111;
    values[2] = (void *)v111;
    values[3] = (void *)v123;
    values[4] = (void *)v122;
    values[5] = (void *)v121;
    v24 = CFArrayCreate(0, (const void **)values, 6, MEMORY[0x1E0C9B378]);
    v25 = DCSRecordCopyTextElements((uint64_t)v20, v24);
    CFRelease(v24);
    if (!v25)
    {
      Title = DCSRecordGetTitle((uint64_t)v20);
      if (!Title)
        Title = DCSRecordGetHeadword((uint64_t)v20);
      v34 = objc_msgSend(*(id *)(v6 + 24), v99, Title);
      v35 = v128;
      objc_msgSend(v128, v96, v34);
      v36 = DCSRecordCopyDefinition((uint64_t)v20, 3);
      v37 = v127;
      if (v36)
      {
        v38 = (const void *)v36;
        v138[0] = 0;
        v138[0] = objc_msgSend(*(id *)(v6 + 16), v99, v36);
        objc_msgSend(v138[0], v92, 3);
        v39 = CFArrayCreate(0, (const void **)v138, 1, MEMORY[0x1E0C9B378]);
        objc_msgSend(v35, v105, v39);
        CFRelease(v39);
        CFRelease(v38);
      }
      goto LABEL_65;
    }
    v117 = v16;
    Value = CFDictionaryGetValue((CFDictionaryRef)v25, v23);
    if (!Value)
      Value = CFDictionaryGetValue((CFDictionaryRef)v25, v120);
    v27 = CFDictionaryGetValue((CFDictionaryRef)v25, v122);
    v28 = CFDictionaryGetValue((CFDictionaryRef)v25, v123);
    v126 = v25;
    v29 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v25, v17);
    if (v29)
      v30 = v29;
    else
      v30 = &stru_1E8B587B0;
    Identifier = (const __CFString *)DCSDictionaryGetIdentifier((uint64_t)v129);
    if (CFStringHasPrefix(Identifier, CFSTR("com.apple.dictionary")))
    {
      v32 = CFStringGetLength(Identifier);
      v141.length = v32 + v97;
      v141.location = v98;
      Identifier = CFStringCreateWithSubstring(0, Identifier, v141);
    }
    else
    {
      CFRetain(Identifier);
    }
    v40 = CFStringCreateWithFormat(0, 0, CFSTR("d:%@.%@"), Identifier, v30);
    CFRelease(Identifier);
    v41 = v128;
    objc_msgSend(v128, v124, v40);
    CFRelease(v40);
    v42 = (id)objc_opt_new();
    v43 = (id)objc_opt_new();
    objc_msgSend(v43, v106, Value);
    objc_msgSend(v43, v101, 1);
    v44 = (id)objc_opt_new();
    if (v28 && v27)
    {
      v45 = CFStringCreateWithFormat(0, 0, CFSTR("  |  %@  |  %@"), v27, v28);
      v46 = (const __CFDictionary *)v126;
      if (!v45)
        goto LABEL_38;
    }
    else
    {
      v46 = (const __CFDictionary *)v126;
      if (v27)
      {
        v47 = CFStringCreateWithFormat(0, 0, CFSTR("  |  %@"), v27);
      }
      else
      {
        if (!v28)
          goto LABEL_38;
        v47 = CFStringCreateWithFormat(0, 0, CFSTR("  |  %@"), v28);
      }
      v45 = v47;
      if (!v47)
      {
LABEL_38:
        v138[0] = v43;
        v138[1] = v44;
        v48 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
        v49 = CFArrayCreate(0, (const void **)v138, 2, MEMORY[0x1E0C9B378]);
        objc_msgSend(v42, v100, v49);
        CFRelease(v49);
        objc_msgSend(v41, sel_getUid("setTitle:"), v42);
        v50 = (const __CFArray *)CFDictionaryGetValue(v46, v121);
        v118 = v15;
        if (v50)
        {
          v51 = v50;
          v52 = CFArrayGetCount(v50);
          v53 = CFArrayCreateMutable(0, v52, v48);
          if (v52)
          {
            v54 = 0;
            v55 = v95;
            v56 = v94;
            v57 = v93;
            v15 = v53;
            do
            {
              v58 = (const __CFDictionary *)CFArrayGetValueAtIndex(v51, v54);
              if (CFDictionaryGetValue(v58, v55) != v56)
              {
                v59 = CFDictionaryGetValue(v58, v57);
                CFArrayAppendValue(v15, v59);
              }
              ++v54;
            }
            while (v52 != v54);
            goto LABEL_47;
          }
        }
        else
        {
          v53 = CFArrayCreateMutable(0, 0, v48);
        }
        v15 = v53;
LABEL_47:
        v60 = CFArrayGetCount(v15);
        v61 = CFArrayCreateMutable(0, 0, v48);
        v62 = v61;
        v135 = v60;
        if (v60 >= 2)
          v63 = 2;
        else
          v63 = v60;
        v64 = CFSTR("%@%@%@");
        if (v63)
        {
          v65 = 0;
          v131 = sel_setMaxLines_;
          v132 = sel_textWithString_;
          v66 = 2;
          if (v135 == 1)
            v66 = 4;
          v130 = v66;
          v67 = 1;
          v133 = v63;
          v134 = v61;
          do
          {
            v68 = v135;
            if (v135 > 2 && v67 == 0)
              v70 = CFSTR("…");
            else
              v70 = &stru_1E8B587B0;
            v136 = v70;
            v71 = v15;
            v72 = v64;
            v73 = v6;
            v74 = CFNumberFormatterCreate(0, 0, kCFNumberFormatterDecimalStyle);
            v75 = v65 + 1;
            valuePtr = v65 + 1;
            v76 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
            StringWithNumber = CFNumberFormatterCreateStringWithNumber(0, v74, v76);
            CFRelease(v76);
            v78 = CFStringCreateWithFormat(0, 0, CFSTR("%@. "), StringWithNumber);
            CFRelease(StringWithNumber);
            v79 = v74;
            v6 = v73;
            v64 = v72;
            v15 = v71;
            CFRelease(v79);
            v80 = CFArrayGetValueAtIndex(v71, v65);
            if (v68 == 1)
              v81 = &stru_1E8B587B0;
            else
              v81 = v78;
            v82 = CFStringCreateWithFormat(0, 0, v64, v81, v80, v136);
            v83 = objc_msgSend(*(id *)(v6 + 16), v132, v82);
            v84 = v82;
            v62 = v134;
            CFRelease(v84);
            CFRelease(v78);
            objc_msgSend(v83, v131, v130);
            CFArrayAppendValue(v62, v83);
            --v67;
            v65 = v75;
          }
          while (v75 != v133);
        }
        v35 = v128;
        objc_msgSend(v128, v105, v62);
        CFRelease(v62);
        CFRelease(v15);
        CFRelease(v126);
        a2 = v104;
        a1 = v103;
        LODWORD(v15) = (_DWORD)v118;
        v16 = v117;
        v17 = v102;
        v37 = v127;
LABEL_65:
        v15 = (__CFArray *)((_DWORD)v15 + 1);
        v85 = (uint64_t)v129;
        Name = DCSDictionaryGetName((uint64_t)v129);
        objc_msgSend(v35, v110, Name);
        v87 = (id)objc_opt_new();
        v88 = DCSDictionaryGetIdentifier(v85);
        objc_msgSend(v87, v109, v88);
        objc_msgSend(v87, v108, a1);
        objc_msgSend(v35, v107, v87);
        CFArrayAppendValue(Mutable, v35);
        CFRelease(v37);
        goto LABEL_66;
      }
    }
    objc_msgSend(v44, v106, v45);
    CFRelease(v45);
    goto LABEL_38;
  }
LABEL_67:

  return Mutable;
}

uint64_t NewAutoReleasePool()
{
  if (_GetFoundationFrameworkInfo__DispatchOnceToken != -1)
    dispatch_once(&_GetFoundationFrameworkInfo__DispatchOnceToken, &__block_literal_global_42);
  if (_GetFoundationFrameworkInfo__InfoPtr)
    return objc_opt_new();
  else
    return 0;
}

__CFArray *DCSEnvironment::copyActiveDictionaries(DCSEnvironment *this, const __CFDictionary *a2)
{
  const __CFBoolean *Value;
  const __CFString *v5;
  const __CFString *v6;
  const __CFArray *ActiveDictionaries;
  CFIndex v8;
  DCSDictionary **ValueAtIndex;
  DCSDictionary **v10;
  DCSDictionary *v11;
  const __CFArray *v12;
  const __CFArray *v13;
  CFIndex v14;
  CFIndex v15;
  CFIndex v16;
  const __CFDictionary *v17;
  DCSEnvironment *v18;
  DCSEnvironment *v19;
  __CFArray *v20;
  pthread_mutex_t *v22;
  __CFArray *Mutable;
  CFIndex Count;
  BOOL v25;
  const __CFArray *theArray;

  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (a2)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(a2, CFSTR("DCSFilterOptionAllowNetworkServices"));
    if (Value)
      v25 = CFBooleanGetValue(Value) != 0;
    else
      v25 = 0;
    v5 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("DCSFilterOptionIndexLanguage"));
    v6 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("DCSFilterOptionDescriptionLanguage"));
  }
  else
  {
    v25 = 0;
    v5 = 0;
    v6 = 0;
  }
  ActiveDictionaries = (const __CFArray *)DCSEnvironment::getActiveDictionaries(this);
  v22 = (pthread_mutex_t *)((char *)this + 264);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
  theArray = ActiveDictionaries;
  if (ActiveDictionaries)
  {
    Count = CFArrayGetCount(ActiveDictionaries);
    if (Count >= 1)
    {
      v8 = 0;
      while (1)
      {
        ValueAtIndex = (DCSDictionary **)CFArrayGetValueAtIndex(theArray, v8);
        v10 = ValueAtIndex;
        if (ValueAtIndex)
          v11 = ValueAtIndex[2];
        else
          v11 = 0;
        if (!v25 && (DCSDictionary::isNetworkDictionary(v11) & 1) != 0)
          goto LABEL_24;
        if (!((unint64_t)v5 | (unint64_t)v6))
          goto LABEL_23;
        v12 = DCSDictionary::languages((CFDictionaryRef *)v11);
        if (v12)
          break;
LABEL_24:
        if (++v8 == Count)
          goto LABEL_25;
      }
      v13 = v12;
      v14 = CFArrayGetCount(v12);
      if (v14 >= 1)
      {
        v15 = v14;
        v16 = 0;
        while (1)
        {
          v17 = (const __CFDictionary *)CFArrayGetValueAtIndex(v13, v16);
          v18 = (DCSEnvironment *)CFDictionaryGetValue(v17, CFSTR("DCSDictionaryIndexLanguage"));
          if (DCSEnvironment::checkLanguageMatch(v18, (CFStringRef)v18, v5))
          {
            v19 = (DCSEnvironment *)CFDictionaryGetValue(v17, CFSTR("DCSDictionaryDescriptionLanguage"));
            if ((DCSEnvironment::checkLanguageMatch(v19, (CFStringRef)v19, v6) & 1) != 0)
              break;
          }
          if (v15 == ++v16)
            goto LABEL_24;
        }
      }
LABEL_23:
      CFArrayAppendValue(Mutable, v10);
      goto LABEL_24;
    }
  }
LABEL_25:
  pthread_mutex_unlock(v22);
  v20 = Mutable;
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return v20;
}

uint64_t DCSBaseDictionary::isNetworkDictionary(DCSBaseDictionary *this)
{
  return 0;
}

const __CFDictionary *DCSDictionary::isNetworkDictionary(DCSDictionary *this)
{
  uint64_t v2;
  const __CFDictionary *result;

  v2 = *((_QWORD *)this + 1);
  if (v2)
    return (const __CFDictionary *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 208))(v2);
  result = (const __CFDictionary *)*((_QWORD *)this + 5);
  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("network"));
    if (result)
      return (const __CFDictionary *)(CFBooleanGetValue(result) != 0);
  }
  return result;
}

uint64_t DCSEnvironment::getActiveDictionaries(DCSEnvironment *this)
{
  uint64_t result;
  const __CFArray *Count;
  const __CFArray *v4;

  result = *((_QWORD *)this + 7);
  if (!result)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
    if (*((_QWORD *)this + 7))
    {
      DCSLog(16, CFSTR("DCSEnvironment::getActiveDictionaries hit cache"));
    }
    else
    {
      Count = DCSDictionaryAssetCopyInstalledDictionaries();
      v4 = Count;
      if (Count)
        Count = (const __CFArray *)CFArrayGetCount(Count);
      DCSLog(16, CFSTR("DCSEnvironment::getActiveDictionaries queried and found %ld assets"), Count);
      *((_QWORD *)this + 7) = v4;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
    return *((_QWORD *)this + 7);
  }
  return result;
}

__CFArray *DCSCopyActiveDictionaries(const __CFDictionary *a1)
{
  DCSEnvironment *v2;

  v2 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  return DCSEnvironment::copyActiveDictionaries(v2, a1);
}

uint64_t SyncSingleton<DCSEnvironment>::instance()
{
  DCSEnvironment *v0;

  if (!SyncSingleton<DCSEnvironment>::_instantiated)
  {
    pthread_mutex_lock(&SyncSingleton<DCSEnvironment>::_mutex);
    if (!SyncSingleton<DCSEnvironment>::_instantiated)
    {
      v0 = (DCSEnvironment *)operator new();
      DCSEnvironment::DCSEnvironment(v0);
      SyncSingleton<DCSEnvironment>::_instance = (uint64_t)v0;
      SyncSingleton<DCSEnvironment>::_instantiated = 1;
    }
    pthread_mutex_unlock(&SyncSingleton<DCSEnvironment>::_mutex);
  }
  return SyncSingleton<DCSEnvironment>::_instance;
}

void sub_1CDF6A058(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10E0C401AB056A1);
  _Unwind_Resume(a1);
}

void DCSDictionary::DCSDictionary(DCSDictionary *this, const __CFURL *a2, __CFDictionary *a3)
{
  CFURLRef v6;
  CFTypeRef v7;
  DCSEnvironment *v8;
  uint64_t v9;
  const __CFDictionary *v10;
  CFStringRef v11;
  const __CFDictionary *Value;
  const void *v13;
  DCSBaseDictionary *v14;
  uint64_t v15;

  *((_QWORD *)this + 1) = 0;
  *((_BYTE *)this + 16) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_WORD *)this + 16) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_WORD *)this + 32) = 0;
  *((_QWORD *)this + 11) = -1;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 104), 0);
  *(_QWORD *)this = DCSDictionary::createDictionaryRef(this);
  if (a2)
    v6 = CFURLCopyAbsoluteURL(a2);
  else
    v6 = 0;
  *((_QWORD *)this + 6) = v6;
  if (a3)
  {
    v7 = CFRetain(a3);
    v6 = (CFURLRef)*((_QWORD *)this + 6);
  }
  else
  {
    v7 = 0;
  }
  *((_QWORD *)this + 12) = v7;
  if (v6)
  {
    v8 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
    v9 = DCSEnvironment::cachedDictionariesInfo(v8);
    if (v9)
    {
      v10 = (const __CFDictionary *)v9;
      v11 = CFURLCopyFileSystemPath(*((CFURLRef *)this + 6), kCFURLPOSIXPathStyle);
      Value = (const __CFDictionary *)CFDictionaryGetValue(v10, CFSTR("dictionaries"));
      if (Value)
      {
        v13 = CFDictionaryGetValue(Value, v11);
        *((_QWORD *)this + 5) = v13;
        if (v13)
          CFRetain(v13);
      }
      else
      {
        *((_QWORD *)this + 5) = 0;
      }
      CFRelease(v11);
    }
  }
  if (!*((_QWORD *)this + 5) && DCSDictionary::createDictionaryObj(this))
  {
    v14 = (DCSBaseDictionary *)*((_QWORD *)this + 1);
    if (v14)
    {
      if (!*((_QWORD *)this + 5))
      {
        *((_QWORD *)this + 5) = _CreateDictionaryCacheInfo(v14);
        *((_BYTE *)this + 33) = 1;
      }
    }
    v15 = SyncSingleton<DCSEnvironment>::instance();
    DCSEnvironment::updateDictionaryCacheInfo(v15, a2, *((const __CFDictionary **)this + 5));
  }
}

uint64_t DCSDictionary::createDictionaryRef(DCSDictionary *this)
{
  uint64_t result;

  pthread_once(&_DCSDictionaryClassID(void)::once_control, (void (*)(void))_DCSDictionaryInitialize);
  result = _CFRuntimeCreateInstance();
  if (result)
    *(_QWORD *)(result + 16) = this;
  return result;
}

uint64_t DCSDictionary::createDictionaryObj(DCSDictionary *this)
{
  const __CFString *v2;
  uint64_t DictionaryObj;
  const __CFArray *v4;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const void *ValueAtIndex;
  const __CFString *v10;
  const __CFString *v11;
  const __CFURL *v12;
  const __CFString *v13;
  const __CFString *v14;
  DCSIDXDictionary *v15;
  uint64_t v16;
  uint64_t v17;
  DCSEnvironment *v18;
  const __CFString *v19;
  const void *DictionaryPreference;

  if (!*((_BYTE *)this + 16))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 104));
    if (*((_BYTE *)this + 16))
    {
LABEL_31:
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 104));
      return *((_QWORD *)this + 1);
    }
    if (*((_BYTE *)this + 32))
    {
      DictionaryObj = DCSDictionary::createDictionaryObj(*((DCSDictionary **)this + 3));
      if (DictionaryObj)
      {
        v4 = (const __CFArray *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)DictionaryObj + 144))(DictionaryObj);
        if (v4)
        {
          v5 = v4;
          Count = CFArrayGetCount(v4);
          if (Count >= 1)
          {
            v7 = Count;
            v8 = 0;
            while (1)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(v5, v8);
              v10 = (const __CFString *)DCSDictionary::identifier(this);
              v11 = (const __CFString *)(*(uint64_t (**)(const void *))(*(_QWORD *)ValueAtIndex + 24))(ValueAtIndex);
              if (CFStringCompare(v10, v11, 0) == kCFCompareEqualTo)
                break;
              if (v7 == ++v8)
                goto LABEL_20;
            }
            *((_QWORD *)this + 1) = ValueAtIndex;
            *((_QWORD *)this + 9) = v8;
          }
        }
      }
      goto LABEL_20;
    }
    v12 = (const __CFURL *)*((_QWORD *)this + 6);
    if (*((_QWORD *)this + 12))
    {
      if (v12)
        goto LABEL_15;
      v12 = (const __CFURL *)DCSEnvironment::copyInactiveDictionaries(*((DCSEnvironment **)this + 12), v2);
      *((_QWORD *)this + 6) = v12;
    }
    if (!v12)
    {
LABEL_20:
      v16 = *((_QWORD *)this + 1);
      if (v16)
      {
        *(_QWORD *)(v16 + 8) = this;
        *(_BYTE *)(v16 + 16) = 1;
        if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 200))(v16) & 1) == 0)
        {
          v17 = *((_QWORD *)this + 1);
          if (v17)
            (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
          *((_QWORD *)this + 1) = 0;
        }
      }
      if (!*((_BYTE *)this + 32) && *((_QWORD *)this + 1))
      {
        v18 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
        v19 = (const __CFString *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1));
        DictionaryPreference = DCSEnvironment::getDictionaryPreference(v18, v19);
        if (DictionaryPreference)
          (*(void (**)(_QWORD, const void *))(**((_QWORD **)this + 1) + 184))(*((_QWORD *)this + 1), DictionaryPreference);
        *((_BYTE *)this + 64) = 0;
        DCSDictionary::subDictionaries(this);
      }
      *((_BYTE *)this + 16) = *((_QWORD *)this + 6) != 0;
      goto LABEL_31;
    }
LABEL_15:
    v13 = CFURLCopyPathExtension(v12);
    if (v13)
    {
      v14 = v13;
      if (CFStringCompare(v13, CFSTR("dictionary"), 0) == kCFCompareEqualTo)
      {
        v15 = (DCSIDXDictionary *)operator new();
        DCSIDXDictionary::DCSIDXDictionary(v15, *((const __CFURL **)this + 6));
        *((_QWORD *)this + 1) = v15;
      }
      CFRelease(v14);
    }
    goto LABEL_20;
  }
  return *((_QWORD *)this + 1);
}

void sub_1CDF6A41C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F1C40ECEE0193);
  _Unwind_Resume(a1);
}

__CFDictionary *DCSDictionary::dictionaryCacheInfo(DCSDictionary *this, int a2)
{
  __CFDictionary *result;

  if (!*((_QWORD *)this + 1))
    return 0;
  result = (__CFDictionary *)*((_QWORD *)this + 5);
  if (a2)
  {
    if (result)
    {
      CFRelease(result);
      *((_QWORD *)this + 5) = 0;
    }
  }
  else if (result)
  {
    return result;
  }
  result = _CreateDictionaryCacheInfo(*((DCSBaseDictionary **)this + 1));
  *((_QWORD *)this + 5) = result;
  *((_BYTE *)this + 33) = 1;
  return result;
}

void DCSDictionary::DCSDictionary(DCSDictionary *this, CFURLRef *a2, const __CFDictionary *a3)
{
  *((_QWORD *)this + 1) = 0;
  *((_BYTE *)this + 16) = 0;
  *((_BYTE *)this + 33) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_BYTE *)this + 64) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = -1;
  *((_QWORD *)this + 12) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 104), 0);
  *(_QWORD *)this = DCSDictionary::createDictionaryRef(this);
  *((_QWORD *)this + 6) = CFURLCopyAbsoluteURL(a2[6]);
  *((_QWORD *)this + 5) = CFRetain(a3);
  *((_QWORD *)this + 3) = a2;
  *((_BYTE *)this + 32) = 1;
}

void DCSDictionary::DCSDictionary(DCSDictionary *this, CFURLRef *a2, DCSBaseDictionary *a3)
{
  const __CFDictionary *v6;
  const __CFArray *Value;
  const __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  const __CFDictionary *ValueAtIndex;
  const __CFString *v13;
  const __CFString *v14;

  *((_BYTE *)this + 33) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_BYTE *)this + 64) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = -1;
  *((_QWORD *)this + 12) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 104), 0);
  *(_QWORD *)this = DCSDictionary::createDictionaryRef(this);
  *((_QWORD *)this + 6) = CFURLCopyAbsoluteURL(a2[6]);
  *((_QWORD *)this + 3) = a2;
  *((_BYTE *)this + 32) = 1;
  *((_QWORD *)this + 1) = a3;
  *((_BYTE *)this + 16) = 1;
  *((_QWORD *)a3 + 1) = this;
  *((_BYTE *)a3 + 16) = 1;
  v6 = a2[5];
  if (v6)
  {
    Value = (const __CFArray *)CFDictionaryGetValue(v6, CFSTR("sub dictionaries"));
    if (Value)
    {
      v8 = Value;
      Count = CFArrayGetCount(Value);
      if (Count >= 1)
      {
        v10 = Count;
        v11 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, v11);
          v13 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("identifier"));
          v14 = (const __CFString *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)a3 + 24))(a3);
          if (CFStringCompare(v13, v14, 0) == kCFCompareEqualTo)
            break;
          if (v10 == ++v11)
            return;
        }
        *((_QWORD *)this + 5) = CFRetain(ValueAtIndex);
      }
    }
  }
}

void DCSDictionary::~DCSDictionary(DCSDictionary *this)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;

  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 104));
  v2 = *((_QWORD *)this + 1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (const void *)*((_QWORD *)this + 6);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 12);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 5);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 7);
  if (v6)
    CFRelease(v6);
  v7 = (const void *)*((_QWORD *)this + 10);
  if (v7)
    CFRelease(v7);
}

uint64_t DCSDictionary::dictionaryRefClassID(DCSDictionary *this)
{
  pthread_once(&_DCSDictionaryClassID(void)::once_control, (void (*)(void))_DCSDictionaryInitialize);
  return _DCSDictionaryID;
}

const __CFDictionary *DCSDictionary::identifier(DCSDictionary *this)
{
  uint64_t v1;
  const __CFDictionary *result;
  const __CFString *v3;
  const __CFDictionary *v4;
  const __CFDictionary *v5;

  v1 = *((_QWORD *)this + 1);
  if (v1)
    return (const __CFDictionary *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v1 + 24))(*((_QWORD *)this + 1));
  if (*((_QWORD *)this + 5))
  {
    v3 = CFSTR("identifier");
    v4 = (const __CFDictionary *)*((_QWORD *)this + 5);
    return (const __CFDictionary *)CFDictionaryGetValue(v4, v3);
  }
  result = (const __CFDictionary *)*((_QWORD *)this + 12);
  if (result)
  {
    v5 = (const __CFDictionary *)DCSMAGetAssetAttributes(result);
    result = (const __CFDictionary *)CFDictionaryGetValue(v5, CFSTR("DictionaryIdentifier"));
    if (!result)
    {
      v3 = CFSTR("DictionaryPackageName");
      v4 = v5;
      return (const __CFDictionary *)CFDictionaryGetValue(v4, v3);
    }
  }
  return result;
}

const __CFDictionary *DCSDictionary::name(DCSDictionary *this)
{
  uint64_t v1;
  const __CFDictionary *result;
  const __CFDictionary *v3;

  v1 = *((_QWORD *)this + 1);
  if (v1)
    return (const __CFDictionary *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v1 + 40))(*((_QWORD *)this + 1));
  if (*((_QWORD *)this + 5))
    return (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), CFSTR("name"));
  result = (const __CFDictionary *)*((_QWORD *)this + 12);
  if (result)
  {
    v3 = (const __CFDictionary *)DCSMAGetAssetAttributes(result);
    return (const __CFDictionary *)CFDictionaryGetValue(v3, CFSTR("DictionaryPackageDisplayName"));
  }
  return result;
}

const __CFString *DCSDictionary::shortName(DCSDictionary *this)
{
  const __CFDictionary *v2;
  CFIndex Count;
  DCSEnvironment *v4;
  CFStringRef CurrentAppLocalization;
  uint64_t v6;
  const __CFString *v7;
  uint64_t v9;
  const __CFDictionary *v10;
  const __CFString *Value;
  const __CFString *v12;
  const void *v14;
  const __CFString *v16;
  const void *v19;
  const __CFString *v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  CFMutableDictionaryRef MutableCopy;
  const __CFDictionary *v24;
  __CFDictionary *v25;
  const __CFString *v26;
  const __CFDictionary *v27;
  __CFDictionary *v28;
  __CFDictionary *DictionaryCacheInfo;
  CFDictionaryRef *v30;
  const __CFString *v31;
  uint64_t v32;
  DCSBaseDictionary *v33;
  uint64_t v34;

  v2 = *(const __CFDictionary **)(SyncSingleton<DCSEnvironment>::instance() + 192);
  Count = CFDictionaryGetCount(v2);
  v4 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  CurrentAppLocalization = DCSEnvironment::getCurrentAppLocalization(v4);
  v6 = *((_QWORD *)this + 1);
  if (!v6)
  {
    v10 = (const __CFDictionary *)*((_QWORD *)this + 5);
    if (!v10)
      return 0;
    Value = (const __CFString *)CFDictionaryGetValue(v10, CFSTR("primary language"));
    v12 = Value;
    if (Count > 1 || Value == 0)
    {
      if (!Value)
      {
        v14 = 0;
LABEL_27:
        v19 = (const void *)*MEMORY[0x1E0C9AE50];
        if (v14 == (const void *)*MEMORY[0x1E0C9AE50])
          v20 = CFSTR("localized detailed names");
        else
          v20 = CFSTR("localized names");
        v21 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), v20);
        if (!v21)
          goto LABEL_33;
        v16 = (const __CFString *)CFDictionaryGetValue(v21, CurrentAppLocalization);
        if (v16)
          goto LABEL_32;
        if (DCSDictionary::createDictionaryObj(this))
        {
          if (!*((_BYTE *)this + 33))
          {
            MutableCopy = CFDictionaryCreateMutableCopy(0, 0, *((CFDictionaryRef *)this + 5));
            CFRelease(*((CFTypeRef *)this + 5));
            *((_QWORD *)this + 5) = MutableCopy;
            *((_BYTE *)this + 33) = 1;
          }
          v16 = (const __CFString *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 48))(*((_QWORD *)this + 1));
          v24 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), CFSTR("localized names"));
          v25 = CFDictionaryCreateMutableCopy(0, 0, v24);
          CFDictionarySetValue(v25, CurrentAppLocalization, v16);
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 5), CFSTR("localized names"), v25);
          CFRelease(v25);
          v26 = (const __CFString *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 56))(*((_QWORD *)this + 1));
          v27 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), CFSTR("localized detailed names"));
          if (v27)
          {
            if (v26)
            {
              v28 = CFDictionaryCreateMutableCopy(0, 0, v27);
              CFDictionarySetValue(v28, CurrentAppLocalization, v26);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 5), CFSTR("localized detailed names"), v28);
              CFRelease(v28);
              if (v14 == v19)
                v16 = v26;
            }
          }
          DictionaryCacheInfo = (__CFDictionary *)*((_QWORD *)this + 5);
          if (*((_BYTE *)this + 32))
          {
            v30 = (CFDictionaryRef *)*((_QWORD *)this + 3);
            if (v30)
            {
              v31 = (const __CFString *)DCSDictionary::identifier(this);
              DCSDictionary::enrollSubDictionaryCache(v30, v31);
              v32 = *((_QWORD *)this + 3);
              v33 = *(DCSBaseDictionary **)(v32 + 8);
              if (v33)
              {
                DictionaryCacheInfo = *(__CFDictionary **)(v32 + 40);
                if (!DictionaryCacheInfo)
                {
                  DictionaryCacheInfo = _CreateDictionaryCacheInfo(v33);
                  *(_QWORD *)(v32 + 40) = DictionaryCacheInfo;
                  *(_BYTE *)(v32 + 33) = 1;
                }
              }
              else
              {
                DictionaryCacheInfo = 0;
              }
            }
          }
          v34 = SyncSingleton<DCSEnvironment>::instance();
          DCSEnvironment::updateDictionaryCacheInfo(v34, *((const __CFURL **)this + 6), DictionaryCacheInfo);
          if (!v16)
            goto LABEL_33;
LABEL_32:
          if (CFStringGetLength(v16))
            return v16;
LABEL_33:
          v22 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), CFSTR("localized names"));
          return (const __CFString *)CFDictionaryGetValue(v22, CurrentAppLocalization);
        }
        return 0;
      }
    }
    else if (CompareLanguageCode(Value, CurrentAppLocalization, 0))
    {
      v16 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), CFSTR("native name"));
      if (!v16)
        goto LABEL_33;
      goto LABEL_32;
    }
    v14 = CFDictionaryGetValue(v2, v12);
    goto LABEL_27;
  }
  v7 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 88))(v6);
  if (Count > 1 || v7 == 0)
  {
    if (!v7 || CFDictionaryGetValue(v2, v7) != (const void *)*MEMORY[0x1E0C9AE50])
      return (const __CFString *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 48))(*((_QWORD *)this + 1));
    v9 = 7;
  }
  else
  {
    if (!CompareLanguageCode(v7, CurrentAppLocalization, 0))
      return (const __CFString *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 48))(*((_QWORD *)this + 1));
    v16 = (const __CFString *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 64))(*((_QWORD *)this + 1));
    if (v16)
      return v16;
    v9 = 9;
  }
  v16 = (const __CFString *)(*(uint64_t (**)(void))(**((_QWORD **)this + 1) + 8 * v9))();
  if (!v16)
    return (const __CFString *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 48))(*((_QWORD *)this + 1));
  return v16;
}

void DCSDictionary::enrollSubDictionaryCache(CFDictionaryRef *this, const __CFString *a2)
{
  CFIndex v3;
  CFIndex v4;
  _QWORD *ValueAtIndex;
  uint64_t v6;
  DCSBaseDictionary *v7;
  __CFDictionary *DictionaryCacheInfo;
  const __CFArray *Value;
  __CFArray *MutableCopy;
  __CFDictionary *v11;

  v3 = DCSDictionary::indexOfSubDictionaryIdentifier((DCSDictionary *)this, a2);
  if (v3 != -1)
  {
    v4 = v3;
    ValueAtIndex = CFArrayGetValueAtIndex(this[7], v3);
    if (ValueAtIndex)
      v6 = ValueAtIndex[2];
    else
      v6 = 0;
    v7 = *(DCSBaseDictionary **)(v6 + 8);
    if (v7)
    {
      DictionaryCacheInfo = *(__CFDictionary **)(v6 + 40);
      if (!DictionaryCacheInfo)
      {
        DictionaryCacheInfo = _CreateDictionaryCacheInfo(v7);
        *(_QWORD *)(v6 + 40) = DictionaryCacheInfo;
        *(_BYTE *)(v6 + 33) = 1;
      }
    }
    else
    {
      DictionaryCacheInfo = 0;
    }
    Value = (const __CFArray *)CFDictionaryGetValue(this[5], CFSTR("sub dictionaries"));
    MutableCopy = CFArrayCreateMutableCopy(0, 0, Value);
    CFArraySetValueAtIndex(MutableCopy, v4, DictionaryCacheInfo);
    v11 = this[5];
    if (!*((_BYTE *)this + 33))
    {
      v11 = CFDictionaryCreateMutableCopy(0, 0, this[5]);
      CFRelease(this[5]);
      this[5] = v11;
      *((_BYTE *)this + 33) = 1;
    }
    CFDictionarySetValue(v11, CFSTR("sub dictionaries"), MutableCopy);
    CFRelease(MutableCopy);
  }
}

const __CFDictionary *DCSDictionary::version(DCSDictionary *this)
{
  uint64_t v2;
  const __CFDictionary *result;

  v2 = *((_QWORD *)this + 1);
  if (v2)
    return (const __CFDictionary *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 80))(v2);
  result = (const __CFDictionary *)*((_QWORD *)this + 5);
  if (result)
    return (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("version"));
  return result;
}

const __CFString *DCSDictionary::primaryLanguage(DCSDictionary *this)
{
  uint64_t v1;
  const __CFString *result;

  v1 = *((_QWORD *)this + 1);
  if (v1)
    return (const __CFString *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v1 + 88))(*((_QWORD *)this + 1));
  if (*((_QWORD *)this + 5))
    return (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), CFSTR("primary language"));
  result = (const __CFString *)*((_QWORD *)this + 12);
  if (result)
    return DCSMAGetAssetLanguage((const __CFDictionary *)result);
  return result;
}

uint64_t DCSDictionary::subDictionaries(DCSDictionary *this)
{
  uint64_t v2;
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex v5;
  CFIndex v6;
  const __CFDictionary *v7;
  const __CFArray *Value;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex v11;
  DCSBaseDictionary *v12;
  const __CFString *v13;
  CFIndex v14;
  CFIndex v15;
  _QWORD *v16;
  DCSDictionary *v17;
  const void *v18;
  CFIndex v19;
  const __CFDictionary *ValueAtIndex;
  const __CFString *v21;
  CFIndex v22;
  CFIndex v23;
  _QWORD *v24;
  DCSDictionary *v25;
  const void *v26;
  const __CFArray *v27;
  CFIndex v28;

  if (*((_BYTE *)this + 64))
    return *((_QWORD *)this + 7);
  v2 = *((_QWORD *)this + 1);
  if (!v2)
  {
    v7 = (const __CFDictionary *)*((_QWORD *)this + 5);
    if (v7)
    {
      Value = (const __CFArray *)CFDictionaryGetValue(v7, CFSTR("sub dictionaries"));
      if (Value)
      {
        v9 = Value;
        Count = CFArrayGetCount(Value);
        v6 = Count;
        if (*((_QWORD *)this + 7) || Count < 1)
        {
          if (Count < 1)
            goto LABEL_34;
        }
        else
        {
          *((_QWORD *)this + 7) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
        }
        v19 = 0;
        do
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, v19);
          v21 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), CFSTR("identifier"));
          v22 = DCSDictionary::indexOfSubDictionaryIdentifier(this, v21);
          if (v22 == -1)
          {
            v25 = (DCSDictionary *)operator new();
            DCSDictionary::DCSDictionary(v25, (CFURLRef *)this, ValueAtIndex);
            v26 = *(const void **)v25;
            CFArrayInsertValueAtIndex(*((CFMutableArrayRef *)this + 7), v19, *(const void **)v25);
            CFRelease(v26);
          }
          else
          {
            v23 = v22;
            v24 = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 7), v22);
            if (v24)
              v25 = (DCSDictionary *)v24[2];
            else
              v25 = 0;
            if (v19 != v23)
              CFArrayExchangeValuesAtIndices(*((CFMutableArrayRef *)this + 7), v23, v19);
          }
          *((_QWORD *)v25 + 9) = v19++;
        }
        while (v6 != v19);
        goto LABEL_34;
      }
    }
    goto LABEL_12;
  }
  v3 = (const __CFArray *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 144))(v2);
  if (!v3)
  {
LABEL_12:
    v6 = 0;
    goto LABEL_34;
  }
  v4 = v3;
  v5 = CFArrayGetCount(v3);
  v6 = v5;
  if (!*((_QWORD *)this + 7) && v5 >= 1)
  {
    *((_QWORD *)this + 7) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    goto LABEL_14;
  }
  if (v5 >= 1)
  {
LABEL_14:
    v11 = 0;
    do
    {
      v12 = (DCSBaseDictionary *)CFArrayGetValueAtIndex(v4, v11);
      v13 = (const __CFString *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)v12 + 24))(v12);
      v14 = DCSDictionary::indexOfSubDictionaryIdentifier(this, v13);
      if (v14 == -1)
      {
        v17 = (DCSDictionary *)operator new();
        DCSDictionary::DCSDictionary(v17, (CFURLRef *)this, v12);
        v18 = *(const void **)v17;
        CFArrayInsertValueAtIndex(*((CFMutableArrayRef *)this + 7), v11, *(const void **)v17);
        CFRelease(v18);
      }
      else
      {
        v15 = v14;
        v16 = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 7), v14);
        if (v16)
          v17 = (DCSDictionary *)v16[2];
        else
          v17 = 0;
        *((_QWORD *)v12 + 1) = v17;
        *((_BYTE *)v12 + 16) = 1;
        if (v11 != v15)
          CFArrayExchangeValuesAtIndices(*((CFMutableArrayRef *)this + 7), v15, v11);
      }
      *((_QWORD *)v17 + 9) = v11++;
    }
    while (v6 != v11);
  }
LABEL_34:
  v27 = (const __CFArray *)*((_QWORD *)this + 7);
  if (v27)
    v28 = CFArrayGetCount(v27);
  else
    v28 = 0;
  while (v28 > v6)
    CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 7), --v28);
  *((_BYTE *)this + 64) = 1;
  return *((_QWORD *)this + 7);
}

void sub_1CDF6AFBC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x1060C40D262D689);
  _Unwind_Resume(a1);
}

CFIndex DCSDictionary::indexOfSubDictionaryIdentifier(DCSDictionary *this, const __CFString *a2)
{
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  DCSDictionary *ValueAtIndex;
  const __CFString *v9;

  v3 = (const __CFArray *)*((_QWORD *)this + 7);
  if (!v3)
    return -1;
  Count = CFArrayGetCount(v3);
  if (Count < 1)
    return -1;
  v6 = Count;
  v7 = 0;
  while (1)
  {
    ValueAtIndex = (DCSDictionary *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 7), v7);
    if (ValueAtIndex)
      ValueAtIndex = (DCSDictionary *)*((_QWORD *)ValueAtIndex + 2);
    v9 = (const __CFString *)DCSDictionary::identifier(ValueAtIndex);
    if (CFStringCompare(v9, a2, 0) == kCFCompareEqualTo)
      break;
    if (v6 == ++v7)
      return -1;
  }
  return v7;
}

uint64_t DCSDictionary::parentDictionary(DCSDictionary *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 3);
  if (v1)
    return *(_QWORD *)v1;
  else
    return 0;
}

uint64_t DCSDictionary::validDictionary(DCSDictionary *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 1);
  if (v1)
    return (*(uint64_t (**)(_QWORD))(*(_QWORD *)v1 + 200))(*((_QWORD *)this + 1));
  if (*((_QWORD *)this + 5))
    return 1;
  return *((_QWORD *)this + 12) != 0;
}

void DCSDictionary::setCustomHTMLHeader(DCSDictionary *this, const __CFString *key, uint64_t a3, int a4, const __CFString *a5)
{
  const __CFDictionary *Mutable;
  void *Value;
  CFNumberRef v11;
  void **v12;
  CFDictionaryRef v13;
  uint64_t valuePtr;
  void *values[2];
  void *keys[2];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  valuePtr = a3;
  Mutable = (const __CFDictionary *)*((_QWORD *)this + 10);
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *((_QWORD *)this + 10) = Mutable;
  }
  Value = (void *)CFDictionaryGetValue(Mutable, key);
  if (!Value)
  {
    Value = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 10), key, Value);
    CFRelease(Value);
  }
  v11 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
  if (a5)
  {
    v12 = (void **)MEMORY[0x1E0C9AE50];
    *(_OWORD *)keys = xmmword_1E8B564C8;
    if (!a4)
      v12 = (void **)MEMORY[0x1E0C9AE40];
    values[0] = *v12;
    values[1] = (void *)a5;
    v13 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue((CFMutableDictionaryRef)Value, v11, v13);
  }
  else
  {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)Value, v11);
  }
  CFRelease(v11);
}

DCSDictionary *DCSDictionary::customHTMLHeader(DCSDictionary *this, const __CFString *a2, uint64_t a3, BOOL *a4)
{
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  CFNumberRef v10;
  const __CFDictionary *v11;
  const __CFBoolean *Value;
  DCSDictionary *result;
  uint64_t valuePtr;

  valuePtr = a3;
  v7 = (const __CFDictionary *)*((_QWORD *)this + 10);
  if (v7
    && (v8 = (const __CFDictionary *)CFDictionaryGetValue(v7, a2)) != 0
    && (v9 = v8,
        v10 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr),
        v11 = (const __CFDictionary *)CFDictionaryGetValue(v9, v10),
        CFRelease(v10),
        v11))
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(v11, CFSTR("append"));
    *a4 = CFBooleanGetValue(Value) != 0;
    return (DCSDictionary *)CFDictionaryGetValue(v11, CFSTR("header"));
  }
  else if (*((_BYTE *)this + 32))
  {
    result = (DCSDictionary *)*((_QWORD *)this + 3);
    if (result)
      return (DCSDictionary *)DCSDictionary::customHTMLHeader(result, a2, valuePtr, a4);
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t DCSDictionary::baseURL(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 1) + 352))(*((_QWORD *)this + 1));
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1));
  }
  return result;
}

const __CFArray *DCSDictionary::languages(CFDictionaryRef *this)
{
  const __CFArray *v2;
  BOOL v4;

  if (this[12])
  {
    v4 = 0;
    v2 = DCSDictionary::checkAssetLanguageInfo(this, &v4);
    if (!v4)
      return v2;
  }
  else
  {
    v2 = 0;
  }
  if (DCSDictionary::createDictionaryObj((DCSDictionary *)this))
    return (const __CFArray *)(*(uint64_t (**)(CFDictionaryRef))(*(_QWORD *)this[1] + 96))(this[1]);
  return v2;
}

const __CFArray *DCSDictionary::checkAssetLanguageInfo(CFDictionaryRef *this, BOOL *a2)
{
  const __CFArray *Value;
  const __CFArray *Mutable;
  const __CFString *v6;
  const __CFDictionary *v7;
  const __CFArray *v8;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex v12;
  const CFDictionaryValueCallBacks *v13;
  __CFDictionary *v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFDictionary *ValueAtIndex;
  const __CFString *v18;
  DCSDictionary *v20;
  pthread_mutex_t *v21;
  BOOL *v22;

  Value = (const __CFArray *)CFDictionaryGetValue(this[12], CFSTR("Languages"));
  if (Value)
  {
    Mutable = Value;
    *a2 = 0;
LABEL_11:
    if (CFArrayGetCount(Mutable) >= 1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, 0);
      v18 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("DCSDictionaryIndexLanguage"));
      if (v18)
      {
        if (CFStringCompare(v18, CFSTR("*"), 0) == kCFCompareEqualTo)
          *a2 = 1;
      }
    }
    return Mutable;
  }
  v21 = (pthread_mutex_t *)(this + 13);
  v22 = a2;
  pthread_mutex_lock((pthread_mutex_t *)(this + 13));
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v6 = DCSMAGetAssetLanguage(this[12]);
  v20 = (DCSDictionary *)this;
  v7 = (const __CFDictionary *)DCSMAGetAssetAttributes(this[12]);
  v8 = (const __CFArray *)CFDictionaryGetValue(v7, CFSTR("IndexLanguages"));
  if (v8)
  {
    v9 = v8;
    Count = CFArrayGetCount(v8);
    if (Count >= 1)
    {
      v11 = Count;
      v12 = 0;
      v13 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
      do
      {
        v14 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], v13);
        v15 = (const __CFString *)CFArrayGetValueAtIndex(v9, v12);
        CFDictionarySetValue(v14, CFSTR("DCSDictionaryIndexLanguage"), v15);
        if (v6)
          v16 = v6;
        else
          v16 = v15;
        CFDictionarySetValue(v14, CFSTR("DCSDictionaryDescriptionLanguage"), v16);
        CFArrayAppendValue(Mutable, v14);
        CFRelease(v14);
        ++v12;
      }
      while (v11 != v12);
    }
  }
  CFDictionarySetValue(*((CFMutableDictionaryRef *)v20 + 12), CFSTR("Languages"), Mutable);
  CFRelease(Mutable);
  pthread_mutex_unlock(v21);
  a2 = v22;
  *v22 = 0;
  if (Mutable)
    goto LABEL_11;
  return Mutable;
}

uint64_t DCSDictionary::styleSheetURLs(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 104))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::styleSheetContents(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 112))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::privateFontURLs(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 120))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::XSLTData(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 128))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::elementXPaths(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 136))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::preferenceHTML(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 160))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::preference(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 168))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::defaultPreference(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 176))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::setPreference(DCSDictionary *this, const __CFDictionary *a2)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD, const __CFDictionary *))(**((_QWORD **)this + 1) + 184))(*((_QWORD *)this + 1), a2);
  return result;
}

uint64_t DCSDictionary::migrateOldPreference(DCSDictionary *this, const __CFDictionary *a2)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD, const __CFDictionary *))(**((_QWORD **)this + 1) + 192))(*((_QWORD *)this + 1), a2);
  return result;
}

uint64_t DCSDictionary::isLocalizableDictionary(CFDictionaryRef *this)
{
  uint64_t result;
  BOOL v3;

  if (this[12])
  {
    v3 = 0;
    DCSDictionary::checkAssetLanguageInfo(this, &v3);
    return v3;
  }
  else
  {
    result = DCSDictionary::createDictionaryObj((DCSDictionary *)this);
    if (result)
      return (*(uint64_t (**)(CFDictionaryRef))(*(_QWORD *)this[1] + 216))(this[1]);
  }
  return result;
}

uint64_t DCSDictionary::isSortableDictionary(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::isAppearanceAwareDictionary(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 232))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::isLanguageDictionary(DCSDictionary *this)
{
  const __CFDictionary *v2;
  uint64_t result;

  v2 = (const __CFDictionary *)*((_QWORD *)this + 12);
  if (v2)
    return DCSMAIsLanguageDictionaryAsset(v2) != 0;
  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 240))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::previewMarkupVersion(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 248))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::primaryLocale(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 256))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::createSessionInfo(DCSDictionary *this, DCSSearchSession *a2, const __CFString *a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD, DCSSearchSession *, const __CFString *, uint64_t, uint64_t))(**((_QWORD **)this + 1) + 264))(*((_QWORD *)this + 1), a2, a3, a4, a5);
  return result;
}

uint64_t DCSDictionary::releaseSessionInfo(DCSDictionary *this, void *a2)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)this + 1) + 272))(*((_QWORD *)this + 1), a2);
  return result;
}

uint64_t DCSDictionary::scheduleSession(DCSDictionary *this, void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD, void *, __CFRunLoop *, const __CFString *))(**((_QWORD **)this + 1) + 280))(*((_QWORD *)this + 1), a2, a3, a4);
  return result;
}

uint64_t DCSDictionary::unscheduleSession(DCSDictionary *this, void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD, void *, __CFRunLoop *, const __CFString *))(**((_QWORD **)this + 1) + 288))(*((_QWORD *)this + 1), a2, a3, a4);
  return result;
}

uint64_t DCSDictionary::searchByString(DCSDictionary *this, const __CFString *a2, uint64_t a3, uint64_t a4)
{
  if (DCSDictionary::createDictionaryObj(this))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 1) + 352))(*((_QWORD *)this + 1));
    return (*(uint64_t (**)(_QWORD, const __CFString *, uint64_t, uint64_t))(**((_QWORD **)this + 1) + 296))(*((_QWORD *)this + 1), a2, a3, a4);
  }
  else
  {
    if (DCSMAPrepareMobileAssetQuery()
      && !*((_QWORD *)this + 6)
      && *((_QWORD *)this + 12)
      && DCSMAPrepareMobileAssetQuery() == 1)
    {
      DCSDictionary::startGlobalDictionariesEnvironment(*((DCSDictionary **)this + 12));
    }
    return 0;
  }
}

uint64_t DCSDictionary::searchByReference(DCSDictionary *this, const __CFString *a2)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 1) + 352))(*((_QWORD *)this + 1));
    return (*(uint64_t (**)(_QWORD, const __CFString *))(**((_QWORD **)this + 1) + 304))(*((_QWORD *)this + 1), a2);
  }
  return result;
}

uint64_t DCSDictionary::copyData(DCSDictionary *this, DCSRecord *a2, uint64_t a3)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD, DCSRecord *, uint64_t))(**((_QWORD **)this + 1) + 312))(*((_QWORD *)this + 1), a2, a3);
  return result;
}

uint64_t DCSDictionary::copyDataURL(DCSDictionary *this, DCSRecord *a2, uint64_t a3)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD, DCSRecord *, uint64_t))(**((_QWORD **)this + 1) + 320))(*((_QWORD *)this + 1), a2, a3);
  return result;
}

uint64_t DCSDictionary::hasRecord(DCSDictionary *this, const __CFString *a2, uint64_t a3, unsigned __int8 *a4)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD, const __CFString *, uint64_t, unsigned __int8 *))(**((_QWORD **)this + 1)
                                                                                             + 328))(*((_QWORD *)this + 1), a2, a3, a4);
  return result;
}

uint64_t DCSDictionary::isSupportedDefinitionStyle(DCSDictionary *this, uint64_t a2)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 1) + 336))(*((_QWORD *)this + 1), a2);
  return result;
}

uint64_t DCSDictionary::purgeInactiveData(DCSDictionary *this)
{
  uint64_t result;

  result = DCSDictionary::createDictionaryObj(this);
  if (result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 344))(*((_QWORD *)this + 1));
  return result;
}

uint64_t DCSDictionary::dictionaryFlag(DCSDictionary *this)
{
  const __CFString *v2;
  const __CFString *v3;
  uint64_t v4;

  if (*((_QWORD *)this + 11) == -1)
  {
    *((_QWORD *)this + 11) = 0;
    v2 = DCSDictionary::primaryLanguage(this);
    if (v2)
    {
      v3 = v2;
      if (!CFStringHasPrefix(v2, CFSTR("zh")))
      {
        if (CFStringHasPrefix(v3, CFSTR("ko")))
        {
          v4 = 48;
          goto LABEL_7;
        }
        if (!CFStringHasPrefix(v3, CFSTR("hi")))
          return *((_QWORD *)this + 11);
      }
      v4 = 14;
LABEL_7:
      *((_QWORD *)this + 11) = v4;
    }
  }
  return *((_QWORD *)this + 11);
}

uint64_t DCSDictionary::languageDirectionOfFoundRecord(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 360))(*(_QWORD *)(a1 + 8));
}

uint64_t DCSDictionary::resetSubDictionaries(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  const __CFURL *v3;
  DCSBaseDictionary *v4;
  __CFDictionary *DictionaryCacheInfo;

  if (!*(_BYTE *)(this + 65))
  {
    v1 = this;
    *(_BYTE *)(this + 65) = 1;
    if (!*(_QWORD *)(this + 40) || (this = DCSDictionary::updateSubDictionaryInfo((DCSDictionary *)this), (_DWORD)this))
    {
      v2 = SyncSingleton<DCSEnvironment>::instance();
      v3 = *(const __CFURL **)(v1 + 48);
      v4 = *(DCSBaseDictionary **)(v1 + 8);
      if (v4)
      {
        DictionaryCacheInfo = *(__CFDictionary **)(v1 + 40);
        if (!DictionaryCacheInfo)
        {
          DictionaryCacheInfo = _CreateDictionaryCacheInfo(v4);
          *(_QWORD *)(v1 + 40) = DictionaryCacheInfo;
          *(_BYTE *)(v1 + 33) = 1;
        }
      }
      else
      {
        DictionaryCacheInfo = 0;
      }
      DCSEnvironment::updateDictionaryCacheInfo(v2, v3, DictionaryCacheInfo);
      *(_BYTE *)(v1 + 64) = 0;
      this = DCSDictionary::subDictionaries((DCSDictionary *)v1);
    }
    *(_BYTE *)(v1 + 65) = 0;
  }
  return this;
}

uint64_t DCSDictionary::updateSubDictionaryInfo(DCSDictionary *this)
{
  uint64_t v2;
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex Count;
  uint64_t v6;
  __CFArray *Mutable;
  char v8;
  CFIndex i;
  DCSBaseDictionary *ValueAtIndex;
  __CFDictionary *DictionaryCacheInfo;
  const void *Value;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v14;
  char v15;
  char v16;
  char v17;

  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    v3 = (const __CFArray *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 144))(v2);
    if (v3 && (v4 = v3, (Count = CFArrayGetCount(v3)) != 0))
    {
      v6 = Count;
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      if (v6 >= 1)
      {
        v8 = 0;
        for (i = 0; i != v6; ++i)
        {
          ValueAtIndex = (DCSBaseDictionary *)CFArrayGetValueAtIndex(v4, i);
          v8 |= *((_QWORD *)ValueAtIndex + 1) == 0;
          DictionaryCacheInfo = _CreateDictionaryCacheInfo(ValueAtIndex);
          CFArrayAppendValue(Mutable, DictionaryCacheInfo);
          CFRelease(DictionaryCacheInfo);
        }
LABEL_10:
        Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), CFSTR("sub dictionaries"));
        if ((Mutable != 0) != (Value != 0))
        {
LABEL_11:
          if (!*((_BYTE *)this + 33))
          {
            MutableCopy = CFDictionaryCreateMutableCopy(0, 0, *((CFDictionaryRef *)this + 5));
            CFRelease(*((CFTypeRef *)this + 5));
            *((_QWORD *)this + 5) = MutableCopy;
            *((_BYTE *)this + 33) = 1;
          }
          v14 = (__CFDictionary *)*((_QWORD *)this + 5);
          if (!Mutable)
          {
            CFDictionaryRemoveValue(v14, CFSTR("sub dictionaries"));
            v17 = 1;
            goto LABEL_23;
          }
          CFDictionarySetValue(v14, CFSTR("sub dictionaries"), Mutable);
          v15 = 1;
          goto LABEL_21;
        }
        if (Mutable && Value)
        {
          if (!CFEqual(Value, Mutable))
            goto LABEL_11;
          v15 = 0;
        }
        else
        {
          v15 = 0;
          v17 = 0;
          if (!Mutable)
          {
LABEL_23:
            v16 = v17 | v8;
            return v16 & 1;
          }
        }
LABEL_21:
        CFRelease(Mutable);
        v17 = v15;
        goto LABEL_23;
      }
    }
    else
    {
      Mutable = 0;
    }
    v8 = 0;
    goto LABEL_10;
  }
  v16 = 0;
  return v16 & 1;
}

__CFDictionary *_CreateDictionaryCacheInfo(DCSBaseDictionary *a1)
{
  const CFDictionaryKeyCallBacks *v2;
  const CFDictionaryValueCallBacks *v3;
  __CFDictionary *Mutable;
  DCSEnvironment *v5;
  CFStringRef CurrentAppLocalization;
  CFDictionaryRef v7;
  CFDictionaryRef v8;
  const __CFString *v9;
  uint64_t v10;
  const void *v11;
  BOOL v12;
  int v13;
  const void **v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const __CFArray *v18;
  const __CFArray *v19;
  CFIndex Count;
  uint64_t v21;
  __CFArray *v22;
  CFIndex i;
  DCSBaseDictionary *ValueAtIndex;
  const void *DictionaryCacheInfo;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  v2 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v3 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v5 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  CurrentAppLocalization = DCSEnvironment::getCurrentAppLocalization(v5);
  keys[0] = (void *)CurrentAppLocalization;
  values = (void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)a1 + 48))(a1);
  v7 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, v2, v3);
  CFDictionaryAddValue(Mutable, CFSTR("localized names"), v7);
  CFRelease(v7);
  values = (void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)a1 + 56))(a1);
  if (values)
  {
    v8 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionaryAddValue(Mutable, CFSTR("localized detailed names"), v8);
    CFRelease(v8);
  }
  v9 = (const __CFString *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)a1 + 88))(a1);
  if (v9)
    CFDictionaryAddValue(Mutable, CFSTR("primary language"), v9);
  v10 = (*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)a1 + 64))(a1);
  v11 = (const void *)v10;
  if (v9)
    v12 = v10 == 0;
  else
    v12 = 0;
  if (v12)
  {
    if (!CompareLanguageCode(v9, CurrentAppLocalization, 0))
      goto LABEL_14;
    v11 = (const void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)a1 + 72))(a1);
  }
  if (v11)
    CFDictionaryAddValue(Mutable, CFSTR("native name"), v11);
LABEL_14:
  v13 = (*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)a1 + 208))(a1);
  v14 = (const void **)MEMORY[0x1E0C9AE50];
  if (!v13)
    v14 = (const void **)MEMORY[0x1E0C9AE40];
  CFDictionaryAddValue(Mutable, CFSTR("network"), *v14);
  v15 = (const void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)a1 + 24))(a1);
  CFDictionaryAddValue(Mutable, CFSTR("identifier"), v15);
  v16 = (const void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)a1 + 40))(a1);
  CFDictionaryAddValue(Mutable, CFSTR("name"), v16);
  v17 = (const void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)a1 + 80))(a1);
  CFDictionaryAddValue(Mutable, CFSTR("version"), v17);
  v18 = (const __CFArray *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)a1 + 144))(a1);
  if (v18)
  {
    v19 = v18;
    Count = CFArrayGetCount(v18);
    if (Count)
    {
      v21 = Count;
      v22 = CFArrayCreateMutable(0, Count, MEMORY[0x1E0C9B378]);
      if (v21 >= 1)
      {
        for (i = 0; i != v21; ++i)
        {
          ValueAtIndex = (DCSBaseDictionary *)CFArrayGetValueAtIndex(v19, i);
          DictionaryCacheInfo = (const void *)_CreateDictionaryCacheInfo(ValueAtIndex);
          CFArrayAppendValue(v22, DictionaryCacheInfo);
          CFRelease(DictionaryCacheInfo);
        }
      }
      if (v22)
      {
        CFDictionarySetValue(Mutable, CFSTR("sub dictionaries"), v22);
        CFRelease(v22);
      }
    }
  }
  return Mutable;
}

const void *DCSDictionaryManager::dictionary(DCSDictionaryManager *this, const __CFURL *a2, __CFDictionary *a3)
{
  const __CFDictionary *v5;
  const void *Value;
  CFStringRef v7;
  CFStringRef v8;
  const void *v9;
  pthread_rwlock_t *v10;
  DCSDictionary *v12;
  uint64_t v13;
  DCSEnvironment *v14;
  const __CFArray *ActiveDictionaryInfos;
  const __CFArray *v16;
  CFIndex Count;
  CFIndex v18;
  const __CFDictionary *ValueAtIndex;
  const void *v20;

  if ((_initedCachedDictionaries & 1) == 0)
    pthread_once(&DCSDictionaryManager::dictionary(__CFURL const*,__CFDictionary *,BOOL)::once_control, (void (*)(void))_InitializeCachedDictionaries);
  if (a3)
  {
    v5 = (const __CFDictionary *)DCSMAGetAssetAttributes(a3);
    Value = CFDictionaryGetValue(v5, CFSTR("DictionaryIdentifier"));
    if (!Value)
      Value = CFDictionaryGetValue(v5, CFSTR("DictionaryPackageName"));
    v7 = CFStringCreateWithFormat(0, 0, CFSTR("asset:/%@"), Value);
  }
  else
  {
    if (!a2)
      return 0;
    v7 = CopyFileObjectIdentifierAtURL(a2);
  }
  v8 = v7;
  if (v7)
  {
    pthread_rwlock_rdlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
    v9 = CFDictionaryGetValue(*(CFDictionaryRef *)(_cachedDictionaries + 8), v8);
    pthread_rwlock_unlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
    if (v9)
    {
      CFRetain(v9);
LABEL_15:
      CFRelease(v8);
      return v9;
    }
    v10 = (pthread_rwlock_t *)(_cachedDictionaries + 16);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
    v9 = CFDictionaryGetValue(*(CFDictionaryRef *)(_cachedDictionaries + 8), v8);
    if (v9)
    {
LABEL_14:
      pthread_rwlock_unlock(v10);
      goto LABEL_15;
    }
    v12 = (DCSDictionary *)operator new();
    DCSDictionary::DCSDictionary(v12, a2, a3);
    v13 = *((_QWORD *)v12 + 1);
    if (v13)
    {
      if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v13 + 200))(v13))
      {
LABEL_19:
        DCSDictionary::~DCSDictionary(v12);
        MEMORY[0x1D17BC79C](v12, 0x1060C40D262D689);
        v9 = 0;
        goto LABEL_14;
      }
    }
    else if (!*((_QWORD *)v12 + 5) && !*((_QWORD *)v12 + 12))
    {
      goto LABEL_19;
    }
    v9 = *(const void **)v12;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(_cachedDictionaries + 8), v8, *(const void **)v12);
    if (a2)
    {
      v14 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
      ActiveDictionaryInfos = (const __CFArray *)DCSEnvironment::getActiveDictionaryInfos(v14);
      v16 = ActiveDictionaryInfos;
      if (ActiveDictionaryInfos)
      {
        Count = CFArrayGetCount(ActiveDictionaryInfos);
        if (Count >= 1)
        {
          v18 = 0;
          while (1)
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v16, v18);
            v20 = CFDictionaryGetValue(ValueAtIndex, CFSTR("URL"));
            if (v20)
            {
              if (CFEqual(v20, a2))
                break;
            }
            if (Count == ++v18)
              goto LABEL_14;
          }
          *((_QWORD *)v12 + 9) = v18;
        }
      }
    }
    goto LABEL_14;
  }
  return 0;
}

void sub_1CDF6C608(_Unwind_Exception *a1)
{
  pthread_rwlock_t *v1;

  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t _InitializeCachedDictionaries(void)
{
  uint64_t v0;
  CFMutableDictionaryRef Mutable;
  uint64_t result;

  v0 = operator new();
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], 0);
  *(_QWORD *)v0 = &unk_1E8B56538;
  *(_QWORD *)(v0 + 8) = Mutable;
  result = pthread_rwlock_init((pthread_rwlock_t *)(v0 + 16), 0);
  *(_QWORD *)v0 = &unk_1E8B564E8;
  _cachedDictionaries = v0;
  _initedCachedDictionaries = 1;
  return result;
}

{
  uint64_t v0;
  CFMutableDictionaryRef Mutable;
  uint64_t result;

  v0 = operator new();
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], 0);
  *(_QWORD *)v0 = &unk_1E8B56538;
  *(_QWORD *)(v0 + 8) = Mutable;
  result = pthread_rwlock_init((pthread_rwlock_t *)(v0 + 16), 0);
  *(_QWORD *)v0 = &unk_1E8B564E8;
  _cachedDictionaries = v0;
  _initedCachedDictionaries = 1;
  return result;
}

void sub_1CDF6C6E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void DCSDictionaryManager::remove(DCSDictionaryManager *this, const __DCSDictionary *a2)
{
  uint64_t v3;
  const __CFURL *v4;
  void *v5;
  CFTypeRef v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const void *Value;
  const void *v10;

  if (!a2)
    return;
  pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  v3 = *((_QWORD *)a2 + 2);
  v4 = *(const __CFURL **)(v3 + 48);
  if (v4)
  {
    v5 = (void *)CopyFileObjectIdentifierAtURL(v4);
LABEL_4:
    v6 = v5;
    goto LABEL_5;
  }
  v7 = *(const __CFDictionary **)(v3 + 96);
  if (!v7)
  {
    v6 = 0;
    goto LABEL_5;
  }
  v8 = (const __CFDictionary *)DCSMAGetAssetAttributes(v7);
  Value = CFDictionaryGetValue(v8, CFSTR("DictionaryIdentifier"));
  v6 = CFRetain(Value);
  if (!v6)
  {
    v10 = CFDictionaryGetValue(v8, CFSTR("DictionaryPackageName"));
    v5 = (void *)CFRetain(v10);
    goto LABEL_4;
  }
LABEL_5:
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(_cachedDictionaries + 8), v6))
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(_cachedDictionaries + 8), v6);
  CFRelease(v6);
  pthread_rwlock_unlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
}

uint64_t DCSDictionaryManager::updateOrders(DCSDictionaryManager *this)
{
  CFIndex Count;
  unint64_t v2;
  const void **v3;
  size_t v4;
  DCSEnvironment *v5;
  const __CFArray *ActiveDictionaryInfos;
  const __CFArray *v7;
  CFIndex v8;
  uint64_t i;
  _QWORD *v10;
  uint64_t v11;
  const void *v12;
  BOOL v13;
  CFIndex v14;
  const __CFDictionary *ValueAtIndex;
  const void *Value;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(_cachedDictionaries + 8));
  v18[0] = v18;
  MEMORY[0x1E0C80A78](Count);
  v3 = (const void **)((char *)v18 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v2 >= 0x200)
    v4 = 512;
  else
    v4 = v2;
  bzero((char *)v18 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0), v4);
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(_cachedDictionaries + 8), 0, v3);
  v5 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  ActiveDictionaryInfos = (const __CFArray *)DCSEnvironment::getActiveDictionaryInfos(v5);
  v7 = ActiveDictionaryInfos;
  if (ActiveDictionaryInfos)
    v8 = CFArrayGetCount(ActiveDictionaryInfos);
  else
    v8 = 0;
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      v10 = v3[i];
      if (v10)
        v11 = v10[2];
      else
        v11 = 0;
      v12 = *(const void **)(v11 + 48);
      if (v12)
        v13 = v8 < 1;
      else
        v13 = 1;
      if (!v13)
      {
        v14 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v14);
          Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("URL"));
          if (Value)
          {
            if (CFEqual(Value, v12))
              break;
          }
          if (v8 == ++v14)
            goto LABEL_22;
        }
        *(_QWORD *)(v11 + 72) = v14;
      }
LABEL_22:
      ;
    }
  }
  return pthread_rwlock_unlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
}

uint64_t DCSDictionaryManager::updatePreferences(DCSDictionaryManager *this)
{
  CFIndex Count;
  unint64_t v2;
  const void **v3;
  size_t v4;
  uint64_t v5;
  _QWORD *v6;
  DCSEnvironment *v7;
  const __CFString *v8;
  const void *DictionaryPreference;
  const void *v10;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  pthread_rwlock_rdlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(_cachedDictionaries + 8));
  MEMORY[0x1E0C80A78](Count);
  v3 = (const void **)((char *)v12 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v2 >= 0x200)
    v4 = 512;
  else
    v4 = v2;
  bzero((char *)v12 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0), v4);
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(_cachedDictionaries + 8), 0, v3);
  if (Count >= 1)
  {
    do
    {
      if (*v3)
      {
        v5 = *((_QWORD *)*v3 + 2);
        if (v5)
        {
          if (*(_BYTE *)(v5 + 16))
          {
            v6 = *(_QWORD **)(v5 + 24);
            if (!v6 || !*v6)
            {
              v7 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
              v8 = (const __CFString *)DCSDictionary::identifier((DCSDictionary *)v5);
              DictionaryPreference = DCSEnvironment::getDictionaryPreference(v7, v8);
              if (DictionaryPreference)
              {
                v10 = DictionaryPreference;
                if (DCSDictionary::createDictionaryObj((DCSDictionary *)v5))
                  (*(void (**)(_QWORD, const void *))(**(_QWORD **)(v5 + 8) + 184))(*(_QWORD *)(v5 + 8), v10);
              }
            }
          }
        }
      }
      ++v3;
      --Count;
    }
    while (Count);
  }
  return pthread_rwlock_unlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
}

void SyncMutableCFSpecificType<__CFDictionary *>::~SyncMutableCFSpecificType(SyncMutableCFRef *a1)
{
  SyncMutableCFRef::~SyncMutableCFRef(a1);
  JUMPOUT(0x1D17BC79CLL);
}

void sub_1CDF6CB18(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

uint64_t SyncMutableCFRef::get(SyncMutableCFRef *this)
{
  return *((_QWORD *)this + 1);
}

void SyncMutableCFRef::~SyncMutableCFRef(SyncMutableCFRef *this)
{
  SyncMutableCFRef::~SyncMutableCFRef(this);
  JUMPOUT(0x1D17BC79CLL);
}

{
  const void *v2;

  *(_QWORD *)this = &unk_1E8B56538;
  pthread_rwlock_destroy((pthread_rwlock_t *)((char *)this + 16));
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
}

void sub_1CDF6CB7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

uint64_t _DCSDictionaryInitialize(void)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  _DCSDictionaryID = result;
  return result;
}

void _DCSDictionaryFinalize(const __DCSDictionary *a1)
{
  DCSDictionary *v2;
  _QWORD *v3;
  DCSDictionaryManager *v4;

  v2 = (DCSDictionary *)*((_QWORD *)a1 + 2);
  v3 = (_QWORD *)*((_QWORD *)v2 + 3);
  if (!v3 || !*v3)
  {
    v4 = (DCSDictionaryManager *)SyncSingleton<DCSDictionaryManager>::instance();
    DCSDictionaryManager::remove(v4, a1);
  }
  DCSDictionary::~DCSDictionary(v2);
  JUMPOUT(0x1D17BC79CLL);
}

void sub_1CDF6CC5C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x1060C40D262D689);
  _Unwind_Resume(a1);
}

uint64_t _DCSDictionaryEqual(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  uint64_t v7;
  uint64_t v8;

  v2 = a1[2];
  v3 = a2[2];
  v4 = *(const void **)(v2 + 48);
  if (v4)
  {
    v5 = *(const void **)(v3 + 48);
    if (v5)
      return CFEqual(v4, v5);
  }
  v7 = *(_QWORD *)(v2 + 96);
  return v7 && (v8 = *(_QWORD *)(v3 + 96)) != 0 && v7 == v8;
}

CFStringRef _DCSDictionaryCopyFormattingDesc(_QWORD *a1, const __CFDictionary *a2)
{
  DCSDictionary *v3;
  const __CFAllocator *v4;
  const __CFDictionary *v5;

  v3 = (DCSDictionary *)a1[2];
  v4 = CFGetAllocator(a1);
  v5 = DCSDictionary::name(v3);
  return CFStringCreateWithFormat(v4, a2, CFSTR("<%@>"), v5);
}

CFStringRef _DCSDictionaryCopyDebugDesc(_QWORD *a1)
{
  DCSDictionary *v1;
  const __CFAllocator *v2;
  const __CFURL *v3;
  void *v4;

  v1 = (DCSDictionary *)a1[2];
  v2 = CFGetAllocator(a1);
  v3 = (const __CFURL *)*((_QWORD *)v1 + 6);
  if (v3)
    v4 = (void *)CFURLGetString(v3);
  else
    v4 = DCSDictionary::name(v1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<DCSDictionaryRef %p>{URL = %@}"), v1, v4);
}

uint64_t SyncSingleton<DCSDictionaryManager>::instance()
{
  if (!SyncSingleton<DCSDictionaryManager>::_instantiated)
  {
    pthread_mutex_lock(&SyncSingleton<DCSDictionaryManager>::_mutex);
    if (!SyncSingleton<DCSDictionaryManager>::_instantiated)
    {
      SyncSingleton<DCSDictionaryManager>::_instance = operator new();
      SyncSingleton<DCSDictionaryManager>::_instantiated = 1;
    }
    pthread_mutex_unlock(&SyncSingleton<DCSDictionaryManager>::_mutex);
  }
  return SyncSingleton<DCSDictionaryManager>::_instance;
}

void DCSUsageTrackingCoreAnalyticsLogging::DCSUsageTrackingCoreAnalyticsLogging(DCSUsageTrackingCoreAnalyticsLogging *this)
{
  *(_QWORD *)this = &off_1E8B565C0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 1) = xpc_dictionary_create(0, 0, 0);
}

void DCSUsageTrackingCoreAnalyticsLogging::~DCSUsageTrackingCoreAnalyticsLogging(DCSUsageTrackingCoreAnalyticsLogging *this)
{
  void *v1;

  *(_QWORD *)this = &off_1E8B565C0;
  v1 = (void *)*((_QWORD *)this + 1);
  if (v1)
    xpc_release(v1);
}

{
  void *v1;

  *(_QWORD *)this = &off_1E8B565C0;
  v1 = (void *)*((_QWORD *)this + 1);
  if (v1)
    xpc_release(v1);
}

{
  void *v1;

  *(_QWORD *)this = &off_1E8B565C0;
  v1 = (void *)*((_QWORD *)this + 1);
  if (v1)
    xpc_release(v1);
  JUMPOUT(0x1D17BC79CLL);
}

void sub_1CDF6CEE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x81C40803F642BLL);
  _Unwind_Resume(a1);
}

void DCSUsageTrackingCoreAnalyticsLogging::logApplicationName(xpc_object_t *this, const char *string)
{
  xpc_dictionary_set_string(this[1], "com.apple.message.signature", string);
}

void DCSUsageTrackingCoreAnalyticsLogging::logDictionaryIdentifier(xpc_object_t *this, const char *string)
{
  xpc_dictionary_set_string(this[1], "com.apple.message.signature2", string);
}

void DCSUsageTrackingCoreAnalyticsLogging::logPrimaryLanguage(xpc_object_t *this, const char *string)
{
  xpc_dictionary_set_string(this[1], "com.apple.message.signature3", string);
}

void DCSUsageTrackingCoreAnalyticsLogging::doLogging(DCSUsageTrackingCoreAnalyticsLogging *this)
{
  uint64_t v1;
  void *v2;
  _QWORD v3[5];

  v1 = kDCSUsageTrackingDoman;
  v2 = (void *)*((_QWORD *)this + 1);
  if (_CallAnalyticsSendEventLazy(char const*,void *)::_OnceToken != -1)
    dispatch_once(&_CallAnalyticsSendEventLazy(char const*,void *)::_OnceToken, &__block_literal_global);
  if (_CallAnalyticsSendEventLazy(char const*,void *)::_AnalyticsSendEventLazyProc)
  {
    xpc_retain(v2);
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 0x40000000;
    v3[2] = ___ZL27_CallAnalyticsSendEventLazyPKcPv_block_invoke_2;
    v3[3] = &__block_descriptor_tmp_17;
    v3[4] = v2;
    _CallAnalyticsSendEventLazy(char const*,void *)::_AnalyticsSendEventLazyProc(v1, v3);
  }
}

void DCSUsageTrackingASLLogging::DCSUsageTrackingASLLogging(DCSUsageTrackingASLLogging *this)
{
  __asl_object_s *v2;

  *(_QWORD *)this = &off_1E8B56608;
  *((_QWORD *)this + 1) = 0;
  v2 = asl_new(0);
  *((_QWORD *)this + 1) = v2;
  asl_set(v2, "com.apple.message.domain", (const char *)kDCSUsageTrackingDoman);
}

void DCSUsageTrackingASLLogging::~DCSUsageTrackingASLLogging(DCSUsageTrackingASLLogging *this)
{
  *(_QWORD *)this = &off_1E8B56608;
  if (*((_QWORD *)this + 1))
    MEMORY[0x1D17BC85C]();
}

{
  *(_QWORD *)this = &off_1E8B56608;
  if (*((_QWORD *)this + 1))
    MEMORY[0x1D17BC85C]();
}

{
  *(_QWORD *)this = &off_1E8B56608;
  if (*((_QWORD *)this + 1))
    MEMORY[0x1D17BC85C]();
  JUMPOUT(0x1D17BC79CLL);
}

void sub_1CDF6D0FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t DCSUsageTrackingASLLogging::setSummarize(DCSUsageTrackingASLLogging *this, int a2)
{
  __asl_object_s *v2;
  const char *v3;

  v2 = (__asl_object_s *)*((_QWORD *)this + 1);
  if (a2)
    v3 = "YES";
  else
    v3 = "NO";
  return asl_set(v2, "com.apple.message.summarize", v3);
}

uint64_t DCSUsageTrackingASLLogging::logApplicationName(asl_object_t *this, const char *value)
{
  return asl_set(this[1], "com.apple.message.signature", value);
}

uint64_t DCSUsageTrackingASLLogging::logDictionaryIdentifier(asl_object_t *this, const char *value)
{
  return asl_set(this[1], "com.apple.message.signature2", value);
}

uint64_t DCSUsageTrackingASLLogging::logPrimaryLanguage(asl_object_t *this, const char *value)
{
  return asl_set(this[1], "com.apple.message.signature3", value);
}

uint64_t DCSUsageTrackingASLLogging::doLogging(asl_object_t *this)
{
  return asl_log(0, this[1], 5, "");
}

void DCSUsageTrackingAggregateLogging::DCSUsageTrackingAggregateLogging(DCSUsageTrackingAggregateLogging *this)
{
  *(_QWORD *)this = &off_1E8B56650;
}

void DCSUsageTrackingAggregateLogging::~DCSUsageTrackingAggregateLogging(DCSUsageTrackingAggregateLogging *this)
{
  JUMPOUT(0x1D17BC79CLL);
}

void DCSUsageTrackingAggregateLogging::logApplicationName(DCSUsageTrackingAggregateLogging *this, const char *a2)
{
  CFStringRef v2;
  CFStringRef v3;

  v2 = CFStringCreateWithFormat(0, 0, CFSTR("%s.%s.%s"), kDCSUsageTrackingDoman, "applicationName", a2);
  if (v2)
  {
    v3 = v2;
    ADClientAddValueForScalarKey();
    CFRelease(v3);
  }
}

uint64_t DCSUsageTrackingAggregateLogging::logKey(DCSUsageTrackingAggregateLogging *this, const __CFString *a2)
{
  return ADClientAddValueForScalarKey();
}

void DCSUsageTrackingAggregateLogging::logDictionaryIdentifier(DCSUsageTrackingAggregateLogging *this, const char *a2)
{
  CFStringRef v2;
  CFStringRef v3;

  v2 = CFStringCreateWithFormat(0, 0, CFSTR("%s.%s.%s"), kDCSUsageTrackingDoman, "dictionaryIdentifier", a2);
  if (v2)
  {
    v3 = v2;
    ADClientAddValueForScalarKey();
    CFRelease(v3);
  }
}

void DCSUsageTrackingAggregateLogging::logPrimaryLanguage(DCSUsageTrackingAggregateLogging *this, const char *a2)
{
  CFStringRef v2;
  CFStringRef v3;

  v2 = CFStringCreateWithFormat(0, 0, CFSTR("%s.%s.%s"), kDCSUsageTrackingDoman, "primaryLanguage", a2);
  if (v2)
  {
    v3 = v2;
    ADClientAddValueForScalarKey();
    CFRelease(v3);
  }
}

uint64_t ___ZL27_CallAnalyticsSendEventLazyPKcPv_block_invoke_2(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

void DCSEnvironment::DCSEnvironment(DCSEnvironment *this)
{
  CFStringRef *v2;
  DCSDictionary *Mutable;
  __CFBundle *MainBundle;
  const __CFDictionary *InfoDictionary;
  const __CFString *Value;
  const __CFString *v7;
  const __CFString *v8;
  __CFNotificationCenter *DarwinNotifyCenter;
  __CFNotificationCenter *LocalCenter;

  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_BYTE *)this + 104) = 0;
  *(_QWORD *)((char *)this + 108) = -1;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_BYTE *)this + 136) = 0;
  *((_QWORD *)this + 18) = -1;
  *((_WORD *)this + 76) = 0;
  *((_BYTE *)this + 154) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_BYTE *)this + 168) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_WORD *)this + 92) = 0;
  v2 = (CFStringRef *)((char *)this + 584);
  *((_QWORD *)this + 75) = 0;
  *(_OWORD *)((char *)this + 584) = 0u;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 200), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 264), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 328), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 392), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 456), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 520), 0);
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)this + 24) = Mutable;
  DCSDictionary::startGlobalDictionariesEnvironment(Mutable);
  DCSMAPrepareMobileAssetQuery();
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
    *((_BYTE *)this + 185) = InfoDictionary == 0;
    if (InfoDictionary)
    {
      Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, CFSTR("CFBundleIdentifier"));
      if (Value)
      {
        v7 = Value;
        *((_BYTE *)this + 185) = CFStringCompare(Value, CFSTR("com.apple.lookupd"), 0) == kCFCompareEqualTo;
        if (CFStringHasPrefix(v7, CFSTR("com.apple.")))
          v8 = v7;
        else
          v8 = CFSTR("com.apple.lookupd");
      }
      else
      {
        *((_BYTE *)this + 185) = 1;
        v8 = CFSTR("Unknown");
      }
      *v2 = CFStringCreateCopy(0, v8);
    }
  }
  else
  {
    *((_BYTE *)this + 185) = 1;
  }
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(DarwinNotifyCenter, this, (CFNotificationCallback)ActiveDictionaryChangedCallback, CFSTR("DCSActiveDictionariesChangedDistributedNotification"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(LocalCenter, this, (CFNotificationCallback)_PurgeInactiveDataCallback, CFSTR("UIApplicationDidEnterBackgroundNotification"), 0, CFNotificationSuspensionBehaviorDrop);
}

void ___ZN14DCSEnvironmentC2Ev_block_invoke(uint64_t a1, int a2)
{
  if (a2)
    DCSEnvironment::resetActiveDictionaries(*(DCSEnvironment **)(a1 + 32), 0);
}

void DCSEnvironment::resetActiveDictionaries(DCSEnvironment *this, int a2)
{
  const void *v4;
  const void *v5;
  __CFNotificationCenter *LocalCenter;

  if (*((_QWORD *)this + 6))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 200));
    v4 = (const void *)*((_QWORD *)this + 6);
    if (v4)
    {
      CFRelease(v4);
      *((_QWORD *)this + 6) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 200));
  }
  if (*((_QWORD *)this + 7))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
    v5 = (const void *)*((_QWORD *)this + 7);
    if (v5)
    {
      CFRelease(v5);
      *((_QWORD *)this + 7) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
  }
  if (a2)
  {
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterPostNotification(LocalCenter, CFSTR("DCSActiveDictionariesChangedNotification"), 0, 0, 0);
  }
}

void ActiveDictionaryChangedCallback(__CFNotificationCenter *a1, DCSEnvironment *a2, const __CFString *a3, const void *a4, const __CFDictionary *a5)
{
  DCSLog(16, CFSTR("kDCSActiveDictionariesChangedDistributedNotification caught"), a3, a4, a5);
  DCSEnvironment::resetActiveDictionaries(a2, 1);
}

void _PurgeInactiveDataCallback(__CFNotificationCenter *a1, void *a2, const __CFString *a3, const void *a4, const __CFDictionary *a5)
{
  DCSEnvironment *v5;
  __CFArray *v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex i;
  const void *ValueAtIndex;
  DCSDictionary *v12;

  v5 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  v6 = DCSEnvironment::copyActiveDictionaries(v5, 0);
  if (v6)
  {
    v7 = v6;
    Count = CFArrayGetCount(v6);
    if (Count >= 1)
    {
      v9 = Count;
      for (i = 0; i != v9; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v7, i);
        if (ValueAtIndex)
        {
          v12 = (DCSDictionary *)*((_QWORD *)ValueAtIndex + 2);
          if (v12)
            DCSDictionary::purgeInactiveData(v12);
        }
      }
    }
    CFRelease(v7);
  }
}

void DCSEnvironment::~DCSEnvironment(DCSEnvironment *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  __CFNotificationCenter *DarwinNotifyCenter;
  __CFNotificationCenter *DistributedCenter;

  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 5);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 6);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 7);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 8);
  if (v6)
    CFRelease(v6);
  v7 = (const void *)*((_QWORD *)this + 11);
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 15);
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)this + 16);
  if (v9)
    CFRelease(v9);
  if (*(_QWORD *)this)
    CFRelease(*(CFTypeRef *)this);
  v10 = (const void *)*((_QWORD *)this + 2);
  if (v10)
    CFRelease(v10);
  v11 = (const void *)*((_QWORD *)this + 3);
  if (v11)
    CFRelease(v11);
  v12 = (const void *)*((_QWORD *)this + 24);
  if (v12)
    CFRelease(v12);
  v13 = (const void *)*((_QWORD *)this + 73);
  if (v13)
    CFRelease(v13);
  v14 = (const void *)*((_QWORD *)this + 74);
  if (v14)
    CFRelease(v14);
  v15 = (const void *)*((_QWORD *)this + 75);
  if (v15)
    CFRelease(v15);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 200));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 264));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 328));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 392));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 456));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 520));
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver(DarwinNotifyCenter, this, CFSTR("DCSActiveDictionariesChangedDistributedNotification"), 0);
  DistributedCenter = CFNotificationCenterGetDistributedCenter();
  CFNotificationCenterRemoveObserver(DistributedCenter, this, CFSTR("UIApplicationDidEnterBackgroundNotification"), 0);
}

uint64_t DCSEnvironment::getFrameworkBundle(DCSEnvironment *this)
{
  uint64_t result;
  const __CFString *v3;
  const __CFURL *v4;

  result = *(_QWORD *)this;
  if (!result)
  {
    v3 = CFStringCreateWithCString(0, "/System/Library/PrivateFrameworks/DictionaryServices.framework", 0x8000100u);
    v4 = CFURLCreateWithFileSystemPath(0, v3, kCFURLPOSIXPathStyle, 1u);
    *(_QWORD *)this = CFBundleCreate(0, v4);
    CFRelease(v4);
    CFRelease(v3);
    return *(_QWORD *)this;
  }
  return result;
}

CFStringRef DCSEnvironment::getCurrentAppLocalization(DCSEnvironment *this)
{
  CFStringRef result;
  __CFBundle *MainBundle;
  const __CFArray *v4;
  const __CFArray *v5;
  const __CFArray *v6;
  const __CFArray *v7;
  const __CFString *ValueAtIndex;

  result = (CFStringRef)*((_QWORD *)this + 1);
  if (!result)
  {
    MainBundle = CFBundleGetMainBundle();
    v4 = CFBundleCopyBundleLocalizations(MainBundle);
    if (v4)
    {
      v5 = v4;
      v6 = CFBundleCopyPreferredLocalizationsFromArray(v4);
      if (v6)
      {
        v7 = v6;
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, 0);
        *((_QWORD *)this + 1) = CFStringCreateCopy(0, ValueAtIndex);
        CFRelease(v7);
      }
      else
      {
        *((_QWORD *)this + 1) = CFStringCreateCopy(0, CFSTR("English"));
      }
      CFRelease(v5);
      return (CFStringRef)*((_QWORD *)this + 1);
    }
    else
    {
      result = CFStringCreateCopy(0, CFSTR("English"));
      *((_QWORD *)this + 1) = result;
    }
  }
  return result;
}

CFStringRef DCSEnvironment::getCurrentSystemLanguage(DCSEnvironment *this)
{
  CFStringRef result;
  const __CFArray *v3;
  const __CFArray *v4;
  const __CFString *ValueAtIndex;
  const __CFAllocator *Copy;
  const __CFString *FallbackEnglishLanguage;

  result = (CFStringRef)*((_QWORD *)this + 2);
  if (!result)
  {
    v3 = CFLocaleCopyPreferredLanguages();
    if (!v3)
      goto LABEL_8;
    v4 = v3;
    if (CFArrayGetCount(v3) >= 1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, 0);
      if (CFStringCompare(ValueAtIndex, CFSTR("en"), 0) == kCFCompareEqualTo)
      {
        FallbackEnglishLanguage = (const __CFString *)DCSEnvironment::getFallbackEnglishLanguage(0);
        Copy = (const __CFAllocator *)CFStringCreateCopy(0, FallbackEnglishLanguage);
        *((_QWORD *)this + 2) = Copy;
        if (Copy)
          goto LABEL_7;
        goto LABEL_6;
      }
      Copy = (const __CFAllocator *)*((_QWORD *)this + 2);
      if (!Copy)
LABEL_6:
        *((_QWORD *)this + 2) = CFStringCreateCopy(Copy, ValueAtIndex);
    }
LABEL_7:
    CFRelease(v4);
LABEL_8:
    result = (CFStringRef)*((_QWORD *)this + 2);
    if (!result)
    {
      result = CFStringCreateCopy(0, CFSTR("en_US"));
      *((_QWORD *)this + 2) = result;
    }
  }
  return result;
}

CFTypeRef DCSEnvironment::getFallbackEnglishLanguage(DCSEnvironment *this)
{
  CFTypeRef result;
  CFLocaleRef v2;
  CFLocaleRef v3;
  const __CFString *v4;

  result = (CFTypeRef)DCSEnvironment::getFallbackEnglishLanguage(void)::_FallbackEnglishLanguage;
  if (!DCSEnvironment::getFallbackEnglishLanguage(void)::_FallbackEnglishLanguage)
  {
    v2 = CFLocaleCopyCurrent();
    if (v2)
    {
      v3 = v2;
      v4 = (const __CFString *)MEMORY[0x1D17BC130]();
      DCSEnvironment::getFallbackEnglishLanguage(void)::_FallbackEnglishLanguage = (uint64_t)CopyPreferredEnglishLanguage(v4);
      CFRelease(v3);
      return (CFTypeRef)DCSEnvironment::getFallbackEnglishLanguage(void)::_FallbackEnglishLanguage;
    }
    else
    {
      result = CopyPreferredEnglishLanguage(0);
      DCSEnvironment::getFallbackEnglishLanguage(void)::_FallbackEnglishLanguage = (uint64_t)result;
    }
  }
  return result;
}

uint64_t DCSEnvironment::getCurrentPreferredLanguages(DCSEnvironment *this, uint64_t *a2)
{
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  const __CFString *ValueAtIndex;

  if (!*((_QWORD *)this + 3))
  {
    *((_QWORD *)this + 3) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    *((_QWORD *)this + 4) = -1;
    v4 = CFLocaleCopyPreferredLanguages();
    Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      v6 = Count;
      for (i = 0; i != v6; ++i)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, i);
        if (CFStringCompare(ValueAtIndex, CFSTR("en"), 0) == kCFCompareEqualTo)
        {
          ValueAtIndex = (const __CFString *)DCSEnvironment::getFallbackEnglishLanguage(0);
          *((_QWORD *)this + 4) = i;
        }
        CFArrayAppendValue(*((CFMutableArrayRef *)this + 3), ValueAtIndex);
      }
    }
    CFRelease(v4);
    if (!CFArrayGetCount(*((CFArrayRef *)this + 3)))
      CFArrayAppendValue(*((CFMutableArrayRef *)this + 3), CFSTR("en_US"));
  }
  if (a2)
    *a2 = *((_QWORD *)this + 4);
  return *((_QWORD *)this + 3);
}

CFStringRef DCSEnvironment::getUserAgentName(DCSEnvironment *this)
{
  CFStringRef result;
  __CFBundle *FrameworkBundle;
  const __CFDictionary *InfoDictionary;
  const __CFString *Value;
  const __CFString *v6;

  result = (CFStringRef)*((_QWORD *)this + 5);
  if (!result)
  {
    FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(this);
    InfoDictionary = CFBundleGetInfoDictionary(FrameworkBundle);
    Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, CFSTR("CFBundleVersion"));
    v6 = CFSTR("0");
    if (Value)
      v6 = Value;
    result = CFStringCreateWithFormat(0, 0, CFSTR("AppleDictionaryService/%@"), v6);
    *((_QWORD *)this + 5) = result;
  }
  return result;
}

uint64_t DCSEnvironment::getActiveDictionaryInfos(DCSEnvironment *this)
{
  uint64_t result;
  const __CFArray *ActiveDictionaryInfoList;

  result = *((_QWORD *)this + 6);
  if (!result)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 200));
    if (!*((_QWORD *)this + 6))
    {
      ActiveDictionaryInfoList = DCSEnvironment::loadActiveDictionaryInfoList((CFMutableDictionaryRef *)this);
      *((_QWORD *)this + 6) = ActiveDictionaryInfoList;
      if (!ActiveDictionaryInfoList)
        *((_QWORD *)this + 6) = CFArrayCreateMutable(0, 0, 0);
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 200));
    return *((_QWORD *)this + 6);
  }
  return result;
}

const __CFArray *DCSEnvironment::loadActiveDictionaryInfoList(CFMutableDictionaryRef *this)
{
  const __CFArray *Mutable;
  CFIndex Count;
  CFIndex v4;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *Value;
  const __CFString *v8;
  DCSEnvironment *v9;
  const __CFString *v10;

  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  CFDictionaryRemoveAllValues(this[24]);
  Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    v4 = Count;
    for (i = 0; i != v4; ++i)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, i);
      Value = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, CFSTR("asset"));
      if (Value)
      {
        v8 = DCSMAGetAssetLanguage(Value);
        DCSEnvironment::storeActiveDictionaryLanguage(this, v8);
      }
      else
      {
        v9 = (DCSEnvironment *)CFDictionaryGetValue(ValueAtIndex, CFSTR("URL"));
        if (v9)
        {
          v10 = (const __CFString *)DCSEnvironment::copyPrimaryLanguageOfDictionaryURL(v9, v9);
          DCSEnvironment::storeActiveDictionaryLanguage(this, v10);
          if (v10)
            CFRelease(v10);
        }
      }
    }
  }
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t DCSEnvironment::checkLanguageMatch(DCSEnvironment *this, CFStringRef theString1, const __CFString *a3)
{
  const __CFString *CanonicalLanguageIdentifierFromString;
  const __CFString *v6;
  uint64_t v7;

  if (!a3 || CFStringCompare(theString1, CFSTR("*"), 0) == kCFCompareEqualTo)
    return 1;
  CanonicalLanguageIdentifierFromString = CFLocaleCreateCanonicalLanguageIdentifierFromString(0, theString1);
  v6 = CFLocaleCreateCanonicalLanguageIdentifierFromString(0, a3);
  v7 = 1;
  if (CFStringCompare(CanonicalLanguageIdentifierFromString, v6, 1uLL))
  {
    if (CFStringFind(v6, CFSTR("-"), 0).location == -1)
      v7 = CompareLanguageCode(CanonicalLanguageIdentifierFromString, v6, 0);
    else
      v7 = 0;
  }
  CFRelease(CanonicalLanguageIdentifierFromString);
  CFRelease(v6);
  return v7;
}

uint64_t DCSEnvironment::setActiveDictionaries(DCSEnvironment *this, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v5;
  BOOL v6;
  CFIndex v8;
  const void *ValueAtIndex;
  const void *v10;
  int v11;
  BOOL v12;
  CFArrayRef Copy;
  const void *v14;

  Count = CFArrayGetCount(theArray);
  DCSEnvironment::getActiveDictionaries(this);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
  v5 = CFArrayGetCount(*((CFArrayRef *)this + 7));
  v6 = Count != v5;
  if (Count == v5 && Count >= 1)
  {
    v8 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v8);
      v10 = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 7), v8);
      v11 = CFEqual(ValueAtIndex, v10);
      v6 = v11 == 0;
      ++v8;
      if (v11)
        v12 = v8 < Count;
      else
        v12 = 0;
    }
    while (v12);
  }
  if (v6)
  {
    Copy = CFArrayCreateCopy(0, theArray);
    v14 = (const void *)*((_QWORD *)this + 7);
    if (v14)
      CFRelease(v14);
    *((_QWORD *)this + 7) = Copy;
  }
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
}

uint64_t DCSEnvironment::copyInactiveDictionaries(DCSEnvironment *this, const __CFString *a2)
{
  return 0;
}

uint64_t DCSEnvironment::prepareDefaultAssets(DCSEnvironment *this)
{
  DCSEnvironment::getCurrentPreferredLanguages(this, 0);
  return DCSDictionary::startGlobalDictionariesEnvironment(0);
}

CFNumberRef DCSEnvironment::setServiceWindowType(DCSEnvironment *this, __int16 a2)
{
  __int16 valuePtr;

  valuePtr = a2;
  return CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
}

const void *DCSEnvironment::getDictionaryPreference(DCSEnvironment *this, const __CFString *key)
{
  const __CFDictionary *v4;

  if (!key)
    return 0;
  v4 = (const __CFDictionary *)*((_QWORD *)this + 11);
  if (!v4)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 392));
    if (!*((_QWORD *)this + 11))
      *((_QWORD *)this + 11) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
    v4 = (const __CFDictionary *)*((_QWORD *)this + 11);
  }
  return CFDictionaryGetValue(v4, key);
}

uint64_t DCSEnvironment::setDictionaryPreference(DCSEnvironment *this, const __CFString *a2, const __CFDictionary *a3)
{
  DCSEnvironment::getDictionaryPreference(this, a2);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 392));
  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 11), a2, a3);
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
}

uint64_t DCSEnvironment::resetDictionaryPreferences(DCSEnvironment *this)
{
  pthread_mutex_t *v2;
  const void *v3;
  DCSDictionaryManager *v4;

  if (*((_QWORD *)this + 11))
  {
    v2 = (pthread_mutex_t *)((char *)this + 392);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 392));
    v3 = (const void *)*((_QWORD *)this + 11);
    if (v3)
    {
      CFRelease(v3);
      *((_QWORD *)this + 11) = 0;
    }
    pthread_mutex_unlock(v2);
  }
  v4 = (DCSDictionaryManager *)SyncSingleton<DCSDictionaryManager>::instance();
  return DCSDictionaryManager::updatePreferences(v4);
}

uint64_t DCSEnvironment::parentalControlCensoringContents(DCSEnvironment *this)
{
  _QWORD v3[5];

  if (*((double *)this + 12) == 0.0)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 0x40000000;
    v3[2] = ___ZN14DCSEnvironment32parentalControlCensoringContentsEv_block_invoke;
    v3[3] = &__block_descriptor_tmp_36;
    v3[4] = this;
    *((_BYTE *)this + 104) = IsManagedConfigProfanityFilterForced();
    *((CFAbsoluteTime *)this + 12) = CFAbsoluteTimeGetCurrent();
    SetManagedConfigChangedCallback((uint64_t)v3);
  }
  return *((unsigned __int8 *)this + 104);
}

void ___ZN14DCSEnvironment32parentalControlCensoringContentsEv_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v1 + 104) = IsManagedConfigProfanityFilterForced();
  *(CFAbsoluteTime *)(v1 + 96) = CFAbsoluteTimeGetCurrent();
}

BOOL DCSEnvironment::networkDictionariesExcluded(DCSEnvironment *this)
{
  int v1;
  __CFBundle *MainBundle;
  CFTypeRef ValueForInfoDictionaryKey;
  BOOL v5;

  v1 = *((_DWORD *)this + 27);
  if (v1 == -1)
  {
    *((_DWORD *)this + 27) = 1;
    MainBundle = CFBundleGetMainBundle();
    if (MainBundle)
    {
      ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(MainBundle, CFSTR("DCSUseNetworkDictionaries"));
      if (ValueForInfoDictionaryKey)
        v5 = ValueForInfoDictionaryKey == (CFTypeRef)*MEMORY[0x1E0C9AE40];
      else
        v5 = 1;
      v1 = v5;
      *((_DWORD *)this + 27) = v1;
    }
    else
    {
      v1 = *((_DWORD *)this + 27);
    }
  }
  return v1 != 0;
}

BOOL DCSEnvironment::orientationVerticalAllowed(DCSEnvironment *this)
{
  __CFBundle *MainBundle;
  _BOOL4 v3;
  __CFBundle *v4;
  const __CFString *Identifier;

  if (*((_DWORD *)this + 28) == -1)
  {
    *((_DWORD *)this + 28) = 0;
    MainBundle = CFBundleGetMainBundle();
    if (MainBundle)
    {
      v3 = CFBundleGetValueForInfoDictionaryKey(MainBundle, CFSTR("DCSAllowOrientationVertical")) == (CFTypeRef)*MEMORY[0x1E0C9AE50];
      *((_DWORD *)this + 28) = v3;
      if (v3)
        return *((_DWORD *)this + 28) > 0;
    }
    else if (*((_DWORD *)this + 28))
    {
      return *((_DWORD *)this + 28) > 0;
    }
    v4 = CFBundleGetMainBundle();
    if (v4)
    {
      Identifier = CFBundleGetIdentifier(v4);
      if (Identifier)
      {
        if (CFStringCompare(Identifier, CFSTR("com.apple.Dictionary"), 0) == kCFCompareEqualTo)
          *((_DWORD *)this + 28) = 1;
      }
    }
  }
  return *((_DWORD *)this + 28) > 0;
}

uint64_t DCSEnvironment::readyForFontActivation(DCSEnvironment *this)
{
  return 0;
}

uint64_t DCSEnvironment::getSubstituteCharactersTable(DCSEnvironment *this, const __CFCharacterSet **a2)
{
  const __CFDictionary *PropertyList;
  const __CFDictionary *v5;
  uint64_t Count;
  const void **v7;
  const void **v8;
  const void **v9;
  __CFCharacterSet *Mutable;
  uint64_t v11;
  uint64_t Length;
  uint64_t v13;
  const void *v14;
  const __CFAllocator *alloc;
  void **values;
  UniChar buffer[2];
  CFRange v20;

  if (!*((_QWORD *)this + 15))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 456));
    if (!*((_QWORD *)this + 15))
    {
      PropertyList = DCSEnvironment::loadPropertyList(this, CFSTR("SubstituteCharacters"));
      if (PropertyList)
      {
        v5 = PropertyList;
        Count = CFDictionaryGetCount(PropertyList);
        v7 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
        v8 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
        v9 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
        alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
        values = (void **)v8;
        CFDictionaryGetKeysAndValues(v5, v7, v8);
        v11 = 0;
        if (Count >= 1)
        {
          while (1)
          {
            Length = CFStringGetLength((CFStringRef)v7[v11]);
            if (Length > 2)
              break;
            v13 = Length;
            v20.location = 0;
            v20.length = Length;
            CFStringGetCharacters((CFStringRef)v7[v11], v20, buffer);
            v14 = (const void *)buffer[0];
            if (v13 == 2 && (buffer[0] & 0xFC00) == 55296)
              v14 = (const void *)(buffer[1] + (buffer[0] << 10) - 56613888);
            v9[v11] = v14;
            CFCharacterSetAddCharactersInString(Mutable, (CFStringRef)v7[v11++]);
            if (Count == v11)
              goto LABEL_15;
          }
        }
        if (v11 == Count)
        {
LABEL_15:
          *((_QWORD *)this + 15) = CFDictionaryCreate(0, v9, (const void **)values, Count, 0, MEMORY[0x1E0C9B3A0]);
          *((_QWORD *)this + 16) = CFCharacterSetCreateInvertedSet(alloc, Mutable);
        }
        free(v7);
        free(values);
        free(v9);
        CFRelease(Mutable);
        CFRelease(v5);
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 456));
  }
  if (a2)
    *a2 = (const __CFCharacterSet *)*((_QWORD *)this + 16);
  return *((_QWORD *)this + 15);
}

const __CFURL *DCSEnvironment::loadPropertyList(DCSEnvironment *this, const __CFString *a2)
{
  __CFBundle *FrameworkBundle;
  const __CFURL *v4;
  CFDataRef resourceData;

  FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(this);
  v4 = CFBundleCopyResourceURL(FrameworkBundle, a2, CFSTR("plist"), 0);
  if (v4)
  {
    resourceData = 0;
    CFURLCreateDataAndPropertiesFromResource(0, v4, &resourceData, 0, 0, 0);
    CFRelease(v4);
    if (resourceData)
    {
      v4 = (const __CFURL *)CFPropertyListCreateFromXMLData(0, resourceData, 0, 0);
      CFRelease(resourceData);
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

CFMutableSetRef DCSEnvironment::copyAvailableDictionaries(DCSEnvironment *this)
{
  const __CFDictionary *v1;
  CFMutableSetRef Mutable;
  const __CFDictionary *Value;

  v1 = (const __CFDictionary *)DCSEnvironment::cachedDictionariesInfo(this);
  Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  Value = (const __CFDictionary *)CFDictionaryGetValue(v1, CFSTR("dictionaries"));
  if (Value)
    CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)CollectDictionariesInCacheCallback, Mutable);
  if (!CFSetGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t DCSEnvironment::cachedDictionariesInfo(DCSEnvironment *this)
{
  pthread_mutex_t *v2;
  unsigned __int8 v3;
  int v4;
  uint64_t Count;
  __CFDictionary *v6;
  CFArrayRef DictionaryPathArray;
  uint64_t v8;
  CFMutableDictionaryRef Mutable;
  CFIndex j;
  DCSEnvironment *v11;
  const __CFSet *v12;
  CFIndex v13;
  CFIndex v14;
  CFIndex k;
  const __CFString *v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  CFIndex v19;
  unint64_t v20;
  const __CFDictionary **v21;
  size_t v22;
  uint64_t v23;
  CFStringRef *v24;
  const __CFURL *v25;
  DCSDictionaryManager *v26;
  uint64_t v27;
  const void *v28;
  __CFDictionary *v29;
  const __CFDictionary *v30;
  __CFDictionary *MutableCopy;
  DCSEnvironment *Value;
  uint64_t v33;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v37;
  const void *v38;
  char v39[1024];
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v2 = (pthread_mutex_t *)((char *)this + 520);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 520));
  v3 = *((_BYTE *)this + 152);
  v4 = *((unsigned __int8 *)this + 154);
  Count = (uint64_t)DCSEnvironment::cachedDictionariesInfo_internal(this);
  v6 = (__CFDictionary *)Count;
  if (v4 | v3)
  {
    if (v4)
    {
LABEL_3:
      DictionaryPathArray = DCSEnvironment::createDictionaryPathArray((DCSEnvironment *)Count);
      goto LABEL_4;
    }
    DictionaryPathArray = 0;
LABEL_39:
    pthread_mutex_unlock(v2);
    if (!DictionaryPathArray)
      return *((_QWORD *)this + 20);
LABEL_40:
    CFRelease(DictionaryPathArray);
    return *((_QWORD *)this + 20);
  }
  Value = (DCSEnvironment *)CFDictionaryGetValue((CFDictionaryRef)Count, CFSTR("directories"));
  DictionaryPathArray = DCSEnvironment::createDictionaryPathArray(Value);
  Count = CFArrayGetCount(DictionaryPathArray);
  if (Count >= 1 && Value)
  {
    v33 = Count;
    for (i = 0; i != v33; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(DictionaryPathArray, i);
      CFDictionaryGetValue(Value, ValueAtIndex);
    }
    goto LABEL_39;
  }
  if (Value)
    goto LABEL_39;
  if (!DictionaryPathArray)
    goto LABEL_3;
LABEL_4:
  v8 = CFArrayGetCount(DictionaryPathArray);
  Mutable = CFDictionaryCreateMutable(0, v8, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v8 >= 1)
  {
    for (j = 0; j != v8; ++j)
      CFArrayGetValueAtIndex(DictionaryPathArray, j);
  }
  CFDictionarySetValue(v6, CFSTR("directories"), Mutable);
  CFRelease(Mutable);
  *((_BYTE *)this + 154) = 0;
  pthread_mutex_unlock(v2);
  v11 = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  v12 = v11;
  if (!DictionaryPathArray)
    DictionaryPathArray = DCSEnvironment::createDictionaryPathArray(v11);
  v13 = CFArrayGetCount(DictionaryPathArray);
  if (v13 >= 1)
  {
    v14 = v13;
    for (k = 0; k != v14; ++k)
    {
      v16 = (const __CFString *)CFArrayGetValueAtIndex(DictionaryPathArray, k);
      CFStringGetFileSystemRepresentation(v16, v39, 1024);
      IterateDirectory(v39, (unsigned int (*)(char *, uint64_t, uint64_t))CollectDictionariesOnDiskCallback, (uint64_t)v12);
    }
  }
  DCSEnvironment::checkSavedDictionaryPrefs(this, v12);
  v17 = (const __CFDictionary *)CFDictionaryGetValue(v6, CFSTR("dictionaries"));
  if (v17)
  {
    v18 = v17;
    v19 = CFDictionaryGetCount(v17);
    v37 = (uint64_t)&v37;
    MEMORY[0x1E0C80A78](v19);
    v20 = (8 * v19 + 15) & 0xFFFFFFFFFFFFFFF0;
    v21 = (const __CFDictionary **)((char *)&v37 - v20);
    v22 = (unint64_t)(8 * v19) >= 0x200 ? 512 : 8 * v19;
    bzero((char *)&v37 - v20, v22);
    MEMORY[0x1E0C80A78](v23);
    v24 = (CFStringRef *)((char *)&v37 - v20);
    bzero((char *)&v37 - v20, v22);
    CFDictionaryGetKeysAndValues(v18, (const void **)((char *)&v37 - v20), (const void **)((char *)&v37 - v20));
    if (v19 >= 1)
    {
      v38 = (const void *)*MEMORY[0x1E0C9AE50];
      while (1)
      {
        v25 = CFURLCreateWithFileSystemPath(0, *v24, kCFURLPOSIXPathStyle, 1u);
        if (!ItemExistsAtURL(v25))
          break;
        v26 = (DCSDictionaryManager *)SyncSingleton<DCSDictionaryManager>::instance();
        v27 = DCSDictionaryManager::dictionary(v26, v25, 0, 0);
        if (v27)
        {
          v28 = (const void *)v27;
          v29 = DCSDictionary::dictionaryCacheInfo(*(DCSDictionary **)(v27 + 16), 1);
          if (v29)
            v30 = v29;
          else
            v30 = *v21;
          MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v30);
          if (CFSetContainsValue(v12, v28))
            CFDictionarySetValue(MutableCopy, CFSTR("scanned"), v38);
          CFRelease(v28);
          goto LABEL_27;
        }
LABEL_29:
        ++v21;
        ++v24;
        if (!--v19)
          goto LABEL_30;
      }
      MutableCopy = 0;
LABEL_27:
      DCSEnvironment::updateDictionaryCacheInfo((uint64_t)this, v25, MutableCopy);
      CFRelease(v25);
      if (MutableCopy)
        CFRelease(MutableCopy);
      goto LABEL_29;
    }
  }
LABEL_30:
  CFRelease(v12);
  if (DictionaryPathArray)
    goto LABEL_40;
  return *((_QWORD *)this + 20);
}

void CollectDictionariesInCacheCallback(const __CFString *a1, CFDictionaryRef theDict, __CFSet *a3)
{
  const __CFURL *v5;
  CFStringRef v6;
  DCSDictionaryManager *v7;
  const void *v8;
  const void *v9;

  if (CFDictionaryContainsKey(theDict, CFSTR("scanned")))
  {
    v5 = CFURLCreateWithFileSystemPath(0, a1, kCFURLPOSIXPathStyle, 1u);
    v6 = CFURLCopyFileSystemPath(v5, kCFURLPOSIXPathStyle);
    v7 = (DCSDictionaryManager *)SyncSingleton<DCSDictionaryManager>::instance();
    v8 = DCSDictionaryManager::dictionary(v7, v5, 0);
    if (v8)
    {
      v9 = v8;
      CFSetAddValue(a3, v8);
      CFRelease(v9);
    }
    CFRelease(v5);
    CFRelease(v6);
  }
}

__CFDictionary *DCSEnvironment::cachedDictionariesInfo_internal(DCSEnvironment *this)
{
  __CFDictionary *Mutable;
  const __CFURL *DictionariesCacheURL;
  uint64_t v4;
  const __CFDictionary *v5;
  const __CFNumber *Value;
  std::error_code *v7;
  CFNumberRef v8;
  std::__fs::filesystem::path resourceData[42];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  Mutable = (__CFDictionary *)*((_QWORD *)this + 20);
  if (!Mutable)
  {
    if (*((_BYTE *)this + 152))
      return 0;
    DictionariesCacheURL = DCSEnvironment::createDictionariesCacheURL(this);
    v4 = _AcquireLockOfCacheFile(DictionariesCacheURL);
    if ((_DWORD)v4 != -1)
    {
      resourceData[0].__pn_.__r_.__value_.__r.__words[0] = 0;
      CFURLCreateDataAndPropertiesFromResource(0, DictionariesCacheURL, (CFDataRef *)resourceData, 0, 0, 0);
      if (resourceData[0].__pn_.__r_.__value_.__r.__words[0])
      {
        v5 = (const __CFDictionary *)CFPropertyListCreateFromXMLData(0, (CFDataRef)resourceData[0].__pn_.__r_.__value_.__l.__data_, 1uLL, 0);
        CFRelease(resourceData[0].__pn_.__r_.__value_.__l.__data_);
        if (v5)
        {
          LODWORD(resourceData[0].__pn_.__r_.__value_.__l.__data_) = 0;
          Value = (const __CFNumber *)CFDictionaryGetValue(v5, CFSTR("cache version"));
          CFNumberGetValue(Value, kCFNumberSInt32Type, resourceData);
          if (LODWORD(resourceData[0].__pn_.__r_.__value_.__l.__data_) == 8)
          {
            *((_QWORD *)this + 20) = v5;
            CFRelease(DictionariesCacheURL);
            _ReleaseLockOfCacheFile(v4);
            Mutable = (__CFDictionary *)*((_QWORD *)this + 20);
LABEL_11:
            *((_BYTE *)this + 152) = 1;
            return Mutable;
          }
          CFURLGetFileSystemRepresentation(DictionariesCacheURL, 1u, (UInt8 *)resourceData, 1024);
          remove(resourceData, v7);
          CFRelease(v5);
        }
      }
    }
    CFRelease(DictionariesCacheURL);
    _ReleaseLockOfCacheFile(v4);
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    resourceData[0].__pn_.__r_.__value_.__r.__words[0] = 8;
    v8 = CFNumberCreate(0, kCFNumberCFIndexType, resourceData);
    CFDictionaryAddValue(Mutable, CFSTR("cache version"), v8);
    CFRelease(v8);
    *((_QWORD *)this + 20) = Mutable;
    goto LABEL_11;
  }
  return Mutable;
}

CFArrayRef DCSEnvironment::createDictionaryPathArray(DCSEnvironment *this)
{
  CFArrayRef v1;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cf[0] = CFStringCreateWithCString(0, "/Library/Dictionaries", 0x8000100u);
  v1 = CFArrayCreate(0, cf, 1, MEMORY[0x1E0C9B378]);
  if (cf[0])
    CFRelease(cf[0]);
  return v1;
}

uint64_t DCSEnvironment::checkDirectoryTimeStamp(DCSEnvironment *this, const __CFString *a2, const __CFNumber *a3, const __CFNumber **a4)
{
  if (a4)
    *a4 = 0;
  return 1;
}

uint64_t CollectDictionariesOnDiskCallback(char *a1, int a2, __CFSet *a3)
{
  size_t v5;
  const __CFURL *v6;
  CFStringRef v7;
  DCSDictionaryManager *v8;
  const void *v9;
  const void *v10;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  v5 = strlen(a1);
  if (strrchr(a1, 46) && (v5 < 6 || strcmp(&a1[v5 - 6], ".lproj")))
  {
    MEMORY[0x1E0C80A78]();
    strlcpy((char *)v12 - ((v5 + 271) & 0xFFFFFFFFFFFFFFF0), a1, v5 + 256);
    strlcat((char *)v12 - ((v5 + 271) & 0xFFFFFFFFFFFFFFF0), "/Contents/Info.plist", v5 + 256);
    if (ItemExistsAtPath((const char *)v12 - ((v5 + 271) & 0xFFFFFFFFFFFFFFF0), 0))
    {
      v6 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)a1, v5, 1u);
      v7 = CFURLCopyFileSystemPath(v6, kCFURLPOSIXPathStyle);
      v8 = (DCSDictionaryManager *)SyncSingleton<DCSDictionaryManager>::instance();
      v9 = (const void *)DCSDictionaryManager::dictionary(v8, v6, 0, 0);
      if (v9)
      {
        v10 = v9;
        CFSetAddValue(a3, v9);
        CFRelease(v10);
      }
      CFRelease(v6);
      CFRelease(v7);
    }
    return 0;
  }
  return 1;
}

void DCSEnvironment::checkSavedDictionaryPrefs(DCSEnvironment *this, CFSetRef theSet)
{
  CFIndex Count;
  const void **v5;
  const void **v6;
  DCSDictionary *v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const void *Value;
  const void *v11;
  const __CFString *v12;
  const __CFDictionary *DictionaryPreference;
  const __CFDictionary *v14;
  const void *v15;
  const void *v16;
  __CFDictionary *v17;
  const __CFDictionary *v18;

  Count = CFSetGetCount(theSet);
  v5 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
  CFSetGetValues(theSet, v5);
  if (Count >= 1)
  {
    v6 = v5;
    do
    {
      if (*v6)
        v7 = (DCSDictionary *)*((_QWORD *)*v6 + 2);
      else
        v7 = 0;
      v8 = (const __CFDictionary *)DCSDictionary::defaultPreference(v7);
      if (v8)
      {
        v9 = v8;
        Value = CFDictionaryGetValue(v8, CFSTR("version"));
        if (Value)
        {
          v11 = Value;
          v12 = (const __CFString *)DCSDictionary::identifier(v7);
          DictionaryPreference = (const __CFDictionary *)DCSEnvironment::getDictionaryPreference(this, v12);
          if (DictionaryPreference)
          {
            v14 = DictionaryPreference;
            v15 = CFDictionaryGetValue(DictionaryPreference, CFSTR("version"));
            if (v15)
            {
              if (!CFEqual(v11, v15))
              {
                v16 = (const void *)DCSDictionary::migrateOldPreference(v7, v14);
                pthread_mutex_lock((pthread_mutex_t *)((char *)this + 392));
                v17 = (__CFDictionary *)*((_QWORD *)this + 11);
                v18 = DCSDictionary::identifier(v7);
                if (v16)
                {
                  CFDictionarySetValue(v17, v18, v16);
                  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
                  DCSDictionary::setPreference(v7, (const __CFDictionary *)v16);
                  CFRelease(v16);
                }
                else
                {
                  CFDictionaryRemoveValue(v17, v18);
                  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
                  DCSDictionary::setPreference(v7, v9);
                }
              }
            }
          }
        }
      }
      ++v6;
      --Count;
    }
    while (Count);
  }
  free(v5);
}

uint64_t DCSEnvironment::updateDictionaryCacheInfo(uint64_t this, const __CFURL *a2, const __CFDictionary *a3)
{
  CFDictionaryRef *v5;
  pthread_mutex_t *v6;
  __CFDictionary *Value;
  const __CFDictionary *v8;
  __CFDictionary *v9;
  CFStringRef v10;

  if (a2)
  {
    v5 = (CFDictionaryRef *)this;
    v6 = (pthread_mutex_t *)(this + 520);
    pthread_mutex_lock((pthread_mutex_t *)(this + 520));
    if (DCSEnvironment::updateDictionaryCacheInfo(__CFURL const*,__CFDictionary const*)::_CacheInfoModified == 1)
    {
      Value = (__CFDictionary *)CFDictionaryGetValue(v5[20], CFSTR("dictionaries"));
    }
    else
    {
      DCSEnvironment::cachedDictionariesInfo_internal((DCSEnvironment *)v5);
      v8 = (const __CFDictionary *)CFDictionaryGetValue(v5[20], CFSTR("dictionaries"));
      if (v8)
        Value = CFDictionaryCreateMutableCopy(0, 0, v8);
      else
        Value = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    }
    v9 = Value;
    v10 = CFURLCopyFileSystemPath(a2, kCFURLPOSIXPathStyle);
    if (a3)
      CFDictionarySetValue(v9, v10, a3);
    else
      CFDictionaryRemoveValue(v9, v10);
    CFRelease(v10);
    if ((DCSEnvironment::updateDictionaryCacheInfo(__CFURL const*,__CFDictionary const*)::_CacheInfoModified & 1) == 0)
    {
      CFDictionarySetValue(v5[20], CFSTR("dictionaries"), v9);
      CFRelease(v9);
      DCSEnvironment::updateDictionaryCacheInfo(__CFURL const*,__CFDictionary const*)::_CacheInfoModified = 1;
    }
    DCSEnvironment::setDelayedWriteCacheTask((DCSEnvironment *)v5);
    return pthread_mutex_unlock(v6);
  }
  return this;
}

void DCSEnvironment::setDelayedWriteCacheTask(DCSEnvironment *this)
{
  __CFRunLoopObserver *v2;
  __CFRunLoop *Main;
  CFRunLoopObserverContext context;

  if (!*((_BYTE *)this + 153))
  {
    context.version = 0;
    context.info = this;
    memset(&context.retain, 0, 24);
    v2 = CFRunLoopObserverCreate(0, 0x20uLL, 0, 0, (CFRunLoopObserverCallBack)_DictionaryCacheChangedCallback, &context);
    Main = CFRunLoopGetMain();
    CFRunLoopAddObserver(Main, v2, (CFRunLoopMode)*MEMORY[0x1E0C9B270]);
    *((_BYTE *)this + 153) = 1;
  }
}

uint64_t DCSEnvironment::delayedWriteDictionariesCache(DCSEnvironment *this)
{
  pthread_mutex_t *v2;
  DCSEnvironment *v3;
  const __CFURL *DictionariesCacheURL;
  uint64_t v6;
  uint64_t v7;
  __CFWriteStream *v8;
  __CFWriteStream *v9;

  v2 = (pthread_mutex_t *)((char *)this + 520);
  v3 = (DCSEnvironment *)pthread_mutex_trylock((pthread_mutex_t *)((char *)this + 520));
  if ((_DWORD)v3)
  {
    *((_BYTE *)this + 153) = 0;
    return DCSEnvironment::setDelayedWriteCacheTask(this);
  }
  else
  {
    DictionariesCacheURL = DCSEnvironment::createDictionariesCacheURL(v3);
    v6 = _AcquireLockOfCacheFile(DictionariesCacheURL);
    if ((_DWORD)v6 != -1)
    {
      v7 = v6;
      v8 = CFWriteStreamCreateWithFile(0, DictionariesCacheURL);
      if (v8)
      {
        v9 = v8;
        if (CFWriteStreamOpen(v8))
        {
          CFPropertyListWriteToStream(*((CFPropertyListRef *)this + 20), v9, kCFPropertyListBinaryFormat_v1_0, 0);
          CFWriteStreamClose(v9);
        }
        CFRelease(v9);
      }
      _ReleaseLockOfCacheFile(v7);
    }
    CFRelease(DictionariesCacheURL);
    *((_BYTE *)this + 153) = 0;
    return pthread_mutex_unlock(v2);
  }
}

const __CFURL *DCSEnvironment::createDictionariesCacheURL(DCSEnvironment *this)
{
  const __CFArray *v1;
  const __CFURL *ValueAtIndex;
  __CFBundle *MainBundle;
  CFStringRef Identifier;
  const __CFString *v5;
  const __CFURL *v6;
  const __CFURL *PathComponent;
  UInt8 buffer[1024];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v1 = (const __CFArray *)CFCopySearchPathForDirectoriesInDomains();
  if (!CFArrayGetCount(v1))
    DCSEnvironment::createDictionariesCacheURL();
  ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v1, 0);
  MainBundle = CFBundleGetMainBundle();
  Identifier = CFBundleGetIdentifier(MainBundle);
  v5 = CFStringCreateWithFormat(0, 0, CFSTR("Caches/%@/com.apple.DictionaryServices/%@"), Identifier, CFSTR("DictionaryCache.plist"));
  v6 = CFURLCreateCopyAppendingPathComponent(0, ValueAtIndex, v5, 0);
  CFRelease(v1);
  CFRelease(v5);
  if (!ItemExistsAtURL(v6))
  {
    PathComponent = CFURLCreateCopyDeletingLastPathComponent(0, v6);
    if (!ItemExistsAtURL(PathComponent))
    {
      CFURLGetFileSystemRepresentation(PathComponent, 1u, buffer, 1024);
      mkdir((const char *)buffer, 0x1FFu);
    }
    CFRelease(PathComponent);
  }
  return v6;
}

uint64_t _AcquireLockOfCacheFile(CFURLRef url)
{
  const __CFURL *PathComponent;
  uint64_t v2;
  uint64_t v3;
  UInt8 buffer[1024];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  PathComponent = CFURLCreateCopyDeletingLastPathComponent(0, url);
  CFURLGetFileSystemRepresentation(PathComponent, 1u, buffer, 1024);
  strlcat((char *)buffer, "/.lockfile", 0x400uLL);
  CFRelease(PathComponent);
  v2 = open((const char *)buffer, 514, 511);
  v3 = v2;
  if ((_DWORD)v2 != -1 && flock(v2, 2))
  {
    close(v3);
    return 0xFFFFFFFFLL;
  }
  return v3;
}

uint64_t _ReleaseLockOfCacheFile(uint64_t result)
{
  int v1;

  if ((_DWORD)result != -1)
  {
    v1 = result;
    flock(result, 8);
    return close(v1);
  }
  return result;
}

void DCSEnvironment::logUsageTrackingInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  const __CFDictionary *Identifier;
  const __CFString *v6;
  DCSUsageTrackingCoreAnalyticsLogging *v7;
  const __CFString *v8;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  uint64_t v11;
  const char *v12;
  CFIndex v13;
  const char *v14;
  CFIndex v15;
  CFStringRef Copy;
  DCSDictionary *v17;
  int found;
  const __CFArray *Languages;
  const __CFArray *v20;
  CFIndex Count;
  CFIndex v23;
  const __CFDictionary *ValueAtIndex;
  const __CFString *Value;
  CFStringRef v26;
  CFIndex v27;
  CFIndex v28;
  char *v29;
  CFIndex v30;
  const __CFArray *CurrentPreferredLanguages;
  const __CFString *v32;
  CFIndex v33;
  CFIndex v34;
  char *v35;
  CFIndex v36;
  _QWORD block[7];
  CFRange result;
  uint64_t v39;
  CFRange v40;
  CFRange v41;

  v39 = *MEMORY[0x1E0C80C00];
  v3 = DCSRecord::dictionaryRef(*(DCSRecord **)(a2 + 16));
  if (v3)
  {
    v4 = v3;
    Identifier = DCSDictionaryGetIdentifier(v3);
    if (Identifier)
    {
      v6 = (const __CFString *)Identifier;
      v7 = (DCSUsageTrackingCoreAnalyticsLogging *)operator new();
      DCSUsageTrackingCoreAnalyticsLogging::DCSUsageTrackingCoreAnalyticsLogging(v7);
      (*(void (**)(DCSUsageTrackingCoreAnalyticsLogging *, uint64_t))(*(_QWORD *)v7 + 16))(v7, 1);
      v8 = *(const __CFString **)(a1 + 584);
      if (v8)
      {
        Length = CFStringGetLength(v8);
        MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
        MEMORY[0x1E0C80A78](MaximumSizeForEncoding);
        v12 = (char *)block - v11;
        if (CFStringGetCString(*(CFStringRef *)(a1 + 584), (char *)block - v11, v13, 0x8000100u))
          v14 = v12;
        else
          v14 = "Unknown";
        (*(void (**)(DCSUsageTrackingCoreAnalyticsLogging *, const char *))(*(_QWORD *)v7 + 24))(v7, v14);
      }
      v15 = CFStringGetLength(v6);
      v40.location = 0;
      v40.length = v15;
      if (!CFStringFindWithOptions(v6, CFSTR("com.apple.dictionary."), v40, 0, &result) || result.location)
      {
        Copy = CFStringCreateCopy(0, v6);
      }
      else
      {
        v41.location = result.length;
        v41.length = v15 - result.length;
        Copy = CFStringCreateWithSubstring(0, v6, v41);
        v17 = *(DCSDictionary **)(v4 + 16);
        if ((DCSDictionary::isNetworkDictionary(v17) & 1) == 0)
        {
          found = DCSDictionary::languageDirectionOfFoundRecord((uint64_t)v17);
          Languages = DCSDictionaryGetLanguages(v4);
          v20 = Languages;
          if (Languages)
          {
            Count = CFArrayGetCount(Languages);
            v23 = found == 1 && Count == 2;
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v20, v23);
            Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("DCSDictionaryIndexLanguage"));
          }
          else
          {
            Value = &stru_1E8B587B0;
          }
          v26 = CFStringCreateWithFormat(0, 0, CFSTR("%@:[%@]"), Copy, Value);
          CFRelease(Copy);
          Copy = v26;
        }
      }
      v27 = CFStringGetLength(Copy);
      v28 = CFStringGetMaximumSizeForEncoding(v27, 0x8000100u);
      v29 = (char *)block - ((MEMORY[0x1E0C80A78](v28) + 16) & 0xFFFFFFFFFFFFFFF0);
      CFStringGetCString(Copy, v29, v30, 0x8000100u);
      (*(void (**)(DCSUsageTrackingCoreAnalyticsLogging *, char *))(*(_QWORD *)v7 + 32))(v7, v29);
      CFRelease(Copy);
      CurrentPreferredLanguages = (const __CFArray *)DCSEnvironment::getCurrentPreferredLanguages((DCSEnvironment *)a1, 0);
      if (CFArrayGetCount(CurrentPreferredLanguages) >= 1)
      {
        v32 = (const __CFString *)CFArrayGetValueAtIndex(CurrentPreferredLanguages, 0);
        v33 = CFStringGetLength(v32);
        v34 = CFStringGetMaximumSizeForEncoding(v33, 0x8000100u);
        v35 = (char *)block - ((MEMORY[0x1E0C80A78](v34) + 16) & 0xFFFFFFFFFFFFFFF0);
        CFStringGetCString(v32, v35, v36, 0x8000100u);
        (*(void (**)(DCSUsageTrackingCoreAnalyticsLogging *, char *))(*(_QWORD *)v7 + 40))(v7, v35);
      }
      if (!*(_QWORD *)(a1 + 600))
        *(_QWORD *)(a1 + 600) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], 0);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = ___ZN14DCSEnvironment20logUsageTrackingInfoEPK11__DCSRecord_block_invoke;
      block[3] = &__block_descriptor_tmp_57;
      block[4] = a1;
      block[5] = v6;
      block[6] = v7;
      dispatch_async(MEMORY[0x1E0C80D38], block);
    }
  }
}

void sub_1CDF6F73C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x81C40803F642BLL);
  _Unwind_Resume(a1);
}

void ___ZN14DCSEnvironment20logUsageTrackingInfoEPK11__DCSRecord_block_invoke(uint64_t a1)
{
  uint64_t v2;
  char *v3;
  dispatch_time_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[8];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = (char *)CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 600), *(const void **)(a1 + 40)) + 1;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(v2 + 600), *(const void **)(a1 + 40), v3);
  v4 = dispatch_time(0, 1000000000);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v7[2] = ___ZN14DCSEnvironment20logUsageTrackingInfoEPK11__DCSRecord_block_invoke_2;
  v7[3] = &__block_descriptor_tmp_56;
  v5 = *(_QWORD *)(a1 + 40);
  v6 = *(_QWORD *)(a1 + 48);
  v7[4] = v2;
  v7[5] = v5;
  v7[6] = v3;
  v7[7] = v6;
  dispatch_after(v4, MEMORY[0x1E0C80D38], v7);
}

uint64_t ___ZN14DCSEnvironment20logUsageTrackingInfoEPK11__DCSRecord_block_invoke_2(uint64_t a1)
{
  uint64_t result;

  if (*(const void **)(a1 + 48) == CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 600), *(const void **)(a1 + 40)))(*(void (**)(_QWORD))(**(_QWORD **)(a1 + 56) + 48))(*(_QWORD *)(a1 + 56));
  result = *(_QWORD *)(a1 + 56);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void DCSEnvironment::storeActiveDictionaryLanguage(CFDictionaryRef *this, CFStringRef theString1)
{
  CFIndex Count;
  unint64_t v5;
  const void **v6;
  size_t v7;
  const void *v8;
  const void *v9;
  _BYTE v10[7];
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (theString1 && CFStringCompare(theString1, CFSTR("*"), 0) && !CFDictionaryGetValue(this[24], theString1))
  {
    Count = CFDictionaryGetCount(this[24]);
    MEMORY[0x1E0C80A78](Count);
    v6 = (const void **)&v10[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0)];
    if (v5 >= 0x200)
      v7 = 512;
    else
      v7 = v5;
    bzero(&v10[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0)], v7);
    CFDictionaryGetKeysAndValues(this[24], v6, 0);
    v8 = (const void *)*MEMORY[0x1E0C9AE40];
    if (Count >= 1)
    {
      v9 = (const void *)*MEMORY[0x1E0C9AE50];
      do
      {
        v11 = 0;
        CompareLanguageCode(theString1, (CFStringRef)*v6, &v11);
        if (v11)
        {
          CFDictionarySetValue(this[24], *v6, v9);
          v8 = v9;
        }
        ++v6;
        --Count;
      }
      while (Count);
    }
    CFDictionarySetValue(this[24], theString1, v8);
  }
}

const void *DCSEnvironment::copyPrimaryLanguageOfDictionaryURL(DCSEnvironment *this, const __CFURL *a2)
{
  __CFBundle *v2;
  __CFBundle *v3;
  const __CFDictionary *InfoDictionary;
  const void *Value;
  const void *v6;

  v2 = CFBundleCreate(0, a2);
  if (!v2)
    return 0;
  v3 = v2;
  InfoDictionary = CFBundleGetInfoDictionary(v2);
  Value = CFDictionaryGetValue(InfoDictionary, CFSTR("DCSDictionaryPrimaryLanguage"));
  v6 = Value;
  if (Value)
    CFRetain(Value);
  CFRelease(v3);
  return v6;
}

__CFArray *DCSEnvironment::createDefaultDictionaryList(DCSEnvironment *this)
{
  __CFBundle *FrameworkBundle;
  const __CFDictionary *InfoDictionary;
  const __CFArray *Value;

  FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(this);
  InfoDictionary = CFBundleGetInfoDictionary(FrameworkBundle);
  Value = (const __CFArray *)CFDictionaryGetValue(InfoDictionary, CFSTR("DCSAppleDictionaries"));
  return DCSEnvironment::createMatchedDictionariesForPreferredLanguages(this, Value, 0, 1);
}

__CFArray *DCSEnvironment::createMatchedDictionariesForPreferredLanguages(DCSEnvironment *this, const __CFArray *a2, int a3, int a4)
{
  const CFArrayCallBacks *v6;
  __CFArray *Mutable;
  __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  const CFArrayCallBacks *v11;
  const __CFString *ValueAtIndex;
  const __CFURL *v13;
  const __CFURL *v14;
  DCSEnvironment *v15;
  const void *v16;
  const void *v17;
  void *Value;
  const void *CurrentPreferredLanguages;
  const __CFArray *v20;
  const __CFDictionary *v21;
  CFIndex v22;
  unint64_t v23;
  size_t v24;
  uint64_t v25;
  CFIndex v26;
  CFIndex v27;
  CFIndex i;
  const __CFString *v29;
  const __CFString *v32;
  CFArrayRef *v33;
  CFStringRef *v34;
  CFIndex v35;
  const __CFArray *v36;
  DCSEnvironment *v37;
  uint64_t v38;
  const __CFArray *v39;
  const __CFArray *v40;
  CFIndex j;
  const void *v42;
  uint64_t v44;
  int v45;
  CFArrayRef v46;
  const __CFArray *v47;
  CFIndex v48;
  const __CFDictionary *v49;
  int v50;
  CFArrayRef *v51;
  CFStringRef *v52;
  void *values;
  uint64_t v54[2];
  CFRange v55;
  CFRange v56;
  CFRange v57;

  v50 = a4;
  v45 = a3;
  v54[1] = *MEMORY[0x1E0C80C00];
  v6 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v8 = CFArrayCreateMutable(0, 0, v6);
  Count = CFArrayGetCount(a2);
  v48 = Count;
  v49 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Count >= 1)
  {
    v10 = 0;
    v11 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    do
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v10);
      v13 = CFURLCreateWithFileSystemPath(0, ValueAtIndex, kCFURLPOSIXPathStyle, 1u);
      if (v13)
      {
        v14 = v13;
        v15 = (DCSEnvironment *)ItemExistsAtURL(v13);
        if ((_DWORD)v15)
        {
          v16 = DCSEnvironment::copyPrimaryLanguageOfDictionaryURL(v15, v14);
          if (v16)
          {
            v17 = v16;
            Value = (void *)CFDictionaryGetValue(v49, v16);
            if (!Value)
            {
              Value = CFArrayCreateMutable(0, 0, v11);
              CFDictionarySetValue(v49, v17, Value);
              CFRelease(Value);
            }
            CFArrayAppendValue((CFMutableArrayRef)Value, ValueAtIndex);
            CFRelease(v17);
            Count = v48;
          }
          else
          {
            CFArrayAppendValue(v8, ValueAtIndex);
          }
        }
        CFRelease(v14);
      }
      ++v10;
    }
    while (Count != v10);
  }
  v46 = v8;
  v47 = a2;
  v54[0] = 0;
  CurrentPreferredLanguages = (const void *)DCSEnvironment::getCurrentPreferredLanguages(this, v54);
  v20 = (const __CFArray *)CFRetain(CurrentPreferredLanguages);
  v21 = v49;
  v22 = CFDictionaryGetCount(v49);
  v44 = (uint64_t)&v44;
  MEMORY[0x1E0C80A78](v22);
  v23 = (8 * v22 + 15) & 0xFFFFFFFFFFFFFFF0;
  if ((unint64_t)(8 * v22) >= 0x200)
    v24 = 512;
  else
    v24 = 8 * v22;
  bzero((char *)&v44 - v23, v24);
  MEMORY[0x1E0C80A78](v25);
  bzero((char *)&v44 - v23, v24);
  v51 = (CFArrayRef *)((char *)&v44 - v23);
  v52 = (CFStringRef *)((char *)&v44 - v23);
  CFDictionaryGetKeysAndValues(v21, (const void **)((char *)&v44 - v23), (const void **)((char *)&v44 - v23));
  while (1)
  {
    v26 = CFArrayGetCount(v20);
    if (v26 >= 1)
    {
      v27 = v26;
      for (i = 0; i != v27; ++i)
      {
        v29 = (const __CFString *)CFArrayGetValueAtIndex(v20, i);
        if ((i != v54[0] || i == 0) && v22 >= 1)
        {
          v32 = v29;
          v33 = v51;
          v34 = v52;
          v35 = v22;
          do
          {
            if (CompareLanguageCode(v32, *v34, 0))
            {
              v36 = *v33;
              v56.length = CFArrayGetCount(*v33);
              v56.location = 0;
              CFArrayAppendArray(Mutable, v36, v56);
            }
            ++v33;
            ++v34;
            --v35;
          }
          while (v35);
        }
      }
    }
    if ((v50 & 1) == 0)
      break;
    v37 = (DCSEnvironment *)CFArrayGetCount(Mutable);
    if ((uint64_t)v37 > 0)
      break;
    if (v20)
      CFRelease(v20);
    values = 0;
    values = (void *)DCSEnvironment::getFallbackEnglishLanguage(v37);
    v20 = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    v50 = 0;
  }
  v38 = v48;
  if (v20)
    CFRelease(v20);
  v40 = v46;
  v39 = v47;
  if (v45)
  {
    if (v38 >= 1)
    {
      for (j = 0; j != v38; ++j)
      {
        v42 = CFArrayGetValueAtIndex(v39, j);
        v55.length = CFArrayGetCount(Mutable);
        v55.location = 0;
        if (!CFArrayContainsValue(Mutable, v55, v42))
          CFArrayAppendValue(Mutable, v42);
      }
    }
  }
  else
  {
    v57.length = CFArrayGetCount(v46);
    v57.location = 0;
    CFArrayAppendArray(Mutable, v40, v57);
  }
  CFRelease(v40);
  CFRelease(v49);
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

const __CFArray *DCSEnvironment::appendNewReleasedDictionaries(DCSEnvironment *this, const __CFArray *a2, __CFArray *a3)
{
  __CFArray *updated;
  const __CFArray *v6;
  __CFBundle *FrameworkBundle;
  const __CFDictionary *InfoDictionary;
  const __CFDictionary *Value;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v12;
  CFIndex i;
  const __CFNumber *ValueAtIndex;
  CFStringRef v15;
  const __CFArray *v16;
  const __CFArray *v17;
  const __CFString *CurrentPreferredLanguages;
  const __CFArray *v19;
  uint64_t v20;
  const __CFArray *v21;
  const __CFArray *v22;
  CFIndex v23;
  CFIndex v24;
  CFIndex v25;
  CFIndex v26;
  const __CFDictionary *v27;
  const __CFDictionary *v28;
  const __CFString *v29;
  const __CFString *CurrentSystemLanguage;
  __CFArray *v31;
  CFMutableArrayRef MutableCopy;
  const __CFArray *v33;
  CFIndex v34;
  CFIndex v35;
  const __CFDictionary *v36;
  const __CFDictionary *v37;
  const void *v38;
  const __CFString *v39;
  const __CFString *v40;
  const __CFString *v41;
  CFIndex v42;
  const __CFArray *v44;
  uint64_t valuePtr;
  CFRange v47;
  CFRange v48;
  CFRange v49;

  updated = DCSMACopyAndUpdateDictionaryCompatibilityVersionHistory();
  if (updated)
  {
    v6 = updated;
    FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(this);
    InfoDictionary = CFBundleGetInfoDictionary(FrameworkBundle);
    Value = (const __CFDictionary *)CFDictionaryGetValue(InfoDictionary, CFSTR("DCSNewReleasedDictionaries"));
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    Count = CFArrayGetCount(v6);
    if (Count >= 1)
    {
      v12 = Count;
      for (i = 0; i != v12; ++i)
      {
        valuePtr = 0;
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v6, i);
        if (CFNumberGetValue(ValueAtIndex, kCFNumberCFIndexType, &valuePtr))
        {
          v15 = CFStringCreateWithFormat(0, 0, CFSTR("%ld"), valuePtr);
          if (Value)
          {
            v16 = (const __CFArray *)CFDictionaryGetValue(Value, v15);
            if (v16)
            {
              v17 = v16;
              v49.length = CFArrayGetCount(v16);
              v49.location = 0;
              CFArrayAppendArray(Mutable, v17, v49);
            }
          }
          CFRelease(v15);
        }
      }
    }
    CFRelease(v6);
    if (!CFArrayGetCount(Mutable))
    {
      v31 = Mutable;
      goto LABEL_40;
    }
    CurrentPreferredLanguages = (const __CFString *)DCSEnvironment::getCurrentPreferredLanguages(this, 0);
    v19 = (const __CFArray *)DCSEnvironment::copyInactiveDictionaries(Mutable, CurrentPreferredLanguages);
    CFRelease(Mutable);
    if (v19)
    {
      v20 = CFArrayGetCount(v19);
      v21 = (const __CFArray *)DCSEnvironment::copyInactiveDictionaries(0, 0);
      if (v21)
      {
        v22 = v21;
        v23 = CFArrayGetCount(v21);
        if (v23 < 1)
        {
          v26 = 0;
        }
        else
        {
          v24 = v23;
          v25 = 0;
          v26 = 0;
          do
          {
            v27 = (const __CFDictionary *)CFArrayGetValueAtIndex(v22, v25);
            v47.location = 0;
            v47.length = v20;
            if (!CFArrayContainsValue(v19, v47, v27))
            {
              v28 = (const __CFDictionary *)DCSMAGetAssetAttributes(v27);
              v29 = (const __CFString *)CFDictionaryGetValue(v28, CFSTR("Language"));
              CurrentSystemLanguage = DCSEnvironment::getCurrentSystemLanguage(this);
              v26 += CompareLanguageCode(v29, CurrentSystemLanguage, 0);
            }
            ++v25;
          }
          while (v24 != v25);
        }
        CFRelease(v22);
      }
      else
      {
        v26 = 0;
      }
      v44 = a2;
      if (a2)
        MutableCopy = CFArrayCreateMutableCopy(0, 0, a2);
      else
        MutableCopy = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      v33 = MutableCopy;
      if (v20 >= 1)
      {
        v34 = 0;
        v35 = v26;
        do
        {
          v36 = (const __CFDictionary *)CFArrayGetValueAtIndex(v19, v34);
          v48.length = CFArrayGetCount(v33);
          v48.location = 0;
          if (!CFArrayContainsValue(v33, v48, v36))
          {
            v37 = (const __CFDictionary *)DCSMAGetAssetAttributes(v36);
            v38 = CFDictionaryGetValue(v37, CFSTR("DictionaryIdentifier"));
            v39 = (const __CFString *)CFDictionaryGetValue(v37, CFSTR("Language"));
            if (v26
              || (v40 = v39,
                  v41 = DCSEnvironment::getCurrentSystemLanguage(this),
                  !CompareLanguageCode(v40, v41, 0)))
            {
              CFArrayAppendValue(v33, v36);
              CFArrayAppendValue(a3, v38);
            }
            else
            {
              CFArrayInsertValueAtIndex(v33, v35, v36);
              CFArrayInsertValueAtIndex(a3, v35++, v38);
            }
          }
          ++v34;
        }
        while (v20 != v34);
      }
      CFRelease(v19);
      a2 = v44;
      if (v44)
      {
        v42 = CFArrayGetCount(v44);
        if (CFArrayGetCount(v33) != v42)
        {
          CFRelease(v44);
          return v33;
        }
      }
      else if (CFArrayGetCount(v33))
      {
        return v33;
      }
      v31 = v33;
LABEL_40:
      CFRelease(v31);
    }
  }
  return a2;
}

void _DictionaryCacheChangedCallback(__CFRunLoopObserver *a1, unint64_t a2, DCSEnvironment *this)
{
  DCSEnvironment::delayedWriteDictionariesCache(this);
  CFRunLoopObserverInvalidate(a1);
  CFRelease(a1);
}

CFURLRef DCSEnvironment::copyWikipediaDictionaryURL(DCSEnvironment *this)
{
  __CFBundle *FrameworkBundle;

  FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(this);
  return CFBundleCopyResourceURL(FrameworkBundle, CFSTR("Wikipedia"), CFSTR("wikipediadictionary"), 0);
}

void DCSIDXDictionary::DCSIDXDictionary(DCSIDXDictionary *this, const __CFURL *a2)
{
  uint64_t v3;

  DCSBaseDictionary::DCSBaseDictionary(this, a2);
  *(_QWORD *)v3 = &off_1E8B567D0;
  *(_QWORD *)(v3 + 256) = 0;
  *(_QWORD *)(v3 + 264) = 0;
  *(_QWORD *)(v3 + 248) = 0;
  *(_BYTE *)(v3 + 272) = 0;
  *(_QWORD *)(v3 + 280) = 0;
  *(_QWORD *)(v3 + 288) = 0;
  *(_QWORD *)(v3 + 296) = 0;
  *(_QWORD *)(v3 + 304) = -1;
  *((_QWORD *)this + 39) = 0;
  *((_QWORD *)this + 40) = 0;
  pthread_mutex_init((pthread_mutex_t *)(v3 + 328), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 392), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 456), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 520), 0);
}

void sub_1CDF702D8(_Unwind_Exception *a1)
{
  DCSBaseDictionary *v1;

  DCSBaseDictionary::~DCSBaseDictionary(v1);
  _Unwind_Resume(a1);
}

void DCSIDXDictionary::~DCSIDXDictionary(DCSIDXDictionary *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  void *v6;
  const void *v7;
  const void *v8;
  uint64_t v9;

  *(_QWORD *)this = &off_1E8B567D0;
  v2 = (const void *)*((_QWORD *)this + 37);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 31);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 32);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 33);
  if (v5)
    CFRelease(v5);
  v6 = (void *)*((_QWORD *)this + 36);
  if (v6)
    free(v6);
  v7 = (const void *)*((_QWORD *)this + 39);
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 38);
  if ((unint64_t)v8 + 1 >= 2)
    CFRelease(v8);
  v9 = *((_QWORD *)this + 40);
  if (v9)
  {
    DCSDictionaryImageReplacement::~DCSDictionaryImageReplacement(*((DCSDictionaryImageReplacement **)this + 40));
    MEMORY[0x1D17BC79C](v9, 0x10F0C403D00FC33);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 328));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 392));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 456));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 520));
  DCSBaseDictionary::~DCSBaseDictionary(this);
}

{
  DCSIDXDictionary::~DCSIDXDictionary(this);
  JUMPOUT(0x1D17BC79CLL);
}

void sub_1CDF703C4(_Unwind_Exception *a1)
{
  DCSBaseDictionary *v1;
  uint64_t v2;
  uint64_t v3;

  v3 = v2;
  MEMORY[0x1D17BC79C](v3, 0x10F0C403D00FC33);
  DCSBaseDictionary::~DCSBaseDictionary(v1);
  _Unwind_Resume(a1);
}

void sub_1CDF70438(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F1C40ECEE0193);
  _Unwind_Resume(a1);
}

_QWORD *DCSIDXDictionary::createSessionInfo(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  CFRunLoopObserverContext v6;

  v6.version = 0;
  memset(&v6.retain, 0, 24);
  v4 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
  *v4 = a1;
  v4[1] = a2;
  v6.info = v4;
  v4[2] = CFRunLoopObserverCreate(0, 0x20uLL, 0, 0, (CFRunLoopObserverCallBack)_RunLoopObserverCallBack, &v6);
  return v4;
}

void _RunLoopObserverCallBack(__CFRunLoopObserver *a1, unint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  const __CFArray *v4;
  CFTypeRef v5;
  CFIndex v6;

  v3 = a3[1];
  v4 = (const __CFArray *)(*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)*a3 + 296))(*a3, *(_QWORD *)(v3 + 56), *(_QWORD *)(v3 + 64), *(_QWORD *)(v3 + 72));
  v5 = CFRetain(*(CFTypeRef *)v3);
  v6 = CFGetRetainCount(v5);
  DCSSearchSession::didFindRecord((_QWORD *)v3, v4);
  if (v4)
    CFRelease(v4);
  if (CFGetRetainCount(v5) == v6)
    DCSSearchSession::didFinishSearch((DCSSearchSession *)v3, 0);
  CFRelease(v5);
}

void DCSIDXDictionary::releaseSessionInfo(DCSIDXDictionary *this, _QWORD *a2)
{
  const void *v3;

  v3 = (const void *)a2[2];
  if (v3)
    CFRelease(v3);
  free(a2);
}

void DCSIDXDictionary::scheduleSession(DCSIDXDictionary *this, CFRunLoopObserverRef *a2, CFRunLoopRef rl, CFRunLoopMode mode)
{
  CFRunLoopAddObserver(rl, a2[2], mode);
}

void DCSIDXDictionary::unscheduleSession(DCSIDXDictionary *this, CFRunLoopObserverRef *a2, CFRunLoopRef rl, CFRunLoopMode mode)
{
  CFRunLoopRemoveObserver(rl, a2[2], mode);
}

__CFArray *DCSIDXDictionary::searchByString(DCSIDXDictionary *this, const __CFString *a2, unint64_t a3, uint64_t a4)
{
  int v5;
  const __CFString *v6;
  const __CFArray *v8;
  __CFArray *result;
  const __CFArray *v10;
  const __CFArray *v11;
  CFIndex v12;
  const __CFString *v13;
  unint64_t v14;
  const __CFDictionary *ValueAtIndex;
  const __CFString *Value;
  const __CFString *v17;
  CFMutableStringRef MutableCopy;
  CFComparisonResult v19;
  unsigned int v20;
  char v21;
  const __CFString *v22;
  CFMutableStringRef v23;
  BOOL v24;
  __CFArray *v25;
  __CFArray *v26;
  const __CFArray *v27;
  const __CFArray *v28;
  CFIndex v29;
  const __CFString *v30;
  uint64_t v31;
  __CFString *v32;
  const __CFString *v33;
  const __CFLocale *v34;
  __CFArray *v35;
  __CFArray *v37;
  __CFArray *v38;
  __CFArray *v39;
  char v40;
  BOOL v41;
  int v42;
  CFMutableStringRef v44;
  __CFString *v45;
  __CFString *v46;
  const __CFArray *v47;
  CFIndex v48;
  CFIndex v49;
  CFIndex v50;
  const __CFString *v51;
  __CFArray *v52;
  CFIndex v53;
  __CFArray *v54;
  uint64_t v55;
  CFIndex v56;
  CFIndex i;
  DCSRecord **v58;
  DCSRecord **v59;
  DCSRecord *v60;
  __CFArray *v61;
  const __CFArray *v62;
  char v63;
  CFIndex Count;
  CFIndex v65;
  CFComparisonResult v66;
  const __CFString *v67;
  __CFArray *theArray;
  const __CFString *v69;
  __CFString *v70;
  __CFString *v71;
  int v72;
  const __CFString *v73;
  const __CFString *cf;
  char v75;
  __CFArray *v76;
  CFIndex v77;
  BOOL v78;
  _QWORD v79[7];
  CFRange v80;

  v5 = a3;
  v6 = a2;
  v79[0] = MEMORY[0x1E0C809B0];
  v79[1] = 0x40000000;
  v79[2] = ___ZN16DCSIDXDictionary14searchByStringEPK10__CFStringll_block_invoke;
  v79[3] = &__block_descriptor_tmp_1;
  v79[4] = this;
  v79[5] = (unsigned __int16)a3;
  v78 = 0;
  v8 = ___ZN16DCSIDXDictionary14searchByStringEPK10__CFStringll_block_invoke((uint64_t)v79, a2, a3, a4, &v78);
  if (v78)
    return v8;
  v10 = (const __CFArray *)(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 96))(this);
  if (!v10)
    return v8;
  v11 = v10;
  Count = CFArrayGetCount(v10);
  if (Count < 1)
    return v8;
  v61 = v8;
  v12 = 0;
  v13 = 0;
  theArray = 0;
  v14 = *(_QWORD *)&v5 & 0x10000;
  v69 = v6;
  v62 = v11;
  while (2)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v11, v12);
    Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("DCSDictionaryIndexLanguage"));
    if (!Value)
    {
      v22 = v13;
      goto LABEL_78;
    }
    v17 = Value;
    v67 = v13;
    v65 = v12;
    MutableCopy = CFStringCreateMutableCopy(0, 0, v6);
    v19 = CFStringCompare(v17, CFSTR("ar"), 0);
    v66 = CFStringCompare(v17, CFSTR("he"), 0);
    v71 = (__CFString *)v17;
    v20 = _IsStopLemmatizeWordForLanguage(v6, v17);
    v21 = 0;
    v72 = v20 ^ 1;
    if (v19 == kCFCompareEqualTo && (v20 & 1) == 0)
    {
      if (ContainsLatinAlphabets(v6))
      {
        v21 = 0;
        v72 = 0;
      }
      else
      {
        v23 = CFStringCreateMutableCopy(0, 0, v6);
        ExtraNormalizeStringForArabic(v23, 0);
        if (CFStringCompare(v6, v23, 0))
        {
          theArray = DCSIDXDictionary::searchByString_internal(this, v23, v14, a4);
          v24 = theArray != 0;
          v72 = theArray == 0;
        }
        else
        {
          v24 = 0;
        }
        CFRelease(v23);
        v21 = v24;
      }
    }
    v63 = v21;
    v75 = v21;
    v25 = theArray;
    v73 = v67;
    cf = v6;
    v70 = MutableCopy;
    while (1)
    {
      if (!v72)
      {
        v73 = v67;
        v40 = v63;
        goto LABEL_49;
      }
      v26 = v25;
      v27 = DCSCopyLemmas((uint64_t)cf, v71);
      if (v27)
      {
        v28 = v27;
        v77 = CFArrayGetCount(v27);
        if (v77 < 1)
        {
          v76 = 0;
        }
        else
        {
          v29 = 0;
          v76 = 0;
          do
          {
            v30 = (const __CFString *)CFArrayGetValueAtIndex(v28, v29);
            v31 = 0;
            while (1)
            {
              v32 = CFStringCreateMutableCopy(0, 0, v30);
              v33 = v32;
              if (v31)
              {
                ExtraNormalizeStringForArabic(v32, 0);
              }
              else
              {
                v34 = (const __CFLocale *)(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 256))(this);
                DCSNormalizeSearchStringWithOptionsAndLocale(v33, 0, v34);
              }
              v35 = DCSIDXDictionary::searchByString_internal(this, v33, v14, a4);
              CFRelease(v33);
              if (v35)
                break;
              if (v19 | v31++)
                goto LABEL_35;
            }
            if (v19)
              v73 = (const __CFString *)CFRetain(cf);
            if (v76)
            {
              v80.length = CFArrayGetCount(v35);
              v80.location = 0;
              CFArrayAppendArray(v76, v35, v80);
            }
            else
            {
              v76 = CFArrayCreateMutableCopy(0, 0, v35);
            }
            CFRelease(v35);
            v75 = 1;
LABEL_35:
            ++v29;
          }
          while (v29 != v77);
        }
        CFRelease(v28);
        v6 = v69;
        MutableCopy = v70;
        v37 = v76;
      }
      else
      {
        MutableCopy = v70;
        v37 = v26;
      }
      if ((v75 & 1) != 0 || v19 || cf != v6)
      {
        v40 = v75;
        theArray = v37;
        goto LABEL_49;
      }
      v38 = v37;
      ExtraNormalizeStringForArabic(MutableCopy, 1);
      if (CFStringCompare(v6, MutableCopy, 0) == kCFCompareEqualTo)
        break;
      v39 = DCSIDXDictionary::searchByString_internal(this, MutableCopy, v14, a4);
      v75 = 0;
      v25 = 0;
      cf = MutableCopy;
      if (v39)
      {
        v40 = 1;
        theArray = v39;
        goto LABEL_49;
      }
    }
    v40 = v75;
    theArray = v38;
LABEL_49:
    if (v19)
      v41 = v66 == kCFCompareEqualTo;
    else
      v41 = 1;
    v42 = v41;
    if ((v72 & !v78 & ~v40) != 1 || v42 == 0)
    {
      v44 = MutableCopy;
LABEL_72:
      CFRelease(v44);
      v11 = v62;
      v12 = v65;
      goto LABEL_77;
    }
    v45 = CFStringCreateMutableCopy(0, 0, v6);
    v46 = v45;
    if (v19 == kCFCompareEqualTo)
      ExtraNormalizeStringForArabic(v45, 0);
    v47 = _CopyPossibleArabicHebrewStemList(v46, v71);
    CFRelease(v46);
    if (!v47)
    {
      v44 = v70;
      goto LABEL_72;
    }
    v48 = CFArrayGetCount(v47);
    if (v48 < 1)
      goto LABEL_76;
    v49 = v48;
    v50 = 0;
    while (1)
    {
      v51 = (const __CFString *)CFArrayGetValueAtIndex(v47, v50);
      if (CFStringGetLength(v51) >= 3)
        break;
LABEL_69:
      if (v49 == ++v50)
        goto LABEL_76;
    }
    v52 = DCSIDXDictionary::searchByString_internal(this, v51, v14, a4);
    if (!v52)
    {
      theArray = 0;
      goto LABEL_69;
    }
    theArray = v52;
    if (v19)
      v73 = (const __CFString *)CFRetain(v6);
    v40 = 1;
LABEL_76:
    v11 = v62;
    v12 = v65;
    CFRelease(v47);
    CFRelease(v70);
LABEL_77:
    v22 = v73;
    if ((v40 & 1) == 0)
    {
LABEL_78:
      ++v12;
      v13 = v22;
      if (v12 == Count)
        break;
      continue;
    }
    break;
  }
  if (theArray)
  {
    v53 = CFArrayGetCount(theArray);
    v54 = theArray;
    v55 = (uint64_t)v61;
    if (v53 >= 1)
    {
      v56 = v53;
      for (i = 0; i != v56; ++i)
      {
        v58 = (DCSRecord **)CFArrayGetValueAtIndex(theArray, i);
        v59 = v58;
        if (v22)
        {
          v60 = v58[2];
          DCSRecord::setHeadword(v60, v22);
          DCSRecord::setKeyString(v60, v22);
        }
        if (v61)
          CFArrayAppendValue(v61, v59);
      }
      v54 = theArray;
    }
    if (v22)
LABEL_89:
      CFRelease(v22);
  }
  else
  {
    v54 = 0;
    v55 = (uint64_t)v61;
    if (v22)
      goto LABEL_89;
  }
  if (v55)
    result = (__CFArray *)v55;
  else
    result = v54;
  if (v55)
  {
    if (theArray)
    {
      CFRelease(v54);
      return (__CFArray *)v55;
    }
  }
  return result;
}

__CFArray *DCSIDXDictionary::searchByString_internal(DCSIDXDictionary *this, const __CFString *a2, unint64_t a3, uint64_t a4)
{
  DCSIDXDictionary *v7;
  __CFArray *Mutable;
  unsigned __int8 v9;
  pthread_mutex_t *v10;
  DCSEnvironment *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t matched;
  uint64_t v25;
  uint64_t v26;
  const void *RecordRef;
  const void *v28;
  BOOL v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  __CFArray *v38;
  uint64_t v39;
  uint64_t v40;
  const void *v41;
  BOOL v42;
  char v43;
  uint64_t v44;
  BOOL v45;
  pthread_mutex_t *v47;
  pthread_mutex_t **v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53[2];

  v50 = a4;
  v53[1] = *MEMORY[0x1E0C80C00];
  DCSIDXDictionary::prepareTrieIndex((uint64_t)this);
  if (!*((_QWORD *)this + 31))
    return 0;
  v7 = this;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if ((v9 & 1) == 0
  {
    DCSIDXDictionary::searchByString_internal(__CFString const*,long,long)::methodString[0] = (uint64_t)CFSTR("IDXExactMatch");
    unk_1ED2CBCD0 = CFSTR("IDXPrefixMatch");
    qword_1ED2CBCD8 = (uint64_t)CFSTR("IDXCommonPrefixMatch");
    unk_1ED2CBCE0 = CFSTR("IDXWildcardMatch");
  }
  v10 = (pthread_mutex_t *)((char *)this + 328);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 328));
  if (IDXSetSearchString(*((_QWORD *)this + 31), a2, DCSIDXDictionary::searchByString_internal(__CFString const*,long,long)::methodString[(unsigned __int16)a3]))
  {
    v47 = (pthread_mutex_t *)((char *)this + 328);
    v11 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
    v51 = DCSEnvironment::parentalControlCensoringContents(v11);
    v12 = IDXSupportDataPtr(*((_QWORD *)this + 31));
    v13 = (uint64_t *)this;
    if ((_DWORD)v12)
    {
      v48 = &v47;
      v14 = 1024;
      if (v50)
        v14 = v50;
      v49 = v14;
      v15 = 8 * v14;
      MEMORY[0x1E0C80A78](v12);
      v16 = (v15 + 15) & 0xFFFFFFFFFFFFFFF0;
      if (v15 >= 0x200)
        v17 = 512;
      else
        v17 = v15;
      v18 = (char *)&v47 - v16;
      bzero((char *)&v47 - v16, v17);
      MEMORY[0x1E0C80A78](v19);
      v20 = (char *)&v47 - v16;
      v21 = 0;
      v22 = 0;
      v23 = (a3 >> 16) & 1;
      while (1)
      {
        matched = IDXGetMatchDataPtr(v13[31], v49, (uint64_t)v18, (uint64_t)v20);
        if (!matched)
          break;
        v25 = matched;
        if (matched >= 1)
        {
          v26 = 0;
          do
          {
            RecordRef = (const void *)DCSIDXDictionary::createRecordRef((DCSIDXDictionary *)v13, *(const unsigned __int8 **)&v18[8 * v26], *(_QWORD *)&v20[8 * v26], 0, v51, v23, v21 + v26 + 1);
            if (RecordRef)
            {
              v28 = RecordRef;
              CFArrayAppendValue(Mutable, RecordRef);
              CFRelease(v28);
              ++v22;
              if (v50)
                v29 = v22 < v50;
              else
                v29 = 1;
              v30 = !v29;
            }
            else
            {
              v30 = 0;
            }
            ++v26;
          }
          while ((v30 & 1) == 0 && v26 < v25);
          v21 += v26;
          if ((v30 & 1) != 0)
            break;
        }
      }
    }
    else
    {
      v31 = 0;
      v32 = 0;
      v53[0] = 0x20000;
      v33 = (a3 >> 16) & 1;
      do
      {
        v48 = &v47;
        MEMORY[0x1E0C80A78](v12);
        v35 = (char *)&v47 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0);
        v49 = v36;
        if (!(_BYTE)v36)
          v35 = (char *)malloc_type_malloc(v53[0], 0x8E56F5AAuLL);
        v52 = 0;
        while (1)
        {
          v12 = IDXGetMatchData(v13[31], v50, v53[0], (uint64_t)v35, (uint64_t)&v52, v53);
          v37 = v12;
          if (!v12)
            break;
          if (v12 >= 1)
          {
            v38 = Mutable;
            v39 = 0;
            v40 = 1;
            do
            {
              v12 = DCSIDXDictionary::createRecordRef(v7, (const unsigned __int8 *)&v35[*(_QWORD *)(v52 + v39)], *(_QWORD *)(v52 + v39 + 8), 1, v51, v33, v31 + v40);
              if (v12)
              {
                v41 = (const void *)v12;
                CFArrayAppendValue(v38, (const void *)v12);
                CFRelease(v41);
                ++v32;
                if (v50)
                  v42 = v32 < v50;
                else
                  v42 = 1;
                v43 = !v42;
              }
              else
              {
                v43 = 0;
              }
              v44 = v40 + 1;
              if ((v43 & 1) != 0)
                break;
              v39 += 16;
              v29 = v40++ < v37;
            }
            while (v29);
            v31 = v31 + v44 - 1;
            Mutable = v38;
            v13 = (uint64_t *)v7;
            if ((v43 & 1) != 0)
              break;
          }
        }
        if (!(_BYTE)v49)
          free(v35);
        if (v37)
          v45 = 1;
        else
          v45 = v53[0] == 0;
      }
      while (!v45);
    }
    v10 = v47;
  }
  pthread_mutex_unlock(v10);
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

const __CFArray *_IsStopLemmatizeWordForLanguage(const __CFString *a1, const __CFString *key)
{
  const __CFArray *result;
  const __CFArray *v5;
  CFRange v6;

  if (_IsStopLemmatizeWordForLanguage(__CFString const*,__CFString const*)::_OnceToken != -1)
    dispatch_once(&_IsStopLemmatizeWordForLanguage(__CFString const*,__CFString const*)::_OnceToken, &__block_literal_global_0);
  result = 0;
  if (a1 && _IsStopLemmatizeWordForLanguage(__CFString const*,__CFString const*)::_StopWordDict)
  {
    result = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_IsStopLemmatizeWordForLanguage(__CFString const*,__CFString const*)::_StopWordDict, key);
    if (result)
    {
      v5 = result;
      v6.length = CFArrayGetCount(result);
      v6.location = 0;
      return (const __CFArray *)(CFArrayContainsValue(v5, v6, a1) != 0);
    }
  }
  return result;
}

CFArrayRef _CopyPossibleArabicHebrewStemList(__CFString *a1, const __CFString *a2)
{
  const CFArrayCallBacks *v3;
  const __CFArray *Copy;
  CFMutableArrayRef Mutable;
  const __CFAllocator *v6;
  CFIndex Count;
  CFIndex v8;
  unsigned int v9;
  unint64_t v10;
  unint64_t v11;
  CFIndex v12;
  const __CFString *ValueAtIndex;
  const __CFString *v14;
  const __CFDictionary *v15;
  const __CFDictionary *Value;
  const __CFDictionary *v17;
  const __CFArray *v18;
  const __CFArray *v19;
  const __CFArray *v20;
  __CFArray *v21;
  CFIndex Length;
  CFIndex v23;
  CFIndex v24;
  CFIndex i;
  const __CFString *v26;
  CFIndex v27;
  CFIndex v28;
  CFStringRef v29;
  CFIndex v30;
  CFIndex v31;
  CFIndex j;
  const __CFString *v33;
  CFIndex v34;
  CFIndex v35;
  CFIndex v36;
  CFStringRef v37;
  CFIndex v38;
  CFIndex v39;
  CFIndex k;
  const void *v41;
  CFIndex v42;
  CFMutableArrayRef v43;
  CFArrayRef v44;
  const __CFAllocator *allocator;
  unsigned int v47;
  __CFDictionary *theDict;
  __CFArray *theArray;
  const __CFString *v50;
  const __CFArray *v51;
  CFIndex v52;
  void *values;
  CFRange v54;
  CFRange v55;
  CFRange v56;

  values = a1;
  v3 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  Copy = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
  Mutable = CFArrayCreateMutable(0, 0, v3);
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  Count = CFArrayGetCount(Copy);
  allocator = v6;
  if (Count >= 1)
  {
    v8 = Count;
    v9 = 0;
    v10 = 0x1EFA5C000uLL;
    v11 = 0x1EFA5C000uLL;
    theArray = Mutable;
    v50 = a2;
    while (1)
    {
      v47 = v9;
      v12 = 0;
      v51 = Copy;
      v52 = v8;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(Copy, v12);
        v14 = ValueAtIndex;
        if (*(_QWORD *)(v10 + 2648) == -1)
        {
          if (!ValueAtIndex)
            goto LABEL_29;
        }
        else
        {
          dispatch_once(&_CreateNextPossibleStems(__CFString const*,__CFString const*)::_OnceToken, &__block_literal_global_41);
          if (!v14)
            goto LABEL_29;
        }
        v15 = *(const __CFDictionary **)(v11 + 2656);
        if (v15)
        {
          Value = (const __CFDictionary *)CFDictionaryGetValue(v15, a2);
          if (Value)
          {
            v17 = Value;
            v18 = (const __CFArray *)CFDictionaryGetValue(Value, CFSTR("prefix"));
            v19 = (const __CFArray *)CFDictionaryGetValue(v17, CFSTR("suffix"));
            if (v18)
            {
              v20 = v19;
              if (v19)
              {
                v21 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
                Length = CFStringGetLength(v14);
                v23 = CFArrayGetCount(v20);
                if (v23 >= 1)
                {
                  v24 = v23;
                  for (i = 0; i != v24; ++i)
                  {
                    v26 = (const __CFString *)CFArrayGetValueAtIndex(v20, i);
                    v27 = CFStringGetLength(v26);
                    v28 = Length - v27;
                    if (Length > v27 && CFStringHasSuffix(v14, v26))
                    {
                      v55.location = 0;
                      v55.length = v28;
                      v29 = CFStringCreateWithSubstring(0, v14, v55);
                      CFArrayAppendValue(v21, v29);
                      CFRelease(v29);
                    }
                  }
                }
                v30 = CFArrayGetCount(v18);
                if (v30 >= 1)
                {
                  v31 = v30;
                  for (j = 0; j != v31; ++j)
                  {
                    v33 = (const __CFString *)CFArrayGetValueAtIndex(v18, j);
                    v34 = CFStringGetLength(v33);
                    v35 = Length - v34;
                    if (Length > v34)
                    {
                      v36 = v34;
                      if (CFStringHasPrefix(v14, v33))
                      {
                        v56.location = v36;
                        v56.length = v35;
                        v37 = CFStringCreateWithSubstring(0, v14, v56);
                        CFArrayAppendValue(v21, v37);
                        CFRelease(v37);
                      }
                    }
                  }
                }
                a2 = v50;
                Copy = v51;
                v10 = 0x1EFA5C000;
                v11 = 0x1EFA5C000;
                v8 = v52;
                if (v21)
                {
                  v38 = CFArrayGetCount(v21);
                  if (v38 >= 1)
                  {
                    v39 = v38;
                    for (k = 0; k != v39; ++k)
                    {
                      v41 = CFArrayGetValueAtIndex(v21, k);
                      if (!CFDictionaryContainsKey(theDict, v41))
                      {
                        CFDictionaryAddValue(theDict, v41, CFSTR("1"));
                        CFArrayAppendValue(theArray, v41);
                      }
                    }
                  }
                  CFRelease(v21);
                  v11 = 0x1EFA5C000;
                  v8 = v52;
                }
              }
            }
          }
        }
LABEL_29:
        ++v12;
      }
      while (v12 != v8);
      CFRelease(Copy);
      Mutable = theArray;
      Copy = CFArrayCreateCopy(0, theArray);
      CFArrayRemoveAllValues(theArray);
      v42 = CFArrayGetCount(Copy);
      if (v42 >= 1)
      {
        v8 = v42;
        v9 = v47 + 1;
        if (v47 < 3)
          continue;
      }
      break;
    }
  }
  CFRelease(Copy);
  CFRelease(Mutable);
  v43 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)_AddKeyToArray, v43);
  CFRelease(theDict);
  v54.length = CFArrayGetCount(v43);
  v54.location = 0;
  CFArraySortValues(v43, v54, (CFComparatorFunction)_CompareStringLength, 0);
  v44 = CFArrayCreateCopy(allocator, v43);
  CFRelease(v43);
  return v44;
}

uint64_t DCSIDXDictionary::prepareTrieIndex(uint64_t this)
{
  uint64_t v1;
  const __CFURL *v2;
  _QWORD *v3;
  const __CFArray *v4;
  const __CFURL *v5;
  void *values[2];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(this + 248))
  {
    v1 = this;
    if (!*(_BYTE *)(this + 272))
    {
      pthread_mutex_lock((pthread_mutex_t *)(this + 328));
      if (!*(_QWORD *)(v1 + 248))
      {
        v2 = (const __CFURL *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1);
        v3 = IDXCreateIndexObject(0, v2, CFSTR("DCSKeywordIndex"));
        *(_QWORD *)(v1 + 248) = v3;
        if (v3)
        {
          *(_OWORD *)values = xmmword_1E8B56978;
          v7 = *(_OWORD *)&off_1E8B56988;
          v8 = xmmword_1E8B56998;
          v9 = *(_OWORD *)off_1E8B569A8;
          v4 = CFArrayCreate(0, (const void **)values, 8, MEMORY[0x1E0C9B378]);
          IDXSetRequestFields(*(_QWORD *)(v1 + 248), v4);
          CFRelease(v4);
        }
        else
        {
          *(_BYTE *)(v1 + 272) = 1;
          v5 = (const __CFURL *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1);
          CFURLGetString(v5);
          CFLog();
        }
      }
      return pthread_mutex_unlock((pthread_mutex_t *)(v1 + 328));
    }
  }
  return this;
}

uint64_t DCSIDXDictionary::createRecordRef(DCSIDXDictionary *this, const unsigned __int8 *a2, uint64_t a3, char a4, int a5, int a6, unint64_t a7)
{
  unint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  __CFString *v16[2];
  unsigned __int16 *v17[2];
  unsigned __int16 *v18[2];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  *(_OWORD *)v16 = 0u;
  *(_OWORD *)v17 = 0u;
  *(_OWORD *)v18 = 0u;
  v19 = 0u;
  IDXGetFieldDataPtrs(*((_QWORD *)this + 31), (uint64_t)a2, a3, &v20, v16);
  v12 = 0;
  switch(LOBYTE(v16[0]))
  {
    case 1:
      v12 = *(unsigned __int8 *)v20;
      break;
    case 2:
      v12 = *(unsigned __int16 *)v20;
      break;
    case 4:
      v12 = *(unsigned int *)v20;
      break;
    case 8:
      v12 = *(_QWORD *)v20;
      break;
    default:
      break;
  }
  LOWORD(v13) = 0;
  switch(LOBYTE(v16[1]))
  {
    case 1:
      LOWORD(v13) = **((_BYTE **)&v20 + 1);
      if (a5)
        goto LABEL_14;
      goto LABEL_15;
    case 2:
      LOWORD(v13) = **((_WORD **)&v20 + 1);
      if (!a5)
        goto LABEL_15;
      goto LABEL_14;
    case 4:
      LODWORD(v13) = **((_DWORD **)&v20 + 1);
      if (!a5)
        goto LABEL_15;
      goto LABEL_14;
    case 8:
      v13 = **((_QWORD **)&v20 + 1);
      if (!a5)
        goto LABEL_15;
LABEL_14:
      if ((v13 & 1) != 0)
        return 0;
LABEL_15:
      if (a6 && (v13 & 0x1E) != 0)
        return 0;
LABEL_18:
      result = 0;
      if (LOWORD(v17[0]))
      {
        if ((_QWORD)v21)
        {
          HIWORD(v15) = v13;
          BYTE4(v15) = a4;
          LODWORD(v15) = 335544576;
          return DCSRecord::createRecordRef(*((DCSRecord **)this + 1), (DCSDictionary *)v21, (const unsigned __int16 *)LOWORD(v17[0]), *((const unsigned __int16 **)&v21 + 1), (const unsigned __int16 *)LOWORD(v17[1]), (const unsigned __int16 *)v22, (const unsigned __int16 *)LOWORD(v18[0]), *((const unsigned __int16 **)&v22 + 1), (const unsigned __int16 *)LOWORD(v18[1]), (const unsigned __int16 *)v23, (const unsigned __int16 *)(unsigned __int16)v19, *((const unsigned __int16 **)&v23 + 1), (const unsigned __int16 *)WORD4(v19), v15, v12, a7, 0, 0, v16[0]);
        }
      }
      return result;
    default:
      goto LABEL_18;
  }
}

uint64_t DCSIDXDictionary::searchByReference(DCSIDXDictionary *this, const __CFString *a2)
{
  uint64_t matched;
  const __CFString *v5;
  const __CFURL *v6;
  _QWORD *v7;
  const __CFArray *v8;
  uint64_t v9;
  uint64_t v10;
  const __CFURL *v11;
  const __CFURL *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  const __CFString **v17;
  uint64_t v18;
  void *values[65];

  values[64] = *(void **)MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)this + 33))
  {
    if (*((_BYTE *)this + 272))
      return 0;
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 392));
    if (!*((_QWORD *)this + 33))
    {
      v6 = (const __CFURL *)(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 16))(this);
      v7 = IDXCreateIndexObject(0, v6, CFSTR("DCSReferenceIndex"));
      *((_QWORD *)this + 33) = v7;
      if (v7)
      {
        values[0] = CFSTR("DCSExternalBodyID");
        v8 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x1E0C9B378]);
        IDXSetRequestFields(*((_QWORD *)this + 33), v8);
        CFRelease(v8);
      }
      else
      {
        *((_BYTE *)this + 272) = 1;
        v13 = (const __CFURL *)(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 16))(this);
        CFURLGetString(v13);
        CFLog();
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
    if (!*((_QWORD *)this + 33))
      return 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 392));
  if (!IDXSetSearchString(*((_QWORD *)this + 33), a2, (uint64_t)CFSTR("IDXExactMatch")))
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
    return 0;
  }
  v17 = 0;
  v18 = 0;
  v15 = 0;
  v16 = 0;
  if (IDXSupportDataPtr(*((_QWORD *)this + 33)))
  {
    matched = IDXGetMatchDataPtr(*((_QWORD *)this + 33), 1, (uint64_t)&v18, (uint64_t)&v16);
    if (matched >= 1)
    {
      IDXGetFieldDataPtrs(*((_QWORD *)this + 33), v18, v16, &v17, &v15);
      v5 = 0;
      switch((char)v15)
      {
        case 1:
          v5 = (const __CFString *)*(unsigned __int8 *)v17;
          break;
        case 2:
          v5 = (const __CFString *)*(unsigned __int16 *)v17;
          break;
        case 4:
          v5 = (const __CFString *)*(unsigned int *)v17;
          break;
        case 8:
          v5 = *v17;
          break;
        default:
          break;
      }
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
      return DCSRecord::createRecordRef(*((DCSRecord **)this + 1), a2, v5, 0, v11);
    }
    v9 = matched;
    goto LABEL_16;
  }
  v14 = 0;
  v9 = IDXGetMatchData(*((_QWORD *)this + 33), 1, 512, (uint64_t)values, (uint64_t)&v14, 0);
  if (v9 < 1)
  {
LABEL_16:
    v5 = 0;
    goto LABEL_17;
  }
  v10 = v14[1];
  v18 = (uint64_t)values + *v14;
  v16 = v10;
  IDXGetFieldDataPtrs(*((_QWORD *)this + 33), v18, v10, &v17, &v15);
  v5 = 0;
  switch((char)v15)
  {
    case 1:
      v5 = (const __CFString *)*(unsigned __int8 *)v17;
      break;
    case 2:
      v5 = (const __CFString *)*(unsigned __int16 *)v17;
      break;
    case 4:
      v5 = (const __CFString *)*(unsigned int *)v17;
      break;
    case 8:
      v5 = *v17;
      break;
    default:
      break;
  }
LABEL_17:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
  if (v9)
    return DCSRecord::createRecordRef(*((DCSRecord **)this + 1), a2, v5, 0, v11);
  return 0;
}

__CFString *DCSIDXDictionary::copyData(DCSIDXDictionary *this, DCSRecord *a2, unint64_t a3)
{
  pthread_mutex_t *v6;
  int v7;
  _QWORD *v8;
  BOOL v9;
  const __CFURL *v10;
  int v11;
  const UInt8 *v12;
  const __CFData *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  __CFString *v17;
  const UInt8 *BytePtr;
  CFIndex v19;
  const __CFString *v20;
  const __CFString *v21;
  DCSDictionaryImageReplacement *v22;
  const void *v23;
  __CFString *SourceXMLByReplacingImage;
  __CFString *v25;
  DCSDictionary *v26;
  CFIndex length;

  v6 = (pthread_mutex_t *)((char *)this + 456);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 456));
  v7 = (*(uint64_t (**)(DCSIDXDictionary *, unint64_t))(*(_QWORD *)this + 336))(this, a3);
  v8 = (_QWORD *)*((_QWORD *)this + 32);
  if (v8)
    v9 = 1;
  else
    v9 = v7 == 0;
  if (!v9)
  {
    v10 = (const __CFURL *)(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 16))(this);
    v8 = IDXCreateIndexObject(0, v10, CFSTR("DCSBodyDataIndex"));
    *((_QWORD *)this + 32) = v8;
  }
  if (v8)
    v11 = v7;
  else
    v11 = 0;
  if (v11 != 1)
    goto LABEL_28;
  length = 0;
  if (IDXSupportDataPtr((uint64_t)v8))
  {
    v12 = (const UInt8 *)IDXGetDataPtrByID(*((_QWORD *)this + 32), *((_QWORD *)a2 + 26), (uint64_t)&length);
    v13 = CFDataCreateWithBytesNoCopy(0, v12, length, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  }
  else
  {
    v14 = (void *)*((_QWORD *)this + 36);
    if (!v14)
    {
      *((_QWORD *)this + 35) = 0x8000;
      v14 = malloc_type_malloc(0x8000uLL, 0xA4DFE211uLL);
      *((_QWORD *)this + 36) = v14;
    }
    v15 = IDXGetDataByID(*((_QWORD *)this + 32), *((_QWORD *)a2 + 26), *((_QWORD *)this + 35), (uint64_t)v14);
    length = v15;
    if (v15 > *((_QWORD *)this + 35))
    {
      free(*((void **)this + 36));
      *((_QWORD *)this + 35) = v15;
      v16 = malloc_type_malloc(v15, 0xF4C92DF2uLL);
      *((_QWORD *)this + 36) = v16;
      v15 = IDXGetDataByID(*((_QWORD *)this + 32), *((_QWORD *)a2 + 26), *((_QWORD *)this + 35), (uint64_t)v16);
      length = v15;
    }
    if (!v15)
      goto LABEL_28;
    v13 = CFDataCreate(0, *((const UInt8 **)this + 36), v15);
  }
  v17 = (__CFString *)v13;
  if (!v13 || a3 == 4)
    goto LABEL_29;
  BytePtr = CFDataGetBytePtr(v13);
  v19 = CFDataGetLength((CFDataRef)v17);
  v20 = CFStringCreateWithBytes(0, BytePtr, v19, 0x8000100u, 0);
  CFRelease(v17);
  if (!v20)
  {
LABEL_28:
    v17 = 0;
    goto LABEL_29;
  }
  if (a3 != 255)
  {
    v21 = (const __CFString *)(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 368))(this);
    if (CFStringCompare(v21, CFSTR("Korean"), 0) == kCFCompareEqualTo)
    {
      v22 = (DCSDictionaryImageReplacement *)*((_QWORD *)this + 40);
      if (!v22)
      {
        v22 = (DCSDictionaryImageReplacement *)operator new();
        v23 = (const void *)(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 16))(this);
        DCSDictionaryImageReplacement::DCSDictionaryImageReplacement(v22, v23);
        *((_QWORD *)this + 40) = v22;
      }
      SourceXMLByReplacingImage = DCSDictionaryImageReplacement::createSourceXMLByReplacingImage((const __CFURL **)v22, v20);
      if (SourceXMLByReplacingImage)
      {
        v25 = SourceXMLByReplacingImage;
        CFRelease(v20);
        v20 = v25;
      }
    }
  }
  v26 = (DCSDictionary *)*((_QWORD *)this + 1);
  DCSRecord::dataString(a2);
  v17 = CopyTransformedTextFromXML(v20, v26, a3);
  CFRelease(v20);
LABEL_29:
  pthread_mutex_unlock(v6);
  return v17;
}

void sub_1CDF71D6C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F0C403D00FC33);
  _Unwind_Resume(a1);
}

uint64_t DCSIDXDictionary::hasRecord(DCSIDXDictionary *this, const __CFString *a2, unsigned __int16 a3, unsigned __int8 *a4)
{
  unint64_t v4;
  uint64_t v5;
  const __CFString *v7;
  _BOOL8 hasRecord_internal;
  CFIndex Length;
  const __CFArray *v11;
  const __CFArray *v12;
  CFIndex Count;
  CFIndex v14;
  CFIndex v15;
  const __CFDictionary *ValueAtIndex;
  const __CFString *Value;
  const __CFString *v18;
  CFComparisonResult v19;
  CFComparisonResult v20;
  unsigned __int8 v21;
  _BOOL4 v22;
  char v23;
  CFMutableStringRef MutableCopy;
  CFMutableStringRef v25;
  int v26;
  uint64_t v27;
  const __CFArray *v28;
  const __CFArray *v29;
  CFIndex v30;
  const __CFString *v31;
  uint64_t v32;
  __CFString *v33;
  const __CFString *v34;
  const __CFLocale *v35;
  BOOL v36;
  BOOL v38;
  int v39;
  __CFString *v40;
  __CFString *v41;
  const __CFArray *v42;
  CFIndex v43;
  CFIndex v44;
  CFIndex v45;
  const __CFString *v46;
  unsigned int v48;
  CFIndex v49;
  unsigned __int128 v50;
  CFIndex v51;
  const __CFArray *v52;
  BOOL v53;
  CFComparisonResult v54;
  CFIndex v55;
  const __CFString *v56;
  char v57;
  const __CFString *v58;
  CFIndex v59;

  v4 = a3;
  if (a3 > 3uLL)
    return 0;
  v7 = a2;
  hasRecord_internal = DCSIDXDictionary::hasRecord_internal(this, a2, a3, a4);
  v5 = hasRecord_internal;
  if (v4 <= 1 && !hasRecord_internal || v4 == 2 && a4)
  {
    Length = CFStringGetLength(v7);
    v11 = (const __CFArray *)(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 96))(this);
    if (v11)
    {
      v12 = v11;
      Count = CFArrayGetCount(v11);
      if (Count >= 1)
      {
        v14 = Count;
        v49 = Length;
        *(_QWORD *)&v50 = a4;
        *((_QWORD *)&v50 + 1) = v4;
        v48 = v5;
        v15 = 0;
        v56 = v7;
        v51 = Count;
        v52 = v12;
LABEL_10:
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v12, v15);
        Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("DCSDictionaryIndexLanguage"));
        if (!Value)
          goto LABEL_64;
        v18 = Value;
        v55 = v15;
        v19 = CFStringCompare(Value, CFSTR("ar"), 0);
        v20 = CFStringCompare(v18, CFSTR("he"), 0);
        v21 = _IsStopLemmatizeWordForLanguage(v7, v18);
        v22 = 0;
        v23 = v21 ^ 1;
        v54 = v20;
        if ((v21 & 1) == 0 && v19 == kCFCompareEqualTo)
        {
          if (ContainsLatinAlphabets(v7))
          {
            v22 = 0;
            v23 = 0;
          }
          else
          {
            MutableCopy = CFStringCreateMutableCopy(0, 0, v7);
            ExtraNormalizeStringForArabic(MutableCopy, 0);
            if (CFStringCompare(v7, MutableCopy, 0))
            {
              v22 = DCSIDXDictionary::hasRecord_internal(this, MutableCopy, 0, 0);
              v23 = !v22;
            }
            else
            {
              v22 = 0;
            }
            CFRelease(MutableCopy);
          }
        }
        v25 = 0;
        v53 = v22;
        v26 = v22;
        v27 = (uint64_t)v7;
        v58 = v18;
        v57 = v23;
        while ((v23 & 1) != 0)
        {
          v28 = DCSCopyLemmas(v27, v18);
          if (v28)
          {
            v29 = v28;
            v59 = CFArrayGetCount(v28);
            if (v59 >= 1)
            {
              v30 = 0;
              while (2)
              {
                v31 = (const __CFString *)CFArrayGetValueAtIndex(v29, v30);
                v32 = 0;
                do
                {
                  v33 = CFStringCreateMutableCopy(0, 0, v31);
                  v34 = v33;
                  if (v32)
                  {
                    ExtraNormalizeStringForArabic(v33, 0);
                  }
                  else
                  {
                    v35 = (const __CFLocale *)(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 256))(this);
                    DCSNormalizeSearchStringWithOptionsAndLocale(v34, 0, v35);
                  }
                  v36 = DCSIDXDictionary::hasRecord_internal(this, v34, 0, 0);
                  CFRelease(v34);
                  if (v36)
                  {
                    v26 = 1;
                    goto LABEL_33;
                  }
                }
                while (!(v19 | v32++));
                if (++v30 != v59)
                  continue;
                break;
              }
              v26 = 0;
LABEL_33:
              v7 = v56;
              v18 = v58;
              v23 = v57;
            }
            CFRelease(v29);
          }
          if ((v26 & 1) != 0
            || v19
            || (const __CFString *)v27 != v7
            || (v25 = CFStringCreateMutableCopy(0, 0, v7),
                ExtraNormalizeStringForArabic(v25, 1),
                CFStringCompare(v7, v25, 0) == kCFCompareEqualTo))
          {
            if (v19)
              v38 = v54 == kCFCompareEqualTo;
            else
              v38 = 1;
            v39 = v38;
            if (((v26 ^ 1) & v39) != 1)
            {
              v15 = v55;
LABEL_61:
              if (!v25)
                goto LABEL_63;
LABEL_62:
              CFRelease(v25);
              goto LABEL_63;
            }
            v40 = CFStringCreateMutableCopy(0, 0, v7);
            v41 = v40;
            if (v19 == kCFCompareEqualTo)
              ExtraNormalizeStringForArabic(v40, 0);
            v42 = _CopyPossibleArabicHebrewStemList(v41, v18);
            CFRelease(v41);
            v15 = v55;
            if (!v42)
              goto LABEL_61;
            v43 = CFArrayGetCount(v42);
            if (v43 < 1)
              goto LABEL_67;
            v44 = v43;
            v45 = 0;
            while (2)
            {
              v46 = (const __CFString *)CFArrayGetValueAtIndex(v42, v45);
              if (CFStringGetLength(v46) < 3)
              {
LABEL_56:
                if (v44 == ++v45)
                  goto LABEL_67;
                continue;
              }
              break;
            }
            if (!DCSIDXDictionary::hasRecord_internal(this, v46, 0, 0))
            {
              LOBYTE(v26) = 0;
              goto LABEL_56;
            }
            LOBYTE(v26) = 1;
LABEL_67:
            CFRelease(v42);
            if (v25)
              goto LABEL_62;
LABEL_63:
            v14 = v51;
            v12 = v52;
            if ((v26 & 1) != 0)
              goto LABEL_71;
LABEL_64:
            if (++v15 == v14)
              return v48;
            goto LABEL_10;
          }
          v26 = 0;
          v27 = (uint64_t)v25;
          if (DCSIDXDictionary::hasRecord_internal(this, v25, 0, 0))
          {
            if (v25)
              CFRelease(v25);
            goto LABEL_71;
          }
        }
        v14 = v51;
        v12 = v52;
        v15 = v55;
        if (!v53)
          goto LABEL_64;
LABEL_71:
        v5 = 1;
        if (v50 > __PAIR128__(2, 0))
          *(_BYTE *)(v49 + v50 - 1) = 1;
      }
    }
  }
  return v5;
}

BOOL DCSIDXDictionary::hasRecord_internal(DCSIDXDictionary *this, const __CFString *a2, uint64_t a3, unsigned __int8 *a4)
{
  unsigned __int8 v8;
  _BOOL8 v9;

  DCSIDXDictionary::prepareTrieIndex((uint64_t)this);
  if (!*((_QWORD *)this + 31))
    return 0;
  if ((v8 & 1) == 0
  {
    DCSIDXDictionary::hasRecord_internal(__CFString const*,long,unsigned char *)::methodString[0] = (uint64_t)CFSTR("IDXExactMatch");
    *(_QWORD *)algn_1EFA5CA38 = CFSTR("IDXPrefixMatch");
    qword_1EFA5CA40 = (uint64_t)CFSTR("IDXCommonPrefixMatch");
    unk_1EFA5CA48 = CFSTR("IDXWildcardMatch");
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 328));
  if (IDXSetSearchString(*((_QWORD *)this + 31), a2, DCSIDXDictionary::hasRecord_internal(__CFString const*,long,unsigned char *)::methodString[a3]))v9 = IDXContainsMatchData(*((_QWORD *)this + 31), (uint64_t)a4) != 0;
  else
    v9 = 0;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 328));
  return v9;
}

uint64_t DCSIDXDictionary::baseURL(DCSIDXDictionary *this)
{
  const __CFURL *v2;
  __CFArray *v3;
  const __CFURL *ValueAtIndex;
  const void *v5;

  if (!*((_QWORD *)this + 37) && (*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 16))(this))
  {
    v2 = (const __CFURL *)(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 16))(this);
    v3 = IDXCopyIndexNames(v2, 1);
    ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v3, 0);
    *((_QWORD *)this + 37) = ValueAtIndex;
    if (ItemExistsAtURL(ValueAtIndex))
    {
      CFRetain(*((CFTypeRef *)this + 37));
    }
    else
    {
      v5 = (const void *)DCSBaseDictionary::baseURL(this);
      *((_QWORD *)this + 37) = CFRetain(v5);
    }
    CFRelease(v3);
  }
  return *((_QWORD *)this + 37);
}

uint64_t DCSIDXDictionary::languages(DCSIDXDictionary *this)
{
  uint64_t result;
  const __CFArray *v3;
  const __CFArray *v4;
  const __CFDictionary *ValueAtIndex;
  const void *Value;
  const void *v7;
  __CFBundle *v8;
  const __CFArray *v9;
  const __CFArray *v10;
  const __CFArray *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFLocale *v14;
  CFTypeRef v15;
  CFTypeRef v16;
  CFStringRef v17;
  CFTypeRef cf;
  void *v19[2];
  void *values;
  const __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  result = *((_QWORD *)this + 38);
  if (result == -1)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 520));
    if (*((_QWORD *)this + 38) == -1)
    {
      v3 = (const __CFArray *)DCSBaseDictionary::languages(this);
      *((_QWORD *)this + 38) = v3;
      if (v3)
      {
        v4 = v3;
        if (CFArrayGetCount(v3) == 2
          && (ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v4, 0),
              Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("DCSDictionaryDescriptionLanguage")),
              v7 = CFDictionaryGetValue(ValueAtIndex, CFSTR("DCSDictionaryIndexLanguage")),
              !CFEqual(Value, v7)))
        {
          values = (void *)CFArrayGetValueAtIndex(v4, 1);
          v21 = (const __CFString *)ValueAtIndex;
          v4 = CFArrayCreate(0, (const void **)&values, 2, MEMORY[0x1E0C9B378]);
        }
        else
        {
          CFRetain(v4);
        }
        *((_QWORD *)this + 38) = v4;
        goto LABEL_20;
      }
      if ((*(unsigned int (**)(DCSIDXDictionary *))(*(_QWORD *)this + 216))(this))
      {
        v8 = (__CFBundle *)(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 376))(this);
        v9 = CFBundleCopyBundleLocalizations(v8);
        if (v9)
        {
          v10 = v9;
          v11 = CFBundleCopyPreferredLocalizationsFromArray(v9);
          CFRelease(v10);
          if (v11)
          {
            v12 = (const __CFString *)CFArrayGetValueAtIndex(v11, 0);
            if (v12)
            {
              v13 = v12;
              CFRetain(v12);
              CFRelease(v11);
              v14 = CFLocaleCreate(0, v13);
              CFRelease(v13);
              if (!v14)
                goto LABEL_20;
              v15 = CFLocaleGetValue(v14, (CFLocaleKey)*MEMORY[0x1E0C9B088]);
              v16 = CFLocaleGetValue(v14, (CFLocaleKey)*MEMORY[0x1E0C9B060]);
              v17 = v16 ? CFStringCreateWithFormat(0, 0, CFSTR("%@-%@"), v15, v16) : (CFStringRef)CFRetain(v15);
              v11 = (const __CFArray *)v17;
              CFRelease(v14);
              if (!v11)
                goto LABEL_20;
              values = CFSTR("DCSDictionaryIndexLanguage");
              v21 = CFSTR("DCSDictionaryDescriptionLanguage");
              v19[0] = v11;
              v19[1] = v11;
              cf = CFDictionaryCreate(0, (const void **)&values, (const void **)v19, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              *((_QWORD *)this + 38) = CFArrayCreate(0, &cf, 1, MEMORY[0x1E0C9B378]);
              CFRelease(cf);
            }
            CFRelease(v11);
          }
        }
      }
    }
LABEL_20:
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 520));
    return *((_QWORD *)this + 38);
  }
  return result;
}

BOOL DCSIDXDictionary::validDictionary(DCSIDXDictionary *this)
{
  const __CFURL *v2;
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  const __CFArray *Value;
  const __CFDictionary *ValueAtIndex;
  const __CFString *v7;
  _BOOL8 v8;

  if (!(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 16))(this))
    return 0;
  v2 = (const __CFURL *)(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 16))(this);
  v3 = CFBundleCopyInfoDictionaryInDirectory(v2);
  if (!v3)
    return 0;
  v4 = v3;
  Value = (const __CFArray *)CFDictionaryGetValue(v3, CFSTR("IDXDictionaryIndexes"));
  v8 = Value
    && (ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, 0)) != 0
    && (v7 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("IDXIndexName"))) != 0
    && CFStringCompare(v7, CFSTR("DCSKeywordIndex"), 0) == kCFCompareEqualTo;
  CFRelease(v4);
  return v8;
}

BOOL DCSIDXDictionary::isLocalizableDictionary(DCSIDXDictionary *this)
{
  const __CFURL *v2;
  __CFArray *v3;
  __CFArray *v4;
  const __CFURL *ValueAtIndex;
  const __CFURL *v6;
  const __CFURL *v7;
  const __CFString *PathComponent;
  const __CFString *v9;
  _BOOL8 v10;

  if (!(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 16))(this))
    return 0;
  v2 = (const __CFURL *)(*(uint64_t (**)(DCSIDXDictionary *))(*(_QWORD *)this + 16))(this);
  v3 = IDXCopyIndexNames(v2, 1);
  if (!v3)
    return 0;
  v4 = v3;
  ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v3, 0);
  if (ValueAtIndex && (v6 = CFURLCreateCopyDeletingLastPathComponent(0, ValueAtIndex)) != 0)
  {
    v7 = v6;
    PathComponent = CFURLCopyLastPathComponent(v6);
    if (PathComponent)
    {
      v9 = PathComponent;
      v10 = CFStringHasSuffix(PathComponent, CFSTR(".lproj")) != 0;
      CFRelease(v7);
      v7 = (const __CFURL *)v9;
    }
    else
    {
      v10 = 0;
    }
    CFRelease(v7);
  }
  else
  {
    v10 = 0;
  }
  CFRelease(v4);
  return v10;
}

uint64_t DCSIDXDictionary::primaryLocale(DCSIDXDictionary *this)
{
  uint64_t result;
  const __CFString *v3;
  const __CFString *CanonicalLanguageIdentifierFromString;
  const __CFString *v5;

  result = *((_QWORD *)this + 39);
  if (!result)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 520));
    if (!*((_QWORD *)this + 39))
    {
      v3 = (const __CFString *)DCSBaseDictionary::primaryLanguage(this);
      if (v3)
      {
        CanonicalLanguageIdentifierFromString = CFLocaleCreateCanonicalLanguageIdentifierFromString(0, v3);
        if (CanonicalLanguageIdentifierFromString)
        {
          v5 = CanonicalLanguageIdentifierFromString;
          *((_QWORD *)this + 39) = CFLocaleCreate(0, CanonicalLanguageIdentifierFromString);
          CFRelease(v5);
        }
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 520));
    return *((_QWORD *)this + 39);
  }
  return result;
}

uint64_t DCSIDXDictionary::purgeInactiveData(DCSIDXDictionary *this)
{
  pthread_mutex_t *v2;
  uint64_t result;
  const void *v4;

  v2 = (pthread_mutex_t *)((char *)this + 456);
  result = pthread_mutex_trylock((pthread_mutex_t *)((char *)this + 456));
  if (!(_DWORD)result)
  {
    v4 = (const void *)*((_QWORD *)this + 32);
    if (v4)
    {
      CFRelease(v4);
      *((_QWORD *)this + 32) = 0;
    }
    return pthread_mutex_unlock(v2);
  }
  return result;
}

uint64_t DCSIDXDictionary::languageDirectionOfFoundRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 16);
  if (v2)
    return (*(unsigned __int16 *)(v2 + 192) >> 5) & 1;
  else
    return 0;
}

uint64_t DCSBaseDictionary::URL(DCSBaseDictionary *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t DCSBaseDictionary::subDictionaries(DCSBaseDictionary *this)
{
  return 0;
}

uint64_t DCSBaseDictionary::parentDictionary(DCSBaseDictionary *this)
{
  return 0;
}

uint64_t DCSBaseDictionary::migrateOldPreference(DCSBaseDictionary *this, const __CFDictionary *a2)
{
  return 0;
}

uint64_t DCSBaseDictionary::copyDataURL()
{
  return 0;
}

uint64_t DCSBaseDictionary::dictionaryFileName(DCSBaseDictionary *this)
{
  return *((_QWORD *)this + 4);
}

CFTypeRef ___ZL31_IsStopLemmatizeWordForLanguagePK10__CFStringS1__block_invoke()
{
  DCSEnvironment *v0;
  __CFBundle *FrameworkBundle;
  CFTypeRef result;

  v0 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(v0);
  result = CFBundleGetValueForInfoDictionaryKey(FrameworkBundle, CFSTR("DSCStopLemmatizeWordList"));
  _IsStopLemmatizeWordForLanguage(__CFString const*,__CFString const*)::_StopWordDict = (uint64_t)result;
  if (result)
    return CFRetain(result);
  return result;
}

void _AddKeyToArray(const void *value, const void *a2, CFMutableArrayRef theArray)
{
  CFArrayAppendValue(theArray, value);
}

uint64_t _CompareStringLength(const __CFString *a1, const __CFString *a2, void *a3)
{
  CFIndex Length;
  CFIndex v5;
  uint64_t v6;

  Length = CFStringGetLength(a1);
  v5 = CFStringGetLength(a2);
  if (Length <= v5)
    v6 = 0;
  else
    v6 = -1;
  if (Length < v5)
    return 1;
  else
    return v6;
}

CFTypeRef ___ZL24_CreateNextPossibleStemsPK10__CFStringS1__block_invoke()
{
  DCSEnvironment *v0;
  __CFBundle *FrameworkBundle;
  CFTypeRef result;

  v0 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(v0);
  result = CFBundleGetValueForInfoDictionaryKey(FrameworkBundle, CFSTR("DCSStemGuessData"));
  _CreateNextPossibleStems(__CFString const*,__CFString const*)::_StemGuessData = (uint64_t)result;
  if (result)
    return CFRetain(result);
  return result;
}

void DCSDictionaryImageReplacement::DCSDictionaryImageReplacement(DCSDictionaryImageReplacement *this, CFTypeRef cf)
{
  *(_QWORD *)this = cf;
  *((_BYTE *)this + 8) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  CFRetain(cf);
}

void DCSDictionaryImageReplacement::~DCSDictionaryImageReplacement(DCSDictionaryImageReplacement *this)
{
  const void *v2;
  void *v3;
  uint64_t v4;

  v2 = *(const void **)this;
  if (v2)
    CFRelease(v2);
  v3 = (void *)*((_QWORD *)this + 2);
  if (v3)
    munmap(v3, *((_QWORD *)this + 3));
  v4 = *((_QWORD *)this + 4);
  if (v4)
  {
    if (*(_DWORD *)(v4 + 48))
      free(*(void **)(v4 + 8));
    free((void *)v4);
  }
}

void DCSDictionaryImageReplacement::openData(const __CFURL **this)
{
  const __CFURL *DictionaryComponentURL;
  char *FileSystemPath;
  int v4;
  off_t st_size;
  const __CFURL *v6;
  unsigned int *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  __int128 v11;
  stat v12;

  DictionaryComponentURL = CreateDictionaryComponentURL(*this, (uint64_t)CFSTR("Resources/ImageData.data"));
  CFRelease(*this);
  *this = 0;
  FileSystemPath = CreateFileSystemPath(DictionaryComponentURL);
  CFRelease(DictionaryComponentURL);
  if (FileSystemPath)
  {
    v4 = open(FileSystemPath, 0);
    free(FileSystemPath);
    if (v4 != -1)
    {
      fstat(v4, &v12);
      st_size = v12.st_size;
      this[3] = (const __CFURL *)v12.st_size;
      this[2] = (const __CFURL *)mmap(0, st_size, 1, 1, v4, 0);
      close(v4);
      v6 = this[2];
      v7 = (unsigned int *)((char *)v6 + 8);
      v8 = *(unsigned int *)v6;
      v9 = (char *)malloc_type_malloc(0x48uLL, 0x1090040DA38FBB1uLL);
      if (v9)
      {
        *((_QWORD *)v9 + 8) = 0;
        *((_OWORD *)v9 + 2) = 0u;
        *((_OWORD *)v9 + 3) = 0u;
        *(_OWORD *)v9 = 0u;
        *((_OWORD *)v9 + 1) = 0u;
        *((_QWORD *)v9 + 1) = v7;
        *((_QWORD *)v9 + 5) = v8;
        if (v8 >= 0x18)
        {
          *(_DWORD *)v9 = *((_DWORD *)v6 + 3);
          *((_QWORD *)v9 + 2) = (char *)v7 + *((unsigned int *)v6 + 5);
          v10 = *((_QWORD *)v6 + 3);
          *(_QWORD *)&v11 = v10;
          *((_QWORD *)&v11 + 1) = HIDWORD(v10);
          *(_OWORD *)(v9 + 24) = v11;
        }
      }
      this[4] = (const __CFURL *)v9;
      this[5] = (const __CFURL *)((char *)v7 + v8);
    }
  }
}

__CFString *DCSDictionaryImageReplacement::createSourceXMLByReplacingImage(const __CFURL **this, CFStringRef theString)
{
  const __CFURL **v3;
  CFArrayRef Results;
  const __CFArray *v5;
  CFIndex Length;
  __CFString *Mutable;
  CFIndex v8;
  CFIndex v9;
  _QWORD *ValueAtIndex;
  CFIndex v11;
  CFIndex location;
  int8x8_t v14;
  const __CFURL *v15;
  unsigned int v16;
  unsigned __int8 *v17;
  unsigned int *v18;
  unsigned int v19;
  int v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  unsigned int *v28;
  unsigned int v29;
  _DWORD *v30;
  unsigned __int8 *v31;
  int v32;
  char *v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  size_t v37;
  int v38;
  int v39;
  uint64_t v40;
  CFIndex v41;
  const __CFString *v42;
  __CFString *v44;
  const __CFURL **v45;
  CFIndex v46;
  const __CFAllocator *contentsDeallocator;
  unsigned __int8 *v48;
  CFRange v49;
  CFRange v50;
  CFRange v51;
  CFRange v52;
  CFRange v53;

  v3 = this;
  if (!*((_BYTE *)this + 8))
  {
    DCSDictionaryImageReplacement::openData(this);
    *((_BYTE *)v3 + 8) = 1;
  }
  if (!v3[4])
    return 0;
  v53.length = CFStringGetLength(theString);
  v53.location = 0;
  Results = CFStringCreateArrayWithFindResults(0, theString, CFSTR("<img src=\""), v53, 0);
  if (!Results)
    return 0;
  v5 = Results;
  Length = CFStringGetLength(theString);
  if (CFArrayGetCount(v5) < 1)
  {
    v8 = 0;
    Mutable = 0;
    goto LABEL_61;
  }
  Mutable = 0;
  v8 = 0;
  v9 = 0;
  contentsDeallocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v5, v9);
    v11 = ValueAtIndex[1] + *ValueAtIndex;
    location = v11 + 4;
    if (v11 >= Length || location >= Length)
      break;
    if (CFStringGetCharacterAtIndex(theString, v11 + 4) != 34)
      goto LABEL_57;
    v50.location = v11;
    v50.length = 4;
    if (CFStringGetBytes(theString, v50, 0x8000100u, 0, 0, (UInt8 *)&v49.length + 4, 4, 0) != 4)
    {
      location = v8;
      goto LABEL_56;
    }
    v49.location = v8;
    v15 = v3[4];
    v16 = 4;
    v17 = (unsigned __int8 *)&v49.length + 4;
    v18 = (unsigned int *)v15;
    while (1)
    {
      v19 = *v18;
      v20 = v19 & 3;
      if (v20 != 2)
        break;
      v22 = *((_QWORD *)v15 + 1);
      v23 = v19 - 2;
      v21 = (char *)(v22 + v23);
      if (!v16)
        goto LABEL_51;
      v24 = *v17;
      v25 = v24 >> 5;
      v26 = *(_DWORD *)&v21[4 * (v24 >> 5) + 4];
      if (((v26 >> v24) & 1) == 0)
        goto LABEL_55;
      if (v24 >= 0x20)
      {
        v27 = 0;
        if (v25 <= 1)
          v25 = 1;
        else
          v25 = v25;
        v28 = (unsigned int *)(v22 + v23 + 4);
        do
        {
          v29 = *v28++;
          v14 = vcnt_s8((int8x8_t)v29);
          v14.i16[0] = vaddlv_u8((uint8x8_t)v14);
          v27 += v14.i32[0];
          --v25;
        }
        while (v25);
      }
      else
      {
        v27 = 0;
      }
      v14.i32[0] = v26 & ~(-1 << (v24 & 0x1F));
      v14 = vcnt_s8(v14);
      v14.i16[0] = vaddlv_u8((uint8x8_t)v14);
      v18 = (unsigned int *)&v21[4 * (v27 + v14.i32[0]) + 40];
LABEL_29:
      --v16;
      ++v17;
    }
    if (v20 == 3)
    {
      v21 = (char *)(*((_QWORD *)v15 + 1) + v19 - 3);
      if (!v16)
        goto LABEL_51;
      v18 = (unsigned int *)&v21[4 * *v17 + 4];
      goto LABEL_29;
    }
    if (v20 != 1)
      goto LABEL_55;
    v46 = Length;
    v30 = (_DWORD *)(*((_QWORD *)v15 + 2) + v19 - 1);
    v21 = (char *)(v30 + 1);
    if (!v16)
    {
LABEL_50:
      Length = v46;
LABEL_51:
      v40 = *(unsigned int *)v21;
      if ((_DWORD)v40)
      {
        v41 = Length;
        if (!Mutable)
          Mutable = CFStringCreateMutable(0, 0);
        v51.location = v49.location;
        v51.length = v11 - v49.location;
        appendOriginalSubstring(Mutable, theString, v51);
        v42 = CFStringCreateWithBytesNoCopy(0, (const UInt8 *)v3[5] + v40, *(unsigned int *)((char *)v3[5] + v40 - 4), 0x8000100u, 0, contentsDeallocator);
        CFStringAppend(Mutable, v42);
        CFRelease(v42);
        Length = v41;
        goto LABEL_56;
      }
LABEL_55:
      location = v49.location;
      goto LABEL_56;
    }
    v32 = *v30;
    v31 = (unsigned __int8 *)(v30 + 2);
    v48 = (unsigned __int8 *)&v21[v32];
    if (v31 < v48)
    {
      v44 = Mutable;
      v45 = v3;
      while (1)
      {
        v35 = *v31;
        v33 = (char *)(v31 + 1);
        v34 = v35;
        v36 = v35 - v16;
        v37 = v35 >= v16 ? v16 : v34;
        v38 = memcmp(v33, v17, v37);
        v39 = v38 ? v38 : v36;
        if ((v39 & 0x80000000) == 0)
          break;
        v31 = (unsigned __int8 *)&v33[v34 + 4];
        if (v31 >= v48)
        {
          location = v49.location;
          v3 = v45;
LABEL_47:
          Mutable = v44;
          goto LABEL_48;
        }
      }
      v3 = v45;
      if (v39)
      {
        location = v49.location;
        goto LABEL_47;
      }
      v21 = &v33[v34];
      Mutable = v44;
      goto LABEL_50;
    }
    location = v49.location;
LABEL_48:
    Length = v46;
LABEL_56:
    v8 = location;
LABEL_57:
    ++v9;
  }
  while (v9 < CFArrayGetCount(v5));
LABEL_61:
  CFRelease(v5);
  if (v8 && Length > v8)
  {
    v52.location = v8;
    v52.length = Length - v8;
    appendOriginalSubstring(Mutable, theString, v52);
  }
  return Mutable;
}

void appendOriginalSubstring(__CFString *a1, const __CFString *a2, CFRange a3)
{
  const __CFString *v4;

  v4 = CFStringCreateWithSubstring(0, a2, a3);
  CFStringAppend(a1, v4);
  CFRelease(v4);
}

void DCSRecord::DCSRecord(DCSRecord *this, DCSDictionary *a2, const unsigned __int16 *a3, size_t a4, const unsigned __int16 *a5, size_t a6, const unsigned __int16 *a7, size_t a8, const unsigned __int16 *a9, size_t a10, const unsigned __int16 *a11, uint64_t a12, const unsigned __int16 *a13, size_t a14, unsigned int a15, BOOL a16, unsigned __int16 a17, unint64_t a18, uint64_t a19, const __CFURL *a20,const __CFString *a21)
{
  const void *v26;
  uint64_t v27;
  BOOL v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;

  *(_QWORD *)this = a2;
  *((_DWORD *)this + 4) = a15;
  *((_BYTE *)this + 20) = a16;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = a4;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = a6;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = a8;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = a10;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = a12;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = 0;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((_QWORD *)this + 20) = a14;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_WORD *)this + 96) = a17;
  *((_QWORD *)this + 25) = a19;
  *((_QWORD *)this + 26) = a18;
  *(_OWORD *)((char *)this + 232) = 0u;
  if (a21)
    *((_QWORD *)this + 27) = CFRetain(a21);
  if (a20)
    *((_QWORD *)this + 28) = CFRetain(a20);
  v26 = **(const void ***)this;
  *((_QWORD *)this + 1) = v26;
  CFRetain(v26);
  v27 = DCSDictionary::dictionaryFlag(*(DCSDictionary **)this);
  *((_QWORD *)this + 3) = v27;
  v28 = 0;
  if ((v27 & 4) != 0)
  {
    if (a6 && a12 >= 1)
      v28 = a4 != a6 || memcmp(a3, a5, a6) != 0;
  }
  else if (a12 >= 1 && a4 == a12)
  {
    v28 = memcmp(a3, a11, a12) == 0;
  }
  *((_BYTE *)this + 21) = v28;
  if (a16)
  {
    if (a3)
    {
      v29 = malloc_type_malloc(a4, 0xAB85F0BDuLL);
      *((_QWORD *)this + 4) = v29;
      memcpy(v29, a3, a4);
    }
    if (a5)
    {
      v30 = malloc_type_malloc(a6, 0x201A078BuLL);
      *((_QWORD *)this + 7) = v30;
      memcpy(v30, a5, a6);
    }
    if (a7)
    {
      v31 = malloc_type_malloc(a8, 0xCA49E36uLL);
      *((_QWORD *)this + 10) = v31;
      memcpy(v31, a7, a8);
    }
    if (a9)
    {
      v32 = malloc_type_malloc(a10, 0xA2DAD704uLL);
      *((_QWORD *)this + 13) = v32;
      memcpy(v32, a9, a10);
    }
    if (a11)
    {
      v33 = malloc_type_malloc(a12, 0x8AFF3782uLL);
      *((_QWORD *)this + 16) = v33;
      memcpy(v33, a11, a12);
    }
    if (a13)
    {
      v34 = malloc_type_malloc(a14, 0xF4C854C8uLL);
      *((_QWORD *)this + 19) = v34;
      memcpy(v34, a13, a14);
    }
  }
  else
  {
    *((_QWORD *)this + 4) = a3;
    *((_QWORD *)this + 7) = a5;
    *((_QWORD *)this + 10) = a7;
    *((_QWORD *)this + 13) = a9;
    *((_QWORD *)this + 16) = a11;
    *((_QWORD *)this + 19) = a13;
  }
}

void DCSRecord::DCSRecord(DCSRecord *this, DCSDictionary *a2, const unsigned __int16 *a3, size_t a4, const unsigned __int16 *a5, size_t a6, const unsigned __int16 *a7, size_t a8, const unsigned __int16 *a9, size_t a10, const unsigned __int16 *a11, uint64_t a12, const unsigned __int16 *a13, size_t a14, unsigned int a15, BOOL a16, unsigned __int16 a17, unint64_t a18, uint64_t a19, const __CFURL *a20,const __CFString *a21,const __CFURL *a22,const __CFString *a23)
{
  DCSRecord::DCSRecord(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21);
}

void DCSRecord::~DCSRecord(DCSRecord *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  v2 = (const void *)*((_QWORD *)this + 6);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 9);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 12);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 15);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 18);
  if (v6)
    CFRelease(v6);
  v7 = (const void *)*((_QWORD *)this + 21);
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 27);
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)this + 22);
  if (v9)
    CFRelease(v9);
  v10 = (const void *)*((_QWORD *)this + 23);
  if (v10)
    CFRelease(v10);
  v11 = (const void *)*((_QWORD *)this + 28);
  if (v11)
    CFRelease(v11);
  CFRelease(*((CFTypeRef *)this + 1));
  if (*((_BYTE *)this + 20))
  {
    v12 = (void *)*((_QWORD *)this + 4);
    if (v12)
      free(v12);
    v13 = (void *)*((_QWORD *)this + 7);
    if (v13)
      free(v13);
    v14 = (void *)*((_QWORD *)this + 10);
    if (v14)
      free(v14);
    v15 = (void *)*((_QWORD *)this + 13);
    if (v15)
      free(v15);
    v16 = (void *)*((_QWORD *)this + 16);
    if (v16)
      free(v16);
    v17 = (void *)*((_QWORD *)this + 19);
    if (v17)
      free(v17);
  }
}

uint64_t DCSRecord::createRecordRef(DCSRecord *this, DCSDictionary *a2, const unsigned __int16 *a3, const unsigned __int16 *a4, const unsigned __int16 *a5, const unsigned __int16 *a6, const unsigned __int16 *a7, const unsigned __int16 *a8, const unsigned __int16 *a9, const unsigned __int16 *a10, const unsigned __int16 *a11, const unsigned __int16 *a12, const unsigned __int16 *a13, uint64_t a14, unint64_t a15, unint64_t a16, const __CFURL *a17, const __CFString *a18, const __CFString *a19)
{
  uint64_t Instance;
  DCSRecord *v28;

  pthread_once(&_DCSRecordClassID(void)::once_control, (void (*)(void))_DCSRecordInitialize);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v28 = (DCSRecord *)operator new();
    DCSRecord::DCSRecord(v28, this, (const unsigned __int16 *)a2, (size_t)a3, a4, (size_t)a5, a6, (size_t)a7, a8, (size_t)a9, a10, (uint64_t)a11, a12, (size_t)a13, a14, SBYTE4(a14), HIWORD(a14), a15, a16,
      a17,
      a18);
    *(_QWORD *)(Instance + 16) = v28;
  }
  return Instance;
}

void sub_1CDF73430(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F0C406EFE96A2);
  _Unwind_Resume(a1);
}

uint64_t DCSRecord::createRecordRef(DCSRecord *this, const __CFString *a2, const __CFString *a3, const __CFURL *a4, const __CFURL *a5)
{
  uint64_t v6;
  __CFString *vars0;

  HIWORD(v6) = 0;
  BYTE4(v6) = 0;
  LODWORD(v6) = 256;
  return DCSRecord::createRecordRef(this, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, v6, (unint64_t)a3, 0, a4, a2, vars0);
}

uint64_t DCSRecord::recordRefClassID(DCSRecord *this)
{
  pthread_once(&_DCSRecordClassID(void)::once_control, (void (*)(void))_DCSRecordInitialize);
  return _DCSRecordID;
}

CFStringRef DCSRecord::keyString(DCSRecord *this)
{
  CFStringRef result;
  const UInt8 *v3;

  result = (CFStringRef)*((_QWORD *)this + 6);
  if (!result)
  {
    v3 = (const UInt8 *)*((_QWORD *)this + 4);
    if (v3)
    {
      result = CFStringCreateWithBytes(0, v3, *((_QWORD *)this + 5), *((_DWORD *)this + 4), 0);
      *((_QWORD *)this + 6) = result;
    }
    else
    {
      return (CFStringRef)*((_QWORD *)this + 27);
    }
  }
  return result;
}

CFIndex DCSRecord::setKeyString(DCSRecord *this, CFStringRef theString)
{
  const void *v4;
  CFIndex result;

  v4 = (const void *)*((_QWORD *)this + 6);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)this + 6) = CFStringCreateCopy(0, theString);
  result = CFStringGetLength(theString);
  *((_QWORD *)this + 5) = 2 * result;
  return result;
}

void *DCSRecord::headword(DCSRecord *this)
{
  void *result;
  uint64_t v3;
  const __CFString *v4;
  const __CFString *v5;
  CFStringRef v6;
  const __CFString *v7;
  uint64_t v8;

  result = (void *)*((_QWORD *)this + 22);
  if (!result)
  {
    if (!*((_QWORD *)this + 4))
      return (void *)*((_QWORD *)this + 27);
    if (*((_QWORD *)this + 17))
    {
      v3 = *((_QWORD *)this + 3);
      if ((v3 & 1) != 0 || (v3 & 2) == 0 && *((_BYTE *)this + 21))
      {
        v4 = DCSRecord::yomiString(this);
        v5 = DCSRecord::dataString(this);
      }
      else
      {
        v4 = DCSRecord::dataString(this);
        v5 = DCSRecord::yomiString(this);
      }
      v7 = v5;
      if (CFStringCompare(v4, v5, 0))
      {
        v8 = *((_QWORD *)this + 3);
        if ((v8 & 8) != 0)
        {
          result = (void *)CFStringCreateWithFormat(0, 0, CFSTR("%@  %@"), v4, v7);
        }
        else if ((v8 & 0x10) != 0)
        {
          result = (void *)CFStringCreateWithFormat(0, 0, CFSTR("%@ (%@)"), v4, v7);
        }
        else
        {
          result = (void *)CFStringCreateWithFormat(0, 0, CFSTR("%@%C%@%C"), v4, 12304, v7, 12305);
        }
        goto LABEL_19;
      }
      v6 = v4;
    }
    else
    {
      v6 = DCSRecord::dataString(this);
    }
    result = (void *)CFRetain(v6);
LABEL_19:
    *((_QWORD *)this + 22) = result;
  }
  return result;
}

CFStringRef DCSRecord::dataString(DCSRecord *this)
{
  CFStringRef result;
  const UInt8 *v3;

  result = (CFStringRef)*((_QWORD *)this + 9);
  if (!result)
  {
    v3 = (const UInt8 *)*((_QWORD *)this + 7);
    if (v3)
    {
      result = CFStringCreateWithBytes(0, v3, *((_QWORD *)this + 8), *((_DWORD *)this + 4), 0);
      *((_QWORD *)this + 9) = result;
    }
    else
    {
      return DCSRecord::keyString(this);
    }
  }
  return result;
}

CFStringRef DCSRecord::yomiString(DCSRecord *this)
{
  const UInt8 *v1;
  CFStringRef result;

  v1 = (const UInt8 *)*((_QWORD *)this + 16);
  if (!v1)
    return 0;
  result = (CFStringRef)*((_QWORD *)this + 18);
  if (!result)
  {
    result = CFStringCreateWithBytes(0, v1, *((_QWORD *)this + 17), *((_DWORD *)this + 4), 0);
    *((_QWORD *)this + 18) = result;
  }
  return result;
}

CFStringRef DCSRecord::setHeadword(DCSRecord *this, CFStringRef theString)
{
  const void *v4;
  const void *v5;
  CFStringRef result;

  v4 = (const void *)*((_QWORD *)this + 22);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)this + 22) = CFStringCreateCopy(0, theString);
  v5 = (const void *)*((_QWORD *)this + 9);
  if (v5)
    CFRelease(v5);
  result = CFStringCreateCopy(0, theString);
  *((_QWORD *)this + 9) = result;
  return result;
}

CFStringRef DCSRecord::titleString(DCSRecord *this)
{
  const UInt8 *v2;
  CFStringRef result;

  v2 = (const UInt8 *)*((_QWORD *)this + 10);
  if (v2)
  {
    result = (CFStringRef)*((_QWORD *)this + 12);
    if (!result)
    {
      result = CFStringCreateWithBytes(0, v2, *((_QWORD *)this + 11), *((_DWORD *)this + 4), 0);
      *((_QWORD *)this + 12) = result;
    }
  }
  else if (*((uint64_t *)this + 17) < 1)
  {
    return 0;
  }
  else
  {
    return DCSRecord::dataString(this);
  }
  return result;
}

CFStringRef DCSRecord::anchorString(DCSRecord *this)
{
  const UInt8 *v1;
  CFStringRef result;

  v1 = (const UInt8 *)*((_QWORD *)this + 13);
  if (!v1)
    return 0;
  result = (CFStringRef)*((_QWORD *)this + 15);
  if (!result)
  {
    result = CFStringCreateWithBytes(0, v1, *((_QWORD *)this + 14), *((_DWORD *)this + 4), 0);
    *((_QWORD *)this + 15) = result;
  }
  return result;
}

CFStringRef DCSRecord::sortkeyString(DCSRecord *this)
{
  const UInt8 *v1;
  CFStringRef result;

  v1 = (const UInt8 *)*((_QWORD *)this + 19);
  if (!v1)
    return 0;
  result = (CFStringRef)*((_QWORD *)this + 21);
  if (!result)
  {
    result = CFStringCreateWithBytes(0, v1, *((_QWORD *)this + 20), *((_DWORD *)this + 4), 0);
    *((_QWORD *)this + 21) = result;
  }
  return result;
}

CFStringRef DCSRecord::headwordSortString(DCSRecord *this, int a2)
{
  CFStringRef result;
  const __CFString *v4;
  const __CFString *MutableCopy;
  const __CFLocale *v6;
  const __CFString *v7;
  CFStringRef v8;

  if (!*((_BYTE *)this + 21) || a2 && (*((_BYTE *)this + 24) & 2) != 0)
  {
    result = (CFStringRef)*((_QWORD *)this + 23);
    if (!result)
    {
      v4 = DCSRecord::dataString(this);
      MutableCopy = CFStringCreateMutableCopy(0, 0, v4);
      v6 = (const __CFLocale *)DCSDictionary::primaryLocale(*(DCSDictionary **)this);
      DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 1, v6);
      *((_QWORD *)this + 23) = MutableCopy;
      v7 = DCSRecord::dataString(this);
      if (CFStringCompare(v7, MutableCopy, 0))
      {
        return (CFStringRef)*((_QWORD *)this + 23);
      }
      else
      {
        CFRelease(MutableCopy);
        v8 = DCSRecord::dataString(this);
        result = (CFStringRef)CFRetain(v8);
        *((_QWORD *)this + 23) = result;
      }
    }
  }
  else
  {
    result = DCSRecord::yomiString(this);
    if (!result)
    {
      if (!*((_QWORD *)this + 7) && (*((_BYTE *)this + 24) & 0x20) != 0)
        return DCSRecord::keyString(this);
      else
        return 0;
    }
  }
  return result;
}

uint64_t DCSRecord::copyData(DCSDictionary **this, uint64_t a2)
{
  return DCSDictionary::copyData(*this, (DCSRecord *)this, a2);
}

uint64_t DCSRecord::copyDataURL(DCSDictionary **this, uint64_t a2)
{
  return DCSDictionary::copyDataURL(*this, (DCSRecord *)this, a2);
}

__CFDictionary *DCSRecord::copyKeyedElements(DCSDictionary **this, const __CFArray *a2)
{
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex v6;
  CFIndex v7;
  CFIndex i;
  const void *ValueAtIndex;
  CFIndex FirstIndexOfValue;
  const void *v11;
  CFIndex v12;
  const __CFDictionary *v13;
  __CFDictionary *v14;
  const __CFDictionary *v15;
  CFIndex v16;
  const __CFArray *v17;
  unint64_t v18;
  const void **v19;
  size_t v20;
  __CFArray *v21;
  const __CFString **v22;
  CFIndex v23;
  const __CFString *v24;
  const __CFString *v25;
  const void **v26;
  CFIndex j;
  const __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  const __CFString *Value;
  __CFDictionary *v32;
  const __CFString *v33;
  const __CFString *v34;
  const void *v35;
  const void *v36;
  CFRange v37;
  CFStringRef v38;
  CFStringRef v39;
  const __CFDictionary *v40;
  const __CFDictionary *MutableCopy;
  __CFDictionary *v42;
  int v43;
  DCSDictionary **v44;
  char v45;
  const __CFString *v46;
  const __CFString *v47;
  const void *v48;
  uint64_t v50;
  DCSDictionary **v51;
  const __CFDictionary *v52;
  uint64_t v53;
  CFRange v54;
  CFRange v55;
  CFRange v56;
  CFRange v57;

  v53 = *MEMORY[0x1E0C80C00];
  if (DCSDictionary::previewMarkupVersion(*this) == 1)
  {
    if (DCSRecord::copyKeyedElements(__CFArray const*)::_DispatchOnceToken != -1)
      dispatch_once(&DCSRecord::copyKeyedElements(__CFArray const*)::_DispatchOnceToken, &__block_literal_global_1);
    if (a2)
    {
      Count = CFArrayGetCount((CFArrayRef)DCSRecord::copyKeyedElements(__CFArray const*)::_DefinedKeyArray);
      Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E0C9B378]);
      v6 = CFArrayGetCount(a2);
      if (v6 >= 1)
      {
        v7 = v6;
        for (i = 0; i != v7; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
          v54.location = 0;
          v54.length = Count;
          FirstIndexOfValue = CFArrayGetFirstIndexOfValue((CFArrayRef)DCSRecord::copyKeyedElements(__CFArray const*)::_DefinedKeyArray, v54, ValueAtIndex);
          if (FirstIndexOfValue != -1)
          {
            v11 = CFArrayGetValueAtIndex((CFArrayRef)DCSRecord::copyKeyedElements(__CFArray const*)::_DefinedKeyArray, FirstIndexOfValue);
            CFArrayAppendValue(Mutable, v11);
          }
        }
      }
    }
    else
    {
      Mutable = (__CFArray *)CFRetain((CFTypeRef)DCSRecord::copyKeyedElements(__CFArray const*)::_DefinedKeyArray);
    }
    if (CFArrayGetCount(Mutable) < 1)
      v14 = 0;
    else
      v14 = DCSRecord::copyElementsByMarkupText(this, Mutable);
    v17 = Mutable;
    goto LABEL_72;
  }
  v51 = this;
  if (a2)
  {
    v12 = CFArrayGetCount(a2);
    v13 = (const __CFDictionary *)DCSDictionary::elementXPaths(*this);
    CFRetain(a2);
  }
  else
  {
    v15 = (const __CFDictionary *)DCSDictionary::elementXPaths(*this);
    v13 = v15;
    if (v15)
    {
      v15 = (const __CFDictionary *)CFDictionaryGetCount(v15);
      v16 = (CFIndex)v15;
    }
    else
    {
      v16 = 0;
    }
    v12 = v16 + 3;
    MEMORY[0x1E0C80A78](v15);
    v19 = (const void **)((char *)&v50 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0));
    if (v18 >= 0x200)
      v20 = 512;
    else
      v20 = v18;
    bzero((char *)&v50 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0), v20);
    v21 = CFArrayCreateMutable(0, v16, MEMORY[0x1E0C9B378]);
    if (v13)
    {
      CFDictionaryGetKeysAndValues(v13, v19, 0);
      if (v16 >= 1)
      {
        v22 = (const __CFString **)v19;
        v23 = v16;
        do
        {
          v24 = (const __CFString *)_CopyConvertedTextElementKey(*v22, 0);
          if (v24)
          {
            v25 = v24;
            *v22 = v24;
            CFArrayAppendValue(v21, v24);
            CFRelease(v25);
          }
          ++v22;
          --v23;
        }
        while (v23);
      }
    }
    v26 = &v19[v16];
    *v26 = CFSTR("DCSTextElementKeyRecordID");
    v26[1] = CFSTR("DCSTextElementKeyHeadword");
    v26[2] = CFSTR("DCSTextElementKeySensesWithAttributes");
    a2 = CFArrayCreate(0, v19, v16 + 3, MEMORY[0x1E0C9B378]);
    CFRelease(v21);
  }
  v52 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v12 >= 1)
  {
    for (j = 0; v12 != j; ++j)
    {
      v28 = (const __CFString *)CFArrayGetValueAtIndex(a2, j);
      v29 = v28;
      if (v13
        && (CFStringCompare(v28, CFSTR("DCSTextElementKeySensesWithAttributes"), 0)
          ? (v30 = v29)
          : (v30 = CFSTR("DCSTextElementKeySenses")),
            (Value = (const __CFString *)CFDictionaryGetValue(v13, v30)) != 0
         || (v35 = _CopyConvertedTextElementKey(v30, 1)) != 0
         && (v36 = v35, Value = (const __CFString *)CFDictionaryGetValue(v13, v35), CFRelease(v36), Value)))
      {
        v32 = v52;
        v33 = v29;
        v34 = Value;
      }
      else
      {
        if (CFStringCompare(v29, CFSTR("id"), 0) && CFStringCompare(v29, CFSTR("DCSTextElementKeyRecordID"), 0))
        {
          if (CFStringHasPrefix(v29, CFSTR("xpath_")))
          {
            v37 = CFStringFind(v29, CFSTR(":"), 0);
            if (v37.length)
            {
              v56.length = CFStringGetLength(v29) - (v37.location + v37.length);
              v56.location = v37.location + v37.length;
              v38 = CFStringCreateWithSubstring(0, v29, v56);
              v57.location = 0;
              v57.length = v37.location + v37.length;
              v39 = CFStringCreateWithSubstring(0, v29, v57);
              CFDictionarySetValue(v52, v39, v38);
              CFRelease(v38);
              CFRelease(v39);
            }
          }
          continue;
        }
        v32 = v52;
        v33 = CFSTR("DCSTextElementKeyRecordID");
        v34 = CFSTR("//d:entry/@id");
      }
      CFDictionarySetValue(v32, v33, v34);
    }
  }
  if (v13 && (v40 = (const __CFDictionary *)CFDictionaryGetValue(v13, CFSTR("namespaces"))) != 0)
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v40);
  else
    MutableCopy = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v42 = MutableCopy;
  v43 = CFDictionaryContainsKey(MutableCopy, CFSTR("d"));
  v44 = v51;
  if (!v43)
    CFDictionarySetValue(v42, CFSTR("d"), CFSTR("http://www.apple.com/DTDs/DictionaryService-1.0.rng"));
  if (CFDictionaryGetCount(v52))
  {
    v45 = 1;
    v46 = (const __CFString *)DCSDictionary::copyData(*v44, (DCSRecord *)v44, 1);
    v47 = v46;
    if (v46)
    {
      v14 = CopyXPathElementsArray(v46, v52, v42);
      v45 = 0;
    }
    else
    {
      v14 = 0;
    }
  }
  else
  {
    v47 = 0;
    v14 = 0;
    v45 = 1;
  }
  v55.length = CFArrayGetCount(a2);
  v55.location = 0;
  if (CFArrayContainsValue(a2, v55, CFSTR("DCSTextElementKeyHeadword"))
    && (!v14 || !CFDictionaryContainsKey(v14, CFSTR("DCSTextElementKeyHeadword"))))
  {
    v48 = DCSRecord::titleString((DCSRecord *)v44);
    if (v48 || (v48 = DCSRecord::headword((DCSRecord *)v44)) != 0)
    {
      if (!v14)
        v14 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue(v14, CFSTR("DCSTextElementKeyHeadword"), v48);
    }
  }
  CFRelease(v42);
  CFRelease(v52);
  if ((v45 & 1) == 0)
    CFRelease(v47);
  if (a2)
  {
    v17 = a2;
LABEL_72:
    CFRelease(v17);
  }
  return v14;
}

CFArrayRef ___ZN9DCSRecord17copyKeyedElementsEPK9__CFArray_block_invoke()
{
  CFArrayRef result;
  const void *v1[8];

  v1[7] = *(const void **)MEMORY[0x1E0C80C00];
  v1[0] = CFSTR("DCSTextElementKeyRecordID");
  v1[1] = CFSTR("DCSTextElementKeyHeadword");
  v1[2] = CFSTR("DCSTextElementKeySyllabifiedHeadword");
  v1[3] = CFSTR("DCSTextElementKeyPartOfSpeech");
  v1[4] = CFSTR("DCSTextElementKeyPronunciation");
  v1[5] = CFSTR("DCSTextElementKeySenses");
  v1[6] = CFSTR("DCSTextElementKeySensesWithAttributes");
  result = CFArrayCreate(0, v1, 7, MEMORY[0x1E0C9B378]);
  DCSRecord::copyKeyedElements(__CFArray const*)::_DefinedKeyArray = (uint64_t)result;
  return result;
}

__CFDictionary *DCSRecord::copyElementsByMarkupText(DCSDictionary **this, const __CFArray *a2)
{
  const __CFString *v3;
  const __CFString *v4;
  CFIndex Length;
  __CFDictionary *Mutable;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  __CFString *v9;
  CFIndex v10;
  CFIndex v11;
  CFIndex v12;
  CFRange *v13;
  CFIndex v14;
  __int16 v15;
  int64_t v16;
  const __CFString *v17;
  CFIndex v18;
  CFRange *v19;
  int64_t v20;
  unsigned __int16 v21;
  CFIndex v22;
  CFIndex v23;
  CFIndex v24;
  CFRange *v25;
  int64_t v26;
  unsigned int v27;
  int64_t v28;
  int64_t v29;
  uint64_t v30;
  CFIndex v31;
  __int16 v32;
  CFIndex v33;
  uint64_t v34;
  CFIndex v35;
  int64_t v36;
  int64_t v37;
  char v38;
  CFIndex v39;
  CFIndex v40;
  CFIndex v41;
  CFRange *v42;
  int64_t v43;
  int v44;
  int64_t v45;
  int64_t v46;
  int64_t i;
  uint64_t v48;
  int v49;
  char v50;
  char v51;
  CFIndex v52;
  CFIndex v53;
  uint64_t v54;
  CFIndex v55;
  int64_t v56;
  int64_t v57;
  CFStringRef v58;
  const __CFString *Value;
  const __CFString *v60;
  __CFString *v61;
  __CFString *v62;
  CFIndex v63;
  CFIndex v64;
  CFIndex v65;
  CFIndex v66;
  CFIndex v67;
  const __CFString *v68;
  uint64_t Count;
  CFMutableDictionaryRef v70;
  __CFDictionary *v71;
  CFIndex v72;
  __CFString *ValueAtIndex;
  __CFString *v74;
  const void *v75;
  CFIndex v76;
  const __CFString *v77;
  int v78;
  CFIndex location;
  CFIndex v80;
  CFStringRef v81;
  CFIndex v82;
  const void *ExtractedStringsMarkedByTag;
  __CFDictionary *v84;
  const __CFString *v85;
  const __CFString *v86;
  const __CFString *v87;
  int v88;
  const __CFString *v89;
  const __CFDictionary *v90;
  CFIndex v91;
  CFIndex v92;
  CFIndex j;
  const __CFDictionary *v94;
  const void *v95;
  __CFDictionary *v97;
  const __CFArray *v98;
  const __CFString *v100;
  __CFDictionary *v101;
  const __CFString *v102;
  CFRange range;
  CFRange buffer[8];
  CFStringRef theString;
  CFRange *v106;
  const char *v107;
  uint64_t v108;
  CFIndex v109;
  CFIndex v110;
  CFIndex v111;
  CFRange v112;
  CFRange v113;
  CFRange v114;
  CFRange v115;
  CFRange v116;
  CFRange v117;
  CFRange v118;
  CFRange v119;
  CFRange v120;
  CFRange v121;
  CFRange v122;
  CFRange v123;
  CFRange v124;
  CFRange v125;
  CFRange v126;

  v3 = (const __CFString *)DCSDictionary::copyData(*this, (DCSRecord *)this, 255);
  if (!v3)
    return 0;
  v4 = v3;
  Length = CFStringGetLength(v3);
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionaryAddValue(Mutable, CFSTR("amp"), CFSTR("&"));
  CFDictionaryAddValue(Mutable, CFSTR("quot"), CFSTR("\""));
  CFDictionaryAddValue(Mutable, CFSTR("lt"), CFSTR("<"));
  CFDictionaryAddValue(Mutable, CFSTR("gt"), CFSTR(">"));
  CFDictionaryAddValue(Mutable, CFSTR("apos"), CFSTR("'"));
  theString = v4;
  v108 = 0;
  v109 = Length - 1;
  CharactersPtr = CFStringGetCharactersPtr(v4);
  CStringPtr = 0;
  v106 = (CFRange *)CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(v4, 0x600u);
  v110 = 0;
  v111 = 0;
  v107 = CStringPtr;
  v9 = CFStringCreateMutable(0, 0);
  v98 = a2;
  v100 = v9;
  if (Length >= 1)
  {
    v10 = 0;
    v11 = 0;
    v101 = Mutable;
    v102 = v4;
    while (1)
    {
      if (v11 < 0 || (v12 = v109, v109 <= v11))
      {
        v16 = v11 + 1;
        goto LABEL_12;
      }
      v13 = v106;
      if (v106)
        break;
      if (!v107)
      {
        if (v111 <= v11 || (v22 = v110, v110 > v11))
        {
          v23 = v11 - 4;
          if ((unint64_t)v11 < 4)
            v23 = 0;
          if (v23 + 64 < v109)
            v12 = v23 + 64;
          v110 = v23;
          v111 = v12;
          v112.location = v108 + v23;
          v112.length = v12 - v23;
          CFStringGetCharacters(theString, v112, (UniChar *)buffer);
          v22 = v110;
        }
        v14 = v11 - v22;
        v13 = buffer;
        goto LABEL_10;
      }
      v15 = v107[v108 + v11];
LABEL_16:
      v16 = v11 + 1;
      if (v15 == 38)
      {
        if (v11 > v10)
        {
          v118.location = v10;
          v118.length = v11 - v10;
          v17 = CFStringCreateWithSubstring(0, v4, v118);
          CFStringAppend(v9, v17);
          CFRelease(v17);
        }
        v18 = v109;
        if (v109 <= v16)
        {
          v21 = 0;
          v16 = v11 + 2;
        }
        else
        {
          v19 = v106;
          if (v106)
          {
            v20 = v108 + v16;
            goto LABEL_22;
          }
          if (v107)
          {
            v21 = v107[v108 + v16];
          }
          else
          {
            if (v111 <= v16 || (v39 = v110, v110 > v16))
            {
              v40 = v11 - 3;
              if ((unint64_t)v11 < 3)
                v40 = 0;
              if (v40 + 64 < v109)
                v18 = v40 + 64;
              v110 = v40;
              v111 = v18;
              v114.location = v108 + v40;
              v114.length = v18 - v40;
              CFStringGetCharacters(theString, v114, (UniChar *)buffer);
              v39 = v110;
            }
            v20 = v16 - v39;
            v19 = buffer;
LABEL_22:
            v21 = *((_WORD *)&v19->location + v20);
          }
          v16 = v11 + 2;
          if (v21 == 35)
          {
            v24 = v109;
            if (v109 <= v16)
            {
              v38 = 0;
              v21 = 0;
              v16 = v11 + 3;
            }
            else
            {
              v25 = v106;
              if (v106)
              {
                v26 = v108 + v16;
                goto LABEL_38;
              }
              if (v107)
              {
                v21 = v107[v108 + v16];
              }
              else
              {
                if (v111 <= v16 || (v64 = v110, v110 > v16))
                {
                  v65 = v11 - 2;
                  if ((unint64_t)v11 < 2)
                    v65 = 0;
                  if (v65 + 64 < v109)
                    v24 = v65 + 64;
                  v110 = v65;
                  v111 = v24;
                  v116.location = v108 + v65;
                  v116.length = v24 - v65;
                  CFStringGetCharacters(theString, v116, (UniChar *)buffer);
                  v64 = v110;
                }
                v26 = v16 - v64;
                v25 = buffer;
LABEL_38:
                v21 = *((_WORD *)&v25->location + v26);
              }
              v16 = v11 + 3;
              if (v21 == 120)
              {
                v41 = v109;
                if (v109 <= v16)
                {
                  v21 = 0;
                }
                else
                {
                  v42 = v106;
                  if (v106)
                  {
                    v43 = v108 + v16;
                    goto LABEL_80;
                  }
                  if (v107)
                  {
                    v21 = v107[v108 + v16];
                  }
                  else
                  {
                    if (v111 <= v16 || (v66 = v110, v110 > v16))
                    {
                      v67 = v11 - 1;
                      if (!v11)
                        v67 = 0;
                      if (v67 + 64 < v109)
                        v41 = v67 + 64;
                      v110 = v67;
                      v111 = v41;
                      v117.location = v108 + v67;
                      v117.length = v41 - v67;
                      CFStringGetCharacters(theString, v117, (UniChar *)buffer);
                      v66 = v110;
                    }
                    v43 = v16 - v66;
                    v42 = buffer;
LABEL_80:
                    v21 = *((_WORD *)&v42->location + v43);
                  }
                }
                v16 = v11 + 4;
                v44 = 16;
                v38 = 1;
LABEL_85:
                v27 = 0;
                if (Length <= v16)
                  v45 = v16;
                else
                  v45 = Length;
                v46 = -v16;
                for (i = v16 + 64; ; ++i)
                {
                  if ((unint64_t)v16 >= 4)
                    v48 = 4;
                  else
                    v48 = v16;
                  if ((unsigned __int16)(v21 - 48) > 9u)
                  {
                    v50 = v38 ^ 1;
                    if ((unsigned __int16)(v21 - 97) > 5u)
                      v51 = 1;
                    else
                      v51 = v38 ^ 1;
                    if ((v51 & 1) != 0)
                    {
                      if ((unsigned __int16)(v21 - 65) > 5u)
                        v50 = 1;
                      if ((v50 & 1) != 0)
                      {
                        a2 = v98;
                        v9 = (__CFString *)v100;
                        Mutable = v101;
                        v4 = v102;
                        goto LABEL_40;
                      }
                      v49 = 16 * v27 - 55;
                    }
                    else
                    {
                      v49 = 16 * v27 - 87;
                    }
                  }
                  else
                  {
                    v49 = v27 * v44 - 48;
                  }
                  v27 = v49 + v21;
                  if (v45 == v16)
                  {
                    v16 = v45;
                    a2 = v98;
                    v9 = (__CFString *)v100;
                    Mutable = v101;
                    v4 = v102;
                    goto LABEL_121;
                  }
                  if (v16 < 0 || (v52 = v109, v109 <= v16))
                  {
                    v21 = 0;
                  }
                  else if (v106)
                  {
                    v21 = *((_WORD *)&v106->location + v16 + v108);
                  }
                  else if (v107)
                  {
                    v21 = v107[v108 + v16];
                  }
                  else
                  {
                    if (v111 <= v16 || (v53 = v110, v110 > v16))
                    {
                      v54 = v48 + v46;
                      v55 = i - v48;
                      v56 = v16 - v48;
                      v57 = v56 + 64;
                      if (v56 + 64 >= v109)
                        v57 = v109;
                      v110 = v56;
                      v111 = v57;
                      if (v109 >= v55)
                        v52 = v55;
                      v115.length = v52 + v54;
                      v115.location = v56 + v108;
                      CFStringGetCharacters(theString, v115, (UniChar *)buffer);
                      v53 = v110;
                    }
                    v21 = *((_WORD *)&buffer[0].location + v16 - v53);
                  }
                  ++v16;
                  --v46;
                }
              }
              v38 = 0;
            }
            v44 = 10;
            goto LABEL_85;
          }
        }
        v27 = 0xFFFF;
LABEL_40:
        if (v21 != 59 && v16 < Length)
        {
          v28 = -v16;
          v29 = v16 + 64;
          do
          {
            if ((unint64_t)v16 >= 4)
              v30 = 4;
            else
              v30 = v16;
            if (v16 < 0 || (v31 = v109, v109 <= v16))
            {
              v32 = 0;
            }
            else if (v106)
            {
              v32 = *((_WORD *)&v106->location + v16 + v108);
            }
            else if (v107)
            {
              v32 = v107[v108 + v16];
            }
            else
            {
              if (v111 <= v16 || (v33 = v110, v110 > v16))
              {
                v34 = v30 + v28;
                v35 = v29 - v30;
                v36 = v16 - v30;
                v37 = v36 + 64;
                if (v36 + 64 >= v109)
                  v37 = v109;
                v110 = v36;
                v111 = v37;
                if (v109 >= v35)
                  v31 = v35;
                v113.length = v31 + v34;
                v113.location = v36 + v108;
                CFStringGetCharacters(theString, v113, (UniChar *)buffer);
                v33 = v110;
              }
              v32 = *((_WORD *)&buffer[0].location + v16 - v33);
            }
            ++v16;
            if (v32 == 59)
              break;
            --v28;
            ++v29;
          }
          while (v16 < Length);
          a2 = v98;
        }
LABEL_121:
        if (v27 == 0xFFFF)
        {
          v119.length = v16 - v11 - 2;
          v119.location = v11 + 1;
          v58 = CFStringCreateWithSubstring(0, v4, v119);
          Value = (const __CFString *)CFDictionaryGetValue(Mutable, v58);
          if (Value)
          {
            v60 = Value;
            v61 = v9;
          }
          else
          {
            CFRelease(v58);
            v120.location = v11;
            v120.length = v16 - v11;
            v58 = CFStringCreateWithSubstring(0, v4, v120);
            v61 = v9;
            v60 = v58;
          }
          CFStringAppend(v61, v60);
          CFRelease(v58);
        }
        else
        {
          if (v27 < 0x10000)
          {
            LOWORD(range.length) = v27;
            v62 = v9;
            v63 = 1;
          }
          else
          {
            LOWORD(range.length) = ((v27 + 67043328) >> 10) - 10240;
            WORD1(range.length) = v27 & 0x3FF | 0xDC00;
            v62 = v9;
            v63 = 2;
          }
          CFStringAppendCharacters(v62, (const UniChar *)&range.length, v63);
        }
        v10 = v16;
      }
LABEL_12:
      v11 = v16;
      if (v16 >= Length)
        goto LABEL_151;
    }
    v14 = v108 + v11;
LABEL_10:
    v15 = *((_WORD *)&v13->location + v14);
    goto LABEL_16;
  }
  v16 = 0;
  v10 = 0;
LABEL_151:
  if (v10 < Length)
  {
    v121.length = v16 - v10;
    v121.location = v10;
    v68 = CFStringCreateWithSubstring(0, v4, v121);
    CFStringAppend(v9, v68);
    CFRelease(v68);
  }
  CFRelease(Mutable);
  if (v9)
    CFRelease(v4);
  else
    v100 = v4;
  Count = CFArrayGetCount(a2);
  v70 = CFDictionaryCreateMutable(0, Count, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v71 = v70;
  if (Count >= 1)
  {
    v72 = 0;
    v97 = v70;
    while (1)
    {
      ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(a2, v72);
      if (ValueAtIndex != CFSTR("DCSTextElementKeyRecordID"))
        break;
      v76 = CFStringGetLength(v100);
      v77 = CFStringCreateWithFormat(0, 0, CFSTR("<%@ "), CFSTR("d:entry"));
      v122.location = 0;
      v122.length = v76;
      v78 = CFStringFindWithOptions(v100, v77, v122, 0, buffer);
      CFRelease(v77);
      if (!v78)
        goto LABEL_200;
      location = buffer[0].location;
      v123.length = v76 - buffer[0].location;
      v123.location = buffer[0].location;
      if (!CFStringFindWithOptions(v100, CFSTR(">"), v123, 0, buffer))
        goto LABEL_200;
      v80 = buffer[0].location - location;
      v81 = CFStringCreateWithFormat(0, 0, CFSTR("%@=\""), CFSTR("id"));
      v124.location = location;
      v124.length = v80;
      if (!CFStringFindWithOptions(v100, v81, v124, 0, buffer)
        || (v82 = buffer[0].length + buffer[0].location,
            v125.length = v76 - (buffer[0].length + buffer[0].location),
            v125.location = buffer[0].length + buffer[0].location,
            !CFStringFindWithOptions(v100, CFSTR("\""), v125, 0, buffer)))
      {
        CFRelease(v81);
        goto LABEL_200;
      }
      v126.length = buffer[0].location - v82;
      buffer[0].location = v82;
      buffer[0].length = v126.length;
      v126.location = v82;
      ExtractedStringsMarkedByTag = CFStringCreateWithSubstring(0, v100, v126);
      CFRelease(v81);
      if (ExtractedStringsMarkedByTag)
      {
        v84 = v71;
        v85 = CFSTR("DCSTextElementKeyRecordID");
LABEL_198:
        CFDictionarySetValue(v84, v85, ExtractedStringsMarkedByTag);
        CFRelease(ExtractedStringsMarkedByTag);
      }
LABEL_200:
      if (++v72 == Count)
        goto LABEL_201;
    }
    v74 = ValueAtIndex;
    if (ValueAtIndex != CFSTR("DCSTextElementKeyPartOfSpeech")
      && ValueAtIndex != CFSTR("DCSTextElementKeyPronunciation")
      && ValueAtIndex != CFSTR("DCSTextElementKeySenses")
      && ValueAtIndex != CFSTR("DCSTextElementKeySensesWithAttributes")
      && ValueAtIndex != CFSTR("DCSTextElementKeySyllabifiedHeadword"))
    {
      if (ValueAtIndex == CFSTR("DCSTextElementKeyHeadword"))
      {
        v75 = DCSRecord::titleString((DCSRecord *)this);
        if (v75 || (v75 = DCSRecord::headword((DCSRecord *)this)) != 0)
          CFDictionarySetValue(v71, CFSTR("DCSTextElementKeyHeadword"), v75);
      }
      goto LABEL_200;
    }
    v86 = CFSTR("d:def");
    if (ValueAtIndex == CFSTR("DCSTextElementKeySyllabifiedHeadword"))
      v86 = CFSTR("d:syl");
    if (ValueAtIndex == CFSTR("DCSTextElementKeyPronunciation"))
      v86 = CFSTR("d:prn");
    if (ValueAtIndex == CFSTR("DCSTextElementKeyPartOfSpeech"))
      v87 = CFSTR("d:pos");
    else
      v87 = v86;
    v88 = ValueAtIndex == CFSTR("DCSTextElementKeySensesWithAttributes")
       || ValueAtIndex == CFSTR("DCSTextElementKeySenses");
    if (ValueAtIndex == CFSTR("DCSTextElementKeySensesWithAttributes"))
    {
      range.length = (CFIndex)CFSTR("d:prtl");
      buffer[0].location = (CFIndex)CFSTR("DCSTextElementSenseKeyIsExplicit");
      v90 = CFDictionaryCreate(0, (const void **)buffer, (const void **)&range.length, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      ExtractedStringsMarkedByTag = _CreateExtractedStringsMarkedByTag(v100, v87, CFSTR("1"), v90, v88);
      if (v90)
        CFRelease(v90);
      if (!ExtractedStringsMarkedByTag)
        goto LABEL_200;
      v91 = CFArrayGetCount((CFArrayRef)ExtractedStringsMarkedByTag);
      if (v91 >= 1)
      {
        v92 = v91;
        for (j = 0; j != v92; ++j)
        {
          v94 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)ExtractedStringsMarkedByTag, j);
          v95 = CFDictionaryGetValue(v94, CFSTR("temp_text"));
          CFDictionarySetValue(v94, CFSTR("DCSTextElementSenseKeyText"), v95);
          CFDictionaryRemoveValue(v94, CFSTR("temp_text"));
        }
        a2 = v98;
        v71 = v97;
      }
    }
    else
    {
      if (v88)
        v89 = CFSTR("1");
      else
        v89 = 0;
      ExtractedStringsMarkedByTag = _CreateExtractedStringsMarkedByTag(v100, v87, v89, 0, v88);
      if (!ExtractedStringsMarkedByTag)
        goto LABEL_200;
    }
    v84 = v71;
    v85 = v74;
    goto LABEL_198;
  }
LABEL_201:
  CFRelease(v100);
  if (!CFDictionaryGetCount(v71))
  {
    CFRelease(v71);
    return 0;
  }
  return v71;
}

const void *_CopyConvertedTextElementKey(const __CFString *key, int a2)
{
  uint64_t *v4;

  if (_CopyConvertedTextElementKey(__CFString const*,BOOL)::_DispatchOnceToken != -1)
    dispatch_once(&_CopyConvertedTextElementKey(__CFString const*,BOOL)::_DispatchOnceToken, &__block_literal_global_53);
  v4 = &_CopyConvertedTextElementKey(__CFString const*,BOOL)::_NewToOldDict;
  if (!a2)
    v4 = &_CopyConvertedTextElementKey(__CFString const*,BOOL)::_OldToNewDict;
  return CFDictionaryGetValue((CFDictionaryRef)*v4, key);
}

uint64_t DCSRecord::dictionaryRef(DCSRecord *this)
{
  return **(_QWORD **)this;
}

uint64_t DCSRecord::subDictionaryRef(DCSRecord *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 29);
  if (v1)
    return *(_QWORD *)v1;
  else
    return 0;
}

__CFArray *_CreateExtractedStringsMarkedByTag(const __CFString *a1, const __CFString *a2, const __CFString *a3, const __CFDictionary *a4, int a5)
{
  CFIndex Length;
  const __CFString *v10;
  CFIndex Count;
  const __CFString *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  const void **v16;
  size_t v17;
  uint64_t v18;
  char *v19;
  const __CFString *v20;
  __CFArray *Mutable;
  CFIndex v22;
  const void *v23;
  const void *v24;
  CFIndex v25;
  CFIndex location;
  __CFArray *v28;
  int v29;
  CFIndex v30;
  CFIndex v31;
  CFIndex v32;
  CFIndex v33;
  UniChar *v34;
  uint64_t v35;
  char v36;
  CFIndex v37;
  int v38;
  CFStringRef v39;
  int v40;
  uint64_t v41;
  __CFDictionary *v42;
  const __CFString **v43;
  const void **v44;
  const __CFString *v45;
  const void *v46;
  const void *v47;
  uint64_t v49;
  CFMutableArrayRef v50;
  const __CFString **v51;
  uint64_t *v52;
  uint64_t v53;
  CFIndex v54;
  const void **v55;
  CFStringRef v56;
  int v57;
  CFStringRef v58;
  CFStringRef v59;
  CFRange result;
  CFRange v61;
  CFRange v62;
  uint64_t v63;
  CFRange v64;
  CFRange v65;
  CFRange v66;
  CFRange v67;
  CFRange v68;
  CFRange v69;
  CFRange v70;
  CFRange v71;
  CFRange v72;

  v57 = a5;
  v63 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  if (a3)
    v10 = CFStringCreateWithFormat(0, 0, CFSTR("%@=\"%@\""), a2, a3);
  else
    v10 = CFStringCreateWithFormat(0, 0, CFSTR("%@=\""), a2);
  v59 = v10;
  v58 = CFStringCreateWithFormat(0, 0, CFSTR("<%@></%@>"), a2, a2);
  Count = (CFIndex)CFStringCreateWithFormat(0, 0, CFSTR("<%@/>"), a2);
  v12 = (const __CFString *)Count;
  if (a4)
  {
    Count = CFDictionaryGetCount(a4);
    v13 = Count;
  }
  else
  {
    v13 = 0;
  }
  MEMORY[0x1E0C80A78](Count);
  v15 = (v14 + 23) & 0xFFFFFFFFFFFFFFF0;
  v16 = (const void **)((char *)&v49 - v15);
  if ((unint64_t)(8 * v13 + 8) >= 0x200)
    v17 = 512;
  else
    v17 = 8 * v13 + 8;
  bzero((char *)&v49 - v15, v17);
  MEMORY[0x1E0C80A78](v18);
  v19 = (char *)&v49 - v15;
  bzero(v19, v17);
  if (v13 >= 1)
    CFDictionaryGetKeysAndValues(a4, v16, (const void **)v19);
  v55 = v16;
  v20 = v59;
  v65.location = 0;
  v65.length = Length;
  if (!CFStringFindWithOptions(a1, v59, v65, 0, &result))
  {
    Mutable = 0;
    v39 = 0;
LABEL_66:
    v40 = v57;
    goto LABEL_67;
  }
  v51 = (const __CFString **)v19;
  v52 = &v49;
  v53 = v13;
  v56 = v12;
  Mutable = 0;
  v22 = 0;
  v23 = (const void *)*MEMORY[0x1E0C9AE50];
  v24 = (const void *)*MEMORY[0x1E0C9AE40];
  v25 = Length;
  v54 = Length;
  while (2)
  {
    location = result.location;
    v66.location = 0;
    v66.length = result.location;
    if (!CFStringFindWithOptions(a1, CFSTR("<"), v66, 4uLL, &v62))
      goto LABEL_60;
    v67.location = 0;
    v67.length = location;
    if (CFStringFindWithOptions(a1, CFSTR(">"), v67, 4uLL, &v61) && v62.location <= v61.location)
      goto LABEL_60;
    v28 = Mutable;
    v68.length = CFStringGetLength(a1) - location;
    v68.location = location;
    v29 = CFStringFindWithOptions(a1, CFSTR(">"), v68, 0, &v61);
    if (v29)
      v30 = v61.location - v62.location;
    else
      v30 = 0;
    if (v29)
      v31 = v62.location;
    else
      v31 = -1;
    if (v29)
      v32 = v61.location + 1;
    else
      v32 = 0;
    v69.location = v32;
    v69.length = Length - v32;
    if (!CFStringFindWithOptions(a1, v58, v69, 0, &result))
    {
      v70.location = v32;
      v70.length = Length - v32;
      if (!CFStringFindWithOptions(a1, v56, v70, 0, &result))
      {
        v39 = 0;
        v12 = v56;
        v40 = v57;
        Mutable = v28;
        v20 = v59;
        goto LABEL_67;
      }
    }
    v33 = result.location - v32;
    v34 = (UniChar *)malloc_type_malloc(2 * (result.location - v32), 0xC18A7B23uLL);
    v64.location = v32;
    v64.length = v33;
    CFStringGetCharacters(a1, v64, v34);
    Mutable = v28;
    v20 = v59;
    if (v33 < 1)
      goto LABEL_62;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    do
    {
      while (1)
      {
        v38 = v34[v35];
        if (v38 == 60)
        {
          v36 = 1;
          goto LABEL_41;
        }
        if ((v36 & 1) != 0)
        {
          v36 &= v38 != 62;
          goto LABEL_41;
        }
        if (v37 || v38 != 32)
          break;
        v36 = 0;
        v37 = 0;
        if (++v35 == v33)
          goto LABEL_62;
      }
      v36 = 0;
      v34[v37++] = v38;
LABEL_41:
      ++v35;
    }
    while (v35 != v33);
    if (v37 < 1)
    {
      if (v37)
        goto LABEL_47;
LABEL_62:
      free(v34);
      goto LABEL_63;
    }
    while (v34[v37 - 1] == 32)
    {
      if ((unint64_t)v37-- <= 1)
        goto LABEL_62;
    }
LABEL_47:
    v39 = CFStringCreateWithCharacters(0, v34, v37);
    free(v34);
    if (!v39)
    {
LABEL_64:
      v12 = v56;
      goto LABEL_66;
    }
    v40 = v57;
    if (v57)
    {
      if (!Mutable)
        Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      v41 = v53;
      if (v53 < 1)
      {
        CFArrayAppendValue(Mutable, v39);
      }
      else
      {
        v50 = Mutable;
        v42 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v43 = v51;
        v44 = v55;
        do
        {
          v45 = *v43++;
          v71.location = v31;
          v71.length = v30;
          if (CFStringFindWithOptions(a1, v45, v71, 0, 0))
            v46 = v23;
          else
            v46 = v24;
          v47 = *v44++;
          CFDictionarySetValue(v42, v47, v46);
          --v41;
        }
        while (v41);
        CFDictionarySetValue(v42, CFSTR("temp_text"), v39);
        Mutable = v50;
        CFArrayAppendValue(v50, v42);
        CFRelease(v42);
        v20 = v59;
      }
      CFRelease(v39);
      v22 = result.length + result.location;
      Length = v54;
      v25 = v54 - (result.length + result.location);
LABEL_60:
      v72.location = v22;
      v72.length = v25;
      if (!CFStringFindWithOptions(a1, v20, v72, 0, &result))
      {
LABEL_63:
        v39 = 0;
        goto LABEL_64;
      }
      continue;
    }
    break;
  }
  v12 = v56;
LABEL_67:
  CFRelease(v20);
  CFRelease(v58);
  CFRelease(v12);
  if (v40)
    return Mutable;
  else
    return (__CFArray *)v39;
}

CFDictionaryRef ___ZL28_CopyConvertedTextElementKeyPK10__CFStringb_block_invoke()
{
  const CFDictionaryKeyCallBacks *v0;
  const CFDictionaryValueCallBacks *v1;
  CFDictionaryRef result;
  _OWORD v3[2];
  void *keys[5];

  keys[4] = *(void **)MEMORY[0x1E0C80C00];
  keys[0] = CFSTR("DCSTextElementKeySyllabifiedHeadword");
  keys[1] = CFSTR("DCSTextElementKeyPartOfSpeech");
  keys[2] = CFSTR("DCSTextElementKeyPronunciation");
  keys[3] = CFSTR("DCSTextElementKeySenses");
  v3[0] = xmmword_1E8B56AD0;
  v3[1] = *(_OWORD *)off_1E8B56AE0;
  v0 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v1 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  _CopyConvertedTextElementKey(__CFString const*,BOOL)::_NewToOldDict = (uint64_t)CFDictionaryCreate(0, (const void **)keys, (const void **)v3, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  result = CFDictionaryCreate(0, (const void **)v3, (const void **)keys, 4, v0, v1);
  _CopyConvertedTextElementKey(__CFString const*,BOOL)::_OldToNewDict = (uint64_t)result;
  return result;
}

uint64_t _DCSRecordInitialize(void)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  _DCSRecordID = result;
  return result;
}

uint64_t _DCSRecordFinalize(uint64_t result)
{
  if (*(_QWORD *)(result + 16))
  {
    DCSRecord::~DCSRecord(*(DCSRecord **)(result + 16));
    JUMPOUT(0x1D17BC79CLL);
  }
  return result;
}

void sub_1CDF7540C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F0C406EFE96A2);
  _Unwind_Resume(a1);
}

BOOL _DCSRecordEqual(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  size_t v4;
  size_t v5;
  size_t v6;
  size_t v7;
  _QWORD *v8;
  _QWORD *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v14;

  v2 = a1[2];
  v3 = a2[2];
  v4 = *(_QWORD *)(v2 + 40);
  if (v4 != *(_QWORD *)(v3 + 40))
    return 0;
  v5 = *(_QWORD *)(v2 + 64);
  if (v5 != *(_QWORD *)(v3 + 64))
    return 0;
  v6 = *(_QWORD *)(v2 + 88);
  if (v6 != *(_QWORD *)(v3 + 88))
    return 0;
  v7 = *(_QWORD *)(v2 + 136);
  if (v7 != *(_QWORD *)(v3 + 136) || *(_QWORD *)v2 != *(_QWORD *)v3)
    return 0;
  v8 = *(_QWORD **)(v2 + 232);
  if (v8)
    v8 = (_QWORD *)*v8;
  v9 = *(_QWORD **)(v3 + 232);
  if (v9)
    v9 = (_QWORD *)*v9;
  if (v8 != v9)
    return 0;
  if (*(_QWORD *)(v2 + 208) != *(_QWORD *)(v3 + 208))
    return 0;
  if (*(unsigned __int16 *)(v2 + 192) != *(unsigned __int16 *)(v3 + 192))
    return 0;
  v10 = *(const void **)(v2 + 32);
  if (v10)
  {
    if (memcmp(v10, *(const void **)(v3 + 32), v4))
      return 0;
  }
  v11 = *(const void **)(v2 + 56);
  if (v11)
  {
    if (memcmp(v11, *(const void **)(v3 + 56), v5))
      return 0;
  }
  v12 = *(const void **)(v2 + 80);
  if (v12)
  {
    if (memcmp(v12, *(const void **)(v3 + 80), v6))
      return 0;
  }
  v14 = *(const void **)(v2 + 128);
  return !v14 || memcmp(v14, *(const void **)(v3 + 128), v7) == 0;
}

CFStringRef _DCSRecordCopyFormattingDesc(_QWORD *a1, const __CFDictionary *a2)
{
  DCSRecord *v3;
  const __CFAllocator *v4;
  void *v5;

  v3 = (DCSRecord *)a1[2];
  v4 = CFGetAllocator(a1);
  v5 = DCSRecord::headword(v3);
  return CFStringCreateWithFormat(v4, a2, CFSTR("<%@>"), v5);
}

CFStringRef _DCSRecordCopyDebugDesc(_QWORD *a1)
{
  DCSRecord *v1;
  const __CFAllocator *v2;
  CFStringRef v3;
  void *v4;

  v1 = (DCSRecord *)a1[2];
  v2 = CFGetAllocator(a1);
  v3 = DCSRecord::keyString(v1);
  v4 = DCSRecord::headword(v1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<DCSRecordRef %p>{key = %@, headword = %@, bodyID = %d}"), v1, v3, v4, *((_QWORD *)v1 + 26));
}

BOOL IsManagedConfigProfanityFilterForced()
{
  uint64_t v0;
  void *v1;
  unsigned int v2;

  if (_GetManagedConfigFrameworkInfo__DispatchOnceToken != -1)
    dispatch_once(&_GetManagedConfigFrameworkInfo__DispatchOnceToken, &__block_literal_global_46);
  v0 = _GetManagedConfigFrameworkInfo__InfoPtr;
  if (!_GetManagedConfigFrameworkInfo__InfoPtr)
    return 0;
  v1 = (void *)NewAutoReleasePool();
  v2 = objc_msgSend(objc_msgSend(*(id *)(v0 + 8), sel_sharedConnection), sel_effectiveBoolValueForSetting_, *(_QWORD *)(v0 + 16));

  return v2 == 1;
}

void SetManagedConfigChangedCallback(uint64_t a1)
{
  _QWORD block[5];

  if (_GetManagedConfigFrameworkInfo__DispatchOnceToken != -1)
    dispatch_once(&_GetManagedConfigFrameworkInfo__DispatchOnceToken, &__block_literal_global_46);
  if (_GetManagedConfigFrameworkInfo__InfoPtr)
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __SetManagedConfigChangedCallback_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = _GetManagedConfigFrameworkInfo__InfoPtr;
    if (SetManagedConfigChangedCallback__DispatchOnceToken != -1)
      dispatch_once(&SetManagedConfigChangedCallback__DispatchOnceToken, block);
    if (SetManagedConfigChangedCallback__MyReceiverObj)
      objc_msgSend((id)SetManagedConfigChangedCallback__MyReceiverObj, sel_setCallbackBlock_, a1);
  }
}

void AddLinguisticDataAssetion(uint64_t a1, const __CFArray *a2)
{
  id *v4;
  id v5;
  CFDictionaryRef v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex i;
  const void *ValueAtIndex;
  CFStringRef v11;
  void *v12;
  void *values[2];
  const __CFString *v14;
  void *keys[2];
  const __CFString *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  DCSLog(16, CFSTR("AddLinguisticDataAssetion_iOS for dictionary (%@) with languages (%@)"), a1, a2);
  if (a1 && a2)
  {
    if (_GetTextInputFrameworkInfo__DispatchOnceToken != -1)
      dispatch_once(&_GetTextInputFrameworkInfo__DispatchOnceToken, &__block_literal_global_52);
    v4 = (id *)_GetTextInputFrameworkInfo__InfoPtr;
    if (_GetTextInputFrameworkInfo__InfoPtr)
    {
      v12 = (void *)NewAutoReleasePool();
      v5 = objc_msgSend(*v4, sel_new);
      *(_OWORD *)keys = xmmword_1E8B56BF0;
      v16 = CFSTR("City");
      *(_OWORD *)values = xmmword_1E8B56C08;
      v14 = &stru_1E8B587B0;
      v6 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      Count = CFArrayGetCount(a2);
      if (Count >= 1)
      {
        v8 = Count;
        for (i = 0; i != v8; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
          v11 = CFStringCreateWithFormat(0, 0, CFSTR("%@;%@;%@"),
                  CFSTR("com.apple.DictionaryServices"),
                  ValueAtIndex,
                  a1);
          DCSLog(16, CFSTR("AddLinguisticDataAssetion_iOS actually adding language (%@) to client (%@)"), ValueAtIndex, v5);
          objc_msgSend(v5, sel_addLinguisticAssetsAssertionForLanguage_assertionID_region_clientID_withHandler_, ValueAtIndex, v11, v6, CFSTR("com.apple.DictionaryServices"), &__block_literal_global_34);
          CFRelease(v11);
        }
      }
      CFRelease(v6);

    }
  }
}

void RemoveLinguisticDataAssetion(uint64_t a1, const __CFArray *a2)
{
  id *v4;
  id v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const void *ValueAtIndex;
  CFStringRef v10;
  id v11;

  DCSLog(16, CFSTR("RemoveLinguisticDataAssetion_iOS for dictionary (%@) with languages (%@)"), a1, a2);
  if (a1 && a2)
  {
    if (_GetTextInputFrameworkInfo__DispatchOnceToken != -1)
      dispatch_once(&_GetTextInputFrameworkInfo__DispatchOnceToken, &__block_literal_global_52);
    v4 = (id *)_GetTextInputFrameworkInfo__InfoPtr;
    if (_GetTextInputFrameworkInfo__InfoPtr)
    {
      v11 = (id)NewAutoReleasePool();
      v5 = objc_msgSend(*v4, sel_new);
      Count = CFArrayGetCount(a2);
      if (Count >= 1)
      {
        v7 = Count;
        for (i = 0; i != v7; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
          v10 = CFStringCreateWithFormat(0, 0, CFSTR("%@;%@;%@"),
                  CFSTR("com.apple.DictionaryServices"),
                  ValueAtIndex,
                  a1);
          DCSLog(16, CFSTR("RemoveLinguisticDataAssetion_iOS actually removing language (%@) from client (%@)"), ValueAtIndex, v5);
          objc_msgSend(v5, sel_removeLinguisticAssetsAssertionWithIdentifier_forClientID_withHandler_, v10, CFSTR("com.apple.DictionaryServices"), &__block_literal_global_41_0);
          CFRelease(v10);
        }
      }

    }
  }
}

CFMutableSetRef DCSCopyAvailableDictionaries()
{
  DCSEnvironment *v0;

  v0 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  return DCSEnvironment::copyAvailableDictionaries(v0);
}

uint64_t DCSInvalidateDictionaryCache()
{
  uint64_t result;

  result = SyncSingleton<DCSEnvironment>::instance();
  *(_BYTE *)(result + 154) = 1;
  return result;
}

uint64_t DCSGetActiveDictionaries()
{
  DCSEnvironment *v0;

  v0 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  return DCSEnvironment::getActiveDictionaries(v0);
}

uint64_t DCSCopyInactiveDictionaries(const __CFString *a1)
{
  DCSEnvironment *v2;

  v2 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  return DCSEnvironment::copyInactiveDictionaries(v2, a1);
}

uint64_t DCSSetActiveDictionaries(const __CFArray *a1)
{
  DCSEnvironment *v2;

  v2 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  return DCSEnvironment::setActiveDictionaries(v2, a1);
}

uint64_t DCSGetDefaultDictionary()
{
  return 0;
}

uint64_t DCSGetDefaultThesaurus()
{
  return 0;
}

CFRange DCSGetTermRangeInString(DCSDictionaryRef dictionary, CFStringRef textString, CFIndex offset)
{
  const __CFArray *v5;
  uint64_t v6;
  CFIndex v7;
  CFIndex v8;
  CFIndex v9;
  CFIndex v10;
  void *values;
  CFRange result;

  values = dictionary;
  if (dictionary)
  {
    v5 = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    v6 = DCSGetTermRangeInStringWithOptions(v5, textString, offset, 1);
    v8 = v7;
    if (v5)
      CFRelease(v5);
    v9 = v6;
    v10 = v8;
  }
  else
  {
    v9 = DCSGetTermRangeInStringWithOptions(0, textString, offset, 1);
  }
  result.length = v10;
  result.location = v9;
  return result;
}

uint64_t DCSGetTermRangeInStringWithOptions(const __CFArray *ActiveDictionaries, CFStringRef theString, uint64_t a3, char a4)
{
  CFIndex Length;
  DCSEnvironment *v8;
  CFIndex v9;
  CFIndex v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t Count;
  const CFDictionaryKeyCallBacks *v15;
  const CFDictionaryValueCallBacks *v16;
  const __CFDictionary *Mutable;
  CFIndex v18;
  const void *ValueAtIndex;
  CFDictionaryRef *v20;
  const __CFArray *v21;
  const __CFArray *v22;
  uint64_t v23;
  __CFArray *v24;
  CFIndex i;
  const __CFDictionary *v26;
  const __CFString *Value;
  const __CFDictionary *ComponentsFromLocaleIdentifier;
  const __CFDictionary *v29;
  CFLocaleIdentifier LocaleIdentifierFromComponents;
  CFLocaleIdentifier v31;
  CFIndex v32;
  CFIndex v33;
  CFIndex j;
  const __CFString *v35;
  const __CFLocale *v36;
  __CFData *v37;
  char *MutableBytePtr;
  const __CFDictionary *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  CFIndex v44;
  CFIndex v45;
  uint64_t v46;
  CFIndex v49;
  uint64_t v50;
  uint64_t v51;
  const __CFArray *theArray;
  __CFDictionary *theDict;
  CFIndex v54;
  CFIndex v55;
  void *newValues;
  CFRange v57;
  CFRange v58;
  CFRange v59;

  Length = CFStringGetLength(theString);
  if (!ActiveDictionaries)
  {
    v8 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
    ActiveDictionaries = (const __CFArray *)DCSEnvironment::getActiveDictionaries(v8);
  }
  if (a3 <= 25)
    v9 = 0;
  else
    v9 = a3 - 25;
  v10 = v9 + 50;
  v55 = v9;
  v11 = Length - v9;
  v12 = v10 <= Length;
  v13 = 50;
  if (!v12)
    v13 = v11;
  v54 = v13;
  v49 = Length;
  v50 = a3;
  theArray = ActiveDictionaries;
  if (ActiveDictionaries)
    Count = CFArrayGetCount(ActiveDictionaries);
  else
    Count = 0;
  v15 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v16 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  theDict = CFDictionaryCreateMutable(0, Count, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  Mutable = CFDictionaryCreateMutable(0, 0, v15, v16);
  if (Count >= 1)
  {
    v18 = 0;
    v51 = Count;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v18);
      if (ValueAtIndex)
      {
        v20 = (CFDictionaryRef *)*((_QWORD *)ValueAtIndex + 2);
        if (v20)
        {
          if ((DCSDictionary::isNetworkDictionary(*((DCSDictionary **)ValueAtIndex + 2)) & 1) == 0)
          {
            v21 = DCSDictionary::languages(v20);
            if (v21)
            {
              v22 = v21;
              v23 = CFArrayGetCount(v21);
              v24 = CFArrayCreateMutable(0, v23, MEMORY[0x1E0C9B378]);
              if (v23 >= 1)
              {
                for (i = 0; i != v23; ++i)
                {
                  v26 = (const __CFDictionary *)CFArrayGetValueAtIndex(v22, i);
                  Value = (const __CFString *)CFDictionaryGetValue(v26, CFSTR("DCSDictionaryIndexLanguage"));
                  if (Value)
                  {
                    ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier(0, Value);
                    if (ComponentsFromLocaleIdentifier)
                    {
                      v29 = ComponentsFromLocaleIdentifier;
                      LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents(0, ComponentsFromLocaleIdentifier);
                      if (LocaleIdentifierFromComponents)
                      {
                        v31 = LocaleIdentifierFromComponents;
                        CFArrayAppendValue(v24, LocaleIdentifierFromComponents);
                        CFRelease(v31);
                      }
                      CFRelease(v29);
                    }
                  }
                }
              }
            }
            else
            {
              v24 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
            }
            if (!CFArrayGetCount(v24))
              CFArrayAppendValue(v24, &stru_1E8B587B0);
            v32 = CFArrayGetCount(v24);
            if (v32 >= 1)
            {
              v33 = v32;
              for (j = 0; j != v33; ++j)
              {
                v35 = (const __CFString *)CFArrayGetValueAtIndex(v24, j);
                newValues = 0;
                newValues = (void *)CFDictionaryGetValue(Mutable, v35);
                if (!newValues)
                {
                  if (CFStringGetLength(v35))
                    v36 = CFLocaleCreate(0, v35);
                  else
                    v36 = 0;
                  v37 = CFDataCreateMutable(0, 408);
                  CFDataSetLength(v37, 408);
                  MutableBytePtr = (char *)CFDataGetMutableBytePtr(v37);
                  v57.length = v54;
                  v57.location = v55;
                  BuildWordBreakTable(theString, v57, v36, MutableBytePtr);
                  CFDictionarySetValue(Mutable, v35, v37);
                  if (v36)
                    CFRelease(v36);
                  newValues = v37;
                  CFRelease(v37);
                }
                v58.location = j;
                v58.length = 1;
                CFArrayReplaceValues(v24, v58, (const void **)&newValues, 1);
              }
            }
            v39 = DCSDictionary::identifier((DCSDictionary *)v20);
            CFDictionarySetValue(theDict, v39, v24);
            CFRelease(v24);
            Count = v51;
          }
        }
      }
      ++v18;
    }
    while (v18 != Count);
  }
  CFRelease(Mutable);
  v40 = 0;
  v41 = v50 - v55;
  if (v50 - v55 < 0)
  {
    v43 = -1;
  }
  else
  {
    v42 = 0;
    v43 = -1;
    do
    {
      v44 = v42 + v55;
      v59.length = v54 - v42;
      v59.location = v42 + v55;
      v45 = LongestRangeAroundOffset(theArray, theString, v59, v42, v41 - v42, theDict, a4 & 1);
      if (v46 > v40)
      {
        v43 = v45;
        v40 = v46;
      }
      if (v49 > v44 && (CFStringGetCharacterAtIndex(theString, v44) & 0xFC00) == 0xD800)
        ++v42;
      v12 = v42++ < v41;
    }
    while (v12);
  }
  CFRelease(theDict);
  return v43;
}

CFIndex LongestRangeAroundOffset(const __CFArray *a1, const __CFString *a2, CFRange a3, uint64_t a4, int64_t a5, const __CFDictionary *a6, int a7)
{
  CFIndex length;
  CFIndex location;
  const __CFArray *v12;
  CFIndex Count;
  int64_t v14;
  CFIndex v15;
  DCSDictionary **ValueAtIndex;
  DCSDictionary **v17;
  DCSDictionary *v18;
  const __CFDictionary *v19;
  const __CFArray *Value;
  CFIndex v21;
  unint64_t v22;
  uint64_t v23;
  char *v24;
  size_t v25;
  CFIndex v26;
  uint64_t v27;
  const __CFData *v28;
  const UInt8 *v29;
  uint64_t v30;
  DCSDictionary *v31;
  const __CFString *MutableCopy;
  CFIndex v33;
  uint64_t v34;
  const __CFString *v35;
  unsigned __int8 *v36;
  DCSDictionary *v37;
  const __CFString *v38;
  uint64_t v39;
  unsigned __int8 *v40;
  uint64_t v41;
  BOOL v42;
  int64_t v43;
  const __CFLocale *v44;
  DCSDictionary *v45;
  uint64_t v46;
  const __CFArray *v47;
  uint64_t i;
  uint64_t v49;
  CFIndex v50;
  CFIndex v51;
  CFIndex j;
  _QWORD *v53;
  int64_t v54;
  BOOL v55;
  const __CFString *v57;
  CFIndex v58;
  int v59;
  uint64_t v60;
  CFStringRef v61;
  const __CFArray *v62;
  CFIndex v63;
  CFDictionaryRef v64;
  const __CFString **v65;
  uint64_t v66;
  CFRange v67;

  v59 = a7;
  v64 = a6;
  length = a3.length;
  location = a3.location;
  v12 = a1;
  v66 = *MEMORY[0x1E0C80C00];
  Count = CFArrayGetCount(a1);
  v58 = location;
  v67.location = location;
  v67.length = length;
  v61 = CFStringCreateWithSubstring(0, a2, v67);
  if (Count >= 1)
  {
    v60 = a4;
    v14 = 0;
    v15 = 0;
    v62 = v12;
    v63 = Count;
    do
    {
      ValueAtIndex = (DCSDictionary **)CFArrayGetValueAtIndex(v12, v15);
      if (!ValueAtIndex)
        goto LABEL_53;
      v17 = ValueAtIndex;
      v18 = ValueAtIndex[2];
      if (!v18 || (DCSDictionary::isNetworkDictionary(ValueAtIndex[2]) & 1) != 0)
        goto LABEL_53;
      v19 = DCSDictionary::identifier(v18);
      Value = (const __CFArray *)CFDictionaryGetValue(v64, v19);
      v21 = CFArrayGetCount(Value);
      v65 = &v57;
      MEMORY[0x1E0C80A78](v21);
      v24 = (char *)&v57 - v23;
      v25 = v22 >= 0x200 ? 512 : v22;
      bzero((char *)&v57 - v23, v25);
      if (v21 < 1)
        goto LABEL_53;
      v26 = 0;
      v27 = v60;
      do
      {
        v28 = (const __CFData *)CFArrayGetValueAtIndex(Value, v26);
        v29 = &CFDataGetBytePtr(v28)[8 * v27];
        v30 = *(_QWORD *)v29;
        if (*(_QWORD *)v29 != 1)
          v29 = 0;
        *(_QWORD *)&v24[8 * v26++] = v29;
      }
      while (v21 != v26);
      v12 = v62;
      Count = v63;
      if (v30 != 1)
        goto LABEL_53;
      v31 = v17[2];
      if (v31 && (DCSDictionary::isNetworkDictionary(v31) & 1) != 0)
      {
        MutableCopy = (const __CFString *)CFRetain(v61);
        if (!v59)
          goto LABEL_18;
      }
      else
      {
        MutableCopy = CFStringCreateMutableCopy(0, 0, v61);
        v44 = (const __CFLocale *)DCSDictionary::primaryLocale(v18);
        DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v44);
        if ((v59 & 1) == 0)
        {
LABEL_18:
          v33 = CFStringGetLength(MutableCopy);
          v34 = MEMORY[0x1E0C80A78](v33);
          v35 = MutableCopy;
          v36 = (unsigned __int8 *)&v57 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0);
          v37 = v18;
          v38 = v35;
          if (DCSDictionary::hasRecord(v37, v35, 2, v36))
          {
            v39 = 0;
            v40 = v36 - 1;
            MutableCopy = v38;
            do
            {
              v41 = *(_QWORD *)&v24[8 * v39];
              if (v41)
                v42 = v33 < 1;
              else
                v42 = 1;
              if (!v42)
              {
                v43 = v33;
                while (v43 < a5 || !v40[v43] || !*(_QWORD *)(v41 + 8 * v43))
                {
                  if ((unint64_t)v43-- <= 1)
                    goto LABEL_32;
                }
                if (v43 > v14)
                  v14 = v43;
              }
LABEL_32:
              ++v39;
            }
            while (v39 != v21);
          }
          else
          {
            MutableCopy = v38;
          }
          Count = v63;
          goto LABEL_52;
        }
      }
      v45 = v17[2];
      if (v45)
      {
        v46 = DCSDictionary::searchByString(v45, MutableCopy, 65538, 0);
        if (v46)
        {
          v47 = (const __CFArray *)v46;
          v57 = MutableCopy;
          for (i = 0; i != v21; ++i)
          {
            v49 = *(_QWORD *)&v24[8 * i];
            if (v49)
            {
              v50 = CFArrayGetCount(v47);
              if (v50 >= 1)
              {
                v51 = v50;
                for (j = 0; j != v51; ++j)
                {
                  v53 = CFArrayGetValueAtIndex(v47, j);
                  v54 = *(_QWORD *)(v53[2] + 40) >> 1;
                  v55 = v54 <= v14 || v54 < a5;
                  if (!v55 && *(_QWORD *)(v49 + 8 * v54))
                    v14 = *(_QWORD *)(v53[2] + 40) >> 1;
                }
              }
            }
          }
          CFRelease(v47);
          v12 = v62;
          Count = v63;
          MutableCopy = v57;
        }
      }
LABEL_52:
      CFRelease(MutableCopy);
LABEL_53:
      ++v15;
    }
    while (v15 != Count);
  }
  CFRelease(v61);
  return v58;
}

BOOL DCSHasDefinitionForTerm(const void *ValueAtIndex, CFStringRef theString, CFRange range, uint64_t a4, _QWORD *a5)
{
  CFIndex length;
  CFIndex location;
  const __CFString *v9;
  DCSEnvironment *v11;
  const __CFArray *ActiveDictionaries;
  const __CFArray *v13;
  CFIndex Count;
  BOOL v15;
  CFIndex v16;
  unint64_t v17;
  DCSDictionary *v18;
  const __CFString *MutableCopy;
  const __CFLocale *v20;
  DCSDictionary *v21;
  const __CFArray *v22;
  const __CFArray *v23;
  const __CFString *v24;
  uint64_t v25;
  CFIndex v26;
  BOOL v27;
  DCSDictionary *v28;
  int hasRecord;
  _QWORD *v31;
  unint64_t v32;
  CFRange v33;

  length = range.length;
  location = range.location;
  v9 = theString;
  if (a5)
    *a5 = 0;
  if (!theString)
    return 0;
  if (range.location || range.length != CFStringGetLength(theString))
  {
    v33.location = location;
    v33.length = length;
    v9 = CFStringCreateWithSubstring(0, v9, v33);
    if (!ValueAtIndex)
      goto LABEL_7;
  }
  else
  {
    CFRetain(v9);
    if (!ValueAtIndex)
    {
LABEL_7:
      v11 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
      ActiveDictionaries = (const __CFArray *)DCSEnvironment::getActiveDictionaries(v11);
      if (!ActiveDictionaries || (v13 = ActiveDictionaries, Count = CFArrayGetCount(ActiveDictionaries), Count < 1))
      {
        v15 = 0;
        goto LABEL_37;
      }
      goto LABEL_12;
    }
  }
  v13 = 0;
  Count = 1;
LABEL_12:
  v31 = a5;
  v16 = 0;
  v17 = a4 & 0xFFFFFFFFFFFFFFFELL;
  v15 = 1;
  v32 = a4 & 0xFFFFFFFFFFFFFFFELL;
  while (1)
  {
    if (v13)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v13, v16);
      if (!DCSDictionaryIsSupportedDefinitionStyle((uint64_t)ValueAtIndex, a4))
        goto LABEL_32;
    }
    if (ValueAtIndex)
    {
      v18 = (DCSDictionary *)*((_QWORD *)ValueAtIndex + 2);
      if (v18 && (DCSDictionary::isNetworkDictionary(*((DCSDictionary **)ValueAtIndex + 2)) & 1) != 0)
      {
        MutableCopy = (const __CFString *)CFRetain(v9);
        if (v17 != 2)
          goto LABEL_28;
        goto LABEL_23;
      }
    }
    else
    {
      v18 = 0;
    }
    v20 = (const __CFLocale *)DCSDictionary::primaryLocale(v18);
    MutableCopy = CFStringCreateMutableCopy(0, 0, v9);
    DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v20);
    if (v17 != 2)
      break;
    if (!ValueAtIndex)
      goto LABEL_29;
LABEL_23:
    v21 = (DCSDictionary *)*((_QWORD *)ValueAtIndex + 2);
    if (!v21 || (v22 = (const __CFArray *)DCSDictionary::searchByString(v21, MutableCopy, 0x10000, 1)) == 0)
    {
LABEL_29:
      CFRelease(MutableCopy);
      goto LABEL_32;
    }
    v23 = v22;
    v24 = v9;
    v25 = a4;
    v26 = CFArrayGetCount(v22);
    CFRelease(v23);
    CFRelease(MutableCopy);
    v27 = v26 <= 0;
    a4 = v25;
    v9 = v24;
    v17 = v32;
    if (!v27)
      goto LABEL_35;
LABEL_32:
    v15 = ++v16 < Count;
    if (Count == v16)
      goto LABEL_37;
  }
  if (ValueAtIndex)
  {
LABEL_28:
    v28 = (DCSDictionary *)*((_QWORD *)ValueAtIndex + 2);
    goto LABEL_31;
  }
  v28 = 0;
LABEL_31:
  hasRecord = DCSDictionary::hasRecord(v28, MutableCopy, 0, 0);
  CFRelease(MutableCopy);
  if (!hasRecord)
    goto LABEL_32;
LABEL_35:
  if (v31)
    *v31 = ValueAtIndex;
LABEL_37:
  CFRelease(v9);
  return v15;
}

uint64_t DCSDictionaryIsSupportedDefinitionStyle(uint64_t result, uint64_t a2)
{
  DCSDictionary *v2;

  if (result)
  {
    v2 = *(DCSDictionary **)(result + 16);
    if (v2)
    {
      result = 1;
      if (a2)
      {
        if (a2 != 255)
          return DCSDictionary::isSupportedDefinitionStyle(v2, a2);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void DCSNormalizeSearchStringWithOptionsAndLocale(const __CFString *a1, uint64_t a2, const __CFLocale *a3)
{
  CFMutableStringRef v5;
  CFIndex Length;
  DCSEnvironment *v7;
  uint64_t SubstituteCharactersTable;
  const __CFDictionary *v9;
  const __CFCharacterSet *v10;
  int IsSupersetOfSet;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const UniChar *v15;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  int v18;
  CFIndex v19;
  int64_t v20;
  int64_t v21;
  UniChar *v22;
  int64_t v23;
  UniChar v24;
  unsigned int v25;
  UniChar *v26;
  int64_t v28;
  int64_t v29;
  UniChar *v30;
  int64_t v31;
  UniChar v32;
  int64_t v33;
  int64_t v35;
  uint64_t v36;
  const __CFString *Value;
  CFIndex v38;
  const __CFString *v39;
  int64_t v40;
  int64_t v41;
  uint64_t v42;
  CFMutableStringRef v43;
  const __CFLocale *v44;
  uint64_t *v45;
  uint64_t v46;
  int64_t v47;
  UniChar buffer[64];
  CFStringRef v49;
  UniChar *v50;
  const char *v51;
  uint64_t v52;
  int64_t v53;
  int64_t v54;
  int64_t v55;
  __CFCharacterSet *v56[3];
  CFRange v57;
  CFRange v58;
  CFRange v59;
  CFRange v60;
  CFRange v61;

  v5 = (CFMutableStringRef)a1;
  v56[1] = *(__CFCharacterSet **)MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  if (Length >= 256)
  {
    v57.length = Length - 255;
    v57.location = 255;
    CFStringDelete(v5, v57);
  }
  CFStringNormalize(v5, kCFStringNormalizationFormC);
  v56[0] = 0;
  v7 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  SubstituteCharactersTable = DCSEnvironment::getSubstituteCharactersTable(v7, v56);
  if (SubstituteCharactersTable)
  {
    v9 = (const __CFDictionary *)SubstituteCharactersTable;
    if (!v56[0]
      || (v10 = CFCharacterSetCreateWithCharactersInString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v5),
          IsSupersetOfSet = CFCharacterSetIsSupersetOfSet(v56[0], v10),
          CFRelease(v10),
          !IsSupersetOfSet))
    {
      v46 = a2;
      v12 = CFStringGetLength(v5);
      v45 = &v42;
      v13 = MEMORY[0x1E0C80A78](v12);
      v15 = (const UniChar *)((char *)&v42 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0));
      v49 = v5;
      v52 = 0;
      v53 = v13;
      CharactersPtr = CFStringGetCharactersPtr(v5);
      CStringPtr = 0;
      v50 = (UniChar *)CharactersPtr;
      if (!CharactersPtr)
        CStringPtr = CFStringGetCStringPtr(v5, 0x600u);
      v54 = 0;
      v55 = 0;
      v51 = CStringPtr;
      v47 = v12 - 1;
      if (v12 >= 1)
      {
        v43 = v5;
        v44 = a3;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        while (1)
        {
          v21 = v53;
          if (v53 <= v20)
          {
            v25 = 0;
            v26 = (UniChar *)&v15[v19];
            *v26 = 0;
LABEL_40:
            v36 = 1;
            goto LABEL_41;
          }
          v22 = v50;
          if (v50)
            break;
          if (!v51)
          {
            v33 = v54;
            if (v55 <= v20 || v54 > v20)
            {
              v35 = v20 - 4;
              if ((unint64_t)v20 < 4)
                v35 = 0;
              if (v35 + 64 < v53)
                v21 = v35 + 64;
              v54 = v35;
              v55 = v21;
              v58.location = v52 + v35;
              v58.length = v21 - v35;
              CFStringGetCharacters(v49, v58, buffer);
              v33 = v54;
            }
            v23 = v20 - v33;
            v22 = buffer;
            goto LABEL_13;
          }
          v24 = v51[v52 + v20];
LABEL_17:
          v25 = v24;
          v26 = (UniChar *)&v15[v19];
          *v26 = v24;
          if (v24 >> 10 != 54 || v20 >= v47)
            goto LABEL_40;
          v28 = v20 + 1;
          v29 = v53;
          if (v53 <= v20 + 1)
            goto LABEL_40;
          v30 = v50;
          if (v50)
          {
            v31 = v52 + v28;
LABEL_25:
            v32 = v30[v31];
            goto LABEL_38;
          }
          if (!v51)
          {
            if (v55 <= v28 || (v40 = v54, v54 > v28))
            {
              v41 = v20 - 3;
              if ((unint64_t)v20 < 3)
                v41 = 0;
              if (v41 + 64 < v53)
                v29 = v41 + 64;
              v54 = v41;
              v55 = v29;
              v60.location = v52 + v41;
              v60.length = v29 - v41;
              CFStringGetCharacters(v49, v60, buffer);
              v40 = v54;
            }
            v31 = v28 - v40;
            v30 = buffer;
            goto LABEL_25;
          }
          v32 = v51[v52 + v28];
LABEL_38:
          if (v32 >> 10 != 55)
            goto LABEL_40;
          v25 = (v25 << 10) + v32 - 56613888;
          v15[v19 + 1] = v32;
          v36 = 2;
LABEL_41:
          Value = (const __CFString *)CFDictionaryGetValue(v9, (const void *)v25);
          v38 = v36;
          if (Value)
          {
            v39 = Value;
            v38 = CFStringGetLength(Value);
            v59.location = 0;
            v59.length = v38;
            CFStringGetCharacters(v39, v59, v26);
            v18 = 1;
          }
          v19 += v38;
          v20 += v36;
          if (v20 >= v12)
          {
            a3 = v44;
            v5 = v43;
            if (v18)
            {
              v61.location = 0;
              v61.length = v12;
              CFStringDelete(v43, v61);
              CFStringAppendCharacters(v5, v15, v19);
            }
            goto LABEL_55;
          }
        }
        v23 = v52 + v20;
LABEL_13:
        v24 = v22[v23];
        goto LABEL_17;
      }
LABEL_55:
      LOBYTE(a2) = v46;
    }
    CFStringTrimWhitespace(v5);
    if ((a2 & 1) == 0)
      CFStringLowercase(v5, a3);
  }
}

__CFString *DCSCopyDefinitionMarkup(DCSDictionary **a1, CFStringRef theString, CFRange range, uint64_t a4, _QWORD *a5)
{
  CFIndex length;
  CFIndex location;
  const __CFString *v9;
  __CFArray *v11;
  __CFArray *v12;
  CFIndex Count;
  CFIndex v14;
  CFIndex v15;
  __CFString *Mutable;
  const __CFString *ValueAtIndex;
  const void *StyleSheetURL;
  CFTypeRef cf;
  CFRange v21;
  CFRange v22;

  length = range.length;
  location = range.location;
  v9 = theString;
  if (a5)
    *a5 = 0;
  if (theString)
  {
    if (range.location || range.length != CFStringGetLength(theString))
    {
      v21.location = location;
      v21.length = length;
      v9 = CFStringCreateWithSubstring(0, v9, v21);
    }
    else
    {
      CFRetain(v9);
    }
    cf = 0;
    v22.location = location;
    v22.length = length;
    v11 = CopyDefinitionsInternal(a1, v9, v22, a4, &cf);
    if (!v11)
    {
      Mutable = 0;
LABEL_24:
      CFRelease(v9);
      return Mutable;
    }
    v12 = v11;
    Count = CFArrayGetCount(v11);
    if (Count < 1)
    {
      Mutable = 0;
      if (!a5)
      {
LABEL_21:
        if (cf)
          CFRelease(cf);
        CFRelease(v12);
        goto LABEL_24;
      }
    }
    else
    {
      v14 = Count;
      v15 = 0;
      Mutable = 0;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v12, v15);
        if (!Mutable)
          Mutable = CFStringCreateMutable(0, 0);
        CFStringAppend(Mutable, ValueAtIndex);
        ++v15;
      }
      while (v14 != v15);
      if (!a5)
        goto LABEL_21;
    }
    StyleSheetURL = DCSDictionaryGetStyleSheetURL((uint64_t)cf);
    *a5 = StyleSheetURL;
    if (StyleSheetURL)
      CFRetain(StyleSheetURL);
    goto LABEL_21;
  }
  return 0;
}

__CFArray *CopyDefinitionsInternal(DCSDictionary **a1, const __CFString *a2, CFRange a3, uint64_t a4, CFTypeRef *a5)
{
  const __CFArray *v7;
  const __CFArray *v8;
  DCSRecord *v9;
  CFIndex Count;
  CFIndex v11;
  __CFArray *Mutable;
  CFIndex v13;
  const CFArrayCallBacks *v14;
  const void *ValueAtIndex;
  uint64_t v16;
  const void *v17;

  if (a5)
  {
    *a5 = 0;
    v7 = DCSCopyDefinitionRecords(a1, a2, a3, a4);
    if (v7)
    {
      v8 = v7;
      v9 = (DCSRecord *)*((_QWORD *)CFArrayGetValueAtIndex(v7, 0) + 2);
      if (v9)
        v9 = (DCSRecord *)DCSRecord::dictionaryRef(v9);
      *a5 = CFRetain(v9);
      goto LABEL_7;
    }
    return 0;
  }
  v8 = DCSCopyDefinitionRecords(a1, a2, a3, a4);
  if (!v8)
    return 0;
LABEL_7:
  Count = CFArrayGetCount(v8);
  if (Count < 1)
  {
    Mutable = 0;
  }
  else
  {
    v11 = Count;
    Mutable = 0;
    v13 = 0;
    v14 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v8, v13);
      v16 = DCSRecordCopyDefinition((uint64_t)ValueAtIndex, a4);
      if (v16)
      {
        v17 = (const void *)v16;
        if (!Mutable)
          Mutable = CFArrayCreateMutable(0, 0, v14);
        CFArrayAppendValue(Mutable, v17);
        CFRelease(v17);
      }
      ++v13;
    }
    while (v11 != v13);
  }
  CFRelease(v8);
  return Mutable;
}

const void *DCSDictionaryGetStyleSheetURL(uint64_t a1)
{
  DCSDictionary *v1;
  const __CFArray *v2;
  const __CFArray *v3;

  if (a1
    && (v1 = *(DCSDictionary **)(a1 + 16)) != 0
    && (v2 = (const __CFArray *)DCSDictionary::styleSheetURLs(v1)) != 0
    && (v3 = v2, CFArrayGetCount(v2) >= 1))
  {
    return CFArrayGetValueAtIndex(v3, 0);
  }
  else
  {
    return 0;
  }
}

__CFArray *DCSCopyDefinitions(DCSDictionary **a1, const __CFString *a2, CFRange a3, uint64_t a4)
{
  return CopyDefinitionsInternal(a1, a2, a3, a4, 0);
}

const __CFArray *DCSCopyDefinitionRecords(DCSDictionary **a1, CFStringRef theString, CFRange range, uint64_t a4)
{
  CFIndex length;
  CFIndex location;
  const __CFString *v7;
  void *ValueAtIndex;
  DCSDictionary *v9;
  DCSEnvironment *v10;
  const __CFArray *ActiveDictionaries;
  CFIndex Count;
  uint64_t v13;
  uint64_t v14;
  const __CFArray *v15;
  CFIndex v16;
  DCSDictionary *v17;
  const __CFString *MutableCopy;
  const __CFLocale *v19;
  DCSDictionary *v20;
  DCSDictionary *v22;
  const __CFString *v23;
  CFIndex v24;
  uint64_t v25;
  const __CFArray *Mutable;
  const __CFArray *v27;
  const __CFArray *v28;
  CFIndex v29;
  CFIndex v30;
  CFIndex i;
  const __CFString *v32;
  __CFArray *v33;
  const __CFArray *v34;
  CFIndex v35;
  CFIndex v36;
  CFIndex j;
  const void *v38;
  const __CFArray *v39;
  CFRange v40;
  CFRange v41;

  if (!theString)
    return 0;
  length = range.length;
  location = range.location;
  v7 = theString;
  ValueAtIndex = a1;
  if (a1)
  {
    v9 = a1[2];
    if (!v9 || a4 && a4 != 255 && !DCSDictionary::isSupportedDefinitionStyle(v9, a4))
      return 0;
  }
  if (location || length != CFStringGetLength(v7))
  {
    v41.location = location;
    v41.length = length;
    v7 = CFStringCreateWithSubstring(0, v7, v41);
    if (!ValueAtIndex)
      goto LABEL_10;
  }
  else
  {
    CFRetain(v7);
    if (!ValueAtIndex)
    {
LABEL_10:
      v10 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
      ActiveDictionaries = (const __CFArray *)DCSEnvironment::getActiveDictionaries(v10);
      Count = CFArrayGetCount(ActiveDictionaries);
      v39 = 0;
      if (Count < 1)
      {
LABEL_30:
        v15 = 0;
        goto LABEL_31;
      }
      v13 = Count;
      v14 = (unint64_t)((a4 & 0xFFFFFFFFFFFFFFFELL) == 2) << 16;
      goto LABEL_15;
    }
  }
  ActiveDictionaries = 0;
  v14 = (unint64_t)((a4 & 0xFFFFFFFFFFFFFFFELL) == 2) << 16;
  v39 = 0;
  v13 = 1;
LABEL_15:
  v16 = 0;
  while (1)
  {
    if (ActiveDictionaries)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(ActiveDictionaries, v16);
      if (!DCSDictionaryIsSupportedDefinitionStyle((uint64_t)ValueAtIndex, a4))
        goto LABEL_29;
    }
    if (ValueAtIndex)
    {
      v17 = (DCSDictionary *)*((_QWORD *)ValueAtIndex + 2);
      if (v17)
      {
        if ((DCSDictionary::isNetworkDictionary(v17) & 1) != 0)
        {
          MutableCopy = (const __CFString *)CFRetain(v7);
          goto LABEL_25;
        }
        v17 = (DCSDictionary *)*((_QWORD *)ValueAtIndex + 2);
      }
    }
    else
    {
      v17 = 0;
    }
    v19 = (const __CFLocale *)DCSDictionary::primaryLocale(v17);
    MutableCopy = CFStringCreateMutableCopy(0, 0, v7);
    DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v19);
    if (!ValueAtIndex)
      goto LABEL_28;
LABEL_25:
    v20 = (DCSDictionary *)*((_QWORD *)ValueAtIndex + 2);
    if (!v20)
    {
LABEL_28:
      CFRelease(MutableCopy);
      goto LABEL_29;
    }
    v15 = (const __CFArray *)DCSDictionary::searchByString(v20, MutableCopy, v14, 10);
    CFRelease(MutableCopy);
    if (v15)
      break;
LABEL_29:
    if (v13 == ++v16)
      goto LABEL_30;
  }
  v39 = v15;
  v22 = (DCSDictionary *)*((_QWORD *)ValueAtIndex + 2);
  if (!v22)
  {
    v25 = CFArrayGetCount(v15);
    if (v25 <= 1)
      goto LABEL_31;
LABEL_50:
    Mutable = CFArrayCreateMutableCopy(0, v25, v15);
    DCSSortRecordsWithHeadword(Mutable, v7);
    goto LABEL_51;
  }
  v23 = DCSDictionary::primaryLanguage(v22);
  v24 = CFArrayGetCount(v15);
  if (v24 <= 1)
    goto LABEL_31;
  v25 = v24;
  if (!v23 || CFStringCompare(v23, CFSTR("ar"), 1uLL))
    goto LABEL_50;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v27 = DCSCreateHeadwordList(1, (uint64_t)&v39, v7);
  if (v27)
  {
    v28 = v27;
    v29 = CFArrayGetCount(v27);
    if (v29 >= 1)
    {
      v30 = v29;
      for (i = 0; i != v30; ++i)
      {
        v32 = (const __CFString *)CFArrayGetValueAtIndex(v28, i);
        v33 = DCSCopyRecordsWithHeadword(1, (uint64_t)&v39, v32);
        if (v33)
        {
          v34 = v33;
          v35 = CFArrayGetCount(v33);
          if (v35 >= 1)
          {
            v36 = v35;
            for (j = 0; j != v36; ++j)
            {
              v38 = CFArrayGetValueAtIndex(v34, j);
              v40.length = CFArrayGetCount(Mutable);
              v40.location = 0;
              if (!CFArrayContainsValue(Mutable, v40, v38))
                CFArrayAppendValue(Mutable, v38);
            }
          }
          CFRelease(v34);
        }
      }
    }
    CFRelease(v28);
  }
LABEL_51:
  CFRelease(v15);
  v15 = Mutable;
LABEL_31:
  CFRelease(v7);
  return v15;
}

const __CFString *DCSDictionaryGetPrimaryLanguage(uint64_t a1)
{
  DCSDictionary *v1;

  if (a1 && (v1 = *(DCSDictionary **)(a1 + 16)) != 0)
    return DCSDictionary::primaryLanguage(v1);
  else
    return 0;
}

CFArrayRef DCSCreateHeadwordList(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  DCSDictionary *v5;
  uint64_t v6;
  char v7;
  char v8;
  char isSortableDictionary;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex i;
  _QWORD *ValueAtIndex;
  DCSDictionary **v15;
  DCSRecord *EffectiveLanguageOfRecord;
  const __CFString *v17;
  int v18;
  DCSDictionary *v19;
  BOOL v20;
  CFIndex v21;
  CFIndex v22;
  const void **v23;
  __CFArray *Mutable;
  DCSDictionary *v25;
  CFComparisonResult (__cdecl *v26)(const void *, const void *, void *);
  CFArrayRef v27;
  const void **v28;
  CFIndex v29;
  CFIndex j;
  DCSRecord **v31;
  uint64_t v34;
  const __CFString *v35;
  __CFDictionary *theDict;
  _BYTE context[56];
  CFDictionaryKeyCallBacks keyCallBacks;
  CFRange v39;
  CFRange v40;

  memset(&keyCallBacks, 0, 32);
  *(_OWORD *)&keyCallBacks.equal = xmmword_1E8B56D20;
  theDict = CFDictionaryCreateMutable(0, 0, &keyCallBacks, 0);
  v34 = a1;
  if (a1 < 1)
  {
    v5 = 0;
    v35 = 0;
    isSortableDictionary = 1;
    v8 = 1;
  }
  else
  {
    v35 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 1;
    v8 = 1;
    isSortableDictionary = 1;
    do
    {
      v10 = *(const __CFArray **)(a2 + 8 * v6);
      if (v10)
      {
        Count = CFArrayGetCount(v10);
        if (Count >= 1)
        {
          v12 = Count;
          for (i = 0; i != v12; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 8 * v6), i);
            v15 = (DCSDictionary **)ValueAtIndex[2];
            CFDictionaryAddValue(theDict, v15, ValueAtIndex);
            if (!i && (v7 & 1) != 0)
            {
              EffectiveLanguageOfRecord = GetEffectiveLanguageOfRecord((uint64_t)ValueAtIndex);
              if (EffectiveLanguageOfRecord)
              {
                v17 = v35;
                if (v35)
                {
                  v18 = CompareLanguageCode(v35, (CFStringRef)EffectiveLanguageOfRecord, 0);
                  v7 = v18;
                  if (!v18)
                    v17 = 0;
                  v35 = v17;
                }
                else
                {
                  v7 = 1;
                  v35 = (const __CFString *)EffectiveLanguageOfRecord;
                }
              }
              else
              {
                v7 = 1;
              }
            }
            v19 = *v15;
            if (v5 != *v15)
            {
              if (v5)
                v19 = v5;
              v20 = (v8 & 1) == 0 || v5 == 0;
              v5 = v19;
              if (!v20)
                v8 = 0;
              if ((isSortableDictionary & 1) != 0)
                isSortableDictionary = DCSDictionary::isSortableDictionary(v19);
              else
                isSortableDictionary = 0;
            }
          }
        }
      }
      ++v6;
    }
    while (v6 != v34);
  }
  v21 = CFDictionaryGetCount(theDict);
  if (v21)
  {
    v22 = v21;
    v23 = (const void **)malloc_type_malloc(8 * v21, 0xC0040B8AA526DuLL);
    CFDictionaryGetKeysAndValues(theDict, 0, v23);
    CFRelease(theDict);
    if ((isSortableDictionary & 1) != 0)
    {
      Mutable = CFArrayCreateMutable(0, v22, MEMORY[0x1E0C9B378]);
      v39.location = 0;
      v39.length = 0;
      CFArrayReplaceValues(Mutable, v39, v23, v22);
      if ((v8 & 1) != 0)
        v25 = v5;
      else
        v25 = 0;
      InitSortStringInfo((uint64_t)context, a3, v25, v35, 1);
      if (v35 && (v8 & 1) != 0 && (CompareLanguageCode(v35, CFSTR("zh-Hans"), 0) & 1) != 0)
        v26 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))ComparatorForSortingSCHeadword;
      else
        v26 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))ComparatorForSortingHeadword;
      v40.location = 0;
      v40.length = v22;
      CFArraySortValues(Mutable, v40, v26, context);
      ReleaseSortStringInfo((uint64_t)context);
      if (v22 >= 1)
      {
        for (j = 0; j != v22; ++j)
        {
          v31 = (DCSRecord **)CFArrayGetValueAtIndex(Mutable, j);
          v23[j] = DCSRecord::headword(v31[2]);
        }
      }
      CFRelease(Mutable);
    }
    else if (v22 >= 1)
    {
      v28 = v23;
      v29 = v22;
      do
      {
        *v28 = DCSRecord::headword(*((DCSRecord **)*v28 + 2));
        ++v28;
        --v29;
      }
      while (v29);
    }
    v27 = CFArrayCreate(0, v23, v22, MEMORY[0x1E0C9B378]);
    free(v23);
  }
  else
  {
    CFRelease(theDict);
    return 0;
  }
  return v27;
}

__CFArray *DCSCopyRecordsWithHeadword(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  __CFArray *v3;
  uint64_t v5;
  uint64_t v6;
  const __CFArray *v7;
  CFIndex Count;
  uint64_t v9;
  DCSRecord *v10;
  uint64_t v11;
  DCSDictionary *v12;
  DCSDictionary *v13;
  const __CFString *v14;
  const __CFLocale *v15;
  CFIndex v16;
  _QWORD *ValueAtIndex;
  uint64_t *v18;
  const __CFString *v19;
  const __CFString *MutableCopy;
  CFComparisonResult v21;
  const __CFString *v22;
  const __CFString *v23;
  CFComparisonResult v24;
  uint64_t v26;
  uint64_t v27;
  __CFArray *theArray;
  CFRange v30;
  CFRange v31;

  v3 = 0;
  if (a1 && a3)
  {
    v5 = a1;
    theArray = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    if (v5 >= 1)
    {
      v6 = 0;
      v26 = v5;
      v27 = a2;
      while (1)
      {
        v7 = *(const __CFArray **)(a2 + 8 * v6);
        if (!v7)
          goto LABEL_26;
        Count = CFArrayGetCount(*(CFArrayRef *)(a2 + 8 * v6));
        if (!Count)
          goto LABEL_26;
        v9 = Count;
        v10 = (DCSRecord *)*((_QWORD *)CFArrayGetValueAtIndex(v7, 0) + 2);
        if (!v10)
          break;
        v11 = DCSRecord::dictionaryRef(v10);
        v12 = (DCSDictionary *)v11;
        if (!v11)
          goto LABEL_13;
        v13 = *(DCSDictionary **)(v11 + 16);
        if (!v13)
          break;
        if ((DCSDictionary::isNetworkDictionary(v13) & 1) == 0)
        {
          v12 = (DCSDictionary *)*((_QWORD *)v12 + 2);
          goto LABEL_13;
        }
        v14 = 0;
        v15 = 0;
LABEL_14:
        if (v9 >= 1)
        {
          v16 = 0;
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v7, v16);
            v18 = (uint64_t *)ValueAtIndex[2];
            v19 = (const __CFString *)DCSRecord::headword((DCSRecord *)v18);
            if (v14)
              break;
            if (CFStringCompare(v19, a3, 0x121uLL) == kCFCompareEqualTo)
              goto LABEL_22;
LABEL_23:
            if (v9 == ++v16)
              goto LABEL_24;
          }
          MutableCopy = CFStringCreateMutableCopy(0, 0, v19);
          DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v15);
          v30.length = CFStringGetLength(MutableCopy);
          v30.location = 0;
          v21 = CFStringCompareWithOptionsAndLocale(MutableCopy, v14, v30, 0x121uLL, v15);
          CFRelease(MutableCopy);
          if (v21)
          {
            if (v18[17] < 1)
              goto LABEL_23;
            v22 = DCSRecord::dataString((DCSRecord *)v18);
            v23 = CFStringCreateMutableCopy(0, 0, v22);
            DCSNormalizeSearchStringWithOptionsAndLocale(v23, 0, v15);
            v31.length = CFStringGetLength(v23);
            v31.location = 0;
            v24 = CFStringCompareWithOptionsAndLocale(v23, v14, v31, 0x121uLL, v15);
            CFRelease(v23);
            if (v24)
              goto LABEL_23;
          }
LABEL_22:
          CFArrayAppendValue(theArray, ValueAtIndex);
          goto LABEL_23;
        }
LABEL_24:
        v5 = v26;
        a2 = v27;
        if (v14)
          CFRelease(v14);
LABEL_26:
        if (++v6 == v5)
          goto LABEL_29;
      }
      v12 = 0;
LABEL_13:
      DCSDictionary::primaryLanguage(v12);
      v15 = (const __CFLocale *)DCSDictionary::primaryLocale(v12);
      v14 = CFStringCreateMutableCopy(0, 0, a3);
      DCSNormalizeSearchStringWithOptionsAndLocale(v14, 0, v15);
      goto LABEL_14;
    }
LABEL_29:
    v3 = theArray;
    if (CFArrayGetCount(theArray))
    {
      DCSSortRecordsWithHeadword(theArray, a3);
    }
    else
    {
      CFRelease(theArray);
      return 0;
    }
  }
  return v3;
}

void DCSSortRecordsWithHeadword(const __CFArray *a1, const __CFString *a2)
{
  CFIndex Count;
  CFIndex v5;
  DCSDictionary *v6;
  CFIndex v7;
  const __CFString *v8;
  char v9;
  char v10;
  char isSortableDictionary;
  const void *ValueAtIndex;
  const void *v13;
  DCSRecord *EffectiveLanguageOfRecord;
  int v15;
  DCSDictionary *v16;
  BOOL v17;
  DCSDictionary *v18;
  CFComparisonResult (__cdecl *v19)(const void *, const void *, void *);
  uint64_t v20;
  uint64_t v21;
  DCSRecord *v22;
  uint64_t v23;
  DCSRecord *v24;
  uint64_t v25;
  _BYTE context[56];
  CFRange v27;

  Count = CFArrayGetCount(a1);
  if (Count < 2)
    return;
  v5 = Count;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 1;
  v10 = 1;
  isSortableDictionary = 1;
  do
  {
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v7);
      v13 = ValueAtIndex;
      if ((v9 & 1) != 0)
      {
        EffectiveLanguageOfRecord = GetEffectiveLanguageOfRecord((uint64_t)ValueAtIndex);
        if (EffectiveLanguageOfRecord)
        {
          if (v8)
          {
            v15 = CompareLanguageCode(v8, (CFStringRef)EffectiveLanguageOfRecord, 0);
            v9 = v15;
            if (!v15)
              v8 = 0;
          }
          else
          {
            v9 = 1;
            v8 = (const __CFString *)EffectiveLanguageOfRecord;
          }
        }
        else
        {
          v9 = 1;
        }
      }
      else
      {
        v9 = 0;
      }
      v16 = (DCSDictionary *)**((_QWORD **)v13 + 2);
      if (v6 == v16)
        break;
      if (v6)
        v16 = v6;
      v17 = (v10 & 1) == 0 || v6 == 0;
      v6 = v16;
      if (!v17)
        v10 = 0;
      if ((isSortableDictionary & 1) != 0)
      {
        isSortableDictionary = DCSDictionary::isSortableDictionary(v16);
        break;
      }
      isSortableDictionary = 0;
      if (++v7 == v5)
        goto LABEL_36;
    }
    ++v7;
  }
  while (v7 != v5);
  if ((isSortableDictionary & 1) != 0)
  {
    if ((v10 & 1) != 0)
      v18 = v6;
    else
      v18 = 0;
    InitSortStringInfo((uint64_t)context, a2, v18, v8, 0);
    if (v8 && v10 && (CompareLanguageCode(v8, CFSTR("zh-Hans"), 0) & 1) != 0)
      v19 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))ComparatorForSortingSCHeadword;
    else
      v19 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))ComparatorForSortingRecord;
    v27.location = 0;
    v27.length = v5;
    CFArraySortValues(a1, v27, v19, context);
    ReleaseSortStringInfo((uint64_t)context);
  }
LABEL_36:
  v20 = v5 - 1;
  do
  {
    v21 = v5--;
    v22 = (DCSRecord *)*((_QWORD *)CFArrayGetValueAtIndex(a1, v5) + 2);
    v23 = v20;
    while (1)
    {
      v24 = (DCSRecord *)*((_QWORD *)CFArrayGetValueAtIndex(a1, --v23) + 2);
      if (*(_QWORD *)v22 == *(_QWORD *)v24)
      {
        v25 = DCSRecord::subDictionaryRef(v22);
        if (v25 == DCSRecord::subDictionaryRef(v24) && *((_QWORD *)v22 + 26) == *((_QWORD *)v24 + 26))
          break;
      }
      if (v23 <= 0)
        goto LABEL_42;
    }
    CFArrayRemoveValueAtIndex(a1, v5);
LABEL_42:
    --v20;
  }
  while (v21 > 2);
}

CFStringRef DCSCopyTextDefinition(DCSDictionaryRef dictionary, CFStringRef textString, CFRange range)
{
  CFIndex length;
  CFIndex location;
  const __CFString *v5;
  DCSEnvironment *v7;
  const __CFArray *ActiveDictionaries;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex v11;
  DCSDictionary *v12;
  const __CFString *MutableCopy;
  const __CFLocale *v14;
  DCSDictionary *v15;
  const __CFArray *v16;
  const __CFString *v17;
  CFIndex v18;
  CFIndex v19;
  const void *ValueAtIndex;
  DCSRecord *EffectiveLanguageOfRecord;
  DCSDictionary **v22;
  DCSDictionary *v23;
  const __CFString *v24;
  __CFArray *v25;
  CFComparisonResult (__cdecl *v26)(const void *, const void *, void *);
  const void *v27;
  _BYTE context[56];
  CFRange v30;
  CFRange v31;

  if (!textString)
    return 0;
  length = range.length;
  location = range.location;
  v5 = textString;
  if (range.location || range.length != CFStringGetLength(textString))
  {
    v31.location = location;
    v31.length = length;
    v5 = CFStringCreateWithSubstring(0, v5, v31);
    if (!dictionary)
      goto LABEL_5;
  }
  else
  {
    CFRetain(v5);
    if (!dictionary)
    {
LABEL_5:
      v7 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
      ActiveDictionaries = (const __CFArray *)DCSEnvironment::getActiveDictionaries(v7);
      if (!ActiveDictionaries || (v9 = ActiveDictionaries, Count = CFArrayGetCount(ActiveDictionaries), Count < 1))
      {
LABEL_24:
        v17 = 0;
        goto LABEL_35;
      }
      goto LABEL_10;
    }
  }
  v9 = 0;
  Count = 1;
LABEL_10:
  v11 = 0;
  while (1)
  {
    if (v9)
      dictionary = (DCSDictionaryRef)CFArrayGetValueAtIndex(v9, v11);
    if (dictionary)
    {
      v12 = (DCSDictionary *)*((_QWORD *)dictionary + 2);
      if (v12 && DCSDictionary::isNetworkDictionary(*((DCSDictionary **)dictionary + 2)))
      {
        MutableCopy = (const __CFString *)CFRetain(v5);
        goto LABEL_19;
      }
    }
    else
    {
      v12 = 0;
    }
    v14 = (const __CFLocale *)DCSDictionary::primaryLocale(v12);
    MutableCopy = CFStringCreateMutableCopy(0, 0, v5);
    DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v14);
    if (!dictionary)
      goto LABEL_22;
LABEL_19:
    v15 = (DCSDictionary *)*((_QWORD *)dictionary + 2);
    if (!v15)
    {
LABEL_22:
      CFRelease(MutableCopy);
      goto LABEL_23;
    }
    v16 = (const __CFArray *)DCSDictionary::searchByString(v15, MutableCopy, 0x10000, 10);
    CFRelease(MutableCopy);
    if (v16)
      break;
LABEL_23:
    if (Count == ++v11)
      goto LABEL_24;
  }
  v18 = CFArrayGetCount(v16);
  if (v18 >= 2
    && (v19 = v18,
        ValueAtIndex = CFArrayGetValueAtIndex(v16, 0),
        EffectiveLanguageOfRecord = GetEffectiveLanguageOfRecord((uint64_t)ValueAtIndex),
        v22 = (DCSDictionary **)*((_QWORD *)ValueAtIndex + 2),
        (v23 = *v22) != 0)
    && (v24 = (const __CFString *)EffectiveLanguageOfRecord, DCSDictionary::isSortableDictionary(*v22)))
  {
    v25 = CFArrayCreateMutableCopy(0, v19, v16);
    InitSortStringInfo((uint64_t)context, v5, v23, v24, 0);
    if (Count == 1 && v24 && (CompareLanguageCode(v24, CFSTR("zh-Hans"), 0) & 1) != 0)
      v26 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))ComparatorForSortingSCHeadword;
    else
      v26 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))ComparatorForSortingHeadword;
    v30.location = 0;
    v30.length = v19;
    CFArraySortValues(v25, v30, v26, context);
    ReleaseSortStringInfo((uint64_t)context);
    CFRelease(v16);
  }
  else
  {
    v25 = v16;
  }
  v27 = CFArrayGetValueAtIndex(v25, 0);
  v17 = (const __CFString *)DCSRecordCopyDefinition((uint64_t)v27, 3);
  CFRelease(v25);
LABEL_35:
  CFRelease(v5);
  return v17;
}

DCSRecord *GetEffectiveLanguageOfRecord(uint64_t a1)
{
  DCSRecord *result;
  uint64_t v3;
  const __CFArray *v4;
  const __CFDictionary *ValueAtIndex;

  result = *(DCSRecord **)(a1 + 16);
  if (result)
  {
    v3 = DCSRecord::subDictionaryRef(result);
    if (v3
      || (result = *(DCSRecord **)(a1 + 16)) != 0
      && (result = (DCSRecord *)DCSRecord::dictionaryRef(result), (v3 = (uint64_t)result) != 0))
    {
      result = *(DCSRecord **)(v3 + 16);
      if (result)
      {
        result = (DCSRecord *)DCSDictionary::primaryLanguage(result);
        if (!result)
        {
          result = *(DCSRecord **)(v3 + 16);
          if (result)
          {
            result = DCSDictionary::languages((CFDictionaryRef *)result);
            if (result)
            {
              v4 = result;
              if (CFArrayGetCount(result) < 1)
              {
                return 0;
              }
              else
              {
                ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v4, 0);
                return (DCSRecord *)CFDictionaryGetValue(ValueAtIndex, CFSTR("DCSDictionaryIndexLanguage"));
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t InitSortStringInfo(uint64_t a1, const __CFString *a2, DCSDictionary *this, const __CFString *a4, char a5)
{
  const __CFLocale *v10;
  const __CFString *MutableCopy;
  const __CFString *v12;
  const __CFString *v13;
  CFMutableStringRef v14;
  const __CFString *CanonicalLocaleIdentifierFromString;
  const __CFString *v16;
  uint64_t result;

  if (this)
    v10 = (const __CFLocale *)DCSDictionary::primaryLocale(this);
  else
    v10 = 0;
  MutableCopy = CFStringCreateMutableCopy(0, 0, a2);
  DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 1, v10);
  *(_QWORD *)(a1 + 8) = MutableCopy;
  if (CFStringCompare(a2, MutableCopy, 0) == kCFCompareEqualTo)
  {
    CFRelease(MutableCopy);
    *(_QWORD *)(a1 + 8) = CFRetain(a2);
  }
  v12 = CFStringCreateMutableCopy(0, 0, a2);
  DCSNormalizeSearchStringWithOptionsAndLocale(v12, 0, v10);
  *(_QWORD *)(a1 + 16) = v12;
  if (CFStringCompare(a2, v12, 0))
  {
    v13 = *(const __CFString **)(a1 + 16);
  }
  else
  {
    CFRelease(v12);
    v13 = (const __CFString *)CFRetain(a2);
    *(_QWORD *)(a1 + 16) = v13;
  }
  v14 = CFStringCreateMutableCopy(0, 0, v13);
  CFStringUppercase(v14, 0);
  *(_QWORD *)(a1 + 24) = v14;
  if (CFStringCompare(a2, v14, 0) == kCFCompareEqualTo)
  {
    CFRelease(v14);
    *(_QWORD *)(a1 + 24) = CFRetain(a2);
  }
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 32) = 0;
  if (a4)
  {
    CanonicalLocaleIdentifierFromString = CFLocaleCreateCanonicalLocaleIdentifierFromString(0, a4);
    if (CanonicalLocaleIdentifierFromString)
    {
      v16 = CanonicalLocaleIdentifierFromString;
      *(_QWORD *)(a1 + 32) = CFLocaleCreate(0, CanonicalLocaleIdentifierFromString);
      CFRelease(v16);
    }
  }
  *(_BYTE *)(a1 + 41) = this != 0;
  if (this)
    result = DCSDictionary::dictionaryFlag(this);
  else
    result = 0;
  *(_QWORD *)(a1 + 48) = result;
  *(_BYTE *)(a1 + 40) = a5;
  return result;
}

CFComparisonResult ComparatorForSortingSCHeadword(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t *v3;
  uint64_t *v4;
  const __CFLocale *v5;
  const __CFString *v6;
  CFIndex Length;
  const __CFString *v8;
  CFIndex v9;
  const __CFString *v10;
  CFIndex v11;
  const __CFString *v12;
  int v13;
  const __CFString *v14;
  int v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *v19;
  const __CFString *v20;
  CFRange v21;
  CFRange v22;
  CFRange v23;

  v3 = (uint64_t *)a1[2];
  v4 = (uint64_t *)a2[2];
  v5 = (const __CFLocale *)a3[4];
  v6 = (const __CFString *)a3[2];
  Length = CFStringGetLength(v6);
  v8 = DCSRecord::keyString((DCSRecord *)v3);
  v9 = CFStringGetLength(v8);
  v10 = DCSRecord::keyString((DCSRecord *)v4);
  v11 = CFStringGetLength(v10);
  if (Length == v9)
  {
    v12 = DCSRecord::keyString((DCSRecord *)v3);
    v21.location = 0;
    v21.length = Length;
    v13 = CFStringCompareWithOptionsAndLocale(v6, v12, v21, 0x121uLL, v5) == kCFCompareEqualTo;
  }
  else
  {
    v13 = 0;
  }
  if (Length == v11)
  {
    v14 = DCSRecord::keyString((DCSRecord *)v4);
    v22.location = 0;
    v22.length = Length;
    v15 = CFStringCompareWithOptionsAndLocale(v6, v14, v22, 0x121uLL, v5) == kCFCompareEqualTo;
  }
  else
  {
    v15 = 0;
  }
  if (v15 == v13)
  {
    if (v3[20] < 1 || v4[20] < 1)
    {
      v19 = DCSRecord::headwordSortString((DCSRecord *)v3, 0);
      v20 = DCSRecord::headwordSortString((DCSRecord *)v4, 0);
      v23.length = CFStringGetLength(v19);
      v23.location = 0;
      return CFStringCompareWithOptionsAndLocale(v19, v20, v23, 0x121uLL, v5);
    }
    else
    {
      v16 = DCSRecord::sortkeyString((DCSRecord *)v3);
      v17 = DCSRecord::sortkeyString((DCSRecord *)v4);
      return CFStringCompare(v16, v17, 0);
    }
  }
  else if (v13)
  {
    return -1;
  }
  else
  {
    return 1;
  }
}

uint64_t ComparatorForSortingHeadword(const void *a1, _QWORD *a2, _BYTE *a3)
{
  _BYTE *v3;
  uint64_t v4;
  DCSDictionary **v5;
  _BOOL4 v6;
  CFStringRef v7;
  CFStringRef v8;
  BOOL v9;
  const __CFLocale *v10;
  const __CFString *v11;
  DCSDictionary *v12;
  DCSDictionary *v13;
  BOOL v15;
  BOOL v16;
  CFStringRef v17;
  const __CFString *v18;
  const __CFString *v19;
  uint64_t v20;
  const __CFString *v21;
  const __CFString *v22;
  const __CFString *v23;
  _BYTE *v24;
  const __CFString *v25;
  const __CFString *v26;
  CFComparisonResult v27;
  CFComparisonResult v28;
  CFComparisonResult v29;
  const __CFString *v30;
  CFComparisonResult v31;
  CFComparisonResult v32;
  CFComparisonResult v33;
  const __CFString *v34;
  const __CFString *v35;
  const __CFString *v36;
  const __CFString *v37;
  const __CFString *v38;
  const __CFString *v39;
  const __CFString *v40;
  const __CFString *v41;
  CFRange v42;
  const __CFString *v43;
  const __CFString *v44;
  char v45;
  unsigned __int16 v46;
  const __CFString *v47;
  CFIndex Length;
  CFIndex v49;
  char v50;
  CFStringCompareFlags v51;
  char v52;
  CFComparisonResult v53;
  _BOOL4 v54;
  _BYTE *v55;
  CFIndex v56;
  const __CFString *v57;
  CFComparisonResult v58;
  CFComparisonResult v59;
  DCSRecord *v60;
  const __CFString *v61;
  const __CFString *v62;
  const __CFString *v63;
  const __CFString *v64;
  double v65;
  double v66;
  double v67;
  const __CFString *v68;
  const __CFString *v69;
  const __CFString *v70;
  const __CFString *v71;
  int HasPrefix;
  int v73;
  uint64_t v74;
  CFStringRef v75;
  const __CFString *v76;
  CFStringRef v77;
  const __CFString *v78;
  CFComparisonResult v79;
  CFComparisonResult v80;
  _BYTE *v81;
  const __CFString *v82;
  DCSDictionary **v83;
  const __CFString *theString1;
  const __CFString *theString2;
  CFStringRef theString2a;
  const __CFString *theString;
  BOOL theStringa;
  CFRange result;
  CFRange v90;
  CFRange v91;
  CFRange v92;
  CFRange v93;
  CFRange v94;
  CFRange v95;
  CFRange v96;
  CFRange v97;
  CFRange v98;
  CFRange v99;
  CFRange v100;
  CFRange v101;
  CFRange v102;
  CFRange v103;

  v3 = a3;
  v4 = *((_QWORD *)a1 + 2);
  v5 = (DCSDictionary **)a2[2];
  if (a3)
    v6 = a3[41] != 0;
  else
    v6 = 1;
  v7 = DCSRecord::headwordSortString(*((DCSRecord **)a1 + 2), !v6);
  v8 = DCSRecord::headwordSortString((DCSRecord *)v5, !v6);
  if (v3)
  {
    v9 = (v3[48] & 0x20) != 0 && *(_BYTE *)(v4 + 21) && *((_BYTE *)v5 + 21) != 0;
    v10 = (const __CFLocale *)*((_QWORD *)v3 + 4);
    v11 = *(const __CFString **)v3;
  }
  else
  {
    v10 = 0;
    v9 = 0;
    v11 = 0;
  }
  v12 = *(DCSDictionary **)(v4 + 112);
  v13 = v5[14];
  if (v12 != v13 && (!v12 || v13 == 0))
  {
    v15 = v12 == 0;
    goto LABEL_96;
  }
  if (v6 && *(uint64_t *)(v4 + 160) >= 1 && (uint64_t)v5[20] >= 1)
  {
    v16 = v9;
    v17 = DCSRecord::sortkeyString((DCSRecord *)v4);
    v18 = DCSRecord::sortkeyString((DCSRecord *)v5);
    v19 = v17;
    v9 = v16;
    v20 = CFStringCompare(v19, v18, 0);
    if (v20)
      return v20;
  }
  if (v7)
    v21 = v7;
  else
    v21 = &stru_1E8B587B0;
  if (v8)
    v22 = v8;
  else
    v22 = &stru_1E8B587B0;
  if (!v10
    || (v23 = (const __CFString *)MEMORY[0x1D17BC130](v10)) == 0
    || CFStringCompare(v23, CFSTR("ar"), 1uLL)
    || !v11)
  {
    theStringa = v9;
    if (v3)
      v45 = v9;
    else
      v45 = 1;
    if ((v45 & 1) != 0 || !v11)
      goto LABEL_117;
    if (CFStringCompare(v21, v22, 0x121uLL) == kCFCompareEqualTo)
    {
      v46 = *((_WORD *)v5 + 96);
      v20 = (v46 & 1) != 0 ? -1 : 1;
      if (((*(_WORD *)(v4 + 192) ^ v46) & 1) != 0)
        return v20;
    }
    theString2a = v11;
    v81 = v3;
    v83 = v5;
    v47 = (const __CFString *)*((_QWORD *)v3 + 1);
    Length = CFStringGetLength(v21);
    v49 = CFStringGetLength(v22);
    v50 = 1;
    v51 = 32;
    do
    {
      v52 = v50;
      v94.location = 0;
      v94.length = Length;
      v53 = CFStringCompareWithOptionsAndLocale(v21, v47, v94, v51, v10);
      v95.location = 0;
      v95.length = v49;
      if ((v53 == kCFCompareEqualTo) == (CFStringCompareWithOptionsAndLocale(v22, v47, v95, v51, v10) != kCFCompareEqualTo))
      {
        v15 = v53 == kCFCompareEqualTo;
        goto LABEL_96;
      }
      v50 = 0;
      v51 = 33;
    }
    while ((v52 & 1) != 0);
    if (DCSDictionary::isNetworkDictionary(*(DCSDictionary **)v4))
    {
      v96.location = 0;
      v96.length = Length;
      v5 = v83;
      if (!CFStringFindWithOptionsAndLocale(v21, v47, v96, 0x1A1uLL, v10, &result))
      {
        v3 = v81;
        if ((DCSDictionary::isNetworkDictionary(*v83) & 1) != 0)
        {
          v101.location = 0;
          v101.length = v49;
          if (!CFStringFindWithOptionsAndLocale(v22, v47, v101, 0x1A1uLL, v10, &result))
          {
            v11 = theString2a;
            goto LABEL_117;
          }
          v11 = theString2a;
          if (result.location)
            goto LABEL_117;
        }
        return 1;
      }
      v54 = result.location == 0;
    }
    else
    {
      v54 = 1;
      v5 = v83;
    }
    v3 = v81;
    if ((DCSDictionary::isNetworkDictionary(*v5) & 1) != 0)
    {
      v100.location = 0;
      v100.length = v49;
      if (CFStringFindWithOptionsAndLocale(v22, v47, v100, 0x1A1uLL, v10, &result))
      {
        if (v54)
          v20 = -1;
        else
          v20 = 1;
        v11 = theString2a;
        if (((v54 ^ (result.location == 0)) & 1) != 0)
          return v20;
      }
      else
      {
        v11 = theString2a;
        if (v54)
          return -1;
      }
LABEL_117:
      v102.length = CFStringGetLength(v21);
      v102.location = 0;
      v20 = CFStringCompareWithOptionsAndLocale(v21, v22, v102, 0x121uLL, v10);
      if (v20)
        return v20;
      if (!theStringa && (*(_QWORD *)(v4 + 136) || v5[17]))
      {
        v68 = (const __CFString *)DCSRecord::headword((DCSRecord *)v4);
        v69 = (const __CFString *)DCSRecord::headword((DCSRecord *)v5);
        v70 = (const __CFString *)DCSRecord::headword((DCSRecord *)v4);
        v103.length = CFStringGetLength(v70);
        v103.location = 0;
        v20 = CFStringCompareWithOptionsAndLocale(v68, v69, v103, 0x121uLL, v10);
        if (v20)
          return v20;
      }
      if (v3)
      {
        v71 = (const __CFString *)*((_QWORD *)v3 + 3);
        HasPrefix = CFStringHasPrefix(v21, v71);
        v73 = CFStringHasPrefix(v22, v71);
        v20 = HasPrefix ? 1 : -1;
        if (HasPrefix != v73)
          return v20;
      }
      if (DCSRecord::titleString((DCSRecord *)v4) || DCSRecord::titleString((DCSRecord *)v5))
      {
        v74 = v4;
        v75 = DCSRecord::titleString((DCSRecord *)v4)
            ? DCSRecord::titleString((DCSRecord *)v4)
            : (CFStringRef)DCSRecord::headword((DCSRecord *)v4);
        v76 = v75;
        v77 = DCSRecord::titleString((DCSRecord *)v5)
            ? DCSRecord::titleString((DCSRecord *)v5)
            : (CFStringRef)DCSRecord::headword((DCSRecord *)v5);
        v78 = v77;
        v79 = CFStringCompare(v76, v11, 1uLL);
        v80 = CFStringCompare(v78, v11, 1uLL);
        v20 = v79 ? 1 : -1;
        v4 = v74;
        if (v79 != v80)
          return v20;
      }
      goto LABEL_140;
    }
    v11 = theString2a;
    if (v54)
      goto LABEL_117;
    return 1;
  }
  v24 = v3;
  v25 = (const __CFString *)DCSRecord::headword((DCSRecord *)v4);
  v26 = (const __CFString *)DCSRecord::headword((DCSRecord *)v5);
  v27 = CFStringCompare(v25, v11, 0);
  theString = v26;
  v28 = CFStringCompare(v26, v11, 0);
  v29 = v28;
  if (v27 != v28 && (v27 == kCFCompareEqualTo || v28 == kCFCompareEqualTo))
    goto LABEL_94;
  theString2 = v11;
  v30 = (const __CFString *)*((_QWORD *)v24 + 2);
  v90.length = CFStringGetLength(v25);
  theString1 = v25;
  v90.location = 0;
  v31 = CFStringCompareWithOptionsAndLocale(v25, v30, v90, 0x121uLL, v10);
  v91.length = CFStringGetLength(v26);
  v91.location = 0;
  v32 = CFStringCompareWithOptionsAndLocale(v26, v30, v91, 0x121uLL, v10);
  v33 = v32;
  if (v31 != v32 && (v31 == kCFCompareEqualTo || v32 == kCFCompareEqualTo))
  {
LABEL_95:
    v15 = v31 == kCFCompareEqualTo;
LABEL_96:
    if (v15)
      return -1;
    else
      return 1;
  }
  if (CFStringCompare(theString1, v26, 0) == kCFCompareEqualTo)
  {
    v34 = DCSRecord::titleString((DCSRecord *)v4);
    v35 = DCSRecord::titleString((DCSRecord *)v5);
    if ((unint64_t)v34 | (unint64_t)v35)
    {
      v82 = v34;
      if (v34)
      {
        v36 = v35;
        v27 = CFStringCompare(v82, theString2, 0);
        v35 = v36;
        v34 = v82;
      }
      if (v35)
      {
        v37 = v35;
        v29 = CFStringCompare(v35, theString2, 0);
        v35 = v37;
        v34 = v82;
      }
      if (!(v27 | v29))
        goto LABEL_140;
      if (v27 && v29)
      {
        if (v34)
        {
          v38 = v34;
          v39 = v35;
          v92.length = CFStringGetLength(v38);
          v92.location = 0;
          v31 = CFStringCompareWithOptionsAndLocale(v38, v30, v92, 0x121uLL, v10);
          v35 = v39;
          v34 = v38;
        }
        if (v35)
        {
          v40 = v35;
          v93.length = CFStringGetLength(v35);
          v93.location = 0;
          v33 = CFStringCompareWithOptionsAndLocale(v40, v30, v93, 0x121uLL, v10);
          v35 = v40;
        }
        if (v31 | v33)
        {
          if (v31 && v33)
          {
            if (v34 && v35)
            {
              v41 = v35;
              v42.length = CFStringGetLength(v34);
              v43 = v34;
              v44 = v41;
LABEL_115:
              v42.location = 0;
              return CFStringCompareWithOptionsAndLocale(v43, v44, v42, 0x121uLL, v10);
            }
            goto LABEL_74;
          }
          goto LABEL_95;
        }
LABEL_140:
        if (*(_QWORD *)(v4 + 200) > (uint64_t)v5[25])
          return 1;
        else
          return -1;
      }
LABEL_94:
      v15 = v27 == kCFCompareEqualTo;
      goto LABEL_96;
    }
  }
LABEL_74:
  v55 = v24;
  if (!CFStringHasPrefix(v30, CFSTR("ال")))
    goto LABEL_81;
  v56 = CFStringGetLength(v30);
  if (v56 < 3)
    goto LABEL_81;
  v97.length = v56 - 2;
  v97.location = 2;
  v57 = CFStringCreateWithSubstring(0, v30, v97);
  v98.length = CFStringGetLength(theString1);
  v98.location = 0;
  v58 = CFStringCompareWithOptionsAndLocale(theString1, v57, v98, 0x121uLL, v10);
  v99.length = CFStringGetLength(theString);
  v99.location = 0;
  v59 = CFStringCompareWithOptionsAndLocale(theString, v57, v99, 0x121uLL, v10);
  CFRelease(v57);
  v20 = v58 ? 1 : -1;
  if (v58 && v59)
  {
LABEL_81:
    v60 = (DCSRecord *)v5;
    if (DCSRecord::titleString((DCSRecord *)v4) && !v55[40])
      v61 = DCSRecord::titleString((DCSRecord *)v4);
    else
      v61 = (const __CFString *)DCSRecord::headword((DCSRecord *)v4);
    v62 = v61;
    if (DCSRecord::titleString(v60) && !v55[40])
      v63 = DCSRecord::titleString(v60);
    else
      v63 = (const __CFString *)DCSRecord::headword(v60);
    v64 = v63;
    DistanceBetweenWords(v62, theString2);
    v66 = v65;
    DistanceBetweenWords(v64, theString2);
    if (v66 == v67)
    {
      v42.length = CFStringGetLength(theString1);
      v43 = theString1;
      v44 = theString;
      goto LABEL_115;
    }
    if (v66 >= v67)
      return 1;
    else
      return -1;
  }
  return v20;
}

void ReleaseSortStringInfo(uint64_t a1)
{
  const void *v2;

  CFRelease(*(CFTypeRef *)(a1 + 8));
  CFRelease(*(CFTypeRef *)(a1 + 16));
  CFRelease(*(CFTypeRef *)(a1 + 24));
  v2 = *(const void **)(a1 + 32);
  if (v2)
    CFRelease(v2);
}

uint64_t DCSRecordCopyData(uint64_t a1, uint64_t a2)
{
  if (a2 == 4)
    return 0;
  else
    return DCSRecordCopyDefinition(a1, a2);
}

uint64_t DCSCopyRecordsForSearchString(uint64_t a1, CFStringRef theString, uint64_t a3, uint64_t a4)
{
  const __CFString *v6;
  uint64_t v8;
  DCSDictionary *v9;
  const __CFString *MutableCopy;
  DCSDictionary *v11;
  const __CFLocale *v12;
  DCSDictionary *v13;

  if (theString)
  {
    v6 = theString;
    if (CFStringGetLength(theString) <= 100)
    {
      *(_BYTE *)(SyncSingleton<DCSEnvironment>::instance() + 136) = 1;
      if (a1 && (v9 = *(DCSDictionary **)(a1 + 16)) != 0)
      {
        if ((DCSDictionary::isNetworkDictionary(v9) & 1) != 0)
        {
          MutableCopy = 0;
          goto LABEL_12;
        }
        v11 = *(DCSDictionary **)(a1 + 16);
      }
      else
      {
        v11 = 0;
      }
      MutableCopy = CFStringCreateMutableCopy(0, 0, v6);
      v12 = (const __CFLocale *)DCSDictionary::primaryLocale(v11);
      DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v12);
      if (!a1)
        goto LABEL_15;
      v6 = MutableCopy;
LABEL_12:
      v13 = *(DCSDictionary **)(a1 + 16);
      if (v13)
      {
        v8 = DCSDictionary::searchByString(v13, v6, a3, a4);
        if (!MutableCopy)
          return v8;
        goto LABEL_16;
      }
LABEL_15:
      v8 = 0;
      if (!MutableCopy)
        return v8;
LABEL_16:
      CFRelease(MutableCopy);
      return v8;
    }
  }
  return 0;
}

uint64_t DCSCopyRecordForReference(uint64_t a1, const __CFString *a2)
{
  DCSDictionary *v2;

  if (a1 && (v2 = *(DCSDictionary **)(a1 + 16)) != 0)
    return DCSDictionary::searchByReference(v2, a2);
  else
    return 0;
}

uint64_t DCSSearchSessionCreate(uint64_t a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  const __CFString *MutableCopy;
  DCSDictionary *v12;
  const __CFLocale *v13;
  uint64_t v14;

  *(_BYTE *)(SyncSingleton<DCSEnvironment>::instance() + 136) = 1;
  if (!a1)
  {
    v10 = 0;
    goto LABEL_6;
  }
  v10 = *(_QWORD *)(a1 + 16);
  if (!v10)
  {
LABEL_6:
    v12 = 0;
    goto LABEL_8;
  }
  if ((DCSDictionary::isNetworkDictionary(*(DCSDictionary **)(a1 + 16)) & 1) != 0)
  {
    MutableCopy = 0;
    goto LABEL_9;
  }
  v12 = *(DCSDictionary **)(a1 + 16);
LABEL_8:
  MutableCopy = CFStringCreateMutableCopy(0, 0, a2);
  v13 = (const __CFLocale *)DCSDictionary::primaryLocale(v12);
  DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v13);
  a2 = MutableCopy;
LABEL_9:
  v14 = operator new();
  DCSSearchSession::DCSSearchSession(v14, v10, a2, a3, a4, a5);
  if (MutableCopy)
    CFRelease(MutableCopy);
  return *(_QWORD *)v14;
}

void sub_1CDF78CD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10E0C40DFD76AA2);
  _Unwind_Resume(a1);
}

uint64_t DCSSearchSessionScheduleWithRunLoop(uint64_t a1, __CFRunLoop *a2, const __CFString *a3)
{
  return DCSSearchSession::scheduleRunLoop(*(DCSSearchSession **)(a1 + 16), a2, a3);
}

uint64_t DCSSearchSessionUnscheduleFromRunLoop(uint64_t a1, __CFRunLoop *a2, const __CFString *a3)
{
  return DCSSearchSession::unscheduleRunLoop(*(DCSSearchSession **)(a1 + 16), a2, a3);
}

uint64_t EqualHeadwordCallback(DCSRecord *a1, DCSRecord *a2)
{
  void *v3;
  void *v4;

  v3 = DCSRecord::headword(a1);
  v4 = DCSRecord::headword(a2);
  return CFEqual(v3, v4);
}

CFHashCode HashHeadwordCallback(DCSRecord *a1)
{
  void *v1;

  v1 = DCSRecord::headword(a1);
  return CFHash(v1);
}

__CFArray *DCSCopyRecordsForHeadword(uint64_t a1, const __CFString *a2)
{
  __CFArray *result;
  uint64_t v4;

  result = 0;
  v4 = a1;
  if (a1)
  {
    if (a2)
      return DCSCopyRecordsWithHeadword(1, (uint64_t)&v4, a2);
  }
  return result;
}

DCSRecord *DCSRecordGetDictionary(uint64_t a1)
{
  DCSRecord *result;

  result = *(DCSRecord **)(a1 + 16);
  if (result)
    return (DCSRecord *)DCSRecord::dictionaryRef(result);
  return result;
}

uint64_t ComparatorForSortingRecord(_QWORD **a1, _QWORD **a2, _BYTE *a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *a1[2];
  v4 = *a2[2];
  if (v3 == v4)
    return ComparatorForSortingHeadword(a1, a2, a3);
  if (*(_QWORD *)(v3 + 72) < *(_QWORD *)(v4 + 72))
    return -1;
  return 1;
}

DCSRecord *DCSRecordGetString(uint64_t a1)
{
  DCSRecord *result;

  result = *(DCSRecord **)(a1 + 16);
  if (result)
    return (DCSRecord *)DCSRecord::keyString(result);
  return result;
}

DCSRecord *DCSRecordGetHeadword(uint64_t a1)
{
  DCSRecord *result;

  result = *(DCSRecord **)(a1 + 16);
  if (result)
    return (DCSRecord *)DCSRecord::headword(result);
  return result;
}

DCSRecord *DCSRecordSetHeadword(uint64_t a1, const __CFString *a2)
{
  DCSRecord *result;

  result = *(DCSRecord **)(a1 + 16);
  if (result)
    return (DCSRecord *)DCSRecord::setHeadword(result, a2);
  return result;
}

DCSRecord *DCSRecordGetRawHeadword(uint64_t a1)
{
  DCSRecord *result;

  result = *(DCSRecord **)(a1 + 16);
  if (result)
    return (DCSRecord *)DCSRecord::dataString(result);
  return result;
}

DCSRecord *DCSRecordGetSupplementalHeadword(uint64_t a1)
{
  DCSRecord *result;

  result = *(DCSRecord **)(a1 + 16);
  if (result)
    return (DCSRecord *)DCSRecord::yomiString(result);
  return result;
}

DCSRecord *DCSRecordGetTitle(uint64_t a1)
{
  DCSRecord *result;

  result = *(DCSRecord **)(a1 + 16);
  if (result)
    return (DCSRecord *)DCSRecord::titleString(result);
  return result;
}

DCSRecord *DCSRecordGetAnchor(uint64_t a1)
{
  DCSRecord *result;

  result = *(DCSRecord **)(a1 + 16);
  if (result)
    return (DCSRecord *)DCSRecord::anchorString(result);
  return result;
}

DCSRecord *DCSRecordGetSubDictionary(uint64_t a1)
{
  DCSRecord *result;

  result = *(DCSRecord **)(a1 + 16);
  if (result)
    return (DCSRecord *)DCSRecord::subDictionaryRef(result);
  return result;
}

uint64_t DCSRecordGetDataURL(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
    return *(_QWORD *)(v1 + 224);
  else
    return 0;
}

uint64_t DCSRecordCopyDataURL(uint64_t a1, uint64_t a2)
{
  DCSDictionary **v2;
  uint64_t v5;

  v2 = *(DCSDictionary ***)(a1 + 16);
  if (!v2)
    return 0;
  v5 = SyncSingleton<DCSEnvironment>::instance();
  DCSEnvironment::logUsageTrackingInfo(v5, a1);
  return DCSRecord::copyDataURL(v2, a2);
}

uint64_t DCSRecordCopyDefinition(uint64_t a1, uint64_t a2)
{
  DCSDictionary **v2;
  uint64_t v5;

  v2 = *(DCSDictionary ***)(a1 + 16);
  if (!v2)
    return 0;
  v5 = SyncSingleton<DCSEnvironment>::instance();
  DCSEnvironment::logUsageTrackingInfo(v5, a1);
  return DCSRecord::copyData(v2, a2);
}

DCSDictionary **DCSRecordCopyTextElements(uint64_t a1, const __CFArray *a2)
{
  DCSDictionary **result;

  result = *(DCSDictionary ***)(a1 + 16);
  if (result)
    return (DCSDictionary **)DCSRecord::copyKeyedElements(result, a2);
  return result;
}

uint64_t DCSRecordSetAssociatedObj(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 16);
  if (v2)
    *(_QWORD *)(v2 + 240) = a2;
  return result;
}

uint64_t DCSRecordGetAssociatedObj(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
    return *(_QWORD *)(v1 + 240);
  else
    return 0;
}

const void *DCSDictionaryCreate(const __CFURL *a1)
{
  DCSDictionaryManager *v2;
  const void *v3;

  v2 = (DCSDictionaryManager *)SyncSingleton<DCSDictionaryManager>::instance();
  v3 = DCSDictionaryManager::dictionary(v2, a1, 0);
  StartDownloadDictionaryIfRequired((uint64_t)v3);
  return v3;
}

uint64_t StartDownloadDictionaryIfRequired(uint64_t result)
{
  uint64_t v1;
  DCSDictionary *v2;

  if (result)
  {
    v1 = *(_QWORD *)(result + 16);
    if (v1)
      v2 = *(DCSDictionary **)(v1 + 96);
    else
      v2 = 0;
    result = DCSMAPrepareMobileAssetQuery();
    if ((_DWORD)result == 1)
      return DCSDictionary::startGlobalDictionariesEnvironment(v2);
  }
  return result;
}

const void *DCSDictionaryCreateWithIdentifier(const __CFString *a1)
{
  DCSEnvironment *v2;
  const __CFSet *v3;
  const __CFSet *v4;
  CFIndex Count;
  unint64_t v6;
  const void **v7;
  size_t v8;
  DCSDictionary *v9;
  const __CFString *v10;
  const void *v11;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v2 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  v3 = DCSEnvironment::copyAvailableDictionaries(v2);
  if (!v3)
    return 0;
  v4 = v3;
  Count = CFSetGetCount(v3);
  MEMORY[0x1E0C80A78](Count);
  v7 = (const void **)((char *)v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v6 >= 0x200)
    v8 = 512;
  else
    v8 = v6;
  bzero((char *)v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0), v8);
  CFSetGetValues(v4, v7);
  if (Count < 1)
  {
LABEL_12:
    v11 = 0;
  }
  else
  {
    while (1)
    {
      if (*v7 && (v9 = (DCSDictionary *)*((_QWORD *)*v7 + 2)) != 0)
        v10 = (const __CFString *)DCSDictionary::identifier(v9);
      else
        v10 = 0;
      if (CFStringCompare(a1, v10, 0) == kCFCompareEqualTo)
        break;
      ++v7;
      if (!--Count)
        goto LABEL_12;
    }
    v11 = *v7;
  }
  CFRelease(v4);
  StartDownloadDictionaryIfRequired((uint64_t)v11);
  return v11;
}

const __CFDictionary *DCSDictionaryGetIdentifier(uint64_t a1)
{
  DCSDictionary *v1;

  if (a1 && (v1 = *(DCSDictionary **)(a1 + 16)) != 0)
    return DCSDictionary::identifier(v1);
  else
    return 0;
}

uint64_t DCSDictionaryGetURL(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(_QWORD *)(result + 16);
    if (v1)
      return *(_QWORD *)(v1 + 48);
    else
      return 0;
  }
  return result;
}

const __CFDictionary *DCSDictionaryGetName(uint64_t a1)
{
  DCSDictionary *v1;

  if (a1 && (v1 = *(DCSDictionary **)(a1 + 16)) != 0)
    return DCSDictionary::name(v1);
  else
    return 0;
}

const __CFString *DCSDictionaryGetShortName(uint64_t a1)
{
  DCSDictionary *v1;

  if (a1 && (v1 = *(DCSDictionary **)(a1 + 16)) != 0)
    return DCSDictionary::shortName(v1);
  else
    return 0;
}

uint64_t DCSDictionaryGetBaseURL(uint64_t a1)
{
  DCSDictionary *v2;

  *(_BYTE *)(SyncSingleton<DCSEnvironment>::instance() + 136) = 1;
  if (a1 && (v2 = *(DCSDictionary **)(a1 + 16)) != 0)
    return DCSDictionary::baseURL(v2);
  else
    return 0;
}

uint64_t DCSDictionaryGetSubDictionaries(uint64_t a1)
{
  DCSDictionary *v1;

  if (a1 && (v1 = *(DCSDictionary **)(a1 + 16)) != 0)
    return DCSDictionary::subDictionaries(v1);
  else
    return 0;
}

uint64_t DCSDictionaryGetParentDictionary(uint64_t a1)
{
  DCSDictionary *v1;

  if (a1 && (v1 = *(DCSDictionary **)(a1 + 16)) != 0)
    return DCSDictionary::parentDictionary(v1);
  else
    return 0;
}

uint64_t DCSDictionaryGetPreferenceHTML(uint64_t a1)
{
  DCSDictionary *v1;

  if (a1 && (v1 = *(DCSDictionary **)(a1 + 16)) != 0)
    return DCSDictionary::preferenceHTML(v1);
  else
    return 0;
}

const void *DCSDictionaryGetPreference(const void *result)
{
  DCSDictionary *v1;
  const __CFString *v2;
  DCSEnvironment *v3;

  if (result)
  {
    v1 = (DCSDictionary *)*((_QWORD *)result + 2);
    if (v1)
    {
      v2 = (const __CFString *)DCSDictionary::identifier(*((DCSDictionary **)result + 2));
      v3 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
      result = DCSEnvironment::getDictionaryPreference(v3, v2);
      if (!result)
        return (const void *)DCSDictionary::preference(v1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t DCSDictionarySetPreference(uint64_t result, const __CFDictionary *a2)
{
  DCSDictionary *v2;
  const void *Preference;
  const __CFDictionary *v5;
  DCSEnvironment *v6;
  const __CFString *v7;

  if (result)
  {
    v2 = *(DCSDictionary **)(result + 16);
    if (v2)
    {
      Preference = DCSDictionaryGetPreference((const void *)result);
      if (!Preference || (result = CFEqual(Preference, a2), !(_DWORD)result))
      {
        DCSDictionary::setPreference(v2, a2);
        v5 = (const __CFDictionary *)DCSDictionary::preference(v2);
        v6 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
        v7 = (const __CFString *)DCSDictionary::identifier(v2);
        return DCSEnvironment::setDictionaryPreference(v6, v7, v5);
      }
    }
  }
  return result;
}

const __CFArray *DCSDictionaryGetLanguages(uint64_t a1)
{
  CFDictionaryRef *v1;

  if (a1 && (v1 = *(CFDictionaryRef **)(a1 + 16)) != 0)
    return DCSDictionary::languages(v1);
  else
    return 0;
}

CFTypeRef DCSDictionaryCopyResourceURLsOfType(uint64_t a1, CFStringRef theString1)
{
  DCSDictionary *v2;
  const void *v4;

  if (!a1)
    return 0;
  v2 = *(DCSDictionary **)(a1 + 16);
  if (!v2)
    return 0;
  if (CFStringCompare(theString1, CFSTR("DCSResourceTypeStyleSheet"), 0))
  {
    if (CFStringCompare(theString1, CFSTR("DCSResourceTypePrivateFont"), 0))
      return 0;
    v4 = (const void *)DCSDictionary::privateFontURLs(v2);
    if (!v4)
      return 0;
  }
  else
  {
    v4 = (const void *)DCSDictionary::styleSheetURLs(v2);
    if (!v4)
      return 0;
  }
  return CFRetain(v4);
}

void DCSDictionarySetDataHeader(uint64_t a1, const __CFString *a2, uint64_t a3, int a4, const __CFString *a5)
{
  DCSDictionary *v5;

  if (a1)
  {
    v5 = *(DCSDictionary **)(a1 + 16);
    if (v5)
      DCSDictionary::setCustomHTMLHeader(v5, a2, a3, a4, a5);
  }
}

const __CFDictionary *DCSDictionaryIsNetworkService(const __CFDictionary *result)
{
  if (result)
  {
    result = (const __CFDictionary *)*((_QWORD *)result + 2);
    if (result)
      return DCSDictionary::isNetworkDictionary(result);
  }
  return result;
}

DCSDictionary *DCSDictionaryIsLanguageDictionary(DCSDictionary *result)
{
  if (result)
  {
    result = (DCSDictionary *)*((_QWORD *)result + 2);
    if (result)
      return (DCSDictionary *)DCSDictionary::isLanguageDictionary(result);
  }
  return result;
}

const __CFDictionary *DCSDictionaryGetAssetObj(uint64_t a1)
{
  uint64_t v1;
  const __CFDictionary *v2;

  if (a1 && (v1 = *(_QWORD *)(a1 + 16)) != 0 && (v2 = *(const __CFDictionary **)(v1 + 96)) != 0)
    return DCSMAGetAssetObj(v2);
  else
    return 0;
}

uint64_t DCSDictionaryDownloadFinished(uint64_t a1)
{
  DCSDictionary *v1;
  DCSDictionary *v2;

  if (a1)
  {
    v1 = *(DCSDictionary **)(a1 + 16);
    if (v1)
    {
      v2 = (DCSDictionary *)*((_QWORD *)v1 + 12);
      if (v2)
        DCSDictionary::startGlobalDictionariesEnvironment(v2);
    }
  }
  else
  {
    v1 = 0;
  }
  return DCSDictionary::baseURL(v1);
}

CFSetRef DCSCopyLanguagesOfPreparedDefaultDictionaries()
{
  __CFDictionary *Mutable;
  DCSEnvironment *v1;
  __CFArray *v2;
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const CFArrayCallBacks *v7;
  DCSDictionary **ValueAtIndex;
  DCSDictionary **v9;
  DCSDictionary *v10;
  const __CFString *v11;
  DCSDictionary *v12;
  const __CFDictionary *v13;
  uint64_t v14;
  DCSDictionary *v15;
  CFDictionaryRef *v16;
  const __CFArray *v17;
  const __CFArray *v18;
  __CFArray *v19;
  CFIndex v20;
  CFIndex v21;
  CFIndex i;
  const __CFDictionary *v23;
  const void *Value;
  CFIndex v25;
  CFIndex v26;
  unint64_t v27;
  const void **v28;
  size_t v29;
  CFSetRef v30;
  void *values[2];

  values[1] = *(void **)MEMORY[0x1E0C80C00];
  if (!DCSMAPrepareMobileAssetQuery())
    return 0;
  DCSDictionary::startGlobalDictionariesEnvironment((DCSDictionary *)1);
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v1 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  v2 = DCSEnvironment::copyActiveDictionaries(v1, 0);
  if (v2)
  {
    v3 = v2;
    Count = CFArrayGetCount(v2);
    if (Count >= 1)
    {
      v5 = Count;
      v6 = 0;
      v7 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
      do
      {
        ValueAtIndex = (DCSDictionary **)CFArrayGetValueAtIndex(v3, v6);
        values[0] = 0;
        if (!ValueAtIndex)
          goto LABEL_27;
        v9 = ValueAtIndex;
        v10 = ValueAtIndex[2];
        if (!v10)
          goto LABEL_27;
        v11 = DCSDictionary::primaryLanguage(v10);
        values[0] = (void *)v11;
        if (v11)
          CFDictionarySetValue(Mutable, v11, &stru_1E8B587B0);
        v12 = v9[2];
        if (!v12)
          goto LABEL_27;
        v13 = DCSDictionary::identifier(v12);
        if (!v13)
          goto LABEL_27;
        v14 = (uint64_t)v13;
        v15 = v9[2];
        if (!v15 || !DCSDictionary::isLanguageDictionary(v15))
          goto LABEL_27;
        v16 = (CFDictionaryRef *)v9[2];
        if (v16 && (v17 = DCSDictionary::languages(v16)) != 0)
        {
          v18 = v17;
          v19 = CFArrayCreateMutable(0, 0, v7);
          v20 = CFArrayGetCount(v18);
          if (v20 >= 1)
          {
            v21 = v20;
            for (i = 0; i != v21; ++i)
            {
              v23 = (const __CFDictionary *)CFArrayGetValueAtIndex(v18, i);
              Value = CFDictionaryGetValue(v23, CFSTR("DCSDictionaryIndexLanguage"));
              if (Value)
                CFArrayAppendValue(v19, Value);
            }
          }
          if (CFArrayGetCount(v19) <= 0)
          {
            CFRelease(v19);
            v7 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
            goto LABEL_27;
          }
          v7 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
          if (!v19)
            goto LABEL_27;
        }
        else
        {
          if (!values[0])
            goto LABEL_27;
          v19 = CFArrayCreate(0, (const void **)values, 1, v7);
          if (!v19)
            goto LABEL_27;
        }
        DCSMAUpdateLinguisticData(v14, v19, 1);
        CFRelease(v19);
LABEL_27:
        ++v6;
      }
      while (v6 != v5);
    }
    CFRelease(v3);
  }
  v25 = CFDictionaryGetCount(Mutable);
  if (v25 < 1)
  {
    v30 = 0;
  }
  else
  {
    v26 = v25;
    MEMORY[0x1E0C80A78](v25);
    v28 = (const void **)((char *)values - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0));
    if (v27 >= 0x200)
      v29 = 512;
    else
      v29 = v27;
    bzero((char *)values - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0), v29);
    CFDictionaryGetKeysAndValues(Mutable, v28, 0);
    v30 = CFSetCreate(0, v28, v26, MEMORY[0x1E0C9B3B0]);
  }
  CFRelease(Mutable);
  DCSDictionary::startGlobalDictionariesEnvironment(0);
  return v30;
}

uint64_t DCSPrepareMobileAssetQuery()
{
  return DCSMAPrepareMobileAssetQuery();
}

uint64_t DCSGetServicePresentationType()
{
  DCSEnvironment *v0;
  const __CFString *v1;

  v0 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  return DCSEnvironment::copyInactiveDictionaries(v0, v1);
}

CFNumberRef DCSSetServicePresentationType(__int16 a1)
{
  DCSEnvironment *v2;

  v2 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  return DCSEnvironment::setServiceWindowType(v2, a1);
}

void DCSActivateDictionaryPanel(CFDataRef theData)
{
  BOOL v2;
  __CFMessagePort *Remote;
  __CFMessagePort *v4;
  SInt32 v5;

  if (theData)
  {
    if (!CFDataGetLength(theData))
    {
      v2 = 0;
      goto LABEL_7;
    }
  }
  else if (DCSActivateDictionaryPanel::_PanelIsBeingShown)
  {
    return;
  }
  Remote = CFMessagePortCreateRemote(0, CFSTR("com.apple.DictionaryPanelHelper"));
  if (!Remote)
    return;
  v4 = Remote;
  v5 = CFMessagePortSendRequest(Remote, 1, theData, 5.0, 5.0, CFSTR("DCSActivateDictionaryPanelReplyModes"), 0);
  CFRelease(v4);
  v2 = v5 == 0;
LABEL_7:
  DCSActivateDictionaryPanel::_PanelIsBeingShown = v2;
}

uint64_t DCSCreateAppleWordEquivalenceList(uint64_t a1)
{
  if (a1)
    return (uint64_t)CreateWordEquivalenceList(a1);
  return a1;
}

void DCSNormalizeSearchString(const __CFString *a1)
{
  DCSNormalizeSearchStringWithOptionsAndLocale(a1, 0, 0);
}

DIR *IterateDirectory(const char *a1, unsigned int (*a2)(char *, uint64_t, uint64_t), uint64_t a3)
{
  DIR *result;
  DIR *v7;
  size_t v8;
  char *v9;
  size_t v10;
  char *v11;
  dirent *v12;
  dirent *v13;
  const char *d_name;
  int v15;
  stat v16;

  result = opendir(a1);
  if (result)
  {
    v7 = result;
    v8 = strlen(a1) + 256;
    v9 = (char *)malloc_type_malloc(v8, 0x413E99EuLL);
    strlcpy(v9, a1, v8);
    v10 = strlen(a1);
    *(_WORD *)&v9[v10] = 47;
    v11 = &v9[v10 + 1];
    memset(&v16, 0, sizeof(v16));
    v12 = readdir(v7);
    if (v12)
    {
      v13 = v12;
      do
      {
        v15 = v13->d_name[0];
        d_name = v13->d_name;
        if (v15 != 46)
        {
          strlcpy(v11, d_name, 0x100uLL);
          if ((stat(v9, &v16) & 0x80000000) == 0)
          {
            if ((v16.st_mode & 0xF000) == 0x4000)
            {
              if (a2(v9, 1, a3))
                IterateDirectory(v9, a2, a3);
            }
            else
            {
              a2(v9, 0, a3);
            }
          }
        }
        v13 = readdir(v7);
      }
      while (v13);
    }
    free(v9);
    return (DIR *)closedir(v7);
  }
  return result;
}

BOOL ItemExistsAtPath(const char *a1, int a2)
{
  stat v4;

  if (a2)
  {
    memset(&v4, 0, sizeof(v4));
    return !stat(a1, &v4) && (v4.st_mode & 0xF000) == 0x4000;
  }
  else
  {
    return access(a1, 0) == 0;
  }
}

uint64_t ItemExistsAtURL(const __CFURL *a1)
{
  uint64_t result;
  int v3;
  UInt8 buffer[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  result = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024);
  if ((_DWORD)result)
  {
    v3 = CFURLHasDirectoryPath(a1);
    return ItemExistsAtPath((const char *)buffer, v3);
  }
  return result;
}

CFStringRef CopyFileObjectIdentifierAtURL(const __CFURL *a1)
{
  const __CFURL *v1;
  CFStringRef v2;

  v1 = CFURLCopyAbsoluteURL(a1);
  v2 = CFURLCopyFileSystemPath(v1, kCFURLPOSIXPathStyle);
  CFRelease(v1);
  return v2;
}

void BuildWordBreakTable(CFStringRef str, CFRange range, const __CFLocale *a3, char *__b)
{
  CFIndex length;
  CFIndex location;
  const __CFString *v9;
  CFStringTokenizerRef v10;
  CFStringTokenizerRef v11;
  CFRange v12;
  CFRange v13;

  length = range.length;
  location = range.location;
  if ((range.length & 0x8000000000000000) == 0)
    memset(__b, 255, 8 * range.length + 8);
  v12.location = location;
  v12.length = length;
  v9 = CFStringCreateWithSubstring(0, str, v12);
  v13.location = 0;
  v13.length = length;
  v10 = CFStringTokenizerCreate(0, v9, v13, 0x80uLL, a3);
  if (v10)
  {
    v11 = v10;
    while (_CFStringTokenizerTokenize())
    {
      *(_QWORD *)__b = 1;
      bzero(__b + 8, 0xFFFFFFFFFFFFFFF8);
    }
    CFRelease(v11);
    CFRelease(v9);
  }
}

CFTypeRef CopyPreferredEnglishLanguage(CFLocaleIdentifier localeID)
{
  const __CFDictionary *ComponentsFromLocaleIdentifier;
  void *v2;
  const void **v3;
  const __CFDictionary *v4;
  __CFDictionary *MutableCopy;
  CFLocaleIdentifier LocaleIdentifierFromComponents;
  char v7;
  uint64_t v8;
  char v9;
  const CFDictionaryKeyCallBacks *v10;
  const CFDictionaryValueCallBacks *v11;
  __CFString *v12;
  char v13;
  const __CFDictionary *v14;
  const CFArrayCallBacks *v15;
  const __CFArray *v16;
  const __CFArray *v17;
  const __CFArray *v18;
  const __CFArray *v19;
  const void *ValueAtIndex;
  CFTypeRef v21;
  CFLocaleIdentifier v23;
  void *values[2];
  CFTypeRef cf;
  CFTypeRef v26;
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  v23 = localeID;
  ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier(0, localeID);
  v2 = (void *)*MEMORY[0x1E0C9B060];
  v3 = (const void **)MEMORY[0x1E0C9B088];
  if (ComponentsFromLocaleIdentifier)
  {
    v4 = ComponentsFromLocaleIdentifier;
    if (CFDictionaryGetValue(ComponentsFromLocaleIdentifier, (const void *)*MEMORY[0x1E0C9B060]))
    {
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v4);
      CFDictionarySetValue(MutableCopy, *v3, CFSTR("en"));
      LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents(0, MutableCopy);
      CFRelease(MutableCopy);
      if (LocaleIdentifierFromComponents)
      {
        v7 = 0;
        v23 = LocaleIdentifierFromComponents;
LABEL_8:
        CFRelease(v4);
        goto LABEL_9;
      }
    }
    else
    {
      LocaleIdentifierFromComponents = 0;
    }
    v7 = 1;
    goto LABEL_8;
  }
  LocaleIdentifierFromComponents = 0;
  v7 = 1;
LABEL_9:
  v8 = 0;
  keys[0] = (void *)*v3;
  keys[1] = v2;
  cf = 0;
  v26 = 0;
  v9 = 1;
  v10 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v11 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  do
  {
    v12 = off_1E8B56DB8[v8];
    v13 = v9;
    values[0] = CFSTR("en");
    values[1] = v12;
    v14 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, v10, v11);
    *(&cf + v8) = CFLocaleCreateLocaleIdentifierFromComponents(0, v14);
    CFRelease(v14);
    v9 = 0;
    v8 = 1;
  }
  while ((v13 & 1) != 0);
  v15 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  v16 = CFArrayCreate(0, &cf, 2, MEMORY[0x1E0C9B378]);
  v17 = CFArrayCreate(0, (const void **)&v23, 1, v15);
  v18 = CFBundleCopyLocalizationsForPreferences(v16, v17);
  if (v18)
  {
    v19 = v18;
    ValueAtIndex = CFArrayGetValueAtIndex(v18, 0);
    v21 = CFRetain(ValueAtIndex);
    CFRelease(v19);
  }
  else
  {
    v21 = 0;
  }
  CFRelease(v16);
  CFRelease(v17);
  CFRelease(cf);
  CFRelease(v26);
  if ((v7 & 1) == 0)
    CFRelease(LocaleIdentifierFromComponents);
  return v21;
}

uint64_t CompareLanguageCode(const __CFString *a1, CFStringRef theString2, _BYTE *a3)
{
  uint64_t CanonicalLocaleIdentifierFromString;
  uint64_t v7;
  char v8;
  char v9;
  const __CFDictionary *ComponentsFromLocaleIdentifier;
  const __CFDictionary *v11;
  const __CFString *Value;
  const __CFString *v13;
  uint64_t v14;
  char v15;
  const __CFString *v16;
  const __CFString *v17;
  char v18;
  const __CFString *v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  const __CFString *v23;
  const void *v24;
  const __CFString *v25;
  const __CFDictionary *v26;
  const __CFDictionary *v27;
  const __CFString *v28;
  const __CFString *v29;
  BOOL v30;
  uint64_t v31;
  char v32;
  char v33;
  const void *v34;
  const __CFString *v36;
  const __CFString *v37;
  _BYTE *v38;
  void *v39;
  void *v40;
  void *key;
  _QWORD v42[2];
  __int128 v43;
  CFStringRef theString1;
  CFStringRef theString2a;
  CFStringRef v46;
  CFStringRef v47;
  uint64_t v48;
  uint64_t v50;

  CanonicalLocaleIdentifierFromString = 0;
  v50 = *MEMORY[0x1E0C80C00];
  v46 = 0;
  v47 = 0;
  theString1 = 0;
  theString2a = 0;
  v43 = 0uLL;
  if (!a1 || !theString2)
    return CanonicalLocaleIdentifierFromString;
  if (CFStringCompare(a1, theString2, 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, CFSTR("*"), 0) == kCFCompareEqualTo
    || CFStringCompare(theString2, CFSTR("*"), 0) == kCFCompareEqualTo)
  {
    CanonicalLocaleIdentifierFromString = 1;
    if (a3)
      *a3 = 1;
    return CanonicalLocaleIdentifierFromString;
  }
  if (a3)
    *a3 = 0;
  CanonicalLocaleIdentifierFromString = (uint64_t)CFLocaleCreateCanonicalLocaleIdentifierFromString(0, a1);
  v48 = CanonicalLocaleIdentifierFromString;
  if (!CanonicalLocaleIdentifierFromString)
    return CanonicalLocaleIdentifierFromString;
  if (!CFLocaleCreateCanonicalLocaleIdentifierFromString(0, theString2))
  {
    CFRelease((CFTypeRef)CanonicalLocaleIdentifierFromString);
    return 0;
  }
  v38 = a3;
  v7 = 0;
  v42[0] = 0;
  v42[1] = 0;
  key = (void *)*MEMORY[0x1E0C9B088];
  v40 = (void *)*MEMORY[0x1E0C9B060];
  v8 = 1;
  v39 = (void *)*MEMORY[0x1E0C9B090];
  do
  {
    v9 = v8;
    ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier(0, (CFLocaleIdentifier)*(&v48 + v7));
    v42[v7] = ComponentsFromLocaleIdentifier;
    if (ComponentsFromLocaleIdentifier)
    {
      v11 = ComponentsFromLocaleIdentifier;
      Value = (const __CFString *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, key);
      v13 = (const __CFString *)CFDictionaryGetValue(v11, v40);
      ComponentsFromLocaleIdentifier = (const __CFDictionary *)CFDictionaryGetValue(v11, v39);
    }
    else
    {
      Value = 0;
      v13 = 0;
    }
    v8 = 0;
    *(&v46 + v7) = Value;
    *(&theString1 + v7) = v13;
    *((_QWORD *)&v43 + v7) = ComponentsFromLocaleIdentifier;
    v7 = 1;
  }
  while ((v9 & 1) != 0);
  v14 = 0;
  v15 = 1;
  v16 = CFSTR("en");
  v17 = CFSTR("nb");
  do
  {
    v18 = v15;
    v19 = *(&v46 + v14);
    if (!v19)
      goto LABEL_36;
    if (CFStringCompare(*(&v46 + v14), CFSTR("zh"), 0))
    {
      if (CFStringCompare(v19, v16, 0) || !*(&theString1 + v14))
      {
        if (CFStringCompare(v19, v17, 0) == kCFCompareEqualTo
          || CFStringCompare(v19, CFSTR("nn"), 0) == kCFCompareEqualTo)
        {
          *(&v46 + v14) = CFSTR("no");
        }
      }
      else
      {
        v22 = v17;
        v23 = (const __CFString *)CopyPreferredEnglishLanguage((CFLocaleIdentifier)*(&v48 + v14));
        v24 = (const void *)v42[v14];
        if (v24)
          CFRelease(v24);
        v25 = v16;
        v26 = CFLocaleCreateComponentsFromLocaleIdentifier(0, v23);
        v42[v14] = v26;
        if (v26)
        {
          v27 = v26;
          v28 = (const __CFString *)CFDictionaryGetValue(v26, key);
          v29 = (const __CFString *)CFDictionaryGetValue(v27, v40);
          v26 = (const __CFDictionary *)CFDictionaryGetValue(v27, v39);
        }
        else
        {
          v28 = 0;
          v29 = 0;
        }
        *(&v46 + v14) = v28;
        *(&theString1 + v14) = v29;
        *((_QWORD *)&v43 + v14) = v26;
        CFRelease(v23);
        v16 = v25;
        v17 = v22;
      }
    }
    else if (!*((_QWORD *)&v43 + v14))
    {
      v20 = *(&theString1 + v14);
      if (v20)
      {
        if (CFStringCompare(*(&theString1 + v14), CFSTR("CN"), 1uLL))
        {
          if (CFStringCompare(v20, CFSTR("TW"), 1uLL))
            goto LABEL_36;
          v21 = CFSTR("Hant");
        }
        else
        {
          v21 = CFSTR("Hans");
        }
        *((_QWORD *)&v43 + v14) = v21;
      }
    }
LABEL_36:
    v15 = 0;
    v14 = 1;
  }
  while ((v18 & 1) != 0);
  if (v46)
    v30 = v47 == 0;
  else
    v30 = 1;
  if (v30 || CFStringCompare(v46, v47, 1uLL))
  {
    CanonicalLocaleIdentifierFromString = 0;
  }
  else
  {
    if (v38)
      *v38 = 1;
    v37 = (const __CFString *)*((_QWORD *)&v43 + 1);
    v36 = (const __CFString *)v43;
    if (v43 == 0)
    {
      v36 = theString1;
      CanonicalLocaleIdentifierFromString = 1;
      if (!theString1)
        goto LABEL_43;
      v37 = theString2a;
    }
    else
    {
      CanonicalLocaleIdentifierFromString = 0;
      if (!(_QWORD)v43)
        goto LABEL_43;
    }
    if (v37)
      CanonicalLocaleIdentifierFromString = CFStringCompare(v36, v37, 1uLL) == kCFCompareEqualTo;
  }
LABEL_43:
  v31 = 0;
  v32 = 1;
  do
  {
    v33 = v32;
    CFRelease((CFTypeRef)*(&v48 + v31));
    v34 = (const void *)v42[v31];
    if (v34)
      CFRelease(v34);
    v32 = 0;
    v31 = 1;
  }
  while ((v33 & 1) != 0);
  return CanonicalLocaleIdentifierFromString;
}

const __CFString *GetScriptForLanguage(CFStringRef theString1)
{
  const __CFArray *v2;
  CFRange v4;

  if (GetScriptForLanguage__DispatchOnceToken != -1)
    dispatch_once(&GetScriptForLanguage__DispatchOnceToken, &__block_literal_global_3);
  if (CFStringCompare(theString1, CFSTR("ja"), 1uLL) == kCFCompareEqualTo)
    return CFSTR("Jpan");
  if (CFStringCompare(theString1, CFSTR("ko"), 1uLL) == kCFCompareEqualTo)
    return CFSTR("Kore");
  if (CFStringCompare(theString1, CFSTR("zh-Hans"), 1uLL) == kCFCompareEqualTo)
    return CFSTR("Hans");
  if (CFStringCompare(theString1, CFSTR("zh-Hant"), 1uLL) == kCFCompareEqualTo)
    return CFSTR("Hant");
  v2 = (const __CFArray *)GetScriptForLanguage__LatinLanguagesArray;
  v4.length = CFArrayGetCount((CFArrayRef)GetScriptForLanguage__LatinLanguagesArray);
  v4.location = 0;
  if (CFArrayContainsValue(v2, v4, theString1))
    return CFSTR("Latn");
  else
    return 0;
}

uint64_t DetectEncodingOfStringData(const __CFData *a1)
{
  uint64_t v2;
  const char *Name;
  const __CFString *v5;
  const __CFString *v6;

  ucsdet_open();
  CFDataGetBytePtr(a1);
  CFDataGetLength(a1);
  ucsdet_setText();
  ucsdet_detect();
  Name = (const char *)ucsdet_getName();
  if (Name && (v5 = CFStringCreateWithCString(0, Name, 0x8000100u)) != 0)
  {
    v6 = v5;
    v2 = CFStringConvertIANACharSetNameToEncoding(v5);
    CFRelease(v6);
  }
  else
  {
    v2 = 0xFFFFFFFFLL;
  }
  ucsdet_close();
  return v2;
}

uint64_t ExtraNormalizeStringForArabic(__CFString *a1, int a2)
{
  const __CFString *v4;
  CFRange v6;

  CFStringNormalize(a1, kCFStringNormalizationFormD);
  v6.location = 0;
  v6.length = CFStringGetLength(a1);
  if (a2)
    v4 = CFSTR("[\\u0610-\\u061A \\u064B-\\u065F \\u0670 \\u06D6-\\u06DC \\u06DF-\\u06E4 \\u06E7-\\u06E8 \\u06EA-\\u06ED] Remove");
  else
    v4 = CFSTR("[\\u0610-\\u061A \\u064B-\\u0652 \\u0656-\\u065F \\u0670 \\u06D6-\\u06DC \\u06E1-\\u06E3 \\u06E7-\\u06E8 \\u06EA-\\u06ED] Remove");
  return CFStringTransform(a1, &v6, v4, 0);
}

BOOL ContainsLatinAlphabets(const __CFString *a1)
{
  uint64_t Length;
  uint64_t v3;
  UniChar *v4;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  _QWORD v9[2];
  CFRange v10;

  v9[1] = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  MEMORY[0x1E0C80A78](Length);
  v4 = (UniChar *)((char *)v9 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  v10.location = 0;
  v10.length = Length;
  CFStringGetCharacters(a1, v10, v4);
  if (Length < 1)
    return 0;
  if ((*v4 & 0xFFDFu) - 65 < 0x1A)
    return 1;
  v6 = 1;
  do
  {
    v7 = v6;
    if (Length == v6)
      break;
    v8 = (v4[v6++] & 0xFFDF) - 65;
  }
  while (v8 > 0x19);
  return v7 < Length;
}

void DistanceBetweenWords(CFStringRef theString, const __CFString *a2)
{
  CFMutableStringRef MutableCopy;
  CFMutableStringRef v4;
  CFIndex Length;
  uint64_t v6;
  CFIndex v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  double *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double *v17;
  double *v18;
  uint64_t v19;
  int v20;
  _BOOL4 isDiacritic;
  double v22;
  unsigned __int16 *v23;
  double *v24;
  uint64_t v25;
  int v26;
  int v27;
  double v28;
  _BOOL4 v29;
  double v30;
  double v31;
  _QWORD v33[2];
  CFMutableStringRef v34;
  CFMutableStringRef v35;
  double *v36;
  char *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  CFRange v42;
  CFRange v43;

  v41 = *MEMORY[0x1E0C80C00];
  MutableCopy = CFStringCreateMutableCopy(0, 0, theString);
  v4 = CFStringCreateMutableCopy(0, 0, a2);
  CFStringNormalize(MutableCopy, kCFStringNormalizationFormD);
  CFStringNormalize(v4, kCFStringNormalizationFormD);
  Length = CFStringGetLength(MutableCopy);
  MEMORY[0x1E0C80A78](Length);
  v35 = MutableCopy;
  v42.location = 0;
  v42.length = Length;
  v38 = (char *)v33 - v6;
  CFStringGetCharacters(MutableCopy, v42, (UniChar *)((char *)v33 - v6));
  v7 = CFStringGetLength(v4);
  MEMORY[0x1E0C80A78](v7);
  v34 = v4;
  v43.location = 0;
  v43.length = v7;
  v37 = (char *)v33 - v8;
  CFStringGetCharacters(v4, v43, (UniChar *)((char *)v33 - v8));
  v40 = v7;
  v33[1] = Length + 1 + (Length + 1) * v7;
  MEMORY[0x1E0C80A78](v9);
  v12 = (double *)((char *)v33 - v11);
  v39 = Length;
  if ((Length & 0x8000000000000000) == 0)
  {
    v13 = 0;
    do
    {
      v12[v13] = (double)v13;
      ++v13;
    }
    while (v10 != v13);
  }
  v14 = v39;
  if ((v40 & 0x8000000000000000) == 0)
  {
    v15 = 0;
    v16 = v40 + 1;
    v17 = v12;
    do
    {
      *v17 = (double)v15++;
      v17 = (double *)((char *)v17 + v14 * 8 + 8);
    }
    while (v16 != v15);
  }
  v36 = v12;
  if (v39 >= 1)
  {
    v18 = v36 + 1;
    v19 = 1;
    do
    {
      if (v40 >= 1)
      {
        v20 = *(unsigned __int16 *)&v38[2 * v19 - 2];
        isDiacritic = _isDiacritic(v20);
        if (isDiacritic)
          v22 = 0.1;
        else
          v22 = 1.0;
        v23 = (unsigned __int16 *)v37;
        v24 = v18;
        v25 = v40;
        do
        {
          v27 = *v23++;
          v26 = v27;
          if (v20 == v27)
            v28 = 0.0;
          else
            v28 = 2.0;
          v29 = _isDiacritic(v26);
          if (isDiacritic && v29)
          {
            v30 = v28 / 100.0;
          }
          else
          {
            v30 = v28 * 0.5;
            if (!isDiacritic && !v29)
              v30 = v28;
          }
          if (v29)
            v31 = 0.1;
          else
            v31 = 1.0;
          v24[v14 + 1] = fmin(v30 + *(v24 - 1), fmin(v22 + v24[v14], v31 + *v24));
          v24 = (double *)((char *)v24 + v14 * 8 + 8);
          --v25;
        }
        while (v25);
      }
      ++v18;
    }
    while (v19++ != v39);
  }
  CFRelease(v35);
  CFRelease(v34);
}

BOOL _isDiacritic(int a1)
{
  unsigned int v2;
  _BOOL8 result;

  v2 = a1 - 1552;
  result = 1;
  if (v2 >= 0xB
    && (a1 - 1611) >= 0x15
    && ((a1 - 1750) > 0x17 || ((1 << (a1 + 42)) & 0xF67E7F) == 0))
  {
    return a1 == 1648;
  }
  return result;
}

uint64_t IsWorkingInDictionaryApp()
{
  if (IsWorkingInDictionaryApp__OnceToken != -1)
    dispatch_once(&IsWorkingInDictionaryApp__OnceToken, &__block_literal_global_281);
  return IsWorkingInDictionaryApp__Flag;
}

void DCSLog(int a1, CFStringRef format, ...)
{
  uint64_t v4;
  CFStringRef v5;
  CFStringRef v6;
  NSObject *v7;
  uint8_t buf[4];
  CFStringRef v9;
  uint64_t v10;
  va_list va;

  va_start(va, format);
  v10 = *MEMORY[0x1E0C80C00];
  if (DCSLog__OnceToken != -1)
    dispatch_once(&DCSLog__OnceToken, &__block_literal_global_285);
  if (a1 > 15)
  {
    if (a1 == 16)
    {
      v4 = 3;
      goto LABEL_13;
    }
    if (a1 == 17)
    {
      v4 = 4;
      goto LABEL_13;
    }
  }
  else
  {
    if (a1 == 1)
    {
      v4 = 1;
      goto LABEL_13;
    }
    if (a1 == 2)
    {
      v4 = 2;
      goto LABEL_13;
    }
  }
  v4 = 0;
LABEL_13:
  v5 = CFStringCreateWithFormatAndArguments(0, 0, format, va);
  if (v5)
  {
    v6 = v5;
    v7 = DCSLog__LogObj[v4];
    if (os_log_type_enabled(v7, (os_log_type_t)a1))
    {
      *(_DWORD *)buf = 138543362;
      v9 = v6;
      _os_log_impl(&dword_1CDF67000, v7, (os_log_type_t)a1, "%{public}@", buf, 0xCu);
    }
    CFRelease(v6);
  }
}

__CFArray *CreateWordEquivalenceList(uint64_t a1)
{
  const __CFString *v1;
  const __CFURL *v2;
  CFIndex Length;
  uint64_t v4;
  uint64_t v5;
  UniChar *v6;
  uint64_t v7;
  char *v8;
  CFMutableStringRef MutableCopy;
  int v10;
  CFIndex v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t matched;
  uint64_t v16;
  uint64_t *v17;
  unint64_t *v18;
  const unsigned __int8 **v19;
  uint64_t v20;
  const unsigned __int8 *v21;
  unint64_t v22;
  __int16 v23;
  uint64_t v24;
  CFIndex v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  CFIndex v30;
  const unsigned __int8 *v31;
  uint64_t v32;
  int v33;
  uint64_t v35;
  const __CFString *v36;
  const __CFString *v37;
  int v38;
  UniChar *v39;
  _QWORD *v40;
  uint64_t v41;
  const unsigned __int16 *v42;
  char *v43;
  __CFArray *Mutable;
  _QWORD v45[1024];
  _QWORD v46[1024];
  _QWORD v47[1026];
  CFRange v48;
  CFRange v49;

  v1 = (const __CFString *)MEMORY[0x1E0C80A78](a1);
  v47[1024] = *MEMORY[0x1E0C80C00];
  v2 = (const __CFURL *)_PrivateWEDictURL;
  if (!_PrivateWEDictURL)
  {
    pthread_once(&CreateWordEquivalenceList::once_control, (void (*)(void))InitializeDictionaryStuff);
    v2 = (const __CFURL *)_PrivateWEDictURL;
    if (!_PrivateWEDictURL)
      return 0;
  }
  v40 = IDXCreateIndexObject(0, v2, 0);
  if (!v40)
    return 0;
  Length = CFStringGetLength(v1);
  v35 = (uint64_t)&v35;
  v4 = MEMORY[0x1E0C80A78](Length);
  v6 = (UniChar *)((char *)&v35 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1E0C80A78](v4);
  v8 = (char *)&v35 - ((v7 + 23) & 0xFFFFFFFFFFFFFFF0);
  MutableCopy = CFStringCreateMutableCopy(0, 0, v1);
  CFStringLowercase(MutableCopy, 0);
  v48.location = 0;
  v48.length = Length;
  CFStringGetCharacters(MutableCopy, v48, v6);
  CFRelease(MutableCopy);
  v39 = v6;
  v10 = v6[Length - 1];
  if (v10 == 42)
    v11 = Length - 1;
  else
    v11 = Length;
  v49.location = 0;
  v49.length = v11;
  v43 = v8;
  BuildWordBreakTable(v1, v49, 0, v8);
  v38 = v10;
  if (v10 == 42)
    *(_QWORD *)&v43[8 * Length - 8] = -1;
  memset(v47, 0, 512);
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (v11 >= 1)
  {
    v12 = 0;
    v36 = CFSTR("IDXPrefixMatch");
    v37 = CFSTR("IDXCommonPrefixMatch");
    v13 = v43;
    do
    {
      if (*(_QWORD *)&v43[8 * v12] == 1)
      {
        v14 = (uint64_t)v40;
        v41 = v11 - v12;
        v42 = &v39[v12];
        IDXSetSearchCharacters((uint64_t)v40, (uint64_t)v42, v11 - v12, (uint64_t)v37);
        matched = IDXGetMatchDataPtr(v14, 1024, (uint64_t)v47, (uint64_t)v46);
        v16 = matched;
        if (matched)
        {
          if (matched >= 1)
          {
            v17 = v46;
            v18 = v45;
            v19 = (const unsigned __int8 **)v47;
            v20 = matched;
            do
            {
              v21 = *v19;
              v22 = (unint64_t)*(unsigned __int16 *)*v19 >> 1;
              *v18 = v22;
              v23 = v22 + v12;
              if (v11 >= v23 && *(_QWORD *)&v43[8 * v23])
                AddSynonymsToArray(Mutable, 0, 0, v21, *v17);
              ++v17;
              ++v18;
              ++v19;
              --v20;
            }
            while (v20);
          }
        }
        else
        {
          v24 = 1;
          do
          {
            v25 = v24;
            if (v12 + v24 >= v11)
              break;
            ++v24;
          }
          while (!*(_QWORD *)&v13[8 * v25]);
          AddSynonymsToArray(Mutable, v42, v25, 0, 0);
        }
        if (v38 == 42)
        {
          v26 = (uint64_t)v40;
          IDXSetSearchCharacters((uint64_t)v40, (uint64_t)v42, v41, (uint64_t)v36);
          v27 = IDXGetMatchDataPtr(v26, 1024, (uint64_t)v47, (uint64_t)v46);
          if (v27 >= 1)
          {
            v28 = v27;
            v29 = 0;
            v30 = v41 + 1;
            do
            {
              v31 = (const unsigned __int8 *)v47[v29];
              if (v16 < 1)
              {
                v32 = 0;
              }
              else
              {
                v32 = 0;
                v33 = 0;
                do
                {
                  if (v45[v32] == (unint64_t)*(unsigned __int16 *)v31 >> 1)
                    break;
                  v32 = (__int16)++v33;
                }
                while (v16 > (__int16)v33);
              }
              if (v16 == v32)
                AddSynonymsToArray(Mutable, v42, v30, v31, v46[v29]);
              ++v29;
            }
            while (v29 != v28);
          }
        }
      }
      ++v12;
      v13 += 8;
    }
    while (v12 != v11);
  }
  CFRelease(v40);
  return Mutable;
}

const __CFURL *InitializeDictionaryStuff(void)
{
  DCSEnvironment *v0;
  __CFBundle *FrameworkBundle;
  const __CFURL *result;

  v0 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(v0);
  result = CFBundleCopyResourceURL(FrameworkBundle, CFSTR("WordEquivalence"), CFSTR("dictionary"), 0);
  _PrivateWEDictURL = (uint64_t)result;
  if (result)
    return (const __CFURL *)IDXCreateIndexObject(0, result, 0);
  return result;
}

void AddSynonymsToArray(__CFArray *a1, const unsigned __int16 *a2, CFIndex a3, const unsigned __int8 *a4, uint64_t a5)
{
  __CFArray *Mutable;
  CFStringRef v11;
  uint64_t v12;
  const UInt8 *v13;
  CFIndex v14;
  CFStringRef v15;

  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (a2)
  {
    v11 = CFStringCreateWithCharacters(0, a2, a3);
    CFArrayAppendValue(Mutable, v11);
    CFRelease(v11);
  }
  if (a5 >= 1)
  {
    v12 = 0;
    do
    {
      v14 = *(__int16 *)a4;
      v13 = a4 + 2;
      v15 = CFStringCreateWithBytes(0, v13, v14, 0x14000100u, 0);
      a4 = &v13[v14];
      v12 += v14 + 2;
      CFArrayAppendValue(Mutable, v15);
      CFRelease(v15);
    }
    while (v12 < a5);
  }
  CFArrayAppendValue(a1, Mutable);
  CFRelease(Mutable);
}

__CFString *CopyTransformedTextFromXML(const __CFString *a1, DCSDictionary *a2, unint64_t a3)
{
  DCSEnvironment *v6;
  int v7;
  const __CFData *v8;
  UInt8 *UTF8CString;
  xmlDoc *v11;
  xsltStylesheet *v12;
  char *v13;
  xmlDocPtr v14;
  const char *BytePtr;
  int Length;
  xmlDoc *v17;
  xsltStylesheet *v18;
  const __CFDictionary *Preference;
  DCSEnvironment *v20;
  const __CFString *v21;
  __CFDictionary *MutableCopy;
  __CFString *SanitizedText;
  const __CFDictionary *v24;
  xmlDocPtr v25;
  unint64_t v26;
  const __CFArray *v27;
  xsltStylesheet *v28;
  const __CFString *v29;
  const __CFString *v30;
  const __CFURL *v31;
  const __CFString *v32;
  const __CFString *v33;
  CFStringRef v34;
  const __CFString *v35;
  char *v36;
  const __CFArray *v37;
  const __CFArray *v38;
  const __CFDictionary *ValueAtIndex;
  const __CFString *Value;
  const __CFString *CanonicalLanguageIdentifierFromString;
  const __CFString *v42;
  int isAppearanceAwareDictionary;
  const char *v44;
  const __CFArray *v45;
  CFIndex Count;
  CFIndex v47;
  CFIndex i;
  xmlDocPtr v49;
  xmlDocPtr v50;
  unint64_t v51;
  xsltStylesheet *v52;
  xmlDocPtr v53;
  const __CFString *v54;
  CFIndex v55;
  CFIndex v56;
  CFIndex j;
  CFRange v58;
  const void *v59;
  const __CFString *v60;
  char *v61;
  int size;
  xmlChar *mem;
  char *v64[2];
  __int128 v65;
  const char *v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  v6 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  v7 = DCSEnvironment::parentalControlCensoringContents(v6);
  v8 = (const __CFData *)DCSDictionary::XSLTData(a2);
  if (a3 == 255 && (v7 & 1) == 0)
    return (__CFString *)CFRetain(a1);
  mem = 0;
  size = 0;
  pthread_mutex_lock(&CopyTransformedTextFromXML::gGlobalLock);
  UTF8CString = CreateUTF8CString(a1);
  v11 = xmlParseDoc(UTF8CString);
  free(UTF8CString);
  if (v11)
  {
    v64[0] = "parental-control";
    v12 = (xsltStylesheet *)PredefinedCachedXSLTDoc(0);
    v13 = "''";
    if (v7)
      v13 = "'1'";
    v61 = v13;
    v14 = ApplyXSLT(v11, v12, 0, 1, (const char **)v64, (const char **)&v61);
    if (v8)
    {
      BytePtr = (const char *)CFDataGetBytePtr(v8);
      Length = CFDataGetLength(v8);
      v17 = xmlParseMemory(BytePtr, Length);
      v18 = xsltParseStylesheetDoc(v17);
      Preference = (const __CFDictionary *)DCSDictionaryGetPreference(*(const void **)a2);
      v20 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
      if (((a3 == 1) & DCSEnvironment::orientationVerticalAllowed(v20)) != 0)
        v21 = CFSTR("1");
      else
        v21 = CFSTR("0");
      if (Preference)
        MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Preference);
      else
        MutableCopy = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v24 = MutableCopy;
      CFDictionarySetValue(MutableCopy, CFSTR("DCSAllowOrientationVertical"), v21);
      v25 = ApplyXSLT(v14, v18, v24, 0, 0, 0);
      CFRelease(v24);
      xmlFreeDoc(v14);
      xsltFreeStylesheet(v18);
      v14 = v25;
    }
    if (a3 - 1 > 1)
    {
      v27 = 0;
    }
    else
    {
      *(_OWORD *)v64 = xmmword_1E8B572C8;
      v65 = *(_OWORD *)off_1E8B572D8;
      v66 = "''";
      if (a3 == 2 && BecomeEmptyBySimplification(v14))
        v26 = 1;
      else
        v26 = a3;
      v28 = (xsltStylesheet *)PredefinedCachedXSLTDoc(v26);
      v29 = DCSDictionary::shortName(a2);
      v30 = CFStringCreateWithFormat(0, 0, CFSTR("'%@'"), v29);
      v64[0] = (char *)CreateUTF8CString(v30);
      CFRelease(v30);
      v31 = (const __CFURL *)DCSDictionary::baseURL(a2);
      if (v31)
      {
        v32 = CFURLGetString(v31);
        v33 = CFURLCreateStringByReplacingPercentEscapes(0, v32, &stru_1E8B587B0);
        v34 = CFURLCreateStringByAddingPercentEscapes(0, v33, 0, CFSTR("'"), 0x8000100u);
        CFRelease(v33);
        v35 = CFStringCreateWithFormat(0, 0, CFSTR("'%@'"), v34);
        CFRelease(v34);
        v36 = (char *)CreateUTF8CString(v35);
        CFRelease(v35);
      }
      else
      {
        v36 = (char *)CreateUTF8CString(CFSTR("''"));
      }
      v64[1] = v36;
      if (DCSDictionary::isLocalizableDictionary((CFDictionaryRef *)a2))
      {
        v37 = DCSDictionary::languages((CFDictionaryRef *)a2);
        if (v37)
        {
          v38 = v37;
          if (CFArrayGetCount(v37))
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v38, 0);
            if (ValueAtIndex)
            {
              Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("DCSDictionaryDescriptionLanguage"));
              if (Value)
              {
                CanonicalLanguageIdentifierFromString = CFLocaleCreateCanonicalLanguageIdentifierFromString(0, Value);
                if (CanonicalLanguageIdentifierFromString)
                {
                  v42 = CanonicalLanguageIdentifierFromString;
                  if (CFLocaleGetLanguageCharacterDirection(CanonicalLanguageIdentifierFromString) == kCFLocaleLanguageDirectionRightToLeft)
                    *(_QWORD *)&v65 = "'1'";
                  CFRelease(v42);
                }
              }
            }
          }
        }
      }
      isAppearanceAwareDictionary = DCSDictionary::isAppearanceAwareDictionary(a2);
      v44 = "'apple_appearance-incompliant'";
      if (isAppearanceAwareDictionary)
        v44 = "'apple_appearance-compliant'";
      v66 = v44;
      v45 = (const __CFArray *)DCSDictionary::styleSheetContents(a2);
      v27 = v45;
      if (v45 && (Count = CFArrayGetCount(v45), Count >= 1))
      {
        v47 = Count;
        for (i = 0; i != v47; ++i)
        {
          CFArrayGetValueAtIndex(v27, i);
          *((_QWORD *)&v65 + 1) = "'<!-- embedded_css_placeholder -->'";
          v49 = ApplyXSLT(v14, v28, 0, 5, (const char **)&off_1E8B572A0, (const char **)v64);
          xmlFreeDoc(v14);
          if (!i)
          {
            free(v64[0]);
            v64[0] = "''";
            free(v64[1]);
            v64[1] = "''";
            *(_QWORD *)&v65 = "''";
          }
          v14 = v49;
        }
      }
      else
      {
        v49 = v14;
      }
      v14 = v49;
    }
    xmlDocDumpMemory(v14, &mem, &size);
    xmlFreeDoc(v11);
    xmlFreeDoc(v14);
    if (a3 == 3)
    {
      v50 = xmlParseDoc(mem);
      if (BecomeEmptyBySimplification(v50))
        v51 = 4;
      else
        v51 = 3;
      v52 = (xsltStylesheet *)PredefinedCachedXSLTDoc(v51);
      v53 = xsltApplyStylesheet(v52, v50, 0);
      SanitizedText = (__CFString *)ExtractSanitizedText(v53);
      xmlFreeDoc(v50);
      xmlFreeDoc(v53);
    }
    else
    {
      v54 = CFStringCreateWithBytes(0, mem, size, 0x8000100u, 0);
      SanitizedText = CFStringCreateMutableCopy(0, 0, v54);
      CFRelease(v54);
      if (v27)
      {
        v55 = CFArrayGetCount(v27);
        if (v55 >= 1)
        {
          v56 = v55;
          for (j = 0; j != v56; ++j)
          {
            v58 = CFStringFind(SanitizedText, CFSTR("<!-- embedded_css_placeholder -->"), 0);
            if (!v58.length)
              break;
            v59 = CFArrayGetValueAtIndex(v27, j);
            v60 = CFStringCreateWithFormat(0, 0, CFSTR("/*<![CDATA[*/ %@ /*]]>*/"), v59);
            CFStringReplace(SanitizedText, v58, v60);
            CFRelease(v60);
          }
        }
      }
    }
    ((void (*)(xmlChar *))*MEMORY[0x1E0DE8D30])(mem);
  }
  else
  {
    SanitizedText = 0;
  }
  pthread_mutex_unlock(&CopyTransformedTextFromXML::gGlobalLock);
  return SanitizedText;
}

UInt8 *CreateUTF8CString(const __CFString *a1)
{
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  UInt8 *v4;
  CFIndex usedBufLen;
  CFRange v7;

  Length = CFStringGetLength(a1);
  usedBufLen = 0;
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  v4 = (UInt8 *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0x43FEC6C4uLL);
  v7.location = 0;
  v7.length = Length;
  CFStringGetBytes(a1, v7, 0x8000100u, 0, 0, v4, MaximumSizeForEncoding, &usedBufLen);
  v4[usedBufLen] = 0;
  return v4;
}

uint64_t PredefinedCachedXSLTDoc(unint64_t a1)
{
  const __CFData *v1;
  const __CFData *v2;
  const __CFString *v5;
  DCSEnvironment *v6;
  __CFBundle *FrameworkBundle;
  const __CFURL *v8;
  const char *BytePtr;
  int Length;
  xmlDoc *v11;
  CFDataRef resourceData[7];

  if (a1 > 4)
    return 0;
  resourceData[5] = v1;
  resourceData[6] = v2;
  if (!PredefinedCachedXSLTDoc(long)::_XSLTDoc[a1])
  {
    v5 = CFStringCreateWithCString(0, PredefinedCachedXSLTDoc(long)::_FileNames[a1], 0);
    v6 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
    FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(v6);
    v8 = CFBundleCopyResourceURL(FrameworkBundle, v5, 0, 0);
    CFRelease(v5);
    if (v8)
    {
      resourceData[0] = 0;
      CFURLCreateDataAndPropertiesFromResource(0, v8, resourceData, 0, 0, 0);
      CFRelease(v8);
      if (resourceData[0])
      {
        BytePtr = (const char *)CFDataGetBytePtr(resourceData[0]);
        Length = CFDataGetLength(resourceData[0]);
        v11 = xmlParseMemory(BytePtr, Length);
        PredefinedCachedXSLTDoc(long)::_XSLTDoc[a1] = xsltParseStylesheetDoc(v11);
        CFRelease(resourceData[0]);
      }
    }
  }
  return PredefinedCachedXSLTDoc(long)::_XSLTDoc[a1];
}

xmlDocPtr ApplyXSLT(xmlDocPtr doc, xsltStylesheetPtr style, CFDictionaryRef theDict, uint64_t a4, const char **a5, const char **a6)
{
  CFIndex Count;
  const char **v13;
  const char **v14;
  unint64_t v15;
  const __CFString **v16;
  size_t v17;
  uint64_t v18;
  const __CFString **v19;
  UInt8 **v20;
  CFIndex v21;
  const __CFString *v22;
  const __CFString *v23;
  _QWORD *v24;
  CFIndex v25;
  uint64_t v26;
  uint64_t v27;
  xmlDocPtr v28;
  uint64_t v29;
  void **v30;
  void *v31;
  _QWORD v32[2];

  Count = a4;
  v32[1] = *MEMORY[0x1E0C80C00];
  if (!theDict && a4 < 1)
    return xsltApplyStylesheet(style, doc, 0);
  if (theDict)
    Count = CFDictionaryGetCount(theDict);
  v13 = (const char **)malloc_type_malloc((16 * Count) | 8, 0x10040436913F5uLL);
  v14 = v13;
  if (theDict)
  {
    v32[0] = v32;
    MEMORY[0x1E0C80A78](v13);
    v15 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
    v16 = (const __CFString **)((char *)v32 - v15);
    if ((unint64_t)(8 * Count) >= 0x200)
      v17 = 512;
    else
      v17 = 8 * Count;
    bzero((char *)v32 - v15, v17);
    MEMORY[0x1E0C80A78](v18);
    v19 = (const __CFString **)((char *)v32 - v15);
    bzero((char *)v32 - v15, v17);
    CFDictionaryGetKeysAndValues(theDict, (const void **)((char *)v32 - v15), (const void **)((char *)v32 - v15));
    if (Count >= 1)
    {
      v20 = (UInt8 **)(v14 + 1);
      v21 = Count;
      do
      {
        v22 = *v16++;
        *(v20 - 1) = CreateUTF8CString(v22);
        v23 = *v19++;
        *v20 = CreateUTF8CString(v23);
        v20 += 2;
        --v21;
      }
      while (v21);
    }
    goto LABEL_17;
  }
  if (Count >= 1)
  {
    v24 = v13 + 1;
    v25 = Count;
    do
    {
      v26 = (uint64_t)*a5++;
      *(v24 - 1) = v26;
      v27 = (uint64_t)*a6++;
      *v24 = v27;
      v24 += 2;
      --v25;
    }
    while (v25);
LABEL_17:
    v14[2 * Count] = 0;
    v28 = xsltApplyStylesheet(style, doc, v14);
    if (theDict && Count >= 1)
    {
      if (2 * Count <= 1)
        v29 = 1;
      else
        v29 = 2 * Count;
      v30 = (void **)v14;
      do
      {
        v31 = *v30++;
        free(v31);
        --v29;
      }
      while (v29);
    }
    goto LABEL_26;
  }
  v13[2 * Count] = 0;
  v28 = xsltApplyStylesheet(style, doc, v13);
LABEL_26:
  free(v14);
  return v28;
}

BOOL BecomeEmptyBySimplification(_xmlDoc *a1)
{
  xsltStylesheet *v2;
  const xmlDoc *v3;
  xmlDoc *v4;
  xmlNodePtr RootElement;
  const xmlNode *children;
  xmlChar *Content;
  int64_t v8;
  const __CFString *v9;
  CFMutableStringRef MutableCopy;
  _BOOL8 v11;

  v2 = (xsltStylesheet *)PredefinedCachedXSLTDoc(3uLL);
  v3 = xsltApplyStylesheet(v2, a1, 0);
  if (!v3)
    return 1;
  v4 = (xmlDoc *)v3;
  RootElement = xmlDocGetRootElement(v3);
  if (RootElement && (children = RootElement->children) != 0)
  {
    Content = xmlNodeGetContent(children);
    v8 = strlen((const char *)Content);
    if (v8 < 1)
    {
      v11 = 1;
    }
    else
    {
      v9 = CFStringCreateWithBytes(0, Content, v8, 0x8000100u, 0);
      MutableCopy = CFStringCreateMutableCopy(0, 0, v9);
      CFRelease(v9);
      CFStringTrimWhitespace(MutableCopy);
      v11 = CFStringGetLength(MutableCopy) == 0;
      CFRelease(MutableCopy);
    }
    ((void (*)(xmlChar *))*MEMORY[0x1E0DE8D30])(Content);
  }
  else
  {
    v11 = 1;
  }
  xmlFreeDoc(v4);
  return v11;
}

_xmlNode *ExtractSanitizedText(_xmlDoc *a1)
{
  _xmlNode *result;
  xmlChar *Content;
  int v3;
  UInt8 *v4;
  int v5;
  int v6;
  int v7;
  BOOL v8;
  xmlChar *v9;
  unsigned int v10;
  int v11;
  CFStringRef v13;

  result = xmlDocGetRootElement(a1)->children;
  if (result)
  {
    Content = xmlNodeGetContent(result);
    v3 = strlen((const char *)Content);
    v4 = (UInt8 *)malloc_type_malloc(v3, 0x75E9D989uLL);
    if (v3 < 1)
    {
      v6 = 0;
    }
    else
    {
      v5 = 0;
      v6 = 0;
      v7 = 1;
      v8 = 1;
      do
      {
        v9 = &Content[v5];
        v10 = *v9;
        v11 = v9[1];
        if (v3 - v5 >= 5 && v10 == 35 && v11 == 66 && Content[v5 + 2] == 82 && Content[v5 + 3] == 35)
        {
          if (v7)
            v7 = 0;
          else
            v4[v6++] = 10;
          v8 = 1;
          v5 += 3;
        }
        else if (v8)
        {
          if (v10 > 0x20 || ((1 << v10) & 0x100000600) == 0)
          {
            v8 = 0;
            v4[v6++] = v10;
          }
          else
          {
            v8 = 1;
          }
        }
        else if (v10 == 9 || v10 == 32 && v11 == 32)
        {
          v8 = 0;
        }
        else
        {
          v4[v6++] = v10;
          v8 = v10 == 10;
        }
        ++v5;
      }
      while (v5 < v3);
    }
    v13 = CFStringCreateWithBytes(0, v4, v6, 0x8000100u, 0);
    ((void (*)(xmlChar *))*MEMORY[0x1E0DE8D30])(Content);
    free(v4);
    return (_xmlNode *)v13;
  }
  return result;
}

xmlDoc *CopySimplifiedTextFromWikipediaResult(const __CFString *a1)
{
  UInt8 *UTF8CString;
  xmlDoc *SanitizedText;
  xmlDocPtr v4;

  pthread_mutex_lock(&CopySimplifiedTextFromWikipediaResult::gGlobalLock);
  UTF8CString = CreateUTF8CString(a1);
  SanitizedText = xmlParseDoc(UTF8CString);
  free(UTF8CString);
  if (SanitizedText)
  {
    v4 = xsltApplyStylesheet(0, SanitizedText, 0);
    xmlFreeDoc(SanitizedText);
    if (v4)
    {
      SanitizedText = (xmlDoc *)ExtractSanitizedText(v4);
      xmlFreeDoc(v4);
    }
    else
    {
      SanitizedText = 0;
    }
  }
  pthread_mutex_unlock(&CopySimplifiedTextFromWikipediaResult::gGlobalLock);
  return SanitizedText;
}

CFMutableDictionaryRef CopyXPathElementsArray(const __CFString *a1, const __CFDictionary *a2, const __CFDictionary *a3)
{
  UInt8 *UTF8CString;
  UInt8 *v7;
  xmlDoc *v8;
  xmlXPathContext *v9;
  CFIndex Count;
  unint64_t v11;
  const void **v12;
  size_t v13;
  CFIndex v14;
  CFIndex v15;
  const __CFDictionary *v16;
  unint64_t v17;
  const void **v18;
  size_t v19;
  const __CFString *v20;
  const __CFString *Value;
  const __CFString *v22;
  UInt8 *v23;
  UInt8 *v24;
  UInt8 *v25;
  BOOL v26;
  CFIndex v27;
  const __CFString *v28;
  CFComparisonResult v29;
  const __CFString *v30;
  UInt8 *v31;
  UInt8 *v32;
  xmlXPathObject *v33;
  int *p_nodeNr;
  uint64_t v35;
  uint64_t v37;
  __CFArray *v38;
  uint64_t v39;
  int v40;
  CFMutableStringRef v41;
  xmlChar *Content;
  const UInt8 *v43;
  size_t v44;
  __CFDictionary *v45;
  const void *ValueAtIndex;
  __CFDictionary *v47;
  const __CFString *v48;
  CFMutableDictionaryRef v49;
  uint64_t v51;
  CFStringRef v52;
  const __CFDictionary *v53;
  xmlDocPtr v54;
  int v55;
  CFMutableDictionaryRef Mutable;
  const void *v57;
  const __CFString *v58;
  const __CFString *v59;
  xmlXPathContext *v60;
  const void **v61;
  CFIndex v62;
  CFStringRef v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  pthread_mutex_lock(&CopyXPathElementsArray::gGlobalLock);
  if (a1
    && (UTF8CString = CreateUTF8CString(a1)) != 0
    && (v7 = UTF8CString, v8 = xmlParseDoc(UTF8CString), free(v7), v8))
  {
    v54 = v8;
    v9 = xmlXPathNewContext(v8);
    v55 = 0;
  }
  else
  {
    v54 = 0;
    v9 = 0;
    v55 = 1;
  }
  Count = CFDictionaryGetCount(a2);
  MEMORY[0x1E0C80A78](Count);
  v12 = (const void **)((char *)&v51 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v11 >= 0x200)
    v13 = 512;
  else
    v13 = v11;
  bzero((char *)&v51 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), v13);
  CFDictionaryGetKeysAndValues(a2, v12, 0);
  v61 = v12;
  v62 = Count;
  if (a3)
  {
    if (v9)
    {
      v14 = CFDictionaryGetCount(a3);
      if (v14 >= 1)
      {
        v15 = v14;
        v16 = a2;
        MEMORY[0x1E0C80A78](v14);
        v18 = (const void **)((char *)&v51 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0));
        if (v17 >= 0x200)
          v19 = 512;
        else
          v19 = v17;
        bzero((char *)&v51 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0), v19);
        CFDictionaryGetKeysAndValues(a3, v18, 0);
        while (1)
        {
          v20 = (const __CFString *)*v18;
          Value = (const __CFString *)CFDictionaryGetValue(a3, *v18);
          if (Value)
          {
            v22 = Value;
            v23 = CreateUTF8CString(v20);
            v24 = CreateUTF8CString(v22);
            v25 = v24;
            if (v23)
              v26 = v24 == 0;
            else
              v26 = 1;
            if (!v26)
            {
              xmlXPathRegisterNs(v9, v23, v24);
LABEL_27:
              free(v23);
              if (!v25)
                goto LABEL_25;
LABEL_24:
              free(v25);
              goto LABEL_25;
            }
            if (v23)
              goto LABEL_27;
            if (v24)
              goto LABEL_24;
          }
LABEL_25:
          ++v18;
          if (!--v15)
          {
            a2 = v16;
            v12 = v61;
            Count = v62;
            break;
          }
        }
      }
    }
  }
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v9 || Count < 1)
    goto LABEL_66;
  v27 = 0;
  v63 = CFSTR("DCSTextElementKeySensesWithAttributes");
  v58 = CFSTR("DCSTextElementSenseKeyIsExplicit");
  v59 = CFSTR("DCSTextElementSenseKeyText");
  v57 = (const void *)*MEMORY[0x1E0C9AE40];
  v52 = CFSTR("DCSTextElementKeySenses");
  v53 = a2;
  v60 = v9;
  do
  {
    v28 = (const __CFString *)v12[v27];
    v29 = CFStringCompare(v28, v63, 0);
    v30 = (const __CFString *)CFDictionaryGetValue(a2, v28);
    v31 = CreateUTF8CString(v30);
    if (!v31)
      goto LABEL_65;
    v32 = v31;
    v33 = (xmlXPathObject *)MEMORY[0x1D17BCDB4](v31, v9);
    free(v32);
    if (!v33)
      goto LABEL_65;
    p_nodeNr = &v33->nodesetval->nodeNr;
    if (!p_nodeNr)
      goto LABEL_64;
    v35 = *p_nodeNr;
    if (!(_DWORD)v35)
      goto LABEL_64;
    if (!*((_QWORD *)p_nodeNr + 1) || (int)v35 < 1)
      goto LABEL_64;
    v37 = 0;
    v38 = 0;
    do
    {
      v39 = *(_QWORD *)(*((_QWORD *)p_nodeNr + 1) + 8 * v37);
      v40 = *(_DWORD *)(v39 + 8);
      if (v40 == 2)
      {
        Content = xmlNodeGetContent(*(const xmlNode **)(*((_QWORD *)p_nodeNr + 1) + 8 * v37));
        if (Content)
        {
          v43 = Content;
          v44 = strlen((const char *)Content);
          v41 = v44 ? (CFMutableStringRef)CFStringCreateWithBytes(0, v43, v44, 0x8000100u, 0) : 0;
          ((void (*)(const UInt8 *))*MEMORY[0x1E0DE8D30])(v43);
          if (v41)
          {
LABEL_50:
            if (v38)
            {
              if (v29)
                goto LABEL_52;
LABEL_54:
              v45 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              CFDictionarySetValue(v45, v59, v41);
              CFDictionarySetValue(v45, v58, v57);
              CFArrayAppendValue(v38, v45);
              CFRelease(v45);
            }
            else
            {
              v38 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
              if (v29 == kCFCompareEqualTo)
                goto LABEL_54;
LABEL_52:
              CFArrayAppendValue(v38, v41);
            }
            CFRelease(v41);
          }
        }
      }
      else if (v40 == 1)
      {
        v41 = CFStringCreateMutable(0, 0);
        _TraverseAndCollectStringInNode(*(_QWORD *)(v39 + 24), v41);
        CFStringTrimWhitespace(v41);
        if (v41)
          goto LABEL_50;
      }
      ++v37;
    }
    while (v35 != v37);
    a2 = v53;
    if (v38)
    {
      if (CFStringCompare(v28, v52, 0) && v29 && CFStringHasPrefix(v28, CFSTR("DCSTextElementKey")))
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v38, 0);
        v47 = Mutable;
        v48 = v28;
      }
      else
      {
        v47 = Mutable;
        v48 = v28;
        ValueAtIndex = v38;
      }
      CFDictionarySetValue(v47, v48, ValueAtIndex);
      CFRelease(v38);
    }
LABEL_64:
    xmlXPathFreeObject(v33);
    v9 = v60;
    v12 = v61;
    Count = v62;
LABEL_65:
    ++v27;
  }
  while (v27 < Count);
LABEL_66:
  if ((v55 & 1) == 0)
    xmlFreeDoc(v54);
  v49 = Mutable;
  if (v9)
    xmlXPathFreeContext(v9);
  if (!CFDictionaryGetCount(v49))
  {
    CFRelease(v49);
    v49 = 0;
  }
  pthread_mutex_unlock(&CopyXPathElementsArray::gGlobalLock);
  return v49;
}

uint64_t _TraverseAndCollectStringInNode(uint64_t result, __CFString *a2)
{
  uint64_t v3;
  void (**v4)(const UInt8 *);
  xmlChar *Content;
  const UInt8 *v6;
  size_t v7;
  const __CFString *v8;

  if (result)
  {
    v3 = result;
    v4 = (void (**)(const UInt8 *))MEMORY[0x1E0DE8D30];
    do
    {
      if (*(_DWORD *)(v3 + 8) == 3)
      {
        Content = xmlNodeGetContent((const xmlNode *)v3);
        if (Content)
        {
          v6 = Content;
          v7 = strlen((const char *)Content);
          if (v7)
          {
            v8 = CFStringCreateWithBytes(0, v6, v7, 0x8000100u, 0);
            (*v4)(v6);
            if (v8)
            {
              CFStringAppend(a2, v8);
              CFRelease(v8);
            }
          }
          else
          {
            (*v4)(v6);
          }
        }
      }
      result = _TraverseAndCollectStringInNode(*(_xmlNode **)(v3 + 24), a2);
      v3 = *(_QWORD *)(v3 + 48);
    }
    while (v3);
  }
  return result;
}

uint64_t IDXAccessContext::IDXAccessContext(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = off_1E8B57328;
  *(_QWORD *)(result + 8) = a2;
  *(_BYTE *)(result + 16) = 0;
  return result;
}

void IDXAccessContext::~IDXAccessContext(IDXAccessContext *this)
{
  uint64_t v1;

  *(_QWORD *)this = off_1E8B57328;
  if (*((_BYTE *)this + 16))
  {
    v1 = *((_QWORD *)this + 1);
    if (v1)
    {
      IDXIndexInfo::~IDXIndexInfo(*((IDXIndexInfo **)this + 1));
      MEMORY[0x1D17BC79C](v1, 0x1070C4063F6B07ELL);
    }
  }
}

void sub_1CDF7C528(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

uint64_t IDXAccessContext::initialize(IDXAccessContext *this)
{
  uint64_t v2;
  IDXIndexInfo *v3;
  pthread_mutex_t *v4;
  void *v6;
  uint64_t v7;

  pthread_mutex_lock((pthread_mutex_t *)(*((_QWORD *)this + 1) + 232));
  v7 = 0;
  v6 = (void *)IDXIndexInfo::accessContextData(*((IDXIndexInfo **)this + 1), &v7);
  v2 = (*(uint64_t (**)(IDXAccessContext *, BOOL, void **))(*(_QWORD *)this + 96))(this, v7 == 0, &v6);
  v3 = (IDXIndexInfo *)*((_QWORD *)this + 1);
  if ((v2 & 1) != 0)
  {
    IDXIndexInfo::opened(v3, v6);
    v4 = (pthread_mutex_t *)(*((_QWORD *)this + 1) + 232);
  }
  else
  {
    v4 = (pthread_mutex_t *)((char *)v3 + 232);
  }
  pthread_mutex_unlock(v4);
  return v2;
}

uint64_t IDXAccessContext::finalize(IDXAccessContext *this)
{
  _BOOL8 v2;

  pthread_mutex_lock((pthread_mutex_t *)(*((_QWORD *)this + 1) + 232));
  v2 = IDXIndexInfo::closed(*((IDXIndexInfo **)this + 1)) == 0;
  (*(void (**)(IDXAccessContext *, _BOOL8))(*(_QWORD *)this + 104))(this, v2);
  return pthread_mutex_unlock((pthread_mutex_t *)(*((_QWORD *)this + 1) + 232));
}

uint64_t openRawIndexFile(const char *a1, int a2, int a3)
{
  int v3;

  if (a2)
    v3 = 2;
  else
    v3 = 0;
  if (a3)
    return open(a1, v3 | 0xA00, 438);
  else
    return open(a1, v3);
}

uint64_t mapIndexFile(int a1, int a2, off_t *a3)
{
  int v5;
  int st_size;
  stat v8;

  if (a2)
    v5 = 3;
  else
    v5 = 1;
  if (fstat(a1, &v8) == -1)
    return -1;
  st_size = v8.st_size;
  if (a3)
    *a3 = v8.st_size;
  return (uint64_t)mmap(0, st_size, v5, 1, a1, 0);
}

uint64_t unmapIndexFile(void *a1, size_t a2)
{
  msync(a1, a2, 16);
  return munmap(a1, a2);
}

uint64_t flushIndexFile(void *a1, size_t a2)
{
  return msync(a1, a2, 16);
}

uint64_t IDXAccessContext::getDataPtrByID(IDXAccessContext *this, unint64_t a2, uint64_t *a3)
{
  return 0;
}

uint64_t IDXAccessContext::getDataByID(IDXAccessContext *this, unint64_t a2, uint64_t a3, unsigned __int8 *a4)
{
  return 0;
}

uint64_t IDXAccessContext::addRecord(IDXAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4, uint64_t a5, unint64_t *a6)
{
  return 0;
}

uint64_t IDXAccessContext::deleteRecord(IDXAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4)
{
  return 0;
}

uint64_t IDXAccessContext::buildWithRecords(IDXAccessContext *this, void *a2, const __CFArray *a3, const __CFArray *a4, unint64_t *a5)
{
  return 0;
}

uint64_t IDXAccessContext::initializeSubclass(IDXAccessContext *this, BOOL a2, void **a3)
{
  return 1;
}

void IDXAccessMethodManager::IDXAccessMethodManager(IDXAccessMethodManager *this)
{
  *(_QWORD *)this = 1;
  *((_QWORD *)this + 1) = 1;
  *((_QWORD *)this + 2) = 1;
  *((_QWORD *)this + 3) = 1;
}

void IDXAccessMethodManager::~IDXAccessMethodManager(IDXAccessMethodManager *this)
{
  uint64_t i;
  const void *v3;

  for (i = 0; i != 32; i += 8)
  {
    v3 = *(const void **)((char *)this + i);
    if ((unint64_t)v3 >= 2)
      CFRelease(v3);
  }
}

_QWORD *IDXAccessMethodManager::accessMethod(IDXAccessMethodManager *this, const __CFString *a2, IDXDictionaryPackage *a3)
{
  _QWORD *Value;
  pthread_rwlock_t *v6;
  const __CFArray *v7;
  IDXDictionaryPackage *v8;

  if (!a2)
    return 0;
  if ((_initedRegisteredAccessMethods & 1) == 0)
    pthread_once(&IDXAccessMethodManager::assureSharedRegistrationList(void)::once_control, (void (*)(void))_InitializeRegisteredAcccessMethods);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(_registeredAccessMethods + 16));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(_registeredAccessMethods + 8), a2);
  pthread_rwlock_unlock((pthread_rwlock_t *)(_registeredAccessMethods + 16));
  if (!Value)
  {
    v6 = (pthread_rwlock_t *)(_registeredAccessMethods + 16);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(_registeredAccessMethods + 16));
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(_registeredAccessMethods + 8), a2);
    if (!Value)
    {
      v7 = (const __CFArray *)IDXAccessMethodManager::activateBuiltInAccessMethod(0, a2);
      Value = v7;
      if (v7 || (v7 = IDXAccessMethodManager::searchPlugInAccessMethod(this, a2, v8), (Value = v7) != 0))
        IDXAccessMethodManager::registerAccessMethod((uint64_t)v7, Value);
    }
    pthread_rwlock_unlock(v6);
  }
  return Value;
}

void sub_1CDF7C89C(_Unwind_Exception *a1)
{
  pthread_rwlock_t *v1;

  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IDXAccessMethodManager::assureSharedRegistrationList(IDXAccessMethodManager *this)
{
  uint64_t result;

  if ((_initedRegisteredAccessMethods & 1) == 0)
    return pthread_once(&IDXAccessMethodManager::assureSharedRegistrationList(void)::once_control, (void (*)(void))_InitializeRegisteredAcccessMethods);
  return result;
}

uint64_t IDXAccessMethodManager::activateBuiltInAccessMethod(IDXAccessMethodManager *this, CFStringRef theString1)
{
  uint64_t v3;

  if (!theString1)
    return 0;
  if (CFStringCompare(theString1, CFSTR("com.apple.TrieAccessMethod"), 0))
  {
    if (CFStringCompare(theString1, CFSTR("com.apple.HeapAccessMethod"), 0))
    {
      v3 = 0;
      if (CFStringCompare(theString1, CFSTR("com.apple.TestAccessMethod-Inspector"), 0) == kCFCompareEqualTo)
      {
        v3 = operator new();
        IDXBuiltInAccessMethod<InspectorAccessContext>::IDXBuiltInAccessMethod(v3, theString1);
      }
    }
    else
    {
      v3 = operator new();
      IDXBuiltInAccessMethod<HeapAccessContext>::IDXBuiltInAccessMethod(v3, theString1);
    }
  }
  else
  {
    v3 = operator new();
    IDXBuiltInAccessMethod<TrieAccessContext>::IDXBuiltInAccessMethod(v3, theString1);
  }
  return v3;
}

void sub_1CDF7C9C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10E1C404BFD5011);
  _Unwind_Resume(a1);
}

const __CFArray *IDXAccessMethodManager::searchPlugInAccessMethod(IDXAccessMethodManager *this, const __CFString *a2, IDXDictionaryPackage *a3)
{
  const __CFArray *v4;
  const __CFURL *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  __CFBundle *ValueAtIndex;
  const __CFDictionary *InfoDictionary;
  const __CFDictionary *Value;
  const __CFString *v13;
  const __CFUUID *v14;
  const __CFURL *v15;

  v4 = (const __CFArray *)*((_QWORD *)this + 2);
  if (v4 == (const __CFArray *)1)
  {
    v6 = CFURLCreateWithFileSystemPath(0, CFSTR("/System/Library/Dictionaries/"), kCFURLPOSIXPathStyle, 1u);
    *((_QWORD *)this + 2) = CFBundleCreateBundlesFromDirectory(0, v6, CFSTR("dictionaryPlugin"));
    CFRelease(v6);
    v4 = (const __CFArray *)*((_QWORD *)this + 2);
    if (!v4)
      return v4;
  }
  else if (!v4)
  {
    return v4;
  }
  Count = CFArrayGetCount(v4);
  if (Count < 1)
    return 0;
  v8 = Count;
  v9 = 0;
  while (1)
  {
    ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v4, v9);
    InfoDictionary = CFBundleGetInfoDictionary(ValueAtIndex);
    Value = (const __CFDictionary *)CFDictionaryGetValue(InfoDictionary, CFSTR("IDXAccessMethodIDs"));
    if (Value)
    {
      v13 = (const __CFString *)CFDictionaryGetValue(Value, a2);
      if (v13)
        break;
    }
    if (v8 == ++v9)
      return 0;
  }
  v14 = CFUUIDCreateFromString(0, v13);
  v15 = CFBundleCopyBundleURL(ValueAtIndex);
  v4 = (const __CFArray *)operator new();
  IDXPlugInAccessMethod::IDXPlugInAccessMethod(v4, v15, v14, a2);
  CFRelease(v15);
  CFRelease(v14);
  return v4;
}

void sub_1CDF7CB34(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10E1C40777B8806);
  _Unwind_Resume(a1);
}

void IDXAccessMethodManager::registerAccessMethod(uint64_t a1, _QWORD *a2)
{
  __CFDictionary *v3;
  const void *v4;

  if ((_initedRegisteredAccessMethods & 1) == 0)
    pthread_once(&IDXAccessMethodManager::assureSharedRegistrationList(void)::once_control, (void (*)(void))_InitializeRegisteredAcccessMethods);
  if (a2)
  {
    v3 = *(__CFDictionary **)(_registeredAccessMethods + 8);
    v4 = (const void *)a2[1];
    if (!CFDictionaryContainsKey(v3, v4))
      CFDictionarySetValue(v3, v4, a2);
  }
}

uint64_t _InitializeRegisteredAcccessMethods(void)
{
  uint64_t v0;
  CFMutableDictionaryRef Mutable;
  uint64_t result;

  v0 = operator new();
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], 0);
  *(_QWORD *)v0 = &unk_1E8B56538;
  *(_QWORD *)(v0 + 8) = Mutable;
  result = pthread_rwlock_init((pthread_rwlock_t *)(v0 + 16), 0);
  *(_QWORD *)v0 = &unk_1E8B564E8;
  _registeredAccessMethods = v0;
  _initedRegisteredAccessMethods = 1;
  return result;
}

void sub_1CDF7CC68(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::IDXBuiltInAccessMethod(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  *(_QWORD *)a1 = &unk_1E8B57488;
  v3 = CFRetain(cf);
  *(_QWORD *)a1 = &unk_1E8B573B8;
  *(_QWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 168) = 1;
  IDXBuiltInAccessMethod_SetBridgeFunctionPtrs((_QWORD *)(a1 + 32));
  *(_QWORD *)(a1 + 16) = a1 + 32;
  *(_QWORD *)(a1 + 24) = a1;
  return a1;
}

void sub_1CDF7CCF4(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  const void *v4;

  *v1 = v2;
  v4 = (const void *)v1[1];
  if (v4)
    CFRelease(v4);
  _Unwind_Resume(exception_object);
}

_QWORD *IDXBuiltInAccessMethod<TrieAccessContext>::~IDXBuiltInAccessMethod(_QWORD *a1)
{
  const void *v2;

  *a1 = &unk_1E8B57488;
  v2 = (const void *)a1[1];
  if (v2)
    CFRelease(v2);
  return a1;
}

void IDXBuiltInAccessMethod<TrieAccessContext>::~IDXBuiltInAccessMethod(_QWORD *a1)
{
  const void *v1;

  *a1 = &unk_1E8B57488;
  v1 = (const void *)a1[1];
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x1D17BC79CLL);
}

void sub_1CDF7CD9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10E1C404BFD5011);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::queryInterface(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  *a4 = a1 + 16;
  return 1;
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::retain(uint64_t a1)
{
  uint64_t v1;

  v1 = (*(_DWORD *)(a1 + 168) + 1);
  *(_DWORD *)(a1 + 168) = v1;
  return v1;
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::release(uint64_t a1)
{
  uint64_t v1;

  v1 = (*(_DWORD *)(a1 + 168) - 1);
  *(_DWORD *)(a1 + 168) = v1;
  return v1;
}

TrieAccessContext *IDXBuiltInAccessMethod<TrieAccessContext>::openIndexFile(uint64_t a1, const __CFURL *a2, const __CFDictionary *a3)
{
  IDXIndexInfo *v5;
  TrieAccessContext *v6;

  v5 = (IDXIndexInfo *)operator new();
  IDXIndexInfo::IDXIndexInfo(v5, a2, a3, 0);
  v6 = (TrieAccessContext *)operator new();
  TrieAccessContext::TrieAccessContext(v6, v5);
  if ((IDXAccessContext::initialize(v6) & 1) != 0)
  {
    *((_BYTE *)v6 + 16) = 1;
  }
  else
  {
    (*(void (**)(TrieAccessContext *))(*(_QWORD *)v6 + 8))(v6);
    return 0;
  }
  return v6;
}

void sub_1CDF7CEA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F1C4043258D86);
  _Unwind_Resume(a1);
}

TrieAccessContext *IDXBuiltInAccessMethod<TrieAccessContext>::openIndexFile(uint64_t a1, IDXIndexInfo *a2)
{
  TrieAccessContext *v3;

  v3 = (TrieAccessContext *)operator new();
  TrieAccessContext::TrieAccessContext(v3, a2);
  if ((IDXAccessContext::initialize(v3) & 1) != 0)
  {
    *((_BYTE *)v3 + 16) = 0;
  }
  else
  {
    (*(void (**)(TrieAccessContext *))(*(_QWORD *)v3 + 8))(v3);
    return 0;
  }
  return v3;
}

void sub_1CDF7CF4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F1C4043258D86);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::closeIndexFile(int a1, IDXAccessContext *this)
{
  uint64_t result;

  result = IDXAccessContext::finalize(this);
  if (this)
    return (*(uint64_t (**)(IDXAccessContext *))(*(_QWORD *)this + 8))(this);
  return result;
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::setSearchCharacters(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::getMatchDataPtr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 24))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::getMatchData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::containsMatchData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, a3);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::getDataPtrByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 48))(a2, a3, a4);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::getDataByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 56))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::supportDataPtr(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 64))(a2);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::addRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 72))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::deleteRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 80))(a2, a3, a4, a5, a6, a7);
}

HeapAccessContext *IDXBuiltInAccessMethod<TrieAccessContext>::buildWithRecords(uint64_t a1, TrieAccessContext *a2, const __CFArray *a3, const __CFArray *a4, unint64_t *a5)
{
  return TrieAccessContext::buildWithRecords(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::createIndexFile(uint64_t a1, const __CFURL *a2, const __CFDictionary *a3)
{
  IDXIndexInfo *v5;
  IDXIndexInfo *v6;
  uint64_t IndexFile;

  v5 = (IDXIndexInfo *)operator new();
  IDXIndexInfo::IDXIndexInfo(v5, a2, a3, 0);
  IndexFile = TrieAccessContext::createIndexFile(v5, v6);
  IDXIndexInfo::~IDXIndexInfo(v5);
  MEMORY[0x1D17BC79C](v5, 0x1070C4063F6B07ELL);
  return IndexFile;
}

void sub_1CDF7D144(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

uint64_t IDXAccessMethod::retain(IDXAccessMethod *this)
{
  return 0;
}

uint64_t IDXAccessMethod::release(IDXAccessMethod *this)
{
  return 0;
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::IDXBuiltInAccessMethod(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  *(_QWORD *)a1 = &unk_1E8B57488;
  v3 = CFRetain(cf);
  *(_QWORD *)a1 = &unk_1E8B57530;
  *(_QWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 168) = 1;
  IDXBuiltInAccessMethod_SetBridgeFunctionPtrs((_QWORD *)(a1 + 32));
  *(_QWORD *)(a1 + 16) = a1 + 32;
  *(_QWORD *)(a1 + 24) = a1;
  return a1;
}

void sub_1CDF7D1E4(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  const void *v4;

  *v1 = v2;
  v4 = (const void *)v1[1];
  if (v4)
    CFRelease(v4);
  _Unwind_Resume(exception_object);
}

_QWORD *IDXBuiltInAccessMethod<HeapAccessContext>::~IDXBuiltInAccessMethod(_QWORD *a1)
{
  const void *v2;

  *a1 = &unk_1E8B57488;
  v2 = (const void *)a1[1];
  if (v2)
    CFRelease(v2);
  return a1;
}

void IDXBuiltInAccessMethod<HeapAccessContext>::~IDXBuiltInAccessMethod(_QWORD *a1)
{
  const void *v1;

  *a1 = &unk_1E8B57488;
  v1 = (const void *)a1[1];
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x1D17BC79CLL);
}

void sub_1CDF7D28C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10E1C404BFD5011);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::queryInterface(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  *a4 = a1 + 16;
  return 1;
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::retain(uint64_t a1)
{
  uint64_t v1;

  v1 = (*(_DWORD *)(a1 + 168) + 1);
  *(_DWORD *)(a1 + 168) = v1;
  return v1;
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::release(uint64_t a1)
{
  uint64_t v1;

  v1 = (*(_DWORD *)(a1 + 168) - 1);
  *(_DWORD *)(a1 + 168) = v1;
  return v1;
}

HeapAccessContext *IDXBuiltInAccessMethod<HeapAccessContext>::openIndexFile(uint64_t a1, const __CFURL *a2, const __CFDictionary *a3)
{
  IDXIndexInfo *v5;
  HeapAccessContext *v6;

  v5 = (IDXIndexInfo *)operator new();
  IDXIndexInfo::IDXIndexInfo(v5, a2, a3, 0);
  v6 = (HeapAccessContext *)operator new();
  HeapAccessContext::HeapAccessContext(v6, v5);
  if ((IDXAccessContext::initialize(v6) & 1) != 0)
  {
    *((_BYTE *)v6 + 16) = 1;
  }
  else
  {
    (*(void (**)(HeapAccessContext *))(*(_QWORD *)v6 + 8))(v6);
    return 0;
  }
  return v6;
}

void sub_1CDF7D390(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F1C409CAD4C71);
  _Unwind_Resume(a1);
}

HeapAccessContext *IDXBuiltInAccessMethod<HeapAccessContext>::openIndexFile(uint64_t a1, IDXIndexInfo *a2)
{
  HeapAccessContext *v3;

  v3 = (HeapAccessContext *)operator new();
  HeapAccessContext::HeapAccessContext(v3, a2);
  if ((IDXAccessContext::initialize(v3) & 1) != 0)
  {
    *((_BYTE *)v3 + 16) = 0;
  }
  else
  {
    (*(void (**)(HeapAccessContext *))(*(_QWORD *)v3 + 8))(v3);
    return 0;
  }
  return v3;
}

void sub_1CDF7D43C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F1C409CAD4C71);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::closeIndexFile(int a1, IDXAccessContext *this)
{
  uint64_t result;

  result = IDXAccessContext::finalize(this);
  if (this)
    return (*(uint64_t (**)(IDXAccessContext *))(*(_QWORD *)this + 8))(this);
  return result;
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::setSearchCharacters(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::getMatchDataPtr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 24))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::getMatchData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::containsMatchData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, a3);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::getDataPtrByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 48))(a2, a3, a4);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::getDataByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 56))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::supportDataPtr(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 64))(a2);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::addRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 72))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::deleteRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 80))(a2, a3, a4, a5, a6, a7);
}

BOOL IDXBuiltInAccessMethod<HeapAccessContext>::buildWithRecords(int a1, HeapAccessContext *this, __CFArray *a3, CFArrayRef theArray, unint64_t *a5)
{
  return HeapAccessContext::buildWithRecords(this, a3, theArray, a5);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::createIndexFile(uint64_t a1, const __CFURL *a2, const __CFDictionary *a3)
{
  IDXIndexInfo *v5;
  IDXIndexInfo *v6;
  uint64_t IndexFile;

  v5 = (IDXIndexInfo *)operator new();
  IDXIndexInfo::IDXIndexInfo(v5, a2, a3, 0);
  IndexFile = HeapAccessContext::createIndexFile(v5, v6);
  IDXIndexInfo::~IDXIndexInfo(v5);
  MEMORY[0x1D17BC79C](v5, 0x1070C4063F6B07ELL);
  return IndexFile;
}

void sub_1CDF7D634(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::IDXBuiltInAccessMethod(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  *(_QWORD *)a1 = &unk_1E8B57488;
  v3 = CFRetain(cf);
  *(_QWORD *)a1 = &unk_1E8B575F0;
  *(_QWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 168) = 1;
  IDXBuiltInAccessMethod_SetBridgeFunctionPtrs((_QWORD *)(a1 + 32));
  *(_QWORD *)(a1 + 16) = a1 + 32;
  *(_QWORD *)(a1 + 24) = a1;
  return a1;
}

void sub_1CDF7D6C4(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  const void *v4;

  *v1 = v2;
  v4 = (const void *)v1[1];
  if (v4)
    CFRelease(v4);
  _Unwind_Resume(exception_object);
}

_QWORD *IDXBuiltInAccessMethod<InspectorAccessContext>::~IDXBuiltInAccessMethod(_QWORD *a1)
{
  const void *v2;

  *a1 = &unk_1E8B57488;
  v2 = (const void *)a1[1];
  if (v2)
    CFRelease(v2);
  return a1;
}

void IDXBuiltInAccessMethod<InspectorAccessContext>::~IDXBuiltInAccessMethod(_QWORD *a1)
{
  const void *v1;

  *a1 = &unk_1E8B57488;
  v1 = (const void *)a1[1];
  if (v1)
    CFRelease(v1);
  JUMPOUT(0x1D17BC79CLL);
}

void sub_1CDF7D76C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10E1C404BFD5011);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::queryInterface(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  *a4 = a1 + 16;
  return 1;
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::retain(uint64_t a1)
{
  uint64_t v1;

  v1 = (*(_DWORD *)(a1 + 168) + 1);
  *(_DWORD *)(a1 + 168) = v1;
  return v1;
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::release(uint64_t a1)
{
  uint64_t v1;

  v1 = (*(_DWORD *)(a1 + 168) - 1);
  *(_DWORD *)(a1 + 168) = v1;
  return v1;
}

InspectorAccessContext *IDXBuiltInAccessMethod<InspectorAccessContext>::openIndexFile(uint64_t a1, const __CFURL *a2, const __CFDictionary *a3)
{
  IDXIndexInfo *v5;
  InspectorAccessContext *v6;

  v5 = (IDXIndexInfo *)operator new();
  IDXIndexInfo::IDXIndexInfo(v5, a2, a3, 0);
  v6 = (InspectorAccessContext *)operator new();
  InspectorAccessContext::InspectorAccessContext(v6, v5);
  if ((IDXAccessContext::initialize(v6) & 1) != 0)
  {
    *((_BYTE *)v6 + 16) = 1;
  }
  else
  {
    (*(void (**)(InspectorAccessContext *))(*(_QWORD *)v6 + 8))(v6);
    return 0;
  }
  return v6;
}

void sub_1CDF7D870(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F1C40F8DAED6BLL);
  _Unwind_Resume(a1);
}

InspectorAccessContext *IDXBuiltInAccessMethod<InspectorAccessContext>::openIndexFile(uint64_t a1, IDXIndexInfo *a2)
{
  InspectorAccessContext *v3;

  v3 = (InspectorAccessContext *)operator new();
  InspectorAccessContext::InspectorAccessContext(v3, a2);
  if ((IDXAccessContext::initialize(v3) & 1) != 0)
  {
    *((_BYTE *)v3 + 16) = 0;
  }
  else
  {
    (*(void (**)(InspectorAccessContext *))(*(_QWORD *)v3 + 8))(v3);
    return 0;
  }
  return v3;
}

void sub_1CDF7D91C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F1C40F8DAED6BLL);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::closeIndexFile(int a1, IDXAccessContext *this)
{
  uint64_t result;

  result = IDXAccessContext::finalize(this);
  if (this)
    return (*(uint64_t (**)(IDXAccessContext *))(*(_QWORD *)this + 8))(this);
  return result;
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::setSearchCharacters(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::getMatchDataPtr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 24))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::getMatchData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::containsMatchData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, a3);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::getDataPtrByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 48))(a2, a3, a4);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::getDataByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 56))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::supportDataPtr(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 64))(a2);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::addRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 72))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::deleteRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 80))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::buildWithRecords(int a1, DCSEnvironment *this)
{
  return DCSEnvironment::readyForFontActivation(this);
}

BOOL IDXBuiltInAccessMethod<InspectorAccessContext>::createIndexFile(uint64_t a1, const __CFURL *a2, const __CFDictionary *a3)
{
  IDXIndexInfo *v5;
  IDXIndexInfo *v6;
  _BOOL8 IndexFile;

  v5 = (IDXIndexInfo *)operator new();
  IDXIndexInfo::IDXIndexInfo(v5, a2, a3, 0);
  IndexFile = InspectorAccessContext::createIndexFile(v5, v6);
  IDXIndexInfo::~IDXIndexInfo(v5);
  MEMORY[0x1D17BC79C](v5, 0x1070C4063F6B07ELL);
  return IndexFile;
}

void sub_1CDF7DB14(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

_QWORD *IDXBuiltInAccessMethod_SetBridgeFunctionPtrs(_QWORD *result)
{
  result[5] = _CloseIndex_AcccessMethodBridge;
  result[6] = _SetSearchCharacters_AcccessMethodBridge;
  result[7] = _GetMatchDataPtr_AcccessMethodBridge;
  result[8] = _GetMatchData_AcccessMethodBridge;
  result[9] = _ContainsMatchData_AcccessMethodBridge;
  result[10] = _GetDataPtrByID_AcccessMethodBridge;
  result[11] = _GetDataByID_AcccessMethodBridge;
  result[12] = _SupportDataPtr_AcccessMethodBridge;
  result[13] = _AddRecord_AcccessMethodBridge;
  result[14] = _DeleteRecord_AcccessMethodBridge;
  result[15] = _BuildWithRecords_AcccessMethodBridge;
  result[16] = _CreateIndexFile_AcccessMethodBridge;
  result[1] = _QueryInterface_AcccessMethodBridge;
  result[2] = _AddRef_AcccessMethodBridge;
  result[3] = _Release_AcccessMethodBridge;
  result[4] = _OpenIndex_AcccessMethodBridge;
  return result;
}

uint64_t _OpenIndex_AcccessMethodBridge(_QWORD **a1, const __CFURL *a2, const __CFDictionary *a3)
{
  return (*(uint64_t (**)(_QWORD *, const __CFURL *, const __CFDictionary *))(*a1[1] + 40))(a1[1], a2, a3);
}

uint64_t _CloseIndex_AcccessMethodBridge(_QWORD **a1, void *a2)
{
  return (*(uint64_t (**)(_QWORD *, void *))(*a1[1] + 56))(a1[1], a2);
}

uint64_t _SetSearchCharacters_AcccessMethodBridge(_QWORD **a1, void *a2, const unsigned __int16 *a3, uint64_t a4, const __CFString *a5)
{
  return (*(uint64_t (**)(_QWORD *, void *, const unsigned __int16 *, uint64_t, const __CFString *))(*a1[1] + 64))(a1[1], a2, a3, a4, a5);
}

uint64_t _GetMatchDataPtr_AcccessMethodBridge(_QWORD **a1, void *a2, uint64_t a3, const unsigned __int8 **a4, uint64_t *a5)
{
  return (*(uint64_t (**)(_QWORD *, void *, uint64_t, const unsigned __int8 **, uint64_t *))(*a1[1] + 72))(a1[1], a2, a3, a4, a5);
}

uint64_t _GetMatchData_AcccessMethodBridge(_QWORD **a1, void *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, CFRange **a6, uint64_t *a7)
{
  return (*(uint64_t (**)(_QWORD *, void *, uint64_t, uint64_t, unsigned __int8 *, CFRange **, uint64_t *))(*a1[1] + 80))(a1[1], a2, a3, a4, a5, a6, a7);
}

uint64_t _ContainsMatchData_AcccessMethodBridge(_QWORD **a1, void *a2, unsigned __int8 *a3)
{
  return (*(uint64_t (**)(_QWORD *, void *, unsigned __int8 *))(*a1[1] + 88))(a1[1], a2, a3);
}

uint64_t _GetDataPtrByID_AcccessMethodBridge(_QWORD **a1, void *a2, uint64_t a3, uint64_t *a4)
{
  return (*(uint64_t (**)(_QWORD *, void *, uint64_t, uint64_t *))(*a1[1] + 96))(a1[1], a2, a3, a4);
}

uint64_t _GetDataByID_AcccessMethodBridge(_QWORD **a1, void *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  return (*(uint64_t (**)(_QWORD *, void *, uint64_t, uint64_t, unsigned __int8 *))(*a1[1] + 104))(a1[1], a2, a3, a4, a5);
}

uint64_t _SupportDataPtr_AcccessMethodBridge(_QWORD **a1, void *a2)
{
  return (*(uint64_t (**)(_QWORD *, void *))(*a1[1] + 112))(a1[1], a2);
}

uint64_t _AddRecord_AcccessMethodBridge(_QWORD **a1, void *a2, const unsigned __int16 *a3, uint64_t a4, const unsigned __int8 *a5, uint64_t a6, unint64_t *a7)
{
  return (*(uint64_t (**)(_QWORD *, void *, const unsigned __int16 *, uint64_t, const unsigned __int8 *, uint64_t, unint64_t *))(*a1[1] + 120))(a1[1], a2, a3, a4, a5, a6, a7);
}

uint64_t _DeleteRecord_AcccessMethodBridge(_QWORD **a1, void *a2, const unsigned __int16 *a3, uint64_t a4, const unsigned __int8 *a5)
{
  return (*(uint64_t (**)(_QWORD *, void *, const unsigned __int16 *, uint64_t, const unsigned __int8 *))(*a1[1] + 128))(a1[1], a2, a3, a4, a5);
}

uint64_t _BuildWithRecords_AcccessMethodBridge(_QWORD **a1, void *a2, const __CFArray *a3, const __CFArray *a4, unint64_t *a5)
{
  return (*(uint64_t (**)(_QWORD *, void *, const __CFArray *, const __CFArray *, unint64_t *))(*a1[1] + 136))(a1[1], a2, a3, a4, a5);
}

uint64_t _CreateIndexFile_AcccessMethodBridge(_QWORD **a1, const __CFURL *a2, const __CFDictionary *a3)
{
  return (*(uint64_t (**)(_QWORD *, const __CFURL *, const __CFDictionary *))(*a1[1] + 144))(a1[1], a2, a3);
}

uint64_t _QueryInterface_AcccessMethodBridge(_QWORD **a1, CFUUIDBytes a2, void **a3)
{
  return (*(uint64_t (**)(_QWORD *, _QWORD, _QWORD, void **))(*a1[1] + 16))(a1[1], *(_QWORD *)&a2.byte0, *(_QWORD *)&a2.byte8, a3);
}

uint64_t _AddRef_AcccessMethodBridge(_QWORD **a1)
{
  return (*(uint64_t (**)(_QWORD *))(*a1[1] + 24))(a1[1]);
}

uint64_t _Release_AcccessMethodBridge(_QWORD **a1)
{
  return (*(uint64_t (**)(_QWORD *))(*a1[1] + 32))(a1[1]);
}

IDXDictionaryPackage *IDXDictionaryManager::dictionary(IDXDictionaryManager *this, CFURLRef relativeURL)
{
  const __CFURL *v3;
  CFStringRef v4;
  IDXDictionaryPackage *Value;
  pthread_rwlock_t *v6;

  if ((_initedCachedDictionaries & 1) == 0)
    pthread_once(&IDXDictionaryManager::dictionary(__CFURL const*)::once_control, (void (*)(void))_InitializeCachedDictionaries);
  v3 = CFURLCopyAbsoluteURL(relativeURL);
  v4 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
  CFRelease(v3);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  Value = (IDXDictionaryPackage *)CFDictionaryGetValue(*(CFDictionaryRef *)(_cachedDictionaries + 8), v4);
  pthread_rwlock_unlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  if (!Value)
  {
    v6 = (pthread_rwlock_t *)(_cachedDictionaries + 16);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
    Value = (IDXDictionaryPackage *)CFDictionaryGetValue(*(CFDictionaryRef *)(_cachedDictionaries + 8), v4);
    if (!Value)
    {
      Value = (IDXDictionaryPackage *)operator new();
      IDXDictionaryPackage::IDXDictionaryPackage(Value, relativeURL);
      if (IDXDictionaryPackage::validDictionary((CFDictionaryRef *)Value))
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(_cachedDictionaries + 8), v4, Value);
      }
      else
      {
        IDXDictionaryPackage::~IDXDictionaryPackage(Value);
        MEMORY[0x1D17BC79C](Value, 0x10E0C4030B049B9);
        Value = 0;
      }
    }
    pthread_rwlock_unlock(v6);
  }
  CFRelease(v4);
  return Value;
}

void sub_1CDF7DEA8(_Unwind_Exception *a1)
{
  pthread_rwlock_t *v1;
  uint64_t v2;

  MEMORY[0x1D17BC79C](v2, 0x10E0C4030B049B9);
  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1CDF7DF70(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

uint64_t IDXDictionaryManager::remove(IDXDictionaryManager *this, CFAbsoluteTime *a2)
{
  pthread_rwlock_t *v3;
  __CFDictionary *v4;
  const __CFURL *v5;
  CFStringRef v6;

  v3 = (pthread_rwlock_t *)(_cachedDictionaries + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  v4 = *(__CFDictionary **)(_cachedDictionaries + 8);
  v5 = (const __CFURL *)IDXDictionaryPackage::URL(a2);
  v6 = CFURLCopyFileSystemPath(v5, kCFURLPOSIXPathStyle);
  CFDictionaryRemoveValue(v4, v6);
  if (a2)
  {
    IDXDictionaryPackage::~IDXDictionaryPackage((IDXDictionaryPackage *)a2);
    MEMORY[0x1D17BC79C](a2, 0x10E0C4030B049B9);
  }
  return pthread_rwlock_unlock(v3);
}

void sub_1CDF7E018(_Unwind_Exception *a1)
{
  pthread_rwlock_t *v1;
  uint64_t v2;

  MEMORY[0x1D17BC79C](v2, 0x10E0C4030B049B9);
  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IDXDictionaryManager::clearInactiveCaches(IDXDictionaryManager *this)
{
  pthread_rwlock_t *v1;
  const __CFDictionary *v2;
  CFIndex Count;
  double Current;
  uint64_t v5;
  unint64_t v6;
  IDXDictionaryPackage **v7;
  size_t v8;
  uint64_t v9;
  const void **v10;
  IDXDictionaryPackage *v11;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v1 = (pthread_rwlock_t *)(_cachedDictionaries + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  v2 = *(const __CFDictionary **)(_cachedDictionaries + 8);
  Count = CFDictionaryGetCount(v2);
  if (Count >= 1)
  {
    Current = CFAbsoluteTimeGetCurrent();
    MEMORY[0x1E0C80A78](v5);
    v6 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
    v7 = (IDXDictionaryPackage **)((char *)v13 - v6);
    if ((unint64_t)(8 * Count) >= 0x200)
      v8 = 512;
    else
      v8 = 8 * Count;
    bzero((char *)v13 - v6, v8);
    MEMORY[0x1E0C80A78](v9);
    v10 = (const void **)((char *)v13 - v6);
    bzero((char *)v13 - v6, v8);
    CFDictionaryGetKeysAndValues(v2, (const void **)((char *)v13 - v6), (const void **)((char *)v13 - v6));
    do
    {
      if (!*((_DWORD *)*v7 + 44) && Current > *((double *)*v7 + 40) + 300.0)
      {
        CFDictionaryRemoveValue(v2, *v10);
        v11 = *v7;
        if (*v7)
        {
          IDXDictionaryPackage::~IDXDictionaryPackage(*v7);
          MEMORY[0x1D17BC79C](v11, 0x10E0C4030B049B9);
        }
      }
      ++v10;
      ++v7;
      --Count;
    }
    while (Count);
  }
  return pthread_rwlock_unlock(v1);
}

void sub_1CDF7E1E4(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

const __CFString *IDXDictionaryManager::templateProperty(IDXDictionaryManager *this, const __CFString *a2)
{
  const __CFString *v2;
  CFTypeID v3;
  const void *Value;
  pthread_rwlock_t *v5;
  CFTypeID v6;
  const __CFURL *v8;
  __CFBundle *BundleWithIdentifier;
  const __CFURL *v10;
  CFDataRef resourceData;

  if (a2)
    v2 = a2;
  else
    v2 = CFSTR("IDXDefaultProperty");
  v3 = CFGetTypeID(v2);
  if (v3 == CFStringGetTypeID())
  {
    if ((_initedCachedProperties & 1) == 0)
      pthread_once(&IDXDictionaryManager::templateProperty(void const*)::once_control, (void (*)(void))_InitializeCachedProperties);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(_cachedProperties + 16));
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(_cachedProperties + 8), v2);
    pthread_rwlock_unlock((pthread_rwlock_t *)(_cachedProperties + 16));
    if (!Value)
    {
      v5 = (pthread_rwlock_t *)(_cachedProperties + 16);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedProperties + 16));
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(_cachedProperties + 8), v2);
      if (!Value)
      {
        if (CFStringGetCharacterAtIndex(v2, 0) == 47)
        {
          v8 = CFURLCreateWithFileSystemPath(0, v2, kCFURLPOSIXPathStyle, 0);
        }
        else
        {
          BundleWithIdentifier = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.DictionaryServices"));
          v8 = CFBundleCopyResourceURL(BundleWithIdentifier, v2, CFSTR("plist"), 0);
        }
        v10 = v8;
        if (!v8)
        {
          Value = 0;
          goto LABEL_10;
        }
        resourceData = 0;
        if (CFURLCreateDataAndPropertiesFromResource(0, v8, &resourceData, 0, 0, 0))
        {
          Value = CFPropertyListCreateFromXMLData(0, resourceData, 0, 0);
          CFRelease(resourceData);
        }
        else
        {
          Value = 0;
        }
        CFRelease(v10);
        if (!Value)
          goto LABEL_10;
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(_cachedProperties + 8), v2, Value);
      CFRelease(Value);
LABEL_10:
      pthread_rwlock_unlock(v5);
    }
  }
  else
  {
    v6 = CFGetTypeID(v2);
    if (v6 == CFDictionaryGetTypeID())
      return v2;
    else
      return 0;
  }
  return (const __CFString *)Value;
}

void sub_1CDF7E40C(_Unwind_Exception *a1)
{
  pthread_rwlock_t *v1;

  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t _InitializeCachedProperties(void)
{
  uint64_t v0;
  CFMutableDictionaryRef Mutable;
  uint64_t result;

  v0 = operator new();
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)v0 = &unk_1E8B56538;
  *(_QWORD *)(v0 + 8) = Mutable;
  result = pthread_rwlock_init((pthread_rwlock_t *)(v0 + 16), 0);
  *(_QWORD *)v0 = &unk_1E8B564E8;
  _cachedProperties = v0;
  _initedCachedProperties = 1;
  return result;
}

void sub_1CDF7E4C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

CFMutableArrayRef DCSSearchFoundationCopyResults(const __CFString *a1)
{
  __CFArray *v2;
  CFMutableArrayRef v3;

  v2 = DCSCopyActiveDictionaries(0);
  v3 = DCSSearchFoundationCopyResultsWithOptions(a1, v2, 0);
  if (v2)
    CFRelease(v2);
  return v3;
}

void IDXDictionaryPackage::IDXDictionaryPackage(IDXDictionaryPackage *this, CFURLRef relativeURL)
{
  *(_QWORD *)this = -1;
  *((_QWORD *)this + 2) = 0;
  *((_BYTE *)this + 24) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  *((_BYTE *)this + 108) = 0;
  *((_DWORD *)this + 44) = 0;
  *((_QWORD *)this + 31) = 0;
  *((_QWORD *)this + 1) = CFURLCopyAbsoluteURL(relativeURL);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 32), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 184), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 112), 0);
  pthread_mutex_init((pthread_mutex_t *)this + 4, 0);
  *((CFAbsoluteTime *)this + 40) = CFAbsoluteTimeGetCurrent();
}

void IDXDictionaryPackage::~IDXDictionaryPackage(IDXDictionaryPackage *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  void *v5;
  int v6;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;

  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 2);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 31);
  if (v4)
    CFRelease(v4);
  v5 = (void *)*((_QWORD *)this + 12);
  if (v5)
  {
    v6 = *((_DWORD *)this + 26);
    if (v6 >= 1)
    {
      for (i = 0; i < v6; ++i)
      {
        v8 = *((_QWORD *)this + 12);
        v9 = *(_QWORD *)(v8 + 8 * i);
        if (v9)
        {
          IDXIndexInfo::~IDXIndexInfo(*(IDXIndexInfo **)(v8 + 8 * i));
          MEMORY[0x1D17BC79C](v9, 0x1070C4063F6B07ELL);
          v6 = *((_DWORD *)this + 26);
        }
      }
      v5 = (void *)*((_QWORD *)this + 12);
    }
    free(v5);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 184));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 112));
  pthread_mutex_destroy((pthread_mutex_t *)this + 4);
}

void sub_1CDF7EB1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

uint64_t IDXDictionaryPackage::URL(CFAbsoluteTime *this)
{
  this[40] = CFAbsoluteTimeGetCurrent();
  return *((_QWORD *)this + 1);
}

CFDictionaryRef IDXDictionaryPackage::version(CFDictionaryRef *this)
{
  const __CFNumber *Value;

  if (*this == (CFDictionaryRef)-1)
  {
    if (IDXDictionaryPackage::properties((IDXDictionaryPackage *)this))
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(this[2], CFSTR("IDXDictionaryVersion"));
      if (Value)
        CFNumberGetValue(Value, kCFNumberCFIndexType, this);
    }
  }
  return *this;
}

uint64_t IDXDictionaryPackage::properties(IDXDictionaryPackage *this)
{
  const __CFURL *DictionaryComponentURL;
  BOOL v3;
  CFDataRef resourceData;

  if (!*((_BYTE *)this + 24))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    if (!*((_BYTE *)this + 24))
    {
      DictionaryComponentURL = CreateDictionaryComponentURL(*((const __CFURL **)this + 1), (uint64_t)CFSTR("Info.plist"));
      resourceData = 0;
      if (CFURLCreateDataAndPropertiesFromResource(0, DictionaryComponentURL, &resourceData, 0, 0, 0))
        v3 = resourceData == 0;
      else
        v3 = 1;
      if (!v3)
      {
        *((_QWORD *)this + 2) = CFPropertyListCreateFromXMLData(0, resourceData, 0, 0);
        CFRelease(resourceData);
      }
      CFRelease(DictionaryComponentURL);
    }
    *((_BYTE *)this + 24) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 32));
  }
  *((CFAbsoluteTime *)this + 40) = CFAbsoluteTimeGetCurrent();
  return *((_QWORD *)this + 2);
}

uint64_t IDXDictionaryPackage::bundle(IDXDictionaryPackage *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 31);
  if (!result)
  {
    pthread_mutex_lock((pthread_mutex_t *)this + 4);
    if (!*((_QWORD *)this + 31))
      *((_QWORD *)this + 31) = CFBundleCreate(0, *((CFURLRef *)this + 1));
    pthread_mutex_unlock((pthread_mutex_t *)this + 4);
    return *((_QWORD *)this + 31);
  }
  return result;
}

BOOL IDXDictionaryPackage::validDictionary(CFDictionaryRef *this)
{
  CFDictionaryRef v2;
  _BOOL8 result;

  v2 = IDXDictionaryPackage::version(this);
  result = 0;
  if (v2 != (CFDictionaryRef)-1 && (uint64_t)v2 <= 3)
    return IDXDictionaryPackage::indexInfoList(this, 0) != 0;
  return result;
}

CFDictionaryRef IDXDictionaryPackage::indexInfoList(CFDictionaryRef *this, int *a2)
{
  pthread_mutex_t *v4;
  const __CFArray *Value;
  const __CFArray *v6;
  int Count;
  CFIndex v8;
  const __CFDictionary *ValueAtIndex;
  const __CFString *v10;
  const __CFNumber *v11;
  const __CFString *v12;
  const __CFURL *DictionaryComponentURL;
  IDXIndexInfo *v14;
  __CFBundle *v15;
  CFIndex v16;
  CFDictionaryRef v17;
  uint64_t v18;
  CFDictionaryRef v20;
  uint64_t valuePtr;

  if (!*((_BYTE *)this + 108) && IDXDictionaryPackage::properties((IDXDictionaryPackage *)this))
  {
    v4 = (pthread_mutex_t *)(this + 14);
    pthread_mutex_lock((pthread_mutex_t *)(this + 14));
    if (!*((_BYTE *)this + 108))
    {
      Value = (const __CFArray *)CFDictionaryGetValue(this[2], CFSTR("IDXDictionaryIndexes"));
      if (Value)
      {
        v6 = Value;
        Count = CFArrayGetCount(Value);
        *((_DWORD *)this + 26) = Count;
        this[12] = (CFDictionaryRef)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
        if (*((int *)this + 26) >= 1)
        {
          v8 = 0;
          do
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v6, v8);
            v10 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("IDXIndexPath"));
            valuePtr = 1;
            v11 = (const __CFNumber *)CFDictionaryGetValue(this[2], CFSTR("IDXDictionaryVersion"));
            if (v11)
              CFNumberGetValue(v11, kCFNumberCFIndexType, &valuePtr);
            if (valuePtr < 3 || CFStringHasPrefix(v10, CFSTR("Resources/")))
            {
              v12 = 0;
            }
            else
            {
              v10 = CFStringCreateWithFormat(0, 0, CFSTR("Resources/%@"), v10);
              v12 = v10;
            }
            DictionaryComponentURL = CreateDictionaryComponentURL(this[1], (uint64_t)v10);
            v14 = (IDXIndexInfo *)operator new();
            v15 = (__CFBundle *)IDXDictionaryPackage::bundle((IDXDictionaryPackage *)this);
            IDXIndexInfo::IDXIndexInfo(v14, DictionaryComponentURL, ValueAtIndex, v15);
            *((_QWORD *)this[12] + v8) = v14;
            v16 = v8;
            if (!**((_QWORD **)this[12] + v8))
            {
              do
              {
                v17 = this[12];
                v18 = *((_QWORD *)v17 + v16);
                if (v18)
                {
                  IDXIndexInfo::~IDXIndexInfo(*((IDXIndexInfo **)v17 + v16));
                  MEMORY[0x1D17BC79C](v18, 0x1070C4063F6B07ELL);
                }
              }
              while (v16-- > 0);
              v20 = this[12];
              *((_DWORD *)this + 26) = 0;
              free(v20);
              this[12] = 0;
            }
            CFRelease(DictionaryComponentURL);
            if (v12)
              CFRelease(v12);
            ++v8;
          }
          while (v8 < *((int *)this + 26));
        }
      }
      *((_BYTE *)this + 108) = 1;
      v4 = (pthread_mutex_t *)(this + 14);
    }
    pthread_mutex_unlock(v4);
  }
  if (a2)
    *a2 = *((_DWORD *)this + 26);
  return this[12];
}

void sub_1CDF7EF94(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

IDXIndexInfo *IDXDictionaryPackage::retainIndex(CFDictionaryRef *this, const __CFString *a2)
{
  IDXIndexInfo **v4;
  int v5;
  uint64_t v6;
  const __CFString *v7;
  IDXIndexInfo *v8;

  v4 = (IDXIndexInfo **)IDXDictionaryPackage::indexInfoList(this, 0);
  v5 = *((_DWORD *)this + 26);
  if (a2)
  {
    if (v5 >= 1)
    {
      v6 = 0;
      while (1)
      {
        v7 = (const __CFString *)IDXIndexInfo::indexName(*v4);
        if (v7)
        {
          if (CFStringCompare(a2, v7, 0) == kCFCompareEqualTo)
            break;
        }
        if (CFStringCompare(a2, *((CFStringRef *)*v4 + 4), 0) == kCFCompareEqualTo)
          break;
        ++v6;
        ++v4;
        if (v6 >= *((int *)this + 26))
          return 0;
      }
      goto LABEL_10;
    }
    return 0;
  }
  if (v5 <= 0)
    return 0;
LABEL_10:
  v8 = *v4;
  if (v8)
    IDXDictionaryPackage::retain((IDXDictionaryPackage *)this);
  return v8;
}

void IDXDictionaryPackage::retain(IDXDictionaryPackage *this)
{
  pthread_mutex_t *v2;

  v2 = (pthread_mutex_t *)((char *)this + 184);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
  ++*((_DWORD *)this + 44);
  pthread_mutex_unlock(v2);
  *((CFAbsoluteTime *)this + 40) = CFAbsoluteTimeGetCurrent();
}

void IDXDictionaryPackage::releaseIndex(IDXDictionaryPackage *this, IDXIndexInfo *a2)
{
  if (a2)
    IDXDictionaryPackage::release(this);
}

void IDXDictionaryPackage::release(IDXDictionaryPackage *this)
{
  pthread_mutex_t *v2;
  int v3;
  BOOL v4;
  int v5;

  v2 = (pthread_mutex_t *)((char *)this + 184);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
  v3 = *((_DWORD *)this + 44);
  v4 = __OFSUB__(v3, 1);
  v5 = v3 - 1;
  if (v5 < 0 == v4)
    *((_DWORD *)this + 44) = v5;
  pthread_mutex_unlock(v2);
  *((CFAbsoluteTime *)this + 40) = CFAbsoluteTimeGetCurrent();
}

uint64_t DCSMAGetDictionaryAssetCompatibilityVersion()
{
  return 14;
}

const __CFString *DCSMAGetDictionaryAssetType()
{
  return CFSTR("com.apple.MobileAsset.DictionaryServices.dictionary2");
}

__CFArray *DCSMACopyAndUpdateDictionaryCompatibilityVersionHistory()
{
  const __CFNumber *v0;
  const __CFNumber *v1;
  __CFArray *Mutable;
  CFNumberRef v4;
  uint64_t i;
  CFNumberRef v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t valuePtr;

  valuePtr = 5;
  v0 = (const __CFNumber *)DCSCopySharedPreferenceValue(CFSTR("DCSLastUsedAssetCompatibilityVersion"), 0, 0);
  if (v0)
  {
    v1 = v0;
    CFNumberGetValue(v0, kCFNumberCFIndexType, &valuePtr);
    CFRelease(v1);
    if (valuePtr > 13)
      return 0;
  }
  v8 = 14;
  v4 = CFNumberCreate(0, kCFNumberCFIndexType, &v8);
  DCSUpdateSharedPreferenceValue(CFSTR("DCSLastUsedAssetCompatibilityVersion"), v4);
  CFRelease(v4);
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  for (i = valuePtr; ; i = v7)
  {
    v7 = i + 1;
    if (i >= v8)
      break;
    v6 = CFNumberCreate(0, kCFNumberCFIndexType, &v7);
    CFArrayAppendValue(Mutable, v6);
    CFRelease(v6);
  }
  return Mutable;
}

uint64_t DCSMAPrepareMobileAssetQuery()
{
  return 1;
}

const void *DCSMAGetAssetAttributes(const __CFDictionary *a1)
{
  return CFDictionaryGetValue(a1, CFSTR("attributes"));
}

const __CFString *DCSMAGetAssetLanguage(const __CFDictionary *a1)
{
  const __CFDictionary *Value;
  const __CFDictionary *v2;
  const __CFString *v3;
  const __CFString *v4;
  const __CFArray *v5;
  const __CFArray *v6;
  CFRange v8;

  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("attributes"));
  if (!Value)
    return 0;
  v2 = Value;
  v3 = (const __CFString *)CFDictionaryGetValue(Value, CFSTR("Language"));
  v4 = v3;
  if (v3)
  {
    if (CFStringCompare(v3, CFSTR("en"), 1uLL) == kCFCompareEqualTo)
    {
      v5 = (const __CFArray *)CFDictionaryGetValue(v2, CFSTR("Countries"));
      if (v5)
      {
        v6 = v5;
        v8.length = CFArrayGetCount(v5);
        v8.location = 0;
        if (CFArrayGetFirstIndexOfValue(v6, v8, CFSTR("US")) == -1)
          return CFSTR("en_GB");
        else
          return CFSTR("en_US");
      }
    }
  }
  return v4;
}

uint64_t DCSMAIsLanguageDictionaryAsset(const __CFDictionary *a1)
{
  const __CFDictionary *Value;
  const __CFArray *v4;
  const __CFArray *v5;
  uint64_t Count;
  _BOOL4 v7;
  CFRange v8;

  if (DCSMAGetAssetLanguage(a1))
    return 1;
  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("attributes"));
  v4 = (const __CFArray *)CFDictionaryGetValue(Value, CFSTR("IndexLanguages"));
  if (v4)
  {
    v5 = v4;
    Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      v8.location = 0;
      v8.length = Count;
      v7 = CFArrayGetFirstIndexOfValue(v5, v8, CFSTR("*")) == -1;
      return Count > 1 && v7;
    }
  }
  else
  {
    Count = 0;
  }
  v7 = 1;
  return Count > 1 && v7;
}

uint64_t DCSMAPreferredOrderOfDictionaryAssetAttributesForLanguages(const void *a1, CFArrayRef theArray)
{
  CFIndex Count;
  uint64_t v5;
  uint64_t v6;
  __CFDictionary *Mutable;
  const __CFString *v8;
  const __CFString *v9;
  CFIndex v10;
  const __CFString *v11;
  int v12;
  const __CFString *Value;
  const __CFArray *v14;
  const __CFArray *v15;
  CFIndex v16;
  CFIndex v17;
  const __CFString *ValueAtIndex;
  const __CFString *v19;
  _BOOL4 v20;
  const __CFString *v21;
  const __CFString *v22;
  CFIndex v23;
  const __CFString *v24;
  CFIndex v25;
  uint64_t v26;
  const __CFString *v27;
  CFIndex v28;
  const __CFString *v29;

  if (!theArray)
    return -1;
  Count = CFArrayGetCount(theArray);
  v5 = -1;
  if (a1)
  {
    v6 = Count;
    if (Count)
    {
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue(Mutable, CFSTR("attributes"), a1);
      if (!DCSMAIsLanguageDictionaryAsset(Mutable))
      {
        Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("DictionaryIdentifier"));
        if (Value)
        {
          if (CFStringCompare(Value, CFSTR("com.apple.dictionary.AppleDictionary"), 0))
            v5 = -1;
          else
            v5 = 1000;
        }
        goto LABEL_46;
      }
      v8 = DCSMAGetAssetLanguage(Mutable);
      if (!v8)
      {
        v14 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("IndexLanguages"));
        if (v14)
        {
          v15 = v14;
          v16 = CFArrayGetCount(v14);
          if (v16 >= 1)
          {
            v17 = v16;
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, 0);
            v19 = (const __CFString *)CFArrayGetValueAtIndex(v15, 0);
            if ((CompareLanguageCode(ValueAtIndex, v19, 0) & 1) != 0)
            {
              v20 = 1;
            }
            else
            {
              v23 = 1;
              do
              {
                if (v17 == v23)
                {
LABEL_13:
                  v5 = -1;
                  goto LABEL_46;
                }
                v24 = (const __CFString *)CFArrayGetValueAtIndex(v15, v23++);
              }
              while (!CompareLanguageCode(ValueAtIndex, v24, 0));
              v20 = v23 - 1 < v17;
            }
            v5 = -1;
            if (v20 && v6 >= 2)
            {
              v25 = 1;
              v26 = 1;
              while (2)
              {
                v27 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v25);
                v28 = 0;
                while (1)
                {
                  v29 = (const __CFString *)CFArrayGetValueAtIndex(v15, v28);
                  if (CompareLanguageCode(v27, v29, 0))
                    break;
                  if (v17 == ++v28)
                    goto LABEL_41;
                }
                if (++v26 == v17)
                {
                  v5 = 3;
                  goto LABEL_46;
                }
LABEL_41:
                ++v25;
                v5 = -1;
                if (v25 != v6)
                  continue;
                break;
              }
            }
          }
        }
        goto LABEL_46;
      }
      if (v6 >= 1)
      {
        v9 = v8;
        v5 = 0;
        v10 = 0;
        while (1)
        {
          v11 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v10);
          if ((CompareLanguageCode(v11, v9, 0) & 1) != 0)
            break;
          v12 = CompareLanguageCode(v11, CFSTR("hi"), 0);
          if (!v10 && v12 && CompareLanguageCode(v9, CFSTR("en_GB"), 0))
          {
            v5 = 10;
            break;
          }
          ++v10;
          v5 += 20;
          if (v6 == v10)
            goto LABEL_13;
        }
        v21 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("DictionaryType"));
        if (!v21)
        {
LABEL_28:
          v5 += 4;
          goto LABEL_46;
        }
        v22 = v21;
        if (CFStringCompare(v21, CFSTR("Monolingual"), 1uLL))
        {
          if (CFStringCompare(v22, CFSTR("Bilingual"), 1uLL) == kCFCompareEqualTo)
          {
            v5 += 2;
            goto LABEL_46;
          }
          if (CFStringCompare(v22, CFSTR("Thesaurus"), 1uLL) == kCFCompareEqualTo)
          {
            v5 |= 1uLL;
            goto LABEL_46;
          }
          goto LABEL_28;
        }
      }
LABEL_46:
      CFRelease(Mutable);
    }
  }
  return v5;
}

const __CFDictionary *DCSMAGetAssetObj(const __CFDictionary *result)
{
  if (result)
    return (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("asset"));
  return result;
}

void DCSMAUpdateLinguisticData(uint64_t a1, const __CFArray *a2, int a3)
{
  if (a1 && a2)
  {
    if (a3)
      AddLinguisticDataAssetion(a1, a2);
    else
      RemoveLinguisticDataAssetion(a1, a2);
  }
}

void DCSMAUpdateLinguisticDataForDictionaryAssetAttribute(const __CFDictionary *a1, int a2)
{
  const void *Value;
  uint64_t v5;
  const __CFArray *v6;
  const __CFArray *v7;
  __CFDictionary *Mutable;
  void *values;

  if (a1)
  {
    Value = CFDictionaryGetValue(a1, CFSTR("DictionaryIdentifier"));
    if (Value)
    {
      v5 = (uint64_t)Value;
      v6 = (const __CFArray *)CFDictionaryGetValue(a1, CFSTR("IndexLanguages"));
      if (v6)
      {
        v7 = v6;
        CFRetain(v6);
      }
      else
      {
        values = (void *)CFDictionaryGetValue(a1, CFSTR("Language"));
        if (!values)
          return;
        v7 = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
        if (!v7)
          return;
      }
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue(Mutable, CFSTR("attributes"), a1);
      if (DCSMAIsLanguageDictionaryAsset(Mutable))
      {
        if (a2)
          AddLinguisticDataAssetion(v5, v7);
        else
          RemoveLinguisticDataAssetion(v5, v7);
      }
      CFRelease(Mutable);
      CFRelease(v7);
    }
  }
}

id DCSMAIsInstalledAsset(const __CFDictionary *Value)
{
  if (Value)
    Value = (const __CFDictionary *)CFDictionaryGetValue(Value, CFSTR("asset"));
  return -[__CFDictionary wasLocal](Value, sel_wasLocal);
}

id DCSMAIsDeletableAsset(const __CFDictionary *Value)
{
  if (Value)
    Value = (const __CFDictionary *)CFDictionaryGetValue(Value, CFSTR("asset"));
  return -[__CFDictionary wasPurgeable](Value, sel_wasPurgeable);
}

CFMutableArrayRef DCSDictionaryAssetCopyInstalledDictionaries()
{
  CFMutableArrayRef v0;
  id v1;
  id v2;
  const __CFArray *v3;
  char **p_data;
  const __CFArray *v5;
  uint64_t Count;
  CFMutableDictionaryRef Mutable;
  const __CFDictionary *v8;
  CFIndex v9;
  void *ValueAtIndex;
  unsigned int v11;
  id v12;
  const void *v13;
  __CFDictionary *v14;
  __CFDictionary *v15;
  void *Value;
  unsigned int v17;
  const __CFNumber *v18;
  const void *v19;
  const void *v20;
  void *v21;
  void *v22;
  const __CFNumber *AssetContentVersion;
  _BOOL4 v24;
  const __CFNumber *v25;
  CFIndex v26;
  CFIndex v27;
  uint64_t v28;
  const void **v29;
  const __CFArray *v30;
  CFIndex v31;
  const char *v32;
  void *v33;
  const __CFDictionary *v34;
  const void *v35;
  const void *v36;
  __CFDictionary *v37;
  const __CFString *v38;
  Class *v39;
  const __CFArray *v40;
  const __CFArray *v41;
  CFIndex v42;
  const __CFDictionary *v43;
  __CFBundle *MainBundle;
  const __CFArray *v45;
  const __CFArray *v46;
  const __CFString *v47;
  const void *v48;
  id v49;
  id v50;
  const __CFString *v51;
  CFStringRef Copy;
  const __CFDictionary *Name;
  const void *v54;
  const __CFArray *Languages;
  const __CFArray *v56;
  const __CFDictionary *v57;
  CFMutableArrayRef v58;
  const __CFString *v59;
  CFStringRef v60;
  __CFArray *v61;
  const CFArrayCallBacks *v62;
  CFMutableArrayRef v63;
  CFIndex v64;
  CFIndex v65;
  const void *v66;
  const __CFString *v67;
  const __CFDictionary *ComponentsFromLocaleIdentifier;
  const __CFString *v69;
  CFIndex v70;
  const __CFDictionary *v71;
  const __CFString *v72;
  const __CFDictionary *v73;
  const __CFString *v74;
  const void *v75;
  const __CFString *v76;
  CFIndex FirstIndexOfValue;
  CFIndex v78;
  CFComparisonResult v79;
  CFIndex i;
  const __CFDictionary *v81;
  const void *v82;
  id v84;
  id v85;
  CFMutableArrayRef v86;
  uint64_t CanonicalLanguageIdentifierFromString;
  const char *v88;
  const char *v89;
  char *v90;
  char *v91;
  const __CFDictionary *v92;
  const char *v93;
  _QWORD valuePtr[2];
  CFRange v95;
  CFRange v96;
  CFRange v97;
  CFRange v98;

  valuePtr[1] = *MEMORY[0x1E0C80C00];
  if (_GetMobileAssetObjectInfo__DispatchOnceToken != -1)
    dispatch_once(&_GetMobileAssetObjectInfo__DispatchOnceToken, &__block_literal_global_5);
  v0 = (CFMutableArrayRef)_GetMobileAssetObjectInfo__ObjectInfoPtr;
  if (_GetMobileAssetObjectInfo__ObjectInfoPtr)
  {
    v1 = objc_alloc_init(*(Class *)_GetMobileAssetObjectInfo__ObjectInfoPtr);
    v2 = objc_msgSend(objc_alloc(*((Class *)v0 + 4)), sel_initWithType_, CFSTR("com.apple.MobileAsset.DictionaryServices.dictionary2"));
    objc_msgSend(v2, sel_returnTypes_, 2);
    objc_msgSend(v2, sel_setDoNotBlockBeforeFirstUnlock_, 1);
    if (objc_msgSend(v2, sel_queryMetaDataSync))
    {
      v0 = 0;
LABEL_99:

      if (v0 && !CFArrayGetCount(v0))
      {
        CFRelease(v0);
        return 0;
      }
      return v0;
    }
    v85 = v1;
    v3 = (const __CFArray *)objc_msgSend(v2, sel_results);
    p_data = &CFSTR("MAAsset").data;
    v84 = v2;
    if (v3)
    {
      v5 = v3;
      Count = CFArrayGetCount(v3);
      Mutable = CFDictionaryCreateMutable(0, Count, MEMORY[0x1E0C9B390], 0);
      v8 = Mutable;
      if (Count >= 1)
      {
        v92 = Mutable;
        v9 = 0;
        v93 = sel_wasLocal;
        v91 = sel_purgeSync;
        do
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(v5, v9);
          v11 = objc_msgSend(ValueAtIndex, sel_state);
          v12 = objc_msgSend(ValueAtIndex, sel_attributes);
          if (v12)
          {
            v13 = v12;
            v14 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v15 = v14;
            if (ValueAtIndex)
              CFDictionarySetValue(v14, CFSTR("asset"), ValueAtIndex);
            CFDictionarySetValue(v15, CFSTR("attributes"), v13);
            if (v15)
              Value = (void *)CFDictionaryGetValue(v15, CFSTR("asset"));
            else
              Value = 0;
            v17 = objc_msgSend(Value, v93, v84);
            CFRelease(v15);
            if (v17)
            {
              v18 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v13, CFSTR("_CompatibilityVersion"));
              valuePtr[0] = 0;
              if (v18)
              {
                CFNumberGetValue(v18, kCFNumberCFIndexType, valuePtr);
                if (valuePtr[0] == 14)
                {
                  v19 = CFDictionaryGetValue((CFDictionaryRef)v13, CFSTR("DictionaryIdentifier"));
                  if (v19)
                  {
                    v20 = v19;
                    v21 = (void *)CFDictionaryGetValue(v92, v19);
                    if (!v21)
                      goto LABEL_23;
                    v22 = v21;
                    AssetContentVersion = _GetAssetContentVersion(ValueAtIndex);
                    v24 = (uint64_t)AssetContentVersion >= (uint64_t)_GetAssetContentVersion(v22) && v11 != 3;
                    if (!v24)
                      v22 = ValueAtIndex;
                    objc_msgSend(v22, v91);
                    v25 = _GetAssetContentVersion(v22);
                    DCSLog(16, CFSTR("Purged duplicated old dictionary %@ (content ver = %ld)"), v20, v25);
                    if (v24)
LABEL_23:
                      CFDictionarySetValue(v92, v20, ValueAtIndex);
                  }
                }
              }
            }
          }
          ++v9;
        }
        while (Count != v9);
        p_data = (char **)(CFSTR("MAAsset") + 16);
        v8 = v92;
      }
    }
    else
    {
      v8 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], 0);
    }
    v26 = CFDictionaryGetCount(v8);
    v27 = v26;
    if (v26 <= 0)
    {
      v30 = 0;
    }
    else
    {
      MEMORY[0x1E0C80A78](v26);
      v29 = (const void **)((char *)&v84 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0));
      CFDictionaryGetKeysAndValues(v8, 0, v29);
      v30 = CFArrayCreate(0, v29, v27, 0);
    }
    CFRelease(v8);
    v91 = (char *)CFArrayCreateMutable(0, v27, MEMORY[0x1E0C9B378]);
    if (v27 >= 1)
    {
      v31 = 0;
      v32 = p_data[422];
      v88 = sel_initWithLocaleIdentifier_;
      v89 = sel_localizedStringForLanguage_context_;
      v93 = CFSTR("DCSDictionaryDescriptionLanguage");
      do
      {
        v33 = (void *)CFArrayGetValueAtIndex(v30, v31);
        v34 = (const __CFDictionary *)objc_msgSend(v33, v32);
        v35 = DCSDictionaryCreateWithAssetAttributes(v34, (const __CFURL *)objc_msgSend(v33, sel_getLocalFileUrl));
        if (v35)
        {
          v36 = v35;
          v37 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          CFDictionarySetValue(v37, CFSTR("dictionaryRef"), v36);
          CFRelease(v36);
          v38 = (const __CFString *)CFDictionaryGetValue(v34, CFSTR("DictionaryPackageName"));
          if (CFStringCompare(v38, CFSTR("Apple Dictionary.dictionary"), 0)
            && CFStringCompare(v38, CFSTR("TTY Abbreviations Dictionary.dictionary"), 0))
          {
            if (_GetMobileAssetObjectInfo__DispatchOnceToken != -1)
              dispatch_once(&_GetMobileAssetObjectInfo__DispatchOnceToken, &__block_literal_global_5);
            v39 = (Class *)_GetMobileAssetObjectInfo__ObjectInfoPtr;
            if (_GetMobileAssetObjectInfo__ObjectInfoPtr)
            {
              if (*(_QWORD *)(_GetMobileAssetObjectInfo__ObjectInfoPtr + 64))
              {
                v40 = (const __CFArray *)CFDictionaryGetValue(v34, CFSTR("IndexLanguages"));
                if (v40)
                {
                  v41 = v40;
                  if (CFArrayGetCount(v40))
                  {
                    v90 = (char *)CFArrayGetValueAtIndex(v41, 0);
                    v42 = CFArrayGetCount(v41);
                    v43 = 0;
                    if (v42 >= 2)
                      v43 = (const __CFDictionary *)CFArrayGetValueAtIndex(v41, 1);
                    v92 = v43;
                    MainBundle = CFBundleGetMainBundle();
                    if (MainBundle)
                    {
                      v45 = CFBundleCopyBundleLocalizations(MainBundle);
                      if (v45)
                      {
                        v46 = v45;
                        if (CFArrayGetCount(v45) >= 1
                          && (v47 = (const __CFString *)CFArrayGetValueAtIndex(v46, 0)) != 0)
                        {
                          CanonicalLanguageIdentifierFromString = (uint64_t)CFLocaleCreateCanonicalLanguageIdentifierFromString(0, v47);
                          CFRelease(v46);
                          if (CanonicalLanguageIdentifierFromString)
                          {
                            v48 = (const void *)CanonicalLanguageIdentifierFromString;
                            v86 = (CFMutableArrayRef)objc_alloc_init(*v39);
                            v49 = objc_alloc(v39[8]);
                            v50 = objc_msgSend(v49, v88, v48);
                            CFRelease(v48);
                            CanonicalLanguageIdentifierFromString = (uint64_t)v50;
                            v51 = (const __CFString *)objc_msgSend(v50, v89, v90, 3);
                            if (v51)
                              Copy = CFStringCreateCopy(0, v51);
                            else
                              Copy = 0;
                            v58 = v86;
                            if (v92)
                            {
                              v59 = (const __CFString *)objc_msgSend((id)CanonicalLanguageIdentifierFromString, v89, v92, 3);
                              if (v59)
                                v60 = CFStringCreateCopy(0, v59);
                              else
                                v60 = 0;
                              v92 = (const __CFDictionary *)CFStringCreateWithFormat(0, 0, CFSTR("%@-%@"), Copy, v60);
                              CFRelease(Copy);
                              CFRelease(v60);
                              Copy = (CFStringRef)v92;
                              v58 = v86;
                            }

                            if (Copy)
                              goto LABEL_53;
                          }
                        }
                        else
                        {
                          CFRelease(v46);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          Name = DCSDictionaryGetName((uint64_t)v36);
          if (Name)
          {
            Copy = (CFStringRef)Name;
            CFRetain(Name);
LABEL_53:
            CFDictionarySetValue(v37, CFSTR("sortKey"), Copy);
            CFRelease(Copy);
            v54 = CFDictionaryGetValue(v34, CFSTR("Language"));
            if (v54
              || (Languages = DCSDictionaryGetLanguages((uint64_t)v36)) != 0
              && (v56 = Languages, CFArrayGetCount(Languages) >= 1)
              && (v57 = (const __CFDictionary *)CFArrayGetValueAtIndex(v56, 0)) != 0
              && (v54 = CFDictionaryGetValue(v57, v93)) != 0)
            {
              CFDictionarySetValue(v37, CFSTR("language"), v54);
            }
            CFArrayAppendValue((CFMutableArrayRef)v91, v37);
            CFRelease(v37);
          }
        }
        ++v31;
      }
      while (v27 != v31);
    }
    if (v30)
      CFRelease(v30);
    v61 = (__CFArray *)v91;
    v95.length = CFArrayGetCount((CFArrayRef)v91);
    v95.location = 0;
    CFArraySortValues(v61, v95, (CFComparatorFunction)_ComparatorForSortingDictionary, 0);
    v62 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    v0 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    v63 = CFArrayCreateMutable(0, 0, v62);
    v64 = CFArrayGetCount(v61);
    v88 = (const char *)CFLocaleCopyPreferredLanguages();
    CanonicalLanguageIdentifierFromString = CFArrayGetCount((CFArrayRef)v88);
    if (CanonicalLanguageIdentifierFromString < 1)
    {
LABEL_93:
      CFRelease(v88);
      CFRelease(v63);
      if (v64 >= 1)
      {
        for (i = 0; i != v64; ++i)
        {
          v81 = (const __CFDictionary *)CFArrayGetValueAtIndex(v61, i);
          v82 = CFDictionaryGetValue(v81, CFSTR("dictionaryRef"));
          v98.length = CFArrayGetCount(v0);
          v98.location = 0;
          if (!CFArrayContainsValue(v0, v98, v82))
            CFArrayAppendValue(v0, v82);
        }
      }
      CFRelease(v61);
      v2 = v84;
      v1 = v85;
      goto LABEL_99;
    }
    v65 = 0;
    v66 = (const void *)*MEMORY[0x1E0C9B088];
    v92 = (const __CFDictionary *)*MEMORY[0x1E0C9B090];
    v86 = v0;
    while (1)
    {
      v90 = (char *)v65;
      v67 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v88, v65);
      ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier(0, v67);
      v69 = (const __CFString *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, v66);
      v89 = (const char *)ComponentsFromLocaleIdentifier;
      v93 = (const char *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, v92);
      if (v64 >= 1)
        break;
LABEL_92:
      CFRelease(v89);
      v65 = (CFIndex)(v90 + 1);
      if (v90 + 1 == (char *)CanonicalLanguageIdentifierFromString)
        goto LABEL_93;
    }
    v70 = 0;
    while (1)
    {
      v71 = (const __CFDictionary *)CFArrayGetValueAtIndex(v61, v70);
      v72 = (const __CFString *)CFDictionaryGetValue(v71, CFSTR("language"));
      if (v72)
        break;
LABEL_80:
      if (v64 == ++v70)
        goto LABEL_92;
    }
    v73 = CFLocaleCreateComponentsFromLocaleIdentifier(0, v72);
    v74 = (const __CFString *)CFDictionaryGetValue(v73, v66);
    if (CFStringCompare(v74, v69, 0))
    {
LABEL_79:
      CFRelease(v73);
      goto LABEL_80;
    }
    v75 = CFDictionaryGetValue(v71, CFSTR("dictionaryRef"));
    v76 = (const __CFString *)CFDictionaryGetValue(v73, v92);
    v96.length = CFArrayGetCount(v0);
    v96.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v0, v96, v75);
    v78 = FirstIndexOfValue;
    if (v76 && v93)
    {
      v79 = CFStringCompare(v76, (CFStringRef)v93, 0);
      v61 = (__CFArray *)v91;
      if (v79)
        goto LABEL_79;
      v97.length = CFArrayGetCount(v63);
      v97.location = 0;
      if (CFArrayContainsValue(v63, v97, v75))
      {
        v0 = v86;
        if (v78 != -1)
          goto LABEL_79;
      }
      else
      {
        CFArrayAppendValue(v63, v75);
        v0 = v86;
        if (v78 != -1)
          CFArrayRemoveValueAtIndex(v86, v78);
      }
    }
    else
    {
      v61 = (__CFArray *)v91;
      if (FirstIndexOfValue != -1)
        goto LABEL_79;
    }
    CFArrayAppendValue(v0, v75);
    goto LABEL_79;
  }
  return v0;
}

const __CFNumber *_GetAssetContentVersion(void *a1)
{
  const __CFNumber *result;
  uint64_t valuePtr;

  valuePtr = 0;
  result = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)objc_msgSend(a1, sel_attributes), CFSTR("_ContentVersion"));
  if (result)
  {
    CFNumberGetValue(result, kCFNumberCFIndexType, &valuePtr);
    return (const __CFNumber *)valuePtr;
  }
  return result;
}

CFComparisonResult _ComparatorForSortingDictionary(const __CFDictionary *a1, const __CFDictionary *a2)
{
  const __CFString *Value;
  const __CFString *v4;

  Value = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("sortKey"));
  v4 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("sortKey"));
  return CFStringCompare(Value, v4, 0x20uLL);
}

__CFString *DCSMACopyDiagnosticLog()
{
  uint64_t v0;
  id v1;
  id v2;
  id v3;
  unsigned int has_internal_diagnostics;
  id v5;
  __CFBundle *MainBundle;
  const __CFString *v7;
  const __CFURL *v8;
  const __CFURL *v9;
  const __CFString *v10;
  const __CFString *v11;
  const __SCNetworkReachability *v12;
  __CFString *Mutable;
  __CFString *v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  __CFString *v23;
  const __CFURL *v25;
  id v26;
  id v27;
  const __CFArray *v28;
  id v29;
  BOOL v30;
  uint64_t v31;
  CFStringRef Copy;
  CFIndex Count;
  CFMutableStringRef MutableCopy;
  const __CFString *v35;
  const __CFURL *v36;
  BOOL v37;
  CFStringRef v38;
  CFIndex i;
  const __CFDictionary *v40;
  const __CFString *Value;
  const void *v42;
  const void *v43;
  const void *v44;
  const __CFString *v45;
  uint64_t v46;
  CFErrorRef err;
  char buffer[8];
  uint64_t v49;
  CFRange v50;

  v49 = *MEMORY[0x1E0C80C00];
  if (_GetMobileAssetObjectInfo__DispatchOnceToken != -1)
    dispatch_once(&_GetMobileAssetObjectInfo__DispatchOnceToken, &__block_literal_global_5);
  v0 = _GetMobileAssetObjectInfo__ObjectInfoPtr;
  if (!_GetMobileAssetObjectInfo__ObjectInfoPtr)
    return 0;
  v1 = objc_alloc_init(*(Class *)_GetMobileAssetObjectInfo__ObjectInfoPtr);
  v2 = objc_msgSend(*(id *)(v0 + 56), sel_processInfo);
  v3 = objc_msgSend(v2, sel_operatingSystemVersionString);
  has_internal_diagnostics = os_variant_has_internal_diagnostics();
  _LogMessage(CFSTR("System version: %@ (internal = %d)"), v3, has_internal_diagnostics);
  _LogMessage(CFSTR("Current dictionary asset compatibility version: %d"), 14);
  v5 = objc_msgSend(v2, sel_processName);
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
    MainBundle = (__CFBundle *)CFBundleGetIdentifier(MainBundle);
  v7 = CFSTR("unknown identifier");
  if (MainBundle)
    v7 = (const __CFString *)MainBundle;
  _LogMessage(CFSTR("Caller application: %@ (%@)"), v5, v7);
  err = 0;
  v8 = (const __CFURL *)(*(uint64_t (**)(const __CFString *, CFErrorRef *))(v0 + 72))(CFSTR("com.apple.MobileAsset.DictionaryServices.dictionary2"), &err);
  v9 = v8;
  if (v8)
  {
    v10 = CFURLCopyHostName(v8);
    if (v10)
    {
      v11 = v10;
      if (CFStringGetCString(v10, buffer, 512, 0x8000100u))
      {
        v12 = SCNetworkReachabilityCreateWithName(0, buffer);
        CFRelease(v11);
        if (!v12)
          goto LABEL_40;
        *(_DWORD *)buffer = 0;
        SCNetworkReachabilityGetFlags(v12, (SCNetworkReachabilityFlags *)buffer);
        Mutable = CFStringCreateMutable(0, 0);
        v14 = Mutable;
        if ((buffer[0] & 1) != 0)
          v15 = CFSTR("T");
        else
          v15 = CFSTR("-");
        CFStringAppend(Mutable, v15);
        if ((buffer[0] & 2) != 0)
          v16 = CFSTR("R");
        else
          v16 = CFSTR("-");
        CFStringAppend(v14, v16);
        if ((buffer[0] & 4) != 0)
          v17 = CFSTR("C");
        else
          v17 = CFSTR("-");
        CFStringAppend(v14, v17);
        if ((buffer[0] & 8) != 0)
          v18 = CFSTR("A");
        else
          v18 = CFSTR("-");
        CFStringAppend(v14, v18);
        if ((buffer[0] & 0x10) != 0)
          v19 = CFSTR("I");
        else
          v19 = CFSTR("-");
        CFStringAppend(v14, v19);
        if ((*(_DWORD *)buffer & 0x10000) != 0)
          v20 = CFSTR("L");
        else
          v20 = CFSTR("-");
        CFStringAppend(v14, v20);
        if ((*(_DWORD *)buffer & 0x20000) != 0)
          v21 = CFSTR("D");
        else
          v21 = CFSTR("-");
        CFStringAppend(v14, v21);
        if ((*(_DWORD *)buffer & 0x40000) != 0)
          v22 = CFSTR("W");
        else
          v22 = CFSTR("-");
        CFStringAppend(v14, v22);
        _LogMessage(CFSTR("Network reachability flags: %@"), v14);
        CFRelease(v12);
        v23 = v14;
      }
      else
      {
        v23 = (__CFString *)v11;
      }
      CFRelease(v23);
    }
  }
LABEL_40:
  if (err)
  {
    v25 = (const __CFURL *)CFErrorCopyDescription(err);
    _LogMessage(CFSTR("Getting dictionary assets server failed due to error: %@"), v25);
    goto LABEL_42;
  }
  _LogMessage(CFSTR("Dictionary assets server URL: %@"), v9);
  *(_QWORD *)buffer = 0;
  v30 = _CheckURL(v9, (CFStringRef *)buffer);
  v31 = *(_QWORD *)buffer;
  if (*(_QWORD *)buffer)
  {
    Copy = CFStringCreateWithFormat(0, 0, CFSTR("failed due to error: %@"), *(_QWORD *)buffer);
    CFRelease(*(CFTypeRef *)buffer);
  }
  else
  {
    if (v30)
    {
      Copy = CFStringCreateCopy(0, CFSTR("OK"));
      MutableCopy = CFStringCreateMutableCopy(0, 0, CFSTR("com.apple.MobileAsset.DictionaryServices.dictionary2"));
      v50.length = CFStringGetLength(MutableCopy);
      v50.location = 0;
      CFStringFindAndReplace(MutableCopy, CFSTR("."), CFSTR("_"), v50, 0);
      v35 = CFStringCreateWithFormat(0, 0, CFSTR("/%@/%@.xml"), MutableCopy, MutableCopy);
      CFRelease(MutableCopy);
      v36 = CFURLCreateCopyAppendingPathComponent(0, v9, v35, 0);
      CFRelease(v35);
      v37 = _CheckURL(v36, (CFStringRef *)buffer);
      if (*(_QWORD *)buffer)
      {
        v38 = CFStringCreateWithFormat(0, 0, CFSTR("failed due to error: %@"), *(_QWORD *)buffer);
        CFRelease(*(CFTypeRef *)buffer);
      }
      else
      {
        if (v37)
          v45 = CFSTR("OK");
        else
          v45 = CFSTR("not exist");
        v38 = CFStringCreateCopy(0, v45);
      }
      CFRelease(v36);
      _LogMessage(CFSTR("Checking access to the server and directory...%@"), Copy);
      _LogMessage(CFSTR("Checking XML file existence in the server directory...%@"), v38);
      if (!Copy)
        goto LABEL_64;
      goto LABEL_63;
    }
    Copy = CFStringCreateCopy(0, CFSTR("failed since the directory doesn't exist"));
  }
  _LogMessage(CFSTR("Checking access to the server and directory...%@"), Copy);
  v38 = 0;
  if (Copy)
LABEL_63:
    CFRelease(Copy);
LABEL_64:
  if (v38)
    CFRelease(v38);
  if (!v31)
    goto LABEL_43;
  v25 = CFURLCreateWithString(0, CFSTR("https://www.apple.com"), 0);
  _CheckURL(v25, (CFStringRef *)buffer);
  if (*(_QWORD *)buffer)
  {
    _LogMessage(CFSTR("(accessing to www.apple.com was also failed due to error: %@)"), *(_QWORD *)buffer);
    CFRelease(*(CFTypeRef *)buffer);
  }
  else
  {
    _LogMessage(CFSTR("(but accessing to www.apple.com was OK)"), v46);
  }
LABEL_42:
  CFRelease(v25);
LABEL_43:
  v26 = objc_msgSend(objc_alloc(*(Class *)(v0 + 32)), sel_initWithType_, CFSTR("com.apple.MobileAsset.DictionaryServices.dictionary2"));
  objc_msgSend(v26, sel_returnTypes_, 2);
  objc_msgSend(v26, sel_setDoNotBlockBeforeFirstUnlock_, 1);
  v27 = objc_msgSend(v26, sel_queryMetaDataSync);
  v28 = (const __CFArray *)objc_msgSend(v26, sel_results);
  v29 = v26;
  if (v27)
  {
    _LogMessage(CFSTR("Querying local dictionary assets (without network access)...failed due to error: %ld"), v27);
  }
  else
  {
    _LogMessage(CFSTR("Querying local dictionary assets (without network access)...OK"));
    if (v28)
      Count = CFArrayGetCount(v28);
    else
      Count = 0;
    _LogMessage(CFSTR("Local dictionary assets count: %ld"), Count);
    _LogMessage(CFSTR("Local assets contains following NOAD dictionaries %@"), CFSTR("{ ===="));
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        v40 = (const __CFDictionary *)objc_msgSend((id)CFArrayGetValueAtIndex(v28, i), sel_attributes);
        Value = (const __CFString *)CFDictionaryGetValue(v40, CFSTR("DictionaryIdentifier"));
        if (Value)
        {
          if (CFStringCompare(Value, CFSTR("com.apple.dictionary.NOAD"), 0) == kCFCompareEqualTo)
          {
            v42 = CFDictionaryGetValue(v40, CFSTR("_CompatibilityVersion"));
            v43 = CFDictionaryGetValue(v40, CFSTR("_ContentVersion"));
            v44 = CFDictionaryGetValue(v40, CFSTR("_MasteredVersion"));
            _LogMessage(CFSTR("    CompatibilityVersion:%@, ContentVersion:%@, MasteredVersion:%@"), v42, v43, v44);
          }
        }
      }
    }
    _LogMessage(CFSTR("%@"), CFSTR("==== }"));
  }

  return _LogMessage(0);
}

__CFString *_LogMessage(CFStringRef format, ...)
{
  const __CFString *v2;
  __CFString *MutableCopy;
  __CFString *v4;
  __CFDateFormatter *v5;
  CFAbsoluteTime Current;
  CFStringRef StringWithAbsoluteTime;
  const __CFString *v8;
  va_list va;
  CFRange v11;

  va_start(va, format);
  if (_LogMessage__OnceToken != -1)
  {
    dispatch_once(&_LogMessage__OnceToken, &__block_literal_global_203);
    if (format)
      goto LABEL_3;
LABEL_5:
    MutableCopy = CFStringCreateMutableCopy(0, 0, (CFStringRef)_LogMessage__LogString);
    v4 = (__CFString *)_LogMessage__LogString;
    v11.length = CFStringGetLength((CFStringRef)_LogMessage__LogString);
    v11.location = 0;
    CFStringDelete(v4, v11);
    v5 = CFDateFormatterCreate(0, 0, kCFDateFormatterShortStyle, kCFDateFormatterMediumStyle);
    Current = CFAbsoluteTimeGetCurrent();
    StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(0, v5, Current);
    CFRelease(v5);
    v8 = CFStringCreateWithFormat(0, 0, CFSTR("// ==== DictionaryServices Diagnostic Log (%@) ==== //\n"), StringWithAbsoluteTime);
    CFRelease(StringWithAbsoluteTime);
    CFStringInsert(MutableCopy, 0, v8);
    CFRelease(v8);
    return MutableCopy;
  }
  if (!format)
    goto LABEL_5;
LABEL_3:
  v2 = CFStringCreateWithFormatAndArguments(0, 0, format, va);
  CFStringAppend((CFMutableStringRef)_LogMessage__LogString, v2);
  CFStringAppend((CFMutableStringRef)_LogMessage__LogString, CFSTR("\n"));
  CFRelease(v2);
  return 0;
}

BOOL _CheckURL(const __CFURL *a1, CFStringRef *a2)
{
  double Current;
  __CFHTTPMessage *Request;
  __CFReadStream *v6;
  __CFReadStream *v7;
  double v8;
  CFIndex ResponseStatusCode;
  _BOOL8 v10;
  const __CFString *v11;
  __CFHTTPMessage *v12;
  __CFHTTPMessage *v13;
  __CFHTTPMessage *v14;
  __CFHTTPMessage *v15;
  UInt8 buffer[1024];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a2)
    *a2 = 0;
  Current = CFAbsoluteTimeGetCurrent();
  Request = CFHTTPMessageCreateRequest(0, CFSTR("HEAD"), a1, (CFStringRef)*MEMORY[0x1E0C930E8]);
  v6 = CFReadStreamCreateForHTTPRequest(0, Request);
  v7 = v6;
  if (v6 && CFReadStreamOpen(v6))
  {
    v8 = Current + 10.0;
    ResponseStatusCode = 404;
    while (!CFReadStreamHasBytesAvailable(v7))
    {
      if (CFAbsoluteTimeGetCurrent() > v8)
        goto LABEL_8;
    }
    v11 = (const __CFString *)*MEMORY[0x1E0C93230];
    v12 = (__CFHTTPMessage *)CFReadStreamCopyProperty(v7, (CFStreamPropertyKey)*MEMORY[0x1E0C93230]);
    if (v12)
    {
      v13 = v12;
      ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v12);
      CFRelease(v13);
      if (CFReadStreamRead(v7, buffer, 1024) > 0)
        goto LABEL_21;
    }
    else
    {
      if (CFReadStreamRead(v7, buffer, 1024) >= 1)
      {
        v14 = (__CFHTTPMessage *)CFReadStreamCopyProperty(v7, v11);
        if (v14)
        {
          v15 = v14;
          ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v14);
          CFRelease(v15);
        }
        else
        {
          ResponseStatusCode = 404;
        }
        goto LABEL_21;
      }
      ResponseStatusCode = 404;
    }
LABEL_8:
    if (a2)
      *a2 = _CreateErrorDescriptionFromStream(v7);
LABEL_21:
    v10 = ResponseStatusCode != 404;
    CFReadStreamClose(v7);
  }
  else
  {
    v10 = 0;
    if (a2)
      *a2 = _CreateErrorDescriptionFromStream(v7);
  }
  if (v7)
    CFRelease(v7);
  CFRelease(Request);
  return v10;
}

CFStringRef _CreateErrorDescriptionFromStream(__CFReadStream *a1)
{
  __CFError *v2;
  __CFError *v3;
  CFStringRef v4;
  CFStringRef result;
  CFStreamError Error;

  if (!a1)
    return CFStringCreateCopy(0, CFSTR("Could not create read stream"));
  v2 = CFReadStreamCopyError(a1);
  if (v2)
  {
    v3 = v2;
    v4 = CFErrorCopyDescription(v2);
    CFRelease(v3);
    return v4;
  }
  Error = CFReadStreamGetError(a1);
  if (Error.domain == *MEMORY[0x1E0C93170] && (Error.error & 0xFFFFFFFC) == 4294967292)
  {
    result = CFStringCreateCopy(0, *(__CFString **)((char *)off_1E8B57888 + (((*(_QWORD *)&Error.error << 32) + 0x400000000) >> 29)));
    if (!Error.domain)
      return result;
  }
  else
  {
    result = 0;
    if (!Error.domain)
      return result;
  }
  if (!result)
    return CFStringCreateWithFormat(0, 0, CFSTR("Stream error (domain=%d, error=%d)"), Error.domain, *(_QWORD *)&Error.error);
  return result;
}

void IDXIndexInfo::IDXIndexInfo(IDXIndexInfo *this, const __CFURL *a2, const __CFDictionary *a3, __CFBundle *a4)
{
  __CFBundle *DictionaryBundleFromComponentURL;
  const __CFURL *v9;
  const __CFURL *v10;
  const __CFURL *v11;
  const __CFString *v12;
  CFRange v13;
  CFRange v14;

  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((_QWORD *)this + 10) = -1;
  *((_QWORD *)this + 11) = -1;
  *((_BYTE *)this + 96) = 0;
  *(_QWORD *)((char *)this + 100) = -1;
  *((_DWORD *)this + 27) = -1;
  *((_BYTE *)this + 160) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 168), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 232), 0);
  *((_QWORD *)this + 1) = CFRetain(a3);
  *((_QWORD *)this + 4) = CFURLCopyLastPathComponent(a2);
  if (a4)
  {
    DictionaryBundleFromComponentURL = (__CFBundle *)CFRetain(a4);
    *((_QWORD *)this + 5) = DictionaryBundleFromComponentURL;
    if (DictionaryBundleFromComponentURL)
      goto LABEL_6;
  }
  else
  {
    DictionaryBundleFromComponentURL = (__CFBundle *)*((_QWORD *)this + 5);
    if (DictionaryBundleFromComponentURL)
      goto LABEL_6;
  }
  DictionaryBundleFromComponentURL = CreateDictionaryBundleFromComponentURL(a2);
  *((_QWORD *)this + 5) = DictionaryBundleFromComponentURL;
  if (!DictionaryBundleFromComponentURL)
  {
    *(_QWORD *)this = CFURLCopyAbsoluteURL(a2);
    return;
  }
LABEL_6:
  v9 = CFBundleCopyResourceURL(DictionaryBundleFromComponentURL, *((CFStringRef *)this + 4), 0, 0);
  v10 = v9;
  if (!v9)
    v9 = a2;
  v11 = CFURLCopyAbsoluteURL(v9);
  *(_QWORD *)this = v11;
  v12 = CFURLCopyFileSystemPath(v11, kCFURLPOSIXPathStyle);
  *((_QWORD *)this + 2) = v12;
  v13 = CFStringFind(v12, CFSTR("Contents/"), 0);
  v14.length = CFStringGetLength(*((CFStringRef *)this + 2)) - (v13.location + v13.length);
  v14.location = v13.location + v13.length;
  *((_QWORD *)this + 3) = CFStringCreateWithSubstring(0, *((CFStringRef *)this + 2), v14);
  if (v10)
    CFRelease(v10);
}

void IDXIndexInfo::~IDXIndexInfo(IDXIndexInfo *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  void *v7;

  IDXIndexInfo::destructDataFields((void **)this);
  if (*(_QWORD *)this)
    CFRelease(*(CFTypeRef *)this);
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 2);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 5);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 3);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 4);
  if (v6)
    CFRelease(v6);
  v7 = (void *)*((_QWORD *)this + 6);
  if (v7)
    free(v7);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 168));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 232));
}

void IDXIndexInfo::destructDataFields(void **this)
{
  if (*((_BYTE *)this + 160))
  {
    free(this[17]);
    free(this[18]);
    free(this[19]);
  }
}

const __CFDictionary *IDXIndexInfo::indexName(IDXIndexInfo *this)
{
  const __CFDictionary *result;

  result = (const __CFDictionary *)*((_QWORD *)this + 7);
  if (!result)
  {
    result = (const __CFDictionary *)*((_QWORD *)this + 1);
    if (result)
    {
      result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("IDXIndexName"));
      *((_QWORD *)this + 7) = result;
    }
  }
  return result;
}

const __CFDictionary *IDXIndexInfo::relativePath(IDXIndexInfo *this)
{
  const __CFDictionary *result;
  const void *Value;

  result = (const __CFDictionary *)*((_QWORD *)this + 3);
  if (!result)
  {
    result = (const __CFDictionary *)*((_QWORD *)this + 1);
    if (result)
    {
      Value = CFDictionaryGetValue(result, CFSTR("IDXIndexPath"));
      *((_QWORD *)this + 3) = Value;
      CFRetain(Value);
      return (const __CFDictionary *)*((_QWORD *)this + 3);
    }
  }
  return result;
}

CFStringRef IDXIndexInfo::fullPath(IDXIndexInfo *this)
{
  CFStringRef result;

  result = (CFStringRef)*((_QWORD *)this + 2);
  if (!result)
  {
    if (*((_QWORD *)this + 1))
    {
      result = CFURLCopyFileSystemPath(*(CFURLRef *)this, kCFURLPOSIXPathStyle);
      *((_QWORD *)this + 2) = result;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t IDXIndexInfo::POSIXPath(IDXIndexInfo *this)
{
  uint64_t result;
  const __CFString *v3;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  char *v6;
  const __CFString *v7;

  result = *((_QWORD *)this + 6);
  if (!result)
  {
    if (*((_QWORD *)this + 1))
    {
      v3 = (const __CFString *)*((_QWORD *)this + 2);
      if (!v3)
      {
        v3 = CFURLCopyFileSystemPath(*(CFURLRef *)this, kCFURLPOSIXPathStyle);
        *((_QWORD *)this + 2) = v3;
      }
      Length = CFStringGetLength(v3);
      MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
      v6 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0xECF878FAuLL);
      *((_QWORD *)this + 6) = v6;
      v7 = (const __CFString *)*((_QWORD *)this + 2);
      if (!v7)
      {
        if (*((_QWORD *)this + 1))
        {
          v7 = CFURLCopyFileSystemPath(*(CFURLRef *)this, kCFURLPOSIXPathStyle);
          *((_QWORD *)this + 2) = v7;
          v6 = (char *)*((_QWORD *)this + 6);
        }
        else
        {
          v7 = 0;
        }
      }
      CFStringGetFileSystemRepresentation(v7, v6, MaximumSizeForEncoding);
      return *((_QWORD *)this + 6);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const __CFDictionary *IDXIndexInfo::accessMethodName(IDXIndexInfo *this)
{
  const __CFDictionary *result;

  result = (const __CFDictionary *)*((_QWORD *)this + 8);
  if (!result)
  {
    result = (const __CFDictionary *)*((_QWORD *)this + 1);
    if (result)
    {
      result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("IDXIndexAccessMethod"));
      *((_QWORD *)this + 8) = result;
    }
  }
  return result;
}

const __CFDictionary *IDXIndexInfo::keyMatchingMethods(IDXIndexInfo *this)
{
  const __CFDictionary *result;

  result = (const __CFDictionary *)*((_QWORD *)this + 9);
  if (!result)
  {
    result = (const __CFDictionary *)*((_QWORD *)this + 1);
    if (result)
    {
      result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("IDXIndexKeyMatchingMethods"));
      *((_QWORD *)this + 9) = result;
    }
  }
  return result;
}

uint64_t IDXIndexInfo::dataSizeLength(IDXIndexInfo *this)
{
  char *v1;
  const __CFDictionary *v4;
  const __CFNumber *Value;

  v1 = (char *)this + 80;
  if (*((_QWORD *)this + 10) == -1)
  {
    v4 = (const __CFDictionary *)*((_QWORD *)this + 1);
    if (v4)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(v4, CFSTR("IDXIndexDataSizeLength"));
      if (Value && CFNumberGetValue(Value, kCFNumberCFIndexType, v1))
      {
        if (*(_QWORD *)v1)
          return *(_QWORD *)v1;
      }
      else
      {
        *(_QWORD *)v1 = 0;
      }
      IDXIndexInfo::dataFields(this);
      if (*((_QWORD *)this + 16) == 1 && !*((_QWORD *)this + 14) && !*((_QWORD *)this + 15))
        *((_QWORD *)this + 10) = *(_QWORD *)(*((_QWORD *)this + 19) + 8);
    }
  }
  return *(_QWORD *)v1;
}

uint64_t IDXIndexInfo::dataFields(IDXIndexInfo *this)
{
  if (!*((_BYTE *)this + 160) && *((_QWORD *)this + 1))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 168));
    if (!*((_BYTE *)this + 160))
    {
      IDXIndexInfo::constructDataFields((CFDictionaryRef *)this);
      *((_BYTE *)this + 160) = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 168));
  }
  return (uint64_t)this + 112;
}

uint64_t IDXIndexInfo::fixedDataSize(IDXIndexInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;

  if (!*((_BYTE *)this + 96))
  {
    IDXIndexInfo::dataFields(this);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 168));
    if (!*((_BYTE *)this + 96))
    {
      *((_QWORD *)this + 11) = 0;
      if (!*((_QWORD *)this + 16))
      {
        v2 = *((_QWORD *)this + 14);
        if (v2 < 1)
        {
          v3 = 0;
        }
        else
        {
          v3 = 0;
          v4 = (uint64_t *)(*((_QWORD *)this + 17) + 16);
          do
          {
            v5 = *v4;
            v4 += 3;
            v3 += v5;
            --v2;
          }
          while (v2);
          *((_QWORD *)this + 11) = v3;
        }
        v6 = *((_QWORD *)this + 15);
        if (v6 >= 1)
        {
          v7 = (uint64_t *)(*((_QWORD *)this + 18) + 8);
          do
          {
            v8 = *v7;
            v7 += 2;
            v3 += v8;
            --v6;
          }
          while (v6);
          *((_QWORD *)this + 11) = v3;
        }
      }
    }
    *((_BYTE *)this + 96) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 168));
  }
  return *((_QWORD *)this + 11);
}

BOOL IDXIndexInfo::writable(IDXIndexInfo *this)
{
  int v1;
  const __CFDictionary *v4;
  const __CFBoolean *Value;
  int v6;
  const char *v7;
  const char *v8;

  v1 = *((_DWORD *)this + 25);
  if (v1 == -1)
  {
    v4 = (const __CFDictionary *)*((_QWORD *)this + 1);
    if (v4)
    {
      Value = (const __CFBoolean *)CFDictionaryGetValue(v4, CFSTR("IDXIndexWritable"));
      v6 = CFBooleanGetValue(Value);
      *((_DWORD *)this + 25) = v6;
      if (v6)
      {
        v7 = (const char *)IDXIndexInfo::POSIXPath(this);
        if (access(v7, 0))
        {
          v1 = *((_DWORD *)this + 25);
        }
        else
        {
          v8 = (const char *)IDXIndexInfo::POSIXPath(this);
          v1 = access(v8, 2) == 0;
          *((_DWORD *)this + 25) = v1;
        }
      }
      else
      {
        v1 = 0;
      }
    }
    else
    {
      v1 = -1;
    }
  }
  return v1 != 0;
}

BOOL IDXIndexInfo::supportDataID(IDXIndexInfo *this)
{
  int v2;
  const __CFDictionary *v3;
  const __CFBoolean *Value;

  v2 = *((_DWORD *)this + 26);
  if (v2 == -1)
  {
    v3 = (const __CFDictionary *)*((_QWORD *)this + 1);
    if (v3)
    {
      Value = (const __CFBoolean *)CFDictionaryGetValue(v3, CFSTR("IDXIndexSupportDataID"));
      v2 = CFBooleanGetValue(Value);
      *((_DWORD *)this + 26) = v2;
    }
    else
    {
      v2 = -1;
    }
  }
  return v2 != 0;
}

BOOL IDXIndexInfo::bigEndian(IDXIndexInfo *this)
{
  int v2;
  const __CFDictionary *v3;
  const __CFBoolean *Value;

  v2 = *((_DWORD *)this + 27);
  if (v2 == -1)
  {
    v3 = (const __CFDictionary *)*((_QWORD *)this + 1);
    if (v3)
    {
      Value = (const __CFBoolean *)CFDictionaryGetValue(v3, CFSTR("IDXIndexBigEndian"));
      v2 = CFBooleanGetValue(Value);
      *((_DWORD *)this + 27) = v2;
    }
    else
    {
      v2 = -1;
    }
  }
  return v2 != 0;
}

const __CFDictionary *IDXIndexInfo::optionalProperty(IDXIndexInfo *this, const __CFString *a2)
{
  const __CFDictionary *result;

  result = (const __CFDictionary *)*((_QWORD *)this + 1);
  if (result)
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  return result;
}

uint64_t IDXIndexInfo::constructDataFields(CFDictionaryRef *this)
{
  uint64_t result;
  const __CFDictionary *v3;
  const __CFArray *Value;
  const __CFArray *v5;
  CFIndex Count;
  uint64_t v7;
  uint64_t v8;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *v11;
  const __CFArray *v12;
  const __CFArray *v13;
  CFIndex v14;
  uint64_t v15;
  uint64_t v16;
  CFIndex j;
  const __CFDictionary *v18;
  const __CFNumber *v19;
  const __CFArray *v20;
  uint64_t v21;
  uint64_t v22;
  CFIndex k;
  const __CFDictionary *v24;
  const __CFNumber *v25;

  result = (uint64_t)CFDictionaryGetValue(this[1], CFSTR("IDXIndexDataFields"));
  if (!result)
    return result;
  v3 = (const __CFDictionary *)result;
  Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)result, CFSTR("IDXExternalDataFields"));
  if (!Value)
  {
    this[14] = 0;
    goto LABEL_9;
  }
  v5 = Value;
  Count = CFArrayGetCount(Value);
  this[14] = (CFDictionaryRef)Count;
  if (!Count)
  {
LABEL_9:
    this[17] = 0;
    goto LABEL_10;
  }
  v7 = Count;
  this[17] = (CFDictionaryRef)malloc_type_malloc(24 * Count, 0x106004033AEC38CuLL);
  if (v7 >= 1)
  {
    v8 = 0;
    for (i = 0; i != v7; ++i)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v5, i);
      *(_QWORD *)((char *)this[17] + v8) = CFDictionaryGetValue(ValueAtIndex, CFSTR("IDXDataFieldName"));
      *(_QWORD *)((char *)this[17] + v8 + 8) = CFDictionaryGetValue(ValueAtIndex, CFSTR("IDXIndexPath"));
      v11 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("IDXDataSize"));
      CFNumberGetValue(v11, kCFNumberCFIndexType, (char *)this[17] + v8 + 16);
      v8 += 24;
    }
  }
LABEL_10:
  v12 = (const __CFArray *)CFDictionaryGetValue(v3, CFSTR("IDXFixedDataFields"));
  if (!v12)
  {
    this[15] = 0;
    goto LABEL_17;
  }
  v13 = v12;
  v14 = CFArrayGetCount(v12);
  this[15] = (CFDictionaryRef)v14;
  if (!v14)
  {
LABEL_17:
    this[18] = 0;
    goto LABEL_18;
  }
  v15 = v14;
  this[18] = (CFDictionaryRef)malloc_type_malloc(16 * v14, 0x1060040C2E02434uLL);
  if (v15 >= 1)
  {
    v16 = 0;
    for (j = 0; j != v15; ++j)
    {
      v18 = (const __CFDictionary *)CFArrayGetValueAtIndex(v13, j);
      *(_QWORD *)((char *)this[18] + v16) = CFDictionaryGetValue(v18, CFSTR("IDXDataFieldName"));
      v19 = (const __CFNumber *)CFDictionaryGetValue(v18, CFSTR("IDXDataSize"));
      CFNumberGetValue(v19, kCFNumberCFIndexType, (char *)this[18] + v16 + 8);
      v16 += 16;
    }
  }
LABEL_18:
  result = (uint64_t)CFDictionaryGetValue(v3, CFSTR("IDXVariableDataFields"));
  if (!result)
  {
    this[16] = 0;
    goto LABEL_25;
  }
  v20 = (const __CFArray *)result;
  result = CFArrayGetCount((CFArrayRef)result);
  this[16] = (CFDictionaryRef)result;
  if (!result)
  {
LABEL_25:
    this[19] = 0;
    return result;
  }
  v21 = result;
  result = (uint64_t)malloc_type_malloc(16 * result, 0x1060040C2E02434uLL);
  this[19] = (CFDictionaryRef)result;
  if (v21 >= 1)
  {
    v22 = 0;
    for (k = 0; k != v21; ++k)
    {
      v24 = (const __CFDictionary *)CFArrayGetValueAtIndex(v20, k);
      *(_QWORD *)((char *)this[19] + v22) = CFDictionaryGetValue(v24, CFSTR("IDXDataFieldName"));
      v25 = (const __CFNumber *)CFDictionaryGetValue(v24, CFSTR("IDXDataSizeLength"));
      result = CFNumberGetValue(v25, kCFNumberCFIndexType, (char *)this[19] + v22 + 8);
      v22 += 16;
    }
  }
  return result;
}

uint64_t IDXIndexInfo::openCount(IDXIndexInfo *this)
{
  pthread_rwlock_t *v2;
  unsigned int *Value;
  uint64_t v4;

  if (!*((_QWORD *)this + 2))
    return 0;
  v2 = (pthread_rwlock_t *)(_allOpenedIndexes + 16);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(_allOpenedIndexes + 16));
  Value = (unsigned int *)CFDictionaryGetValue(*(CFDictionaryRef *)(_allOpenedIndexes + 8), *((const void **)this + 2));
  if (Value)
    v4 = *Value;
  else
    v4 = 0;
  pthread_rwlock_unlock(v2);
  return v4;
}

void sub_1CDF81BF0(_Unwind_Exception *a1)
{
  pthread_rwlock_t *v1;

  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IDXIndexInfo::opened(IDXIndexInfo *this, void *a2)
{
  pthread_rwlock_t *v4;
  const __CFDictionary *v5;
  _QWORD *Value;
  uint64_t v7;
  CFStringRef v8;

  if ((_initedAllOpenedIndexes & 1) == 0)
    pthread_once(&IDXIndexInfo::opened(void *)::once_control, (void (*)(void))_InitializeOpenedIndexes);
  if (!*((_QWORD *)this + 2))
  {
    if (!*((_QWORD *)this + 1))
      return 0;
    v8 = CFURLCopyFileSystemPath(*(CFURLRef *)this, kCFURLPOSIXPathStyle);
    *((_QWORD *)this + 2) = v8;
    if (!v8)
      return 0;
  }
  v4 = (pthread_rwlock_t *)(_allOpenedIndexes + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(_allOpenedIndexes + 16));
  v5 = *(const __CFDictionary **)(_allOpenedIndexes + 8);
  Value = CFDictionaryGetValue(v5, *((const void **)this + 2));
  if (!Value)
    Value = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
  ++*Value;
  Value[1] = a2;
  CFDictionarySetValue(v5, *((const void **)this + 2), Value);
  v7 = *(unsigned int *)Value;
  pthread_rwlock_unlock(v4);
  return v7;
}

void sub_1CDF81D00(_Unwind_Exception *a1)
{
  pthread_rwlock_t *v1;

  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t _InitializeOpenedIndexes(void)
{
  uint64_t v0;
  CFMutableDictionaryRef Mutable;
  uint64_t result;

  v0 = operator new();
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], 0);
  *(_QWORD *)v0 = &unk_1E8B56538;
  *(_QWORD *)(v0 + 8) = Mutable;
  result = pthread_rwlock_init((pthread_rwlock_t *)(v0 + 16), 0);
  *(_QWORD *)v0 = &unk_1E8B564E8;
  _allOpenedIndexes = v0;
  _initedAllOpenedIndexes = 1;
  return result;
}

void sub_1CDF81DA4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

unsigned int *IDXIndexInfo::closed(IDXIndexInfo *this)
{
  pthread_rwlock_t *v2;
  const __CFDictionary *v3;
  unsigned int *Value;
  unsigned int *v5;
  const void *v6;

  if (!*((_QWORD *)this + 2))
    return 0;
  v2 = (pthread_rwlock_t *)(_allOpenedIndexes + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(_allOpenedIndexes + 16));
  v3 = *(const __CFDictionary **)(_allOpenedIndexes + 8);
  Value = (unsigned int *)CFDictionaryGetValue(v3, *((const void **)this + 2));
  v5 = Value;
  if (Value)
  {
    v6 = (const void *)*((_QWORD *)this + 2);
    if ((*(_QWORD *)Value)-- == 1)
    {
      CFDictionaryRemoveValue(v3, v6);
      free(v5);
      v5 = 0;
    }
    else
    {
      CFDictionarySetValue(v3, v6, Value);
      v5 = (unsigned int *)*v5;
    }
  }
  pthread_rwlock_unlock(v2);
  return v5;
}

void sub_1CDF81E74(_Unwind_Exception *a1)
{
  pthread_rwlock_t *v1;

  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IDXIndexInfo::accessContextData(IDXIndexInfo *this, uint64_t *a2)
{
  BOOL v3;
  uint64_t v4;
  uint64_t result;
  pthread_rwlock_t *v7;
  uint64_t *Value;

  if (*((_QWORD *)this + 2))
    v3 = _allOpenedIndexes == 0;
  else
    v3 = 1;
  if (v3)
  {
    Value = 0;
    v4 = 0;
    result = 0;
    if (!a2)
      return result;
  }
  else
  {
    v7 = (pthread_rwlock_t *)(_allOpenedIndexes + 16);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(_allOpenedIndexes + 16));
    Value = (uint64_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(_allOpenedIndexes + 8), *((const void **)this + 2));
    pthread_rwlock_unlock(v7);
    if (!a2)
      goto LABEL_13;
    if (Value)
      v4 = *Value;
    else
      v4 = 0;
  }
  *a2 = v4;
LABEL_13:
  if (Value)
    return Value[1];
  else
    return 0;
}

void sub_1CDF81F30(_Unwind_Exception *a1)
{
  pthread_rwlock_t *v1;

  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

__CFArray *DCSMACreateLocalDictionaryAssets_XPC()
{
  xpc_object_t v0;
  xpc_object_t v1;
  void *v2;
  __CFArray *value;
  __CFArray *Mutable;
  int64_t length;
  CFIndex v6;
  const UInt8 *bytes_ptr;
  const __CFData *v8;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex v12;
  const CFArrayCallBacks *v13;
  const __CFDictionary *ValueAtIndex;
  CFMutableDictionaryRef MutableCopy;

  v0 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v0, "command", "local_dictionary_assets");
  if (DCSXPCConnection__OnceToken != -1)
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  if (DCSXPCConnection__ServiceConnection
    && (v1 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)DCSXPCConnection__ServiceConnection, v0)) != 0)
  {
    v2 = v1;
    value = (__CFArray *)xpc_dictionary_get_value(v1, "result");
    Mutable = value;
    if (value)
    {
      length = xpc_data_get_length(value);
      if (length >= 1
        && (v6 = length,
            bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(Mutable),
            v8 = CFDataCreate(0, bytes_ptr, v6),
            v9 = (const __CFArray *)CFPropertyListCreateWithData(0, v8, 0, 0, 0),
            CFRelease(v8),
            v9)
        && (Count = CFArrayGetCount(v9), Count >= 1))
      {
        v11 = Count;
        Mutable = 0;
        v12 = 0;
        v13 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
        do
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, v12);
          MutableCopy = CFDictionaryCreateMutableCopy(0, 0, ValueAtIndex);
          if (!Mutable)
            Mutable = CFArrayCreateMutable(0, 0, v13);
          CFArrayAppendValue(Mutable, MutableCopy);
          CFRelease(MutableCopy);
          ++v12;
        }
        while (v11 != v12);
      }
      else
      {
        Mutable = 0;
      }
    }
    xpc_release(v2);
  }
  else
  {
    Mutable = 0;
  }
  xpc_release(v0);
  return Mutable;
}

void DCSMACreateDictionaryAssetsAsync_XPC(uint64_t a1)
{
  _xpc_connection_s *v2;
  xpc_object_t v3;
  void *v4;
  _QWORD handler[5];

  if (DCSXPCConnection__OnceToken != -1)
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  v2 = (_xpc_connection_s *)DCSXPCConnection__ServiceConnection;
  if (DCSXPCConnection__ServiceConnection)
  {
    v3 = xpc_dictionary_create(0, 0, 0);
    v4 = v3;
    if (a1)
    {
      xpc_dictionary_set_string(v3, "command", "server_dictionary_assets");
      if (DCSXPCQueue__OnceToken != -1)
        dispatch_once(&DCSXPCQueue__OnceToken, &__block_literal_global_34_0);
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 0x40000000;
      handler[2] = __DCSMACreateDictionaryAssetsAsync_XPC_block_invoke;
      handler[3] = &unk_1E8B578B0;
      handler[4] = a1;
      xpc_connection_send_message_with_reply(v2, v4, (dispatch_queue_t)DCSXPCQueue__XPCQueue, handler);
    }
    else
    {
      xpc_dictionary_set_string(v3, "command", "server_dictionary_assets_noreply");
      xpc_connection_send_message(v2, v4);
    }
    xpc_release(v4);
  }
  else if (a1)
  {
    (*(void (**)(uint64_t, _QWORD))(a1 + 16))(a1, 0);
  }
}

void DCSMADownloadDictionaryAsset_XPC(const __CFDictionary *a1, int a2)
{
  xpc_object_t v4;

  v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v4, "command", "download_dictionary_asset");
  _SetDictionaryAssetIDToMessage(v4, a1);
  if (a2)
    xpc_dictionary_set_BOOL(v4, "userInitiatedDownload", 1);
  if (DCSXPCConnection__OnceToken != -1)
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  if (DCSXPCConnection__ServiceConnection)
    xpc_connection_send_message((xpc_connection_t)DCSXPCConnection__ServiceConnection, v4);
  xpc_release(v4);
}

void _SetDictionaryAssetIDToMessage(void *a1, const __CFDictionary *a2)
{
  const __CFDictionary *v3;
  const __CFString *Value;
  char buffer[256];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v3 = (const __CFDictionary *)DCSMAGetAssetAttributes(a2);
  Value = (const __CFString *)CFDictionaryGetValue(v3, CFSTR("DictionaryIdentifier"));
  if (!Value)
    Value = (const __CFString *)CFDictionaryGetValue(v3, CFSTR("DictionaryPackageName"));
  CFStringGetCString(Value, buffer, 255, 0x8000100u);
  xpc_dictionary_set_string(a1, "dictionaryID", buffer);
}

void DCSMAPurgeDictionaryAsset_XPC(const __CFDictionary *a1)
{
  xpc_object_t v2;

  v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v2, "command", "purge_dictionary_asset");
  _SetDictionaryAssetIDToMessage(v2, a1);
  if (DCSXPCConnection__OnceToken != -1)
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  if (DCSXPCConnection__ServiceConnection)
    xpc_connection_send_message((xpc_connection_t)DCSXPCConnection__ServiceConnection, v2);
  xpc_release(v2);
}

CFURLRef DCSMACreateAssetInstalledURL_XPC(const __CFDictionary *a1)
{
  xpc_object_t v2;
  xpc_object_t v3;
  void *v4;
  const __CFURL *value;
  CFURLRef v6;
  const char *string_ptr;
  const __CFString *v8;

  v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v2, "command", "copy_path_dictionary_asset");
  _SetDictionaryAssetIDToMessage(v2, a1);
  if (DCSXPCConnection__OnceToken != -1)
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  if (DCSXPCConnection__ServiceConnection
    && (v3 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)DCSXPCConnection__ServiceConnection, v2)) != 0)
  {
    v4 = v3;
    value = (const __CFURL *)xpc_dictionary_get_value(v3, "result");
    v6 = value;
    if (value)
    {
      if (object_getClass(value) == (Class)MEMORY[0x1E0C81390])
      {
        string_ptr = xpc_string_get_string_ptr(v6);
        v8 = CFStringCreateWithCString(0, string_ptr, 0x8000100u);
        v6 = CFURLCreateWithFileSystemPath(0, v8, kCFURLPOSIXPathStyle, 1u);
        CFRelease(v8);
      }
      else
      {
        v6 = 0;
      }
    }
    xpc_release(v4);
  }
  else
  {
    v6 = 0;
  }
  xpc_release(v2);
  return v6;
}

int64_t DCSMAGetAssetState_XPC(const __CFDictionary *a1)
{
  xpc_object_t v2;
  xpc_object_t v3;
  void *v4;
  int64_t int64;

  v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v2, "command", "get_state_dictionary_asset");
  _SetDictionaryAssetIDToMessage(v2, a1);
  if (DCSXPCConnection__OnceToken != -1)
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  if (DCSXPCConnection__ServiceConnection
    && (v3 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)DCSXPCConnection__ServiceConnection, v2)) != 0)
  {
    v4 = v3;
    int64 = xpc_dictionary_get_int64(v3, "result");
    xpc_release(v4);
  }
  else
  {
    int64 = 1;
  }
  xpc_release(v2);
  return int64;
}

void DCSMAPrepareDefaultDictionaryAssets_XPC(const __CFArray *a1, const __CFArray *a2)
{
  xpc_object_t v4;
  CFIndex Count;
  xpc_object_t v6;
  CFIndex i;
  const __CFString *ValueAtIndex;
  const char *v9;
  char buffer[256];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v4, "command", "prepare_default_assets");
  if (a1)
    a2 = a1;
  Count = CFArrayGetCount(a2);
  v6 = xpc_array_create(0, 0);
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, i);
      CFStringGetCString(ValueAtIndex, buffer, 255, 0x8000100u);
      xpc_array_set_string(v6, 0xFFFFFFFFFFFFFFFFLL, buffer);
    }
  }
  if (a1)
    v9 = "dictionaryIDs";
  else
    v9 = "languageIDs";
  xpc_dictionary_set_value(v4, v9, v6);
  if (DCSXPCConnection__OnceToken != -1)
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  if (DCSXPCConnection__ServiceConnection)
    xpc_connection_send_message((xpc_connection_t)DCSXPCConnection__ServiceConnection, v4);
  xpc_release(v4);
}

void *DCSCopySharedPreferenceValue(const __CFString *a1, uint64_t a2, int64_t *a3)
{
  xpc_object_t v6;
  xpc_object_t v7;
  void *v8;
  xpc_object_t value;
  xpc_object_t v10;
  void *v11;
  int64_t length;
  CFIndex v13;
  const UInt8 *bytes_ptr;
  const __CFData *v15;
  char buffer[256];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a3)
    *a3 = 0;
  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v6, "command", "read_preference");
  CFStringGetCString(a1, buffer, 255, 0x8000100u);
  xpc_dictionary_set_string(v6, "key", buffer);
  xpc_dictionary_set_uint64(v6, "currentVersion", a2);
  xpc_dictionary_set_BOOL(v6, "checkVersion", a3 != 0);
  if (DCSXPCConnection__OnceToken != -1)
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  if (DCSXPCConnection__ServiceConnection
    && (v7 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)DCSXPCConnection__ServiceConnection, v6)) != 0)
  {
    v8 = v7;
    if (a3)
    {
      value = xpc_dictionary_get_value(v7, "savedVersion");
      if (value)
        *a3 = xpc_int64_get_value(value);
    }
    v10 = xpc_dictionary_get_value(v8, "value");
    v11 = v10;
    if (v10)
    {
      length = xpc_data_get_length(v10);
      if (length < 1)
      {
        v11 = 0;
      }
      else
      {
        v13 = length;
        bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v11);
        v15 = CFDataCreate(0, bytes_ptr, v13);
        v11 = (void *)CFPropertyListCreateWithData(0, v15, 0, 0, 0);
        CFRelease(v15);
      }
    }
    xpc_release(v8);
  }
  else
  {
    v11 = 0;
  }
  xpc_release(v6);
  return v11;
}

void DCSUpdateSharedPreferenceValue(const __CFString *a1, const void *a2)
{
  xpc_object_t v4;
  const __CFData *Data;
  const __CFData *v6;
  const UInt8 *BytePtr;
  size_t Length;
  char buffer[256];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v4, "command", "update_preference");
  if (a1)
  {
    CFStringGetCString(a1, buffer, 255, 0x8000100u);
    xpc_dictionary_set_string(v4, "key", buffer);
    Data = CFPropertyListCreateData(0, a2, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (Data)
    {
      v6 = Data;
      BytePtr = CFDataGetBytePtr(Data);
      Length = CFDataGetLength(v6);
      xpc_dictionary_set_data(v4, "value", BytePtr, Length);
      CFRelease(v6);
    }
  }
  if (DCSXPCConnection__OnceToken != -1)
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  if (DCSXPCConnection__ServiceConnection)
    xpc_connection_send_message((xpc_connection_t)DCSXPCConnection__ServiceConnection, v4);
  xpc_release(v4);
}

void DCSSynchronizeSharedPreference()
{
  xpc_object_t v0;

  v0 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v0, "command", "sync_preference");
  if (DCSXPCConnection__OnceToken != -1)
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  if (DCSXPCConnection__ServiceConnection)
    xpc_connection_send_message((xpc_connection_t)DCSXPCConnection__ServiceConnection, v0);
  xpc_release(v0);
}

void IDXPlugInAccessMethod::IDXPlugInAccessMethod(IDXPlugInAccessMethod *this, const __CFURL *a2, const __CFUUID *a3, CFTypeRef cf)
{
  CFTypeRef v7;

  *(_QWORD *)this = &unk_1E8B57488;
  v7 = CFRetain(cf);
  *(_QWORD *)this = &off_1E8B579A0;
  *((_QWORD *)this + 1) = v7;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 2) = CFPlugInCreate(0, a2);
  *((_QWORD *)this + 3) = CFRetain(a3);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 32), 0);
}

void sub_1CDF82DA8(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  const void *v4;

  *v1 = v2;
  v4 = (const void *)v1[1];
  if (v4)
    CFRelease(v4);
  _Unwind_Resume(exception_object);
}

void IDXPlugInAccessMethod::~IDXPlugInAccessMethod(IDXPlugInAccessMethod *this)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  const void *v5;

  *(_QWORD *)this = &off_1E8B579A0;
  v2 = *((_QWORD *)this + 12);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  v3 = (const void *)*((_QWORD *)this + 2);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 3);
  if (v4)
    CFRelease(v4);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32));
  *(_QWORD *)this = &unk_1E8B57488;
  v5 = (const void *)*((_QWORD *)this + 1);
  if (v5)
    CFRelease(v5);
}

{
  IDXPlugInAccessMethod::~IDXPlugInAccessMethod(this);
  JUMPOUT(0x1D17BC79CLL);
}

void sub_1CDF82E48(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  const void *v3;

  *v1 = &unk_1E8B57488;
  v3 = (const void *)v1[1];
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

void sub_1CDF82EAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10E1C40777B8806);
  _Unwind_Resume(a1);
}

BOOL IDXPlugInAccessMethod::queryInterface(IDXPlugInAccessMethod *this, CFUUIDBytes a2, void **a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 v7;
  void *v8;
  CFUUIDRef v9;
  CFUUIDRef v10;
  int v11;
  _BOOL8 v12;
  CFUUIDBytes v14;

  v4 = *(_QWORD *)&a2.byte8;
  v5 = *(_QWORD *)&a2.byte0;
  v6 = IDXPlugInAccessMethod::pluginInstance(this);
  v7 = v6 != 0;
  if (!v6)
  {
    if (!a3)
      return 0;
    v8 = 0;
    goto LABEL_7;
  }
  v8 = (void *)v6;
  *(_QWORD *)&v14.byte0 = v5;
  *(_QWORD *)&v14.byte8 = v4;
  v9 = CFUUIDCreateFromUUIDBytes(0, v14);
  v10 = CFUUIDGetConstantUUIDWithBytes(0, 0xA7u, 0xE7u, 0x9Eu, 0x44u, 0xCAu, 0x66u, 0x4Eu, 0xB0u, 0x88u, 0x56u, 0x8Cu, 0xDCu, 0x83u, 0x62u, 0x1Au, 0x80u);
  v11 = CFEqual(v9, v10);
  v12 = v11 != 0;
  CFRelease(v9);
  if (a3 && v11)
  {
LABEL_7:
    *a3 = v8;
    return v7;
  }
  return v12;
}

uint64_t IDXPlugInAccessMethod::pluginInstance(IDXPlugInAccessMethod *this)
{
  uint64_t result;
  char *v3;
  pthread_mutex_t *v4;
  const __CFUUID *v5;
  const __CFUUID *v6;
  void *v7;
  void *v8;
  void (*v9)(void *, _QWORD, _QWORD, char *);
  const __CFUUID *v10;
  CFUUIDBytes v11;

  v3 = (char *)this + 96;
  result = *((_QWORD *)this + 12);
  if (!result)
  {
    v4 = (pthread_mutex_t *)((char *)this + 32);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    if (!*((_QWORD *)this + 12))
    {
      v5 = (const __CFUUID *)*((_QWORD *)this + 3);
      v6 = CFUUIDGetConstantUUIDWithBytes(0, 0x80u, 0x60u, 0x58u, 5u, 0x30u, 0x24u, 0x40u, 0x39u, 0xA3u, 0x62u, 0x10u, 0x4Cu, 0xEEu, 0x36u, 0x19u, 0x62u);
      v7 = CFPlugInInstanceCreate(0, v5, v6);
      if (v7)
      {
        v8 = v7;
        v9 = *(void (**)(void *, _QWORD, _QWORD, char *))(*(_QWORD *)v7 + 8);
        v10 = CFUUIDGetConstantUUIDWithBytes(0, 0xA7u, 0xE7u, 0x9Eu, 0x44u, 0xCAu, 0x66u, 0x4Eu, 0xB0u, 0x88u, 0x56u, 0x8Cu, 0xDCu, 0x83u, 0x62u, 0x1Au, 0x80u);
        v11 = CFUUIDGetUUIDBytes(v10);
        v9(v8, *(_QWORD *)&v11.byte0, *(_QWORD *)&v11.byte8, v3);
        (*(void (**)(void *))(*(_QWORD *)v8 + 24))(v8);
      }
    }
    pthread_mutex_unlock(v4);
    return *(_QWORD *)v3;
  }
  return result;
}

uint64_t IDXPlugInAccessMethod::retain(IDXPlugInAccessMethod *this)
{
  uint64_t result;

  result = IDXPlugInAccessMethod::pluginInstance(this);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  return result;
}

uint64_t IDXPlugInAccessMethod::release(IDXPlugInAccessMethod *this)
{
  uint64_t result;

  result = IDXPlugInAccessMethod::pluginInstance(this);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t IDXPlugInAccessMethod::openIndexFile(IDXPlugInAccessMethod *this, const __CFURL *a2, const __CFDictionary *a3)
{
  uint64_t result;

  result = IDXPlugInAccessMethod::pluginInstance(this);
  if (result)
    return (*(uint64_t (**)(uint64_t, const __CFURL *, const __CFDictionary *))(*(_QWORD *)result + 32))(result, a2, a3);
  return result;
}

uint64_t IDXPlugInAccessMethod::openIndexFile(IDXPlugInAccessMethod *this, IDXIndexInfo *a2)
{
  return (*(uint64_t (**)(IDXPlugInAccessMethod *, _QWORD, _QWORD))(*(_QWORD *)this + 40))(this, *(_QWORD *)a2, *((_QWORD *)a2 + 1));
}

uint64_t IDXPlugInAccessMethod::closeIndexFile(IDXPlugInAccessMethod *this, void *a2)
{
  uint64_t v3;

  v3 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(uint64_t (**)(uint64_t, void *))(*(_QWORD *)v3 + 40))(v3, a2);
}

BOOL IDXPlugInAccessMethod::setSearchCharacters(IDXPlugInAccessMethod *this, void *a2, const unsigned __int16 *a3, uint64_t a4, const __CFString *a5)
{
  uint64_t v9;

  v9 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(unsigned int (**)(uint64_t, void *, const unsigned __int16 *, uint64_t, const __CFString *))(*(_QWORD *)v9 + 48))(v9, a2, a3, a4, a5) != 0;
}

uint64_t IDXPlugInAccessMethod::getMatchDataPtr(IDXPlugInAccessMethod *this, void *a2, uint64_t a3, const unsigned __int8 **a4, uint64_t *a5)
{
  uint64_t v9;

  v9 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(uint64_t (**)(uint64_t, void *, uint64_t, const unsigned __int8 **, uint64_t *))(*(_QWORD *)v9 + 56))(v9, a2, a3, a4, a5);
}

uint64_t IDXPlugInAccessMethod::getMatchData(IDXPlugInAccessMethod *this, void *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, CFRange **a6, uint64_t *a7)
{
  uint64_t v13;

  v13 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t, unsigned __int8 *, CFRange **, uint64_t *))(*(_QWORD *)v13 + 64))(v13, a2, a3, a4, a5, a6, a7);
}

BOOL IDXPlugInAccessMethod::containsMatchData(IDXPlugInAccessMethod *this, void *a2, unsigned __int8 *a3)
{
  uint64_t v5;

  v5 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(unsigned int (**)(uint64_t, void *, unsigned __int8 *))(*(_QWORD *)v5 + 72))(v5, a2, a3) != 0;
}

uint64_t IDXPlugInAccessMethod::getDataPtrByID(IDXPlugInAccessMethod *this, void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7;

  v7 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t *))(*(_QWORD *)v7 + 80))(v7, a2, a3, a4);
}

uint64_t IDXPlugInAccessMethod::getDataByID(IDXPlugInAccessMethod *this, void *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  uint64_t v9;

  v9 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t, unsigned __int8 *))(*(_QWORD *)v9 + 88))(v9, a2, a3, a4, a5);
}

BOOL IDXPlugInAccessMethod::supportDataPtr(IDXPlugInAccessMethod *this, void *a2)
{
  uint64_t v3;

  v3 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(unsigned int (**)(uint64_t, void *))(*(_QWORD *)v3 + 96))(v3, a2) != 0;
}

BOOL IDXPlugInAccessMethod::addRecord(IDXPlugInAccessMethod *this, void *a2, const unsigned __int16 *a3, uint64_t a4, const unsigned __int8 *a5, uint64_t a6, unint64_t *a7)
{
  uint64_t v13;

  v13 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(unsigned int (**)(uint64_t, void *, const unsigned __int16 *, uint64_t, const unsigned __int8 *, uint64_t, unint64_t *))(*(_QWORD *)v13 + 104))(v13, a2, a3, a4, a5, a6, a7) != 0;
}

BOOL IDXPlugInAccessMethod::deleteRecord(IDXPlugInAccessMethod *this, void *a2, const unsigned __int16 *a3, uint64_t a4, const unsigned __int8 *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13;

  v13 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(unsigned int (**)(uint64_t, void *, const unsigned __int16 *, uint64_t, const unsigned __int8 *, uint64_t, uint64_t))(*(_QWORD *)v13 + 112))(v13, a2, a3, a4, a5, a6, a7) != 0;
}

BOOL IDXPlugInAccessMethod::buildWithRecords(IDXPlugInAccessMethod *this, void *a2, const __CFArray *a3, const __CFArray *a4, unint64_t *a5)
{
  uint64_t v9;

  v9 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(unsigned int (**)(uint64_t, void *, const __CFArray *, const __CFArray *, unint64_t *))(*(_QWORD *)v9 + 120))(v9, a2, a3, a4, a5) != 0;
}

uint64_t IDXPlugInAccessMethod::createIndexFile(IDXPlugInAccessMethod *this, const __CFURL *a2, const __CFDictionary *a3)
{
  uint64_t result;

  result = IDXPlugInAccessMethod::pluginInstance(this);
  if (result)
    return (*(unsigned int (**)(uint64_t, const __CFURL *, const __CFDictionary *))(*(_QWORD *)result + 128))(result, a2, a3) != 0;
  return result;
}

uint64_t IDXIndexGetTypeID()
{
  pthread_once(&_IDXIndexClassID(void)::once_control, (void (*)(void))_IDXIndexInitialize);
  return _IDXIndexID;
}

__CFArray *IDXCopyIndexNames(const __CFURL *a1, int a2)
{
  IDXDictionaryManager *v4;
  CFDictionaryRef *v5;
  CFDictionaryRef v6;
  CFDictionaryRef v7;
  __CFArray *Mutable;
  uint64_t i;
  const __CFDictionary **v10;
  const __CFDictionary *v11;
  CFIndex capacity;

  v4 = (IDXDictionaryManager *)SyncSingleton<IDXDictionaryManager>::instance();
  v5 = (CFDictionaryRef *)IDXDictionaryManager::dictionary(v4, a1);
  if (!v5)
    return 0;
  LODWORD(capacity) = 0;
  v6 = IDXDictionaryPackage::indexInfoList(v5, (int *)&capacity);
  if (!v6 || (int)capacity < 1)
    return 0;
  v7 = v6;
  Mutable = CFArrayCreateMutable(0, capacity, MEMORY[0x1E0C9B378]);
  if ((int)capacity >= 1)
  {
    for (i = 0; i < (int)capacity; ++i)
    {
      v10 = (const __CFDictionary **)*((_QWORD *)v7 + i);
      if (!a2)
      {
        v11 = IDXIndexInfo::indexName(*((IDXIndexInfo **)v7 + i));
        if (v11)
          goto LABEL_9;
        v10 += 4;
      }
      v11 = *v10;
LABEL_9:
      CFArrayAppendValue(Mutable, v11);
    }
  }
  return Mutable;
}

uint64_t SyncSingleton<IDXDictionaryManager>::instance()
{
  DCSDictionary *v0;

  if (!SyncSingleton<IDXDictionaryManager>::_instantiated)
  {
    pthread_mutex_lock(&SyncSingleton<IDXDictionaryManager>::_mutex);
    if (!SyncSingleton<IDXDictionaryManager>::_instantiated)
    {
      v0 = (DCSDictionary *)operator new();
      DCSDictionary::startGlobalDictionariesEnvironment(v0);
      SyncSingleton<IDXDictionaryManager>::_instance = (uint64_t)v0;
      SyncSingleton<IDXDictionaryManager>::_instantiated = 1;
    }
    pthread_mutex_unlock(&SyncSingleton<IDXDictionaryManager>::_mutex);
  }
  return SyncSingleton<IDXDictionaryManager>::_instance;
}

void sub_1CDF836D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0xC400A2AC0F1);
  _Unwind_Resume(a1);
}

_QWORD *IDXCreateIndexObject(uint64_t a1, const __CFURL *a2, const __CFString *a3)
{
  IDXDictionaryManager *v5;
  CFDictionaryRef *v6;
  IDXDictionaryPackage *v7;
  IDXIndexInfo *v8;
  IDXIndexInfo *v9;
  IDXAccessMethodManager *v10;
  const __CFString *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t Instance;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  unsigned __int8 v20;
  uint64_t v21;
  _BOOL4 v22;

  if (!a2)
    return 0;
  v5 = (IDXDictionaryManager *)SyncSingleton<IDXDictionaryManager>::instance();
  v6 = (CFDictionaryRef *)IDXDictionaryManager::dictionary(v5, a2);
  if (!v6)
    return 0;
  v7 = (IDXDictionaryPackage *)v6;
  v8 = IDXDictionaryPackage::retainIndex(v6, a3);
  if (!v8)
    return 0;
  v9 = v8;
  v10 = (IDXAccessMethodManager *)SyncSingleton<IDXAccessMethodManager>::instance();
  v11 = (const __CFString *)IDXIndexInfo::accessMethodName(v9);
  v12 = IDXAccessMethodManager::accessMethod(v10, v11, v7);
  if (!v12 || (v13 = v12, (v14 = (*(uint64_t (**)(_QWORD *, IDXIndexInfo *))(*v12 + 48))(v12, v9)) == 0))
  {
LABEL_9:
    IDXDictionaryPackage::releaseIndex(v7, v9);
    return 0;
  }
  v15 = v14;
  pthread_once(&_IDXIndexClassID(void)::once_control, (void (*)(void))_IDXIndexInitialize);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    (*(void (**)(_QWORD *, uint64_t))(*v13 + 56))(v13, v15);
    goto LABEL_9;
  }
  v17 = (_QWORD *)Instance;
  v18 = (_QWORD *)IDXIndexInfo::dataFields(v9);
  v19 = malloc_type_malloc((32 * (v18[1] + *v18 + v18[2])) | 0x10, 0x2131404EuLL);
  v17[2] = v13;
  v17[3] = v7;
  v17[4] = v9;
  v17[5] = v15;
  v17[8] = v19;
  v20 = IDXIndexInfo::dataSizeLength(v9);
  v21 = IDXIndexInfo::fixedDataSize(v9);
  v22 = IDXIndexInfo::bigEndian(v9);
  v17[6] = GetPreConfiguredGetDataSizeFunction(v20, v21, v22, v17 + 7);
  return v17;
}

uint64_t SyncSingleton<IDXAccessMethodManager>::instance()
{
  IDXAccessMethodManager *v0;

  if (!SyncSingleton<IDXAccessMethodManager>::_instantiated)
  {
    pthread_mutex_lock(&SyncSingleton<IDXAccessMethodManager>::_mutex);
    if (!SyncSingleton<IDXAccessMethodManager>::_instantiated)
    {
      v0 = (IDXAccessMethodManager *)operator new();
      IDXAccessMethodManager::IDXAccessMethodManager(v0);
      SyncSingleton<IDXAccessMethodManager>::_instance = (uint64_t)v0;
      SyncSingleton<IDXAccessMethodManager>::_instantiated = 1;
    }
    pthread_mutex_unlock(&SyncSingleton<IDXAccessMethodManager>::_mutex);
  }
  return SyncSingleton<IDXAccessMethodManager>::_instance;
}

void sub_1CDF838EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x60C40902580DDLL);
  _Unwind_Resume(a1);
}

uint64_t IDXSetSearchCharacters(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 16) + 64))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40), a2, a3, a4);
}

uint64_t IDXSetSearchString(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  UInt8 *v5;
  uint64_t v6;
  unint64_t v8;

  v8 = 0;
  v5 = CreateCharactersFromString(a2, 0x100u, &v8);
  v6 = (*(uint64_t (**)(_QWORD, _QWORD, UInt8 *, unint64_t, uint64_t))(**(_QWORD **)(a1 + 16) + 64))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40), v5, v8, a3);
  if (v5)
    free(v5);
  return v6;
}

void IDXPerformSearch(uint64_t a1, void (*a2)(uint64_t, char *, uint64_t, uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  char **v10;
  char *v11;
  char *v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD v19[128];
  _OWORD v20[64];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v6 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 16) + 112))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40));
  if ((_DWORD)v6)
  {
    memset(v20, 0, 512);
    v7 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _OWORD *, _QWORD *))(**(_QWORD **)(a1 + 16) + 72))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40), 128, v20, v19);
    if (v7)
    {
      v8 = v7;
      do
      {
        if (v8 >= 1)
        {
          v9 = v19;
          v10 = (char **)v20;
          do
          {
            v12 = *v10++;
            v11 = v12;
            v13 = *v9++;
            a2(a1, v11, v13, 0, a3);
            --v8;
          }
          while (v8);
        }
        v8 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _OWORD *, _QWORD *))(**(_QWORD **)(a1 + 16) + 72))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40), 128, v20, v19);
      }
      while (v8);
    }
  }
  else
  {
    *(_QWORD *)&v20[0] = 0x20000;
    v14 = 1;
    do
    {
      MEMORY[0x1E0C80A78](v6);
      v16 = (char *)v19 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
      if (!v14)
        v16 = (char *)malloc_type_malloc(*(size_t *)&v20[0], 0x333A2437uLL);
      v19[0] = 0;
      while (1)
      {
        v6 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, char *, _QWORD *, _OWORD *))(**(_QWORD **)(a1 + 16) + 80))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40), 0, *(_QWORD *)&v20[0], v16, v19, v20);
        v17 = v6;
        if (!v6)
          break;
        if (v6 >= 1)
        {
          v18 = 0;
          do
          {
            a2(a1, &v16[*(_QWORD *)(v19[0] + v18)], *(_QWORD *)(v19[0] + v18 + 8), 1, a3);
            v18 += 16;
            --v17;
          }
          while (v17);
        }
      }
      if (!v14)
        free(v16);
      v14 = *(_QWORD *)&v20[0] <= 0x20000;
    }
    while (*(_QWORD *)&v20[0]);
  }
}

uint64_t IDXSupportDataPtr(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 16) + 112))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40));
}

uint64_t IDXGetMatchDataPtr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 16) + 72))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40), a2, a3, a4);
}

uint64_t IDXGetMatchData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  if (a6)
    *a6 = a3;
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 16) + 80))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40), a2, a3, a4, a5);
}

uint64_t IDXContainsMatchData(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 88))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40), a2);
}

uint64_t IDXGetDataPtrByID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 16) + 96))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40), a2, a3);
}

uint64_t IDXGetDataByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 16) + 104))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40), a2, a3, a4);
}

CFIndex IDXSetRequestFields(uint64_t a1, const __CFArray *a2)
{
  uint64_t *v3;
  CFIndex result;
  uint64_t v5;
  uint64_t v6;
  CFIndex v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFIndex v11;
  const __CFString *ValueAtIndex;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _BOOL4 v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  CFIndex v21;
  const __CFString *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  _BOOL4 v26;
  uint64_t v27;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  CFIndex *v32;
  int v33;
  _BOOL4 v34;
  CFIndex v35;
  const __CFString *v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  IDXIndexInfo *v41;

  v41 = *(IDXIndexInfo **)(a1 + 32);
  v3 = (uint64_t *)IDXIndexInfo::dataFields(v41);
  result = CFArrayGetCount(a2);
  v5 = result;
  v38 = *v3;
  v40 = v3;
  if (*v3 < 1)
  {
    v8 = 0;
    v7 = 0;
    v6 = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    do
    {
      v10 = v3[3];
      if (v5 < 1)
      {
        v11 = 0;
      }
      else
      {
        v11 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v11);
          result = CFStringCompare(ValueAtIndex, *(CFStringRef *)(v10 + 24 * v9), 0);
          if (!result)
            break;
          if (v5 == ++v11)
            goto LABEL_11;
        }
        v13 = v8 + 1;
        v14 = (_QWORD *)(*(_QWORD *)(a1 + 64) + 32 * v8);
        v14[5] = v11 + 1;
        v15 = *(_QWORD *)(v10 + 24 * v9 + 16);
        v16 = IDXIndexInfo::bigEndian(v41);
        result = (CFIndex)GetPreConfiguredGetDataSizeFunction(0, v15, v16, v14 + 4);
        v14[2] = v7;
        v14[3] = result;
        v3 = v40;
        ++v6;
        v8 = v13;
        v7 = 0;
      }
      if (v11 == v5)
LABEL_11:
        v7 += *(_QWORD *)(v10 + 24 * v9 + 16);
      ++v9;
    }
    while (v9 != v38);
  }
  v17 = v3[1];
  if (v17 >= 1 && v6 < v5)
  {
    v19 = 0;
    v39 = v3[1];
    do
    {
      v20 = v3[4];
      if (v5 < 1)
      {
        v21 = 0;
      }
      else
      {
        v21 = 0;
        while (1)
        {
          v22 = (const __CFString *)CFArrayGetValueAtIndex(a2, v21);
          result = CFStringCompare(v22, *(CFStringRef *)(v20 + 16 * v19), 0);
          if (!result)
            break;
          if (v5 == ++v21)
          {
            v17 = v39;
            goto LABEL_29;
          }
        }
        v23 = v8 + 1;
        v24 = (_QWORD *)(*(_QWORD *)(a1 + 64) + 32 * v8);
        v24[5] = v21 + 1;
        v25 = *(_QWORD *)(v20 + 16 * v19 + 8);
        v26 = IDXIndexInfo::bigEndian(v41);
        result = (CFIndex)GetPreConfiguredGetDataSizeFunction(0, v25, v26, v24 + 4);
        v24[2] = v7;
        v24[3] = result;
        v17 = v39;
        v3 = v40;
        ++v6;
        v8 = v23;
        v7 = 0;
      }
      if (v21 == v5)
LABEL_29:
        v7 += *(_QWORD *)(v20 + 16 * v19 + 8);
      ++v19;
    }
    while (v19 < v17 && v6 < v5);
  }
  v27 = v3[2];
  if (v27 >= 1 && v6 < v5)
  {
    v29 = 0;
    do
    {
      v30 = v3[5] + 16 * v29;
      v31 = *(_QWORD *)(a1 + 64) + 32 * v8;
      *(_QWORD *)(v31 + 40) = 0;
      v32 = (CFIndex *)(v31 + 40);
      v33 = *(unsigned __int8 *)(v30 + 8);
      v34 = IDXIndexInfo::bigEndian(v41);
      result = (CFIndex)GetPreConfiguredGetDataSizeFunction(v33, 0, v34, v32 - 1);
      *(v32 - 3) = v7;
      *(v32 - 2) = result;
      if (v5 >= 1)
      {
        v35 = 0;
        while (1)
        {
          v36 = (const __CFString *)CFArrayGetValueAtIndex(a2, v35);
          result = CFStringCompare(v36, *(CFStringRef *)v30, 0);
          ++v35;
          if (!result)
            break;
          if (v5 == v35)
            goto LABEL_44;
        }
        *v32 = v35;
        ++v6;
      }
LABEL_44:
      v3 = v40;
      ++v8;
      if (++v29 >= v27)
        break;
      v7 = 0;
    }
    while (v6 < v5);
  }
  v37 = *(uint64_t **)(a1 + 64);
  *v37 = v5;
  v37[1] = v8;
  return result;
}

uint64_t IDXGetFieldDataPtrs(uint64_t result, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 v20;

  v7 = *(uint64_t **)(result + 64);
  v8 = *v7;
  if (*v7 >= 1)
  {
    v9 = a4;
    v10 = a5;
    do
    {
      *v9++ = 0;
      *v10++ = 0;
      --v8;
    }
    while (v8);
  }
  v11 = v7[1];
  if (v11 >= 1 && a3 >= 1)
  {
    v13 = a2 + a3;
    v20 = 0;
    v14 = v7 + 5;
    v15 = 1;
    do
    {
      v16 = a2 + *(v14 - 3);
      result = ((uint64_t (*)(_QWORD, uint64_t, unsigned __int8 *))*(v14 - 2))(*(v14 - 1), v16, &v20);
      v17 = v16 + v20;
      if (*v14)
      {
        if (result <= 0)
          v18 = 0;
        else
          v18 = v16 + v20;
        v19 = 8 * *v14 - 8;
        *(_QWORD *)((char *)a4 + v19) = v18;
        *(_QWORD *)((char *)a5 + v19) = result;
      }
      if (v15 >= v11)
        break;
      v14 += 4;
      a2 = v17 + result;
      ++v15;
    }
    while (v17 + result < v13);
  }
  return result;
}

__CFData *IDXCreateFlattenData(uint64_t a1, const __CFDictionary *a2)
{
  IDXIndexInfo *v3;
  uint64_t *v4;
  _BOOL4 v5;
  __CFData *Mutable;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const __CFString *Value;
  uint64_t v12;
  uint64_t v13;
  const __CFAllocator *v14;
  uint64_t v15;
  uint64_t v16;
  const __CFString *v17;
  uint64_t v18;
  UInt8 *v19;
  const __CFString *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const __CFString *v25;

  v3 = *(IDXIndexInfo **)(a1 + 32);
  v4 = (uint64_t *)IDXIndexInfo::dataFields(v3);
  v5 = IDXIndexInfo::bigEndian(v3);
  Mutable = CFDataCreateMutable(0, 0);
  v7 = *v4;
  if (*v4 >= 1)
  {
    v8 = 0;
    do
    {
      v9 = v4[3];
      if (CFDictionaryContainsKey(a2, *(const void **)(v9 + v8)))
      {
        v10 = v9 + v8;
        Value = (const __CFString *)CFDictionaryGetValue(a2, *(const void **)v10);
        AppendFieldDataToData(Mutable, Value, *(unsigned __int8 *)(v10 + 16), 1, v5);
      }
      else
      {
        AppendNumberToData(Mutable, 0, *(unsigned __int8 *)(v9 + v8 + 16), v5);
      }
      v8 += 24;
      --v7;
    }
    while (v7);
  }
  v12 = v4[1];
  if (v12 >= 1)
  {
    v13 = 0;
    v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
    do
    {
      v15 = v4[4];
      if (CFDictionaryContainsKey(a2, *(const void **)(v15 + v13)))
      {
        v16 = v15 + v13;
        v17 = (const __CFString *)CFDictionaryGetValue(a2, *(const void **)v16);
        AppendFieldDataToData(Mutable, v17, *(unsigned __int8 *)(v16 + 8), 1, v5);
      }
      else
      {
        v18 = v15 + v13;
        v19 = (UInt8 *)malloc_type_calloc(1uLL, *(_QWORD *)(v15 + v13 + 8), 0x8E2BA5EDuLL);
        v20 = (const __CFString *)CFDataCreateWithBytesNoCopy(0, v19, *(_QWORD *)(v18 + 8), v14);
        AppendFieldDataToData(Mutable, v20, *(unsigned __int8 *)(v18 + 8), 1, v5);
        CFRelease(v20);
        free(v19);
      }
      v13 += 16;
      --v12;
    }
    while (v12);
  }
  v21 = v4[2];
  if (v21 >= 1)
  {
    v22 = 0;
    do
    {
      v23 = v4[5];
      if (CFDictionaryContainsKey(a2, *(const void **)(v23 + v22)))
      {
        v24 = v23 + v22;
        v25 = (const __CFString *)CFDictionaryGetValue(a2, *(const void **)v24);
        AppendFieldDataToData(Mutable, v25, *(unsigned __int8 *)(v24 + 8), 0, v5);
      }
      else
      {
        AppendNumberToData(Mutable, 0, *(unsigned __int8 *)(v23 + v22 + 8), v5);
      }
      v22 += 16;
      --v21;
    }
    while (v21);
  }
  return Mutable;
}

uint64_t IDXAddRecord(uint64_t a1, const __CFString *a2, const __CFData *a3, uint64_t a4)
{
  UInt8 *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v14;
  unint64_t v16;

  if (!a2 && IDXIndexInfo::keyMatchingMethods(*(IDXIndexInfo **)(a1 + 32)))
    return 0;
  v16 = 0;
  v8 = CreateCharactersFromString(a2, 0x100u, &v16);
  v9 = *(_QWORD *)(a1 + 16);
  v10 = *(_QWORD *)(a1 + 40);
  v11 = v16;
  BytePtr = CFDataGetBytePtr(a3);
  Length = CFDataGetLength(a3);
  v14 = (*(uint64_t (**)(uint64_t, uint64_t, UInt8 *, unint64_t, const UInt8 *, CFIndex, uint64_t))(*(_QWORD *)v9 + 120))(v9, v10, v8, v11, BytePtr, Length, a4);
  free(v8);
  return v14;
}

uint64_t IDXDeleteRecord(uint64_t a1, const __CFString *a2, const __CFData *a3, uint64_t a4)
{
  UInt8 *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v14;
  unint64_t v16;

  if (!a2 && IDXIndexInfo::keyMatchingMethods(*(IDXIndexInfo **)(a1 + 32)))
    return 0;
  v16 = 0;
  v8 = CreateCharactersFromString(a2, 0x100u, &v16);
  v9 = *(_QWORD *)(a1 + 16);
  v10 = *(_QWORD *)(a1 + 40);
  v11 = v16;
  BytePtr = CFDataGetBytePtr(a3);
  Length = CFDataGetLength(a3);
  v14 = (*(uint64_t (**)(uint64_t, uint64_t, UInt8 *, unint64_t, const UInt8 *, CFIndex, uint64_t))(*(_QWORD *)v9 + 128))(v9, v10, v8, v11, BytePtr, Length, a4);
  free(v8);
  return v14;
}

uint64_t IDXBuildIndexWithRecords(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 || !IDXIndexInfo::keyMatchingMethods(*(IDXIndexInfo **)(a1 + 32)))
    return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 16) + 136))(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40), a2, a3, a4);
  else
    return 0;
}

uint64_t IDXCreateDictionaryPackage(const __CFURL *a1, const __CFString *a2)
{
  IDXDictionaryManager *v4;
  IDXAccessMethodManager *v5;
  uint64_t result;
  const __CFDictionary *v7;
  char *FileSystemPath;
  int v9;
  const __CFURL *DictionaryComponentURL;
  std::__fs::filesystem::path *v11;
  const __CFNumber *Value;
  const __CFURL *v13;
  const __CFURL *v14;
  __CFWriteStream *v15;
  __CFWriteStream *v16;
  CFIndex v17;
  _BOOL4 v18;
  CFDictionaryRef *v19;
  CFAbsoluteTime *v20;
  CFDictionaryRef v21;
  CFDictionaryRef v22;
  uint64_t v23;
  IDXIndexInfo *v24;
  const __CFString *v25;
  _QWORD *v26;
  int v27;
  uint64_t valuePtr;

  v4 = (IDXDictionaryManager *)SyncSingleton<IDXDictionaryManager>::instance();
  v5 = (IDXAccessMethodManager *)SyncSingleton<IDXAccessMethodManager>::instance();
  result = (uint64_t)IDXDictionaryManager::templateProperty(v4, a2);
  if (result)
  {
    v7 = (const __CFDictionary *)result;
    FileSystemPath = CreateFileSystemPath(a1);
    v9 = mkdir(FileSystemPath, 0x1FFu);
    free(FileSystemPath);
    if (v9)
      return 0;
    DictionaryComponentURL = CreateDictionaryComponentURL(a1, 0);
    v11 = (std::__fs::filesystem::path *)CreateFileSystemPath(DictionaryComponentURL);
    CFRelease(DictionaryComponentURL);
    LODWORD(DictionaryComponentURL) = mkdir((const char *)v11, 0x1FFu);
    free(v11);
    if ((_DWORD)DictionaryComponentURL)
      return 0;
    valuePtr = 1;
    Value = (const __CFNumber *)CFDictionaryGetValue(v7, CFSTR("IDXDictionaryVersion"));
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
      if (valuePtr >= 3)
      {
        v13 = CreateDictionaryComponentURL(a1, (uint64_t)CFSTR("Resources"));
        v11 = (std::__fs::filesystem::path *)CreateFileSystemPath(v13);
        CFRelease(v13);
        LODWORD(v13) = mkdir((const char *)v11, 0x1FFu);
        free(v11);
        if ((_DWORD)v13)
          return 0;
      }
    }
    v14 = CreateDictionaryComponentURL(a1, (uint64_t)CFSTR("Info.plist"));
    v15 = CFWriteStreamCreateWithFile(0, v14);
    if (v15)
    {
      v16 = v15;
      if (CFWriteStreamOpen(v15))
      {
        v17 = CFPropertyListWriteToStream(v7, v16, kCFPropertyListBinaryFormat_v1_0, 0);
        CFWriteStreamClose(v16);
        v18 = v17 > 0;
      }
      else
      {
        v18 = 0;
      }
      CFRelease(v16);
      if (!v14)
        goto LABEL_15;
    }
    else
    {
      v18 = 0;
      if (!v14)
      {
LABEL_15:
        if (v18)
        {
          v19 = (CFDictionaryRef *)IDXDictionaryManager::dictionary(v4, a1);
          if (v19)
          {
            v20 = (CFAbsoluteTime *)v19;
            v27 = 0;
            v21 = IDXDictionaryPackage::indexInfoList(v19, &v27);
            if (v21)
            {
              if (v27 < 1)
                return 1;
              v22 = v21;
              v23 = 0;
              while (1)
              {
                v24 = (IDXIndexInfo *)*((_QWORD *)v22 + v23);
                v25 = (const __CFString *)IDXIndexInfo::accessMethodName(v24);
                v26 = IDXAccessMethodManager::accessMethod(v5, v25, 0);
                if (!v26
                  || ((*(uint64_t (**)(_QWORD *, _QWORD, _QWORD))(*v26 + 144))(v26, *(_QWORD *)v24, *((_QWORD *)v24 + 1)) & 1) == 0)
                {
                  break;
                }
                if (++v23 >= v27)
                  return 1;
              }
            }
            IDXDictionaryManager::remove(v4, v20);
          }
        }
        DeleteDirectoryAtPath(v11);
        return 0;
      }
    }
    CFRelease(v14);
    goto LABEL_15;
  }
  return result;
}

_QWORD *IDXQueryAccessMethodInterface(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  IDXAccessMethodManager *v8;
  _QWORD *result;

  v8 = (IDXAccessMethodManager *)SyncSingleton<IDXAccessMethodManager>::instance();
  result = IDXAccessMethodManager::accessMethod(v8, a1, 0);
  if (result)
    return (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*result + 16))(result, a2, a3, a4);
  return result;
}

uint64_t _IDXIndexInitialize(void)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  _IDXIndexID = result;
  return result;
}

void _IDXIndexFinalize(const void *a1)
{
  void *v2;

  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)a1 + 2) + 56))(*((_QWORD *)a1 + 2), *((_QWORD *)a1 + 5));
  IDXDictionaryPackage::releaseIndex(*((IDXDictionaryPackage **)a1 + 3), *((IDXIndexInfo **)a1 + 4));
  v2 = (void *)*((_QWORD *)a1 + 8);
  if (v2)
    free(v2);
}

BOOL _IDXIndexEqual(const void *a1, const void *a2)
{
  return a1 == a2;
}

CFStringRef _IDXIndexCopyFormattingDesc(CFURLRef **a1, const __CFDictionary *a2)
{
  const __CFAllocator *v4;
  CFStringRef PathComponent;
  CFStringRef v6;
  CFStringRef v7;

  v4 = CFGetAllocator(a1);
  PathComponent = CFURLCopyLastPathComponent(*a1[4]);
  if (!PathComponent)
    return CFStringCreateWithFormat(v4, a2, CFSTR("<#invalid index>"));
  v6 = PathComponent;
  v7 = CFStringCreateWithFormat(v4, a2, CFSTR("<%@>"), PathComponent);
  CFRelease(v6);
  return v7;
}

CFStringRef _IDXIndexCopyDebugDesc(CFURLRef **a1)
{
  const __CFAllocator *v2;
  CFURLRef *v3;
  CFStringRef v4;
  CFURLRef v5;
  CFStringRef v6;
  uint64_t v7;
  CFStringRef v8;

  v2 = CFGetAllocator(a1);
  v3 = a1[4];
  v4 = CFURLCopyFileSystemPath(*v3, kCFURLPOSIXPathStyle);
  v5 = a1[2][1];
  if (!v4)
    return CFStringCreateWithFormat(v2, 0, CFSTR("<IDXIndexRef %p>{access method = %@, #invalid index}"), a1, v5);
  v6 = v4;
  v7 = IDXIndexInfo::openCount((IDXIndexInfo *)v3);
  v8 = CFStringCreateWithFormat(v2, 0, CFSTR("<IDXIndexRef %p>{access method = %@, index = %@, open# = %d}"), a1, v5, v6, v7);
  CFRelease(v6);
  return v8;
}

_OWORD *mtrie_open(uint64_t a1, uint64_t a2, unsigned int *a3, unint64_t a4)
{
  _OWORD *v8;
  _OWORD *v9;
  _QWORD *v10;
  marisa::Agent *v11;
  unsigned int v12;
  uint64_t v13;

  v8 = malloc_type_malloc(0x48uLL, 0x10B004015DDB5A3uLL);
  v9 = v8;
  if (v8)
  {
    v8[1] = 0u;
    v8[2] = 0u;
    *((_QWORD *)v8 + 6) = 0;
    *((_QWORD *)v8 + 7) = a1;
    *((_QWORD *)v8 + 8) = a2;
    *(_QWORD *)v8 = a3;
    *((_QWORD *)v8 + 1) = a4;
    v10 = (_QWORD *)operator new();
    marisa::Trie::Trie(v10);
    *((_QWORD *)v9 + 4) = v10;
    v11 = (marisa::Agent *)operator new();
    marisa::Agent::Agent(v11);
    *((_QWORD *)v9 + 5) = v11;
    if (a3)
    {
      if (a4 >= 0x18)
      {
        v12 = a3[2];
        if (v12)
        {
          v13 = *(_QWORD *)v9;
          *((_QWORD *)v9 + 2) = *(_QWORD *)v9 + a3[1];
          *((_DWORD *)v9 + 6) = v12;
          *((_DWORD *)v9 + 12) = a3[5];
          marisa::Trie::map(*((marisa::grimoire::trie::LoudsTrie ***)v9 + 4), (const void *)(v13 + a3[3]), a3[4]);
        }
      }
    }
  }
  return v9;
}

void sub_1CDF84A90(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x1070C40FE8A955FLL);
  _Unwind_Resume(a1);
}

marisa::grimoire::trie::LoudsTrie *mtrie_exact_match_search(uint64_t a1, const char *a2, uint64_t a3)
{
  marisa::grimoire::trie::LoudsTrie *result;
  uint64_t v5;

  result = 0;
  if (a2 && a3)
  {
    if (!*(_DWORD *)(a1 + 24))
      return 0;
    marisa::Agent::set_query(*(_QWORD **)(a1 + 40), a2, a3);
    result = marisa::Trie::lookup(*(marisa::grimoire::trie::LoudsTrie ***)(a1 + 32), *(marisa::Agent **)(a1 + 40));
    if (!(_DWORD)result)
      return result;
    v5 = *(unsigned int *)(*(_QWORD *)(a1 + 40) + 36);
    if (*(_DWORD *)(a1 + 24) > v5)
      return (marisa::grimoire::trie::LoudsTrie *)*(unsigned int *)(*(_QWORD *)(a1 + 16) + 4 * v5);
    else
      return 0;
  }
  return result;
}

uint64_t mtrie_build(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  const void *p_p;
  uint64_t v23;
  FILE *v24;
  const char *v25;
  size_t v26;
  void *__p;
  uint64_t v29;
  unsigned __int8 v30;
  _BYTE v31[16];
  uint64_t v32;
  size_t v33[3];
  uint64_t v34[3];
  uint64_t v35[8];

  if (!a2)
    return 0;
  marisa::Keyset::Keyset((marisa::Keyset *)v33);
  v10 = 0;
  do
  {
    marisa::Keyset::push_back(v33, *(const char **)(a3 + 8 * v10), *(_QWORD *)(a4 + 8 * v10), 1.0);
    ++v10;
  }
  while (a2 != v10);
  marisa::Trie::build(*(marisa::grimoire::trie::LoudsTrie ***)(a1 + 32), (marisa::Keyset *)v33, 0x21203u);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v31);
  marisa::write(&v32, *(_QWORD *)(a1 + 32));
  std::stringbuf::str();
  v11 = 4 * a2 + 28;
  if ((a2 & 1) == 0)
    v11 = 4 * a2 + 24;
  v12 = v30;
  if ((v30 & 0x80u) != 0)
    v12 = v29;
  v13 = v12 + v11;
  v14 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(a1 + 56))(*(_QWORD *)a1, v12 + v11, *(_QWORD *)(a1 + 64));
  v15 = v14;
  v16 = 0;
  *(_QWORD *)a1 = v14;
  *(_QWORD *)(a1 + 8) = v13;
  *(_QWORD *)v14 = 0x1800000001;
  v17 = 4 * a2 + 28;
  if ((a2 & 1) == 0)
    v17 = 4 * a2 + 24;
  *(_DWORD *)(v14 + 8) = a2;
  *(_DWORD *)(v14 + 12) = v17;
  v18 = v30;
  if ((v30 & 0x80u) != 0)
    v18 = v29;
  *(_DWORD *)(v14 + 16) = v18;
  *(_DWORD *)(v14 + 20) = v13;
  *(_QWORD *)(a1 + 16) = v14 + 24;
  *(_DWORD *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 48) = v13;
  v19 = *(_QWORD *)(a1 + 40);
  do
  {
    marisa::Agent::set_query((_QWORD *)v19, *(const char **)(a3 + 8 * v16), *(_QWORD *)(a4 + 8 * v16));
    if ((marisa::Trie::lookup(*(marisa::grimoire::trie::LoudsTrie ***)(a1 + 32), *(marisa::Agent **)(a1 + 40)) & 1) == 0)
    {
      v24 = (FILE *)*MEMORY[0x1E0C80C10];
      v25 = "trie->_marisa_trie->lookup failed.\n";
      v26 = 35;
LABEL_25:
      fwrite(v25, v26, 1uLL, v24);
      v23 = 0xFFFFFFFFLL;
      goto LABEL_26;
    }
    v19 = *(_QWORD *)(a1 + 40);
    v20 = *(unsigned int *)(v19 + 36);
    if (v20 >= a2)
    {
      v24 = (FILE *)*MEMORY[0x1E0C80C10];
      v25 = "wrong entry ID.\n";
      v26 = 16;
      goto LABEL_25;
    }
    v21 = *(_QWORD *)(a1 + 16);
    *(_DWORD *)(v21 + 4 * v20) = *(_DWORD *)(a5 + 4 * v16++);
  }
  while (a2 != v16);
  if ((a2 & 1) != 0)
    *(_DWORD *)(v21 + 4 * a2) = 0;
  if ((v30 & 0x80u) == 0)
    p_p = &__p;
  else
    p_p = __p;
  memcpy((void *)(*(_QWORD *)a1 + *(unsigned int *)(v15 + 12)), p_p, *(unsigned int *)(v15 + 16));
  v23 = 0;
LABEL_26:
  if ((char)v30 < 0)
    operator delete(__p);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)v31);
  marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array(v35);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(v34);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)v33);
  return v23;
}

void sub_1CDF84D7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  uint64_t v15;

  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)(v15 - 192));
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  std::ios_base *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = MEMORY[0x1E0DE4FD0];
  v3 = MEMORY[0x1E0DE4FD0] + 104;
  *(_QWORD *)(a1 + 128) = MEMORY[0x1E0DE4FD0] + 104;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  v4 = a1 + 16;
  v5 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + *(_QWORD *)(v6 - 24)) = v7;
  *(_QWORD *)(a1 + 8) = 0;
  v8 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  v9 = v5[4];
  v10 = v5[5];
  *(_QWORD *)(a1 + 16) = v9;
  *(_QWORD *)(v4 + *(_QWORD *)(v9 - 24)) = v10;
  v11 = v5[1];
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + *(_QWORD *)(v11 - 24)) = v5[6];
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 128) = v3;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 24) = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_1CDF84EF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::iostream::~basic_iostream();
  MEMORY[0x1D17BC754](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = MEMORY[0x1E0DE4F50];
  v3 = *MEMORY[0x1E0DE4F50];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F50];
  v4 = *(_QWORD *)(v2 + 72);
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 64);
  *(_QWORD *)(a1 + 24) = MEMORY[0x1E0DE4FB8] + 16;
  *(_QWORD *)(a1 + 16) = v4;
  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D17BC754](a1 + 128);
  return a1;
}

void sub_1CDF84FAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC754](v1 + 128);
  _Unwind_Resume(a1);
}

void marisa::Keyset::~Keyset(marisa::Keyset *this)
{
  marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array((uint64_t *)this + 6);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)this + 3);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)this);
}

void sub_1CDF8500C(_Unwind_Exception *a1)
{
  uint64_t *v1;

  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(v1);
  _Unwind_Resume(a1);
}

uint64_t mtrie_data(unsigned int *a1, _QWORD *a2)
{
  if (a2)
    *a2 = a1[12];
  return *(_QWORD *)a1;
}

void mtrie_close(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  if (a1)
  {
    v2 = a1[4];
    if (v2)
    {
      marisa::Trie::~Trie((marisa::Trie *)a1[4]);
      MEMORY[0x1D17BC79C](v2, 0x20C4093837F09);
    }
    v3 = a1[5];
    if (v3)
    {
      marisa::Agent::~Agent((marisa::Agent *)a1[5]);
      MEMORY[0x1D17BC79C](v3, 0x1070C40FE8A955FLL);
    }
    free(a1);
  }
}

void sub_1CDF850C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x1070C40FE8A955FLL);
  _Unwind_Resume(a1);
}

uint64_t *marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *a1;
  if (*a1)
  {
    v5 = *(_QWORD *)(v2 - 8);
    v4 = v2 - 8;
    v3 = v5;
    if (v5)
    {
      v6 = 8 * v3;
      do
      {
        v7 = *(_QWORD *)(v4 + v6);
        if (v7)
          MEMORY[0x1D17BC778](v7, 0x1050C80717B85FCLL);
        v6 -= 8;
      }
      while (v6);
    }
    MEMORY[0x1D17BC778](v4 - 8, 0x20C8093837F09);
  }
  return a1;
}

uint64_t *marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *a1;
  if (*a1)
  {
    v5 = *(_QWORD *)(v2 - 8);
    v4 = v2 - 8;
    v3 = v5;
    if (v5)
    {
      v6 = 8 * v3;
      do
      {
        v7 = *(_QWORD *)(v4 + v6);
        if (v7)
          MEMORY[0x1D17BC778](v7, 0x1000C8077774924);
        v6 -= 8;
      }
      while (v6);
    }
    MEMORY[0x1D17BC778](v4 - 8, 0x10C80436913F5);
  }
  return a1;
}

UInt8 *CreateCharactersFromString(const __CFString *a1, CFStringEncoding a2, unint64_t *a3)
{
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  UInt8 *v8;
  CFIndex usedBufLen;
  CFRange v11;

  if (a1)
  {
    Length = CFStringGetLength(a1);
    usedBufLen = 0;
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, a2);
    v8 = (UInt8 *)malloc_type_malloc(MaximumSizeForEncoding, 0xFCECAB9AuLL);
    v11.location = 0;
    v11.length = Length;
    CFStringGetBytes(a1, v11, a2, 0, 0, v8, MaximumSizeForEncoding, &usedBufLen);
    if (a3)
      *a3 = (unint64_t)usedBufLen >> 1;
  }
  else
  {
    v8 = 0;
    if (a3)
      *a3 = 0;
  }
  return v8;
}

char *CreateFileSystemPath(const __CFURL *a1)
{
  const __CFURL *v1;
  const __CFString *v2;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  char *v5;

  v1 = CFURLCopyAbsoluteURL(a1);
  v2 = CFURLCopyFileSystemPath(v1, kCFURLPOSIXPathStyle);
  CFRelease(v1);
  if (!v2)
    return 0;
  Length = CFStringGetLength(v2);
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  v5 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0x31523115uLL);
  LODWORD(MaximumSizeForEncoding) = CFStringGetFileSystemRepresentation(v2, v5, MaximumSizeForEncoding);
  CFRelease(v2);
  if (!(_DWORD)MaximumSizeForEncoding)
  {
    free(v5);
    return 0;
  }
  return v5;
}

CFURLRef CreateDictionaryComponentURL(const __CFURL *a1, uint64_t a2)
{
  const __CFString *v4;
  const __CFString *v5;
  CFURLRef v6;

  if (a2)
    v4 = CFStringCreateWithFormat(0, 0, CFSTR("Contents/%@"), a2);
  else
    v4 = CFStringCreateWithFormat(0, 0, CFSTR("Contents"));
  v5 = v4;
  v6 = CFURLCreateCopyAppendingPathComponent(0, a1, v4, a2 == 0);
  CFRelease(v5);
  return v6;
}

CFBundleRef CreateDictionaryBundleFromComponentURL(const __CFURL *a1)
{
  const __CFString *PathComponent;
  const __CFURL *v3;
  CFComparisonResult v4;
  const __CFURL *v5;
  CFBundleRef v6;

  PathComponent = CFURLCopyLastPathComponent(a1);
  if (CFStringCompare(PathComponent, CFSTR("/"), 0))
  {
    v3 = a1;
    while (1)
    {
      v4 = CFStringCompare(PathComponent, CFSTR("Contents"), 0);
      CFRelease(PathComponent);
      v5 = CFURLCreateCopyDeletingLastPathComponent(0, v3);
      if (v4 == kCFCompareEqualTo)
        break;
      if (v3 != a1)
        CFRelease(v3);
      PathComponent = CFURLCopyLastPathComponent(v5);
      v3 = v5;
      if (CFStringCompare(PathComponent, CFSTR("/"), 0) == kCFCompareEqualTo)
      {
        v6 = 0;
        v3 = v5;
        goto LABEL_10;
      }
    }
    v6 = CFBundleCreate(0, v5);
    PathComponent = (const __CFString *)v5;
  }
  else
  {
    v6 = 0;
    v3 = a1;
  }
LABEL_10:
  CFRelease(PathComponent);
  if (v3 != a1)
    CFRelease(v3);
  return v6;
}

DIR *DeleteDirectoryAtPath(const std::__fs::filesystem::path *a1)
{
  std::error_code *v2;
  DIR *result;
  DIR *v4;
  size_t v5;
  char *v6;
  size_t v7;
  char *v8;
  dirent *v9;
  const char *d_name;
  stat v11;

  memset(&v11, 0, sizeof(v11));
  if (lstat((const char *)a1, &v11) < 0)
    return 0;
  if ((v11.st_mode & 0xF000) != 0x4000)
    return (DIR *)!remove(a1, v2);
  result = opendir((const char *)a1);
  if (result)
  {
    v4 = result;
    v5 = strlen((const char *)a1) + 256;
    v6 = (char *)malloc_type_malloc(v5, 0xABB69ADBuLL);
    strlcpy(v6, (const char *)a1, v5);
    v7 = strlen((const char *)a1);
    *(_WORD *)&v6[v7] = 47;
    v8 = &v6[v7 + 1];
    while (1)
    {
      v9 = readdir(v4);
      if (!v9)
        break;
      d_name = v9->d_name;
      if (strcmp(v9->d_name, "."))
      {
        if (strcmp(d_name, ".."))
        {
          strlcpy(v8, d_name, 0x100uLL);
          if (!DeleteDirectoryAtPath(v6))
          {
            free(v6);
            closedir(v4);
            return 0;
          }
        }
      }
    }
    free(v6);
    closedir(v4);
    return (DIR *)(rmdir((const char *)a1) >= 0);
  }
  return result;
}

DIR *DeleteDirectoryAtURL(const __CFURL *a1)
{
  std::__fs::filesystem::path *FileSystemPath;
  DIR *v2;

  FileSystemPath = (std::__fs::filesystem::path *)CreateFileSystemPath(a1);
  v2 = DeleteDirectoryAtPath(FileSystemPath);
  free(FileSystemPath);
  return v2;
}

void (*GetPreConfiguredGetDataSizeFunction(int a1, uint64_t a2, int a3, _QWORD *a4))(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  void (*result)(uint64_t, uint64_t, _BYTE *);
  void (*v6)(uint64_t, uint64_t, _BYTE *);
  void (*v7)(uint64_t, uint64_t, _BYTE *);

  result = (void (*)(uint64_t, uint64_t, _BYTE *))_GetDataSize_8bit;
  switch(a1)
  {
    case 0:
      if (a4)
        *a4 = a2;
      return _GetDataSize_FixedLength;
    case 1:
      return result;
    case 2:
      v6 = (void (*)(uint64_t, uint64_t, _BYTE *))_GetDataSize_16bitBigEndian;
      v7 = (void (*)(uint64_t, uint64_t, _BYTE *))_GetDataSize_16bitLittleEndian;
      goto LABEL_9;
    case 4:
      v6 = (void (*)(uint64_t, uint64_t, _BYTE *))_GetDataSize_32bitBigEndian;
      v7 = (void (*)(uint64_t, uint64_t, _BYTE *))_GetDataSize_32bitLittleEndian;
      goto LABEL_9;
    case 8:
      v6 = (void (*)(uint64_t, uint64_t, _BYTE *))_GetDataSize_64bitBigEndian;
      v7 = (void (*)(uint64_t, uint64_t, _BYTE *))_GetDataSize_64bitLittleEndian;
LABEL_9:
      if (a3)
        result = v6;
      else
        result = v7;
      break;
    default:
      result = (void (*)(uint64_t, uint64_t, _BYTE *))_GetDataSize_Invalid;
      break;
  }
  return result;
}

void _GetDataSize_FixedLength(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  *a3 = 0;
}

uint64_t _GetDataSize_8bit(uint64_t a1, unsigned __int8 *a2, _BYTE *a3)
{
  *a3 = 1;
  return *a2;
}

uint64_t _GetDataSize_16bitBigEndian(uint64_t a1, unsigned __int16 *a2, _BYTE *a3)
{
  *a3 = 2;
  return bswap32(*a2) >> 16;
}

uint64_t _GetDataSize_16bitLittleEndian(uint64_t a1, unsigned __int16 *a2, _BYTE *a3)
{
  *a3 = 2;
  return *a2;
}

uint64_t _GetDataSize_32bitBigEndian(uint64_t a1, unsigned int *a2, _BYTE *a3)
{
  *a3 = 4;
  return bswap32(*a2);
}

uint64_t _GetDataSize_32bitLittleEndian(uint64_t a1, unsigned int *a2, _BYTE *a3)
{
  *a3 = 4;
  return *a2;
}

unint64_t _GetDataSize_64bitBigEndian(uint64_t a1, unint64_t *a2, _BYTE *a3)
{
  *a3 = 8;
  return bswap64(*a2);
}

uint64_t _GetDataSize_64bitLittleEndian(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  *a3 = 8;
  return *(_QWORD *)a2;
}

uint64_t _GetDataSize_Invalid(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  *a3 = 0;
  return 0;
}

_BYTE *CreateSizeBytesEmbededData(const void *a1, size_t a2, unsigned int a3, int a4, size_t *a5)
{
  size_t v10;
  _BYTE *v11;

  if (a3)
  {
    v10 = a2 + a3;
    v11 = malloc_type_malloc(v10, 0x76EC069AuLL);
    memcpy(&v11[a3], a1, a2);
    *a5 = v10;
    EmbedSizeBytesToBuffer(v11, a2, a3, a4);
    return v11;
  }
  else
  {
    *a5 = a2;
  }
  return a1;
}

_BYTE *EmbedSizeBytesToBuffer(_BYTE *result, unint64_t a2, int a3, int a4)
{
  switch(a3)
  {
    case 1:
      *result = a2;
      break;
    case 2:
      if (a4)
        *(_WORD *)result = bswap32(a2) >> 16;
      else
        *(_WORD *)result = a2;
      break;
    case 4:
      if (a4)
        *(_DWORD *)result = bswap32(a2);
      else
        *(_DWORD *)result = a2;
      break;
    case 8:
      if (a4)
        *(_QWORD *)result = bswap64(a2);
      else
        *(_QWORD *)result = a2;
      break;
    default:
      return result;
  }
  return result;
}

void AppendFieldDataToData(__CFData *a1, const __CFString *cf, int a3, int a4, int a5)
{
  CFTypeID v10;
  unsigned int v11;
  unsigned int v12;
  __CFData *v13;
  CFIndex v14;
  CFTypeID v15;
  CFIndex Length;
  uint64_t v17;
  CFStringEncoding v18;
  UInt8 *v19;
  CFTypeID v20;
  CFIndex v21;
  const UInt8 *BytePtr;
  unint64_t v23;
  unint64_t v24;
  double valuePtr;
  CFRange v26;

  v10 = CFGetTypeID(cf);
  if (v10 == CFNumberGetTypeID())
  {
    if (CFNumberIsFloatType((CFNumberRef)cf))
    {
      if (a3 == 8)
      {
        valuePtr = 0.0;
        CFNumberGetValue((CFNumberRef)cf, kCFNumberFloat64Type, &valuePtr);
        v23 = (unint64_t)valuePtr;
        v24 = bswap64((unint64_t)valuePtr);
        if (a5)
          v23 = v24;
        valuePtr = (double)v23;
        v13 = a1;
        v14 = 8;
      }
      else
      {
        if (a3 != 4)
          return;
        LODWORD(valuePtr) = 0;
        CFNumberGetValue((CFNumberRef)cf, kCFNumberFloat32Type, &valuePtr);
        v11 = *(float *)&valuePtr;
        v12 = bswap32(*(float *)&valuePtr);
        if (a5)
          v11 = v12;
        *(float *)&valuePtr = (float)v11;
        v13 = a1;
        v14 = 4;
      }
      CFDataAppendBytes(v13, (const UInt8 *)&valuePtr, v14);
    }
    else
    {
      valuePtr = 0.0;
      CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt64Type, &valuePtr);
      AppendNumberToData(a1, *(unint64_t *)&valuePtr, a3, a5);
    }
  }
  else
  {
    v15 = CFGetTypeID(cf);
    if (v15 == CFStringGetTypeID())
    {
      Length = CFStringGetLength(cf);
      v17 = 2 * Length;
      valuePtr = 0.0;
      if (!a4)
        AppendNumberToData(a1, v17, a3, a5);
      if (a5)
        v18 = 268435712;
      else
        v18 = 335544576;
      v19 = (UInt8 *)malloc_type_malloc(v17, 0x8F3C58B0uLL);
      v26.location = 0;
      v26.length = Length;
      CFStringGetBytes(cf, v26, v18, 0, 0, v19, v17, (CFIndex *)&valuePtr);
      CFDataAppendBytes(a1, v19, *(CFIndex *)&valuePtr);
      free(v19);
    }
    else
    {
      v20 = CFGetTypeID(cf);
      if (v20 == CFDataGetTypeID())
      {
        v21 = CFDataGetLength((CFDataRef)cf);
        if (!a4)
          AppendNumberToData(a1, v21, a3, a5);
        BytePtr = CFDataGetBytePtr((CFDataRef)cf);
        CFDataAppendBytes(a1, BytePtr, v21);
      }
    }
  }
}

void AppendNumberToData(__CFData *a1, unint64_t a2, int a3, int a4)
{
  const UInt8 *v4;
  CFIndex v5;
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  unsigned int v10;
  __int16 v11;
  char v12;

  switch(a3)
  {
    case 1:
      v12 = a2;
      v4 = (const UInt8 *)&v12;
      v5 = 1;
      goto LABEL_12;
    case 2:
      v6 = bswap32(a2) >> 16;
      if (!a4)
        LOWORD(v6) = a2;
      v11 = v6;
      v4 = (const UInt8 *)&v11;
      v5 = 2;
      goto LABEL_12;
    case 4:
      v7 = bswap32(a2);
      if (!a4)
        v7 = a2;
      v10 = v7;
      v4 = (const UInt8 *)&v10;
      v5 = 4;
      goto LABEL_12;
    case 8:
      v8 = bswap64(a2);
      if (!a4)
        v8 = a2;
      v9 = v8;
      v4 = (const UInt8 *)&v9;
      v5 = 8;
LABEL_12:
      CFDataAppendBytes(a1, v4, v5);
      break;
    default:
      return;
  }
}

void WriteLogFile(CFStringRef format, ...)
{
  CFStringRef v1;
  CFStringRef v2;
  __CFDateFormatter *v3;
  CFAbsoluteTime Current;
  CFStringRef StringWithAbsoluteTime;
  uint64_t v6;
  const __CFString *v7;
  const __CFURL *v8;
  const __CFURL *v9;
  const __CFString *v10;
  int v11;
  int v12;
  size_t v13;
  char buffer[512];
  uint64_t v15;
  va_list va;

  va_start(va, format);
  v15 = *MEMORY[0x1E0C80C00];
  v1 = CFStringCreateWithFormatAndArguments(0, 0, format, va);
  if (v1)
  {
    v2 = v1;
    v3 = CFDateFormatterCreate(0, 0, kCFDateFormatterShortStyle, kCFDateFormatterMediumStyle);
    Current = CFAbsoluteTimeGetCurrent();
    StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(0, v3, Current);
    v6 = getpid();
    v7 = CFStringCreateWithFormat(0, 0, CFSTR("%@ [%d] %@\n"), StringWithAbsoluteTime, v6, v2);
    CFRelease(v2);
    CFRelease(v3);
    CFRelease(StringWithAbsoluteTime);
    if (v7)
    {
      v8 = (const __CFURL *)CFCopyHomeDirectoryURLForUser();
      v9 = CFURLCreateCopyAppendingPathComponent(0, v8, CFSTR("Library/Logs/IndexedSearchLog.txt"), 0);
      v10 = CFURLCopyFileSystemPath(v9, kCFURLPOSIXPathStyle);
      CFStringGetCString(v10, buffer, 512, 0x8000100u);
      CFRelease(v8);
      CFRelease(v9);
      CFRelease(v10);
      v11 = open(buffer, 522, 438);
      if (v11 != -1)
      {
        v12 = v11;
        CFStringGetCString(v7, buffer, 512, 0x8000100u);
        v13 = strlen(buffer);
        write(v12, buffer, v13);
        close(v12);
      }
      CFRelease(v7);
    }
  }
}

void HeapAccessContext::HeapAccessContext(HeapAccessContext *this, IDXIndexInfo *a2)
{
  uint64_t v4;
  unsigned __int8 v5;
  uint64_t v6;
  _BOOL4 v7;
  void (*DataSizeFunction)(uint64_t, uint64_t, _BYTE *);
  const __CFDictionary *v9;
  int v10;
  uint64_t v11;
  void (*v12)(uint64_t, uint64_t, _BYTE *);
  uint64_t v13;
  const __CFDictionary *v14;
  unint64_t v15;
  const __CFDictionary *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  int64x2_t v22;
  uint64x2_t v23;
  int8x16_t v24;
  uint64x2_t v25;
  int64x2_t v26;
  uint64x2_t v27;
  int8x16_t v28;
  int8x16_t v29;
  uint64_t v30;
  unint64_t v31;
  int64x2_t v32;
  uint64x2_t v33;
  int8x16_t v34;
  uint64x2_t v35;
  int64x2_t v36;
  uint64x2_t v37;
  int8x16_t v38;
  int8x16_t v39;
  unint64_t valuePtr;

  v4 = IDXAccessContext::IDXAccessContext((uint64_t)this, (uint64_t)a2);
  *(_QWORD *)v4 = &off_1E8B57B70;
  *(_QWORD *)(v4 + 24) = 0;
  *((_BYTE *)this + 32) = IDXIndexInfo::fixedDataSize(*(IDXIndexInfo **)(v4 + 8)) != 0;
  *((_BYTE *)this + 33) = IDXIndexInfo::writable(*((IDXIndexInfo **)this + 1));
  *((_BYTE *)this + 34) = IDXIndexInfo::bigEndian(a2);
  v5 = IDXIndexInfo::dataSizeLength(a2);
  v6 = IDXIndexInfo::fixedDataSize(a2);
  v7 = IDXIndexInfo::bigEndian(a2);
  DataSizeFunction = GetPreConfiguredGetDataSizeFunction(v5, v6, v7, (_QWORD *)this + 17);
  *((_WORD *)this + 18) = 0;
  *((_QWORD *)this + 16) = DataSizeFunction;
  v9 = IDXIndexInfo::optionalProperty(a2, CFSTR("HeapDataCompressionType"));
  if (v9)
    CFNumberGetValue(v9, kCFNumberSInt16Type, (char *)this + 36);
  v10 = *((__int16 *)this + 18);
  *((_BYTE *)this + 35) = *((_WORD *)this + 18) != 0;
  *((_BYTE *)this + 38) = v10 > 3;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  if ((v10 & 0xFFFE) == 2)
  {
    *((_QWORD *)this + 11) = *((_QWORD *)this + 16);
    v11 = IDXIndexInfo::dataSizeLength(a2);
    v12 = GetPreConfiguredGetDataSizeFunction(((_DWORD)v11 << (v11 < 4)), 0, *((unsigned __int8 *)this + 34), 0);
    v13 = 0x2000;
    if (*((_WORD *)this + 18) == 2)
      v13 = 0x8000;
    *((_QWORD *)this + 8) = v13;
    *((_QWORD *)this + 16) = v12;
    v14 = IDXIndexInfo::optionalProperty(a2, CFSTR("HeapDataCompressionBlockSize"));
    if (v14)
      CFNumberGetValue(v14, kCFNumberCFIndexType, (char *)this + 64);
    if (*((_WORD *)this + 18) == 2)
      v15 = 0xFFFFFFFFLL;
    else
      v15 = 0xFFFFLL;
    valuePtr = v15;
    v16 = IDXIndexInfo::optionalProperty(a2, CFSTR("HeapDataCompressionMaxBlockCount"));
    if (v16)
    {
      CFNumberGetValue(v16, kCFNumberLongLongType, &valuePtr);
      v15 = valuePtr;
    }
    if (*((_WORD *)this + 18) == 2)
      v17 = 64;
    else
      v17 = 32;
    v18 = vcvtpd_s64_f64(log2((double)v15));
    v19 = v17 - v18;
    *((_QWORD *)this + 12) = 0;
    v20 = v18 - 1;
    if (v18 < 1)
    {
      v30 = 0;
    }
    else
    {
      v21 = (v18 + 1) & 0xFFFFFFFFFFFFFFFELL;
      v22 = (int64x2_t)xmmword_1CDFA7EA0;
      v23 = (uint64x2_t)vdupq_n_s64(v20);
      v24 = 0uLL;
      v25 = (uint64x2_t)vdupq_n_s64(1uLL);
      v26 = vdupq_n_s64(2uLL);
      do
      {
        v27 = (uint64x2_t)v22;
        v28 = v24;
        v24 = vorrq_s8(v24, (int8x16_t)vshlq_u64(v25, (uint64x2_t)v22));
        v22 = vaddq_s64(v22, v26);
        v21 -= 2;
      }
      while (v21);
      v29 = vbslq_s8((int8x16_t)vcgtq_u64(v27, v23), v28, v24);
      *(int8x8_t *)v29.i8 = vorr_s8(*(int8x8_t *)v29.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL));
      *((_QWORD *)this + 12) = v29.i64[0];
      v30 = v29.i64[0];
    }
    *((_QWORD *)this + 14) = 0;
    if (v19 >= 1)
    {
      v31 = (v19 + 1) & 0xFFFFFFFFFFFFFFFELL;
      v32 = (int64x2_t)xmmword_1CDFA7EA0;
      v33 = (uint64x2_t)vdupq_n_s64(v19 - 1);
      v34 = 0uLL;
      v35 = (uint64x2_t)vdupq_n_s64(1uLL);
      v36 = vdupq_n_s64(2uLL);
      do
      {
        v37 = (uint64x2_t)v32;
        v38 = v34;
        v34 = vorrq_s8(v34, (int8x16_t)vshlq_u64(v35, (uint64x2_t)v32));
        v32 = vaddq_s64(v32, v36);
        v31 -= 2;
      }
      while (v31);
      v39 = vbslq_s8((int8x16_t)vcgtq_u64(v37, v33), v38, v34);
      *((int8x8_t *)this + 14) = vorr_s8(*(int8x8_t *)v39.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL));
    }
    *((_QWORD *)this + 13) = v30 << v19;
    *((_BYTE *)this + 120) = v19;
  }
  *((_BYTE *)this + 121) = 0;
}

void sub_1CDF86014(_Unwind_Exception *a1)
{
  IDXAccessContext *v1;

  IDXAccessContext::~IDXAccessContext(v1);
  _Unwind_Resume(a1);
}

void HeapAccessContext::~HeapAccessContext(HeapAccessContext *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E8B57B70;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
    free(v2);
  IDXAccessContext::~IDXAccessContext(this);
}

{
  HeapAccessContext::~HeapAccessContext(this);
  JUMPOUT(0x1D17BC79CLL);
}

void sub_1CDF860B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F1C409CAD4C71);
  _Unwind_Resume(a1);
}

uint64_t HeapAccessContext::getDataPtrByID(HeapAccessContext *this, unint64_t a2, uint64_t *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 v12;

  v4 = *((unsigned __int16 *)this + 18);
  if ((v4 & 0xFFFE) == 2)
    a2 = (*((_QWORD *)this + 13) & a2) >> *((_BYTE *)this + 120);
  v5 = *((_QWORD *)this + 3);
  if (v4 != 3 && *((_BYTE *)this + 32) == 0)
  {
    v8 = (_DWORD *)(*(_QWORD *)(v5 + 16) + a2);
    if (!*v8)
    {
      v10 = 0;
      v9 = 0;
      if (!a3)
        return v10;
      goto LABEL_11;
    }
    v7 = (uint64_t)(v8 + 1);
  }
  else
  {
    v7 = *(_QWORD *)(v5 + 16) + (a2 - 1) * *(unsigned int *)(v5 + 36) + 8;
  }
  v12 = 0;
  v9 = (*((uint64_t (**)(_QWORD, uint64_t, unsigned __int8 *))this + 16))(*((_QWORD *)this + 17), v7, &v12);
  v10 = v7 + v12;
  if (a3)
LABEL_11:
    *a3 = v9;
  return v10;
}

uint64_t HeapAccessContext::getDataByID(HeapAccessContext *this, uint64_t a2, int64_t a3, unsigned __int8 *a4)
{
  unsigned int v6;
  uint64_t v8;
  Bytef *v9;
  int64_t v10;
  uLong v11;
  int v12;
  void *v13;
  uint64_t v14;
  uLong v15;
  uLongf destLen;
  unsigned __int8 v18;
  uLong sourceLen;

  v6 = a2;
  sourceLen = 0;
  v8 = (*(uint64_t (**)(HeapAccessContext *, uint64_t, uLong *))(*(_QWORD *)this + 48))(this, a2, &sourceLen);
  v18 = 0;
  if (!v8)
    return 0;
  v9 = (Bytef *)v8;
  if (*((_BYTE *)this + 121) || *((_BYTE *)this + 35))
  {
    v10 = (*((uint64_t (**)(_QWORD, uint64_t, unsigned __int8 *))this + 16))(0, v8, &v18);
    v11 = sourceLen - v18;
    sourceLen = v11;
    v9 += v18;
  }
  else
  {
    v11 = sourceLen;
    v10 = sourceLen;
  }
  v12 = *((unsigned __int16 *)this + 18);
  if ((v12 & 0xFFFE) == 2)
  {
    if (v10 > *((_QWORD *)this + 7))
    {
      v13 = (void *)*((_QWORD *)this + 6);
      if (v13)
        free(v13);
      *((_QWORD *)this + 6) = malloc_type_malloc(v10, 0x433828E1uLL);
      *((_QWORD *)this + 7) = v10;
    }
    if (v9 != *((Bytef **)this + 9))
    {
      destLen = v10;
      uncompress(*((Bytef **)this + 6), &destLen, v9, sourceLen);
      *((_QWORD *)this + 9) = v9;
    }
    v14 = *((_QWORD *)this + 6) + (v6 & *((_DWORD *)this + 28));
    v15 = (*((uint64_t (**)(_QWORD, uint64_t, unsigned __int8 *))this + 11))(0, v14, &v18);
    sourceLen = v15;
    v9 = (Bytef *)(v14 + v18);
    if (*((_BYTE *)this + 121))
    {
      v10 = (*((uint64_t (**)(_QWORD, Bytef *, unsigned __int8 *))this + 11))(0, v9, &v18);
      v11 = sourceLen - v18;
      sourceLen = v11;
      v9 += v18;
    }
    else
    {
      v11 = v15;
      v10 = v15;
    }
    v12 = *((unsigned __int16 *)this + 18);
  }
  if (v12 == 1)
  {
    if (v10 <= a3)
    {
      destLen = a3;
      uncompress(a4, &destLen, v9, v11);
    }
  }
  else if (v10 <= a3)
  {
    memcpy(a4, v9, v11);
  }
  if (*((_BYTE *)this + 121) && v10 <= a3)
    free(v9);
  return v10;
}

BOOL HeapAccessContext::addRecord(HeapAccessContext *this, const unsigned __int16 *a2, uint64_t a3, unsigned __int8 *a4, size_t a5, unint64_t *a6)
{
  unsigned __int8 *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  const Bytef *v15;
  Bytef *v16;
  Bytef *v17;
  Bytef *v18;
  unint64_t v19;
  unint64_t v20;
  Bytef *CompressedData;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _DWORD *v36;
  _DWORD *v37;
  uint64_t v38;
  int v39;
  int v40;
  _DWORD *v41;
  unint64_t v42;
  unint64_t v43;
  unsigned int v44;
  uint64_t v45;
  int v46;
  _DWORD *v47;
  unint64_t v48;
  unint64_t v49;
  unsigned int v50;
  unint64_t v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  _DWORD *v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  unint64_t v65;
  uLongf destLen;
  uLong sourceLen;
  uLong v68;
  unsigned __int8 v69;
  unsigned __int8 v70;
  uint64_t v71;
  size_t __len;

  __len = a5;
  if (!*((_BYTE *)this + 33))
    return 0;
  v71 = 0;
  v70 = 0;
  (*((void (**)(_QWORD, uint64_t *, unsigned __int8 *))this + 16))(*((_QWORD *)this + 17), &v71, &v70);
  if ((*((_WORD *)this + 18) & 0xFFFE) != 2)
  {
    if (*((_BYTE *)this + 35))
    {
      CompressedData = HeapAccessContext::createCompressedData(this, a4, __len, v70, *((unsigned __int8 *)this + 121), (uint64_t *)&__len);
    }
    else
    {
      if (*((_BYTE *)this + 121))
      {
        v18 = 0;
LABEL_29:
        v30 = *((_QWORD *)this + 3);
        v31 = __len;
        if (!*((_BYTE *)this + 32))
        {
          v20 = vsheap_add_record(*((_QWORD *)this + 3), v18, __len);
          goto LABEL_93;
        }
        v32 = *(unsigned int *)(v30 + 36);
        if (__len)
        {
          if ((_DWORD)v32)
          {
            if (__len != v32)
              goto LABEL_57;
          }
          else
          {
            *(_DWORD *)(v30 + 36) = __len;
            LODWORD(v32) = v31;
          }
        }
        else if (!(_DWORD)v32)
        {
          goto LABEL_57;
        }
        v41 = *(_DWORD **)(v30 + 16);
        if (v41)
        {
          v42 = *(_QWORD *)(v30 + 24);
          if (v42 >= (*(_DWORD *)(v30 + 32) + v32))
            goto LABEL_54;
          v43 = v42 + ((_DWORD)v32 << 10);
        }
        else
        {
          v43 = ((_DWORD)v32 << 10) | 8u;
        }
        v41 = (_DWORD *)(*(uint64_t (**)(void))v30)();
        if (!v41)
        {
LABEL_57:
          v20 = 0;
          goto LABEL_93;
        }
        *(_QWORD *)(v30 + 16) = v41;
        *(_QWORD *)(v30 + 24) = v43;
LABEL_54:
        v44 = *(_DWORD *)(v30 + 32);
        if (!v44)
        {
          *(_DWORD *)(v30 + 32) = 8;
          *v41 = 8;
          v41[1] = *(_DWORD *)(v30 + 36);
          v44 = *(_DWORD *)(v30 + 32);
        }
        v45 = *(_QWORD *)(v30 + 40);
        memcpy((char *)v41 + v44, v18, *(unsigned int *)(v30 + 36));
        v46 = *(_DWORD *)(v30 + 32) + *(_DWORD *)(v30 + 36);
        *(_DWORD *)(v30 + 32) = v46;
        **(_DWORD **)(v30 + 16) = v46;
        ++*(_QWORD *)(v30 + 40);
        v20 = v45 + 1;
        goto LABEL_93;
      }
      CompressedData = CreateSizeBytesEmbededData(a4, __len, v70, *((unsigned __int8 *)this + 34), &__len);
    }
    v18 = CompressedData;
    goto LABEL_29;
  }
  v69 = 0;
  (*((void (**)(_QWORD, uint64_t *, unsigned __int8 *))this + 11))(0, &v71, &v69);
  v10 = 0;
  if (!*((_BYTE *)this + 121))
    v10 = CreateSizeBytesEmbededData(a4, __len, v69, *((unsigned __int8 *)this + 34), &__len);
  v11 = *((_QWORD *)this + 10);
  if (!v11)
    goto LABEL_10;
  v68 = 0;
  v12 = (*(uint64_t (**)(HeapAccessContext *, uint64_t, uLong *))(*(_QWORD *)this + 48))(this, v11, &v68);
  v13 = (*((uint64_t (**)(_QWORD, uint64_t, unsigned __int8 *))this + 16))(0, v12, &v70);
  v68 -= v70;
  if (v13 >= *((_QWORD *)this + 14))
    goto LABEL_10;
  v14 = v13;
  v15 = (const Bytef *)(v12 + v70);
  sourceLen = __len + v13;
  v16 = (Bytef *)malloc_type_malloc(__len + v13, 0x8C3EEDFFuLL);
  destLen = sourceLen;
  uncompress(v16, &destLen, v15, v68);
  memmove(&v16[v14], v10, __len);
  v17 = HeapAccessContext::createCompressedData(this, v16, sourceLen, v70, 0, (uint64_t *)&sourceLen);
  v18 = v17;
  if (*((_WORD *)this + 18) != 2 && (int64_t)sourceLen > *((_QWORD *)this + 8))
  {
    free(v17);
    free(v16);
LABEL_10:
    v18 = HeapAccessContext::createCompressedData(this, v10, __len, v70, 0, (uint64_t *)&__len);
    if (v10 != a4)
      free(v10);
    v14 = 0;
    goto LABEL_13;
  }
  if (v10 != a4)
    free(v10);
  __len = sourceLen;
  free(v16);
  v33 = *((_QWORD *)this + 3);
  v34 = *((_QWORD *)this + 10) >> *((_BYTE *)this + 120);
  if (*((_WORD *)this + 18) == 2)
  {
    v35 = *(unsigned int *)(v33 + 36);
    if (v34 < v35)
    {
      v36 = *(_DWORD **)(v33 + 16);
      v37 = (_DWORD *)((char *)v36 + v34);
      v38 = *(unsigned int *)((char *)v36 + v34);
      if ((_DWORD)v38)
      {
        if (v34 + v38 + 4 == v35)
        {
          v39 = v35 - v38 - 4;
          *(_DWORD *)(v33 + 36) = v39;
          *v36 = v39;
          if (*(int *)(v33 + 32) >= 1)
          {
            v40 = *(_DWORD *)(v33 + 48) - 1;
            *(_DWORD *)(v33 + 48) = v40;
            v36[5] = v40;
          }
        }
        else
        {
          *v37 = 0;
          if (v38 >= 4 && *(int *)(v33 + 32) >= 1)
          {
            v37[1] = v38;
            if (v38 >= 0x20 && v34 > *(unsigned int *)(v33 + 40))
            {
              v65 = *(unsigned int *)(v33 + 44);
              if (!(_DWORD)v65 || v34 < v65)
              {
                *(_DWORD *)(v33 + 44) = v34;
                v36[4] = v34;
              }
            }
          }
        }
      }
    }
  }
  else if (*(_QWORD *)(v33 + 40) == v34)
  {
    *(_QWORD *)(v33 + 40) = v34 - 1;
    v64 = *(_DWORD *)(v33 + 32) - *(_DWORD *)(v33 + 36);
    *(_DWORD *)(v33 + 32) = v64;
    **(_DWORD **)(v33 + 16) = v64;
  }
LABEL_13:
  if (*((_WORD *)this + 18) == 2)
  {
    v19 = vsheap_add_record(*((_QWORD *)this + 3), v18, __len) << *((_BYTE *)this + 120);
    v20 = v19 + v14;
    if ((int64_t)__len >= *((_QWORD *)this + 8))
      v19 = 0;
    *((_QWORD *)this + 10) = v19;
    goto LABEL_93;
  }
  v23 = *((_QWORD *)this + 8);
  v24 = (uint64_t)__len / v23;
  if ((uint64_t)__len % v23)
    ++v24;
  v25 = v24 * v23;
  v26 = (char *)malloc_type_calloc(1uLL, v24 * v23, 0x6D5323DBuLL);
  memmove(v26, v18, __len);
  free(v18);
  v27 = *((_QWORD *)this + 3);
  v28 = *((_QWORD *)this + 8);
  v29 = *(unsigned int *)(v27 + 36);
  if (v28)
  {
    if ((_DWORD)v29)
    {
      if (v28 != v29)
        goto LABEL_72;
    }
    else
    {
      *(_DWORD *)(v27 + 36) = v28;
      LODWORD(v29) = v28;
    }
  }
  else if (!(_DWORD)v29)
  {
    goto LABEL_72;
  }
  v47 = *(_DWORD **)(v27 + 16);
  if (v47)
  {
    v48 = *(_QWORD *)(v27 + 24);
    if (v48 >= (*(_DWORD *)(v27 + 32) + v29))
      goto LABEL_66;
    v49 = v48 + ((_DWORD)v29 << 10);
  }
  else
  {
    v49 = ((_DWORD)v29 << 10) | 8u;
  }
  v47 = (_DWORD *)(*(uint64_t (**)(void))v27)();
  if (!v47)
  {
LABEL_72:
    v20 = 0;
    v25 = 0;
    *((_QWORD *)this + 10) = 0;
    goto LABEL_73;
  }
  *(_QWORD *)(v27 + 16) = v47;
  *(_QWORD *)(v27 + 24) = v49;
LABEL_66:
  v50 = *(_DWORD *)(v27 + 32);
  if (!v50)
  {
    *(_DWORD *)(v27 + 32) = 8;
    *v47 = 8;
    v47[1] = *(_DWORD *)(v27 + 36);
    v50 = *(_DWORD *)(v27 + 32);
  }
  v51 = *(_QWORD *)(v27 + 40);
  memcpy((char *)v47 + v50, v26, *(unsigned int *)(v27 + 36));
  v52 = *(_DWORD *)(v27 + 32) + *(_DWORD *)(v27 + 36);
  *(_DWORD *)(v27 + 32) = v52;
  **(_DWORD **)(v27 + 16) = v52;
  ++*(_QWORD *)(v27 + 40);
  *((_QWORD *)this + 10) = v51 + 1;
  if (v51 >= *((_QWORD *)this + 12))
  {
    if (v51 != -1)
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "Failed to add a new data since record count exceeds limit (%lld) defined in the current compaction-type.\n", *((_QWORD *)this + 12));
    goto LABEL_72;
  }
  v53 = (v51 + 1) << *((_BYTE *)this + 120);
  *((_QWORD *)this + 10) = v53;
  v20 = v53 + v14;
LABEL_73:
  v54 = *((_QWORD *)this + 8);
  v55 = v25 - v54;
  if (v25 != v54)
  {
    v56 = v26;
    do
    {
      v56 += v54;
      v57 = *((_QWORD *)this + 3);
      v58 = *(unsigned int *)(v57 + 36);
      if (v54)
      {
        if ((_DWORD)v58)
        {
          if (v54 != v58)
            goto LABEL_91;
        }
        else
        {
          *(_DWORD *)(v57 + 36) = v54;
          LODWORD(v58) = v54;
        }
      }
      else if (!(_DWORD)v58)
      {
        goto LABEL_91;
      }
      v59 = *(_DWORD **)(v57 + 16);
      if (v59)
      {
        v60 = *(_QWORD *)(v57 + 24);
        if (v60 >= (*(_DWORD *)(v57 + 32) + v58))
          goto LABEL_88;
        v61 = v60 + ((_DWORD)v58 << 10);
      }
      else
      {
        v61 = ((_DWORD)v58 << 10) | 8u;
      }
      v59 = (_DWORD *)(*(uint64_t (**)(void))v57)();
      if (v59)
      {
        *(_QWORD *)(v57 + 16) = v59;
        *(_QWORD *)(v57 + 24) = v61;
LABEL_88:
        v62 = *(unsigned int *)(v57 + 32);
        if (!(_DWORD)v62)
        {
          *(_DWORD *)(v57 + 32) = 8;
          *v59 = 8;
          v59[1] = *(_DWORD *)(v57 + 36);
          v62 = *(unsigned int *)(v57 + 32);
        }
        memcpy((char *)v59 + v62, v56, *(unsigned int *)(v57 + 36));
        v63 = *(_DWORD *)(v57 + 32) + *(_DWORD *)(v57 + 36);
        *(_DWORD *)(v57 + 32) = v63;
        **(_DWORD **)(v57 + 16) = v63;
        ++*(_QWORD *)(v57 + 40);
      }
LABEL_91:
      *((_QWORD *)this + 10) = 0;
      v54 = *((_QWORD *)this + 8);
      v55 -= v54;
    }
    while (v55);
  }
  v18 = (Bytef *)v26;
LABEL_93:
  if (*((_BYTE *)this + 35) || *((_BYTE *)this + 121) || __len != a5)
    free(v18);
  if (a6)
    *a6 = v20;
  return v20 != 0;
}

Bytef *HeapAccessContext::createCompressedData(HeapAccessContext *this, const unsigned __int8 *a2, uLong sourceLen, unsigned int a4, int a5, uint64_t *a6)
{
  size_t v12;
  uint64_t v13;
  Bytef *v14;
  Bytef *v15;
  uLongf destLen;

  v12 = 2 * a4;
  v13 = a4;
  destLen = compressBound(sourceLen) + v12;
  v14 = (Bytef *)malloc_type_malloc(destLen, 0x6B8BACE9uLL);
  compress2(&v14[2 * a4], &destLen, a2, sourceLen, 9);
  if (a5)
  {
    v15 = (Bytef *)malloc_type_malloc(v12, 0xC332F394uLL);
    free(v14);
    destLen = 0;
    v14 = v15;
  }
  EmbedSizeBytesToBuffer(&v14[v13], sourceLen, a4, *((unsigned __int8 *)this + 34));
  EmbedSizeBytesToBuffer(v14, destLen + v13, a4, *((unsigned __int8 *)this + 34));
  if (a6)
    *a6 = destLen + v12;
  return v14;
}

unint64_t vsheap_add_record(uint64_t a1, void *__src, size_t __n)
{
  uint64_t v6;
  size_t v7;
  size_t v8;
  size_t v9;
  size_t v10;
  unsigned int v11;
  unsigned int v12;
  unint64_t v13;
  int v14;
  size_t v15;
  unint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  unsigned int v19;
  size_t v20;
  _DWORD *v21;
  unint64_t v22;
  int v23;
  unsigned int v24;
  _DWORD *v26;
  unint64_t v27;
  uint64_t v28;
  int v29;
  _DWORD *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  int *v34;
  int v35;

  v6 = *(_QWORD *)(a1 + 16);
  if (v6)
  {
    v7 = *(_QWORD *)(a1 + 24);
    if (__n + 4 + *(unsigned int *)(a1 + 36) <= v7)
      goto LABEL_11;
    v8 = (__n + 4) << 10;
    if (v8 >= __n + 262148)
      v8 = __n + 262148;
    v9 = v7 + v8;
  }
  else
  {
    v10 = (__n << 10) + 4096;
    if (v10 >= __n + 262148)
      v10 = __n + 262148;
    v9 = v10 + 32;
  }
  v6 = (*(uint64_t (**)(void))a1)();
  if (!v6)
    return 0;
  *(_QWORD *)(a1 + 16) = v6;
  *(_QWORD *)(a1 + 24) = v9;
LABEL_11:
  if (*(_DWORD *)(a1 + 36))
  {
    v11 = *(_DWORD *)(a1 + 44);
    if (v11)
    {
      v12 = *(_DWORD *)(a1 + 40);
      if (v11 < v12)
      {
        *(_DWORD *)(a1 + 44) = v12;
        v11 = v12;
      }
      v13 = *(unsigned int *)(a1 + 36);
      if (v11 < v13)
      {
        v14 = 0;
        v15 = __n + 4;
        v16 = v11;
        while (1)
        {
          v17 = *(_QWORD *)(a1 + 16);
          v18 = (_DWORD *)(v17 + v16);
          v19 = *(_DWORD *)(v17 + v16);
          if (!v19)
          {
            v20 = v18[1];
            v19 = v18[1];
            v21 = (_DWORD *)((char *)v18 + v20 + 4);
            v22 = v17 + v13;
            if ((unint64_t)v21 >= v22)
            {
              v23 = 0;
            }
            else
            {
              v23 = 0;
              do
              {
                if (*v21)
                  break;
                v24 = v21[1];
                v21 = (_DWORD *)((char *)v21 + v24 + 4);
                v19 += v24 + 4;
                ++v23;
              }
              while ((unint64_t)v21 < v22);
              v20 = v19;
            }
            if (v20 != __n && __n + 8 >= v20)
            {
              v27 = 0;
              if (v14)
                goto LABEL_37;
            }
            else
            {
              *(_DWORD *)(a1 + 48) -= v23;
              *v18 = __n;
              memcpy(v18 + 1, __src, __n);
              if (v20 > __n)
              {
                v26 = (_DWORD *)((char *)v18 + v15);
                v19 -= v15;
                *v26 = 0;
                v26[1] = v19;
                ++*(_DWORD *)(a1 + 48);
              }
              v27 = v16;
              if (v14)
                goto LABEL_37;
            }
            if (v19 > 0x1F || v27)
            {
              *(_DWORD *)(a1 + 44) = v16;
LABEL_37:
              if (v27)
              {
                v30 = *(_DWORD **)(a1 + 16);
                v30[4] = *(_DWORD *)(a1 + 44);
                goto LABEL_46;
              }
              v14 = 1;
              goto LABEL_39;
            }
            v14 = 0;
          }
LABEL_39:
          v16 += v19 + 4;
          v13 = *(unsigned int *)(a1 + 36);
          if (v16 >= v13)
          {
            if (!v14)
              break;
            v6 = *(_QWORD *)(a1 + 16);
            *(_DWORD *)(v6 + 16) = *(_DWORD *)(a1 + 44);
            goto LABEL_45;
          }
        }
      }
      *(_DWORD *)(a1 + 44) = 0;
      v6 = *(_QWORD *)(a1 + 16);
      *(_DWORD *)(v6 + 16) = 0;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 32) = 0x2000000001;
    *(_DWORD *)(a1 + 40) = 32;
    *(_QWORD *)v6 = 32;
    *(_DWORD *)(v6 + 8) = -*(_DWORD *)(a1 + 32);
    *(_DWORD *)(v6 + 12) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(v6 + 16) = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(v6 + 20) = *(_DWORD *)(a1 + 48);
    *(_QWORD *)(v6 + 24) = -1;
  }
LABEL_45:
  v27 = *(unsigned int *)(a1 + 36);
  ++*(_DWORD *)(a1 + 48);
  *(_DWORD *)(v6 + v27) = __n;
  v28 = (*(_DWORD *)(a1 + 36) + 4);
  *(_DWORD *)(a1 + 36) = v28;
  memcpy((void *)(*(_QWORD *)(a1 + 16) + v28), __src, __n);
  v29 = *(_DWORD *)(a1 + 36) + __n;
  *(_DWORD *)(a1 + 36) = v29;
  v30 = *(_DWORD **)(a1 + 16);
  *v30 = v29;
LABEL_46:
  if (*(int *)(a1 + 32) >= 1)
  {
    v31 = *(_DWORD *)(a1 + 48);
    if (v31 >= 0x1389)
    {
      v32 = *(_DWORD *)(a1 + 40);
      v33 = 500;
      do
      {
        v34 = (_DWORD *)((char *)v30 + v32);
        v35 = *v34;
        if (!*v34)
          v35 = v34[1];
        v32 += v35 + 4;
        *(_DWORD *)(a1 + 40) = v32;
        --v33;
      }
      while (v33);
      v30[3] = v32;
      v31 = 4501;
      *(_DWORD *)(a1 + 48) = 4501;
    }
    v30[5] = v31;
  }
  return v27;
}

uint64_t HeapAccessContext::deleteRecord(HeapAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4, uint64_t a5, unint64_t a6)
{
  uint64_t v6;
  unint64_t v7;
  int v8;
  unint64_t v10;
  _DWORD *v11;
  _DWORD *v12;
  uint64_t v13;
  int v14;
  int v15;
  unint64_t v18;

  if (*((_BYTE *)this + 33) && (*((_WORD *)this + 18) & 0xFFFE) != 2)
  {
    v6 = *((_QWORD *)this + 3);
    if (*((_BYTE *)this + 32))
    {
      v7 = *(_QWORD *)(v6 + 40);
      if (v7 >= a6)
      {
        if (v7 == a6)
        {
          *(_QWORD *)(v6 + 40) = a6 - 1;
          v8 = *(_DWORD *)(v6 + 32) - *(_DWORD *)(v6 + 36);
          *(_DWORD *)(v6 + 32) = v8;
          **(_DWORD **)(v6 + 16) = v8;
        }
        return 1;
      }
    }
    else
    {
      v10 = *(unsigned int *)(v6 + 36);
      if (v10 > a6)
      {
        v11 = *(_DWORD **)(v6 + 16);
        v12 = (_DWORD *)((char *)v11 + a6);
        v13 = *(unsigned int *)((char *)v11 + a6);
        if ((_DWORD)v13)
        {
          if (a6 + v13 + 4 == v10)
          {
            v14 = v10 - v13 - 4;
            *(_DWORD *)(v6 + 36) = v14;
            *v11 = v14;
            if (*(int *)(v6 + 32) >= 1)
            {
              v15 = *(_DWORD *)(v6 + 48) - 1;
              *(_DWORD *)(v6 + 48) = v15;
              v11[5] = v15;
            }
          }
          else
          {
            *v12 = 0;
            if (v13 >= 4 && *(_DWORD *)(v6 + 32) >= 1)
            {
              v12[1] = v13;
              if (v13 >= 0x20 && *(unsigned int *)(v6 + 40) < a6)
              {
                v18 = *(unsigned int *)(v6 + 44);
                if (!(_DWORD)v18 || v18 > a6)
                {
                  *(_DWORD *)(v6 + 44) = a6;
                  v11[4] = a6;
                }
              }
            }
          }
          return 1;
        }
      }
    }
  }
  return 0;
}

BOOL HeapAccessContext::buildWithRecords(HeapAccessContext *this, const __CFArray *a2, CFArrayRef theArray, unint64_t *a4)
{
  const __CFArray *v5;
  CFIndex Count;
  void **v8;
  _QWORD *v9;
  _QWORD *v10;
  const __CFData *v11;
  int v12;
  CFIndex j;
  const __CFData *v14;
  uint64_t v15;
  const void **v16;
  _QWORD *v17;
  _QWORD *v18;
  CFIndex v19;
  int v20;
  const void *v21;
  _DWORD *v22;
  unsigned int v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  _BOOL8 v31;
  CFMutableDataRef Mutable;
  uint64_t v33;
  CFIndex v34;
  Bytef *v35;
  CFIndex v36;
  const __CFArray *v37;
  const __CFData *v38;
  int v39;
  const UInt8 *v40;
  size_t v41;
  UInt8 *v42;
  uint64_t v43;
  const unsigned __int8 *v44;
  uLong v45;
  Bytef *v46;
  Bytef *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  int64_t v52;
  Bytef *v53;
  uint64_t v54;
  void *v55;
  void *v56;
  size_t v57;
  unint64_t v58;
  BOOL v59;
  _BOOL4 v60;
  CFIndex i;
  const __CFData *ValueAtIndex;
  const __CFData *v63;
  const unsigned __int8 *BytePtr;
  uLong Length;
  Bytef *SizeBytesEmbededData;
  int v67;
  const UInt8 *v68;
  size_t v69;
  uint64_t v70;
  size_t *v71;
  unint64_t *v72;
  CFIndex v73;
  size_t v74;
  unint64_t v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  const void **v79;
  void **v80;
  unint64_t *v81;
  size_t *v82;
  uint64_t v83;
  size_t v84;
  unint64_t v85;
  void **v86;
  CFIndex v87;
  void *v88;
  _QWORD *v89;
  int v90;
  const void *v91;
  _DWORD *v92;
  unsigned int v93;
  unint64_t v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  void **v99;
  uint64_t v100;
  void *v101;
  int v102;
  char v103;
  unint64_t *v104;
  CFIndex v105;
  unint64_t *v106;
  unint64_t v107;
  _QWORD *v109;
  size_t *v110;
  CFIndex v111;
  void **v112;
  uint64_t v113;
  CFIndex v114;
  CFIndex v115;
  unint64_t *v116;
  unsigned __int8 v117;
  uint64_t v118;
  unsigned __int8 v119;
  uint64_t v120;
  uint64_t v121;

  v5 = theArray;
  Count = CFArrayGetCount(theArray);
  v8 = (void **)malloc_type_malloc(8 * Count, 0x10040436913F5uLL);
  v9 = malloc_type_malloc(8 * Count, 0x100004000313F17uLL);
  if (!*((_BYTE *)this + 33))
    return 0;
  v10 = v9;
  v112 = v8;
  if (!*((_BYTE *)this + 32))
  {
    v109 = v9;
    v110 = (size_t *)malloc_type_malloc(8 * Count, 0x100004000313F17uLL);
    v121 = 0;
    v120 = 0;
    v119 = 0;
    (*((void (**)(_QWORD, uint64_t *, unsigned __int8 *))this + 16))(*((_QWORD *)this + 17), &v120, &v119);
    if ((*((_WORD *)this + 18) & 0xFFFE) != 2)
    {
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v5, i);
          v63 = ValueAtIndex;
          if (*((_BYTE *)this + 35))
          {
            BytePtr = CFDataGetBytePtr(ValueAtIndex);
            Length = CFDataGetLength(v63);
            SizeBytesEmbededData = HeapAccessContext::createCompressedData(this, BytePtr, Length, v119, *((unsigned __int8 *)this + 121), &v121);
          }
          else
          {
            v67 = *((unsigned __int8 *)this + 121);
            v68 = CFDataGetBytePtr(ValueAtIndex);
            v69 = CFDataGetLength(v63);
            if (v67)
              SizeBytesEmbededData = 0;
            else
              SizeBytesEmbededData = CreateSizeBytesEmbededData(v68, v69, v119, *((unsigned __int8 *)this + 34), (size_t *)&v121);
            v8 = v112;
          }
          v8[i] = SizeBytesEmbededData;
          v110[i] = v121;
        }
      }
      if (!Count)
      {
        LODWORD(v29) = 0;
        v30 = 0;
        v10 = v109;
        goto LABEL_126;
      }
      v70 = *((_QWORD *)this + 3);
      v10 = v109;
      v71 = v110;
      v72 = v109;
      v73 = Count;
      while (1)
      {
        v74 = *v71++;
        v75 = vsheap_add_record(v70, *v8, v74);
        *v72 = v75;
        if (!v75)
          break;
        ++v72;
        ++v8;
        if (!--v73)
        {
          LODWORD(v29) = 0;
LABEL_91:
          if (Count >= 1)
          {
            v86 = v112;
            v87 = Count;
            do
            {
              v88 = *v86++;
              free(v88);
              --v87;
            }
            while (v87);
          }
          v30 = 0;
          goto LABEL_126;
        }
      }
      LODWORD(v29) = -1;
      goto LABEL_91;
    }
    Mutable = CFDataCreateMutable(0, 0);
    v118 = 0;
    v117 = 0;
    (*((void (**)(_QWORD, uint64_t *, unsigned __int8 *))this + 11))(0, &v120, &v117);
    v114 = Count - 1;
    if (Count < 1)
    {
      CFRelease(Mutable);
      if (*((_WORD *)this + 18) != 2)
        *(_DWORD *)(*((_QWORD *)this + 3) + 36) = *((_QWORD *)this + 8);
      LODWORD(v29) = 0;
      v76 = a4 == 0;
      v10 = v109;
      goto LABEL_125;
    }
    v115 = Count;
    v116 = a4;
    v33 = 0;
    v113 = 0;
    v34 = 0;
    do
    {
      v35 = 0;
      v111 = v34;
      v36 = v34;
      while (1)
      {
        v37 = v5;
        v38 = (const __CFData *)CFArrayGetValueAtIndex(v5, v36);
        v39 = *((unsigned __int8 *)this + 121);
        v40 = CFDataGetBytePtr(v38);
        v41 = CFDataGetLength(v38);
        if (v39)
          v42 = 0;
        else
          v42 = CreateSizeBytesEmbededData(v40, v41, v117, *((unsigned __int8 *)this + 34), (size_t *)&v121);
        if (v116)
        {
          v43 = v113 << *((_BYTE *)this + 120);
          v116[v36] = v43 + CFDataGetLength(Mutable);
        }
        CFDataAppendBytes(Mutable, v42, v121);
        if (CFDataGetBytePtr(v38) != v42)
          free(v42);
        v44 = CFDataGetBytePtr(Mutable);
        v45 = CFDataGetLength(Mutable);
        v46 = HeapAccessContext::createCompressedData(this, v44, v45, v119, 0, &v118);
        v47 = v46;
        v48 = v118;
        v49 = *((_QWORD *)this + 8);
        v5 = v37;
        if (v118 > v49 || v114 == v36)
          break;
        v33 = v118;
        if (v35)
        {
          free(v35);
          v33 = v118;
        }
        ++v36;
        v35 = v47;
        Count = v115;
        if (v36 >= v115)
        {
          v50 = 0;
          v34 = v111;
          goto LABEL_61;
        }
      }
      if (*((_WORD *)this + 18) == 2 || v118 <= v49 || !v35)
      {
        if (v35)
        {
          free(v35);
          v48 = v118;
        }
        v34 = v36 + 1;
        v33 = v48;
        v35 = v47;
      }
      else
      {
        free(v46);
        v34 = v36;
      }
      v51 = v113;
      if (*((_WORD *)this + 18) == 2)
      {
        v50 = 0;
        v112[v113] = v47;
        v110[v113++] = v118;
      }
      else
      {
        if (v33 < 1)
        {
          v50 = 0;
        }
        else
        {
          v52 = *((_QWORD *)this + 8);
          v53 = v35;
          while (1)
          {
            v54 = v51;
            v55 = malloc_type_calloc(1uLL, v52, 0x71CA5D5FuLL);
            v56 = v55;
            v57 = v33 >= *((_QWORD *)this + 8) ? *((_QWORD *)this + 8) : v33;
            memmove(v55, v53, v57);
            v51 = v54 + 1;
            v112[v54] = v56;
            v58 = *((_QWORD *)this + 12);
            if (v54 + 1 > v58)
              break;
            v52 = *((_QWORD *)this + 8);
            v53 += v52;
            v59 = v33 <= v52;
            v33 -= v52;
            if (v59)
            {
              v50 = 0;
              v113 = v54 + 1;
              goto LABEL_59;
            }
          }
          v113 = v54 + 1;
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "Record count exceeds limit (%lld).\n", v58);
          v50 = 1;
        }
LABEL_59:
        free(v35);
      }
      Count = v115;
      CFDataSetLength(Mutable, 0);
LABEL_61:
      ;
    }
    while (v34 < Count && !v50);
    CFRelease(Mutable);
    if ((v50 & 1) != 0)
    {
      v60 = 0;
      LODWORD(v29) = -1;
LABEL_115:
      a4 = v116;
      v10 = v109;
      v78 = v113;
      goto LABEL_116;
    }
    v77 = *((_QWORD *)this + 3);
    v79 = (const void **)v112;
    v78 = v113;
    v10 = v109;
    if (*((_WORD *)this + 18) == 2)
    {
      if (v113)
      {
        v80 = v112;
        v81 = v109;
        v82 = v110;
        v83 = v113;
        while (1)
        {
          v84 = *v82++;
          v85 = vsheap_add_record(v77, *v80, v84);
          *v81 = v85;
          v60 = v85 != 0;
          if (!v85)
            break;
          ++v81;
          ++v80;
          if (!--v83)
          {
            LODWORD(v29) = 0;
            goto LABEL_114;
          }
        }
        LODWORD(v29) = -1;
LABEL_114:
        Count = v115;
        goto LABEL_115;
      }
LABEL_112:
      LODWORD(v29) = 0;
      v50 = 0;
      v60 = 1;
      a4 = v116;
      goto LABEL_119;
    }
    *(_DWORD *)(v77 + 36) = *((_QWORD *)this + 8);
    if (!v113)
      goto LABEL_112;
    v89 = v109;
    v29 = v113;
    while (1)
    {
      v90 = *(_DWORD *)(v77 + 36);
      if (v90)
        break;
      v96 = 0;
LABEL_110:
      *v89++ = v96;
      ++v79;
      if (!--v29)
      {
        v60 = 1;
        Count = v115;
        a4 = v116;
LABEL_116:
        if (v78 >= 1)
        {
          v99 = v112;
          do
          {
            v100 = v78;
            v101 = *v99++;
            free(v101);
            v78 = v100 - 1;
          }
          while (v100 != 1);
        }
LABEL_119:
        v102 = !v60;
        if (!a4)
          v102 = 1;
        v76 = v50 | v102;
        if ((v76 & 1) == 0)
        {
          v103 = *((_BYTE *)this + 120);
          v104 = a4;
          v105 = Count;
          do
          {
            *v104 = (*((_QWORD *)this + 14) & *v104)
                  + (v10[((*((_QWORD *)this + 13) & *v104) >> v103)] << v103);
            ++v104;
            --v105;
          }
          while (v105);
          v76 = 0;
        }
LABEL_125:
        v30 = v76 ^ 1;
LABEL_126:
        free(v110);
        goto LABEL_127;
      }
    }
    v91 = *v79;
    v92 = *(_DWORD **)(v77 + 16);
    if (v92)
    {
      v93 = *(_DWORD *)(v77 + 32);
      v94 = *(_QWORD *)(v77 + 24);
      if (v94 >= v93 + v90)
        goto LABEL_105;
      v95 = v94 + (v90 << 10);
    }
    else
    {
      v95 = (v90 << 10) | 8u;
    }
    v92 = (_DWORD *)(*(uint64_t (**)(void))v77)();
    if (!v92)
    {
      v96 = 0;
LABEL_109:
      v10 = v109;
      v78 = v113;
      goto LABEL_110;
    }
    *(_QWORD *)(v77 + 16) = v92;
    *(_QWORD *)(v77 + 24) = v95;
    v93 = *(_DWORD *)(v77 + 32);
LABEL_105:
    if (!v93)
    {
      *(_DWORD *)(v77 + 32) = 8;
      *v92 = 8;
      v92[1] = *(_DWORD *)(v77 + 36);
      v93 = *(_DWORD *)(v77 + 32);
    }
    v97 = *(_QWORD *)(v77 + 40);
    memcpy((char *)v92 + v93, v91, *(unsigned int *)(v77 + 36));
    v98 = *(_DWORD *)(v77 + 32) + *(_DWORD *)(v77 + 36);
    *(_DWORD *)(v77 + 32) = v98;
    **(_DWORD **)(v77 + 16) = v98;
    ++*(_QWORD *)(v77 + 40);
    v96 = v97 + 1;
    goto LABEL_109;
  }
  v11 = (const __CFData *)CFArrayGetValueAtIndex(v5, 0);
  v12 = CFDataGetLength(v11);
  if (Count >= 1)
  {
    for (j = 0; j != Count; ++j)
    {
      v14 = (const __CFData *)CFArrayGetValueAtIndex(v5, j);
      v8[j] = (void *)CFDataGetBytePtr(v14);
    }
  }
  v15 = *((_QWORD *)this + 3);
  *(_DWORD *)(v15 + 36) = v12;
  if (!Count)
  {
    LODWORD(v29) = 0;
    v30 = 0;
    goto LABEL_127;
  }
  v16 = (const void **)v112;
  v17 = v10;
  v18 = v10;
  v19 = Count;
  do
  {
    v20 = *(_DWORD *)(v15 + 36);
    if (!v20)
    {
LABEL_18:
      v28 = 0;
      goto LABEL_19;
    }
    v21 = *v16;
    v22 = *(_DWORD **)(v15 + 16);
    if (v22)
    {
      v23 = *(_DWORD *)(v15 + 32);
      v24 = *(_QWORD *)(v15 + 24);
      if (v24 >= v23 + v20)
        goto LABEL_15;
      v25 = v24 + (v20 << 10);
    }
    else
    {
      v25 = (v20 << 10) | 8u;
    }
    v22 = (_DWORD *)(*(uint64_t (**)(void))v15)();
    if (!v22)
      goto LABEL_18;
    *(_QWORD *)(v15 + 16) = v22;
    *(_QWORD *)(v15 + 24) = v25;
    v23 = *(_DWORD *)(v15 + 32);
LABEL_15:
    if (!v23)
    {
      *(_DWORD *)(v15 + 32) = 8;
      *v22 = 8;
      v22[1] = *(_DWORD *)(v15 + 36);
      v23 = *(_DWORD *)(v15 + 32);
    }
    v26 = *(_QWORD *)(v15 + 40);
    memcpy((char *)v22 + v23, v21, *(unsigned int *)(v15 + 36));
    v27 = *(_DWORD *)(v15 + 32) + *(_DWORD *)(v15 + 36);
    *(_DWORD *)(v15 + 32) = v27;
    **(_DWORD **)(v15 + 16) = v27;
    ++*(_QWORD *)(v15 + 40);
    v28 = v26 + 1;
LABEL_19:
    *v18++ = v28;
    ++v16;
    --v19;
  }
  while (v19);
  LODWORD(v29) = 0;
  v30 = 0;
  v10 = v17;
LABEL_127:
  v31 = (_DWORD)v29 == 0;
  if (a4 && !v30 && Count >= 1 && !(_DWORD)v29)
  {
    v106 = v10;
    do
    {
      v107 = *v106++;
      *a4++ = v107;
      --Count;
    }
    while (Count);
  }
  free(v10);
  free(v112);
  return v31;
}

uint64_t HeapAccessContext::createIndexFile(HeapAccessContext *this, IDXIndexInfo *a2)
{
  const char *v3;
  _BOOL4 v4;
  int v5;
  int v6;
  const std::__fs::filesystem::path *v8;
  std::error_code *v9;

  v3 = (const char *)IDXIndexInfo::POSIXPath(this);
  v4 = IDXIndexInfo::writable(this);
  v5 = openRawIndexFile(v3, v4, 1);
  if (v5 != -1)
  {
    v6 = v5;
    if (lseek(v5, 63, 0) != -1 && write(v6, "", 1uLL) == 1)
    {
      close(v6);
      return 1;
    }
    close(v6);
    v8 = (const std::__fs::filesystem::path *)IDXIndexInfo::POSIXPath(this);
    remove(v8, v9);
  }
  return 0;
}

uint64_t HeapAccessContext::compact(uint64_t this)
{
  uint64_t v1;
  unint64_t v2;

  if (*(_BYTE *)(this + 32) || *(_WORD *)(this + 36) == 3)
  {
    v1 = *(_QWORD *)(this + 24);
    v2 = *(unsigned int *)(v1 + 32);
    if (*(_QWORD *)(v1 + 24) > v2)
    {
      this = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))v1)(*(_QWORD *)(v1 + 16), *(unsigned int *)(v1 + 32), *(_QWORD *)(v1 + 8));
      if (this)
      {
        *(_QWORD *)(v1 + 16) = this;
        *(_QWORD *)(v1 + 24) = v2;
      }
    }
  }
  return this;
}

uint64_t HeapAccessContext::flush(HeapAccessContext *this)
{
  return flushIndexFile((void *)(*(_QWORD *)(*((_QWORD *)this + 3) + 16) - 64), *(_QWORD *)(*((_QWORD *)this + 5) + 16));
}

uint64_t HeapAccessContext::initializeSubclass(HeapAccessContext *this, int a2, void **a3)
{
  const char *v5;
  int v6;
  int v7;
  _DWORD *v8;
  unsigned int *v9;
  unint64_t v10;
  const char *v11;
  size_t v12;
  char *v13;
  const char *v14;
  uint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  unint64_t v22;
  BOOL v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  unint64_t v27;

  if (*((_BYTE *)this + 38))
    return 0;
  if (!a2)
  {
    v19 = (uint64_t)*a3;
    *((_QWORD *)this + 5) = *a3;
    *((_QWORD *)this + 3) = *(_QWORD *)(v19 + 8);
    return 1;
  }
  v27 = 0;
  v5 = (const char *)IDXIndexInfo::POSIXPath(*((IDXIndexInfo **)this + 1));
  v6 = openRawIndexFile(v5, *((unsigned __int8 *)this + 33), 0);
  if (v6 == -1)
    return 0;
  v7 = v6;
  v8 = (_DWORD *)mapIndexFile(v6, *((unsigned __int8 *)this + 33), (off_t *)&v27);
  close(v7);
  if (v8 == (_DWORD *)-1)
    return 0;
  v9 = v8 + 16;
  v10 = v27 - 64;
  *((_QWORD *)this + 5) = malloc_type_malloc(0x18uLL, 0x80040B8603338uLL);
  v11 = (const char *)IDXIndexInfo::POSIXPath(*((IDXIndexInfo **)this + 1));
  v12 = strlen(v11) + 1;
  v13 = (char *)malloc_type_malloc(v12, 0x82104DEAuLL);
  v14 = (const char *)IDXIndexInfo::POSIXPath(*((IDXIndexInfo **)this + 1));
  strlcpy(v13, v14, v12);
  if (!*((_BYTE *)this + 32) && *((_WORD *)this + 18) != 3)
  {
    v21 = *((_QWORD *)this + 5);
    v16 = malloc_type_malloc(0x38uLL, 0x10900408C52C49CuLL);
    if (v16)
    {
      *v16 = myReallocator;
      v16[1] = v21;
      v16[2] = v9;
      v16[3] = v10;
      *((_DWORD *)v16 + 8) = 0;
      v16[5] = 0;
      *((_DWORD *)v16 + 12) = 0;
      if (v10 >= 4 && (v22 = *v9, v10 >= v22))
      {
        *((_DWORD *)v16 + 9) = v22;
        if (v22 >= 0x20 && !v8[17])
        {
          v26 = -v8[18] & ((int)v8[18] >> 31);
          *((_DWORD *)v16 + 8) = v26;
          if (v26 >= 1)
          {
            *((_DWORD *)v16 + 10) = v8[19];
            *((_DWORD *)v16 + 11) = v8[20];
            *((_DWORD *)v16 + 12) = v8[21];
          }
        }
      }
      else
      {
        *((_DWORD *)v16 + 9) = 0;
      }
    }
    goto LABEL_13;
  }
  v15 = *((_QWORD *)this + 5);
  v16 = malloc_type_malloc(0x30uLL, 0x109004033C35484uLL);
  if (v16)
  {
    *v16 = myReallocator;
    v16[1] = v15;
    v16[2] = v9;
    v16[3] = v10;
    if (v10 >= 4 && (v17 = *v9, v10 >= v17))
    {
      *((_DWORD *)v16 + 8) = v17;
      v23 = v17 >= 8;
      v24 = v17 - 8;
      if (v23)
      {
        v25 = v8[17];
        *((_DWORD *)v16 + 9) = v25;
        if (!v25)
          goto LABEL_13;
        v18 = v24 / v25;
        goto LABEL_12;
      }
    }
    else
    {
      *((_DWORD *)v16 + 8) = 0;
    }
    v18 = 0;
    *((_DWORD *)v16 + 9) = 0;
LABEL_12:
    v16[5] = v18;
  }
LABEL_13:
  *((_QWORD *)this + 3) = v16;
  **((_QWORD **)this + 5) = v13;
  *(_QWORD *)(*((_QWORD *)this + 5) + 8) = *((_QWORD *)this + 3);
  *(_QWORD *)(*((_QWORD *)this + 5) + 16) = v27;
  *a3 = (void *)*((_QWORD *)this + 5);
  return 1;
}

uint64_t myReallocator(char *a1, uint64_t a2, const char **a3)
{
  int v6;
  int v7;
  uint64_t v8;
  unint64_t v10;
  stat v11;

  v6 = openRawIndexFile(*a3, 1, 0);
  if (v6 == -1)
    return 0;
  v7 = v6;
  v10 = 0;
  if (fstat(v6, &v11) == -1)
    return 0;
  unmapIndexFile(a1 - 64, v11.st_size);
  if (ftruncate(v7, a2 + 64) == -1)
    return 0;
  v8 = mapIndexFile(v7, 1, (off_t *)&v10);
  a3[2] = (const char *)v10;
  close(v7);
  return v8 + 64;
}

{
  int v6;
  int v7;
  uint64_t v8;
  unint64_t v10;
  stat v11;

  v6 = openRawIndexFile(*a3, 1, 0);
  if (v6 == -1)
    return 0;
  v7 = v6;
  v10 = 0;
  if (fstat(v6, &v11) == -1)
    return 0;
  unmapIndexFile(a1 - 64, v11.st_size);
  if (ftruncate(v7, a2 + 64) == -1)
    return 0;
  v8 = mapIndexFile(v7, 1, (off_t *)&v10);
  a3[2] = (const char *)v10;
  close(v7);
  return v8 + 64;
}

void HeapAccessContext::finalizeSubclass(HeapAccessContext *this, int a2)
{
  _QWORD *v3;
  uint64_t v4;

  if (a2)
  {
    v3 = (_QWORD *)*((_QWORD *)this + 3);
    if (v3)
    {
      v4 = v3[2];
      free(v3);
      unmapIndexFile((void *)(v4 - 64), *(_QWORD *)(*((_QWORD *)this + 5) + 16));
      free(**((void ***)this + 5));
      free(*((void **)this + 5));
    }
  }
}

uint64_t HeapAccessContext::setSearchCharacters(HeapAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const __CFString *a4)
{
  return 0;
}

uint64_t HeapAccessContext::getMatchDataPtr(HeapAccessContext *this, uint64_t a2, const unsigned __int8 **a3, uint64_t *a4)
{
  return 0;
}

uint64_t HeapAccessContext::getMatchData(HeapAccessContext *this, uint64_t a2, uint64_t a3, unsigned __int8 *a4, CFRange **a5, uint64_t *a6)
{
  return 0;
}

uint64_t HeapAccessContext::containsMatchData(HeapAccessContext *this, unsigned __int8 *a2)
{
  return 0;
}

BOOL HeapAccessContext::supportDataPtr(HeapAccessContext *this)
{
  return !*((_BYTE *)this + 35) && *((_BYTE *)this + 121) == 0;
}

void TrieAccessContext::TrieAccessContext(TrieAccessContext *this, IDXIndexInfo *a2)
{
  uint64_t v4;
  BOOL v5;
  const __CFDictionary *v6;
  unsigned __int8 v7;
  uint64_t v8;
  _BOOL4 v9;

  v4 = IDXAccessContext::IDXAccessContext((uint64_t)this, (uint64_t)a2);
  *(_QWORD *)v4 = &off_1E8B57C08;
  *(_QWORD *)(v4 + 104) = 0;
  *(_QWORD *)(v4 + 136) = 0;
  *(_QWORD *)(v4 + 160) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  pthread_mutex_init((pthread_mutex_t *)(v4 + 184), 0);
  *((_BYTE *)this + 72) = IDXIndexInfo::writable(a2);
  v5 = IDXIndexInfo::bigEndian(a2);
  *((_WORD *)this + 37) = 0;
  *((_BYTE *)this + 73) = v5;
  v6 = IDXIndexInfo::optionalProperty(a2, CFSTR("TrieIndexCompressionType"));
  if (v6)
    CFNumberGetValue(v6, kCFNumberSInt16Type, (char *)this + 74);
  v7 = IDXIndexInfo::dataSizeLength(a2);
  v8 = IDXIndexInfo::fixedDataSize(a2);
  v9 = IDXIndexInfo::bigEndian(a2);
  *((_QWORD *)this + 21) = GetPreConfiguredGetDataSizeFunction(v7, v8, v9, (_QWORD *)this + 22);
}

void sub_1CDF87DEC(_Unwind_Exception *a1)
{
  IDXAccessContext *v1;

  IDXAccessContext::~IDXAccessContext(v1);
  _Unwind_Resume(a1);
}

void TrieAccessContext::~TrieAccessContext(TrieAccessContext *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_1E8B57C08;
  v2 = *((_QWORD *)this + 10);
  if (v2)
    MEMORY[0x1D17BC778](v2, 0x1000C80BDFB0063);
  v3 = *((_QWORD *)this + 17);
  if (v3)
    MEMORY[0x1D17BC778](v3, 0x1000C8052888210);
  v4 = *((_QWORD *)this + 6);
  if (v4)
    MEMORY[0x1D17BC778](v4, 0x1000C8077774924);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 184));
  IDXAccessContext::~IDXAccessContext(this);
}

{
  TrieAccessContext::~TrieAccessContext(this);
  JUMPOUT(0x1D17BC79CLL);
}

void sub_1CDF87E94(_Unwind_Exception *a1)
{
  IDXAccessContext *v1;

  IDXAccessContext::~IDXAccessContext(v1);
  _Unwind_Resume(a1);
}

void sub_1CDF87EE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F1C4043258D86);
  _Unwind_Resume(a1);
}

uint64_t TrieAccessContext::setSearchCharacters(CFStringRef *this, const unsigned __int16 *__src, uint64_t a3, CFStringRef theString1)
{
  uint64_t result;
  int v9;
  CFStringRef v10;
  CFStringRef v11;
  __CFString *v12;
  unsigned int v13;

  if (this[13] == theString1)
    goto LABEL_14;
  if (CFStringCompare(theString1, CFSTR("IDXExactMatch"), 0))
  {
    if (CFStringCompare(theString1, CFSTR("IDXCommonPrefixMatch"), 0))
    {
      if (CFStringCompare(theString1, CFSTR("IDXPrefixMatch"), 0) == kCFCompareEqualTo)
      {
LABEL_12:
        v9 = 1;
        goto LABEL_13;
      }
      if (CFStringCompare(theString1, CFSTR("IDXWildcardMatch"), 0))
      {
        if (CFStringCompare(theString1, CFSTR("IDXAllMatch"), 0))
          return 0;
        __src = 0;
        a3 = 0;
        goto LABEL_12;
      }
      v9 = 3;
    }
    else
    {
      v9 = 2;
    }
  }
  else
  {
    v9 = 0;
  }
LABEL_13:
  *((_DWORD *)this + 28) = v9;
  this[13] = theString1;
LABEL_14:
  if (a3 > (uint64_t)this[11])
  {
    this[11] = (CFStringRef)(a3 + 128);
    v10 = this[10];
    if (v10)
      MEMORY[0x1D17BC778](v10, 0x1000C80BDFB0063);
    this[10] = (CFStringRef)operator new[]();
    v11 = this[17];
    if (v11)
      MEMORY[0x1D17BC778](v11, 0x1000C8052888210);
    this[17] = (CFStringRef)operator new[]();
  }
  this[12] = (CFStringRef)(2 * a3);
  if (__src && a3 >= 1)
  {
    v12 = (__CFString *)this[10];
    if (*((_BYTE *)this + 73))
    {
      do
      {
        v13 = *__src++;
        LOWORD(v12->isa) = bswap32(v13) >> 16;
        v12 = (__CFString *)((char *)v12 + 2);
        --a3;
      }
      while (a3);
    }
    else
    {
      memcpy(v12, __src, 2 * a3);
    }
  }
  *((_BYTE *)this + 116) = 0;
  this[15] = 0;
  result = 1;
  this[20] = 0;
  return result;
}

uint64_t TrieAccessContext::supportDataPtr(TrieAccessContext *this)
{
  uint64_t result;

  result = TrieAccessContext::keyDataHeapContext(this);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 64))(result);
  return result;
}

uint64_t TrieAccessContext::keyDataHeapContext(TrieAccessContext *this)
{
  uint64_t result;
  HeapAccessContext *v3;
  uint64_t v4;

  result = *((_QWORD *)this + 5);
  if (!result)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
    if (!*((_QWORD *)this + 5))
    {
      v3 = (HeapAccessContext *)operator new();
      HeapAccessContext::HeapAccessContext(v3, *((IDXIndexInfo **)this + 4));
      *((_QWORD *)this + 5) = v3;
      if ((IDXAccessContext::initialize(v3) & 1) == 0)
      {
        IDXAccessContext::finalize(*((IDXAccessContext **)this + 5));
        v4 = *((_QWORD *)this + 5);
        if (v4)
          (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
        *((_QWORD *)this + 5) = 0;
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 184));
    return *((_QWORD *)this + 5);
  }
  return result;
}

void sub_1CDF881C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F1C409CAD4C71);
  _Unwind_Resume(a1);
}

uint64_t TrieAccessContext::getMatchDataPtr(TrieAccessContext *this, uint64_t a2, const unsigned __int8 **a3, uint64_t *a4)
{
  return TrieAccessContext::getMatchDataCommon((uint64_t)this, a2, a3, a4, 0, 0, 0, 0, 0);
}

uint64_t TrieAccessContext::getMatchDataCommon(uint64_t this, uint64_t a2, const unsigned __int8 **a3, uint64_t *a4, _BOOL4 a5, CFRange *a6, unsigned __int8 *a7, unsigned __int8 *a8, uint64_t *a9)
{
  unsigned __int8 *v9;
  CFRange *v10;
  uint64_t v14;
  unsigned __int8 *v15;
  uint64_t *v16;
  const unsigned __int8 *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint8x8_t v22;
  uint64_t v23;
  signed int *v24;
  uint64_t v25;
  signed int matched;
  int64_t v27;
  unint64_t v28;
  uint64_t v29;
  int *v30;
  unsigned int v31;
  unint64_t v32;
  BOOL v33;
  int *v34;
  unint64_t v35;
  int64_t v36;
  CFRange *v37;
  unsigned __int8 *v38;
  int64_t v39;
  int64_t v40;
  unsigned int *HeapData;
  unsigned int v42;
  uint64_t v43;
  BOOL v44;
  BOOL v45;
  char v46;
  uint64_t *v47;
  _BOOL4 v48;
  uint64_t v49;
  uint64_t *v50;
  const unsigned __int8 **v51;
  uint64_t v52;
  unsigned __int8 *v53;
  int64_t v54;
  unint64_t v55[2];

  v9 = a7;
  v10 = a6;
  v14 = this;
  v55[1] = *MEMORY[0x1E0C80C00];
  v52 = 0;
  v53 = a8;
  if (*(_QWORD *)(this + 96))
    v15 = *(unsigned __int8 **)(this + 80);
  else
    v15 = 0;
  v16 = a9;
  v17 = *(const unsigned __int8 **)(this + 160);
  v51 = a3;
  if (v17)
  {
    this = TrieAccessContext::processHomographData((TrieAccessContext *)this, v17, 0, *(_DWORD *)(this + 144), *(_QWORD *)(this + 152), a2, a3, a4, a5, a6, a7, &v53, &v52);
    v18 = this;
    a2 -= this;
    v19 = v52;
  }
  else
  {
    v19 = 0;
    v18 = 0;
  }
  if (a2 >= 1 && !v19)
  {
    if (!*(_BYTE *)(v14 + 116))
    {
      v47 = a4;
      MEMORY[0x1E0C80A78](this);
      v24 = (signed int *)((char *)&v47 - v23);
      LODWORD(v23) = *(_DWORD *)(v14 + 112);
      v49 = v25;
      v50 = a9;
      v48 = a5;
      switch((int)v23)
      {
        case 0:
          if (*(_WORD *)(v14 + 74) == 1)
          {
            matched = btrie_exact_match_search(*(_QWORD *)(v14 + 24), v15, *(_QWORD *)(v14 + 96), v22);
          }
          else if (*(_WORD *)(v14 + 74))
          {
            matched = mtrie_exact_match_search(*(_QWORD *)(v14 + 24), (const char *)v15, *(_QWORD *)(v14 + 96));
          }
          else
          {
            matched = trie_exact_match_search(*(_QWORD *)(v14 + 24), v15, *(_QWORD *)(v14 + 96));
          }
          *v24 = matched;
          v27 = matched > 0;
          goto LABEL_45;
        case 1:
          if (*(_WORD *)(v14 + 74) == 1)
          {
            v30 = *(int **)(v14 + 24);
            v31 = *(_DWORD *)(v14 + 96);
            v32 = *(_QWORD *)(v14 + 120);
            v54 = 0;
            v55[0] = v32;
            __btrie_find_prefix((uint64_t)v30, *v30, v15, v31, v55, a2, (unint64_t *)&v54, (uint64_t)v24, v22);
            v27 = v54;
            goto LABEL_41;
          }
          if (*(_WORD *)(v14 + 74))
            goto LABEL_31;
          v28 = trie_prefix_match_search(*(_QWORD *)(v14 + 24), v15, *(_QWORD *)(v14 + 96), *(_QWORD *)(v14 + 120), a2, (uint64_t)v24);
          goto LABEL_40;
        case 2:
          v29 = *(_QWORD *)(v14 + 120);
          v24 = *(signed int **)(v14 + 136);
          if (v29)
          {
            v24 += v29;
            v27 = *(_QWORD *)(v14 + 128) - v29;
          }
          else
          {
            if (*(_WORD *)(v14 + 74) == 1)
            {
              v34 = *(int **)(v14 + 24);
              v35 = *(_QWORD *)(v14 + 96);
              v55[0] = 0;
              __btrie_find_common_prefix((uint64_t)v34, *v34, v15, v35, v35, v55, (uint64_t)v24, 0, (uint64_t)v15);
              v27 = v55[0];
            }
            else if (*(_WORD *)(v14 + 74))
            {
              v27 = 0;
            }
            else
            {
              v27 = trie_common_prefix_search(*(_QWORD *)(v14 + 24), (uint64_t)v15, *(_QWORD *)(v14 + 96), *(_QWORD *)(v14 + 96), *(_QWORD *)(v14 + 136), 0);
            }
            *(_QWORD *)(v14 + 128) = v27;
          }
LABEL_45:
          v33 = 1;
          goto LABEL_46;
        case 3:
          if (*(_WORD *)(v14 + 74) == 1)
          {
            v28 = btrie_wildcard_match_search(*(unsigned int **)(v14 + 24), v15, *(_QWORD *)(v14 + 96), 2u, *(_QWORD *)(v14 + 120), a2, (uint64_t)v24, v22);
          }
          else
          {
            if (*(_WORD *)(v14 + 74))
            {
LABEL_31:
              v27 = 0;
              goto LABEL_41;
            }
            v28 = trie_wildcard_match_search(*(_QWORD *)(v14 + 24), (uint64_t)v15, *(_QWORD *)(v14 + 96), *(_BYTE *)(v14 + 73) == 0, 2u, *(_QWORD *)(v14 + 120), a2, (uint64_t)v24);
          }
LABEL_40:
          v27 = v28;
LABEL_41:
          v33 = v27 < a2;
LABEL_46:
          *(_BYTE *)(v14 + 116) = v33;
LABEL_47:
          v19 = 0;
          v36 = 0;
          break;
        default:
          v27 = 0;
          goto LABEL_47;
      }
      do
      {
        v37 = v10;
        v38 = v9;
        if (v36 <= v27)
          v39 = v27;
        else
          v39 = v36;
        v40 = v36;
        do
        {
          if (v39 == v40)
          {
            v36 = v39;
            goto LABEL_63;
          }
          v36 = v40 + 1;
          HeapData = (unsigned int *)TrieAccessContext::getHeapData((TrieAccessContext *)v14, v24[v40], 0);
          v40 = v36;
        }
        while (!HeapData);
        if (*(_BYTE *)(v14 + 73))
          v42 = bswap32(*HeapData);
        else
          v42 = *HeapData;
        v9 = v38;
        v10 = v37;
        v43 = TrieAccessContext::processHomographData((TrieAccessContext *)v14, (const unsigned __int8 *)HeapData, 4, v42, 0, a2, &v51[v18], &v47[v18], v48, &v37[v18], v9, &v53, &v52);
        a2 -= v43;
        v18 += v43;
        v19 = v52;
        if (a2)
          v44 = v52 < 1;
        else
          v44 = 0;
      }
      while (v44);
LABEL_63:
      if (*(_BYTE *)(v14 + 116))
        v45 = v36 == v27;
      else
        v45 = 0;
      v46 = v45;
      *(_BYTE *)(v14 + 116) = v46;
      *(_QWORD *)(v14 + 120) += v36;
      v16 = v50;
      if (!v50)
        return v18;
      goto LABEL_12;
    }
    v19 = 0;
  }
  if (!a9)
    return v18;
LABEL_12:
  if (*(_BYTE *)(v14 + 116))
  {
    v20 = *(_QWORD *)(v14 + 160);
    if (!v20)
      goto LABEL_16;
  }
  if (!v18)
  {
    v20 = v19 + 16;
LABEL_16:
    *v16 = v20;
  }
  return v18;
}

uint64_t TrieAccessContext::getMatchData(TrieAccessContext *this, uint64_t a2, uint64_t a3, CFRange *a4, CFRange **a5, uint64_t *a6)
{
  *a5 = a4;
  if (a6)
    *a6 = a3;
  if (!a2)
    a2 = 1000;
  return TrieAccessContext::getMatchDataCommon((uint64_t)this, a2, 0, 0, 1, a4, (unsigned __int8 *)a4, (unsigned __int8 *)a4 + a3, a6);
}

uint64_t TrieAccessContext::processHomographData(TrieAccessContext *this, const unsigned __int8 *a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, const unsigned __int8 **a7, uint64_t *a8, BOOL a9, CFRange *a10, unsigned __int8 *a11, unsigned __int8 **a12, uint64_t *a13)
{
  uint64_t v14;
  TrieAccessContext *v15;
  uint64_t v16;
  const unsigned __int8 *v17;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  unsigned __int8 *v21;
  CFRange *v22;
  uint64_t v23;
  unsigned __int8 v30;

  v14 = a3;
  v15 = this;
  v16 = 0;
  v17 = &a2[a3];
  *((_QWORD *)this + 20) = 0;
  v18 = a4;
  while (1)
  {
    v30 = 0;
    v19 = (*((uint64_t (**)(_QWORD, const unsigned __int8 *, unsigned __int8 *))v15 + 21))(*((_QWORD *)v15 + 22), v17, &v30);
    v20 = v19;
    if (!a9)
      break;
    v21 = &(*a12)[-v19];
    if (&a10[v16 + 1] > (CFRange *)v21)
    {
      *a13 = v20;
      v17 = &a2[v30 + v20 + v14];
      ++a5;
LABEL_11:
      v15 = this;
      goto LABEL_13;
    }
    *a12 = v21;
    memmove(v21, &v17[v30], v20);
    v22 = &a10[v16];
    v22->location = *a12 - a11;
    v22->length = v20;
    v14 += v20 + v30;
    v17 = &a2[v14];
    ++a5;
    if (v16 + 1 == a6)
    {
      v16 = a6;
      goto LABEL_11;
    }
    ++v16;
    v15 = this;
LABEL_7:
    if (a5 == v18)
      return v16;
  }
  a8[v16] = v19;
  v23 = v30;
  a7[v16++] = &v17[v30];
  v14 += v19 + v23;
  v17 = &a2[v14];
  ++a5;
  if (v16 != a6)
    goto LABEL_7;
  v16 = a6;
LABEL_13:
  if (a5 < v18)
  {
    *((_QWORD *)v15 + 19) = a5;
    *((_QWORD *)v15 + 20) = v17;
    *((_QWORD *)v15 + 18) = v18;
  }
  return v16;
}

uint64_t trie_exact_match_search(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  int v9;

  if (*(_QWORD *)(a1 + 24) < 2uLL)
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)(a1 + 8);
  if (a3)
  {
    v5 = 1;
    while (1)
    {
      v6 = *a2++;
      v7 = *(_DWORD *)(v4 + 8 * v5) + v6 + 1;
      if (*(_DWORD *)(v4 + 8 * v7 + 4) != v5)
        return 0xFFFFFFFFLL;
      v5 = v7;
      if (!--a3)
        goto LABEL_9;
    }
  }
  v7 = 1;
LABEL_9:
  v8 = *(unsigned int *)(v4 + 8 * v7);
  result = 0xFFFFFFFFLL;
  if (*(_DWORD *)(v4 + 8 * v8 + 4) == v7)
  {
    v9 = *(_DWORD *)(v4 + 8 * v8);
    if (v9 < 0)
      return -v9;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t btrie_exact_match_search(uint64_t a1, unsigned __int8 *__s2, unsigned int a3, uint8x8_t a4)
{
  unsigned int *v6;
  unsigned int v7;
  int v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  unsigned int *v16;
  unsigned int v17;
  _DWORD *v18;
  unsigned __int8 *v19;
  int v20;
  unsigned __int8 *v21;
  char *v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  size_t v26;
  int v27;
  int v28;

  v6 = (unsigned int *)a1;
  while (1)
  {
    v7 = *v6;
    v8 = v7 & 3;
    if (v8 != 2)
      break;
    v10 = *(_QWORD *)(a1 + 8);
    v11 = v7 - 2;
    v9 = (char *)(v10 + v11);
    if (!a3)
      return *(unsigned int *)v9;
    v12 = *__s2;
    v13 = v12 >> 5;
    v14 = *(_DWORD *)&v9[4 * (v12 >> 5) + 4];
    if (((v14 >> v12) & 1) == 0)
      return 0;
    if (v12 >= 0x20)
    {
      v15 = 0;
      if (v13 <= 1)
        v13 = 1;
      else
        v13 = v13;
      v16 = (unsigned int *)(v10 + v11 + 4);
      do
      {
        v17 = *v16++;
        a4 = (uint8x8_t)vcnt_s8((int8x8_t)v17);
        a4.i16[0] = vaddlv_u8(a4);
        v15 += a4.i32[0];
        --v13;
      }
      while (v13);
    }
    else
    {
      v15 = 0;
    }
    a4.i32[0] = v14 & ~(-1 << (v12 & 0x1F));
    a4 = (uint8x8_t)vcnt_s8((int8x8_t)a4);
    a4.i16[0] = vaddlv_u8(a4);
    v6 = (unsigned int *)&v9[4 * (v15 + a4.i32[0]) + 40];
LABEL_16:
    --a3;
    ++__s2;
  }
  if (v8 == 3)
  {
    v9 = (char *)(*(_QWORD *)(a1 + 8) + v7 - 3);
    if (!a3)
      return *(unsigned int *)v9;
    v6 = (unsigned int *)&v9[4 * *__s2 + 4];
    goto LABEL_16;
  }
  if (v8 != 1)
    return 0;
  v18 = (_DWORD *)(*(_QWORD *)(a1 + 16) + v7 - 1);
  v9 = (char *)(v18 + 1);
  if (a3)
  {
    v20 = *v18;
    v19 = (unsigned __int8 *)(v18 + 2);
    v21 = (unsigned __int8 *)&v9[v20];
    while (v19 < v21)
    {
      v24 = *v19;
      v22 = (char *)(v19 + 1);
      v23 = v24;
      v25 = v24 - a3;
      if (v24 >= a3)
        v26 = a3;
      else
        v26 = v23;
      v27 = memcmp(v22, __s2, v26);
      if (v27)
        v28 = v27;
      else
        v28 = v25;
      if ((v28 & 0x80000000) == 0)
      {
        if (v28)
          return 0;
        v9 = &v22[v23];
        return *(unsigned int *)v9;
      }
      v19 = (unsigned __int8 *)&v22[v23 + 4];
    }
    return 0;
  }
  return *(unsigned int *)v9;
}

unint64_t trie_prefix_match_search(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  unint64_t v12;
  uint64_t v13;

  v6 = 0;
  v12 = 0;
  v13 = a4;
  if (*(_QWORD *)(a1 + 24) >= 2uLL)
  {
    v7 = 1;
    if (a2 && a3)
    {
      v8 = *(_QWORD *)(a1 + 8);
      v9 = 1;
      while (1)
      {
        v10 = *a2++;
        v7 = *(_DWORD *)(v8 + 8 * v9) + v10 + 1;
        if (*(_DWORD *)(v8 + 8 * v7 + 4) != v9)
          return 0;
        v9 = v7;
        if (!--a3)
          goto LABEL_7;
      }
    }
    else
    {
LABEL_7:
      __search_node_tree(a1, a5, &v13, &v12, a6, v7);
      return v12;
    }
  }
  return v6;
}

unint64_t trie_wildcard_match_search(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, uint64_t a6, unint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v10;
  uint64_t v11;

  v8 = 0;
  v11 = a6;
  v10 = 0;
  if (*(_QWORD *)(a1 + 24) >= 2uLL)
  {
    __wildcard_match_str(a1, a7, &v11, &v10, a8, 1, a2, a3, a4, a5);
    return v10;
  }
  return v8;
}

unint64_t btrie_wildcard_match_search(unsigned int *a1, _BYTE *a2, int a3, unsigned int a4, uint64_t a5, unint64_t a6, uint64_t a7, uint8x8_t a8)
{
  uint64_t v11;
  unint64_t v13;
  uint64_t v14;

  v14 = a5;
  v11 = *a1;
  v13 = 0;
  __btrie_wildcard_match((uint64_t)a1, v11, &v13, a2, a3, a4, &v14, a6, a8, a7, 0, 0);
  return v13;
}

uint64_t trie_common_prefix_search(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;

  if (*(_QWORD *)(a1 + 24) < 2uLL || a3 == 0)
    return 0;
  result = 0;
  v9 = 0;
  v10 = *(_QWORD *)(a1 + 8);
  LODWORD(v11) = 1;
  do
  {
    v12 = v11;
    v11 = *(_DWORD *)(v10 + 8 * v11) + *(unsigned __int8 *)(a2 + v9) + 1;
    if (*(_DWORD *)(v10 + 8 * v11 + 4) != v12)
      break;
    v13 = *(unsigned int *)(v10 + 8 * v11);
    if (*(_DWORD *)(v10 + 8 * v13 + 4) == (_DWORD)v11)
    {
      v14 = *(_DWORD *)(v10 + 8 * v13);
      if (v14 < 0)
      {
        if (a4)
        {
          *(_DWORD *)(a5 + 4 * result) = -v14;
          if (a6)
            *(_QWORD *)(a6 + 8 * result) = v9 + 1;
          if (++result >= a4)
            return result;
        }
        else
        {
          ++result;
        }
      }
    }
    ++v9;
  }
  while (a3 != v9);
  return result;
}

uint64_t TrieAccessContext::getHeapData(TrieAccessContext *this, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  result = TrieAccessContext::keyDataHeapContext(this);
  if (result)
  {
    v7 = result;
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)result + 64))(result))
    {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v7 + 48))(v7, a2, a3);
    }
    else
    {
      v8 = *((_QWORD *)this + 6);
      if (!v8)
      {
        *((_QWORD *)this + 7) = 0x8000;
        v8 = operator new[]();
        *((_QWORD *)this + 6) = v8;
      }
      v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v7 + 56))(v7, a2, *((_QWORD *)this + 7), v8);
      if (v9 > *((_QWORD *)this + 7))
      {
        v10 = *((_QWORD *)this + 6);
        if (v10)
          MEMORY[0x1D17BC778](v10, 0x1000C8077774924);
        *((_QWORD *)this + 7) = v9;
        v11 = operator new[]();
        *((_QWORD *)this + 6) = v11;
        (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v7 + 56))(v7, a2, *((_QWORD *)this + 7), v11);
      }
      if (a3)
        *a3 = v9;
      return *((_QWORD *)this + 6);
    }
  }
  return result;
}

BOOL TrieAccessContext::containsMatchData(TrieAccessContext *this, unsigned __int8 *a2, uint8x8_t a3)
{
  char *v3;
  unint64_t v4;
  BOOL v5;
  _BOOL8 result;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  int v28;
  int *v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t v38;
  char *v39;
  int v40;
  int v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unsigned int v47;
  int v48;
  unsigned int *v49;
  unsigned int v50;
  BOOL v51;
  int *v52;
  unsigned int *v53;
  _DWORD *v54;
  unsigned __int8 *v55;
  int v56;
  unsigned __int8 *v57;
  char *v58;
  uint64_t v59;
  unsigned int v60;
  int v61;
  size_t v62;
  int v63;
  int v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67[2];

  v67[1] = *MEMORY[0x1E0C80C00];
  v3 = (char *)*((_QWORD *)this + 10);
  v4 = *((_QWORD *)this + 12);
  if (v3)
    v5 = v4 == 0;
  else
    v5 = 1;
  if (v5)
    return 0;
  v9 = *((_DWORD *)this + 28);
  if (!a2 || v9 != 2)
    goto LABEL_11;
  if (v4 >= 2)
  {
    bzero(a2, v4 >> 1);
    v9 = *((_DWORD *)this + 28);
LABEL_11:
    switch(v9)
    {
      case 0:
        if (*((_WORD *)this + 37) != 1)
        {
          if (*((_WORD *)this + 37))
          {
            v51 = mtrie_exact_match_search(*((_QWORD *)this + 3), v3, v4) == 0;
            return !v51;
          }
          v10 = *((_QWORD *)this + 3);
          if (*(_QWORD *)(v10 + 24) < 2uLL)
            return 0;
          v11 = *(_QWORD *)(v10 + 8);
          v12 = 1;
          do
          {
            v13 = *v3++;
            v14 = (*(_DWORD *)(v11 + 8 * v12) + v13 + 1);
            if (*(_DWORD *)(v11 + 8 * v14 + 4) != v12)
              return 0;
            v12 = v14;
            --v4;
          }
          while (v4);
          v15 = *(unsigned int *)(v11 + 8 * v14);
          if (*(_DWORD *)(v11 + 8 * v15 + 4) == (_DWORD)v14)
            return *(_DWORD *)(v11 + 8 * v15) >> 31;
          return 0;
        }
        v38 = *((_QWORD *)this + 3);
        v39 = (char *)v38;
        break;
      case 1:
        if (*((_WORD *)this + 37) == 1)
        {
          v52 = (int *)*((_QWORD *)this + 3);
          v66 = 0;
          v67[0] = 0;
          __btrie_find_prefix((uint64_t)v52, *v52, (unsigned __int8 *)v3, v4, v67, 1uLL, &v66, (uint64_t)&v65 + 4, a3);
          goto LABEL_68;
        }
        if (*((_WORD *)this + 37))
          return 0;
        v22 = *((_QWORD *)this + 3);
        v66 = 0;
        v67[0] = 0;
        if (*(_QWORD *)(v22 + 24) < 2uLL)
          return 0;
        v23 = *(_QWORD *)(v22 + 8);
        v24 = 1;
        do
        {
          v25 = v24;
          v26 = *v3++;
          v24 = *(_DWORD *)(v23 + 8 * v24) + v26 + 1;
          if (*(_DWORD *)(v23 + 8 * v24 + 4) != v25)
            return 0;
          --v4;
        }
        while (v4);
        __search_node_tree(v22, 1uLL, v67, &v66, (uint64_t)&v65 + 4, v24);
        goto LABEL_68;
      case 2:
        goto LABEL_20;
      case 3:
        if (*((_WORD *)this + 37) == 1)
        {
          v53 = (unsigned int *)*((_QWORD *)this + 3);
          v66 = 0;
          v67[0] = 0;
          __btrie_wildcard_match((uint64_t)v53, *v53, &v66, v3, v4, 2u, v67, 1uLL, a3, (uint64_t)&v65 + 4, 0, 0);
        }
        else
        {
          if (*((_WORD *)this + 37))
            return 0;
          v27 = *((_QWORD *)this + 3);
          v28 = *((unsigned __int8 *)this + 73);
          v66 = 0;
          v67[0] = 0;
          if (*(_QWORD *)(v27 + 24) < 2uLL)
            return 0;
          __wildcard_match_str(v27, 1uLL, v67, &v66, (uint64_t)&v65 + 4, 1, (uint64_t)v3, v4, v28 == 0, 2u);
        }
LABEL_68:
        v51 = v66 == 0;
        return !v51;
      default:
        return 0;
    }
    while (1)
    {
      v40 = *(_DWORD *)v39;
      v41 = v40 & 3;
      switch(v41)
      {
        case 2:
          v43 = *(_QWORD *)(v38 + 8);
          v44 = (v40 - 2);
          v42 = (char *)(v43 + v44);
          if (!(_DWORD)v4)
            goto LABEL_86;
          v45 = *v3;
          v46 = v45 >> 5;
          v47 = *(_DWORD *)&v42[4 * (v45 >> 5) + 4];
          if (((v47 >> v45) & 1) == 0)
            return 0;
          if (v45 >= 0x20)
          {
            v48 = 0;
            if (v46 <= 1)
              v46 = 1;
            else
              v46 = v46;
            v49 = (unsigned int *)(v43 + v44 + 4);
            do
            {
              v50 = *v49++;
              a3 = (uint8x8_t)vcnt_s8((int8x8_t)v50);
              a3.i16[0] = vaddlv_u8(a3);
              v48 += a3.i32[0];
              --v46;
            }
            while (v46);
          }
          else
          {
            v48 = 0;
          }
          a3.i32[0] = v47 & ~(-1 << (v45 & 0x1F));
          a3 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
          a3.i16[0] = vaddlv_u8(a3);
          v39 = &v42[4 * (v48 + a3.i32[0]) + 40];
          break;
        case 3:
          v42 = (char *)(*(_QWORD *)(v38 + 8) + (v40 - 3));
          if (!(_DWORD)v4)
            goto LABEL_86;
          v39 = &v42[4 * *v3 + 4];
          break;
        case 1:
          v54 = (_DWORD *)(*(_QWORD *)(v38 + 16) + (v40 - 1));
          v42 = (char *)(v54 + 1);
          if (!(_DWORD)v4)
            goto LABEL_86;
          v56 = *v54;
          v55 = (unsigned __int8 *)(v54 + 2);
          v57 = (unsigned __int8 *)&v42[v56];
          if (v55 >= v57)
            return 0;
          while (1)
          {
            v60 = *v55;
            v58 = (char *)(v55 + 1);
            v59 = v60;
            v61 = v60 - v4;
            v62 = v60 >= v4 ? v4 : v59;
            v63 = memcmp(v58, v3, v62);
            v64 = v63 ? v63 : v61;
            if ((v64 & 0x80000000) == 0)
              break;
            result = 0;
            v55 = (unsigned __int8 *)&v58[v59 + 4];
            if (v55 >= v57)
              return result;
          }
          if (!v64)
          {
            v42 = &v58[v59];
LABEL_86:
            v51 = *(_DWORD *)v42 == 0;
            return !v51;
          }
          return 0;
        default:
          return 0;
      }
      LODWORD(v4) = v4 - 1;
      ++v3;
    }
  }
LABEL_20:
  v16 = MEMORY[0x1E0C80A78](this);
  MEMORY[0x1E0C80A78](v16);
  v19 = (unint64_t *)((char *)&v65 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (a2)
    v20 = v4;
  else
    v20 = 1;
  if (*((_WORD *)this + 37) == 1)
  {
    v29 = (int *)*((_QWORD *)this + 3);
    v67[0] = 0;
    __btrie_find_common_prefix((uint64_t)v29, *v29, (unsigned __int8 *)v3, v4, v20, v67, v17, (uint64_t)v19, (uint64_t)v3);
    v30 = v67[0];
  }
  else
  {
    if (*((_WORD *)this + 37))
      return 0;
    v21 = *((_QWORD *)this + 3);
    if (*(_QWORD *)(v21 + 24) < 2uLL)
      return 0;
    v30 = 0;
    v32 = 0;
    v33 = *(_QWORD *)(v21 + 8);
    LODWORD(v34) = *(_DWORD *)(v33 + 8);
    LODWORD(v35) = 1;
    do
    {
      v36 = v35;
      v35 = v34 + v3[v32] + 1;
      if (*(_DWORD *)(v33 + 8 * v35 + 4) != v36)
        break;
      v34 = *(unsigned int *)(v33 + 8 * v35);
      if (*(_DWORD *)(v33 + 8 * v34 + 4) == (_DWORD)v35)
      {
        v37 = *(_DWORD *)(v33 + 8 * v34);
        if (v37 < 0)
        {
          *(_DWORD *)(v17 + 4 * v30) = -v37;
          v19[v30++] = v32 + 1;
          if (v30 >= v20)
            break;
        }
      }
      ++v32;
    }
    while (v4 != v32);
  }
  for (result = v30 != 0; v30; --v30)
  {
    v31 = *v19++;
    a2[(v31 >> 1) - 1] = 1;
  }
  return result;
}

uint64_t TrieAccessContext::addRecord(TrieAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4, size_t a5, unint64_t *a6)
{
  uint64_t result;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _BYTE *SizeBytesEmbededData;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  const unsigned __int16 *v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  size_t v26;
  _DWORD *v27;
  int v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *HeapData;
  uint64_t v36;
  uint64_t v37;
  unsigned __int8 v38;
  uint64_t v39;
  size_t v40[2];

  v40[1] = *MEMORY[0x1E0C80C00];
  v40[0] = a5;
  result = TrieAccessContext::keyDataHeapContext(this);
  if (!result)
    return result;
  if (!*((_BYTE *)this + 72) || *((_WORD *)this + 37))
    return 0;
  v13 = result;
  v14 = 2 * a3;
  MEMORY[0x1E0C80A78](result);
  if (*((_BYTE *)this + 73))
  {
    if (a3)
    {
      v15 = 0;
      do
      {
        *(_WORD *)((char *)&v32 + 2 * v15 - ((2 * a3 + 15) & 0xFFFFFFFFFFFFFFF0)) = bswap32(a2[v15]) >> 16;
        ++v15;
      }
      while (a3 != v15);
    }
    a2 = (const unsigned __int16 *)((char *)&v32 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0));
  }
  v39 = 0;
  v38 = 0;
  (*((void (**)(_QWORD, uint64_t *, unsigned __int8 *))this + 21))(*((_QWORD *)this + 22), &v39, &v38);
  SizeBytesEmbededData = CreateSizeBytesEmbededData(a4, a5, v38, *((unsigned __int8 *)this + 73), v40);
  v37 = 0;
  v17 = *((_QWORD *)this + 3);
  if (*(_QWORD *)(v17 + 24) >= 2uLL)
  {
    v18 = *(_QWORD *)(v17 + 8);
    if (v14)
    {
      v19 = 1;
      v20 = a2;
      v21 = 2 * a3;
      while (1)
      {
        v22 = *(unsigned __int8 *)v20;
        v20 = (const unsigned __int16 *)((char *)v20 + 1);
        v23 = *(_DWORD *)(v18 + 8 * v19) + v22 + 1;
        if (*(_DWORD *)(v18 + 8 * v23 + 4) != v19)
          break;
        v19 = v23;
        if (!--v21)
          goto LABEL_17;
      }
    }
    else
    {
      v23 = 1;
LABEL_17:
      v24 = *(unsigned int *)(v18 + 8 * v23);
      if (*(_DWORD *)(v18 + 8 * v24 + 4) == v23)
      {
        v25 = *(_DWORD *)(v18 + 8 * v24);
        if (v25 < 0)
        {
          v30 = -v25;
          HeapData = (_DWORD *)TrieAccessContext::getHeapData(this, v30, &v37);
          if (HeapData)
          {
            v33 = v37;
            v34 = v30;
            v26 = v40[0] + v37;
            v27 = malloc_type_malloc(v40[0] + v37, 0x61F944FuLL);
            memcpy(v27, HeapData, v37);
            memcpy((char *)v27 + v33, SizeBytesEmbededData, v40[0]);
            if (*((_BYTE *)this + 73))
              v31 = bswap32(bswap32(*HeapData) + 1);
            else
              v31 = *HeapData + 1;
            *v27 = v31;
            (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v13 + 80))(v13, 0, 0, 0, 0, v34);
            goto LABEL_23;
          }
        }
      }
    }
  }
  v26 = v40[0] + 4;
  v27 = malloc_type_malloc(v40[0] + 4, 0xBCD0B6ECuLL);
  memcpy(v27 + 1, SizeBytesEmbededData, v40[0]);
  if (*((_BYTE *)this + 73))
    v28 = 0x1000000;
  else
    v28 = 1;
  *v27 = v28;
LABEL_23:
  if (v40[0] != a5)
    free(SizeBytesEmbededData);
  v36 = 0;
  v29 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _DWORD *, size_t, uint64_t *))(*(_QWORD *)v13 + 72))(v13, 0, 0, v27, v26, &v36);
  free(v27);
  if (!v29)
    return 0;
  result = trie_insert_key(*((_QWORD *)this + 3), (uint64_t)a2, v14, v36) == 0;
  if (a6)
    *a6 = 0;
  return result;
}

uint64_t trie_insert_key(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  int i;
  unsigned int v21;
  int v22;
  int v24;
  uint64_t v25;
  _BOOL4 v26;
  int v27;
  uint64_t list;
  unint64_t v29;
  unint64_t v30;
  unsigned int v31;
  unint64_t v32;
  _BYTE *v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  __int16 v37;
  int v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  _BYTE v43[514];
  _BYTE v44[514];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 24);
  if (v8 <= 1 && __resize_array(a1, v8 + 0x2000))
    return 0xFFFFFFFFLL;
  v9 = *(_DWORD *)(a1 + 16);
  if (!v9)
  {
    v10 = *(_QWORD *)a1;
    *(_QWORD *)v10 = 0x1074726965;
    *(_DWORD *)(v10 + 8) = 65793;
    *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) = 1;
    v9 = 1;
    *(_DWORD *)(a1 + 16) = 1;
  }
  v11 = 0;
  v12 = 1;
  while (1)
  {
    if (a3 == v11)
    {
      v13 = *(_QWORD *)(a1 + 8);
      if (v9 < v12)
      {
        v14 = 0;
        goto LABEL_18;
      }
      v14 = *(unsigned int *)(v13 + 8 * v12);
    }
    else
    {
      v15 = v9 >= v12 ? *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v12) : 0;
      v14 = v15 + *(unsigned __int8 *)(a2 + v11) + 1;
    }
    if (v9 < v14)
    {
      if ((_DWORD)v12)
        goto LABEL_22;
      goto LABEL_20;
    }
    v13 = *(_QWORD *)(a1 + 8);
LABEL_18:
    if (*(_DWORD *)(v13 + 8 * v14 + 4) != (_DWORD)v12)
    {
LABEL_22:
      v17 = -a4;
      while (1)
      {
        if (v11 == a3)
          v18 = 0;
        else
          v18 = *(unsigned __int8 *)(a2 + v11) + 1;
        v19 = *(_DWORD *)(a1 + 16);
        if (v19 < v12 || !*(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v12))
        {
          for (i = 1; ; ++i)
          {
            v21 = i + v18;
            v22 = v19 >= i + v18 ? *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v21 + 4) : 0;
            if (v21 != 1 && v22 == 0)
              break;
          }
          __write_base(a1, v12, i);
          v19 = *(_DWORD *)(a1 + 16);
        }
        v24 = v19 >= v12 ? *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v12) : 0;
        v25 = (v24 + v18);
        v26 = v19 >= v25 && *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v25 + 4) != 0;
        if ((_DWORD)v25 == 1 || v26)
          break;
        v27 = v12;
        v12 = v25;
LABEL_59:
        if (v19 < v12 || !*(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v12 + 4))
        {
          __write_check(a1, v12, v27);
          if (!v18)
            __write_base(a1, v12, v17);
        }
        if (++v11 > a3)
          goto LABEL_67;
      }
      list = __get_list(a1, v12, (uint64_t)v44);
      if ((_DWORD)v25 != 1)
      {
        if (v19 >= v25)
        {
          v31 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v25 + 4);
          v32 = __get_list(a1, v31, (uint64_t)v43);
          if (list + 1 >= v32)
          {
            v30 = v32;
            goto LABEL_54;
          }
        }
        else
        {
          v29 = __get_list(a1, 0, (uint64_t)v43);
          if (list + 1 >= v29)
          {
            v30 = v29;
            v31 = 0;
LABEL_54:
            v33 = v43;
            v34 = a1;
            v35 = v12;
            v36 = v31;
            v37 = 0;
            v38 = 0;
            goto LABEL_55;
          }
        }
      }
      v33 = v44;
      v34 = a1;
      v35 = v12;
      v36 = v12;
      v30 = list;
      v37 = v18;
      v38 = 1;
LABEL_55:
      v39 = __modify_array(v34, v35, v36, (uint64_t)v33, v30, v37, v38);
      v27 = v39;
      v19 = *(_DWORD *)(a1 + 16);
      if (v19 >= v39)
        v40 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v39);
      else
        v40 = 0;
      v12 = (v40 + v18);
      goto LABEL_59;
    }
    v16 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v14);
    if (v16 < 0)
      break;
LABEL_20:
    ++v11;
    v12 = v14;
    if (v11 > a3)
      goto LABEL_67;
  }
  if (v16 + a4)
    __write_base(a1, v14, -a4);
LABEL_67:
  v41 = *(unsigned int *)(a1 + 16);
  *(_DWORD *)(*(_QWORD *)a1 + 12) = v41;
  if ((unint64_t)(*(_QWORD *)(a1 + 24) + ~v41) <= 0x101
    && __resize_array(a1, (v41 + 259)))
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 0;
  }
}

BOOL TrieAccessContext::deleteRecord(TrieAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4, size_t a5)
{
  uint64_t v10;
  _BOOL8 v11;
  uint64_t v13;
  unint64_t v14;
  const unsigned __int16 *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  unint64_t v44[2];
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  const void *v48;
  size_t v49;
  char *v50;
  unsigned int *HeapData;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55[2];

  v55[1] = *MEMORY[0x1E0C80C00];
  v10 = TrieAccessContext::keyDataHeapContext(this);
  if (!v10 || !*((_BYTE *)this + 72) || *((_WORD *)this + 37))
    return 0;
  v13 = v10;
  MEMORY[0x1E0C80A78](v10);
  v15 = (const unsigned __int16 *)((char *)v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (*((_BYTE *)this + 73))
  {
    if (!a3)
    {
      v18 = (uint64_t *)((char *)this + 24);
      v23 = *((_QWORD *)this + 3);
      if (*(_QWORD *)(v23 + 24) >= 2uLL)
      {
        v19 = *(_QWORD *)(v23 + 8);
        goto LABEL_20;
      }
      return 0;
    }
    v16 = 0;
    do
    {
      v15[v16] = bswap32(a2[v16]) >> 16;
      ++v16;
    }
    while (a3 != v16);
  }
  else
  {
    v15 = a2;
  }
  v18 = (uint64_t *)((char *)this + 24);
  v17 = *((_QWORD *)this + 3);
  if (*(_QWORD *)(v17 + 24) < 2uLL)
    return 0;
  v19 = *(_QWORD *)(v17 + 8);
  if (v14)
  {
    v20 = 0;
    v21 = 1;
    while (1)
    {
      v22 = v21;
      v21 = *(_DWORD *)(v19 + 8 * v21) + *((unsigned __int8 *)v15 + v20) + 1;
      if (*(_DWORD *)(v19 + 8 * v21 + 4) != v22)
        return 0;
      if (v14 == ++v20)
        goto LABEL_21;
    }
  }
LABEL_20:
  v21 = 1;
LABEL_21:
  v24 = *(unsigned int *)(v19 + 8 * v21);
  if (*(_DWORD *)(v19 + 8 * v24 + 4) != v21)
    return 0;
  v25 = *(_DWORD *)(v19 + 8 * v24);
  if ((v25 & 0x80000000) == 0)
    return 0;
  v44[0] = v14;
  v26 = -v25;
  v55[0] = 0;
  HeapData = (unsigned int *)TrieAccessContext::getHeapData(this, v26, v55);
  if (!HeapData)
    return 0;
  v44[1] = (unint64_t)v44;
  v27 = *((unsigned __int8 *)this + 73);
  v46 = v18;
  v47 = v13;
  if (v27)
    v28 = bswap32(*HeapData);
  else
    v28 = *HeapData;
  v45 = v26;
  v50 = (char *)malloc_type_malloc(v55[0] + 8 * v28, 0x79232F17uLL);
  if (v28)
  {
    v48 = a4;
    v49 = a5;
    v52 = 4;
    v53 = 0;
    v29 = 4;
    do
    {
      v30 = (char *)HeapData + v29;
      LOBYTE(v54) = 0;
      v31 = (*((uint64_t (**)(_QWORD, char *, uint64_t *))this + 21))(*((_QWORD *)this + 22), (char *)HeapData + v29, &v54);
      v32 = v54;
      if (v31 != a5 || memcmp(v48, &v30[v54], a5))
      {
        v33 = v52;
        memcpy(&v50[v52], v30, v31 + v32);
        a5 = v49;
        v52 = v31 + v32 + v33;
        ++v53;
      }
      v29 += v31 + v32;
      --v28;
    }
    while (v28);
  }
  else
  {
    v52 = 4;
    v53 = 0;
  }
  v34 = v53;
  if (*((_BYTE *)this + 73))
    *(_DWORD *)v50 = bswap32(v53);
  else
    *(_DWORD *)v50 = v53;
  v36 = v46;
  v35 = v47;
  (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v47 + 80))(v47, 0, 0, 0, 0, v45);
  if (v34 <= 0)
  {
    v37 = *v36;
    v38 = *(_DWORD *)(*v36 + 16);
    v39 = -2 * a3;
    v40 = 1;
    while (1)
    {
      if (v39)
      {
        if (v38 >= v40)
          v41 = *(_DWORD *)(*(_QWORD *)(v37 + 8) + 8 * v40);
        else
          v41 = 0;
        v43 = v41 + *(unsigned __int8 *)v15 + 1;
      }
      else
      {
        v42 = *(_QWORD *)(v37 + 8);
        if (v38 < v40)
        {
          v43 = 0;
          goto LABEL_55;
        }
        v43 = *(_DWORD *)(v42 + 8 * v40);
      }
      if (v38 < v43)
      {
        if (v40)
          goto LABEL_58;
        goto LABEL_57;
      }
      v42 = *(_QWORD *)(v37 + 8);
LABEL_55:
      if (*(_DWORD *)(v42 + 8 * v43 + 4) != v40)
        goto LABEL_58;
      if ((*(_DWORD *)(v42 + 8 * v43) & 0x80000000) != 0)
      {
        __write_base(*v36, v43, 0);
        __write_check(v37, v43, 0);
        v11 = 1;
        goto LABEL_59;
      }
LABEL_57:
      ++v39;
      v15 = (const unsigned __int16 *)((char *)v15 + 1);
      v40 = v43;
      if (v39 == 1)
        goto LABEL_58;
    }
  }
  v54 = 0;
  if ((*(unsigned int (**)(uint64_t, _QWORD, _QWORD, char *, uint64_t, uint64_t *))(*(_QWORD *)v35 + 72))(v35, 0, 0, v50, v52, &v54))
  {
    v11 = trie_insert_key(*v36, (uint64_t)v15, v44[0], v54) == 0;
  }
  else
  {
LABEL_58:
    v11 = 0;
  }
LABEL_59:
  free(v50);
  return v11;
}

HeapAccessContext *TrieAccessContext::buildWithRecords(TrieAccessContext *this, const __CFArray *a2, const __CFArray *a3, unint64_t *a4)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  const __CFArray *v7;
  const __CFArray *v8;
  const __CFArray *v9;
  const __CFArray *v10;
  uint64_t v11;
  int64_t Count;
  HeapAccessContext *result;
  CFStringEncoding v14;
  _QWORD *v15;
  const void ***v16;
  CFIndex i;
  const __CFString *ValueAtIndex;
  UInt8 *v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  const void *v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 **v26;
  const void **v27;
  unint64_t v28;
  const void *v29;
  size_t v30;
  unsigned __int8 **v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t v34;
  _QWORD *v35;
  int v36;
  uint64_t v37;
  uint64_t *v38;
  _DWORD *v39;
  void ***v40;
  void **v41;
  uint64_t v42;
  uint64_t v43;
  HeapAccessContext *v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  _DWORD *v48;
  uint64_t *v49;
  unsigned __int8 v50;
  uint64_t v51;
  unint64_t v52;
  _QWORD v53[4];
  char v54[8224];
  uint64_t v55;

  v4 = MEMORY[0x1E0C80A78](this);
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v11 = v4;
  v55 = *MEMORY[0x1E0C80C00];
  Count = CFArrayGetCount(v9);
  result = (HeapAccessContext *)TrieAccessContext::keyDataHeapContext((TrieAccessContext *)v11);
  if (!result)
    return result;
  if (!*(_BYTE *)(v11 + 72))
    return 0;
  v44 = result;
  v45 = v6;
  v51 = 0;
  v52 = 0;
  if (*(_BYTE *)(v11 + 73))
    v14 = 268435712;
  else
    v14 = 335544576;
  v50 = 0;
  (*(void (**)(_QWORD, uint64_t *, unsigned __int8 *))(v11 + 168))(*(_QWORD *)(v11 + 176), &v51, &v50);
  v15 = (_QWORD *)operator new[]();
  v16 = (const void ***)operator new[]();
  v47 = operator new[]();
  v49 = (uint64_t *)operator new[]();
  v48 = (_DWORD *)operator new[]();
  v46 = v15;
  if (Count < 1)
  {
    qsort(v16, Count, 8uLL, (int (__cdecl *)(const void *, const void *))sortingComparator);
    v21 = 0;
    v26 = (unsigned __int8 **)v47;
LABEL_22:
    if (*(_WORD *)(v11 + 74) == 1)
    {
      v39 = v48;
      v38 = v49;
      v36 = btrie_build(*(_QWORD *)(v11 + 24), v21, v26, v49, v48);
      v32 = v45;
    }
    else
    {
      v32 = v45;
      if (!*(_WORD *)(v11 + 74))
      {
        v33 = *(_QWORD *)(v11 + 24);
        v34 = *(_QWORD *)(v33 + 24);
        v35 = v46;
        if (v34 <= 1 && __resize_array(*(_QWORD *)(v11 + 24), v34 + 0x2000))
        {
          v36 = -1;
          v37 = (uint64_t)v44;
          v39 = v48;
          v38 = v49;
LABEL_31:
          HeapAccessContext::compact(v37);
          MEMORY[0x1D17BC778](v26, 0x50C80EE9192B6);
          MEMORY[0x1D17BC778](v38, 0x1000C8000313F17);
          MEMORY[0x1D17BC778](v39, 0x1000C8052888210);
          if (Count >= 1)
          {
            v40 = (void ***)v16;
            do
            {
              v41 = *v40++;
              free(*v41);
              --Count;
            }
            while (Count);
          }
          MEMORY[0x1D17BC778](v16, 0x20C8093837F09);
          MEMORY[0x1D17BC778](v35, 0x1070C80BBF44EAALL);
          if (v32)
            *v32 = 0;
          return (HeapAccessContext *)(v36 == 0);
        }
        v42 = *(_QWORD *)v33;
        *(_QWORD *)v42 = 0x1074726965;
        *(_DWORD *)(v42 + 8) = 65793;
        *(_QWORD *)(*(_QWORD *)(v33 + 8) + 8) = 1;
        *(_DWORD *)(v33 + 16) = 1;
        *(_DWORD *)(v33 + 76) = 0;
        v39 = v48;
        v38 = v49;
        *(_QWORD *)(v33 + 48) = v26;
        *(_QWORD *)(v33 + 56) = v49;
        *(_QWORD *)(v33 + 64) = v48;
        v53[1] = 0;
        v53[2] = v21;
        v53[3] = 0;
        __get_children(v33, v53, (uint64_t)v54);
        *(_DWORD *)(v33 + 72) = 2;
        __insert_nodes(v33);
        v43 = *(unsigned int *)(v33 + 16);
        *(_DWORD *)(*(_QWORD *)v33 + 12) = v43;
        if ((unint64_t)(*(_QWORD *)(v33 + 24) + ~v43) <= 0x101
          && __resize_array(v33, (v43 + 259)))
        {
          v36 = -1;
        }
        else
        {
          v36 = *(_DWORD *)(v33 + 76);
        }
LABEL_30:
        v37 = (uint64_t)v44;
        goto LABEL_31;
      }
      v39 = v48;
      v38 = v49;
      v36 = mtrie_build(*(_QWORD *)(v11 + 24), v21, (uint64_t)v26, (uint64_t)v49, (uint64_t)v48);
    }
    v35 = v46;
    goto LABEL_30;
  }
  for (i = 0; i != Count; ++i)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, i);
    v19 = CreateCharactersFromString(ValueAtIndex, v14, &v52);
    v16[i] = (const void **)v15;
    v20 = 2 * v52;
    *v15 = v19;
    v15[1] = v20;
    v15[2] = CFArrayGetValueAtIndex(v8, i);
    v15[3] = i;
    v15 += 4;
  }
  qsort(v16, Count, 8uLL, (int (__cdecl *)(const void *, const void *))sortingComparator);
  v21 = 0;
  v23 = **v16;
  v22 = (size_t)(*v16)[1];
  v24 = 1;
  v25 = 1;
  v26 = (unsigned __int8 **)v47;
  while (1)
  {
    if (v25 < Count)
    {
      v27 = v16[v25];
      v29 = *v27;
      v28 = (unint64_t)v27[1];
      v52 = v28;
      if (v28 == v22)
      {
        if (!memcmp(v29, v23, v22))
        {
          ++v24;
          v26 = (unsigned __int8 **)v47;
          goto LABEL_18;
        }
        v23 = v29;
      }
      else
      {
        v23 = v29;
        v22 = v28;
      }
      v26 = (unsigned __int8 **)v47;
    }
    v30 = TrieAccessContext::addSeriesOfHomographData((unsigned __int8 *)v11, v25 - v24, v24, v50, (uint64_t)v16);
    if (!v30)
      break;
    v31 = (unsigned __int8 **)(&v16[v25])[-v24];
    v26[v21] = *v31;
    v49[v21] = (uint64_t)v31[1];
    v48[v21++] = v30;
    v24 = 1;
LABEL_18:
    if (++v25 - Count == 1)
      goto LABEL_22;
  }
  MEMORY[0x1D17BC778](v48, 0x1000C8052888210);
  MEMORY[0x1D17BC778](v49, 0x1000C8000313F17);
  MEMORY[0x1D17BC778](v26, 0x50C80EE9192B6);
  MEMORY[0x1D17BC778](v16, 0x20C8093837F09);
  MEMORY[0x1D17BC778](v46, 0x1070C80BBF44EAALL);
  return 0;
}

uint64_t sortingComparator(const void ***a1, const void ***a2)
{
  const void **v2;
  const void **v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  size_t v8;
  uint64_t result;

  v2 = *a1;
  v3 = *a2;
  v4 = **a1;
  v5 = v2[1];
  v6 = **a2;
  v7 = v3[1];
  if ((uint64_t)v5 >= (uint64_t)v7)
    v8 = (size_t)v3[1];
  else
    v8 = (size_t)v2[1];
  result = memcmp(v4, v6, v8);
  if (!(_DWORD)result)
  {
    result = ((_DWORD)v5 - (_DWORD)v7);
    if ((_DWORD)v5 == (_DWORD)v7)
      return (*((_DWORD *)v2 + 6) - *((_DWORD *)v3 + 6));
  }
  return result;
}

size_t TrieAccessContext::addSeriesOfHomographData(unsigned __int8 *a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _DWORD *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  const __CFData *v19;
  const UInt8 *BytePtr;
  _BYTE *v21;
  size_t v22;
  uint64_t v23;
  int v24;
  size_t __n;

  if (a3 <= 0)
  {
    v11 = 4;
    v15 = (_DWORD *)operator new[]();
  }
  else
  {
    v10 = a4;
    v11 = 4;
    v12 = a3;
    v13 = (uint64_t *)(a5 + 8 * a2);
    do
    {
      v14 = *v13++;
      v11 += v10 + CFDataGetLength(*(CFDataRef *)(v14 + 16));
      --v12;
    }
    while (v12);
    v15 = (_DWORD *)operator new[]();
    v16 = (char *)(v15 + 1);
    v17 = a5 + 8 * a2;
    v18 = a3;
    do
    {
      v19 = *(const __CFData **)(*(_QWORD *)v17 + 16);
      __n = 0;
      __n = CFDataGetLength(v19);
      BytePtr = CFDataGetBytePtr(v19);
      v21 = CreateSizeBytesEmbededData(BytePtr, __n, a4, a1[73], &__n);
      v22 = __n;
      memcpy(v16, v21, __n);
      if (a4)
      {
        free(v21);
        v22 = __n;
      }
      v16 += v22;
      v17 += 8;
      --v18;
    }
    while (v18);
  }
  if (a1[73])
    *v15 = bswap32(a3);
  else
    *v15 = a3;
  __n = 0;
  v23 = TrieAccessContext::keyDataHeapContext((TrieAccessContext *)a1);
  if (v23)
  {
    v24 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _DWORD *, uint64_t, size_t *))(*(_QWORD *)v23 + 72))(v23, 0, 0, v15, v11, &__n);
    MEMORY[0x1D17BC778](v15, 0x1000C8077774924);
    if (v24)
      return __n;
    else
      return 0;
  }
  else
  {
    MEMORY[0x1D17BC778](v15, 0x1000C8077774924);
    return 0;
  }
}

uint64_t btrie_build(uint64_t a1, uint64_t a2, unsigned __int8 **a3, uint64_t *a4, _DWORD *a5)
{
  char *v10;
  unint64_t v11;
  void *v12;
  int v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  size_t v20;
  uint64_t v21;
  char *v22;
  _DWORD *v23;
  uint64_t (*v24)(char *, size_t, uint64_t);
  unint64_t v25;
  size_t v26;
  size_t v27;
  char *v28;
  char *v29;
  unint64_t v30;
  size_t v31;
  int v32;
  size_t v33;
  size_t v34;
  size_t v35;
  char *v36;
  void *v37;
  _DWORD *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v44;
  size_t v45;
  __int128 v46;
  uint64_t v47;
  int v48;
  void *v49;
  size_t v50;
  size_t __n;
  uint64_t v52;
  int v53;
  void *__src;
  size_t size;
  size_t v56;
  size_t v57;
  int v58;
  _DWORD *v59;
  __int128 v60;
  void *ptr;
  unint64_t v62;
  unsigned int v63;

  v63 = 1024;
  v49 = malloc_type_malloc(0x10000uLL, 0xE8DE09A0uLL);
  v48 = 0;
  bzero(v49, 0x10000uLL);
  __n = 0;
  v52 = 0;
  v50 = 0x10000;
  v10 = (char *)malloc_type_malloc(0x10000uLL, 0xE8DE09A0uLL);
  __src = v10;
  v53 = 0;
  bzero(v10, 0x10000uLL);
  v56 = 0;
  v57 = 0;
  v11 = *(_QWORD *)(a1 + 40);
  size = v11;
  v12 = *(void **)(a1 + 8);
  v60 = *(_OWORD *)(a1 + 56);
  v59 = (_DWORD *)(a1 + 48);
  ptr = v12;
  v58 = 1;
  bzero(v12, v11);
  v46 = xmmword_1CDFA7F10;
  v47 = 0;
  v62 = 0x300000000;
  if (a2)
  {
    do
    {
      v14 = *a4++;
      v13 = v14;
      if ((unint64_t)(v14 - 257) < 0xFFFFFFFFFFFFFF00)
        return 0xFFFFFFFFLL;
      v16 = *a3++;
      v15 = v16;
      LODWORD(v16) = *a5++;
      __btrie_insert_fat((uint64_t)&v46, v62, v15, v13, v16);
      --a2;
    }
    while (a2);
    v17 = *((_QWORD *)&v46 + 1);
    v11 = size;
    v10 = (char *)__src;
    v18 = v52 & 0xFFFFFFFC;
    v19 = (v56 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  }
  else
  {
    v19 = 0;
    v18 = 0;
    v17 = 1028;
  }
  *(_QWORD *)&v46 = v17;
  v50 = v18 + *(unsigned int *)&v10[v18] + 4;
  __n = v50;
  v20 = v19 + 24;
  if (v19 + 24 > v11)
  {
    v45 = v19;
    v21 = *((_QWORD *)&v60 + 1);
    v22 = (char *)ptr;
    v23 = v59;
    v24 = (uint64_t (*)(char *, size_t, uint64_t))v60;
    v25 = size;
    while (1)
    {
      v26 = v25;
      v25 = 2 * v11;
      if (!v58)
        break;
      v27 = 2 * v11;
      if (!v24)
      {
        v22 = (char *)malloc_type_realloc(v22, v27, 0x44C5D969uLL);
        *v23 = 1;
        v29 = &v22[v11];
LABEL_14:
        bzero(v29, v11);
        goto LABEL_15;
      }
      v22 = (char *)v24(v22, v27, v21);
LABEL_15:
      v11 *= 2;
      if (v20 <= v25)
      {
        ptr = v22;
        size = v25;
        v19 = v45;
        goto LABEL_17;
      }
    }
    v28 = (char *)malloc_type_realloc(v22, 2 * v11, 0x20B045E2uLL);
    v22 = v28;
    if (!v28)
    {
      ptr = 0;
      size = v26;
      v19 = -1;
      goto LABEL_18;
    }
    v29 = &v28[v11];
    goto LABEL_14;
  }
LABEL_17:
  v56 = v20;
  v57 = v19;
LABEL_18:
  v30 = __btrie_build_compact_trie((uint64_t)&v46, v62, (uint64_t)&size, 1);
  v31 = size;
  v32 = v56;
  v33 = (v56 + 4095) & 0xFFFFFFFFFFFFF000;
  v34 = __n;
  v35 = v33 + __n;
  if (v33 + __n <= size)
  {
    v57 = (v56 + 4095) & 0xFFFFFFFFFFFFF000;
    goto LABEL_29;
  }
  do
  {
    v31 *= 2;
    if (v58)
    {
      if ((_QWORD)v60)
      {
        ptr = (void *)((uint64_t (*)(void *, size_t, _QWORD))v60)(ptr, v31, *((_QWORD *)&v60 + 1));
        goto LABEL_26;
      }
      v36 = (char *)malloc_type_realloc(ptr, v31, 0x44C5D969uLL);
      ptr = v36;
      *v59 = 1;
    }
    else
    {
      v36 = (char *)malloc_type_realloc(ptr, v31, 0x20B045E2uLL);
      ptr = v36;
      if (!v36)
      {
        v44 = 0xFFFFFFFFLL;
        goto LABEL_34;
      }
    }
    bzero(&v36[size], v31 - size);
LABEL_26:
    size = v31;
  }
  while (v35 > v31);
  v57 = v33;
  v34 = __n;
LABEL_29:
  v56 = v35;
  memcpy((char *)ptr + v33, __src, v34);
  v37 = ptr;
  v38 = (char *)ptr + v19;
  v39 = HIDWORD(v30) + 4 * v30;
  *v38 = 1;
  v38[1] = v39;
  v38[2] = v32;
  v38[3] = v33;
  v40 = __n;
  v38[4] = __n;
  v41 = v63;
  v38[5] = v63;
  *(_DWORD *)a1 = v39;
  *(_QWORD *)(a1 + 24) = v40;
  *(_QWORD *)(a1 + 32) = v41;
  size = v56;
  if ((_QWORD)v60)
    v42 = (char *)((uint64_t (*)(void))v60)();
  else
    v42 = (char *)malloc_type_realloc(v37, v56, 0x2487FC11uLL);
  v44 = 0;
  ptr = v42;
  *(_QWORD *)(a1 + 8) = v42;
  *(_QWORD *)(a1 + 16) = &v42[v33];
LABEL_34:
  if (v49)
    free(v49);
  if (__src)
    free(__src);
  return v44;
}

uint64_t TrieAccessContext::createIndexFile(TrieAccessContext *this, IDXIndexInfo *a2)
{
  const char *v3;
  _BOOL4 v4;
  int v5;
  int v6;
  IDXIndexInfo *v7;
  IDXIndexInfo *IndexInfoForHeapAccess;
  IDXIndexInfo *v9;
  uint64_t IndexFile;
  const std::__fs::filesystem::path *v12;
  std::error_code *v13;

  v3 = (const char *)IDXIndexInfo::POSIXPath(this);
  v4 = IDXIndexInfo::writable(this);
  v5 = openRawIndexFile(v3, v4, 1);
  if (v5 == -1)
    return 0;
  v6 = v5;
  if (lseek(v5, 4159, 0) == -1 || write(v6, "", 1uLL) != 1)
  {
    close(v6);
    v12 = (const std::__fs::filesystem::path *)IDXIndexInfo::POSIXPath(this);
    remove(v12, v13);
    return 0;
  }
  close(v6);
  IndexInfoForHeapAccess = TrieAccessContext::createIndexInfoForHeapAccess((__CFBundle **)this, v7);
  IndexFile = HeapAccessContext::createIndexFile(IndexInfoForHeapAccess, v9);
  IDXIndexInfo::~IDXIndexInfo(IndexInfoForHeapAccess);
  MEMORY[0x1D17BC79C](IndexInfoForHeapAccess, 0x1070C4063F6B07ELL);
  return IndexFile;
}

void sub_1CDF8AA88(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

IDXIndexInfo *TrieAccessContext::createIndexInfoForHeapAccess(__CFBundle **this, IDXIndexInfo *a2)
{
  const __CFDictionary *v3;
  const __CFDictionary *MutableCopy;
  __CFDictionary *Mutable;
  BOOL v6;
  const __CFString *Value;
  CFStringRef v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  const __CFString *v11;
  const __CFString *v12;
  unint64_t v13;
  const __CFString *v14;
  CFIndex v15;
  const __CFString *v16;
  __CFString *v17;
  const __CFDictionary *v18;
  const __CFDictionary *v19;
  TrieAccessContext *v20;
  CFDictionaryRef FieldForHeapAccess;
  const __CFString *v22;
  CFMutableStringRef v23;
  const __CFString *v24;
  const __CFURL *v25;
  IDXIndexInfo *v26;
  const __CFDictionary *v28;
  BOOL v29;
  const __CFURL *v30;
  CFStringRef PathComponent;
  CFRange v32;

  v3 = IDXIndexInfo::optionalProperty((IDXIndexInfo *)this, CFSTR("TrieAuxiliaryDataOptions"));
  if (!v3)
  {
    v9 = IDXIndexInfo::optionalProperty((IDXIndexInfo *)this, CFSTR("TrieAuxiliaryDataFile"));
    if (!v9)
    {
      v10 = IDXIndexInfo::optionalProperty((IDXIndexInfo *)this, CFSTR("TrieSubIndexPath"));
      v6 = 1;
      if (v10)
      {
        v8 = (CFStringRef)v10;
        goto LABEL_11;
      }
      Mutable = 0;
LABEL_22:
      v29 = v6;
      v30 = CFURLCreateCopyDeletingPathExtension(0, *this);
      PathComponent = CFURLCopyLastPathComponent(v30);
      CFRelease(v30);
      v8 = CFStringCreateWithFormat(0, 0, CFSTR("%@_aux.data"), PathComponent);
      CFRelease(PathComponent);
      v6 = 0;
      if (!v29)
        goto LABEL_12;
LABEL_11:
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      goto LABEL_12;
    }
    goto LABEL_10;
  }
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v3);
  Mutable = MutableCopy;
  v6 = MutableCopy == 0;
  if (!MutableCopy)
  {
    v9 = IDXIndexInfo::optionalProperty((IDXIndexInfo *)this, CFSTR("TrieAuxiliaryDataFile"));
    if (!v9)
      goto LABEL_18;
LABEL_10:
    v8 = (CFStringRef)v9;
    v6 = 1;
    goto LABEL_11;
  }
  Value = (const __CFString *)CFDictionaryGetValue(MutableCopy, CFSTR("IDXIndexPath"));
  if (Value
    || (Value = (const __CFString *)IDXIndexInfo::optionalProperty((IDXIndexInfo *)this, CFSTR("TrieAuxiliaryDataFile"))) != 0)
  {
    v8 = Value;
    v6 = 1;
    goto LABEL_12;
  }
LABEL_18:
  v28 = IDXIndexInfo::optionalProperty((IDXIndexInfo *)this, CFSTR("TrieSubIndexPath"));
  if (!v28)
    goto LABEL_22;
  v8 = (CFStringRef)v28;
  v6 = 1;
  if (!Mutable)
    goto LABEL_11;
LABEL_12:
  CFDictionarySetValue(Mutable, CFSTR("IDXIndexAccessMethod"), CFSTR("com.apple.HeapAccessMethod"));
  v11 = (const __CFString *)IDXIndexInfo::relativePath((IDXIndexInfo *)this);
  if (CFStringFind(v11, CFSTR("/"), 0).location == -1)
  {
    v17 = (__CFString *)CFRetain(v8);
  }
  else
  {
    v12 = (const __CFString *)IDXIndexInfo::relativePath((IDXIndexInfo *)this);
    v13 = (unint64_t)CFStringFind(v12, CFSTR("/"), 4uLL).location + 1;
    v14 = (const __CFString *)IDXIndexInfo::relativePath((IDXIndexInfo *)this);
    v15 = CFStringGetLength(v14) - v13;
    v16 = (const __CFString *)IDXIndexInfo::relativePath((IDXIndexInfo *)this);
    v17 = CFStringCreateMutableCopy(0, 0, v16);
    v32.location = v13;
    v32.length = v15;
    CFStringDelete(v17, v32);
    CFStringAppend(v17, v8);
  }
  CFDictionarySetValue(Mutable, CFSTR("IDXIndexPath"), v17);
  if (!v6)
    CFRelease(v8);
  CFDictionarySetValue(Mutable, CFSTR("IDXIndexSupportDataID"), (const void *)*MEMORY[0x1E0C9AE50]);
  v18 = IDXIndexInfo::optionalProperty((IDXIndexInfo *)this, CFSTR("IDXIndexWritable"));
  CFDictionarySetValue(Mutable, CFSTR("IDXIndexWritable"), v18);
  v19 = IDXIndexInfo::optionalProperty((IDXIndexInfo *)this, CFSTR("IDXIndexBigEndian"));
  CFDictionarySetValue(Mutable, CFSTR("IDXIndexBigEndian"), v19);
  FieldForHeapAccess = TrieAccessContext::createFieldForHeapAccess(v20);
  CFDictionarySetValue(Mutable, CFSTR("IDXIndexDataFields"), FieldForHeapAccess);
  CFRelease(FieldForHeapAccess);
  v22 = CFURLCopyFileSystemPath(*this, kCFURLPOSIXPathStyle);
  v23 = CFStringCreateMutableCopy(0, 0, v22);
  CFRelease(v22);
  v24 = (const __CFString *)IDXIndexInfo::relativePath((IDXIndexInfo *)this);
  CFStringTrim(v23, v24);
  CFStringAppend(v23, v17);
  v25 = CFURLCreateWithFileSystemPath(0, v23, kCFURLPOSIXPathStyle, 0);
  CFRelease(v23);
  CFRelease(v17);
  v26 = (IDXIndexInfo *)operator new();
  IDXIndexInfo::IDXIndexInfo(v26, v25, Mutable, this[5]);
  CFRelease(v25);
  CFRelease(Mutable);
  return v26;
}

void sub_1CDF8AE50(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

uint64_t TrieAccessContext::initializeSubclass(TrieAccessContext *this, int a2, void **a3)
{
  const char *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  const char *v12;
  size_t v13;
  char *v14;
  const char *v15;
  IDXIndexInfo *v16;
  uint64_t v17;
  _OWORD *v18;
  int v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  unint64_t v25;
  unint64_t v26;

  if (*((unsigned __int16 *)this + 37) > 2u || *((_WORD *)this + 37) && *((_BYTE *)this + 73))
    return 0;
  if (a2)
  {
    v26 = 0;
    v5 = (const char *)IDXIndexInfo::POSIXPath(*((IDXIndexInfo **)this + 1));
    v6 = openRawIndexFile(v5, *((unsigned __int8 *)this + 72), 0);
    if (v6 != -1)
    {
      v7 = v6;
      v8 = mapIndexFile(v6, *((unsigned __int8 *)this + 72), (off_t *)&v26);
      close(v7);
      if (v8 != -1)
      {
        v9 = v8 + 64;
        v10 = v26;
        v11 = v26 - 64;
        *((_QWORD *)this + 8) = malloc_type_malloc(0x20uLL, 0x80040B8603338uLL);
        v12 = (const char *)IDXIndexInfo::POSIXPath(*((IDXIndexInfo **)this + 1));
        v13 = strlen(v12) + 1;
        v14 = (char *)malloc_type_malloc(v13, 0x4800EB06uLL);
        v15 = (const char *)IDXIndexInfo::POSIXPath(*((IDXIndexInfo **)this + 1));
        strlcpy(v14, v15, v13);
        *((_QWORD *)this + 4) = TrieAccessContext::createIndexInfoForHeapAccess(*((__CFBundle ***)this + 1), v16);
        if (*((_WORD *)this + 37) == 1)
        {
          v22 = *((_QWORD *)this + 8);
          v18 = malloc_type_malloc(0x48uLL, 0x1090040DA38FBB1uLL);
          if (v18)
          {
            v18[1] = 0u;
            v18[2] = 0u;
            *v18 = 0u;
            *((_QWORD *)v18 + 7) = myReallocator;
            *((_QWORD *)v18 + 8) = v22;
            *((_QWORD *)v18 + 1) = v9;
            *((_QWORD *)v18 + 5) = v11;
            *((_QWORD *)v18 + 6) = 0;
            if (v11 >= 0x18)
            {
              *(_DWORD *)v18 = *(_DWORD *)(v8 + 68);
              *((_QWORD *)v18 + 2) = v9 + *(unsigned int *)(v8 + 76);
              v23 = *(_QWORD *)(v8 + 80);
              *(_QWORD *)&v24 = v23;
              *((_QWORD *)&v24 + 1) = HIDWORD(v23);
              *(_OWORD *)((char *)v18 + 24) = v24;
            }
          }
        }
        else if (*((_WORD *)this + 37))
        {
          v18 = mtrie_open((uint64_t)myReallocator, *((_QWORD *)this + 8), (unsigned int *)(v8 + 64), v11);
        }
        else
        {
          v17 = *((_QWORD *)this + 8);
          v18 = malloc_type_malloc(0x58uLL, 0x10B0040A3C4D6A3uLL);
          if (v18)
          {
            *((_QWORD *)v18 + 4) = myReallocator;
            *((_QWORD *)v18 + 5) = v17;
            *(_QWORD *)v18 = v9;
            *((_DWORD *)v18 + 20) = 0;
            if (v11 < 0x10)
            {
              v25 = 0;
              *((_QWORD *)v18 + 1) = 0;
              *((_DWORD *)v18 + 4) = 0;
            }
            else
            {
              *((_QWORD *)v18 + 1) = v8 + 80;
              if (*(_DWORD *)(v8 + 64) == 1953655141)
                v19 = *(_DWORD *)(v8 + 76);
              else
                v19 = 0;
              *((_DWORD *)v18 + 4) = v19;
              v25 = (v10 - 80) >> 3;
            }
            *((_QWORD *)v18 + 3) = v25;
          }
        }
        *((_QWORD *)this + 3) = v18;
        **((_QWORD **)this + 8) = v14;
        *(_QWORD *)(*((_QWORD *)this + 8) + 8) = *((_QWORD *)this + 3);
        *(_QWORD *)(*((_QWORD *)this + 8) + 16) = v26;
        *(_QWORD *)(*((_QWORD *)this + 8) + 24) = *((_QWORD *)this + 4);
        *a3 = (void *)*((_QWORD *)this + 8);
        return 1;
      }
    }
    return 0;
  }
  v21 = (uint64_t)*a3;
  *((_QWORD *)this + 8) = *a3;
  *((_QWORD *)this + 3) = *(_QWORD *)(v21 + 8);
  *((_QWORD *)this + 4) = *(_QWORD *)(v21 + 24);
  return 1;
}

void TrieAccessContext::finalizeSubclass(TrieAccessContext *this, int a2)
{
  IDXAccessContext *v4;
  uint64_t v5;
  _QWORD *v6;
  char *v7;
  BOOL v8;
  uint64_t v9;
  size_t v10;

  v4 = (IDXAccessContext *)*((_QWORD *)this + 5);
  if (v4)
  {
    IDXAccessContext::finalize(v4);
    v5 = *((_QWORD *)this + 5);
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    *((_QWORD *)this + 5) = 0;
  }
  if (a2)
  {
    v10 = 0;
    if (*((_WORD *)this + 37) == 1)
    {
      v6 = (_QWORD *)*((_QWORD *)this + 3);
      v7 = (char *)v6[1];
      if (*((_DWORD *)v6 + 12))
LABEL_15:
        free(v7);
    }
    else
    {
      if (*((_WORD *)this + 37))
      {
        v7 = (char *)mtrie_data(*((unsigned int **)this + 3), &v10);
        mtrie_close(*((_QWORD **)this + 3));
        goto LABEL_18;
      }
      v6 = (_QWORD *)*((_QWORD *)this + 3);
      v7 = (char *)*v6;
      if (*((_DWORD *)v6 + 20))
        v8 = v7 == 0;
      else
        v8 = 1;
      if (!v8)
        goto LABEL_15;
    }
    free(v6);
LABEL_18:
    v10 = *(_QWORD *)(*((_QWORD *)this + 8) + 16);
    unmapIndexFile(v7 - 64, v10);
    v9 = *((_QWORD *)this + 4);
    if (v9)
    {
      IDXIndexInfo::~IDXIndexInfo(*((IDXIndexInfo **)this + 4));
      MEMORY[0x1D17BC79C](v9, 0x1070C4063F6B07ELL);
    }
    free(**((void ***)this + 8));
    free(*((void **)this + 8));
  }
}

void sub_1CDF8B2C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

CFDictionaryRef TrieAccessContext::createFieldForHeapAccess(TrieAccessContext *this)
{
  const CFDictionaryKeyCallBacks *v1;
  const CFDictionaryValueCallBacks *v2;
  CFArrayRef v3;
  CFDictionaryRef v4;
  CFTypeRef v6;
  __int16 valuePtr;
  void *values;
  CFTypeRef cf;
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  keys[0] = CFSTR("IDXDataFieldName");
  keys[1] = CFSTR("IDXDataSizeLength");
  valuePtr = 4;
  values = CFSTR("Packed Homograph");
  cf = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v6 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFRelease(cf);
  v3 = CFArrayCreate(0, &v6, 1, MEMORY[0x1E0C9B378]);
  CFRelease(v6);
  keys[0] = CFSTR("IDXVariableDataFields");
  values = v3;
  v4 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, v1, v2);
  CFRelease(v3);
  return v4;
}

uint64_t TrieAccessContext::getDataPtrByID(TrieAccessContext *this, unint64_t a2, uint64_t *a3)
{
  return 0;
}

uint64_t TrieAccessContext::getDataByID(TrieAccessContext *this, unint64_t a2, uint64_t a3, unsigned __int8 *a4)
{
  return 0;
}

uint64_t __search_node_tree(uint64_t a1, unint64_t a2, _QWORD *a3, unint64_t *a4, uint64_t a5, unsigned int a6)
{
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  unint64_t v18;
  unint64_t v19;

  v12 = *(_QWORD *)(a1 + 8);
  v13 = *(unsigned int *)(v12 + 8 * a6);
  if (*(_DWORD *)(v12 + 8 * v13 + 4) == a6)
  {
    v14 = *(_DWORD *)(v12 + 8 * v13);
    if (v14 < 0)
    {
      if (*a3)
      {
        --*a3;
      }
      else if (a2)
      {
        v18 = *a4;
        v19 = *a4 + 1;
        *a4 = v19;
        *(_DWORD *)(a5 + 4 * v18) = -v14;
        if (v19 >= a2)
          return 1;
      }
      else
      {
        ++*a4;
      }
    }
  }
  v15 = (v13 + 1);
  v16 = 257;
  while (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v15 + 4) != a6
       || !__search_node_tree(a1, a2, a3, a4, a5, v15))
  {
    v15 = (v15 + 1);
    if (--v16 <= 1)
      return 0;
  }
  return 1;
}

BOOL __btrie_find_prefix(uint64_t a1, int a2, unsigned __int8 *a3, unsigned int a4, _QWORD *a5, unint64_t a6, unint64_t *a7, uint64_t a8, uint8x8_t a9)
{
  int v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned int *v23;
  char *v24;
  unint64_t v25;
  char *v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  int v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  unint64_t v36;
  uint64_t v37;
  unsigned int v38;
  char v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  int v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  int v50;
  unsigned int *v51;
  unsigned int v52;
  uint8x8_t v53;
  unsigned int *v54;
  unsigned int v55;
  uint8x8_t v56;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;

  v16 = a2 & 3;
  switch(v16)
  {
    case 1:
      v23 = (unsigned int *)(*(_QWORD *)(a1 + 16) + (a2 - 1));
      if (!a4)
      {
        v44 = v23[1];
        if (v44)
        {
          if (*a5)
          {
            --*a5;
          }
          else
          {
            v60 = *a7;
            v61 = *a7 + 1;
            *a7 = v61;
            if (a6)
            {
              *(_DWORD *)(a8 + 4 * v60) = v44;
              if (v61 >= a6)
                return 1;
            }
          }
        }
      }
      v24 = (char *)(v23 + 2);
      v25 = (unint64_t)v23 + *v23 + 4;
      if ((unint64_t)(v23 + 2) < v25)
      {
        do
        {
          v28 = *v24;
          v26 = v24 + 1;
          v27 = v28;
          if (v28 >= a4)
          {
            v29 = memcmp(v26, a3, (int)a4);
            if (v29 > 0)
              return 0;
            if (!v29)
            {
              if (*a5)
              {
                --*a5;
              }
              else if (a6)
              {
                v30 = *(_DWORD *)&v26[v27];
                v31 = *a7;
                v32 = *a7 + 1;
                *a7 = v32;
                *(_DWORD *)(a8 + 4 * v31) = v30;
                if (v32 >= a6)
                  return 1;
              }
              else
              {
                ++*a7;
              }
            }
          }
          v24 = &v26[v27 + 4];
        }
        while ((unint64_t)v24 < v25);
      }
      return 0;
    case 2:
      v33 = *(_QWORD *)(a1 + 8);
      v34 = (a2 - 2);
      v35 = (int *)(v33 + v34);
      if (!a4)
      {
        v45 = *v35;
        if (*v35)
        {
          if (*a5)
          {
            --*a5;
          }
          else
          {
            v62 = *a7;
            v63 = *a7 + 1;
            *a7 = v63;
            if (a6)
            {
              *(_DWORD *)(a8 + 4 * v62) = v45;
              if (v63 >= a6)
                return 1;
            }
          }
        }
        v46 = 0;
        v47 = v34 + v33 + 4;
        while (1)
        {
          v48 = v46 >> 5 <= 1 ? 1 : v46 >> 5;
          v49 = v35[(v46 >> 5) + 1];
          if (((v49 >> v46) & 1) != 0)
          {
            if ((v46 & 0xE0) != 0)
            {
              v50 = 0;
              v51 = (unsigned int *)v47;
              do
              {
                v52 = *v51++;
                a9 = (uint8x8_t)vcnt_s8((int8x8_t)v52);
                a9.i16[0] = vaddlv_u8(a9);
                v50 += a9.i32[0];
                --v48;
              }
              while (v48);
            }
            else
            {
              v50 = 0;
            }
            a9.i32[0] = v49 & ~(-1 << (v46 & 0x1F));
            v53 = (uint8x8_t)vcnt_s8((int8x8_t)a9);
            v53.i16[0] = vaddlv_u8(v53);
            if (__btrie_find_prefix(a1, v35[v50 + v53.i32[0] + 10], a3, 0, a5, a6, a7, a8))break;
          }
          if ((_DWORD)++v46 == 256)
            return 0;
        }
        return 1;
      }
      v36 = *a3;
      v37 = v36 >> 5;
      v38 = v35[(v36 >> 5) + 1];
      if (((v38 >> v36) & 1) == 0)
        return 0;
      v39 = v36 & 0x1F;
      if (v36 >= 0x20)
      {
        v40 = 0;
        if (v37 <= 1)
          v37 = 1;
        else
          v37 = v37;
        v54 = (unsigned int *)(v34 + v33 + 4);
        do
        {
          v55 = *v54++;
          a9 = (uint8x8_t)vcnt_s8((int8x8_t)v55);
          a9.i16[0] = vaddlv_u8(a9);
          v40 += a9.i32[0];
          --v37;
        }
        while (v37);
      }
      else
      {
        v40 = 0;
      }
      a9.i32[0] = v38 & ~(-1 << v39);
      v56 = (uint8x8_t)vcnt_s8((int8x8_t)a9);
      v56.i16[0] = vaddlv_u8(v56);
      v20 = v35[v40 + v56.i32[0] + 10];
      v22 = a3 + 1;
      v21 = a4 - 1;
      break;
    case 3:
      v17 = *(_QWORD *)(a1 + 8);
      v18 = (a2 - 3);
      v19 = (int *)(v17 + v18);
      if (!a4)
      {
        v41 = *v19;
        if (v41)
        {
          if (*a5)
          {
            --*a5;
          }
          else
          {
            v58 = *a7;
            v59 = *a7 + 1;
            *a7 = v59;
            if (a6)
            {
              *(_DWORD *)(a8 + 4 * v58) = v41;
              if (v59 >= a6)
                return 1;
            }
          }
        }
        v42 = 0;
        v43 = v18 + v17 + 4;
        while (!__btrie_find_prefix(a1, *(unsigned int *)(v43 + v42), a3, 0, a5, a6, a7, a8))
        {
          v42 += 4;
          if (v42 == 1024)
            return 0;
        }
        return 1;
      }
      v20 = v19[*a3 + 1];
      v21 = a4 - 1;
      v22 = a3 + 1;
      break;
    default:
      return 0;
  }
  return __btrie_find_prefix(a1, v20, v22, v21, a5, a6, a7, a8) != 0;
}

uint64_t __wildcard_match_str(uint64_t a1, unint64_t a2, _QWORD *a3, unint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10)
{
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  _DWORD *v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  int v26;
  unint64_t v28;
  unint64_t v29;

  if (!a8)
  {
    v16 = *(_QWORD *)(a1 + 8);
    goto LABEL_32;
  }
  v12 = 0;
  v13 = a10;
  while (1)
  {
    if (a10 == 1)
    {
      v15 = *(unsigned __int8 *)(a7 + v12);
      goto LABEL_12;
    }
    if (a10 == 2 && (v12 & 1) == 0)
    {
      v14 = *(unsigned __int8 *)(a7 + v12);
      if (a9)
      {
        if (v14 == 63)
        {
          if (!*(_BYTE *)(a7 + v12 + 1))
            goto LABEL_20;
        }
        else if (v14 == 42 && !*(_BYTE *)(a7 + v12 + 1))
        {
          return __wildcard_asterisk(a1, a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7 + v13, a8 - v13, a9, a10);
        }
        goto LABEL_14;
      }
      if (!*(_BYTE *)(a7 + v12))
        break;
    }
LABEL_14:
    v16 = *(_QWORD *)(a1 + 8);
    v17 = *(_DWORD *)(v16 + 8 * a6) + *(unsigned __int8 *)(a7 + v12) + 1;
    if (*(_DWORD *)(v16 + 8 * v17 + 4) != (_DWORD)a6)
      return 0;
    ++v12;
    ++v13;
    a6 = v17;
    if (a8 == v12)
    {
      LODWORD(a6) = v17;
LABEL_32:
      v25 = *(unsigned int *)(v16 + 8 * a6);
      if (*(_DWORD *)(v16 + 8 * v25 + 4) == (_DWORD)a6)
      {
        v26 = *(_DWORD *)(v16 + 8 * v25);
        if (v26 < 0)
        {
          if (*a3)
          {
            --*a3;
          }
          else if (a2)
          {
            v28 = *a4;
            v29 = *a4 + 1;
            *a4 = v29;
            *(_DWORD *)(a5 + 4 * v28) = -v26;
            if (v29 >= a2)
              return 1;
          }
          else
          {
            ++*a4;
          }
        }
      }
      return 0;
    }
  }
  v15 = *(unsigned __int8 *)(a7 + v12 + 1);
LABEL_12:
  if (v15 == 42)
    return __wildcard_asterisk(a1, a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7 + v13, a8 - v13, a9, a10);
  if (!(2 * (v15 == 63)))
    goto LABEL_14;
LABEL_20:
  v18 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * a6);
  v19 = 256;
  while (1)
  {
    v20 = (_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * ++v18);
    if (v20[1] == (_DWORD)a6)
      break;
LABEL_29:
    v24 = v19-- != 0;
    if (v19 == 0 || !v24)
      return 0;
  }
  if (a10 != 2)
  {
    v21 = 1;
    if (__wildcard_match_str(a1))
      return v21;
    goto LABEL_29;
  }
  v22 = *v20 + 1;
  v23 = 257;
  while (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v22 + 4) != v18 || !__wildcard_match_str(a1))
  {
    ++v22;
    if (--v23 <= 1)
      goto LABEL_29;
  }
  return 1;
}

uint64_t __wildcard_asterisk(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, int a10)
{
  uint64_t v18;
  uint64_t v20;
  int v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  if (!__wildcard_match_str(a1))
  {
    v27 = a5;
    v28 = a7;
    v29 = a8;
    LODWORD(v20) = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * a6);
    v21 = 256;
    while (1)
    {
      v20 = (v20 + 1);
      v22 = (_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v20);
      v23 = a6;
      if (v22[1] == (_DWORD)a6)
      {
        if (a10 == 2)
        {
          v24 = (*v22 + 1);
          v25 = 257;
          while (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v24 + 4) != (_DWORD)v20
               || !__wildcard_asterisk(a1, a2, a3, a4, v27, v24, v28, v29, a9 | 0x200000000))
          {
            v24 = (v24 + 1);
            if (--v25 <= 1)
              goto LABEL_14;
          }
          return 1;
        }
        if (a10 == 1)
        {
          v18 = 1;
          if (__wildcard_asterisk(a1, a2, a3, a4, v27, v20, v28, v29, a9 | 0x100000000))
            return v18;
        }
      }
LABEL_14:
      v26 = v21-- != 0;
      a6 = v23;
      if (v21 == 0 || !v26)
        return 0;
    }
  }
  return 1;
}

uint64_t __btrie_wildcard_match(uint64_t a1, uint64_t a2, unint64_t *a3, _BYTE *a4, int a5, unsigned int a6, _QWORD *a7, unint64_t a8, uint8x8_t a9, uint64_t a10, int a11, int a12)
{
  uint64_t v15;
  int v16;
  int *v17;
  int v18;
  unsigned int *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t result;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  unsigned int v29;
  unsigned __int8 *v30;
  unint64_t v31;
  unsigned __int8 *v33;
  _WORD *v34;
  const unsigned __int16 *v35;
  uint64_t v36;
  _BYTE *v37;
  uint64_t v38;
  unsigned __int8 *v39;
  unsigned __int8 *v40;
  _BYTE *v41;
  unsigned __int8 *v42;
  int v43;
  _BYTE *v45;
  unsigned __int8 *v46;
  int v47;
  uint64_t v49;
  BOOL v50;
  unsigned __int16 *v51;
  unint64_t v52;
  _WORD *v53;
  int v54;
  _WORD *v56;
  unsigned __int16 *v57;
  int v58;
  unsigned __int8 *v60;
  unsigned __int16 *v61;
  int v62;
  _WORD *v64;
  unsigned __int16 *v65;
  int v66;
  int v69;
  unint64_t v70;
  unint64_t v71;
  _BOOL4 v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unsigned int v77;
  char v78;
  int v79;
  unint64_t v80;
  unint64_t v81;
  unsigned int *v82;
  unsigned int v83;
  uint8x8_t v84;
  const unsigned __int16 *v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;

  v15 = a10;
  v16 = a2 & 3;
  if (v16 == 1)
  {
    v19 = (unsigned int *)(*(_QWORD *)(a1 + 16) + (a2 - 1));
    if (!a5)
      goto LABEL_29;
    if (a5 == 2 && a6 == 2)
    {
      v20 = *(unsigned __int16 *)a4;
    }
    else
    {
      if (a5 != 1 || a6 != 1)
        goto LABEL_32;
      v20 = *a4;
    }
    if (v20 == 42)
    {
LABEL_29:
      v26 = v19[1];
      if (v26)
      {
        if (*a7)
        {
          --*a7;
        }
        else
        {
          v80 = *a3;
          v81 = *a3 + 1;
          *a3 = v81;
          if (a8)
          {
            *(_DWORD *)(a10 + 4 * v80) = v26;
            if (v81 >= a8)
              return 1;
          }
        }
      }
    }
LABEL_32:
    if (a12)
      v27 = a6;
    else
      v27 = 0;
    if (a12)
      v28 = -(uint64_t)(int)a6;
    else
      v28 = 0;
    v29 = v27 + a5;
    if (!(v27 + a5))
      return 0;
    v30 = (unsigned __int8 *)(v19 + 2);
    v31 = (unint64_t)v19 + *v19 + 4;
    if ((unint64_t)(v19 + 2) >= v31)
      return 0;
    v33 = &a4[v28];
    v34 = &a4[v28 + (v29 & 0xFFFFFFFE)];
    v35 = (const unsigned __int16 *)&a4[v28 + 1];
    v36 = (v29 - 1) >> 1;
    v37 = &a4[v28 + v29];
    while (1)
    {
      v39 = v30 + 1;
      v38 = *v30;
      if (a6 != 2)
      {
        if (a6 != 1)
          goto LABEL_146;
        v40 = &v39[v38];
        v41 = v33;
        v42 = v39;
        if ((_DWORD)v38)
        {
          v42 = v39;
          v41 = v33;
          do
          {
            v43 = *v41;
            if (v43 == 42)
              break;
            if (v43 != 63 && v43 != *v42)
              goto LABEL_146;
            ++v41;
            ++v42;
          }
          while (v42 < v40);
        }
        if (v42 < v40)
        {
          v45 = 0;
          v46 = 0;
          do
          {
            if (v41 >= v37)
              goto LABEL_64;
            v47 = *v41;
            if (v47 == 42)
            {
              if (++v41 == v37)
                goto LABEL_134;
              v46 = v42 + 1;
              v45 = v41;
              continue;
            }
            if (v47 == 63 || v47 == *v42)
            {
              ++v41;
              ++v42;
            }
            else
            {
LABEL_64:
              v42 = v46++;
              v41 = v45;
            }
          }
          while (v42 < v40);
        }
        if (v41 < v37)
        {
          v49 = v37 - v41;
          while (*v41 == 42)
          {
            ++v41;
            if (!--v49)
            {
              v41 = v37;
              break;
            }
          }
        }
        v50 = v41 == v37;
        goto LABEL_130;
      }
      if (a11)
      {
        if (v29 < 2 || (v38 & 1) == 0)
          goto LABEL_146;
        v51 = (unsigned __int16 *)(v30 + 2);
        v52 = (unint64_t)&v30[(((_DWORD)v38 - 1) & 0xFFFFFFFE) + 2];
        v53 = v33;
        if ((v38 - 1) >= 2)
        {
          do
          {
            v54 = (unsigned __int16)*v53;
            if (v54 == 42)
              break;
            if (v54 != 63 && v54 != *v51)
              goto LABEL_146;
            ++v53;
            ++v51;
          }
          while ((unint64_t)v51 < v52);
        }
        if ((unint64_t)v51 < v52)
        {
          v56 = 0;
          v57 = 0;
          do
          {
            if (v53 >= v34)
              goto LABEL_95;
            v58 = (unsigned __int16)*v53;
            if (v58 == 42)
            {
              if (++v53 == v34)
                goto LABEL_134;
              v57 = v51 + 1;
              v56 = v53;
              continue;
            }
            if (v58 == 63 || v58 == *v51)
            {
              ++v53;
              ++v51;
            }
            else
            {
LABEL_95:
              v51 = v57++;
              v53 = v56;
            }
          }
          while ((unint64_t)v51 < v52);
        }
        while (v53 < v34 && *v53 == 42)
          ++v53;
LABEL_129:
        v50 = v53 == v34;
LABEL_130:
        if (v50)
          goto LABEL_134;
        goto LABEL_146;
      }
      if ((v29 & 1) == 0)
        break;
      if ((v38 & 1) != 0 && *v33 == *v39)
      {
        if (v29 == 1 && (_DWORD)v38 == 1)
          goto LABEL_134;
        v87 = a8;
        v88 = v36;
        v86 = v15;
        v85 = v35;
        v72 = __btrie_wildcardmatch_uint16(v35, v36, (const unsigned __int16 *)v30 + 1, (v38 - 1) >> 1);
        a8 = v87;
        v36 = v88;
        v35 = v85;
        a11 = 0;
        v15 = v86;
        if (v72)
        {
LABEL_134:
          if (*a7)
          {
            --*a7;
          }
          else if (a8)
          {
            v69 = *(_DWORD *)&v39[v38];
            v70 = *a3;
            v71 = *a3 + 1;
            *a3 = v71;
            *(_DWORD *)(v15 + 4 * v70) = v69;
            if (v71 >= a8)
              return 1;
          }
          else
          {
            ++*a3;
          }
        }
      }
LABEL_146:
      v30 = &v39[v38 + 4];
      if ((unint64_t)v30 >= v31)
        return 0;
    }
    if (v29 < 2 || (v38 & 1) != 0)
      goto LABEL_146;
    v60 = &v39[v38 & 0xFE];
    v53 = v33;
    v61 = (unsigned __int16 *)v39;
    if (v38 >= 2)
    {
      v61 = (unsigned __int16 *)v39;
      v53 = v33;
      do
      {
        v62 = (unsigned __int16)*v53;
        if (v62 == 42)
          break;
        if (v62 != 63 && v62 != *v61)
          goto LABEL_146;
        ++v53;
        ++v61;
      }
      while (v61 < (unsigned __int16 *)v60);
    }
    if (v61 >= (unsigned __int16 *)v60)
    {
LABEL_126:
      while (v53 < v34 && *v53 == 42)
        ++v53;
      goto LABEL_129;
    }
    v64 = 0;
    v65 = 0;
    while (1)
    {
      if (v53 >= v34)
        goto LABEL_124;
      v66 = (unsigned __int16)*v53;
      if (v66 == 42)
      {
        if (++v53 == v34)
          goto LABEL_134;
        v65 = v61 + 1;
        v64 = v53;
        goto LABEL_125;
      }
      if (v66 == 63 || v66 == *v61)
      {
        ++v53;
        ++v61;
      }
      else
      {
LABEL_124:
        v61 = v65++;
        v53 = v64;
      }
LABEL_125:
      if (v61 >= (unsigned __int16 *)v60)
        goto LABEL_126;
    }
  }
  if (v16 != 2)
  {
    if (v16 == 3)
    {
      v17 = (int *)(*(_QWORD *)(a1 + 8) + (a2 - 3));
      if (a5)
      {
        if (a5 == 1 || a6 != 2)
        {
          v18 = *a4;
          if (a6 == 1)
          {
LABEL_22:
            if (v18 != 42)
            {
              if (!(2 * (v18 == 63)))
                goto LABEL_155;
              return __btrie_wildcard_questionmark_search(a1, a2, a9, (uint64_t)a3, (uint64_t)&a4[a6], a5 - a6, a6);
            }
            return __btrie_wildcard_asterisk_search(a1, a2, (uint64_t)a3, (uint64_t)&a4[a6], a5 - a6, a6, (uint64_t)a7, a8, a10);
          }
        }
        else
        {
          if ((a5 & 1) == 0)
          {
            v18 = *(unsigned __int16 *)a4;
            goto LABEL_22;
          }
          LOBYTE(v18) = *a4;
        }
LABEL_155:
        v75 = v17[v18 + 1];
        goto LABEL_173;
      }
      goto LABEL_18;
    }
    return 0;
  }
  v21 = *(_QWORD *)(a1 + 8);
  v22 = (a2 - 2);
  v17 = (int *)(v21 + v22);
  if (!a5)
  {
LABEL_18:
    v24 = *v17;
    if (*v17)
    {
      if (*a7)
      {
        result = 0;
        --*a7;
        return result;
      }
      v73 = *a3;
      v74 = *a3 + 1;
      *a3 = v74;
      if (a8)
      {
        *(_DWORD *)(a10 + 4 * v73) = v24;
        if (v74 >= a8)
          return 1;
      }
    }
    return 0;
  }
  if (a5 == 1 || a6 != 2)
  {
    v23 = *a4;
    if (a6 != 1)
      goto LABEL_159;
  }
  else
  {
    if ((a5 & 1) != 0)
    {
      LOBYTE(v23) = *a4;
      goto LABEL_159;
    }
    v23 = *(unsigned __int16 *)a4;
  }
  if (v23 == 42)
    return __btrie_wildcard_asterisk_search(a1, a2, (uint64_t)a3, (uint64_t)&a4[a6], a5 - a6, a6, (uint64_t)a7, a8, a10);
  if (2 * (v23 == 63))
    return __btrie_wildcard_questionmark_search(a1, a2, a9, (uint64_t)a3, (uint64_t)&a4[a6], a5 - a6, a6);
LABEL_159:
  LODWORD(v76) = v23 >> 5;
  v77 = v17[(v23 >> 5) + 1];
  if (((v77 >> v23) & 1) == 0)
    return 0;
  v78 = v23 & 0x1F;
  if (v23 >= 0x20u)
  {
    v79 = 0;
    if (v76 <= 1)
      v76 = 1;
    else
      v76 = v76;
    v82 = (unsigned int *)(v22 + v21 + 4);
    do
    {
      v83 = *v82++;
      a9 = (uint8x8_t)vcnt_s8((int8x8_t)v83);
      a9.i16[0] = vaddlv_u8(a9);
      v79 += a9.i32[0];
      --v76;
    }
    while (v76);
  }
  else
  {
    v79 = 0;
  }
  a9.i32[0] = v77 & ~(-1 << v78);
  v84 = (uint8x8_t)vcnt_s8((int8x8_t)a9);
  v84.i16[0] = vaddlv_u8(v84);
  v75 = v17[v79 + v84.i32[0] + 10];
LABEL_173:
  result = __btrie_wildcard_match(a1, v75);
  if ((_DWORD)result)
    return 1;
  return result;
}

uint64_t __btrie_wildcard_asterisk_search(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v15;
  uint64_t v17;
  int8x8_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  unsigned int *v31;
  unsigned int v32;
  uint8x8_t v33;
  unint64_t v34;
  uint64_t v35;
  unsigned int v36;
  char v37;
  int v38;
  int v39;
  unsigned int *v40;
  unsigned int v41;
  uint8x8_t v42;
  int v43;
  unsigned int *v44;
  unsigned int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  int v55;
  unsigned int *v56;
  unsigned int v57;
  uint8x8_t v58;
  uint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;

  v15 = a2;
  v17 = 1;
  HIDWORD(v60) = 1;
  if (__btrie_wildcard_match(a1, a2))
    return v17;
  v61 = a6;
  if ((v15 & 3) == 2)
  {
    v34 = 0;
    v63 = *(_QWORD *)(a1 + 8) + (v15 - 2);
    while (1)
    {
      if (v34 >> 5 <= 1)
        v35 = 1;
      else
        v35 = v34 >> 5;
      v36 = *(_DWORD *)(v63 + 4 * (v34 >> 5) + 4);
      if (((v36 >> v34) & 1) != 0)
      {
        v37 = v34 & 0x1F;
        if (v61 == 2)
        {
          if (v34 >= 0x20)
          {
            v39 = 0;
            v44 = (unsigned int *)(v63 + 4);
            do
            {
              v45 = *v44++;
              v18 = vcnt_s8((int8x8_t)v45);
              v18.i16[0] = vaddlv_u8((uint8x8_t)v18);
              v39 += v18.i32[0];
              --v35;
            }
            while (v35);
          }
          else
          {
            v39 = 0;
          }
          v18.i32[0] = v36 & ~(-1 << v37);
          v18 = vcnt_s8(v18);
          v18.i16[0] = vaddlv_u8((uint8x8_t)v18);
          v46 = *(unsigned int *)(v63 + 4 * (v39 + v18.i32[0]) + 40);
          v47 = *(_DWORD *)(v63 + 4 * (v39 + v18.i32[0]) + 40) & 3;
          switch(v47)
          {
            case 1:
              v17 = 1;
              LODWORD(v60) = 1;
              v43 = __btrie_wildcard_asterisk_search(a1, v46, a3, a4, a5, 2, a7, a8, a9, v60);
              goto LABEL_58;
            case 2:
              v51 = 0;
              v52 = *(_QWORD *)(a1 + 8) + (v46 - 2);
              do
              {
                if (v51 >> 5 <= 1)
                  v53 = 1;
                else
                  v53 = v51 >> 5;
                v54 = *(_DWORD *)(v52 + 4 * (v51 >> 5) + 4);
                if (((v54 >> v51) & 1) != 0)
                {
                  if ((v51 & 0xE0) != 0)
                  {
                    v55 = 0;
                    v56 = (unsigned int *)(v52 + 4);
                    do
                    {
                      v57 = *v56++;
                      v18 = vcnt_s8((int8x8_t)v57);
                      v18.i16[0] = vaddlv_u8((uint8x8_t)v18);
                      v55 += v18.i32[0];
                      --v53;
                    }
                    while (v53);
                  }
                  else
                  {
                    v55 = 0;
                  }
                  v18.i32[0] = v54 & ~(-1 << (v51 & 0x1F));
                  v58 = (uint8x8_t)vcnt_s8(v18);
                  v58.i16[0] = vaddlv_u8(v58);
                  LODWORD(v60) = 0;
                  if (__btrie_wildcard_asterisk_search(a1, *(unsigned int *)(v52 + 4 * (v55 + v58.i32[0]) + 40), a3, a4, a5, 2, a7, a8, a9, v60))return 1;
                }
                ++v51;
              }
              while ((_DWORD)v51 != 256);
              break;
            case 3:
              v48 = 0;
              v49 = *(_QWORD *)(a1 + 8) + (v46 - 3) + 4;
              do
              {
                v50 = *(unsigned int *)(v49 + v48);
                if ((v50 & 3) != 0)
                {
                  LODWORD(v60) = 0;
                  if (__btrie_wildcard_asterisk_search(a1, v50, a3, a4, a5, 2, a7, a8, a9, v60))
                    return 1;
                }
                v48 += 4;
              }
              while (v48 != 1024);
              break;
          }
        }
        else if (v61 == 1)
        {
          if (v34 >= 0x20)
          {
            v38 = 0;
            v40 = (unsigned int *)(v63 + 4);
            do
            {
              v41 = *v40++;
              v18 = vcnt_s8((int8x8_t)v41);
              v18.i16[0] = vaddlv_u8((uint8x8_t)v18);
              v38 += v18.i32[0];
              --v35;
            }
            while (v35);
          }
          else
          {
            v38 = 0;
          }
          v18.i32[0] = v36 & ~(-1 << v37);
          v42 = (uint8x8_t)vcnt_s8(v18);
          v42.i16[0] = vaddlv_u8(v42);
          LODWORD(v60) = 0;
          v17 = 1;
          v43 = __btrie_wildcard_asterisk_search(a1, *(unsigned int *)(v63 + 4 * (v38 + v42.i32[0]) + 40), a3, a4, a5, 1, a7, a8, a9, v60);
LABEL_58:
          if (v43)
            return v17;
        }
      }
      if ((_DWORD)++v34 == 256)
        return 0;
    }
  }
  if ((v15 & 3) != 3)
    return 0;
  v19 = 0;
  v62 = *(_QWORD *)(a1 + 8) + (v15 - 3);
  while (1)
  {
    v20 = *(unsigned int *)(v62 + 4 * v19 + 4);
    v21 = *(_DWORD *)(v62 + 4 * v19 + 4) & 3;
    if ((v20 & 3) == 0)
      goto LABEL_31;
    if (v61 == 2)
      break;
    if (v61 == 1)
    {
      LODWORD(v60) = 0;
      v17 = 1;
      v22 = __btrie_wildcard_asterisk_search(a1, v20, a3, a4, a5, 1, a7, a8, a9, v60);
LABEL_30:
      if (v22)
        return v17;
    }
LABEL_31:
    if (++v19 == 256)
      return 0;
  }
  if (v21 != 2)
  {
    if (v21 == 3)
    {
      v23 = 0;
      v24 = *(_QWORD *)(a1 + 8) + (v20 - 3) + 4;
      while (1)
      {
        v25 = *(unsigned int *)(v24 + v23);
        if ((v25 & 3) != 0)
        {
          LODWORD(v60) = 0;
          if (__btrie_wildcard_asterisk_search(a1, v25, a3, a4, a5, 2, a7, a8, a9, v60))
            return 1;
        }
        v23 += 4;
        if (v23 == 1024)
          goto LABEL_31;
      }
    }
    v17 = 1;
    LODWORD(v60) = 1;
    v22 = __btrie_wildcard_asterisk_search(a1, v20, a3, a4, a5, 2, a7, a8, a9, v60);
    goto LABEL_30;
  }
  v26 = 0;
  v27 = *(_QWORD *)(a1 + 8) + (v20 - 2);
  while (1)
  {
    v28 = v26 >> 5 <= 1 ? 1 : v26 >> 5;
    v29 = *(_DWORD *)(v27 + 4 * (v26 >> 5) + 4);
    if (((v29 >> v26) & 1) != 0)
    {
      if ((v26 & 0xE0) != 0)
      {
        v30 = 0;
        v31 = (unsigned int *)(v27 + 4);
        do
        {
          v32 = *v31++;
          v18 = vcnt_s8((int8x8_t)v32);
          v18.i16[0] = vaddlv_u8((uint8x8_t)v18);
          v30 += v18.i32[0];
          --v28;
        }
        while (v28);
      }
      else
      {
        v30 = 0;
      }
      v18.i32[0] = v29 & ~(-1 << (v26 & 0x1F));
      v33 = (uint8x8_t)vcnt_s8(v18);
      v33.i16[0] = vaddlv_u8(v33);
      LODWORD(v60) = 0;
      if (__btrie_wildcard_asterisk_search(a1, *(unsigned int *)(v27 + 4 * (v30 + v33.i32[0]) + 40), a3, a4, a5, 2, a7, a8, a9, v60))return 1;
    }
    if ((_DWORD)++v26 == 256)
      goto LABEL_31;
  }
}

uint64_t __btrie_wildcard_questionmark_search(uint64_t a1, int a2, uint8x8_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  unsigned int *v21;
  unsigned int v22;
  uint8x8_t v23;
  unint64_t v24;
  uint64_t v25;
  unsigned int v26;
  char v27;
  int v28;
  int v29;
  unsigned int *v30;
  unsigned int v31;
  uint8x8_t v32;
  unsigned int *v33;
  unsigned int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  unsigned int *v45;
  unsigned int v46;
  uint8x8_t v47;
  uint64_t v50;
  uint64_t v51;

  if ((a2 & 3) == 2)
  {
    v24 = 0;
    v51 = *(_QWORD *)(a1 + 8) + (a2 - 2);
    do
    {
      if (v24 >> 5 <= 1)
        v25 = 1;
      else
        v25 = v24 >> 5;
      v26 = *(_DWORD *)(v51 + 4 * (v24 >> 5) + 4);
      if (((v26 >> v24) & 1) != 0)
      {
        v27 = v24 & 0x1F;
        if (a7 == 2)
        {
          if (v24 >= 0x20)
          {
            v29 = 0;
            v33 = (unsigned int *)(v51 + 4);
            do
            {
              v34 = *v33++;
              a3 = (uint8x8_t)vcnt_s8((int8x8_t)v34);
              a3.i16[0] = vaddlv_u8(a3);
              v29 += a3.i32[0];
              --v25;
            }
            while (v25);
          }
          else
          {
            v29 = 0;
          }
          a3.i32[0] = v26 & ~(-1 << v27);
          a3 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
          a3.i16[0] = vaddlv_u8(a3);
          v35 = *(unsigned int *)(v51 + 4 * (v29 + a3.i32[0]) + 40);
          v36 = *(_DWORD *)(v51 + 4 * (v29 + a3.i32[0]) + 40) & 3;
          switch(v36)
          {
            case 1:
              v11 = 1;
              if (__btrie_wildcard_match(a1, v35))
                return v11;
              break;
            case 2:
              v40 = 0;
              v41 = *(_QWORD *)(a1 + 8) + (v35 - 2);
              do
              {
                if (v40 >> 5 <= 1)
                  v42 = 1;
                else
                  v42 = v40 >> 5;
                v43 = *(_DWORD *)(v41 + 4 * (v40 >> 5) + 4);
                if (((v43 >> v40) & 1) != 0)
                {
                  if ((v40 & 0xE0) != 0)
                  {
                    v44 = 0;
                    v45 = (unsigned int *)(v41 + 4);
                    do
                    {
                      v46 = *v45++;
                      a3 = (uint8x8_t)vcnt_s8((int8x8_t)v46);
                      a3.i16[0] = vaddlv_u8(a3);
                      v44 += a3.i32[0];
                      --v42;
                    }
                    while (v42);
                  }
                  else
                  {
                    v44 = 0;
                  }
                  a3.i32[0] = v43 & ~(-1 << (v40 & 0x1F));
                  v47 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
                  v47.i16[0] = vaddlv_u8(v47);
                  if (__btrie_wildcard_match(a1, *(unsigned int *)(v41 + 4 * (v44 + v47.i32[0]) + 40)))return 1;
                }
                ++v40;
              }
              while ((_DWORD)v40 != 256);
              break;
            case 3:
              v37 = 0;
              v38 = *(_QWORD *)(a1 + 8) + (v35 - 3) + 4;
              do
              {
                v39 = *(unsigned int *)(v38 + v37);
                if ((v39 & 3) != 0 && __btrie_wildcard_match(a1, v39))
                  return 1;
                v37 += 4;
              }
              while (v37 != 1024);
              break;
          }
        }
        else if (a7 == 1)
        {
          if (v24 >= 0x20)
          {
            v28 = 0;
            v30 = (unsigned int *)(v51 + 4);
            do
            {
              v31 = *v30++;
              a3 = (uint8x8_t)vcnt_s8((int8x8_t)v31);
              a3.i16[0] = vaddlv_u8(a3);
              v28 += a3.i32[0];
              --v25;
            }
            while (v25);
          }
          else
          {
            v28 = 0;
          }
          a3.i32[0] = v26 & ~(-1 << v27);
          v32 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
          v32.i16[0] = vaddlv_u8(v32);
          v11 = 1;
          if (__btrie_wildcard_match(a1, *(unsigned int *)(v51 + 4 * (v28 + v32.i32[0]) + 40)))return v11;
        }
      }
      ++v24;
    }
    while ((_DWORD)v24 != 256);
    return 0;
  }
  if ((a2 & 3) != 3)
    return 0;
  v8 = 0;
  v50 = *(_QWORD *)(a1 + 8) + (a2 - 3);
  while (1)
  {
    v9 = *(unsigned int *)(v50 + 4 * v8 + 4);
    v10 = *(_DWORD *)(v50 + 4 * v8 + 4) & 3;
    if ((v9 & 3) == 0)
      goto LABEL_30;
    if (a7 == 2)
      break;
    if (a7 == 1)
    {
      v11 = 1;
      v12 = a1;
LABEL_29:
      if (__btrie_wildcard_match(v12, v9))
        return v11;
    }
LABEL_30:
    if (++v8 == 256)
      return 0;
  }
  if (v10 != 2)
  {
    if (v10 == 3)
    {
      v13 = 0;
      v14 = *(_QWORD *)(a1 + 8) + (v9 - 3) + 4;
      while (1)
      {
        v15 = *(unsigned int *)(v14 + v13);
        if ((v15 & 3) != 0)
        {
          if (__btrie_wildcard_match(a1, v15))
            return 1;
        }
        v13 += 4;
        if (v13 == 1024)
          goto LABEL_30;
      }
    }
    v11 = 1;
    v12 = a1;
    goto LABEL_29;
  }
  v16 = 0;
  v17 = *(_QWORD *)(a1 + 8) + (v9 - 2);
  while (1)
  {
    v18 = v16 >> 5 <= 1 ? 1 : v16 >> 5;
    v19 = *(_DWORD *)(v17 + 4 * (v16 >> 5) + 4);
    if (((v19 >> v16) & 1) != 0)
    {
      if ((v16 & 0xE0) != 0)
      {
        v20 = 0;
        v21 = (unsigned int *)(v17 + 4);
        do
        {
          v22 = *v21++;
          a3 = (uint8x8_t)vcnt_s8((int8x8_t)v22);
          a3.i16[0] = vaddlv_u8(a3);
          v20 += a3.i32[0];
          --v18;
        }
        while (v18);
      }
      else
      {
        v20 = 0;
      }
      a3.i32[0] = v19 & ~(-1 << (v16 & 0x1F));
      v23 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
      v23.i16[0] = vaddlv_u8(v23);
      if (__btrie_wildcard_match(a1, *(unsigned int *)(v17 + 4 * (v20 + v23.i32[0]) + 40)))return 1;
    }
    if ((_DWORD)++v16 == 256)
      goto LABEL_30;
  }
}

BOOL __btrie_wildcardmatch_uint16(const unsigned __int16 *a1, uint64_t a2, const unsigned __int16 *a3, uint64_t a4)
{
  const unsigned __int16 *v4;
  const unsigned __int16 *v5;
  int v6;
  const unsigned __int16 *v8;
  const unsigned __int16 *v9;
  const unsigned __int16 *v10;
  int v11;

  if (!a2)
    return 0;
  v4 = &a3[a4];
  v5 = a1;
  if (a4 >= 1)
  {
    do
    {
      v6 = *v5;
      if (v6 == 42)
        break;
      if (v6 != 63 && v6 != *a3)
        return 0;
      ++v5;
      ++a3;
    }
    while (a3 < v4);
  }
  v8 = &a1[a2];
  if (a3 < v4)
  {
    v9 = 0;
    v10 = 0;
    while (v5 < v8)
    {
      v11 = *v5;
      if (v11 == 42)
      {
        if (++v5 == v8)
          return 1;
        v10 = a3 + 1;
        v9 = v5;
      }
      else
      {
        if (v11 != 63 && v11 != *a3)
          break;
        ++v5;
        ++a3;
      }
LABEL_23:
      if (a3 >= v4)
        goto LABEL_27;
    }
    a3 = v10++;
    v5 = v9;
    goto LABEL_23;
  }
LABEL_27:
  while (v5 < v8 && *v5 == 42)
    ++v5;
  return v5 == v8;
}

uint64_t __btrie_find_common_prefix(uint64_t a1, int a2, unsigned __int8 *a3, unsigned int a4, unint64_t a5, unint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  _DWORD *v19;
  _DWORD *v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  unsigned int v25;
  unint64_t v26;
  unsigned __int8 *v27;
  char *v28;
  size_t v29;
  unsigned int v30;
  int v31;
  unint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t result;
  int v42;
  unsigned int *v43;
  unsigned int v44;
  uint8x8_t v45;

  v15 = a2 & 3;
  if (v15 == 1)
  {
    v19 = (_DWORD *)(*(_QWORD *)(a1 + 16) + (a2 - 1));
    v20 = v19 + 1;
    v21 = v19[1];
    if (v21)
    {
      if (!a5)
      {
        ++*a6;
        if (!a4)
          return 0;
        goto LABEL_17;
      }
      if (a8)
        *(_QWORD *)(a8 + 8 * *a6) = &a3[-a9];
      v22 = *a6;
      v23 = *a6 + 1;
      *a6 = v23;
      *(_DWORD *)(a7 + 4 * v22) = v21;
      if (v23 >= a5)
        return 1;
    }
    if (!a4)
      return 0;
LABEL_17:
    v25 = *v19;
    v24 = (char *)(v19 + 2);
    v26 = (unint64_t)v20 + v25;
    if ((unint64_t)v24 < v26)
    {
      v27 = &a3[-a9];
      while (1)
      {
        v30 = *v24;
        v28 = v24 + 1;
        v29 = v30;
        if (v30 <= a4)
        {
          v31 = memcmp(v28, a3, v29);
          if (v31 > 0)
            return 0;
          if (!v31)
          {
            v32 = *a6;
            if (a5)
            {
              if (a8)
              {
                *(_QWORD *)(a8 + 8 * v32) = &v27[v29];
                v32 = *a6;
              }
              v33 = *(_DWORD *)&v28[v29];
              *a6 = v32 + 1;
              *(_DWORD *)(a7 + 4 * v32) = v33;
              if (v32 + 1 >= a5)
                return 1;
            }
            else
            {
              *a6 = v32 + 1;
            }
          }
        }
        v24 = &v28[v29 + 4];
        if ((unint64_t)v24 >= v26)
          return 0;
      }
    }
    return 0;
  }
  if (v15 == 2)
  {
    v34 = *(_QWORD *)(a1 + 8);
    v35 = (a2 - 2);
    v36 = *(_DWORD *)(v34 + v35);
    if (v36)
    {
      if (!a5)
      {
        ++*a6;
        if (!a4)
          return 0;
LABEL_36:
        v39 = *a3;
        v40 = v39 >> 5;
        if (((*(_DWORD *)(v34 + v35 + 4 * (v39 >> 5) + 4) >> v39) & 1) == 0)
          return 0;
        if (v39 >= 0x20)
        {
          v42 = 0;
          if (v40 <= 1)
            v40 = 1;
          else
            v40 = v40;
          v43 = (unsigned int *)(v35 + v34 + 4);
          do
          {
            v44 = *v43++;
            v45 = (uint8x8_t)vcnt_s8((int8x8_t)v44);
            v45.i16[0] = vaddlv_u8(v45);
            v42 += v45.i32[0];
            --v40;
          }
          while (v40);
        }
LABEL_50:
        result = __btrie_find_common_prefix(a1);
        if (!(_DWORD)result)
          return result;
        return 1;
      }
      if (a8)
        *(_QWORD *)(a8 + 8 * *a6) = &a3[-a9];
      v37 = *a6;
      v38 = *a6 + 1;
      *a6 = v38;
      *(_DWORD *)(a7 + 4 * v37) = v36;
      if (v38 >= a5)
        return 1;
    }
    if (!a4)
      return 0;
    goto LABEL_36;
  }
  if (v15 != 3)
    return 0;
  v16 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + (a2 - 3));
  if (!v16)
  {
LABEL_9:
    if (a4)
      goto LABEL_50;
    return 0;
  }
  if (!a5)
  {
    ++*a6;
    if (!a4)
      return 0;
    goto LABEL_50;
  }
  if (a8)
    *(_QWORD *)(a8 + 8 * *a6) = &a3[-a9];
  v17 = *a6;
  v18 = *a6 + 1;
  *a6 = v18;
  *(_DWORD *)(a7 + 4 * v17) = v16;
  if (v18 < a5)
    goto LABEL_9;
  return 1;
}

uint64_t __resize_array(uint64_t a1, uint64_t a2)
{
  uint64_t (*v4)(void *, size_t, _QWORD);
  void *v5;
  size_t v6;
  char *v7;
  uint64_t result;

  v4 = *(uint64_t (**)(void *, size_t, _QWORD))(a1 + 32);
  v5 = *(void **)a1;
  v6 = 8 * a2 + 16;
  if (v4)
  {
    v7 = (char *)v4(v5, v6, *(_QWORD *)(a1 + 40));
    if (!v7)
      return 0xFFFFFFFFLL;
    *(_QWORD *)a1 = v7;
  }
  else
  {
    v7 = (char *)malloc_type_realloc(v5, v6, 0x9FCAA123uLL);
    *(_QWORD *)a1 = v7;
    if (!*(_DWORD *)(a1 + 80))
      *(_DWORD *)(a1 + 80) = 1;
  }
  *(_QWORD *)(a1 + 8) = v7 + 16;
  if (!*(_QWORD *)(a1 + 32))
    bzero(&v7[8 * *(_QWORD *)(a1 + 24) + 16], 8 * (a2 - *(_QWORD *)(a1 + 24)));
  result = 0;
  *(_QWORD *)(a1 + 24) = a2;
  return result;
}

uint64_t __write_base(uint64_t result, unsigned int a2, int a3)
{
  uint64_t v5;
  unint64_t v6;

  v5 = result;
  v6 = *(_QWORD *)(result + 24);
  if (v6 > a2 || (result = __resize_array(result, v6 + 0x2000), !(_DWORD)result))
  {
    if (*(_DWORD *)(v5 + 16) < a2)
      *(_DWORD *)(v5 + 16) = a2;
    *(_DWORD *)(*(_QWORD *)(v5 + 8) + 8 * a2) = a3;
  }
  return result;
}

uint64_t __get_list(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;

  v3 = *(_DWORD *)(a1 + 16);
  if (v3 >= a2)
    v4 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
  else
    v4 = 0;
  v5 = 0;
  v6 = 0;
  do
  {
    if (v3 >= v4 + (int)v5)
      v7 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * (v4 + v5) + 4);
    else
      v7 = 0;
    if (v7 == a2)
      *(_WORD *)(a3 + 2 * v6++) = v5;
    ++v5;
  }
  while (v5 != 257);
  return v6;
}

uint64_t __modify_array(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unint64_t a5, __int16 a6, int a7)
{
  unsigned int v12;
  int v13;
  unint64_t v14;
  int v15;
  unsigned int v16;
  int v17;
  unint64_t v19;
  unsigned int v20;
  int v21;
  uint64_t v23;
  unsigned int v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  int i;
  unsigned int v31;
  int v32;
  unsigned int v33;

  v12 = *(_DWORD *)(a1 + 16);
  if (v12 >= a3)
  {
    v13 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * a3);
    if (a7)
    {
LABEL_3:
      v14 = 0;
      *(_WORD *)(a4 + 2 * a5) = a6;
      v15 = 1;
      do
      {
        v16 = v15 + *(__int16 *)(a4 + 2 * v14);
        if (v12 >= v16)
          v17 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v16 + 4);
        else
          v17 = 0;
        ++v14;
        if (v16 == 1 || v17 != 0)
        {
          ++v15;
          v14 = 0;
        }
      }
      while (v14 < a5 + 1);
      goto LABEL_25;
    }
  }
  else
  {
    v13 = 0;
    if (a7)
      goto LABEL_3;
  }
  v19 = 0;
  v15 = 1;
  do
  {
    v20 = v15 + *(__int16 *)(a4 + 2 * v19);
    if (v12 >= v20)
      v21 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v20 + 4);
    else
      v21 = 0;
    ++v19;
    if (v20 == 1 || v21 != 0)
    {
      ++v15;
      v19 = 0;
    }
  }
  while (v19 < a5);
LABEL_25:
  __write_base(a1, a3, v15);
  if (a5)
  {
    v23 = 0;
    do
    {
      v24 = *(_DWORD *)(a1 + 16);
      if (v24 >= a3)
        v25 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * a3);
      else
        v25 = 0;
      v26 = *(__int16 *)(a4 + 2 * v23);
      v27 = (v13 + v26);
      if (v24 >= v27)
        v28 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * (v13 + v26));
      else
        v28 = 0;
      v29 = v25 + v26;
      __write_base(a1, v25 + v26, v28);
      __write_check(a1, v29, a3);
      if (*(_DWORD *)(a1 + 16) >= v27 && *(int *)(*(_QWORD *)(a1 + 8) + 8 * v27) >= 1)
      {
        for (i = 0; i != 257; ++i)
        {
          v31 = *(_DWORD *)(a1 + 16);
          if (v31 >= v27)
            v32 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v27);
          else
            v32 = 0;
          v33 = v32 + i;
          if (v32 + i > v31)
            break;
          if (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 8 * v33 + 4) == (_DWORD)v27)
            __write_check(a1, v33, v29);
        }
      }
      if ((_DWORD)v27 != (_DWORD)a2 || (_DWORD)a2 == a3)
        a2 = a2;
      else
        a2 = v29;
      __write_base(a1, v27, 0);
      __write_check(a1, v27, 0);
      ++v23;
    }
    while (v23 != a5);
  }
  return a2;
}

uint64_t __write_check(uint64_t result, unsigned int a2, int a3)
{
  uint64_t v5;
  unint64_t v6;

  v5 = result;
  v6 = *(_QWORD *)(result + 24);
  if (v6 > a2 || (result = __resize_array(result, v6 + 0x2000), !(_DWORD)result))
  {
    if (*(_DWORD *)(v5 + 16) < a2)
      *(_DWORD *)(v5 + 16) = a2;
    *(_DWORD *)(*(_QWORD *)(v5 + 8) + 8 * a2 + 4) = a3;
  }
  return result;
}

uint64_t __get_children(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if ((*(_DWORD *)(a1 + 76) & 0x80000000) != 0)
    return 0;
  v3 = a2[1];
  v4 = a2[2];
  if (v3 >= v4)
    return 0;
  result = 0;
  v7 = *(_QWORD *)(a1 + 56);
  v8 = 0xFFFFLL;
  do
  {
    v9 = *(_QWORD *)(v7 + 8 * v3);
    v10 = a2[3];
    if (v9 >= v10)
    {
      if (v9 > v10)
        v11 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v3) + v10) + 1;
      else
        v11 = 0;
      if ((__int16)v8 > (int)v11)
      {
        result = 0;
        *(_DWORD *)(a1 + 76) = -1;
        return result;
      }
      if ((_DWORD)v11 != (__int16)v8)
      {
        if (result)
          *(_QWORD *)(a3 + 32 * result - 16) = v3;
        v12 = a3 + 32 * result;
        *(_WORD *)v12 = v11;
        *(_QWORD *)(v12 + 8) = v3;
        *(_QWORD *)(v12 + 24) = v10 + 1;
        ++result;
        v4 = a2[2];
      }
    }
    else
    {
      v11 = v8;
    }
    ++v3;
    v8 = v11;
  }
  while (v3 < v4);
  if (result)
    *(_QWORD *)(a3 + 32 * result - 16) = v4;
  return result;
}

uint64_t __insert_nodes(uint64_t a1)
{
  uint64_t v1;
  int v2;
  unint64_t v3;
  __int16 *v4;
  __int16 *v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  __int16 *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  __int16 *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int16 *v19;
  unint64_t v20;
  int v21;
  __int16 *v22;
  unint64_t v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t children;
  int inserted;
  _QWORD v30[1030];

  v1 = MEMORY[0x1E0C80A78](a1);
  v30[1028] = *MEMORY[0x1E0C80C00];
  if ((*(_DWORD *)(v1 + 76) & 0x80000000) != 0)
    return 0;
  v5 = v4;
  v6 = v3;
  v7 = v2;
  v8 = v1;
  v9 = 0;
  v10 = v3 - 1;
  v11 = &v4[16 * v3 - 16];
  v12 = *v4;
  v13 = *v11 - v12;
  if (*(_DWORD *)(v1 + 72) <= (v12 + 1))
    v14 = v12 + 1;
  else
    v14 = *(_DWORD *)(v1 + 72);
  v15 = v4 + 16;
  while (1)
  {
    v16 = *(_QWORD *)(v8 + 24);
    if (v13 + (unint64_t)v14 >= v16 && __resize_array(v8, v16 + 0x2000))
    {
LABEL_30:
      v18 = 0;
      *(_DWORD *)(v8 + 76) = -2;
      return v18;
    }
    v17 = *(_QWORD *)(v8 + 8);
    if (!*(_DWORD *)(v17 + 8 * v14 + 4))
      break;
LABEL_16:
    ++v14;
  }
  if (!v9)
    *(_DWORD *)(v8 + 72) = v14 + 1;
  v18 = v14 - *v5;
  v19 = v15;
  v20 = v10;
  if (v6 >= 2)
  {
    while (1)
    {
      v21 = *v19;
      v19 += 16;
      if (*(_DWORD *)(v17 + 8 * ((int)v18 + v21) + 4))
        break;
      if (!--v20)
        goto LABEL_17;
    }
    v9 = 1;
    goto LABEL_16;
  }
LABEL_17:
  if (v6)
  {
    v22 = v5;
    v23 = v6;
    do
    {
      v24 = *v22;
      v22 += 16;
      *(_DWORD *)(v17 + 8 * ((int)v18 + v24) + 4) = v7;
      --v23;
    }
    while (v23);
  }
  v25 = v18 + *v11;
  if (*(_DWORD *)(v8 + 16) < v25)
    *(_DWORD *)(v8 + 16) = v25;
  for (; v6; --v6)
  {
    v26 = (v18 + *v5);
    children = __get_children(v8, v5, (uint64_t)v30);
    if (children)
    {
      inserted = __insert_nodes(v8, v26, children, v30);
      if (inserted < 1)
        goto LABEL_30;
    }
    else
    {
      inserted = -*(_DWORD *)(*(_QWORD *)(v8 + 64) + 4 * *((_QWORD *)v5 + 1));
    }
    *(_DWORD *)(*(_QWORD *)(v8 + 8) + 8 * v26) = inserted;
    v5 += 16;
  }
  return v18;
}

void __btrie_insert_fat(uint64_t a1, int a2, unsigned __int8 *a3, int a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  int v8;
  uint64_t v11;
  unsigned int *v12;
  _DWORD *v13;
  unsigned int v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  size_t i;
  uint64_t (*v22)(void *, size_t, _QWORD);
  void *v23;
  char *v24;
  uint64_t v25;
  size_t v26;
  int *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  char *v32;

  v5 = *(_QWORD *)(a1 + 56);
  v6 = (4 * a2);
  v7 = (unsigned int *)(v5 + v6);
  if (!a4)
    goto LABEL_28;
  v8 = a4;
  while (1)
  {
    v11 = *a3;
    v12 = &v7[v11];
    v14 = v12[1];
    v13 = v12 + 1;
    v15 = v14 & 3;
    v16 = (unint64_t)v14 >> 2;
    if (v15 == 3)
    {
      LODWORD(v25) = v16;
      ++a3;
      LODWORD(v26) = v8 - 1;
      goto LABEL_27;
    }
    if (v15 == 1)
      goto LABEL_22;
    if (v15)
      break;
    v17 = *(_QWORD *)(a1 + 80);
    if (v17 != *(_QWORD *)(a1 + 72))
    {
      v17 = (*(_QWORD *)(a1 + 80) & 0xFFFFFFFCLL)
          + *(unsigned int *)(*(_QWORD *)(a1 + 120) + (*(_QWORD *)(a1 + 80) & 0xFFFFFFFCLL))
          + 4;
      *(_QWORD *)(a1 + 72) = v17;
    }
    v18 = v17 + 3;
    v19 = (v17 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    v20 = v19 + *(unsigned int *)(a1 + 200);
    for (i = *(_QWORD *)(a1 + 64); v20 > i; *(_QWORD *)(a1 + 64) = i)
    {
      i *= 2;
      if (*(_DWORD *)(a1 + 88))
      {
        v22 = *(uint64_t (**)(void *, size_t, _QWORD))(a1 + 104);
        v23 = *(void **)(a1 + 120);
        if (v22)
        {
          *(_QWORD *)(a1 + 120) = v22(v23, i, *(_QWORD *)(a1 + 112));
          continue;
        }
        v24 = (char *)malloc_type_realloc(v23, i, 0x44C5D969uLL);
        *(_QWORD *)(a1 + 120) = v24;
        **(_DWORD **)(a1 + 96) = 1;
      }
      else
      {
        v24 = (char *)malloc_type_realloc(*(void **)(a1 + 120), i, 0x20B045E2uLL);
        *(_QWORD *)(a1 + 120) = v24;
        if (!v24)
        {
          v16 = 0;
          goto LABEL_21;
        }
      }
      bzero(&v24[*(_QWORD *)(a1 + 64)], i - *(_QWORD *)(a1 + 64));
    }
    *(_QWORD *)(a1 + 72) = v20;
    *(_QWORD *)(a1 + 80) = v19;
    v16 = (v18 >> 2) | 0x100000000;
LABEL_21:
    *v13 = HIDWORD(v16) | (4 * v16);
LABEL_22:
    v27 = (int *)(*(_QWORD *)(a1 + 120) + (4 * v16));
    v26 = (v8 - 1);
    if (v8 == 1)
    {
      v27[1] = a5;
      v31 = 4;
LABEL_31:
      *v27 = v31;
      return;
    }
    v28 = *v27;
    if (!(_DWORD)v28)
    {
      *(_QWORD *)v27 = 4;
      v28 = 4;
    }
    ++a3;
    v29 = (v8 + 4);
    v30 = v28 + 4;
    if (v30 + v29 < (unint64_t)*(unsigned int *)(a1 + 200))
    {
      *((_BYTE *)v27 + v30) = v26;
      v32 = (char *)v27 + v30 + 1;
      memcpy(v32, a3, v26);
      *(_DWORD *)&v32[v26] = a5;
      v31 = *v27 + v29;
      goto LABEL_31;
    }
    v25 = __btrie_burst_flat(a1);
    v5 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)(v5 + v6 + 4 * v11 + 4) = HIDWORD(v25) | (4 * v25);
LABEL_27:
    v6 = (4 * v25);
    v7 = (unsigned int *)(v5 + v6);
    v8 = v26;
    if (!(_DWORD)v26)
    {
LABEL_28:
      *v7 = a5;
      return;
    }
  }
}

uint64_t __btrie_burst_flat(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD *v4;
  int v5;
  uint64_t v6;
  unsigned int *v7;
  size_t v8;
  size_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t (*v12)(void *, size_t, _QWORD);
  void *v13;
  char *v14;
  unsigned __int8 *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v19;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  v2 = MEMORY[0x1E0C80A78](a1);
  v4 = (_DWORD *)((char *)v20 - ((v3 + 19) & 0x1FFFFFFF0));
  v6 = (4 * v5);
  v7 = (unsigned int *)(*(_QWORD *)(v2 + 120) + v6);
  v8 = *v7;
  *v4 = v8;
  memcpy(v4 + 1, v7 + 1, v8);
  if (*(_QWORD *)(a1 + 80) == v6)
  {
    bzero(v7, *(_QWORD *)(a1 + 72) - v6);
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a1 + 80);
  }
  v9 = *(_QWORD *)a1;
  v10 = *(_QWORD *)(a1 + 8) + 3;
  v11 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + 1028;
  if (v11 > *(_QWORD *)a1)
  {
    while (1)
    {
      v9 *= 2;
      if (!*(_DWORD *)(a1 + 24))
        break;
      v12 = *(uint64_t (**)(void *, size_t, _QWORD))(a1 + 40);
      v13 = *(void **)(a1 + 56);
      if (!v12)
      {
        v14 = (char *)malloc_type_realloc(v13, v9, 0x44C5D969uLL);
        *(_QWORD *)(a1 + 56) = v14;
        **(_DWORD **)(a1 + 32) = 1;
LABEL_10:
        bzero(&v14[*(_QWORD *)a1], v9 - *(_QWORD *)a1);
        goto LABEL_11;
      }
      *(_QWORD *)(a1 + 56) = v12(v13, v9, *(_QWORD *)(a1 + 48));
LABEL_11:
      *(_QWORD *)a1 = v9;
      if (v11 <= v9)
        goto LABEL_12;
    }
    v14 = (char *)malloc_type_realloc(*(void **)(a1 + 56), v9, 0x20B045E2uLL);
    *(_QWORD *)(a1 + 56) = v14;
    if (!v14)
    {
      v19 = 0;
      goto LABEL_13;
    }
    goto LABEL_10;
  }
LABEL_12:
  *(_QWORD *)(a1 + 8) = v11;
  *(_QWORD *)(a1 + 16) = v10 & 0xFFFFFFFFFFFFFFFCLL;
  v19 = (v10 >> 2) | 0x300000000;
LABEL_13:
  *(_DWORD *)(*(_QWORD *)(a1 + 56) + (4 * v19)) = v4[1];
  v15 = (unsigned __int8 *)(v4 + 2);
  v16 = (unint64_t)v4 + v8 + 4;
  if ((unint64_t)(v4 + 2) < v16)
  {
    do
    {
      v17 = (unint64_t)&v15[*v15 + 5];
      __btrie_insert_fat(a1, v19);
      v15 = (unsigned __int8 *)v17;
    }
    while (v17 < v16);
  }
  return v19;
}

unint64_t __btrie_build_compact_trie(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __n128 v11;
  int32x4_t v12;
  unsigned __int8 v13;
  size_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t (*v17)(void *, size_t, _QWORD);
  void *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;
  _DWORD *v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  size_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t (*v32)(void *, size_t, _QWORD, __n128);
  void *v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  int *v37;
  _DWORD *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;

  LODWORD(v4) = a2;
  v5 = HIDWORD(a2);
  if (HIDWORD(a2) != 3)
    return v4 | ((unint64_t)v5 << 32);
  v8 = 0;
  v9 = *(_QWORD *)(a1 + 56);
  v10 = (4 * a2);
  v11 = 0uLL;
  v12.i64[0] = 0x300000003;
  v12.i64[1] = 0x300000003;
  do
  {
    v11 = (__n128)vsubq_s32((int32x4_t)v11, vtstq_s32(*(int32x4_t *)(v10 + v9 + 4 + v8), v12));
    v8 += 16;
  }
  while (v8 != 1024);
  if (a4 || (v11.n128_u32[0] = vaddvq_s32((int32x4_t)v11), v13 = v11.n128_u8[0], v11.n128_u32[0] >= 0x21))
  {
    v29 = *(_QWORD *)a3;
    v30 = *(_QWORD *)(a3 + 8) + 3;
    v31 = (v30 & 0xFFFFFFFFFFFFFFFCLL) + 1028;
    if (v31 <= *(_QWORD *)a3)
    {
LABEL_30:
      *(_QWORD *)(a3 + 8) = v31;
      *(_QWORD *)(a3 + 16) = v30 & 0xFFFFFFFFFFFFFFFCLL;
      v4 = (v30 >> 2) | 0x300000000;
LABEL_31:
      v35 = 0;
      v36 = (4 * v4);
      v37 = (int *)(v9 + v10);
      v39 = *v37;
      v38 = v37 + 1;
      *(_DWORD *)(*(_QWORD *)(a3 + 56) + v36) = v39;
      v40 = v36 + 4;
      do
      {
        v41 = __btrie_build_compact_trie(a1, ((unint64_t)v38[v35] >> 2) | ((unint64_t)(v38[v35] & 3) << 32), a3, 0, v11);
        *(_DWORD *)(*(_QWORD *)(a3 + 56) + v40 + v35 * 4) = HIDWORD(v41) + 4 * v41;
        ++v35;
      }
      while (v35 != 256);
      goto LABEL_33;
    }
    while (1)
    {
      v29 *= 2;
      if (!*(_DWORD *)(a3 + 24))
        break;
      v32 = *(uint64_t (**)(void *, size_t, _QWORD, __n128))(a3 + 40);
      v33 = *(void **)(a3 + 56);
      if (!v32)
      {
        v34 = (char *)malloc_type_realloc(v33, v29, 0x44C5D969uLL);
        *(_QWORD *)(a3 + 56) = v34;
        **(_DWORD **)(a3 + 32) = 1;
LABEL_28:
        bzero(&v34[*(_QWORD *)a3], v29 - *(_QWORD *)a3);
        goto LABEL_29;
      }
      *(_QWORD *)(a3 + 56) = v32(v33, v29, *(_QWORD *)(a3 + 48), v11);
LABEL_29:
      *(_QWORD *)a3 = v29;
      if (v31 <= v29)
        goto LABEL_30;
    }
    v34 = (char *)malloc_type_realloc(*(void **)(a3 + 56), v29, 0x20B045E2uLL);
    *(_QWORD *)(a3 + 56) = v34;
    if (!v34)
    {
      v4 = 0;
      goto LABEL_31;
    }
    goto LABEL_28;
  }
  v14 = *(_QWORD *)a3;
  v15 = *(_QWORD *)(a3 + 8) + 3;
  v16 = (v15 & 0xFFFFFFFFFFFFFFFCLL) + 4 * v11.n128_u32[0] + 40;
  if (v16 <= *(_QWORD *)a3)
  {
LABEL_15:
    *(_QWORD *)(a3 + 8) = v16;
    *(_QWORD *)(a3 + 16) = v15 & 0xFFFFFFFFFFFFFFFCLL;
    v4 = (v15 >> 2) | 0x200000000;
    goto LABEL_16;
  }
  while (1)
  {
    v14 *= 2;
    if (!*(_DWORD *)(a3 + 24))
      break;
    v17 = *(uint64_t (**)(void *, size_t, _QWORD))(a3 + 40);
    v18 = *(void **)(a3 + 56);
    if (!v17)
    {
      v19 = (char *)malloc_type_realloc(v18, v14, 0x44C5D969uLL);
      *(_QWORD *)(a3 + 56) = v19;
      **(_DWORD **)(a3 + 32) = 1;
      goto LABEL_13;
    }
    *(_QWORD *)(a3 + 56) = v17(v18, v14, *(_QWORD *)(a3 + 48));
LABEL_14:
    *(_QWORD *)a3 = v14;
    if (v16 <= v14)
      goto LABEL_15;
  }
  v19 = (char *)malloc_type_realloc(*(void **)(a3 + 56), v14, 0x20B045E2uLL);
  *(_QWORD *)(a3 + 56) = v19;
  if (v19)
  {
LABEL_13:
    bzero(&v19[*(_QWORD *)a3], v14 - *(_QWORD *)a3);
    goto LABEL_14;
  }
  v4 = 0;
LABEL_16:
  v20 = 0;
  v21 = (4 * v4);
  v22 = (int *)(v9 + v10);
  v24 = *v22;
  v23 = v22 + 1;
  v25 = *(_QWORD *)(a3 + 56) + v21;
  *(_DWORD *)v25 = v24;
  *(_BYTE *)(v25 + 37) = v13;
  do
  {
    v26 = __btrie_build_compact_trie(a1, ((unint64_t)v23[v20] >> 2) | ((unint64_t)(v23[v20] & 3) << 32), a3, 0, v11);
    if (HIDWORD(v26))
    {
      v27 = *(_QWORD *)(a3 + 56) + v21;
      v28 = *(unsigned __int8 *)(v27 + 36);
      *(_BYTE *)(v27 + 36) = v28 + 1;
      *(_DWORD *)(v27 + 4 * v28 + 40) = HIDWORD(v26) + 4 * v26;
      *(_DWORD *)(v27 + 4 * (v20 >> 5) + 4) |= 1 << v20;
    }
    ++v20;
  }
  while (v20 != 256);
LABEL_33:
  v5 = HIDWORD(v4);
  return v4 | ((unint64_t)v5 << 32);
}

uint64_t DCSSearchSession::DCSSearchSession(uint64_t a1, DCSDictionary *a2, const __CFString *a3, uint64_t a4, uint64_t a5, __int128 *a6)
{
  __int128 v12;
  __int128 v13;
  const __CFString *v14;
  uint64_t v15;

  *(_QWORD *)a1 = DCSSearchSession::createSessionRef((DCSSearchSession *)a1);
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 56) = CFRetain(a3);
  *(_QWORD *)(a1 + 64) = a4;
  *(_QWORD *)(a1 + 72) = a5;
  if (*(_QWORD *)a6)
  {
    v12 = *a6;
    v13 = a6[1];
    *(_QWORD *)(a1 + 48) = *((_QWORD *)a6 + 4);
    *(_OWORD *)(a1 + 16) = v12;
    *(_OWORD *)(a1 + 32) = v13;
    v14 = *(const __CFString **)(a1 + 32);
    if (v14)
      *(_QWORD *)(a1 + 32) = CFStringCreateCopy(0, v14);
  }
  else
  {
    *(_QWORD *)(a1 + 32) = 0;
    v15 = *((_QWORD *)a6 + 1);
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = v15;
    *(_OWORD *)(a1 + 40) = a6[1];
  }
  *(_QWORD *)(a1 + 80) = DCSDictionary::createSessionInfo(a2, (DCSSearchSession *)a1, a3, a4, a5);
  return a1;
}

uint64_t DCSSearchSession::createSessionRef(DCSSearchSession *this)
{
  uint64_t result;

  pthread_once(&_DCSSearchSessionClassID(void)::once_control, (void (*)(void))_DCSSearchSessionInitialize);
  result = _CFRuntimeCreateInstance();
  if (result)
    *(_QWORD *)(result + 16) = this;
  return result;
}

void DCSSearchSession::~DCSSearchSession(DCSSearchSession *this)
{
  const void *v2;
  void *v3;
  const void *v4;

  v2 = (const void *)*((_QWORD *)this + 7);
  if (v2)
    CFRelease(v2);
  v3 = (void *)*((_QWORD *)this + 10);
  if (v3)
    DCSDictionary::releaseSessionInfo(*((DCSDictionary **)this + 1), v3);
  v4 = (const void *)*((_QWORD *)this + 4);
  if (v4)
    CFRelease(v4);
}

uint64_t DCSSearchSession::scheduleRunLoop(DCSSearchSession *this, __CFRunLoop *a2, const __CFString *a3)
{
  return DCSDictionary::scheduleSession(*((DCSDictionary **)this + 1), *((void **)this + 10), a2, a3);
}

uint64_t DCSSearchSession::unscheduleRunLoop(DCSSearchSession *this, __CFRunLoop *a2, const __CFString *a3)
{
  return DCSDictionary::unscheduleSession(*((DCSDictionary **)this + 1), *((void **)this + 10), a2, a3);
}

_QWORD *DCSSearchSession::didFindRecord(_QWORD *this, const __CFArray *a2)
{
  uint64_t (*v2)(_QWORD, const __CFArray *, _QWORD);

  v2 = (uint64_t (*)(_QWORD, const __CFArray *, _QWORD))this[5];
  if (v2)
    return (_QWORD *)v2(*this, a2, this[3]);
  return this;
}

void DCSSearchSession::didFinishSearch(DCSSearchSession *this, CFTypeRef cf)
{
  void (*v2)(_QWORD, CFTypeRef, _QWORD);

  v2 = (void (*)(_QWORD, CFTypeRef, _QWORD))*((_QWORD *)this + 6);
  if (v2)
  {
    v2(*(_QWORD *)this, cf, *((_QWORD *)this + 3));
  }
  else if (cf)
  {
    CFRelease(cf);
  }
}

uint64_t DCSSearchSession::sessionRefClassID(DCSSearchSession *this)
{
  pthread_once(&_DCSSearchSessionClassID(void)::once_control, (void (*)(void))_DCSSearchSessionInitialize);
  return _DCSSearchSessionID;
}

uint64_t _DCSSearchSessionInitialize(void)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  _DCSSearchSessionID = result;
  return result;
}

uint64_t _DCSSearchSessionFinalize(uint64_t result)
{
  if (*(_QWORD *)(result + 16))
  {
    DCSSearchSession::~DCSSearchSession(*(DCSSearchSession **)(result + 16));
    JUMPOUT(0x1D17BC79CLL);
  }
  return result;
}

void sub_1CDF8E2C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10E0C40DFD76AA2);
  _Unwind_Resume(a1);
}

BOOL _DCSSearchSessionEqual(const void *a1, const void *a2)
{
  return a1 == a2;
}

CFStringRef _DCSSearchSessionCopyFormattingDesc(_QWORD *a1, const __CFDictionary *a2)
{
  uint64_t v3;
  const __CFAllocator *v4;
  const __CFDictionary *v5;

  v3 = a1[2];
  v4 = CFGetAllocator(a1);
  v5 = DCSDictionary::identifier(*(DCSDictionary **)(v3 + 8));
  return CFStringCreateWithFormat(v4, a2, CFSTR("<session for %@>"), v5);
}

CFStringRef _DCSSearchSessionCopyDebugDesc(_QWORD *a1)
{
  uint64_t v1;
  const __CFAllocator *v2;
  const __CFDictionary *v3;
  const __CFString *v4;

  v1 = a1[2];
  v2 = CFGetAllocator(a1);
  v3 = DCSDictionary::identifier(*(DCSDictionary **)(v1 + 8));
  v4 = *(const __CFString **)(v1 + 32);
  if (!v4)
    v4 = &stru_1E8B587B0;
  return CFStringCreateWithFormat(v2, 0, CFSTR("<DCSSearchSessionRef %p>{dict:%@, client:%@}"), v1, v3, v4);
}

void DCSBaseDictionary::DCSBaseDictionary(DCSBaseDictionary *this, CFURLRef relativeURL)
{
  const __CFURL *v3;
  const __CFURL *v4;

  *(_QWORD *)this = off_1E8B57D00;
  *((_QWORD *)this + 1) = 0;
  *((_BYTE *)this + 16) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_BYTE *)this + 72) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_BYTE *)this + 88) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_BYTE *)this + 104) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_BYTE *)this + 120) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_BYTE *)this + 136) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_BYTE *)this + 152) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_BYTE *)this + 168) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_BYTE *)this + 56) = 0;
  *((_QWORD *)this + 22) = -1;
  v3 = CFURLCopyAbsoluteURL(relativeURL);
  *((_QWORD *)this + 3) = v3;
  v4 = CFURLCreateCopyDeletingPathExtension(0, v3);
  *((_QWORD *)this + 4) = CFURLCopyLastPathComponent(v4);
  CFRelease(v4);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 184), 0);
}

void DCSBaseDictionary::~DCSBaseDictionary(DCSBaseDictionary *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;

  *(_QWORD *)this = off_1E8B57D00;
  CFRelease(*((CFTypeRef *)this + 3));
  CFRelease(*((CFTypeRef *)this + 4));
  v2 = (const void *)*((_QWORD *)this + 5);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 6);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 8);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 10);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 12);
  if (v6)
    CFRelease(v6);
  v7 = (const void *)*((_QWORD *)this + 14);
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 16);
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)this + 18);
  if (v9)
    CFRelease(v9);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 184));
}

CFStringRef DCSBaseDictionary::identifier(DCSBaseDictionary *this)
{
  CFStringRef result;
  __CFBundle *v3;

  result = (CFStringRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
  if (result)
  {
    v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
    return CFBundleGetIdentifier(v3);
  }
  return result;
}

uint64_t DCSBaseDictionary::baseURL(DCSBaseDictionary *this)
{
  uint64_t result;
  __CFBundle *v3;
  const __CFURL *v4;

  result = *((_QWORD *)this + 6);
  if (!result)
  {
    v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
    v4 = CFBundleCopyBundleURL(v3);
    *((_QWORD *)this + 6) = CFURLCreateCopyAppendingPathComponent(0, v4, CFSTR("Contents/Info.plist"), 0);
    CFRelease(v4);
    return *((_QWORD *)this + 6);
  }
  return result;
}

CFTypeRef DCSBaseDictionary::name(DCSBaseDictionary *this)
{
  __CFBundle *v2;
  CFTypeRef result;

  if (!(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this))
    return (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 368))(this);
  v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
  result = CFBundleGetValueForInfoDictionaryKey(v2, CFSTR("CFBundleDisplayName"));
  if (!result)
    return (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 368))(this);
  return result;
}

CFTypeRef DCSBaseDictionary::shortName(DCSBaseDictionary *this)
{
  __CFBundle *v2;
  CFTypeRef result;

  if (!(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this))
    return (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 368))(this);
  v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
  result = CFBundleGetValueForInfoDictionaryKey(v2, CFSTR("CFBundleName"));
  if (!result)
    return (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 368))(this);
  return result;
}

CFTypeRef DCSBaseDictionary::detailedShortName(DCSBaseDictionary *this)
{
  CFTypeRef result;
  __CFBundle *v3;

  result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
  if (result)
  {
    v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, CFSTR("DCSDictionaryDetailedDisplayName"));
  }
  return result;
}

CFTypeRef DCSBaseDictionary::nativeShortName(DCSBaseDictionary *this)
{
  CFTypeRef result;
  __CFBundle *v3;

  result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
  if (result)
  {
    v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, CFSTR("DCSDictionaryNativeDisplayName"));
  }
  return result;
}

CFTypeRef DCSBaseDictionary::typeName(DCSBaseDictionary *this)
{
  CFTypeRef result;
  __CFBundle *v3;

  result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
  if (result)
  {
    v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, CFSTR("DCSDictionaryTypeDisplayName"));
  }
  return result;
}

CFTypeRef DCSBaseDictionary::version(DCSBaseDictionary *this)
{
  CFTypeRef result;
  __CFBundle *v3;

  result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
  if (result)
  {
    v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, CFSTR("CFBundleShortVersionString"));
  }
  return result;
}

CFTypeRef DCSBaseDictionary::primaryLanguage(DCSBaseDictionary *this)
{
  CFTypeRef result;
  __CFBundle *v3;

  result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
  if (result)
  {
    v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, CFSTR("DCSDictionaryPrimaryLanguage"));
  }
  return result;
}

CFTypeRef DCSBaseDictionary::languages(DCSBaseDictionary *this)
{
  CFTypeRef result;
  __CFBundle *v3;

  result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
  if (result)
  {
    v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, CFSTR("DCSDictionaryLanguages"));
  }
  return result;
}

uint64_t DCSBaseDictionary::styleSheetURLs(DCSBaseDictionary *this)
{
  __CFBundle *v2;
  const __CFArray *ValueForInfoDictionaryKey;
  const __CFArray *v4;
  __CFBundle *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const __CFString *ValueAtIndex;
  const __CFURL *v10;
  CFURLRef v11;
  CFURLRef v12;
  void *values;

  if (!*((_BYTE *)this + 72))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
    if (*((_BYTE *)this + 72))
    {
LABEL_18:
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 184));
      return *((_QWORD *)this + 10);
    }
    if ((*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this)
      && (v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this),
          (ValueForInfoDictionaryKey = (const __CFArray *)CFBundleGetValueForInfoDictionaryKey(v2, CFSTR("DCSDictionaryStyleSheets"))) != 0))
    {
      v4 = ValueForInfoDictionaryKey;
      CFRetain(ValueForInfoDictionaryKey);
    }
    else if (!(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this)
           || (v5 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this),
               (values = (void *)CFBundleGetValueForInfoDictionaryKey(v5, CFSTR("DCSDictionaryCSS"))) == 0)
           || (v4 = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E0C9B378])) == 0)
    {
LABEL_17:
      *((_BYTE *)this + 72) = 1;
      goto LABEL_18;
    }
    *((_QWORD *)this + 10) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      v7 = Count;
      for (i = 0; i != v7; ++i)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, i);
        v10 = (const __CFURL *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 32))(this);
        v11 = CFURLCreateWithString(0, ValueAtIndex, v10);
        if (v11)
        {
          v12 = v11;
          CFArrayAppendValue(*((CFMutableArrayRef *)this + 10), v11);
          CFRelease(v12);
        }
      }
    }
    if (!CFArrayGetCount(*((CFArrayRef *)this + 10)))
    {
      CFRelease(*((CFTypeRef *)this + 10));
      *((_QWORD *)this + 10) = 0;
    }
    CFRelease(v4);
    goto LABEL_17;
  }
  return *((_QWORD *)this + 10);
}

uint64_t DCSBaseDictionary::styleSheetContents(DCSBaseDictionary *this)
{
  __CFBundle *v2;
  const __CFArray *ValueForInfoDictionaryKey;
  const __CFArray *v4;
  __CFBundle *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v10;
  const __CFData *v11;
  const __CFString *v12;
  CFStringEncoding v13;
  CFStringRef v14;
  const __CFString *v15;
  CFStringRef v16;
  void *values;
  CFRange v19;

  if (!*((_BYTE *)this + 88))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
    if (*((_BYTE *)this + 88))
    {
LABEL_28:
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 184));
      return *((_QWORD *)this + 12);
    }
    if ((*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this)
      && (v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this),
          (ValueForInfoDictionaryKey = (const __CFArray *)CFBundleGetValueForInfoDictionaryKey(v2, CFSTR("DCSDictionaryStyleSheets"))) != 0))
    {
      v4 = ValueForInfoDictionaryKey;
      CFRetain(ValueForInfoDictionaryKey);
    }
    else if (!(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this)
           || (v5 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this),
               (values = (void *)CFBundleGetValueForInfoDictionaryKey(v5, CFSTR("DCSDictionaryCSS"))) == 0)
           || (v4 = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E0C9B378])) == 0)
    {
LABEL_27:
      *((_BYTE *)this + 88) = 1;
      goto LABEL_28;
    }
    *((_QWORD *)this + 12) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      v7 = Count;
      for (i = 0; v7 != i; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v4, i);
        v10 = (*(uint64_t (**)(DCSBaseDictionary *, const void *, uint64_t, _QWORD))(*(_QWORD *)this + 384))(this, ValueAtIndex, 1, 0);
        if (v10)
        {
          v11 = (const __CFData *)v10;
          v12 = (const __CFString *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 24))(this);
          if (v12 && CFStringHasPrefix(v12, CFSTR("com.apple.dictionary."))
            || (v13 = DetectEncodingOfStringData(v11), v13 == -1))
          {
            v14 = CFStringCreateFromExternalRepresentation(0, v11, 0x8000100u);
            if (v14)
            {
              v15 = v14;
              CFRelease(v11);
LABEL_19:
              if (CFStringGetLength(v15) >= 1)
              {
                if (CFStringGetCharacterAtIndex(v15, 0) == 65279)
                {
                  v19.length = CFStringGetLength(v15) - 1;
                  v19.location = 1;
                  v16 = CFStringCreateWithSubstring(0, v15, v19);
                  CFRelease(v15);
                  v15 = v16;
                }
                CFArrayAppendValue(*((CFMutableArrayRef *)this + 12), v15);
                CFRelease(v15);
              }
              continue;
            }
            v13 = 256;
          }
          v15 = CFStringCreateFromExternalRepresentation(0, v11, v13);
          CFRelease(v11);
          if (v15)
            goto LABEL_19;
        }
      }
    }
    if (!CFArrayGetCount(*((CFArrayRef *)this + 12)))
    {
      CFRelease(*((CFTypeRef *)this + 12));
      *((_QWORD *)this + 12) = 0;
    }
    CFRelease(v4);
    goto LABEL_27;
  }
  return *((_QWORD *)this + 12);
}

uint64_t DCSBaseDictionary::privateFontURLs(DCSBaseDictionary *this)
{
  __CFBundle *v2;
  const __CFArray *ValueForInfoDictionaryKey;
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  const void *ValueAtIndex;
  void *value;

  if (!*((_BYTE *)this + 104))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
    if (!*((_BYTE *)this + 104))
    {
      if ((*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this))
      {
        v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
        ValueForInfoDictionaryKey = (const __CFArray *)CFBundleGetValueForInfoDictionaryKey(v2, CFSTR("DCSDictionaryPrivateFonts"));
        if (ValueForInfoDictionaryKey)
        {
          v4 = ValueForInfoDictionaryKey;
          *((_QWORD *)this + 14) = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
          Count = CFArrayGetCount(v4);
          if (Count >= 1)
          {
            v6 = Count;
            for (i = 0; i != v6; ++i)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(v4, i);
              value = 0;
              (*(void (**)(DCSBaseDictionary *, const void *, _QWORD, void **))(*(_QWORD *)this + 384))(this, ValueAtIndex, 0, &value);
              if (value)
              {
                CFArrayAppendValue(*((CFMutableArrayRef *)this + 14), value);
                CFRelease(value);
              }
            }
          }
          if (!CFArrayGetCount(*((CFArrayRef *)this + 14)))
          {
            CFRelease(*((CFTypeRef *)this + 14));
            *((_QWORD *)this + 14) = 0;
          }
        }
      }
      *((_BYTE *)this + 104) = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 184));
  }
  return *((_QWORD *)this + 14);
}

uint64_t DCSBaseDictionary::XSLTData(DCSBaseDictionary *this)
{
  __CFBundle *v2;
  CFTypeRef ValueForInfoDictionaryKey;

  if (!*((_BYTE *)this + 56))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
    if (!*((_BYTE *)this + 56))
    {
      if ((*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this))
      {
        v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
        ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(v2, CFSTR("DCSDictionaryXSL"));
        if (ValueForInfoDictionaryKey)
          *((_QWORD *)this + 8) = (*(uint64_t (**)(DCSBaseDictionary *, CFTypeRef, uint64_t, _QWORD))(*(_QWORD *)this + 384))(this, ValueForInfoDictionaryKey, 1, 0);
      }
      *((_BYTE *)this + 56) = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 184));
  }
  return *((_QWORD *)this + 8);
}

CFTypeRef DCSBaseDictionary::elementXPaths(DCSBaseDictionary *this)
{
  CFTypeRef result;
  __CFBundle *v3;

  result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
  if (result)
  {
    v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, CFSTR("DCSElementXPath"));
  }
  return result;
}

uint64_t DCSBaseDictionary::preferenceHTML(DCSBaseDictionary *this)
{
  __CFBundle *v2;
  CFTypeRef ValueForInfoDictionaryKey;
  const __CFData *v4;
  const __CFData *v5;
  const UInt8 *BytePtr;
  CFIndex Length;

  if (!*((_BYTE *)this + 120))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
    if (!*((_BYTE *)this + 120))
    {
      if ((*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this))
      {
        v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
        ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(v2, CFSTR("DCSDictionaryPrefsHTML"));
        if (ValueForInfoDictionaryKey)
        {
          v4 = (const __CFData *)(*(uint64_t (**)(DCSBaseDictionary *, CFTypeRef, uint64_t, _QWORD))(*(_QWORD *)this + 384))(this, ValueForInfoDictionaryKey, 1, 0);
          if (v4)
          {
            v5 = v4;
            BytePtr = CFDataGetBytePtr(v4);
            Length = CFDataGetLength(v5);
            *((_QWORD *)this + 16) = CFStringCreateWithBytes(0, BytePtr, Length, 0x8000100u, 0);
            CFRelease(v5);
          }
        }
      }
      *((_BYTE *)this + 120) = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 184));
  }
  return *((_QWORD *)this + 16);
}

uint64_t DCSBaseDictionary::preference(DCSBaseDictionary *this)
{
  const void *v2;

  if (!*((_BYTE *)this + 136))
  {
    if ((*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this))
    {
      v2 = (const void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 176))(this);
      *((_QWORD *)this + 18) = v2;
      if (v2)
        CFRetain(v2);
    }
    else
    {
      *((_QWORD *)this + 18) = 0;
    }
    *((_BYTE *)this + 136) = 1;
  }
  return *((_QWORD *)this + 18);
}

CFTypeRef DCSBaseDictionary::defaultPreference(DCSBaseDictionary *this)
{
  CFTypeRef result;
  __CFBundle *v3;

  result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
  if (result)
  {
    v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, CFSTR("DCSDictionaryDefaultPrefs"));
  }
  return result;
}

void DCSBaseDictionary::setPreference(DCSBaseDictionary *this, CFTypeRef cf)
{
  const void *v4;

  *((_BYTE *)this + 136) = 1;
  CFRetain(cf);
  v4 = (const void *)*((_QWORD *)this + 18);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)this + 18) = cf;
}

const __CFBoolean *DCSBaseDictionary::isSortableDictionary(DCSBaseDictionary *this)
{
  const __CFBoolean *result;
  __CFBundle *v3;

  result = (const __CFBoolean *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
  if (result)
  {
    v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
    result = (const __CFBoolean *)CFBundleGetValueForInfoDictionaryKey(v3, CFSTR("DCSDictionarySortAllowed_iOS"));
    if (result)
      return (const __CFBoolean *)(CFBooleanGetValue(result) != 0);
  }
  return result;
}

BOOL DCSBaseDictionary::isAppearanceAwareDictionary(DCSBaseDictionary *this)
{
  DCSBaseDictionary *v1;
  __CFBundle *v2;

  v1 = this;
  if (*((_BYTE *)this + 168))
  {
    LODWORD(this) = *((unsigned __int8 *)this + 169);
  }
  else
  {
    *((_BYTE *)this + 168) = 1;
    this = (DCSBaseDictionary *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
    if (this)
    {
      v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)v1 + 376))(v1);
      this = (DCSBaseDictionary *)CFBundleGetValueForInfoDictionaryKey(v2, CFSTR("DCSDictionaryUseSystemAppearance"));
      if (this)
        LODWORD(this) = CFBooleanGetValue(this);
    }
    *((_BYTE *)v1 + 169) = (_BYTE)this;
  }
  return (_DWORD)this != 0;
}

BOOL DCSBaseDictionary::isLanguageDictionary(DCSBaseDictionary *this)
{
  const __CFArray *v2;

  v2 = (const __CFArray *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 96))(this);
  if ((*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 88))(this))
    return 1;
  if (v2)
    return CFArrayGetCount(v2) > 1;
  return 0;
}

uint64_t DCSBaseDictionary::previewMarkupVersion(DCSBaseDictionary *this)
{
  uint64_t result;
  _QWORD *v3;
  __CFBundle *v4;

  v3 = (_QWORD *)((char *)this + 176);
  result = *((_QWORD *)this + 22);
  if (result == -1)
  {
    result = (*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
    if (result)
    {
      v4 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
      result = (uint64_t)CFBundleGetValueForInfoDictionaryKey(v4, CFSTR("DCSDictionaryPreviewMarkupVersion"));
      if (result)
        result = CFNumberGetValue((CFNumberRef)result, kCFNumberCFIndexType, v3);
    }
    *v3 = result;
  }
  return result;
}

BOOL DCSBaseDictionary::isSupportedDefinitionStyle(DCSBaseDictionary *this, uint64_t a2)
{
  __CFBundle *v4;
  const __CFArray *ValueForInfoDictionaryKey;
  const __CFArray *v6;
  CFIndex Count;
  uint64_t v8;
  uint64_t v9;
  CFRange v11;
  CFRange v12;

  if (!*((_QWORD *)this + 20))
  {
    if (!(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this)
      || (v4 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this),
          (ValueForInfoDictionaryKey = (const __CFArray *)CFBundleGetValueForInfoDictionaryKey(v4, CFSTR("DCSDictionaryDefinitionDataType"))) == 0))
    {
      v8 = 1;
      goto LABEL_9;
    }
    v6 = ValueForInfoDictionaryKey;
    Count = CFArrayGetCount(ValueForInfoDictionaryKey);
    v11.location = 0;
    v11.length = Count;
    if (CFArrayGetFirstIndexOfValue(v6, v11, CFSTR("DCSDictionaryDefinitionDataXML")) != -1)
      *((_QWORD *)this + 20) |= 1uLL;
    v12.location = 0;
    v12.length = Count;
    if (CFArrayGetFirstIndexOfValue(v6, v12, CFSTR("DCSDictionaryDefinitionDataRTFD")) != -1)
    {
      v8 = *((_QWORD *)this + 20) | 2;
LABEL_9:
      *((_QWORD *)this + 20) = v8;
    }
  }
  v9 = 1;
  if (a2 == 4)
    v9 = 2;
  return (*((_QWORD *)this + 20) & v9) != 0;
}

CFBundleRef DCSBaseDictionary::bundle(DCSBaseDictionary *this)
{
  CFBundleRef result;
  const __CFURL *v3;

  result = (CFBundleRef)*((_QWORD *)this + 5);
  if (!result)
  {
    v3 = (const __CFURL *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 16))(this);
    result = CFBundleCreate(0, v3);
    *((_QWORD *)this + 5) = result;
  }
  return result;
}

CFDataRef DCSBaseDictionary::resourceData(DCSBaseDictionary *this, const __CFString *a2, int a3, const __CFURL **a4)
{
  const __CFURL *v8;
  const __CFURL *v9;
  const __CFURL *v10;
  __CFBundle *v11;
  const __CFURL *v12;
  CFDataRef resourceData;

  resourceData = 0;
  v8 = (const __CFURL *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 16))(this);
  v9 = CFURLCreateCopyAppendingPathComponent(0, v8, CFSTR("Contents"), 1u);
  v10 = CFURLCreateCopyAppendingPathComponent(0, v9, a2, 0);
  CFRelease(v9);
  if (a3)
  {
    if (CFURLCreateDataAndPropertiesFromResource(0, v10, &resourceData, 0, 0, 0))
      goto LABEL_10;
  }
  else if (ItemExistsAtURL(v10))
  {
    goto LABEL_10;
  }
  CFRelease(v10);
  v11 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(_QWORD *)this + 376))(this);
  v12 = CFBundleCopyResourceURL(v11, a2, 0, 0);
  v10 = v12;
  if (!v12)
  {
LABEL_10:
    if (!a4)
      goto LABEL_13;
LABEL_11:
    *a4 = v10;
    return resourceData;
  }
  if (!a3)
  {
    if (!ItemExistsAtURL(v12))
      goto LABEL_12;
    goto LABEL_10;
  }
  if (CFURLCreateDataAndPropertiesFromResource(0, v12, &resourceData, 0, 0, 0))
    goto LABEL_10;
LABEL_12:
  CFRelease(v10);
  v10 = 0;
  if (a4)
    goto LABEL_11;
LABEL_13:
  if (v10)
    CFRelease(v10);
  return resourceData;
}

uint64_t DCSBaseDictionary::isLocalizableDictionary(DCSBaseDictionary *this)
{
  return 0;
}

uint64_t DCSBaseDictionary::primaryLocale(DCSBaseDictionary *this)
{
  return 0;
}

uint64_t DCSBaseDictionary::languageDirectionOfFoundRecord()
{
  return 0;
}

void InspectorAccessContext::InspectorAccessContext(InspectorAccessContext *this, IDXIndexInfo *a2)
{
  uint64_t v3;
  const __CFString *v4;

  v3 = IDXAccessContext::IDXAccessContext((uint64_t)this, (uint64_t)a2);
  *(_QWORD *)v3 = &off_1E8B57EA8;
  *(_QWORD *)(v3 + 56) = 0;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  v4 = (const __CFString *)IDXIndexInfo::relativePath(*(IDXIndexInfo **)(v3 + 8));
  *((_BYTE *)this + 64) = CFStringCompare(v4, CFSTR("NumberValue.index"), 0) == kCFCompareEqualTo;
}

void sub_1CDF8F52C(_Unwind_Exception *a1)
{
  IDXAccessContext *v1;

  IDXAccessContext::~IDXAccessContext(v1);
  _Unwind_Resume(a1);
}

void InspectorAccessContext::~InspectorAccessContext(InspectorAccessContext *this)
{
  IDXAccessContext::~IDXAccessContext(this);
  JUMPOUT(0x1D17BC79CLL);
}

void sub_1CDF8F584(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC79C](v1, 0x10F1C40F8DAED6BLL);
  _Unwind_Resume(a1);
}

BOOL InspectorAccessContext::setSearchCharacters(InspectorAccessContext *this, const unsigned __int16 *__src, unint64_t a3, const __CFString *a4)
{
  void *v8;
  const void *v9;
  CFStringRef v10;

  v8 = (void *)*((_QWORD *)this + 4);
  if (!v8)
  {
    v8 = (void *)operator new[]();
    *((_QWORD *)this + 4) = v8;
  }
  if (a3 <= 0x80)
  {
    *((_QWORD *)this + 5) = a3;
    memcpy(v8, __src, 2 * a3);
    *((_QWORD *)this + 3) = CFRetain(a4);
    v9 = (const void *)*((_QWORD *)this + 7);
    if (v9)
      CFRelease(v9);
    v10 = CFStringCreateWithBytes(0, (const UInt8 *)__src, 2 * a3, 0x100u, 0);
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 7) = v10;
  }
  return a3 < 0x81;
}

uint64_t InspectorAccessContext::getMatchDataPtr(InspectorAccessContext *this, uint64_t a2, const unsigned __int8 **a3, uint64_t *a4)
{
  return 0;
}

uint64_t InspectorAccessContext::getMatchData(InspectorAccessContext *this, uint64_t a2, uint64_t a3, CFRange *a4, CFRange **a5, uint64_t *a6)
{
  uint64_t result;
  uint64_t v10;
  CFComparisonResult v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 *v16;
  uint64_t v17;

  result = 0;
  *a6 = 0;
  if (*((uint64_t *)this + 6) > 0)
    return result;
  if (*((_BYTE *)this + 64))
  {
    v10 = a3 - 4;
    a4->location = a3 - 4;
    a4->length = 4;
    if (CFStringCompare(*((CFStringRef *)this + 7), CFSTR("openCount"), 0) == kCFCompareEqualTo)
    {
      v12 = IDXIndexInfo::openCount(*((IDXIndexInfo **)this + 1));
      goto LABEL_13;
    }
    if (CFStringCompare(*((CFStringRef *)this + 7), CFSTR("initiallyOpenedCallCount"), 0) == kCFCompareEqualTo)
    {
      v12 = InspectorAccessContext::_initiallyOpenedCallCount;
      goto LABEL_13;
    }
    v11 = CFStringCompare(*((CFStringRef *)this + 7), CFSTR("lastlyClosedCallCount"), 0);
    result = 0;
    if (v11 == kCFCompareEqualTo)
    {
      v12 = InspectorAccessContext::_lastlyClosedCallCount;
LABEL_13:
      *(_DWORD *)((char *)&a4->location + v10) = v12;
      goto LABEL_14;
    }
  }
  else
  {
    v13 = *((_QWORD *)this + 5);
    v14 = a3 - 2 * v13;
    a4->location = v14 - 2;
    a4->length = 2 * v13 + 2;
    *(_WORD *)((char *)a4 + v14 - 2) = 2 * v13;
    v15 = *((_QWORD *)this + 5);
    if (v15 < 1)
    {
LABEL_14:
      result = 1;
      goto LABEL_15;
    }
    v16 = (unsigned __int8 *)a4 + v14;
    v17 = *((_QWORD *)this + 4) - 2;
    result = 1;
    do
    {
      *(_WORD *)v16 = *(_WORD *)(v17 + 2 * v15);
      v16 += 2;
      --v15;
    }
    while (v15);
  }
LABEL_15:
  if (a5)
    *a5 = a4;
  *((_QWORD *)this + 6) += result;
  return result;
}

uint64_t InspectorAccessContext::supportDataPtr(InspectorAccessContext *this)
{
  return 0;
}

uint64_t InspectorAccessContext::getDataPtrByID(InspectorAccessContext *this, unint64_t a2, uint64_t *a3)
{
  return 0;
}

CFIndex InspectorAccessContext::getDataByID(InspectorAccessContext *this, uint64_t a2, CFIndex a3, unsigned __int8 *a4)
{
  const __CFTimeZone *v7;
  unint64_t v8;
  const __CFString *v9;
  CFIndex usedBufLen;
  CFRange v12;

  v7 = CFTimeZoneCopySystem();
  v8 = *(_OWORD *)&CFAbsoluteTimeGetGregorianDate((double)a2, v7);
  CFRelease(v7);
  v9 = CFStringCreateWithFormat(0, 0, CFSTR("%02d/%02d/%04d"), ((int)(v8 >> 8) >> 24), ((int)(v8 >> 16) >> 24), v8);
  usedBufLen = 0;
  v12.length = CFStringGetLength(v9);
  v12.location = 0;
  CFStringGetBytes(v9, v12, 0x8000100u, 0, 0, a4, a3, &usedBufLen);
  CFRelease(v9);
  return usedBufLen;
}

uint64_t InspectorAccessContext::addRecord(InspectorAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4, uint64_t a5, unint64_t *a6)
{
  return 0;
}

uint64_t InspectorAccessContext::deleteRecord(InspectorAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4)
{
  return 0;
}

BOOL InspectorAccessContext::createIndexFile(InspectorAccessContext *this, IDXIndexInfo *a2)
{
  __CFWriteStream *v3;
  __CFWriteStream *v4;
  CFIndex v5;
  _BOOL8 v6;

  v3 = CFWriteStreamCreateWithFile(0, *(CFURLRef *)this);
  if (!v3)
    return 0;
  v4 = v3;
  if (CFWriteStreamOpen(v3))
  {
    v5 = CFPropertyListWriteToStream(*((CFPropertyListRef *)this + 1), v4, kCFPropertyListXMLFormat_v1_0, 0);
    CFWriteStreamClose(v4);
    v6 = v5 > 0;
  }
  else
  {
    v6 = 0;
  }
  CFRelease(v4);
  return v6;
}

uint64_t InspectorAccessContext::initializeSubclass(InspectorAccessContext *this, int a2, void **a3)
{
  if (a2)
    ++InspectorAccessContext::_initiallyOpenedCallCount;
  return 1;
}

void InspectorAccessContext::finalizeSubclass(InspectorAccessContext *this, int a2)
{
  if (a2)
    ++InspectorAccessContext::_lastlyClosedCallCount;
}

uint64_t InspectorAccessContext::containsMatchData(InspectorAccessContext *this, unsigned __int8 *a2)
{
  return 0;
}

const void *DCSDictionaryCreateWithAssetAttributes(const __CFDictionary *a1, const __CFURL *a2)
{
  const __CFString *Value;
  const __CFURL *v4;
  const void *v5;

  Value = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("DictionaryPackageName"));
  v4 = CFURLCreateCopyAppendingPathComponent(0, a2, Value, 1u);
  v5 = DCSDictionaryCreate(v4);
  CFRelease(v4);
  return v5;
}

void DCSDictionaryAssetAttributesDownloaded(const __CFDictionary *a1)
{
  const void *Value;
  const void *v3;
  _QWORD block[5];

  if (a1)
  {
    Value = CFDictionaryGetValue(a1, CFSTR("DictionaryPackageName"));
    if (Value)
    {
      v3 = Value;
      CFRetain(Value);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __DCSDictionaryAssetAttributesDownloaded_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = v3;
      dispatch_async(MEMORY[0x1E0C80D38], block);
      DCSMAUpdateLinguisticDataForDictionaryAssetAttribute(a1, 1);
    }
  }
}

void __DCSDictionaryAssetUpdatePreferences(const void *a1, int a2)
{
  const __CFAllocator *v4;
  __CFArray *Mutable;
  const __CFArray *v6;
  const __CFArray *v7;
  CFRange v8;
  CFIndex FirstIndexOfValue;
  __CFArray *v10;
  const __CFArray *v11;
  const __CFArray *v12;
  CFRange v13;
  CFIndex v14;
  __CFNotificationCenter *DarwinNotifyCenter;
  CFRange v16;
  CFRange v17;

  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v6 = (const __CFArray *)DCSCopySharedPreferenceValue(CFSTR("DCSAssetPreferenceKeyDownloadedDictionaries"), 0, 0);
  if (v6)
  {
    v7 = v6;
    v16.length = CFArrayGetCount(v6);
    v16.location = 0;
    CFArrayAppendArray(Mutable, v7, v16);
    CFRelease(v7);
  }
  v8.length = CFArrayGetCount(Mutable);
  v8.location = 0;
  if (a2)
  {
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(Mutable, v8, a1);
    if (FirstIndexOfValue == -1)
      goto LABEL_9;
    CFArrayRemoveValueAtIndex(Mutable, FirstIndexOfValue);
  }
  else
  {
    if (CFArrayContainsValue(Mutable, v8, a1))
      goto LABEL_9;
    CFArrayAppendValue(Mutable, a1);
  }
  DCSUpdateSharedPreferenceValue(CFSTR("DCSAssetPreferenceKeyDownloadedDictionaries"), Mutable);
LABEL_9:
  CFRelease(Mutable);
  v10 = CFArrayCreateMutable(v4, 0, MEMORY[0x1E0C9B378]);
  v11 = (const __CFArray *)DCSCopySharedPreferenceValue(CFSTR("DCSAssetPreferenceKeyRemovedDictionaries"), 0, 0);
  if (v11)
  {
    v12 = v11;
    v17.length = CFArrayGetCount(v11);
    v17.location = 0;
    CFArrayAppendArray(v10, v12, v17);
    CFRelease(v12);
  }
  v13.length = CFArrayGetCount(v10);
  v13.location = 0;
  if (a2)
  {
    if (!CFArrayContainsValue(v10, v13, a1))
    {
      CFArrayAppendValue(v10, a1);
LABEL_16:
      DCSUpdateSharedPreferenceValue(CFSTR("DCSAssetPreferenceKeyRemovedDictionaries"), v10);
    }
  }
  else
  {
    v14 = CFArrayGetFirstIndexOfValue(v10, v13, a1);
    if (v14 != -1)
    {
      CFArrayRemoveValueAtIndex(v10, v14);
      goto LABEL_16;
    }
  }
  CFRelease(v10);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterPostNotification(DarwinNotifyCenter, CFSTR("DCSActiveDictionariesChangedDistributedNotification"), 0, 0, 0);
}

void DCSDictionaryAssetAttributesWillBePurged(const __CFDictionary *a1)
{
  const void *Value;
  const void *v3;
  _QWORD block[5];

  if (a1)
  {
    Value = CFDictionaryGetValue(a1, CFSTR("DictionaryPackageName"));
    if (Value)
    {
      v3 = Value;
      CFRetain(Value);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __DCSDictionaryAssetAttributesWillBePurged_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = v3;
      dispatch_async(MEMORY[0x1E0C80D38], block);
      DCSMAUpdateLinguisticDataForDictionaryAssetAttribute(a1, 0);
    }
  }
}

void *DCSDictionaryAssetCopyDownloadedDictionaryIdentifiers()
{
  return DCSCopySharedPreferenceValue(CFSTR("DCSAssetPreferenceKeyDownloadedDictionaries"), 0, 0);
}

void *DCSDictionaryAssetCopyRemovedDictionaryIdentifiers()
{
  return DCSCopySharedPreferenceValue(CFSTR("DCSAssetPreferenceKeyRemovedDictionaries"), 0, 0);
}

const __CFArray *DCSCopyLemmas(uint64_t a1, const void *a2)
{
  uint64_t v4;
  const __CFDictionary *Value;
  const __CFDictionary *v6;
  unint64_t v7;
  const __CFDictionary *v8;
  CFMutableDictionaryRef Mutable;
  NSObject *v10;
  NSObject *v11;
  dispatch_time_t v12;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  unint64_t v15;
  const __CFArray *v16;
  void (*v18)(unint64_t, uint64_t, _QWORD *);
  CFIndex Count;
  CFIndex v20;
  unint64_t v21;
  const void **v22;
  size_t v23;
  CFArrayRef v24;
  _QWORD v25[7];
  _QWORD v26[5];
  _QWORD block[8];

  block[7] = *MEMORY[0x1E0C80C00];
  if (DCSCopyLemmas__OnceToken != -1)
  {
    dispatch_once(&DCSCopyLemmas__OnceToken, &__block_literal_global_7);
    if (!a1)
      return 0;
LABEL_3:
    if (_GetNLPFrameworkInfo__DispatchOnceToken != -1)
      dispatch_once(&_GetNLPFrameworkInfo__DispatchOnceToken, &__block_literal_global_11_0);
    v4 = _GetNLPFrameworkInfo__InfoPtr;
    if (!_GetNLPFrameworkInfo__InfoPtr)
      return 0;
    pthread_mutex_lock(&DCSCopyLemmas__AnalyzersCacheMutex);
    Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)DCSCopyLemmas__AnalyzersForLanguage, a2);
    if (Value)
    {
      v6 = Value;
      v7 = (unint64_t)CFDictionaryGetValue(Value, CFSTR("MorphologicalAnalyzer"));
      v8 = v6;
    }
    else
    {
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue((CFMutableDictionaryRef)DCSCopyLemmas__AnalyzersForLanguage, a2, Mutable);
      CFRelease(Mutable);
      pthread_mutex_unlock(&DCSCopyLemmas__AnalyzersCacheMutex);
      v10 = dispatch_queue_create("dispatch_queue_for_analayzer", 0);
      v11 = dispatch_group_create();
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __DCSCopyLemmas_block_invoke_2;
      block[3] = &__block_descriptor_56_e5_v8__0l;
      block[4] = v4;
      block[5] = a2;
      block[6] = 0;
      dispatch_group_async(v11, v10, block);
      v12 = dispatch_time(0, 1000000000);
      dispatch_group_wait(v11, v12);
      dispatch_release(v11);
      dispatch_release(v10);
      pthread_mutex_lock(&DCSCopyLemmas__AnalyzersCacheMutex);
      v13 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)DCSCopyLemmas__AnalyzersForLanguage, a2);
      if (!v13)
      {
        v15 = 0;
        v7 = 0;
LABEL_11:
        pthread_mutex_unlock(&DCSCopyLemmas__AnalyzersCacheMutex);
        if (!(v7 | v15))
          return 0;
        if (v7)
        {
          v16 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
          v18 = *(void (**)(unint64_t, uint64_t, _QWORD *))(v4 + 8);
          v26[0] = MEMORY[0x1E0C809B0];
          v26[1] = 3221225472;
          v26[2] = __DCSCopyLemmas_block_invoke_3;
          v26[3] = &__block_descriptor_40_e41_v32__0____CFString__8____CFString__16_B24l;
          v26[4] = v16;
          v18(v7, a1, v26);
          if (CFArrayGetCount(v16) > 0)
            return v16;
        }
        else
        {
          if (!v15)
            return 0;
          v16 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          v25[1] = MEMORY[0x1E0C809B0];
          v25[2] = 3221225472;
          v25[3] = __DCSCopyLemmas_block_invoke_4;
          v25[4] = &__block_descriptor_48_e27_v28__0____CFString__8C16_20l;
          v25[5] = a1;
          v25[6] = v16;
          LXLemmatizerEnumerateLemmasforString();
          Count = CFDictionaryGetCount(v16);
          if (Count >= 1)
          {
            v20 = Count;
            MEMORY[0x1E0C80A78](Count);
            v22 = (const void **)((char *)v25 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0));
            if (v21 >= 0x200)
              v23 = 512;
            else
              v23 = v21;
            bzero((char *)v25 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v23);
            CFDictionaryGetKeysAndValues(v16, v22, 0);
            v24 = CFArrayCreate(0, v22, v20, MEMORY[0x1E0C9B378]);
            goto LABEL_24;
          }
        }
        v24 = 0;
LABEL_24:
        CFRelease(v16);
        return v24;
      }
      v14 = v13;
      v7 = (unint64_t)CFDictionaryGetValue(v13, CFSTR("MorphologicalAnalyzer"));
      v8 = v14;
    }
    v15 = (unint64_t)CFDictionaryGetValue(v8, CFSTR("Lemmatizer"));
    goto LABEL_11;
  }
  if (a1)
    goto LABEL_3;
  return 0;
}

double marisa::Agent::Agent(marisa::Agent *this)
{
  double result;

  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  return result;
}

void marisa::Agent::~Agent(marisa::Agent *this)
{
  marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((_QWORD *)this + 5);
}

_QWORD *marisa::Agent::set_query(_QWORD *this, const char *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *exception;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc";
    exception[2] = 0x20000000DLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc:13: MARISA_NULL_ERROR: str == NULL";
  }
  v2 = this[5];
  if (v2)
    *(_DWORD *)(v2 + 108) = 0;
  v3 = 0;
  while (a2[v3++])
    ;
  *this = a2;
  this[1] = v3 - 1;
  return this;
}

_QWORD *marisa::Agent::set_query(_QWORD *this, const char *a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *exception;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc";
    exception[2] = 0x200000015;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc:21: MARISA_NULL_ERROR: (ptr == NULL)"
                   " && (length != 0)";
  }
  v3 = this[5];
  if (v3)
    *(_DWORD *)(v3 + 108) = 0;
  *this = a2;
  this[1] = a3;
  return this;
}

uint64_t marisa::Agent::set_query(uint64_t this, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(this + 40);
  if (v2)
    *(_DWORD *)(v2 + 108) = 0;
  *(_QWORD *)(this + 16) = a2;
  return this;
}

_QWORD *marisa::Agent::init_state(marisa::Agent *this)
{
  uint64_t *v1;
  _OWORD *v2;
  _QWORD *result;
  _QWORD *exception;
  const char *v5;

  v1 = (uint64_t *)((char *)this + 40);
  if (*((_QWORD *)this + 5))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc";
    exception[2] = 0x100000024;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc:36: MARISA_STATE_ERROR: state_.get() != NULL";
    goto LABEL_8;
  }
  v2 = operator new(0x70uLL, MEMORY[0x1E0DE4E10]);
  if (v2)
  {
    *(_OWORD *)((char *)v2 + 25) = 0u;
    *v2 = 0u;
    v2[1] = 0u;
    v2[3] = 0u;
    v2[4] = 0u;
    *(_OWORD *)((char *)v2 + 73) = 0u;
    *((_QWORD *)v2 + 12) = 0;
    *((_QWORD *)v2 + 13) = 0;
  }
  result = marisa::scoped_ptr<marisa::grimoire::trie::State>::reset(v1, (uint64_t)v2);
  if (!*v1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc";
    exception[2] = 0x800000026;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc:38: MARISA_MEMORY_ERROR: state_.get() == NULL";
LABEL_8:
    exception[3] = v5;
  }
  return result;
}

_QWORD *marisa::scoped_ptr<marisa::grimoire::trie::State>::reset(uint64_t *a1, uint64_t a2)
{
  _QWORD *exception;
  uint64_t v4;

  if (a2 && *a1 == a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/include/marisa/scoped-ptr.h";
    exception[2] = 0x600000013;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/include/marisa/scoped-ptr.h:19: MARISA_RESET_ERROR: (ptr"
                   " != NULL) && (ptr == ptr_)";
  }
  v4 = *a1;
  *a1 = a2;
  return marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr(&v4);
}

_QWORD *marisa::Agent::clear(marisa::Agent *this)
{
  uint64_t v2;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  v2 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  return marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr(&v2);
}

uint64_t *marisa::Agent::swap(uint64_t *this, marisa::Agent *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *this;
  v3 = this[1];
  v4 = *((_QWORD *)a2 + 1);
  *this = *(_QWORD *)a2;
  this[1] = v4;
  *(_QWORD *)a2 = v2;
  *((_QWORD *)a2 + 1) = v3;
  v5 = this[2];
  v6 = this[3];
  v7 = *((_QWORD *)a2 + 3);
  this[2] = *((_QWORD *)a2 + 2);
  this[3] = v7;
  *((_QWORD *)a2 + 2) = v5;
  *((_QWORD *)a2 + 3) = v6;
  LODWORD(v5) = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  *((_DWORD *)a2 + 8) = v5;
  LODWORD(v5) = *((_DWORD *)this + 9);
  *((_DWORD *)this + 9) = *((_DWORD *)a2 + 9);
  *((_DWORD *)a2 + 9) = v5;
  v8 = this[5];
  this[5] = *((_QWORD *)a2 + 5);
  *((_QWORD *)a2 + 5) = v8;
  return this;
}

void marisa::Exception::~Exception(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x1D17BC79CLL);
}

uint64_t marisa::Exception::what(marisa::Exception *this)
{
  return *((_QWORD *)this + 3);
}

_QWORD *marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = (_QWORD *)*a1;
  if (*a1)
  {
    v3 = v2[6];
    if (v3)
      MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
    if (*v2)
      MEMORY[0x1D17BC778](*v2, 0x1000C8077774924);
    MEMORY[0x1D17BC79C](v2, 0x1070C406A3FAA47);
  }
  return a1;
}

uint64_t marisa::grimoire::io::Mapper::Mapper(uint64_t this)
{
  *(_QWORD *)this = 0;
  *(_QWORD *)(this + 8) = -1;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 32) = -1;
  return this;
}

void marisa::grimoire::io::Mapper::~Mapper(marisa::grimoire::io::Mapper *this)
{
  void *v2;
  int v3;

  v2 = (void *)*((_QWORD *)this + 1);
  if (v2 != (void *)-1)
    munmap(v2, *((_QWORD *)this + 3));
  v3 = *((_DWORD *)this + 8);
  if (v3 != -1)
    close(v3);
}

void marisa::grimoire::io::Mapper::open(marisa::grimoire::io::Mapper *this, const char *a2)
{
  __int128 v3;
  __int128 v4;
  __int128 v5;
  int v6;
  _QWORD *exception;
  __int128 v8;
  __int128 v9;
  int v10;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x200000037;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:55: MARISA_NULL_ERROR: "
                   "filename == NULL";
  }
  *(_QWORD *)&v8 = 0;
  *((_QWORD *)&v8 + 1) = -1;
  v9 = 0uLL;
  v10 = -1;
  marisa::grimoire::io::Mapper::open_((marisa::grimoire::io::Mapper *)&v8, a2);
  v3 = v9;
  v4 = *(_OWORD *)this;
  v5 = *((_OWORD *)this + 1);
  *(_OWORD *)this = v8;
  *((_OWORD *)this + 1) = v3;
  v8 = v4;
  v9 = v5;
  v6 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = v10;
  v10 = v6;
  marisa::grimoire::io::Mapper::~Mapper((marisa::grimoire::io::Mapper *)&v8);
}

void sub_1CDF90888(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  marisa::grimoire::io::Mapper::~Mapper((marisa::grimoire::io::Mapper *)&a9);
  _Unwind_Resume(a1);
}

void *marisa::grimoire::io::Mapper::open_(marisa::grimoire::io::Mapper *this, const char *a2)
{
  int v4;
  void *result;
  _QWORD *exception;
  const char *v7;
  stat v8;

  if (stat(a2, &v8))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x90000008DLL;
    v7 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:141: MARISA_IO_ERROR: ::stat(filename, &st) != 0";
    goto LABEL_8;
  }
  *((_QWORD *)this + 3) = v8.st_size;
  v4 = open(a2, 0);
  *((_DWORD *)this + 8) = v4;
  if (v4 == -1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x900000092;
    v7 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:146: MARISA_IO_ERROR: fd_ == -1";
    goto LABEL_8;
  }
  result = mmap(0, *((_QWORD *)this + 3), 1, 1, v4, 0);
  *((_QWORD *)this + 1) = result;
  if (result == (void *)-1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x900000095;
    v7 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:149: MARISA_IO_ERROR: origin_ == MAP_FAILED";
LABEL_8:
    exception[3] = v7;
  }
  *(_QWORD *)this = result;
  *((_QWORD *)this + 2) = *((_QWORD *)this + 3);
  return result;
}

uint64_t *marisa::grimoire::io::Mapper::swap(uint64_t *this, marisa::grimoire::io::Mapper *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *this;
  *this = *(_QWORD *)a2;
  *(_QWORD *)a2 = v2;
  v4 = this[1];
  v3 = this[2];
  v5 = *((_QWORD *)a2 + 2);
  this[1] = *((_QWORD *)a2 + 1);
  this[2] = v5;
  *((_QWORD *)a2 + 1) = v4;
  *((_QWORD *)a2 + 2) = v3;
  v6 = this[3];
  this[3] = *((_QWORD *)a2 + 3);
  *((_QWORD *)a2 + 3) = v6;
  LODWORD(v6) = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  *((_DWORD *)a2 + 8) = v6;
  return this;
}

__n128 marisa::grimoire::io::Mapper::open(marisa::grimoire::io::Mapper *this, const void *a2, uint64_t a3)
{
  __int128 v3;
  __int128 v4;
  int v5;
  __n128 result;
  _QWORD *exception;
  _OWORD v8[2];
  int v9;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x20000003FLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:63: MARISA_NULL_ERROR: "
                   "(ptr == NULL) && (size != 0)";
  }
  v3 = *(_OWORD *)this;
  v4 = *((_OWORD *)this + 1);
  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = -1;
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  v8[0] = v3;
  v8[1] = v4;
  v5 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = -1;
  v9 = v5;
  marisa::grimoire::io::Mapper::~Mapper((marisa::grimoire::io::Mapper *)v8);
  return result;
}

_QWORD *marisa::grimoire::io::Mapper::open_(_QWORD *this, const void *a2, uint64_t a3)
{
  *this = a2;
  this[2] = a3;
  return this;
}

uint64_t marisa::grimoire::io::Mapper::seek(marisa::grimoire::io::Mapper *this, unint64_t a2)
{
  _QWORD *exception;
  const char *v4;

  if (!*(_QWORD *)this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x100000047;
    v4 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:71: MARISA_STATE_ERROR: !is_open()";
    goto LABEL_6;
  }
  if (*((_QWORD *)this + 2) < a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x900000048;
    v4 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:72: MARISA_IO_ERROR: size > avail_";
LABEL_6:
    exception[3] = v4;
  }
  return marisa::grimoire::io::Mapper::map_data(this, a2);
}

BOOL marisa::grimoire::io::Mapper::is_open(marisa::grimoire::io::Mapper *this)
{
  return *(_QWORD *)this != 0;
}

uint64_t marisa::grimoire::io::Mapper::map_data(marisa::grimoire::io::Mapper *this, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  unint64_t v5;
  _QWORD *exception;
  const char *v8;

  v2 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x100000063;
    v8 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:99: MARISA_STATE_ERROR: !is_open()";
LABEL_6:
    exception[3] = v8;
  }
  v3 = *((_QWORD *)this + 2);
  v4 = v3 >= a2;
  v5 = v3 - a2;
  if (!v4)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x900000064;
    v8 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:100: MARISA_IO_ERROR: size > avail_";
    goto LABEL_6;
  }
  *(_QWORD *)this = v2 + a2;
  *((_QWORD *)this + 2) = v5;
  return v2;
}

__n128 marisa::grimoire::io::Mapper::clear(marisa::grimoire::io::Mapper *this)
{
  __int128 v1;
  __int128 v2;
  __n128 result;
  _OWORD v4[2];
  int v5;

  v1 = *(_OWORD *)this;
  v2 = *((_OWORD *)this + 1);
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = -1;
  v4[0] = v1;
  v4[1] = v2;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  v5 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = -1;
  marisa::grimoire::io::Mapper::~Mapper((marisa::grimoire::io::Mapper *)v4);
  return result;
}

uint64_t marisa::grimoire::io::Reader::Reader(uint64_t this)
{
  *(_QWORD *)this = 0;
  *(_DWORD *)(this + 8) = -1;
  *(_QWORD *)(this + 16) = 0;
  *(_BYTE *)(this + 24) = 0;
  return this;
}

void marisa::grimoire::io::Reader::~Reader(FILE **this)
{
  if (*((_BYTE *)this + 24))
    fclose(*this);
}

FILE *marisa::grimoire::io::Reader::open(FILE **this, const char *a2)
{
  FILE *result;
  int v4;
  _QWORD *exception;
  FILE *v6;
  int v7;
  FILE *v8;
  char v9;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
    exception[2] = 0x20000001BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:27: MARISA_NULL_ERROR: "
                   "filename == NULL";
  }
  v6 = 0;
  v7 = -1;
  v8 = 0;
  v9 = 0;
  marisa::grimoire::io::Reader::open_((marisa::grimoire::io::Reader *)&v6, a2);
  result = *this;
  *this = v6;
  *((_DWORD *)this + 2) = v7;
  this[2] = v8;
  v4 = *((unsigned __int8 *)this + 24);
  *((_BYTE *)this + 24) = v9;
  if (v4)
    return (FILE *)fclose(result);
  return result;
}

void sub_1CDF90D70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, FILE *a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a12)
    fclose(a9);
  _Unwind_Resume(exception_object);
}

FILE *marisa::grimoire::io::Reader::open_(marisa::grimoire::io::Reader *this, const char *__filename)
{
  FILE *result;
  _QWORD *exception;

  result = fopen(__filename, "rb");
  if (!result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
    exception[2] = 0x90000005ELL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:94: MARISA_IO_ERROR: file == NULL";
  }
  *(_QWORD *)this = result;
  *((_BYTE *)this + 24) = 1;
  return result;
}

uint64_t *marisa::grimoire::io::Reader::swap(uint64_t *this, marisa::grimoire::io::Reader *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *this;
  *this = *(_QWORD *)a2;
  *(_QWORD *)a2 = v2;
  LODWORD(v2) = *((_DWORD *)this + 2);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)a2 + 2) = v2;
  v3 = this[2];
  this[2] = *((_QWORD *)a2 + 2);
  *((_QWORD *)a2 + 2) = v3;
  LOBYTE(v3) = *((_BYTE *)this + 24);
  *((_BYTE *)this + 24) = *((_BYTE *)a2 + 24);
  *((_BYTE *)a2 + 24) = v3;
  return this;
}

FILE *marisa::grimoire::io::Reader::open(FILE **this, __sFILE *a2)
{
  FILE *result;
  int v4;
  _QWORD *exception;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
    exception[2] = 0x200000023;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:35: MARISA_NULL_ERROR: file == NULL";
  }
  result = *this;
  *this = a2;
  *((_DWORD *)this + 2) = -1;
  this[2] = 0;
  v4 = *((unsigned __int8 *)this + 24);
  *((_BYTE *)this + 24) = 0;
  if (v4)
    return (FILE *)fclose(result);
  return result;
}

_QWORD *marisa::grimoire::io::Reader::open_(_QWORD *this, __sFILE *a2)
{
  *this = a2;
  return this;
}

FILE *marisa::grimoire::io::Reader::open(FILE **this, int a2)
{
  FILE *result;
  int v4;
  _QWORD *exception;

  if (a2 == -1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
    exception[2] = 0x50000002BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:43: MARISA_CODE_ERROR: fd == -1";
  }
  result = *this;
  *this = 0;
  *((_DWORD *)this + 2) = a2;
  this[2] = 0;
  v4 = *((unsigned __int8 *)this + 24);
  *((_BYTE *)this + 24) = 0;
  if (v4)
    return (FILE *)fclose(result);
  return result;
}

uint64_t marisa::grimoire::io::Reader::open_(uint64_t this, int a2)
{
  *(_DWORD *)(this + 8) = a2;
  return this;
}

FILE *marisa::grimoire::io::Reader::open(uint64_t a1, uint64_t a2)
{
  FILE *result;
  int v4;

  result = *(FILE **)a1;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = -1;
  *(_QWORD *)(a1 + 16) = a2;
  v4 = *(unsigned __int8 *)(a1 + 24);
  *(_BYTE *)(a1 + 24) = 0;
  if (v4)
    return (FILE *)fclose(result);
  return result;
}

uint64_t marisa::grimoire::io::Reader::open_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 16) = a2;
  return result;
}

FILE *marisa::grimoire::io::Reader::clear(FILE **this)
{
  FILE *result;
  int v3;

  result = *this;
  *this = 0;
  *((_DWORD *)this + 2) = -1;
  this[2] = 0;
  v3 = *((unsigned __int8 *)this + 24);
  *((_BYTE *)this + 24) = 0;
  if (v3)
    return (FILE *)fclose(result);
  return result;
}

uint64_t marisa::grimoire::io::Reader::seek(uint64_t this, size_t __nitems)
{
  size_t v2;
  uint64_t v3;
  size_t v4;
  _QWORD *exception;
  char v6[1024];
  uint64_t v7;

  v2 = __nitems;
  v3 = this;
  v7 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)this && *(_DWORD *)(this + 8) == -1 && !*(_QWORD *)(this + 16))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
    exception[2] = 0x100000044;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:68: MARISA_STATE_ERROR: !is_open()";
  }
  if (__nitems)
  {
    if (__nitems > 0x10)
    {
      do
      {
        if (v2 >= 0x400)
          v4 = 1024;
        else
          v4 = v2;
        this = marisa::grimoire::io::Reader::read_data(v3, v6, v4);
        v2 -= v4;
      }
      while (v2);
    }
    else
    {
      return marisa::grimoire::io::Reader::read_data(this, v6, __nitems);
    }
  }
  return this;
}

BOOL marisa::grimoire::io::Reader::is_open(marisa::grimoire::io::Reader *this)
{
  return *(_QWORD *)this || *((_DWORD *)this + 2) != -1 || *((_QWORD *)this + 2) != 0;
}

uint64_t marisa::grimoire::io::Reader::read_data(uint64_t this, char *a2, size_t __nitems)
{
  size_t v3;
  char *v4;
  uint64_t v5;
  FILE *v6;
  size_t v7;
  _QWORD *exception;
  const char *v9;
  _QWORD *v10;

  v3 = __nitems;
  v4 = a2;
  v5 = this;
  v6 = *(FILE **)this;
  if (!*(_QWORD *)this && *(_DWORD *)(this + 8) == -1 && !*(_QWORD *)(this + 16))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
    exception[2] = 0x100000071;
    v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:113: MARISA_STATE_ERROR: !is_open()";
    goto LABEL_19;
  }
  if (__nitems)
  {
    if (*(_DWORD *)(this + 8) != -1)
    {
      while (1)
      {
        v7 = v3 >= 0x7FFFFFFFFFFFFFFFLL ? 0x7FFFFFFFFFFFFFFFLL : v3;
        this = read(*(_DWORD *)(v5 + 8), v4, v7);
        if (this <= 0)
          break;
        v4 += this;
        v3 -= this;
        if (!v3)
          return this;
      }
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &off_1E8B57FF8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
      exception[2] = 0x900000081;
      v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:129: MARISA_IO_ERROR: size_read <= 0";
LABEL_19:
      exception[3] = v9;
    }
    if (v6)
    {
      this = fread(a2, 1uLL, __nitems, v6);
      if (this != v3)
      {
        exception = __cxa_allocate_exception(0x20uLL);
        *exception = &off_1E8B57FF8;
        exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
        exception[2] = 0x900000086;
        v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:134: MARISA_IO_ERROR: ::fread"
             "(buf, 1, size, file_) != size";
        goto LABEL_19;
      }
    }
    else
    {
      this = *(_QWORD *)(this + 16);
      if (this)
      {
        this = std::istream::read();
        if ((*(_BYTE *)(this + *(_QWORD *)(*(_QWORD *)this - 24) + 32) & 5) != 0)
        {
          v10 = __cxa_allocate_exception(0x20uLL);
          *v10 = &off_1E8B57FF8;
          v10[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
          v10[2] = 0x90000008ALL;
          v10[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:138: MARISA_IO_ERROR: !"
                   "stream_->read(static_cast<char *>(buf), size)";
        }
      }
    }
  }
  return this;
}

void sub_1CDF912E0()
{
  __break(1u);
}

void sub_1CDF91344()
{
  __cxa_end_catch();
  JUMPOUT(0x1CDF9134CLL);
}

FILE *marisa::grimoire::io::Writer::open(FILE **this, const char *a2)
{
  FILE *result;
  int v4;
  _QWORD *exception;
  FILE *v6;
  int v7;
  FILE *v8;
  char v9;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x20000001BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:27: MARISA_NULL_ERROR: "
                   "filename == NULL";
  }
  v6 = 0;
  v7 = -1;
  v8 = 0;
  v9 = 0;
  marisa::grimoire::io::Writer::open_((marisa::grimoire::io::Writer *)&v6, a2);
  result = *this;
  *this = v6;
  *((_DWORD *)this + 2) = v7;
  this[2] = v8;
  v4 = *((unsigned __int8 *)this + 24);
  *((_BYTE *)this + 24) = v9;
  if (v4)
    return (FILE *)fclose(result);
  return result;
}

void sub_1CDF91420(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, FILE *a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a12)
    fclose(a9);
  _Unwind_Resume(exception_object);
}

FILE *marisa::grimoire::io::Writer::open_(marisa::grimoire::io::Writer *this, const char *__filename)
{
  FILE *result;
  _QWORD *exception;

  result = fopen(__filename, "wb");
  if (!result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x90000005ELL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:94: MARISA_IO_ERROR: file == NULL";
  }
  *(_QWORD *)this = result;
  *((_BYTE *)this + 24) = 1;
  return result;
}

FILE *marisa::grimoire::io::Writer::open(FILE **this, __sFILE *a2)
{
  FILE *result;
  int v4;
  _QWORD *exception;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x200000023;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:35: MARISA_NULL_ERROR: file == NULL";
  }
  result = *this;
  *this = a2;
  *((_DWORD *)this + 2) = -1;
  this[2] = 0;
  v4 = *((unsigned __int8 *)this + 24);
  *((_BYTE *)this + 24) = 0;
  if (v4)
    return (FILE *)fclose(result);
  return result;
}

FILE *marisa::grimoire::io::Writer::open(FILE **this, int a2)
{
  FILE *result;
  int v4;
  _QWORD *exception;

  if (a2 == -1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x50000002BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:43: MARISA_CODE_ERROR: fd == -1";
  }
  result = *this;
  *this = 0;
  *((_DWORD *)this + 2) = a2;
  this[2] = 0;
  v4 = *((unsigned __int8 *)this + 24);
  *((_BYTE *)this + 24) = 0;
  if (v4)
    return (FILE *)fclose(result);
  return result;
}

uint64_t marisa::grimoire::io::Writer::seek(uint64_t this, size_t __nitems)
{
  size_t v2;
  uint64_t v3;
  size_t v4;
  _QWORD *exception;
  _QWORD __buf[129];

  v2 = __nitems;
  v3 = this;
  __buf[128] = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)this && *(_DWORD *)(this + 8) == -1 && !*(_QWORD *)(this + 16))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x100000044;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:68: MARISA_STATE_ERROR: !is_open()";
  }
  if (__nitems)
  {
    if (__nitems > 0x10)
    {
      bzero(__buf, 0x400uLL);
      do
      {
        if (v2 >= 0x400)
          v4 = 1024;
        else
          v4 = v2;
        this = marisa::grimoire::io::Writer::write_data(v3, (char *)__buf, v4);
        v2 -= v4;
      }
      while (v2);
    }
    else
    {
      __buf[0] = 0;
      __buf[1] = 0;
      return marisa::grimoire::io::Writer::write_data(this, (char *)__buf, __nitems);
    }
  }
  return this;
}

uint64_t marisa::grimoire::io::Writer::write_data(uint64_t this, char *__buf, size_t __nitems)
{
  size_t v3;
  char *v4;
  uint64_t v5;
  FILE *v6;
  size_t v7;
  _QWORD *exception;
  const char *v9;
  _QWORD *v10;

  v3 = __nitems;
  v4 = __buf;
  v5 = this;
  v6 = *(FILE **)this;
  if (!*(_QWORD *)this && *(_DWORD *)(this + 8) == -1 && !*(_QWORD *)(this + 16))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x100000071;
    v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:113: MARISA_STATE_ERROR: !is_open()";
    goto LABEL_20;
  }
  if (__nitems)
  {
    if (*(_DWORD *)(this + 8) != -1)
    {
      while (1)
      {
        v7 = v3 >= 0x7FFFFFFFFFFFFFFFLL ? 0x7FFFFFFFFFFFFFFFLL : v3;
        this = write(*(_DWORD *)(v5 + 8), v4, v7);
        if (this <= 0)
          break;
        v4 += this;
        v3 -= this;
        if (!v3)
          return this;
      }
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &off_1E8B57FF8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
      exception[2] = 0x900000081;
      v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:129: MARISA_IO_ERROR: size_written <= 0";
LABEL_20:
      exception[3] = v9;
    }
    if (v6)
    {
      if (fwrite(__buf, 1uLL, __nitems, v6) != __nitems)
      {
        exception = __cxa_allocate_exception(0x20uLL);
        *exception = &off_1E8B57FF8;
        exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
        exception[2] = 0x900000086;
        v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:134: MARISA_IO_ERROR: ::fwrit"
             "e(data, 1, size, file_) != size";
        goto LABEL_20;
      }
      this = fflush(*(FILE **)v5);
      if ((_DWORD)this)
      {
        exception = __cxa_allocate_exception(0x20uLL);
        *exception = &off_1E8B57FF8;
        exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
        exception[2] = 0x900000087;
        v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:135: MARISA_IO_ERROR: ::fflush(file_) != 0";
        goto LABEL_20;
      }
    }
    else
    {
      this = *(_QWORD *)(this + 16);
      if (this)
      {
        this = std::ostream::write();
        if ((*(_BYTE *)(this + *(_QWORD *)(*(_QWORD *)this - 24) + 32) & 5) != 0)
        {
          v10 = __cxa_allocate_exception(0x20uLL);
          *v10 = &off_1E8B57FF8;
          v10[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
          v10[2] = 0x90000008BLL;
          v10[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:139: MARISA_IO_ERROR: !"
                   "stream_->write(static_cast<const char *>(data), size)";
        }
      }
    }
  }
  return this;
}

void sub_1CDF91900()
{
  __break(1u);
}

void sub_1CDF91964()
{
  __cxa_end_catch();
  JUMPOUT(0x1CDF9196CLL);
}

marisa::grimoire::trie::LoudsTrie *marisa::grimoire::trie::LoudsTrie::LoudsTrie(marisa::grimoire::trie::LoudsTrie *this)
{
  *(_OWORD *)((char *)this + 25) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 137) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *(_OWORD *)((char *)this + 185) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 89) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *(_OWORD *)((char *)this + 233) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *(_OWORD *)((char *)this + 345) = 0u;
  *(_OWORD *)((char *)this + 393) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 297) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *(_OWORD *)((char *)this + 441) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *(_OWORD *)((char *)this + 553) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_OWORD *)this + 34) = 0u;
  *(_OWORD *)((char *)this + 601) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = 0u;
  *(_OWORD *)((char *)this + 505) = 0u;
  *((_OWORD *)this + 30) = 0u;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *(_OWORD *)((char *)this + 649) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *((_OWORD *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 697) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((_QWORD *)this + 90) = 0;
  *((_DWORD *)this + 182) = 0;
  *((_QWORD *)this + 92) = 0;
  marisa::grimoire::trie::Tail::Tail((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744));
  *((_BYTE *)this + 1048) = 0;
  *(_OWORD *)((char *)this + 1016) = 0u;
  *(_OWORD *)((char *)this + 1032) = 0u;
  *(_OWORD *)((char *)this + 1000) = 0u;
  *((_OWORD *)this + 66) = 0u;
  *((_QWORD *)this + 134) = 3;
  *((_QWORD *)this + 135) = 0x100000000200;
  *((_DWORD *)this + 272) = 0x20000;
  marisa::grimoire::io::Mapper::Mapper((uint64_t)this + 1096);
  return this;
}

void sub_1CDF91A98(_Unwind_Exception *a1)
{
  marisa::grimoire::vector::BitVector *v1;
  marisa::grimoire::vector::BitVector *v2;
  marisa::grimoire::vector::BitVector *v3;
  marisa::grimoire::trie::Tail *v4;
  marisa::grimoire::trie::LoudsTrie **v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v9;

  v9 = *((_QWORD *)v1 + 126);
  if (v9)
    MEMORY[0x1D17BC778](v9, 0x1000C8077774924);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(v5);
  marisa::grimoire::trie::Tail::~Tail(v4);
  if (*v7)
    MEMORY[0x1D17BC778](*v7, 0x1000C8077774924);
  if (*v6)
    MEMORY[0x1D17BC778](*v6, 0x1000C8077774924);
  marisa::grimoire::vector::BitVector::~BitVector(v3);
  marisa::grimoire::vector::BitVector::~BitVector(v2);
  marisa::grimoire::vector::BitVector::~BitVector(v1);
  _Unwind_Resume(a1);
}

void marisa::grimoire::trie::Tail::~Tail(marisa::grimoire::trie::Tail *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 26);
  if (v2)
    MEMORY[0x1D17BC778](v2, 0x1000C8077774924);
  v3 = *((_QWORD *)this + 20);
  if (v3)
    MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  v4 = *((_QWORD *)this + 14);
  if (v4)
    MEMORY[0x1D17BC778](v4, 0x1000C8077774924);
  v5 = *((_QWORD *)this + 6);
  if (v5)
    MEMORY[0x1D17BC778](v5, 0x1000C8077774924);
  if (*(_QWORD *)this)
    MEMORY[0x1D17BC778](*(_QWORD *)this, 0x1000C8077774924);
}

void marisa::grimoire::vector::BitVector::~BitVector(marisa::grimoire::vector::BitVector *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 20);
  if (v2)
    MEMORY[0x1D17BC778](v2, 0x1000C8077774924);
  v3 = *((_QWORD *)this + 14);
  if (v3)
    MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  v4 = *((_QWORD *)this + 8);
  if (v4)
    MEMORY[0x1D17BC778](v4, 0x1000C8077774924);
  if (*(_QWORD *)this)
    MEMORY[0x1D17BC778](*(_QWORD *)this, 0x1000C8077774924);
}

void marisa::grimoire::trie::LoudsTrie::~LoudsTrie(marisa::grimoire::trie::LoudsTrie *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  marisa::grimoire::io::Mapper::~Mapper((marisa::grimoire::trie::LoudsTrie *)((char *)this + 1096));
  v2 = *((_QWORD *)this + 126);
  if (v2)
    MEMORY[0x1D17BC778](v2, 0x1000C8077774924);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)this + 125);
  v3 = *((_QWORD *)this + 119);
  if (v3)
    MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  v4 = *((_QWORD *)this + 113);
  if (v4)
    MEMORY[0x1D17BC778](v4, 0x1000C8077774924);
  v5 = *((_QWORD *)this + 107);
  if (v5)
    MEMORY[0x1D17BC778](v5, 0x1000C8077774924);
  v6 = *((_QWORD *)this + 99);
  if (v6)
    MEMORY[0x1D17BC778](v6, 0x1000C8077774924);
  v7 = *((_QWORD *)this + 93);
  if (v7)
    MEMORY[0x1D17BC778](v7, 0x1000C8077774924);
  v8 = *((_QWORD *)this + 84);
  if (v8)
    MEMORY[0x1D17BC778](v8, 0x1000C8077774924);
  v9 = *((_QWORD *)this + 78);
  if (v9)
    MEMORY[0x1D17BC778](v9, 0x1000C8077774924);
  v10 = *((_QWORD *)this + 72);
  if (v10)
    MEMORY[0x1D17BC778](v10, 0x1000C8077774924);
  v11 = *((_QWORD *)this + 66);
  if (v11)
    MEMORY[0x1D17BC778](v11, 0x1000C8077774924);
  v12 = *((_QWORD *)this + 60);
  if (v12)
    MEMORY[0x1D17BC778](v12, 0x1000C8077774924);
  v13 = *((_QWORD *)this + 52);
  if (v13)
    MEMORY[0x1D17BC778](v13, 0x1000C8077774924);
  v14 = *((_QWORD *)this + 46);
  if (v14)
    MEMORY[0x1D17BC778](v14, 0x1000C8077774924);
  v15 = *((_QWORD *)this + 40);
  if (v15)
    MEMORY[0x1D17BC778](v15, 0x1000C8077774924);
  v16 = *((_QWORD *)this + 34);
  if (v16)
    MEMORY[0x1D17BC778](v16, 0x1000C8077774924);
  v17 = *((_QWORD *)this + 26);
  if (v17)
    MEMORY[0x1D17BC778](v17, 0x1000C8077774924);
  v18 = *((_QWORD *)this + 20);
  if (v18)
    MEMORY[0x1D17BC778](v18, 0x1000C8077774924);
  v19 = *((_QWORD *)this + 14);
  if (v19)
    MEMORY[0x1D17BC778](v19, 0x1000C8077774924);
  v20 = *((_QWORD *)this + 8);
  if (v20)
    MEMORY[0x1D17BC778](v20, 0x1000C8077774924);
  if (*(_QWORD *)this)
    MEMORY[0x1D17BC778](*(_QWORD *)this, 0x1000C8077774924);
}

void marisa::grimoire::trie::LoudsTrie::build(marisa::grimoire::trie::LoudsTrie *this, marisa::Keyset *a2, unsigned int a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  _QWORD v8[2];
  int v9;

  v5 = 3;
  v6 = 0x100000000200;
  v7 = 0x20000;
  marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v5, a3);
  v8[0] = v5;
  v8[1] = v6;
  v9 = v7;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie((marisa::grimoire::trie::LoudsTrie *)&v5);
  marisa::grimoire::trie::LoudsTrie::build_((marisa::grimoire::trie::LoudsTrie *)&v5, a2, (const marisa::grimoire::trie::Config *)v8);
  marisa::grimoire::trie::LoudsTrie::swap(this, (marisa::grimoire::trie::LoudsTrie *)&v5);
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie((marisa::grimoire::trie::LoudsTrie *)&v5);
}

void sub_1CDF91F68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie((marisa::grimoire::trie::LoudsTrie *)va);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_(marisa::grimoire::trie::LoudsTrie *this, marisa::Keyset *a2, const marisa::grimoire::trie::Config *a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t i;
  unint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t result;
  _OWORD v28[3];
  __int128 v29;
  unint64_t v30[4];
  _OWORD v31[3];
  char v32;

  memset(v31, 0, 41);
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::resize((uint64_t *)v31, *((_QWORD *)a2 + 11));
  if (*((_QWORD *)a2 + 11))
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = *((_QWORD *)&v31[0] + 1) + v6;
      v9 = *(_QWORD *)(*((_QWORD *)a2 + 6) + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v7;
      v10 = *(_DWORD *)(v9 + 8);
      *(_QWORD *)v8 = *(_QWORD *)v9;
      *(_DWORD *)(v8 + 8) = v10;
      *(_DWORD *)(v8 + 12) = *(_DWORD *)(v9 + 12);
      ++v7;
      v6 += 24;
    }
    while (v7 < *((_QWORD *)a2 + 11));
  }
  v29 = 0u;
  memset(v30, 0, 25);
  marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::Key>((uint64_t)this, (uint64_t *)v31, &v29, (uint64_t)a3, 1);
  memset(v28, 0, 41);
  marisa::grimoire::vector::Vector<std::pair<unsigned int,unsigned int>>::resize((uint64_t *)v28, v30[1]);
  v11 = *((_QWORD *)&v28[1] + 1);
  if (*((_QWORD *)&v28[1] + 1))
  {
    v12 = 0;
    v13 = *((_QWORD *)&v29 + 1);
    v14 = (_DWORD *)(*((_QWORD *)&v28[0] + 1) + 4);
    do
    {
      *(v14 - 1) = *(_DWORD *)(v13 + 4 * v12);
      *v14 = v12++;
      v14 += 2;
    }
    while (v11 != v12);
  }
  v15 = v29;
  v29 = 0u;
  memset(v30, 0, 25);
  if (v15)
  {
    MEMORY[0x1D17BC778](v15, 0x1000C8077774924);
    v11 = *((_QWORD *)&v28[1] + 1);
  }
  v16 = 126 - 2 * __clz(v11);
  if (v11)
    v17 = v16;
  else
    v17 = 0;
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,false>(*((uint64_t *)&v28[0] + 1), (unsigned int *)(*((_QWORD *)&v28[0] + 1) + 8 * v11), (uint64_t)&v32, v17, 1);
  if (*((_QWORD *)&v28[1] + 1))
  {
    v18 = 0;
    v19 = 0;
    do
    {
      for (i = *((_QWORD *)&v28[0] + 1); ; i = *((_QWORD *)&v28[0] + 1))
      {
        v21 = *(unsigned int *)(i + 8 * v18);
        if (v19 >= v21)
          break;
        marisa::grimoire::vector::BitVector::push_back((uint64_t *)this + 26, 0);
        ++v19;
      }
      if (v19 == v21)
      {
        marisa::grimoire::vector::BitVector::push_back((uint64_t *)this + 26, 1);
        ++v19;
      }
      ++v18;
    }
    while (v18 < *((_QWORD *)&v28[1] + 1));
  }
  else
  {
    v19 = 0;
  }
  for (; v19 < *((_QWORD *)this + 81); ++v19)
    marisa::grimoire::vector::BitVector::push_back((uint64_t *)this + 26, 0);
  v22 = (uint64_t *)((char *)this + 208);
  marisa::grimoire::vector::BitVector::push_back(v22, 0);
  marisa::grimoire::vector::BitVector::build((marisa::grimoire::vector::BitVector *)v22, 0, 1);
  if (*((_QWORD *)a2 + 11))
  {
    v23 = 0;
    v24 = 0;
    do
    {
      v25 = *(unsigned int *)(*((_QWORD *)&v28[0] + 1) + v23 + 4);
      v26 = *(_QWORD *)(*((_QWORD *)a2 + 6) + ((v25 >> 5) & 0x7FFFFF8));
      *(_DWORD *)(v26 + 16 * v25 + 12) = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::vector::BitVector *)v22, *(unsigned int *)(*((_QWORD *)&v28[0] + 1) + v23));
      ++v24;
      v23 += 8;
    }
    while (v24 < *((_QWORD *)a2 + 11));
  }
  if (*(_QWORD *)&v28[0])
    MEMORY[0x1D17BC778](*(_QWORD *)&v28[0], 0x1000C8077774924);
  if ((_QWORD)v29)
    MEMORY[0x1D17BC778](v29, 0x1000C8077774924);
  result = *(_QWORD *)&v31[0];
  if (*(_QWORD *)&v31[0])
    return MEMORY[0x1D17BC778](*(_QWORD *)&v31[0], 0x1000C8077774924);
  return result;
}

void sub_1CDF92248(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a15)
    MEMORY[0x1D17BC778](a15, 0x1000C8077774924);
  if (a21)
    MEMORY[0x1D17BC778](a21, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t *marisa::grimoire::trie::LoudsTrie::swap(marisa::grimoire::trie::LoudsTrie *this, marisa::grimoire::trie::LoudsTrie *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  marisa::grimoire::vector::BitVector::swap(this, a2);
  marisa::grimoire::vector::BitVector::swap((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), (marisa::grimoire::trie::LoudsTrie *)((char *)a2 + 208));
  marisa::grimoire::vector::BitVector::swap((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), (marisa::grimoire::trie::LoudsTrie *)((char *)a2 + 416));
  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this + 78, (uint64_t *)a2 + 78);
  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this + 84, (uint64_t *)a2 + 84);
  v4 = *((_QWORD *)this + 90);
  *((_QWORD *)this + 90) = *((_QWORD *)a2 + 90);
  *((_QWORD *)a2 + 90) = v4;
  LODWORD(v4) = *((_DWORD *)this + 182);
  *((_DWORD *)this + 182) = *((_DWORD *)a2 + 182);
  *((_DWORD *)a2 + 182) = v4;
  v5 = *((_QWORD *)this + 92);
  *((_QWORD *)this + 92) = *((_QWORD *)a2 + 92);
  *((_QWORD *)a2 + 92) = v5;
  marisa::grimoire::trie::Tail::swap((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), (marisa::grimoire::trie::LoudsTrie *)((char *)a2 + 744));
  v6 = *((_QWORD *)this + 125);
  *((_QWORD *)this + 125) = *((_QWORD *)a2 + 125);
  *((_QWORD *)a2 + 125) = v6;
  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this + 126, (uint64_t *)a2 + 126);
  v7 = *((_QWORD *)this + 132);
  *((_QWORD *)this + 132) = *((_QWORD *)a2 + 132);
  *((_QWORD *)a2 + 132) = v7;
  v8 = *((_QWORD *)this + 133);
  *((_QWORD *)this + 133) = *((_QWORD *)a2 + 133);
  *((_QWORD *)a2 + 133) = v8;
  v9 = *((_QWORD *)this + 134);
  *((_QWORD *)this + 134) = *((_QWORD *)a2 + 134);
  *((_QWORD *)a2 + 134) = v9;
  v10 = *((_QWORD *)this + 135);
  *((_QWORD *)this + 135) = *((_QWORD *)a2 + 135);
  *((_QWORD *)a2 + 135) = v10;
  LODWORD(v9) = *((_DWORD *)this + 272);
  *((_DWORD *)this + 272) = *((_DWORD *)a2 + 272);
  *((_DWORD *)a2 + 272) = v9;
  return marisa::grimoire::io::Mapper::swap((uint64_t *)this + 137, (marisa::grimoire::trie::LoudsTrie *)((char *)a2 + 1096));
}

void marisa::grimoire::trie::LoudsTrie::map(marisa::grimoire::trie::LoudsTrie *this, marisa::grimoire::io::Mapper *a2)
{
  _BYTE v4[1096];
  uint64_t v5[5];

  marisa::grimoire::trie::Header::map((marisa::grimoire::trie::Header *)v4, a2);
  marisa::grimoire::trie::LoudsTrie::LoudsTrie((marisa::grimoire::trie::LoudsTrie *)v4);
  marisa::grimoire::trie::LoudsTrie::map_((marisa::grimoire::trie::LoudsTrie *)v4, a2);
  marisa::grimoire::io::Mapper::swap(v5, a2);
  marisa::grimoire::trie::LoudsTrie::swap(this, (marisa::grimoire::trie::LoudsTrie *)v4);
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie((marisa::grimoire::trie::LoudsTrie *)v4);
}

void sub_1CDF92440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie((marisa::grimoire::trie::LoudsTrie *)&a9);
  _Unwind_Resume(a1);
}

_BYTE *marisa::grimoire::trie::Header::map(marisa::grimoire::trie::Header *this, marisa::grimoire::io::Mapper *a2)
{
  _BYTE *result;
  uint64_t v3;
  int v4;
  int v5;
  _QWORD *exception;

  result = (_BYTE *)marisa::grimoire::io::Mapper::map_data(a2, 0x10uLL);
  if (*result != 87)
    goto LABEL_7;
  v3 = 1u;
  do
  {
    if (v3 == 16)
      return result;
    v4 = result[v3];
    v5 = marisa::grimoire::trie::Header::get_header(void)::buf[v3++];
  }
  while (v4 == v5);
  if ((unint64_t)(v3 - 2) <= 0xE)
  {
LABEL_7:
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/header.h";
    exception[2] = 0xA00000015;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/header.h:21: MARISA_FORMAT_ERRO"
                   "R: !test_header(ptr)";
  }
  return result;
}

double marisa::grimoire::trie::LoudsTrie::map_(marisa::grimoire::trie::LoudsTrie *this, marisa::grimoire::io::Mapper *a2)
{
  marisa::grimoire::trie::LoudsTrie *v4;
  marisa::grimoire::trie::LoudsTrie *v5;
  marisa::grimoire::trie::LoudsTrie *v6;
  unsigned int v7;
  double result;
  _QWORD *exception;
  uint64_t v10;
  double v11;
  int v12;

  marisa::grimoire::vector::BitVector::map(this, a2);
  marisa::grimoire::vector::BitVector::map((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), a2);
  marisa::grimoire::vector::BitVector::map((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), a2);
  marisa::grimoire::vector::Vector<unsigned char>::map((__int128 *)this + 39, a2);
  marisa::grimoire::vector::FlatVector::map((marisa::grimoire::trie::LoudsTrie *)((char *)this + 672), a2);
  marisa::grimoire::trie::Tail::map((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), a2);
  if (*((_QWORD *)this + 59) && !*((_QWORD *)this + 96))
  {
    v4 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E0DE4E10]);
    v5 = v4;
    if (v4)
      marisa::grimoire::trie::LoudsTrie::LoudsTrie(v4);
    marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::reset((marisa::grimoire::trie::LoudsTrie **)this + 125, v5);
    v6 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
    if (!v6)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &off_1E8B57FF8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
      exception[2] = 0x80000021ELL;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:542: MARISA_MEM"
                     "ORY_ERROR: next_trie_.get() == NULL";
    }
    marisa::grimoire::trie::LoudsTrie::map_(v6, a2);
  }
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::map((__int128 *)this + 63, a2);
  *((_QWORD *)this + 132) = *((_QWORD *)this + 129) - 1;
  *((_QWORD *)this + 133) = *(unsigned int *)marisa::grimoire::io::Mapper::map_data(a2, 4uLL);
  v7 = *(_DWORD *)marisa::grimoire::io::Mapper::map_data(a2, 4uLL);
  v10 = 3;
  *(_QWORD *)&v11 = 0x100000000200;
  v12 = 0x20000;
  marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v10, v7);
  *((_QWORD *)this + 134) = v10;
  result = v11;
  *((double *)this + 135) = v11;
  *((_DWORD *)this + 272) = v12;
  return result;
}

void sub_1CDF92678(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC790](v1, MEMORY[0x1E0DE4E10]);
  _Unwind_Resume(a1);
}

void marisa::grimoire::trie::LoudsTrie::read(marisa::grimoire::trie::LoudsTrie *this, marisa::grimoire::io::Reader *a2)
{
  _BYTE v4[1136];

  marisa::grimoire::trie::Header::read((marisa::grimoire::trie::Header *)v4, a2);
  marisa::grimoire::trie::LoudsTrie::LoudsTrie((marisa::grimoire::trie::LoudsTrie *)v4);
  marisa::grimoire::trie::LoudsTrie::read_((marisa::grimoire::trie::LoudsTrie *)v4, a2);
  marisa::grimoire::trie::LoudsTrie::swap(this, (marisa::grimoire::trie::LoudsTrie *)v4);
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie((marisa::grimoire::trie::LoudsTrie *)v4);
}

void sub_1CDF926F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie((marisa::grimoire::trie::LoudsTrie *)&a9);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::Header::read(marisa::grimoire::trie::Header *this, marisa::grimoire::io::Reader *a2)
{
  uint64_t result;
  uint64_t v3;
  int v4;
  int v5;
  _QWORD *exception;
  char v7[16];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  result = marisa::grimoire::io::Reader::read_data((uint64_t)a2, v7, 0x10uLL);
  if (v7[0] != 87)
    goto LABEL_7;
  v3 = 1u;
  do
  {
    if (v3 == 16)
      return result;
    v4 = v7[v3];
    v5 = marisa::grimoire::trie::Header::get_header(void)::buf[v3++];
  }
  while (v4 == v5);
  if ((unint64_t)(v3 - 2) <= 0xE)
  {
LABEL_7:
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/header.h";
    exception[2] = 0xA0000001ALL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/header.h:26: MARISA_FORMAT_ERRO"
                   "R: !test_header(buf)";
  }
  return result;
}

double marisa::grimoire::trie::LoudsTrie::read_(marisa::grimoire::trie::LoudsTrie *this, marisa::grimoire::io::Reader *a2)
{
  marisa::grimoire::trie::LoudsTrie *v4;
  marisa::grimoire::trie::LoudsTrie *v5;
  marisa::grimoire::trie::LoudsTrie *v6;
  double result;
  _QWORD *exception;
  int v9;
  uint64_t v10;
  double v11;
  int v12;

  marisa::grimoire::vector::BitVector::read(this, a2);
  marisa::grimoire::vector::BitVector::read((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), a2);
  marisa::grimoire::vector::BitVector::read((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), a2);
  marisa::grimoire::vector::Vector<unsigned char>::read((__int128 *)this + 39, a2);
  marisa::grimoire::vector::FlatVector::read((marisa::grimoire::trie::LoudsTrie *)((char *)this + 672), a2);
  marisa::grimoire::trie::Tail::read((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), a2);
  if (*((_QWORD *)this + 59) && !*((_QWORD *)this + 96))
  {
    v4 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E0DE4E10]);
    v5 = v4;
    if (v4)
      marisa::grimoire::trie::LoudsTrie::LoudsTrie(v4);
    marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::reset((marisa::grimoire::trie::LoudsTrie **)this + 125, v5);
    v6 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
    if (!v6)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &off_1E8B57FF8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
      exception[2] = 0x800000238;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:568: MARISA_MEM"
                     "ORY_ERROR: next_trie_.get() == NULL";
    }
    marisa::grimoire::trie::LoudsTrie::read_(v6, a2);
  }
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::read((__int128 *)this + 63, a2);
  *((_QWORD *)this + 132) = *((_QWORD *)this + 129) - 1;
  LODWORD(v10) = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v10, 4uLL);
  *((_QWORD *)this + 133) = v10;
  v9 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v9, 4uLL);
  v10 = 3;
  *(_QWORD *)&v11 = 0x100000000200;
  v12 = 0x20000;
  marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v10, v9);
  *((_QWORD *)this + 134) = v10;
  result = v11;
  *((double *)this + 135) = v11;
  *((_DWORD *)this + 272) = v12;
  return result;
}

void sub_1CDF92980(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC790](v1, MEMORY[0x1E0DE4E10]);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::LoudsTrie::write(marisa::grimoire::trie::LoudsTrie **this, marisa::grimoire::io::Writer *a2)
{
  marisa::grimoire::io::Writer::write_data((uint64_t)a2, "We love Marisa.", 0x10uLL);
  return marisa::grimoire::trie::LoudsTrie::write_(this, a2);
}

uint64_t marisa::grimoire::trie::LoudsTrie::write_(marisa::grimoire::trie::LoudsTrie **this, marisa::grimoire::io::Writer *a2)
{
  marisa::grimoire::trie::LoudsTrie *v4;
  int v6;
  unsigned int __buf;

  marisa::grimoire::vector::BitVector::write_((marisa::grimoire::vector::BitVector *)this, a2);
  marisa::grimoire::vector::BitVector::write_((marisa::grimoire::vector::BitVector *)(this + 26), a2);
  marisa::grimoire::vector::BitVector::write_((marisa::grimoire::vector::BitVector *)(this + 52), a2);
  marisa::grimoire::vector::Vector<unsigned char>::write_((uint64_t)(this + 78), a2);
  marisa::grimoire::vector::FlatVector::write_((marisa::grimoire::vector::FlatVector *)(this + 84), a2);
  marisa::grimoire::trie::Tail::write((marisa::grimoire::trie::Tail *)(this + 93), a2);
  v4 = this[125];
  if (v4)
    marisa::grimoire::trie::LoudsTrie::write_(v4, a2);
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::write_((uint64_t)(this + 126), a2);
  __buf = this[133];
  marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&__buf, 4uLL);
  v6 = *((_DWORD *)this + 271) | *((_DWORD *)this + 268) | *((_DWORD *)this + 272);
  return marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&v6, 4uLL);
}

uint64_t marisa::grimoire::trie::LoudsTrie::lookup(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v4 = *((_QWORD *)a2 + 5);
  *(_QWORD *)(v4 + 96) = 0;
  *(_DWORD *)(v4 + 108) = 0;
  while (1)
  {
    v5 = *((_QWORD *)a2 + 1);
    if (v5 <= *(unsigned int *)(v4 + 100))
      break;
    if ((marisa::grimoire::trie::LoudsTrie::find_child(this, a2) & 1) == 0)
      return 0;
  }
  v6 = *(unsigned int *)(v4 + 96);
  if (((*(_QWORD *)(*((_QWORD *)this + 28) + ((v6 >> 3) & 0x1FFFFFF8)) >> v6) & 1) != 0)
  {
    *((_QWORD *)a2 + 3) = *(_QWORD *)a2;
    *((_DWORD *)a2 + 8) = v5;
    *((_DWORD *)a2 + 9) = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), v6);
    return 1;
  }
  return 0;
}

uint64_t marisa::grimoire::trie::LoudsTrie::find_child(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  marisa::grimoire::trie::LoudsTrie *v25;
  uint64_t v26;
  marisa::grimoire::trie::LoudsTrie *v27;

  v4 = *((_QWORD *)a2 + 5);
  v5 = *(unsigned int *)(v4 + 96);
  v6 = *(unsigned int *)(v4 + 100);
  v7 = (*(unsigned __int8 *)(*(_QWORD *)a2 + v6) ^ (32 * v5) ^ v5) & *((_QWORD *)this + 132);
  v8 = *((_QWORD *)this + 128);
  if ((_DWORD)v5 != *(_DWORD *)(v8 + 12 * v7))
  {
    v10 = marisa::grimoire::vector::BitVector::select0(this, v5);
    v11 = *((_QWORD *)this + 2);
    if (((*(_QWORD *)(v11 + (((v10 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v10 + 1)) & 1) != 0)
    {
      v12 = v10 - *(_DWORD *)(v4 + 96);
      *(_DWORD *)(v4 + 96) = v12;
      v13 = v10 + 2;
      v14 = 0xFFFFFFFFLL;
      while (1)
      {
        v15 = v12;
        if (((*(_QWORD *)(*((_QWORD *)this + 54) + (((unint64_t)v12 >> 3) & 0x1FFFFFF8)) >> v12) & 1) != 0)
        {
          if (v14 == 0xFFFFFFFFLL)
          {
            v14 = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), v12);
            v15 = *(unsigned int *)(v4 + 96);
          }
          else
          {
            ++v14;
          }
          v17 = *(_DWORD *)(v4 + 100);
          v18 = *((_QWORD *)this + 90);
          v19 = (unint64_t)(v18 * v14) >> 6;
          v20 = (v18 * v14) & 0x3F;
          v21 = v20 + v18;
          v22 = *((_QWORD *)this + 86);
          v23 = *(_QWORD *)(v22 + 8 * v19) >> v20;
          if (v21 > 0x40)
            v23 |= (2 * *(_QWORD *)(v22 + 8 * v19 + 8)) << (v20 ^ 0x3Fu);
          v24 = *(unsigned __int8 *)(*((_QWORD *)this + 80) + v15) | ((*((_DWORD *)this + 182) & v23) << 8);
          v25 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
          if (v25)
          {
            if ((marisa::grimoire::trie::LoudsTrie::match_(v25, a2, v24) & 1) != 0)
              return 1;
          }
          else if ((marisa::grimoire::trie::Tail::match((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), a2, v24) & 1) != 0)
          {
            return 1;
          }
          if (*(_DWORD *)(v4 + 100) != v17)
            return 0;
          v12 = *(_DWORD *)(v4 + 96);
          v11 = *((_QWORD *)this + 2);
        }
        else
        {
          v16 = *(unsigned int *)(v4 + 100);
          if (*(unsigned __int8 *)(*((_QWORD *)this + 80) + v12) == *(unsigned __int8 *)(*(_QWORD *)a2 + v16))
          {
            *(_DWORD *)(v4 + 100) = v16 + 1;
            return 1;
          }
        }
        *(_DWORD *)(v4 + 96) = ++v12;
        v26 = *(_QWORD *)(v11 + ((v13 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v13;
        ++v13;
        if ((v26 & 1) == 0)
          return 0;
      }
    }
    return 0;
  }
  v9 = *(unsigned int *)(v8 + 12 * v7 + 8);
  if (v9 > 0xFFFFFEFF)
  {
    *(_DWORD *)(v4 + 100) = v6 + 1;
    goto LABEL_24;
  }
  v27 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
  if (v27)
  {
    if ((marisa::grimoire::trie::LoudsTrie::match_(v27, a2, v9) & 1) != 0)
      goto LABEL_24;
    return 0;
  }
  if ((marisa::grimoire::trie::Tail::match((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), a2, v9) & 1) == 0)
    return 0;
LABEL_24:
  *(_DWORD *)(v4 + 96) = *(_DWORD *)(*((_QWORD *)this + 128) + 12 * v7 + 4);
  return 1;
}

unint64_t marisa::grimoire::trie::LoudsTrie::reverse_lookup(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  unint64_t v3;
  uint64_t v5;
  unint64_t v6;
  size_t v7;
  unint64_t result;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  marisa::grimoire::trie::LoudsTrie *v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  unint64_t v23;
  char v24;
  BOOL v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  _BYTE *v29;
  BOOL v30;
  unint64_t v31;
  char v32;
  uint64_t v33;
  _QWORD *exception;
  char v35;

  v3 = *((_QWORD *)a2 + 2);
  if (v3 >= *((_QWORD *)this + 33))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
    exception[2] = 0x300000049;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:73: MARISA_BOUND_"
                   "ERROR: agent.query().id() >= size()";
  }
  v5 = *((_QWORD *)a2 + 5);
  *(_QWORD *)(v5 + 24) = 0;
  v6 = *(_QWORD *)(v5 + 32);
  if (v6 <= 0x1F)
  {
    if (v6 <= 0x10)
      v7 = 32;
    else
      v7 = 2 * v6;
    marisa::grimoire::vector::Vector<char>::realloc((uint64_t *)v5, v7);
    v3 = *((_QWORD *)a2 + 2);
  }
  *(_DWORD *)(v5 + 108) = 0;
  result = marisa::grimoire::vector::BitVector::select1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), v3);
  *(_DWORD *)(v5 + 96) = result;
  if (!(_DWORD)result)
    goto LABEL_30;
  while (1)
  {
    if (((*(_QWORD *)(*((_QWORD *)this + 54) + ((result >> 3) & 0x1FFFFFF8)) >> result) & 1) != 0)
    {
      v9 = *(_QWORD *)(v5 + 24);
      v10 = *(unsigned __int8 *)(*((_QWORD *)this + 80) + result);
      v11 = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), result);
      v12 = *((_QWORD *)this + 90);
      v13 = (unint64_t)(v12 * v11) >> 6;
      v14 = (v12 * v11) & 0x3F;
      v15 = v14 + v12;
      v16 = *((_QWORD *)this + 86);
      v17 = *(_QWORD *)(v16 + 8 * v13) >> v14;
      if (v15 > 0x40)
        v17 |= (2 * *(_QWORD *)(v16 + 8 * v13 + 8)) << (v14 ^ 0x3Fu);
      v18 = v10 | ((*((_DWORD *)this + 182) & v17) << 8);
      v19 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
      if (v19)
        result = (unint64_t)marisa::grimoire::trie::LoudsTrie::restore_(v19, a2, v18);
      else
        result = (unint64_t)marisa::grimoire::trie::Tail::restore((uint64_t *)this + 93, a2, v18);
      v20 = *(_QWORD *)(v5 + 24);
      if (v9 != v20)
      {
        v21 = *(_QWORD *)(v5 + 8);
        v22 = (_BYTE *)(v21 + v20 - 1);
        if ((unint64_t)v22 > v21 + v9)
        {
          v23 = v21 + v9 + 1;
          do
          {
            v24 = *(_BYTE *)(v23 - 1);
            *(_BYTE *)(v23 - 1) = *v22;
            *v22-- = v24;
            v25 = v23++ >= (unint64_t)v22;
          }
          while (!v25);
        }
      }
    }
    else
    {
      v35 = *(_BYTE *)(*((_QWORD *)this + 80) + result);
      result = (unint64_t)marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v5, &v35);
    }
    v26 = *(unsigned int *)(v5 + 96);
    if (*((_QWORD *)this + 133) >= v26)
      break;
    result = marisa::grimoire::vector::BitVector::select1(this, v26) + ~(unint64_t)*(unsigned int *)(v5 + 96);
    *(_DWORD *)(v5 + 96) = result;
  }
  v27 = *(_QWORD *)(v5 + 8);
  v28 = *(_QWORD *)(v5 + 24);
  v29 = (_BYTE *)(v27 + v28 - 1);
  if (v28)
    v30 = (unint64_t)v29 > v27;
  else
    v30 = 0;
  if (v30)
  {
    v31 = v27 + 1;
    do
    {
      v32 = *(_BYTE *)(v31 - 1);
      *(_BYTE *)(v31 - 1) = *v29;
      *v29-- = v32;
      v25 = v31++ >= (unint64_t)v29;
    }
    while (!v25);
LABEL_30:
    v27 = *(_QWORD *)(v5 + 8);
    v28 = *(_QWORD *)(v5 + 24);
  }
  *((_QWORD *)a2 + 3) = v27;
  v33 = *((_QWORD *)a2 + 2);
  *((_DWORD *)a2 + 8) = v28;
  *((_DWORD *)a2 + 9) = v33;
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<char>::push_back(uint64_t *result, _BYTE *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  size_t v6;
  uint64_t v7;
  size_t v8;

  v3 = result;
  v4 = result[3];
  v5 = result[4];
  v6 = v4 + 1;
  if (v5 < (unint64_t)(v4 + 1))
  {
    v7 = 2 * v5;
    if (v5 < 0)
      v7 = -1;
    if (v5 <= v6 >> 1)
      v8 = v6;
    else
      v8 = v7;
    result = (uint64_t *)marisa::grimoire::vector::Vector<char>::realloc(result, v8);
    v4 = v3[3];
  }
  *(_BYTE *)(v3[1] + v4) = *a2;
  ++v3[3];
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::common_prefix_search(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  unsigned int *v4;
  unsigned int v5;
  uint64_t result;
  unint64_t v7;
  marisa::grimoire::vector::BitVector *v8;
  unsigned int v9;

  v4 = (unsigned int *)*((_QWORD *)a2 + 5);
  v5 = v4[27];
  if (v5 == 1)
  {
LABEL_5:
    while (*((_QWORD *)a2 + 1) > (unint64_t)v4[25]
         && (marisa::grimoire::trie::LoudsTrie::find_child(this, a2) & 1) != 0)
    {
      v7 = v4[24];
      if (((*(_QWORD *)(*((_QWORD *)this + 28) + ((v7 >> 3) & 0x1FFFFFF8)) >> v7) & 1) != 0)
      {
        v8 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 208);
        v9 = v4[25];
        *((_QWORD *)a2 + 3) = *(_QWORD *)a2;
        *((_DWORD *)a2 + 8) = v9;
        goto LABEL_11;
      }
    }
    result = 0;
    v4[27] = 3;
  }
  else if (v5 == 3)
  {
    return 0;
  }
  else
  {
    *((_QWORD *)v4 + 12) = 0;
    v4[27] = 1;
    if ((**((_BYTE **)this + 28) & 1) == 0)
      goto LABEL_5;
    v8 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 208);
    *((_QWORD *)a2 + 3) = *(_QWORD *)a2;
    *((_DWORD *)a2 + 8) = 0;
    v7 = 0;
LABEL_11:
    *((_DWORD *)a2 + 9) = marisa::grimoire::vector::BitVector::rank1(v8, v7);
    return 1;
  }
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::predictive_search(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  uint64_t v4;
  int v5;
  uint64_t result;
  unint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  unsigned int *v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  marisa::grimoire::trie::LoudsTrie *v33;
  int v34;
  unint64_t v35;
  uint64_t v36;
  int v37;
  _DWORD *v38;
  int v39;
  _BYTE v40[20];

  v4 = *((_QWORD *)a2 + 5);
  v5 = *(_DWORD *)(v4 + 108);
  if (v5 == 2)
  {
    do
    {
      while (1)
      {
LABEL_10:
        v10 = *(unsigned int *)(v4 + 104);
        if (*(_QWORD *)(v4 + 72) == v10)
        {
          v11 = *(_QWORD *)(v4 + 56) + 20 * v10;
          *(_OWORD *)v40 = xmmword_1CDFA8120;
          *(_DWORD *)&v40[16] = -1;
          v12 = marisa::grimoire::vector::BitVector::select0(this, *(unsigned int *)(v11 - 20));
          *(_DWORD *)&v40[4] = v12 + 1;
          *(_DWORD *)v40 = v12 - *(_DWORD *)(v11 - 20);
          marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::push_back((uint64_t *)(v4 + 48), (__n128 *)v40);
          LODWORD(v10) = *(_DWORD *)(v4 + 104);
        }
        v13 = *(_QWORD *)(v4 + 56);
        v14 = (unsigned int *)(v13 + 20 * v10);
        v15 = v14[1];
        v16 = *(_QWORD *)(*((_QWORD *)this + 2) + ((v15 >> 3) & 0x1FFFFFF8));
        v14[1] = v15 + 1;
        if (((v16 >> v15) & 1) != 0)
          break;
        if ((_DWORD)v10 == 1)
        {
LABEL_7:
          result = 0;
          *(_DWORD *)(v4 + 108) = 4;
          return result;
        }
        v23 = v13 + 20 * v10;
        ++*(_DWORD *)(v23 - 20);
        marisa::grimoire::vector::Vector<char>::resize((uint64_t *)v4, *(unsigned int *)(v23 - 32));
        --*(_DWORD *)(v4 + 104);
      }
      *(_DWORD *)(v4 + 104) = v10 + 1;
      v17 = *v14;
      if (((*(_QWORD *)(*((_QWORD *)this + 54) + ((v17 >> 3) & 0x1FFFFFF8)) >> v17) & 1) != 0)
      {
        v18 = v13 + 20 * v10;
        v21 = *(_DWORD *)(v18 + 12);
        v20 = (unsigned int *)(v18 + 12);
        v19 = v21;
        if (v21 == -1)
        {
          v22 = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), v17);
          v17 = *v14;
        }
        else
        {
          v22 = v19 + 1;
        }
        *v20 = v22;
        v24 = *((_QWORD *)this + 90);
        v25 = v24 * v22;
        v26 = v25 >> 6;
        v27 = v25 & 0x3F;
        v28 = v27 + v24;
        v29 = *((_QWORD *)this + 86);
        v30 = *(_QWORD *)(v29 + 8 * v26);
        if (v28 > 0x40)
          v31 = ((2 * *(_QWORD *)(v29 + 8 * v26 + 8)) << (v27 ^ 0x3Fu)) | (v30 >> v27);
        else
          v31 = v30 >> v27;
        v32 = *(unsigned __int8 *)(*((_QWORD *)this + 80) + v17) | ((*((_DWORD *)this + 182) & v31) << 8);
        v33 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
        if (v33)
          marisa::grimoire::trie::LoudsTrie::restore_(v33, a2, v32);
        else
          marisa::grimoire::trie::Tail::restore((uint64_t *)this + 93, a2, v32);
      }
      else
      {
        v40[0] = *(_BYTE *)(*((_QWORD *)this + 80) + v17);
        marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v4, v40);
      }
      v34 = *(_DWORD *)(v4 + 24);
      *(_DWORD *)(v13 + 20 * v10 + 8) = v34;
      v35 = *v14;
    }
    while (((*(_QWORD *)(*((_QWORD *)this + 28) + ((v35 >> 3) & 0x1FFFFFF8)) >> v35) & 1) == 0);
    v36 = v13 + 20 * v10;
    v39 = *(_DWORD *)(v36 + 16);
    v38 = (_DWORD *)(v36 + 16);
    v37 = v39;
    if (v39 == -1)
    {
      v9 = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), v35);
      v34 = *(_DWORD *)(v4 + 24);
    }
    else
    {
      v9 = v37 + 1;
    }
    *v38 = v9;
    *((_QWORD *)a2 + 3) = *(_QWORD *)(v4 + 8);
    *((_DWORD *)a2 + 8) = v34;
  }
  else
  {
    if (v5 == 4)
      return 0;
    marisa::grimoire::trie::State::predictive_search_init(*((marisa::grimoire::trie::State **)a2 + 5));
    while (*((_QWORD *)a2 + 1) > (unint64_t)*(unsigned int *)(v4 + 100))
    {
      if ((marisa::grimoire::trie::LoudsTrie::predictive_find_child(this, a2) & 1) == 0)
        goto LABEL_7;
    }
    *(_QWORD *)&v40[12] = -1;
    *(_QWORD *)v40 = *(unsigned int *)(v4 + 96);
    *(_DWORD *)&v40[8] = *(_QWORD *)(v4 + 24);
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::push_back((uint64_t *)(v4 + 48), (__n128 *)v40);
    *(_DWORD *)(v4 + 104) = 1;
    v7 = *(unsigned int *)(v4 + 96);
    if (((*(_QWORD *)(*((_QWORD *)this + 28) + ((v7 >> 3) & 0x1FFFFFF8)) >> v7) & 1) == 0)
      goto LABEL_10;
    v8 = *(_QWORD *)(v4 + 24);
    *((_QWORD *)a2 + 3) = *(_QWORD *)(v4 + 8);
    *((_DWORD *)a2 + 8) = v8;
    v9 = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), v7);
  }
  *((_DWORD *)a2 + 9) = v9;
  return 1;
}

double marisa::grimoire::trie::State::predictive_search_init(marisa::grimoire::trie::State *this)
{
  unint64_t v2;
  size_t v3;
  unint64_t v4;
  uint64_t v5;
  double result;

  *((_QWORD *)this + 3) = 0;
  v2 = *((_QWORD *)this + 4);
  if (v2 <= 0x3F)
  {
    if (v2 <= 0x20)
      v3 = 64;
    else
      v3 = 2 * v2;
    marisa::grimoire::vector::Vector<char>::realloc((uint64_t *)this, v3);
  }
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::resize((uint64_t *)this + 6, 0);
  v4 = *((_QWORD *)this + 10);
  if (v4 <= 3)
  {
    if (v4 == 3)
      v5 = 6;
    else
      v5 = 4;
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::realloc((uint64_t *)this + 6, v5);
  }
  result = 0.0;
  *((_OWORD *)this + 6) = xmmword_1CDFA8130;
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::predictive_find_child(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  marisa::grimoire::trie::LoudsTrie *v24;
  uint64_t v25;
  marisa::grimoire::trie::LoudsTrie *v26;
  char v28;
  char v29;

  v4 = *((_QWORD *)a2 + 5);
  v5 = *(unsigned int *)(v4 + 96);
  v6 = (*(unsigned __int8 *)(*(_QWORD *)a2 + *(unsigned int *)(v4 + 100)) ^ (32 * v5) ^ v5) & *((_QWORD *)this + 132);
  v7 = *((_QWORD *)this + 128);
  if ((_DWORD)v5 != *(_DWORD *)(v7 + 12 * v6))
  {
    v10 = marisa::grimoire::vector::BitVector::select0(this, v5);
    v11 = *((_QWORD *)this + 2);
    if (((*(_QWORD *)(v11 + (((v10 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v10 + 1)) & 1) != 0)
    {
      v12 = v10 - *(_DWORD *)(v4 + 96);
      *(_DWORD *)(v4 + 96) = v12;
      v13 = v10 + 2;
      v14 = 0xFFFFFFFFLL;
      while (1)
      {
        v15 = v12;
        if (((*(_QWORD *)(*((_QWORD *)this + 54) + (((unint64_t)v12 >> 3) & 0x1FFFFFF8)) >> v12) & 1) != 0)
        {
          if (v14 == 0xFFFFFFFFLL)
          {
            v14 = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), v12);
            v15 = *(unsigned int *)(v4 + 96);
          }
          else
          {
            ++v14;
          }
          v16 = *(_DWORD *)(v4 + 100);
          v17 = *((_QWORD *)this + 90);
          v18 = (unint64_t)(v17 * v14) >> 6;
          v19 = (v17 * v14) & 0x3F;
          v20 = v19 + v17;
          v21 = *((_QWORD *)this + 86);
          v22 = *(_QWORD *)(v21 + 8 * v18) >> v19;
          if (v20 > 0x40)
            v22 |= (2 * *(_QWORD *)(v21 + 8 * v18 + 8)) << (v19 ^ 0x3Fu);
          v23 = *(unsigned __int8 *)(*((_QWORD *)this + 80) + v15) | ((*((_DWORD *)this + 182) & v22) << 8);
          v24 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
          if (v24)
          {
            if ((marisa::grimoire::trie::LoudsTrie::prefix_match_(v24, a2, v23) & 1) != 0)
              return 1;
          }
          else if (marisa::grimoire::trie::Tail::prefix_match((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), a2, v23))
          {
            return 1;
          }
          if (*(_DWORD *)(v4 + 100) != v16)
            return 0;
          v12 = *(_DWORD *)(v4 + 96);
          v11 = *((_QWORD *)this + 2);
        }
        else if (*(unsigned __int8 *)(*((_QWORD *)this + 80) + v12) == *(unsigned __int8 *)(*(_QWORD *)a2
                                                                                           + *(unsigned int *)(v4 + 100)))
        {
          v28 = *(_BYTE *)(*((_QWORD *)this + 80) + v12);
          marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v4, &v28);
          ++*(_DWORD *)(v4 + 100);
          return 1;
        }
        *(_DWORD *)(v4 + 96) = ++v12;
        v25 = *(_QWORD *)(v11 + ((v13 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v13;
        ++v13;
        if ((v25 & 1) == 0)
          return 0;
      }
    }
    return 0;
  }
  v8 = v7 + 12 * v6;
  v9 = *(unsigned int *)(v8 + 8);
  if (v9 > 0xFFFFFEFF)
  {
    v29 = *(_DWORD *)(v8 + 8);
    marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v4, &v29);
    ++*(_DWORD *)(v4 + 100);
    goto LABEL_24;
  }
  v26 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
  if (v26)
  {
    if ((marisa::grimoire::trie::LoudsTrie::prefix_match_(v26, a2, v9) & 1) != 0)
      goto LABEL_24;
    return 0;
  }
  if (!marisa::grimoire::trie::Tail::prefix_match((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), a2, v9))
    return 0;
LABEL_24:
  *(_DWORD *)(v4 + 96) = *(_DWORD *)(*((_QWORD *)this + 128) + 12 * v6 + 4);
  return 1;
}

__n128 marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::push_back(uint64_t *a1, __n128 *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  __n128 result;

  v4 = a1[3];
  v5 = a1[4];
  v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    v7 = 2 * v5;
    if (v5 > 0x666666666666666)
      v7 = 0xCCCCCCCCCCCCCCCLL;
    if (v5 <= v6 >> 1)
      v8 = v6;
    else
      v8 = v7;
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::realloc(a1, v8);
    v4 = a1[3];
  }
  v9 = (__n128 *)(a1[1] + 20 * v4);
  result = *a2;
  v9[1].n128_u32[0] = a2[1].n128_u32[0];
  *v9 = result;
  ++a1[3];
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<char>::resize(uint64_t *result, size_t a2)
{
  size_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 < 0)
      v5 = -1;
    if (v4 > a2 >> 1)
      a2 = v5;
    result = (uint64_t *)marisa::grimoire::vector::Vector<char>::realloc(result, a2);
  }
  v3[3] = v2;
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::total_size(marisa::grimoire::trie::LoudsTrie *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  marisa::grimoire::trie::LoudsTrie *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v2 = *((_QWORD *)this + 3);
  v3 = *((_QWORD *)this + 11);
  v4 = *((_QWORD *)this + 17);
  v5 = *((_QWORD *)this + 23);
  v6 = *((_QWORD *)this + 29);
  v7 = *((_QWORD *)this + 37);
  v8 = *((_QWORD *)this + 43);
  v9 = *((_QWORD *)this + 49);
  v10 = *((_QWORD *)this + 55);
  v11 = *((_QWORD *)this + 63);
  v12 = *((_QWORD *)this + 69);
  v13 = *((_QWORD *)this + 75);
  v14 = *((_QWORD *)this + 81);
  v15 = *((_QWORD *)this + 87);
  v16 = *((_QWORD *)this + 96);
  v17 = *((_QWORD *)this + 102);
  v18 = *((_QWORD *)this + 110);
  v19 = *((_QWORD *)this + 116);
  v20 = *((_QWORD *)this + 122);
  v21 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
  if (v21)
  {
    v34 = v3;
    v35 = v4;
    v26 = v18;
    v27 = v11;
    v22 = v5;
    v32 = v20;
    v33 = v2;
    v30 = v7;
    v31 = v14;
    v28 = v17;
    v29 = v12;
    v23 = v16;
    v24 = v13;
    v21 = (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::total_size(v21);
    v12 = v29;
    v7 = v30;
    v14 = v31;
    v20 = v32;
    v2 = v33;
    v3 = v34;
    v13 = v24;
    v16 = v23;
    v11 = v27;
    v17 = v28;
    v5 = v22;
    v18 = v26;
    v4 = v35;
  }
  return (uint64_t)v21
       + 12 * *((_QWORD *)this + 129)
       + 12 * v18
       + 12 * v11
       + 12 * v3
       + 12 * v7
       + 8 * v2
       + 8 * v17
       + 8 * v15
       + 8 * v10
       + 8 * v6
       + 4 * v4
       + 4 * v8
       + 4 * v9
       + 4 * v12
       + 4 * v13
       + 4 * v19
       + 4 * v20
       + 4 * v5
       + v16
       + v14;
}

unint64_t marisa::grimoire::trie::LoudsTrie::io_size(marisa::grimoire::trie::LoudsTrie *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  marisa::grimoire::trie::LoudsTrie *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v2 = *((_QWORD *)this + 11);
  v3 = *((_QWORD *)this + 17);
  v4 = *((_QWORD *)this + 23);
  v28 = *((_QWORD *)this + 29);
  v29 = *((_QWORD *)this + 3);
  v5 = *((_QWORD *)this + 37);
  v6 = *((_QWORD *)this + 43);
  v7 = *((_QWORD *)this + 49);
  v25 = *((_QWORD *)this + 63);
  v26 = *((_QWORD *)this + 69);
  v27 = *((_QWORD *)this + 55);
  v8 = *((_QWORD *)this + 75);
  v9 = *((_QWORD *)this + 81);
  v10 = *((_QWORD *)this + 87);
  v11 = marisa::grimoire::trie::Tail::io_size((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744));
  v12 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
  if (v12)
  {
    v24 = v8;
    v13 = v5;
    v14 = v6;
    v15 = v7;
    v16 = v10;
    v17 = v2;
    v18 = v3;
    v19 = v4;
    v20 = v11;
    v21 = marisa::grimoire::trie::LoudsTrie::io_size(v12);
    v11 = v20;
    v4 = v19;
    v3 = v18;
    v2 = v17;
    v10 = v16;
    v7 = v15;
    v6 = v14;
    v5 = v13;
    v8 = v24;
    v22 = v21 - 16;
  }
  else
  {
    v22 = 0;
  }
  return ((12 * v2 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * v3 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * v4 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((12 * v5 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * v6 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * v7 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((12 * v25 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * v26 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((v9 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * v8 + 7) & 0xFFFFFFFFFFFFFFF8)
       + v11
       + 8 * (v28 + v29 + v27 + v10)
       + v22
       + ((12 * *((_QWORD *)this + 129) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 184;
}

unint64_t marisa::grimoire::trie::Tail::io_size(marisa::grimoire::trie::Tail *this)
{
  return ((*((_QWORD *)this + 3) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 8 * *((_QWORD *)this + 9)
       + ((4 * *((_QWORD *)this + 23) + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * *((_QWORD *)this + 29) + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((12 * *((_QWORD *)this + 17) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 48;
}

void marisa::grimoire::trie::LoudsTrie::clear(marisa::grimoire::trie::LoudsTrie *this)
{
  _BYTE v2[1136];

  marisa::grimoire::trie::LoudsTrie::LoudsTrie((marisa::grimoire::trie::LoudsTrie *)v2);
  marisa::grimoire::trie::LoudsTrie::swap((marisa::grimoire::trie::LoudsTrie *)v2, this);
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie((marisa::grimoire::trie::LoudsTrie *)v2);
}

void sub_1CDF93BAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie((marisa::grimoire::trie::LoudsTrie *)&a9);
  _Unwind_Resume(a1);
}

uint64_t *marisa::grimoire::vector::BitVector::swap(marisa::grimoire::vector::BitVector *this, marisa::grimoire::vector::BitVector *a2)
{
  uint64_t v4;
  uint64_t v5;

  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this, (uint64_t *)a2);
  v4 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = *((_QWORD *)a2 + 6);
  *((_QWORD *)a2 + 6) = v4;
  v5 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = *((_QWORD *)a2 + 7);
  *((_QWORD *)a2 + 7) = v5;
  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this + 8, (uint64_t *)a2 + 8);
  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this + 14, (uint64_t *)a2 + 14);
  return marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this + 20, (uint64_t *)a2 + 20);
}

uint64_t *marisa::grimoire::vector::Vector<unsigned char>::swap(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *result;
  *result = *a2;
  *a2 = v2;
  v3 = result[1];
  result[1] = a2[1];
  a2[1] = v3;
  v4 = result[2];
  v5 = result[3];
  v6 = a2[3];
  result[2] = a2[2];
  result[3] = v6;
  a2[2] = v4;
  a2[3] = v5;
  v7 = result[4];
  result[4] = a2[4];
  a2[4] = v7;
  LOBYTE(v7) = *((_BYTE *)result + 40);
  *((_BYTE *)result + 40) = *((_BYTE *)a2 + 40);
  *((_BYTE *)a2 + 40) = v7;
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::resize(uint64_t *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 > 0x555555555555555)
      v5 = 0xAAAAAAAAAAAAAAALL;
    if (v4 > a2 >> 1)
      a2 = v5;
    result = (uint64_t *)marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::realloc(result, a2);
  }
  v6 = v3[3];
  v7 = v2 - v6;
  if (v2 > v6)
  {
    v8 = 24 * v6;
    do
    {
      v9 = v3[1] + v8;
      *(_QWORD *)v9 = 0;
      *(_QWORD *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 16) = 0;
      v8 += 24;
      --v7;
    }
    while (v7);
  }
  v3[3] = v2;
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t *a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  _DWORD *v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t result;
  __int128 v17[3];
  uint64_t v18;
  uint64_t v19;
  int v20;

  marisa::grimoire::trie::LoudsTrie::build_current_trie<marisa::grimoire::trie::Key>((uint64_t *)a1, (uint64_t)a2, a3, a4, a5);
  memset(v17, 0, 41);
  if (a2[3])
    marisa::grimoire::trie::LoudsTrie::build_next_trie<marisa::grimoire::trie::Key>(a1, a2, v17, a4, a5);
  v9 = *(_DWORD **)(a1 + 1000);
  if (v9)
  {
    v10 = (v9[268] + 1) | v9[271] | v9[272];
    v18 = 3;
    v19 = 0x100000000200;
    v20 = 0x20000;
    marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v18, v10);
  }
  else
  {
    if (*(_QWORD *)(a1 + 840))
      v11 = 0x2000;
    else
      v11 = 4096;
    v12 = *(_DWORD *)(a4 + 16) | *(_DWORD *)(a4 + 8) | v11 | 1;
    v18 = 3;
    v19 = 0x100000000200;
    v20 = 0x20000;
    marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v18, v12);
  }
  *(_QWORD *)(a1 + 1072) = v18;
  *(_QWORD *)(a1 + 1080) = v19;
  *(_DWORD *)(a1 + 1088) = v20;
  marisa::grimoire::vector::BitVector::build((marisa::grimoire::vector::BitVector *)(a1 + 416), 0, 0);
  if (*((_QWORD *)&v17[1] + 1))
  {
    v13 = 0;
    v14 = 0;
    do
    {
      do
      {
        v15 = *(_QWORD *)(*(_QWORD *)(a1 + 432) + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v14;
        ++v14;
      }
      while ((v15 & 1) == 0);
      *(_BYTE *)(*(_QWORD *)(a1 + 632) + v14 - 1) = *(_DWORD *)(*((_QWORD *)&v17[0] + 1) + 4 * v13);
      *(_DWORD *)(*((_QWORD *)&v17[0] + 1) + 4 * v13++) >>= 8;
    }
    while (v13 < *((_QWORD *)&v17[1] + 1));
  }
  marisa::grimoire::vector::FlatVector::build((__int128 *)(a1 + 672), (uint64_t)v17);
  marisa::grimoire::trie::LoudsTrie::fill_cache(a1);
  result = *(_QWORD *)&v17[0];
  if (*(_QWORD *)&v17[0])
    return MEMORY[0x1D17BC778](*(_QWORD *)&v17[0], 0x1000C8077774924);
  return result;
}

void sub_1CDF93EB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void marisa::grimoire::vector::Vector<std::pair<unsigned int,unsigned int>>::resize(uint64_t *a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;

  v2 = a2;
  v4 = a1[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 >> 60)
      v5 = 0x1FFFFFFFFFFFFFFFLL;
    if (v4 > a2 >> 1)
      a2 = v5;
    marisa::grimoire::vector::Vector<unsigned long long>::realloc(a1, a2);
  }
  v6 = a1[3];
  if (v2 > v6)
    bzero((void *)(a1[1] + 8 * v6), 8 * (v2 - v6));
  a1[3] = v2;
}

uint64_t *marisa::grimoire::vector::BitVector::push_back(uint64_t *this, int a2)
{
  unint64_t v2;
  uint64_t *v4;
  uint64_t v5;
  _QWORD *exception;
  uint64_t v7;

  v2 = this[6];
  if (v2 == 0xFFFFFFFF)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h";
    exception[2] = 0x700000034;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h:52: MARI"
                   "SA_SIZE_ERROR: size_ == MARISA_UINT32_MAX";
  }
  v4 = this;
  v5 = this[3];
  if (v2 == v5 << 6)
  {
    v7 = 0;
    this = marisa::grimoire::vector::Vector<unsigned long long>::resize(this, v5 + 1, &v7);
    v2 = v4[6];
  }
  if (a2)
  {
    *(_QWORD *)(v4[1] + ((v2 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v2;
    ++v4[7];
  }
  v4[6] = v2 + 1;
  return this;
}

uint64_t marisa::grimoire::vector::BitVector::build(marisa::grimoire::vector::BitVector *this, int a2, int a3)
{
  __int128 v4;
  uint64_t v5;
  __int128 v6;
  uint64_t result;
  _OWORD v8[4];
  __int128 v9;
  _BYTE v10[25];
  __int128 v11;
  _BYTE v12[25];
  __int128 v13;
  _BYTE v14[25];

  memset(v8, 0, 41);
  v11 = 0u;
  memset(v12, 0, sizeof(v12));
  v13 = 0u;
  memset(v14, 0, sizeof(v14));
  v8[3] = 0u;
  v9 = 0u;
  memset(v10, 0, sizeof(v10));
  marisa::grimoire::vector::BitVector::build_index((marisa::grimoire::vector::BitVector *)v8, this, a2, a3);
  marisa::grimoire::vector::Vector<unsigned long long>::shrink(this);
  v4 = v8[0];
  v8[0] = *(_OWORD *)this;
  *(_OWORD *)this = v4;
  v5 = *(_QWORD *)&v8[1];
  *(_QWORD *)&v8[1] = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = v5;
  v6 = *(_OWORD *)((char *)&v8[1] + 8);
  *(_OWORD *)((char *)&v8[1] + 8) = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 24) = v6;
  LOBYTE(v5) = BYTE8(v8[2]);
  BYTE8(v8[2]) = *((_BYTE *)this + 40);
  *((_BYTE *)this + 40) = v5;
  marisa::grimoire::vector::BitVector::swap(this, (marisa::grimoire::vector::BitVector *)v8);
  if ((_QWORD)v13)
    MEMORY[0x1D17BC778](v13, 0x1000C8077774924);
  if ((_QWORD)v11)
    MEMORY[0x1D17BC778](v11, 0x1000C8077774924);
  if ((_QWORD)v9)
    MEMORY[0x1D17BC778](v9, 0x1000C8077774924);
  result = *(_QWORD *)&v8[0];
  if (*(_QWORD *)&v8[0])
    return MEMORY[0x1D17BC778](*(_QWORD *)&v8[0], 0x1000C8077774924);
  return result;
}

void sub_1CDF94158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  marisa::grimoire::vector::BitVector::~BitVector((marisa::grimoire::vector::BitVector *)&a9);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_next_trie<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t *a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  unsigned int *v10;
  _DWORD *v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  marisa::grimoire::trie::LoudsTrie *v21;
  marisa::grimoire::trie::LoudsTrie *v22;
  marisa::grimoire::trie::LoudsTrie **v23;
  uint64_t result;
  _QWORD *exception;
  __int128 v26;
  _BYTE v27[25];

  if (*(_QWORD *)a4 == a5)
  {
    v26 = 0u;
    memset(v27, 0, sizeof(v27));
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::resize((uint64_t *)&v26, a2[3]);
    v9 = a2[3];
    if (v9)
    {
      v10 = (unsigned int *)(*((_QWORD *)&v26 + 1) + 8);
      v11 = (_DWORD *)(a2[1] + 8);
      do
      {
        v12 = *((_QWORD *)v11 - 1);
        v13 = *v11;
        v11 += 6;
        *((_QWORD *)v10 - 1) = v12 + v13 - 1;
        *v10 = v13;
        v10 += 4;
        --v9;
      }
      while (v9);
    }
    marisa::grimoire::trie::Tail::build((__int128 *)(a1 + 744), (uint64_t)&v26, a3, *(_DWORD *)(a4 + 12));
  }
  else
  {
    v26 = 0u;
    memset(v27, 0, sizeof(v27));
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::resize((uint64_t *)&v26, a2[3]);
    if (a2[3])
    {
      v15 = 0;
      v16 = 0;
      do
      {
        v17 = *((_QWORD *)&v26 + 1) + v15;
        v18 = a2[1] + v15;
        v19 = *(unsigned int *)(v18 + 8);
        *(_QWORD *)v17 = *(_QWORD *)v18 + v19;
        *(_DWORD *)(v17 + 8) = v19;
        *(_DWORD *)(v17 + 12) = *(_DWORD *)(v18 + 12);
        ++v16;
        v15 += 24;
      }
      while (v16 < a2[3]);
    }
    v20 = *a2;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *(_OWORD *)((char *)a2 + 25) = 0u;
    if (v20)
      MEMORY[0x1D17BC778](v20, 0x1000C8077774924);
    v21 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E0DE4E10]);
    v22 = v21;
    if (v21)
      marisa::grimoire::trie::LoudsTrie::LoudsTrie(v21);
    v23 = (marisa::grimoire::trie::LoudsTrie **)(a1 + 1000);
    marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::reset(v23, v22);
    if (!*v23)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &off_1E8B57FF8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
      exception[2] = 0x8000001C3;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:451: MARISA_MEM"
                     "ORY_ERROR: next_trie_.get() == NULL";
    }
    marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::ReverseKey>((uint64_t)*v23, (uint64_t)&v26, a3, a4, a5 + 1);
  }
  result = v26;
  if ((_QWORD)v26)
    return MEMORY[0x1D17BC778](v26, 0x1000C8077774924);
  return result;
}

void sub_1CDF94368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  MEMORY[0x1D17BC790](v9, MEMORY[0x1E0DE4E10]);
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::resize(uint64_t *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 >> 59)
      v5 = 0xFFFFFFFFFFFFFFFLL;
    if (v4 > a2 >> 1)
      a2 = v5;
    result = (uint64_t *)marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::realloc(result, a2);
  }
  v6 = v3[3];
  v7 = v2 - v6;
  if (v2 > v6)
  {
    v8 = 16 * v6;
    do
    {
      v9 = (_QWORD *)(v3[1] + v8);
      *v9 = 0;
      v9[1] = 0;
      v8 += 16;
      --v7;
    }
    while (v7);
  }
  v3[3] = v2;
  return result;
}

marisa::grimoire::trie::LoudsTrie **marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::reset(marisa::grimoire::trie::LoudsTrie **a1, marisa::grimoire::trie::LoudsTrie *a2)
{
  _QWORD *exception;
  marisa::grimoire::trie::LoudsTrie *v4;

  if (a2 && *a1 == a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/include/marisa/scoped-ptr.h";
    exception[2] = 0x600000013;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/include/marisa/scoped-ptr.h:19: MARISA_RESET_ERROR: (ptr"
                   " != NULL) && (ptr == ptr_)";
  }
  v4 = *a1;
  *a1 = a2;
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v4);
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  _DWORD *v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t result;
  __int128 v17[3];
  uint64_t v18;
  uint64_t v19;
  int v20;

  marisa::grimoire::trie::LoudsTrie::build_current_trie<marisa::grimoire::trie::ReverseKey>((uint64_t *)a1, a2, a3, a4, a5);
  memset(v17, 0, 41);
  if (*(_QWORD *)(a2 + 24))
    marisa::grimoire::trie::LoudsTrie::build_next_trie<marisa::grimoire::trie::ReverseKey>(a1, a2, v17, a4, a5);
  v9 = *(_DWORD **)(a1 + 1000);
  if (v9)
  {
    v10 = (v9[268] + 1) | v9[271] | v9[272];
    v18 = 3;
    v19 = 0x100000000200;
    v20 = 0x20000;
    marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v18, v10);
  }
  else
  {
    if (*(_QWORD *)(a1 + 840))
      v11 = 0x2000;
    else
      v11 = 4096;
    v12 = *(_DWORD *)(a4 + 16) | *(_DWORD *)(a4 + 8) | v11 | 1;
    v18 = 3;
    v19 = 0x100000000200;
    v20 = 0x20000;
    marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v18, v12);
  }
  *(_QWORD *)(a1 + 1072) = v18;
  *(_QWORD *)(a1 + 1080) = v19;
  *(_DWORD *)(a1 + 1088) = v20;
  marisa::grimoire::vector::BitVector::build((marisa::grimoire::vector::BitVector *)(a1 + 416), 0, 0);
  if (*((_QWORD *)&v17[1] + 1))
  {
    v13 = 0;
    v14 = 0;
    do
    {
      do
      {
        v15 = *(_QWORD *)(*(_QWORD *)(a1 + 432) + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v14;
        ++v14;
      }
      while ((v15 & 1) == 0);
      *(_BYTE *)(*(_QWORD *)(a1 + 632) + v14 - 1) = *(_DWORD *)(*((_QWORD *)&v17[0] + 1) + 4 * v13);
      *(_DWORD *)(*((_QWORD *)&v17[0] + 1) + 4 * v13++) >>= 8;
    }
    while (v13 < *((_QWORD *)&v17[1] + 1));
  }
  marisa::grimoire::vector::FlatVector::build((__int128 *)(a1 + 672), (uint64_t)v17);
  marisa::grimoire::trie::LoudsTrie::fill_cache(a1);
  result = *(_QWORD *)&v17[0];
  if (*(_QWORD *)&v17[0])
    return MEMORY[0x1D17BC778](*(_QWORD *)&v17[0], 0x1000C8077774924);
  return result;
}

void sub_1CDF9465C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_next_trie<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  _DWORD *v10;
  _DWORD *v11;
  uint64_t v12;
  int v13;
  uint64_t result;
  marisa::grimoire::trie::LoudsTrie *v16;
  marisa::grimoire::trie::LoudsTrie *v17;
  marisa::grimoire::trie::LoudsTrie **v18;
  _QWORD *exception;
  _OWORD v20[3];

  if (*(_QWORD *)a4 == a5)
  {
    memset(v20, 0, 41);
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::resize((uint64_t *)v20, *(_QWORD *)(a2 + 24));
    v9 = *(_QWORD *)(a2 + 24);
    if (v9)
    {
      v10 = (_DWORD *)(*((_QWORD *)&v20[0] + 1) + 8);
      v11 = (_DWORD *)(*(_QWORD *)(a2 + 8) + 8);
      do
      {
        v12 = *((_QWORD *)v11 - 1);
        v13 = *v11;
        v11 += 6;
        *((_QWORD *)v10 - 1) = v12 - 1;
        *v10 = v13;
        v10 += 4;
        --v9;
      }
      while (v9);
    }
    marisa::grimoire::trie::Tail::build((__int128 *)(a1 + 744), (uint64_t)v20, a3, *(_DWORD *)(a4 + 12));
    result = *(_QWORD *)&v20[0];
    if (*(_QWORD *)&v20[0])
      return MEMORY[0x1D17BC778](*(_QWORD *)&v20[0], 0x1000C8077774924);
  }
  else
  {
    v16 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E0DE4E10]);
    v17 = v16;
    if (v16)
      marisa::grimoire::trie::LoudsTrie::LoudsTrie(v16);
    v18 = (marisa::grimoire::trie::LoudsTrie **)(a1 + 1000);
    marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::reset(v18, v17);
    if (!*v18)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &off_1E8B57FF8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
      exception[2] = 0x8000001D4;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:468: MARISA_MEM"
                     "ORY_ERROR: next_trie_.get() == NULL";
    }
    return marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::ReverseKey>(*v18, a2, a3, a4, a5 + 1);
  }
  return result;
}

void sub_1CDF947FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC790](v1, MEMORY[0x1E0DE4E10]);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::LoudsTrie::cache<marisa::grimoire::trie::Key>(uint64_t result, uint64_t a2, int a3, unsigned __int8 a4, float a5)
{
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float *v8;
  float v9;
  _DWORD *v10;

  v5 = *(_QWORD *)(result + 1056) & (a4 ^ (unint64_t)(32 * a2) ^ a2);
  v6 = *(_QWORD *)(result + 1016);
  v7 = v6 + 12 * v5;
  v9 = *(float *)(v7 + 8);
  v8 = (float *)(v7 + 8);
  if (v9 < a5)
  {
    v10 = (_DWORD *)(v6 + 12 * v5);
    *v10 = a2;
    v10[1] = a3;
    *v8 = a5;
  }
  return result;
}

uint64_t *marisa::grimoire::trie::LoudsTrie::reserve_cache(marisa::grimoire::trie::LoudsTrie *this, const marisa::grimoire::trie::Config *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5;
  unint64_t v6;
  uint64_t *result;

  v5 = 256;
  if (a3 != 1)
    v5 = 1;
  do
  {
    v6 = v5;
    v5 *= 2;
  }
  while (v6 < a4 / *((unsigned int *)a2 + 2));
  result = marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::resize((uint64_t *)this + 126, v6);
  *((_QWORD *)this + 132) = v6 - 1;
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::resize(uint64_t *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 > 0xAAAAAAAAAAAAAAALL)
      v5 = 0x1555555555555555;
    if (v4 > a2 >> 1)
      a2 = v5;
    result = (uint64_t *)marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::realloc(result, a2);
  }
  v6 = v3[3];
  v7 = v2 - v6;
  if (v2 > v6)
  {
    v8 = 12 * v6;
    do
    {
      v9 = v3[1] + v8;
      *(_QWORD *)v9 = 0;
      *(_DWORD *)(v9 + 8) = 0x800000;
      v8 += 12;
      --v7;
    }
    while (v7);
  }
  v3[3] = v2;
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::cache<marisa::grimoire::trie::ReverseKey>(uint64_t result, int a2, uint64_t a3, float a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float *v7;
  float v8;
  _DWORD *v9;

  v4 = *(_QWORD *)(result + 1056) & a3;
  v5 = *(_QWORD *)(result + 1016);
  v6 = v5 + 12 * v4;
  v8 = *(float *)(v6 + 8);
  v7 = (float *)(v6 + 8);
  if (v8 < a4)
  {
    v9 = (_DWORD *)(v5 + 12 * v4);
    *v9 = a2;
    v9[1] = a3;
    *v7 = a4;
  }
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::fill_cache(uint64_t this)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  marisa::grimoire::vector::BitVector *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int v16;

  v1 = *(_QWORD *)(this + 1032);
  if (v1)
  {
    v2 = this;
    v3 = 0;
    v4 = 0;
    v5 = (marisa::grimoire::vector::BitVector *)(this + 416);
    do
    {
      v6 = *(_QWORD *)(v2 + 1016);
      v7 = *(unsigned int *)(v6 + v3 + 4);
      if ((_DWORD)v7)
      {
        *(_BYTE *)(v6 + v3 + 8) = *(_BYTE *)(*(_QWORD *)(v2 + 632) + v7);
        v8 = *(_QWORD *)(v2 + 1016);
        if (((*(_QWORD *)(*(_QWORD *)(v2 + 432) + ((v7 >> 3) & 0x1FFFFFF8)) >> v7) & 1) != 0)
        {
          this = marisa::grimoire::vector::BitVector::rank1(v5, v7);
          v9 = *(_QWORD *)(v2 + 720);
          v10 = (unint64_t)(v9 * this) >> 6;
          v11 = (v9 * this) & 0x3F;
          v12 = v11 + v9;
          v13 = *(_QWORD *)(v2 + 688);
          v14 = *(_QWORD *)(v13 + 8 * v10);
          if (v12 > 0x40)
            v15 = ((2 * *(_QWORD *)(v13 + 8 * v10 + 8)) << (v11 ^ 0x3Fu)) | (v14 >> v11);
          else
            v15 = v14 >> v11;
          v16 = *(_DWORD *)(v2 + 728) & v15;
        }
        else
        {
          v16 = 0xFFFFFF;
        }
        *(_DWORD *)(v8 + v3 + 8) = *(unsigned __int8 *)(v8 + v3 + 8) | (v16 << 8);
        v1 = *(_QWORD *)(v2 + 1032);
      }
      else
      {
        *(_QWORD *)(v6 + v3) = -1;
      }
      ++v4;
      v3 += 12;
    }
    while (v4 < v1);
  }
  return this;
}

uint64_t marisa::grimoire::vector::BitVector::map(marisa::grimoire::vector::BitVector *this, marisa::grimoire::io::Mapper *a2)
{
  uint64_t result;
  _OWORD v4[4];
  __int128 v5;
  _BYTE v6[25];
  __int128 v7;
  _BYTE v8[25];
  __int128 v9;
  _BYTE v10[25];

  memset(v4, 0, 41);
  v7 = 0u;
  memset(v8, 0, sizeof(v8));
  v9 = 0u;
  memset(v10, 0, sizeof(v10));
  v4[3] = 0u;
  v5 = 0u;
  memset(v6, 0, sizeof(v6));
  marisa::grimoire::vector::BitVector::map_((marisa::grimoire::vector::BitVector *)v4, a2);
  marisa::grimoire::vector::BitVector::swap(this, (marisa::grimoire::vector::BitVector *)v4);
  if ((_QWORD)v9)
    MEMORY[0x1D17BC778](v9, 0x1000C8077774924);
  if ((_QWORD)v7)
    MEMORY[0x1D17BC778](v7, 0x1000C8077774924);
  if ((_QWORD)v5)
    MEMORY[0x1D17BC778](v5, 0x1000C8077774924);
  result = *(_QWORD *)&v4[0];
  if (*(_QWORD *)&v4[0])
    return MEMORY[0x1D17BC778](*(_QWORD *)&v4[0], 0x1000C8077774924);
  return result;
}

void sub_1CDF94B70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  marisa::grimoire::vector::BitVector::~BitVector((marisa::grimoire::vector::BitVector *)&a9);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::vector::Vector<unsigned char>::map(__int128 *a1, marisa::grimoire::io::Mapper *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];

  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned char>::map_((uint64_t)v7, a2);
  v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  v4 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v7[1];
  *(_QWORD *)&v7[1] = v4;
  v5 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v7[2]);
  result = v3;
  BYTE8(v7[2]) = v4;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF94C18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::FlatVector::map(marisa::grimoire::vector::FlatVector *this, marisa::grimoire::io::Mapper *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  _OWORD v9[3];
  uint64_t v10;
  int v11;
  uint64_t v12;

  memset(v9, 0, 41);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  marisa::grimoire::vector::FlatVector::map_((marisa::grimoire::vector::FlatVector *)v9, a2);
  v3 = *(_OWORD *)this;
  *(_OWORD *)this = v9[0];
  v9[0] = v3;
  v4 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = *(_QWORD *)&v9[1];
  *(_QWORD *)&v9[1] = v4;
  v5 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)((char *)&v9[1] + 8);
  *(_OWORD *)((char *)&v9[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)this + 40);
  *((_BYTE *)this + 40) = BYTE8(v9[2]);
  BYTE8(v9[2]) = v4;
  v6 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = v10;
  v10 = v6;
  LODWORD(v6) = *((_DWORD *)this + 14);
  *((_DWORD *)this + 14) = v11;
  v11 = v6;
  v7 = *((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = v12;
  result = v3;
  v12 = v7;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF94D10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::map(__int128 *a1, marisa::grimoire::io::Mapper *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];

  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::map_((uint64_t)v7, a2);
  v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  v4 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v7[1];
  *(_QWORD *)&v7[1] = v4;
  v5 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v7[2]);
  result = v3;
  BYTE8(v7[2]) = v4;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF94DCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::BitVector::read(marisa::grimoire::vector::BitVector *this, marisa::grimoire::io::Reader *a2)
{
  uint64_t result;
  _OWORD v4[4];
  __int128 v5;
  _BYTE v6[25];
  __int128 v7;
  _BYTE v8[25];
  __int128 v9;
  _BYTE v10[25];

  memset(v4, 0, 41);
  v7 = 0u;
  memset(v8, 0, sizeof(v8));
  v9 = 0u;
  memset(v10, 0, sizeof(v10));
  v4[3] = 0u;
  v5 = 0u;
  memset(v6, 0, sizeof(v6));
  marisa::grimoire::vector::BitVector::read_((marisa::grimoire::vector::BitVector *)v4, a2);
  marisa::grimoire::vector::BitVector::swap(this, (marisa::grimoire::vector::BitVector *)v4);
  if ((_QWORD)v9)
    MEMORY[0x1D17BC778](v9, 0x1000C8077774924);
  if ((_QWORD)v7)
    MEMORY[0x1D17BC778](v7, 0x1000C8077774924);
  if ((_QWORD)v5)
    MEMORY[0x1D17BC778](v5, 0x1000C8077774924);
  result = *(_QWORD *)&v4[0];
  if (*(_QWORD *)&v4[0])
    return MEMORY[0x1D17BC778](*(_QWORD *)&v4[0], 0x1000C8077774924);
  return result;
}

void sub_1CDF94EC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  marisa::grimoire::vector::BitVector::~BitVector((marisa::grimoire::vector::BitVector *)&a9);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::vector::Vector<unsigned char>::read(__int128 *a1, marisa::grimoire::io::Reader *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];

  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned char>::read_((uint64_t)v7, a2);
  v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  v4 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v7[1];
  *(_QWORD *)&v7[1] = v4;
  v5 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v7[2]);
  result = v3;
  BYTE8(v7[2]) = v4;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF94F70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::FlatVector::read(marisa::grimoire::vector::FlatVector *this, marisa::grimoire::io::Reader *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  _OWORD v9[3];
  uint64_t v10;
  int v11;
  uint64_t v12;

  memset(v9, 0, 41);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  marisa::grimoire::vector::FlatVector::read_((marisa::grimoire::vector::FlatVector *)v9, a2);
  v3 = *(_OWORD *)this;
  *(_OWORD *)this = v9[0];
  v9[0] = v3;
  v4 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = *(_QWORD *)&v9[1];
  *(_QWORD *)&v9[1] = v4;
  v5 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)((char *)&v9[1] + 8);
  *(_OWORD *)((char *)&v9[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)this + 40);
  *((_BYTE *)this + 40) = BYTE8(v9[2]);
  BYTE8(v9[2]) = v4;
  v6 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = v10;
  v10 = v6;
  LODWORD(v6) = *((_DWORD *)this + 14);
  *((_DWORD *)this + 14) = v11;
  v11 = v6;
  v7 = *((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = v12;
  result = v3;
  v12 = v7;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF95068(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::read(__int128 *a1, marisa::grimoire::io::Reader *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];

  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::read_((uint64_t)v7, a2);
  v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  v4 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v7[1];
  *(_QWORD *)&v7[1] = v4;
  v5 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v7[2]);
  result = v3;
  BYTE8(v7[2]) = v4;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF95124(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t *marisa::grimoire::trie::LoudsTrie::restore_(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2, unint64_t a3)
{
  uint64_t *v6;
  marisa::grimoire::vector::BitVector *v7;
  uint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *result;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  marisa::grimoire::trie::LoudsTrie *v23;
  unint64_t v24;
  marisa::grimoire::trie::LoudsTrie *v25;
  char v26;
  char v27;

  v6 = (uint64_t *)*((_QWORD *)a2 + 5);
  v7 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 416);
  v8 = (uint64_t *)((char *)this + 744);
  while (1)
  {
    while (1)
    {
      v9 = *((_QWORD *)this + 132) & a3;
      v10 = *((_QWORD *)this + 128);
      if (a3 != *(_DWORD *)(v10 + 12 * v9 + 4))
        break;
      v11 = v10 + 12 * v9;
      v12 = *(unsigned int *)(v11 + 8);
      if (v12 <= 0xFFFFFEFF)
      {
        v23 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
        if (v23)
          result = (uint64_t *)marisa::grimoire::trie::LoudsTrie::restore_(v23, a2, v12);
        else
          result = marisa::grimoire::trie::Tail::restore(v8, a2, v12);
      }
      else
      {
        v27 = *(_DWORD *)(v11 + 8);
        result = marisa::grimoire::vector::Vector<char>::push_back(v6, &v27);
      }
      a3 = *(unsigned int *)(*((_QWORD *)this + 128) + 12 * v9);
      if (!(_DWORD)a3)
        return result;
    }
    if (((*(_QWORD *)(*((_QWORD *)this + 54) + ((a3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a3) & 1) != 0)
    {
      v14 = *(unsigned __int8 *)(*((_QWORD *)this + 80) + a3);
      v15 = marisa::grimoire::vector::BitVector::rank1(v7, a3);
      v16 = *((_QWORD *)this + 90);
      v17 = (unint64_t)(v16 * v15) >> 6;
      v18 = (v16 * v15) & 0x3F;
      v19 = v18 + v16;
      v20 = *((_QWORD *)this + 86);
      v21 = *(_QWORD *)(v20 + 8 * v17);
      v22 = v19 > 0x40
          ? ((2 * *(_QWORD *)(v20 + 8 * v17 + 8)) << (v18 ^ 0x3Fu)) | (v21 >> v18)
          : v21 >> v18;
      v24 = v14 | ((*((_DWORD *)this + 182) & v22) << 8);
      v25 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
      result = v25
             ? (uint64_t *)marisa::grimoire::trie::LoudsTrie::restore_(v25, a2, v24)
             : marisa::grimoire::trie::Tail::restore(v8, a2, v24);
    }
    else
    {
      v26 = *(_BYTE *)(*((_QWORD *)this + 80) + a3);
      result = marisa::grimoire::vector::Vector<char>::push_back(v6, &v26);
    }
    if (a3 <= *((_QWORD *)this + 133))
      break;
    a3 = marisa::grimoire::vector::BitVector::select1(this, a3) + ~a3;
  }
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::match_(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2, unint64_t a3)
{
  uint64_t v6;
  marisa::grimoire::vector::BitVector *v7;
  marisa::grimoire::trie::Tail *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  marisa::grimoire::trie::LoudsTrie *v24;
  marisa::grimoire::trie::LoudsTrie *v25;
  uint64_t v26;
  uint64_t v27;

  v6 = *((_QWORD *)a2 + 5);
  v7 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 416);
  v8 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 744);
  while (1)
  {
    while (1)
    {
      v9 = *((_QWORD *)this + 132) & a3;
      v10 = *((_QWORD *)this + 128);
      if (a3 == *(_DWORD *)(v10 + 12 * v9 + 4))
        break;
      if (((*(_QWORD *)(*((_QWORD *)this + 54) + ((a3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a3) & 1) != 0)
      {
        v13 = *((_QWORD *)this + 125);
        v14 = *(unsigned __int8 *)(*((_QWORD *)this + 80) + a3);
        v15 = marisa::grimoire::vector::BitVector::rank1(v7, a3);
        v16 = *((_QWORD *)this + 90);
        v17 = (unint64_t)(v16 * v15) >> 6;
        v18 = (v16 * v15) & 0x3F;
        v19 = v18 + v16;
        v20 = *((_QWORD *)this + 86);
        v21 = *(_QWORD *)(v20 + 8 * v17);
        if (v13)
        {
          v22 = v21 >> v18;
          if (v19 > 0x40)
            v22 |= (2 * *(_QWORD *)(v20 + 8 * v17 + 8)) << (v18 ^ 0x3Fu);
          v23 = v14 | ((*((_DWORD *)this + 182) & v22) << 8);
          v24 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
          if (v24)
          {
            if ((marisa::grimoire::trie::LoudsTrie::match_(v24, a2, v23) & 1) == 0)
              return 0;
            goto LABEL_27;
          }
        }
        else
        {
          if (v19 > 0x40)
            v27 = ((2 * *(_QWORD *)(v20 + 8 * v17 + 8)) << (v18 ^ 0x3Fu)) | (v21 >> v18);
          else
            v27 = v21 >> v18;
          v23 = v14 | ((*((_DWORD *)this + 182) & v27) << 8);
        }
        if ((marisa::grimoire::trie::Tail::match(v8, a2, v23) & 1) == 0)
          return 0;
      }
      else
      {
        v26 = *(unsigned int *)(v6 + 100);
        if (*(unsigned __int8 *)(*((_QWORD *)this + 80) + a3) != *(unsigned __int8 *)(*(_QWORD *)a2 + v26))
          return 0;
        *(_DWORD *)(v6 + 100) = v26 + 1;
      }
LABEL_27:
      if (a3 <= *((_QWORD *)this + 133))
        return 1;
      if (*((_QWORD *)a2 + 1) <= (unint64_t)*(unsigned int *)(v6 + 100))
        return 0;
      a3 = marisa::grimoire::vector::BitVector::select1(this, a3) + ~a3;
    }
    v11 = *(unsigned int *)(v10 + 12 * v9 + 8);
    if (v11 <= 0xFFFFFEFF)
    {
      v25 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
      if (v25)
      {
        if ((marisa::grimoire::trie::LoudsTrie::match_(v25, a2, v11) & 1) == 0)
          return 0;
      }
      else if ((marisa::grimoire::trie::Tail::match(v8, a2, v11) & 1) == 0)
      {
        return 0;
      }
    }
    else
    {
      v12 = *(unsigned int *)(v6 + 100);
      if (*(unsigned __int8 *)(*(_QWORD *)a2 + v12) != v11)
        return 0;
      *(_DWORD *)(v6 + 100) = v12 + 1;
    }
    a3 = *(unsigned int *)(*((_QWORD *)this + 128) + 12 * v9);
    if (!(_DWORD)a3)
      return 1;
    if (*((_QWORD *)a2 + 1) <= (unint64_t)*(unsigned int *)(v6 + 100))
      return 0;
  }
}

uint64_t marisa::grimoire::trie::LoudsTrie::prefix_match_(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2, unint64_t a3)
{
  uint64_t v6;
  marisa::grimoire::vector::BitVector *v7;
  marisa::grimoire::trie::Tail *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  marisa::grimoire::trie::LoudsTrie *v21;
  unint64_t v22;
  marisa::grimoire::trie::LoudsTrie *v23;
  char v25;
  char v26;

  v6 = *((_QWORD *)a2 + 5);
  v7 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 416);
  v8 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 744);
  while (1)
  {
    v9 = *((_QWORD *)this + 132) & a3;
    v10 = *((_QWORD *)this + 128);
    if (a3 != *(_DWORD *)(v10 + 12 * v9 + 4))
    {
      v12 = *(unsigned __int8 *)(*((_QWORD *)this + 80) + a3);
      if (((*(_QWORD *)(*((_QWORD *)this + 54) + ((a3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a3) & 1) != 0)
      {
        v13 = marisa::grimoire::vector::BitVector::rank1(v7, a3);
        v14 = *((_QWORD *)this + 90);
        v15 = (unint64_t)(v14 * v13) >> 6;
        v16 = (v14 * v13) & 0x3F;
        v17 = v16 + v14;
        v18 = *((_QWORD *)this + 86);
        v19 = *(_QWORD *)(v18 + 8 * v15);
        if (v17 > 0x40)
          v20 = ((2 * *(_QWORD *)(v18 + 8 * v15 + 8)) << (v16 ^ 0x3Fu)) | (v19 >> v16);
        else
          v20 = v19 >> v16;
        v22 = v12 | ((*((_DWORD *)this + 182) & v20) << 8);
        v23 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
        if (v23)
        {
          if ((marisa::grimoire::trie::LoudsTrie::prefix_match_(v23, a2, v22) & 1) == 0)
            return 0;
        }
        else if (!marisa::grimoire::trie::Tail::prefix_match(v8, a2, v22))
        {
          return 0;
        }
      }
      else
      {
        if (v12 != *(unsigned __int8 *)(*(_QWORD *)a2 + *(unsigned int *)(v6 + 100)))
          return 0;
        v25 = *(_BYTE *)(*((_QWORD *)this + 80) + a3);
        marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v6, &v25);
        ++*(_DWORD *)(v6 + 100);
      }
      if (a3 <= *((_QWORD *)this + 133))
        return 1;
      a3 = marisa::grimoire::vector::BitVector::select1(this, a3) + ~a3;
      goto LABEL_23;
    }
    v11 = *(unsigned int *)(v10 + 12 * v9 + 8);
    if (v11 > 0xFFFFFEFF)
    {
      if (*(unsigned __int8 *)(*(_QWORD *)a2 + *(unsigned int *)(v6 + 100)) != v11)
        return 0;
      v26 = *(_DWORD *)(v10 + 12 * v9 + 8);
      marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v6, &v26);
      ++*(_DWORD *)(v6 + 100);
      goto LABEL_22;
    }
    v21 = (marisa::grimoire::trie::LoudsTrie *)*((_QWORD *)this + 125);
    if (!v21)
      break;
    if ((marisa::grimoire::trie::LoudsTrie::prefix_match_(v21, a2, v11) & 1) == 0)
      return 0;
LABEL_22:
    a3 = *(unsigned int *)(*((_QWORD *)this + 128) + 12 * v9);
    if (!(_DWORD)a3)
      return 1;
LABEL_23:
    if (*((_QWORD *)a2 + 1) <= (unint64_t)*(unsigned int *)(v6 + 100))
    {
      marisa::grimoire::trie::LoudsTrie::restore_(this, a2, a3);
      return 1;
    }
  }
  if (marisa::grimoire::trie::Tail::prefix_match(v8, a2, v11))
    goto LABEL_22;
  return 0;
}

uint64_t marisa::grimoire::trie::Config::parse_(marisa::grimoire::trie::Config *this, unsigned int a2)
{
  _QWORD *exception;

  if (a2 >= 0x100000)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h";
    exception[2] = 0x50000003BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h:59: MARISA_CODE_ERROR:"
                   " (config_flags & ~MARISA_CONFIG_MASK) != 0";
  }
  if ((a2 & 0x7F) != 0)
    *(_QWORD *)this = a2 & 0x7F;
  marisa::grimoire::trie::Config::parse_cache_level((uint64_t)this, a2);
  marisa::grimoire::trie::Config::parse_tail_mode((uint64_t)this, a2);
  return marisa::grimoire::trie::Config::parse_node_order((uint64_t)this, a2);
}

uint64_t marisa::grimoire::trie::Config::parse_cache_level(uint64_t this, __int16 a2)
{
  unsigned int v2;
  int v3;
  _QWORD *exception;

  v2 = a2 & 0xF80;
  v3 = 512;
  if (v2 > 0x1FF)
  {
    if (v2 == 512)
      goto LABEL_11;
    if (v2 != 1024)
    {
      v3 = a2 & 0xF80;
      if (v2 != 2048)
        goto LABEL_9;
      goto LABEL_11;
    }
LABEL_10:
    v3 = a2 & 0xF80;
    goto LABEL_11;
  }
  if ((a2 & 0xF80) == 0)
    goto LABEL_11;
  if (v2 == 128)
    goto LABEL_10;
  v3 = a2 & 0xF80;
  if (v2 != 256)
  {
LABEL_9:
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h";
    exception[2] = 0x500000065;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h:101: MARISA_CODE_ERROR"
                   ": undefined cache level";
  }
LABEL_11:
  *(_DWORD *)(this + 8) = v3;
  return this;
}

uint64_t marisa::grimoire::trie::Config::parse_tail_mode(uint64_t this, __int16 a2)
{
  int v2;
  int v3;
  _QWORD *exception;

  v2 = 4096;
  v3 = a2 & 0xF000;
  if ((a2 & 0xF000) != 0 && v3 != 4096)
  {
    if (v3 != 0x2000)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &off_1E8B57FF8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h";
      exception[2] = 0x500000079;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h:121: MARISA_CODE_ERR"
                     "OR: undefined tail mode";
    }
    v2 = 0x2000;
  }
  *(_DWORD *)(this + 12) = v2;
  return this;
}

uint64_t marisa::grimoire::trie::Config::parse_node_order(uint64_t this, int a2)
{
  int v2;
  int v3;
  _QWORD *exception;

  v2 = 0x20000;
  v3 = a2 & 0xF0000;
  if ((a2 & 0xF0000) != 0 && v3 != 0x20000)
  {
    if (v3 != 0x10000)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &off_1E8B57FF8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h";
      exception[2] = 0x50000008DLL;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h:141: MARISA_CODE_ERR"
                     "OR: undefined node order";
    }
    v2 = 0x10000;
  }
  *(_DWORD *)(this + 16) = v2;
  return this;
}

_BYTE *marisa::grimoire::vector::Vector<char>::realloc(uint64_t *a1, size_t __sz)
{
  _BYTE *result;
  uint64_t v5;
  char *v6;
  _BYTE *v7;
  char v8;
  uint64_t v9;

  result = operator new[](__sz, MEMORY[0x1E0DE4E10]);
  v5 = a1[3];
  if (v5)
  {
    v6 = (char *)a1[1];
    v7 = result;
    do
    {
      v8 = *v6++;
      *v7++ = v8;
      --v5;
    }
    while (v5);
  }
  v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = __sz;
  if (v9)
    JUMPOUT(0x1D17BC778);
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::resize(uint64_t *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _DWORD *v8;

  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 > 0x666666666666666)
      v5 = 0xCCCCCCCCCCCCCCCLL;
    if (v4 > a2 >> 1)
      a2 = v5;
    result = (uint64_t *)marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::realloc(result, a2);
  }
  v6 = v3[3];
  v7 = v2 - v6;
  if (v2 > v6)
  {
    v8 = (_DWORD *)(v3[1] + 20 * v6 + 16);
    do
    {
      *((_OWORD *)v8 - 1) = xmmword_1CDFA8120;
      *v8 = -1;
      v8 += 5;
      --v7;
    }
    while (v7);
  }
  v3[3] = v2;
  return result;
}

_DWORD *marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::realloc(uint64_t *a1, uint64_t a2)
{
  _DWORD *result;
  uint64_t v5;
  __int128 *v6;
  _DWORD *v7;
  __int128 v8;
  uint64_t v9;

  result = operator new[](20 * a2, MEMORY[0x1E0DE4E10]);
  v5 = a1[3];
  if (v5)
  {
    v6 = (__int128 *)a1[1];
    v7 = result;
    do
    {
      v8 = *v6;
      v7[4] = *((_DWORD *)v6 + 4);
      *(_OWORD *)v7 = v8;
      v7 += 5;
      v6 = (__int128 *)((char *)v6 + 20);
      --v5;
    }
    while (v5);
  }
  v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
    JUMPOUT(0x1D17BC778);
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<unsigned long long>::resize(uint64_t *result, unint64_t a2, _QWORD *a3)
{
  unint64_t v4;
  uint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;

  v4 = a2;
  v5 = result;
  v6 = result[4];
  if (v6 < a2)
  {
    v7 = 2 * v6;
    if (v6 >> 60)
      v7 = 0x1FFFFFFFFFFFFFFFLL;
    if (v6 > a2 >> 1)
      a2 = v7;
    result = marisa::grimoire::vector::Vector<unsigned long long>::realloc(result, a2);
  }
  v8 = v5[3];
  v9 = v4 - v8;
  if (v4 > v8)
  {
    v10 = (_QWORD *)(v5[1] + 8 * v8);
    do
    {
      *v10++ = *a3;
      --v9;
    }
    while (v9);
  }
  v5[3] = v4;
  return result;
}

_QWORD *marisa::grimoire::vector::Vector<unsigned long long>::realloc(uint64_t *a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  result = operator new[](8 * a2, MEMORY[0x1E0DE4E10]);
  v5 = a1[3];
  if (v5)
  {
    v6 = (uint64_t *)a1[1];
    v7 = result;
    do
    {
      v8 = *v6++;
      *v7++ = v8;
      --v5;
    }
    while (v5);
  }
  v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
    JUMPOUT(0x1D17BC778);
  return result;
}

_QWORD *marisa::grimoire::vector::Vector<unsigned long long>::shrink(_QWORD *result)
{
  uint64_t v1;
  _QWORD *exception;

  if (*((_BYTE *)result + 40))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0x100000064;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:100: MARISA_"
                   "STATE_ERROR: fixed_";
  }
  v1 = result[3];
  if (v1 != result[4])
    return marisa::grimoire::vector::Vector<unsigned long long>::realloc(result, v1);
  return result;
}

uint64_t marisa::grimoire::vector::BitVector::map_(marisa::grimoire::vector::BitVector *this, marisa::grimoire::io::Mapper *a2)
{
  unint64_t v4;
  _QWORD *exception;

  marisa::grimoire::vector::Vector<unsigned long long>::map((__int128 *)this, a2);
  *((_QWORD *)this + 6) = *(unsigned int *)marisa::grimoire::io::Mapper::map_data(a2, 4uLL);
  v4 = *(unsigned int *)marisa::grimoire::io::Mapper::map_data(a2, 4uLL);
  if (*((_QWORD *)this + 6) < v4)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h";
    exception[2] = 0xA00000087;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h:135: MAR"
                   "ISA_FORMAT_ERROR: temp_num_1s > size_";
  }
  *((_QWORD *)this + 7) = v4;
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::map((__int128 *)this + 4, a2);
  marisa::grimoire::vector::Vector<unsigned int>::map((__int128 *)this + 7, a2);
  return marisa::grimoire::vector::Vector<unsigned int>::map((__int128 *)this + 10, a2);
}

uint64_t marisa::grimoire::vector::Vector<unsigned long long>::map(__int128 *a1, marisa::grimoire::io::Mapper *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];

  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned long long>::map_((uint64_t)v7, a2);
  v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  v4 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v7[1];
  *(_QWORD *)&v7[1] = v4;
  v5 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v7[2]);
  result = v3;
  BYTE8(v7[2]) = v4;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF95DF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::map(__int128 *a1, marisa::grimoire::io::Mapper *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];

  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::map_((uint64_t)v7, a2);
  v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  v4 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v7[1];
  *(_QWORD *)&v7[1] = v4;
  v5 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v7[2]);
  result = v3;
  BYTE8(v7[2]) = v4;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF95EB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<unsigned int>::map(__int128 *a1, marisa::grimoire::io::Mapper *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];

  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned int>::map_((uint64_t)v7, a2);
  v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  v4 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v7[1];
  *(_QWORD *)&v7[1] = v4;
  v5 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v7[2]);
  result = v3;
  BYTE8(v7[2]) = v4;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF95F6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<unsigned long long>::map_(uint64_t a1, marisa::grimoire::io::Mapper *this)
{
  unint64_t v4;
  _QWORD *exception;

  v4 = *(_QWORD *)marisa::grimoire::io::Mapper::map_data(this, 8uLL);
  if ((v4 & 7) != 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000CALL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:202: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  marisa::grimoire::io::Mapper::map<unsigned long long>(this, (uint64_t *)(a1 + 16), v4 >> 3);
  marisa::grimoire::io::Mapper::seek(this, -(int)v4 & 7);
  *(_QWORD *)(a1 + 24) = v4 >> 3;
  return marisa::grimoire::vector::Vector<unsigned long long>::fix(a1);
}

uint64_t marisa::grimoire::io::Mapper::map<unsigned long long>(marisa::grimoire::io::Mapper *a1, uint64_t *a2, unint64_t a3)
{
  uint64_t result;
  _QWORD *exception;
  const char *v6;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h";
    exception[2] = 0x20000001CLL;
    v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h:28: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >> 61)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h";
    exception[2] = 0x70000001ELL;
    v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h:30: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v6;
  }
  result = marisa::grimoire::io::Mapper::map_data(a1, 8 * a3);
  *a2 = result;
  return result;
}

uint64_t marisa::grimoire::vector::Vector<unsigned long long>::fix(uint64_t result)
{
  _QWORD *exception;

  if (*(_BYTE *)(result + 40))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0x10000006BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:107: MARISA_"
                   "STATE_ERROR: fixed_";
  }
  *(_BYTE *)(result + 40) = 1;
  return result;
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::map_(uint64_t a1, marisa::grimoire::io::Mapper *this)
{
  unint64_t v4;
  unint64_t v5;
  _QWORD *exception;

  v4 = *(_QWORD *)marisa::grimoire::io::Mapper::map_data(this, 8uLL);
  v5 = v4 / 0xC;
  if (v4 % 0xC)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000CALL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:202: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  marisa::grimoire::io::Mapper::map<marisa::grimoire::vector::RankIndex>(this, (uint64_t *)(a1 + 16), v5);
  marisa::grimoire::io::Mapper::seek(this, -(int)v4 & 7);
  *(_QWORD *)(a1 + 24) = v5;
  return marisa::grimoire::vector::Vector<unsigned long long>::fix(a1);
}

uint64_t marisa::grimoire::io::Mapper::map<marisa::grimoire::vector::RankIndex>(marisa::grimoire::io::Mapper *a1, uint64_t *a2, unint64_t a3)
{
  uint64_t result;
  _QWORD *exception;
  const char *v6;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h";
    exception[2] = 0x20000001CLL;
    v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h:28: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >= 0x1555555555555556)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h";
    exception[2] = 0x70000001ELL;
    v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h:30: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v6;
  }
  result = marisa::grimoire::io::Mapper::map_data(a1, 12 * a3);
  *a2 = result;
  return result;
}

uint64_t marisa::grimoire::vector::Vector<unsigned int>::map_(uint64_t a1, marisa::grimoire::io::Mapper *this)
{
  unint64_t v4;
  _QWORD *exception;

  v4 = *(_QWORD *)marisa::grimoire::io::Mapper::map_data(this, 8uLL);
  if ((v4 & 3) != 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000CALL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:202: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  marisa::grimoire::io::Mapper::map<unsigned int>(this, (uint64_t *)(a1 + 16), v4 >> 2);
  marisa::grimoire::io::Mapper::seek(this, -(int)v4 & 7);
  *(_QWORD *)(a1 + 24) = v4 >> 2;
  return marisa::grimoire::vector::Vector<unsigned long long>::fix(a1);
}

uint64_t marisa::grimoire::io::Mapper::map<unsigned int>(marisa::grimoire::io::Mapper *a1, uint64_t *a2, unint64_t a3)
{
  uint64_t result;
  _QWORD *exception;
  const char *v6;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h";
    exception[2] = 0x20000001CLL;
    v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h:28: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >> 62)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h";
    exception[2] = 0x70000001ELL;
    v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h:30: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v6;
  }
  result = marisa::grimoire::io::Mapper::map_data(a1, 4 * a3);
  *a2 = result;
  return result;
}

_QWORD *marisa::grimoire::vector::FlatVector::map_(marisa::grimoire::vector::FlatVector *this, marisa::grimoire::io::Mapper *a2)
{
  uint64_t v4;
  _QWORD *result;
  _QWORD *exception;

  marisa::grimoire::vector::Vector<unsigned long long>::map((__int128 *)this, a2);
  v4 = *(unsigned int *)marisa::grimoire::io::Mapper::map_data(a2, 4uLL);
  if (v4 >= 0x21)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/flat-vector.h";
    exception[2] = 0xA00000086;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/flat-vector.h:134: MA"
                   "RISA_FORMAT_ERROR: temp_value_size > 32";
  }
  *((_QWORD *)this + 6) = v4;
  *((_DWORD *)this + 14) = *(_DWORD *)marisa::grimoire::io::Mapper::map_data(a2, 4uLL);
  result = (_QWORD *)marisa::grimoire::io::Mapper::map_data(a2, 8uLL);
  *((_QWORD *)this + 8) = *result;
  return result;
}

uint64_t marisa::grimoire::vector::BitVector::read_(marisa::grimoire::vector::BitVector *this, marisa::grimoire::io::Reader *a2)
{
  _QWORD *exception;
  unsigned int v6;
  unsigned int v7;

  marisa::grimoire::vector::Vector<unsigned long long>::read((__int128 *)this, a2);
  v7 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v7, 4uLL);
  *((_QWORD *)this + 6) = v7;
  v6 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v6, 4uLL);
  if (*((_QWORD *)this + 6) < (unint64_t)v6)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h";
    exception[2] = 0xA00000099;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h:153: MAR"
                   "ISA_FORMAT_ERROR: temp_num_1s > size_";
  }
  *((_QWORD *)this + 7) = v6;
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::read((__int128 *)this + 4, a2);
  marisa::grimoire::vector::Vector<unsigned int>::read((__int128 *)this + 7, a2);
  return marisa::grimoire::vector::Vector<unsigned int>::read((__int128 *)this + 10, a2);
}

uint64_t marisa::grimoire::vector::Vector<unsigned long long>::read(__int128 *a1, marisa::grimoire::io::Reader *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];

  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned long long>::read_((uint64_t)v7, a2);
  v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  v4 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v7[1];
  *(_QWORD *)&v7[1] = v4;
  v5 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v7[2]);
  result = v3;
  BYTE8(v7[2]) = v4;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF96674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::read(__int128 *a1, marisa::grimoire::io::Reader *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];

  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::read_((uint64_t)v7, a2);
  v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  v4 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v7[1];
  *(_QWORD *)&v7[1] = v4;
  v5 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v7[2]);
  result = v3;
  BYTE8(v7[2]) = v4;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF96730(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<unsigned int>::read(__int128 *a1, marisa::grimoire::io::Reader *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];

  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned int>::read_((uint64_t)v7, a2);
  v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  v4 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v7[1];
  *(_QWORD *)&v7[1] = v4;
  v5 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v7[2]);
  result = v3;
  BYTE8(v7[2]) = v4;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF967EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<unsigned long long>::read_(uint64_t a1, marisa::grimoire::io::Reader *this)
{
  unint64_t v4;
  _QWORD *exception;
  unint64_t v7;

  v7 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)this, (char *)&v7, 8uLL);
  if ((v7 & 7) != 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000D5;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:213: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  v4 = v7 >> 3;
  marisa::grimoire::vector::Vector<unsigned long long>::resize((uint64_t *)a1, v7 >> 3);
  marisa::grimoire::io::Reader::read<unsigned long long>((uint64_t)this, *(char **)(a1 + 8), v4);
  return marisa::grimoire::io::Reader::seek((uint64_t)this, -(int)v7 & 7);
}

uint64_t *marisa::grimoire::vector::Vector<unsigned long long>::resize(uint64_t *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 >> 60)
      v5 = 0x1FFFFFFFFFFFFFFFLL;
    if (v4 > a2 >> 1)
      a2 = v5;
    result = marisa::grimoire::vector::Vector<unsigned long long>::realloc(result, a2);
  }
  v3[3] = v2;
  return result;
}

uint64_t marisa::grimoire::io::Reader::read<unsigned long long>(uint64_t a1, char *a2, unint64_t a3)
{
  _QWORD *exception;
  const char *v5;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x20000001FLL;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:31: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >> 61)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x700000021;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:33: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v5;
  }
  return marisa::grimoire::io::Reader::read_data(a1, a2, 8 * a3);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::read_(uint64_t a1, marisa::grimoire::io::Reader *this)
{
  unint64_t v4;
  _QWORD *exception;
  unint64_t v7;

  v7 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)this, (char *)&v7, 8uLL);
  v4 = v7 / 0xC;
  if (v7 % 0xC)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000D5;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:213: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::resize((uint64_t *)a1, v7 / 0xC);
  marisa::grimoire::io::Reader::read<marisa::grimoire::vector::RankIndex>((uint64_t)this, *(char **)(a1 + 8), v4);
  return marisa::grimoire::io::Reader::seek((uint64_t)this, -(int)v7 & 7);
}

void marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::resize(uint64_t *a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;

  v2 = a2;
  v4 = a1[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 > 0xAAAAAAAAAAAAAAALL)
      v5 = 0x1555555555555555;
    if (v4 > a2 >> 1)
      a2 = v5;
    marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::realloc(a1, a2);
  }
  v6 = a1[3];
  if (v2 > v6)
    bzero((void *)(a1[1] + 12 * v6), 12 * (v2 - v6));
  a1[3] = v2;
}

uint64_t marisa::grimoire::io::Reader::read<marisa::grimoire::vector::RankIndex>(uint64_t a1, char *a2, unint64_t a3)
{
  _QWORD *exception;
  const char *v5;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x20000001FLL;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:31: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >= 0x1555555555555556)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x700000021;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:33: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v5;
  }
  return marisa::grimoire::io::Reader::read_data(a1, a2, 12 * a3);
}

_DWORD *marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::realloc(uint64_t *a1, uint64_t a2)
{
  _DWORD *result;
  uint64_t v5;
  uint64_t *v6;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;

  result = operator new[](12 * a2, MEMORY[0x1E0DE4E10]);
  v5 = a1[3];
  if (v5)
  {
    v6 = (uint64_t *)a1[1];
    v7 = result;
    do
    {
      v8 = *v6;
      v7[2] = *((_DWORD *)v6 + 2);
      *(_QWORD *)v7 = v8;
      v7 += 3;
      v6 = (uint64_t *)((char *)v6 + 12);
      --v5;
    }
    while (v5);
  }
  v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
    JUMPOUT(0x1D17BC778);
  return result;
}

uint64_t marisa::grimoire::vector::Vector<unsigned int>::read_(uint64_t a1, marisa::grimoire::io::Reader *this)
{
  unint64_t v4;
  _QWORD *exception;
  unint64_t v7;

  v7 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)this, (char *)&v7, 8uLL);
  if ((v7 & 3) != 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000D5;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:213: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  v4 = v7 >> 2;
  marisa::grimoire::vector::Vector<unsigned int>::resize((uint64_t *)a1, v7 >> 2);
  marisa::grimoire::io::Reader::read<unsigned int>((uint64_t)this, *(char **)(a1 + 8), v4);
  return marisa::grimoire::io::Reader::seek((uint64_t)this, -(int)v7 & 7);
}

uint64_t *marisa::grimoire::vector::Vector<unsigned int>::resize(uint64_t *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v2 = a2;
  v3 = result;
  v4 = result[4];
  if (v4 < a2)
  {
    v5 = 2 * v4;
    if (v4 >> 61)
      v5 = 0x3FFFFFFFFFFFFFFFLL;
    if (v4 > a2 >> 1)
      a2 = v5;
    result = (uint64_t *)marisa::grimoire::vector::Vector<unsigned int>::realloc(result, a2);
  }
  v3[3] = v2;
  return result;
}

uint64_t marisa::grimoire::io::Reader::read<unsigned int>(uint64_t a1, char *a2, unint64_t a3)
{
  _QWORD *exception;
  const char *v5;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x20000001FLL;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:31: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >> 62)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x700000021;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:33: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v5;
  }
  return marisa::grimoire::io::Reader::read_data(a1, a2, 4 * a3);
}

_DWORD *marisa::grimoire::vector::Vector<unsigned int>::realloc(uint64_t *a1, uint64_t a2)
{
  _DWORD *result;
  uint64_t v5;
  int *v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;

  result = operator new[](4 * a2, MEMORY[0x1E0DE4E10]);
  v5 = a1[3];
  if (v5)
  {
    v6 = (int *)a1[1];
    v7 = result;
    do
    {
      v8 = *v6++;
      *v7++ = v8;
      --v5;
    }
    while (v5);
  }
  v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
    JUMPOUT(0x1D17BC778);
  return result;
}

uint64_t marisa::grimoire::vector::FlatVector::read_(marisa::grimoire::vector::FlatVector *this, marisa::grimoire::io::Reader *a2)
{
  uint64_t result;
  _QWORD *exception;
  uint64_t v6;

  marisa::grimoire::vector::Vector<unsigned long long>::read((__int128 *)this, a2);
  LODWORD(v6) = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v6, 4uLL);
  if (v6 >= 0x21)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/flat-vector.h";
    exception[2] = 0xA0000009BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/flat-vector.h:155: MA"
                   "RISA_FORMAT_ERROR: temp_value_size > 32";
  }
  *((_QWORD *)this + 6) = v6;
  LODWORD(v6) = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v6, 4uLL);
  *((_DWORD *)this + 14) = v6;
  v6 = 0;
  result = marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v6, 8uLL);
  *((_QWORD *)this + 8) = v6;
  return result;
}

uint64_t marisa::grimoire::vector::BitVector::write_(marisa::grimoire::vector::BitVector *this, marisa::grimoire::io::Writer *a2)
{
  int v5;
  int __buf;

  marisa::grimoire::vector::Vector<unsigned long long>::write_((uint64_t)this, a2);
  __buf = *((_QWORD *)this + 6);
  marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&__buf, 4uLL);
  v5 = *((_QWORD *)this + 7);
  marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&v5, 4uLL);
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::write_((uint64_t)this + 64, a2);
  marisa::grimoire::vector::Vector<unsigned int>::write_((uint64_t)this + 112, a2);
  return marisa::grimoire::vector::Vector<unsigned int>::write_((uint64_t)this + 160, a2);
}

uint64_t marisa::grimoire::vector::Vector<unsigned long long>::write_(uint64_t a1, marisa::grimoire::io::Writer *this)
{
  uint64_t __buf;

  __buf = 8 * *(_QWORD *)(a1 + 24);
  marisa::grimoire::io::Writer::write_data((uint64_t)this, (char *)&__buf, 8uLL);
  marisa::grimoire::io::Writer::write<unsigned long long>((uint64_t)this, *(char **)(a1 + 16), *(_QWORD *)(a1 + 24));
  return marisa::grimoire::io::Writer::seek((uint64_t)this, 0);
}

uint64_t marisa::grimoire::io::Writer::write<unsigned long long>(uint64_t a1, char *a2, unint64_t a3)
{
  _QWORD *exception;
  const char *v5;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x20000001ELL;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:30: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >> 61)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x700000020;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:32: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v5;
  }
  return marisa::grimoire::io::Writer::write_data(a1, a2, 8 * a3);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::write_(uint64_t a1, marisa::grimoire::io::Writer *this)
{
  uint64_t __buf;

  __buf = 12 * *(_QWORD *)(a1 + 24);
  marisa::grimoire::io::Writer::write_data((uint64_t)this, (char *)&__buf, 8uLL);
  marisa::grimoire::io::Writer::write<marisa::grimoire::vector::RankIndex>((uint64_t)this, *(char **)(a1 + 16), *(_QWORD *)(a1 + 24));
  return marisa::grimoire::io::Writer::seek((uint64_t)this, 4 * (*(_DWORD *)(a1 + 24) & 1));
}

uint64_t marisa::grimoire::io::Writer::write<marisa::grimoire::vector::RankIndex>(uint64_t a1, char *a2, unint64_t a3)
{
  _QWORD *exception;
  const char *v5;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x20000001ELL;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:30: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >= 0x1555555555555556)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x700000020;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:32: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v5;
  }
  return marisa::grimoire::io::Writer::write_data(a1, a2, 12 * a3);
}

uint64_t marisa::grimoire::vector::Vector<unsigned int>::write_(uint64_t a1, marisa::grimoire::io::Writer *this)
{
  uint64_t __buf;

  __buf = 4 * *(_QWORD *)(a1 + 24);
  marisa::grimoire::io::Writer::write_data((uint64_t)this, (char *)&__buf, 8uLL);
  marisa::grimoire::io::Writer::write<unsigned int>((uint64_t)this, *(char **)(a1 + 16), *(_QWORD *)(a1 + 24));
  return marisa::grimoire::io::Writer::seek((uint64_t)this, 4 * (*(_DWORD *)(a1 + 24) & 1));
}

uint64_t marisa::grimoire::io::Writer::write<unsigned int>(uint64_t a1, char *a2, unint64_t a3)
{
  _QWORD *exception;
  const char *v5;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x20000001ELL;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:30: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >> 62)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x700000020;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:32: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v5;
  }
  return marisa::grimoire::io::Writer::write_data(a1, a2, 4 * a3);
}

uint64_t marisa::grimoire::vector::FlatVector::write_(marisa::grimoire::vector::FlatVector *this, marisa::grimoire::io::Writer *a2)
{
  uint64_t __buf;

  marisa::grimoire::vector::Vector<unsigned long long>::write_((uint64_t)this, a2);
  LODWORD(__buf) = *((_QWORD *)this + 6);
  marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&__buf, 4uLL);
  LODWORD(__buf) = *((_DWORD *)this + 14);
  marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&__buf, 4uLL);
  __buf = *((_QWORD *)this + 8);
  return marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&__buf, 8uLL);
}

marisa::grimoire::trie::LoudsTrie **marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(marisa::grimoire::trie::LoudsTrie **a1)
{
  marisa::grimoire::trie::LoudsTrie *v2;

  v2 = *a1;
  if (v2)
  {
    marisa::grimoire::trie::LoudsTrie::~LoudsTrie(v2);
    MEMORY[0x1D17BC79C]();
  }
  return a1;
}

char *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::realloc(uint64_t *a1, uint64_t a2)
{
  char *result;
  uint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;

  result = (char *)operator new[](24 * a2, MEMORY[0x1E0DE4E10]);
  v5 = a1[3];
  if (v5)
  {
    v6 = (_DWORD *)(a1[1] + 16);
    v7 = result + 16;
    do
    {
      *((_QWORD *)v7 - 2) = *((_QWORD *)v6 - 2);
      *(v7 - 2) = *(v6 - 2);
      *(v7 - 1) = *(v6 - 1);
      v8 = *v6;
      v6 += 6;
      *v7 = v8;
      v7 += 6;
      --v5;
    }
    while (v5);
  }
  v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
    JUMPOUT(0x1D17BC778);
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_current_trie<marisa::grimoire::trie::Key>(uint64_t *a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  __n128 v34;
  uint64_t v35;
  __n128 *v36;
  unint64_t v37;
  __n128 *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unsigned int *v43;
  uint64_t *v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unsigned __int32 *v57;
  float v58;
  float v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  float *v63;
  float v64;
  uint64_t v65;
  _DWORD *v66;
  uint64_t v67;
  __int128 v68;
  uint64_t v69;
  __int128 v70;
  uint64_t result;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v75;
  uint64_t v76;
  uint64_t *v77;
  __n128 v78;
  int v79;
  __int128 v80;
  uint64_t v81[4];
  _OWORD v82[2];
  __int128 v83;
  _OWORD v84[4];

  v9 = *(_QWORD *)(a2 + 24);
  v10 = *(_QWORD *)(a2 + 8);
  if (v9)
  {
    v11 = 0;
    v12 = (_DWORD *)(v10 + 16);
    do
    {
      *v12 = v11;
      v12 += 6;
      ++v11;
    }
    while (v9 != v11);
  }
  v13 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v10, v10 + 24 * v9, 0);
  v14 = 256;
  if (a5 != 1)
    v14 = 1;
  do
  {
    v15 = v14;
    v14 *= 2;
  }
  while (v15 < v13 / *(unsigned int *)(a4 + 8));
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::resize(a1 + 126, v15);
  a1[132] = v15 - 1;
  marisa::grimoire::vector::BitVector::push_back(a1, 1);
  marisa::grimoire::vector::BitVector::push_back(a1, 0);
  v16 = a1 + 78;
  LOBYTE(v84[0]) = 0;
  marisa::grimoire::vector::Vector<char>::push_back(a1 + 78, v84);
  v77 = a1 + 52;
  marisa::grimoire::vector::BitVector::push_back(a1 + 52, 0);
  v72 = a5;
  memset(v84, 0, 41);
  v83 = 0u;
  memset(v82, 0, sizeof(v82));
  v80 = 0u;
  memset(v81, 0, 25);
  v78.n128_u64[0] = *(_QWORD *)(a2 + 24) << 32;
  v78.n128_u32[2] = 0;
  std::deque<marisa::grimoire::trie::Range>::push_back(v82, (uint64_t *)&v78);
  v17 = *((_QWORD *)&v83 + 1);
  if (*((_QWORD *)&v83 + 1))
  {
    v73 = a1 + 78;
    do
    {
      v18 = a1[58];
      v19 = (unsigned int *)(*(_QWORD *)(*((_QWORD *)&v82[0] + 1) + 8 * ((unint64_t)v83 / 0x155))
                           + 12 * ((unint64_t)v83 % 0x155));
      v20 = *v19;
      v21 = v19[1];
      v22 = v19[2];
      *(_QWORD *)&v83 = v83 + 1;
      *((_QWORD *)&v83 + 1) = v17 - 1;
      if ((unint64_t)v83 >= 0x2AA)
      {
        v23 = v18;
        operator delete(**((void ***)&v82[0] + 1));
        v18 = v23;
        *((_QWORD *)&v82[0] + 1) += 8;
        *(_QWORD *)&v83 = v83 - 341;
      }
      v76 = v17;
      v24 = v18 - v17;
      if (v20 < v21)
      {
        while (1)
        {
          v25 = *(_QWORD *)(a2 + 8);
          if (*(_DWORD *)(v25 + 24 * v20 + 8) != (_DWORD)v22)
            break;
          *(_DWORD *)(v25 + 24 * v20 + 12) = v24;
          v20 = (v20 + 1);
          if ((_DWORD)v21 == (_DWORD)v20)
            goto LABEL_49;
        }
      }
      if ((_DWORD)v20 != (_DWORD)v21)
      {
        v75 = v18;
        v26 = v80;
        v80 = 0u;
        memset(v81, 0, 25);
        if (v26)
          MEMORY[0x1D17BC778](v26, 0x1000C8077774924);
        v27 = *(_QWORD *)(a2 + 8);
        v28 = *(float *)(v27 + 24 * v20 + 12);
        v29 = v20 + 1;
        if (v20 + 1 < v21)
        {
          v30 = 24 * v20;
          v31 = (v20 << 32) + 0x100000000;
          do
          {
            if (*(unsigned __int8 *)(*(_QWORD *)(v27 + v30) + v22) != *(unsigned __int8 *)(*(_QWORD *)(v27 + v30 + 24)
                                                                                          + v22))
            {
              *(float *)&v32 = v28;
              v78.n128_u64[0] = v31 + v20;
              v78.n128_u64[1] = v22 | ((unint64_t)v32 << 32);
              marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back((uint64_t *)&v80, &v78);
              v27 = *(_QWORD *)(a2 + 8);
              v28 = 0.0;
              LODWORD(v20) = v29;
            }
            v28 = v28 + *(float *)(v27 + v30 + 36);
            ++v29;
            v30 += 24;
            v31 += 0x100000000;
          }
          while (v21 != v29);
        }
        *(float *)&v33 = v28;
        v78.n128_u32[0] = v20;
        v78.n128_u32[1] = v21;
        v78.n128_u64[1] = v22 | ((unint64_t)v33 << 32);
        v34 = marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back((uint64_t *)&v80, &v78);
        v16 = a1 + 78;
        v35 = v75;
        if (*(_DWORD *)(a4 + 16) == 0x20000)
        {
          v36 = (__n128 *)*((_QWORD *)&v80 + 1);
          v37 = v81[1];
          if (v81[1] < 129)
          {
            v38 = 0;
            v40 = 0;
          }
          else
          {
            v38 = (__n128 *)std::get_temporary_buffer[abi:ne180100]<marisa::grimoire::trie::WeightedRange>(v81[1]);
            v40 = v39;
          }
          std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(v36, &v36[v37], (uint64_t)&v78, v37, v38, v40, v34);
          if (v38)
            operator delete(v38);
          v35 = v75;
        }
        v41 = v81[1];
        if (v35 == v76)
          a1[133] = v81[1];
        if (v41)
        {
          v42 = 0;
          do
          {
            v43 = (unsigned int *)(*((_QWORD *)&v80 + 1) + 16 * v42);
            v44 = (uint64_t *)v43;
            v45 = v43[2];
            v46 = *v43;
            v47 = *(_QWORD *)(a2 + 8);
            v48 = *(unsigned int *)(v47 + 24 * *v43 + 8);
            v49 = v45 + 1;
            if (v45 + 1 >= v48)
            {
              v50 = v43[2];
              LODWORD(v48) = v45 + 1;
            }
            else
            {
              v50 = v48 - 1;
              v51 = v43[2];
              do
              {
                v52 = v51;
                v51 = v49;
                v53 = (uint64_t *)(v47 + 24 * v46);
                v54 = *v43;
                while (++v54 < (unint64_t)v43[1])
                {
                  v55 = *v53;
                  v56 = v53[3];
                  v53 += 3;
                  if (*(unsigned __int8 *)(v55 + v51) != *(unsigned __int8 *)(v56 + v51))
                  {
                    v50 = v52;
                    LODWORD(v48) = v51;
                    goto LABEL_43;
                  }
                }
                v49 = v51 + 1;
              }
              while (v51 + 1 != v48);
            }
LABEL_43:
            v58 = *((float *)v43 + 3);
            v57 = v43 + 3;
            v59 = v58;
            v60 = ((32 * v24) ^ v24 ^ *(unsigned __int8 *)(*(_QWORD *)(v47 + 24 * v46) + v45)) & a1[132];
            v61 = a1[127];
            v62 = v61 + 12 * v60;
            v64 = *(float *)(v62 + 8);
            v63 = (float *)(v62 + 8);
            if (v64 < v59)
            {
              v65 = a1[81];
              v66 = (_DWORD *)(v61 + 12 * v60);
              *v66 = v24;
              v66[1] = v65;
              *v63 = v59;
              v45 = *((unsigned int *)v44 + 2);
            }
            if (v50 == v45)
            {
              v78.n128_u8[0] = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 24 * *(unsigned int *)v44) + v50);
              marisa::grimoire::vector::Vector<char>::push_back(v73, &v78);
              marisa::grimoire::vector::BitVector::push_back(v77, 0);
            }
            else
            {
              v78.n128_u8[0] = 0;
              marisa::grimoire::vector::Vector<char>::push_back(v73, &v78);
              marisa::grimoire::vector::BitVector::push_back(v77, 1);
              v78 = 0uLL;
              v79 = 0;
              v67 = *((unsigned int *)v44 + 2);
              v78.n128_u64[0] = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 24 * *(unsigned int *)v44) + v67;
              v78.n128_u64[1] = (v48 - v67);
              v78.n128_u32[3] = *v57;
              marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::push_back((uint64_t *)v84, (uint64_t)&v78);
            }
            *((_DWORD *)v44 + 2) = v48;
            std::deque<marisa::grimoire::trie::Range>::push_back(v82, v44);
            marisa::grimoire::vector::BitVector::push_back(a1, 1);
            ++v42;
          }
          while (v42 < v81[1]);
        }
      }
LABEL_49:
      marisa::grimoire::vector::BitVector::push_back(a1, 0);
      v17 = *((_QWORD *)&v83 + 1);
    }
    while (*((_QWORD *)&v83 + 1));
  }
  marisa::grimoire::vector::BitVector::push_back(a1, 0);
  marisa::grimoire::vector::BitVector::build((marisa::grimoire::vector::BitVector *)a1, v72 == 1, 1);
  marisa::grimoire::vector::Vector<unsigned char>::shrink(v16);
  marisa::grimoire::trie::LoudsTrie::build_terminals<marisa::grimoire::trie::Key>((uint64_t)a1, a2, a3);
  v68 = *(_OWORD *)a2;
  *(_OWORD *)a2 = v84[0];
  v84[0] = v68;
  v69 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)&v84[1];
  *(_QWORD *)&v84[1] = v69;
  v70 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)((char *)&v84[1] + 8);
  *(_OWORD *)((char *)&v84[1] + 8) = v70;
  LOBYTE(v69) = *(_BYTE *)(a2 + 40);
  *(_BYTE *)(a2 + 40) = BYTE8(v84[2]);
  BYTE8(v84[2]) = v69;
  if ((_QWORD)v80)
    MEMORY[0x1D17BC778](v80, 0x1000C8077774924);
  std::deque<marisa::grimoire::trie::Range>::~deque[abi:ne180100](v82);
  result = *(_QWORD *)&v84[0];
  if (*(_QWORD *)&v84[0])
    return MEMORY[0x1D17BC778](*(_QWORD *)&v84[0], 0x1000C8077774924);
  return result;
}

void sub_1CDF97AB4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, ...)
{
  uint64_t v18;
  uint64_t v21;
  _QWORD *exception;
  va_list va;

  va_start(va, a18);
  if (a13)
    MEMORY[0x1D17BC778](a13, 0x1000C8077774924);
  std::deque<marisa::grimoire::trie::Range>::~deque[abi:ne180100]((uint64_t *)va);
  v21 = *(_QWORD *)(v18 - 144);
  if (v21)
    MEMORY[0x1D17BC778](v21, 0x1000C8077774924);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
    exception[2] = 0x8000001ACLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:428: MARISA_MEMOR"
                   "Y_ERROR: std::bad_alloc";
  }
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::vector::FlatVector::build(__int128 *a1, uint64_t a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  _OWORD v9[3];
  uint64_t v10;
  int v11;
  uint64_t v12;

  memset(v9, 0, 41);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  marisa::grimoire::vector::FlatVector::build_((uint64_t)v9, a2);
  v3 = *a1;
  *a1 = v9[0];
  v9[0] = v3;
  v4 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v9[1];
  *(_QWORD *)&v9[1] = v4;
  v5 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v9[1] + 8);
  *(_OWORD *)((char *)&v9[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v9[2]);
  BYTE8(v9[2]) = v4;
  v6 = *((_QWORD *)a1 + 6);
  *((_QWORD *)a1 + 6) = v10;
  v10 = v6;
  LODWORD(v6) = *((_DWORD *)a1 + 14);
  *((_DWORD *)a1 + 14) = v11;
  v11 = v6;
  v7 = *((_QWORD *)a1 + 8);
  *((_QWORD *)a1 + 8) = v12;
  result = v3;
  v12 = v7;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF97C8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

__n128 marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back(uint64_t *a1, __n128 *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __n128 result;

  v4 = a1[3];
  v5 = a1[4];
  v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    v7 = 2 * v5;
    if (v5 >> 59)
      v7 = 0xFFFFFFFFFFFFFFFLL;
    if (v5 <= v6 >> 1)
      v8 = v6;
    else
      v8 = v7;
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::realloc(a1, v8);
    v4 = a1[3];
  }
  result = *a2;
  *(__n128 *)(a1[1] + 16 * v4) = *a2;
  ++a1[3];
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::push_back(uint64_t *result, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = result;
  v4 = result[3];
  v5 = result[4];
  v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    v7 = 2 * v5;
    if (v5 > 0x555555555555555)
      v7 = 0xAAAAAAAAAAAAAAALL;
    if (v5 <= v6 >> 1)
      v8 = v6;
    else
      v8 = v7;
    result = (uint64_t *)marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::realloc(result, v8);
    v4 = v3[3];
  }
  v9 = v3[1] + 24 * v4;
  *(_QWORD *)v9 = *(_QWORD *)a2;
  *(_DWORD *)(v9 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(v9 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(v9 + 16) = *(_DWORD *)(a2 + 16);
  ++v3[3];
  return result;
}

_BYTE *marisa::grimoire::vector::Vector<unsigned char>::shrink(_BYTE *result)
{
  size_t v1;
  _QWORD *exception;

  if (result[40])
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0x100000064;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:100: MARISA_"
                   "STATE_ERROR: fixed_";
  }
  v1 = *((_QWORD *)result + 3);
  if (v1 != *((_QWORD *)result + 4))
    return marisa::grimoire::vector::Vector<char>::realloc((uint64_t *)result, v1);
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_terminals<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t result;
  _OWORD v13[3];

  memset(v13, 0, 41);
  marisa::grimoire::vector::Vector<unsigned int>::resize((uint64_t *)v13, *(_QWORD *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 24);
  if (v5)
  {
    v6 = *((_QWORD *)&v13[0] + 1);
    v7 = (unsigned int *)(*(_QWORD *)(a2 + 16) + 16);
    do
    {
      *(_DWORD *)(v6 + 4 * *v7) = *(v7 - 1);
      v7 += 6;
      --v5;
    }
    while (v5);
  }
  else
  {
    v6 = *((_QWORD *)&v13[0] + 1);
  }
  v8 = *a3;
  v9 = *(_QWORD *)&v13[1];
  *(_QWORD *)a3 = *(_QWORD *)&v13[0];
  *((_QWORD *)a3 + 1) = v6;
  v13[0] = v8;
  v10 = *((_QWORD *)a3 + 2);
  *((_QWORD *)a3 + 2) = v9;
  *(_QWORD *)&v13[1] = v10;
  v11 = *(__int128 *)((char *)a3 + 24);
  *(__int128 *)((char *)a3 + 24) = *(_OWORD *)((char *)&v13[1] + 8);
  *(_OWORD *)((char *)&v13[1] + 8) = v11;
  LOBYTE(v10) = *((_BYTE *)a3 + 40);
  *((_BYTE *)a3 + 40) = BYTE8(v13[2]);
  result = v8;
  BYTE8(v13[2]) = v10;
  if ((_QWORD)v8)
    return MEMORY[0x1D17BC778](v8, 0x1000C8077774924);
  return result;
}

void sub_1CDF97EFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int64_t v37;
  uint64_t v38;
  int64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v44;

  v4 = a2;
  v5 = a1;
  v6 = a2 - a1;
  if ((uint64_t)(a2 - a1) < 241)
  {
    v7 = 0;
    goto LABEL_69;
  }
  v7 = 0;
  do
  {
    v8 = marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::Key>(v5, v5 + 24 * (v6 / 0x30uLL), v4 - 24, a3);
    v9 = v8;
    v10 = v5;
    v11 = v4;
    v12 = v5;
    v13 = v4;
    while (v10 < v11)
    {
      v14 = *(unsigned int *)(v10 + 8);
      v15 = a3 >= v14 ? -1 : *(unsigned __int8 *)(*(_QWORD *)v10 + a3);
      if (v15 > v8)
        break;
      if (v15 == v8)
      {
        v16 = *(_QWORD *)v10;
        *(_QWORD *)v10 = *(_QWORD *)v12;
        *(_DWORD *)(v10 + 8) = *(_DWORD *)(v12 + 8);
        v17 = *(_QWORD *)(v10 + 12);
        *(_DWORD *)(v10 + 12) = *(_DWORD *)(v12 + 12);
        *(_DWORD *)(v10 + 16) = *(_DWORD *)(v12 + 16);
        *(_QWORD *)v12 = v16;
        *(_DWORD *)(v12 + 8) = v14;
        *(_QWORD *)(v12 + 12) = v17;
        v12 += 24;
      }
LABEL_11:
      v10 += 24;
    }
    if (v10 < v11)
    {
      v18 = v11 - 24;
      do
      {
        v11 = v18;
        v19 = *(unsigned int *)(v18 + 8);
        if (a3 >= v19)
          v20 = -1;
        else
          v20 = *(unsigned __int8 *)(*(_QWORD *)v11 + a3);
        if (v20 < v8)
          break;
        if (v20 == v8)
        {
          v21 = *(_QWORD *)(v13 - 24);
          v13 -= 24;
          v22 = *(_QWORD *)v11;
          *(_QWORD *)v11 = v21;
          *(_DWORD *)(v11 + 8) = *(_DWORD *)(v13 + 8);
          v23 = *(_QWORD *)(v11 + 12);
          *(_DWORD *)(v11 + 12) = *(_DWORD *)(v13 + 12);
          *(_DWORD *)(v11 + 16) = *(_DWORD *)(v13 + 16);
          *(_QWORD *)v13 = v22;
          *(_DWORD *)(v13 + 8) = v19;
          *(_QWORD *)(v13 + 12) = v23;
        }
        v18 = v11 - 24;
      }
      while (v10 < v11);
    }
    if (v10 < v11)
    {
      v24 = *(_QWORD *)v10;
      v25 = *(_DWORD *)(v10 + 16);
      *(_QWORD *)v10 = *(_QWORD *)v11;
      v26 = *(_QWORD *)(v10 + 8);
      *(_DWORD *)(v10 + 8) = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v10 + 12) = *(_DWORD *)(v11 + 12);
      *(_DWORD *)(v10 + 16) = *(_DWORD *)(v11 + 16);
      *(_QWORD *)v11 = v24;
      *(_QWORD *)(v11 + 8) = v26;
      *(_DWORD *)(v11 + 16) = v25;
      goto LABEL_11;
    }
    v44 = v7;
    if (v12 > v5)
    {
      v27 = 0;
      do
      {
        v28 = v12 + v27;
        v29 = v10 + v27;
        v30 = *(_QWORD *)(v12 + v27 - 24);
        v31 = *(_DWORD *)(v12 + v27 - 8);
        *(_QWORD *)(v28 - 24) = *(_QWORD *)(v10 + v27 - 24);
        v32 = *(_QWORD *)(v12 + v27 - 16);
        *(_DWORD *)(v28 - 16) = *(_DWORD *)(v10 + v27 - 16);
        *(_DWORD *)(v28 - 12) = *(_DWORD *)(v10 + v27 - 12);
        *(_DWORD *)(v28 - 8) = *(_DWORD *)(v10 + v27 - 8);
        *(_QWORD *)(v29 - 24) = v30;
        *(_QWORD *)(v29 - 16) = v32;
        *(_DWORD *)(v29 - 8) = v31;
        v27 -= 24;
      }
      while (v12 + v27 > v5);
      v10 += v27;
    }
    while (v13 < v4)
    {
      v33 = *(_QWORD *)v13;
      v34 = *(_DWORD *)(v13 + 16);
      *(_QWORD *)v13 = *(_QWORD *)v11;
      v35 = *(_QWORD *)(v13 + 8);
      *(_DWORD *)(v13 + 8) = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v13 + 12) = *(_DWORD *)(v11 + 12);
      *(_DWORD *)(v13 + 16) = *(_DWORD *)(v11 + 16);
      *(_QWORD *)v11 = v33;
      *(_QWORD *)(v11 + 8) = v35;
      *(_DWORD *)(v11 + 16) = v34;
      v11 += 24;
      v13 += 24;
    }
    v36 = v10 - v5;
    v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v5) >> 3);
    v38 = v11 - v10;
    v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v10) >> 3);
    if (v37 <= v39)
    {
      v40 = v4 - v11;
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v11) >> 3)) <= v39)
      {
        if (v36 == 24)
        {
          v41 = v44 + 1;
        }
        else
        {
          if (v36 < 25)
            goto LABEL_53;
          v41 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v5, v10, a3) + v44;
        }
        v44 = v41;
LABEL_53:
        if (v40 == 24)
        {
          v7 = v44 + 1;
        }
        else if (v40 < 25)
        {
          v7 = v44;
        }
        else
        {
          v7 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v11, v4, a3) + v44;
        }
        if (v38 == 24)
        {
          ++v7;
        }
        else if (v38 >= 25)
        {
          if (v9 == -1)
          {
            ++v7;
            v5 = v11;
            goto LABEL_64;
          }
          ++a3;
        }
        v5 = v10;
LABEL_64:
        v4 = v11;
        goto LABEL_65;
      }
    }
    if (v38 == 24)
      goto LABEL_32;
    if (v38 < 25)
    {
      v7 = v44;
    }
    else if (v8 == -1)
    {
LABEL_32:
      v7 = v44 + 1;
    }
    else
    {
      v7 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v10, v11, a3 + 1) + v44;
    }
    v42 = v4 - v11;
    if (v37 >= (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v11) >> 3)))
    {
      if (v42 == 24)
      {
        ++v7;
      }
      else if (v42 >= 25)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v11, v4, a3);
      }
      v4 = v10;
    }
    else
    {
      if (v36 == 24)
      {
        ++v7;
      }
      else if (v36 >= 25)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v5, v10, a3);
      }
      v5 = v11;
    }
LABEL_65:
    v6 = v4 - v5;
  }
  while ((uint64_t)(v4 - v5) > 240);
LABEL_69:
  if (v6 >= 25)
    v7 += marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::Key *>(v5, v4, a3);
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;

  if (*(unsigned int *)(a1 + 8) <= a4)
    v4 = -1;
  else
    v4 = *(unsigned __int8 *)(*(_QWORD *)a1 + a4);
  if (*(unsigned int *)(a2 + 8) <= a4)
    v5 = -1;
  else
    v5 = *(unsigned __int8 *)(*(_QWORD *)a2 + a4);
  if (*(unsigned int *)(a3 + 8) <= a4)
    v6 = -1;
  else
    v6 = *(unsigned __int8 *)(*(_QWORD *)a3 + a4);
  if (v4 <= v5)
    v7 = v5;
  else
    v7 = v4;
  if (v4 >= v5)
    v4 = v5;
  if (v4 <= v6)
    v4 = v6;
  if (v7 >= v6)
    return v4;
  else
    return v7;
}

uint64_t marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::Key *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;

  v3 = a1 + 24;
  if (a1 + 24 >= a2)
    return 1;
  v7 = 1;
  do
  {
    v8 = v3;
    if (v3 <= a1)
    {
      v10 = 0;
    }
    else
    {
      while (1)
      {
        v9 = v8 - 24;
        v10 = marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::Key>(v8 - 24, v8, a3);
        if (v10 < 1)
          break;
        v11 = *(_QWORD *)(v8 - 24);
        v12 = *(_DWORD *)(v8 - 8);
        *(_QWORD *)(v8 - 24) = *(_QWORD *)v8;
        v13 = *(_QWORD *)(v8 + 8);
        *(_DWORD *)(v8 - 8) = *(_DWORD *)(v8 + 16);
        *(_QWORD *)v8 = v11;
        v14 = *(_QWORD *)(v8 - 16);
        *(_QWORD *)(v8 - 16) = v13;
        *(_QWORD *)(v8 + 8) = v14;
        *(_DWORD *)(v8 + 16) = v12;
        v8 -= 24;
        if (v9 <= a1)
        {
          v10 = 1;
          break;
        }
      }
    }
    if (v10)
      ++v7;
    v3 += 24;
  }
  while (v3 < a2);
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  int v9;
  int v10;
  uint64_t result;
  unsigned int v12;

  v3 = *(unsigned int *)(a1 + 8);
  v4 = *(unsigned int *)(a2 + 8);
  v5 = v3 - a3;
  if (v3 <= a3)
  {
LABEL_6:
    if (v3 < v4)
      v12 = -1;
    else
      v12 = 1;
    if ((_DWORD)v3 == (_DWORD)v4)
      return 0;
    else
      return v12;
  }
  else
  {
    v6 = v4 - a3;
    v7 = (unsigned __int8 *)(*(_QWORD *)a1 + a3);
    v8 = (unsigned __int8 *)(*(_QWORD *)a2 + a3);
    while (v6)
    {
      v9 = *v7;
      v10 = *v8;
      result = (v9 - v10);
      if (v9 != v10)
        return result;
      --v6;
      ++v7;
      ++v8;
      if (!--v5)
        goto LABEL_6;
    }
    return 1;
  }
}

void std::deque<marisa::grimoire::trie::Range>::push_back(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;

  v4 = a1[2];
  v5 = a1[1];
  v6 = 341 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5)
    v6 = 0;
  v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<marisa::grimoire::trie::Range>::__add_back_capacity(a1);
    v5 = a1[1];
    v7 = a1[5] + a1[4];
  }
  v8 = *(_QWORD *)(v5 + 8 * (v7 / 0x155)) + 12 * (v7 % 0x155);
  v9 = *a2;
  *(_DWORD *)(v8 + 8) = *((_DWORD *)a2 + 2);
  *(_QWORD *)v8 = v9;
  ++a1[5];
}

void std::deque<marisa::grimoire::trie::Range>::__add_back_capacity(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  _QWORD *v56;

  v2 = a1[4];
  v3 = v2 >= 0x155;
  v4 = v2 - 341;
  if (v3)
  {
    v5 = (uint64_t)(a1 + 3);
    v6 = (char *)a1[3];
    a1[4] = v4;
    v7 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v11 = *v7;
    v9 = (char *)(v7 + 1);
    v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(_QWORD *)v8 = v10;
      a1[2] += 8;
      return;
    }
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v33 = 1;
      else
        v33 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>(v5, v33);
      v35 = &v34[8 * (v33 >> 2)];
      v37 = &v34[8 * v36];
      v38 = (uint64_t *)a1[1];
      v8 = v35;
      v39 = a1[2] - (_QWORD)v38;
      if (v39)
      {
        v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        v40 = 8 * (v39 >> 3);
        v41 = &v34[8 * (v33 >> 2)];
        do
        {
          v42 = *v38++;
          *(_QWORD *)v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    v13 = v12 >> 3;
    v14 = v12 >> 3 < -1;
    v15 = (v12 >> 3) + 2;
    if (v14)
      v16 = v15;
    else
      v16 = v13 + 1;
    v17 = -(v16 >> 1);
    v18 = v16 >> 1;
    v19 = &v9[-8 * v18];
    v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      v9 = (char *)a1[1];
    }
    v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  v21 = a1[2];
  v22 = (v21 - a1[1]) >> 3;
  v23 = a1[3];
  v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(_QWORD *)&v54 = operator new(0xFFCuLL);
      std::__split_buffer<marisa::grimoire::trie::Range *>::push_back(a1, &v54);
      return;
    }
    *(_QWORD *)&v54 = operator new(0xFFCuLL);
    std::__split_buffer<marisa::grimoire::trie::Range *>::push_front((uint64_t)a1, &v54);
    v44 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v45 = *v44;
    v9 = (char *)(v44 + 1);
    v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3])
      goto LABEL_33;
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v46 = 1;
      else
        v46 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>((uint64_t)(a1 + 3), v46);
      v35 = &v34[8 * (v46 >> 2)];
      v37 = &v34[8 * v47];
      v48 = (uint64_t *)a1[1];
      v8 = v35;
      v49 = a1[2] - (_QWORD)v48;
      if (v49)
      {
        v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        v50 = 8 * (v49 >> 3);
        v51 = &v34[8 * (v46 >> 2)];
        do
        {
          v52 = *v48++;
          *(_QWORD *)v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1)
    v25 = 1;
  else
    v25 = v24 >> 2;
  v56 = a1 + 3;
  *(_QWORD *)&v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>((uint64_t)(a1 + 3), v25);
  *((_QWORD *)&v54 + 1) = v54 + 8 * v22;
  *(_QWORD *)&v55 = *((_QWORD *)&v54 + 1);
  *((_QWORD *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0xFFCuLL);
  std::__split_buffer<marisa::grimoire::trie::Range *>::push_back(&v54, &v53);
  v27 = (_QWORD *)a1[2];
  v28 = -7 - (_QWORD)v27;
  while (v27 != (_QWORD *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<marisa::grimoire::trie::Range *>::push_front((uint64_t)&v54, v27);
  }
  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(_QWORD *)&v54 = *a1;
  *((_QWORD *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (_QWORD *)v32)
    *(_QWORD *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  if (v29)
    operator delete(v29);
}

void sub_1CDF988DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  void *v13;

  operator delete(v13);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void std::__split_buffer<marisa::grimoire::trie::Range *>::push_back(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  char *v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;

  v5 = (char *)a1[3];
  v4 = (uint64_t)(a1 + 3);
  v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    v7 = (char *)a1[1];
    v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1)
        v18 = 1;
      else
        v18 = (uint64_t)&v6[-*a1] >> 2;
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>(v4, v18);
      v21 = &v19[8 * (v18 >> 2)];
      v22 = (uint64_t *)a1[1];
      v6 = v21;
      v23 = a1[2] - (_QWORD)v22;
      if (v23)
      {
        v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        v24 = 8 * (v23 >> 3);
        v25 = &v19[8 * (v18 >> 2)];
        do
        {
          v26 = *v22++;
          *(_QWORD *)v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        v6 = (char *)a1[2];
      }
    }
    else
    {
      v9 = v8 >> 3;
      v10 = v8 >> 3 < -1;
      v11 = (v8 >> 3) + 2;
      if (v10)
        v12 = v11;
      else
        v12 = v9 + 1;
      v13 = -(v12 >> 1);
      v14 = v12 >> 1;
      v15 = &v7[-8 * v14];
      v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        v6 = (char *)a1[1];
      }
      v17 = &v6[8 * v13];
      v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(_QWORD *)v6 = *a2;
  a1[2] += 8;
}

{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  char *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;

  v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    v5 = (char *)a1[1];
    v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1)
        v16 = 1;
      else
        v16 = (uint64_t)&v4[-*a1] >> 2;
      v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>(a1[4], v16);
      v19 = &v17[8 * (v16 >> 2)];
      v20 = (uint64_t *)a1[1];
      v4 = v19;
      v21 = a1[2] - (_QWORD)v20;
      if (v21)
      {
        v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        v22 = 8 * (v21 >> 3);
        v23 = &v17[8 * (v16 >> 2)];
        do
        {
          v24 = *v20++;
          *(_QWORD *)v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        v4 = (char *)a1[2];
      }
    }
    else
    {
      v7 = v6 >> 3;
      v8 = v6 >> 3 < -1;
      v9 = (v6 >> 3) + 2;
      if (v8)
        v10 = v9;
      else
        v10 = v7 + 1;
      v11 = -(v10 >> 1);
      v12 = v10 >> 1;
      v13 = &v5[-8 * v12];
      v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        v4 = (char *)a1[1];
      }
      v15 = &v4[8 * v11];
      v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(_QWORD *)v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<marisa::grimoire::trie::Range *>::push_front(uint64_t a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = a1 + 24;
    v7 = *(_BYTE **)(a1 + 24);
    v8 = *(_BYTE **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4)
        v12 = 1;
      else
        v12 = (v7 - v4) >> 2;
      v13 = 2 * v12;
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>(v6, v12);
      v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      v16 = *(uint64_t **)(a1 + 8);
      v17 = v5;
      v18 = *(_QWORD *)(a1 + 16) - (_QWORD)v16;
      if (v18)
      {
        v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        v19 = 8 * (v18 >> 3);
        v20 = v5;
        do
        {
          v21 = *v16++;
          *(_QWORD *)v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      v22 = *(char **)a1;
      *(_QWORD *)a1 = v14;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v17;
      *(_QWORD *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v9 = (v7 - v8) >> 3;
      if (v9 >= -1)
        v10 = v9 + 1;
      else
        v10 = v9 + 2;
      v11 = v10 >> 1;
      v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

{
  char *v4;
  char *v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = *(_BYTE **)(a1 + 16);
    v7 = *(_BYTE **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4)
        v11 = 1;
      else
        v11 = (v7 - v4) >> 2;
      v12 = 2 * v11;
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>(*(_QWORD *)(a1 + 32), v11);
      v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      v15 = *(uint64_t **)(a1 + 8);
      v16 = v5;
      v17 = *(_QWORD *)(a1 + 16) - (_QWORD)v15;
      if (v17)
      {
        v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        v18 = 8 * (v17 >> 3);
        v19 = v5;
        do
        {
          v20 = *v15++;
          *(_QWORD *)v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      v21 = *(char **)a1;
      *(_QWORD *)a1 = v13;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v16;
      *(_QWORD *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v8 = (v7 - v6) >> 3;
      if (v8 >= -1)
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v9 >> 1;
      v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E0DE4E98], MEMORY[0x1E0DE4390]);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

_OWORD *marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::realloc(uint64_t *a1, uint64_t a2)
{
  _OWORD *result;
  uint64_t v5;
  __int128 *v6;
  _OWORD *v7;
  __int128 v8;
  uint64_t v9;

  result = operator new[](16 * a2, MEMORY[0x1E0DE4E10]);
  v5 = a1[3];
  if (v5)
  {
    v6 = (__int128 *)a1[1];
    v7 = result;
    do
    {
      v8 = *v6++;
      *v7++ = v8;
      --v5;
    }
    while (v5);
  }
  v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
    JUMPOUT(0x1D17BC778);
  return result;
}

void *std::get_temporary_buffer[abi:ne180100]<marisa::grimoire::trie::WeightedRange>(uint64_t a1)
{
  unint64_t v1;
  const std::nothrow_t *v2;
  void *result;
  BOOL v4;

  if (a1 < 1)
    return 0;
  if (a1 >= 0x7FFFFFFFFFFFFFFLL)
    v1 = 0x7FFFFFFFFFFFFFFLL;
  else
    v1 = a1;
  v2 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
  while (1)
  {
    result = operator new(16 * v1, v2);
    if (result)
      break;
    v4 = v1 > 1;
    v1 >>= 1;
    if (!v4)
      return 0;
  }
  return result;
}

double std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, uint64_t a3, unint64_t a4, __n128 *a5, uint64_t a6, __n128 a7)
{
  unint64_t v13;
  __n128 *v14;
  unint64_t v15;
  __n128 v16;
  __n128 v17;
  __n128 v18;

  if (a4 >= 2)
  {
    if (a4 == 2)
    {
      a7.n128_u32[0] = a2[-1].n128_u32[3];
      if (a7.n128_f32[0] > a1->n128_f32[3])
      {
        a7 = *a1;
        *a1 = a2[-1];
        a2[-1] = a7;
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      v13 = a4 >> 1;
      v14 = &a1[a4 >> 1];
      v15 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        v17.n128_f64[0] = std::__stable_sort_move<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, v14, a3, v15, a5, a7);
        v18.n128_f64[0] = std::__stable_sort_move<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(&a1[a4 >> 1], a2, a3, a4 - (a4 >> 1), &a5[v13], v17);
        a7.n128_u64[0] = std::__merge_move_assign[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*>(a5, &a5[v13], &a5[v13], &a5[a4], a1, v18).n128_u64[0];
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, v14, a3, v15, a5, a6);
        std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(&a1[a4 >> 1], a2, a3, a4 - (a4 >> 1), a5, a6);
        a7.n128_u64[0] = std::__inplace_merge<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>((__int128 *)a1, (__int128 *)&a1[a4 >> 1], (__int128 *)a2, a3, a4 >> 1, a4 - (a4 >> 1), (char *)a5, a6, v16).n128_u64[0];
      }
    }
    else
    {
      std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>((uint64_t)a1, (uint64_t)a2);
    }
  }
  return a7.n128_f64[0];
}

uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  float v5;
  float v6;
  uint64_t v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  if (result != a2)
  {
    v2 = result + 16;
    if (result + 16 != a2)
    {
      v3 = 0;
      v4 = result;
      do
      {
        v5 = *(float *)(v4 + 28);
        v6 = *(float *)(v4 + 12);
        v4 = v2;
        if (v5 > v6)
        {
          v10 = *(_QWORD *)v2;
          v11 = *(_DWORD *)(v2 + 8);
          v7 = v3;
          while (1)
          {
            *(_OWORD *)(result + v7 + 16) = *(_OWORD *)(result + v7);
            if (!v7)
              break;
            v8 = *(float *)(result + v7 - 4);
            v7 -= 16;
            if (v5 <= v8)
            {
              v9 = result + v7 + 16;
              goto LABEL_10;
            }
          }
          v9 = result;
LABEL_10:
          *(_QWORD *)v9 = v10;
          *(_DWORD *)(v9 + 8) = v11;
          *(float *)(v9 + 12) = v5;
        }
        v2 = v4 + 16;
        v3 += 16;
      }
      while (v4 + 16 != a2);
    }
  }
  return result;
}

double std::__stable_sort_move<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, uint64_t a3, unint64_t a4, __n128 *a5, __n128 a6)
{
  __n128 *v10;
  __n128 v12;

  if (a4)
  {
    if (a4 == 2)
    {
      v10 = a2 - 1;
      if (a2[-1].n128_f32[3] <= a1->n128_f32[3])
      {
        *a5 = *a1;
        a6 = *v10;
      }
      else
      {
        *a5 = *v10;
        a6 = *a1;
      }
      a5[1] = a6;
    }
    else if (a4 == 1)
    {
      a6 = *a1;
      *a5 = *a1;
    }
    else if ((uint64_t)a4 > 8)
    {
      std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, &a1[a4 >> 1], a3, a4 >> 1, a5, a4 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(&a1[a4 >> 1], a2, a3, a4 - (a4 >> 1), &a5[a4 >> 1], a4 - (a4 >> 1));
      a6.n128_u64[0] = std::__merge_move_assign[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*>(a1, &a1[a4 >> 1], &a1[a4 >> 1], a2, a5, v12).n128_u64[0];
    }
    else
    {
      a6.n128_u64[0] = std::__insertion_sort_move[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, a2, a5).n128_u64[0];
    }
  }
  return a6.n128_f64[0];
}

__n128 std::__merge_move_assign[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5, __n128 result)
{
  __n128 v6;
  __n128 v7;
  __n128 v8;
  uint64_t v9;

  while (1)
  {
    if (a1 == a2)
    {
      while (a3 != a4)
      {
        v8 = *a3++;
        result.n128_u64[0] = v8.n128_u64[0];
        *a5++ = v8;
      }
      return result;
    }
    if (a3 == a4)
      break;
    if (a3->n128_f32[3] <= a1->n128_f32[3])
    {
      v7 = *a1++;
      result = v7;
    }
    else
    {
      v6 = *a3++;
      result = v6;
    }
    *a5++ = result;
  }
  if (a1 != a2)
  {
    v9 = 0;
    do
    {
      result = a1[v9];
      a5[v9++] = result;
    }
    while (&a1[v9] != a2);
  }
  return result;
}

__n128 std::__inplace_merge<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(__int128 *a1, __int128 *a2, __int128 *a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8, __n128 result)
{
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  __int128 *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 *v19;
  __int128 *v20;
  unint64_t v21;
  unint64_t v22;
  __int128 *v23;
  float v24;
  __int128 *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  __int128 *v29;
  float v30;
  __int128 *v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  __int128 *v36;
  uint64_t v37;
  uint64_t v38;
  __int128 *v39;
  uint64_t v40;
  __n128 v43;

  if (a6)
  {
    v10 = a6;
    do
    {
      if (v10 <= a8 || a5 <= a8)
      {
        std::__buffered_inplace_merge[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, a2, a3, a4, a5, v10, a7);
        return result;
      }
      if (!a5)
        return result;
      v12 = 0;
      result.n128_u32[0] = *((_DWORD *)a2 + 3);
      v13 = -a5;
      while (1)
      {
        v14 = &a1[v12];
        if (result.n128_f32[0] > *((float *)&a1[v12] + 3))
          break;
        ++v12;
        if (__CFADD__(v13++, 1))
          return result;
      }
      v16 = -v13;
      v39 = a3;
      v40 = a8;
      if (-v13 >= v10)
      {
        if (v13 == -1)
        {
          v43 = (__n128)a1[v12];
          a1[v12] = *a2;
          result = v43;
          *a2 = (__int128)v43;
          return result;
        }
        if (v13 > 0)
          v16 = 1 - v13;
        v26 = v16 >> 1;
        v20 = &a1[(v16 >> 1) + v12];
        v19 = a3;
        if (a3 != a2)
        {
          v27 = a3 - a2;
          v19 = a2;
          do
          {
            v28 = v27 >> 1;
            v29 = &v19[v27 >> 1];
            v30 = *((float *)v29 + 3);
            v31 = v29 + 1;
            v27 += ~(v27 >> 1);
            if (v30 > *((float *)v20 + 3))
              v19 = v31;
            else
              v27 = v28;
          }
          while (v27);
        }
        v18 = v19 - a2;
      }
      else
      {
        if (v10 >= 0)
          v17 = v10;
        else
          v17 = v10 + 1;
        v18 = v17 >> 1;
        v19 = &a2[v17 >> 1];
        v20 = a2;
        if (v14 != a2)
        {
          v21 = ((char *)a2 - (char *)a1 - v12 * 16) >> 4;
          v20 = &a1[v12];
          do
          {
            v22 = v21 >> 1;
            v23 = &v20[v21 >> 1];
            v24 = *((float *)v23 + 3);
            v25 = v23 + 1;
            v21 += ~(v21 >> 1);
            if (*((float *)v19 + 3) > v24)
              v21 = v22;
            else
              v20 = v25;
          }
          while (v21);
        }
        v26 = ((char *)v20 - (char *)a1 - v12 * 16) >> 4;
      }
      a5 = -(v26 + v13);
      v32 = v10 - v18;
      v33 = v18;
      v34 = std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *,marisa::grimoire::trie::WeightedRange *>((char *)v20, (char *)a2, (char *)v19);
      v35 = v33;
      v36 = (__int128 *)v34;
      if (v26 + v35 >= v10 - (v26 + v35) - v13)
      {
        v38 = v35;
        std::__inplace_merge<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(v34, v19, v39, a4, a5, v32, a7, v40);
        v19 = v20;
        v32 = v38;
        a5 = v26;
        a8 = v40;
        a3 = v36;
      }
      else
      {
        v37 = v26;
        a8 = v40;
        std::__inplace_merge<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(v14, v20, v34, a4, v37, v35, a7, v40);
        v14 = v36;
        a3 = v39;
      }
      v10 = v32;
      a1 = v14;
      a2 = v19;
    }
    while (v32);
  }
  return result;
}

__n128 std::__insertion_sort_move[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, __n128 *a3)
{
  __n128 result;
  __n128 *v4;
  uint64_t v5;
  __n128 *v6;
  __n128 *v7;
  __n128 *v8;
  __n128 *v9;
  uint64_t v10;

  if (a1 != a2)
  {
    result = *a1;
    *a3 = *a1;
    v4 = a1 + 1;
    if (&a1[1] != a2)
    {
      v5 = 0;
      v6 = a3;
      do
      {
        v7 = a1;
        v8 = v6;
        a1 = v4;
        v9 = ++v6;
        if (v7[1].n128_f32[3] > v8->n128_f32[3])
        {
          *v6 = *v8;
          v9 = a3;
          if (v8 != a3)
          {
            v10 = v5;
            while (1)
            {
              v9 = (__n128 *)((char *)a3 + v10);
              if (v7[1].n128_f32[3] <= *(float *)((char *)&a3->n128_f32[-1] + v10))
                break;
              *v9 = v9[-1];
              v10 -= 16;
              if (!v10)
              {
                v9 = a3;
                break;
              }
            }
          }
        }
        result = *a1;
        *v9 = *a1;
        v4 = a1 + 1;
        v5 += 16;
      }
      while (&a1[1] != a2);
    }
  }
  return result;
}

__int128 *std::__buffered_inplace_merge[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(__int128 *result, __int128 *a2, __int128 *a3, int a4, uint64_t a5, uint64_t a6, char *__src)
{
  uint64_t v7;
  float *v8;
  __int128 *v9;
  float v10;
  float v11;
  char *v12;
  unint64_t v13;
  float *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  unint64_t v18;

  if (a5 <= a6)
  {
    if (result != a2)
    {
      v13 = 0;
      do
      {
        *(_OWORD *)&__src[v13] = result[v13 / 0x10];
        v13 += 16;
      }
      while (&result[v13 / 0x10] != a2);
      if (v13)
      {
        v14 = (float *)__src;
        while (a2 != a3)
        {
          if (*((float *)a2 + 3) <= v14[3])
          {
            v17 = *(_OWORD *)v14;
            v14 += 4;
            v16 = v17;
          }
          else
          {
            v15 = *a2++;
            v16 = v15;
          }
          *result++ = v16;
          if (&__src[v13] == (char *)v14)
            return result;
        }
        return (__int128 *)memmove(result, v14, __src - (char *)v14 + v13);
      }
    }
  }
  else if (a2 != a3)
  {
    v7 = 0;
    do
    {
      *(_OWORD *)&__src[v7 * 16] = a2[v7];
      ++v7;
    }
    while (&a2[v7] != a3);
    if (v7 * 16)
    {
      v8 = (float *)&__src[v7 * 16];
      v9 = a3 - 1;
      while (a2 != result)
      {
        v10 = *(v8 - 1);
        v11 = *((float *)a2 - 1);
        if (v10 <= v11)
          v12 = (char *)(v8 - 4);
        else
          v12 = (char *)(a2 - 1);
        if (v10 <= v11)
          v8 -= 4;
        else
          --a2;
        *v9-- = *(_OWORD *)v12;
        if (v8 == (float *)__src)
          return result;
      }
      v18 = 0;
      do
      {
        v9[v18 / 4] = *(_OWORD *)&v8[v18 - 4];
        v18 -= 4;
      }
      while (&v8[v18] != (float *)__src);
    }
  }
  return result;
}

char *std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *,marisa::grimoire::trie::WeightedRange *>(char *__src, char *a2, char *a3)
{
  char *v4;
  int64_t v6;
  size_t v7;
  __int128 v9;
  __int128 v10;

  v4 = a3;
  if (__src != a2)
  {
    if (a2 == a3)
    {
      return __src;
    }
    else if (__src + 16 == a2)
    {
      v9 = *(_OWORD *)__src;
      v6 = a3 - a2;
      memmove(__src, a2, a3 - a2);
      v4 = &__src[v6];
      *(_OWORD *)v4 = v9;
    }
    else if (a2 + 16 == a3)
    {
      v4 = __src + 16;
      v10 = *((_OWORD *)a3 - 1);
      v7 = a3 - 16 - __src;
      if (a3 - 16 != __src)
        memmove(__src + 16, __src, v7);
      *(_OWORD *)__src = v10;
    }
    else
    {
      return (char *)std::__rotate_gcd[abi:ne180100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *>(__src, a2, a3);
    }
  }
  return v4;
}

_OWORD *std::__rotate_gcd[abi:ne180100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *>(_OWORD *a1, _OWORD *a2, _OWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _OWORD *v12;
  __int128 v13;
  _OWORD *v14;
  _OWORD *v15;
  _OWORD *v16;
  BOOL v17;
  char v18;
  uint64_t v19;

  v3 = a2 - a1;
  if (v3 == a3 - a2)
  {
    if (a1 != a2 && a2 != a3)
    {
      v4 = 0;
      do
      {
        v5 = a1[v4];
        a1[v4] = a2[v4];
        v6 = (uint64_t)&a1[v4 + 1];
        a2[v4] = v5;
        v7 = (uint64_t)&a2[++v4];
      }
      while ((_OWORD *)v6 != a2 && v7 != (_QWORD)a3);
    }
  }
  else
  {
    v9 = a3 - a2;
    v10 = a2 - a1;
    do
    {
      v11 = v10;
      v10 = v9;
      v9 = v11 % v9;
    }
    while (v9);
    if (v10)
    {
      v12 = &a1[v10];
      do
      {
        v13 = *--v12;
        v14 = &v12[v3];
        v15 = v12;
        do
        {
          v16 = v15;
          v15 = v14;
          *v16 = *v14;
          v17 = __OFSUB__(v3, a3 - v14);
          v19 = v3 - (a3 - v14);
          v18 = (v19 < 0) ^ v17;
          v14 = &a1[v19];
          if (v18)
            v14 = &v15[v3];
        }
        while (v14 != v12);
        *v15 = v13;
      }
      while (v12 != a1);
    }
    return &a1[a3 - a2];
  }
  return a2;
}

uint64_t std::deque<marisa::grimoire::trie::Range>::~deque[abi:ne180100](_QWORD *a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  a1[5] = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 170;
  }
  else
  {
    if (v5 != 2)
      goto LABEL_9;
    v6 = 341;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    v7 = *v2++;
    operator delete(v7);
  }
  return std::__split_buffer<marisa::grimoire::trie::Range *>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__split_buffer<marisa::grimoire::trie::Range *>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
    *(_QWORD *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  v4 = *(void **)a1;
  if (*(_QWORD *)a1)
    operator delete(v4);
  return a1;
}

uint64_t marisa::grimoire::vector::FlatVector::build_(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  BOOL v11;
  _BOOL8 v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t result;
  uint64_t v16;
  unint64_t v17;

  v4 = *(_QWORD *)(a2 + 24);
  if (!v4)
    goto LABEL_10;
  v5 = 0;
  v6 = *(unsigned int **)(a2 + 16);
  v7 = *(_QWORD *)(a2 + 24);
  do
  {
    v9 = *v6++;
    v8 = v9;
    if (v9 > v5)
      v5 = v8;
    --v7;
  }
  while (v7);
  if (v5)
  {
    v10 = 0;
    do
    {
      ++v10;
      v11 = v5 > 1;
      v5 >>= 1;
    }
    while (v11);
  }
  else
  {
LABEL_10:
    v10 = 0;
  }
  v12 = v4 != 0;
  v13 = (unint64_t)(v10 * v4 + 63) >> 6;
  if (v10)
    v14 = v13;
  else
    v14 = v12;
  result = (uint64_t)marisa::grimoire::vector::Vector<unsigned long long>::resize((uint64_t *)a1, v14);
  if (v14)
    *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * *(_QWORD *)(a1 + 24) - 8) = 0;
  *(_QWORD *)(a1 + 48) = v10;
  if (v10)
    *(_DWORD *)(a1 + 56) = 0xFFFFFFFF >> -(char)v10;
  v16 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 64) = v16;
  if (v16)
  {
    v17 = 0;
    do
    {
      result = marisa::grimoire::vector::FlatVector::set(a1, v17, *(_DWORD *)(*(_QWORD *)(a2 + 16) + 4 * v17));
      ++v17;
    }
    while (v17 < *(_QWORD *)(a2 + 24));
  }
  return result;
}

uint64_t marisa::grimoire::vector::FlatVector::set(uint64_t this, uint64_t a2, int a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v3 = *(_QWORD *)(this + 48);
  v4 = (unint64_t)(v3 * a2) >> 6;
  v5 = (v3 * a2) & 0x3F;
  v6 = *(unsigned int *)(this + 56);
  v7 = *(_QWORD *)(this + 8);
  v8 = v6 & a3;
  *(_QWORD *)(v7 + 8 * v4) = *(_QWORD *)(v7 + 8 * v4) & ~(v6 << (v3 * a2)) | (v8 << (v3 * a2));
  if ((unint64_t)(v5 + v3) >= 0x41)
    *(_QWORD *)(v7 + 8 * v4 + 8) = *(_QWORD *)(v7 + 8 * v4 + 8) & ~(v6 >> -(char)v5) | (v8 >> -(char)v5);
  return this;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,false>(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, char a5)
{
  unsigned int *v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int *v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int *v18;
  char v19;
  BOOL v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;

  v8 = (unsigned int *)result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = ((char *)a2 - (char *)v9) >> 3;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v21 = *(a2 - 2);
        v22 = *v9;
        if (v21 < *v9 || v22 >= v21 && *(a2 - 1) < v9[1])
        {
          *v9 = v21;
          *(a2 - 2) = v22;
          v23 = v9[1];
          v9[1] = *(a2 - 1);
          *(a2 - 1) = v23;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v9, v9 + 2, a2 - 2);
      case 4uLL:
        return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v9, v9 + 2, v9 + 4, a2 - 2);
      case 5uLL:
        return std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v9, v9 + 2, v9 + 4, v9 + 6, a2 - 2);
      default:
        if (v12 <= 191)
        {
          if ((a5 & 1) != 0)
            return (uint64_t)std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v9, a2);
          else
            return (uint64_t)std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v9, a2);
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[2 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(&v9[2 * (v13 >> 1)], v9, a2 - 2);
            if ((a5 & 1) != 0)
              goto LABEL_14;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v9, &v9[2 * (v13 >> 1)], a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v9 + 2, v15 - 2, a2 - 4);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v9 + 4, &v9[2 * v14 + 2], a2 - 6);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v15 - 2, v15, &v9[2 * v14 + 2]);
            v16 = *(_QWORD *)v9;
            *(_QWORD *)v9 = *(_QWORD *)v15;
            *(_QWORD *)v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_14;
          }
          v17 = *(v9 - 2);
          if (v17 >= *v9 && (*v9 < v17 || *(v9 - 1) >= v9[1]))
          {
            result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<unsigned int,unsigned int> *,std::__less<void,void> &>(v9, a2);
            v9 = (unsigned int *)result;
            goto LABEL_19;
          }
LABEL_14:
          v18 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<unsigned int,unsigned int> *,std::__less<void,void> &>(v9, a2);
          if ((v19 & 1) == 0)
            goto LABEL_17;
          v20 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v9, v18);
          v9 = v18 + 2;
          result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v18 + 2, a2);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v20)
              continue;
LABEL_17:
            result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,false>(v8, v18, a3, -v11, a5 & 1);
            v9 = v18 + 2;
LABEL_19:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v18;
          if (v20)
            return result;
          goto LABEL_2;
        }
        if (v9 != a2)
          return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,std::pair<unsigned int,unsigned int> *>(v9, a2, a2, a3);
        return result;
    }
  }
}

unsigned int *std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *result, unsigned int *a2)
{
  unsigned int *v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int *v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int *v15;

  if (result != a2)
  {
    v2 = result + 2;
    if (result + 2 != a2)
    {
      v3 = 0;
      v4 = result;
      do
      {
        v5 = v4;
        v4 = v2;
        v6 = v5[2];
        v7 = *v5;
        if (v6 < *v5 || v7 >= v6 && v5[3] < v5[1])
        {
          v9 = v5[2];
          v8 = v5[3];
          v10 = v5[1];
          v5[2] = v7;
          v4[1] = v10;
          v11 = result;
          if (v5 != result)
          {
            v12 = v3;
            do
            {
              v13 = *(unsigned int *)((char *)result + v12 - 8);
              if (v13 <= v9)
              {
                if (v13 < v9)
                {
                  v11 = v5;
                  goto LABEL_17;
                }
                v11 = (unsigned int *)((char *)result + v12);
                v14 = *(unsigned int *)((char *)result + v12 - 4);
                if (v14 <= v8)
                  goto LABEL_17;
              }
              else
              {
                v14 = *(unsigned int *)((char *)result + v12 - 4);
              }
              v5 -= 2;
              v15 = (unsigned int *)((char *)result + v12);
              *v15 = v13;
              v15[1] = v14;
              v12 -= 8;
            }
            while (v12);
            v11 = result;
          }
LABEL_17:
          *v11 = v9;
          v11[1] = v8;
        }
        v2 = v4 + 2;
        v3 += 8;
      }
      while (v4 + 2 != a2);
    }
  }
  return result;
}

unsigned int *std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *result, unsigned int *a2)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int *i;
  unsigned int v10;

  if (result != a2)
  {
    v2 = result + 2;
    if (result + 2 != a2)
    {
      v3 = result + 1;
      do
      {
        v4 = result;
        result = v2;
        v5 = v4[2];
        v6 = *v4;
        if (v5 < *v4 || v6 >= v5 && v4[3] < v4[1])
        {
          v7 = *result;
          v8 = result[1];
          for (i = v3; ; i -= 2)
          {
            v10 = *i;
            i[1] = v6;
            i[2] = v10;
            v6 = *(i - 3);
            if (v6 <= v7 && (v6 < v7 || *(i - 2) <= v8))
              break;
          }
          *(i - 1) = v7;
          *i = v8;
        }
        v2 = result + 2;
        v3 += 2;
      }
      while (result + 2 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  int *v6;
  int *v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  int *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;

  v3 = *a2;
  v4 = *a1;
  if (*a2 >= *a1 && (v4 < v3 || a2[1] >= a1[1]))
  {
    v9 = *a3;
    if (*a3 >= v3 && (v3 < v9 || a3[1] >= a2[1]))
      return 0;
    *a2 = v9;
    *a3 = v3;
    v11 = (int *)(a2 + 1);
    v10 = a2[1];
    a2[1] = a3[1];
    a3[1] = v10;
    v12 = *a2;
    v13 = *a1;
    if (*a2 >= *a1 && (v13 < v12 || *v11 >= a1[1]))
      return 1;
    *a1 = v12;
    v6 = (int *)(a1 + 1);
    *a2 = v13;
    v8 = 2;
  }
  else
  {
    v5 = *a3;
    if (*a3 < v3 || v3 >= v5 && a3[1] < a2[1])
    {
      *a1 = v5;
      v6 = (int *)(a1 + 1);
      *a3 = v4;
      v7 = (int *)(a3 + 1);
      v8 = 1;
    }
    else
    {
      *a1 = v3;
      *a2 = v4;
      v14 = a1[1];
      a1[1] = a2[1];
      a2[1] = v14;
      v15 = *a3;
      v16 = *a2;
      if (*a3 >= *a2 && (v16 < v15 || a3[1] >= v14))
        return 1;
      *a2 = v15;
      *a3 = v16;
      v7 = (int *)(a3 + 1);
      v8 = 2;
      v6 = (int *)(a2 + 1);
    }
    v11 = v7;
  }
  v17 = *v6;
  *v6 = *v11;
  *v11 = v17;
  return v8;
}

unsigned int *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<unsigned int,unsigned int> *,std::__less<void,void> &>(unsigned int *a1, unsigned int *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int *i;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v14;

  v3 = *a1;
  v2 = a1[1];
  v4 = *(a2 - 2);
  if (v4 <= *a1 && (v4 < v3 || *(a2 - 1) <= v2))
  {
    for (i = a1 + 2; i < a2 && *i <= v3 && (*i < v3 || i[1] <= v2); i += 2)
      ;
  }
  else
  {
    i = a1;
    do
    {
      v7 = i[2];
      i += 2;
      v6 = v7;
    }
    while (v7 <= v3 && (v6 < v3 || i[1] <= v2));
  }
  if (i < a2)
  {
    for (a2 -= 2; v4 > v3 || v4 >= v3 && a2[1] > v2; a2 -= 2)
    {
      v8 = *(a2 - 2);
      v4 = v8;
    }
  }
  if (i < a2)
  {
    v9 = *i;
    v10 = *a2;
    do
    {
      *i = v10;
      *a2 = v9;
      v11 = i[1];
      i[1] = a2[1];
      a2[1] = v11;
      do
      {
        v12 = i[2];
        i += 2;
        v9 = v12;
      }
      while (v12 <= v3 && (v9 < v3 || i[1] <= v2));
      do
      {
        do
        {
          v13 = *(a2 - 2);
          a2 -= 2;
          v10 = v13;
          v14 = v13 >= v3;
        }
        while (v13 > v3);
      }
      while (v14 && a2[1] > v2);
    }
    while (i < a2);
  }
  if (i - 2 != a1)
  {
    *a1 = *(i - 2);
    a1[1] = *(i - 1);
  }
  *(i - 2) = v3;
  *(i - 1) = v2;
  return i;
}

unsigned int *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<unsigned int,unsigned int> *,std::__less<void,void> &>(unsigned int *a1, unsigned int *a2)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v12;
  unsigned int *v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  BOOL v17;
  unsigned int v18;

  v2 = 0;
  v3 = *a1;
  v4 = a1[1];
  while (1)
  {
    v5 = a1[v2 + 2];
    if (v5 >= v3 && (v5 > v3 || a1[v2 + 3] >= v4))
      break;
    v2 += 2;
  }
  v6 = (unint64_t)&a1[v2 + 2];
  if (v2 * 4)
  {
    do
    {
      v8 = *(a2 - 2);
      a2 -= 2;
      v7 = v8;
    }
    while (v8 >= v3 && (v7 > v3 || a2[1] >= v4));
  }
  else
  {
LABEL_19:
    if (v6 < (unint64_t)a2)
    {
      do
      {
        v10 = *(a2 - 2);
        a2 -= 2;
        v9 = v10;
        if (v10 < v3)
          break;
        if (v9 > v3)
          goto LABEL_19;
      }
      while (a2[1] >= v4 && v6 < (unint64_t)a2);
    }
  }
  if (v6 >= (unint64_t)a2)
  {
    v13 = (unsigned int *)v6;
  }
  else
  {
    v12 = *a2;
    v13 = (unsigned int *)v6;
    v14 = a2;
    do
    {
      *v13 = v12;
      *v14 = v5;
      v15 = v13[1];
      v13[1] = v14[1];
      v14[1] = v15;
      do
      {
        do
        {
          v16 = v13[2];
          v13 += 2;
          v5 = v16;
          v17 = v16 > v3;
        }
        while (v16 < v3);
      }
      while (!v17 && v13[1] < v4);
      do
      {
        v18 = *(v14 - 2);
        v14 -= 2;
        v12 = v18;
      }
      while (v18 >= v3 && (v12 > v3 || v14[1] >= v4));
    }
    while (v13 < v14);
  }
  if (v13 - 2 != a1)
  {
    *a1 = *(v13 - 2);
    a1[1] = *(v13 - 1);
  }
  *(v13 - 2) = v3;
  *(v13 - 1) = v4;
  return v13 - 2;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *a1, unsigned int *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int *v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int *v16;
  uint64_t v17;
  char *v18;
  unsigned int v19;
  unsigned int v20;

  v4 = ((char *)a2 - (char *)a1) >> 3;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 2);
      v7 = *a1;
      if (v6 < *a1 || v7 >= v6 && *(a2 - 1) < a1[1])
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      v9 = a1 + 4;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a1 + 2, a1 + 4);
      v10 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  do
  {
    v13 = *v9;
    if (*v10 >= *v9 && (v13 < *v10 || v10[1] >= v9[1]))
      goto LABEL_22;
    v14 = *v10;
    v15 = v10[1];
    *v10 = v13;
    v10[1] = v9[1];
    v16 = a1;
    if (v9 == a1)
      goto LABEL_21;
    v17 = v11;
    while (1)
    {
      v18 = (char *)a1 + v17;
      v19 = *(unsigned int *)((char *)a1 + v17 + 8);
      if (v19 <= v14)
        break;
      v20 = *((_DWORD *)v18 + 3);
LABEL_18:
      v9 -= 2;
      *((_DWORD *)v18 + 4) = v19;
      *(unsigned int *)((char *)a1 + v17 + 20) = v20;
      v17 -= 8;
      if (v17 == -16)
      {
        v16 = a1;
        goto LABEL_21;
      }
    }
    if (v19 < v14)
    {
      v16 = v9;
      goto LABEL_21;
    }
    v20 = *(unsigned int *)((char *)a1 + v17 + 12);
    if (v20 > v15)
      goto LABEL_18;
    v16 = (unsigned int *)((char *)a1 + v17 + 16);
LABEL_21:
    *v16 = v14;
    v16[1] = v15;
    if (++v12 == 8)
      return v10 + 2 == a2;
LABEL_22:
    v9 = v10;
    v11 += 8;
    v10 += 2;
  }
  while (v10 != a2);
  return 1;
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;

  result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a2, a3);
  v9 = *a4;
  v10 = *a3;
  if (*a4 < *a3 || v10 >= v9 && a4[1] < a3[1])
  {
    *a3 = v9;
    *a4 = v10;
    v11 = a3[1];
    a3[1] = a4[1];
    a4[1] = v11;
    v12 = *a3;
    v13 = *a2;
    if (*a3 < *a2 || v13 >= v12 && a3[1] < a2[1])
    {
      *a2 = v12;
      *a3 = v13;
      v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      v15 = *a2;
      v16 = *a1;
      if (*a2 < *a1 || v16 >= v15 && a2[1] < a1[1])
      {
        *a1 = v15;
        *a2 = v16;
        v17 = a1[1];
        a1[1] = a2[1];
        a2[1] = v17;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t result;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;

  result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a2, a3, a4);
  v11 = *a5;
  v12 = *a4;
  if (*a5 < *a4 || v12 >= v11 && a5[1] < a4[1])
  {
    *a4 = v11;
    *a5 = v12;
    v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    v14 = *a4;
    v15 = *a3;
    if (*a4 < *a3 || v15 >= v14 && a4[1] < a3[1])
    {
      *a3 = v14;
      *a4 = v15;
      v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      v17 = *a3;
      v18 = *a2;
      if (*a3 < *a2 || v18 >= v17 && a3[1] < a2[1])
      {
        *a2 = v17;
        *a3 = v18;
        v19 = a2[1];
        a2[1] = a3[1];
        a3[1] = v19;
        v20 = *a2;
        v21 = *a1;
        if (*a2 < *a1 || v21 >= v20 && a2[1] < a1[1])
        {
          *a1 = v20;
          *a2 = v21;
          v22 = a1[1];
          a1[1] = a2[1];
          a2[1] = v22;
        }
      }
    }
  }
  return result;
}

unsigned int *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,std::pair<unsigned int,unsigned int> *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int *v12;
  unsigned int *v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int *v22;

  if (a1 != a2)
  {
    v8 = (char *)a2 - (char *)a1;
    v9 = ((char *)a2 - (char *)a1) >> 3;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[2 * v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>((uint64_t)a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != a3)
    {
      v14 = a2;
      do
      {
        v15 = *v14;
        v16 = *a1;
        if (*v14 < *a1 || v16 >= v15 && v14[1] < a1[1])
        {
          *v14 = v16;
          *a1 = v15;
          v17 = v14[1];
          v14[1] = a1[1];
          a1[1] = v17;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>((uint64_t)a1, a4, v9, a1);
        }
        v14 += 2;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 9)
    {
      v18 = (unint64_t)v8 >> 3;
      v19 = a2 - 2;
      do
      {
        v21 = *a1;
        v20 = a1[1];
        v22 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a4, v18);
        if (v19 == v22)
        {
          *v22 = v21;
          v22[1] = v20;
        }
        else
        {
          *v22 = *v19;
          v22[1] = v19[1];
          *v19 = v21;
          v19[1] = v20;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>((uint64_t)a1, (uint64_t)(v22 + 2), a4, ((char *)(v22 + 2) - (char *)a1) >> 3);
        }
        v19 -= 2;
      }
      while (v18-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(uint64_t result, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      v6 = v4 >> 2;
      v7 = (v4 >> 2) + 1;
      v8 = (unsigned int *)(result + 8 * v7);
      v9 = v6 + 2;
      if (v9 < a3)
      {
        v10 = v8[2];
        if (*v8 < v10 || v10 >= *v8 && *(_DWORD *)(result + 8 * v7 + 4) < v8[3])
        {
          v8 += 2;
          v7 = v9;
        }
      }
      v11 = *v8;
      if (*v8 >= *a4 && (*a4 < v11 || v8[1] >= a4[1]))
      {
        v12 = *a4;
        v13 = a4[1];
        *a4 = v11;
        a4[1] = v8[1];
        if (v5 >= v7)
        {
          while (1)
          {
            v15 = 2 * v7;
            v7 = (2 * v7) | 1;
            v14 = (unsigned int *)(result + 8 * v7);
            v16 = v15 + 2;
            if (v16 < a3)
            {
              v17 = v14[2];
              if (*v14 < v17 || v17 >= *v14 && *(_DWORD *)(result + 8 * v7 + 4) < v14[3])
              {
                v14 += 2;
                v7 = v16;
              }
            }
            v18 = *v14;
            if (*v14 < v12 || v18 <= v12 && v14[1] < v13)
              break;
            *v8 = v18;
            v8[1] = v14[1];
            v8 = v14;
            if (v5 < v7)
              goto LABEL_22;
          }
        }
        v14 = v8;
LABEL_22:
        *v14 = v12;
        v14[1] = v13;
      }
    }
  }
  return result;
}

unsigned int *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;

  v3 = 0;
  v4 = a3 - 2;
  if (a3 < 2)
    v4 = a3 - 1;
  v5 = v4 >> 1;
  do
  {
    v6 = result;
    v7 = v3 + 1;
    result += 2 * v3 + 2;
    v8 = 2 * v3;
    v3 = (2 * v3) | 1;
    v9 = v8 + 2;
    if (v9 < a3)
    {
      v10 = result[2];
      if (*result < v10 || v10 >= *result && v6[2 * v7 + 1] < result[3])
      {
        result += 2;
        v3 = v9;
      }
    }
    *v6 = *result;
    v6[1] = result[1];
  }
  while (v3 <= v5);
  return result;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int *v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;

  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v5 = v4 >> 1;
    v6 = (unsigned int *)(result + 8 * (v4 >> 1));
    v7 = *v6;
    v8 = *(_DWORD *)(a2 - 8);
    if (*v6 < v8 || v8 >= v7 && *(_DWORD *)(result + 8 * v5 + 4) < *(_DWORD *)(a2 - 4))
    {
      v9 = *(_DWORD *)(a2 - 8);
      v10 = *(_DWORD *)(a2 - 4);
      *(_DWORD *)(a2 - 8) = v7;
      *(_DWORD *)(a2 - 4) = v6[1];
      if (v4 >= 2)
      {
        while (1)
        {
          v12 = v5 - 1;
          v5 = (v5 - 1) >> 1;
          v11 = (unsigned int *)(result + 8 * v5);
          v13 = *v11;
          if (*v11 >= v9)
          {
            if (v13 > v9)
              break;
            v14 = *(_DWORD *)(result + 8 * v5 + 4);
            if (v14 >= v10)
              break;
          }
          else
          {
            v14 = v11[1];
          }
          *v6 = v13;
          v6[1] = v14;
          v6 = (unsigned int *)(result + 8 * v5);
          if (v12 <= 1)
            goto LABEL_12;
        }
      }
      v11 = v6;
LABEL_12:
      *v11 = v9;
      v11[1] = v10;
    }
  }
  return result;
}

char *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::realloc(uint64_t *a1, uint64_t a2)
{
  char *result;
  uint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  result = (char *)operator new[](16 * a2, MEMORY[0x1E0DE4E10]);
  v5 = a1[3];
  if (v5)
  {
    v6 = (uint64_t *)(a1[1] + 8);
    v7 = result + 8;
    do
    {
      *(v7 - 1) = *(v6 - 1);
      v8 = *v6;
      v6 += 2;
      *v7 = v8;
      v7 += 2;
      --v5;
    }
    while (v5);
  }
  v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
    JUMPOUT(0x1D17BC778);
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_current_trie<marisa::grimoire::trie::ReverseKey>(uint64_t *a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  __n128 v33;
  uint64_t v34;
  __n128 *v35;
  unint64_t v36;
  __n128 *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int *v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t *v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unsigned __int32 *v57;
  float v58;
  float v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  float *v63;
  float v64;
  _DWORD *v65;
  uint64_t v66;
  __int128 v67;
  uint64_t v68;
  __int128 v69;
  uint64_t result;
  uint64_t *v72;
  uint64_t *v73;
  uint64_t v75;
  uint64_t v76;
  int v77;
  __n128 v78;
  int v79;
  __int128 v80;
  uint64_t v81[4];
  _OWORD v82[2];
  __int128 v83;
  _OWORD v84[4];

  v8 = *(_QWORD *)(a2 + 24);
  v9 = *(_QWORD *)(a2 + 8);
  if (v8)
  {
    v10 = 0;
    v11 = (_DWORD *)(v9 + 16);
    do
    {
      *v11 = v10;
      v11 += 6;
      ++v10;
    }
    while (v8 != v10);
  }
  v12 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v9, v9 + 24 * v8, 0);
  v13 = 256;
  if (a5 != 1)
    v13 = 1;
  do
  {
    v14 = v13;
    v13 *= 2;
  }
  while (v14 < v12 / *(unsigned int *)(a4 + 8));
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::resize(a1 + 126, v14);
  a1[132] = v14 - 1;
  marisa::grimoire::vector::BitVector::push_back(a1, 1);
  marisa::grimoire::vector::BitVector::push_back(a1, 0);
  v15 = a1 + 78;
  LOBYTE(v84[0]) = 0;
  marisa::grimoire::vector::Vector<char>::push_back(a1 + 78, v84);
  marisa::grimoire::vector::BitVector::push_back(a1 + 52, 0);
  memset(v84, 0, 41);
  v83 = 0u;
  memset(v82, 0, sizeof(v82));
  v80 = 0u;
  memset(v81, 0, 25);
  v78.n128_u64[0] = *(_QWORD *)(a2 + 24) << 32;
  v78.n128_u32[2] = 0;
  std::deque<marisa::grimoire::trie::Range>::push_back(v82, (uint64_t *)&v78);
  v16 = *((_QWORD *)&v83 + 1);
  if (*((_QWORD *)&v83 + 1))
  {
    v72 = a1 + 52;
    v73 = a1 + 78;
    do
    {
      v17 = a1[58];
      v18 = (unsigned int *)(*(_QWORD *)(*((_QWORD *)&v82[0] + 1) + 8 * ((unint64_t)v83 / 0x155))
                           + 12 * ((unint64_t)v83 % 0x155));
      v19 = *v18;
      v20 = v18[1];
      v21 = v18[2];
      *(_QWORD *)&v83 = v83 + 1;
      *((_QWORD *)&v83 + 1) = v16 - 1;
      if ((unint64_t)v83 >= 0x2AA)
      {
        v22 = v17;
        v23 = v16;
        operator delete(**((void ***)&v82[0] + 1));
        v16 = v23;
        v17 = v22;
        *((_QWORD *)&v82[0] + 1) += 8;
        *(_QWORD *)&v83 = v83 - 341;
      }
      if (v19 < v20)
      {
        while (1)
        {
          v24 = *(_QWORD *)(a2 + 8);
          if (*(_DWORD *)(v24 + 24 * v19 + 8) != (_DWORD)v21)
            break;
          *(_DWORD *)(v24 + 24 * v19 + 12) = v17 - v16;
          v19 = (v19 + 1);
          if ((_DWORD)v20 == (_DWORD)v19)
            goto LABEL_49;
        }
      }
      if ((_DWORD)v19 != (_DWORD)v20)
      {
        v76 = v16;
        v77 = v17 - v16;
        v25 = v80;
        v80 = 0u;
        memset(v81, 0, 25);
        if (v25)
          MEMORY[0x1D17BC778](v25, 0x1000C8077774924);
        v75 = v17;
        v26 = *(_QWORD *)(a2 + 8);
        v27 = *(float *)(v26 + 24 * v19 + 12);
        v28 = v19 + 1;
        if (v19 + 1 < v20)
        {
          v29 = 24 * v19;
          v30 = (v19 << 32) + 0x100000000;
          do
          {
            if (*(unsigned __int8 *)(*(_QWORD *)(v26 + v29) - v21 - 1) != *(unsigned __int8 *)(*(_QWORD *)(v26 + v29 + 24)
                                                                                              - v21
                                                                                              - 1))
            {
              *(float *)&v31 = v27;
              v78.n128_u64[0] = v30 + v19;
              v78.n128_u64[1] = v21 | ((unint64_t)v31 << 32);
              marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back((uint64_t *)&v80, &v78);
              v26 = *(_QWORD *)(a2 + 8);
              v27 = 0.0;
              LODWORD(v19) = v28;
            }
            v27 = v27 + *(float *)(v26 + v29 + 36);
            ++v28;
            v29 += 24;
            v30 += 0x100000000;
          }
          while (v20 != v28);
        }
        *(float *)&v32 = v27;
        v78.n128_u32[0] = v19;
        v78.n128_u32[1] = v20;
        v78.n128_u64[1] = v21 | ((unint64_t)v32 << 32);
        v33 = marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back((uint64_t *)&v80, &v78);
        v15 = a1 + 78;
        v34 = v76;
        if (*(_DWORD *)(a4 + 16) == 0x20000)
        {
          v35 = (__n128 *)*((_QWORD *)&v80 + 1);
          v36 = v81[1];
          if (v81[1] < 129)
          {
            v37 = 0;
            v39 = 0;
          }
          else
          {
            v37 = (__n128 *)std::get_temporary_buffer[abi:ne180100]<marisa::grimoire::trie::WeightedRange>(v81[1]);
            v39 = v38;
          }
          std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(v35, &v35[v36], (uint64_t)&v78, v36, v37, v39, v33);
          if (v37)
            operator delete(v37);
          v34 = v76;
        }
        v40 = v81[1];
        if (v75 == v34)
          a1[133] = v81[1];
        if (v40)
        {
          v41 = 0;
          do
          {
            v42 = (unsigned int *)(*((_QWORD *)&v80 + 1) + 16 * v41);
            v43 = (uint64_t *)v42;
            v44 = v42[2];
            v45 = *(_QWORD *)(a2 + 8);
            v46 = *(unsigned int *)(v45 + 24 * *v42 + 8);
            v47 = v44 + 1;
            if (v44 + 1 >= v46)
            {
              v48 = v42[2];
              LODWORD(v46) = v44 + 1;
            }
            else
            {
              v48 = v46 - 1;
              v49 = (uint64_t *)(v45 + 24 * *v42);
              v50 = v42[2];
              do
              {
                v51 = v50;
                v50 = v47;
                v52 = v49;
                v53 = *v42;
                while (++v53 < (unint64_t)v42[1])
                {
                  v54 = *v52;
                  v55 = v52[3];
                  v52 += 3;
                  if (*(unsigned __int8 *)(v54 + ~v51 - 1) != *(unsigned __int8 *)(v55 + ~v51 - 1))
                  {
                    v48 = v51;
                    LODWORD(v46) = v47;
                    goto LABEL_43;
                  }
                }
                ++v47;
              }
              while (v50 + 1 != v46);
            }
LABEL_43:
            v56 = a1[81];
            v58 = *((float *)v42 + 3);
            v57 = v42 + 3;
            v59 = v58;
            v60 = a1[132] & v56;
            v61 = a1[127];
            v62 = v61 + 12 * v60;
            v64 = *(float *)(v62 + 8);
            v63 = (float *)(v62 + 8);
            if (v64 < v59)
            {
              v65 = (_DWORD *)(v61 + 12 * v60);
              *v65 = v77;
              v65[1] = v56;
              *v63 = v59;
              v44 = *((unsigned int *)v43 + 2);
            }
            if (v48 == v44)
            {
              v78.n128_u8[0] = *(_BYTE *)(~v48 + *(_QWORD *)(*(_QWORD *)(a2 + 8) + 24 * *(unsigned int *)v43));
              marisa::grimoire::vector::Vector<char>::push_back(v73, &v78);
              marisa::grimoire::vector::BitVector::push_back(v72, 0);
            }
            else
            {
              v78.n128_u8[0] = 0;
              marisa::grimoire::vector::Vector<char>::push_back(v73, &v78);
              marisa::grimoire::vector::BitVector::push_back(v72, 1);
              v78 = 0uLL;
              v79 = 0;
              v66 = *((unsigned int *)v43 + 2);
              v78.n128_u64[0] = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 24 * *(unsigned int *)v43) - v66;
              v78.n128_u64[1] = (v46 - v66);
              v78.n128_u32[3] = *v57;
              marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::push_back((uint64_t *)v84, (uint64_t)&v78);
            }
            *((_DWORD *)v43 + 2) = v46;
            std::deque<marisa::grimoire::trie::Range>::push_back(v82, v43);
            marisa::grimoire::vector::BitVector::push_back(a1, 1);
            ++v41;
          }
          while (v41 < v81[1]);
        }
      }
LABEL_49:
      marisa::grimoire::vector::BitVector::push_back(a1, 0);
      v16 = *((_QWORD *)&v83 + 1);
    }
    while (*((_QWORD *)&v83 + 1));
  }
  marisa::grimoire::vector::BitVector::push_back(a1, 0);
  marisa::grimoire::vector::BitVector::build((marisa::grimoire::vector::BitVector *)a1, a5 == 1, 1);
  marisa::grimoire::vector::Vector<unsigned char>::shrink(v15);
  marisa::grimoire::trie::LoudsTrie::build_terminals<marisa::grimoire::trie::ReverseKey>((uint64_t)a1, a2, a3);
  v67 = *(_OWORD *)a2;
  *(_OWORD *)a2 = v84[0];
  v84[0] = v67;
  v68 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)&v84[1];
  *(_QWORD *)&v84[1] = v68;
  v69 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)((char *)&v84[1] + 8);
  *(_OWORD *)((char *)&v84[1] + 8) = v69;
  LOBYTE(v68) = *(_BYTE *)(a2 + 40);
  *(_BYTE *)(a2 + 40) = BYTE8(v84[2]);
  BYTE8(v84[2]) = v68;
  if ((_QWORD)v80)
    MEMORY[0x1D17BC778](v80, 0x1000C8077774924);
  std::deque<marisa::grimoire::trie::Range>::~deque[abi:ne180100](v82);
  result = *(_QWORD *)&v84[0];
  if (*(_QWORD *)&v84[0])
    return MEMORY[0x1D17BC778](*(_QWORD *)&v84[0], 0x1000C8077774924);
  return result;
}

void sub_1CDF9B290(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  uint64_t v27;
  uint64_t v30;
  _QWORD *exception;

  if (a21)
    MEMORY[0x1D17BC778](a21, 0x1000C8077774924);
  std::deque<marisa::grimoire::trie::Range>::~deque[abi:ne180100](&a27);
  v30 = *(_QWORD *)(v27 - 144);
  if (v30)
    MEMORY[0x1D17BC778](v30, 0x1000C8077774924);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
    exception[2] = 0x8000001ACLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:428: MARISA_MEMOR"
                   "Y_ERROR: std::bad_alloc";
  }
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_terminals<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t result;
  _OWORD v13[3];

  memset(v13, 0, 41);
  marisa::grimoire::vector::Vector<unsigned int>::resize((uint64_t *)v13, *(_QWORD *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 24);
  if (v5)
  {
    v6 = *((_QWORD *)&v13[0] + 1);
    v7 = (unsigned int *)(*(_QWORD *)(a2 + 16) + 16);
    do
    {
      *(_DWORD *)(v6 + 4 * *v7) = *(v7 - 1);
      v7 += 6;
      --v5;
    }
    while (v5);
  }
  else
  {
    v6 = *((_QWORD *)&v13[0] + 1);
  }
  v8 = *a3;
  v9 = *(_QWORD *)&v13[1];
  *(_QWORD *)a3 = *(_QWORD *)&v13[0];
  *((_QWORD *)a3 + 1) = v6;
  v13[0] = v8;
  v10 = *((_QWORD *)a3 + 2);
  *((_QWORD *)a3 + 2) = v9;
  *(_QWORD *)&v13[1] = v10;
  v11 = *(__int128 *)((char *)a3 + 24);
  *(__int128 *)((char *)a3 + 24) = *(_OWORD *)((char *)&v13[1] + 8);
  *(_OWORD *)((char *)&v13[1] + 8) = v11;
  LOBYTE(v10) = *((_BYTE *)a3 + 40);
  *((_BYTE *)a3 + 40) = BYTE8(v13[2]);
  result = v8;
  BYTE8(v13[2]) = v10;
  if ((_QWORD)v8)
    return MEMORY[0x1D17BC778](v8, 0x1000C8077774924);
  return result;
}

void sub_1CDF9B464(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int64_t v37;
  uint64_t v38;
  int64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v44;

  v4 = a2;
  v5 = a1;
  v6 = a2 - a1;
  if ((uint64_t)(a2 - a1) < 241)
  {
    v7 = 0;
    goto LABEL_69;
  }
  v7 = 0;
  do
  {
    v8 = marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::ReverseKey>(v5, v5 + 24 * (v6 / 0x30uLL), v4 - 24, a3);
    v9 = v8;
    v10 = v5;
    v11 = v4;
    v12 = v5;
    v13 = v4;
    while (v10 < v11)
    {
      v14 = *(unsigned int *)(v10 + 8);
      v15 = a3 >= v14 ? -1 : *(unsigned __int8 *)(*(_QWORD *)v10 - a3 - 1);
      if (v15 > v8)
        break;
      if (v15 == v8)
      {
        v16 = *(_QWORD *)v10;
        *(_QWORD *)v10 = *(_QWORD *)v12;
        *(_DWORD *)(v10 + 8) = *(_DWORD *)(v12 + 8);
        v17 = *(_QWORD *)(v10 + 12);
        *(_DWORD *)(v10 + 12) = *(_DWORD *)(v12 + 12);
        *(_DWORD *)(v10 + 16) = *(_DWORD *)(v12 + 16);
        *(_QWORD *)v12 = v16;
        *(_DWORD *)(v12 + 8) = v14;
        *(_QWORD *)(v12 + 12) = v17;
        v12 += 24;
      }
LABEL_11:
      v10 += 24;
    }
    if (v10 < v11)
    {
      v18 = v11 - 24;
      do
      {
        v11 = v18;
        v19 = *(unsigned int *)(v18 + 8);
        if (a3 >= v19)
          v20 = -1;
        else
          v20 = *(unsigned __int8 *)(*(_QWORD *)v11 - a3 - 1);
        if (v20 < v8)
          break;
        if (v20 == v8)
        {
          v21 = *(_QWORD *)(v13 - 24);
          v13 -= 24;
          v22 = *(_QWORD *)v11;
          *(_QWORD *)v11 = v21;
          *(_DWORD *)(v11 + 8) = *(_DWORD *)(v13 + 8);
          v23 = *(_QWORD *)(v11 + 12);
          *(_DWORD *)(v11 + 12) = *(_DWORD *)(v13 + 12);
          *(_DWORD *)(v11 + 16) = *(_DWORD *)(v13 + 16);
          *(_QWORD *)v13 = v22;
          *(_DWORD *)(v13 + 8) = v19;
          *(_QWORD *)(v13 + 12) = v23;
        }
        v18 = v11 - 24;
      }
      while (v10 < v11);
    }
    if (v10 < v11)
    {
      v24 = *(_QWORD *)v10;
      v25 = *(_DWORD *)(v10 + 16);
      *(_QWORD *)v10 = *(_QWORD *)v11;
      v26 = *(_QWORD *)(v10 + 8);
      *(_DWORD *)(v10 + 8) = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v10 + 12) = *(_DWORD *)(v11 + 12);
      *(_DWORD *)(v10 + 16) = *(_DWORD *)(v11 + 16);
      *(_QWORD *)v11 = v24;
      *(_QWORD *)(v11 + 8) = v26;
      *(_DWORD *)(v11 + 16) = v25;
      goto LABEL_11;
    }
    v44 = v7;
    if (v12 > v5)
    {
      v27 = 0;
      do
      {
        v28 = v12 + v27;
        v29 = v10 + v27;
        v30 = *(_QWORD *)(v12 + v27 - 24);
        v31 = *(_DWORD *)(v12 + v27 - 8);
        *(_QWORD *)(v28 - 24) = *(_QWORD *)(v10 + v27 - 24);
        v32 = *(_QWORD *)(v12 + v27 - 16);
        *(_DWORD *)(v28 - 16) = *(_DWORD *)(v10 + v27 - 16);
        *(_DWORD *)(v28 - 12) = *(_DWORD *)(v10 + v27 - 12);
        *(_DWORD *)(v28 - 8) = *(_DWORD *)(v10 + v27 - 8);
        *(_QWORD *)(v29 - 24) = v30;
        *(_QWORD *)(v29 - 16) = v32;
        *(_DWORD *)(v29 - 8) = v31;
        v27 -= 24;
      }
      while (v12 + v27 > v5);
      v10 += v27;
    }
    while (v13 < v4)
    {
      v33 = *(_QWORD *)v13;
      v34 = *(_DWORD *)(v13 + 16);
      *(_QWORD *)v13 = *(_QWORD *)v11;
      v35 = *(_QWORD *)(v13 + 8);
      *(_DWORD *)(v13 + 8) = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v13 + 12) = *(_DWORD *)(v11 + 12);
      *(_DWORD *)(v13 + 16) = *(_DWORD *)(v11 + 16);
      *(_QWORD *)v11 = v33;
      *(_QWORD *)(v11 + 8) = v35;
      *(_DWORD *)(v11 + 16) = v34;
      v11 += 24;
      v13 += 24;
    }
    v36 = v10 - v5;
    v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v5) >> 3);
    v38 = v11 - v10;
    v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v10) >> 3);
    if (v37 <= v39)
    {
      v40 = v4 - v11;
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v11) >> 3)) <= v39)
      {
        if (v36 == 24)
        {
          v41 = v44 + 1;
        }
        else
        {
          if (v36 < 25)
            goto LABEL_53;
          v41 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v5, v10, a3) + v44;
        }
        v44 = v41;
LABEL_53:
        if (v40 == 24)
        {
          v7 = v44 + 1;
        }
        else if (v40 < 25)
        {
          v7 = v44;
        }
        else
        {
          v7 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v11, v4, a3) + v44;
        }
        if (v38 == 24)
        {
          ++v7;
        }
        else if (v38 >= 25)
        {
          if (v9 == -1)
          {
            ++v7;
            v5 = v11;
            goto LABEL_64;
          }
          ++a3;
        }
        v5 = v10;
LABEL_64:
        v4 = v11;
        goto LABEL_65;
      }
    }
    if (v38 == 24)
      goto LABEL_32;
    if (v38 < 25)
    {
      v7 = v44;
    }
    else if (v8 == -1)
    {
LABEL_32:
      v7 = v44 + 1;
    }
    else
    {
      v7 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v10, v11, a3 + 1) + v44;
    }
    v42 = v4 - v11;
    if (v37 >= (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v11) >> 3)))
    {
      if (v42 == 24)
      {
        ++v7;
      }
      else if (v42 >= 25)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v11, v4, a3);
      }
      v4 = v10;
    }
    else
    {
      if (v36 == 24)
      {
        ++v7;
      }
      else if (v36 >= 25)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v5, v10, a3);
      }
      v5 = v11;
    }
LABEL_65:
    v6 = v4 - v5;
  }
  while ((uint64_t)(v4 - v5) > 240);
LABEL_69:
  if (v6 >= 25)
    v7 += marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::ReverseKey *>(v5, v4, a3);
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;

  if (*(unsigned int *)(a1 + 8) <= a4)
    v4 = -1;
  else
    v4 = *(unsigned __int8 *)(~a4 + *(_QWORD *)a1);
  if (*(unsigned int *)(a2 + 8) <= a4)
    v5 = -1;
  else
    v5 = *(unsigned __int8 *)(~a4 + *(_QWORD *)a2);
  if (*(unsigned int *)(a3 + 8) <= a4)
    v6 = -1;
  else
    v6 = *(unsigned __int8 *)(~a4 + *(_QWORD *)a3);
  if (v4 <= v5)
    v7 = v5;
  else
    v7 = v4;
  if (v4 >= v5)
    v4 = v5;
  if (v4 <= v6)
    v4 = v6;
  if (v7 >= v6)
    return v4;
  else
    return v7;
}

uint64_t marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::ReverseKey *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;

  v3 = a1 + 24;
  if (a1 + 24 >= a2)
    return 1;
  v7 = 1;
  do
  {
    v8 = v3;
    if (v3 <= a1)
    {
      v10 = 0;
    }
    else
    {
      while (1)
      {
        v9 = v8 - 24;
        v10 = marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::ReverseKey>(v8 - 24, v8, a3);
        if (v10 < 1)
          break;
        v11 = *(_QWORD *)(v8 - 24);
        v12 = *(_DWORD *)(v8 - 8);
        *(_QWORD *)(v8 - 24) = *(_QWORD *)v8;
        v13 = *(_QWORD *)(v8 + 8);
        *(_DWORD *)(v8 - 8) = *(_DWORD *)(v8 + 16);
        *(_QWORD *)v8 = v11;
        v14 = *(_QWORD *)(v8 - 16);
        *(_QWORD *)(v8 - 16) = v13;
        *(_QWORD *)(v8 + 8) = v14;
        *(_DWORD *)(v8 + 16) = v12;
        v8 -= 24;
        if (v9 <= a1)
        {
          v10 = 1;
          break;
        }
      }
    }
    if (v10)
      ++v7;
    v3 += 24;
  }
  while (v3 < a2);
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  int v9;
  int v10;
  uint64_t result;
  unsigned int v12;

  v3 = *(unsigned int *)(a1 + 8);
  v4 = *(unsigned int *)(a2 + 8);
  v5 = v3 - a3;
  if (v3 <= a3)
  {
LABEL_6:
    if (v3 < v4)
      v12 = -1;
    else
      v12 = 1;
    if ((_DWORD)v3 == (_DWORD)v4)
      return 0;
    else
      return v12;
  }
  else
  {
    v6 = v4 - a3;
    v7 = (unsigned __int8 *)(*(_QWORD *)a2 + ~a3);
    v8 = (unsigned __int8 *)(*(_QWORD *)a1 + ~a3);
    while (v6)
    {
      v9 = *v8;
      v10 = *v7;
      result = (v9 - v10);
      if (v9 != v10)
        return result;
      --v6;
      --v7;
      --v8;
      if (!--v5)
        goto LABEL_6;
    }
    return 1;
  }
}

char *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::realloc(uint64_t *a1, uint64_t a2)
{
  char *result;
  uint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;

  result = (char *)operator new[](12 * a2, MEMORY[0x1E0DE4E10]);
  v5 = a1[3];
  if (v5)
  {
    v6 = (_DWORD *)(a1[1] + 8);
    v7 = result + 8;
    do
    {
      *((_QWORD *)v7 - 1) = *((_QWORD *)v6 - 1);
      v8 = *v6;
      v6 += 3;
      *v7 = v8;
      v7 += 3;
      --v5;
    }
    while (v5);
  }
  v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
    JUMPOUT(0x1D17BC778);
  return result;
}

uint64_t marisa::grimoire::vector::Vector<unsigned char>::map_(uint64_t a1, marisa::grimoire::io::Mapper *this)
{
  unint64_t v4;

  v4 = *(_QWORD *)marisa::grimoire::io::Mapper::map_data(this, 8uLL);
  *(_QWORD *)(a1 + 16) = marisa::grimoire::io::Mapper::map_data(this, v4);
  marisa::grimoire::io::Mapper::seek(this, -(int)v4 & 7);
  *(_QWORD *)(a1 + 24) = v4;
  return marisa::grimoire::vector::Vector<unsigned long long>::fix(a1);
}

uint64_t marisa::grimoire::vector::Vector<unsigned char>::read_(uint64_t a1, marisa::grimoire::io::Reader *this)
{
  size_t v4;
  size_t v6;

  v6 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)this, (char *)&v6, 8uLL);
  v4 = v6;
  marisa::grimoire::vector::Vector<char>::resize((uint64_t *)a1, v6);
  marisa::grimoire::io::Reader::read<unsigned char>((uint64_t)this, *(char **)(a1 + 8), v4);
  return marisa::grimoire::io::Reader::seek((uint64_t)this, -(int)v6 & 7);
}

uint64_t marisa::grimoire::io::Reader::read<unsigned char>(uint64_t a1, char *a2, size_t a3)
{
  _QWORD *exception;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x20000001FLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:31: MARISA_NULL_"
                   "ERROR: (objs == NULL) && (num_objs != 0)";
  }
  return marisa::grimoire::io::Reader::read_data(a1, a2, a3);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::read_(uint64_t a1, marisa::grimoire::io::Reader *this)
{
  unint64_t v4;
  _QWORD *exception;
  unint64_t v7;

  v7 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)this, (char *)&v7, 8uLL);
  v4 = v7 / 0xC;
  if (v7 % 0xC)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000D5;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:213: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::resize((uint64_t *)a1, v7 / 0xC);
  marisa::grimoire::io::Reader::read<marisa::grimoire::vector::RankIndex>((uint64_t)this, *(char **)(a1 + 8), v4);
  return marisa::grimoire::io::Reader::seek((uint64_t)this, -(int)v7 & 7);
}

uint64_t marisa::grimoire::vector::Vector<unsigned char>::write_(uint64_t a1, marisa::grimoire::io::Writer *this)
{
  uint64_t __buf;

  __buf = *(_QWORD *)(a1 + 24);
  marisa::grimoire::io::Writer::write_data((uint64_t)this, (char *)&__buf, 8uLL);
  marisa::grimoire::io::Writer::write<unsigned char>((uint64_t)this, *(char **)(a1 + 16), *(_QWORD *)(a1 + 24));
  return marisa::grimoire::io::Writer::seek((uint64_t)this, -*(_DWORD *)(a1 + 24) & 7);
}

uint64_t marisa::grimoire::io::Writer::write<unsigned char>(uint64_t a1, char *a2, size_t a3)
{
  _QWORD *exception;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x20000001ELL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:30: MARISA_NULL_"
                   "ERROR: (objs == NULL) && (num_objs != 0)";
  }
  return marisa::grimoire::io::Writer::write_data(a1, a2, a3);
}

double marisa::grimoire::trie::Tail::Tail(marisa::grimoire::trie::Tail *this)
{
  double result;

  result = 0.0;
  *(_OWORD *)((char *)this + 25) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 73) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *(_OWORD *)((char *)this + 185) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *(_OWORD *)((char *)this + 233) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 137) = 0u;
  return result;
}

uint64_t marisa::grimoire::trie::Tail::build(__int128 *a1, uint64_t a2, __int128 *a3, int a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  uint64_t result;
  _QWORD *exception;
  const char *v17;
  _OWORD v18[3];
  _OWORD v19[4];
  __int128 v20;
  _BYTE v21[25];
  __int128 v22;
  _BYTE v23[25];
  __int128 v24;
  _BYTE v25[25];

  if (!a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc";
    exception[2] = 0x20000000DLL;
    v17 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc:13: MARISA_NULL_ERROR: offsets == NULL";
    goto LABEL_28;
  }
  if (a4 == 0x2000)
    goto LABEL_15;
  if (a4 != 4096)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc";
    exception[2] = 0x500000024;
    v17 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc:36: MARISA_CODE_ERROR: undefined tail mode";
LABEL_28:
    exception[3] = v17;
  }
  v5 = *(_QWORD *)(a2 + 24);
  if (v5)
  {
    v6 = 0;
    a4 = 4096;
    while (1)
    {
      v7 = *(_QWORD *)(a2 + 8) + 16 * v6;
      v8 = *(unsigned int *)(v7 + 8);
      if ((_DWORD)v8)
        break;
LABEL_11:
      if (++v6 == v5)
        goto LABEL_15;
    }
    v9 = -v8;
    v10 = *(_QWORD *)v7 + 1;
    while (*(_BYTE *)(v10 + v9))
    {
      if (__CFADD__(v9++, 1))
        goto LABEL_11;
    }
    a4 = 0x2000;
  }
  else
  {
    a4 = 4096;
  }
LABEL_15:
  memset(v18, 0, 41);
  memset(v19, 0, 41);
  v22 = 0u;
  memset(v23, 0, sizeof(v23));
  v24 = 0u;
  memset(v25, 0, sizeof(v25));
  v19[3] = 0u;
  v20 = 0u;
  memset(v21, 0, sizeof(v21));
  marisa::grimoire::trie::Tail::build_((uint64_t)v18, a2, a3, a4);
  v12 = *a1;
  *a1 = v18[0];
  v18[0] = v12;
  v13 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v18[1];
  *(_QWORD *)&v18[1] = v13;
  v14 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v18[1] + 8);
  *(_OWORD *)((char *)&v18[1] + 8) = v14;
  LOBYTE(v13) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v18[2]);
  BYTE8(v18[2]) = v13;
  marisa::grimoire::vector::BitVector::swap((marisa::grimoire::vector::BitVector *)(a1 + 3), (marisa::grimoire::vector::BitVector *)v19);
  if ((_QWORD)v24)
    MEMORY[0x1D17BC778](v24, 0x1000C8077774924);
  if ((_QWORD)v22)
    MEMORY[0x1D17BC778](v22, 0x1000C8077774924);
  if ((_QWORD)v20)
    MEMORY[0x1D17BC778](v20, 0x1000C8077774924);
  if (*(_QWORD *)&v19[0])
    MEMORY[0x1D17BC778](*(_QWORD *)&v19[0], 0x1000C8077774924);
  result = *(_QWORD *)&v18[0];
  if (*(_QWORD *)&v18[0])
    return MEMORY[0x1D17BC778](*(_QWORD *)&v18[0], 0x1000C8077774924);
  return result;
}

void sub_1CDF9C09C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  marisa::grimoire::trie::Tail::~Tail((marisa::grimoire::trie::Tail *)&a9);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::Tail::build_(uint64_t a1, uint64_t a2, __int128 *a3, int a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t i;
  unint64_t v25;
  __int128 v26;
  uint64_t v27;
  __int128 v28;
  uint64_t result;
  _QWORD *exception;
  _QWORD *v31;
  char v32;
  _QWORD v33[2];
  _OWORD v34[3];

  v8 = *(_QWORD *)(a2 + 24);
  v9 = *(_QWORD *)(a2 + 8);
  if (v8)
  {
    v10 = 0;
    v11 = (_DWORD *)(v9 + 12);
    do
    {
      *v11 = v10;
      v11 += 4;
      ++v10;
    }
    while (v8 != v10);
  }
  marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v9, v9 + 16 * v8, 0);
  memset(v34, 0, 41);
  v12 = *(_QWORD *)(a2 + 24);
  LODWORD(v33[0]) = 0;
  marisa::grimoire::vector::Vector<unsigned int>::resize((uint64_t *)v34, v12, v33);
  v33[0] = 0;
  v33[1] = 0;
  v13 = *(_QWORD *)(a2 + 24);
  if (v13)
  {
    v14 = v33;
    do
    {
      --v13;
      v15 = *(_QWORD *)(a2 + 8);
      v16 = v15 + 16 * v13;
      v18 = (unsigned int *)(v16 + 8);
      v17 = *(unsigned int *)(v16 + 8);
      if (!*(_DWORD *)(v16 + 8))
      {
        exception = __cxa_allocate_exception(0x20uLL);
        *exception = &off_1E8B57FF8;
        exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc";
        exception[2] = 0x4000000AALL;
        exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc:170: MARISA_RANGE_E"
                       "RROR: current.length() == 0";
      }
      v19 = 0;
      v20 = 0;
      v21 = *((unsigned int *)v14 + 2);
      while (v21 != v20)
      {
        if (*(unsigned __int8 *)(*v14 + v19) != *(unsigned __int8 *)(*(_QWORD *)v16 + v19))
          goto LABEL_13;
        ++v20;
        --v19;
        if (v17 == v20)
          goto LABEL_14;
      }
      v20 = *((unsigned int *)v14 + 2);
LABEL_13:
      if (v20 != v17)
      {
        v22 = *((_QWORD *)&v34[0] + 1);
        goto LABEL_17;
      }
LABEL_14:
      v22 = *((_QWORD *)&v34[0] + 1);
      if ((_DWORD)v21)
      {
        *(_DWORD *)(*((_QWORD *)&v34[0] + 1) + 4 * *(unsigned int *)(v15 + 16 * v13 + 12)) = v21
                                                                                             - v17
                                                                                             + *(_DWORD *)(*((_QWORD *)&v34[0] + 1) + 4 * *((unsigned int *)v14 + 3));
        goto LABEL_29;
      }
LABEL_17:
      *(_DWORD *)(v22 + 4 * *(unsigned int *)(v15 + 16 * v13 + 12)) = *(_QWORD *)(a1 + 24);
      v23 = *v18;
      if ((_DWORD)v23)
      {
        for (i = 0; i < v23; ++i)
        {
          v32 = *(_BYTE *)(*(_QWORD *)v16 - v23 + i + 1);
          marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)a1, &v32);
          v23 = *v18;
        }
        if (a4 != 4096)
        {
          if (v23 >= 2)
          {
            v25 = 1;
            do
            {
              marisa::grimoire::vector::BitVector::push_back((uint64_t *)(a1 + 48), 0);
              ++v25;
            }
            while (v25 < *v18);
          }
LABEL_27:
          marisa::grimoire::vector::BitVector::push_back((uint64_t *)(a1 + 48), 1);
          goto LABEL_28;
        }
      }
      else if (a4 != 4096)
      {
        goto LABEL_27;
      }
      v32 = 0;
      marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)a1, &v32);
LABEL_28:
      if (*(_DWORD *)(a1 + 28))
      {
        v31 = __cxa_allocate_exception(0x20uLL);
        *v31 = &off_1E8B57FF8;
        v31[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc";
        v31[2] = 0x7000000C0;
        v31[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc:192: MARISA_SIZE_ERROR: b"
                 "uf_.size() > MARISA_UINT32_MAX";
      }
LABEL_29:
      v14 = (_QWORD *)v16;
    }
    while (v13);
  }
  marisa::grimoire::vector::Vector<unsigned char>::shrink((_BYTE *)a1);
  v26 = *a3;
  *a3 = v34[0];
  v34[0] = v26;
  v27 = *((_QWORD *)a3 + 2);
  *((_QWORD *)a3 + 2) = *(_QWORD *)&v34[1];
  *(_QWORD *)&v34[1] = v27;
  v28 = *(__int128 *)((char *)a3 + 24);
  *(__int128 *)((char *)a3 + 24) = *(_OWORD *)((char *)&v34[1] + 8);
  *(_OWORD *)((char *)&v34[1] + 8) = v28;
  LOBYTE(v27) = *((_BYTE *)a3 + 40);
  *((_BYTE *)a3 + 40) = BYTE8(v34[2]);
  result = v26;
  BYTE8(v34[2]) = v27;
  if ((_QWORD)v26)
    return MEMORY[0x1D17BC778](v26, 0x1000C8077774924);
  return result;
}

void sub_1CDF9C3A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
    MEMORY[0x1D17BC778](a13, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t *marisa::grimoire::trie::Tail::swap(marisa::grimoire::trie::Tail *this, marisa::grimoire::trie::Tail *a2)
{
  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this, (uint64_t *)a2);
  return marisa::grimoire::vector::BitVector::swap((marisa::grimoire::trie::Tail *)((char *)this + 48), (marisa::grimoire::trie::Tail *)((char *)a2 + 48));
}

uint64_t marisa::grimoire::trie::Tail::map(marisa::grimoire::trie::Tail *this, marisa::grimoire::io::Mapper *a2)
{
  __int128 v4;
  uint64_t v5;
  __int128 v6;
  uint64_t result;
  __int128 v8[3];
  _OWORD v9[4];
  __int128 v10;
  _BYTE v11[25];
  __int128 v12;
  _BYTE v13[25];
  __int128 v14;
  _BYTE v15[25];

  memset(v8, 0, 41);
  memset(v9, 0, 41);
  v12 = 0u;
  memset(v13, 0, sizeof(v13));
  v14 = 0u;
  memset(v15, 0, sizeof(v15));
  v9[3] = 0u;
  v10 = 0u;
  memset(v11, 0, sizeof(v11));
  marisa::grimoire::vector::Vector<char>::map(v8, a2);
  marisa::grimoire::vector::BitVector::map((marisa::grimoire::vector::BitVector *)v9, a2);
  v4 = *(_OWORD *)this;
  *(_OWORD *)this = v8[0];
  v8[0] = v4;
  v5 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = *(_QWORD *)&v8[1];
  *(_QWORD *)&v8[1] = v5;
  v6 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 24) = *(__int128 *)((char *)&v8[1] + 8);
  *(__int128 *)((char *)&v8[1] + 8) = v6;
  LOBYTE(v5) = *((_BYTE *)this + 40);
  *((_BYTE *)this + 40) = BYTE8(v8[2]);
  BYTE8(v8[2]) = v5;
  marisa::grimoire::vector::BitVector::swap((marisa::grimoire::trie::Tail *)((char *)this + 48), (marisa::grimoire::vector::BitVector *)v9);
  if ((_QWORD)v14)
    MEMORY[0x1D17BC778](v14, 0x1000C8077774924);
  if ((_QWORD)v12)
    MEMORY[0x1D17BC778](v12, 0x1000C8077774924);
  if ((_QWORD)v10)
    MEMORY[0x1D17BC778](v10, 0x1000C8077774924);
  if (*(_QWORD *)&v9[0])
    MEMORY[0x1D17BC778](*(_QWORD *)&v9[0], 0x1000C8077774924);
  result = *(_QWORD *)&v8[0];
  if (*(_QWORD *)&v8[0])
    return MEMORY[0x1D17BC778](*(_QWORD *)&v8[0], 0x1000C8077774924);
  return result;
}

void sub_1CDF9C56C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  marisa::grimoire::trie::Tail::~Tail((marisa::grimoire::trie::Tail *)&a9);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::Tail::map_(marisa::grimoire::trie::Tail *this, marisa::grimoire::io::Mapper *a2)
{
  marisa::grimoire::vector::Vector<char>::map((__int128 *)this, a2);
  return marisa::grimoire::vector::BitVector::map((marisa::grimoire::trie::Tail *)((char *)this + 48), a2);
}

uint64_t marisa::grimoire::trie::Tail::read(marisa::grimoire::trie::Tail *this, marisa::grimoire::io::Reader *a2)
{
  __int128 v4;
  uint64_t v5;
  __int128 v6;
  uint64_t result;
  __int128 v8[3];
  _OWORD v9[4];
  __int128 v10;
  _BYTE v11[25];
  __int128 v12;
  _BYTE v13[25];
  __int128 v14;
  _BYTE v15[25];

  memset(v8, 0, 41);
  memset(v9, 0, 41);
  v12 = 0u;
  memset(v13, 0, sizeof(v13));
  v14 = 0u;
  memset(v15, 0, sizeof(v15));
  v9[3] = 0u;
  v10 = 0u;
  memset(v11, 0, sizeof(v11));
  marisa::grimoire::vector::Vector<char>::read(v8, a2);
  marisa::grimoire::vector::BitVector::read((marisa::grimoire::vector::BitVector *)v9, a2);
  v4 = *(_OWORD *)this;
  *(_OWORD *)this = v8[0];
  v8[0] = v4;
  v5 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = *(_QWORD *)&v8[1];
  *(_QWORD *)&v8[1] = v5;
  v6 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 24) = *(__int128 *)((char *)&v8[1] + 8);
  *(__int128 *)((char *)&v8[1] + 8) = v6;
  LOBYTE(v5) = *((_BYTE *)this + 40);
  *((_BYTE *)this + 40) = BYTE8(v8[2]);
  BYTE8(v8[2]) = v5;
  marisa::grimoire::vector::BitVector::swap((marisa::grimoire::trie::Tail *)((char *)this + 48), (marisa::grimoire::vector::BitVector *)v9);
  if ((_QWORD)v14)
    MEMORY[0x1D17BC778](v14, 0x1000C8077774924);
  if ((_QWORD)v12)
    MEMORY[0x1D17BC778](v12, 0x1000C8077774924);
  if ((_QWORD)v10)
    MEMORY[0x1D17BC778](v10, 0x1000C8077774924);
  if (*(_QWORD *)&v9[0])
    MEMORY[0x1D17BC778](*(_QWORD *)&v9[0], 0x1000C8077774924);
  result = *(_QWORD *)&v8[0];
  if (*(_QWORD *)&v8[0])
    return MEMORY[0x1D17BC778](*(_QWORD *)&v8[0], 0x1000C8077774924);
  return result;
}

void sub_1CDF9C700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  marisa::grimoire::trie::Tail::~Tail((marisa::grimoire::trie::Tail *)&a9);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::Tail::read_(marisa::grimoire::trie::Tail *this, marisa::grimoire::io::Reader *a2)
{
  marisa::grimoire::vector::Vector<char>::read((__int128 *)this, a2);
  return marisa::grimoire::vector::BitVector::read((marisa::grimoire::trie::Tail *)((char *)this + 48), a2);
}

uint64_t marisa::grimoire::trie::Tail::write(marisa::grimoire::trie::Tail *this, marisa::grimoire::io::Writer *a2)
{
  marisa::grimoire::vector::Vector<char>::write_((uint64_t)this, a2);
  return marisa::grimoire::vector::BitVector::write_((marisa::grimoire::trie::Tail *)((char *)this + 48), a2);
}

uint64_t *marisa::grimoire::trie::Tail::restore(uint64_t *this, marisa::Agent *a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  _BYTE *v7;

  v3 = a3;
  v4 = this;
  v5 = (uint64_t *)*((_QWORD *)a2 + 5);
  if (this[12])
  {
    do
    {
      this = marisa::grimoire::vector::Vector<char>::push_back(v5, (_BYTE *)(v4[2] + v3));
      v6 = *(_QWORD *)(v4[8] + ((v3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v3;
      ++v3;
    }
    while ((v6 & 1) == 0);
  }
  else
  {
    v7 = (_BYTE *)(this[2] + a3);
    if (*v7)
    {
      do
        this = marisa::grimoire::vector::Vector<char>::push_back(v5, v7);
      while (*++v7);
    }
  }
  return this;
}

uint64_t marisa::grimoire::trie::Tail::match(marisa::grimoire::trie::Tail *this, marisa::Agent *a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  unint64_t v12;

  v3 = *((_QWORD *)a2 + 5);
  v4 = *((_QWORD *)this + 2);
  if (*((_QWORD *)this + 12))
  {
    v5 = *(_DWORD *)(v3 + 100);
    v6 = *(_QWORD *)a2;
    v7 = *((_QWORD *)a2 + 1);
    do
    {
      if (*(unsigned __int8 *)(v4 + a3) != *(unsigned __int8 *)(v6 + v5))
        break;
      *(_DWORD *)(v3 + 100) = ++v5;
      if (((*(_QWORD *)(*((_QWORD *)this + 8) + ((a3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a3) & 1) != 0)
        return 1;
      ++a3;
    }
    while (v7 > v5);
  }
  else
  {
    v12 = v4 + a3;
    v8 = v4 + a3 - *(unsigned int *)(v3 + 100);
    v9 = *(_QWORD *)a2;
    v10 = *((_QWORD *)a2 + 1);
    v11 = *(unsigned __int8 *)v12;
    LODWORD(v12) = *(_DWORD *)(v3 + 100);
    while (v11 == *(unsigned __int8 *)(v9 + v12))
    {
      v12 = (v12 + 1);
      *(_DWORD *)(v3 + 100) = v12;
      v11 = *(unsigned __int8 *)(v8 + v12);
      if (!*(_BYTE *)(v8 + v12))
        return 1;
      if (v10 <= v12)
        return 0;
    }
  }
  return 0;
}

BOOL marisa::grimoire::trie::Tail::prefix_match(marisa::grimoire::trie::Tail *this, marisa::Agent *a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v6;
  unsigned int v7;
  _BYTE *v8;
  int v9;
  int v10;
  _BOOL8 v11;
  uint64_t v12;
  unsigned __int8 *v13;
  int v14;
  unint64_t v15;
  int v16;
  unsigned __int8 *v17;

  v3 = a3;
  v6 = *((_QWORD *)a2 + 5);
  if (*((_QWORD *)this + 12))
  {
    v7 = *(_DWORD *)(v6 + 100);
    while (1)
    {
      v8 = (_BYTE *)(*((_QWORD *)this + 2) + v3);
      v9 = *v8;
      v10 = *(unsigned __int8 *)(*(_QWORD *)a2 + v7);
      v11 = v9 == v10;
      if (v9 != v10)
        break;
      marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v6, v8);
      v7 = *(_DWORD *)(v6 + 100) + 1;
      *(_DWORD *)(v6 + 100) = v7;
      if (((*(_QWORD *)(*((_QWORD *)this + 8) + ((v3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v3) & 1) != 0)
        break;
      ++v3;
      if (*((_QWORD *)a2 + 1) <= (unint64_t)v7)
      {
        do
        {
          marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v6, (_BYTE *)(*((_QWORD *)this + 2) + v3));
          v12 = *(_QWORD *)(*((_QWORD *)this + 8) + ((v3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v3;
          ++v3;
        }
        while ((v12 & 1) == 0);
        return 1;
      }
    }
  }
  else
  {
    v15 = *((_QWORD *)this + 2) + a3;
    v13 = (unsigned __int8 *)(v15 - *(unsigned int *)(v6 + 100));
    v14 = *(unsigned __int8 *)v15;
    LODWORD(v15) = *(_DWORD *)(v6 + 100);
    while (1)
    {
      v16 = *(unsigned __int8 *)(*(_QWORD *)a2 + v15);
      v11 = v14 == v16;
      if (v14 != v16)
        break;
      marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v6, &v13[v15]);
      v15 = (*(_DWORD *)(v6 + 100) + 1);
      *(_DWORD *)(v6 + 100) = v15;
      v14 = v13[v15];
      if (!v13[v15])
        break;
      if (*((_QWORD *)a2 + 1) <= v15)
      {
        v17 = &v13[v15];
        do
          marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v6, v17);
        while (*++v17);
        return 1;
      }
    }
  }
  return v11;
}

uint64_t marisa::grimoire::trie::Tail::clear(marisa::grimoire::trie::Tail *this)
{
  uint64_t result;
  __int128 v2;
  _OWORD v3[4];
  __int128 v4;
  _BYTE v5[25];
  __int128 v6;
  _BYTE v7[25];
  __int128 v8;
  _BYTE v9[25];

  memset(v3, 0, 41);
  v6 = 0u;
  memset(v7, 0, sizeof(v7));
  v8 = 0u;
  memset(v9, 0, sizeof(v9));
  v3[3] = 0u;
  v4 = 0u;
  memset(v5, 0, sizeof(v5));
  v2 = *(_OWORD *)this;
  *(_OWORD *)this = 0u;
  *((_QWORD *)this + 2) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_BYTE *)this + 40) = 0;
  marisa::grimoire::vector::BitVector::swap((marisa::grimoire::vector::BitVector *)v3, (marisa::grimoire::trie::Tail *)((char *)this + 48));
  if ((_QWORD)v8)
    MEMORY[0x1D17BC778](v8, 0x1000C8077774924);
  if ((_QWORD)v6)
    MEMORY[0x1D17BC778](v6, 0x1000C8077774924);
  if ((_QWORD)v4)
    MEMORY[0x1D17BC778](v4, 0x1000C8077774924);
  if (*(_QWORD *)&v3[0])
    MEMORY[0x1D17BC778](*(_QWORD *)&v3[0], 0x1000C8077774924);
  result = v2;
  if ((_QWORD)v2)
    return MEMORY[0x1D17BC778](v2, 0x1000C8077774924);
  return result;
}

void sub_1CDF9CAFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  marisa::grimoire::trie::Tail::~Tail((marisa::grimoire::trie::Tail *)&a9);
  _Unwind_Resume(a1);
}

uint64_t *marisa::grimoire::vector::Vector<unsigned int>::resize(uint64_t *result, unint64_t a2, _DWORD *a3)
{
  unint64_t v4;
  uint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _DWORD *v10;

  v4 = a2;
  v5 = result;
  v6 = result[4];
  if (v6 < a2)
  {
    v7 = 2 * v6;
    if (v6 >> 61)
      v7 = 0x3FFFFFFFFFFFFFFFLL;
    if (v6 > a2 >> 1)
      a2 = v7;
    result = (uint64_t *)marisa::grimoire::vector::Vector<unsigned int>::realloc(result, a2);
  }
  v8 = v5[3];
  v9 = v4 - v8;
  if (v4 > v8)
  {
    v10 = (_DWORD *)(v5[1] + 4 * v8);
    do
    {
      *v10++ = *a3;
      --v9;
    }
    while (v9);
  }
  v5[3] = v4;
  return result;
}

uint64_t marisa::grimoire::vector::Vector<char>::map(__int128 *a1, marisa::grimoire::io::Mapper *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];

  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned char>::map_((uint64_t)v7, a2);
  v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  v4 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v7[1];
  *(_QWORD *)&v7[1] = v4;
  v5 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v7[2]);
  result = v3;
  BYTE8(v7[2]) = v4;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF9CC28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<char>::read(__int128 *a1, marisa::grimoire::io::Reader *a2)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  _OWORD v7[3];

  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<char>::read_((uint64_t)v7, a2);
  v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  v4 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = *(_QWORD *)&v7[1];
  *(_QWORD *)&v7[1] = v4;
  v5 = *(__int128 *)((char *)a1 + 24);
  *(__int128 *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((_BYTE *)a1 + 40);
  *((_BYTE *)a1 + 40) = BYTE8(v7[2]);
  result = v3;
  BYTE8(v7[2]) = v4;
  if ((_QWORD)v3)
    return MEMORY[0x1D17BC778](v3, 0x1000C8077774924);
  return result;
}

void sub_1CDF9CCE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
    MEMORY[0x1D17BC778](a9, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v42;

  v4 = a2;
  v5 = a1;
  v6 = a2 - a1;
  if ((uint64_t)(a2 - a1) < 161)
  {
    v7 = 0;
    goto LABEL_68;
  }
  v7 = 0;
  do
  {
    v8 = marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::Entry>(v5, v5 + 16 * ((unint64_t)v6 >> 5), v4 - 16, a3);
    v9 = v8;
    v10 = v5;
    v11 = v4;
    v12 = v5;
    v13 = v4;
    while (v10 < v11)
    {
      v14 = *(unsigned int *)(v10 + 8);
      v15 = a3 >= v14 ? -1 : *(unsigned __int8 *)(*(_QWORD *)v10 - a3);
      if (v15 > v8)
        break;
      if (v15 == v8)
      {
        v16 = *(_QWORD *)v10;
        v17 = *(_DWORD *)(v10 + 12);
        *(_QWORD *)v10 = *(_QWORD *)v12;
        *(_QWORD *)(v10 + 8) = *(_QWORD *)(v12 + 8);
        *(_QWORD *)v12 = v16;
        *(_DWORD *)(v12 + 8) = v14;
        *(_DWORD *)(v12 + 12) = v17;
        v12 += 16;
      }
LABEL_11:
      v10 += 16;
    }
    if (v10 < v11)
    {
      v18 = v11 - 16;
      do
      {
        v11 = v18;
        v19 = *(unsigned int *)(v18 + 8);
        if (a3 >= v19)
          v20 = -1;
        else
          v20 = *(unsigned __int8 *)(*(_QWORD *)v11 - a3);
        if (v20 < v8)
          break;
        if (v20 == v8)
        {
          v21 = *(_QWORD *)(v13 - 16);
          v13 -= 16;
          v22 = *(_QWORD *)v11;
          v23 = *(_DWORD *)(v11 + 12);
          *(_QWORD *)v11 = v21;
          *(_QWORD *)(v11 + 8) = *(_QWORD *)(v13 + 8);
          *(_QWORD *)v13 = v22;
          *(_DWORD *)(v13 + 8) = v19;
          *(_DWORD *)(v13 + 12) = v23;
        }
        v18 = v11 - 16;
      }
      while (v10 < v11);
    }
    if (v10 < v11)
    {
      v24 = *(_QWORD *)v10;
      *(_QWORD *)v10 = *(_QWORD *)v11;
      v25 = *(_QWORD *)(v11 + 8);
      *(_QWORD *)v11 = v24;
      v26 = *(_QWORD *)(v10 + 8);
      *(_QWORD *)(v10 + 8) = v25;
      *(_QWORD *)(v11 + 8) = v26;
      goto LABEL_11;
    }
    v42 = v7;
    while (v12 > v5)
    {
      v28 = *(_QWORD *)(v12 - 16);
      v12 -= 16;
      v27 = v28;
      v29 = *(_QWORD *)(v10 - 16);
      v10 -= 16;
      *(_QWORD *)v12 = v29;
      v30 = *(_QWORD *)(v10 + 8);
      *(_QWORD *)v10 = v27;
      v31 = *(_QWORD *)(v12 + 8);
      *(_QWORD *)(v12 + 8) = v30;
      *(_QWORD *)(v10 + 8) = v31;
    }
    while (v13 < v4)
    {
      v32 = *(_QWORD *)v13;
      *(_QWORD *)v13 = *(_QWORD *)v11;
      v33 = *(_QWORD *)(v11 + 8);
      *(_QWORD *)v11 = v32;
      v34 = *(_QWORD *)(v13 + 8);
      *(_QWORD *)(v13 + 8) = v33;
      *(_QWORD *)(v11 + 8) = v34;
      v11 += 16;
      v13 += 16;
    }
    v35 = v10 - v5;
    v36 = (uint64_t)(v10 - v5) >> 4;
    v37 = v11 - v10;
    if (v36 <= (uint64_t)(v11 - v10) >> 4)
    {
      v38 = v4 - v11;
      if (v37 >> 4 >= (uint64_t)(v4 - v11) >> 4)
      {
        if (v35 == 16)
        {
          v39 = v42 + 1;
        }
        else
        {
          if (v35 < 17)
            goto LABEL_52;
          v39 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v5, v10, a3) + v42;
        }
        v42 = v39;
LABEL_52:
        if (v38 == 16)
        {
          v7 = v42 + 1;
        }
        else if (v38 < 17)
        {
          v7 = v42;
        }
        else
        {
          v7 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v11, v4, a3) + v42;
        }
        if (v37 == 16)
        {
          ++v7;
        }
        else if (v37 >= 17)
        {
          if (v9 == -1)
          {
            ++v7;
            v5 = v11;
            goto LABEL_63;
          }
          ++a3;
        }
        v5 = v10;
LABEL_63:
        v4 = v11;
        goto LABEL_64;
      }
    }
    if (v37 == 16)
      goto LABEL_31;
    if (v37 < 17)
    {
      v7 = v42;
    }
    else if (v8 == -1)
    {
LABEL_31:
      v7 = v42 + 1;
    }
    else
    {
      v7 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v10, v11, a3 + 1) + v42;
    }
    v40 = v4 - v11;
    if (v36 >= (uint64_t)(v4 - v11) >> 4)
    {
      if (v40 == 16)
      {
        ++v7;
      }
      else if (v40 >= 17)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v11, v4, a3);
      }
      v4 = v10;
    }
    else
    {
      if (v35 == 16)
      {
        ++v7;
      }
      else if (v35 >= 17)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v5, v10, a3);
      }
      v5 = v11;
    }
LABEL_64:
    v6 = v4 - v5;
  }
  while ((uint64_t)(v4 - v5) > 160);
LABEL_68:
  if (v6 >= 17)
    v7 += marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::Entry *>(v5, v4, a3);
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::Entry>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;

  if (*(unsigned int *)(a1 + 8) <= a4)
    v4 = -1;
  else
    v4 = *(unsigned __int8 *)(*(_QWORD *)a1 - a4);
  if (*(unsigned int *)(a2 + 8) <= a4)
    v5 = -1;
  else
    v5 = *(unsigned __int8 *)(*(_QWORD *)a2 - a4);
  if (*(unsigned int *)(a3 + 8) <= a4)
    v6 = -1;
  else
    v6 = *(unsigned __int8 *)(*(_QWORD *)a3 - a4);
  if (v4 <= v5)
    v7 = v5;
  else
    v7 = v4;
  if (v4 >= v5)
    v4 = v5;
  if (v4 <= v6)
    v4 = v6;
  if (v7 >= v6)
    return v4;
  else
    return v7;
}

uint64_t marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::Entry *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  _QWORD *v3;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = (_QWORD *)(a1 + 16);
  if (a1 + 16 >= a2)
    return 1;
  v7 = 1;
  do
  {
    v8 = v3;
    if ((unint64_t)v3 <= a1)
    {
      v10 = 0;
    }
    else
    {
      while (1)
      {
        v9 = v8 - 2;
        v10 = marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::Entry>((uint64_t)(v8 - 2), (uint64_t)v8, a3);
        if (v10 < 1)
          break;
        v11 = *(v8 - 2);
        *(v8 - 2) = *v8;
        v12 = v8[1];
        *v8 = v11;
        v13 = *(v8 - 1);
        *(v8 - 1) = v12;
        v8[1] = v13;
        v8 -= 2;
        if ((unint64_t)v9 <= a1)
        {
          v10 = 1;
          break;
        }
      }
    }
    if (v10)
      ++v7;
    v3 += 2;
  }
  while ((unint64_t)v3 < a2);
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::Entry>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  int v9;
  int v10;
  uint64_t result;
  unsigned int v12;

  v3 = *(unsigned int *)(a1 + 8);
  v4 = *(unsigned int *)(a2 + 8);
  v5 = v3 - a3;
  if (v3 <= a3)
  {
LABEL_6:
    if (v3 < v4)
      v12 = -1;
    else
      v12 = 1;
    if ((_DWORD)v3 == (_DWORD)v4)
      return 0;
    else
      return v12;
  }
  else
  {
    v6 = v4 - a3;
    v7 = (unsigned __int8 *)(*(_QWORD *)a2 - a3);
    v8 = (unsigned __int8 *)(*(_QWORD *)a1 - a3);
    while (v6)
    {
      v9 = *v8;
      v10 = *v7;
      result = (v9 - v10);
      if (v9 != v10)
        return result;
      --v6;
      --v7;
      --v8;
      if (!--v5)
        goto LABEL_6;
    }
    return 1;
  }
}

uint64_t marisa::grimoire::vector::Vector<char>::read_(uint64_t a1, marisa::grimoire::io::Reader *this)
{
  size_t v4;
  size_t v6;

  v6 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)this, (char *)&v6, 8uLL);
  v4 = v6;
  marisa::grimoire::vector::Vector<char>::resize((uint64_t *)a1, v6);
  marisa::grimoire::io::Reader::read<char>((uint64_t)this, *(char **)(a1 + 8), v4);
  return marisa::grimoire::io::Reader::seek((uint64_t)this, -(int)v6 & 7);
}

uint64_t marisa::grimoire::io::Reader::read<char>(uint64_t a1, char *a2, size_t a3)
{
  _QWORD *exception;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/../io/reader.h";
    exception[2] = 0x20000001FLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/../io/reader.h:31: MA"
                   "RISA_NULL_ERROR: (objs == NULL) && (num_objs != 0)";
  }
  return marisa::grimoire::io::Reader::read_data(a1, a2, a3);
}

uint64_t marisa::grimoire::vector::Vector<char>::write_(uint64_t a1, marisa::grimoire::io::Writer *this)
{
  uint64_t __buf;

  __buf = *(_QWORD *)(a1 + 24);
  marisa::grimoire::io::Writer::write_data((uint64_t)this, (char *)&__buf, 8uLL);
  marisa::grimoire::io::Writer::write<char>((uint64_t)this, *(char **)(a1 + 16), *(_QWORD *)(a1 + 24));
  return marisa::grimoire::io::Writer::seek((uint64_t)this, -*(_DWORD *)(a1 + 24) & 7);
}

uint64_t marisa::grimoire::io::Writer::write<char>(uint64_t a1, char *a2, size_t a3)
{
  _QWORD *exception;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/../io/writer.h";
    exception[2] = 0x20000001ELL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/../io/writer.h:30: MA"
                   "RISA_NULL_ERROR: (objs == NULL) && (num_objs != 0)";
  }
  return marisa::grimoire::io::Writer::write_data(a1, a2, a3);
}

uint64_t marisa::grimoire::vector::BitVector::rank1(marisa::grimoire::vector::BitVector *this, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = a2 >> 9;
  v3 = *((_QWORD *)this + 10);
  v4 = *(unsigned int *)(v3 + 12 * (a2 >> 9));
  switch((a2 >> 6) & 7)
  {
    case 1uLL:
      v5 = *(_DWORD *)(v3 + 12 * v2 + 4) & 0x7F;
      goto LABEL_10;
    case 2uLL:
      v6 = (unint64_t)*(unsigned int *)(v3 + 12 * v2 + 4) >> 7;
      goto LABEL_5;
    case 3uLL:
      v6 = (unint64_t)*(unsigned int *)(v3 + 12 * v2 + 4) >> 15;
LABEL_5:
      v4 += v6;
      break;
    case 4uLL:
      v4 += (unint64_t)*(unsigned int *)(v3 + 12 * v2 + 4) >> 23;
      break;
    case 5uLL:
      v5 = *(_DWORD *)(v3 + 12 * v2 + 8) & 0x1FF;
      goto LABEL_10;
    case 6uLL:
      v5 = ((unint64_t)*(unsigned int *)(v3 + 12 * v2 + 8) >> 9) & 0x1FF;
      goto LABEL_10;
    case 7uLL:
      v5 = ((unint64_t)*(unsigned int *)(v3 + 12 * v2 + 8) >> 18) & 0x1FF;
LABEL_10:
      v4 += v5;
      break;
    default:
      break;
  }
  v7 = *(_QWORD *)(*((_QWORD *)this + 2) + 8 * (a2 >> 6)) & ~(-1 << a2);
  v8 = (((((v7 >> 1) & 0x5555555555555555) + (v7 & 0x5555555555555555)) >> 2) & 0x3333333333333333)
     + ((((v7 >> 1) & 0x5555555555555555) + (v7 & 0x5555555555555555)) & 0x3333333333333333);
  return v4 + ((0x101010101010101 * (((v8 >> 4) & 0x707070707070707) + (v8 & 0x707070707070707))) >> 56);
}

unint64_t marisa::grimoire::vector::BitVector::select0(marisa::grimoire::vector::BitVector *this, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v11;
  unint64_t v12;
  marisa::grimoire::vector::_anonymous_namespace_ *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v2 = *((_QWORD *)this + 16);
  if ((a2 & 0x1FF) == 0)
    return *(unsigned int *)(v2 + 4 * (a2 >> 9));
  v3 = *(_DWORD *)(v2 + 4 * (a2 >> 9)) >> 9;
  v4 = (*(_DWORD *)(v2 + 4 * (a2 >> 9) + 4) + 511) >> 9;
  v5 = *((_QWORD *)this + 10);
  if (v3 + 10 >= v4)
  {
    v7 = v5 + 12 * v3;
    v8 = v3-- << 9;
    v9 = (unsigned int *)(v7 + 12);
    do
    {
      v10 = *v9;
      v9 += 3;
      ++v3;
      v8 += 512;
    }
    while (v8 - v10 <= a2);
  }
  else
  {
    do
    {
      if (((v4 + v3) >> 1 << 9) - *(unsigned int *)(v5 + 12 * ((v4 + v3) >> 1)) > a2)
        v4 = (v4 + v3) >> 1;
      else
        v3 = (v4 + v3) >> 1;
    }
    while (v3 + 1 < v4);
  }
  v11 = (unsigned int *)(v5 + 12 * v3);
  v12 = v11[1];
  v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)(a2 - (v3 << 9) + *v11);
  v14 = 8 * v3;
  if ((unint64_t)v13 >= 256 - (v12 >> 23))
  {
    v15 = *(unsigned int *)(v5 + 12 * v3 + 8);
    v16 = (v15 >> 9) & 0x1FF;
    if ((unint64_t)v13 >= 384 - v16)
    {
      v18 = (v15 >> 18) & 0x1FF;
      if ((unint64_t)v13 >= 448 - v18)
      {
        v14 |= 7uLL;
        v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + v18 - 448);
      }
      else
      {
        v14 |= 6uLL;
        v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + v16 - 384);
      }
    }
    else if ((unint64_t)v13 >= 320 - (v15 & 0x1FF))
    {
      v14 |= 5uLL;
      v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + (v15 & 0x1FF) - 320);
    }
    else
    {
      v14 |= 4uLL;
      v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + (v12 >> 23) - 256);
    }
  }
  else if ((unint64_t)v13 >= 128 - (unint64_t)(v12 >> 7))
  {
    v17 = (v12 >> 15);
    if ((unint64_t)v13 >= 192 - v17)
    {
      v14 |= 3uLL;
      v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + v17 - 192);
    }
    else
    {
      v14 |= 2uLL;
      v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + (v12 >> 7) - 128);
    }
  }
  else if ((unint64_t)v13 >= 64 - (v12 & 0x7F))
  {
    v14 |= 1uLL;
    v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + (v12 & 0x7F) - 64);
  }
}

unint64_t marisa::grimoire::vector::`anonymous namespace'::select_bit(marisa::grimoire::vector::_anonymous_namespace_ *this, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;

  v3 = (((a3 - ((a3 >> 1) & 0x5555555555555555)) >> 2) & 0x3333333333333333)
     + ((a3 - ((a3 >> 1) & 0x5555555555555555)) & 0x3333333333333333);
  v4 = (v3 + (v3 >> 4)) & 0xF0F0F0F0F0F0F0FLL;
  v5 = __clz(__rbit64(((((0x101010101010101 * v4) | 0x8080808080808080)
                      - 0x101010101010101 * (_QWORD)this
                      - 0x101010101010101) >> 7) & 0x101010101010101));
  return v5
       + a2
                                                                     * ((_QWORD)this
                                                                      - ((unint64_t)(0x101010101010100 * v4) >> v5))
                                                                     + (a3 >> v5)];
}

unint64_t marisa::grimoire::vector::BitVector::select1(marisa::grimoire::vector::BitVector *this, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  marisa::grimoire::vector::_anonymous_namespace_ *v16;
  uint64_t v17;
  unint64_t v18;
  marisa::grimoire::vector::_anonymous_namespace_ *v19;
  BOOL v20;
  marisa::grimoire::vector::_anonymous_namespace_ *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  BOOL v28;
  marisa::grimoire::vector::_anonymous_namespace_ *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  marisa::grimoire::vector::_anonymous_namespace_ *v33;
  BOOL v34;

  v2 = *((_QWORD *)this + 22);
  if ((a2 & 0x1FF) == 0)
    return *(unsigned int *)(v2 + 4 * (a2 >> 9));
  v3 = *(_DWORD *)(v2 + 4 * (a2 >> 9)) >> 9;
  v4 = (*(_DWORD *)(v2 + 4 * (a2 >> 9) + 4) + 511) >> 9;
  v5 = *((_QWORD *)this + 10);
  if (v3 + 10 >= v4)
  {
    v7 = v5 + 12 * v3--;
    v8 = (unsigned int *)(v7 + 12);
    do
    {
      v9 = *v8;
      v8 += 3;
      ++v3;
    }
    while (v9 <= a2);
  }
  else
  {
    do
    {
      if (*(unsigned int *)(v5 + 12 * ((v4 + v3) >> 1)) > a2)
        v4 = (v4 + v3) >> 1;
      else
        v3 = (v4 + v3) >> 1;
    }
    while (v3 + 1 < v4);
  }
  v10 = (unsigned int *)(v5 + 12 * v3);
  v11 = v10[1];
  v12 = a2 - *v10;
  v13 = 8 * v3;
  if (v12 >= v11 >> 23)
  {
    v23 = v11 >> 23;
    v24 = *(unsigned int *)(v5 + 12 * v3 + 8);
    v25 = (v24 >> 9) & 0x1FF;
    v26 = (v24 >> 18) & 0x1FF;
    v27 = v13 | 7;
    v28 = v12 >= v26;
    if (v12 < v26)
      v29 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - v25);
    else
      v29 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - v26);
    if (!v28)
      v27 = v13 | 6;
    v30 = v24 & 0x1FF;
    v31 = v13 | 5;
    v32 = v13 | 4;
    v33 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - v23);
    v34 = v12 >= v30;
    if (v12 < v30)
      v21 = v33;
    else
      v21 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - v30);
    if (v34)
      v32 = v31;
    if (v12 < v25)
    {
      v22 = v32;
    }
    else
    {
      v21 = v29;
      v22 = v27;
    }
  }
  else
  {
    v14 = v11 >> 7;
    v15 = (v11 >> 15);
    v16 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - (v11 >> 7));
    if (v12 < v15)
    {
      v17 = v13 | 2;
    }
    else
    {
      v16 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - v15);
      v17 = v13 | 3;
    }
    v18 = v11 & 0x7F;
    v20 = v12 >= v18;
    v19 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - v18);
    if (v20)
      v13 |= 1uLL;
    else
      v19 = (marisa::grimoire::vector::_anonymous_namespace_ *)v12;
    v20 = v12 >= v14;
    if (v12 < v14)
      v21 = v19;
    else
      v21 = v16;
    if (v20)
      v22 = v17;
    else
      v22 = v13;
  }
}

void marisa::grimoire::vector::BitVector::build_index(marisa::grimoire::vector::BitVector *this, const marisa::grimoire::vector::BitVector *a2, int a3, int a4)
{
  uint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  __int16 v14;
  unint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int v18;
  unsigned int v19;
  _DWORD *v20;
  unsigned int v21;
  _DWORD *v22;
  unsigned int v23;
  _DWORD *v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t *v28;
  _DWORD *v29;
  _DWORD *v30;
  int v31;

  v8 = (uint64_t *)((char *)this + 64);
  v9 = *((_QWORD *)a2 + 6);
  if ((v9 & 0x1FF) != 0)
    v10 = (v9 >> 9) + 1;
  else
    v10 = v9 >> 9;
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::resize(v8, v10 + 1);
  v11 = *((_QWORD *)a2 + 6);
  if (v11)
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    do
    {
      if ((v12 & 0x3F) == 0)
        __asm { BR              X12 }
      if (((*(_QWORD *)(*((_QWORD *)a2 + 2) + 8 * (v12 >> 6)) >> (v12 & 0x3F)) & 1) != 0)
      {
        if (a4 && (v13 & 0x1FF) == 0)
        {
          v31 = v12;
          marisa::grimoire::vector::Vector<unsigned int>::push_back((uint64_t *)this + 20, &v31);
        }
        ++v13;
      }
      else
      {
        if (a3 && (v14 & 0x1FF) == 0)
        {
          v31 = v12;
          marisa::grimoire::vector::Vector<unsigned int>::push_back((uint64_t *)this + 14, &v31);
        }
        ++v14;
      }
      ++v12;
      v11 = *((_QWORD *)a2 + 6);
    }
    while (v12 < v11);
    if ((v11 & 0x1FF) != 0)
    {
      v15 = (v11 - 1) >> 9;
      switch(((unint64_t)(v11 - 1) >> 6) & 7)
      {
        case 0uLL:
          v16 = *((_QWORD *)this + 9);
          v17 = (_DWORD *)(v16 + 12 * v15);
          v18 = v13 - *v17;
          v19 = v17[1] & 0xFFFFFF80 | v18 & 0x7F;
          v17[1] = v19;
          goto LABEL_23;
        case 1uLL:
          v16 = *((_QWORD *)this + 9);
          v20 = (_DWORD *)(v16 + 12 * v15);
          v19 = v20[1];
          v18 = v13 - *v20;
LABEL_23:
          v21 = v19 & 0xFFFF807F | (v18 << 7);
          *(_DWORD *)(v16 + 12 * v15 + 4) = v21;
          goto LABEL_25;
        case 2uLL:
          v16 = *((_QWORD *)this + 9);
          v22 = (_DWORD *)(v16 + 12 * v15);
          v21 = v22[1];
          v18 = v13 - *v22;
LABEL_25:
          v23 = v21 & 0xFF807FFF | (v18 << 15);
          *(_DWORD *)(v16 + 12 * v15 + 4) = v23;
          goto LABEL_27;
        case 3uLL:
          v16 = *((_QWORD *)this + 9);
          v24 = (_DWORD *)(v16 + 12 * v15);
          v23 = v24[1];
          v18 = v13 - *v24;
LABEL_27:
          *(_DWORD *)(v16 + 12 * v15 + 4) = v23 & 0x7FFFFF | ((unsigned __int16)v18 << 23);
          goto LABEL_29;
        case 4uLL:
          v16 = *((_QWORD *)this + 9);
          v18 = v13 - *(_DWORD *)(v16 + 12 * v15);
LABEL_29:
          v25 = v16 + 12 * v15;
          v26 = *(_DWORD *)(v25 + 8) & 0xFFFFFE00 | v18 & 0x1FF;
          *(_DWORD *)(v25 + 8) = v26;
          goto LABEL_30;
        case 5uLL:
          v16 = *((_QWORD *)this + 9);
          v29 = (_DWORD *)(v16 + 12 * v15);
          v26 = v29[2];
          v18 = v13 - *v29;
LABEL_30:
          v27 = v26 & 0xFFFC01FF | ((v18 & 0x1FF) << 9);
          *(_DWORD *)(v16 + 12 * v15 + 8) = v27;
          goto LABEL_31;
        case 6uLL:
          v16 = *((_QWORD *)this + 9);
          v30 = (_DWORD *)(v16 + 12 * v15);
          v27 = v30[2];
          v18 = v13 - *v30;
LABEL_31:
          *(_DWORD *)(v16 + 12 * v15 + 8) = v27 & 0xF803FFFF | ((v18 & 0x1FF) << 18);
          break;
        default:
          break;
      }
    }
  }
  else
  {
    v13 = 0;
  }
  *((_QWORD *)this + 6) = v11;
  *((_QWORD *)this + 7) = *((_QWORD *)a2 + 7);
  *(_DWORD *)(*((_QWORD *)this + 9) + 12 * *((_QWORD *)this + 11) - 12) = v13;
  if (a3)
  {
    v31 = *((_QWORD *)a2 + 6);
    marisa::grimoire::vector::Vector<unsigned int>::push_back((uint64_t *)this + 14, &v31);
    marisa::grimoire::vector::Vector<unsigned int>::shrink((_DWORD *)this + 28);
  }
  if (a4)
  {
    v28 = (uint64_t *)((char *)this + 160);
    v31 = *((_QWORD *)a2 + 6);
    marisa::grimoire::vector::Vector<unsigned int>::push_back(v28, &v31);
    marisa::grimoire::vector::Vector<unsigned int>::shrink(v28);
  }
}

uint64_t *marisa::grimoire::vector::Vector<unsigned int>::push_back(uint64_t *result, _DWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = result;
  v4 = result[3];
  v5 = result[4];
  v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    v7 = 2 * v5;
    if (v5 >> 61)
      v7 = 0x3FFFFFFFFFFFFFFFLL;
    if (v5 <= v6 >> 1)
      v8 = v6;
    else
      v8 = v7;
    result = (uint64_t *)marisa::grimoire::vector::Vector<unsigned int>::realloc(result, v8);
    v4 = v3[3];
    v6 = v4 + 1;
  }
  *(_DWORD *)(v3[1] + 4 * v4) = *a2;
  v3[3] = v6;
  return result;
}

_DWORD *marisa::grimoire::vector::Vector<unsigned int>::shrink(_DWORD *result)
{
  uint64_t v1;
  _QWORD *exception;

  if (*((_BYTE *)result + 40))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/vector/vector.h";
    exception[2] = 0x100000064;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/vector/vector.h:100: MARISA_STATE_ERROR: fixed_";
  }
  v1 = *((_QWORD *)result + 3);
  if (v1 != *((_QWORD *)result + 4))
    return marisa::grimoire::vector::Vector<unsigned int>::realloc((uint64_t *)result, v1);
  return result;
}

double marisa::Keyset::Keyset(marisa::Keyset *this)
{
  double result;

  *((_QWORD *)this + 12) = 0;
  result = 0.0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

size_t marisa::Keyset::push_back(size_t *a1, uint64_t a2)
{
  size_t result;
  unint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  size_t v9;

  result = marisa::Keyset::reserve(a1, *(unsigned int *)(a2 + 8));
  if (*(_DWORD *)(a2 + 8))
  {
    v5 = 0;
    do
    {
      *(_BYTE *)(result + v5) = *(_BYTE *)(*(_QWORD *)a2 + v5);
      ++v5;
      v6 = *(unsigned int *)(a2 + 8);
    }
    while (v5 < v6);
    v7 = *(_DWORD *)(a2 + 8);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  v8 = *(_QWORD *)(a1[6] + ((a1[11] >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * a1[11];
  *(_QWORD *)v8 = result;
  *(_DWORD *)(v8 + 8) = v7;
  *(_DWORD *)(v8 + 12) = *(_DWORD *)(a2 + 12);
  v9 = a1[12] + v6;
  ++a1[11];
  a1[12] = v9;
  return result;
}

size_t marisa::Keyset::reserve(size_t *this, size_t __sz)
{
  size_t result;
  size_t v5;

  if (this[7] == this[11] >> 8)
    marisa::Keyset::append_key_block((marisa::Keyset *)this);
  if (__sz < 0x401)
  {
    v5 = this[10];
    if (v5 < __sz)
    {
      marisa::Keyset::append_base_block((uint64_t *)this);
      v5 = this[10];
    }
    result = this[9];
    this[9] = result + __sz;
    this[10] = v5 - __sz;
  }
  else
  {
    marisa::Keyset::append_extra_block((marisa::Keyset *)this, __sz);
    return *(_QWORD *)(this[3] + 8 * this[4] - 8);
  }
  return result;
}

size_t marisa::Keyset::push_back(marisa::Keyset *this, uint64_t a2, char a3)
{
  size_t result;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (*((_QWORD *)this + 7) == *((_QWORD *)this + 11) >> 8)
    marisa::Keyset::append_key_block(this);
  result = marisa::Keyset::reserve((size_t *)this, *(unsigned int *)(a2 + 8) + 1);
  if (*(_DWORD *)(a2 + 8))
  {
    v7 = 0;
    do
    {
      *(_BYTE *)(result + v7) = *(_BYTE *)(*(_QWORD *)a2 + v7);
      ++v7;
      v8 = *(unsigned int *)(a2 + 8);
    }
    while (v7 < v8);
  }
  else
  {
    v8 = 0;
  }
  *(_BYTE *)(result + v8) = a3;
  v9 = *(_QWORD *)(*((_QWORD *)this + 6) + ((*((_QWORD *)this + 11) >> 5) & 0x7FFFFFFFFFFFFF8))
     + 16 * *((_QWORD *)this + 11);
  v10 = *(unsigned int *)(a2 + 8);
  *(_QWORD *)v9 = result;
  *(_DWORD *)(v9 + 8) = v10;
  *(_DWORD *)(v9 + 12) = *(_DWORD *)(a2 + 12);
  v11 = *((_QWORD *)this + 12) + v10;
  ++*((_QWORD *)this + 11);
  *((_QWORD *)this + 12) = v11;
  return result;
}

uint64_t marisa::Keyset::append_key_block(marisa::Keyset *this)
{
  uint64_t v2;
  unint64_t v3;
  _BOOL4 v4;
  size_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  _QWORD *v18;
  _QWORD *exception;
  uint64_t v20;

  v2 = *((_QWORD *)this + 7);
  if (v2 == *((_QWORD *)this + 8))
  {
    if (v2)
      v3 = 2 * v2;
    else
      v3 = 1;
    v4 = v3 >> 61 != 0;
    if (8 * v3 >= 0xFFFFFFFFFFFFFFF0)
      v4 = 1;
    if (v4)
      v5 = -1;
    else
      v5 = 8 * v3 + 16;
    v6 = operator new[](v5, MEMORY[0x1E0DE4E10]);
    if (!v6)
    {
      v20 = 0;
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &off_1E8B57FF8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
      exception[2] = 0x8000000A9;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:169: MARISA_MEMORY_ERROR: new_blo"
                     "cks.get() == NULL";
    }
    *v6 = 8;
    v6[1] = v3;
    v7 = (uint64_t)(v6 + 2);
    if (v3)
      bzero(v6 + 2, 8 * v3);
    v20 = v7;
    if (v2)
    {
      for (i = 0; i != v2; ++i)
      {
        v9 = *((_QWORD *)this + 6);
        v10 = v20;
        v11 = *(_QWORD *)(v9 + 8 * i);
        *(_QWORD *)(v9 + 8 * i) = *(_QWORD *)(v20 + 8 * i);
        *(_QWORD *)(v10 + 8 * i) = v11;
      }
      v7 = v20;
    }
    v12 = *((_QWORD *)this + 6);
    *((_QWORD *)this + 6) = v7;
    v20 = v12;
    *((_QWORD *)this + 8) = v3;
    marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array(&v20);
  }
  v13 = operator new[](0x1000uLL, MEMORY[0x1E0DE4E10]);
  if (!v13)
  {
    v18 = __cxa_allocate_exception(0x20uLL);
    *v18 = &off_1E8B57FF8;
    v18[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    v18[2] = 0x8000000B1;
    v18[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:177: MARISA_MEMORY_ERROR: new_block.get() == NULL";
  }
  v14 = v13;
  bzero(v13, 0x1000uLL);
  v16 = *((_QWORD *)this + 6);
  v15 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = v15 + 1;
  result = *(_QWORD *)(v16 + 8 * v15);
  *(_QWORD *)(v16 + 8 * v15) = v14;
  if (result)
    return MEMORY[0x1D17BC778](result, 0x1050C80717B85FCLL);
  return result;
}

void sub_1CDF9E14C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array((uint64_t *)va);
  _Unwind_Resume(a1);
}

size_t marisa::Keyset::push_back(size_t *this, const char *a2)
{
  uint64_t v2;
  _QWORD *exception;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    exception[2] = 0x200000032;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:50: MARISA_NULL_ERROR: str == NULL";
  }
  v2 = 0;
  while (a2[v2++])
    ;
  return marisa::Keyset::push_back(this, a2, v2 - 1, 1.0);
}

size_t marisa::Keyset::push_back(size_t *this, const char *a2, size_t __sz, float a4)
{
  const char *v6;
  size_t result;
  _BYTE *v9;
  size_t v10;
  char v11;
  uint64_t v12;
  size_t v13;
  _QWORD *exception;
  const char *v15;

  v6 = a2;
  if (!a2 && __sz)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    exception[2] = 0x20000003DLL;
    v15 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:61: MARISA_NULL_ERROR: (ptr == NULL) && (length != 0)";
    goto LABEL_10;
  }
  if (HIDWORD(__sz))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    exception[2] = 0x70000003ELL;
    v15 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:62: MARISA_SIZE_ERROR: length > MARISA_UINT32_MAX";
LABEL_10:
    exception[3] = v15;
  }
  result = marisa::Keyset::reserve(this, __sz);
  if (__sz)
  {
    v9 = (_BYTE *)result;
    v10 = __sz;
    do
    {
      v11 = *v6++;
      *v9++ = v11;
      --v10;
    }
    while (v10);
  }
  v12 = *(_QWORD *)(this[6] + ((this[11] >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * this[11];
  *(_QWORD *)v12 = result;
  *(_DWORD *)(v12 + 8) = __sz;
  *(float *)(v12 + 12) = a4;
  v13 = this[12] + __sz;
  ++this[11];
  this[12] = v13;
  return result;
}

double marisa::Keyset::reset(marisa::Keyset *this)
{
  double result;

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 4) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  return result;
}

uint64_t *marisa::Keyset::clear(marisa::Keyset *this)
{
  _OWORD v2[3];
  _OWORD v3[3];
  uint64_t v4;

  v4 = 0;
  memset(v3, 0, sizeof(v3));
  memset(v2, 0, sizeof(v2));
  marisa::Keyset::swap((uint64_t *)v2, this);
  marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array((uint64_t *)v3);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)&v2[1] + 1);
  return marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)v2);
}

uint64_t *marisa::Keyset::swap(uint64_t *this, marisa::Keyset *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v2 = *this;
  v3 = this[1];
  v4 = *((_QWORD *)a2 + 1);
  *this = *(_QWORD *)a2;
  this[1] = v4;
  *(_QWORD *)a2 = v2;
  *((_QWORD *)a2 + 1) = v3;
  v5 = this[2];
  v6 = this[3];
  v7 = *((_QWORD *)a2 + 3);
  this[2] = *((_QWORD *)a2 + 2);
  this[3] = v7;
  *((_QWORD *)a2 + 2) = v5;
  *((_QWORD *)a2 + 3) = v6;
  v8 = this[4];
  this[4] = *((_QWORD *)a2 + 4);
  *((_QWORD *)a2 + 4) = v8;
  v9 = this[5];
  v10 = this[6];
  v11 = *((_QWORD *)a2 + 6);
  this[5] = *((_QWORD *)a2 + 5);
  this[6] = v11;
  *((_QWORD *)a2 + 5) = v9;
  *((_QWORD *)a2 + 6) = v10;
  v12 = this[7];
  this[7] = *((_QWORD *)a2 + 7);
  *((_QWORD *)a2 + 7) = v12;
  v13 = this[8];
  v14 = this[9];
  v15 = *((_QWORD *)a2 + 9);
  this[8] = *((_QWORD *)a2 + 8);
  this[9] = v15;
  *((_QWORD *)a2 + 8) = v13;
  *((_QWORD *)a2 + 9) = v14;
  v16 = this[10];
  this[10] = *((_QWORD *)a2 + 10);
  *((_QWORD *)a2 + 10) = v16;
  v17 = this[11];
  this[11] = *((_QWORD *)a2 + 11);
  *((_QWORD *)a2 + 11) = v17;
  v18 = this[12];
  this[12] = *((_QWORD *)a2 + 12);
  *((_QWORD *)a2 + 12) = v18;
  return this;
}

void *marisa::Keyset::append_extra_block(marisa::Keyset *this, size_t __sz)
{
  uint64_t v4;
  unint64_t v5;
  _BOOL4 v6;
  size_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *exception;
  uint64_t v21;

  v4 = *((_QWORD *)this + 4);
  if (v4 == *((_QWORD *)this + 5))
  {
    if (v4)
      v5 = 2 * v4;
    else
      v5 = 1;
    v6 = v5 >> 61 != 0;
    if (8 * v5 >= 0xFFFFFFFFFFFFFFF0)
      v6 = 1;
    if (v6)
      v7 = -1;
    else
      v7 = 8 * v5 + 16;
    v8 = operator new[](v7, MEMORY[0x1E0DE4E10]);
    if (!v8)
    {
      v21 = 0;
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &off_1E8B57FF8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
      exception[2] = 0x800000097;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:151: MARISA_MEMORY_ERROR: new_blo"
                     "cks.get() == NULL";
    }
    *v8 = 8;
    v8[1] = v5;
    v9 = (uint64_t)(v8 + 2);
    if (v5)
      bzero(v8 + 2, 8 * v5);
    v21 = v9;
    if (v4)
    {
      for (i = 0; i != v4; ++i)
      {
        v11 = *((_QWORD *)this + 3);
        v12 = v21;
        v13 = *(_QWORD *)(v11 + 8 * i);
        *(_QWORD *)(v11 + 8 * i) = *(_QWORD *)(v21 + 8 * i);
        *(_QWORD *)(v12 + 8 * i) = v13;
      }
      v9 = v21;
    }
    v14 = *((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = v9;
    v21 = v14;
    *((_QWORD *)this + 5) = v5;
    marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(&v21);
  }
  result = operator new[](__sz, MEMORY[0x1E0DE4E10]);
  if (!result)
  {
    v19 = __cxa_allocate_exception(0x20uLL);
    *v19 = &off_1E8B57FF8;
    v19[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    v19[2] = 0x80000009FLL;
    v19[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:159: MARISA_MEMORY_ERROR: new_block.get() == NULL";
  }
  v17 = *((_QWORD *)this + 3);
  v16 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = v16 + 1;
  v18 = *(_QWORD *)(v17 + 8 * v16);
  *(_QWORD *)(v17 + 8 * v16) = result;
  if (v18)
    return (void *)MEMORY[0x1D17BC778](v18, 0x1000C8077774924);
  return result;
}

void sub_1CDF9E5C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *marisa::Keyset::append_base_block(uint64_t *this)
{
  uint64_t *v1;
  uint64_t v2;
  unint64_t v3;
  _BOOL4 v4;
  size_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *exception;
  _QWORD *v15;
  uint64_t v16;

  v1 = this;
  v2 = this[1];
  if (v2 == this[2])
  {
    if (v2)
      v3 = 2 * v2;
    else
      v3 = 1;
    v4 = v3 >> 61 != 0;
    if (8 * v3 >= 0xFFFFFFFFFFFFFFF0)
      v4 = 1;
    if (v4)
      v5 = -1;
    else
      v5 = 8 * v3 + 16;
    v6 = operator new[](v5, MEMORY[0x1E0DE4E10]);
    if (!v6)
    {
      v16 = 0;
      exception = __cxa_allocate_exception(0x20uLL);
      *exception = &off_1E8B57FF8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
      exception[2] = 0x800000081;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:129: MARISA_MEMORY_ERROR: new_blo"
                     "cks.get() == NULL";
    }
    *v6 = 8;
    v6[1] = v3;
    v7 = (uint64_t)(v6 + 2);
    if (v3)
      bzero(v6 + 2, 8 * v3);
    v16 = v7;
    if (v2)
    {
      for (i = 0; i != v2; ++i)
      {
        v9 = v16;
        v10 = *(_QWORD *)(*v1 + 8 * i);
        *(_QWORD *)(*v1 + 8 * i) = *(_QWORD *)(v16 + 8 * i);
        *(_QWORD *)(v9 + 8 * i) = v10;
      }
      v7 = v16;
    }
    v11 = *v1;
    *v1 = v7;
    v16 = v11;
    v1[2] = v3;
    this = marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(&v16);
    v2 = v1[1];
  }
  v12 = *v1;
  v13 = *(_QWORD *)(*v1 + 8 * v2);
  if (!v13)
  {
    this = (uint64_t *)operator new[](0x1000uLL, MEMORY[0x1E0DE4E10]);
    if (!this)
    {
      v15 = __cxa_allocate_exception(0x20uLL);
      *v15 = &off_1E8B57FF8;
      v15[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
      v15[2] = 0x80000008ALL;
      v15[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:138: MARISA_MEMORY_ERROR: new_block.get() == NULL";
    }
    *(_QWORD *)(v12 + 8 * v2) = this;
    v13 = *(_QWORD *)(*v1 + 8 * v2);
  }
  v1[1] = v2 + 1;
  v1[9] = v13;
  v1[10] = 4096;
  return this;
}

void sub_1CDF9E794(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)va);
  _Unwind_Resume(a1);
}

_QWORD *marisa::Trie::Trie(_QWORD *this)
{
  *this = 0;
  return this;
}

marisa::grimoire::trie::LoudsTrie **marisa::Trie::build(marisa::grimoire::trie::LoudsTrie **this, marisa::Keyset *a2, unsigned int a3)
{
  marisa::grimoire::trie::LoudsTrie *v6;
  marisa::grimoire::trie::LoudsTrie *v7;
  marisa::grimoire::trie::LoudsTrie *v8;
  _QWORD *exception;
  marisa::grimoire::trie::LoudsTrie *v11;

  v6 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E0DE4E10]);
  if (!v6)
  {
    v11 = 0;
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x80000000ELL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:14: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  v7 = v6;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v6);
  v11 = v7;
  marisa::grimoire::trie::LoudsTrie::build(v7, a2, a3);
  v8 = *this;
  *this = v7;
  v11 = v8;
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v11);
}

void sub_1CDF9E880(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D17BC790](v1, MEMORY[0x1E0DE4E10]);
  _Unwind_Resume(a1);
}

marisa::grimoire::trie::LoudsTrie **marisa::Trie::mmap(marisa::grimoire::trie::LoudsTrie **this, const char *a2)
{
  marisa::grimoire::trie::LoudsTrie *v4;
  marisa::grimoire::trie::LoudsTrie *v5;
  marisa::grimoire::trie::LoudsTrie *v6;
  _QWORD *exception;
  _QWORD *v9;
  _BYTE v10[40];
  marisa::grimoire::trie::LoudsTrie *v11;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x200000015;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:21: MARISA_NULL_ERROR: filename == NULL";
  }
  v4 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E0DE4E10]);
  if (!v4)
  {
    v11 = 0;
    v9 = __cxa_allocate_exception(0x20uLL);
    *v9 = &off_1E8B57FF8;
    v9[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    v9[2] = 0x800000018;
    v9[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:24: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  v5 = v4;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v4);
  v11 = v5;
  marisa::grimoire::io::Mapper::Mapper((uint64_t)v10);
  marisa::grimoire::io::Mapper::open((marisa::grimoire::io::Mapper *)v10, a2);
  marisa::grimoire::trie::LoudsTrie::map(v11, (marisa::grimoire::io::Mapper *)v10);
  v6 = *this;
  *this = v11;
  v11 = v6;
  marisa::grimoire::io::Mapper::~Mapper((marisa::grimoire::io::Mapper *)v10);
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v11);
}

void sub_1CDF9E9D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)va);
  _Unwind_Resume(a1);
}

marisa::grimoire::trie::LoudsTrie **marisa::Trie::map(marisa::grimoire::trie::LoudsTrie **this, const void *a2, uint64_t a3)
{
  marisa::grimoire::trie::LoudsTrie *v6;
  marisa::grimoire::trie::LoudsTrie *v7;
  marisa::grimoire::trie::LoudsTrie *v8;
  _QWORD *exception;
  _QWORD *v11;
  _BYTE v12[40];
  marisa::grimoire::trie::LoudsTrie *v13;

  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x200000021;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:33: MARISA_NULL_ERROR: (ptr == NULL) && (size != 0)";
  }
  v6 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E0DE4E10]);
  if (!v6)
  {
    v13 = 0;
    v11 = __cxa_allocate_exception(0x20uLL);
    *v11 = &off_1E8B57FF8;
    v11[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    v11[2] = 0x800000024;
    v11[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:36: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  v7 = v6;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v6);
  v13 = v7;
  marisa::grimoire::io::Mapper::Mapper((uint64_t)v12);
  marisa::grimoire::io::Mapper::open((marisa::grimoire::io::Mapper *)v12, a2, a3);
  marisa::grimoire::trie::LoudsTrie::map(v13, (marisa::grimoire::io::Mapper *)v12);
  v8 = *this;
  *this = v13;
  v13 = v8;
  marisa::grimoire::io::Mapper::~Mapper((marisa::grimoire::io::Mapper *)v12);
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v13);
}

void sub_1CDF9EB50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)va);
  _Unwind_Resume(a1);
}

marisa::grimoire::trie::LoudsTrie **marisa::Trie::load(marisa::grimoire::trie::LoudsTrie **this, const char *a2)
{
  marisa::grimoire::trie::LoudsTrie *v4;
  marisa::grimoire::trie::LoudsTrie *v5;
  marisa::grimoire::trie::LoudsTrie *v6;
  _QWORD *exception;
  _QWORD *v9;
  FILE *v10[4];
  marisa::grimoire::trie::LoudsTrie *v11;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x20000002DLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:45: MARISA_NULL_ERROR: filename == NULL";
  }
  v4 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E0DE4E10]);
  if (!v4)
  {
    v11 = 0;
    v9 = __cxa_allocate_exception(0x20uLL);
    *v9 = &off_1E8B57FF8;
    v9[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    v9[2] = 0x800000030;
    v9[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:48: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  v5 = v4;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v4);
  v11 = v5;
  marisa::grimoire::io::Reader::Reader((uint64_t)v10);
  marisa::grimoire::io::Reader::open(v10, a2);
  marisa::grimoire::trie::LoudsTrie::read(v11, (marisa::grimoire::io::Reader *)v10);
  v6 = *this;
  *this = v11;
  v11 = v6;
  marisa::grimoire::io::Reader::~Reader(v10);
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v11);
}

void sub_1CDF9ECBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)va);
  _Unwind_Resume(a1);
}

marisa::grimoire::trie::LoudsTrie **marisa::Trie::read(marisa::grimoire::trie::LoudsTrie **this, int a2)
{
  marisa::grimoire::trie::LoudsTrie *v4;
  marisa::grimoire::trie::LoudsTrie *v5;
  marisa::grimoire::trie::LoudsTrie *v6;
  _QWORD *exception;
  _QWORD *v9;
  FILE *v10[4];
  marisa::grimoire::trie::LoudsTrie *v11;

  if (a2 == -1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x500000039;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:57: MARISA_CODE_ERROR: fd == -1";
  }
  v4 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E0DE4E10]);
  if (!v4)
  {
    v11 = 0;
    v9 = __cxa_allocate_exception(0x20uLL);
    *v9 = &off_1E8B57FF8;
    v9[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    v9[2] = 0x80000003CLL;
    v9[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:60: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  v5 = v4;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v4);
  v11 = v5;
  marisa::grimoire::io::Reader::Reader((uint64_t)v10);
  marisa::grimoire::io::Reader::open(v10, a2);
  marisa::grimoire::trie::LoudsTrie::read(v11, (marisa::grimoire::io::Reader *)v10);
  v6 = *this;
  *this = v11;
  v11 = v6;
  marisa::grimoire::io::Reader::~Reader(v10);
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v11);
}

void sub_1CDF9EE2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)va);
  _Unwind_Resume(a1);
}

void marisa::Trie::save(marisa::grimoire::trie::LoudsTrie ***this, const char *a2)
{
  _QWORD *exception;
  const char *v5;
  FILE *v6[4];

  if (!*this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x100000045;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:69: MARISA_STATE_ERROR: trie_.get() == NULL";
    goto LABEL_6;
  }
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x200000046;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:70: MARISA_NULL_ERROR: filename == NULL";
LABEL_6:
    exception[3] = v5;
  }
  marisa::grimoire::io::Reader::Reader((uint64_t)v6);
  marisa::grimoire::io::Writer::open(v6, a2);
  marisa::grimoire::trie::LoudsTrie::write(*this, (marisa::grimoire::io::Writer *)v6);
  marisa::grimoire::io::Reader::~Reader(v6);
}

void sub_1CDF9EF44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, FILE *a9)
{
  marisa::grimoire::io::Reader::~Reader(&a9);
  _Unwind_Resume(a1);
}

void marisa::Trie::write(marisa::grimoire::trie::LoudsTrie ***this, int a2)
{
  _QWORD *exception;
  const char *v5;
  FILE *v6[4];

  if (!*this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x10000004ELL;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:78: MARISA_STATE_ERROR: trie_.get() == NULL";
    goto LABEL_6;
  }
  if (a2 == -1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x50000004FLL;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:79: MARISA_CODE_ERROR: fd == -1";
LABEL_6:
    exception[3] = v5;
  }
  marisa::grimoire::io::Reader::Reader((uint64_t)v6);
  marisa::grimoire::io::Writer::open(v6, a2);
  marisa::grimoire::trie::LoudsTrie::write(*this, (marisa::grimoire::io::Writer *)v6);
  marisa::grimoire::io::Reader::~Reader(v6);
}

void sub_1CDF9F034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, FILE *a9)
{
  marisa::grimoire::io::Reader::~Reader(&a9);
  _Unwind_Resume(a1);
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::lookup(marisa::grimoire::trie::LoudsTrie **this, marisa::Agent *a2)
{
  marisa::grimoire::trie::LoudsTrie *result;

  result = *this;
  if (result)
  {
    if (!*((_QWORD *)a2 + 5))
    {
      marisa::Agent::init_state(a2);
      result = *this;
    }
    return (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::lookup(result, a2);
  }
  return result;
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::reverse_lookup(marisa::grimoire::trie::LoudsTrie **this, marisa::Agent *a2)
{
  marisa::grimoire::trie::LoudsTrie *result;

  result = *this;
  if (result)
  {
    if (!*((_QWORD *)a2 + 5))
    {
      marisa::Agent::init_state(a2);
      result = *this;
    }
    return (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::reverse_lookup(result, a2);
  }
  return result;
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::common_prefix_search(marisa::grimoire::trie::LoudsTrie **this, marisa::Agent *a2)
{
  marisa::grimoire::trie::LoudsTrie *result;

  result = *this;
  if (result)
  {
    if (!*((_QWORD *)a2 + 5))
    {
      marisa::Agent::init_state(a2);
      result = *this;
    }
    return (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::common_prefix_search(result, a2);
  }
  return result;
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::predictive_search(marisa::grimoire::trie::LoudsTrie **this, marisa::Agent *a2)
{
  marisa::grimoire::trie::LoudsTrie *result;

  result = *this;
  if (result)
  {
    if (!*((_QWORD *)a2 + 5))
    {
      marisa::Agent::init_state(a2);
      result = *this;
    }
    return (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::predictive_search(result, a2);
  }
  return result;
}

uint64_t marisa::Trie::num_tries(marisa::Trie *this)
{
  if (*(_QWORD *)this)
    return *(_QWORD *)(*(_QWORD *)this + 1072);
  else
    return 0;
}

uint64_t marisa::Trie::num_keys(marisa::Trie *this)
{
  if (*(_QWORD *)this)
    return *(_QWORD *)(*(_QWORD *)this + 264);
  else
    return 0;
}

uint64_t marisa::Trie::num_nodes(marisa::Trie *this)
{
  if (*(_QWORD *)this)
    return (*(_QWORD *)(*(_QWORD *)this + 48) >> 1) - 1;
  else
    return 0;
}

uint64_t marisa::Trie::tail_mode(marisa::Trie *this)
{
  _QWORD *exception;

  if (!*(_QWORD *)this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x100000086;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:134: MARISA_STATE_ERROR: trie_.get() == NULL";
  }
  return *(unsigned int *)(*(_QWORD *)this + 1084);
}

uint64_t marisa::Trie::node_order(marisa::Trie *this)
{
  _QWORD *exception;

  if (!*(_QWORD *)this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x10000008BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:139: MARISA_STATE_ERROR: trie_.get() == NULL";
  }
  return *(unsigned int *)(*(_QWORD *)this + 1088);
}

BOOL marisa::Trie::empty(marisa::Trie *this)
{
  return !*(_QWORD *)this || *(_QWORD *)(*(_QWORD *)this + 264) == 0;
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::total_size(marisa::grimoire::trie::LoudsTrie **this)
{
  marisa::grimoire::trie::LoudsTrie *result;

  result = *this;
  if (result)
    return (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::total_size(result);
  return result;
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::io_size(marisa::grimoire::trie::LoudsTrie **this)
{
  marisa::grimoire::trie::LoudsTrie *result;

  result = *this;
  if (result)
    return (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::io_size(result);
  return result;
}

marisa::grimoire::trie::LoudsTrie **marisa::Trie::clear(marisa::grimoire::trie::LoudsTrie **this)
{
  marisa::grimoire::trie::LoudsTrie *v2;

  v2 = *this;
  *this = 0;
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v2);
}

uint64_t *marisa::Trie::swap(uint64_t *this, marisa::Trie *a2)
{
  uint64_t v2;

  v2 = *this;
  *this = *(_QWORD *)a2;
  *(_QWORD *)a2 = v2;
  return this;
}

marisa::grimoire::trie::LoudsTrie **marisa::fread(__sFILE *this, __sFILE *a2, marisa::Trie *a3)
{
  _QWORD *exception;
  const char *v5;

  if (!this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000DELL;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:222: MARISA_NULL_ERROR: file == NULL";
    goto LABEL_6;
  }
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000DFLL;
    v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:223: MARISA_NULL_ERROR: trie == NULL";
LABEL_6:
    exception[3] = v5;
  }
  return marisa::TrieIO::fread(this, a2, a3);
}

marisa::grimoire::trie::LoudsTrie **marisa::TrieIO::fread(__sFILE *this, __sFILE *a2, marisa::Trie *a3)
{
  marisa::grimoire::trie::LoudsTrie *v5;
  marisa::grimoire::trie::LoudsTrie *v6;
  unsigned __int8 *p;
  _QWORD *exception;
  _QWORD *v10;
  FILE *v11[4];
  marisa::grimoire::trie::LoudsTrie *v12;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000B4;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:180: MARISA_NULL_ERROR: trie == NULL";
  }
  v5 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E0DE4E10]);
  if (!v5)
  {
    v12 = 0;
    v10 = __cxa_allocate_exception(0x20uLL);
    *v10 = &off_1E8B57FF8;
    v10[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    v10[2] = 0x8000000B8;
    v10[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:184: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  v6 = v5;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v5);
  v12 = v6;
  marisa::grimoire::io::Reader::Reader((uint64_t)v11);
  marisa::grimoire::io::Reader::open(v11, this);
  marisa::grimoire::trie::LoudsTrie::read(v12, (marisa::grimoire::io::Reader *)v11);
  p = a2->_p;
  a2->_p = (unsigned __int8 *)v12;
  v12 = (marisa::grimoire::trie::LoudsTrie *)p;
  marisa::grimoire::io::Reader::~Reader(v11);
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v12);
}

void sub_1CDF9F4D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)va);
  _Unwind_Resume(a1);
}

void marisa::fwrite(__sFILE *this, __sFILE *a2, const marisa::Trie *a3)
{
  _QWORD *exception;

  if (!this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000E4;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:228: MARISA_NULL_ERROR: file == NULL";
  }
  marisa::TrieIO::fwrite(this, a2, a3);
}

void marisa::TrieIO::fwrite(__sFILE *this, __sFILE *a2, const marisa::Trie *a3)
{
  _QWORD *exception;
  const char *v6;
  FILE *v7[4];

  if (!this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000C0;
    v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:192: MARISA_NULL_ERROR: file == NULL";
    goto LABEL_6;
  }
  if (!a2->_p)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x1000000C1;
    v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:193: MARISA_STATE_ERROR: trie.trie_.get() == NULL";
LABEL_6:
    exception[3] = v6;
  }
  marisa::grimoire::io::Reader::Reader((uint64_t)v7);
  marisa::grimoire::io::Writer::open(v7, this);
  marisa::grimoire::trie::LoudsTrie::write((marisa::grimoire::trie::LoudsTrie **)a2->_p, (marisa::grimoire::io::Writer *)v7);
  marisa::grimoire::io::Reader::~Reader(v7);
}

void sub_1CDF9F640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, FILE *a9)
{
  marisa::grimoire::io::Reader::~Reader(&a9);
  _Unwind_Resume(a1);
}

uint64_t marisa::read(uint64_t a1, marisa::grimoire::trie::LoudsTrie **a2)
{
  _QWORD *exception;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000E9;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:233: MARISA_NULL_ERROR: trie == NULL";
  }
  return marisa::TrieIO::read(a1, a2);
}

uint64_t marisa::TrieIO::read(uint64_t a1, marisa::grimoire::trie::LoudsTrie **a2)
{
  marisa::grimoire::trie::LoudsTrie *v4;
  marisa::grimoire::trie::LoudsTrie *v5;
  marisa::grimoire::trie::LoudsTrie *v6;
  _QWORD *exception;
  _QWORD *v9;
  FILE *v10[4];
  marisa::grimoire::trie::LoudsTrie *v11;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000C8;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:200: MARISA_NULL_ERROR: trie == NULL";
  }
  v4 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E0DE4E10]);
  if (!v4)
  {
    v11 = 0;
    v9 = __cxa_allocate_exception(0x20uLL);
    *v9 = &off_1E8B57FF8;
    v9[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    v9[2] = 0x8000000CCLL;
    v9[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:204: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  v5 = v4;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v4);
  v11 = v5;
  marisa::grimoire::io::Reader::Reader((uint64_t)v10);
  marisa::grimoire::io::Reader::open((uint64_t)v10, a1);
  marisa::grimoire::trie::LoudsTrie::read(v11, (marisa::grimoire::io::Reader *)v10);
  v6 = *a2;
  *a2 = v11;
  v11 = v6;
  marisa::grimoire::io::Reader::~Reader(v10);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v11);
  return a1;
}

void sub_1CDF9F7DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)va);
  _Unwind_Resume(a1);
}

uint64_t marisa::TrieIO::write(uint64_t a1, marisa::grimoire::trie::LoudsTrie ***a2)
{
  _QWORD *exception;
  FILE *v6[4];

  if (!*a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    *exception = &off_1E8B57FF8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x1000000D5;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:213: MARISA_STATE_ERROR: trie.trie_.get() == NULL";
  }
  marisa::grimoire::io::Reader::Reader((uint64_t)v6);
  marisa::grimoire::io::Reader::open((uint64_t)v6, a1);
  marisa::grimoire::trie::LoudsTrie::write(*a2, (marisa::grimoire::io::Writer *)v6);
  marisa::grimoire::io::Reader::~Reader(v6);
  return a1;
}

void sub_1CDF9F8C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, FILE *a9)
{
  marisa::grimoire::io::Reader::~Reader(&a9);
  _Unwind_Resume(a1);
}

void DCSEnvironment::createDictionariesCacheURL()
{
  __assert_rtn("createDictionariesCacheURL", "DCSEnvironment.cpp", 2194, "CFArrayGetCount(pathArray) != 0");
}

uint64_t ADClientAddValueForScalarKey()
{
  return MEMORY[0x1E0CF63A0]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C97C58]();
  return result;
}

CFGregorianDate CFAbsoluteTimeGetGregorianDate(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  uint64_t v2;
  double v3;
  CFGregorianDate result;

  v2 = MEMORY[0x1E0C97C88](tz, at);
  result.second = v3;
  result.year = v2;
  result.month = BYTE4(v2);
  result.day = BYTE5(v2);
  result.hour = BYTE6(v2);
  result.minute = HIBYTE(v2);
  return result;
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
  MEMORY[0x1E0C97CE8](theArray, otherArray, otherRange.location, otherRange.length);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1E0C97D10](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1E0C97D20](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1E0C97D30](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D50](allocator, capacity, theArray);
}

void CFArrayExchangeValuesAtIndices(CFMutableArrayRef theArray, CFIndex idx1, CFIndex idx2)
{
  MEMORY[0x1E0C97D58](theArray, idx1, idx2);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1E0C97D78](theArray, range.location, range.length, value);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DB0](theArray, idx, value);
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
  MEMORY[0x1E0C97DB8](theArray);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x1E0C97DC0](theArray, idx);
}

void CFArrayReplaceValues(CFMutableArrayRef theArray, CFRange range, const void **newValues, CFIndex newCount)
{
  MEMORY[0x1E0C97DC8](theArray, range.location, range.length, newValues, newCount);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DD0](theArray, idx, value);
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
  MEMORY[0x1E0C97DE0](theArray, range.location, range.length, comparator, context);
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1E0C97FE0](BOOLean);
}

CFArrayRef CFBundleCopyBundleLocalizations(CFBundleRef bundle)
{
  return (CFArrayRef)MEMORY[0x1E0C97FF8](bundle);
}

CFURLRef CFBundleCopyBundleURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1E0C98000](bundle);
}

CFDictionaryRef CFBundleCopyInfoDictionaryInDirectory(CFURLRef bundleURL)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98030](bundleURL);
}

CFArrayRef CFBundleCopyLocalizationsForPreferences(CFArrayRef locArray, CFArrayRef prefArray)
{
  return (CFArrayRef)MEMORY[0x1E0C98040](locArray, prefArray);
}

CFArrayRef CFBundleCopyPreferredLocalizationsFromArray(CFArrayRef locArray)
{
  return (CFArrayRef)MEMORY[0x1E0C98070](locArray);
}

CFURLRef CFBundleCopyResourceURL(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  return (CFURLRef)MEMORY[0x1E0C98080](bundle, resourceName, resourceType, subDirName);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return (CFBundleRef)MEMORY[0x1E0C980D0](allocator, bundleURL);
}

CFArrayRef CFBundleCreateBundlesFromDirectory(CFAllocatorRef allocator, CFURLRef directoryURL, CFStringRef bundleType)
{
  return (CFArrayRef)MEMORY[0x1E0C980E0](allocator, directoryURL, bundleType);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1E0C980E8](bundleID);
}

void *__cdecl CFBundleGetDataPointerForName(CFBundleRef bundle, CFStringRef symbolName)
{
  return (void *)MEMORY[0x1E0C980F8](bundle, symbolName);
}

void *__cdecl CFBundleGetFunctionPointerForName(CFBundleRef bundle, CFStringRef functionName)
{
  return (void *)MEMORY[0x1E0C98108](bundle, functionName);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return (CFStringRef)MEMORY[0x1E0C98120](bundle);
}

CFDictionaryRef CFBundleGetInfoDictionary(CFBundleRef bundle)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98130](bundle);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x1E0C98150]();
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1E0C98180](bundle, key);
}

Boolean CFBundleIsExecutableLoaded(CFBundleRef bundle)
{
  return MEMORY[0x1E0C98190](bundle);
}

Boolean CFBundleLoadExecutable(CFBundleRef bundle)
{
  return MEMORY[0x1E0C98198](bundle);
}

void CFCharacterSetAddCharactersInString(CFMutableCharacterSetRef theSet, CFStringRef theString)
{
  MEMORY[0x1E0C982A8](theSet, theString);
}

CFCharacterSetRef CFCharacterSetCreateInvertedSet(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982C0](alloc, theSet);
}

CFMutableCharacterSetRef CFCharacterSetCreateMutable(CFAllocatorRef alloc)
{
  return (CFMutableCharacterSetRef)MEMORY[0x1E0C982C8](alloc);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982E8](alloc, theString);
}

Boolean CFCharacterSetIsSupersetOfSet(CFCharacterSetRef theSet, CFCharacterSetRef theOtherset)
{
  return MEMORY[0x1E0C98330](theSet, theOtherset);
}

uint64_t CFCopyHomeDirectoryURLForUser()
{
  return MEMORY[0x1E0C98368]();
}

uint64_t CFCopySearchPathForDirectoriesInDomains()
{
  return MEMORY[0x1E0C98370]();
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
  MEMORY[0x1E0C98390](theData, bytes, length);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1E0C983A0](allocator, bytes, length);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1E0C983B8](allocator, capacity);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1E0C983C8](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1E0C98408](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1E0C98418]();
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
  MEMORY[0x1E0C98430](theData, length);
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)MEMORY[0x1E0C98460](allocator, locale, dateStyle, timeStyle);
}

CFStringRef CFDateFormatterCreateStringWithAbsoluteTime(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFAbsoluteTime at)
{
  return (CFStringRef)MEMORY[0x1E0C98488](allocator, formatter, at);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98500](theDict, key, value);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98508](theDict, applier, context);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1E0C98518](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98530](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98558](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1E0C98570](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x1E0C985A0](theDict, keys, values);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1E0C985A8]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  MEMORY[0x1E0C985D8](theDict);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x1E0C985E8](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98610](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1E0C98620](cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1E0C98630](err);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x1E0C98718](cf);
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  return MEMORY[0x1E0C98720](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1E0C98738](cf);
}

CFHTTPMessageRef CFHTTPMessageCreateRequest(CFAllocatorRef alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion)
{
  return (CFHTTPMessageRef)MEMORY[0x1E0C92838](alloc, requestMethod, url, httpVersion);
}

CFIndex CFHTTPMessageGetResponseStatusCode(CFHTTPMessageRef response)
{
  return MEMORY[0x1E0C92848](response);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1E0C98758](cf);
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)MEMORY[0x1E0C98770]();
}

CFArrayRef CFLocaleCopyPreferredLanguages(void)
{
  return (CFArrayRef)MEMORY[0x1E0C98790]();
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x1E0C98798](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLanguageIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  return (CFLocaleIdentifier)MEMORY[0x1E0C987A0](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  return (CFLocaleIdentifier)MEMORY[0x1E0C987B0](allocator, localeIdentifier);
}

CFDictionaryRef CFLocaleCreateComponentsFromLocaleIdentifier(CFAllocatorRef allocator, CFLocaleIdentifier localeID)
{
  return (CFDictionaryRef)MEMORY[0x1E0C987B8](allocator, localeID);
}

CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromComponents(CFAllocatorRef allocator, CFDictionaryRef dictionary)
{
  return (CFLocaleIdentifier)MEMORY[0x1E0C987C8](allocator, dictionary);
}

CFLocaleIdentifier CFLocaleGetIdentifier(CFLocaleRef locale)
{
  return (CFLocaleIdentifier)MEMORY[0x1E0C987D8](locale);
}

CFLocaleLanguageDirection CFLocaleGetLanguageCharacterDirection(CFStringRef isoLangCode)
{
  return MEMORY[0x1E0C987E0](isoLangCode);
}

CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey key)
{
  return (CFTypeRef)MEMORY[0x1E0C98800](locale, key);
}

uint64_t CFLog()
{
  return MEMORY[0x1E0C98808]();
}

CFMessagePortRef CFMessagePortCreateRemote(CFAllocatorRef allocator, CFStringRef name)
{
  return (CFMessagePortRef)MEMORY[0x1E0C98870](allocator, name);
}

SInt32 CFMessagePortSendRequest(CFMessagePortRef remote, SInt32 msgid, CFDataRef data, CFTimeInterval sendTimeout, CFTimeInterval rcvTimeout, CFStringRef replyMode, CFDataRef *returnData)
{
  return MEMORY[0x1E0C98898](remote, *(_QWORD *)&msgid, data, replyMode, returnData, sendTimeout, rcvTimeout);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  MEMORY[0x1E0C988B0](center, observer, callBack, name, object, suspensionBehavior);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988B8]();
}

CFNotificationCenterRef CFNotificationCenterGetDistributedCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988C8]();
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988D0]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
  MEMORY[0x1E0C988E0](center, name, object, userInfo, deliverImmediately);
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
  MEMORY[0x1E0C98900](center, observer, name, object);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1E0C98928](allocator, theType, valuePtr);
}

CFNumberFormatterRef CFNumberFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFNumberFormatterStyle style)
{
  return (CFNumberFormatterRef)MEMORY[0x1E0C98938](allocator, locale, style);
}

CFStringRef CFNumberFormatterCreateStringWithNumber(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFNumberRef number)
{
  return (CFStringRef)MEMORY[0x1E0C98948](allocator, formatter, number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1E0C989B8]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x1E0C989D0](number);
}

CFPlugInRef CFPlugInCreate(CFAllocatorRef allocator, CFURLRef plugInURL)
{
  return (CFPlugInRef)MEMORY[0x1E0C989E8](allocator, plugInURL);
}

void *__cdecl CFPlugInInstanceCreate(CFAllocatorRef allocator, CFUUIDRef factoryUUID, CFUUIDRef typeUUID)
{
  return (void *)MEMORY[0x1E0C98A10](allocator, factoryUUID, typeUUID);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1E0C98AA0](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateFromXMLData(CFAllocatorRef allocator, CFDataRef xmlData, CFOptionFlags mutabilityOption, CFStringRef *errorString)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AC8](allocator, xmlData, mutabilityOption, errorString);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AD0](allocator, data, options, format, error);
}

CFIndex CFPropertyListWriteToStream(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFStringRef *errorString)
{
  return MEMORY[0x1E0C98B00](propertyList, stream, format, errorString);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
  MEMORY[0x1E0C98B10](stream);
}

CFErrorRef CFReadStreamCopyError(CFReadStreamRef stream)
{
  return (CFErrorRef)MEMORY[0x1E0C98B20](stream);
}

CFTypeRef CFReadStreamCopyProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName)
{
  return (CFTypeRef)MEMORY[0x1E0C98B28](stream, propertyName);
}

CFReadStreamRef CFReadStreamCreateForHTTPRequest(CFAllocatorRef alloc, CFHTTPMessageRef request)
{
  return (CFReadStreamRef)MEMORY[0x1E0C928E0](alloc, request);
}

CFStreamError CFReadStreamGetError(CFReadStreamRef stream)
{
  CFIndex v1;
  uint64_t v2;
  CFStreamError result;

  v1 = MEMORY[0x1E0C98B58](stream);
  result.error = v2;
  result.domain = v1;
  return result;
}

Boolean CFReadStreamHasBytesAvailable(CFReadStreamRef stream)
{
  return MEMORY[0x1E0C98B78](stream);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1E0C98B80](stream);
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1E0C98B88](stream, buffer, bufferLength);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98BD0](cf);
}

void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98BE8](rl, observer, mode);
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x1E0C98C40]();
}

CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context)
{
  return (CFRunLoopObserverRef)MEMORY[0x1E0C98C60](allocator, activities, repeats, order, callout, context);
}

void CFRunLoopObserverInvalidate(CFRunLoopObserverRef observer)
{
  MEMORY[0x1E0C98C78](observer);
}

void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98C88](rl, observer, mode);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98D70](theSet, value);
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1E0C98D80](theSet, value);
}

CFSetRef CFSetCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFSetCallBacks *callBacks)
{
  return (CFSetRef)MEMORY[0x1E0C98D88](allocator, values, numValues, callBacks);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1E0C98D98](allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1E0C98DA8](theSet);
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
  MEMORY[0x1E0C98DD0](theSet, values);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  MEMORY[0x1E0C98ED8](theString, appendedString);
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
  MEMORY[0x1E0C98EE8](theString, chars, numChars);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F10](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptionsAndLocale(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions, CFLocaleRef locale)
{
  return MEMORY[0x1E0C98F20](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions, locale);
}

CFStringEncoding CFStringConvertIANACharSetNameToEncoding(CFStringRef theString)
{
  return MEMORY[0x1E0C98F40](theString);
}

CFArrayRef CFStringCreateArrayWithFindResults(CFAllocatorRef alloc, CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return (CFArrayRef)MEMORY[0x1E0C98F60](alloc, theString, stringToFind, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1E0C98F78](alloc, theString);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98F88](alloc, data, *(_QWORD *)&encoding);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F90](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F98](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1E0C98FB8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FC8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)MEMORY[0x1E0C98FE8](alloc, chars, numChars);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1E0C99018](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x1E0C99020](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1E0C99030](alloc, str, range.location, range.length);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
  MEMORY[0x1E0C99038](theString, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x1E0C99050](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C99058](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1E0C99068](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

Boolean CFStringFindWithOptionsAndLocale(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFLocaleRef locale, CFRange *result)
{
  return MEMORY[0x1E0C99070](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, locale, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1E0C99080](theString, range.location, range.length, *(_QWORD *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99098](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1E0C990A0](theString, *(_QWORD *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1E0C990B0](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
  MEMORY[0x1E0C990C0](theString, range.location, range.length, buffer);
}

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  return (const UniChar *)MEMORY[0x1E0C990C8](theString);
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C990E0](string, buffer, maxBufLen);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1E0C99100](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99118](length, *(_QWORD *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1E0C99170]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1E0C99180](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1E0C99190](theString, suffix);
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
  MEMORY[0x1E0C991B8](str, idx, insertedStr);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  MEMORY[0x1E0C991D0](theString, locale);
}

void CFStringNormalize(CFMutableStringRef theString, CFStringNormalizationForm theForm)
{
  MEMORY[0x1E0C991D8](theString, theForm);
}

void CFStringReplace(CFMutableStringRef theString, CFRange range, CFStringRef replacement)
{
  MEMORY[0x1E0C991F0](theString, range.location, range.length, replacement);
}

CFStringTokenizerRef CFStringTokenizerCreate(CFAllocatorRef alloc, CFStringRef string, CFRange range, CFOptionFlags options, CFLocaleRef locale)
{
  return (CFStringTokenizerRef)MEMORY[0x1E0C99220](alloc, string, range.location, range.length, options, locale);
}

Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse)
{
  return MEMORY[0x1E0C99248](string, range, transform, reverse);
}

void CFStringTrim(CFMutableStringRef theString, CFStringRef trimString)
{
  MEMORY[0x1E0C99250](theString, trimString);
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
  MEMORY[0x1E0C99258](theString);
}

void CFStringUppercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  MEMORY[0x1E0C99260](theString, locale);
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return (CFTimeZoneRef)MEMORY[0x1E0C99280]();
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1E0C992C8](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1E0C992D8](anURL, pathStyle);
}

CFStringRef CFURLCopyHostName(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C992F0](anURL);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1E0C992F8](url);
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1E0C99320](url);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99380](allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1E0C99390](allocator, url);
}

CFURLRef CFURLCreateCopyDeletingPathExtension(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1E0C99398](allocator, url);
}

Boolean CFURLCreateDataAndPropertiesFromResource(CFAllocatorRef alloc, CFURLRef url, CFDataRef *resourceData, CFDictionaryRef *properties, CFArrayRef desiredProperties, SInt32 *errorCode)
{
  return MEMORY[0x1E0C993B0](alloc, url, resourceData, properties, desiredProperties, errorCode);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C993C8](allocator, buffer, bufLen, isDirectory);
}

CFStringRef CFURLCreateStringByAddingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveUnescaped, CFStringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C993F8](allocator, originalString, charactersToLeaveUnescaped, legalURLCharactersToBeEscaped, *(_QWORD *)&encoding);
}

CFStringRef CFURLCreateStringByReplacingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x1E0C99400](allocator, originalString, charactersToLeaveEscaped);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99420](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99448](allocator, URLString, baseURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C99490](url, resolveAgainstBase, buffer, maxBufLen);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C994A0](anURL);
}

Boolean CFURLHasDirectoryPath(CFURLRef anURL)
{
  return MEMORY[0x1E0C994C0](anURL);
}

CFUUIDRef CFUUIDCreateFromString(CFAllocatorRef alloc, CFStringRef uuidStr)
{
  return (CFUUIDRef)MEMORY[0x1E0C99520](alloc, uuidStr);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x1E0C99530](alloc, *(_QWORD *)&bytes.byte0, *(_QWORD *)&bytes.byte8);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)MEMORY[0x1E0C99558](alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1;
  uint64_t v2;
  CFUUIDBytes result;

  v1 = MEMORY[0x1E0C99568](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
  MEMORY[0x1E0C99600](stream);
}

CFWriteStreamRef CFWriteStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFWriteStreamRef)MEMORY[0x1E0C99630](alloc, fileURL);
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return MEMORY[0x1E0C99650](stream);
}

uint64_t LXLemmatizerCreate()
{
  return MEMORY[0x1E0D43640]();
}

uint64_t LXLemmatizerEnumerateLemmasforString()
{
  return MEMORY[0x1E0D43648]();
}

SCNetworkReachabilityRef SCNetworkReachabilityCreateWithName(CFAllocatorRef allocator, const char *nodename)
{
  return (SCNetworkReachabilityRef)MEMORY[0x1E0CE88C8](allocator, nodename);
}

Boolean SCNetworkReachabilityGetFlags(SCNetworkReachabilityRef target, SCNetworkReachabilityFlags *flags)
{
  return MEMORY[0x1E0CE88D8](target, flags);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1E0C80928](aBlock);
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1E0C9A498]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1E0C9A4B0]();
}

uint64_t _CFStringTokenizerTokenize()
{
  return MEMORY[0x1E0C9A560]();
}

uint64_t _CFStringTokenizerTokenizeCompoundWord()
{
  return MEMORY[0x1E0C9A568]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x1E0DE41F0]();
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1E0DE4388](this);
}

uint64_t std::istream::read()
{
  return MEMORY[0x1E0DE45D0]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x1E0DE46A8]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1E0DE47A8]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1E0DE47E0]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1E0DE47E8]();
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x1E0DE4C68](this, __sb);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1E0DE4D28]();
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x1E0DE4DD8](this);
}

void std::terminate(void)
{
  MEMORY[0x1E0DE4E18]();
}

uint64_t operator delete[]()
{
  return off_1E8B55EE0();
}

void operator delete(void *__p)
{
  off_1E8B55EE8(__p);
}

void operator delete(void *__p, const std::nothrow_t *a2)
{
  off_1E8B55EF0(__p, a2);
}

uint64_t operator delete()
{
  return off_1E8B55EF8();
}

void *__cdecl operator new[](size_t __sz, const std::nothrow_t *a2)
{
  return (void *)off_1E8B55F00(__sz, a2);
}

uint64_t operator new[]()
{
  return off_1E8B55F08();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_1E8B55F10(__sz);
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
  return (void *)off_1E8B55F18(__sz, a2);
}

uint64_t operator new()
{
  return off_1E8B55F20();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x1E0C80A58](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1E0DE5068](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1E0DE5080](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x1E0DE5098]();
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1E0DE50B8](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x1E0DE50C0](a1);
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x1E0DE50D8](a1, lptinfo, a3);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1E0C813D0](a1, *(_QWORD *)&a2);
}

void asl_free(asl_object_t obj)
{
  MEMORY[0x1E0C815C8](obj);
}

int asl_log(asl_object_t client, asl_object_t msg, int level, const char *format, ...)
{
  return MEMORY[0x1E0C815D0](client, msg, *(_QWORD *)&level, format);
}

asl_object_t asl_new(uint32_t type)
{
  return (asl_object_t)MEMORY[0x1E0C815D8](*(_QWORD *)&type);
}

int asl_set(asl_object_t obj, const char *key, const char *value)
{
  return MEMORY[0x1E0C815F0](obj, key, value);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)
{
  return MEMORY[0x1E0DE7A48](cls, name, size, alignment, types);
}

BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
  return MEMORY[0x1E0DE7A50](cls, name, imp, types);
}

Ivar class_getInstanceVariable(Class cls, const char *name)
{
  return (Ivar)MEMORY[0x1E0DE7AB8](cls, name);
}

int close(int a1)
{
  return MEMORY[0x1E0C82688](*(_QWORD *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x1E0C82698](a1);
}

int compress2(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen, int level)
{
  return MEMORY[0x1E0DE92A0](dest, destLen, source, sourceLen, *(_QWORD *)&level);
}

uLong compressBound(uLong sourceLen)
{
  return MEMORY[0x1E0DE92A8](sourceLen);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82BC8](when, queue, block);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1E0C82D00](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82D10](group, queue, block);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1E0C82D20]();
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82D48](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x1E0C82E98](object);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1E0C83050](__handle, __symbol);
}

int fclose(FILE *a1)
{
  return MEMORY[0x1E0C832F8](a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1E0C83370](a1);
}

int flock(int a1, int a2)
{
  return MEMORY[0x1E0C83400](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1E0C83460](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C834A0](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1E0C83560](*(_QWORD *)&a1, a2);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1E0C83590](*(_QWORD *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C835E0](__ptr, __size, __nitems, __stream);
}

pid_t getpid(void)
{
  return MEMORY[0x1E0C83760]();
}

IMP imp_implementationWithBlock(id block)
{
  return (IMP)MEMORY[0x1E0DE7B10](block);
}

long double log2(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BE8](__x);
  return result;
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1E0C83C38](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C83C40](a1, a2);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F10](ptr, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x1E0C840B8](__b, __pattern16, __len);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1E0C84160](a1, a2);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1E0C841D8](a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4, *(_QWORD *)&a5, a6);
}

int msync(void *a1, size_t a2, int a3)
{
  return MEMORY[0x1E0C84210](a1, a2, *(_QWORD *)&a3);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1E0C84220](a1, a2);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1E0DE7BA8](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1E0DE7BB8]();
}

Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)
{
  return (Class)MEMORY[0x1E0DE7BC0](superclass, name, extraBytes);
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7BD0](a1);
}

void objc_disposeClassPair(Class cls)
{
  MEMORY[0x1E0DE7C70](cls);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1E0DE7CB0](name);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D20](a1, a2);
}

id objc_msgSendSuper(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D28](a1, a2);
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1E0DE7D48]();
}

void objc_registerClassPair(Class cls)
{
  MEMORY[0x1E0DE7D68](cls);
}

void objc_release(id a1)
{
  MEMORY[0x1E0DE7D78](a1);
}

Class object_getClass(id a1)
{
  return (Class)MEMORY[0x1E0DE7FF8](a1);
}

Ivar object_getInstanceVariable(id obj, const char *name, void **outValue)
{
  return (Ivar)MEMORY[0x1E0DE8010](obj, name, outValue);
}

id object_getIvar(id a1, Ivar a2)
{
  return (id)MEMORY[0x1E0DE8018](a1, a2);
}

Ivar object_setInstanceVariableWithStrongDefault(id obj, const char *name, void *value)
{
  return (Ivar)MEMORY[0x1E0DE8040](obj, name, value);
}

void object_setIvar(id obj, Ivar ivar, id value)
{
  MEMORY[0x1E0DE8048](obj, ivar, value);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1E0C84480](a1, *(_QWORD *)&a2);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x1E0C844C0](a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1E0C84728](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x1E0C849F8]();
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E18](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1E0C84E20](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E28](a1);
}

int pthread_mutex_trylock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E30](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E38](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1E0C84E68](a1, a2);
}

int pthread_rwlock_destroy(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84E90](a1);
}

int pthread_rwlock_init(pthread_rwlock_t *a1, const pthread_rwlockattr_t *a2)
{
  return MEMORY[0x1E0C84E98](a1, a2);
}

int pthread_rwlock_rdlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EA0](a1);
}

int pthread_rwlock_unlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EB8](a1);
}

int pthread_rwlock_wrlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EC0](a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x1E0C84F88](__base, __nel, __width, __compar);
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1E0C85000](*(_QWORD *)&a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x1E0C85008](a1);
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return MEMORY[0x1E0C850B8](__p, __ec);
}

int rmdir(const char *a1)
{
  return MEMORY[0x1E0C85138](a1);
}

SEL sel_getUid(const char *str)
{
  return (SEL)MEMORY[0x1E0DE80D0](str);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C854D8](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85568](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85570](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C855E8](__s, *(_QWORD *)&__c);
}

uint64_t ucsdet_close()
{
  return MEMORY[0x1E0DE6058]();
}

uint64_t ucsdet_detect()
{
  return MEMORY[0x1E0DE6060]();
}

uint64_t ucsdet_getName()
{
  return MEMORY[0x1E0DE6080]();
}

uint64_t ucsdet_open()
{
  return MEMORY[0x1E0DE6090]();
}

uint64_t ucsdet_setText()
{
  return MEMORY[0x1E0DE6098]();
}

int uncompress(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen)
{
  return MEMORY[0x1E0DE93F8](dest, destLen, source, sourceLen);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1E0C85D40](*(_QWORD *)&__fd, __buf, __nbyte);
}

void xmlDocDumpMemory(xmlDocPtr cur, xmlChar **mem, int *size)
{
  MEMORY[0x1E0DE8D10](cur, mem, size);
}

xmlNodePtr xmlDocGetRootElement(const xmlDoc *doc)
{
  return (xmlNodePtr)MEMORY[0x1E0DE8D18](doc);
}

void xmlFreeDoc(xmlDocPtr cur)
{
  MEMORY[0x1E0DE8D38](cur);
}

xmlChar *__cdecl xmlNodeGetContent(const xmlNode *cur)
{
  return (xmlChar *)MEMORY[0x1E0DE8E70](cur);
}

xmlDocPtr xmlParseDoc(const xmlChar *cur)
{
  return (xmlDocPtr)MEMORY[0x1E0DE8EB0](cur);
}

xmlDocPtr xmlParseMemory(const char *buffer, int size)
{
  return (xmlDocPtr)MEMORY[0x1E0DE8EC8](buffer, *(_QWORD *)&size);
}

xmlXPathObjectPtr xmlXPathEvalExpression(const xmlChar *str, xmlXPathContextPtr ctxt)
{
  return (xmlXPathObjectPtr)MEMORY[0x1E0DE9158](str, ctxt);
}

void xmlXPathFreeContext(xmlXPathContextPtr ctxt)
{
  MEMORY[0x1E0DE9160](ctxt);
}

void xmlXPathFreeObject(xmlXPathObjectPtr obj)
{
  MEMORY[0x1E0DE9168](obj);
}

xmlXPathContextPtr xmlXPathNewContext(xmlDocPtr doc)
{
  return (xmlXPathContextPtr)MEMORY[0x1E0DE9178](doc);
}

int xmlXPathRegisterNs(xmlXPathContextPtr ctxt, const xmlChar *prefix, const xmlChar *ns_uri)
{
  return MEMORY[0x1E0DE9190](ctxt, prefix, ns_uri);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C85E00](objects, count);
}

void xpc_array_set_string(xpc_object_t xarray, size_t index, const char *string)
{
  MEMORY[0x1E0C85ED0](xarray, index, string);
}

xpc_connection_t xpc_connection_create(const char *name, dispatch_queue_t targetq)
{
  return (xpc_connection_t)MEMORY[0x1E0C85F90](name, targetq);
}

void xpc_connection_resume(xpc_connection_t connection)
{
  MEMORY[0x1E0C86018](connection);
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
  MEMORY[0x1E0C86030](connection, message);
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
  MEMORY[0x1E0C86038](connection, message, replyq, handler);
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x1E0C86048](connection, message);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
  MEMORY[0x1E0C86080](connection, handler);
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return (const void *)MEMORY[0x1E0C86198](xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return MEMORY[0x1E0C861A8](xdata);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C86208](keys, values, count);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C862A0](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1E0C862E0](xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
  MEMORY[0x1E0C86310](xdict, key, value);
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
  MEMORY[0x1E0C86330](xdict, key, bytes, length);
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
  MEMORY[0x1E0C86390](xdict, key, string);
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
  MEMORY[0x1E0C86398](xdict, key, value);
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
  MEMORY[0x1E0C863B8](xdict, key, value);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1E0C86520](object);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return MEMORY[0x1E0C86570](xint);
}

void xpc_release(xpc_object_t object)
{
  MEMORY[0x1E0C86658](object);
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1E0C86660](object);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return (const char *)MEMORY[0x1E0C86758](xstring);
}

xmlDocPtr xsltApplyStylesheet(xsltStylesheetPtr style, xmlDocPtr doc, const char **params)
{
  return (xmlDocPtr)MEMORY[0x1E0DE91A0](style, doc, params);
}

void xsltFreeStylesheet(xsltStylesheetPtr style)
{
  MEMORY[0x1E0DE91D8](style);
}

xsltStylesheetPtr xsltParseStylesheetDoc(xmlDocPtr doc)
{
  return (xsltStylesheetPtr)MEMORY[0x1E0DE9228](doc);
}

