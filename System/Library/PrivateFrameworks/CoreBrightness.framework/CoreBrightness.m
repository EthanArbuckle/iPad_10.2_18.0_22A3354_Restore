uint64_t _DisplayCompareFloats(float *a1, float *a2)
{
  if (*a1 >= *a2)
    return *a1 > *a2;
  else
    return -1;
}

float AABC::calculate95thPercentile(AABC *this, AABC::ALSFilter *a2)
{
  uint64_t v2;
  float v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7[5];

  v7[4] = (uint64_t)this;
  v7[3] = (uint64_t)a2;
  std::vector<float>::vector(v7, (uint64_t *)a2);
  v6 = std::vector<float>::begin[abi:ne180100](v7);
  v5 = std::vector<float>::end[abi:ne180100]((uint64_t)v7);
  std::sort[abi:ne180100]<std::__wrap_iter<float *>>(v6, v5);
  v2 = std::vector<float>::size[abi:ne180100](v7);
  v4 = *(float *)std::vector<float>::operator[][abi:ne180100](v7, (unsigned __int16)(vcvtpd_u64_f64((double)(unint64_t)v2 * 0.95) - 1));
  std::vector<float>::~vector[abi:ne180100](v7);
  return v4;
}

void sub_1B5292C5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15, _Unwind_Exception *exception_object)
{
  uint64_t v16;

  std::vector<float>::~vector[abi:ne180100]((uint64_t *)(v16 - 40));
  _Unwind_Resume(a1);
}

_QWORD *std::vector<float>::vector(_QWORD *a1, uint64_t *a2)
{
  std::vector<float>::vector(a1, a2);
  return a1;
}

{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;

  *a1 = 0;
  a1[1] = 0;
  std::vector<float>::__alloc[abi:ne180100]();
  std::allocator_traits<std::allocator<float>>::select_on_container_copy_construction[abi:ne180100]<std::allocator<float>,void,void>();
  std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<float>>(a1 + 2);
  v4 = *a2;
  v5 = a2[1];
  v2 = std::vector<float>::size[abi:ne180100](a2);
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1, v4, v5, v2);
  return a1;
}

_QWORD *std::vector<float>::__construct_at_end<float *,float *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v8 = a4;
  std::vector<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, a4);
  std::vector<float>::__alloc[abi:ne180100]();
  v7 = std::__uninitialized_allocator_copy[abi:ne180100]<std::allocator<float>,float *,float *,float *>(v4, v10, v9, v7);
  return std::vector<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1B5292DB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15)
{
  std::vector<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&a15);
  _Unwind_Resume(a1);
}

uint64_t std::vector<float>::max_size(uint64_t a1)
{
  uint64_t v2;
  _QWORD v3[2];

  v3[1] = a1;
  std::vector<float>::__alloc[abi:ne180100]();
  v3[0] = std::allocator_traits<std::allocator<float>>::max_size[abi:ne180100]<std::allocator<float>,void>();
  v2 = std::numeric_limits<long>::max[abi:ne180100]();
  return *std::min[abi:ne180100]<unsigned long>(v3, &v2);
}

uint64_t CFXUpdateColorFade(uint64_t a1, double a2)
{
  float v2;
  double v3;
  double v4;
  double v5;
  double v6;
  float v7;
  double v8;
  double *v9;
  char v11;
  char v12;
  double v13;
  uint64_t v14;
  int v15;
  int v16;
  float v17[3];
  float v18;
  _BYTE __b[72];
  double Current;
  int j;
  int i;
  char v23;
  float v24;
  float v25;
  BOOL v26;
  char v27;
  uint64_t v28;
  double *v29;
  char v30;
  char v31;
  char v32;
  char v33;
  char v34;
  uint64_t v35;
  double v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  float v42[4];
  _BYTE v43[36];
  float v44[9];
  float v45[9];
  float __src[9];
  float v47[9];
  float __dst[9];
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v37 = a1;
  v36 = a2;
  v35 = a1;
  v34 = 0;
  v33 = 0;
  v32 = 0;
  v31 = 0;
  v30 = 0;
  v29 = 0;
  v28 = mach_absolute_time();
  v27 = 1;
  if (*(_QWORD *)(v35 + 96))
  {
    v27 = *(_BYTE *)(*(_QWORD *)(v35 + 96) + 272) & 1;
    v32 = _CFXUpdateStrengthFade(v36, v35, *(_QWORD *)(v35 + 96) + 256) & 1;
    if ((*(_BYTE *)(*(_QWORD *)(v35 + 96) + 300) & 1) != 0)
    {
      *(_BYTE *)(*(_QWORD *)(v35 + 96) + 300) = 0;
      v27 = 0;
    }
    if ((*(_BYTE *)(*(_QWORD *)(v35 + 96) + 303) & 1) != 0)
    {
      v27 = (v27 & 1 & *(_BYTE *)(*(_QWORD *)(v35 + 96) + 328) & 1) != 0;
      if ((*(_BYTE *)(*(_QWORD *)(v35 + 96) + 328) & 1) == 0)
        _CFXUpdateStrengthFade(v36, v35, *(_QWORD *)(v35 + 96) + 312);
    }
  }
  v29 = (double *)(v35 + 368);
  if ((*(_BYTE *)(v35 + 384) & 1) == 0 || (v27 & 1) == 0)
    v34 = _CFXUpdateColorFadeInternal(v35, v29, 1, v36) & 1;
  v29 = (double *)(v35 + 536);
  if ((*(_BYTE *)(v35 + 552) & 1) == 0)
    v33 = _CFXUpdateColorFadeInternal(v35, v29, 0, v36) & 1;
  memcpy(__dst, (const void *)(v35 + 592), sizeof(__dst));
  _CFXApplyTwilightNightShiftAdjustment(v35, __dst);
  if ((*(_BYTE *)(v35 + 2280) & 1) == 0)
    v31 = CFXAmmoliteFadeInternal(v35 + 2264, *(_DWORD *)(v35 + 360), *(_QWORD *)(v35 + 352), v36) & 1;
  memcpy(v47, (const void *)(v35 + 496), sizeof(v47));
  Mul33MatrixBy33Matrix(v35 + 496, (uint64_t)__dst, (uint64_t)__src);
  if (*(_QWORD *)(v35 + 112))
    _CFXMagic(__src, v45, *(float **)(v35 + 112));
  else
    memcpy(v45, __src, sizeof(v45));
  Mul33MatrixBy33Matrix(v35 + 2320, (uint64_t)v45, (uint64_t)__src);
  if ((*(_BYTE *)(v35 + 2520) & 1) != 0)
  {
    if ((*(_BYTE *)(v35 + 2448) & 1) == 0)
      v30 = _CFXUpdateStrengthFade(v36, v35, v35 + 2432) & 1;
    _CFXCorrectForNativeWP(v35, v44, *(float *)(v35 + 2456));
    memcpy(v43, __src, sizeof(v43));
    Mul33MatrixBy33Matrix((uint64_t)v44, (uint64_t)v43, (uint64_t)__src);
  }
  v42[2] = 1.0;
  v42[1] = 1.0;
  v42[0] = 1.0;
  v40 = 0;
  v41 = 0;
  Mul33MatrixBy31Vector(__src, v42, (float *)&v40);
  v2 = MaxOfVector((float *)&v40);
  Div33MatrixByScalar((uint64_t)__src, (uint64_t)v45, v2);
  v26 = 0;
  v26 = *(float *)(v35 + 740) != *(float *)(v35 + 196);
  v25 = 0.0;
  v24 = 0.0;
  v23 = 0;
  v12 = 1;
  if ((v34 & 1) == 0)
  {
    v12 = 1;
    if ((v33 & 1) == 0)
    {
      v12 = 1;
      if ((v32 & 1) == 0)
        v12 = v31;
    }
  }
  v23 = (v12 ^ 1) & 1;
  for (i = 0; i < 3; ++i)
  {
    for (j = 0; j < 3; ++j)
    {
      v25 = vabds_f32(v45[3 * i + j], *(float *)(v35 + 704 + 12 * i + 4 * j));
      if (v25 > v24)
        v24 = v25;
      if ((v23 & 1) != 0)
      {
        if (i == j)
        {
          if (vabdd_f64(v45[3 * i + j], 1.0) > 0.001)
            v23 = 0;
        }
        else if (fabs(v45[3 * i + j]) > 0.001)
        {
          v23 = 0;
        }
      }
    }
  }
  if (*(_QWORD *)(v35 + 96) && (*(_BYTE *)(*(_QWORD *)(v35 + 96) + 184) & 1) != 0)
    v23 = 0;
  if ((v23 & 1) != 0)
    _CFXIdentity(v45);
  if (v24 > 0.001 || (v23 & 1) != 0)
    v26 = 1;
  if (v26 && *(_QWORD *)(v35 + 328))
  {
    __memcpy_chk();
    *(_DWORD *)(v35 + 740) = *(_DWORD *)(v35 + 196);
    Current = CFAbsoluteTimeGetCurrent();
    memset(__b, 0, sizeof(__b));
    v18 = 0.0;
    *(_QWORD *)v17 = 0;
    _CFXGetWPFromMatrix(v35, v45, v17, &v18);
    if (*(_DWORD *)(v35 + 2532) == 1)
    {
      if (*(_DWORD *)(v35 + 2528) == 1)
      {
        _CFXGetXYZD50Matrix(v35, v17, v45);
      }
      else if (!*(_DWORD *)(v35 + 2528))
      {
        _CFXGetsRGBD50Matrix(v35, v17, v45);
      }
    }
    else if (*(_DWORD *)(v35 + 2532) == 2)
    {
      if (*(_DWORD *)(v35 + 2528) == 1)
      {
        _CFXGetXYZMatrixWithLMSIlluminant(v35, v17, (float *)(v35 + 2536), v45);
      }
      else if (!*(_DWORD *)(v35 + 2528))
      {
        _CFXGetsRGBMatrixWithLMSIlluminant(v35, v17, (float *)(v35 + 2536), v45);
      }
    }
    v3 = _CFXRampInit((uint64_t)__b, 0.0, *(float *)(v35 + 740), v17[0], v17[1], Current, (uint64_t)v45, 0);
    (*(void (**)(_QWORD, _BYTE *, double))(v35 + 328))(*(_QWORD *)(v35 + 336), __b, v3);
    if ((*(_BYTE *)(v35 + 1800) & 1) != 0)
    {
      _CFXGetWPFromMatrix(v35, v47, v17, &v18);
      v4 = _CFXRampInit((uint64_t)__b, 0.0, *(float *)(v35 + 740), v17[0], v17[1], Current, (uint64_t)v47, 2);
      (*(void (**)(_QWORD, _BYTE *, double))(v35 + 328))(*(_QWORD *)(v35 + 336), __b, v4);
      _CFXGetWPFromMatrix(v35, __dst, v17, &v18);
      v5 = _CFXRampInit((uint64_t)__b, 0.0, *(float *)(v35 + 740), v17[0], v17[1], Current, (uint64_t)__dst, 1);
      (*(void (**)(_QWORD, _BYTE *, double))(v35 + 328))(*(_QWORD *)(v35 + 336), __b, v5);
      _CFXGetWPFromMatrix(v35, (float *)(v35 + 2320), v17, &v18);
      v6 = _CFXRampInit((uint64_t)__b, 0.0, *(float *)(v35 + 740), v17[0], v17[1], Current, v35 + 2320, 3);
      (*(void (**)(_QWORD, _BYTE *, double))(v35 + 328))(*(_QWORD *)(v35 + 336), __b, v6);
    }
    ++*(_DWORD *)(v35 + 1792);
    if ((*(_BYTE *)(v35 + 1801) & 1) != 0)
      ++*(_DWORD *)(v35 + 2104);
    v16 = 0;
    v7 = 1.0 / v18;
    *(float *)(v35 + 2140) = v7;
    v38 = 0;
    v39 = 0;
    CFXChromaticity2Tristimulus(v17, (float *)&v38, 100.0);
    v14 = 0;
    v15 = 0;
    CFXTristimulus2Lab((float *)&v38, (float *)&v14);
    v16 = binFromAb((float *)&v14 + 1);
    if (v16 != *(_DWORD *)(v35 + 1228))
    {
      v13 = MachTimeToSeconds(v28 - *(_QWORD *)(v35 + 1232));
      v9 = (double *)(v35 + 1024 + 8 * *(int *)(v35 + 1228));
      v8 = *v9 + v13;
      *v9 = v8;
      *(_QWORD *)(v35 + 1232) = v28;
      *(_DWORD *)(v35 + 1228) = v16;
      *(_DWORD *)(v35 + 320) = v16;
      ++*(_DWORD *)(v35 + 1160 + 4 * v16);
    }
    LODWORD(v8) = *(_DWORD *)(v35 + 1784);
    _CFXUpdateCompensatedBacklight(v35, v28, v8);
  }
  v11 = 1;
  if ((v34 & 1) == 0)
  {
    v11 = 1;
    if ((v33 & 1) == 0)
    {
      v11 = 1;
      if ((v32 & 1) == 0)
      {
        v11 = 1;
        if ((v31 & 1) == 0)
          v11 = v30;
      }
    }
  }
  return v11 & 1;
}

uint64_t _CFXUpdateStrengthFade(double a1, uint64_t a2, uint64_t a3)
{
  float v3;
  char v5;
  double v6;
  double v7;

  v7 = a1 - *(double *)(a3 + 8);
  v6 = v7 / *(double *)a3;
  v5 = 0;
  if (*(double *)a3 == 0.0 || v6 >= 1.0 || v7 < 0.0)
  {
    *(_DWORD *)(a3 + 24) = *(_DWORD *)(a3 + 20);
    *(_QWORD *)a3 = 0;
    *(_BYTE *)(a3 + 16) = 1;
  }
  else
  {
    v3 = *(float *)(a3 + 28) + v6 * (float)(*(float *)(a3 + 20) - *(float *)(a3 + 28));
    *(float *)(a3 + 24) = v3;
    v5 = 1;
  }
  return v5 & 1;
}

uint64_t _CFXGetMatrix(uint64_t a1, float *a2, uint64_t a3, float *a4)
{
  float v4;
  float v6;
  uint64_t v10;
  int v11;
  float v12[3];
  float v13[9];
  _BYTE v14[36];
  _DWORD __b[9];
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v6 = 1.0 / a2[1];
  *a2 = *a2 * v6;
  a2[1] = a2[1] * v6;
  a2[2] = a2[2] * v6;
  v18 = 0;
  v19 = 0;
  CFXTristimulus2lms(a2, (float *)&v18);
  v16 = 0;
  v17 = 0;
  Div31VectorBy31Vector((float *)&v18, a4, (float *)&v16);
  memset(__b, 0, sizeof(__b));
  __b[4] = HIDWORD(v16);
  __b[0] = v16;
  __b[8] = v17;
  Mul33MatrixBy33Matrix((uint64_t)__b, a1 + 2144, (uint64_t)v14);
  Mul33MatrixBy33Matrix(a1 + 2180, (uint64_t)v14, (uint64_t)v13);
  v12[2] = 1.0;
  v12[1] = 1.0;
  v12[0] = 1.0;
  v10 = 0;
  v11 = 0;
  Mul33MatrixBy31Vector(v13, v12, (float *)&v10);
  v4 = MaxOfVector((float *)&v10);
  return Div33MatrixByScalar((uint64_t)v13, a3, v4);
}

uint64_t Mul33MatrixBy33Matrix(uint64_t result, uint64_t a2, uint64_t a3)
{
  int j;
  int i;

  for (i = 0; i < 3; ++i)
  {
    for (j = 0; j < 3; ++j)
      *(float *)(a3 + 12 * i + 4 * j) = (float)((float)(*(float *)(result + 12 * i + 4)
                                                          * *(float *)(a2 + 12 + 4 * j))
                                                  + (float)(*(float *)(result + 12 * i) * *(float *)(a2 + 4 * j)))
                                          + (float)(*(float *)(result + 12 * i + 8) * *(float *)(a2 + 24 + 4 * j));
  }
  return result;
}

uint64_t Div33MatrixByScalar(uint64_t result, uint64_t a2, float a3)
{
  int j;
  int i;

  for (i = 0; i < 3; ++i)
  {
    for (j = 0; j < 3; ++j)
      *(float *)(a2 + 12 * i + 4 * j) = *(float *)(result + 12 * i + 4 * j) / a3;
  }
  return result;
}

float MaxOfVector(float *a1)
{
  float v3;

  if (*a1 <= a1[1])
    v3 = a1[1];
  else
    v3 = *a1;
  if (v3 <= a1[2])
    return a1[2];
  else
    return v3;
}

float CFXTristimulus2lms(float *a1, float *a2)
{
  return Mul33MatrixBy31Vector(Mcat, a1, a2);
}

float Div31VectorBy31Vector(float *a1, float *a2, float *a3)
{
  float result;

  *a3 = *a1 / *a2;
  a3[1] = a1[1] / a2[1];
  result = a1[2] / a2[2];
  a3[2] = result;
  return result;
}

uint64_t _CFXUpdateColorFadeInternal(uint64_t a1, double *a2, char a3, double a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v11;
  NSObject *oslog;
  float v13;
  float v14;
  uint64_t v15;
  _BYTE v16[12];
  int v17;
  uint64_t v18;
  uint64_t v19;
  int j;
  int i;
  double v22;
  int v23;
  int v24;
  int v25;
  char v26;
  double v27;
  double v28;
  char v29;
  double *v30;
  double v31;
  uint64_t v32;
  uint8_t v33[40];
  uint64_t v34;
  int v35;
  float __dst[9];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v32 = a1;
  v31 = a4;
  v30 = a2;
  v29 = a3 & 1;
  v28 = 0.0;
  v28 = a4 - a2[1];
  v27 = 0.0;
  v27 = v28 / *a2;
  v26 = 0;
  if (*a2 == 0.0 || v27 >= 1.0 || v28 < 0.0)
  {
    memcpy(__dst, (char *)v30 + 20, sizeof(__dst));
    *v30 = 0.0;
    *((_BYTE *)v30 + 16) = 1;
  }
  else
  {
    v25 = 0;
    v25 = *(_DWORD *)(v32 + 360) - 1;
    v27 = v27 * (float)v25;
    v24 = (int)v27;
    v23 = (int)v27 + 1;
    v22 = v27 - (double)(int)v27;
    v27 = (1.0 - v22) * *(float *)(*(_QWORD *)(v32 + 352) + 4 * (int)v27)
        + v22 * *(float *)(*(_QWORD *)(v32 + 352) + 4 * v23);
    for (i = 0; i < 3; ++i)
    {
      for (j = 0; j < 3; ++j)
      {
        v4 = *((float *)v30 + 3 * i + j + 23)
           + v27 * (float)(*((float *)v30 + 3 * i + j + 5) - *((float *)v30 + 3 * i + j + 23));
        __dst[3 * i + j] = v4;
      }
    }
    v26 = 1;
  }
  __memcpy_chk();
  if ((v29 & 1) != 0 && *(_QWORD *)(v32 + 96))
  {
    v19 = 0;
    v19 = *(_QWORD *)(v32 + 96);
    v18 = 0;
    v17 = 0;
    _CFXGetWPFromMatrix(v32, __dst, &v18, &v17);
    memset(v16, 0, sizeof(v16));
    v34 = 0;
    v35 = 0;
    CFXChromaticity2Tristimulus((float *)&v18, (float *)&v34, 100.0);
    CFXTristimulus2Lab((float *)&v34, (float *)v16);
    if (*(_QWORD *)(v19 + 56))
    {
      v15 = *(_QWORD *)&v16[4];
      _CFXStickToPolygon(*(_QWORD *)(v19 + 56), *(_DWORD *)(v19 + 148), (float *)&dword_1B546151C, (float *)&v16[4], (float *)&v16[4]);
      if (*(float *)&v15 != *(float *)&v16[4] && *((float *)&v15 + 1) != *(float *)&v16[8])
        syslog(7, "Restrict: (%f, %f) -> (%f, %f)\n", *(float *)&v15, *(float *)&v15, *(float *)&v16[4], *(float *)&v16[8]);
    }
    v14 = 0.0;
    if ((*(_BYTE *)(*(_QWORD *)(v32 + 96) + 303) & 1) != 0)
    {
      v13 = fminf(*(float *)(v19 + 336), *(float *)(v19 + 280));
      oslog = MEMORY[0x1E0C81028];
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v33, COERCE__INT64(v13), COERCE__INT64(*(float *)(v19 + 336)), COERCE__INT64(*(float *)(v19 + 280)));
        _os_log_impl(&dword_1B5291000, oslog, OS_LOG_TYPE_DEFAULT, "BaselineHarmony: Current strength: %f, ALSStrength: %f, AppStrength: %f", v33, 0x20u);
      }
    }
    else
    {
      v13 = *(float *)(v19 + 280);
    }
    *(float *)(v19 + 308) = v13;
    if ((*(_BYTE *)(v19 + 144) & 1) != 0)
    {
      v14 = _CFXFindAdaptation((float *)&v16[4], (uint64_t *)(v19 + 64));
      if ((*(_BYTE *)(v19 + 145) & 1) != 0)
      {
        v11 = _CFXFindAdaptation((float *)&v16[4], (uint64_t *)(v19 + 104));
        if (v13 > 0.35)
        {
          if (v13 > 0.7)
          {
            if (v13 > 0.85)
            {
              v14 = 0.0;
            }
            else
            {
              v7 = (0.85 - v13) / 0.15;
              v14 = (float)((float)(1.0 - v7) * 0.0) + (float)(v7 * v14);
            }
          }
          else
          {
            v6 = (0.7 - v13) / 0.35;
            v14 = (float)((float)(1.0 - v6) * v14) + (float)(v6 * v11);
          }
        }
        else
        {
          v5 = (0.35 - v13) / 0.35;
          v14 = (float)((float)(1.0 - v5) * v11) + (float)(v5 * 1.0);
        }
      }
    }
    v8 = (float)(v14 * 0.0) + (1.0 - v14) * *(float *)&v16[4];
    *(float *)&v16[4] = v8;
    v9 = (float)(v14 * 0.0) + (1.0 - v14) * *(float *)&v16[8];
    *(float *)&v16[8] = v9;
    *(float *)&v16[4] = v8 + (float)(v13 * *(float *)(v19 + 292));
    *(float *)&v16[8] = v9 + (float)(v13 * *(float *)(v19 + 296));
    CFXLab2Tristimulus((float *)v16, (float *)&v34);
    *(float *)(v32 + 2100) = v14;
    CFXTristimulus2Chromaticity((float *)&v34, (float *)(v32 + 2108));
    _CFXGetMatrix(v32, (float *)&v34, (uint64_t)__dst, (float *)(v32 + 2128));
  }
  __memcpy_chk();
  return v26 & 1;
}

float _CFXFindAdaptation(float *a1, uint64_t *a2)
{
  float v2;
  float v3;
  double v5;
  double v6;
  int v7;
  int v8;
  float v9;
  int j;
  int i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;

  v20 = *((_DWORD *)a2 + 2);
  v19 = *((_DWORD *)a2 + 6);
  v18 = v20 - 1;
  v17 = v20 - 1;
  v16 = v19 - 1;
  v15 = v19 - 1;
  v13 = *a2;
  v12 = a2[2];
  for (i = 0; i < v20; ++i)
  {
    if (*a1 <= *(float *)(v13 + 4 * i))
    {
      v17 = i;
      if (i)
        v8 = i - 1;
      else
        v8 = 0;
      v18 = v8;
      break;
    }
  }
  for (j = 0; j < v19; ++j)
  {
    if (a1[1] <= *(float *)(v12 + 4 * j))
    {
      v15 = j;
      if (j)
        v7 = j - 1;
      else
        v7 = 0;
      v16 = v7;
      break;
    }
  }
  if (v18 == v17)
    v6 = 1.0;
  else
    v6 = (float)((float)(*a1 - *(float *)(v13 + 4 * v18))
               / (float)(*(float *)(v13 + 4 * v17) - *(float *)(v13 + 4 * v18)));
  v2 = v6;
  v9 = v2;
  if (v16 == v15)
    v5 = 1.0;
  else
    v5 = (float)((float)(a1[1] - *(float *)(v12 + 4 * v16))
               / (float)(*(float *)(v12 + 4 * v15) - *(float *)(v12 + 4 * v16)));
  v3 = v5;
  v14 = a2[4];
  return (float)((float)((float)(*(float *)(*(_QWORD *)(v14 + 8 * v15) + 4 * v17) * v9)
                       + (float)(*(float *)(*(_QWORD *)(v14 + 8 * v15) + 4 * v18) * (float)(1.0 - v9)))
               * v3)
       + (float)((float)((float)(*(float *)(*(_QWORD *)(v14 + 8 * v16) + 4 * v17) * v9)
                       + (float)(*(float *)(*(_QWORD *)(v14 + 8 * v16) + 4 * v18) * (float)(1.0 - v9)))
               * (float)(1.0 - v3));
}

float CFXChromaticity2Tristimulus(float *a1, float *a2, float a3)
{
  float result;

  *a2 = (float)(*a1 / a1[1]) * a3;
  a2[1] = a3;
  result = (1.0 - *a1 - a1[1]) / a1[1] * a3;
  a2[2] = result;
  return result;
}

float _CFXGetWPFromMatrix(uint64_t a1, float *a2, _QWORD *a3, _DWORD *a4)
{
  float result;
  uint64_t v5;
  _DWORD *v6;
  _QWORD *v7;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v9 = a1;
  v8 = a2;
  v7 = a3;
  v6 = a4;
  v14 = 0x3F8000003F800000;
  v15 = 1065353216;
  if ((*(_BYTE *)(a1 + 2520) & 1) != 0)
  {
    v14 = *(_QWORD *)(v9 + 2508);
    v15 = *(_DWORD *)(v9 + 2516);
  }
  v12 = 0;
  v13 = 0;
  Mul33MatrixBy31Vector(v8, (float *)&v14, (float *)&v12);
  v10 = 0;
  v11 = 0;
  Mul33MatrixBy31Vector((float *)(v9 + 2216), (float *)&v12, (float *)&v10);
  v5 = 0;
  CFXTristimulus2Chromaticity((float *)&v10, (float *)&v5);
  *v7 = v5;
  result = *((float *)&v10 + 1);
  *v6 = HIDWORD(v10);
  return result;
}

float Mul33MatrixBy31Vector(float *a1, float *a2, float *a3)
{
  float result;

  *a3 = (float)((float)(a1[1] * a2[1]) + (float)(*a1 * *a2)) + (float)(a1[2] * a2[2]);
  a3[1] = (float)((float)(a1[4] * a2[1]) + (float)(a1[3] * *a2)) + (float)(a1[5] * a2[2]);
  result = (float)((float)(a1[7] * a2[1]) + (float)(a1[6] * *a2)) + (float)(a1[8] * a2[2]);
  a3[2] = result;
  return result;
}

float CFXTristimulus2Chromaticity(float *a1, float *a2)
{
  float result;
  float v3;

  v3 = (float)(*a1 + a1[1]) + a1[2];
  *a2 = *a1 / v3;
  result = a1[1] / v3;
  a2[1] = result;
  return result;
}

float CFXTristimulus2Lab(float *a1, float *a2)
{
  float v2;
  float result;
  float v6;
  float v7;

  v6 = F(*a1 / 95.05);
  v7 = F(a1[1] / 100.0);
  v2 = F(a1[2] / 108.9);
  *a2 = (float)(116.0 * v7) + -16.0;
  a2[1] = 500.0 * (float)(v6 - v7);
  result = 200.0 * (float)(v7 - v2);
  a2[2] = result;
  return result;
}

float F(float a1)
{
  if (a1 > 0.0088565)
    return powf(a1, 0.33333);
  return 7.787 * a1 + 0.13793;
}

uint64_t __os_log_helper_16_0_3_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

float _CFXStickToPolygon(uint64_t a1, int a2, float *a3, float *a4, float *a5)
{
  double v5;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  int j;
  float v16;
  float v17;
  float v18;
  int i;

  *(float *)&v5 = *a3;
  if (*a3 == *a4)
  {
    *(float *)&v5 = a3[1];
    if (*(float *)&v5 == a4[1])
    {
      a5[1] = a4[1];
      *(float *)&v5 = *a4;
      *a5 = *a4;
    }
    else
    {
      for (i = 0; i < a2 - 1; ++i)
      {
        *(float *)&v5 = (float)(*(float *)(a1 + 8 * i) - *a4) * (float)(*a4 - *(float *)(a1 + 8 * (i + 1)));
        if (*(float *)&v5 >= 0.0)
        {
          v18 = *(float *)(a1 + 8 * i + 4)
              + (float)((float)((float)(*(float *)(a1 + 8 * (i + 1) + 4) - *(float *)(a1 + 8 * i + 4))
                              / (float)(*(float *)(a1 + 8 * (i + 1)) - *(float *)(a1 + 8 * i)))
                      * (float)(*a4 - *(float *)(a1 + 8 * i)));
          v17 = v18 - a4[1];
          v16 = a4[1] - a3[1];
          if ((float)(v17 * v16) > 0.0)
          {
            a5[1] = a4[1];
            *(float *)&v5 = *a4;
            *a5 = *a4;
            return *(float *)&v5;
          }
          v5 = fabs(v17);
          if (v5 < fabs(v16))
          {
            a5[1] = v18;
            *(float *)&v5 = *a4;
            *a5 = *a4;
            return *(float *)&v5;
          }
        }
      }
    }
  }
  else
  {
    for (j = 0; j < a2 - 1; ++j)
    {
      v14 = (float)(a4[1] - a3[1]) / (float)(*a4 - *a3);
      v13 = a3[1] - (float)(v14 * *a3);
      if ((float)(*(float *)(a1 + 8 * (j + 1)) - *(float *)(a1 + 8 * j)) == 0.0)
      {
        v12 = *(float *)(a1 + 8 * (j + 1));
      }
      else
      {
        v10 = (float)(*(float *)(a1 + 8 * (j + 1) + 4) - *(float *)(a1 + 8 * j + 4))
            / (float)(*(float *)(a1 + 8 * (j + 1)) - *(float *)(a1 + 8 * j));
        v12 = (float)(v13 - (float)(*(float *)(a1 + 8 * j + 4) - (float)(v10 * *(float *)(a1 + 8 * j))))
            / (float)(v10 - v14);
      }
      v11 = v13 + (float)(v14 * v12);
      *(float *)&v5 = (float)(*(float *)(a1 + 8 * j) - v12) * (float)(v12 - *(float *)(a1 + 8 * (j + 1)));
      if (*(float *)&v5 >= 0.0)
      {
        *(float *)&v5 = (float)(*(float *)(a1 + 8 * j + 4) - v11) * (float)(v11 - *(float *)(a1 + 8 * (j + 1) + 4));
        if (*(float *)&v5 >= 0.0)
        {
          v9 = (float)((float)(a3[1] - v11) * (float)(a3[1] - v11)) + (float)((float)(*a3 - v12) * (float)(*a3 - v12));
          v8 = (float)((float)(a3[1] - a4[1]) * (float)(a3[1] - a4[1]))
             + (float)((float)(*a3 - *a4) * (float)(*a3 - *a4));
          v7 = (float)((float)(a4[1] - v11) * (float)(a4[1] - v11)) + (float)((float)(*a4 - v12) * (float)(*a4 - v12));
          if (v9 >= v8 && v9 >= v7)
          {
            a5[1] = a4[1];
            *(float *)&v5 = *a4;
            *a5 = *a4;
            return *(float *)&v5;
          }
          *(float *)&v5 = (float)((float)(a3[1] - a4[1]) * (float)(a3[1] - a4[1]))
                        + (float)((float)(*a3 - *a4) * (float)(*a3 - *a4));
          if (v8 >= v9)
          {
            *(float *)&v5 = (float)((float)(a3[1] - a4[1]) * (float)(a3[1] - a4[1]))
                          + (float)((float)(*a3 - *a4) * (float)(*a3 - *a4));
            if (v8 >= v7)
            {
              a5[1] = v11;
              *(float *)&v5 = v12;
              *a5 = v12;
              return *(float *)&v5;
            }
          }
        }
      }
    }
  }
  return *(float *)&v5;
}

float CFXLab2Tristimulus(float *a1, float *a2)
{
  float v2;
  float v3;
  float result;
  float v5;

  v5 = (float)(*a1 + 16.0) / 116.0;
  v2 = v5 + a1[1] / 500.0;
  *a2 = 95.05 * invF(v2);
  a2[1] = 100.0 * invF(v5);
  v3 = v5 - a1[2] / 200.0;
  result = 108.9 * invF(v3);
  a2[2] = result;
  return result;
}

float invF(float a1)
{
  if (a1 > 0.2069)
    return powf(a1, 3.0);
  return 0.12842 * (a1 - 0.13793);
}

float _CFXMagic(float *a1, float *a2, float *a3)
{
  float result;
  int i;
  float v5[3];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  for (i = 0; i < 3; ++i)
    v5[i] = (float)(a1[3 * i] + a1[3 * i + 1]) + a1[3 * i + 2];
  a2[1] = *a3 * a1[1];
  a2[2] = a3[1] * a1[2];
  *a2 = (float)(v5[0] - a2[1]) - a2[2];
  a2[3] = a3[2] * a1[3];
  a2[5] = a3[3] * a1[5];
  a2[4] = (float)(v5[1] - a2[3]) - a2[5];
  a2[6] = a3[4] * a1[6];
  a2[7] = a3[5] * a1[7];
  result = (float)(v5[2] - a2[6]) - a2[7];
  a2[8] = result;
  return result;
}

void _CFXApplyTwilightNightShiftAdjustment(uint64_t a1, float *a2)
{
  NSObject *oslog;
  uint64_t v3;
  float v4;
  float v5;
  float v6;
  int v7;
  uint64_t v8;
  float *v9;
  uint64_t v10;
  uint8_t v11[40];
  uint64_t v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10 = a1;
  v9 = a2;
  if ((*(_BYTE *)(a1 + 2552) & 1) != 0 && !float_equal(*(float *)(v10 + 2600), 0.0) && !_CFXIsIdentity(v9))
  {
    v8 = 0;
    v7 = 0;
    CFXGetWPFromMatrix(v10, v9, &v8, &v7);
    v6 = CFXChromaticity2CCT((float *)&v8);
    v5 = 0.0;
    v5 = two_dimensional_interpolation(*(float **)(v10 + 2568), *(_QWORD *)(v10 + 2560), *(float **)(v10 + 2584), *(_QWORD *)(v10 + 2576), *(_QWORD *)(v10 + 2592), v6, *(float *)(v10 + 2600));
    if (!float_equal(v5, 0.0))
    {
      v4 = v6 + v5;
      v3 = 0;
      _CFXCCT2xy_Shifted(v10, (float *)&v3, v6 + v5);
      v12 = 0;
      v13 = 0;
      CFXChromaticity2Tristimulus((float *)&v3, (float *)&v12, 100.0);
      _CFXGetMatrix(v10, (float *)&v12, (uint64_t)v9, (float *)(v10 + 2128));
      oslog = MEMORY[0x1E0C81028];
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v11, COERCE__INT64(*(float *)(v10 + 2600)), COERCE__INT64(v6), COERCE__INT64(v4));
        _os_log_impl(&dword_1B5291000, oslog, OS_LOG_TYPE_DEFAULT, "TWNS | Twilight.Strength=%f CCT.Original=%f CCT.Adjusted=%f", v11, 0x20u);
      }
    }
  }
}

void *ColorRampCallback(void *result, uint64_t a2)
{
  if (result)
    return (void *)objc_msgSend(result, "colorRampRoutine:", a2);
  return result;
}

{
  if (result)
    return (void *)objc_msgSend(result, "colorRampRoutine:", a2);
  return result;
}

void ColorRampCallback_0(_BYTE *a1, float *a2)
{
  float v2;
  float v3;
  double v4;
  CFAllocatorRef *v5;
  uint64_t inited;
  NSObject *v7;
  double Current;
  CFDictionaryRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  float valuePtr;
  CFTypeRef cf;
  CFMutableArrayRef Mutable;
  void *value;
  unsigned int i;
  CFMutableArrayRef theArray;
  os_log_type_t type;
  os_log_t oslog;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  uint64_t v27;
  _BYTE *v28;
  float *v29;
  _BYTE *v30;
  void *values[4];
  _OWORD keys[2];
  uint8_t v33[56];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v30 = a1;
  v29 = a2;
  v28 = 0;
  if (a1)
  {
    v28 = v30;
    if (v29)
    {
      if (*((_DWORD *)v28 + 3149) == 1)
      {
        v27 = 0;
        v26 = 0.0;
        v25 = 0.0;
        CFXGetWPFromMatrix(*((_QWORD *)v28 + 1563), v29 + 1, &v27, &v26);
        v25 = 1.0 / v26;
        v24 = 0.0;
        v24 = *((float *)v28 + 386);
        CFXFindBrightnessCompAlpha(v24);
        v23 = v2;
        v3 = (float)(v23 * v25) + 1.0 - v23;
        v22 = v3;
        *((float *)v28 + 3132) = v3;
        v21 = 0.0;
        v21 = *((float *)v28 + 375);
        v20 = _DisplayComputeEDRNitsCap((uint64_t)v28);
        oslog = 0;
        if (_logHandle)
        {
          v7 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            inited = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            inited = init_default_corebrightness_log();
          v7 = inited;
        }
        oslog = v7;
        type = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_5_8_0_8_0_4_0_8_0_8_0((uint64_t)v33, COERCE__INT64(v21), COERCE__INT64(v20), *((_DWORD *)v28 + 3150), COERCE__INT64(*((float *)v28 + 298)), COERCE__INT64(*((float *)v28 + 3132)));
          _os_log_debug_impl(&dword_1B5291000, oslog, type, "Night Shift/Harmony - SetLibEDRBrightness - physicalBrightness:%f, maxLum: %f, edrState: %d, lux: %f, brightness boost: %f\n", v33, 0x30u);
        }
        SetLibEDRBrightness((uint64_t)v28, v21, v20, *((float *)v28 + 298), v22);
      }
      theArray = 0;
      theArray = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *((unsigned int *)v29 + 10), MEMORY[0x1E0C9B378]);
      if (theArray)
      {
        for (i = 0; i < *((_DWORD *)v29 + 10); ++i)
        {
          value = 0;
          value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v29[i + 1]);
          if (value)
          {
            CFArrayAppendValue(theArray, value);
            CFRelease(value);
          }
        }
        Mutable = 0;
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B378]);
        if (Mutable)
        {
          cf = 0;
          cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, v29 + 12);
          if (cf)
          {
            CFArrayAppendValue(Mutable, cf);
            CFRelease(cf);
          }
          cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, v29 + 13);
          if (cf)
          {
            CFArrayAppendValue(Mutable, cf);
            CFRelease(cf);
          }
          valuePtr = 0.0;
          valuePtr = *v29;
          v5 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
          v11 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &valuePtr);
          v10 = CFNumberCreate(*v5, kCFNumberFloatType, v29 + 11);
          if (v11)
          {
            if (v10)
            {
              keys[0] = xmmword_1E68EB628;
              keys[1] = xmmword_1E68EB638;
              values[0] = theArray;
              values[1] = v11;
              values[2] = v10;
              values[3] = Mutable;
              v9 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)values, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              if (v9)
              {
                if (*((_QWORD *)v28 + 2))
                  (*((void (**)(_QWORD, const __CFString *, CFDictionaryRef))v28 + 2))(*((_QWORD *)v28 + 3), CFSTR("ColorRamp"), v9);
                CFRelease(v9);
              }
            }
          }
          if (v11)
            CFRelease(v11);
          if (v10)
            CFRelease(v10);
          CFRelease(Mutable);
        }
        CFRelease(theArray);
      }
      v28[12521] = 0;
    }
    else
    {
      v28[12521] = 1;
      Current = CFAbsoluteTimeGetCurrent();
      if (*((_QWORD *)v28 + 1563))
      {
        if ((v28[12521] & 1) != 0)
        {
          v28[12521] = CFXUpdateColorFade(*((_QWORD *)v28 + 1563), Current) & 1;
          if ((v28[12521] & 1) != 0)
          {
            *(float *)&v4 = 1.0 / 60.0;
            __DisplayStartFade(v28, v4);
          }
        }
      }
    }
  }
}

double _CFXUpdateCompensatedBacklight(uint64_t a1, unint64_t a2, double result)
{
  float v3;
  double v4;
  float v5;
  float v6;
  float v8;

  v8 = *(float *)&result;
  if (a1)
  {
    v5 = _CFXFindBrightnessCompAlpha(AlphaArray, 7, *(float *)&result);
    v3 = (float)(v5 * *(float *)(a1 + 2140)) + 1.0 - v5;
    v6 = v8 * v3;
    v4 = MachTimeToSeconds((unint64_t)((double)a2 - *(double *)(a1 + 1776)));
    *(double *)(a1 + 1752) = *(double *)(a1 + 1752) + v4;
    *(double *)(a1 + 1760) = *(double *)(a1 + 1760) + v4 * *(float *)(a1 + 1788);
    *(double *)(a1 + 1768) = *(double *)(a1 + 1768) + v4 * *(float *)(a1 + 1784);
    *(float *)(a1 + 1784) = v8;
    *(float *)(a1 + 1788) = v6;
    result = (double)a2;
    *(double *)(a1 + 1776) = (double)a2;
  }
  return result;
}

float _CFXFindBrightnessCompAlpha(float *a1, int a2, float a3)
{
  float v4;
  int i;
  float v6;

  v6 = 0.0;
  if (a3 <= *a1)
    return a1[a2];
  if (a3 >= a1[a2 - 1])
    return a1[2 * a2 - 1];
  for (i = 1; i < a2; ++i)
  {
    if (a3 < a1[i])
    {
      v4 = (float)(a1[i] - a3) / (float)(a1[i] - a1[i - 1]);
      return (float)((float)(1.0 - v4) * a1[a2 + i]) + (float)(v4 * a1[a2 - 1 + i]);
    }
  }
  return v6;
}

double _CFXRampInit(uint64_t a1, float a2, float a3, float a4, float a5, double a6, uint64_t a7, int a8)
{
  double result;
  unint64_t v13;

  v13 = __PAIR64__(LODWORD(a5), LODWORD(a4));
  *(float *)(a1 + 44) = a3;
  *(_DWORD *)(a1 + 40) = 9;
  __memcpy_chk();
  *(float *)a1 = a2;
  *(_QWORD *)(a1 + 48) = v13;
  *(_DWORD *)(a1 + 56) = a8;
  result = a6;
  *(double *)(a1 + 64) = a6;
  return result;
}

uint64_t DisplaySetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;
  unsigned int v5;
  void (*v6)(void);
  int v7;
  int v8;
  void (*v9)(uint64_t);
  void *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  int v17;
  int v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = a1;
  v21 = a2;
  v20 = a3;
  v15 = 0;
  v16 = &v15;
  v17 = 0x20000000;
  v18 = 32;
  v19 = 1;
  v3 = *(NSObject **)(a1 + 144);
  v6 = (void (*)(void))MEMORY[0x1E0C809B0];
  v7 = -1073741824;
  v8 = 0;
  v9 = __DisplaySetProperty_block_invoke;
  v10 = &unk_1E68EB540;
  v12 = a3;
  v13 = a2;
  v14 = v22;
  v11 = &v15;
  disp_dispatch_sync(v3, &v6);
  v5 = *((unsigned __int8 *)v16 + 24);
  _Block_object_dispose(&v15, 8);
  return v5;
}

void sub_1B529B02C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 56), 8);
  _Unwind_Resume(a1);
}

BOOL float_equal(float a1, float a2)
{
  float v3;
  float v4;

  v4 = std::__math::fabs[abi:ne180100](a1 - a2);
  v3 = std::__math::fabs[abi:ne180100](a1);
  return v4 <= (float)(0.00000011921 * fmaxf(v3, std::__math::fabs[abi:ne180100](a2)));
}

void sub_1B529CC68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1B529DDF4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

__IOHIDEvent *AABC::filter(AABC *this, __IOHIDServiceClient *a2, __IOHIDEvent *a3)
{
  unint64_t v4;
  uint64_t inited;
  NSObject *v6;
  uint8_t v9[24];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (_logHandle)
  {
    v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v6 = inited;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_4_0_4_0((uint64_t)v9, 4, *((_DWORD *)this + 94));
    _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "[%x]: _plugInEnabled=%x", v9, 0xEu);
  }
  if (*((_DWORD *)this + 94))
  {
    v4 = IOHIDEventGetType() - 2;
    if (v4 <= 0xC)
      __asm { BR              X8 }
  }
  return a3;
}

float AABC::IlluminanceToLuminance(uint64_t a1, float *a2, float a3)
{
  const CustomCurve *v3;
  const CustomCurve *v4;
  const CustomCurve *v5;
  void *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t inited;
  NSObject *v23;
  os_log_type_t __b[167];
  os_log_type_t v26;
  os_log_t v27;
  os_log_type_t v28;
  os_log_t v29;
  os_log_type_t v30;
  os_log_t oslog;
  os_log_type_t v32;
  os_log_t v33;
  os_log_type_t v34;
  os_log_t v35;
  os_log_type_t v36;
  os_log_t v37;
  os_log_type_t v38;
  os_log_t v39;
  os_log_type_t v40;
  os_log_t v41;
  float v42;
  float *v43;
  float v44;
  uint64_t v45;
  uint8_t v47[16];
  uint8_t v48[16];
  uint8_t v49[16];
  uint8_t v50[16];
  uint8_t v51[16];
  uint8_t v52[16];
  uint8_t v53[16];
  uint8_t v54[8];
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v45 = a1;
  v44 = a3;
  v43 = a2;
  if ((*(_BYTE *)(a1 + 136) & 1) != 0)
  {
    v42 = 0.0;
    v41 = 0;
    if (_logHandle)
    {
      v23 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v23 = inited;
    }
    v41 = v23;
    v40 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v54, *(_DWORD *)(a1 + 1384));
      _os_log_debug_impl(&dword_1B5291000, v41, v40, "CustomCurveA size %d", v54, 8u);
    }
    v39 = 0;
    if (_logHandle)
    {
      v21 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v20 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v20 = init_default_corebrightness_log();
      v21 = v20;
    }
    v39 = v21;
    v38 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v53, *(_DWORD *)(a1 + 1548));
      _os_log_debug_impl(&dword_1B5291000, v39, v38, "CustomCurveB size %d", v53, 8u);
    }
    if (*(_DWORD *)(a1 + 2876))
    {
      v37 = 0;
      if (_logHandle)
      {
        v19 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v18 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v18 = init_default_corebrightness_log();
        v19 = v18;
      }
      v37 = v19;
      v36 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v52, COERCE__INT64(*(float *)(a1 + 1304 + 4 * (*(_DWORD *)(a1 + 1384) - 1))));
        _os_log_debug_impl(&dword_1B5291000, v37, v36, "Max L point of CustomCurveA is %f", v52, 0xCu);
      }
      v35 = 0;
      if (_logHandle)
      {
        v17 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v16 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v16 = init_default_corebrightness_log();
        v17 = v16;
      }
      v35 = v17;
      v34 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v51, COERCE__INT64(*(float *)(a1 + 1224 + 4 * (*(_DWORD *)(a1 + 1384) - 1))));
        _os_log_debug_impl(&dword_1B5291000, v35, v34, "Max E point of CustomCurveA is %f", v51, 0xCu);
      }
      v33 = 0;
      if (_logHandle)
      {
        v15 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v14 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v14 = init_default_corebrightness_log();
        v15 = v14;
      }
      v33 = v15;
      v32 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v50, COERCE__INT64(v44));
        _os_log_debug_impl(&dword_1B5291000, v33, v32, "CustomCurve E=%f", v50, 0xCu);
      }
      return AAB::IlluminanceToLuminance((AAB *)(a1 + 1224), v44, v3);
    }
    else
    {
      oslog = 0;
      if (_logHandle)
      {
        v13 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v12 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v12 = init_default_corebrightness_log();
        v13 = v12;
      }
      oslog = v13;
      v30 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v49, COERCE__INT64(*(float *)(a1 + 1468 + 4 * (*(_DWORD *)(a1 + 1548) - 1))));
        _os_log_debug_impl(&dword_1B5291000, oslog, v30, "Max L point of CustomCurveB is %f", v49, 0xCu);
      }
      v29 = 0;
      if (_logHandle)
      {
        v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v10 = init_default_corebrightness_log();
        v11 = v10;
      }
      v29 = v11;
      v28 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v48, COERCE__INT64(*(float *)(a1 + 1388 + 4 * (*(_DWORD *)(a1 + 1548) - 1))));
        _os_log_debug_impl(&dword_1B5291000, v29, v28, "Max E point of CustomCurveB is %f", v48, 0xCu);
      }
      v27 = 0;
      if (_logHandle)
      {
        v9 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v8 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v8 = init_default_corebrightness_log();
        v9 = v8;
      }
      v27 = v9;
      v26 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v47, COERCE__INT64(v44));
        _os_log_debug_impl(&dword_1B5291000, v27, v26, "CustomCurve E=%f", v47, 0xCu);
      }
      return AAB::IlluminanceToLuminance((AAB *)(a1 + 1388), v44, v4);
    }
  }
  else if (AABC::isAODCurveActive(a1, -[CBAODState AODState](+[CBAODState sharedInstance](CBAODState, "sharedInstance"), "AODState")))
  {
    return AABC::IlluminanceToLuminanceAggregated_AOD(a1, (AAB *)(a1 + 2540), (float *)(a1 + 1048), v44);
  }
  else if (*(_QWORD *)(a1 + 4056) && (objc_msgSend(*(id *)(a1 + 4056), "isActive") & 1) != 0)
  {
    v7 = *(void **)(a1 + 4056);
    if (v7)
      objc_msgSend(v7, "curve");
    else
      memset(__b, 0, 0xA4uLL);
    return AAB::IlluminanceToLuminance((AAB *)__b, v44, v5);
  }
  else
  {
    return AAB::IlluminanceToLuminance(a1, v43, v44);
  }
}

float AAB::IlluminanceToLuminance(uint64_t a1, float *a2, float a3)
{
  float v5;
  float v6;
  float v7;

  (*(void (**)(uint64_t, const char *, ...))(*(_QWORD *)a1 + 16))(a1, "%s: inputs: (_E1 = %0.2f, _L1 = %0.4f) (_E2 = %0.2f, _L2 = %0.4f) E=%0.2f", "IlluminanceToLuminance", a2[4], a2[6], a2[5], a2[7], a3);
  (*(void (**)(uint64_t, const char *, ...))(*(_QWORD *)a1 + 16))(a1, "%s:    dark (E0a = %0.2f, L0a = %0.4f) (E0b = %0.2f, L0b = %0.4f)", "IlluminanceToLuminance", *a2, a2[1], a2[2], a2[3]);
  if (a3 >= a2[2])
  {
    if (a3 >= a2[5])
    {
      v6 = a2[21];
      v5 = a2[7] - (float)(v6 * a2[5]);
    }
    else
    {
      v6 = (float)(a2[7] - a2[6]) / (float)(a2[5] - a2[4]);
      v5 = a2[6];
    }
  }
  else
  {
    v6 = (float)(a2[3] - a2[1]) / (float)(a2[2] - *a2);
    v5 = a2[1];
  }
  v7 = fmaxf(v5 + (float)(v6 * a3), 0.0);
  (*(void (**)(uint64_t, const char *, ...))(*(_QWORD *)a1 + 16))(a1, "%s: (E2=%f) E=%f * slope=%f + offset=%f  L=%f", "IlluminanceToLuminance", a2[5], a3, v6, v5, v7);
  (*(void (**)(uint64_t, const char *, ...))(*(_QWORD *)a1 + 16))(a1, "%s: outputs: L=%f", "IlluminanceToLuminance", v7);
  return v7;
}

BOOL AABC::isAODCurveActive(uint64_t a1, uint64_t a2)
{
  BOOL v3;

  v3 = 1;
  if (a2 != 1)
    return a2 == 3;
  return v3;
}

float AAB::IlluminanceToLuminance(AAB *this, float a2, const CustomCurve *a3)
{
  float v4;
  int i;
  float v6;

  v6 = 0.0;
  if (*((int *)this + 40) <= 1)
  {
    if (*((_DWORD *)this + 40) == 1)
      v4 = *((float *)this + 20);
    else
      v4 = 0.0;
    v6 = v4;
  }
  else
  {
    for (i = 0; i < *((_DWORD *)this + 40) - 1; ++i)
    {
      if (a2 <= *((float *)this + i + 1))
      {
        if ((float)(*((float *)this + i + 1) - *((float *)this + i)) != 0.0)
          v6 = *((float *)this + i + 20)
             + (float)((float)((float)(*((float *)this + i + 21) - *((float *)this + i + 20))
                             / (float)(*((float *)this + i + 1) - *((float *)this + i)))
                     * (float)(a2 - *((float *)this + i)));
        return fmaxf(fmaxf(v6, 0.0), *((float *)this + 20));
      }
      if (i == *((_DWORD *)this + 40) - 2)
      {
        v6 = *((float *)this + i + 21);
        return fmaxf(fmaxf(v6, 0.0), *((float *)this + 20));
      }
    }
  }
  return fmaxf(fmaxf(v6, 0.0), *((float *)this + 20));
}

uint64_t CFXGetAmbientAdaptationMode(uint64_t a1, float *a2)
{
  unsigned int v3;

  v3 = 0;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      v3 = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 248);
      if (a2)
        *a2 = _CFXGetStrengthFromMode(a1, v3);
    }
  }
  return v3;
}

uint64_t __os_log_helper_16_0_9_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 9;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 62) = 0;
  *(_BYTE *)(result + 63) = 8;
  *(_QWORD *)(result + 64) = a8;
  *(_BYTE *)(result + 72) = 0;
  *(_BYTE *)(result + 73) = 8;
  *(_QWORD *)(result + 74) = a9;
  *(_BYTE *)(result + 82) = 0;
  *(_BYTE *)(result + 83) = 8;
  *(_QWORD *)(result + 84) = a10;
  return result;
}

void CFXAnimateAmbientAdaptationModes(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, float *a6, float a7, float a8)
{
  CFAbsoluteTime v8;
  float v9;
  float v10;
  int j;
  int v12;
  char v13;
  float v14;
  float v15;
  int i;
  int v17;
  char v18;
  float v19;
  float v24;

  if (a1 && *(_QWORD *)(a1 + 96) && a4 && a5 > 0)
  {
    v19 = 1.0;
    v18 = 0;
    v17 = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 248);
    for (i = 0; i < a5; ++i)
    {
      v15 = _CFXGetStrengthFromMode(a1, *(_DWORD *)(a4 + 4 * i));
      if (v15 <= v19)
      {
        v19 = v15;
        v17 = *(_DWORD *)(a4 + 4 * i);
        v18 = 1;
      }
    }
    v14 = 1.0;
    v13 = 0;
    v12 = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 248);
    if (a2)
    {
      for (j = 0; j < a3; ++j)
      {
        v10 = _CFXGetStrengthFromMode(a1, *(_DWORD *)(a2 + 4 * j));
        if (v10 <= v14)
        {
          v14 = v10;
          v12 = *(_DWORD *)(a2 + 4 * j);
          v13 = 1;
        }
      }
    }
    if ((v13 & 1) == 0)
      v14 = _CFXGetStrengthFromMode(a1, *(_DWORD *)(*(_QWORD *)(a1 + 96) + 248));
    if ((v18 & 1) != 0)
    {
      v24 = fminf(1.0, fmaxf(0.0, a7));
      v9 = v14 + (float)(v24 * (float)(v19 - v14));
      if (a6)
        *a6 = v9;
      syslog(7, "ANIMATING from mode %d to mode %d with ratio %f and period %f -> strength %f", v12, v17, (float)(v24 * 100.0), a8, v9);
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 96) + 184) & 1) != 0)
      {
        *(float *)&v8 = v14 + (float)(v24 * (float)(v19 - v14));
        CFXSetAmbientAdaptationStrength(a1, v8, a8);
      }
      if (v24 >= 1.0)
        *(_DWORD *)(*(_QWORD *)(a1 + 96) + 248) = v17;
      else
        *(_DWORD *)(*(_QWORD *)(a1 + 96) + 248) = v12;
    }
  }
}

float _CFXGetStrengthFromMode(uint64_t a1, unsigned int a2)
{
  float v3;

  v3 = 0.0;
  if (a1 && *(_QWORD *)(a1 + 96))
    return *(float *)(*(_QWORD *)(a1 + 96) + 224 + 4 * a2);
  return v3;
}

CFAbsoluteTime CFXSetAmbientAdaptationStrength(uint64_t a1, CFAbsoluteTime result, float a3)
{
  double v3;
  double *v4;
  int v5;
  double v6;
  float v9;
  float v10;

  v10 = *(float *)&result;
  if (a1)
  {
    LODWORD(result) = *(_DWORD *)(a1 + 2252);
    if (*(float *)&result >= 0.0)
    {
      LODWORD(result) = *(_DWORD *)(a1 + 2252);
      a3 = *(float *)&result;
    }
    if (*(_QWORD *)(a1 + 96))
    {
      v9 = *(float *)(*(_QWORD *)(a1 + 96) + 252) * a3;
      *(float *)&result = v10;
      if (v10 != **(float **)(a1 + 96))
      {
        **(float **)(a1 + 96) = v10;
        if (*(_QWORD *)(*(_QWORD *)(a1 + 96) + 56))
        {
          free(*(void **)(*(_QWORD *)(a1 + 96) + 56));
          *(_QWORD *)(*(_QWORD *)(a1 + 96) + 56) = 0;
        }
        syslog(7, "Set strength %f\n", v10);
        *(_QWORD *)(*(_QWORD *)(a1 + 96) + 56) = _CFXPolygonFromStrength((_QWORD *)(*(_QWORD *)(a1 + 96) + 40), *(_DWORD *)(*(_QWORD *)(a1 + 96) + 148), 0.85);
        result = CFAbsoluteTimeGetCurrent();
        v6 = result;
        if ((*(_BYTE *)(a1 + 364) & 1) != 0 && (*(_BYTE *)(*(_QWORD *)(a1 + 96) + 301) & 1) == 0)
        {
          *(_BYTE *)(*(_QWORD *)(a1 + 96) + 272) = 0;
          *(_DWORD *)(*(_QWORD *)(a1 + 96) + 284) = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 280);
          *(float *)(*(_QWORD *)(a1 + 96) + 276) = v10;
          *(CFAbsoluteTime *)(*(_QWORD *)(a1 + 96) + 264) = result;
          result = v9;
          *(double *)(*(_QWORD *)(a1 + 96) + 256) = v9;
          if ((*(_BYTE *)(*(_QWORD *)(a1 + 96) + 303) & 1) != 0)
          {
            *(_BYTE *)(*(_QWORD *)(a1 + 96) + 328) = 0;
            *(_DWORD *)(*(_QWORD *)(a1 + 96) + 340) = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 336);
            *(_DWORD *)(*(_QWORD *)(a1 + 96) + 332) = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 332);
            *(double *)(*(_QWORD *)(a1 + 96) + 320) = v6;
            result = v9;
            *(double *)(*(_QWORD *)(a1 + 96) + 312) = v9;
          }
          if (*(_QWORD *)(a1 + 328))
            (*(void (**)(_QWORD, _QWORD))(a1 + 328))(*(_QWORD *)(a1 + 336), 0);
        }
        if ((*(_BYTE *)(*(_QWORD *)(a1 + 96) + 184) & 1) != 0)
        {
          *(float *)&result = v10 * 10.0;
          v5 = (int)(float)(v10 * 10.0);
          if (v5 > 9)
            v5 = 9;
          if (v5 != *(_DWORD *)(a1 + 1736))
          {
            v3 = MachTimeToSeconds((unint64_t)(v6 - *(double *)(a1 + 1744)));
            v4 = (double *)(a1 + 1656 + 8 * *(int *)(a1 + 1736));
            *v4 = *v4 + v3;
            result = v6;
            *(double *)(a1 + 1744) = v6;
            *(_DWORD *)(a1 + 1736) = v5;
          }
        }
      }
    }
  }
  return result;
}

uint64_t __os_log_helper_16_2_8_8_0_8_0_8_0_8_0_8_0_8_0_8_32_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 8;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 62) = 32;
  *(_BYTE *)(result + 63) = 8;
  *(_QWORD *)(result + 64) = a8;
  *(_BYTE *)(result + 72) = 0;
  *(_BYTE *)(result + 73) = 8;
  *(_QWORD *)(result + 74) = a9;
  return result;
}

uint64_t __os_log_helper_16_2_6_8_32_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 6;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  return result;
}

uint64_t __os_log_helper_16_2_21_8_0_8_0_8_0_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_32_8_0_8_32_8_0_8_32_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  uint64_t result;

  result = a12;
  *(_BYTE *)a1 = 2;
  *(_BYTE *)(a1 + 1) = 21;
  *(_BYTE *)(a1 + 2) = 0;
  *(_BYTE *)(a1 + 3) = 8;
  *(_QWORD *)(a1 + 4) = a2;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 13) = 8;
  *(_QWORD *)(a1 + 14) = a3;
  *(_BYTE *)(a1 + 22) = 0;
  *(_BYTE *)(a1 + 23) = 8;
  *(_QWORD *)(a1 + 24) = a4;
  *(_BYTE *)(a1 + 32) = 32;
  *(_BYTE *)(a1 + 33) = 8;
  *(_QWORD *)(a1 + 34) = a5;
  *(_BYTE *)(a1 + 42) = 0;
  *(_BYTE *)(a1 + 43) = 8;
  *(_QWORD *)(a1 + 44) = a6;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 8;
  *(_QWORD *)(a1 + 54) = a7;
  *(_BYTE *)(a1 + 62) = 0;
  *(_BYTE *)(a1 + 63) = 8;
  *(_QWORD *)(a1 + 64) = a8;
  *(_BYTE *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 73) = 8;
  *(_QWORD *)(a1 + 74) = a9;
  *(_BYTE *)(a1 + 82) = 0;
  *(_BYTE *)(a1 + 83) = 8;
  *(_QWORD *)(a1 + 84) = a10;
  *(_BYTE *)(a1 + 92) = 0;
  *(_BYTE *)(a1 + 93) = 8;
  *(_QWORD *)(a1 + 94) = a11;
  *(_BYTE *)(a1 + 102) = 32;
  *(_BYTE *)(a1 + 103) = 8;
  *(_QWORD *)(a1 + 104) = a12;
  *(_BYTE *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 113) = 8;
  *(_QWORD *)(a1 + 114) = a13;
  *(_BYTE *)(a1 + 122) = 32;
  *(_BYTE *)(a1 + 123) = 8;
  *(_QWORD *)(a1 + 124) = a14;
  *(_BYTE *)(a1 + 132) = 0;
  *(_BYTE *)(a1 + 133) = 8;
  *(_QWORD *)(a1 + 134) = a15;
  *(_BYTE *)(a1 + 142) = 32;
  *(_BYTE *)(a1 + 143) = 8;
  *(_QWORD *)(a1 + 144) = a16;
  *(_BYTE *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + 153) = 8;
  *(_QWORD *)(a1 + 154) = a17;
  *(_BYTE *)(a1 + 162) = 0;
  *(_BYTE *)(a1 + 163) = 8;
  *(_QWORD *)(a1 + 164) = a18;
  *(_BYTE *)(a1 + 172) = 0;
  *(_BYTE *)(a1 + 173) = 8;
  *(_QWORD *)(a1 + 174) = a19;
  *(_BYTE *)(a1 + 182) = 0;
  *(_BYTE *)(a1 + 183) = 8;
  *(_QWORD *)(a1 + 184) = a20;
  *(_BYTE *)(a1 + 192) = 0;
  *(_BYTE *)(a1 + 193) = 8;
  *(_QWORD *)(a1 + 194) = a21;
  *(_BYTE *)(a1 + 202) = 0;
  *(_BYTE *)(a1 + 203) = 8;
  *(_QWORD *)(a1 + 204) = a22;
  return result;
}

uint64_t CBU_IsSecureIndicatorSupported()
{
  if (CBU_IsSecureIndicatorSupported_onceToken != -1)
    dispatch_once(&CBU_IsSecureIndicatorSupported_onceToken, &__block_literal_global_56);
  return CBU_IsSecureIndicatorSupported_supported & 1;
}

float *_CFXPolygonFromStrength(_QWORD *a1, int a2, float a3)
{
  float v3;
  float v4;
  int i;
  float *v7;

  v7 = 0;
  if (a2 > 0 && *a1 && a1[1])
  {
    v7 = (float *)malloc_type_malloc(8 * a2, 0x100004000313F17uLL);
    if (a3 > 0.85)
    {
      v3 = (a3 - 0.85) / 0.15;
      v4 = 1.0 - v3;
      for (i = 0; i < a2; ++i)
      {
        v7[2 * i] = (float)(v4 * *(float *)(*a1 + 8 * i)) + (float)(v3 * *(float *)(a1[1] + 8 * i));
        v7[2 * i + 1] = (float)(v4 * *(float *)(*a1 + 8 * i + 4)) + (float)(v3 * *(float *)(a1[1] + 8 * i + 4));
      }
    }
    else
    {
      __memcpy_chk();
    }
  }
  return v7;
}

void AABC::HandleALSEvent(AABC *this, __IOHIDServiceClient *a2, __IOHIDEvent *a3)
{
  float v3;
  char *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  size_t v8;
  size_t v9;
  size_t v10;
  double v11;
  float v12;
  double v13;
  float v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  float **v21;
  AABC::ALS **v22;
  int v23;
  int v24;
  float *v25;
  float *v26;
  uint64_t v27;
  int v28;
  int v29;
  float v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  double v35;
  float v36;
  BOOL v37;
  BOOL v38;
  BOOL v39;
  char *v40;
  int v41;
  int v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  char *v48;
  double *v49;
  char *v50;
  char *v51;
  char *v52;
  char *v53;
  _BYTE v54[16];
  int v55;
  int updated;
  os_log_t v57;
  int v58;
  uint8_t *v59;
  uint64_t v60;
  NSObject *v61;
  os_log_t v62;
  os_log_t v63;
  int v64;
  uint8_t *v65;
  uint64_t v66;
  NSObject *v67;
  os_log_t v68;
  unint64_t v69;
  int v70;
  uint64_t v71;
  id v72;
  void *v73;
  id v74;
  void *v75;
  float DeviceBrightness;
  void *v77;
  id v78;
  void *v79;
  id v80;
  int BrightnessOverride;
  int v82;
  os_log_t v83;
  int v84;
  uint8_t *v85;
  uint64_t v86;
  NSObject *v87;
  os_log_t v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float LogicalBrightness;
  unsigned int v94;
  uint8_t *v95;
  os_log_t v96;
  int v97;
  uint64_t v98;
  char *v99;
  char *v100;
  int isTouchObstructed;
  uint64_t v102;
  NSObject *v103;
  os_log_t v104;
  int v105;
  _BOOL4 v106;
  int v107;
  id v108;
  _BOOL4 v109;
  float v110;
  float v111;
  int v112;
  os_log_t v113;
  int v114;
  uint8_t *v115;
  uint64_t v116;
  NSObject *v117;
  os_log_t v118;
  float v119;
  float v120;
  os_log_t v121;
  int v122;
  uint8_t *v123;
  uint64_t v124;
  NSObject *v125;
  os_log_t v126;
  uint64_t *v127;
  uint64_t *v128;
  os_log_t v129;
  int v130;
  uint8_t *v131;
  uint64_t v132;
  NSObject *v133;
  os_log_t v134;
  float v135;
  os_log_t v136;
  int v137;
  uint8_t *v138;
  uint64_t v139;
  NSObject *v140;
  os_log_t v141;
  float v142;
  os_log_t v143;
  int v144;
  uint8_t *v145;
  uint64_t v146;
  NSObject *v147;
  os_log_t v148;
  os_log_t v149;
  int v150;
  uint8_t *v151;
  uint64_t v152;
  NSObject *v153;
  os_log_t v154;
  os_log_t v155;
  int v156;
  uint8_t *v157;
  uint64_t v158;
  NSObject *v159;
  os_log_t v160;
  uint64_t *v161;
  os_log_t v162;
  int v163;
  uint8_t *v164;
  uint64_t v165;
  NSObject *v166;
  os_log_t v167;
  uint64_t *v168;
  float v169;
  float v170;
  int v171;
  os_log_t v172;
  int v173;
  uint8_t *v174;
  uint64_t v175;
  NSObject *v176;
  os_log_t v177;
  double Current;
  float v179;
  int v180;
  int v181;
  int v182;
  CBALSEvent *v183;
  CBALSEvent *v184;
  float VirtualBrightness;
  os_log_t v186;
  int v187;
  uint8_t *v188;
  uint64_t v189;
  NSObject *v190;
  os_log_t v191;
  os_log_t v192;
  int v193;
  uint8_t *v194;
  uint64_t v195;
  NSObject *v196;
  os_log_t v197;
  os_log_t v198;
  int v199;
  uint8_t *v200;
  uint64_t v201;
  NSObject *v202;
  os_log_t v203;
  float v204;
  uint64_t v205;
  double v206;
  double v207;
  AABC::ALS *v208;
  const void *Value;
  CFMutableDictionaryRef Mutable;
  uint64_t IntegerValue;
  double v212;
  double v213;
  unint64_t v214;
  uint64_t v215;
  unint64_t v216;
  uint64_t v217;
  const void **v218;
  const void **v219;
  uint64_t v220;
  CFIndex v221;
  CFIndex Count;
  os_log_t v223;
  int v224;
  uint8_t *v225;
  uint64_t v226;
  NSObject *v227;
  os_log_t v228;
  CFNumberRef v229;
  uint64_t v230;
  os_log_t v231;
  int v232;
  uint8_t *v233;
  uint64_t v234;
  NSObject *v235;
  os_log_t v236;
  os_log_t v237;
  int v238;
  uint8_t *v239;
  NSObject *v240;
  os_log_t v241;
  unint64_t v242;
  CBAODState *v243;
  os_log_t v244;
  int v245;
  uint8_t *v246;
  NSObject *v247;
  os_log_t v248;
  os_log_t v249;
  int v250;
  uint8_t *v251;
  NSObject *v252;
  os_log_t v253;
  uint64_t TimeStamp;
  os_log_t v255;
  int v256;
  uint8_t *v257;
  uint64_t inited;
  NSObject *v259;
  os_log_t v260;
  const char *v261;
  char *v262;
  float v263;
  unsigned __int8 v264;
  NSObject *v265;
  unsigned __int8 v266;
  NSObject *v267;
  char v268;
  int v269;
  unint64_t v270;
  uint64_t v271;
  id v272;
  float v273;
  id v274;
  char v275;
  float v276;
  char v277;
  unsigned __int8 v278;
  NSObject *v279;
  float v280;
  float v281;
  float v282;
  float v283;
  unsigned __int8 v284;
  NSObject *v285;
  unsigned __int8 v286;
  NSObject *v287;
  float v288;
  float v289;
  unsigned __int8 v290;
  NSObject *v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294[3];
  float v295;
  unsigned __int8 v296;
  NSObject *v297;
  float v298;
  unsigned __int8 v299;
  NSObject *v300;
  unsigned __int8 v301;
  NSObject *v302;
  unsigned __int8 v303;
  NSObject *v304;
  unsigned __int8 v305;
  NSObject *v306;
  _BYTE v307[15];
  unsigned __int8 v308;
  NSObject *v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312[3];
  float v313;
  int j;
  int v315;
  unsigned __int8 v316;
  NSObject *v317;
  double v318;
  float v319;
  char v320;
  id v321;
  CBALSEvent *v322;
  unsigned __int8 v323;
  NSObject *v324;
  float v325;
  unsigned __int8 v326;
  NSObject *v327;
  unsigned __int8 v328;
  NSObject *v329;
  double v330;
  const void *v331;
  float v332;
  double v333;
  int i;
  float v335;
  int v336;
  uint64_t v337;
  uint64_t v338;
  _BYTE *v339;
  unsigned int v340;
  os_log_type_t v341;
  os_log_t v342;
  CFNumberRef v343;
  double v344;
  os_log_type_t v345;
  os_log_t v346;
  uint8_t v347[15];
  unsigned __int8 v348;
  NSObject *v349;
  os_log_type_t v350;
  os_log_t v351;
  os_log_type_t v352;
  os_log_t v353;
  float v354;
  __CFDictionary *v355;
  float v356;
  float v357;
  AABC::ALS *v358;
  os_log_type_t v359;
  os_log_t v360;
  const void *v361;
  __IOHIDServiceClient *v362;
  AABC *v363;
  _BYTE v364[16];
  _BYTE v365[48];
  _BYTE v366[64];
  _BYTE v367[80];
  _BYTE v368[32];
  _BYTE v369[32];
  _BYTE v370[16];
  _BYTE v371[16];
  _BYTE v372[48];
  _BYTE v373[16];
  _BYTE v374[16];
  _BYTE v375[32];
  _BYTE v376[48];
  _BYTE v377[32];
  _BYTE v378[32];
  uint8_t v379[16];
  uint8_t v380[32];
  uint8_t v381[16];
  uint8_t v382[16];
  uint8_t v383[40];
  uint64_t v384;

  v261 = "HandleALSEvent";
  v384 = *MEMORY[0x1E0C80C00];
  v363 = this;
  v362 = a2;
  v361 = a3;
  v262 = (char *)this;
  v360 = 0;
  if (_logHandle)
  {
    v260 = (os_log_t)_logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
    {
      v259 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else
    {
      inited = init_default_corebrightness_log();
      v259 = inited;
    }
    v260 = v259;
  }
  v360 = v260;
  v359 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v260, OS_LOG_TYPE_DEBUG))
  {
    v255 = v360;
    v256 = v359;
    v257 = v383;
    __os_log_helper_16_0_3_4_0_8_0_8_0((uint64_t)v383, 4, (uint64_t)v362, (uint64_t)v361);
    _os_log_debug_impl(&dword_1B5291000, v360, v359, "[%x]: %p %p", v383, 0x1Cu);
  }
  v358 = 0;
  v356 = 0.0;
  v355 = 0;
  TimeStamp = IOHIDEventGetTimeStamp();
  v3 = (double)(unint64_t)TimeStamp * *(double *)&AABC::_sMachTimebaseFactor;
  v357 = v3;
  v354 = 0.0;
  if (*((float *)v262 + 168) < v3 || *((_DWORD *)v262 + 92))
  {
    if ((v262[505] & 1) != 0 && (v262[506] & 1) != 0)
    {
      v351 = 0;
      if (_logHandle)
      {
        v248 = (os_log_t)_logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v247 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v247 = init_default_corebrightness_log();
        v248 = v247;
      }
      v351 = v248;
      v350 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v248, OS_LOG_TYPE_DEBUG))
      {
        v244 = v351;
        v245 = v350;
        v246 = v381;
        __os_log_helper_16_0_1_4_0((uint64_t)v381, 4);
        _os_log_debug_impl(&dword_1B5291000, v351, v350, "[%x]: throwing away sample, preStrobe is in progress", v381, 8u);
      }
    }
    else
    {
      v243 = +[CBAODState sharedInstance](CBAODState, "sharedInstance");
      v242 = -[CBAODState AODState](v243, "AODState");
      if (AABC::ignoreALSEventsInAOD((uint64_t)v262, v242))
      {
        v349 = 0;
        if (_logHandle)
        {
          v241 = (os_log_t)_logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v240 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v240 = init_default_corebrightness_log();
          v241 = v240;
        }
        v349 = v241;
        v348 = 0;
        if (os_log_type_enabled(v241, OS_LOG_TYPE_DEFAULT))
        {
          v237 = v349;
          v238 = v348;
          v239 = v347;
          __os_log_helper_16_0_0(v347);
          _os_log_impl(&dword_1B5291000, v237, (os_log_type_t)v238, "Ongoing AOD transition IN/OUT -> Ignoring ALS Events!!", v347, 2u);
        }
      }
      else if (*((_DWORD *)v262 + 717) != 1 && *((_DWORD *)v262 + 717) != 2 && *((_DWORD *)v262 + 717) != 3)
      {
        if ((v262[444] & 1) == 0)
        {
          v4 = v262;
          v262[444] = 1;
          if (*((_QWORD *)v4 + 57))
          {
            if (*(_DWORD *)(*((_QWORD *)v262 + 57) + 8) == 8 || *(_DWORD *)(*((_QWORD *)v262 + 57) + 8) == 9)
            {
              v346 = 0;
              if (_logHandle)
              {
                v236 = (os_log_t)_logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v235 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  v234 = init_default_corebrightness_log();
                  v235 = v234;
                }
                v236 = v235;
              }
              v346 = v236;
              v345 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v236, OS_LOG_TYPE_DEFAULT))
              {
                v231 = v346;
                v232 = v345;
                *(double *)&v5 = *((float *)v262 + 852);
                v233 = v380;
                __os_log_helper_16_0_2_8_0_8_0((uint64_t)v380, v5, 0x3FE0000000000000);
                _os_log_impl(&dword_1B5291000, v346, v345, "AABC has received the first ALS sample since the initialization. ALS TIMEOUT will change: %fms -> %fms.", v380, 0x16u);
              }
              *((float *)v262 + 852) = 0.5;
            }
          }
        }
        if ((v262[443] & 1) == 0)
        {
          v230 = mach_absolute_time();
          v344 = (double)v230 * *(double *)&AABC::_sMachTimebaseFactor;
          v343 = 0;
          v229 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &v344);
          v343 = v229;
          if (v229)
          {
            if (*((_QWORD *)v262 + 48))
              CFDictionarySetValue(*((CFMutableDictionaryRef *)v262 + 48), CFSTR("EventTimestampFirstALSSample"), v343);
            v342 = 0;
            if (_logHandle)
            {
              v228 = (os_log_t)_logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
              {
                v227 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else
              {
                v226 = init_default_corebrightness_log();
                v227 = v226;
              }
              v228 = v227;
            }
            v342 = v228;
            v341 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v228, OS_LOG_TYPE_DEFAULT))
            {
              v223 = v342;
              v224 = v341;
              v225 = v379;
              __os_log_helper_16_0_1_8_0((uint64_t)v379, *(uint64_t *)&v344);
              _os_log_impl(&dword_1B5291000, v342, v341, "ts=%f kCBEventTimestampFirstALSSampleKey", v379, 0xCu);
            }
            CFRelease(v343);
          }
        }
        v6 = v262;
        v262[443] = 1;
        if (*((_DWORD *)v6 + 112) == 1)
          v262[440] = 1;
        if ((v262[440] & 1) == 0 && *((_QWORD *)v262 + 54))
        {
          CFDictionarySetValue(*((CFMutableDictionaryRef *)v262 + 54), v362, v361);
          v340 = 0;
          Count = CFDictionaryGetCount(*((CFDictionaryRef *)v262 + 54));
          v340 = Count;
          v220 = (int)Count;
          v221 = CFDictionaryGetCount(*((CFDictionaryRef *)v262 + 53));
          if ((int)Count == v221)
            v262[440] = 1;
          v339 = v54;
          v214 = (8 * v340 + 15) & 0xFFFFFFFFFFFFFFF0;
          MEMORY[0x1E0C80A78]();
          v218 = (const void **)&v54[-v214];
          v338 = v7;
          v215 = 512;
          if ((unint64_t)(8 * v7) <= 0x200)
            v8 = 8 * v7;
          else
            v8 = 512;
          bzero(&v54[-v214], v8);
          v217 = v340;
          v216 = (8 * v340 + 15) & 0xFFFFFFFFFFFFFFF0;
          MEMORY[0x1E0C80A78]();
          v219 = (const void **)&v54[-v216];
          v337 = v217;
          if ((unint64_t)(8 * v217) <= 0x200)
            v10 = 8 * v217;
          else
            v10 = v9;
          bzero(&v54[-v216], v10);
          CFDictionaryGetKeysAndValues(*((CFDictionaryRef *)v262 + 54), v218, v219);
          v336 = -1;
          v335 = -1.0;
          for (i = 0; i < (int)v340; ++i)
          {
            if (v219[i])
            {
              v333 = 0.0;
              if ((v262[3936] & 1) != 0)
              {
                IOHIDEventGetDoubleValue();
                v213 = v11;
                v212 = v11;
              }
              else
              {
                IntegerValue = IOHIDEventGetIntegerValue();
                v212 = (double)IntegerValue;
              }
              v333 = v212;
              v12 = v212;
              v332 = v12;
              if (v12 > v335)
              {
                v335 = v332;
                v336 = i;
              }
            }
          }
          if (v336 >= 0)
          {
            v361 = v219[v336];
            Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], 0);
            v355 = Mutable;
            v331 = 0;
            Value = CFDictionaryGetValue(*((CFDictionaryRef *)v262 + 53), v218[v336]);
            v331 = Value;
            if (v355)
            {
              if (v331)
                CFDictionaryAddValue(v355, v218[v336], v331);
            }
          }
        }
        if ((v262[440] & 1) != 0)
          v262[441] = 0;
        v208 = (AABC::ALS *)CFDictionaryGetValue(*((CFDictionaryRef *)v262 + 53), v362);
        v358 = v208;
        if ((v262[445] & 1) != 0)
          AABC::lazyLoadIntegrationTimes((AABC *)v262, v362, v358);
        v354 = *((float *)v358 + 38);
        v330 = 0.0;
        if ((v262[3936] & 1) != 0)
        {
          IOHIDEventGetDoubleValue();
          v207 = v13;
          v206 = v13;
        }
        else
        {
          v205 = IOHIDEventGetIntegerValue();
          v206 = (double)v205;
        }
        v330 = v206;
        if ((*((_BYTE *)v358 + 68) & 1) != 0)
        {
          v204 = *((float *)v358 + 16);
        }
        else
        {
          v14 = v330;
          v204 = v14;
        }
        v356 = v204;
        v329 = 0;
        if (_logHandle)
        {
          v203 = (os_log_t)_logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
          {
            v202 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else
          {
            v201 = init_default_corebrightness_log();
            v202 = v201;
          }
          v203 = v202;
        }
        v329 = v203;
        v328 = 2;
        if (os_log_type_enabled(v203, OS_LOG_TYPE_DEBUG))
        {
          v198 = v329;
          v199 = v328;
          if ((*((_BYTE *)v358 + 68) & 1) != 0)
            v15 = "(override)";
          else
            v15 = "";
          v200 = v378;
          __os_log_helper_16_2_3_4_0_8_0_8_32((uint64_t)v378, 16, COERCE__INT64(v356), (uint64_t)v15);
          _os_log_debug_impl(&dword_1B5291000, v198, (os_log_type_t)v199, "[%x]: %0.4f %s", v200, 0x1Cu);
        }
        if ((v262[440] & 1) != 0 || (v262[442] & 1) != 0 || (v262[441] & 1) != 0)
          AABC::CancelFirstSampleTimeout((dispatch_object_t *)v262);
        *((float *)v358 + 15) = v356;
        v327 = 0;
        if (_logHandle)
        {
          v197 = (os_log_t)_logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
          {
            v196 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else
          {
            v195 = init_default_corebrightness_log();
            v196 = v195;
          }
          v197 = v196;
        }
        v327 = v197;
        v326 = 2;
        if (os_log_type_enabled(v197, OS_LOG_TYPE_DEBUG))
        {
          v192 = v327;
          v193 = v326;
          *(double *)&v16 = *((float *)v358 + 15);
          v194 = v377;
          __os_log_helper_16_0_2_4_0_8_0((uint64_t)v377, 16, v16);
          _os_log_debug_impl(&dword_1B5291000, v192, (os_log_type_t)v193, "[%x]: als->_Esensor_device=%0.4f", v194, 0x12u);
        }
        v325 = 0.0;
        if (*((_QWORD *)v262 + 60)
          && *((_DWORD *)v262 + 987) == 2
          && (float)(v357 - *((float *)v262 + 986)) > *((float *)v262 + 985))
        {
          v324 = 0;
          if (_logHandle)
          {
            v191 = (os_log_t)_logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
            {
              v190 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else
            {
              v189 = init_default_corebrightness_log();
              v190 = v189;
            }
            v191 = v190;
          }
          v324 = v191;
          v323 = 2;
          if (os_log_type_enabled(v191, OS_LOG_TYPE_DEBUG))
          {
            v186 = v324;
            v187 = v323;
            *(double *)&v17 = *((float *)v262 + 986);
            *(double *)&v18 = (float)(v357 - *((float *)v262 + 986));
            *(double *)&v19 = *((float *)v262 + 985);
            v188 = v376;
            __os_log_helper_16_0_5_4_0_8_0_8_0_8_0_8_0((uint64_t)v376, 64, COERCE__INT64(v357), v17, v18, v19);
            _os_log_debug_impl(&dword_1B5291000, v186, (os_log_type_t)v187, "[%x]: setting _proxState = kProxNone (timestamp=%f _proxReleaseTime=%f delta=%f _proxTriggerDelay=%f)", v188, 0x30u);
          }
          v20 = v262;
          *((_DWORD *)v262 + 987) = 0;
          if ((v20[3937] & 1) != 0)
          {
            v21 = (float **)v262;
            v262[4160] = 1;
            VirtualBrightness = DisplayGetVirtualBrightness(v21[51]);
            *((float *)v262 + 154) = VirtualBrightness;
          }
        }
        if (*((_QWORD *)v358 + 3))
        {
          v322 = 0;
          v184 = [CBALSEvent alloc];
          v183 = -[CBALSEvent initWithHIDEvent:andNode:](v184, "initWithHIDEvent:andNode:", v361, *((_QWORD *)v358 + 4));
          v322 = v183;
          v321 = 0;
          v321 = (id)*((_QWORD *)v358 + 3);
          v320 = 0;
          v182 = objc_msgSend(v321, "isObstructed");
          v320 = v182 & 1;
          objc_msgSend(v321, "filterEvent:", v322);
          v181 = objc_msgSend(v321, "isActive");
          if ((v181 & 1) != 0)
          {
            v180 = objc_msgSend(v321, "isObstructed");
            if ((v180 & 1) == 0 && (v320 & 1) != 0)
            {
              v22 = (AABC::ALS **)v262;
              v262[4160] = 1;
              if (v358 == v22[57])
              {
                v179 = DisplayGetVirtualBrightness(*((float **)v262 + 51));
                *((float *)v262 + 154) = v179;
              }
            }
          }

        }
        v319 = v356;
        v318 = 0.0;
        Current = CFAbsoluteTimeGetCurrent();
        v318 = Current;
        if (*((_DWORD *)v262 + 169) && v318 > *((double *)v262 + 86))
        {
          AABC::CancelFastRampMode((CFAbsoluteTime *)v262);
          v262[3320] = 1;
        }
        v319 = fmaxf(v319, *((float *)v358 + 13));
        if ((v262[3368] & 1) != 0
          && *((_DWORD *)v262 + 832)
          && *((_DWORD *)v262 + 832) < *((_DWORD *)v262 + 843)
          && !*((_DWORD *)v262 + 840)
          && v318 > *(double *)&v262[8 * (*((_DWORD *)v262 + 832) - 1) + 3336] + *((double *)v262 + 424)
          && (v262[3400] & 1) != 0)
        {
          AABC::writeOutlierRemovalPreferences((uint64_t)v262, 1);
          *((_DWORD *)v262 + 832) = *((_DWORD *)v262 + 843);
        }
        if ((v262[440] & 1) != 0 || (v262[442] & 1) != 0 || (v262[441] & 1) != 0)
          ++*((_DWORD *)v262 + 150);
        v317 = 0;
        if (_logHandle)
        {
          v177 = (os_log_t)_logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
          {
            v176 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else
          {
            v175 = init_default_corebrightness_log();
            v176 = v175;
          }
          v177 = v176;
        }
        v317 = v177;
        v316 = 2;
        if (os_log_type_enabled(v177, OS_LOG_TYPE_DEBUG))
        {
          v172 = v317;
          v173 = v316;
          v23 = *((_DWORD *)v262 + 864);
          v24 = *((_DWORD *)v358 + 20);
          v174 = v375;
          __os_log_helper_16_0_3_4_0_4_0_4_0((uint64_t)v375, 2, v23, v24);
          _os_log_debug_impl(&dword_1B5291000, v172, (os_log_type_t)v173, "[%x]: _luxFilter=%x als->_Ehistory_max=%d", v174, 0x14u);
        }
        if (*((_DWORD *)v262 + 864))
        {
          v315 = 0;
          if (*((float *)v358 + 38) <= 0.01)
          {
            v315 = 1;
          }
          else
          {
            v315 = (int)std::__math::round[abi:ne180100](v354 / *((float *)v358 + 38));
            if (v315 <= 0)
              v171 = 1;
            else
              v171 = v315;
            v315 = v171;
          }
          if ((v262[264] & 1) != 0)
            v319 = AABC::calculateMovingAverage((AABC *)v262, v319);
          for (j = 0; j < v315; ++j)
          {
            if (*((_DWORD *)v358 + 20))
            {
              v170 = v319;
              v25 = (float *)std::vector<float>::operator[][abi:ne180100]((_QWORD *)v358 + 11, *((unsigned int *)v358 + 18));
              *v25 = v170;
              *((_DWORD *)v358 + 18) = (*((_DWORD *)v358 + 18) + 1) % *((_DWORD *)v358 + 20);
              if (*((_DWORD *)v358 + 19) < *((_DWORD *)v358 + 20))
                ++*((_DWORD *)v358 + 19);
            }
          }
          if ((v262[136] & 1) != 0 && *((_DWORD *)v262 + 720) == 1)
          {
            if (!*((_DWORD *)v358 + 30))
            {
              *((_DWORD *)v358 + 30) = 5;
              std::vector<float>::resize((uint64_t *)v358 + 16, *((unsigned int *)v358 + 30));
            }
            v169 = v319;
            v26 = (float *)std::vector<float>::operator[][abi:ne180100]((_QWORD *)v358 + 16, *((unsigned int *)v358 + 28));
            *v26 = v169;
            *((_DWORD *)v358 + 28) = (*((_DWORD *)v358 + 28) + 1) % *((_DWORD *)v358 + 30);
            if (*((_DWORD *)v358 + 29) < *((_DWORD *)v358 + 30))
              ++*((_DWORD *)v358 + 29);
          }
          if ((v262[160] & 1) != 0)
            AABC::addToFilter((AABC *)v262, (AABC::ALSFilter *)(v262 + 168), v319);
        }
        if (*((_DWORD *)v262 + 864) == 3)
        {
          v313 = v319;
          if (std::vector<float>::size[abi:ne180100]((_QWORD *)v358 + 11))
          {
            if (*((_DWORD *)v358 + 19) >= 2u)
            {
              std::vector<float>::vector(v312, (uint64_t *)v358 + 11);
              v168 = v312;
              v311 = std::vector<float>::begin[abi:ne180100](v312);
              v310 = std::vector<float>::end[abi:ne180100]((uint64_t)v168);
              std::sort[abi:ne180100]<std::__wrap_iter<float *>>(v311, v310);
              if (std::vector<float>::size[abi:ne180100]((_QWORD *)v358 + 11) == 2)
              {
                v313 = *(float *)std::vector<float>::operator[][abi:ne180100](v312, 0);
                v309 = 0;
                if (_logHandle)
                {
                  v167 = (os_log_t)_logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT)
                  {
                    v166 = _COREBRIGHTNESS_LOG_DEFAULT;
                  }
                  else
                  {
                    v165 = init_default_corebrightness_log();
                    v166 = v165;
                  }
                  v167 = v166;
                }
                v309 = v167;
                v308 = 2;
                if (os_log_type_enabled(v167, OS_LOG_TYPE_DEBUG))
                {
                  v162 = v309;
                  v163 = v308;
                  v164 = v307;
                  __os_log_helper_16_0_0(v307);
                  _os_log_debug_impl(&dword_1B5291000, v162, (os_log_type_t)v163, "Median filter computed on 2 samples - defaulting to minimum", v164, 2u);
                }
              }
              else
              {
                v161 = v312;
                v27 = std::vector<float>::size[abi:ne180100](v312);
                v313 = *(float *)std::vector<float>::operator[][abi:ne180100](v161, v27 - (*((_DWORD *)v358 + 19) + 1) / 2u);
                v306 = 0;
                if (_logHandle)
                {
                  v160 = (os_log_t)_logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT)
                  {
                    v159 = _COREBRIGHTNESS_LOG_DEFAULT;
                  }
                  else
                  {
                    v158 = init_default_corebrightness_log();
                    v159 = v158;
                  }
                  v160 = v159;
                }
                v306 = v160;
                v305 = 2;
                if (os_log_type_enabled(v160, OS_LOG_TYPE_DEBUG))
                {
                  v155 = v306;
                  v156 = v305;
                  v28 = *((_DWORD *)v358 + 19);
                  v157 = v374;
                  __os_log_helper_16_0_2_4_0_4_0((uint64_t)v374, 16, v28);
                  _os_log_debug_impl(&dword_1B5291000, v155, (os_log_type_t)v156, "[%x]: Median filter computed on %d samples", v157, 0xEu);
                }
                v304 = 0;
                if (_logHandle)
                {
                  v154 = (os_log_t)_logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT)
                  {
                    v153 = _COREBRIGHTNESS_LOG_DEFAULT;
                  }
                  else
                  {
                    v152 = init_default_corebrightness_log();
                    v153 = v152;
                  }
                  v154 = v153;
                }
                v304 = v154;
                v303 = 2;
                if (os_log_type_enabled(v154, OS_LOG_TYPE_DEBUG))
                {
                  v149 = v304;
                  v150 = v303;
                  v29 = *((_DWORD *)v358 + 19);
                  v151 = v373;
                  __os_log_helper_16_0_1_4_0((uint64_t)v373, v29);
                  _os_log_debug_impl(&dword_1B5291000, v149, (os_log_type_t)v150, "Median filter computed on %d samples", v151, 8u);
                }
              }
              std::vector<float>::~vector[abi:ne180100](v312);
            }
            if (*((_DWORD *)v262 + 169) && (v262[3460] & 1) == 0)
              *((float *)v358 + 39) = v313;
            else
              *((float *)v358 + 39) = v313;
          }
          else
          {
            *((float *)v358 + 39) = v319;
          }
          v302 = 0;
          if (_logHandle)
          {
            v148 = (os_log_t)_logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
            {
              v147 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else
            {
              v146 = init_default_corebrightness_log();
              v147 = v146;
            }
            v148 = v147;
          }
          v302 = v148;
          v301 = 2;
          if (os_log_type_enabled(v148, OS_LOG_TYPE_DEBUG))
          {
            v143 = v302;
            v144 = v301;
            v145 = v372;
            __os_log_helper_16_0_4_4_0_8_0_8_0_8_0((uint64_t)v372, 16, COERCE__INT64(v357), COERCE__INT64(v319), COERCE__INT64(v313));
            _os_log_debug_impl(&dword_1B5291000, v143, (os_log_type_t)v144, "[%x]: ts=%f Esensor=%f Emedian=%f", v145, 0x26u);
          }
          if ((v262[160] & 1) != 0)
          {
            v142 = AABC::calculate95thPercentile((AABC *)v262, (AABC::ALSFilter *)(v262 + 168));
            v30 = v142 * 1.25;
            *((float *)v358 + 39) = v30;
            v300 = 0;
            if (_logHandle)
            {
              v141 = (os_log_t)_logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
              {
                v140 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else
              {
                v139 = init_default_corebrightness_log();
                v140 = v139;
              }
              v141 = v140;
            }
            v300 = v141;
            v299 = 0;
            if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
            {
              v136 = v300;
              v137 = v299;
              *(double *)&v31 = *((float *)v358 + 39);
              v138 = v371;
              __os_log_helper_16_0_1_8_0((uint64_t)v371, v31);
              _os_log_impl(&dword_1B5291000, v136, (os_log_type_t)v137, "Scaled 95th percentile lux value: %f, scale factor:1.25", v138, 0xCu);
            }
          }
          if ((v262[161] & 1) != 0)
          {
            AABC::addToFilter((AABC *)v262, (AABC::ALSFilter *)(v262 + 216), *((float *)v358 + 39));
            v298 = 0.0;
            v135 = AABC::calculate95thPercentile((AABC *)v262, (AABC::ALSFilter *)(v262 + 216));
            v298 = v135;
            if (v135 >= 100.0)
            {
              *((float *)v358 + 39) = fmaxf(*((float *)v358 + 39), 100.0);
            }
            else
            {
              *((float *)v358 + 39) = v298;
              v297 = 0;
              if (_logHandle)
              {
                v134 = (os_log_t)_logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v133 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  v132 = init_default_corebrightness_log();
                  v133 = v132;
                }
                v134 = v133;
              }
              v297 = v134;
              v296 = 2;
              if (os_log_type_enabled(v134, OS_LOG_TYPE_DEBUG))
              {
                v129 = v297;
                v130 = v296;
                *(double *)&v32 = *((float *)v358 + 39);
                v131 = v370;
                __os_log_helper_16_0_1_8_0((uint64_t)v370, v32);
                _os_log_debug_impl(&dword_1B5291000, v129, (os_log_type_t)v130, "Aliasing Mitigation: using 95th percentile lux value: %f", v131, 0xCu);
              }
            }
          }
        }
        else if (*((_DWORD *)v262 + 864) == 2)
        {
          v295 = v319;
          if (std::vector<float>::size[abi:ne180100]((_QWORD *)v358 + 16) && *((_DWORD *)v358 + 29) >= 2u)
          {
            std::vector<float>::vector(v294, (uint64_t *)v358 + 16);
            v128 = v294;
            v293 = std::vector<float>::begin[abi:ne180100](v294);
            v292 = std::vector<float>::end[abi:ne180100]((uint64_t)v128);
            std::sort[abi:ne180100]<std::__wrap_iter<float *>>(v293, v292);
            v127 = v294;
            v33 = std::vector<float>::size[abi:ne180100](v294);
            v295 = *(float *)std::vector<float>::operator[][abi:ne180100](v127, v33 - (*((_DWORD *)v358 + 29) + 1) / 2u);
            v291 = 0;
            if (_logHandle)
            {
              v126 = (os_log_t)_logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
              {
                v125 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else
              {
                v124 = init_default_corebrightness_log();
                v125 = v124;
              }
              v126 = v125;
            }
            v291 = v126;
            v290 = 2;
            if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
            {
              v121 = v291;
              v122 = v290;
              v34 = *((_DWORD *)v358 + 29);
              v123 = v369;
              __os_log_helper_16_2_3_4_0_8_32_4_0((uint64_t)v369, 16, (uint64_t)v261, v34);
              _os_log_debug_impl(&dword_1B5291000, v121, (os_log_type_t)v122, "[%x]: %s: Accessory filter computed on %d samples", v123, 0x18u);
            }
            std::vector<float>::~vector[abi:ne180100](v294);
          }
          v289 = 0.0;
          if (*((float *)v358 + 31) <= -1.0)
            v120 = 0.0;
          else
            v120 = vabds_f32(*((float *)v358 + 31), v319);
          v289 = v120;
          v288 = 0.0;
          if (v295 <= 0.0)
            v119 = 2.0;
          else
            v119 = vabds_f32(v295, v319) / v295;
          v288 = v119;
          if (*((float *)v358 + 31) == -1.0)
          {
            *((float *)v358 + 39) = v319;
            *((float *)v358 + 31) = v319;
          }
          else if (v288 < 1.0 && v289 > *((float *)v262 + 35) || v319 == 0.0)
          {
            *((float *)v358 + 39) = v319;
            *((float *)v358 + 31) = v319;
          }
          else
          {
            *((_DWORD *)v358 + 39) = *((_DWORD *)v358 + 31);
          }
        }
        else
        {
          v287 = 0;
          if (_logHandle)
          {
            v118 = (os_log_t)_logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
            {
              v117 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else
            {
              v116 = init_default_corebrightness_log();
              v117 = v116;
            }
            v118 = v117;
          }
          v287 = v118;
          v286 = 2;
          if (os_log_type_enabled(v118, OS_LOG_TYPE_DEBUG))
          {
            v113 = v287;
            v114 = v286;
            v115 = v368;
            __os_log_helper_16_0_3_4_0_8_0_8_0((uint64_t)v368, 16, COERCE__INT64(v357), COERCE__INT64(v319));
            _os_log_debug_impl(&dword_1B5291000, v113, (os_log_type_t)v114, "[%x]: ts=%f Esensor=%f", v115, 0x1Cu);
          }
          *((float *)v358 + 39) = v319;
        }
        if ((v262[440] & 1) != 0 || (v262[442] & 1) != 0 || (v262[441] & 1) != 0)
        {
          *((_DWORD *)v262 + 134) = 0;
          if (v355)
            CFDictionaryApplyFunction(v355, (CFDictionaryApplierFunction)AABC::UpdateAggregateFunction, v262);
          else
            CFDictionaryApplyFunction(*((CFDictionaryRef *)v262 + 53), (CFDictionaryApplierFunction)AABC::UpdateAggregateFunction, v262);
          AABC::_ReportEsensorAggregated((AABC *)v262);
          v110 = *((float *)v262 + 136);
          v35 = -1.0;
          if (*((_DWORD *)v262 + 150) <= 1u)
            v35 = 0.1;
          v36 = v35;
          v111 = v36;
          v37 = *((_DWORD *)v262 + 150) <= 1u;
          v112 = 1;
          if (!v37)
            v112 = v262[4160];
          AABC::_UpdateNitsRestrictions((AABC *)v262, v110, v111, v112 & 1);
          v108 = (id)*((_QWORD *)v262 + 491);
          v38 = *((_QWORD *)v262 + 60) == 0;
          v109 = 0;
          if (!v38)
            v109 = *((_DWORD *)v262 + 987) != 0;
          v106 = v109;
          v39 = *(_QWORD *)(*((_QWORD *)v262 + 57) + 24) == 0;
          v107 = 0;
          if (!v39)
          {
            v105 = objc_msgSend(*(id *)(*((_QWORD *)v262 + 57) + 24), "isObstructedIgnoreActive");
            v107 = v105;
          }
          objc_msgSend(v108, "recordOcclusionByProx:andByTouch:", v106, v107 & 1);
          v285 = 0;
          if (_logHandle)
          {
            v104 = (os_log_t)_logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
            {
              v103 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else
            {
              v102 = init_default_corebrightness_log();
              v103 = v102;
            }
            v104 = v103;
          }
          v285 = v104;
          v284 = 2;
          if (os_log_type_enabled(v104, OS_LOG_TYPE_DEBUG))
          {
            v96 = v285;
            v97 = v284;
            *(double *)&v98 = *((float *)v262 + 136);
            v99 = (&kAABStateStr)[*((unsigned int *)v262 + 92)];
            v100 = (&kProxStateStr)[*((unsigned int *)v262 + 987)];
            isTouchObstructed = AABC::ALS::isTouchObstructed(*((id **)v262 + 57));
            v40 = (&kDimPolicyStr)[*((unsigned int *)v262 + 859)];
            v41 = *((_DWORD *)v262 + 859);
            v53 = (&kOrientationString)[*((unsigned int *)v262 + 176)];
            v95 = v367;
            __os_log_helper_16_2_8_4_0_8_0_8_32_8_32_4_0_8_32_4_0_8_32((uint64_t)v367, 16, v98, (uint64_t)v99, (uint64_t)v100, isTouchObstructed & 1, (uint64_t)v40, v41, (uint64_t)v53);
            _os_log_debug_impl(&dword_1B5291000, v96, (os_log_type_t)v97, "[%x]: _Esensor_trusted=%f _state=%s _proxState=%s _touchIsObstucted=%d _settings._internal._dimPolicy=%s %d _orientation=%s", v95, 0x46u);
          }
          if (*((float *)v262 + 123) == 0.0 || *((float *)v262 + 123) == 1.0)
          {
            v94 = *((_DWORD *)v262 + 92);
            if (v94 > 1 && (v94 == 3 || v94 == 2))
            {
              v283 = 0.0;
              v282 = 0.0;
              if (*((_DWORD *)v262 + 130))
              {
                LogicalBrightness = DisplayGetLogicalBrightness(*((_QWORD *)v262 + 51));
                v283 = LogicalBrightness;
                if ((v262[3417] & 1) != 0)
                {
                  v281 = 0.0;
                  v92 = AABC::IlluminanceToLuminance((uint64_t)v262, (float *)v262 + 802, *((float *)v262 + 136), *((float *)v262 + 139));
                  v281 = v92;
                  if ((v262[3418] & 1) == 0)
                    v283 = fminf(*((float *)v262 + 855), v281);
                }
                v91 = AABC::IlluminanceToLuminance((uint64_t)v262, (float *)v262 + 262, *((float *)v262 + 136), *((float *)v262 + 139));
                v282 = v91;
              }
              else
              {
                v90 = AABC::IlluminanceToLuminance((uint64_t)v262, (float *)v262 + 262, *((float *)v262 + 136), *((float *)v262 + 139));
                v283 = v90;
                if ((v262[3417] & 1) != 0)
                {
                  v280 = 0.0;
                  v89 = AABC::IlluminanceToLuminance((uint64_t)v262, (float *)v262 + 802, *((float *)v262 + 136), *((float *)v262 + 139));
                  v280 = v89;
                  v283 = fminf(v283, v89);
                  if ((v262[3418] & 1) == 0)
                    v283 = fminf(*((float *)v262 + 855), v280);
                }
              }
              v283 = fmaxf(v283, *((float *)v262 + 180));
              v283 = fminf(v283, *((float *)v262 + 182));
              if (*((_DWORD *)v262 + 130))
              {
                v282 = fmaxf(v282, *((float *)v262 + 180));
                v282 = fminf(v282, *((float *)v262 + 182));
                DisplaySetABBrightnessForPowerReport(*((_QWORD *)v262 + 51), 1, v282);
              }
              else
              {
                DisplaySetABBrightnessForPowerReport(*((_QWORD *)v262 + 51), 0, v283);
              }
              v325 = AABC::IlluminanceToReflectivity((AABC *)v262, *((float *)v262 + 139));
              v279 = 0;
              if (_logHandle)
              {
                v88 = (os_log_t)_logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v87 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  v86 = init_default_corebrightness_log();
                  v87 = v86;
                }
                v88 = v87;
              }
              v279 = v88;
              v278 = 2;
              if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
              {
                v83 = v279;
                v84 = v278;
                v43 = *(_DWORD *)v358;
                v44 = *((_DWORD *)v358 + 1);
                *(double *)&v45 = *((float *)v358 + 39);
                *(double *)&v46 = *((float *)v262 + 136);
                v85 = v366;
                __os_log_helper_16_0_7_4_0_4_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v366, v43, v44, COERCE__INT64(v356), v45, v46, COERCE__INT64(v283), COERCE__INT64(v325));
                _os_log_debug_impl(&dword_1B5291000, v83, (os_log_type_t)v84, "[%02x/%02x] Esensor_device: %0.2f als->_Esensor_filtered: %0.2f _Esensor_trusted: %0.2f  L: %0.4f L_reflected: %0.4f", v85, 0x40u);
              }
              v277 = 0;
              if (!*((_DWORD *)v262 + 719) || (v47 = v262[136], v82 = 1, (v47 & 1) == 0))
                v82 = v262[136] ^ 1;
              v277 = v82 & 1;
              if ((v82 & 1) != 0)
              {
                v276 = 0.0;
                v275 = 0;
                BrightnessOverride = DisplayGetBrightnessOverride(*((_QWORD *)v262 + 51), &v276);
                v275 = BrightnessOverride & 1;
                if ((BrightnessOverride & 1) != 0)
                {
                  v80 = (id)objc_msgSend(*((id *)v262 + 490), "LLPM");
                  objc_msgSend(v80, "pushNumberWeighted:withWeight:", v276, *((float *)v262 + 158));
                }
                else
                {
                  v274 = 0;
                  if (*((_DWORD *)v262 + 130))
                  {
                    v79 = (void *)objc_msgSend(*((id *)v262 + 490), "LOff");
                    v78 = v79;
                  }
                  else
                  {
                    v77 = (void *)objc_msgSend(*((id *)v262 + 490), "L");
                    v78 = v77;
                  }
                  v274 = v78;
                  objc_msgSend(v78, "pushNumberWeighted:withWeight:", v283, *((float *)v262 + 158));
                }
              }
              else
              {
                v273 = 0.0;
                DeviceBrightness = DisplayGetDeviceBrightness(*((_QWORD *)v262 + 51));
                v273 = DeviceBrightness;
                v272 = 0;
                if (*((_DWORD *)v262 + 130))
                {
                  v75 = (void *)objc_msgSend(*((id *)v262 + 490), "LDeviceOff");
                  v74 = v75;
                }
                else
                {
                  v73 = (void *)objc_msgSend(*((id *)v262 + 490), "LDevice");
                  v74 = v73;
                }
                v272 = v74;
                objc_msgSend(v74, "pushNumberWeighted:withWeight:", v273, *((float *)v262 + 158));
              }
              v72 = (id)objc_msgSend(*((id *)v262 + 490), "E");
              objc_msgSend(v72, "pushNumberWeighted:withWeight:", v356, *((float *)v262 + 158));
              if (*((int *)v262 + 926) >= 0)
              {
                v271 = 0;
                v71 = mach_absolute_time();
                v48 = v262;
                v271 = v71;
                v270 = 0;
                v270 = v71 - *((_QWORD *)v262 + 485);
                v49 = (double *)&v262[8 * *((int *)v262 + 926) + 3808];
                *v49 = *v49 + (double)v270 * *(double *)&AABC::_sMachTimebaseFactor;
                *((_QWORD *)v48 + 485) = v271;
              }
              v269 = 2;
              v70 = AABC::ALS::isTouchObstructed(*((id **)v262 + 57));
              if ((v70 & 1) != 0)
                v269 = *((_QWORD *)v262 + 60) == 0;
              v69 = *((unsigned int *)v262 + 859);
              if (v69 <= 7)
                __asm { BR              X8 }
              v268 = 0;
              v267 = 0;
              if (_logHandle)
              {
                v68 = (os_log_t)_logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v67 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  v66 = init_default_corebrightness_log();
                  v67 = v66;
                }
                v68 = v67;
              }
              v267 = v68;
              v266 = 2;
              if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
              {
                v63 = v267;
                v64 = v266;
                v50 = (&kDimRestrictionStr)[v269];
                v65 = v365;
                __os_log_helper_16_2_2_4_0_8_32((uint64_t)v365, 16, (uint64_t)v50);
                _os_log_debug_impl(&dword_1B5291000, v63, (os_log_type_t)v64, "[%x]: dimRestriction=%s", v65, 0x12u);
              }
              DisplaySetCurrentAmbient(*((_QWORD *)v262 + 51), *((float *)v262 + 136));
              if (*((float *)v262 + 124) > 0.0)
              {
                if (*((_DWORD *)v262 + 150) == 1)
                {
                  v265 = 0;
                  if (_logHandle)
                  {
                    v62 = (os_log_t)_logHandle;
                  }
                  else
                  {
                    if (_COREBRIGHTNESS_LOG_DEFAULT)
                    {
                      v61 = _COREBRIGHTNESS_LOG_DEFAULT;
                    }
                    else
                    {
                      v60 = init_default_corebrightness_log();
                      v61 = v60;
                    }
                    v62 = v61;
                  }
                  v265 = v62;
                  v264 = 2;
                  if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
                  {
                    v57 = v265;
                    v58 = v264;
                    v59 = v364;
                    __os_log_helper_16_0_1_8_0((uint64_t)v364, COERCE__INT64(v283));
                    _os_log_debug_impl(&dword_1B5291000, v57, (os_log_type_t)v58, "Display on L=%0.4f", v59, 0xCu);
                  }
                  updated = AABC::UpdateDisplayBrightness_Block6((uint64_t)v262, 0, 2, 0, v283);
                  v268 = updated & 1;
                }
                else
                {
                  v55 = AABC::UpdateDisplayBrightness_Block6((uint64_t)v262, 1, v269, 0, v283);
                  v268 = v55 & 1;
                }
                if ((v268 & 1) != 0)
                  IOHIDEventSetIntegerValue();
              }
            }
          }
          if (*((float *)v262 + 124) > 0.0
            && *((float *)v262 + 87) != v325
            && std::__math::fabs[abi:ne180100](1.0 - (float)(v325 / *((float *)v262 + 87))) > 0.1)
          {
            v263 = 0.0;
            if (v325 <= *((float *)v262 + 87))
              v263 = 45.0;
            else
              v263 = 3.0;
            DisplaySetReflectedBrightnessWithFade(*((_QWORD *)v262 + 51), 0, 0, v325, v263);
            *((float *)v262 + 87) = v325;
          }
          if (*((_DWORD *)v262 + 150) == 1 && *((_DWORD *)v262 + 167) == 1)
          {
            if (*((_DWORD *)v262 + 92) == 3)
            {
              v51 = v262;
              *((_DWORD *)v262 + 158) = *((_DWORD *)v358 + 12);
              *((_DWORD *)v51 + 167) = 3;
            }
            else if (*((_DWORD *)v262 + 92) == 2)
            {
              v52 = v262;
              *((_DWORD *)v262 + 158) = *((_DWORD *)v358 + 11);
              *((_DWORD *)v52 + 167) = 2;
            }
            if (*((_DWORD *)v262 + 160) && *((float *)v262 + 158) < 0.05)
              *((_DWORD *)v262 + 158) = 1045220557;
            AABC::UpdateALSState((CFDictionaryRef *)v262, 17);
          }
        }
        if (v355)
          CFRelease(v355);
      }
    }
  }
  else
  {
    v353 = 0;
    if (_logHandle)
    {
      v253 = (os_log_t)_logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v252 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v252 = init_default_corebrightness_log();
      v253 = v252;
    }
    v353 = v253;
    v352 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v253, OS_LOG_TYPE_DEBUG))
    {
      v249 = v353;
      v250 = v352;
      v251 = v382;
      __os_log_helper_16_0_1_4_0((uint64_t)v382, 4);
      _os_log_debug_impl(&dword_1B5291000, v353, v352, "[%x]: throwing away stale sample", v382, 8u);
    }
  }
}

void sub_1B52A8328(uint64_t a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = a1;
  _Unwind_Resume(*(_Unwind_Exception **)(v1 + 8));
}

uint64_t AABC::ALS::isTouchObstructed(id *this)
{
  char v2;

  v2 = 0;
  if (this[3])
    v2 = objc_msgSend(this[3], "isObstructed");
  return v2 & 1;
}

BOOL AABC::ignoreALSEventsInAOD(uint64_t a1, uint64_t a2)
{
  BOOL v3;

  v3 = 1;
  if (a2 != 2)
  {
    v3 = 1;
    if (a2 != 3)
      return a2 == 4;
  }
  return v3;
}

void DisplaySetCurrentAmbient(uint64_t a1, float a2)
{
  NSObject *v2;
  void (*v3)(void);
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  uint64_t v8;
  float v9;
  float v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  if (a1)
  {
    if (*(_QWORD *)(v11 + 144))
    {
      v2 = *(NSObject **)(v11 + 144);
      v3 = (void (*)(void))MEMORY[0x1E0C809B0];
      v4 = -1073741824;
      v5 = 0;
      v6 = __DisplaySetCurrentAmbient_block_invoke;
      v7 = &__block_descriptor_44_e5_v8__0l;
      v8 = v11;
      v9 = v10;
      disp_dispatch_sync(v2, &v3);
    }
  }
}

float AABC::IlluminanceToReflectivity(AABC *this, float a2)
{
  return (float)(*((float *)this + 86) * a2) / 3.14159265;
}

void AABC::_ReportEsensorAggregated(AABC *this)
{
  CFNumberRef cf;

  if (*((float *)this + 135) != *((float *)this + 134))
  {
    *((_DWORD *)this + 135) = *((_DWORD *)this + 134);
    if (*((_QWORD *)this + 44))
    {
      cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 536);
      if (cf)
      {
        (*((void (**)(_QWORD, const __CFString *, CFNumberRef))this + 44))(*((_QWORD *)this + 45), CFSTR("Lux"), cf);
        CFRelease(cf);
      }
    }
  }
}

void AABC::CancelFirstSampleTimeout(dispatch_object_t *this)
{
  uint64_t v1;
  uint64_t inited;
  NSObject *v3;
  uint8_t v5[24];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (this[74])
  {
    if (_logHandle)
    {
      v3 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v3 = inited;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(double *)&v1 = CFAbsoluteTimeGetCurrent();
      __os_log_helper_16_0_1_8_0((uint64_t)v5, v1);
      _os_log_impl(&dword_1B5291000, v3, OS_LOG_TYPE_DEFAULT, "ts=%f Cancelling first sample timeout", v5, 0xCu);
    }
    dispatch_release(this[74]);
    this[74] = 0;
  }
}

void AABC::_UpdateNitsRestrictions(AABC *this, float a2, float a3, char a4)
{
  if ((*((_BYTE *)this + 3589) & 1) != 0)
    AABC::_UpdateNitsRestrictionsMultiPoint(this, a2, a3, a4 & 1);
  else
    AABC::_UpdateNitsRestrictionsSinglePoint(this, fminf(a2, *((float *)this + 1007)), a3, a4 & 1);
}

float AABC::addToFilter(AABC *this, AABC::ALSFilter *a2, float a3)
{
  float result;
  float *v4;
  unint64_t v5;
  float v6;
  uint64_t *v7;
  AABC *v8;

  v8 = this;
  v7 = (uint64_t *)a2;
  v6 = a3;
  if (std::vector<float>::size[abi:ne180100](a2))
  {
    if (CFAbsoluteTimeGetCurrent() >= *((double *)v7 + 4))
    {
      v5 = *((unsigned __int16 *)v7 + 20);
      *((_WORD *)v7 + 20) = v5 % std::vector<float>::size[abi:ne180100](v7);
      v4 = (float *)std::vector<float>::operator[][abi:ne180100](v7, *((unsigned __int16 *)v7 + 20));
      result = v6;
      *v4 = v6;
    }
    else
    {
      std::vector<float>::push_back[abi:ne180100](v7, &v6);
    }
    ++*((_WORD *)v7 + 20);
  }
  else
  {
    *((CFAbsoluteTime *)v7 + 4) = CFAbsoluteTimeGetCurrent() + (double)*((unsigned __int16 *)v7 + 12);
    std::vector<float>::push_back[abi:ne180100](v7, &v6);
    ++*((_WORD *)v7 + 20);
  }
  return result;
}

uint64_t DisplayGetBrightnessOverride(uint64_t a1, _DWORD *a2)
{
  char v3;

  if ((*(_BYTE *)(a1 + 1504) & 1) != 0)
  {
    if (a2)
      *a2 = *(_DWORD *)(a1 + 1524);
    v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  return v3 & 1;
}

void DisplaySetReflectedBrightnessWithFade(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  NSObject *v5;
  void (*v6)(void);
  int v7;
  int v8;
  void (*v9)(uint64_t);
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  float v19;
  uint64_t v20;

  v20 = a1;
  v19 = a4;
  v18 = a5;
  v17 = a2;
  v16 = a3;
  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    v18 = *(float *)(v20 + 376);
  if ((*(_BYTE *)(v20 + 12282) & 1) == 0)
  {
    v5 = *(NSObject **)(v20 + 144);
    v6 = (void (*)(void))MEMORY[0x1E0C809B0];
    v7 = -1073741824;
    v8 = 0;
    v9 = __DisplaySetReflectedBrightnessWithFade_block_invoke;
    v10 = &__block_descriptor_64_e5_v8__0l;
    v11 = v20;
    v14 = v18;
    v15 = v19;
    v12 = v17;
    v13 = v16;
    disp_dispatch_sync(v5, &v6);
  }
}

void CFXSetWeakestAmbientAdaptationMode(uint64_t a1, uint64_t a2, int a3, float a4)
{
  CFAbsoluteTime v4;
  float v5;
  int i;
  int v7;
  char v8;
  float v9;

  if (a1 && *(_QWORD *)(a1 + 96))
  {
    v9 = 1.0;
    v8 = 0;
    v7 = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 248);
    for (i = 0; i < a3; ++i)
    {
      v5 = _CFXGetStrengthFromMode(a1, *(_DWORD *)(a2 + 4 * i));
      if (v5 <= v9)
      {
        v9 = v5;
        v7 = *(_DWORD *)(a2 + 4 * i);
        v8 = 1;
      }
    }
    syslog(7, "Min strength %f\n", v9);
    if ((v8 & 1) != 0)
    {
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 96) + 184) & 1) != 0)
      {
        *(float *)&v4 = v9;
        CFXSetAmbientAdaptationStrength(a1, v4, a4);
      }
      *(_DWORD *)(*(_QWORD *)(a1 + 96) + 248) = v7;
    }
  }
}

void sub_1B52AA874()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void AABC::UpdateAggregateFunction(AABC *this, id *a2, AABC::ALS *a3, AABC *a4)
{
  AABC::_UpdateAggregateFunction(a3, this, a2);
}

void AABC::_UpdateAggregateFunction(AABC *this, __IOHIDServiceClient *a2, id *a3)
{
  double *v3;
  void *v4;
  double v5;
  id v6;
  id v7;
  uint64_t inited;
  NSObject *v9;
  BOOL v10;
  id v12;
  id v13;
  int v14;
  double v15;
  uint64_t v16;
  int v17;
  int v18;
  float (*v19)(uint64_t, uint64_t, void *);
  void *v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  float *v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  float *v29;
  int v30;
  int v31;
  float v32;
  uint64_t v33;
  os_log_type_t v34;
  os_log_t v35;
  unint64_t v36;
  uint64_t v37;
  char v38;
  BOOL v39;
  id *v40;
  __IOHIDServiceClient *v41;
  AABC *v42;
  uint8_t v43[40];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v42 = this;
  v41 = a2;
  v40 = a3;
  if (a3 == *((id **)this + 57))
  {
    v39 = 0;
    v10 = !*((_QWORD *)this + 60) || (*((_BYTE *)this + 3937) & 1) == 0 || *((_DWORD *)this + 987) == 0;
    v39 = v10;
    v38 = (AABC::ALS::isTouchObstructed(v40) ^ 1) & 1;
    if (*((float *)v40 + 39) > *((float *)this + 136) || v39 && (v38 & 1) != 0)
      AABC::_UpdateEsensorTrusted(this, *((float *)v40 + 39));
    if (*((int *)this + 926) < 0)
      *((_QWORD *)this + 485) = mach_absolute_time();
    *((_DWORD *)this + 926) = *((_DWORD *)v40 + 1);
    if (*((int *)this + 926) >= 9)
      *((_DWORD *)this + 926) = 8;
  }
  else if (*((float *)v40 + 39) > *((float *)this + 136))
  {
    *((_QWORD *)this + 57) = v40;
    AABC::_UpdateEsensorTrusted(this, *((float *)v40 + 39));
    v37 = mach_absolute_time();
    if (*((int *)this + 926) >= 0)
    {
      v36 = 0;
      v36 = v37 - *((_QWORD *)this + 485);
      v3 = (double *)((char *)this + 8 * *((int *)this + 926) + 3808);
      *v3 = *v3 + (double)v36 * *(double *)&AABC::_sMachTimebaseFactor;
    }
    *((_DWORD *)this + 926) = *((_DWORD *)v40 + 1);
    if (*((int *)this + 926) >= 9)
      *((_DWORD *)this + 926) = 8;
    *((_QWORD *)this + 485) = v37;
    ++*((_DWORD *)this + 974);
  }
  if (*((float *)v40 + 39) > *((float *)this + 134))
    *((_DWORD *)this + 134) = *((_DWORD *)v40 + 39);
  *((float *)this + 152) = fmaxf(*((float *)v40 + 39), *((float *)this + 152));
  v35 = 0;
  if (_logHandle)
  {
    v9 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v9 = inited;
  }
  v35 = v9;
  v34 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_4_0_8_0_8_0_8_0((uint64_t)v43, 16, COERCE__INT64(*((float *)v40 + 39)), COERCE__INT64(*((float *)this + 136)), COERCE__INT64(*((float *)this + 134)));
    _os_log_debug_impl(&dword_1B5291000, v35, v34, "[%x]: _Esensor_filtered=%0.4f _Esensor_trusted=%0.4f _Esensor_aggregated=%0.4f", v43, 0x26u);
  }
  v33 = mach_absolute_time();
  if (objc_msgSend(*((id *)this + 488), "count"))
  {
    v28 = 0;
    v29 = (float *)&v28;
    v30 = 0x20000000;
    v31 = 32;
    v32 = -1.0;
    v23 = 0;
    v24 = (float *)&v23;
    v25 = 0x20000000;
    v26 = 32;
    v27 = 1259902592;
    v4 = (void *)*((_QWORD *)this + 488);
    v16 = MEMORY[0x1E0C809B0];
    v17 = -1073741824;
    v18 = 0;
    v19 = ___ZN4AABC24_UpdateAggregateFunctionEP20__IOHIDServiceClientPNS_3ALSE_block_invoke;
    v20 = &unk_1E68EBB58;
    v21 = &v28;
    v22 = &v23;
    objc_msgSend(v4, "enumerateKeysAndObjectsUsingBlock:", &v16);
    v15 = (double)(v33 - *((_QWORD *)this + 486)) * *(double *)&AABC::_sMachTimebaseFactor;
    if (v29[6] > 5.0)
      v14 = (int)((log10((v29[6] + 1.0) / (v24[6] + 1.0)) + 0.25) * 2.0) + 1;
    else
      v14 = 0;
    if (v14 > 11)
      v14 = 11;
    *((double *)this + v14 + 464) = *((double *)this + v14 + 464) + v15;
    _Block_object_dispose(&v23, 8);
    _Block_object_dispose(&v28, 8);
  }
  v7 = objc_alloc(MEMORY[0x1E0CB37E8]);
  v13 = (id)objc_msgSend(v7, "initWithInt:", *((unsigned int *)v40 + 1));
  v6 = objc_alloc(MEMORY[0x1E0CB37E8]);
  LODWORD(v5) = *((_DWORD *)v40 + 39);
  v12 = (id)objc_msgSend(v6, "initWithFloat:", v5);
  if (v13)
    objc_msgSend(*((id *)this + 488), "setObject:forKey:", v12, v13);

  *((_QWORD *)this + 486) = v33;
}

void sub_1B52ABBB4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_0_1_4_0(uint64_t result, int a2)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 1;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_64_8_64(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 64;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  return result;
}

void sub_1B52B04D8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void sub_1B52B0AD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, id obj, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, int a19, uint64_t a20)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

BOOL CBU_IsAccessory()
{
  return MGGetSInt32Answer() == 7;
}

void sub_1B52B22A8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_2_8_64_8_0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  return result;
}

void AABC::_UpdateEsensorTrusted(AABC *this, float a2)
{
  double v2;
  float v3;
  float v4;
  double v5;
  double v6;
  double v7;
  float v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  NSObject *v23;
  float v24;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v28;
  void *context;
  CFNumberRef cf;
  CFNumberRef v32;
  float v33;
  _DWORD v34[2];
  char v35;
  uint8_t v36[7];
  char v37;
  NSObject *v38;
  id v39;
  float v40;
  int v41;
  id v42;
  char v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  id v49;
  float v50;
  float v51;
  float v52;
  float v53;
  AABC *v54;
  uint8_t v55[32];
  uint8_t v56[16];
  uint8_t v57[24];
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v54 = this;
  v53 = a2;
  v52 = -1.0;
  v51 = a2;
  *((_BYTE *)this + 316) = 0;
  if ((objc_msgSend(*((id *)this + 37), "isRearALSSupported") & 1) != 0
    && (objc_msgSend(*((id *)this + 37), "started") & 1) != 0)
  {
    v50 = v53;
    if (*((_DWORD *)this + 130) || *((_DWORD *)this + 169))
      v50 = -1.0;
    *(float *)&v2 = v50;
    objc_msgSend(*((id *)this + 37), "checkSensorEnablementConditions:", v2);
    v49 = 0;
    v49 = (id)objc_msgSend(*((id *)this + 37), "copyParam:", CFSTR("lux"));
    if (v49)
    {
      objc_msgSend(v49, "floatValue");
      v48 = v3;

      v47 = 0.0;
      v47 = fminf(fmaxf(AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 802, v50, fminf(v50, *((float *)this + 1007))), *((float *)this + 180)), *((float *)this + 182));
      v46 = 0.0;
      objc_msgSend(*((id *)this + 37), "nitsRatio");
      v46 = v4;
      v45 = v4 * v47;
      v45 = fminf(v4 * v47, *((float *)this + 182));
      v44 = AABC::LuminanceToIlluminance((uint64_t)this, (float *)this + 802, v45);
      v48 = fminf(v48, 8079.0);
      v43 = 0;
      *(float *)&v5 = v50;
      *(float *)&v6 = v48;
      *(float *)&v7 = v44;
      v43 = objc_msgSend(*((id *)this + 37), "shouldUseRearLuxFrontLux:rearLux:andCap:", v5, v6, v7) & 1;
      if (v43)
      {
        v52 = fminf(v48, v44);
        v53 = v48;
        *((_BYTE *)this + 316) = 1;
      }
      if (v52 != *((float *)this + 78))
      {
        *((float *)this + 78) = v52;
        if (*((float *)this + 136) == v53 && v53 >= 0.001)
        {
          v8 = v53 - 0.001;
          v53 = v8;
        }
      }
      if (*((_QWORD *)this + 48))
      {
        v42 = objc_alloc_init(MEMORY[0x1E0C99E08]);
        context = (void *)MEMORY[0x1B5E4A8B0]();
        *(float *)&v9 = v50;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v9), CFSTR("frontLux"));
        *(float *)&v10 = v48;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v10), CFSTR("rearLux"));
        *(float *)&v11 = v47;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v11), CFSTR("frontNits-Default"));
        *(float *)&v12 = v45;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v12), CFSTR("rearNits-Default"));
        *(float *)&v13 = v53;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v13), CFSTR("finalLux"));
        *(float *)&v14 = v52;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v14), CFSTR("cappedLuxForAAB"));
        v41 = 0;
        *(float *)&v15 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, v50, fminf(v50, *((float *)this + 1007)));
        v41 = LODWORD(v15);
        v40 = -1.0;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v15), CFSTR("frontNits"));
        if ((*((_BYTE *)this + 316) & 1) != 0)
        {
          *(float *)&v16 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, v52, fminf(v52, *((float *)this + 1007)));
          v40 = *(float *)&v16;
        }
        else
        {
          LODWORD(v16) = v41;
        }
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v16), CFSTR("finalNits"));
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", *((_BYTE *)this + 316) & 1), CFSTR("rearLuxInUse"));
        *(float *)&v17 = v40;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v17), CFSTR("rearNits"));
        v39 = 0;
        v39 = (id)objc_msgSend(*((id *)this + 37), "copyParam:", CFSTR("GainChanged"));
        if (v39)
          objc_msgSend(v42, "setObject:forKey:", v39, CFSTR("gainChanged"));
        objc_autoreleasePoolPop(context);
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), CFSTR("RLuxStats"), v42);
        if (*((_QWORD *)this + 44))
          (*((void (**)(_QWORD, const __CFString *, id))this + 44))(*((_QWORD *)this + 45), CFSTR("RLuxStats"), v42);

      }
    }
    else
    {
      v38 = 0;
      if (_logHandle)
      {
        v28 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v28 = inited;
      }
      v38 = v28;
      v37 = 2;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        log = v38;
        type = v37;
        __os_log_helper_16_0_0(v36);
        _os_log_debug_impl(&dword_1B5291000, log, type, "AABRear: Lux not available", v36, 2u);
      }
    }
  }
  v35 = 0;
  if (!float_equal(*((float *)this + 136), v53))
  {
    *((float *)this + 136) = v53;
    *(float *)&v34[1] = v53;
    v34[0] = 2;
    DisplayUpdateAAPState(*((_QWORD *)this + 51), (uint64_t)v34, 1, 1);
    *((float *)this + 139) = fminf(*((float *)this + 136), *((float *)this + 1007));
    if (v52 >= 0.0)
      *((float *)this + 139) = fminf(*((float *)this + 139), v52);
    if ((*((_BYTE *)this + 3936) & 1) != 0)
      v24 = v53;
    else
      v24 = truncf(v53);
    v33 = fmaxf(v24, 0.0);
    if (vabds_f32(v33, *((float *)this + 138)) > 0.001)
    {
      *((float *)this + 138) = v33;
      v35 = 1;
      if (*((_QWORD *)this + 44))
      {
        v32 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 552);
        if (v32)
        {
          (*((void (**)(_QWORD, const __CFString *, CFNumberRef))this + 44))(*((_QWORD *)this + 45), CFSTR("TrustedLux"), v32);
          CFRelease(v32);
        }
      }
    }
    AABC::_UpdateSemanticAmbientLightLevel((uint64_t)this, 255);
    if ((*((_BYTE *)this + 4084) & 1) != 0)
    {
      if (*((float *)this + 136) <= *((float *)this + 1022) && *((float *)this + 123) >= 1.0)
      {
        if (*((float *)this + 136) < (float)(*((float *)this + 1022) - 100.0)
          && *((float *)this + 136) < (float)(*((float *)this + 1022) * 0.1))
        {
          *((_DWORD *)this + 1022) = *((_DWORD *)this + 136);
          if (!*((_DWORD *)this + 130))
          {
            if (_logHandle)
            {
              v21 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
                v20 = _COREBRIGHTNESS_LOG_DEFAULT;
              else
                v20 = init_default_corebrightness_log();
              v21 = v20;
            }
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v56, COERCE__INT64(*((float *)this + 136)));
              _os_log_debug_impl(&dword_1B5291000, v21, OS_LOG_TYPE_DEBUG, "Resetting weak cap in lux = %f\n", v56, 0xCu);
            }
            DisplayUpdateWeakCapOnSignificantAmbientChange(*((_QWORD *)this + 51));
          }
        }
      }
      else
      {
        *((_DWORD *)this + 1022) = *((_DWORD *)this + 136);
        if (_logHandle)
        {
          v23 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v22 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v22 = init_default_corebrightness_log();
          v23 = v22;
        }
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v57, COERCE__INT64(*((float *)this + 136)));
          _os_log_debug_impl(&dword_1B5291000, v23, OS_LOG_TYPE_DEBUG, "Updating weak cap Emax = %f\n", v57, 0xCu);
        }
      }
    }
  }
  if (*((float *)this + 137) != v51)
  {
    v51 = fminf(v51, *((float *)this + 1007));
    if (*((_QWORD *)this + 44))
    {
      if (*((int *)this + 137) != SLODWORD(v51))
      {
        v35 = 1;
        cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 548);
        if (cf)
        {
          (*((void (**)(_QWORD, const __CFString *, CFNumberRef))this + 44))(*((_QWORD *)this + 45), CFSTR("TrustedFrontLux"), cf);
          CFRelease(cf);
        }
      }
    }
    *((float *)this + 137) = v51;
  }
  if ((v35 & 1) != 0)
  {
    if (_logHandle)
    {
      v19 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v18 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v18 = init_default_corebrightness_log();
      v19 = v18;
    }
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v55, COERCE__INT64(*((float *)this + 136)), COERCE__INT64(*((float *)this + 137)), COERCE__INT64(*((float *)this + 139)));
      _os_log_impl(&dword_1B5291000, v19, OS_LOG_TYPE_DEFAULT, "trusted Lux: %f, trusted front Lux: %f, trusted capped Lux: %f", v55, 0x20u);
    }
  }
}

uint64_t __os_log_helper_16_2_1_8_64(uint64_t result, uint64_t a2)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 1;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  return result;
}

uint64_t convertMachToNanoSeconds(uint64_t a1)
{
  if (!dword_1EF1292FC)
    mach_timebase_info((mach_timebase_info_t)&convertMachToNanoSeconds_sTimebaseInfo);
  return a1 * (convertMachToNanoSeconds_sTimebaseInfo / dword_1EF1292FC);
}

void AABC::_UpdateSemanticAmbientLightLevel(uint64_t a1, int a2)
{
  CFNumberRef cf;
  int v4;

  if (a2 == 255)
  {
    if (*(float *)(a1 + 544) < 10000.0)
    {
      if (*(float *)(a1 + 544) < 2000.0)
      {
        if (*(float *)(a1 + 544) < 300.0)
        {
          if (*(float *)(a1 + 544) < 30.0)
            v4 = 1;
          else
            v4 = 2;
        }
        else
        {
          v4 = 3;
        }
      }
      else
      {
        v4 = 4;
      }
    }
    else
    {
      v4 = 5;
    }
  }
  else
  {
    v4 = a2;
  }
  if (*(_DWORD *)(a1 + 588) != v4)
  {
    *(_DWORD *)(a1 + 588) = v4;
    if (*(_QWORD *)(a1 + 352))
    {
      cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (const void *)(a1 + 588));
      if (cf)
      {
        (*(void (**)(_QWORD, const __CFString *, CFNumberRef))(a1 + 352))(*(_QWORD *)(a1 + 360), CFSTR("SemanticAmbientLightLevel"), cf);
        CFRelease(cf);
      }
    }
  }
}

uint64_t __os_log_helper_16_0_1_8_0(uint64_t result, uint64_t a2)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 1;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  return result;
}

uint64_t __os_log_helper_16_2_1_8_66(uint64_t result, uint64_t a2)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 1;
  *(_BYTE *)(result + 2) = 66;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  return result;
}

uint64_t CFXTriggerMitigation(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(*(_QWORD *)(result + 96) + 302) = a2 & 1;
  return result;
}

float CFXSetSampleStrength(uint64_t a1, float result)
{
  if (a1)
    *(float *)(*(_QWORD *)(a1 + 96) + 332) = result;
  return result;
}

float CFXSetFadeDuration(uint64_t a1, char a2)
{
  float result;
  uint64_t v3;

  if (a1 && *(_QWORD *)(a1 + 96))
  {
    v3 = *(_QWORD *)(a1 + 96);
    *(_DWORD *)(v3 + 180) = 1114636288;
    *(float *)(v3 + 176) = 20.0;
    if ((a2 & 1) != 0)
    {
      result = 15.0;
      *(float *)(v3 + 160) = 15.0;
      *(float *)(v3 + 164) = 15.0;
      *(float *)(v3 + 168) = 15.0;
      *(float *)(v3 + 172) = 15.0;
    }
    else
    {
      result = 5.0;
      *(float *)(v3 + 160) = 5.0;
      *(float *)(v3 + 164) = 5.0;
      *(float *)(v3 + 168) = 5.0;
      *(float *)(v3 + 172) = 5.0;
    }
  }
  return result;
}

void CFXInputAmbientColor(uint64_t *a1, float *a2, int a3)
{
  double *v3;
  double *v4;
  float v5;
  double v6;
  uint64_t v7;
  double v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  char v14;
  uint64_t *v15;
  int v16;
  float *v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v18 = a1;
  v17 = a2;
  v16 = a3;
  v15 = a1;
  if (a1 && v17)
  {
    if (v17[1] >= 11140.846)
    {
      v17[3] = 0.31272;
      v17[4] = 0.329;
      CFXChromaticity2Tristimulus(v17 + 3, v17, v17[1]);
      v17[5] = 6500.0;
    }
    memcpy(v15, v17, 0x3CuLL);
    *((_DWORD *)v15 + 19) = v16;
    v14 = 0;
    _CFXAdaptToColorSample((uint64_t)v15, (uint64_t)v17, v16, &v14, 0.0);
    if ((*((_BYTE *)v15 + 1801) & 1) != 0)
      _CFXLogSample((uint64_t)v15, v14 & 1);
    *((_BYTE *)v15 + 344) = 0;
    v13 = 0;
    v12 = 0;
    if (v17[3] == 0.0 && v17[4] == 0.0)
    {
      v12 = 0;
      v13 = 0;
    }
    else
    {
      v19 = 0;
      v20 = 0;
      CFXChromaticity2Tristimulus(v17 + 3, (float *)&v19, 100.0);
      v10 = 0;
      v11 = 0;
      CFXTristimulus2Lab((float *)&v19, (float *)&v10);
      v13 = binFromAb((float *)&v10 + 1);
      v12 = ansiBinFromChromaticity(v17 + 3);
    }
    if (v13 != *((_DWORD *)v15 + 253))
    {
      v9 = mach_absolute_time();
      v8 = MachTimeToSeconds(v9 - v15[127]);
      v3 = (double *)&v15[*((int *)v15 + 253) + 101];
      *v3 = *v3 + v8;
      v15[127] = v9;
      *((_DWORD *)v15 + 253) = v13;
      ++*((_DWORD *)v15 + v13 + 236);
    }
    if (v12 != *((_DWORD *)v15 + 402))
    {
      v7 = mach_absolute_time();
      v6 = MachTimeToSeconds(v7 - v15[202]);
      v4 = (double *)&v15[*((int *)v15 + 402) + 155];
      *v4 = *v4 + v6;
      v15[202] = v7;
      *((_DWORD *)v15 + 402) = v12;
    }
    v5 = v17[1] * 3.14159265;
    CFXAmmoliteUpdateTarget(v15[282], v5);
    if (v15[282] && (*(_BYTE *)(v15[282] + 24) & 1) != 0)
    {
      if (v15[41])
        ((void (*)(uint64_t, _QWORD))v15[41])(v15[42], 0);
    }
  }
}

uint64_t binFromAb(float *a1)
{
  int v1;
  float v2;
  float v3;
  float v5;
  int v6;
  float v7;
  unsigned int v8;
  float v9;
  float v10;

  v10 = *a1;
  v9 = a1[1];
  v8 = 0;
  if (fmaxf(fabsf(*a1), fabsf(v9)) != 0.0)
  {
    v7 = sqrtf((float)(v9 * v9) + (float)(v10 * v10));
    if (v7 <= 15.0)
      v1 = 1;
    else
      v1 = 9;
    v6 = v1;
    v2 = atan2f(v9 / v7, v10 / v7) + 0.392699082;
    v5 = v2;
    if (v2 < 0.0)
    {
      v3 = v2 + 6.28318531;
      v5 = v3;
    }
    syslog(7, "%f %f %f -> ANGLE %f -> BIN %d", v7, v10, v9, v5, (int)(v5 / 0.785398163));
    return ((int)(v5 / 0.785398163) + v6);
  }
  return v8;
}

double MachTimeToSeconds(unint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  mach_timebase_info info;
  double v5;
  unint64_t v6;

  v6 = a1;
  v5 = 0.0;
  info = 0;
  if (!mach_timebase_info(&info))
  {
    LODWORD(v1) = info.numer;
    *(double *)&v2 = (double)v1;
    LODWORD(v2) = info.denom;
    v5 = 0.000000001 * (double)v1 / (double)v2;
  }
  return (double)v6 * v5;
}

void CFXAmmoliteUpdateTarget(uint64_t a1, float a2)
{
  float v2;
  float v3;
  NSObject *v4;
  float v5;
  float v6;
  int k;
  int j;
  float v9;
  int i;
  uint64_t v11;
  uint8_t v14[52];
  _DWORD __dst[9];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v11 = *(_QWORD *)(a1 + 8);
    for (i = 0; i < *(_QWORD *)(a1 + 8); ++i)
    {
      if (a2 < *(float *)(*(_QWORD *)a1 + 40 * i))
      {
        v11 = i;
        break;
      }
    }
    if (v11)
    {
      if (v11 < *(_QWORD *)(a1 + 8))
      {
        v9 = (float)(a2 - *(float *)(*(_QWORD *)a1 + 40 * (v11 - 1)))
           / (float)(*(float *)(*(_QWORD *)a1 + 40 * v11) - *(float *)(*(_QWORD *)a1 + 40 * (v11 - 1)));
        for (j = 0; j < 3; ++j)
        {
          for (k = 0; k < 3; ++k)
          {
            v2 = (float)(v9 * *(float *)(*(_QWORD *)a1 + 40 * v11 + 4 + 12 * j + 4 * k))
               + (1.0 - v9) * *(float *)(*(_QWORD *)a1 + 40 * (v11 - 1) + 4 + 12 * j + 4 * k);
            *(float *)&__dst[3 * j + k] = v2;
          }
        }
      }
      else
      {
        memcpy(__dst, (const void *)(*(_QWORD *)a1 + 40 * (*(_QWORD *)(a1 + 8) - 1) + 4), sizeof(__dst));
      }
    }
    else
    {
      memcpy(__dst, (const void *)(*(_QWORD *)a1 + 4), sizeof(__dst));
    }
    v3 = fabs((float)(a2 - *(float *)(a1 + 28)));
    v6 = v3;
    v5 = 0.0;
    if (*(float *)(a1 + 28) > 0.0)
      v5 = v3 / *(float *)(a1 + 28);
    if (*(_QWORD *)(a1 + 48))
      v4 = *(NSObject **)(a1 + 48);
    else
      v4 = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_4_8_32_8_0_8_0_8_0((uint64_t)v14, (uint64_t)"CFXAmmoliteUpdateTarget", COERCE__INT64(a2), COERCE__INT64(v6), COERCE__INT64(*(float *)(a1 + 32)));
      _os_log_impl(&dword_1B5291000, v4, OS_LOG_TYPE_INFO, "%s: Ammolite: Lux %f (delta %f / thr %f)\n", v14, 0x2Au);
    }
    if (v6 > *(float *)(a1 + 32)
      && (*(float *)(a1 + 28) == 0.0 || *(float *)(a1 + 28) > 0.0 && v5 > *(float *)(a1 + 36)))
    {
      *(float *)(a1 + 28) = a2;
      *(_BYTE *)(*(_QWORD *)(a1 + 16) + 16) = 0;
      __memcpy_chk();
      __memcpy_chk();
      *(CFAbsoluteTime *)(*(_QWORD *)(a1 + 16) + 8) = CFAbsoluteTimeGetCurrent();
      **(double **)(a1 + 16) = *(float *)(a1 + 40);
      *(_BYTE *)(a1 + 24) = 1;
    }
    else
    {
      *(_BYTE *)(a1 + 24) = 0;
    }
  }
}

uint64_t ansiBinFromChromaticity(float *a1)
{
  BOOL v1;
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  BOOL v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  _QWORD v20[12];
  int v21;
  _QWORD *v22;
  int v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  char v36;
  int j;
  int i;
  int v39;
  int v40;
  float *v41;
  float *v42;
  float *v43;
  float *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v41 = a1;
  v40 = -1;
  v39 = 0;
  for (i = 0; i < 14; ++i)
  {
    for (j = 0; j < 3; ++j)
    {
      v36 = 0;
      v42 = (float *)&ColorAnsiBins[8 * i + 2 * j];
      v23 = 1;
      v43 = (float *)&ColorAnsiBins[8 * i + 2 + 2 * j];
      v44 = (float *)&ColorAnsiBins[8 * i + 8 + 2 * j];
      v1 = triangleInclusion(v41, &v42);
      v36 = v1 & v23;
      if ((v1 & v23 & 1) != 0)
      {
        v2 = *v41;
        v3 = v41[1];
        v4 = *v42;
        v5 = v42[1];
        v6 = *v43;
        v7 = v43[1];
        v8 = *v44;
        v9 = v44[1];
        v22 = v20;
        syslog(7, "BIN %d: (%f, %f) fitting in (%f, %f)-(%f, %f)-(%f, %f)\n", v39, v2, v3, v4, v5, v6, v7, v8, v9);
        v40 = v39;
        break;
      }
      v21 = 1;
      v42 = (float *)&ColorAnsiBins[8 * i + 10 + 2 * j];
      v10 = triangleInclusion(v41, &v42);
      v36 = v10 & v21;
      if ((v10 & v21 & 1) != 0)
      {
        v11 = *v41;
        v12 = v41[1];
        v13 = *v42;
        v14 = v42[1];
        v15 = *v43;
        v16 = v43[1];
        v17 = *v44;
        v18 = v44[1];
        v20[11] = v20;
        syslog(7, "BIN %d: (%f, %f) fitting in (%f, %f)-(%f, %f)-(%f, %f)\n", v39, v11, v12, v13, v14, v15, v16, v17, v18);
        v40 = v39;
        break;
      }
      ++v39;
    }
    if (v40 >= 0)
      break;
  }
  if (v40 < 0)
  {
    if ((v35 = (float)(0.4313 - 0.521) / (float)(0.5443 - 0.6127),
          v34 = 0.521 - (float)(v35 * 0.6127),
          v33 = 0.0,
          v33 = v41[1] - (float)(v35 * *v41),
          v32 = v33 - v34,
          v35 >= 0.0)
      && v32 <= 0.0
      || v35 < 0.0 && v32 > 0.0)
    {
      v40 = 42;
    }
  }
  if (v40 < 0)
  {
    if ((v31 = (float)(0.2585 - 0.2757) / (float)(0.2391 - 0.2127),
          v30 = 0.2757 - (float)(v31 * 0.2127),
          v29 = 0.0,
          v29 = v41[1] - (float)(v31 * *v41),
          v28 = v29 - v30,
          v31 >= 0.0)
      && v28 >= 0.0
      || v31 < 0.0 && v28 < 0.0)
    {
      v40 = 43;
    }
  }
  if (v40 < 0)
  {
    v27 = (float)(0.2757 - 0.521) / (float)(0.2127 - 0.6127);
    v26 = 0.2757 - (float)(v27 * 0.2127);
    v25 = 0.0;
    v25 = v41[1] - (float)(v27 * *v41);
    v24 = v25 - v26;
    if ((float)(v25 - v26) < 0.0)
      return 45;
    else
      return 44;
  }
  return v40;
}

BOOL triangleInclusion(float *a1, float **a2)
{
  float v2;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  BOOL v10;

  v10 = 0;
  v9 = *a2[1] - **a2;
  v8 = *a2[2] - **a2;
  v7 = a2[1][1] - (*a2)[1];
  v6 = a2[2][1] - (*a2)[1];
  v5 = *a1 - **a2;
  v2 = a1[1] - (*a2)[1];
  v4 = (float)((float)(v9 / (float)-(float)((float)(v8 * v7) - (float)(v9 * v6))) * v2)
     + (float)((float)((float)-v7 / (float)-(float)((float)(v8 * v7) - (float)(v9 * v6))) * v5);
  if ((float)((float)((float)((float)-v8 / (float)-(float)((float)(v8 * v7) - (float)(v9 * v6))) * v2)
             + (float)((float)(v6 / (float)-(float)((float)(v8 * v7) - (float)(v9 * v6))) * v5)) >= 0.0
    && v4 >= 0.0)
  {
    return (float)((float)((float)((float)((float)-v8 / (float)-(float)((float)(v8 * v7) - (float)(v9 * v6))) * v2)
                         + (float)((float)(v6 / (float)-(float)((float)(v8 * v7) - (float)(v9 * v6))) * v5))
                 + v4) <= 1.0;
  }
  return v10;
}

void _CFXAdaptToColorSample(uint64_t a1, uint64_t a2, int a3, _BYTE *a4, float a5)
{
  BOOL v5;
  char v6;
  char v7;
  int v8;
  _BYTE *v9;
  float v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v13 = a1;
  v12 = a2;
  v11 = a3;
  v10 = a5;
  v9 = a4;
  syslog(7, "LOWLUX %f\n", *(float *)(a2 + 4));
  v14 = 0;
  v15 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  if ((_CFXRestrictLowAmbientColor(v13, v12, (float *)&v14, (float *)&v8, &v7) & 1) != 0)
  {
    if ((*(_BYTE *)(*(_QWORD *)(v13 + 96) + 220) & 1) != 0
      || (v7 & 1) != 0
      || (*(_BYTE *)(*(_QWORD *)(v13 + 96) + 288) & 1) != 0)
    {
      v6 = 1;
    }
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(v13 + 96) + 220) = 0;
    v6 = 1;
  }
  if ((v6 & 1) != 0)
  {
    if ((*(_BYTE *)(*(_QWORD *)(v13 + 96) + 288) & 1) != 0)
      v10 = 2.0;
    __memcpy_chk();
    *(_DWORD *)(v13 + 92) = v8;
    if ((*(_BYTE *)(*(_QWORD *)(v13 + 96) + 184) & 1) != 0)
    {
      v5 = 1;
      if ((*(_BYTE *)(v13 + 344) & 1) == 0)
        v5 = (v11 & 1) != 0;
      _CFXUpdateTarget(v13, (float *)(v13 + 80), v5, (v11 & 2) != 0, v10);
    }
  }
  *v9 = v6 & 1;
  *(_BYTE *)(*(_QWORD *)(v13 + 96) + 288) = 0;
}

void _CFXUpdateTarget(uint64_t a1, float *a2, char a3, char a4, float a5)
{
  float v5;
  double Current;
  double v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  float v13;
  float v14;
  float v15;
  float v16;
  int v17;
  float v18[3];
  float v19;
  uint64_t v20;
  char v21;
  float v22;
  char v23;
  float *v24;
  uint64_t v25;
  float v26;
  float v27;
  float v28[9];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v25 = a1;
  v24 = a2;
  v23 = a3 & 1;
  v22 = a5;
  v21 = a4 & 1;
  v20 = 0;
  v20 = *(_QWORD *)(a1 + 96);
  _CFXIdentity(v28);
  if (v20
    && (*(_BYTE *)(v20 + 184) & 1) != 0
    && *(float *)v20 >= 0.0
    && (*v24 != 0.0 || v24[1] != 0.0 || v24[2] != 0.0))
  {
    _CFXGetTarget(v25, v24, v28, *(_QWORD *)(v20 + 56), *(_DWORD *)(v20 + 148), v20 + 144, v20 + 64, 0, *(float *)v20);
  }
  v19 = 0.0;
  *(_QWORD *)v18 = 0;
  v17 = 0;
  _CFXGetWPFromMatrix(v25, v28, v18, &v17);
  CFXChromaticity2uv(v18, &v26);
  v19 = CFXChromaticity2CCT(v18);
  v16 = 0.0;
  v16 = v26 - *(float *)(v25 + 120);
  v15 = 0.0;
  v15 = v27 - *(float *)(v25 + 124);
  v5 = sqrt((float)((float)(v15 * v15) + (float)(v16 * v16)));
  v14 = v5;
  v13 = 0.0;
  if ((v23 & 1) != 0 || v20 && v14 >= *(float *)(v20 + 156))
  {
    v12 = 0;
    if ((v23 & 1) != 0)
    {
      v13 = v22;
    }
    else if (v24[1] >= *(float *)(v20 + 196) / 3.14159265)
    {
      if (v24[1] >= *(float *)(v20 + 204) / 3.14159265)
      {
        if (v19 < (float)*(unsigned int *)(v25 + 128))
        {
          v13 = *(float *)(v20 + 164);
          v12 = 1;
        }
        else
        {
          v13 = *(float *)(v20 + 160);
        }
      }
      else
      {
        v13 = *(float *)(v20 + 176);
        v12 = 2;
      }
    }
    else
    {
      v13 = *(float *)(v20 + 180);
      v12 = 2;
    }
    if ((v23 & 1) == 0)
    {
      v11 = 0.0;
      v9 = v25 + 760;
      Current = CFAbsoluteTimeGetCurrent();
      if ((_CFXCheckStats(v9, v12, &v11, Current) & 1) != 0)
        v13 = fmaxf(v11, v13);
    }
    _CFXSetTarget(v25, v28, 1, 1, v13, 1.0);
    *(float *)(v25 + 120) = v26;
    *(float *)(v25 + 124) = v27;
    *(_DWORD *)(v25 + 128) = v19;
  }
  else if (v20 && v14 >= *(float *)(v20 + 152))
  {
    if (v24[1] >= *(float *)(v20 + 196) / 3.14159265)
    {
      if (v24[1] >= *(float *)(v20 + 204) / 3.14159265)
      {
        if (v19 < (float)*(unsigned int *)(v25 + 128))
          v13 = *(float *)(v20 + 172);
        else
          v13 = *(float *)(v20 + 168);
      }
      else
      {
        v13 = *(float *)(v20 + 176);
      }
    }
    else
    {
      v13 = *(float *)(v20 + 180);
    }
    v10 = 0.0;
    v8 = v25 + 760;
    v7 = CFAbsoluteTimeGetCurrent();
    if ((_CFXCheckStats(v8, 3, &v10, v7) & 1) != 0)
      v13 = fmaxf(v10, v13);
    if ((_CFXSetTarget(v25, v28, 0, 1, v13, 1.0) & 1) != 0)
    {
      *(float *)(v25 + 120) = v26;
      *(float *)(v25 + 124) = v27;
      *(_DWORD *)(v25 + 128) = v19;
    }
  }
}

float CFXChromaticity2uv(float *a1, float *a2)
{
  float result;
  float v3;

  v3 = (float)((float)(12.0 * a1[1]) + (float)(-2.0 * *a1)) + 3.0;
  *a2 = (float)(4.0 * *a1) / v3;
  result = (float)(9.0 * a1[1]) / v3;
  a2[1] = result;
  return result;
}

uint64_t _CFXGetTarget(uint64_t a1, float *a2, float *a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, char a8, float a9)
{
  float v9;
  unsigned int v10;
  float v11;
  unsigned int v12;
  float v13;
  unsigned int v14;
  float v15;
  float v16;
  float v17;
  float *v19;
  uint64_t v20;
  float v21[3];
  int v22;
  uint64_t v23;
  _QWORD v24[2];
  int v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  int i;
  int v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  int v35;
  float v36;
  float v37;
  unint64_t v38;
  unint64_t v39;
  float v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  float *v46;
  float *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  float v51[4];
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v48 = a1;
  v47 = a2;
  v46 = a3;
  v45 = a4;
  v44 = a5;
  v43 = a6;
  v42 = a7;
  v41 = a8 & 1;
  v40 = a9;
  v53 = 0;
  v54 = 0;
  v53 = *(_QWORD *)a2;
  v54 = *((_DWORD *)a2 + 2);
  if ((a8 & 1) == 0)
  {
    v39 = 0;
    CFXTristimulus2Chromaticity(v47, (float *)&v39);
    v38 = v39;
    v37 = 0.0;
    v37 = *(float *)(v48 + 92);
    v36 = 0.0;
    v35 = 0;
    v34 = 0;
    v33 = 0;
    v32 = 0;
    if (*(float *)&v39 < 0.0 || *(float *)&v39 > 1.0)
    {
      syslog(1, "Chromaticity NOT within the range: (x,y) (%f, %f)", *(float *)&v38, *((float *)&v38 + 1));
      LODWORD(v39) = fmaxf(*(float *)&v39, 0.0);
      LODWORD(v39) = fminf(*(float *)&v39, 1.0);
    }
    v31 = 0;
    if (*(_QWORD *)(v48 + 96))
      v31 = (*(_BYTE *)(*(_QWORD *)(v48 + 96) + 302) & 1) != 0;
    v30 = 9;
    if (*(float *)&v39 >= 0.0)
    {
      for (i = 1; i < v30; ++i)
      {
        if (*(float *)&v39 <= BB_PieceWise_Table[i])
        {
          *(float *)&v33 = BB_PieceWise_Table[i - 1];
          *((float *)&v33 + 1) = BB_PieceWise_Table[i - 1 + v30];
          *(float *)&v32 = BB_PieceWise_Table[i];
          *((float *)&v32 + 1) = BB_PieceWise_Table[i + v30];
          v36 = cfx_linear_interpolation((float *)&v33, (float *)&v32, *(float *)&v39);
          v35 = i - 1;
          break;
        }
      }
    }
    if (*((float *)&v39 + 1) < v36)
    {
      v9 = compute_projection((float *)&v33, (float *)&v32, (float *)&v39);
      v28 = __PAIR64__(v10, LODWORD(v9));
      v34 = __PAIR64__(v10, LODWORD(v9));
      if (v9 >= *(float *)&v33 || v35 <= 0)
      {
        if (*(float *)&v34 <= *(float *)&v32)
        {
          v39 = v34;
        }
        else
        {
          *(float *)&v33 = BB_PieceWise_Table[v35 + 1];
          *((float *)&v33 + 1) = BB_PieceWise_Table[v35 + 10];
          *(float *)&v32 = BB_PieceWise_Table[v35 + 2];
          *((float *)&v32 + 1) = BB_PieceWise_Table[v35 + 11];
          v13 = compute_projection((float *)&v33, (float *)&v32, (float *)&v39);
          v26 = __PAIR64__(v14, LODWORD(v13));
          v39 = __PAIR64__(v14, LODWORD(v13));
        }
      }
      else
      {
        *(float *)&v33 = BB_PieceWise_Table[v35 - 1];
        *((float *)&v33 + 1) = BB_PieceWise_Table[v35 + 8];
        *(float *)&v32 = BB_PieceWise_Table[v35];
        *((float *)&v32 + 1) = BB_PieceWise_Table[v35 + 9];
        v11 = compute_projection((float *)&v33, (float *)&v32, (float *)&v39);
        v27 = __PAIR64__(v12, LODWORD(v11));
        v39 = __PAIR64__(v12, LODWORD(v11));
      }
    }
    if (*(float *)&v39 != *(float *)&v38 || *((float *)&v39 + 1) != *((float *)&v38 + 1))
      syslog(7, "CCT RESTRICTION @%fK: xy (%f, %f) -> (%f, %f)", v37, *(float *)&v38, *((float *)&v38 + 1), *(float *)&v39, *((float *)&v39 + 1));
    v25 = 1120403456;
    CFXChromaticity2Tristimulus((float *)&v39, (float *)&v53, 100.0);
    memset(v24, 0, 12);
    CFXTristimulus2Lab((float *)&v53, (float *)v24);
    if (v45)
    {
      v23 = *(_QWORD *)((char *)v24 + 4);
      _CFXStickToPolygon(v45, v44, (float *)&dword_1B546151C, (float *)v24 + 1, (float *)v24 + 1);
      if (*(float *)&v23 != *((float *)v24 + 1) && *((float *)&v23 + 1) != *(float *)&v24[1])
        syslog(7, "Restrict: (%f, %f) -> (%f, %f)\n", *(float *)&v23, *(float *)&v23, *((float *)v24 + 1), *(float *)&v24[1]);
    }
    v22 = 0;
    v15 = (float)(0.0 * 0.0) + (1.0 - 0.0) * *((float *)v24 + 1);
    *((float *)v24 + 1) = v15;
    v16 = (float)(0.0 * 0.0) + (1.0 - 0.0) * *(float *)&v24[1];
    *(float *)&v24[1] = v16;
    CFXLab2Tristimulus((float *)v24, (float *)&v53);
    if (v31)
    {
      *(_QWORD *)v21 = 0;
      CFXTristimulus2Chromaticity((float *)&v53, v21);
      CFXChromaticity2uv(v21, (float *)&v52);
      v20 = v52;
      _CFXClampToCurve((uint64_t)&MitigatedDaylightCurve, 13, (float *)&v20);
      v52 = v20;
      CFXuv2Chromaticity((float *)&v52, v21);
      CFXChromaticity2Tristimulus(v21, (float *)&v53, *((float *)&v53 + 1));
    }
  }
  _CFXGetMatrix(v48, (float *)&v53, (uint64_t)v46, (float *)(v48 + 2128));
  v51[2] = 1.0;
  v51[1] = 1.0;
  v51[0] = 1.0;
  v49 = 0;
  v50 = 0;
  Mul33MatrixBy31Vector(v46, v51, (float *)&v49);
  v19 = v46;
  v17 = MaxOfVector((float *)&v49);
  return Div33MatrixByScalar((uint64_t)v19, (uint64_t)v46, v17);
}

float cfx_linear_interpolation(float *a1, float *a2, float a3)
{
  if (a1 && a2)
    return a1[1] + (float)((float)((float)(a2[1] - a1[1]) / (float)(*a2 - *a1)) * (float)(a3 - *a1));
  syslog(1, "%s: Invalid input params: p1=>0x%x, p2=>0x%x\n", "cfx_linear_interpolation", (_DWORD)a1, (_DWORD)a2);
  return -1.0;
}

uint64_t _CFXRestrictLowAmbientColor(uint64_t a1, uint64_t a2, float *a3, float *a4, _BYTE *a5)
{
  float v5;
  double v6;
  float v7;
  float v8;
  uint64_t v10;
  float *v11;
  uint64_t *v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  _BYTE *v20;
  float *v21;
  float *v22;
  float *v23;
  uint64_t v24;

  v24 = a1;
  v23 = (float *)a2;
  v22 = a3;
  v21 = a4;
  v20 = a5;
  v19 = 0;
  v18 = 0;
  *a5 = 0;
  if (v23[4] >= 0.1958)
    *v21 = CFXChromaticity2CCT(v23 + 3);
  else
    *v21 = v23[5];
  syslog(7, "[%s:%s] xy=(%f,%f), CCT = %f, CCT1 = %f", "ColorEffects.c", "_CFXRestrictLowAmbientColor", v23[3], v23[4], *v21, v23[5]);
  if (v24 && *(_QWORD *)(v24 + 96))
  {
    v17 = 0;
    v17 = *(_QWORD *)(v24 + 96);
    v16 = 0.0;
    v5 = v23[1] * 3.14159265;
    v16 = v5;
    if ((*(_BYTE *)(*(_QWORD *)(v24 + 96) + 302) & 1) != 0)
    {
      v19 = _CFXRestrictLowAmbientColorWithMitigation(v24, (uint64_t)v23, (float *)&v18, v20) & 1;
    }
    else if (v16 <= *(float *)(v17 + 196))
    {
      v15 = 0;
      if (v16 > 2.0 && *v21 >= 6000.0)
      {
        v15 = 0x3EA872D23EA01C4CLL;
        if (vabdd_f64(*(float *)(v24 + 92), 6504.0) > 1000.0)
          *v20 = 1;
      }
      else
      {
        v15 = *(_QWORD *)(v17 + 212);
        if (fabs((float)(*(float *)(v24 + 92) - 4000.0)) > 1000.0)
          *v20 = 1;
      }
      if (v16 > *(float *)(v17 + 192))
      {
        v14 = 0;
        v14 = *(_QWORD *)(v23 + 3);
        v13 = 0.0;
        v13 = (float)(*(float *)(v17 + 196) - v16) / (float)(*(float *)(v17 + 196) - *(float *)(v17 + 192));
        *(float *)&v18 = (float)((float)(1.0 - v13) * *(float *)&v14) + (float)(v13 * *(float *)&v15);
        *((float *)&v18 + 1) = (float)((float)(1.0 - v13) * *((float *)&v14 + 1)) + (float)(v13 * *((float *)&v15 + 1));
        v6 = *v21;
        v12 = &v10;
        syslog(7, "RESTRICTION in Lux=%f: CCT %f +Fixed (alpha=%f) => RC = (%f, %f), xyFixed = (%f, %f), xy = (%f, %f)\n", v16, v6, v13, *(float *)&v14, *((float *)&v14 + 1), *(float *)&v15, *((float *)&v15 + 1), *(float *)&v18, *((float *)&v18 + 1));
      }
      else
      {
        v18 = v15;
        syslog(7, "RESTRICTION in Lux=%f: xyFixed xy = (%f, %f)\n", v16, *(float *)&v15, *((float *)&v15 + 1));
      }
      v19 = 1;
    }
  }
  if ((v19 & 1) != 0)
  {
    v7 = fmaxf(v23[1], 1.0);
    v11 = (float *)&v18;
    CFXChromaticity2Tristimulus((float *)&v18, v22, v7);
    v8 = CFXChromaticity2CCT(v11);
    *v21 = v8;
  }
  else
  {
    __memcpy_chk();
  }
  return v19 & 1;
}

float CFXChromaticity2CCT(float *a1)
{
  float v1;

  v1 = (*a1 - 0.332) / (0.1858 - a1[1]);
  return (float)(int)((float)((float)((float)(3525.0 * v1) * v1) + (float)((float)((float)(449.0 * v1) * v1) * v1))
                    + 6823.3 * v1
                    + 5520.33);
}

uint64_t _CFXRestrictLowAmbientColorWithMitigation(uint64_t a1, uint64_t a2, float *a3, _BYTE *a4)
{
  float v4;
  float v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  v10 = 0;
  *a4 = 0;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      v9 = *(_QWORD *)(a1 + 96);
      v4 = *(float *)(a2 + 4) * 3.14159265;
      if (v4 <= *(float *)(v9 + 196))
      {
        if (v4 > 2.0)
          v8 = 0x3EACE8533EA4B5DDLL;
        else
          v8 = *(_QWORD *)(v9 + 212);
        if (v4 > *(float *)(v9 + 192))
        {
          v7 = *(_QWORD *)(a2 + 12);
          v6 = (float)(*(float *)(v9 + 196) - v4) / (float)(*(float *)(v9 + 196) - *(float *)(v9 + 192));
          *a3 = (float)((float)(1.0 - v6) * *(float *)&v7) + (float)(v6 * *(float *)&v8);
          a3[1] = (float)((float)(1.0 - v6) * *((float *)&v7 + 1)) + (float)(v6 * *((float *)&v8 + 1));
        }
        else
        {
          *(_QWORD *)a3 = v8;
        }
        v10 = 1;
        *a4 = 1;
      }
    }
  }
  return v10 & 1;
}

float _CFXIdentity(float *a1)
{
  float result;

  __memset_chk();
  result = 1.0;
  a1[8] = 1.0;
  a1[4] = 1.0;
  *a1 = 1.0;
  return result;
}

void _CFXClampToCurve(uint64_t a1, int a2, float *a3)
{
  float v3;
  float v4;
  unsigned int v5;
  float v6;
  unsigned int v7;
  float v8;
  unsigned int v9;
  float *v10;
  float *v11;
  float v12;
  float v13;
  int i;
  double v15;
  int v16;
  float v17;
  int v18;
  int v19;
  uint64_t v20;
  float v21[3];
  int v22;
  float *v23;
  int v24;
  uint64_t v25;

  v25 = a1;
  v24 = a2;
  v23 = a3;
  v22 = a2;
  *(_QWORD *)v21 = 0;
  v20 = 0;
  if (*a3 >= 0.0)
  {
    v17 = 0.0;
    v16 = -1;
    v15 = 100000.0;
    for (i = 0; i < v22; ++i)
    {
      v13 = *(float *)(v25 + 4 * i) - *v23;
      v3 = *(float *)(v25 + 4 * (i + v22)) - v23[1];
      v12 = (float)(v13 * v13) + (float)(v3 * v3);
      if (v12 < v15)
      {
        v15 = v12;
        v16 = i;
      }
    }
    if (v16 >= 0)
      v17 = *(float *)(v25 + 4 * v16);
    if (*v23 < v17 && v16 > 0 || v16 == v24)
    {
      v19 = v16 - 1;
      v18 = v16;
    }
    else
    {
      v19 = v16;
      v18 = v16 + 1;
    }
    v21[0] = *(float *)(v25 + 4 * v19);
    v21[1] = *(float *)(v25 + 4 * (v19 + v22));
    LODWORD(v20) = *(_DWORD *)(v25 + 4 * v18);
    HIDWORD(v20) = *(_DWORD *)(v25 + 4 * (v18 + v22));
    v4 = compute_projection(v21, (float *)&v20, v23);
    if (v4 >= v21[0] || v19 <= 0)
    {
      if (v4 <= *(float *)&v20)
      {
        *(_QWORD *)v23 = __PAIR64__(v5, LODWORD(v4));
      }
      else
      {
        v21[0] = *(float *)(v25 + 4 * (v19 + 1));
        v21[1] = *(float *)(v25 + 4 * (v19 + 1 + v22));
        LODWORD(v20) = *(_DWORD *)(v25 + 4 * (v19 + 2));
        HIDWORD(v20) = *(_DWORD *)(v25 + 4 * (v19 + 2 + v22));
        v10 = v23;
        v8 = compute_projection(v21, (float *)&v20, v23);
        *(_QWORD *)v10 = __PAIR64__(v9, LODWORD(v8));
        if (*v23 < v21[0] && v19 > 0)
          *(_QWORD *)v23 = *(_QWORD *)v21;
      }
    }
    else
    {
      v21[0] = *(float *)(v25 + 4 * (v19 - 1));
      v21[1] = *(float *)(v25 + 4 * (v19 - 1 + v22));
      LODWORD(v20) = *(_DWORD *)(v25 + 4 * v19);
      HIDWORD(v20) = *(_DWORD *)(v25 + 4 * (v19 + v22));
      v11 = v23;
      v6 = compute_projection(v21, (float *)&v20, v23);
      *(_QWORD *)v11 = __PAIR64__(v7, LODWORD(v6));
      if (*v23 > *(float *)&v20)
        *(_QWORD *)v23 = v20;
    }
  }
}

float compute_projection(float *a1, float *a2, float *a3)
{
  float v4;

  v4 = 0.0;
  if (a1 && a2 && a3)
    return *a3
         - (float)((float)((float)-(float)((float)((float)(*a2 - *a1) * (float)(a3[1] - a1[1]))
                                         - (float)((float)(a2[1] - a1[1]) * (float)(*a3 - *a1)))
                         / (float)((float)((float)(a2[1] - a1[1]) * (float)(a2[1] - a1[1]))
                                 + (float)((float)(*a2 - *a1) * (float)(*a2 - *a1))))
                 * (float)(a2[1] - a1[1]));
  syslog(1, "%s: Invalid input params: p1=>0x%x, p2=>0x%x, p=>0x%x\n", "compute_projection", (_DWORD)a1, (_DWORD)a2, (_DWORD)a3);
  return v4;
}

float CFXuv2Chromaticity(float *a1, float *a2)
{
  float result;
  float v3;

  v3 = 12.0 - (float)((float)(16.0 * a1[1]) - (float)(6.0 * *a1));
  *a2 = (float)(9.0 * *a1) / v3;
  result = (float)(4.0 * a1[1]) / v3;
  a2[1] = result;
  return result;
}

uint64_t _CFXCheckStats(uint64_t a1, int a2, float *a3, double a4)
{
  float v4;
  float v5;
  float v7;
  double v8;
  double *v9;
  uint64_t v10;
  char v11;

  v11 = 0;
  while (*(_QWORD *)(a1 + 8) && **(double **)(a1 + 8) < a4 - *(double *)(a1 + 32))
  {
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
    free(*(void **)(a1 + 8));
    *(_QWORD *)(a1 + 8) = v10;
    --*(_DWORD *)(a1 + 24);
    syslog(7, "REMOVING STAT\n");
    if (!*(_DWORD *)(a1 + 24))
      *(_QWORD *)(a1 + 16) = 0;
  }
  if (*(_QWORD *)(a1 + 16) && a4 - **(double **)(a1 + 16) > *(float *)(a1 + 44))
  {
    syslog(7, "CLEARING STATS\n");
    _CFXClearStats(a1);
  }
  if (a2 != *(_DWORD *)a1 && a2 != 3)
  {
    v9 = (double *)malloc_type_malloc(0x10uLL, 0x10200405730B0C9uLL);
    v9[1] = 0.0;
    *v9 = a4;
    if (*(_QWORD *)(a1 + 8) && *(_QWORD *)(a1 + 16))
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8) = v9;
      *(_QWORD *)(a1 + 16) = v9;
    }
    else
    {
      *(_QWORD *)(a1 + 8) = v9;
      *(_QWORD *)(a1 + 16) = v9;
    }
    ++*(_DWORD *)(a1 + 24);
    *(_DWORD *)a1 = a2;
    syslog(7, "ADDING %d STAT\n", *(_DWORD *)(a1 + 24));
  }
  *a3 = 0.0;
  if (*(_QWORD *)(a1 + 8))
  {
    if (*(_QWORD *)(a1 + 16))
    {
      v8 = **(double **)(a1 + 16) - **(double **)(a1 + 8);
      syslog(7, "DELTAT %f\n", v8);
      if (*(int *)(a1 + 24) >= 5)
      {
        v4 = (float)((float)*(int *)(a1 + 24) - 1.0) / v8;
        v7 = v4;
        syslog(7, "Freq %f Hz\n", v4);
        v5 = 3.0 / v7;
        *(float *)(a1 + 44) = v5;
        syslog(7, "Switch time %f\n", *(float *)(a1 + 44));
        *a3 = 10.0 / v7;
        v11 = 1;
      }
    }
  }
  return v11 & 1;
}

uint64_t _CFXSetTarget(uint64_t a1, float *a2, char a3, char a4, float a5, float a6)
{
  void (*v7)(uint64_t, uint64_t);
  uint64_t v8;
  NSObject *v9;
  os_log_type_t v10;
  char v11;
  int v12;
  uint8_t v13[7];
  os_log_type_t v14;
  NSObject *v15;
  os_log_type_t v16;
  os_log_t v17;
  BOOL v18;
  double Current;
  float v20;
  char v21;
  char v22;
  float v23;
  float *v24;
  uint64_t v25;
  uint8_t v26[24];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v25 = a1;
  v24 = a2;
  v23 = a5;
  v22 = a3 & 1;
  v21 = a4 & 1;
  v20 = a6;
  if (*(float *)(a1 + 2252) >= 0.0)
    v23 = *(float *)(v25 + 2252);
  Current = CFAbsoluteTimeGetCurrent();
  v18 = 0;
  v18 = Current < *(double *)(v25 + 136);
  if (*(_QWORD *)(v25 + 96) && (*(_BYTE *)(*(_QWORD *)(v25 + 96) + 303) & 1) != 0)
  {
    if (*(float *)(*(_QWORD *)(v25 + 96) + 332) == *(float *)(*(_QWORD *)(v25 + 96) + 336))
    {
      v15 = MEMORY[0x1E0C81028];
      v14 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v9 = v15;
        v10 = v14;
        __os_log_helper_16_0_0(v13);
        _os_log_impl(&dword_1B5291000, v9, v10, "BaselineHarmony: Update WP, NO change in ALS strength", v13, 2u);
      }
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(v25 + 96) + 328) = 0;
      *(_DWORD *)(*(_QWORD *)(v25 + 96) + 340) = *(_DWORD *)(*(_QWORD *)(v25 + 96) + 336);
      *(_DWORD *)(*(_QWORD *)(v25 + 96) + 332) = *(_DWORD *)(*(_QWORD *)(v25 + 96) + 332);
      *(double *)(*(_QWORD *)(v25 + 96) + 320) = Current;
      *(double *)(*(_QWORD *)(v25 + 96) + 312) = v23;
      v17 = (os_log_t)MEMORY[0x1E0C81028];
      v16 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v26, COERCE__INT64(*(float *)(*(_QWORD *)(v25 + 96) + 336)), COERCE__INT64(*(float *)(*(_QWORD *)(v25 + 96) + 332)));
        _os_log_impl(&dword_1B5291000, v17, v16, "BaselineHarmony: Set new target, alsStrength current = %f, target: %f", v26, 0x16u);
      }
    }
  }
  if (!v18 || v23 == 0.0 || (v22 & 1) != 0 || (*(_BYTE *)(v25 + 144) & 1) != 0)
  {
    *(_DWORD *)(v25 + 192) = 9;
    __memcpy_chk();
    __memcpy_chk();
    __memcpy_chk();
    v12 = 0;
    _CFXGetWPFromMatrix(v25, v24, (_QWORD *)(v25 + 200), &v12);
    *(float *)(v25 + 152) = v23;
    *(float *)(v25 + 196) = v20;
    *(_BYTE *)(v25 + 144) = (v22 ^ 1) & 1;
    *(double *)(v25 + 136) = Current + v23;
    v11 = 0;
    if ((*(_BYTE *)(v25 + 364) & 1) != 0)
    {
      __memcpy_chk();
      __memcpy_chk();
      *(double *)(v25 + 368) = *(float *)(v25 + 152);
      *(double *)(v25 + 376) = Current;
      v11 = 1;
      *(_BYTE *)(v25 + 384) = 0;
    }
    if (*(_QWORD *)(v25 + 328))
    {
      v7 = *(void (**)(uint64_t, uint64_t))(v25 + 328);
      v8 = *(_QWORD *)(v25 + 336);
      if ((v11 & 1) != 0)
        v7(v8, 0);
      else
        v7(v8, v25 + 152);
    }
  }
  return 1;
}

uint64_t __os_log_helper_16_0_2_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  return result;
}

float ___ZN4AABC24_UpdateAggregateFunctionEP20__IOHIDServiceClientPNS_3ALSE_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  float result;
  float v4;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(a3, "floatValue");
    *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = fmaxf(*(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)+ 24), v4);
    result = fminf(*(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), v4);
    *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = result;
  }
  return result;
}

uint64_t __os_log_helper_16_2_18_8_0_8_0_8_0_8_0_8_0_8_32_8_32_8_0_8_32_8_32_8_0_8_0_8_0_8_32_8_32_8_32_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  uint64_t result;

  result = a9;
  *(_BYTE *)a1 = 2;
  *(_BYTE *)(a1 + 1) = 18;
  *(_BYTE *)(a1 + 2) = 0;
  *(_BYTE *)(a1 + 3) = 8;
  *(_QWORD *)(a1 + 4) = a2;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 13) = 8;
  *(_QWORD *)(a1 + 14) = a3;
  *(_BYTE *)(a1 + 22) = 0;
  *(_BYTE *)(a1 + 23) = 8;
  *(_QWORD *)(a1 + 24) = a4;
  *(_BYTE *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 33) = 8;
  *(_QWORD *)(a1 + 34) = a5;
  *(_BYTE *)(a1 + 42) = 0;
  *(_BYTE *)(a1 + 43) = 8;
  *(_QWORD *)(a1 + 44) = a6;
  *(_BYTE *)(a1 + 52) = 32;
  *(_BYTE *)(a1 + 53) = 8;
  *(_QWORD *)(a1 + 54) = a7;
  *(_BYTE *)(a1 + 62) = 32;
  *(_BYTE *)(a1 + 63) = 8;
  *(_QWORD *)(a1 + 64) = a8;
  *(_BYTE *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 73) = 8;
  *(_QWORD *)(a1 + 74) = a9;
  *(_BYTE *)(a1 + 82) = 32;
  *(_BYTE *)(a1 + 83) = 8;
  *(_QWORD *)(a1 + 84) = a10;
  *(_BYTE *)(a1 + 92) = 32;
  *(_BYTE *)(a1 + 93) = 8;
  *(_QWORD *)(a1 + 94) = a11;
  *(_BYTE *)(a1 + 102) = 0;
  *(_BYTE *)(a1 + 103) = 8;
  *(_QWORD *)(a1 + 104) = a12;
  *(_BYTE *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 113) = 8;
  *(_QWORD *)(a1 + 114) = a13;
  *(_BYTE *)(a1 + 122) = 0;
  *(_BYTE *)(a1 + 123) = 8;
  *(_QWORD *)(a1 + 124) = a14;
  *(_BYTE *)(a1 + 132) = 32;
  *(_BYTE *)(a1 + 133) = 8;
  *(_QWORD *)(a1 + 134) = a15;
  *(_BYTE *)(a1 + 142) = 32;
  *(_BYTE *)(a1 + 143) = 8;
  *(_QWORD *)(a1 + 144) = a16;
  *(_BYTE *)(a1 + 152) = 32;
  *(_BYTE *)(a1 + 153) = 8;
  *(_QWORD *)(a1 + 154) = a17;
  *(_BYTE *)(a1 + 162) = 0;
  *(_BYTE *)(a1 + 163) = 8;
  *(_QWORD *)(a1 + 164) = a18;
  *(_BYTE *)(a1 + 172) = 0;
  *(_BYTE *)(a1 + 173) = 8;
  *(_QWORD *)(a1 + 174) = a19;
  return result;
}

uint64_t __DisplayGetCPMSAPLTableInternal(uint64_t a1)
{
  id v1;
  id v2;
  id v3;
  id v4;
  id v5;
  id v6;
  id v7;
  id v8;
  id v9;
  id v10;
  uint64_t v12;
  os_log_t v14;
  os_log_type_t v15[4];
  uint8_t *v16;
  NSObject *v17;
  os_log_t v18;
  os_log_t v19;
  os_log_type_t v20[4];
  uint8_t *v21;
  NSObject *inited;
  os_log_t v23;
  uint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  int *v27;
  os_log_t log;
  os_log_type_t type[4];
  uint8_t *buf;
  NSObject *v31;
  os_log_t v32;
  uint8_t v33[7];
  os_log_type_t v34;
  os_log_t v35;
  os_log_type_t v36[7];
  os_log_type_t v37;
  os_log_t oslog;
  void *v39;
  id v40;
  unsigned int nn;
  id v42;
  id v43;
  id v44;
  unsigned int mm;
  id v46;
  unsigned int kk;
  id v48;
  id v49;
  id v50;
  id v51;
  id v52;
  int jj;
  int ii;
  int n;
  unsigned int m;
  unsigned int k;
  int j;
  int i;
  unsigned int *v60;
  size_t v61;
  int v62;
  os_log_type_t v63;
  os_log_t v64;
  float v65;
  unsigned int v66;
  CFTypeRef v67;
  char v68;
  uint64_t v69;
  uint8_t v70[24];
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v69 = a1;
  v68 = 1;
  if (*(_DWORD *)(a1 + 108))
  {
    v67 = 0;
    v67 = IORegistryEntrySearchCFProperty(*(_DWORD *)(v69 + 108), "IOService", CFSTR("power-lut-vbatt-cur-nominal"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    v66 = 0;
    v65 = 1.0;
    if ((_DisplayGetUint32FromCFDataAndRelease(v67, &v66) & 1) != 0
      && v66
      && *(float *)(v69 + 12176) != 0.0
      && (DisplayHasDCP(v69) & 1) != 0)
    {
      v65 = *(float *)(v69 + 12176) / (float)((float)v66 / 1000.0);
      v64 = 0;
      if (_logHandle)
      {
        v32 = (os_log_t)_logHandle;
      }
      else
      {
        v31 = (_COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log());
        v32 = v31;
      }
      v64 = v32;
      v63 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
      {
        log = v64;
        *(_DWORD *)type = v63;
        buf = v70;
        __os_log_helper_16_0_1_8_0((uint64_t)v70, COERCE__INT64(v65));
        _os_log_impl(&dword_1B5291000, v64, v63, "CPMS table scalar = %f", v70, 0xCu);
      }
    }
    v27 = &v62;
    v62 = 0;
    v61 = 0;
    v60 = 0;
    v67 = IORegistryEntrySearchCFProperty(*(_DWORD *)(v69 + 108), "IOService", CFSTR("power-lut-data-x"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if ((_DisplayGetUint32FromCFDataAndRelease(v67, &v62) & 1) != 0)
      *(_DWORD *)(v69 + 1660) = v62;
    else
      v68 = 0;
    v67 = IORegistryEntrySearchCFProperty(*(_DWORD *)(v69 + 108), "IOService", CFSTR("power-lut-data-y"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if ((_DisplayGetUint32FromCFDataAndRelease(v67, &v62) & 1) != 0)
      *(_DWORD *)(v69 + 1656) = v62;
    else
      v68 = 0;
    v67 = IORegistryEntrySearchCFProperty(*(_DWORD *)(v69 + 108), "IOService", CFSTR("power-lut-data-xindex"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (v67)
    {
      v60 = (unsigned int *)_DisplayCreateUint32ArrayFromCFData(v67, &v61);
      for (i = 0; i < v61; ++i)
        *(float *)(v69 + 1868 + 4 * i) = (float)v60[i];
      if (v60)
        free(v60);
      CFRelease(v67);
    }
    else
    {
      v68 = 0;
    }
    v67 = IORegistryEntrySearchCFProperty(*(_DWORD *)(v69 + 108), "IOService", CFSTR("power-lut-data-yindex"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (v67)
    {
      v60 = (unsigned int *)_DisplayCreateUint32ArrayFromCFData(v67, &v61);
      if (v60)
      {
        for (j = 0; j < v61; ++j)
          *(float *)(v69 + 1668 + 4 * j) = (float)v60[j];
        free(v60);
      }
      else
      {
        v68 = 0;
      }
      CFRelease(v67);
    }
    else
    {
      v68 = 0;
    }
    v67 = IORegistryEntrySearchCFProperty(*(_DWORD *)(v69 + 108), "IOService", CFSTR("power-lut-data-lut"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (v67)
    {
      v60 = (unsigned int *)_DisplayCreateUint32ArrayFromCFData(v67, &v61);
      if (v60)
      {
        for (k = 0; k < *(_DWORD *)(v69 + 1656); ++k)
        {
          for (m = 0; m < *(_DWORD *)(v69 + 1660); ++m)
            *(float *)(v69 + 2068 + 200 * (int)k + 4 * (int)m) = (float)v60[m * *(_DWORD *)(v69 + 1656) + k] * v65;
        }
        free(v60);
      }
      else
      {
        v68 = 0;
      }
      CFRelease(v67);
    }
    else
    {
      v68 = 0;
    }
  }
  else
  {
    v68 = 0;
  }
  if ((v68 & 1) == 0)
  {
    for (n = 0; n < 21; ++n)
    {
      for (ii = 0; ii < 20; ++ii)
        *(_DWORD *)(v69 + 2068 + 200 * ii + 4 * n) = CPMSPowerModel[20 * n + ii];
      *(float *)(v69 + 1868 + 4 * n) = (float)NitIndexTable[n];
    }
    for (jj = 0; jj < 20; ++jj)
      *(float *)(v69 + 1668 + 4 * jj) = (float)APLIndexTable[jj];
    *(_DWORD *)(v69 + 1660) = 21;
    *(_DWORD *)(v69 + 1656) = 20;
  }
  v52 = 0;
  v25 = 0x1E0C99000uLL;
  v1 = objc_alloc(MEMORY[0x1E0C99DE8]);
  v52 = (id)objc_msgSend(v1, "initWithCapacity:", *(unsigned int *)(v69 + 1660));
  v51 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  v50 = 0;
  v2 = objc_alloc(MEMORY[0x1E0C99DE8]);
  v50 = (id)objc_msgSend(v2, "initWithCapacity:", *(unsigned int *)(v69 + 1656));
  v49 = 0;
  v26 = 0x1E0CB3000uLL;
  v3 = objc_alloc(MEMORY[0x1E0CB37E8]);
  v49 = (id)objc_msgSend(v3, "initWithUnsignedInt:", *(unsigned int *)(v69 + 1660));
  v48 = 0;
  v4 = objc_alloc(MEMORY[0x1E0CB37E8]);
  v48 = (id)objc_msgSend(v4, "initWithUnsignedInt:", *(unsigned int *)(v69 + 1656));
  if (v52 && v51 && v50 && v49 && v48)
  {
    for (kk = 0; kk < *(_DWORD *)(v69 + 1656); ++kk)
    {
      v46 = 0;
      v5 = objc_alloc(MEMORY[0x1E0C99DE8]);
      v46 = (id)objc_msgSend(v5, "initWithCapacity:", *(unsigned int *)(v69 + 1660));
      for (mm = 0; mm < *(_DWORD *)(v69 + 1660); ++mm)
      {
        v44 = 0;
        v6 = objc_alloc(MEMORY[0x1E0CB37E8]);
        v44 = (id)objc_msgSend(v6, "initWithUnsignedInt:", *(float *)(v69 + 2068 + 200 * (int)kk + 4 * (int)mm));
        objc_msgSend(v46, "addObject:", v44);

      }
      v43 = 0;
      v7 = objc_alloc(MEMORY[0x1E0CB3940]);
      v43 = (id)objc_msgSend(v7, "initWithFormat:", CFSTR("%1.3f"), *(float *)(v69 + 1668 + 4 * (int)kk));
      objc_msgSend(v51, "setValue:forKey:", v46, v43);

      v42 = 0;
      v8 = objc_alloc(MEMORY[0x1E0CB37E8]);
      v42 = (id)objc_msgSend(v8, "initWithUnsignedInt:", *(float *)(v69 + 1668 + 4 * (int)kk));
      objc_msgSend(v50, "addObject:", v42);

    }
    for (nn = 0; nn < *(_DWORD *)(v69 + 1660); ++nn)
    {
      v40 = 0;
      v9 = objc_alloc(MEMORY[0x1E0CB37E8]);
      v40 = (id)objc_msgSend(v9, "initWithUnsignedInt:", *(float *)(v69 + 1868 + 4 * (int)nn));
      objc_msgSend(v52, "addObject:", v40);

    }
    if (*(_DWORD *)(v69 + 1660))
      *(_DWORD *)(v69 + 1664) = *(_DWORD *)(v69 + 1868 + 4 * (*(_DWORD *)(v69 + 1660) - 1));
    v39 = 0;
    v10 = objc_alloc(MEMORY[0x1E0C99D80]);
    v24 = &v12;
    v39 = (void *)objc_msgSend(v10, "initWithObjectsAndKeys:", v52, CFSTR("Nits"), v51, CFSTR("Watts"), v49, CFSTR("TableSize"), v50, CFSTR("APL"), v48, CFSTR("APLSize"), 0);
    if (v39)
    {
      v68 = 1;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v69 + 192), CFSTR("CPMSAPLLUT"), v39);

    }
    else
    {
      oslog = 0;
      if (_logHandle)
      {
        v23 = (os_log_t)_logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v23 = inited;
      }
      oslog = v23;
      v37 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        v19 = oslog;
        *(_DWORD *)v20 = v37;
        v21 = (uint8_t *)v36;
        __os_log_helper_16_0_0(v36);
        _os_log_error_impl(&dword_1B5291000, v19, v20[0], "CPMS: problem loading budget dict", v21, 2u);
      }
    }
  }
  else
  {
    v35 = 0;
    if (_logHandle)
    {
      v18 = (os_log_t)_logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v17 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v17 = init_default_corebrightness_log();
      v18 = v17;
    }
    v35 = v18;
    v34 = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v14 = v35;
      *(_DWORD *)v15 = v34;
      v16 = v33;
      __os_log_helper_16_0_0(v33);
      _os_log_error_impl(&dword_1B5291000, v14, v15[0], "CPMS: problem loading table values", v33, 2u);
    }
  }
  if (v49)

  if (v48)
  if (v50)

  if (v52)
  if (v51)

  if ((v68 & 1) != 0)
    return v69 + 1656;
  else
    return 0;
}

float CFXGetWPFromMatrix(uint64_t a1, float *a2, _QWORD *a3, _DWORD *a4)
{
  float result;

  if (a1)
    return _CFXGetWPFromMatrix(a1, a2, a3, a4);
  return result;
}

uint64_t _DisplayGetUint32FromCFDataAndRelease(const void *a1, _DWORD *a2)
{
  CFTypeID v3;
  UInt8 buffer[7];
  char v5;
  _DWORD *v6;
  CFTypeRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFRange v12;

  v7 = a1;
  v6 = a2;
  v5 = 0;
  if (a1)
  {
    v3 = CFGetTypeID(v7);
    if (v3 == CFDataGetTypeID())
    {
      *(_DWORD *)buffer = 0;
      if (CFDataGetLength((CFDataRef)v7) == 4)
      {
        v9 = 0;
        v8 = 4;
        v10 = 0;
        v11 = 4;
        v12.location = 0;
        v12.length = 4;
        CFDataGetBytes((CFDataRef)v7, v12, buffer);
        *v6 = *(_DWORD *)buffer;
        v5 = 1;
      }
    }
    CFRelease(v7);
  }
  return v5 & 1;
}

UInt8 *_DisplayCreateUint32ArrayFromCFData(const void *a1, size_t *a2)
{
  CFTypeID v3;
  UInt8 *buffer;
  size_t v5;
  CFRange v8;

  v5 = 0;
  buffer = 0;
  if (a1)
  {
    v3 = CFGetTypeID(a1);
    if (v3 == CFDataGetTypeID())
    {
      v5 = CFDataGetLength((CFDataRef)a1) / 4uLL;
      buffer = (UInt8 *)malloc_type_calloc(v5, 4uLL, 0x100004052888210uLL);
      if (buffer)
      {
        v8.location = 0;
        v8.length = 4 * v5;
        CFDataGetBytes((CFDataRef)a1, v8, buffer);
      }
      else
      {
        v5 = 0;
      }
    }
  }
  *a2 = v5;
  return buffer;
}

uint64_t getMLMultiArrayClass()
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  void (*v13)(uint64_t, uint64_t);
  void (*v14)(uint64_t);
  uint64_t v15;

  v9 = 0;
  v10 = &v9;
  v11 = 1375731712;
  v12 = 48;
  v13 = __Block_byref_object_copy__14;
  v14 = __Block_byref_object_dispose__14;
  v8 = getMLMultiArrayClass_softClass;
  v15 = getMLMultiArrayClass_softClass;
  if (!getMLMultiArrayClass_softClass)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLMultiArrayClass_block_invoke;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLMultiArrayClass_block_invoke((uint64_t)&v2);
  }
  v1 = v10[5];
  _Block_object_dispose(&v9, 8);
  return v1;
}

uint64_t _DisplayCopyPropertyInternal(uint64_t a1, const void *a2)
{
  void *v3;
  void *Value;

  Value = 0;
  if (CFEqual(a2, CFSTR("PendingDisplayNits")))
  {
    Value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (const void *)(a1 + 1252));
  }
  else if (CFEqual(a2, CFSTR("ThermalMitigationLimitingBrightness")))
  {
    if (*(float *)(a1 + 1256) < *(float *)(a1 + 464))
      v3 = (void *)*MEMORY[0x1E0C9AE40];
    else
      v3 = (void *)*MEMORY[0x1E0C9AE50];
    Value = v3;
  }
  else if (CFEqual(a2, CFSTR("EcoModeFactor")))
  {
    Value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (const void *)(a1 + 648));
  }
  else if (CFEqual(a2, CFSTR("AAPLuxDelta")))
  {
    Value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (const void *)(a1 + 12268));
  }
  else if (CFEqual(a2, CFSTR("DominoFactor")))
  {
    Value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (const void *)(a1 + 224));
  }
  if (!Value)
  {
    Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 192), a2);
    if (Value)
      return objc_msgSend(Value, "copy");
  }
  return (uint64_t)Value;
}

float __DisplayPhysicalBrightnessToPowerInternal(uint64_t a1, unsigned int a2, float a3)
{
  float PercentageFromIndex;
  int IndexFromValue;
  int APLIndex;

  if (!*(_DWORD *)(a1 + 1660))
    return 0.0;
  APLIndex = DisplayGetAPLIndex(a1, a2);
  IndexFromValue = __DisplayGetIndexFromValue(0, *(_DWORD *)(a1 + 1660) - 1, a1 + 1868, a3);
  PercentageFromIndex = __DisplayGetPercentageFromIndex(IndexFromValue, *(_DWORD *)(a1 + 1660) - 1, (float *)(a1 + 1868), a3);
  if (IndexFromValue == *(_DWORD *)(a1 + 1660) - 1)
    return *(float *)(a1 + 2068 + 200 * APLIndex + 4 * IndexFromValue);
  else
    return *(float *)(a1 + 2068 + 200 * APLIndex + 4 * IndexFromValue)
         + (float)(PercentageFromIndex
                 * (float)(*(float *)(a1 + 2068 + 200 * APLIndex + 4 * (IndexFromValue + 1))
                         - *(float *)(a1 + 2068 + 200 * APLIndex + 4 * IndexFromValue)));
}

uint64_t DisplayHasDCP(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  dispatch_once_t *v10;

  v8 = a1;
  v2 = MEMORY[0x1E0C809B0];
  v3 = -1073741824;
  v4 = 0;
  v5 = __DisplayHasDCP_block_invoke;
  v6 = &__block_descriptor_40_e5_v8__0l;
  v7 = a1;
  v10 = &DisplayHasDCP_token;
  v9 = &v2;
  if (DisplayHasDCP_token != -1)
    dispatch_once(v10, v9);
  return DisplayHasDCP_hasDCP & 1;
}

float _DisplayGetBrightDotCap(uint64_t a1, float a2)
{
  float v3;
  float v4;
  float v5;
  float v6;
  char v7;
  float v8;

  v8 = *(float *)(a1 + 1544);
  v7 = _DisplayBDMAvailable(a1) & 1;
  if ((*(_BYTE *)(a1 + 1517) & 1) != 0 && (v7 & 1) != 0)
  {
    v6 = *(float *)(a1 + 1152);
    v5 = *(float *)(a1 + 1156);
    v4 = *(float *)(a1 + 1160);
    v3 = *(float *)(a1 + 1164);
    if (a2 > v6)
    {
      if (a2 >= v4)
        return fminf(v3, v8);
      else
        return fminf(v5 + (float)((float)((float)(a2 - v6) * (float)(v3 - v5)) / (float)(v4 - v6)), v8);
    }
    else
    {
      return fminf(v5, v8);
    }
  }
  return v8;
}

float _DisplayComputeEDRNitsCap(uint64_t a1)
{
  float CPMSPowerConstraint;
  float v2;
  uint64_t inited;
  NSObject *v5;
  unsigned int v6;
  unsigned int APLColumnOrDefault;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  uint8_t v14[56];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v9 = *(float *)(a1 + 1544);
  if ((*(_BYTE *)(a1 + 1517) & 1) != 0)
  {
    if ((_DisplayBDMAvailable(a1) & 1) != 0)
      v9 = *(float *)(a1 + 1168);
    v10 = fmaxf(v9, *(float *)(a1 + 1320));
    if (*(float *)(a1 + 12104) != 0.0)
    {
      v8 = *(float *)(a1 + 12108);
      APLColumnOrDefault = DisplayGetAPLColumnOrDefault(a1, 0x64u);
      CPMSPowerConstraint = __DisplayGetCPMSPowerConstraint(a1);
      v10 = fminf(v10, fmaxf(v8, DisplayPowerToPhysicalBrightness(a1, APLColumnOrDefault, CPMSPowerConstraint)));
    }
    if (_logHandle)
    {
      v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v5 = inited;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v14, COERCE__INT64(*(float *)(a1 + 464)), COERCE__INT64(*(float *)(a1 + 528)), COERCE__INT64(*(float *)(a1 + 1320)), COERCE__INT64(*(float *)(a1 + 12108)), COERCE__INT64(v10));
      _os_log_debug_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEBUG, "Superbright EDR restrictions [would be]: CLTM %f, UPO %f, bottom [lower] restriction %f, nits cap hdr: %f, after BDM: %f", v14, 0x34u);
    }
  }
  else
  {
    v11 = fminf(fminf(v9, *(float *)(a1 + 464)), *(float *)(a1 + 528));
    if (*(float *)(a1 + 1140) < 1.0)
      v11 = *(float *)(a1 + 1320) + (float)(*(float *)(a1 + 1140) * (float)(v11 - *(float *)(a1 + 1320)));
    if ((*(_BYTE *)(a1 + 12512) & 1) == 0 && (*(_BYTE *)(a1 + 12515) & 1) == 0)
      *(float *)(a1 + 12528) = 1.0;
    v10 = fmaxf(v11, *(float *)(a1 + 1320));
    if (*(float *)(a1 + 12104) != 0.0)
    {
      v12 = *(float *)(a1 + 12108);
      v6 = DisplayGetAPLColumnOrDefault(a1, 0x64u);
      v2 = __DisplayGetCPMSPowerConstraint(a1);
      v10 = fmaxf(v12, DisplayPowerToPhysicalBrightness(a1, v6, v2));
    }
  }
  if (*(_DWORD *)(a1 + 224))
    v10 = fminf(v10, *(float *)(a1 + 724));
  *(_DWORD *)(a1 + 1132) = (int)(float)(v10 * 65536.0);
  return v10;
}

uint64_t _DisplayBDMAvailable(uint64_t a1)
{
  char v2;

  v2 = 0;
  if ((DisplayRequiresBDM(a1) & 1) != 0)
  {
    v2 = 0;
    if ((*(_BYTE *)(a1 + 1144) & 1) == 0)
      v2 = *(_BYTE *)(a1 + 1176);
  }
  return v2 & 1;
}

uint64_t DisplayRequiresBDM(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  dispatch_once_t *v10;

  v8 = a1;
  v2 = MEMORY[0x1E0C809B0];
  v3 = -1073741824;
  v4 = 0;
  v5 = __DisplayRequiresBDM_block_invoke;
  v6 = &__block_descriptor_40_e5_v8__0l;
  v7 = a1;
  v10 = &DisplayRequiresBDM_token;
  v9 = &v2;
  if (DisplayRequiresBDM_token != -1)
    dispatch_once(v10, v9);
  return DisplayRequiresBDM_requiresBDM & 1;
}

uint64_t DisplayGetAPLColumnOrDefault(uint64_t a1, unsigned int a2)
{
  unsigned int APLColumn;

  APLColumn = DisplayGetAPLColumn(a1);
  if (APLColumn == -1)
    return a2;
  else
    return APLColumn;
}

uint64_t DisplayGetAPLColumn(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  dispatch_once_t *v10;

  v8 = a1;
  v2 = MEMORY[0x1E0C809B0];
  v3 = -1073741824;
  v4 = 0;
  v5 = __DisplayGetAPLColumn_block_invoke;
  v6 = &__block_descriptor_40_e5_v8__0l;
  v7 = a1;
  v10 = &DisplayGetAPLColumn_token;
  v9 = &v2;
  if (DisplayGetAPLColumn_token != -1)
    dispatch_once(v10, v9);
  return DisplayGetAPLColumn_column;
}

float __DisplayGetCPMSPowerConstraint(uint64_t a1)
{
  unsigned int APLColumnOrDefault;
  float v4;

  if (*(float *)(a1 + 528) <= *(float *)(a1 + 524))
  {
    v4 = *(float *)(a1 + 12076);
  }
  else
  {
    APLColumnOrDefault = DisplayGetAPLColumnOrDefault(a1, 0x64u);
    v4 = DisplayPhysicalBrightnessToPower(a1, APLColumnOrDefault, *(float *)(a1 + 528));
  }
  if ((*(_BYTE *)(a1 + 12080) & 1) != 0)
    return *(float *)(a1 + 12072);
  else
    return fminf(*(float *)(a1 + 12072), v4);
}

float DisplayPowerToPhysicalBrightness(uint64_t a1, unsigned int a2, float a3)
{
  return __DisplayPowerToPhysicalBrightnessInternal(a1, a2, a3);
}

float __DisplayPowerToPhysicalBrightnessInternal(uint64_t a1, unsigned int a2, float a3)
{
  float v4;
  int APLIndex;
  float PercentageFromIndex;
  int IndexFromValue;
  float v8;

  if (!*(_DWORD *)(a1 + 1660))
    return 0.0;
  APLIndex = DisplayGetAPLIndex(a1, a2);
  IndexFromValue = __DisplayGetIndexFromValue(0, *(_DWORD *)(a1 + 1660) - 1, a1 + 2068 + 200 * APLIndex, a3);
  PercentageFromIndex = __DisplayGetPercentageFromIndex(IndexFromValue, *(_DWORD *)(a1 + 1660) - 1, (float *)(a1 + 2068 + 200 * APLIndex), a3);
  if (IndexFromValue == *(_DWORD *)(a1 + 1660) - 1)
    v4 = *(float *)(a1 + 1868 + 4 * IndexFromValue);
  else
    v4 = *(float *)(a1 + 1868 + 4 * IndexFromValue)
       + (float)(PercentageFromIndex
               * (float)(*(float *)(a1 + 1868 + 4 * (IndexFromValue + 1))
                       - *(float *)(a1 + 1868 + 4 * IndexFromValue)));
  v8 = v4;
  if (v4 > *(float *)(a1 + 1664) * 0.95)
    return fmaxf(v4, *(float *)(a1 + 1544));
  return v8;
}

float __DisplayGetPercentageFromIndex(int a1, int a2, float *a3, float a4)
{
  if (a4 < *a3 || a1 == a2)
    return 0.0;
  else
    return (float)(a4 - a3[a1]) / (float)(a3[a1 + 1] - a3[a1]);
}

uint64_t DisplayGetAPLIndex(uint64_t a1, unsigned int a2)
{
  return __DisplayGetIndexFromValue(0, *(_DWORD *)(a1 + 1656) - 1, a1 + 1668, (float)a2);
}

uint64_t __DisplayGetIndexFromValue(int a1, int a2, uint64_t a3, float a4)
{
  int v5;

  if (a1 >= 0 && a2 >= 0)
  {
    if (a1 < a2)
    {
      v5 = (a1 + a2) / 2;
      if (*(float *)(a3 + 4 * v5) <= a4)
      {
        if (a4 >= *(float *)(a3 + 4 * (v5 + 1)))
          return __DisplayGetIndexFromValue((v5 + 1), a2, a3, a4);
        else
          return ((a1 + a2) / 2);
      }
      else
      {
        return __DisplayGetIndexFromValue(a1, v5, a3, a4);
      }
    }
    else
    {
      return a2;
    }
  }
  else
  {
    return 0;
  }
}

void DisplaySetEDRForTargetYcompensation(uint64_t a1, float a2)
{
  float v2;
  float v3;
  uint64_t inited;
  NSObject *v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  uint8_t v13[72];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 12596) == 1)
  {
    v10 = *(float *)(a1 + 1544);
    CFXFindBrightnessCompAlpha(v10);
    v9 = v2;
    v3 = (float)(v9 * a2) + 1.0 - v9;
    v8 = v3;
    *(float *)(a1 + 12528) = v3;
    v7 = *(float *)(a1 + 1500);
    v6 = _DisplayComputeEDRNitsCap(a1);
    if (_logHandle)
    {
      v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v5 = inited;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v13, COERCE__INT64(a2), COERCE__INT64(v10), COERCE__INT64(v9), COERCE__INT64(v8), COERCE__INT64(v7), COERCE__INT64(*(float *)(a1 + 1192)), COERCE__INT64(v6));
      _os_log_debug_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEBUG, "EDR Color brightness compensation (SetLibEDRBrightness) TargetYCompensation: %f, inputL: %f, alpha: %f, Ycomp: %f. L_device: %f, currentLux: %f, nitsCapEDR: %f", v13, 0x48u);
    }
    SetLibEDRBrightness(a1, v7, v6, *(float *)(a1 + 1192), v8);
  }
}

void SetLibEDRBrightness(uint64_t a1, float a2, float a3, float a4, float a5)
{
  uint64_t inited;
  NSObject *v6;
  uint8_t v12[56];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 12596))
  {
    if (_logHandle)
    {
      v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v6 = inited;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v12, COERCE__INT64(a2), COERCE__INT64(a3), COERCE__INT64(a4), COERCE__INT64(a5));
      _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "SetLibEDRBrightness to currentBrightness=%f, maxBrightness=%f, currentLux=%f, compensationBoost=%f", v12, 0x2Au);
    }
    CBEDRServerDisplayBrightness(*(_DWORD *)(a1 + 12592), a2, a3, a4, a5);
  }
}

void CBEDRServerDisplayBrightness(unsigned int a1, float a2, float a3, float a4, float a5)
{
  NSObject *v5;
  NSObject *oslog;
  uint8_t v12[16];
  uint8_t v13[72];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (edrServerSetDisplayBrightnessFunction)
  {
    oslog = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_2_6_8_32_4_0_8_0_8_0_8_0_8_0((uint64_t)v13, (uint64_t)"CBEDRServerDisplayBrightness", a1, COERCE__INT64(a2), COERCE__INT64(a3), COERCE__INT64(a4), COERCE__INT64(a5));
      _os_log_debug_impl(&dword_1B5291000, oslog, OS_LOG_TYPE_DEBUG, "%s: display: %u | target: %f | max: %f | ambient: %f | boost=%f", v13, 0x3Au);
    }
    edrServerSetDisplayBrightnessFunction(a1, a2, a3, a4, a5);
  }
  else
  {
    v5 = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v12, (uint64_t)"CBEDRServerDisplayBrightness");
      _os_log_error_impl(&dword_1B5291000, v5, OS_LOG_TYPE_ERROR, "%s: missing edrServerSetDisplayBrightnessFunction ", v12, 0xCu);
    }
  }
}

void CFXFindBrightnessCompAlpha(float a1)
{
  _CFXFindBrightnessCompAlpha(AlphaArray, 7, a1);
}

float _DisplayLogicalToSliderBrightnessInternal(uint64_t a1, float a2)
{
  unsigned int v3;
  unsigned int v4;
  int v5;
  float v6;
  float v7;

  v7 = 0.0;
  if (a2 > 0.0)
  {
    if (a2 < *(float *)(a1 + 1316))
      v6 = __interpolate(*(float *)(a1 + 1320), *(float *)(a1 + 1308), *(float *)(a1 + 1316), *(float *)(a1 + 1304), a2);
    else
      v6 = __interpolate(*(float *)(a1 + 1316), *(float *)(a1 + 1304), *(float *)(a1 + 1312), *(float *)(a1 + 1300), a2);
    v5 = 0;
    v4 = *(_DWORD *)(a1 + 64);
    while (v4)
    {
      v3 = v4 / 2 + v5;
      if (v3 == *(_DWORD *)(a1 + 64) - 1)
        return fmaxf(*(float *)(a1 + 344), *(float *)(a1 + 340));
      if (v6 >= *(float *)(*(_QWORD *)(a1 + 72) + 4 * v3) && v6 < *(float *)(*(_QWORD *)(a1 + 72) + 4 * (v3 + 1)))
        return fmaxf((float)((float)v3 / (float)((float)*(unsigned int *)(a1 + 64) - 1.0))+ (float)((float)((float)(v6 - *(float *)(*(_QWORD *)(a1 + 72) + 4 * v3))/ (float)(*(float *)(*(_QWORD *)(a1 + 72) + 4 * (v3 + 1))- *(float *)(*(_QWORD *)(a1 + 72) + 4 * v3)))* (float)(1.0 / (float)(*(_DWORD *)(a1 + 64) - 1))), *(float *)(a1 + 340));
      if (v6 <= *(float *)(*(_QWORD *)(a1 + 72) + 4 * v3))
      {
        v4 /= 2u;
      }
      else
      {
        v5 += v4 / 2 + 1;
        v4 = (v4 - 1) / 2;
      }
      if (!v3)
        return fmaxf(*(float *)(a1 + 340), *(float *)(a1 + 340));
    }
    return fmaxf(0.0, *(float *)(a1 + 340));
  }
  return v7;
}

float __interpolate(float a1, float a2, float a3, float a4, float a5)
{
  return a2 + (float)((float)((float)(a4 - a2) / (float)(a3 - a1)) * (float)(a5 - a1));
}

void __DisplayUpdateSlider(float *a1, float a2, float a3, float a4)
{
  float v4;
  const __CFAllocator *v5;
  const __CFAllocator *v6;
  NSObject *v7;
  const __CFAllocator *v8;
  const __CFAllocator *v9;
  NSObject *v10;
  const __CFAllocator *v11;
  const __CFAllocator *v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  CFAllocatorRef *v16;
  uint64_t v17;
  NSObject *v18;
  CFAllocatorRef *v19;
  BOOL v20;
  uint64_t inited;
  NSObject *v22;
  CFAllocatorRef *v23;
  uint64_t v24;
  int v25;
  int v26;
  void (*v27)(uint64_t);
  void *v28;
  CFTypeRef v29;
  void *v30;
  os_log_type_t v31;
  os_log_t v32;
  int i;
  uint64_t v34;
  int v35;
  int v36;
  void (*v37)(uint64_t);
  void *v38;
  CFTypeRef v39;
  void *v40;
  os_log_type_t v41;
  os_log_t v42;
  int numValues;
  float numValues_4;
  BOOL v45;
  float v46;
  int v47;
  void *v48;
  uint64_t block;
  int v50;
  int v51;
  void (*v52)(uint64_t);
  void *v53;
  CFTypeRef v54;
  void *v55;
  os_log_type_t type;
  os_log_t oslog;
  void *value;
  const __CFString *v59;
  float v60;
  float v61;
  float valuePtr;
  CFTypeRef cf;
  uint8_t v64[24];
  CFTypeRef v65;
  CFTypeRef v66;
  CFTypeRef v67;
  __int128 v68;
  const __CFString *v69;
  uint8_t v70[16];
  const void *__b[8];
  const void *__dst[8];
  uint8_t v73[16];
  __int128 v74;
  __int128 v75;
  _OWORD v76[2];
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  cf = a1;
  valuePtr = a2;
  v61 = a3;
  v60 = a4;
  if (a1[70] >= 0.0)
    valuePtr = *((float *)cf + 70);
  if ((*((_BYTE *)cf + 312) & 1) != 0)
  {
    v59 = 0;
    if (*((_DWORD *)cf + 77))
      v59 = CFSTR("DisplayTypeIcon");
    else
      v59 = CFSTR("DisplayTypeSiri");
    if ((*((_BYTE *)cf + 312) & 1) != 0 && *((float *)cf + 79) != -1.0)
    {
      v61 = *((float *)cf + 79);
      v60 = v61;
      v4 = __DisplayPhysicalToLogicalBrightness((uint64_t)cf, v61);
      valuePtr = _DisplayLogicalToSliderBrightnessInternal((uint64_t)cf, v4);
    }
    *((float *)cf + 316) = v60;
    v76[0] = xmmword_1E68EB6F0;
    v76[1] = xmmword_1E68EB700;
    v74 = 0u;
    v75 = 0u;
    v5 = CFGetAllocator(cf);
    *(_QWORD *)&v74 = CFNumberCreate(v5, kCFNumberFloatType, &valuePtr);
    v23 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    *((_QWORD *)&v74 + 1) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloat32Type, &v61);
    *(_QWORD *)&v75 = CFNumberCreate(*v23, kCFNumberFloat32Type, &v60);
    *((_QWORD *)&v75 + 1) = v59;
    v6 = CFGetAllocator(cf);
    value = CFDictionaryCreate(v6, (const void **)v76, (const void **)&v74, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (value)
    {
      oslog = 0;
      if (_logHandle)
      {
        v22 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v22 = inited;
      }
      oslog = v22;
      type = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v73, COERCE__INT64(valuePtr));
        _os_log_debug_impl(&dword_1B5291000, oslog, type, "S=%f", v73, 0xCu);
      }
      CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), CFSTR("DisplayBrightness"), value);
      CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), CFSTR("DisplayNitsKey"), value);
      *((_BYTE *)cf + 272) = 1;
      v7 = *((_QWORD *)cf + 18);
      block = MEMORY[0x1E0C809B0];
      v50 = -1073741824;
      v51 = 0;
      v52 = ____DisplayUpdateSlider_block_invoke;
      v53 = &__block_descriptor_48_e5_v8__0l;
      v54 = cf;
      v55 = value;
      dispatch_async(v7, &block);
    }
    if ((_QWORD)v74)
      CFRelease((CFTypeRef)v74);
    if (*((_QWORD *)&v74 + 1))
      CFRelease(*((CFTypeRef *)&v74 + 1));
    if ((_QWORD)v75)
      CFRelease((CFTypeRef)v75);
  }
  else
  {
    *((float *)cf + 316) = v60;
    v48 = 0;
    if ((*((_BYTE *)cf + 321) & 1) != 0)
    {
      v47 = 0;
      v46 = 0.0;
      v45 = 0;
      v20 = 1;
      if ((*((_BYTE *)cf + 322) & 1) == 0)
        v20 = *((double *)cf + 1576) > 0.0;
      v45 = v20;
      if (v20)
      {
        v47 = *((_DWORD *)cf + 283);
        if ((*((_BYTE *)cf + 1517) & 1) != 0 && (_DisplayBDMAvailable((uint64_t)cf) & 1) != 0)
          v47 = (int)(float)(*((float *)cf + 292) * 65536.0);
      }
      else
      {
        v47 = *((_DWORD *)cf + 282);
      }
      numValues_4 = (float)v47 / 65536.0;
      if ((*((_BYTE *)cf + 1120) & 1) != 0)
        v46 = *((float *)cf + 328);
      else
        v46 = *((float *)cf + 328) * *((float *)cf + 264);
      memcpy(__dst, &off_1E68EB710, sizeof(__dst));
      memset(__b, 0, sizeof(__b));
      v8 = CFGetAllocator(cf);
      __b[0] = CFNumberCreate(v8, kCFNumberFloatType, &valuePtr);
      v19 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
      __b[1] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloat32Type, &v61);
      __b[2] = CFNumberCreate(*v19, kCFNumberFloat32Type, &v60);
      __b[3] = CFNumberCreate(*v19, kCFNumberFloat32Type, &v60);
      __b[4] = CFNumberCreate(*v19, kCFNumberFloat32Type, (char *)cf + 12628);
      __b[5] = CFNumberCreate(*v19, kCFNumberFloat32Type, &numValues_4);
      __b[6] = CFNumberCreate(*v19, kCFNumberFloat32Type, &v46);
      __b[7] = CFNumberCreate(*v19, kCFNumberFloat32Type, (char *)cf + 12944);
      numValues = 8;
      v9 = CFGetAllocator(cf);
      v48 = CFDictionaryCreate(v9, __dst, __b, 8, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v48)
      {
        v42 = 0;
        if (_logHandle)
        {
          v18 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v17 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v17 = init_default_corebrightness_log();
          v18 = v17;
        }
        v42 = v18;
        v41 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v70, COERCE__INT64(valuePtr));
          _os_log_debug_impl(&dword_1B5291000, v42, v41, "S=%f", v70, 0xCu);
        }
        CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), CFSTR("DisplayBrightness"), v48);
        CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), CFSTR("DisplayNitsKey"), v48);
        *((_BYTE *)cf + 272) = 1;
        kdebug_trace();
        v10 = *((_QWORD *)cf + 18);
        v34 = MEMORY[0x1E0C809B0];
        v35 = -1073741824;
        v36 = 0;
        v37 = ____DisplayUpdateSlider_block_invoke_732;
        v38 = &__block_descriptor_48_e5_v8__0l;
        v39 = cf;
        v40 = v48;
        dispatch_async(v10, &v34);
      }
      for (i = 0; i < numValues; ++i)
      {
        if (__b[i])
          CFRelease(__b[i]);
      }
    }
    else
    {
      v68 = xmmword_1E68EB750;
      v69 = CFSTR("NitsPhysical");
      v65 = 0;
      v66 = 0;
      v67 = 0;
      v11 = CFGetAllocator(cf);
      v65 = CFNumberCreate(v11, kCFNumberFloatType, &valuePtr);
      v16 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
      v66 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloat32Type, &v61);
      v67 = CFNumberCreate(*v16, kCFNumberFloat32Type, &v60);
      v12 = CFGetAllocator(cf);
      v48 = CFDictionaryCreate(v12, (const void **)&v68, &v65, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v48)
      {
        v32 = 0;
        if (_logHandle)
        {
          v15 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v14 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v14 = init_default_corebrightness_log();
          v15 = v14;
        }
        v32 = v15;
        v31 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v64, COERCE__INT64(valuePtr));
          _os_log_debug_impl(&dword_1B5291000, v32, v31, "S=%f", v64, 0xCu);
        }
        CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), CFSTR("DisplayBrightness"), v48);
        CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), CFSTR("DisplayNitsKey"), v48);
        *((_BYTE *)cf + 272) = 1;
        kdebug_trace();
        v13 = *((_QWORD *)cf + 18);
        v24 = MEMORY[0x1E0C809B0];
        v25 = -1073741824;
        v26 = 0;
        v27 = ____DisplayUpdateSlider_block_invoke_734;
        v28 = &__block_descriptor_48_e5_v8__0l;
        v29 = cf;
        v30 = v48;
        dispatch_async(v13, &v24);
      }
      if (v65)
        CFRelease(v65);
      if (v66)
        CFRelease(v66);
      if (v67)
        CFRelease(v67);
    }
  }
}

void SendSyncDBVNotification(uint64_t a1, char a2, float a3)
{
  NSObject *v3;
  void (*v4)(void);
  int v5;
  int v6;
  void (*v7)(uint64_t);
  void *v8;
  uint64_t v9;
  float v10;
  char v11;
  char v12;
  float v13;
  uint64_t v14;

  v14 = a1;
  v13 = a3;
  v12 = a2 & 1;
  if ((*(_BYTE *)(a1 + 321) & 1) != 0)
  {
    if ((*(_BYTE *)(v14 + 232) & 1) == 0 || (v12 & 1) != 0)
    {
      v3 = *(NSObject **)(v14 + 120);
      v4 = (void (*)(void))MEMORY[0x1E0C809B0];
      v5 = -1073741824;
      v6 = 0;
      v7 = __SendSyncDBVNotification_block_invoke;
      v8 = &__block_descriptor_45_e5_v8__0l;
      v9 = v14;
      v10 = v13;
      v11 = v12 & 1;
      disp_dispatch_async(v3, &v4);
    }
    else
    {
      *(_DWORD *)(v14 + 236) = (int)(float)(v13 * 65536.0);
    }
  }
}

void disp_dispatch_async(NSObject *a1, void (**a2)(void))
{
  if (a1)
    dispatch_async(a1, a2);
  else
    a2[2]();
}

void DisplayRefPropertyChangedCallback(void *a1, const __CFString *a2, const void *a3)
{
  NSObject *v3;
  NSObject *log;
  os_log_type_t type;
  NSObject *inited;
  uint64_t block;
  int v8;
  int v9;
  void (*v10)(id *);
  void *v11;
  void *v12;
  CFTypeRef v13;
  CFTypeRef v14;
  void *v15;
  uint8_t v16[15];
  char v17;
  NSObject *v18;
  CFTypeRef v19;
  CFTypeRef v20;
  void *v21;

  v21 = a1;
  v20 = a2;
  v19 = a3;
  if (a1)
  {
    v15 = v21;
    if (v20)
      CFRetain(v20);
    if (v19)
      CFRetain(v19);
    v3 = *((_QWORD *)v15 + 3);
    block = MEMORY[0x1E0C809B0];
    v8 = -1073741824;
    v9 = 0;
    v10 = ___Z33DisplayRefPropertyChangedCallbackPvPK10__CFStringPKv_block_invoke;
    v11 = &unk_1E68E9FA0;
    v12 = v15;
    v13 = v20;
    v14 = v19;
    dispatch_async(v3, &block);
  }
  else
  {
    v18 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v18 = inited;
    v17 = 16;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
    {
      log = v18;
      type = v17;
      __os_log_helper_16_0_0(v16);
      _os_log_error_impl(&dword_1B5291000, log, type, "invalid arguments", v16, 2u);
    }
  }
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__4(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__9(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__10(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__12(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__13(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__14(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__16(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t __Block_byref_object_dispose__17(uint64_t a1)
{
  return std::list<AAB::CurveUpdate>::~list(a1 + 48);
}

void __Block_byref_object_dispose__18(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__19(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__20(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_dispose__21(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__5(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__6(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__11(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__12(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__13(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__14(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__15(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__16(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

_QWORD *__Block_byref_object_copy__17(uint64_t a1, uint64_t a2)
{
  return std::list<AAB::CurveUpdate>::list((_QWORD *)(a1 + 48), (uint64_t *)(a2 + 48));
}

void __Block_byref_object_copy__18(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__19(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__20(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_copy__21(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

uint64_t __os_log_helper_16_2_4_8_32_8_0_8_0_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 32;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  return result;
}

float AABC::calculateMovingAverage(AABC *this, float a2)
{
  unint64_t v2;
  unint64_t v3;
  float v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v10;

  v10 = *((_QWORD *)this + 35);
  if (v10 >= std::array<float,3ul>::size[abi:ne180100]())
  {
    v8 = *((_QWORD *)this + 35);
    v2 = std::array<float,3ul>::size[abi:ne180100]();
    *((float *)this + 72) = *((float *)this + 72)
                          - *(float *)std::array<float,3ul>::operator[][abi:ne180100]((uint64_t)this + 268, v8 % v2);
  }
  v6 = *((_QWORD *)this + 35);
  v3 = std::array<float,3ul>::size[abi:ne180100]();
  *(float *)std::array<float,3ul>::operator[][abi:ne180100]((uint64_t)this + 268, v6 % v3) = a2;
  ++*((_QWORD *)this + 35);
  *((float *)this + 72) = *((float *)this + 72) + a2;
  v7 = *((_QWORD *)this + 35);
  if (v7 < std::array<float,3ul>::size[abi:ne180100]())
    return *((float *)this + 72) / (float)*((unint64_t *)this + 35);
  v5 = *((float *)this + 72);
  return v5 / (float)(unint64_t)std::array<float,3ul>::size[abi:ne180100]();
}

float mach_time_now_in_milliseconds()
{
  uint64_t v0;

  v0 = mach_absolute_time();
  return mach_time_to_milliseconds(v0);
}

float mach_time_to_milliseconds(unint64_t a1)
{
  return mach_time_to_nanoseconds(a1) / 1000000.0;
}

float mach_time_now_in_seconds()
{
  uint64_t v0;

  v0 = mach_absolute_time();
  return mach_time_to_seconds(v0);
}

float mach_time_to_seconds(unint64_t a1)
{
  return mach_time_to_nanoseconds(a1) / 1000000000.0;
}

float mach_time_to_nanoseconds(unint64_t a1)
{
  if (mach_time_to_nanoseconds::token != -1)
    dispatch_once(&mach_time_to_nanoseconds::token, &__block_literal_global_6);
  return (float)a1 * *(float *)&mach_time_to_nanoseconds::machTimeBaseFactor;
}

void DisplayUpdateAAPState(uint64_t a1, uint64_t a2, char a3, char a4)
{
  NSObject *v4;
  void (*v5)(void);
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t);
  void *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  char v13;
  char v14;
  uint64_t v15;
  uint64_t v16;

  v16 = a1;
  v15 = a2;
  v14 = a3 & 1;
  v13 = a4 & 1;
  if ((a4 & 1) != 0 && *(_QWORD *)(v16 + 144))
  {
    v4 = *(NSObject **)(v16 + 144);
    v5 = (void (*)(void))MEMORY[0x1E0C809B0];
    v6 = -1073741824;
    v7 = 0;
    v8 = __DisplayUpdateAAPState_block_invoke;
    v9 = &__block_descriptor_49_e5_v8__0l;
    v10 = v16;
    v11 = v15;
    v12 = v14 & 1;
    disp_dispatch_sync(v4, &v5);
  }
  else if ((v13 & 1) == 0)
  {
    __DisplayUpdateAAPStateInternal(v16, v15, v14 & 1);
  }
}

uint64_t AABCCallback(void *a1, const __CFString *a2, const void *a3)
{
  NSObject *log;
  os_log_type_t type;
  NSObject *inited;
  uint8_t v7[15];
  char v8;
  NSObject *v9;
  const void *v10;
  const __CFString *v11;
  id v12;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  if (!a1 || !v11 || !v10)
  {
    v9 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v9 = inited;
    v8 = 16;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
    {
      log = v9;
      type = v8;
      __os_log_helper_16_0_0(v7);
      _os_log_error_impl(&dword_1B5291000, log, type, "error: invalid parameters", v7, 2u);
    }
  }
  return objc_msgSend(v12, "sendNotificationForKey:withValue:", v11, v10);
}

uint64_t DisplayCopyProperty(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint64_t v4;
  void (*v5)(void);
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t);
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = a1;
  v18 = a2;
  v13 = 0;
  v14 = &v13;
  v15 = 0x20000000;
  v16 = 32;
  v17 = 0;
  v2 = *(NSObject **)(a1 + 144);
  v5 = (void (*)(void))MEMORY[0x1E0C809B0];
  v6 = -1073741824;
  v7 = 0;
  v8 = __DisplayCopyProperty_block_invoke;
  v9 = &unk_1E68EA390;
  v10 = &v13;
  v11 = v19;
  v12 = a2;
  disp_dispatch_sync(v2, &v5);
  v4 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1B52CB4F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

void ___Z33DisplayRefPropertyChangedCallbackPvPK10__CFStringPKv_block_invoke(id *a1)
{
  float v1;
  double v2;
  double v3;
  double v4;
  void *context;
  uint64_t v6;
  id v8;
  char v9;

  v9 = 1;
  if (*((_QWORD *)a1[4] + 5))
  {
    v6 = objc_msgSend(*((id *)a1[4] + 5), "getDisplayType");
    if (v6 == objc_msgSend(*((id *)a1[4] + 5), "CBDispTypeIntegrated"))
    {
      if ((objc_msgSend(a1[5], "isEqualToString:", CFSTR("TrustedLux")) & 1) != 0
        || (objc_msgSend(a1[5], "isEqualToString:", CFSTR("FrameSynchronizedBrightnessTransaction")) & 1) != 0
        || (objc_msgSend(a1[5], "isEqualToString:", CFSTR("CPMS.UPO.Cap")) & 1) != 0
        || (objc_msgSend(a1[5], "isEqualToString:", CFSTR("CPMS.CLTM.Cap")) & 1) != 0
        || (objc_msgSend(a1[5], "isEqualToString:", CFSTR("CPMS.HDR.Cap")) & 1) != 0
        || (objc_msgSend(a1[5], "isEqualToString:", CFSTR("CPMSCurrentCap")) & 1) != 0
        || (objc_msgSend(a1[5], "isEqualToString:", CFSTR("DisplayOn")) & 1) != 0
        || (objc_msgSend(a1[5], "isEqualToString:", CFSTR("AuroraFactor")) & 1) != 0
        || (objc_msgSend(a1[5], "isEqualToString:", CFSTR("AuroraRampInProgress")) & 1) != 0)
      {
        objc_msgSend(a1[4], "handleNotificationForKey:withProperty:", a1[5], a1[6]);
      }
      else if ((objc_msgSend(a1[5], "isEqualToString:", CFSTR("DisplayBrightness")) & 1) != 0)
      {
        v9 = 0;
        objc_msgSend(a1[4], "handleNotificationForKey:withProperty:", a1[5], a1[6]);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          context = (void *)MEMORY[0x1B5E4A8B0]();
          v8 = (id)objc_msgSend(a1[6], "mutableCopy");
          objc_msgSend((id)objc_msgSend(v8, "objectForKey:"), "floatValue");
          *(float *)&v2 = v1 * *((float *)a1[4] + 36);
          objc_msgSend(v8, "setValue:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v2), CFSTR("NitsPhysical"));
          LODWORD(v3) = *((_DWORD *)a1[4] + 36);
          objc_msgSend(v8, "setValue:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v3), CFSTR("EDRHeadroom"));
          LODWORD(v4) = *((_DWORD *)a1[4] + 54);
          objc_msgSend(v8, "setValue:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v4), CFSTR("HDRRTPLCCap"));
          _DisplaySetInternalDictionaryProperty(*((_QWORD *)a1[4] + 35), (uint64_t)CFSTR("DisplayBrightness"), (uint64_t)v8);
          _DisplaySetInternalDictionaryProperty(*((_QWORD *)a1[4] + 35), (uint64_t)CFSTR("DisplayNitsKey"), (uint64_t)v8);
          v9 = 0;
          objc_msgSend(a1[4], "sendNotificationForKey:withValue:", a1[5], v8);
          objc_autoreleasePoolPop(context);
        }
      }
    }
  }
  if ((v9 & 1) != 0)
    objc_msgSend(a1[4], "sendNotificationForKey:withValue:", a1[5], a1[6]);
  if (a1[5])
    CFRelease(a1[5]);
  if (a1[6])
    CFRelease(a1[6]);
}

uint64_t __SetBLDriverProperty(const __CFString *a1, const void *a2, uint64_t a3)
{
  return IORegistryEntrySetCFProperty(*(_DWORD *)(a3 + 80), a1, a2);
}

void _DisplaySetInternalDictionaryProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;
  void (*v4)(void);
  int v5;
  int v6;
  void (*v7)(uint64_t);
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v3 = *(NSObject **)(a1 + 144);
  v4 = (void (*)(void))MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = ___DisplaySetInternalDictionaryProperty_block_invoke;
  v8 = &__block_descriptor_56_e5_v8__0l;
  v9 = v14;
  v10 = a2;
  v11 = a3;
  disp_dispatch_sync(v3, &v4);
}

void DisplaySetABBrightnessForPowerReport(uint64_t a1, char a2, float a3)
{
  NSObject *v3;
  void (*v4)(void);
  int v5;
  int v6;
  void (*v7)(uint64_t);
  void *v8;
  uint64_t v9;
  float v10;
  char v11;
  char v12;
  float v13;
  uint64_t v14;

  v14 = a1;
  v13 = a3;
  v12 = a2 & 1;
  v3 = *(NSObject **)(a1 + 144);
  v4 = (void (*)(void))MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = __DisplaySetABBrightnessForPowerReport_block_invoke;
  v8 = &__block_descriptor_45_e5_v8__0l;
  v9 = v14;
  v10 = a3;
  v11 = a2 & 1;
  disp_dispatch_sync(v3, &v4);
}

uint64_t AABC::UpdateDisplayBrightness_Block6(uint64_t a1, int a2, int a3, char a4, float a5)
{
  const char *v5;
  float v6;
  float v7;
  float v8;
  float v9;
  const char *v10;
  const char *v11;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  NSObject *v24;
  char v25;
  float v26;
  float v27;
  float v28;
  float v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t inited;
  NSObject *v37;
  float BrightnessMinPhysical;
  float BrightnessMaxPhysical;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float VirtualBrightness;
  float v47;
  float v48;
  float WeakCap;
  float v50;
  float v51;
  char v52;
  char v53;
  char v54;
  uint8_t v58[64];
  uint8_t v59[32];
  uint8_t v60[48];
  uint8_t v61[48];
  uint8_t v62[32];
  uint8_t v63[64];
  uint8_t v64[64];
  uint8_t v65[16];
  uint8_t v66[64];
  uint8_t v67[8];
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  v54 = a4 & 1;
  if (_logHandle)
  {
    v37 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v37 = inited;
  }
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v67, 4);
    _os_log_debug_impl(&dword_1B5291000, v37, OS_LOG_TYPE_DEBUG, "[%x]: ", v67, 8u);
  }
  if (_logHandle)
  {
    v35 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v34 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v34 = init_default_corebrightness_log();
    v35 = v34;
  }
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
  {
    if (a2)
      v5 = "true";
    else
      v5 = "false";
    __os_log_helper_16_2_6_4_0_8_0_8_32_8_32_8_0_4_0((uint64_t)v66, 512, COERCE__INT64(a5), (uint64_t)v5, (uint64_t)(&kDimRestrictionStr)[a3], COERCE__INT64(*(float *)(a1 + 544)), v54 & 1);
    _os_log_debug_impl(&dword_1B5291000, v35, OS_LOG_TYPE_DEBUG, "[%x]: inputs: L=%f (shouldRamp=%s dimRestriction=%s _Esensor_trusted=%f) curveChanged=%d", v66, 0x36u);
  }
  if (*(_DWORD *)(a1 + 676) && (v54 & 1) == 0)
    a3 = 0;
  v53 = 0;
  if (*(_DWORD *)(a1 + 512) && *(_DWORD *)(a1 + 508) && *(_DWORD *)(a1 + 516))
  {
    v52 = (v54 & 1) != 0;
    v51 = 0.0;
    if (*(float *)(a1 + 620) == 0.0)
      *(_DWORD *)(a1 + 620) = *(_DWORD *)(a1 + 720);
    v50 = a5;
    WeakCap = *(float *)(a1 + 728);
    if ((*(_BYTE *)(a1 + 4084) & 1) != 0)
    {
      WeakCap = DisplayGetWeakCap(*(_QWORD *)(a1 + 408));
      if (_logHandle)
      {
        v33 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v32 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v32 = init_default_corebrightness_log();
        v33 = v32;
      }
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v65, COERCE__INT64(WeakCap));
        _os_log_debug_impl(&dword_1B5291000, v33, OS_LOG_TYPE_DEBUG, "Weak cap read at %f", v65, 0xCu);
      }
      v50 = fminf(a5, WeakCap);
    }
    if (a2)
    {
      if (_logHandle)
      {
        v31 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v30 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v30 = init_default_corebrightness_log();
        v31 = v30;
      }
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_6_4_0_4_0_8_32_8_0_8_0_8_0((uint64_t)v64, 512, *(_DWORD *)(a1 + 676), (uint64_t)(&kDimRestrictionStr)[a3], COERCE__INT64(v50), COERCE__INT64(*(float *)(a1 + 620)), COERCE__INT64(*(float *)(a1 + 604)));
        _os_log_debug_impl(&dword_1B5291000, v31, OS_LOG_TYPE_DEBUG, "[%x]: _fastRampMode=%x dimRestriction=%s L_newtarget=%f _L_current=%f _L_minimum=%f", v64, 0x36u);
      }
      if (a3)
      {
        if (a3 == 1)
          v50 = fmaxf(v50, *(float *)(a1 + 604));
      }
      else
      {
        v50 = fmaxf(v50, *(float *)(a1 + 616));
      }
      v48 = DisplayLuminanceToPerceptualLuminance(*(_QWORD *)(a1 + 408), v50);
      v47 = DisplayLuminanceToPerceptualLuminance(*(_QWORD *)(a1 + 408), *(float *)(a1 + 616));
      if (-[CBAODState isAODActive](+[CBAODState sharedInstance](CBAODState, "sharedInstance"), "isAODActive"))
      {
        -[CBAODState minAODNits](+[CBAODState sharedInstance](CBAODState, "sharedInstance"), "minAODNits");
        v27 = v6;
        -[CBAODState maxAODNits](+[CBAODState sharedInstance](CBAODState, "sharedInstance"), "maxAODNits");
        v48 = BULuminanceToPerceptual(v50, v27, v7);
        v29 = *(float *)(a1 + 616);
        -[CBAODState minAODNits](+[CBAODState sharedInstance](CBAODState, "sharedInstance"), "minAODNits");
        v28 = v8;
        -[CBAODState maxAODNits](+[CBAODState sharedInstance](CBAODState, "sharedInstance"), "maxAODNits");
        v47 = BULuminanceToPerceptual(v29, v28, v9);
      }
      VirtualBrightness = DisplayGetVirtualBrightness(*(float **)(a1 + 408));
      v45 = DisplayLuminanceToPerceptualLuminance(*(_QWORD *)(a1 + 408), VirtualBrightness);
      v44 = v48 - v47;
      v43 = vabds_f32(*(float *)(a1 + 544), *(float *)(a1 + 624));
      if (*(float *)(a1 + 624) == 0.0)
        v26 = *(float *)(a1 + 544);
      else
        v26 = *(float *)(a1 + 544) / *(float *)(a1 + 624);
      v42 = *(float *)(a1 + 4008);
      if (*(_DWORD *)(a1 + 676) && *(float *)(a1 + 624) == 0.0)
        v42 = fmaxf(v42, 2.0);
      if (v43 > v42 || (*(_BYTE *)(a1 + 4092) & 1) != 0)
      {
        v25 = 1;
        if ((v54 & 1) == 0)
          v25 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, float, float, float, float, float))(**(_QWORD **)(a1 + 4016) + 8))(*(_QWORD *)(a1 + 4016), *(_BYTE *)(a1 + 628) & 1, *(_BYTE *)(a1 + 316) & 1, v47, v45, v48, v43, v26);
        v52 = v25 & 1;
        if ((*(_BYTE *)(a1 + 4084) & 1) != 0 && v44 > 0.0 && v50 >= WeakCap)
          v52 = 1;
      }
      if ((*(_BYTE *)(a1 + 4092) & 1) != 0)
        v52 = 1;
      if ((*(_BYTE *)(a1 + 4160) & 1) != 0)
      {
        v52 = 1;
        *(_BYTE *)(a1 + 4160) = 0;
      }
      AABC::RecordLuminance((AABC *)a1, v50);
      if (_logHandle)
      {
        v24 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v23 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v23 = init_default_corebrightness_log();
        v24 = v23;
      }
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        if ((v52 & 1) != 0)
          v10 = "systemShallUpdateBacklight";
        else
          v10 = "";
        __os_log_helper_16_2_6_4_0_8_0_8_0_8_0_8_0_8_32((uint64_t)v63, 512, COERCE__INT64(*(float *)(a1 + 616)), COERCE__INT64(v48), COERCE__INT64(v47), COERCE__INT64(v44), (uint64_t)v10);
        _os_log_debug_impl(&dword_1B5291000, v24, OS_LOG_TYPE_DEBUG, "[%x]: _L_target=%f Pnewtarget=%f Ptarget=%f Pdelta=%f  %s", v63, 0x3Au);
      }
      if ((v52 & 1) != 0)
      {
        *(float *)(a1 + 620) = VirtualBrightness;
        v41 = v48 - v45;
        if ((v54 & 1) != 0)
        {
          v51 = 0.5;
        }
        else if (*(_DWORD *)(a1 + 676))
        {
          if (v41 >= 0.15)
            v51 = *(float *)(a1 + 696);
          else
            v51 = PerceptualLuminanceThresholding::DurationFromPerceptualDelta(*(PerceptualLuminanceThresholding **)(a1 + 4016), v41)/ 5.0;
          if (_logHandle)
          {
            v22 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v21 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v21 = init_default_corebrightness_log();
            v22 = v21;
          }
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_4_0_8_0((uint64_t)v62, 512, COERCE__INT64(v51));
            _os_log_debug_impl(&dword_1B5291000, v22, OS_LOG_TYPE_DEBUG, "[%x]: FAST RAMP (timeConstant=%0.2f", v62, 0x12u);
          }
        }
        else
        {
          v51 = PerceptualLuminanceThresholding::DurationFromPerceptualDelta(*(PerceptualLuminanceThresholding **)(a1 + 4016), v41);
        }
        if (v41 < 0.0)
          ++*(_DWORD *)(a1 + 3984);
      }
    }
    else
    {
      AABC::RecordLuminance((AABC *)a1, v50);
      v52 = 1;
      if (_logHandle)
      {
        v20 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v19 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v19 = init_default_corebrightness_log();
        v20 = v19;
      }
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_4_4_0_8_32_8_0_8_0((uint64_t)v61, 512, (uint64_t)"false", COERCE__INT64(*(float *)(a1 + 620)), COERCE__INT64(v50));
        _os_log_debug_impl(&dword_1B5291000, v20, OS_LOG_TYPE_DEBUG, "[%x]: MANUAL isSensorChange=%s _L_current=%f L_target=%f", v61, 0x26u);
      }
    }
    if (_logHandle)
    {
      v18 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v17 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v17 = init_default_corebrightness_log();
      v18 = v17;
    }
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      if ((v52 & 1) != 0)
        v11 = "true";
      else
        v11 = "false";
      __os_log_helper_16_2_4_4_0_8_32_8_0_8_0((uint64_t)v60, 512, (uint64_t)v11, COERCE__INT64(v50), COERCE__INT64(v51));
      _os_log_debug_impl(&dword_1B5291000, v18, OS_LOG_TYPE_DEBUG, "[%x]: systemShallUpdateBacklight=%s L_target=%f timeConstant=%f", v60, 0x26u);
    }
    if ((*(float *)(a1 + 492) == 0.0 || *(float *)(a1 + 492) == 1.0) && (v52 & 1) != 0)
    {
      *(_DWORD *)(a1 + 624) = *(_DWORD *)(a1 + 544);
      *(float *)(a1 + 616) = v50;
      if (v51 != 0.0)
        *(_BYTE *)(a1 + 628) = 1;
      v53 = 1;
      if (_logHandle)
      {
        v16 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v15 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v15 = init_default_corebrightness_log();
        v16 = v15;
      }
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v59, COERCE__INT64(v50), COERCE__INT64(v51), COERCE__INT64(*(float *)(a1 + 544)));
        _os_log_impl(&dword_1B5291000, v16, OS_LOG_TYPE_INFO, "Begin ramp: L_target=%0.4f timeConstant=%0.4f _Esensor_trusted=%0.4f", v59, 0x20u);
      }
      AABC::SetBrightness((AABC *)a1, *(float *)(a1 + 616), v51, 10, (void (*)(void *))AABC::_RampDoneCallback, a1);
      BrightnessMaxPhysical = _DisplayGetBrightnessMaxPhysical(*(_QWORD *)(a1 + 408));
      BrightnessMinPhysical = _DisplayGetBrightnessMinPhysical(*(_QWORD *)(a1 + 408));
      if (_logHandle)
      {
        v14 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v13 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v13 = init_default_corebrightness_log();
        v14 = v13;
      }
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_6_8_32_8_0_8_0_8_0_8_0_8_0((uint64_t)v58, (uint64_t)"ALS", COERCE__INT64(v50), COERCE__INT64(BrightnessMaxPhysical), COERCE__INT64(BrightnessMinPhysical), COERCE__INT64(v51), COERCE__INT64(*(float *)(a1 + 544)));
        _os_log_impl(&dword_1B5291000, v14, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: Begin ramp: L_target=%0.4f Lmax=%f Lmin=%f timeConstant=%0.4f _Esensor_trusted=%0.4f", v58, 0x3Eu);
      }
    }
  }
  *(_BYTE *)(a1 + 4092) = 0;
  return v53 & 1;
}

void AABC::_UpdateNitsRestrictionsMultiPoint(AABC *this, float a2, float a3, char a4)
{
  uint64_t v5;
  AABC *v6;
  int v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  os_log_type_t v11;
  uint64_t v12;
  NSObject *v13;
  char v14;
  float v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v21;
  char isTrustedOccluded;
  float v24;
  uint8_t v25[15];
  char v26;
  NSObject *v27;
  char v28;
  char v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  int j;
  float v36;
  uint64_t v37;
  float v38;
  os_log_type_t v39;
  os_log_t v40;
  uint8_t v41[7];
  char v42;
  NSObject *v43;
  char v44;
  char v45;
  float v46;
  float RestrictionFactorTarget;
  float v48;
  float v49;
  float v50;
  int i;
  float v52;
  int v53;
  float v54;
  float v55;
  char v56;
  float v57;
  float v58;
  AABC *v59;
  uint8_t v60[32];
  uint8_t v61[24];
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v59 = this;
  v58 = a2;
  v57 = a3;
  v56 = a4 & 1;
  v55 = a2;
  v54 = a2;
  v53 = 0;
  if (a2 < 0.0)
  {
    v54 = 0.0;
    v55 = 0.0;
  }
  if (*((_DWORD *)this + 130) || !*((_DWORD *)this + 129))
    v53 = 1;
  if ((*((_BYTE *)this + 3472) & 1) != 0)
  {
    v52 = 0.0;
    for (i = 0; i < 6 && v58 > *((float *)this + 12 * v53 + i + 873); ++i)
      ;
    if (i)
    {
      if (i == 6)
      {
        v52 = *((float *)this + 12 * v53 + 884);
      }
      else
      {
        v50 = 0.0;
        v50 = *((float *)this + 12 * v53 + i + 873) - *((float *)this + 12 * v53 + i + 872);
        v49 = 0.0;
        v49 = *((float *)this + 12 * v53 + i + 879) - *((float *)this + 12 * v53 + i + 878);
        v48 = 0.0;
        v48 = (float)(v58 - *((float *)this + 12 * v53 + i + 872)) / v50;
        v52 = *((float *)this + 12 * v53 + i + 878) + (float)(v48 * v49);
      }
    }
    else
    {
      v52 = *((float *)this + 12 * v53 + 879);
    }
    RestrictionFactorTarget = 0.0;
    RestrictionFactorTarget = DisplayGetRestrictionFactorTarget(*((_QWORD *)this + 51), 1);
    v46 = v52 - RestrictionFactorTarget;
    v45 = 0;
    isTrustedOccluded = 0;
    if ((float)(v52 - RestrictionFactorTarget) < 0.0)
      isTrustedOccluded = AABC::isTrustedOccluded((id **)this);
    v45 = isTrustedOccluded & 1;
    if ((v56 & 1) != 0 || fabsf(v46) >= 0.01 && (v45 & 1) == 0)
    {
      v44 = 1;
      if (v52 > *((float *)this + 12 * v53 + 879) + 0.005
        && v52 < *((float *)this + 12 * v53 + 884) - 0.005
        && (v56 & 1) == 0
        && (float)(fabsf(v46) / RestrictionFactorTarget) < 0.1)
      {
        v43 = 0;
        if (_logHandle)
        {
          v21 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            inited = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            inited = init_default_corebrightness_log();
          v21 = inited;
        }
        v43 = v21;
        v42 = 2;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          log = v43;
          type = v42;
          __os_log_helper_16_0_0(v41);
          _os_log_debug_impl(&dword_1B5291000, log, type, "Skipping set of minimum restriction due to relative threshold\n", v41, 2u);
        }
        v44 = 0;
      }
      if ((v44 & 1) != 0)
      {
        v40 = 0;
        if (_logHandle)
        {
          v17 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v16 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v16 = init_default_corebrightness_log();
          v17 = v16;
        }
        v40 = v17;
        v39 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v61, COERCE__INT64(v52), COERCE__INT64(v54));
          _os_log_impl(&dword_1B5291000, v40, v39, "Set minimum restriction %f for E=%f\n", v61, 0x16u);
        }
        v38 = v57;
        if (v57 < 0.0)
        {
          if (v46 <= 0.0)
            v15 = *((float *)this + 872);
          else
            v15 = *((float *)this + 871);
          v38 = v15;
        }
        v5 = *((_QWORD *)this + 51);
        v37 = *((_QWORD *)this + 433);
        DisplaySetRestrictionFactorWithFade(v5, 1, v52, v38, *(float *)&v37, *((float *)&v37 + 1));
      }
    }
  }
  if ((*((_BYTE *)this + 3588) & 1) != 0)
  {
    v36 = 0.0;
    for (j = 0; j < 6 && v58 > *((float *)this + 12 * v53 + j + 902); ++j)
      ;
    if (j)
    {
      if (j == 6)
      {
        v36 = *((float *)this + 12 * v53 + 913);
      }
      else
      {
        v6 = this;
        v34 = 0.0;
        v34 = *((float *)v6 + 12 * v53 + j + 902) - *((float *)v6 + 12 * v53 + j + 901);
        v33 = 0.0;
        v33 = *((float *)v6 + 12 * v53 + j + 908) - *((float *)v6 + 12 * v53 + j + 907);
        v32 = 0.0;
        v32 = (float)(v58 - *((float *)this + 12 * v53 + j + 901)) / v34;
        v36 = *((float *)this + 12 * v53 + j + 907) + (float)(v32 * v33);
      }
    }
    else
    {
      v36 = *((float *)this + 12 * v53 + 908);
    }
    v31 = 0.0;
    v31 = DisplayGetRestrictionFactorTarget(*((_QWORD *)this + 51), 0);
    v30 = v36 - v31;
    v29 = 0;
    v14 = 0;
    if ((float)(v36 - v31) < 0.0)
      v14 = AABC::isTrustedOccluded((id **)this);
    v29 = v14 & 1;
    if ((v56 & 1) != 0 || fabsf(v30) >= 0.01 && (v29 & 1) == 0)
    {
      v28 = 1;
      if (v36 > *((float *)this + 12 * v53 + 908) + 0.005
        && v36 < *((float *)this + 12 * v53 + 913) - 0.005
        && (v56 & 1) == 0
        && (float)(fabsf(v30) / v31) < 0.1)
      {
        v27 = 0;
        if (_logHandle)
        {
          v13 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v12 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v12 = init_default_corebrightness_log();
          v13 = v12;
        }
        v27 = v13;
        v26 = 2;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          v10 = v27;
          v11 = v26;
          __os_log_helper_16_0_0(v25);
          _os_log_debug_impl(&dword_1B5291000, v10, v11, "Skipping set of maximum restriction due to relative threshold\n", v25, 2u);
        }
        v28 = 0;
      }
      if ((v28 & 1) != 0)
      {
        if (_logHandle)
        {
          v9 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v8 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v8 = init_default_corebrightness_log();
          v9 = v8;
        }
        if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v60, COERCE__INT64(v36), COERCE__INT64(v55));
          _os_log_impl(&dword_1B5291000, v9, OS_LOG_TYPE_INFO, "Set maximum restriction %f for E=%f\n", v60, 0x16u);
        }
        v24 = v57;
        if (v57 < 0.0)
        {
          if (v30 <= 0.0)
          {
            v24 = *((float *)this + 901);
          }
          else
          {
            v24 = *((float *)this + 900);
            LOBYTE(v7) = 0;
            if ((std::__math::isnan[abi:ne180100]() & 1) == 0)
              v7 = std::__math::isnan[abi:ne180100]() ^ 1;
            if ((v7 & 1) != 0 && v36 >= *((float *)this + 898))
              v24 = *((float *)this + 899);
          }
        }
        DisplaySetRestrictionFactorWithFade(*((_QWORD *)this + 51), 0, v36, v24, COERCE_FLOAT(*((_QWORD *)this + 433)), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 433))));
      }
    }
  }
}

float DisplayGetRestrictionFactorTarget(uint64_t a1, char a2)
{
  NSObject *v2;
  float v4;
  void (*v5)(void);
  int v6;
  int v7;
  float (*v8)(uint64_t);
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  float *v14;
  int v15;
  int v16;
  int v17;
  char v18;
  uint64_t v19;

  v19 = a1;
  v18 = a2 & 1;
  v13 = 0;
  v14 = (float *)&v13;
  v15 = 0x20000000;
  v16 = 32;
  v17 = 0;
  v2 = *(NSObject **)(a1 + 144);
  v5 = (void (*)(void))MEMORY[0x1E0C809B0];
  v6 = -1073741824;
  v7 = 0;
  v8 = __DisplayGetRestrictionFactorTarget_block_invoke;
  v9 = &unk_1E68EB568;
  v10 = &v13;
  v12 = a2 & 1;
  v11 = v19;
  disp_dispatch_sync(v2, &v5);
  v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1B52CE0C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

float DisplayLuminanceToPerceptualLuminance(uint64_t a1, float a2)
{
  NSObject *v2;
  float v4;
  void (*v5)(void);
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t);
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  float v12;
  uint64_t v13;
  float *v14;
  int v15;
  int v16;
  int v17;
  float v18;
  uint64_t v19;

  v19 = a1;
  v18 = a2;
  v13 = 0;
  v14 = (float *)&v13;
  v15 = 0x20000000;
  v16 = 32;
  v17 = 0;
  v2 = *(NSObject **)(a1 + 144);
  v5 = (void (*)(void))MEMORY[0x1E0C809B0];
  v6 = -1073741824;
  v7 = 0;
  v8 = __DisplayLuminanceToPerceptualLuminance_block_invoke;
  v9 = &unk_1E68EB3F0;
  v10 = &v13;
  v11 = v19;
  v12 = a2;
  disp_dispatch_sync(v2, &v5);
  v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1B52CE1AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

void disp_dispatch_sync(NSObject *a1, void (**a2)(void))
{
  if (a1)
    dispatch_sync(a1, a2);
  else
    a2[2]();
}

float AABC::RecordLuminance(AABC *this, float result)
{
  unsigned int i;
  float v3;

  if (*((_QWORD *)this + 497))
  {
    *(float *)(*((_QWORD *)this + 497) + 4 * *((unsigned int *)this + 988)) = result;
    *((_DWORD *)this + 988) = (*((_DWORD *)this + 988) + 1) % *((_DWORD *)this + 990);
    if (*((_DWORD *)this + 989) < *((_DWORD *)this + 990))
      ++*((_DWORD *)this + 989);
    v3 = *((float *)this + 182);
    for (i = 0; i < *((_DWORD *)this + 989); ++i)
      v3 = fminf(v3, *(float *)(*((_QWORD *)this + 497) + 4 * (int)i));
    result = v3;
    *((float *)this + 151) = v3;
  }
  return result;
}

uint64_t AABC::isTrustedOccluded(id **this)
{
  char isTouchObstructed;
  char v3;

  if (!this[60] || (*((_BYTE *)this + 3937) & 1) == 0 || (v3 = 1, !*((_DWORD *)this + 987)))
  {
    isTouchObstructed = 0;
    if (this[57])
      isTouchObstructed = AABC::ALS::isTouchObstructed(this[57]);
    v3 = isTouchObstructed;
  }
  return v3 & 1;
}

void *AABC::getPropertyForClient(AABC *this, const __CFString *a2, const void *a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  uint64_t v8;
  NSObject *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  id v15;
  void *v16;
  void *context;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t inited;
  NSObject *v25;
  float v27;
  void *v28;
  id v29;
  id v30;
  int i;
  id v32;
  id v33;
  CFTypeRef v34;
  int v35;
  CFTypeRef cf;
  CFMutableDictionaryRef v37;
  CFDictionaryRef theDict;
  int v39;
  float valuePtr;
  void *value;
  uint64_t v42;
  uint64_t v43;
  _QWORD v44[4];
  void *v45;
  os_log_type_t v46[31];
  os_log_type_t v47;
  os_log_t v48;
  os_log_type_t v49;
  os_log_t v50;
  __CFDictionary *MutableCopy;
  const __CFDictionary *CurveDictionary;
  void *v53;
  os_log_type_t v54;
  os_log_t v55;
  os_log_type_t type;
  os_log_t v57;
  const void *v58;
  const void *v59;
  AABC *v60;
  uint8_t v61[32];
  CFTypeRef values[15];
  void *keys[15];
  const void *__b[15];
  const void *__dst[15];
  _QWORD v66[3];
  _QWORD v67[3];
  uint8_t v68[16];
  uint8_t v69[16];
  uint8_t v70[32];
  uint8_t v71[8];
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v60 = this;
  v59 = a2;
  v58 = a3;
  v57 = 0;
  if (_logHandle)
  {
    v25 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v25 = inited;
  }
  v57 = v25;
  type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v71, 4);
    _os_log_debug_impl(&dword_1B5291000, v57, type, "[%x]: ", v71, 8u);
  }
  v55 = 0;
  if (_logHandle)
  {
    v23 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v22 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v22 = init_default_corebrightness_log();
    v23 = v22;
  }
  v55 = v23;
  v54 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_2_4_0_8_64((uint64_t)v70, 2, (uint64_t)v59);
    _os_log_debug_impl(&dword_1B5291000, v55, v54, "[%x]: %@", v70, 0x12u);
  }
  v53 = 0;
  if (*((_DWORD *)this + 94))
  {
    if (CFEqual(v59, CFSTR("ALSUserPreference")))
    {
      *((_DWORD *)this + 286) = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 8) + 104))(*((_QWORD *)this + 8));
      CurveDictionary = AABC::createCurveDictionary((uint64_t)this, (char *)this + 1048);
      MutableCopy = 0;
      MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CurveDictionary);
      CFRelease(CurveDictionary);
      if ((*((_BYTE *)this + 3401) & 1) != 0)
      {
        *((_DWORD *)this + 748) = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 8) + 104))(*((_QWORD *)this + 8));
        CurveDictionary = AABC::createCurveDictionary((uint64_t)this, (char *)this + 2896);
        CFDictionaryAddValue(MutableCopy, CFSTR("ReplacementCurve"), CurveDictionary);
        CFRelease(CurveDictionary);
        *((_DWORD *)this + 774) = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 8) + 112))(*((_QWORD *)this + 8));
        CurveDictionary = AABC::createCurveDictionary((uint64_t)this, (char *)this + 3000);
        CFDictionaryAddValue(MutableCopy, CFSTR("AlternativeCurve"), CurveDictionary);
        v50 = 0;
        if (_logHandle)
        {
          v21 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v20 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v20 = init_default_corebrightness_log();
          v21 = v20;
        }
        v50 = v21;
        v49 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_2_1_8_64((uint64_t)v69, (uint64_t)CurveDictionary);
          _os_log_impl(&dword_1B5291000, v50, v49, "Get ALSUserPreference - AlternativeCurve = %@ ", v69, 0xCu);
        }
        CFRelease(CurveDictionary);
        *((_DWORD *)this + 800) = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 8) + 112))(*((_QWORD *)this + 8));
        CurveDictionary = AABC::createCurveDictionary((uint64_t)this, (char *)this + 3104);
        CFDictionaryAddValue(MutableCopy, CFSTR("AlternativeReplacementCurve"), CurveDictionary);
        v48 = 0;
        if (_logHandle)
        {
          v19 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v18 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v18 = init_default_corebrightness_log();
          v19 = v18;
        }
        v48 = v19;
        v47 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_2_1_8_64((uint64_t)v68, (uint64_t)CurveDictionary);
          _os_log_impl(&dword_1B5291000, v48, v47, "Get ALSUserPreference - AlternativeReplacementCurve = %@ ", v68, 0xCu);
        }
        CFRelease(CurveDictionary);
        AAB::GetCurveUpdates(this, (uint64_t)v46);
        if (!std::list<AAB::CurveUpdate>::empty[abi:ne180100]())
        {
          context = (void *)MEMORY[0x1B5E4A8B0]();
          v45 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
          v44[1] = v46;
          v44[0] = std::list<AAB::CurveUpdate>::begin[abi:ne180100]((uint64_t)v46);
          v43 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
          while (std::operator!=[abi:ne180100](v44, &v43))
          {
            v42 = std::__list_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
            v16 = v45;
            v66[0] = CFSTR("Lux");
            LODWORD(v3) = *(_DWORD *)v42;
            v67[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v3);
            v66[1] = CFSTR("Nits");
            LODWORD(v4) = *(_DWORD *)(v42 + 4);
            v67[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v4);
            v66[2] = CFSTR("Timestamp");
            v67[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", *(_QWORD *)(v42 + 8));
            objc_msgSend(v16, "addObject:", objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v67, v66, 3));
            std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)v44);
          }
          CFDictionaryAddValue(MutableCopy, CFSTR("CurveUpdates"), v45);
          objc_autoreleasePoolPop(context);
        }
        (*(void (**)(_QWORD))(**((_QWORD **)this + 8) + 96))(*((_QWORD *)this + 8));
        std::list<AAB::CurveUpdate>::~list((uint64_t)v46);
      }
      if ((*((_BYTE *)this + 3368) & 1) != 0)
      {
        CurveDictionary = AABC::createCurveDictionary((uint64_t)this, (char *)this + 2896);
        CFDictionaryAddValue(MutableCopy, CFSTR("ReplacementCurve"), CurveDictionary);
        CFRelease(CurveDictionary);
        value = AABC::createCurveDescriptorDictionary((uint64_t)this, (_DWORD *)this + 832);
        CFDictionaryAddValue(MutableCopy, CFSTR("Descriptor"), value);
        CFRelease(value);
        if (!v58)
        {
          if (AABC::isCurveGood((uint64_t)this, (uint64_t)this + 1048))
            AABC::writeOutlierRemovalPreferences((uint64_t)this, 0);
          else
            *((_BYTE *)this + 3400) = 1;
        }
      }
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), CFSTR("ALSUserPreference"), MutableCopy);
      v53 = MutableCopy;
      CFRelease(MutableCopy);
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("OutlierRemoval")))
    {
      if (!CFDictionaryGetValueIfPresent(*((CFDictionaryRef *)this + 48), CFSTR("OutlierRemoval"), (const void **)&v53))
        v53 = 0;
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("ALSRequiresProx")))
    {
      v53 = (void *)*MEMORY[0x1E0C9AE50];
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("ALSDimPolicy")))
    {
      v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("ALSDimPolicy"));
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("ALSSpikeFilterDuration")))
    {
      v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("ALSSpikeFilterDuration"));
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("ALSMaxBrightenDuration")))
    {
      v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("ALSMaxBrightenDuration"));
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("ALSInternalSettings")))
    {
      v53 = (void *)*((_QWORD *)this + 49);
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("BrightnessCurveLevel")))
    {
      v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (char *)this + 3404);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("BrightnessCurveLevel"), v53);
        CFRelease(v53);
        v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("BrightnessCurveLevel"));
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("AutoBrightnessLuxFilter")))
    {
      v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (char *)this + 3456);
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("SemanticAmbientLightLevel")))
    {
      v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (char *)this + 588);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), CFSTR("SemanticAmbientLightLevel"), v53);
        CFRelease(v53);
        v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 48), CFSTR("SemanticAmbientLightLevel"));
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("TrustedLux32")))
    {
      v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloat32Type, (char *)this + 544);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("TrustedLux32"), v53);
        CFRelease(v53);
        v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("TrustedLux32"));
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("TrustedLux")))
    {
      v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 544);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("TrustedLux"), v53);
        CFRelease(v53);
        v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("TrustedLux"));
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("TrustedFrontLux")))
    {
      v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 548);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("TrustedFrontLux"), v53);
        CFRelease(v53);
        v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("TrustedFrontLux"));
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("Lux")) || CFEqual(v59, CFSTR("AggregatedLux")))
    {
      v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 536);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("Lux"), v53);
        CFRelease(v53);
        v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("Lux"));
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("VirtualLux")))
    {
      valuePtr = 0.0;
      valuePtr = AABC::LuminanceToIlluminance((uint64_t)this, (float *)this + 262, *((float *)this + 155));
      v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &valuePtr);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("VirtualLux"), v53);
        CFRelease(v53);
        v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("VirtualLux"));
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("ALSCurveInfo")))
    {
      v39 = 2;
      memcpy(__dst, off_1E68EB9C0, sizeof(__dst));
      memset(__b, 0, sizeof(__b));
      __b[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &v39);
      __b[1] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 1064);
      __b[2] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 1072);
      __b[3] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 1068);
      __b[4] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 1076);
      __b[5] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 1048);
      __b[6] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 1052);
      __b[7] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 1056);
      __b[8] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 1060);
      __b[9] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 28);
      __b[10] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 20);
      __b[11] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 24);
      __b[12] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 32);
      __b[13] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 36);
      __b[14] = AABC::createCurvePrefsDictionary((uint64_t)this, (char *)this + 1080);
      theDict = 0;
      theDict = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __dst, __b, 15, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFRelease(__b[14]);
      CFRelease(__b[13]);
      CFRelease(__b[12]);
      CFRelease(__b[11]);
      CFRelease(__b[10]);
      CFRelease(__b[9]);
      CFRelease(__b[8]);
      CFRelease(__b[7]);
      CFRelease(__b[6]);
      CFRelease(__b[5]);
      CFRelease(__b[4]);
      CFRelease(__b[3]);
      CFRelease(__b[2]);
      CFRelease(__b[1]);
      CFRelease(__b[0]);
      if ((*((_BYTE *)this + 3368) & 1) != 0)
      {
        v37 = 0;
        v37 = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, theDict);
        CFRelease(theDict);
        cf = AABC::createCurveDescriptorDictionary((uint64_t)this, (_DWORD *)this + 832);
        CFDictionaryAddValue(v37, CFSTR("Descriptor"), cf);
        CFRelease(cf);
        theDict = v37;
      }
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), CFSTR("ALSCurveInfo"), theDict);
      v53 = theDict;
      CFRelease(theDict);
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("ALSAlternativeCurveInfo")))
    {
      v35 = 2;
      memcpy(keys, off_1E68EBA38, sizeof(keys));
      memset(values, 0, sizeof(values));
      values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &v35);
      values[1] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 3016);
      values[2] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 3024);
      values[3] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 3020);
      values[4] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 3028);
      values[5] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 3000);
      values[6] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 3004);
      values[7] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 3008);
      values[8] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 3012);
      values[9] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 28);
      values[10] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 20);
      values[11] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 24);
      values[12] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 32);
      values[13] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 36);
      values[14] = AABC::createCurvePrefsDictionary((uint64_t)this, (char *)this + 3032);
      v34 = 0;
      v34 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, values, 15, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFRelease(values[14]);
      CFRelease(values[13]);
      CFRelease(values[12]);
      CFRelease(values[11]);
      CFRelease(values[10]);
      CFRelease(values[9]);
      CFRelease(values[8]);
      CFRelease(values[7]);
      CFRelease(values[6]);
      CFRelease(values[5]);
      CFRelease(values[4]);
      CFRelease(values[3]);
      CFRelease(values[2]);
      CFRelease(values[1]);
      CFRelease(values[0]);
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), CFSTR("ALSAlternativeCurveInfo"), v34);
      v53 = (void *)v34;
      CFRelease(v34);
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("AODDarkerCurve")))
    {
      if (*((int *)this + 716) > 0)
      {
        v33 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
        v32 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
        for (i = 0; i < *((_DWORD *)this + 716); ++i)
        {
          v30 = 0;
          v15 = objc_alloc(MEMORY[0x1E0CB37E8]);
          LODWORD(v5) = *((_DWORD *)this + i + 676);
          v30 = (id)objc_msgSend(v15, "initWithFloat:", v5);
          v29 = 0;
          v14 = objc_alloc(MEMORY[0x1E0CB37E8]);
          LODWORD(v6) = *((_DWORD *)this + i + 696);
          v29 = (id)objc_msgSend(v14, "initWithFloat:", v6);
          objc_msgSend(v33, "addObject:", v30);
          objc_msgSend(v32, "addObject:", v29);

        }
        v28 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D80]), "initWithObjectsAndKeys:", v33, CFSTR("lux"), v32, CFSTR("nits"), 0);
        v53 = v28;

        if (v28)
        {
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("AODDarkerCurve"), v53);
          CFRelease(v53);
          v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("AODDarkerCurve"));
        }
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("ALSDefaultCurves")))
      goto LABEL_153;
    if (CFEqual(v59, CFSTR("EcoMode")))
    {
      if ((*((_BYTE *)this + 3416) & 1) != 0)
        v13 = (void *)*MEMORY[0x1E0C9AE50];
      else
        v13 = (void *)*MEMORY[0x1E0C9AE40];
      v53 = v13;
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("CBAutoBrightnessAvailable")))
    {
      if (*((_DWORD *)this + 129))
        v12 = (void *)*MEMORY[0x1E0C9AE50];
      else
        v12 = (void *)*MEMORY[0x1E0C9AE40];
      v53 = v12;
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("ALSBrightenPdeltaSlow")))
    {
      v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 4000);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("ALSBrightenPdeltaSlow"), v53);
        CFRelease(v53);
        v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("ALSBrightenPdeltaSlow"));
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("ALSBrightenPdeltaFast")))
    {
      v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 3996);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("ALSBrightenPdeltaFast"), v53);
        CFRelease(v53);
        v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("ALSBrightenPdeltaFast"));
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("ALSDimPdeltaSlow")))
    {
      v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 3988);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("ALSDimPdeltaSlow"), v53);
        CFRelease(v53);
        v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("ALSDimPdeltaSlow"));
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("Aggressivity")))
    {
      v27 = 0.0;
      v27 = (float)*((unsigned int *)this + 142);
      v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v27);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("Aggressivity"), v53);
        CFRelease(v53);
        v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("Aggressivity"));
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("ProxMitigationTriggered")))
    {
      if (*((_QWORD *)this + 60) && (*((_BYTE *)this + 3937) & 1) != 0 && *((_DWORD *)this + 987))
        v11 = (void *)*MEMORY[0x1E0C9AE50];
      else
        v11 = (void *)*MEMORY[0x1E0C9AE40];
      v53 = v11;
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("TouchMitigationTriggered")))
    {
      if (*((_QWORD *)this + 57) && (AABC::ALS::isTouchObstructed(*((id **)this + 57)) & 1) != 0)
        v10 = (void *)*MEMORY[0x1E0C9AE50];
      else
        v10 = (void *)*MEMORY[0x1E0C9AE40];
      v53 = v10;
      goto LABEL_154;
    }
    if (CFEqual(v59, CFSTR("BrightnessCapabilities")))
    {
      v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("BrightnessCapabilities"));
      goto LABEL_154;
    }
    if (!CFEqual(v59, CFSTR("ALSIntegrationMode")))
    {
LABEL_153:
      v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 48), v59);
      goto LABEL_154;
    }
    v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (char *)this + 668);
    if (v53)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("ALSIntegrationMode"), v53);
      CFRelease(v53);
      v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), CFSTR("ALSIntegrationMode"));
    }
  }
LABEL_154:
  if (_logHandle)
  {
    v9 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v8 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v8 = init_default_corebrightness_log();
    v9 = v8;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v61, 2, (uint64_t)v59, (uint64_t)v53);
    _os_log_debug_impl(&dword_1B5291000, v9, OS_LOG_TYPE_DEBUG, "[%x]: %@ result=%@", v61, 0x1Cu);
  }
  return v53;
}

void sub_1B52D1980()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_1_8_32(uint64_t result, uint64_t a2)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 1;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  return result;
}

void sub_1B52D2B70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, int a16, _Unwind_Exception *exception_object)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

uint64_t init_default_corebrightness_log()
{
  NSObject *log;
  os_log_type_t type;
  uint8_t v3[7];
  char v4;
  NSObject *v5;

  _COREBRIGHTNESS_LOG_DEFAULT = (uint64_t)os_log_create("com.apple.CoreBrightness", "default");
  if (!_COREBRIGHTNESS_LOG_DEFAULT)
  {
    v5 = MEMORY[0x1E0C81028];
    v4 = 16;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      log = v5;
      type = v4;
      __os_log_helper_16_0_0(v3);
      _os_log_error_impl(&dword_1B5291000, log, type, "Failed to create CoreBrightness default log", v3, 2u);
    }
    _COREBRIGHTNESS_LOG_DEFAULT = MEMORY[0x1E0C81028];
  }
  return _COREBRIGHTNESS_LOG_DEFAULT;
}

_BYTE *__os_log_helper_16_0_0(_BYTE *result)
{
  *result = 0;
  result[1] = 0;
  return result;
}

void SetBLDriverNitsValue(float *a1, int a2)
{
  const __CFAllocator *v2;
  NSObject *v3;
  const __CFAllocator *v4;
  NSObject *v5;
  const __CFAllocator *v6;
  NSObject *v7;
  const __CFAllocator *v8;
  NSObject *v9;
  uint64_t inited;
  NSObject *v11;
  uint64_t v12;
  int v13;
  int v14;
  void (*v15)(uint64_t);
  void *v16;
  float *v17;
  CFTypeRef v18;
  uint64_t v19;
  int v20;
  int v21;
  float (*v22)(uint64_t);
  void *v23;
  float *v24;
  CFTypeRef cf;
  uint64_t v26;
  int v27;
  int v28;
  float (*v29)(uint64_t);
  void *v30;
  float *v31;
  CFNumberRef v32;
  uint64_t block;
  int v34;
  int v35;
  void (*v36)(uint64_t);
  void *v37;
  float *v38;
  float v39;
  float v40;
  float v41;
  CFNumberRef v42;
  float v43;
  float v44;
  float v45;
  os_log_type_t v46;
  os_log_t v47;
  int valuePtr;
  float *v49;
  uint8_t v50[24];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v49 = a1;
  valuePtr = a2;
  v47 = 0;
  if (_logHandle)
  {
    v11 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v11 = inited;
  }
  v47 = v11;
  v46 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v50, COERCE__INT64((float)((float)valuePtr / 65536.0)));
    _os_log_debug_impl(&dword_1B5291000, v47, v46, "Setting BL nits value to %f", v50, 0xCu);
  }
  v49[381] = (float)valuePtr / 65536.0;
  if (((_BYTE)v49[379] & 1) != 0)
  {
    if ((*((_BYTE *)v49 + 321) & 1) != 0 || (CBU_ForceFrameAfterBrightnessUpdate() & 1) == 0)
    {
      v41 = (float)valuePtr / 65536.0;
      v40 = 0.0;
      v40 = v49[383];
      if (v41 >= v40 || valuePtr <= 0)
      {
        if (valuePtr > 0)
        {
          v5 = *((_QWORD *)v49 + 18);
          v26 = MEMORY[0x1E0C809B0];
          v27 = -1073741824;
          v28 = 0;
          v29 = __SetBLDriverNitsValue_block_invoke_2;
          v30 = &__block_descriptor_40_e5_v8__0l;
          v31 = v49;
          dispatch_async(v5, &v26);
        }
        v6 = CFGetAllocator(v49);
        cf = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
        if (cf)
        {
          __DisplaySetBLDriverProperty((uint64_t)v49, CFSTR("brightness-nits"), cf);
          CFRelease(cf);
          SetIOMFBBrightness(v49, valuePtr, 0);
        }
        if (!valuePtr)
        {
          v7 = *((_QWORD *)v49 + 18);
          v19 = MEMORY[0x1E0C809B0];
          v20 = -1073741824;
          v21 = 0;
          v22 = __SetBLDriverNitsValue_block_invoke_3;
          v23 = &__block_descriptor_40_e5_v8__0l;
          v24 = v49;
          dispatch_async(v7, &v19);
        }
      }
      else
      {
        v3 = *((_QWORD *)v49 + 18);
        block = MEMORY[0x1E0C809B0];
        v34 = -1073741824;
        v35 = 0;
        v36 = __SetBLDriverNitsValue_block_invoke;
        v37 = &__block_descriptor_44_e5_v8__0l;
        v38 = v49;
        v39 = v41;
        dispatch_async(v3, &block);
        valuePtr = (int)(float)(v40 * 65536.0);
        v4 = CFGetAllocator(v49);
        v32 = CFNumberCreate(v4, kCFNumberSInt32Type, &valuePtr);
        if (v32)
        {
          __DisplaySetBLDriverProperty((uint64_t)v49, CFSTR("brightness-nits"), v32);
          CFRelease(v32);
          SetIOMFBBrightness(v49, valuePtr, 0);
        }
      }
    }
    else
    {
      v45 = (float)valuePtr / 65536.0;
      v44 = 0.0;
      v44 = v49[383];
      v43 = 1.0;
      if (v45 < v44 && valuePtr > 0)
      {
        valuePtr = (int)(float)(v44 * 65536.0);
        v43 = v45 / v49[383];
      }
      v2 = CFGetAllocator(v49);
      v42 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
      if (v42)
      {
        __DisplaySetBLDriverProperty((uint64_t)v49, CFSTR("brightness-nits"), v42);
        CFRelease(v42);
        SetIOMFBBrightness(v49, valuePtr, 0);
      }
      SetWiggledDigitalDimmingScalar((uint64_t)v49, v43);
    }
  }
  else
  {
    v8 = CFGetAllocator(v49);
    v18 = CFNumberCreate(v8, kCFNumberSInt32Type, &valuePtr);
    if (v18)
    {
      __DisplaySetBLDriverProperty((uint64_t)v49, CFSTR("brightness-nits"), v18);
      CFRelease(v18);
      SetIOMFBBrightness(v49, valuePtr, 0);
      if ((*((_BYTE *)v49 + 321) & 1) == 0 && (CBU_ForceFrameAfterBrightnessUpdate() & 1) != 0)
      {
        v9 = *((_QWORD *)v49 + 18);
        v12 = MEMORY[0x1E0C809B0];
        v13 = -1073741824;
        v14 = 0;
        v15 = __SetBLDriverNitsValue_block_invoke_4;
        v16 = &__block_descriptor_40_e5_v8__0l;
        v17 = v49;
        dispatch_async(v9, &v12);
      }
    }
  }
}

float __DisplayPhysicalToLogicalBrightness(uint64_t a1, float a2)
{
  float v3;
  float v4;

  v4 = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
  v3 = 0.0;
  if (*(float *)(a1 + 348) > 0.0)
  {
    if (*(float *)(a1 + 348) < 1.0)
      return _DisplayPerceptualLuminanceToLuminanceInternal(a1, v4 / *(float *)(a1 + 348));
    else
      return a2;
  }
  return v3;
}

void __DisplaySetLogicalBrightnessInternal(const void *a1, int a2, float a3)
{
  float v3;
  float v4;
  float v5;
  const __CFAllocator *v6;
  const __CFAllocator *v7;
  NSObject *v8;
  const __CFAllocator *v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  const __CFAllocator *v15;
  float v16;
  float v17;
  float v18;
  CFTypeRef v19;
  CFTypeRef v20;
  CFTypeRef v21;
  uint64_t v22;
  NSObject *v23;
  CFTypeRef v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  CFTypeRef v29;
  CFTypeRef v30;
  char v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  NSObject *v39;
  NSObject *v40;
  os_log_type_t v41;
  uint64_t v42;
  NSObject *v43;
  uint64_t v44;
  NSObject *v45;
  uint64_t v46;
  NSObject *v47;
  uint64_t v48;
  NSObject *v49;
  uint64_t v50;
  NSObject *v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t v54;
  NSObject *v55;
  float v56;
  uint64_t v57;
  NSObject *v58;
  uint64_t v59;
  NSObject *v60;
  uint64_t v61;
  NSObject *v62;
  uint64_t v63;
  NSObject *v64;
  uint64_t v65;
  NSObject *v66;
  uint64_t v67;
  NSObject *v68;
  uint64_t v69;
  NSObject *v70;
  uint64_t inited;
  NSObject *v72;
  uint64_t v73;
  NSObject *v74;
  int v75;
  uint64_t v76;
  NSObject *v77;
  float v78;
  float v79;
  CFNumberRef v80;
  int v81;
  float v82;
  float v83;
  CFTypeRef v84;
  float v85;
  unsigned int v86;
  BOOL v87;
  os_log_type_t v88;
  os_log_t v89;
  float v90;
  CFTypeRef v91;
  int v92;
  os_log_type_t v93;
  os_log_t v94;
  char v95;
  uint64_t block;
  int v97;
  int v98;
  void (*v99)(uint64_t);
  void *v100;
  CFTypeRef v101;
  CFMutableDictionaryRef v102;
  char v103;
  CFMutableDictionaryRef theDict;
  CFTypeRef v105;
  os_log_type_t v106;
  os_log_t v107;
  unsigned int APLColumnOrDefault;
  char v109;
  float v110;
  float v111;
  int v112;
  os_log_type_t v113;
  os_log_t v114;
  float v115;
  void *value;
  uint64_t v117;
  int v118;
  os_log_type_t v119;
  os_log_t v120;
  os_log_type_t v121;
  os_log_t v122;
  os_log_type_t v123;
  os_log_t v124;
  uint8_t v125[15];
  os_log_type_t v126;
  os_log_t v127;
  os_log_type_t v128;
  os_log_t v129;
  os_log_type_t v130;
  os_log_t v131;
  os_log_type_t v132;
  os_log_t v133;
  os_log_type_t v134;
  os_log_t v135;
  os_log_type_t v136;
  os_log_t v137;
  float v138;
  os_log_type_t v139;
  os_log_t v140;
  os_log_type_t v141;
  os_log_t v142;
  int v143;
  int v144;
  os_log_type_t v145;
  os_log_t v146;
  float v147;
  float v148;
  os_log_type_t v149;
  os_log_t v150;
  float v151;
  os_log_type_t v152;
  os_log_t v153;
  float v154;
  os_log_type_t v155;
  os_log_t v156;
  float v157;
  float v158;
  os_log_type_t v159;
  os_log_t v160;
  float v161;
  float v162;
  float v163;
  float v164;
  os_log_type_t v165;
  os_log_t v166;
  os_log_type_t v167;
  os_log_t v168;
  float v169;
  os_log_type_t v170;
  os_log_t v171;
  float valuePtr;
  os_log_type_t type;
  os_log_t oslog;
  float v175;
  double v176;
  double Current;
  float v178;
  float v179;
  int v180;
  float v181;
  CFTypeRef cf;
  uint8_t v183[48];
  uint8_t v184[48];
  uint8_t v185[32];
  uint8_t v186[32];
  uint8_t v187[80];
  uint8_t v188[32];
  uint8_t v189[16];
  uint8_t v190[16];
  uint8_t v191[16];
  uint8_t v192[32];
  uint8_t v193[32];
  uint8_t v194[32];
  uint8_t v195[32];
  uint8_t v196[64];
  uint8_t v197[32];
  uint8_t v198[32];
  uint8_t v199[32];
  uint8_t v200[48];
  uint8_t v201[48];
  uint8_t v202[32];
  uint8_t v203[32];
  uint8_t v204[32];
  uint8_t v205[24];
  uint64_t v206;

  v206 = *MEMORY[0x1E0C80C00];
  cf = a1;
  v181 = a3;
  v180 = a2;
  v179 = 0.0;
  if ((a2 & 0x8000u) != 0)
  {
    *((_DWORD *)cf + 319) = *((_DWORD *)cf + 314);
    *((_DWORD *)cf + 374) = *((_DWORD *)cf + 372);
    *((_DWORD *)cf + 320) = *((_DWORD *)cf + 315);
    *((_DWORD *)cf + 3140) = *((_DWORD *)cf + 3138);
  }
  *((float *)cf + 3138) = v181;
  *((float *)cf + 314) = v181;
  if (!*((_DWORD *)cf + 10))
    *((float *)cf + 372) = v181;
  if ((*((_BYTE *)cf + 12548) & 1) == 0)
  {
    if ((*((_BYTE *)cf + 1144) & 1) != 0 && *((float *)cf + 287) != 0.0)
      v181 = *((float *)cf + 287);
    if (getClientOverrideState((uint64_t)cf, 0) && *((float *)cf + 241) != 0.0)
      v181 = *((float *)cf + 241);
    v178 = __DisplayLogicalToPhysicalBrightness((uint64_t)cf, v181);
    if (*((float *)cf + 87) == 1.0
      && *((float *)cf + 314) < *((float *)cf + 131)
      && *((float *)cf + 131) > *((float *)cf + 100)
      && *((float *)cf + 132) > *((float *)cf + 131))
    {
      Current = CFAbsoluteTimeGetCurrent();
      v176 = 0.0;
      v3 = Current - *((double *)cf + 72) - *((double *)cf + 71);
      v176 = fmaxf(v3, 0.0);
      if (v176 > 0.0)
      {
        *((_QWORD *)cf + 74) = 0;
        *((_DWORD *)cf + 132) = *((_DWORD *)cf + 131);
        v175 = 0.0;
        v175 = _DisplayLuminanceToPerceptualLuminanceInternal((uint64_t)cf, *((float *)cf + 131));
        *((float *)cf + 153) = v175;
        *((float *)cf + 154) = v175;
        *((float *)cf + 152) = v175;
        oslog = 0;
        if (_logHandle)
        {
          v77 = _logHandle;
        }
        else
        {
          v76 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          v77 = v76;
        }
        oslog = v77;
        type = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v205, COERCE__INT64(*((float *)cf + 132)), COERCE__INT64(*((float *)cf + 314)));
          _os_log_debug_impl(&dword_1B5291000, oslog, type, "Display: Update weak cap to %f on low brightness %f", v205, 0x16u);
        }
      }
    }
    v178 = fminf(v178, *((float *)cf + 132));
    valuePtr = v178;
    if ((*((_BYTE *)cf + 1144) & 1) == 0)
    {
      v75 = *((_DWORD *)cf + 160);
      if (v75 == 1)
      {
        if (*((float *)cf + 162) != 1.0)
        {
          valuePtr = valuePtr * *((float *)cf + 162);
          v171 = 0;
          if (_logHandle)
          {
            v74 = _logHandle;
          }
          else
          {
            v73 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            v74 = v73;
          }
          v171 = v74;
          v170 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_8_0_8_0((uint64_t)v204, COERCE__INT64(*((float *)cf + 162)), COERCE__INT64(valuePtr));
            _os_log_debug_impl(&dword_1B5291000, v171, v170, "EcoModeFactor: %0.2f -> L_device: %f\n", v204, 0x16u);
          }
        }
      }
      else if (v75 == 2)
      {
        v169 = 0.0;
        v169 = *((float *)cf + 195);
        if ((*((_DWORD *)cf + 55) || *((double *)cf + 98) != 0.0) && valuePtr > v169)
        {
          v168 = 0;
          if (_logHandle)
          {
            v72 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              inited = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              inited = init_default_corebrightness_log();
            v72 = inited;
          }
          v168 = v72;
          v167 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_8_0_8_0((uint64_t)v203, COERCE__INT64(v169), COERCE__INT64(valuePtr));
            _os_log_debug_impl(&dword_1B5291000, v168, v167, "EcoModeLimit: %f -> L_device: %f\n", v203, 0x16u);
          }
          valuePtr = v169;
        }
      }
    }
    if (*((_QWORD *)cf + 41))
    {
      if ((objc_msgSend(*((id *)cf + 41), "isActive") & 1) != 0)
      {
        valuePtr = valuePtr * *(float *)(objc_msgSend(*((id *)cf + 41), "fade") + 20);
        if (*(float *)(objc_msgSend(*((id *)cf + 41), "fade") + 20) != 1.0)
        {
          v166 = 0;
          if (_logHandle)
          {
            v70 = _logHandle;
          }
          else
          {
            v69 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            v70 = v69;
          }
          v166 = v70;
          v165 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_8_0_8_0((uint64_t)v202, COERCE__INT64(*(float *)(objc_msgSend(*((id *)cf + 41), "fade") + 20)), COERCE__INT64(valuePtr));
            _os_log_debug_impl(&dword_1B5291000, v166, v165, "SoftWakeFactor: %0.2f -> L_device: %f", v202, 0x16u);
          }
        }
      }
    }
    v164 = 0.0;
    v164 = *((float *)cf + 244);
    v163 = 0.0;
    v163 = *((float *)cf + 245);
    if ((*((_BYTE *)cf + 1144) & 1) == 0)
    {
      if (v164 == v163 || (*((_BYTE *)cf + 1048) & 1) != 0 || (*((_BYTE *)cf + 1120) & 1) != 0)
      {
        if (valuePtr > v164 || valuePtr == 0.0)
        {
          if (valuePtr > v164 && (*((_BYTE *)cf + 1120) & 1) == 0)
          {
            v151 = 0.0;
            v151 = (float)(v164 - (float)(*((float *)cf + 264) * *((float *)cf + 328)))
                 / (float)(v164 - *((float *)cf + 328));
            valuePtr = v164 - (float)(v151 * (float)(v164 - valuePtr));
            v150 = 0;
            if (_logHandle)
            {
              v62 = _logHandle;
            }
            else
            {
              v61 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              v62 = v61;
            }
            v150 = v62;
            v149 = OS_LOG_TYPE_DEBUG;
            if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v198, COERCE__INT64(v151), COERCE__INT64(valuePtr), COERCE__INT64(*((float *)cf + 264)));
              _os_log_debug_impl(&dword_1B5291000, v150, v149, "Min scaler: %f  %f %f", v198, 0x20u);
            }
          }
        }
        else if ((*((_BYTE *)cf + 1048) & 1) == 0)
        {
          v154 = 0.0;
          v154 = (float)(v164 - (float)(*((float *)cf + 246) * *((float *)cf + 330)))
               / (float)(v164 - *((float *)cf + 330));
          valuePtr = v164 - (float)(v154 * (float)(v164 - valuePtr));
          v153 = 0;
          if (_logHandle)
          {
            v64 = _logHandle;
          }
          else
          {
            v63 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            v64 = v63;
          }
          v153 = v64;
          v152 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v199, COERCE__INT64(v154), COERCE__INT64(valuePtr), COERCE__INT64(*((float *)cf + 246)));
            _os_log_debug_impl(&dword_1B5291000, v153, v152, "Min scaler: %f  %f %f", v199, 0x20u);
          }
        }
      }
      else if (valuePtr > 0.0)
      {
        v162 = valuePtr;
        v161 = 0.0;
        if (valuePtr > v163)
        {
          v161 = (float)(v163 - (float)(*((float *)cf + 264) * *((float *)cf + 328)))
               / (float)(v163 - *((float *)cf + 328));
          v162 = v163 - (float)(v161 * (float)(v163 - valuePtr));
        }
        if (v162 <= v164)
        {
          v158 = 0.0;
          v157 = 0.0;
          v157 = (float)(v164 - (float)(*((float *)cf + 246) * *((float *)cf + 330)))
               / (float)(v164 - *((float *)cf + 330));
          v158 = v164 - (float)(v157 * (float)(v164 - v162));
          v156 = 0;
          if (_logHandle)
          {
            v66 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v65 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v65 = init_default_corebrightness_log();
            v66 = v65;
          }
          v156 = v66;
          v155 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v200, COERCE__INT64(valuePtr), COERCE__INT64(v158), COERCE__INT64(v157), COERCE__INT64(*((float *)cf + 246)));
            _os_log_debug_impl(&dword_1B5291000, v156, v155, "Pivoting - LEFT restriction: L_device %f -> %f, ScalerMin = %f, Fmin = %f", v200, 0x2Au);
          }
          valuePtr = v158;
        }
        else
        {
          v160 = 0;
          if (_logHandle)
          {
            v68 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v67 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v67 = init_default_corebrightness_log();
            v68 = v67;
          }
          v160 = v68;
          v159 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v201, COERCE__INT64(valuePtr), COERCE__INT64(v162), COERCE__INT64(v161), COERCE__INT64(*((float *)cf + 264)));
            _os_log_debug_impl(&dword_1B5291000, v160, v159, "Pivoting - RIGHT restriction: L_device %f -> %f, ScalerMax = %f, Fmax = %f", v201, 0x2Au);
          }
          valuePtr = v162;
        }
      }
    }
    if (valuePtr > 0.0)
    {
      if (!*((_DWORD *)cf + 57) && *((double *)cf + 105) != 0.0)
        *((float *)cf + 214) = _DisplayLuminanceToPerceptualLuminanceInternal((uint64_t)cf, valuePtr);
      if (*((_DWORD *)cf + 57) || *((double *)cf + 105) != 0.0)
        valuePtr = fminf(valuePtr, *((float *)cf + 208));
    }
    v148 = 0.0;
    v148 = *((float *)cf + 328);
    if ((*((_BYTE *)cf + 1120) & 1) == 0)
      v148 = v148 * *((float *)cf + 264);
    v148 = fminf(fminf(v148, *((float *)cf + 116)), *((float *)cf + 132));
    if (*((float *)cf + 285) < 1.0)
      v148 = *((float *)cf + 330) + (float)(*((float *)cf + 285) * (float)(v148 - *((float *)cf + 330)));
    if (!getClientOverrideState((uint64_t)cf, 0))
    {
      valuePtr = valuePtr * *((float *)cf + 3236);
      v148 = v148 * *((float *)cf + 3236);
    }
    v147 = 0.0;
    v147 = *((float *)cf + 181);
    if ((*((_DWORD *)cf + 56) || *((double *)cf + 91) != 0.0) && valuePtr > v147)
    {
      v146 = 0;
      if (_logHandle)
      {
        v60 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v59 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v59 = init_default_corebrightness_log();
        v60 = v59;
      }
      v146 = v60;
      v145 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v197, COERCE__INT64(v147), COERCE__INT64(valuePtr));
        _os_log_debug_impl(&dword_1B5291000, v146, v145, "Domino ModeLimit: %f -> L_device: %f\n", v197, 0x16u);
      }
      valuePtr = v147;
      v148 = fminf(v148, v147);
    }
    v144 = (int)(v148 * 65536.0);
    v179 = _DisplayComputeEDRNitsCap((uint64_t)cf);
    v143 = (int)(v179 * 65536.0);
    v142 = 0;
    if (_logHandle)
    {
      v58 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v57 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v57 = init_default_corebrightness_log();
      v58 = v57;
    }
    v142 = v58;
    v141 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
    {
      if ((*((_BYTE *)cf + 1120) & 1) != 0)
        v56 = 0.0;
      else
        v56 = *((float *)cf + 264);
      __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v196, COERCE__INT64(*((float *)cf + 116)), COERCE__INT64(*((float *)cf + 132)), COERCE__INT64(*((float *)cf + 285)), COERCE__INT64(v56), COERCE__INT64(v179));
      _os_log_debug_impl(&dword_1B5291000, v142, v141, "SetLogicalBrightnessInternal caps: cltm %f,  weakcap: %f, gl.scalar: %f, dyn.sl: %f, edrcap: %f", v196, 0x34u);
    }
    v140 = 0;
    if (_logHandle)
    {
      v55 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v54 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v54 = init_default_corebrightness_log();
      v55 = v54;
    }
    v140 = v55;
    v139 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_2_8_0_8_0((uint64_t)v195, COERCE__INT64(v148), COERCE__INT64(v179));
      _os_log_debug_impl(&dword_1B5291000, v140, v139, "Caps after global scaling: nitsCap=%f nitsCapEDR=%f", v195, 0x16u);
    }
    v138 = 0.0;
    v138 = (float)*((int *)cf + 283) / 65536.0;
    if (*((_DWORD *)cf + 3150) == 2)
    {
      v137 = 0;
      if (_logHandle)
      {
        v53 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v52 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v52 = init_default_corebrightness_log();
        v53 = v52;
      }
      v137 = v53;
      v136 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v194, COERCE__INT64(v138), COERCE__INT64(v179));
        _os_log_debug_impl(&dword_1B5291000, v137, v136, "SLBI EDR_ENABLED current=%f, calculated=%f", v194, 0x16u);
      }
    }
    else if (*((_DWORD *)cf + 3150) == 1)
    {
      v135 = 0;
      if (_logHandle)
      {
        v51 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v50 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v50 = init_default_corebrightness_log();
        v51 = v50;
      }
      v135 = v51;
      v134 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v193, COERCE__INT64(v138), COERCE__INT64(v179));
        _os_log_debug_impl(&dword_1B5291000, v135, v134, "SLBI EDR_DISABLED_RAMP_PENDING current=%f, calculated=%f", v193, 0x16u);
      }
    }
    else
    {
      v133 = 0;
      if (_logHandle)
      {
        v49 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v48 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v48 = init_default_corebrightness_log();
        v49 = v48;
      }
      v133 = v49;
      v132 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v192, COERCE__INT64(v138), COERCE__INT64(v179));
        _os_log_debug_impl(&dword_1B5291000, v133, v132, "SLBI other current=%f, calculated=%f", v192, 0x16u);
      }
    }
    if (*((_DWORD *)cf + 3150) == 2 || *((_DWORD *)cf + 3150) == 1)
    {
      if (v143 != *((_DWORD *)cf + 283))
      {
        v131 = 0;
        if (_logHandle)
        {
          v47 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v46 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v46 = init_default_corebrightness_log();
          v47 = v46;
        }
        v131 = v47;
        v130 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v191, COERCE__INT64((float)((float)v143 / 65536.0)));
          _os_log_debug_impl(&dword_1B5291000, v131, v130, "SetBLDriverNitsCap for EDR_ENABLED | EDR_DISABLED_RAMP_PENDING in setlogicalbrightnessinternal to %f", v191, 0xCu);
        }
        if ((*((_BYTE *)cf + 1517) & 1) == 0)
          SetBLDriverNitsCapIfNotInLPM((uint64_t)cf, v143);
        *((_DWORD *)cf + 283) = v143;
      }
      if (v144 != *((_DWORD *)cf + 282))
        *((_DWORD *)cf + 282) = v144;
    }
    else if (v144 != *((_DWORD *)cf + 282))
    {
      v129 = 0;
      if (_logHandle)
      {
        v45 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v44 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v44 = init_default_corebrightness_log();
        v45 = v44;
      }
      v129 = v45;
      v128 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v190, COERCE__INT64(v148));
        _os_log_debug_impl(&dword_1B5291000, v129, v128, "Changing nitsCap to %f\n", v190, 0xCu);
      }
      v127 = 0;
      if (_logHandle)
      {
        v43 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v42 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v42 = init_default_corebrightness_log();
        v43 = v42;
      }
      v127 = v43;
      v126 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
      {
        v40 = v127;
        v41 = v126;
        __os_log_helper_16_0_0(v125);
        _os_log_debug_impl(&dword_1B5291000, v40, v41, "SetBLDriverNitsCap for !EDR_ENABLED in setlogicalbrightnessinternal", v125, 2u);
      }
      SetBLDriverNitsCapIfNotInLPM((uint64_t)cf, v144);
      *((_DWORD *)cf + 282) = v144;
    }
    if (*((float *)cf + 87) > 0.0)
    {
      if (_DisplayCLTMRev2Applicable((uint64_t)cf))
      {
        if (*((_DWORD *)cf + 389) == 1 && *((float *)cf + 388) == 0.0 && *((float *)cf + 123) == 0.0)
        {
          valuePtr = 0.0;
        }
        else
        {
          valuePtr = fminf(valuePtr, *((float *)cf + 116));
          valuePtr = fmaxf(valuePtr, *((float *)cf + 100));
          valuePtr = fmaxf(valuePtr, *((float *)cf + 330));
          valuePtr = fminf(valuePtr, *((float *)cf + 328));
        }
      }
      else
      {
        valuePtr = fmaxf(valuePtr, *((float *)cf + 100));
        if (float_equal(*((float *)cf + 3236), 1.0) || *((float *)cf + 116) < *((float *)cf + 3254))
          valuePtr = fminf(valuePtr, *((float *)cf + 116));
        if (*((float *)cf + 285) < 1.0)
        {
          valuePtr = *((float *)cf + 330) + (float)(*((float *)cf + 285) * (float)(valuePtr - *((float *)cf + 330)));
          v124 = 0;
          if (_logHandle)
          {
            v39 = _logHandle;
          }
          else
          {
            v38 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            v39 = v38;
          }
          v124 = v39;
          v123 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_1_8_0((uint64_t)v189, COERCE__INT64(valuePtr));
            _os_log_debug_impl(&dword_1B5291000, v124, v123, "Brightness after global scaling: %f", v189, 0xCu);
          }
        }
        if (-[CBAODState isAODActive](+[CBAODState sharedInstance](CBAODState, "sharedInstance"), "isAODActive"))
        {
          valuePtr = fmaxf(valuePtr, *((float *)cf + 385));
        }
        else
        {
          valuePtr = fmaxf(valuePtr, *((float *)cf + 330));
        }
        if (float_equal(*((float *)cf + 3236), 1.0))
        {
          valuePtr = fminf(valuePtr, *((float *)cf + 328));
          valuePtr = fminf(valuePtr, *((float *)cf + 132));
        }
        else
        {
          valuePtr = fminf(valuePtr, *((float *)cf + 386));
        }
      }
    }
    if ((*((_BYTE *)cf + 972) & 1) != 0
      && valuePtr != 0.0
      && (*((_BYTE *)cf + 1284) & 1) == 0
      && (v180 & 0x100) == 0
      && (v180 & 0x8000u) == 0
      && (v180 & 0x1000) == 0
      && ((*((_BYTE *)cf + 321) & 1) == 0 || (v180 & 0x40) == 0)
      && vabds_f32(*((float *)cf + 317), valuePtr) <= 0.003 * *((float *)cf + 317)
      && (*((_BYTE *)cf + 12712) & 1) == 0)
    {
      v122 = 0;
      if (_logHandle)
      {
        v37 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v36 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v36 = init_default_corebrightness_log();
        v37 = v36;
      }
      v122 = v37;
      v121 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v188, COERCE__INT64(*((float *)cf + 317)), COERCE__INT64(valuePtr));
        _os_log_debug_impl(&dword_1B5291000, v122, v121, "Skip processing of backlight update - L = %f -> %f", v188, 0x16u);
      }
      if ((*((_BYTE *)cf + 321) & 1) == 0
        && (CBU_ForceUpdateFrequencyAndFrameSkip() & 1) != 0
        && !*((_DWORD *)cf + 3150))
      {
        *((_DWORD *)cf + 317) = 0;
      }
      return;
    }
    if ((v180 & 0x8000u) == 0)
      *((float *)cf + 317) = valuePtr;
    v120 = 0;
    if (_logHandle)
    {
      v35 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v34 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v34 = init_default_corebrightness_log();
      v35 = v34;
    }
    v120 = v35;
    v119 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v187, COERCE__INT64(*((float *)cf + 87)), COERCE__INT64(*((float *)cf + 314)), COERCE__INT64(*((float *)cf + 116)), COERCE__INT64(*((float *)cf + 100)), COERCE__INT64(*((float *)cf + 328)), COERCE__INT64(*((float *)cf + 330)), COERCE__INT64(valuePtr));
      _os_log_debug_impl(&dword_1B5291000, v120, v119, "Factor=%f Lcurrent=%f maxRestriction=%f minRestriction=%f maxPanel=%f minPanel=%f L_device=%f", v187, 0x48u);
    }
    if ((v180 & 0x8000u) != 0)
      valuePtr = *((float *)cf + 3138);
    v118 = (int)(float)(valuePtr * 65536.0);
    *((float *)cf + 315) = valuePtr;
    if ((v180 & 0x8000u) == 0)
    {
      v117 = 0;
      HIDWORD(v117) = *((_DWORD *)cf + 315);
      LODWORD(v117) = 1;
      __DisplayUpdateAAPStateInternal((uint64_t)cf, (uint64_t)&v117, 0);
    }
    value = 0;
    if ((v180 & 0x2000) != 0)
    {
      v115 = 0.0;
      v115 = __DisplayLogicalToPhysicalBrightness((uint64_t)cf, *((float *)cf + 318));
      if (*((float *)cf + 162) != 1.0)
      {
        v115 = v115 * *((float *)cf + 162);
        v114 = 0;
        if (_logHandle)
        {
          v33 = _logHandle;
        }
        else
        {
          v32 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          v33 = v32;
        }
        v114 = v33;
        v113 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v186, COERCE__INT64(*((float *)cf + 162)), COERCE__INT64(v115));
          _os_log_debug_impl(&dword_1B5291000, v114, v113, "EcoModeFactor: %0.2f -> L_physicalVirtual: %f\n", v186, 0x16u);
        }
      }
      if (*((float *)cf + 87) > 0.0)
        v115 = fminf(fmaxf(fminf(fminf(fmaxf(v115, *((float *)cf + 100)), *((float *)cf + 116)), *((float *)cf + 132)), *((float *)cf + 330)), *((float *)cf + 328));
      v112 = (int)(float)(v115 * 65536.0);
      v29 = cf;
      v4 = DisplayNits2milliAmps((uint64_t)cf, v112);
      v111 = DisplayMilliAmpsToMilliWatts((uint64_t)v29, v4);
      v30 = cf;
      v5 = DisplayNits2milliAmps((uint64_t)cf, v118);
      v110 = DisplayMilliAmpsToMilliWatts((uint64_t)v30, v5);
      v109 = 0;
      v31 = 0;
      if (*((_DWORD *)cf + 3179) == 1)
        v31 = *((_BYTE *)cf + 12181) ^ 1;
      v109 = v31 & 1;
      if ((*((_BYTE *)cf + 12181) & 1) != 0)
      {
        APLColumnOrDefault = 100;
        if (*((_DWORD *)cf + 3179) == 1)
          APLColumnOrDefault = 50;
        APLColumnOrDefault = DisplayGetAPLColumnOrDefault((uint64_t)cf, APLColumnOrDefault);
        v111 = __DisplayPhysicalBrightnessToPowerInternal((uint64_t)cf, APLColumnOrDefault, v115);
        v110 = __DisplayPhysicalBrightnessToPowerInternal((uint64_t)cf, APLColumnOrDefault, valuePtr);
      }
      v107 = 0;
      if (_logHandle)
      {
        v28 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v27 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v27 = init_default_corebrightness_log();
        v28 = v27;
      }
      v107 = v28;
      v106 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v185, COERCE__INT64(v115), COERCE__INT64(valuePtr));
        _os_log_debug_impl(&dword_1B5291000, v107, v106, "PowerNitsAB = %f, PowerNitsReal = %f", v185, 0x16u);
      }
      v6 = CFGetAllocator(cf);
      if ((v109 & 1) != 0)
        value = CFNumberCreate(v6, kCFNumberFloatType, &valuePtr);
      else
        value = CFNumberCreate(v6, kCFNumberFloatType, &v110);
      if (value)
      {
        v105 = 0;
        v7 = CFGetAllocator(cf);
        if ((v109 & 1) != 0)
          v105 = CFNumberCreate(v7, kCFNumberFloatType, &v115);
        else
          v105 = CFNumberCreate(v7, kCFNumberFloatType, &v111);
        if (v105)
        {
          theDict = 0;
          theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          if (theDict)
          {
            if ((v109 & 1) != 0)
            {
              CFDictionaryAddValue(theDict, CFSTR("BacklightPowerNitsRealSub"), value);
              CFDictionaryAddValue(theDict, CFSTR("BacklightPowerNitsABSub"), v105);
            }
            else
            {
              CFDictionaryAddValue(theDict, CFSTR("BacklightPowerMilliWattsRealSub"), value);
              CFDictionaryAddValue(theDict, CFSTR("BacklightPowerMilliWattsABSub"), v105);
            }
            if (*((_QWORD *)cf + 18))
            {
              v8 = *((_QWORD *)cf + 18);
              block = MEMORY[0x1E0C809B0];
              v97 = -1073741824;
              v98 = 0;
              v99 = ____DisplaySetLogicalBrightnessInternal_block_invoke;
              v100 = &__block_descriptor_49_e5_v8__0l;
              v101 = cf;
              v103 = v109 & 1;
              v102 = theDict;
              dispatch_async(v8, &block);
            }
            else
            {
              CFRelease(theDict);
            }
          }
          CFRelease(v105);
        }
        CFRelease(value);
      }
      if (*((_QWORD *)cf + 1563))
        CFXUpdateCompensatedBacklight(*((_QWORD *)cf + 1563), valuePtr);
    }
    v95 = 0;
    if ((v180 & 0x4000) == 0)
    {
      if (*((_DWORD *)cf + 3149) == 1 && (v180 & 0x8000u) == 0)
      {
        if (*((_DWORD *)cf + 3150) == 2 || *((_DWORD *)cf + 3150) == 1)
        {
          v94 = 0;
          if (_logHandle)
          {
            v26 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v25 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v25 = init_default_corebrightness_log();
            v26 = v25;
          }
          v94 = v26;
          v93 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_4_8_0_8_0_4_0_8_0((uint64_t)v184, COERCE__INT64(valuePtr), COERCE__INT64(v179), *((_DWORD *)cf + 3150), COERCE__INT64(*((float *)cf + 298)));
            _os_log_debug_impl(&dword_1B5291000, v94, v93, "EDR SetDisplayBrightness - physicalBrightness:%f, maxLum: %f, edrState: %d, lux: %f\n", v184, 0x26u);
          }
          SetLibEDRBrightness((uint64_t)cf, valuePtr, v179, *((float *)cf + 298), *((float *)cf + 3132));
          v92 = (int)(float)(_DisplayLogicalToSliderBrightnessInternal((uint64_t)cf, valuePtr) * 65536.0);
          if (!v92)
            v92 = valuePtr > 0.0;
          v9 = CFGetAllocator(cf);
          v91 = CFNumberCreate(v9, kCFNumberSInt32Type, &v92);
          if (v91)
          {
            __DisplaySetBLDriverProperty((uint64_t)cf, CFSTR("DisplayBrightnessSliderPosition"), v91);
            CFRelease(v91);
          }
          v24 = cf;
          v10 = __DisplayPhysicalToLogicalBrightness((uint64_t)cf, v178);
          v90 = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v24, v10);
          v11 = (float)*((int *)cf + 312) / 65536.0;
          __DisplayUpdateSlider((float *)cf, v90, v178, v11);
          *((float *)cf + 375) = valuePtr;
          return;
        }
        v89 = 0;
        if (_logHandle)
        {
          v23 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v22 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v22 = init_default_corebrightness_log();
          v23 = v22;
        }
        v89 = v23;
        v88 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_4_8_0_8_0_4_0_8_0((uint64_t)v183, COERCE__INT64(valuePtr), COERCE__INT64(v179), *((_DWORD *)cf + 3150), COERCE__INT64(*((float *)cf + 298)));
          _os_log_debug_impl(&dword_1B5291000, v89, v88, "EDR SetDisplayBrightness - physicalBrightness:%f, maxLum: %f, edrState: %d, lux: %f\n", v183, 0x26u);
        }
        SetLibEDRBrightness((uint64_t)cf, valuePtr, v179, *((float *)cf + 298), *((float *)cf + 3132));
        *((float *)cf + 375) = valuePtr;
      }
      if (*((_DWORD *)cf + 71))
      {
        if ((*((_BYTE *)cf + 288) & 1) != 0)
        {
          v87 = 0;
          v87 = valuePtr > (float)*((unsigned int *)cf + 71);
          if ((*((_BYTE *)cf + 289) & 1) != v87)
            __DisplaySendPLCUpdate((uint64_t)cf, v87);
        }
      }
      if (v118 != *((_DWORD *)cf + 312) || (*((_BYTE *)cf + 1284) & 1) != 0 || (*((_BYTE *)cf + 12712) & 1) != 0)
      {
        *((_DWORD *)cf + 312) = v118;
        v86 = DisplayGetAPLColumnOrDefault((uint64_t)cf, 0x64u);
        v85 = 0.0;
        v12 = (double)*((int *)cf + 312) / 65536.0;
        v85 = __DisplayPhysicalBrightnessToPowerInternal((uint64_t)cf, v86, v12);
        v84 = 0;
        v84 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v85);
        if (v84)
        {
          CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), CFSTR("CPMSCurrentPower"), v84);
          CFRelease(v84);
        }
        SetBLDriverNitsValueIfNotInLPM((uint64_t)cf, *((_DWORD *)cf + 312));
        v95 = 1;
        if (*((_DWORD *)cf + 3149) == 1 && (v180 & 0x8000u) != 0)
        {
          v83 = 0.0;
          v83 = __DisplayLogicalToPhysicalBrightness((uint64_t)cf, *((float *)cf + 319));
          v83 = fminf(v83, *((float *)cf + 132));
          v21 = cf;
          v13 = __DisplayPhysicalToLogicalBrightness((uint64_t)cf, v83);
          v82 = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v21, v13);
          v14 = (float)*((int *)cf + 312) / 65536.0;
          __DisplayUpdateSlider((float *)cf, v82, v83, v14);
        }
      }
      if ((v180 & 0x8000u) != 0)
      {
        *((_DWORD *)cf + 314) = *((_DWORD *)cf + 319);
        *((_DWORD *)cf + 372) = *((_DWORD *)cf + 374);
        *((_DWORD *)cf + 315) = *((_DWORD *)cf + 320);
        *((_DWORD *)cf + 3138) = *((_DWORD *)cf + 3140);
      }
    }
    if ((*((_BYTE *)cf + 232) & 1) == 0 && (v95 & 1) == 0 && ((v180 & 0x40) != 0 || (v180 & 0x100) != 0))
      SendSyncDBVNotification((uint64_t)cf, 0, valuePtr);
    if ((v180 & 0x1000) != 0)
    {
      v81 = (int)(float)(_DisplayLogicalToSliderBrightnessInternal((uint64_t)cf, valuePtr) * 65536.0);
      if (!v81)
        v81 = valuePtr > 0.0;
      v15 = CFGetAllocator(cf);
      v80 = CFNumberCreate(v15, kCFNumberSInt32Type, &v81);
      if (v80)
      {
        __DisplaySetBLDriverProperty((uint64_t)cf, CFSTR("DisplayBrightnessSliderPosition"), v80);
        CFRelease(v80);
      }
    }
    if ((v180 & 8) != 0 || _DisplayCLTMRev2Applicable((uint64_t)cf) && *((_DWORD *)cf + 390))
    {
      v20 = cf;
      v16 = __DisplayPhysicalToLogicalBrightness((uint64_t)cf, v178);
      v79 = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v20, v16);
      __DisplayUpdateSlider((float *)cf, v79, v178, valuePtr);
    }
    if (_DisplaySendNotificationForEDRHeadroom((uint64_t)cf, v180))
    {
      v19 = cf;
      v17 = __DisplayPhysicalToLogicalBrightness((uint64_t)cf, v178);
      v78 = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v19, v17);
      v18 = (float)*((int *)cf + 312) / 65536.0;
      __DisplayUpdateSlider((float *)cf, v78, v178, v18);
    }
  }
}

BOOL getClientOverrideState(uint64_t a1, char a2)
{
  return (*(unsigned __int8 *)(a1 + 960) & (1 << a2)) != 0;
}

float __DisplayLogicalToPhysicalBrightness(uint64_t a1, float a2)
{
  float v4;
  float v5;

  v5 = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2) * *(float *)(a1 + 348);
  v4 = 0.0;
  if (*(float *)(a1 + 348) > 0.0)
  {
    if (*(float *)(a1 + 348) < 1.0)
      return _DisplayPerceptualLuminanceToLuminanceInternal(a1, v5);
    else
      return a2;
  }
  return v4;
}

float _DisplayLuminanceToPerceptualLuminanceInternal(uint64_t a1, float a2)
{
  float v3;
  float v4;

  v4 = fminf(fmaxf(a2, *(float *)(a1 + 1320)), *(float *)(a1 + 1312));
  v3 = logf(*(float *)(a1 + 1312) / *(float *)(a1 + 1320));
  return (float)(logf(v4 / *(float *)(a1 + 1312)) / v3) + 1.0;
}

BOOL _DisplayCLTMRev2Applicable(uint64_t a1)
{
  BOOL v2;

  v2 = 0;
  if (a1)
    return (*(_BYTE *)(a1 + 312) & 1) != 0;
  return v2;
}

void SetBLDriverNitsCapIfNotInLPM(uint64_t a1, int a2)
{
  if ((*(_BYTE *)(a1 + 1504) & 1) == 0 && (*(_BYTE *)(a1 + 232) & 1) == 0)
    SetBLDriverNitsCap((const void *)a1, a2);
  *(_DWORD *)(a1 + 1512) = a2;
}

void SetBLDriverNitsCap(const void *a1, int a2)
{
  const __CFAllocator *v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t inited;
  NSObject *v6;
  CFNumberRef cf;
  int valuePtr;
  CFTypeRef v9;
  uint8_t v10[16];
  uint8_t v11[24];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v9 = a1;
  valuePtr = a2;
  if (_logHandle)
  {
    v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v6 = inited;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v11, COERCE__INT64((float)((float)valuePtr / 65536.0)));
    _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "SetBLDriverNitsCap to %f", v11, 0xCu);
  }
  if (valuePtr == *((_DWORD *)v9 + 284))
  {
    if (_logHandle)
    {
      v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v3 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v3 = init_default_corebrightness_log();
      v4 = v3;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v10, COERCE__INT64((float)((float)valuePtr / 65536.0)));
      _os_log_debug_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEBUG, "SetBLDriverNitsCap: cap unchanged (%f), skipping", v10, 0xCu);
    }
  }
  else
  {
    v2 = CFGetAllocator(v9);
    cf = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
    if (cf)
    {
      __DisplaySetBLDriverProperty((uint64_t)v9, CFSTR("brightness-nits-cap"), cf);
      *((_DWORD *)v9 + 284) = valuePtr;
      CFRelease(cf);
    }
  }
}

void __DisplaySetBLDriverProperty(uint64_t a1, const __CFString *a2, const void *a3)
{
  NSObject *v3;
  uint64_t block;
  int v5;
  int v6;
  void (*v7)(uint64_t);
  void *v8;
  uint64_t v9;
  char v10;
  const void *v11;
  const __CFString *v12;
  uint64_t v13;

  v13 = a1;
  v12 = a2;
  v11 = a3;
  if (a1 && *(_DWORD *)(v13 + 80) && v11)
  {
    if (*(_QWORD *)(v13 + 120))
    {
      v10 = 0;
      if (!*(_QWORD *)(v13 + 128))
      {
        *(_QWORD *)(v13 + 128) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v10 = 1;
      }
      if (*(_QWORD *)(v13 + 128))
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(v13 + 128), v12, v11);
        if ((v10 & 1) != 0)
        {
          v3 = *(NSObject **)(v13 + 120);
          block = MEMORY[0x1E0C809B0];
          v5 = -1073741824;
          v6 = 0;
          v7 = ____DisplaySetBLDriverProperty_block_invoke;
          v8 = &__block_descriptor_40_e5_v8__0l;
          v9 = v13;
          dispatch_async(v3, &block);
        }
      }
    }
    else
    {
      IORegistryEntrySetCFProperty(*(_DWORD *)(v13 + 80), v12, v11);
    }
  }
}

BOOL _DisplaySendNotificationForEDRHeadroom(uint64_t a1, __int16 a2)
{
  return (a2 & 8) == 0 && (a2 & 0x4000) != 0 && (a2 & 0x40) != 0;
}

void SetIOMFBBrightness(_BYTE *a1, int a2, char a3)
{
  NSObject *v3;
  const __CFAllocator *v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  int v8;
  void (*v9)(uint64_t);
  void *v10;
  uint64_t v11;
  CFTypeRef v12;
  int v13;
  CFTypeRef cf;
  uint64_t block;
  int v16;
  int v17;
  void (*v18)(uint64_t);
  void *v19;
  uint64_t v20;
  int v21;
  char v22;
  char v23;
  int valuePtr;
  uint64_t v25;

  v25 = (uint64_t)a1;
  valuePtr = a2;
  v23 = a3 & 1;
  if ((a1[321] & 1) != 0)
  {
    if ((*(_BYTE *)(v25 + 232) & 1) == 0 || (v23 & 1) != 0)
    {
      if (*(_QWORD *)(v25 + 120))
      {
        v3 = *(NSObject **)(v25 + 120);
        block = MEMORY[0x1E0C809B0];
        v16 = -1073741824;
        v17 = 0;
        v18 = __SetIOMFBBrightness_block_invoke;
        v19 = &__block_descriptor_45_e5_v8__0l;
        v20 = v25;
        v21 = valuePtr;
        v22 = v23 & 1;
        dispatch_async(v3, &block);
      }
      else
      {
        SendSyncDBVNotification(v25, v23 & 1, (float)valuePtr / 65536.0);
      }
      *(_DWORD *)(v25 + 140) = valuePtr;
    }
    else
    {
      *(_DWORD *)(v25 + 236) = valuePtr;
    }
  }
  else
  {
    v4 = CFGetAllocator((CFTypeRef)v25);
    cf = CFNumberCreate(v4, kCFNumberSInt32Type, &valuePtr);
    if (!cf)
      return;
    if (*(_DWORD *)(v25 + 108))
    {
      if (*(_DWORD *)(v25 + 136))
      {
        v13 = valuePtr;
        if (*(_DWORD *)(v25 + 140) != valuePtr)
        {
          if ((*(_BYTE *)(v25 + 232) & 1) != 0 && (v23 & 1) == 0)
          {
            *(_DWORD *)(v25 + 236) = v13;
            CFRelease(cf);
            return;
          }
          if (*(_QWORD *)(v25 + 120))
          {
            CFRetain(cf);
            v5 = *(NSObject **)(v25 + 120);
            v6 = MEMORY[0x1E0C809B0];
            v7 = -1073741824;
            v8 = 0;
            v9 = __SetIOMFBBrightness_block_invoke_2;
            v10 = &__block_descriptor_48_e5_v8__0l;
            v11 = v25;
            v12 = cf;
            dispatch_async(v5, &v6);
          }
          else
          {
            IORegistryEntrySetCFProperty(*(_DWORD *)(v25 + 108), CFSTR("IOMFBBrightnessLevel"), cf);
          }
          *(_DWORD *)(v25 + 140) = v13;
        }
      }
    }
    CFRelease(cf);
  }
}

void SetBLDriverNitsValueIfNotInLPM(uint64_t a1, int a2)
{
  if ((*(_BYTE *)(a1 + 1504) & 1) == 0)
    SetBLDriverNitsValue((float *)a1, a2);
  *(_DWORD *)(a1 + 1508) = a2;
}

float DisplayMilliAmpsToMilliWatts(uint64_t a1, float a2)
{
  return a2 * *(float *)(a1 + 304);
}

void __DisplayFadeCallback(_BYTE *a1)
{
  float v1;
  double v2;
  double v3;
  float v4;
  double v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  os_log_type_t v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  os_signpost_type_t v13;
  os_signpost_id_t spid;
  uint64_t v15;
  NSObject *v16;
  _BYTE *v17;
  float *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  os_log_type_t v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t inited;
  NSObject *v26;
  uint8_t v27[7];
  os_log_type_t v28;
  os_log_t oslog;
  uint8_t v30[8];
  unint64_t v31;
  os_signpost_type_t v32;
  NSObject *v33;
  int v34;
  os_log_type_t v35;
  os_log_t v36;
  uint8_t v37[15];
  char v38;
  NSObject *v39;
  float v40;
  float v41;
  float v42;
  os_log_type_t v43;
  os_log_t v44;
  char v45;
  char v46;
  char v47;
  char v48;
  char v49;
  char v50;
  char v51;
  double Current;
  _BYTE *v53;
  _BYTE *v54;
  uint8_t v55[64];
  uint8_t v56[32];
  uint8_t v57[24];
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v54 = a1;
  v53 = a1;
  if (a1)
  {
    Current = CFAbsoluteTimeGetCurrent();
    v51 = 0;
    v50 = 0;
    v49 = 0;
    v48 = 1;
    v47 = 0;
    v46 = 0;
    v45 = 0;
    if (*((double *)v53 + 173) > 0.0)
    {
      __DisplayFadeUpdateFactorFade((uint64_t)v53, (double *)v53 + 173, 1, Current);
      _DisplaySetBrightnessFactor((uint64_t)v53, *((float *)v53 + 351));
      if (*((double *)v53 + 173) <= 0.0)
      {
        kdebug_trace();
        v49 = 1;
      }
      else
      {
        v48 = 0;
      }
      v51 = 1;
    }
    if (*((double *)v53 + 51) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 408));
      if (!getClientOverrideState((uint64_t)v53, 1)
        || *((float *)v53 + 100) > *((float *)v53 + 242)
        || *((float *)v53 + 99) > *((float *)v53 + 242))
      {
        *((float *)v53 + 100) = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 107));
      }
      v44 = 0;
      if (_logHandle)
      {
        v26 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v26 = inited;
      }
      v44 = v26;
      v43 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v57, COERCE__INT64(*((float *)v53 + 100)));
        _os_log_debug_impl(&dword_1B5291000, v44, v43, "display->brightness.restriction.min.Lcurrent=%f\n", v57, 0xCu);
      }
      if (*((double *)v53 + 51) <= 0.0)
        v50 = 1;
      else
        v48 = 0;
      v51 = 1;
    }
    if (*((double *)v53 + 59) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 472));
      *((float *)v53 + 116) = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 123));
      if (*((double *)v53 + 59) <= 0.0)
        v50 = 1;
      else
        v48 = 0;
      if (_DisplayCLTMRev2Applicable((uint64_t)v53)
        && *((_DWORD *)v53 + 389) == 1
        && (v48 & 1) == 1
        && *((float *)v53 + 388) == 0.0)
      {
        *((_DWORD *)v53 + 116) = 0;
      }
      v51 = 1;
    }
    if (*((double *)v53 + 74) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 592));
      *((float *)v53 + 132) = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 153));
      if (*((double *)v53 + 74) <= 0.0)
        v50 = 1;
      else
        v48 = 0;
      v51 = 1;
    }
    if (*((double *)v53 + 98) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 784));
      *((float *)v53 + 195) = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 201));
      if (*((double *)v53 + 98) <= 0.0)
        v50 = 1;
      else
        v48 = 0;
      v51 = 1;
    }
    if (*((double *)v53 + 83) > 0.0)
    {
      __DisplayFadeUpdateFactorFade((uint64_t)v53, (double *)v53 + 83, 0, Current);
      *((_DWORD *)v53 + 162) = *((_DWORD *)v53 + 171);
      v42 = 0.0;
      v1 = 0.5 * (float)(*((float *)v53 + 162) - 0.8) / 0.199999988 + 0.5;
      v42 = v1;
      _DisplayReduceBacklightCompensation((uint64_t)v53, v1);
      if (*((double *)v53 + 83) <= 0.0)
        v49 = 1;
      else
        v48 = 0;
      v51 = 1;
    }
    if (*((double *)v53 + 91) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 728));
      *((float *)v53 + 181) = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 187));
      if (*((double *)v53 + 91) <= 0.0)
        v50 = 1;
      else
        v48 = 0;
      v51 = 1;
    }
    if (*((double *)v53 + 124) > 0.0)
    {
      __DisplayFadeUpdateRestrictionFactorFade(Current, (uint64_t)v53, (uint64_t)(v53 + 992));
      *((_DWORD *)v53 + 246) = *((_DWORD *)v53 + 253);
      if (*((double *)v53 + 124) <= 0.0)
        v49 = 1;
      else
        v48 = 0;
      v51 = 1;
    }
    if (*((double *)v53 + 133) > 0.0)
    {
      __DisplayFadeUpdateRestrictionFactorFade(Current, (uint64_t)v53, (uint64_t)(v53 + 1064));
      *((_DWORD *)v53 + 264) = *((_DWORD *)v53 + 271);
      if (*((double *)v53 + 133) <= 0.0)
        v49 = 1;
      else
        v48 = 0;
      v51 = 1;
    }
    if (*((double *)v53 + 1619) > 0.0)
    {
      __DisplayFadeUpdateAuroraFactorFade((uint64_t)v53, (uint64_t)(v53 + 12952), Current);
      *((_DWORD *)v53 + 3236) = *((_DWORD *)v53 + 3243);
      if (*((double *)v53 + 1619) <= 0.0)
        v49 = 1;
      else
        v48 = 0;
      v51 = 1;
    }
    if (*((double *)v53 + 167) <= 0.0)
    {
      *((float *)v53 + 70) = -1.0;
    }
    else
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 1336));
      if (*((float *)v53 + 87) == 0.0 && *((float *)v53 + 339) == 0.0)
        *((_DWORD *)v53 + 314) = 0;
      else
        *((float *)v53 + 314) = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 339));
      if (*((double *)v53 + 167) <= 0.0)
      {
        v50 = 1;
        *((float *)v53 + 70) = -1.0;
      }
      else
      {
        v48 = 0;
      }
      v51 = 1;
    }
    if (*((_QWORD *)v53 + 41)
      && (objc_msgSend(*((id *)v53 + 41), "isActive") & 1) != 0
      && *(double *)objc_msgSend(*((id *)v53 + 41), "fade") > 0.0)
    {
      __DisplayFadeUpdateFactorFade((uint64_t)v53, (double *)objc_msgSend(*((id *)v53 + 41), "fade"), 0, Current);
      if (*(double *)objc_msgSend(*((id *)v53 + 41), "fade") > 0.0)
        v48 = 0;
      v51 = 1;
    }
    if (*((double *)v53 + 180) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 1440));
      if (*((float *)v53 + 87) == 0.0 && *((float *)v53 + 365) == 0.0)
        *((_DWORD *)v53 + 372) = 0;
      else
        *((float *)v53 + 372) = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 365));
      if (*((double *)v53 + 180) <= 0.0)
        v47 = 1;
      else
        v48 = 0;
    }
    if (*((_QWORD *)v53 + 1563))
    {
      if ((v53[12521] & 1) != 0)
      {
        v53[12521] = CFXUpdateColorFade(*((_QWORD *)v53 + 1563), Current) & 1;
        if ((v53[12521] & 1) != 0)
          v48 = 0;
      }
    }
    if (*((double *)v53 + 1524) > 0.0)
    {
      v2 = CFAbsoluteTimeGetCurrent();
      __DisplayFadeUpdateFactorFade((uint64_t)v53, (double *)v53 + 1524, 0, v2);
      if (*((double *)v53 + 1524) > 0.0)
        v48 = 0;
      v41 = 0.0;
      v41 = *((float *)v53 + 3053) * fmaxf(*((float *)v53 + 416), *((float *)v53 + 386));
      *((float *)v53 + 3027) = v41;
      v40 = _DisplayComputeEDRNitsCap((uint64_t)v53);
      SetLibEDRBrightness((uint64_t)v53, *((float *)v53 + 375), v40, *((float *)v53 + 298), *((float *)v53 + 3132));
      *((_DWORD *)v53 + 64) = (int)(float)(*((float *)v53 + 3027) * 65536.0);
      v46 = 1;
    }
    if (*((double *)v53 + 1576) > 0.0)
    {
      __DisplayFastEDRUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 12608));
      if (*((double *)v53 + 1576) > 0.0)
        v48 = 0;
      v46 = 1;
    }
    if (*((double *)v53 + 1582) > 0.0)
    {
      __DisplayRTPLCEDRUpdateFade((uint64_t)v53, (uint64_t)(v53 + 12656), Current);
      if (*((double *)v53 + 1582) > 0.0)
      {
        v48 = 0;
        v53[12704] = 1;
      }
      v46 = 1;
    }
    if ((v53[12712] & 1) != 0)
    {
      v51 = 1;
      v48 = 0;
    }
    if ((v53[321] & 1) != 0
      && (CBU_PassContrastEnhancerStrengthThroughSyncDBV() & 1) != 0
      && (v53[12248] & 1) != 0
      && *((double *)v53 + 1550) > 0.0)
    {
      v3 = CFAbsoluteTimeGetCurrent();
      __DisplayFadeUpdateFactorFade((uint64_t)v53, (double *)v53 + 1550, 0, v3);
      *((float *)v53 + 3098) = clamp(*((float *)v53 + 3105), *((float *)v53 + 3114), *((float *)v53 + 3115));
      if (*((double *)v53 + 1550) > 0.0)
        v48 = 0;
      v45 = 1;
    }
    if (*((_QWORD *)v53 + 33) && (objc_msgSend(*((id *)v53 + 33), "isDisplayRampRunning") & 1) != 0)
    {
      if (!-[CBAODState isAODActive](+[CBAODState sharedInstance](CBAODState, "sharedInstance"), "isAODActive"))v48 = 0;
      v45 = 1;
      v39 = 0;
      if (_logHandle)
      {
        v24 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v23 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v23 = init_default_corebrightness_log();
        v24 = v23;
      }
      v39 = v24;
      v38 = 2;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        v21 = v39;
        v22 = v38;
        __os_log_helper_16_0_0(v37);
        _os_log_debug_impl(&dword_1B5291000, v21, v22, "External ramp forced SyncDBV update", v37, 2u);
      }
    }
    if (*((double *)v53 + 105) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 840));
      *((float *)v53 + 208) = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 215));
      if (*((double *)v53 + 105) <= 0.0)
        *((_DWORD *)v53 + 208) = 1120403456;
      else
        v48 = 0;
      v51 = 1;
    }
    v36 = 0;
    if (_logHandle)
    {
      v20 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v19 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v19 = init_default_corebrightness_log();
      v20 = v19;
    }
    v36 = v20;
    v35 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_4_0_4_0_4_0_4_0((uint64_t)v56, v51 & 1, v47 & 1, v46 & 1, v45 & 1);
      _os_log_debug_impl(&dword_1B5291000, v36, v35, "Display fade callback: updateBrightness = %d, updateVirtual = %d, updateEDRHeadroom = %d, forceSyncDBVUpdate = %d", v56, 0x1Au);
    }
    if ((v51 & 1) != 0 || (v47 & 1) != 0 || (v46 & 1) != 0 || (v45 & 1) != 0)
    {
      if (*((_DWORD *)v53 + 9))
      {
        *((float *)v53 + 98) = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v53, *((float *)v53 + 100));
        *((float *)v53 + 114) = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v53, *((float *)v53 + 116));
        v18 = (float *)v53;
        v4 = __DisplayCalculateBrightnessFromFactorChange((uint64_t)v53, *((_DWORD *)v53 + 51));
        __DisplaySetLogicalBrightnessLegacy(v18, 6u, v4, 0.0);
      }
      else
      {
        v34 = 0;
        v34 = *((_DWORD *)v53 + 332) | 1;
        if ((v50 & 1) != 0)
          v34 |= 0x3000u;
        if ((v47 & 1) != 0)
          v34 |= 0x2000u;
        if ((v49 & 1) != 0)
          v34 |= 0x3008u;
        if ((v51 & 1) == 0)
          v34 |= 0x4000u;
        if ((v46 & 1) != 0)
          v34 |= 0x40u;
        if ((v45 & 1) != 0)
          v34 |= 0x100u;
        __DisplaySetLogicalBrightnessInternal(v53, v34, *((float *)v53 + 314));
      }
    }
    if ((v53[321] & 1) == 0 || (CBU_PassContrastEnhancerStrengthThroughSyncDBV() & 1) == 0)
    {
      if ((v53[12282] & 1) != 0)
      {
        if ((v53[12248] & 1) != 0 && *((double *)v53 + 1550) > 0.0)
        {
          v17 = v53;
          v5 = CFAbsoluteTimeGetCurrent();
          __DisplayFadeUpdateFactorFade((uint64_t)v17, (double *)v53 + 1550, 0, v5);
          if (*((double *)v53 + 1550) > 0.0)
            v48 = 0;
          __DisplaySetAAPFactor(v53, *((float *)v53 + 3105));
        }
      }
      else if ((v53[12248] & 1) != 0 && *((double *)v53 + 197) > 0.0)
      {
        __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 1576));
        *((float *)v53 + 393) = _DisplayPerceptualLuminanceToReflectedLuminanceInternal((uint64_t)v53, *((float *)v53 + 399));
        if (*((double *)v53 + 197) > 0.0)
          v48 = 0;
        __DisplayUpdateAAPFactor((uint64_t)v53);
      }
    }
    if ((v48 & 1) != 0)
    {
      if ((v53[321] & 1) != 0)
      {
        objc_msgSend(*((id *)v53 + 26), "pause");
      }
      else
      {
        dispatch_release(*((dispatch_object_t *)v53 + 1560));
        *((_QWORD *)v53 + 1560) = 0;
      }
      v33 = 0;
      if (_logHandle)
      {
        v16 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v15 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v15 = init_default_corebrightness_log();
        v16 = v15;
      }
      v33 = v16;
      v32 = OS_SIGNPOST_EVENT;
      v31 = 0xEEEEB0B5B2B2EEEELL;
      if (os_signpost_enabled(v16))
      {
        v12 = v33;
        v13 = v32;
        spid = v31;
        __os_log_helper_16_0_0(v30);
        _os_signpost_emit_with_name_impl(&dword_1B5291000, v12, v13, spid, "DisplayFadeEndRamp", (const char *)&unk_1B546AB41, v30, 2u);
      }
      if ((v53[12248] & 1) != 0 && *((float *)v53 + 87) == 0.0)
      {
        oslog = 0;
        if (_logHandle)
        {
          v11 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v10 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v10 = init_default_corebrightness_log();
          v11 = v10;
        }
        oslog = v11;
        v28 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          v8 = oslog;
          v9 = v28;
          __os_log_helper_16_0_0(v27);
          _os_log_debug_impl(&dword_1B5291000, v8, v9, "Resetting AAP cache", v27, 2u);
        }
        *((_DWORD *)v53 + 3098) = 0;
        *((_DWORD *)v53 + 392) = 0;
        *((_DWORD *)v53 + 393) = 0;
      }
      if (*((float *)v53 + 87) == 0.0 && *((float *)v53 + 3124) >= 0.0)
      {
        __DisplaySetBrightness((uint64_t)v53, *((_DWORD *)v53 + 3125), *((float *)v53 + 3124));
        *((float *)v53 + 3124) = -1.0;
      }
      if (_logHandle)
      {
        v7 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v6 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v6 = init_default_corebrightness_log();
        v7 = v6;
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_5_8_32_8_0_8_0_8_0_8_0((uint64_t)v55, (uint64_t)"Unknown", COERCE__INT64(*((float *)v53 + 315)), COERCE__INT64(*((float *)v53 + 314)), COERCE__INT64(*((float *)v53 + 99)), COERCE__INT64(*((float *)v53 + 115)));
        _os_log_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: End ramp: Ldevice = %f, Lcurrent = %f, Lmin = %f, Lmax = %f", v55, 0x34u);
      }
    }
  }
}

uint64_t CBU_PassContrastEnhancerStrengthThroughSyncDBV()
{
  if (CBU_PassContrastEnhancerStrengthThroughSyncDBV_once != -1)
    dispatch_once(&CBU_PassContrastEnhancerStrengthThroughSyncDBV_once, &__block_literal_global_44);
  return CBU_PassContrastEnhancerStrengthThroughSyncDBV_pass & 1;
}

void __DisplayFadeUpdateRestrictionFactorFade(double a1, uint64_t a2, uint64_t a3)
{
  float v3;
  uint64_t inited;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  double v8;
  double v9;
  double v10;
  uint8_t v13[64];
  uint8_t v14[72];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v10 = a1 - *(double *)(a3 + 8);
  v8 = v10 / *(double *)a3;
  if (*(float *)(a3 + 20) == *(float *)(a3 + 16))
    v8 = 1.0;
  if (v8 >= 1.0)
  {
    *(_DWORD *)(a3 + 20) = *(_DWORD *)(a3 + 16);
    if (_logHandle)
    {
      v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v5 = inited;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v13, *(uint64_t *)&a1, *(uint64_t *)&v10, *(_QWORD *)a3, *(uint64_t *)&v8, COERCE__INT64(*(float *)(a3 + 24)), COERCE__INT64(*(float *)(a3 + 16)));
      _os_log_debug_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Fstart=%f fade->Ftarget=%f [finished]\n", v13, 0x3Eu);
    }
    if (*(_QWORD *)(a3 + 40))
      (*(void (**)(_QWORD))(a3 + 40))(*(_QWORD *)(a3 + 48));
    *(_QWORD *)a3 = 0;
  }
  else
  {
    if (*(float *)(a3 + 24) >= *(float *)(a3 + 16))
      v9 = 1.0 - (1.0 - v8) * (1.0 - v8) * (1.0 - v8);
    else
      v9 = v8 * v8 * v8;
    v3 = *(float *)(a3 + 24) + (float)(*(float *)(a3 + 16) - *(float *)(a3 + 24)) * v9;
    *(float *)(a3 + 20) = v3;
    if (_logHandle)
    {
      v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v6 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v6 = init_default_corebrightness_log();
      v7 = v6;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v14, *(uint64_t *)&a1, *(uint64_t *)&v10, *(_QWORD *)a3, *(uint64_t *)&v9, COERCE__INT64(*(float *)(a3 + 24)), COERCE__INT64(*(float *)(a3 + 16)), COERCE__INT64(*(float *)(a3 + 20)));
      _os_log_debug_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Fstart=%f fade->Ftarget=%f Factor=%f\n", v14, 0x48u);
    }
  }
}

void __DisplayFadeUpdateFactorFade(uint64_t a1, double *a2, int a3, double a4)
{
  float v4;
  float v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  os_log_type_t v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *log;
  os_log_type_t v15;
  uint64_t inited;
  NSObject *v17;
  uint8_t v18[7];
  os_log_type_t v19;
  os_log_t v20;
  uint8_t v21[7];
  os_log_type_t type;
  os_log_t oslog;
  double v24;
  double v25;
  int v26;
  double *v27;
  double v28;
  uint64_t v29;
  uint8_t v30[64];
  uint8_t v31[72];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v29 = a1;
  v28 = a4;
  v27 = a2;
  v26 = a3;
  v25 = 0.0;
  v25 = a4 - a2[1];
  v24 = 0.0;
  v24 = v25 / *a2;
  if (a3 && *(_DWORD *)(v29 + 84) && !*(_DWORD *)(v29 + 104) && *((float *)v27 + 4) > 0.0 && !*(_DWORD *)(v29 + 88))
  {
    if (*(double *)(v29 + 96) == 0.0)
      *(double *)(v29 + 96) = v28;
    if (v28 - *(double *)(v29 + 96) < 1.0)
    {
      v27[1] = v28;
      oslog = 0;
      if (_logHandle)
      {
        v17 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v17 = inited;
      }
      oslog = v17;
      type = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        log = oslog;
        v15 = type;
        __os_log_helper_16_0_0(v21);
        _os_log_debug_impl(&dword_1B5291000, log, v15, "Delaying Ramp Start\n", v21, 2u);
      }
      return;
    }
    v20 = 0;
    if (_logHandle)
    {
      v13 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v12 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v12 = init_default_corebrightness_log();
      v13 = v12;
    }
    v20 = v13;
    v19 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v10 = v20;
      v11 = v19;
      __os_log_helper_16_0_0(v18);
      _os_log_debug_impl(&dword_1B5291000, v10, v11, "Ramp delay hit timeout\n", v18, 2u);
    }
  }
  if (v24 >= 1.0)
  {
    v5 = fmin(1.0, *((float *)v27 + 4));
    *((float *)v27 + 5) = v5;
    if (v26)
      *(_DWORD *)(v29 + 88) = 0;
    if (_logHandle)
    {
      v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v6 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v6 = init_default_corebrightness_log();
      v7 = v6;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v30, *(uint64_t *)&v28, *(uint64_t *)&v25, *(_QWORD *)v27, *(uint64_t *)&v24, COERCE__INT64(*((float *)v27 + 6)), COERCE__INT64(*((float *)v27 + 4)));
      _os_log_debug_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Fstart=%f fade->Ftarget=%f [finished]\n", v30, 0x3Eu);
    }
    if (*((_QWORD *)v27 + 5))
      (*((void (**)(_QWORD))v27 + 5))(*((_QWORD *)v27 + 6));
    *v27 = 0.0;
  }
  else
  {
    v4 = __DisplayFadeComputeCurrentFactor((float *)v27, v24);
    *((float *)v27 + 5) = v4;
    if (_logHandle)
    {
      v9 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v8 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v8 = init_default_corebrightness_log();
      v9 = v8;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v31, *(uint64_t *)&v28, *(uint64_t *)&v25, *(_QWORD *)v27, *(uint64_t *)&v24, COERCE__INT64(*((float *)v27 + 6)), COERCE__INT64(*((float *)v27 + 4)), COERCE__INT64(*((float *)v27 + 5)));
      _os_log_debug_impl(&dword_1B5291000, v9, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Fstart=%f fade->Ftarget=%f Factor=%f\n", v31, 0x48u);
    }
  }
}

float __DisplayFadeComputeCurrentFactor(float *a1, double a2)
{
  float v2;
  float v3;

  v2 = a1[7] + a1[8] * a2 + a1[9] * a2 * a2;
  v3 = fmin(1.0, (float)(a1[6] + (float)((float)(a1[4] - a1[6]) * v2)));
  return fmax(0.0, v3);
}

float clamp(float a1, float a2, float a3)
{
  if (a1 < a2)
    return a2;
  if (a1 <= a3)
    return a1;
  else
    return a3;
}

uint64_t __os_log_helper_16_2_2_8_0_8_32(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 32;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  return result;
}

void AABC::setPropertyForClient(AABC *this, const __CFString *a2, const void *a3, const void *a4)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  os_log_t *v8;
  id *v9;
  char *v10;
  id *v11;
  CFNumberRef *v12;
  os_log_t *v13;
  float *v14;
  float *v15;
  float *v16;
  void *v17;
  float *v18;
  char *v19;
  CFDictionaryRef *v20;
  char *v21;
  char *v22;
  os_log_t *v23;
  const char *v24;
  uint64_t v25;
  os_log_t *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  void *v30;
  void *v31;
  char *v32;
  char *v33;
  char *v34;
  char *v35;
  float v36;
  char *v37;
  float v38;
  char *v39;
  char *v40;
  id *v41;
  float v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  os_log_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  os_log_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  os_log_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  os_log_t *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  CFDictionaryRef *v70;
  char *v71;
  os_log_t *v72;
  uint64_t v73;
  os_log_t *v74;
  _QWORD **v75;
  _BYTE *v76;
  CFDictionaryRef *v77;
  char *v78;
  os_log_t *v79;
  uint64_t v80;
  CFDictionaryRef *v81;
  char *v82;
  os_log_t *v83;
  uint64_t v84;
  CFDictionaryRef *v85;
  char *v86;
  os_log_t *v87;
  uint64_t v88;
  os_log_t *v89;
  _QWORD **v90;
  void *v91;
  CFDictionaryRef *v92;
  char *v93;
  char *v94;
  _BYTE *v95;
  const void **v96;
  CFMutableDictionaryRef *v97;
  char *v98;
  os_log_t *v99;
  int v100;
  char *v101;
  _DWORD *v102;
  os_log_t *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  os_log_t *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  char *v113;
  float *v114;
  void *v115;
  char *v116;
  char *v117;
  _DWORD *v118;
  char *v119;
  _DWORD *v120;
  AABC *v121;
  float *v122;
  float *v123;
  float *v124;
  CFNumberRef *v125;
  char *v126;
  _DWORD *v127;
  char *v128;
  CFDictionaryRef *v129;
  char *v130;
  char *v131;
  _DWORD *v132;
  char *v133;
  _DWORD *v134;
  char *v135;
  CFNumberRef *v136;
  CFDictionaryRef *v137;
  char *v138;
  CFNumberRef *v139;
  char *v140;
  char *v141;
  char *v142;
  os_log_t *v143;
  uint64_t v144;
  char *v145;
  _DWORD *v146;
  CFDictionaryRef *v147;
  char *v148;
  os_log_t *v149;
  uint64_t v150;
  CFDictionaryRef *v151;
  char *v152;
  char *v153;
  _DWORD *v154;
  char *v155;
  _DWORD *v156;
  _BYTE *v157;
  float *v158;
  char *v159;
  float *v160;
  float *v161;
  float *v162;
  char *v163;
  _BYTE *v164;
  AABC *v165;
  const __CFNumber **v166;
  _QWORD *v167;
  AABC *v168;
  float *v169;
  float *v170;
  char *v171;
  _BYTE *v172;
  float *v173;
  float *v174;
  float *v175;
  double v176;
  float v177;
  float *v178;
  char *v179;
  CFNumberRef *v180;
  _BYTE *v181;
  _BYTE *v182;
  uint64_t v183;
  _Unwind_Exception *v184[10];
  os_log_type_t v185[4];
  uint64_t v186;
  NSObject *v187;
  os_log_t v188;
  CFTypeID v189;
  CFTypeID v190;
  int v191;
  _BOOL4 v192;
  int v193;
  CFTypeID v194;
  CFTypeID v195;
  int v196;
  os_log_t v197;
  os_log_type_t v198[4];
  uint8_t *v199;
  NSObject *v200;
  os_log_t v201;
  float v202;
  CFTypeID v203;
  CFTypeID v204;
  int v205;
  CFTypeRef property;
  IOHIDServiceClientRef service;
  CFTypeID v208;
  CFTypeID v209;
  int v210;
  CFTypeID v211;
  CFTypeID v212;
  int v213;
  CFTypeID v214;
  CFTypeID v215;
  int v216;
  CFTypeID v217;
  CFTypeID v218;
  int v219;
  CFTypeID v220;
  CFTypeID v221;
  int v222;
  CFTypeID v223;
  CFTypeID v224;
  int v225;
  os_log_t v226;
  os_log_type_t v227[4];
  uint8_t *v228;
  uint64_t v229;
  NSObject *v230;
  os_log_t v231;
  os_log_t v232;
  os_log_type_t v233[4];
  uint8_t *v234;
  uint64_t v235;
  NSObject *v236;
  os_log_t v237;
  double Current;
  int v239;
  int v240;
  CFTypeID v241;
  CFTypeID v242;
  int v243;
  float v244;
  float v245;
  float LogicalBrightness;
  uint64_t v247;
  float v248;
  int v249;
  CFTypeID v250;
  CFTypeID v251;
  int v252;
  CFTypeID v253;
  CFTypeID v254;
  int v255;
  CFTypeID v256;
  CFTypeID v257;
  const void *v258;
  os_log_t v259;
  os_log_type_t v260[4];
  uint8_t *v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  CFTypeID v265;
  CFTypeID v266;
  const void *v267;
  CFTypeID v268;
  CFTypeID v269;
  CFTypeID v270;
  CFTypeID v271;
  int v272;
  os_log_t v273;
  os_log_type_t v274[4];
  uint8_t *v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  CFTypeID v279;
  CFTypeID v280;
  int v281;
  CFTypeID v282;
  CFTypeID v283;
  const void *v284;
  int v285;
  CFTypeID v286;
  CFTypeID v287;
  const void *v288;
  CFTypeID v289;
  CFTypeID v290;
  int v291;
  float v292;
  int v293;
  CFTypeID v294;
  CFTypeID v295;
  int v296;
  const void *v297;
  float v298;
  int v299;
  CFTypeID v300;
  CFTypeID v301;
  const void *v302;
  CFTypeID v303;
  CFTypeID v304;
  int v305;
  CFTypeID v306;
  CFTypeID v307;
  float v308;
  int v309;
  const void *v310;
  CFTypeID v311;
  CFTypeID v312;
  const void *v313;
  CFTypeID v314;
  CFTypeID v315;
  int v316;
  CFTypeID v317;
  CFTypeID v318;
  int v319;
  float v320;
  int v321;
  int v322;
  int v323;
  int v324;
  int v325;
  CFTypeID v326;
  CFTypeID v327;
  int v328;
  int v329;
  CFTypeID v330;
  CFTypeID v331;
  int v332;
  int v333;
  int v334;
  int v335;
  CFTypeID v336;
  CFTypeID v337;
  int v338;
  int v339;
  os_log_t v340;
  os_log_type_t v341[4];
  uint8_t *v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  os_log_t v346;
  os_log_type_t v347[4];
  uint8_t *v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  int v352;
  int v353;
  CFTypeID v354;
  CFTypeID v355;
  int v356;
  os_log_t v357;
  os_log_type_t v358[4];
  uint8_t *v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  int CFBooleanValue;
  int v364;
  CFDictionaryRef OutlierRemovalDictionary;
  CFTypeID v366;
  CFTypeID v367;
  int v368;
  CFTypeID v369;
  CFTypeID v370;
  int v371;
  CFTypeID v372;
  CFTypeID v373;
  const void *v374;
  CFTypeID v375;
  CFTypeID v376;
  const void *v377;
  int v378;
  int v379;
  uint8_t *v380;
  int v381;
  int v382;
  os_log_t v383;
  os_log_type_t v384[4];
  int v385;
  int v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  os_log_t v390;
  os_log_type_t v391[4];
  uint8_t *v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  CFTypeID v396;
  CFTypeID v397;
  const void *v398;
  os_log_t v399;
  os_log_type_t v400[4];
  uint8_t *v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  CFTypeID v405;
  CFTypeID v406;
  const void *v407;
  os_log_t v408;
  os_log_type_t v409[4];
  uint8_t *v410;
  uint64_t v411;
  uint64_t v412;
  uint64_t v413;
  CFTypeID v414;
  CFTypeID v415;
  const void *v416;
  int v417;
  int v418;
  uint8_t *v419;
  int v420;
  int v421;
  os_log_t v422;
  os_log_type_t v423[4];
  int v424;
  int v425;
  uint64_t v426;
  uint64_t v427;
  uint64_t v428;
  os_log_t v429;
  os_log_type_t v430[4];
  uint8_t *v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  CFTypeID v435;
  CFTypeID v436;
  const void *v437;
  CFTypeID v438;
  CFTypeID v439;
  int v440;
  os_log_t v441;
  os_log_type_t v442[4];
  uint8_t *v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  os_log_t v447;
  os_log_type_t v448[4];
  uint8_t *v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  os_log_t v453;
  os_log_type_t v454[4];
  uint8_t *v455;
  uint64_t v456;
  uint64_t v457;
  uint64_t v458;
  os_log_t v459;
  os_log_type_t v460[4];
  uint8_t *v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  int v465;
  _Unwind_Exception **v466;
  uint64_t v467;
  id v468;
  uint64_t v469;
  id v470;
  uint64_t v471;
  id v472;
  float v473;
  uint64_t v474;
  id v475;
  uint64_t v476;
  id v477;
  float v478;
  float v479;
  uint64_t v480;
  uint64_t v481;
  uint64_t v482;
  CFTypeID v483;
  CFTypeID v484;
  int v485;
  uint64_t v486;
  os_log_t v487;
  os_log_type_t v488[4];
  uint8_t *v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  CFTypeID v493;
  CFTypeID v494;
  void *v495;
  int v496;
  os_log_t v497;
  os_log_type_t v498[4];
  uint8_t *v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  CFTypeID v503;
  CFTypeID v504;
  CFTypeID v505;
  CFTypeID v506;
  const void *v507;
  const void *v508;
  CFTypeID v509;
  CFTypeID v510;
  CFTypeID v511;
  CFTypeID v512;
  int v513;
  float v514;
  float v515;
  os_log_t v516;
  os_log_type_t v517[4];
  uint8_t *v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;
  int Value;
  CFTypeID v523;
  CFTypeID v524;
  int v525;
  int v526;
  uint64_t v527;
  uint64_t v528;
  int v529;
  float v530;
  int v532;
  int isKindOfClass;
  uint64_t v534;
  uint64_t v535;
  int v536;
  CFTypeID TypeID;
  CFTypeID v538;
  int v539;
  int v540;
  int v541;
  os_log_t log;
  os_log_type_t v543[4];
  uint8_t *buf;
  uint64_t inited;
  uint64_t v546;
  uint64_t v547;
  char *v548;
  void *context;
  os_log_type_t v550;
  os_log_t v551;
  int v552;
  _QWORD v553[2];
  int v554;
  uint8_t v555[7];
  os_log_type_t v556;
  os_log_t v557;
  float v558;
  int v559;
  int v560;
  unsigned int v561;
  int v562;
  os_log_type_t v563;
  os_log_t v564;
  uint8_t v565[15];
  os_log_type_t v566;
  os_log_t oslog;
  double v568;
  float v569;
  Boolean v570;
  char v571;
  char v572;
  char v573[4];
  char v574[19];
  os_log_type_t v575;
  char v576[7];
  os_log_type_t v577;
  char v578[8];
  char v579[16];
  char v580[24];
  char v581[28];
  char v582[4];
  char v583[11];
  BOOL v584;
  char v585[4];
  char v586[4];
  char v587[48];
  char v588[7];
  os_log_type_t v589;
  os_log_type_t v590;
  char v591[7];
  os_log_type_t v592;
  _QWORD v593[4];
  os_log_type_t v594;
  os_log_type_t v595;
  os_log_type_t v596;
  _QWORD v597[3];
  os_log_type_t v598;
  os_log_type_t v599;
  os_log_type_t v600;
  os_log_type_t v601;
  os_log_type_t v602;
  os_log_type_t v603;
  os_log_type_t v604;
  char v605[56];
  os_log_type_t v606[55];
  os_log_type_t v607;
  os_log_type_t v608;
  char v609[4];
  os_log_type_t v610[11];
  os_log_type_t v611;
  char valuePtr[11];
  os_log_type_t type;
  uint64_t v614;
  uint64_t v615;
  uint64_t v616;
  uint64_t v617;
  void *v618;
  uint8_t v619[32];
  uint8_t v620[16];
  uint8_t v621[32];
  uint8_t v622[32];
  uint8_t v623[48];
  uint8_t v624[48];
  uint8_t v625[16];
  uint8_t v626[32];
  uint8_t v627[16];
  uint8_t v628[16];
  uint8_t v629[16];
  uint8_t v630[32];
  uint8_t v631[16];
  uint8_t v632[48];
  uint8_t v633[48];
  uint8_t v634[48];
  uint8_t v635[48];
  uint8_t v636[16];
  uint8_t v637[32];
  uint8_t v638[16];
  uint8_t v639[8];
  uint64_t v640;

  v4 = (void *)MEMORY[0x1E0C80A78](this, a2, a3, a4);
  v548 = &v571;
  v640 = *MEMORY[0x1E0C80C00];
  v618 = v4;
  v617 = v5;
  v616 = v6;
  v615 = v7;
  context = v4;
  v614 = 0;
  if (_logHandle)
  {
    v547 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
    {
      v546 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else
    {
      inited = init_default_corebrightness_log();
      v546 = inited;
    }
    v547 = v546;
  }
  v8 = (os_log_t *)v548;
  *((_QWORD *)v548 + 104) = v547;
  type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v8[104], OS_LOG_TYPE_DEBUG))
  {
    log = (os_log_t)*((_QWORD *)v548 + 104);
    *(_DWORD *)v543 = type;
    buf = v639;
    __os_log_helper_16_0_1_4_0((uint64_t)v639, 4);
    _os_log_debug_impl(&dword_1B5291000, log, v543[0], "[%x]: ", v639, 8u);
  }
  v541 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("IOHIDEventSystemClientIsUnresponsive"));
  if (!(_BYTE)v541 && *((_DWORD *)context + 94))
  {
    v540 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("AABSensorOverride"));
    if ((_BYTE)v540)
    {
      if (*((_QWORD *)v548 + 106))
        CFDictionaryApplyFunction(*((CFDictionaryRef *)context + 53), (CFDictionaryApplierFunction)AABC::UpdateSensorOverride, *((void **)v548 + 106));
      return;
    }
    v539 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("ALSInternalSettings"));
    if ((_BYTE)v539)
    {
      if (*((_QWORD *)v548 + 106))
      {
        v538 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
        TypeID = CFDictionaryGetTypeID();
        if (v538 == TypeID)
          CFDictionaryApplyFunction(*((CFDictionaryRef *)v548 + 106), (CFDictionaryApplierFunction)AABC::_setInternalProperty, context);
      }
      return;
    }
    v536 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("CBSoftWakeActive"));
    if ((_BYTE)v536)
    {
      if (*((_QWORD *)context + 507))
      {
        if (*((_QWORD *)v548 + 106))
        {
          v534 = *((_QWORD *)v548 + 106);
          v535 = objc_opt_class();
          isKindOfClass = objc_opt_isKindOfClass();
          if ((isKindOfClass & 1) != 0)
          {
            v9 = (id *)v548;
            *((_DWORD *)v548 + 206) = 0;
            v532 = objc_msgSend(v9[106], "intValue");
            v10 = v548;
            v11 = (id *)context;
            *((_DWORD *)v548 + 206) = v532;
            if (!objc_msgSend(v11[507], "action:", *((int *)v10 + 206)))
            {
              v530 = AABC::IlluminanceToLuminance((uint64_t)context, (float *)context + 262, *((float *)context + 156));
              AABC::UpdateDisplayBrightness_Block6((uint64_t)context, 1, 2, 1, v530);
            }
          }
        }
      }
      return;
    }
    v529 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("CBHasExternalDisplay"));
    if ((_BYTE)v529)
    {
      if (*((_QWORD *)v548 + 106))
      {
        v527 = *((_QWORD *)v548 + 106);
        v528 = objc_opt_class();
        v526 = objc_opt_isKindOfClass();
        if ((v526 & 1) != 0
          && *((_QWORD *)context + 508)
          && (objc_msgSend(*((id *)context + 508), "setActive:", objc_msgSend(*((id *)v548 + 106), "BOOLValue") & 1) & 1) != 0)
        {
          AABC::_UpdateNitsRestrictions((AABC *)context, -1.0, 1.5, 1);
        }
      }
      return;
    }
    v525 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("BrightnessCurveLevel"));
    if ((_BYTE)v525)
    {
      if (*((_QWORD *)v548 + 106))
      {
        v524 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
        v523 = CFNumberGetTypeID();
        if (v524 == v523)
        {
          v12 = (CFNumberRef *)v548;
          *((_DWORD *)v548 + 205) = 0;
          Value = CFNumberGetValue(v12[106], kCFNumberIntType, valuePtr);
          if ((_BYTE)Value)
          {
            if (*((_DWORD *)v548 + 205) > 2u)
            {
              *((_QWORD *)v548 + 101) = 0;
              if (_logHandle)
              {
                v521 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v520 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  v519 = init_default_corebrightness_log();
                  v520 = v519;
                }
                v521 = v520;
              }
              v13 = (os_log_t *)v548;
              *((_QWORD *)v548 + 101) = v521;
              v611 = OS_LOG_TYPE_DEBUG;
              if (os_log_type_enabled(v13[101], OS_LOG_TYPE_DEBUG))
              {
                v516 = (os_log_t)*((_QWORD *)v548 + 101);
                *(_DWORD *)v517 = v611;
                v518 = v638;
                __os_log_helper_16_0_1_4_0((uint64_t)v638, 2);
                _os_log_debug_impl(&dword_1B5291000, v516, v517[0], "[%x]: invalid curve level - setting to default.", v638, 8u);
              }
              *((_DWORD *)context + 851) = 1;
            }
            else if (*((_DWORD *)v548 + 205) != *((_DWORD *)context + 851))
            {
              *((_DWORD *)context + 851) = *((_DWORD *)v548 + 205);
            }
            +[CBAnalytics cuveLevel:](CBAnalytics, "cuveLevel:", *((unsigned int *)context + 851));
            memcpy((char *)context + 1048, (char *)context + 104 * *((unsigned int *)context + 851) + 736, 0x68uLL);
            memcpy((char *)context + 2540, (char *)context + 164 * *((unsigned int *)context + 851) + 2048, 0xA4uLL);
            if (*((_QWORD *)context + 521))
              objc_msgSend(*((id *)context + 521), "sendCommand:inputBuffer:inputBufferSize:", 229, (char *)context + 3404, 4);
            if (*((_DWORD *)context + 717) != 1)
            {
              AABC::CancelRamp((AABC *)context);
              v14 = (float *)context;
              *((_DWORD *)v548 + 200) = 0;
              v515 = AABC::IlluminanceToLuminance((uint64_t)v14, v14 + 262, v14[156]);
              v15 = (float *)context;
              v16 = (float *)v548;
              *((float *)v548 + 200) = v515;
              v514 = clamp(v16[200], v15[180], v15[182]);
              v17 = context;
              v18 = (float *)v548;
              *((float *)v548 + 200) = v514;
              AABC::UpdateDisplayBrightness_Block6((uint64_t)v17, 1, 2, 1, v18[200]);
            }
          }
        }
      }
      return;
    }
    v513 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("CBAOTStateUpdate"));
    if ((_BYTE)v513)
    {
      v19 = v548;
      *((_DWORD *)v548 + 199) = 0;
      *((_DWORD *)v19 + 199) = 255;
      *((_DWORD *)v19 + 198) = 0;
      *((_DWORD *)v19 + 198) = 0;
      if (*((_QWORD *)v19 + 106)
        && (v512 = CFGetTypeID(*((CFTypeRef *)v548 + 106)), v511 = CFNumberGetTypeID(), v512 == v511))
      {
        CFNumberGetValue(*((CFNumberRef *)v548 + 106), kCFNumberIntType, v610);
        *((float *)v548 + 198) = 1.0;
      }
      else if (*((_QWORD *)v548 + 106))
      {
        v510 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
        v509 = CFDictionaryGetTypeID();
        if (v510 == v509)
        {
          v20 = (CFDictionaryRef *)v548;
          *((_QWORD *)v548 + 98) = 0;
          v508 = CFDictionaryGetValue(v20[106], CFSTR("AOTState"));
          v21 = v548;
          *((_QWORD *)v548 + 98) = v508;
          *((_QWORD *)v21 + 97) = 0;
          v507 = CFDictionaryGetValue(*((CFDictionaryRef *)v21 + 106), CFSTR("AOTTransitionTime"));
          v22 = v548;
          *((_QWORD *)v548 + 97) = v507;
          if (*((_QWORD *)v22 + 98))
          {
            v506 = CFGetTypeID(*((CFTypeRef *)v548 + 98));
            v505 = CFNumberGetTypeID();
            if (v506 == v505)
              CFNumberGetValue(*((CFNumberRef *)v548 + 98), kCFNumberIntType, v610);
          }
          if (*((_QWORD *)v548 + 97))
          {
            v504 = CFGetTypeID(*((CFTypeRef *)v548 + 97));
            v503 = CFNumberGetTypeID();
            if (v504 == v503)
              CFNumberGetValue(*((CFNumberRef *)v548 + 97), kCFNumberFloatType, v609);
          }
        }
      }
      if (*((_DWORD *)v548 + 199) != *((_DWORD *)context + 717))
      {
        *((_QWORD *)v548 + 96) = 0;
        if (_logHandle)
        {
          v502 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
          {
            v501 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else
          {
            v500 = init_default_corebrightness_log();
            v501 = v500;
          }
          v502 = v501;
        }
        v23 = (os_log_t *)v548;
        *((_QWORD *)v548 + 96) = v502;
        v608 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v23[96], OS_LOG_TYPE_DEFAULT))
        {
          v497 = (os_log_t)*((_QWORD *)v548 + 96);
          *(_DWORD *)v498 = v608;
          if (*((_DWORD *)v548 + 199))
            v24 = "Entering AOT";
          else
            v24 = "Exiting AOT";
          *(double *)&v25 = *((float *)v548 + 198);
          v499 = v637;
          __os_log_helper_16_2_2_8_32_8_0((uint64_t)v637, (uint64_t)v24, v25);
          _os_log_impl(&dword_1B5291000, v497, v498[0], "AOT State update, %s, transitionTime: %f", v637, 0x16u);
        }
        if (*((_QWORD *)context + 521)
          && *((_QWORD *)context + 41)
          && (*((_BYTE *)context + 2888) & 1) == 0
          && (*((_DWORD *)context + 717) != 2 || *((_DWORD *)v548 + 199) != 1)
          && (*((_DWORD *)context + 717) != 3 || *((_DWORD *)v548 + 199)))
        {
          if ((*((_BYTE *)context + 4176) & 1) == 0)
          {
            DisplaySetDCPPowerAssertionForAOT(*((_QWORD *)context + 51), 1);
            *((_BYTE *)context + 4176) = 1;
          }
          AABC::handleAODStateUpdateProperty((uint64_t)context, *((_DWORD *)v548 + 199), *((float *)v548 + 198));
        }
      }
      return;
    }
    v496 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("AOTCurve"));
    if ((_BYTE)v496)
    {
      v495 = (void *)MEMORY[0x1B5E4A8B0]();
      if (*((_QWORD *)v548 + 106))
      {
        v494 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
        v493 = CFDictionaryGetTypeID();
        if (v494 == v493)
        {
          *((_QWORD *)v548 + 94) = 0;
          if (_logHandle)
          {
            v492 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
            {
              v491 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else
            {
              v490 = init_default_corebrightness_log();
              v491 = v490;
            }
            v492 = v491;
          }
          v26 = (os_log_t *)v548;
          *((_QWORD *)v548 + 94) = v492;
          v607 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v26[94], OS_LOG_TYPE_DEFAULT))
          {
            v487 = (os_log_t)*((_QWORD *)v548 + 94);
            *(_DWORD *)v488 = v607;
            v27 = *((_QWORD *)v548 + 106);
            v489 = v636;
            __os_log_helper_16_2_1_8_66((uint64_t)v636, v27);
            _os_log_impl(&dword_1B5291000, v487, v488[0], "Custom Curve: %{public}@", v636, 0xCu);
          }
          v28 = v548;
          *((_QWORD *)v548 + 92) = 0;
          *((_QWORD *)v28 + 92) = *((_QWORD *)v28 + 106);
          *((_QWORD *)v28 + 91) = 0;
          v486 = objc_msgSend(MEMORY[0x1E0C99E08], "dictionaryWithCapacity:", 3);
          v29 = v548;
          v30 = context;
          *((_QWORD *)v548 + 91) = v486;
          *((_QWORD *)v29 + 87) = 0;
          *((_QWORD *)v29 + 88) = v606;
          *((_DWORD *)v29 + 178) = 0x20000000;
          *((_DWORD *)v29 + 179) = 32;
          *((_DWORD *)v29 + 180) = 0;
          *((_DWORD *)v29 + 180) = 0;
          v31 = (void *)*((_QWORD *)v29 + 92);
          *((_QWORD *)v29 + 80) = MEMORY[0x1E0C809B0];
          *((_DWORD *)v29 + 162) = -1073741824;
          *((_DWORD *)v29 + 163) = 0;
          *((_QWORD *)v29 + 82) = ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke;
          *((_QWORD *)v29 + 83) = &unk_1E68EBAE0;
          *((_QWORD *)v29 + 86) = v30;
          *((_QWORD *)v29 + 85) = v606;
          *((_QWORD *)v29 + 84) = *((_QWORD *)v29 + 91);
          objc_msgSend(v31, "enumerateKeysAndObjectsUsingBlock:", v605);
          if (*((_QWORD *)context + 521))
            AABC::sendAOTCurvesToDCP((AABC *)context);
          memcpy((char *)context + 2540, (char *)context + 164 * *((unsigned int *)context + 851) + 2048, 0xA4uLL);
          CFDictionarySetValue(*((CFMutableDictionaryRef *)context + 48), *((const void **)v548 + 107), *((const void **)v548 + 106));
          _Block_object_dispose(v606, 8);
        }
      }
      objc_autoreleasePoolPop(v495);
      return;
    }
    v485 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("DelayedALSOverride"));
    if ((_BYTE)v485)
    {
      if (*((_QWORD *)v548 + 106))
      {
        v484 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
        v483 = CFDictionaryGetTypeID();
        if (v484 == v483)
        {
          v32 = v548;
          *((_QWORD *)v548 + 77) = 0;
          *((_QWORD *)v32 + 76) = 0;
          *((_QWORD *)v32 + 76) = *((_QWORD *)v32 + 106);
          *((_QWORD *)v32 + 75) = 0;
          v482 = objc_msgSend(*((id *)v32 + 76), "objectForKey:", CFSTR("AABSensorOverrideOrientation"));
          v33 = v548;
          *((_QWORD *)v548 + 75) = v482;
          *((_QWORD *)v33 + 74) = 0;
          v481 = objc_msgSend(*((id *)v33 + 76), "objectForKey:", CFSTR("AABSensorOverrideValue"));
          v34 = v548;
          *((_QWORD *)v548 + 74) = v481;
          *((_QWORD *)v34 + 73) = 0;
          v480 = objc_msgSend(*((id *)v34 + 76), "objectForKey:", CFSTR("OverrideDelay"));
          v35 = v548;
          *((_QWORD *)v548 + 73) = v480;
          *((_DWORD *)v35 + 145) = 0;
          objc_msgSend(*((id *)v35 + 74), "floatValue");
          v479 = v36;
          v37 = v548;
          *((_DWORD *)v548 + 145) = (int)(float)(v36 * 65536.0);
          *((_DWORD *)v37 + 144) = 0;
          objc_msgSend(*((id *)v37 + 73), "floatValue");
          v478 = v38;
          v39 = v548;
          *((_DWORD *)v548 + 144) = (int)(float)(v38 * 65536.0);
          *((_QWORD *)v39 + 71) = 0;
          v477 = objc_alloc(MEMORY[0x1E0CB37E8]);
          v476 = objc_msgSend(v477, "initWithInt:", *((unsigned int *)v548 + 145));
          v40 = v548;
          *((_QWORD *)v548 + 71) = v476;
          *((_QWORD *)v40 + 70) = 0;
          v475 = objc_alloc(MEMORY[0x1E0CB37E8]);
          v474 = objc_msgSend(v475, "initWithInt:", *((unsigned int *)v548 + 144));
          v41 = (id *)v548;
          *((_QWORD *)v548 + 70) = v474;
          objc_msgSend(v41[74], "floatValue");
          v473 = v42;
          if (v42 == -1.0)
          {
            v472 = objc_alloc(MEMORY[0x1E0CB37E8]);
            v471 = objc_msgSend(v472, "initWithInt:", 0);
            *((_QWORD *)v548 + 77) = v471;
          }
          else
          {
            v470 = objc_alloc(MEMORY[0x1E0CB37E8]);
            v469 = objc_msgSend(v470, "initWithInt:", 1);
            *((_QWORD *)v548 + 77) = v469;
          }
          *((_QWORD *)v548 + 69) = 0;
          v468 = objc_alloc(MEMORY[0x1E0C99D80]);
          v43 = *((_QWORD *)v548 + 77);
          v44 = *((_QWORD *)v548 + 75);
          v45 = *((_QWORD *)v548 + 71);
          v46 = *((_QWORD *)v548 + 70);
          v466 = v184;
          v467 = objc_msgSend(v468, "initWithObjectsAndKeys:", v43, CFSTR("ALSOverrideState"), v44, CFSTR("AABSensorOverrideOrientation"), v45, CFSTR("AABSensorOverrideValue"), v46, CFSTR("OverrideDelay"), 0);
          v47 = context;
          *((_QWORD *)v548 + 69) = v467;
          if (v47[41])
            IOHIDServiceClientSetProperty(*((IOHIDServiceClientRef *)context + 41), CFSTR("DelayedALSOverride"), *((CFTypeRef *)v548 + 69));

        }
      }
      return;
    }
    v465 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("ALSResetCurve"));
    if ((_BYTE)v465)
    {
      AABC::CreateDefaultCurves((AABC *)context);
      AAB::Reset((AAB *)context);
      AABC::writeOutlierRemovalPreferences((uint64_t)context, 0);
      *((_QWORD *)v548 + 68) = 0;
      if (_logHandle)
      {
        v464 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          v463 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          v462 = init_default_corebrightness_log();
          v463 = v462;
        }
        v464 = v463;
      }
      v48 = (os_log_t *)v548;
      *((_QWORD *)v548 + 68) = v464;
      v604 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v48[68], OS_LOG_TYPE_DEFAULT))
      {
        v459 = (os_log_t)*((_QWORD *)v548 + 68);
        *(_DWORD *)v460 = v604;
        *(double *)&v49 = *((float *)context + 266);
        *(double *)&v50 = *((float *)context + 268);
        *(double *)&v51 = *((float *)context + 267);
        *(double *)&v52 = *((float *)context + 269);
        v53 = *((_DWORD *)context + 286);
        v461 = v635;
        __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_4_0((uint64_t)v635, v49, v50, v51, v52, v53);
        _os_log_impl(&dword_1B5291000, v459, v460[0], "Reseted curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f Type: %d", v635, 0x30u);
      }
      *((_QWORD *)v548 + 66) = 0;
      if (_logHandle)
      {
        v458 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          v457 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          v456 = init_default_corebrightness_log();
          v457 = v456;
        }
        v458 = v457;
      }
      v54 = (os_log_t *)v548;
      *((_QWORD *)v548 + 66) = v458;
      v603 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v54[66], OS_LOG_TYPE_DEFAULT))
      {
        v453 = (os_log_t)*((_QWORD *)v548 + 66);
        *(_DWORD *)v454 = v603;
        *(double *)&v55 = *((float *)context + 262);
        *(double *)&v56 = *((float *)context + 263);
        *(double *)&v57 = *((float *)context + 264);
        *(double *)&v58 = *((float *)context + 265);
        v455 = v634;
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v634, v55, v56, v57, v58);
        _os_log_impl(&dword_1B5291000, v453, v454[0], "Reseted dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v634, 0x2Au);
      }
      *((_QWORD *)v548 + 64) = 0;
      if (_logHandle)
      {
        v452 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          v451 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          v450 = init_default_corebrightness_log();
          v451 = v450;
        }
        v452 = v451;
      }
      v59 = (os_log_t *)v548;
      *((_QWORD *)v548 + 64) = v452;
      v602 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v59[64], OS_LOG_TYPE_DEFAULT))
      {
        v447 = (os_log_t)*((_QWORD *)v548 + 64);
        *(_DWORD *)v448 = v602;
        *(double *)&v60 = *((float *)context + 754);
        *(double *)&v61 = *((float *)context + 756);
        *(double *)&v62 = *((float *)context + 755);
        *(double *)&v63 = *((float *)context + 757);
        v64 = *((_DWORD *)context + 774);
        v449 = v633;
        __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_4_0((uint64_t)v633, v60, v61, v62, v63, v64);
        _os_log_impl(&dword_1B5291000, v447, v448[0], "Reseted alternative curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f Type: %d", v633, 0x30u);
      }
      *((_QWORD *)v548 + 62) = 0;
      if (_logHandle)
      {
        v446 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          v445 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          v444 = init_default_corebrightness_log();
          v445 = v444;
        }
        v446 = v445;
      }
      v65 = (os_log_t *)v548;
      *((_QWORD *)v548 + 62) = v446;
      v601 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v65[62], OS_LOG_TYPE_DEFAULT))
      {
        v441 = (os_log_t)*((_QWORD *)v548 + 62);
        *(_DWORD *)v442 = v601;
        *(double *)&v66 = *((float *)context + 750);
        *(double *)&v67 = *((float *)context + 751);
        *(double *)&v68 = *((float *)context + 752);
        *(double *)&v69 = *((float *)context + 753);
        v443 = v632;
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v632, v66, v67, v68, v69);
        _os_log_impl(&dword_1B5291000, v441, v442[0], "Reseted alternative dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v632, 0x2Au);
      }
      return;
    }
    v440 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("ALSUserPreference"));
    if ((_BYTE)v440)
    {
      if (*((_QWORD *)v548 + 106))
      {
        v439 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
        v438 = CFDictionaryGetTypeID();
        if (v439 == v438 && !*((_DWORD *)context + 162))
        {
          AABC::readCurveFromDictionary((uint64_t)context, *((const __CFDictionary **)v548 + 106), (float *)context + 262);
          v70 = (CFDictionaryRef *)v548;
          *((_QWORD *)v548 + 60) = 0;
          v437 = CFDictionaryGetValue(v70[106], CFSTR("AlternativeCurve"));
          v71 = v548;
          *((_QWORD *)v548 + 60) = v437;
          if (*((_QWORD *)v71 + 60))
          {
            v436 = CFGetTypeID(*((CFTypeRef *)v548 + 60));
            v435 = CFDictionaryGetTypeID();
            if (v436 == v435)
            {
              AABC::readCurveFromDictionary((uint64_t)context, *((const __CFDictionary **)v548 + 60), (float *)context + 750);
              *((_QWORD *)v548 + 59) = 0;
              if (_logHandle)
              {
                v434 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v433 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  v432 = init_default_corebrightness_log();
                  v433 = v432;
                }
                v434 = v433;
              }
              v72 = (os_log_t *)v548;
              *((_QWORD *)v548 + 59) = v434;
              v600 = OS_LOG_TYPE_INFO;
              if (os_log_type_enabled(v72[59], OS_LOG_TYPE_INFO))
              {
                v429 = (os_log_t)*((_QWORD *)v548 + 59);
                *(_DWORD *)v430 = v600;
                v73 = *((_QWORD *)v548 + 60);
                v431 = v631;
                __os_log_helper_16_2_1_8_64((uint64_t)v631, v73);
                _os_log_impl(&dword_1B5291000, v429, v430[0], "Set kIOHIDALSUserPreferenceKey: AlternativeCurve = %@", v631, 0xCu);
              }
              AABC::AlignCurveTypeWithStrategy((uint64_t)context, (_DWORD *)context + 262, (_DWORD *)context + 750);
            }
          }
          *((_QWORD *)v548 + 57) = 0;
          if (_logHandle)
          {
            v428 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
            {
              v427 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else
            {
              v426 = init_default_corebrightness_log();
              v427 = v426;
            }
            v428 = v427;
          }
          v74 = (os_log_t *)v548;
          *((_QWORD *)v548 + 57) = v428;
          v599 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v74[57], OS_LOG_TYPE_DEFAULT))
          {
            v422 = (os_log_t)*((_QWORD *)v548 + 57);
            *(_DWORD *)v423 = v599;
            v424 = *((_DWORD *)context + 286);
            v425 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)context + 8) + 104))(*((_QWORD *)context + 8));
            v420 = *((_DWORD *)context + 774);
            v421 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)context + 8) + 112))(*((_QWORD *)context + 8));
            v419 = v630;
            __os_log_helper_16_0_4_4_0_4_0_4_0_4_0((uint64_t)v630, v424, v425, v420, v421);
            _os_log_impl(&dword_1B5291000, v422, v423[0], "Curve type = %d (%d), Alternative curve type = %d (%d)", v630, 0x1Au);
          }
          v418 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)context + 8) + 104))(*((_QWORD *)context + 8));
          v75 = (_QWORD **)context;
          *((_DWORD *)context + 286) = v418;
          v417 = (*(uint64_t (**)(_QWORD *))(*v75[8] + 112))(v75[8]);
          v76 = context;
          *((_DWORD *)context + 774) = v417;
          if ((v76[3401] & 1) != 0)
          {
            v77 = (CFDictionaryRef *)v548;
            *((_QWORD *)v548 + 55) = 0;
            v416 = CFDictionaryGetValue(v77[106], CFSTR("CurveUpdates"));
            v78 = v548;
            *((_QWORD *)v548 + 55) = v416;
            if (*((_QWORD *)v78 + 55))
            {
              v415 = CFGetTypeID(*((CFTypeRef *)v548 + 55));
              v414 = CFArrayGetTypeID();
              if (v415 == v414)
              {
                *((_QWORD *)v548 + 54) = 0;
                if (_logHandle)
                {
                  v413 = _logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT)
                  {
                    v412 = _COREBRIGHTNESS_LOG_DEFAULT;
                  }
                  else
                  {
                    v411 = init_default_corebrightness_log();
                    v412 = v411;
                  }
                  v413 = v412;
                }
                v79 = (os_log_t *)v548;
                *((_QWORD *)v548 + 54) = v413;
                v598 = OS_LOG_TYPE_DEFAULT;
                if (os_log_type_enabled(v79[54], OS_LOG_TYPE_DEFAULT))
                {
                  v408 = (os_log_t)*((_QWORD *)v548 + 54);
                  *(_DWORD *)v409 = v598;
                  v80 = *((_QWORD *)v548 + 55);
                  v410 = v629;
                  __os_log_helper_16_2_1_8_64((uint64_t)v629, v80);
                  _os_log_impl(&dword_1B5291000, v408, v409[0], "Set kIOHIDALSUserPreferenceKey: CurveUpdates = %@", v629, 0xCu);
                }
                AABC::getCurveUpdatesFromArray((AABC *)context, *((objc_object **)v548 + 55), v597);
                AAB::SetCurveUpdates((uint64_t)context, (uint64_t)v597);
                std::list<AAB::CurveUpdate>::~list((uint64_t)v597);
              }
            }
            v81 = (CFDictionaryRef *)v548;
            *((_QWORD *)v548 + 49) = 0;
            v407 = CFDictionaryGetValue(v81[106], CFSTR("ReplacementCurve"));
            v82 = v548;
            *((_QWORD *)v548 + 49) = v407;
            if (*((_QWORD *)v82 + 49))
            {
              v406 = CFGetTypeID(*((CFTypeRef *)v548 + 49));
              v405 = CFDictionaryGetTypeID();
              if (v406 == v405)
              {
                AABC::readCurveFromDictionary((uint64_t)context, *((const __CFDictionary **)v548 + 49), (float *)context + 724);
                *((_QWORD *)v548 + 48) = 0;
                if (_logHandle)
                {
                  v404 = _logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT)
                  {
                    v403 = _COREBRIGHTNESS_LOG_DEFAULT;
                  }
                  else
                  {
                    v402 = init_default_corebrightness_log();
                    v403 = v402;
                  }
                  v404 = v403;
                }
                v83 = (os_log_t *)v548;
                *((_QWORD *)v548 + 48) = v404;
                v596 = OS_LOG_TYPE_DEFAULT;
                if (os_log_type_enabled(v83[48], OS_LOG_TYPE_DEFAULT))
                {
                  v399 = (os_log_t)*((_QWORD *)v548 + 48);
                  *(_DWORD *)v400 = v596;
                  v84 = *((_QWORD *)v548 + 49);
                  v401 = v628;
                  __os_log_helper_16_2_1_8_64((uint64_t)v628, v84);
                  _os_log_impl(&dword_1B5291000, v399, v400[0], "Set kIOHIDALSUserPreferenceKey: ReplacementCurve = %@", v628, 0xCu);
                }
              }
            }
            v85 = (CFDictionaryRef *)v548;
            *((_QWORD *)v548 + 46) = 0;
            v398 = CFDictionaryGetValue(v85[106], CFSTR("AlternativeReplacementCurve"));
            v86 = v548;
            *((_QWORD *)v548 + 46) = v398;
            if (*((_QWORD *)v86 + 46)
              && (v397 = CFGetTypeID(*((CFTypeRef *)v548 + 46)), v396 = CFDictionaryGetTypeID(), v397 == v396))
            {
              AABC::readCurveFromDictionary((uint64_t)context, *((const __CFDictionary **)v548 + 46), (float *)context + 776);
              *((_QWORD *)v548 + 45) = 0;
              if (_logHandle)
              {
                v395 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v394 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  v393 = init_default_corebrightness_log();
                  v394 = v393;
                }
                v395 = v394;
              }
              v87 = (os_log_t *)v548;
              *((_QWORD *)v548 + 45) = v395;
              v595 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v87[45], OS_LOG_TYPE_DEFAULT))
              {
                v390 = (os_log_t)*((_QWORD *)v548 + 45);
                *(_DWORD *)v391 = v595;
                v88 = *((_QWORD *)v548 + 46);
                v392 = v627;
                __os_log_helper_16_2_1_8_64((uint64_t)v627, v88);
                _os_log_impl(&dword_1B5291000, v390, v391[0], "Set kIOHIDALSUserPreferenceKey: AlternativeReplacementCurve = %@", v627, 0xCu);
              }
              AABC::AlignCurveTypeWithStrategy((uint64_t)context, (_DWORD *)context + 724, (_DWORD *)context + 776);
            }
            else
            {
              memcpy((char *)context + 3104, (char *)context + 2896, 0x68uLL);
            }
            *((_QWORD *)v548 + 43) = 0;
            if (_logHandle)
            {
              v389 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
              {
                v388 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else
              {
                v387 = init_default_corebrightness_log();
                v388 = v387;
              }
              v389 = v388;
            }
            v89 = (os_log_t *)v548;
            *((_QWORD *)v548 + 43) = v389;
            v594 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v89[43], OS_LOG_TYPE_DEFAULT))
            {
              v383 = (os_log_t)*((_QWORD *)v548 + 43);
              *(_DWORD *)v384 = v594;
              v385 = *((_DWORD *)context + 748);
              v386 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)context + 8) + 104))(*((_QWORD *)context + 8));
              v381 = *((_DWORD *)context + 800);
              v382 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)context + 8) + 112))(*((_QWORD *)context + 8));
              v380 = v626;
              __os_log_helper_16_0_4_4_0_4_0_4_0_4_0((uint64_t)v626, v385, v386, v381, v382);
              _os_log_impl(&dword_1B5291000, v383, v384[0], "Good curve type = %d (%d), Alternative good curve type = %d (%d)", v626, 0x1Au);
            }
            v379 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)context + 8) + 104))(*((_QWORD *)context + 8));
            v90 = (_QWORD **)context;
            *((_DWORD *)context + 748) = v379;
            v378 = (*(uint64_t (**)(_QWORD *))(*v90[8] + 112))(v90[8]);
            v91 = context;
            *((_DWORD *)context + 800) = v378;
            AABC::revertToGoodCurve((uint64_t)v91, 2u);
          }
          if ((*((_BYTE *)context + 3368) & 1) != 0)
          {
            v92 = (CFDictionaryRef *)v548;
            *((_QWORD *)v548 + 41) = 0;
            v377 = CFDictionaryGetValue(v92[106], CFSTR("ReplacementCurve"));
            v93 = v548;
            *((_QWORD *)v548 + 41) = v377;
            if (*((_QWORD *)v93 + 41))
            {
              v376 = CFGetTypeID(*((CFTypeRef *)v548 + 41));
              v375 = CFDictionaryGetTypeID();
              if (v376 == v375)
                AABC::readCurveFromDictionary((uint64_t)context, *((const __CFDictionary **)v548 + 41), (float *)context + 724);
            }
            v374 = CFDictionaryGetValue(*((CFDictionaryRef *)v548 + 106), CFSTR("Descriptor"));
            v94 = v548;
            *((_QWORD *)v548 + 41) = v374;
            if (*((_QWORD *)v94 + 41))
            {
              v373 = CFGetTypeID(*((CFTypeRef *)v548 + 41));
              v372 = CFDictionaryGetTypeID();
              if (v373 == v372)
                AABC::readCurveDescriptorFromDictionary((uint64_t)context, *((const __CFDictionary **)v548 + 41), (_DWORD *)context + 832);
            }
            AABC::readOutlierRemovalPreferences((AABC *)context);
            if (*((_DWORD *)context + 832) && *((_DWORD *)context + 832) < *((_DWORD *)context + 843))
            {
              AABC::revertToGoodCurve((uint64_t)context, 4u);
              *((_DWORD *)context + 840) = 1;
            }
            *((_BYTE *)context + 401) = 1;
          }
          *((_BYTE *)context + 400) = 1;
        }
      }
      return;
    }
    v371 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("CurveUpdates"));
    if ((_BYTE)v371)
    {
      if (*((_QWORD *)v548 + 106))
      {
        v370 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
        v369 = CFArrayGetTypeID();
        if (v370 == v369)
        {
          AABC::getCurveUpdatesFromArray((AABC *)context, *((objc_object **)v548 + 106), v593);
          AAB::SetCurveUpdates((uint64_t)context, (uint64_t)v593);
          AABC::revertToGoodCurve((uint64_t)context, 1u);
          std::list<AAB::CurveUpdate>::~list((uint64_t)v593);
        }
      }
      return;
    }
    v368 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("OutlierRemoval"));
    if ((_BYTE)v368)
    {
      if (*((_QWORD *)v548 + 106))
      {
        v367 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
        v366 = CFDictionaryGetTypeID();
        if (v367 == v366)
        {
          AABC::readOutlierRemovalFromDictionary((uint64_t)context, *((const __CFDictionary **)v548 + 106), (BOOL *)context + 3368);
          v95 = context;
          *((_QWORD *)v548 + 37) = 0;
          OutlierRemovalDictionary = AABC::createOutlierRemovalDictionary((uint64_t)v95, v95 + 3368);
          v96 = (const void **)v548;
          v97 = (CFMutableDictionaryRef *)context;
          *((_QWORD *)v548 + 37) = OutlierRemovalDictionary;
          CFDictionarySetValue(v97[48], v96[107], v96[37]);
          CFRelease(*((CFTypeRef *)v548 + 37));
        }
      }
      return;
    }
    v364 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("ALSLockScreenAutoBrightness"));
    if ((_BYTE)v364)
    {
      CFBooleanValue = GetCFBooleanValue(*((const __CFNumber **)v548 + 106));
      v98 = v548;
      *((_DWORD *)context + 860) = CFBooleanValue;
      *((_QWORD *)v98 + 36) = 0;
      if (_logHandle)
      {
        v362 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          v361 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          v360 = init_default_corebrightness_log();
          v361 = v360;
        }
        v362 = v361;
      }
      v99 = (os_log_t *)v548;
      *((_QWORD *)v548 + 36) = v362;
      v592 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v99[36], OS_LOG_TYPE_DEBUG))
      {
        v357 = (os_log_t)*((_QWORD *)v548 + 36);
        *(_DWORD *)v358 = v592;
        v100 = *((_DWORD *)context + 860);
        v359 = v625;
        __os_log_helper_16_0_2_4_0_4_0((uint64_t)v625, 2, v100);
        _os_log_debug_impl(&dword_1B5291000, v357, v358[0], "[%x]: _settings._internal._lockScreenAutoBrightness=%x", v625, 0xEu);
      }
      CFDictionarySetValue(*((CFMutableDictionaryRef *)context + 48), *((const void **)v548 + 107), *((const void **)v548 + 106));
      return;
    }
    v356 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("ALSAccessoryAbsoluteThreshold"));
    if ((_BYTE)v356)
    {
      v355 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
      v354 = CFNumberGetTypeID();
      if (v355 == v354)
      {
        v101 = v548;
        v102 = context;
        *((_DWORD *)v548 + 70) = 0;
        *((_DWORD *)v101 + 70) = v102[35];
        v353 = CFNumberGetValue(*((CFNumberRef *)v101 + 106), kCFNumberFloatType, v591);
        if ((_BYTE)v353)
          *((_DWORD *)context + 35) = *((_DWORD *)v548 + 70);
      }
      return;
    }
    v352 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("LogLevel"));
    if ((_BYTE)v352)
    {
      *((_QWORD *)v548 + 34) = 0;
      if (_logHandle)
      {
        v351 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          v350 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          v349 = init_default_corebrightness_log();
          v350 = v349;
        }
        v351 = v350;
      }
      v103 = (os_log_t *)v548;
      *((_QWORD *)v548 + 34) = v351;
      v590 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v103[34], OS_LOG_TYPE_DEBUG))
      {
        v346 = (os_log_t)*((_QWORD *)v548 + 34);
        *(_DWORD *)v347 = v590;
        *(double *)&v104 = *((float *)context + 266);
        *(double *)&v105 = *((float *)context + 268);
        *(double *)&v106 = *((float *)context + 267);
        *(double *)&v107 = *((float *)context + 269);
        v348 = v624;
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v624, v104, v105, v106, v107);
        _os_log_debug_impl(&dword_1B5291000, v346, v347[0], "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f", v624, 0x2Au);
      }
      *((_QWORD *)v548 + 32) = 0;
      if (_logHandle)
      {
        v345 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          v344 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          v343 = init_default_corebrightness_log();
          v344 = v343;
        }
        v345 = v344;
      }
      v108 = (os_log_t *)v548;
      *((_QWORD *)v548 + 32) = v345;
      v589 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v108[32], OS_LOG_TYPE_DEBUG))
      {
        v340 = (os_log_t)*((_QWORD *)v548 + 32);
        *(_DWORD *)v341 = v589;
        *(double *)&v109 = *((float *)context + 262);
        *(double *)&v110 = *((float *)context + 263);
        *(double *)&v111 = *((float *)context + 264);
        *(double *)&v112 = *((float *)context + 265);
        v342 = v623;
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v623, v109, v110, v111, v112);
        _os_log_debug_impl(&dword_1B5291000, v340, v341[0], "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v623, 0x2Au);
      }
      return;
    }
    v339 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("AutoBrightnessProxEnabled"));
    if ((_BYTE)v339)
    {
      *((_BYTE *)context + 3937) = GetCFBooleanValue(*((const __CFNumber **)v548 + 106)) != 0;
      return;
    }
    v338 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("AutoBrightnessProxDelay"));
    if ((_BYTE)v338)
    {
      v337 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
      v336 = CFNumberGetTypeID();
      if (v337 == v336)
      {
        v113 = v548;
        v114 = (float *)context;
        *((_DWORD *)v548 + 62) = 0;
        *((_DWORD *)v113 + 62) = (int)v114[985];
        v335 = CFNumberGetValue(*((CFNumberRef *)v113 + 106), kCFNumberFloatType, v588);
        if ((_BYTE)v335)
          *((float *)context + 985) = (float)*((int *)v548 + 62);
      }
      return;
    }
    v334 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("AutoBrightnessTouchEnabled"));
    if ((_BYTE)v334 || (v333 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("AutoBrightnessTouchDelay")), (_BYTE)v333))
    {
      v115 = context;
      v116 = v548;
      *((_QWORD *)v548 + 25) = MEMORY[0x1E0C809B0];
      *((_DWORD *)v116 + 52) = -1073741824;
      *((_DWORD *)v116 + 53) = 0;
      *((_QWORD *)v116 + 27) = ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke_520;
      *((_QWORD *)v116 + 28) = &__block_descriptor_48_e35_v24__0____IOHIDServiceClient__8_v16l;
      *((_QWORD *)v116 + 29) = *((_QWORD *)v116 + 106);
      *((_QWORD *)v116 + 30) = *((_QWORD *)v116 + 107);
      AABC::enumerateALSes((uint64_t)v115, (uint64_t)v587);
      return;
    }
    v332 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("AutoBrightnessLogMask"));
    if ((_BYTE)v332)
    {
      v331 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
      v330 = CFNumberGetTypeID();
      if (v331 == v330)
      {
        v117 = v548;
        v118 = context;
        *((_DWORD *)v548 + 49) = 0;
        *((_DWORD *)v117 + 49) = v118[81];
        v329 = CFNumberGetValue(*((CFNumberRef *)v117 + 106), kCFNumberIntType, v586);
        if ((_BYTE)v329)
          *((_DWORD *)context + 81) = *((_DWORD *)v548 + 49) | 1;
      }
      return;
    }
    v328 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("AutoBrightnessLuxFilter"));
    if ((_BYTE)v328)
    {
      v327 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
      v326 = CFNumberGetTypeID();
      if (v327 == v326)
      {
        v119 = v548;
        v120 = context;
        *((_DWORD *)v548 + 48) = 0;
        *((_DWORD *)v119 + 48) = v120[864];
        v325 = CFNumberGetValue(*((CFNumberRef *)v119 + 106), kCFNumberIntType, v585);
        if ((_BYTE)v325)
        {
          if (*((_DWORD *)v548 + 48) < 4u)
            *((_DWORD *)context + 864) = *((_DWORD *)v548 + 48);
        }
      }
      return;
    }
    v324 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("ALSIntPeriod"));
    if ((_BYTE)v324)
      return;
    v323 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("DisplayBrightnessAuto"));
    if ((_BYTE)v323)
    {
      AABC::UpdateAutoBrightnessEnabledStatus((AABC *)context, *((const __CFNumber **)v548 + 106));
      return;
    }
    v322 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("CBDisplayPresetDisableAutoBrightness"));
    if ((_BYTE)v322)
    {
      v584 = 0;
      v321 = GetCFBooleanValue(*((const __CFNumber **)v548 + 106));
      v584 = (_BYTE)v321 == 0;
      if (((_BYTE)v321 == 0) != *((_DWORD *)context + 129))
      {
        v121 = (AABC *)context;
        *((_DWORD *)context + 129) = v584;
        AABC::_UpdateNitsRestrictions(v121, 0.0, 0.0, 1);
        if (v584)
        {
          v122 = (float *)context;
          *((_DWORD *)v548 + 46) = 0;
          v320 = AABC::IlluminanceToLuminance((uint64_t)v122, v122 + 262, v122[136], v122[139]);
          v123 = (float *)context;
          v124 = (float *)v548;
          *((float *)v548 + 46) = v320;
          v124[46] = fmaxf(v124[46], v123[180]);
          v124[46] = fminf(v124[46], v123[182]);
          AABC::UpdateDisplayBrightness_Block6((uint64_t)v123, 1, 2, 1, v124[46]);
        }
        if (*((_QWORD *)context + 44))
          (*((void (**)(_QWORD, const __CFString *, uint64_t))context + 44))(*((_QWORD *)context + 45), CFSTR("CBAutoBrightnessAvailable"), objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", v584));
      }
      return;
    }
    v319 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("DisplayOrientation"));
    if ((_BYTE)v319)
    {
      v318 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
      v317 = CFNumberGetTypeID();
      if (v318 == v317)
      {
        v125 = (CFNumberRef *)v548;
        *((_DWORD *)v548 + 45) = 0;
        CFNumberGetValue(v125[106], kCFNumberIntType, v583);
        AABC::SetDisplayOrientation((uint64_t)context, *((_DWORD *)v548 + 45));
      }
      return;
    }
    v316 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("DisplayBrightness"));
    if ((_BYTE)v316)
    {
      v315 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
      v314 = CFDictionaryGetTypeID();
      if (v315 == v314)
      {
        v126 = v548;
        v127 = context;
        *((_DWORD *)v548 + 44) = 0;
        *((_DWORD *)v126 + 44) = v127[133];
        *((_DWORD *)v126 + 43) = 0;
        *((_DWORD *)v126 + 43) = 0;
        *((_QWORD *)v126 + 20) = 0;
        v313 = CFDictionaryGetValue(*((CFDictionaryRef *)v126 + 106), CFSTR("Brightness"));
        v128 = v548;
        *((_QWORD *)v548 + 20) = v313;
        if (*((_QWORD *)v128 + 20))
        {
          v312 = CFNumberGetTypeID();
          v311 = CFGetTypeID(*((CFTypeRef *)v548 + 20));
          if (v312 == v311)
            CFNumberGetValue(*((CFNumberRef *)v548 + 20), kCFNumberFloatType, v582);
        }
        v129 = (CFDictionaryRef *)v548;
        *((_QWORD *)v548 + 19) = 0;
        v310 = CFDictionaryGetValue(v129[106], CFSTR("Commit"));
        v130 = v548;
        *((_QWORD *)v548 + 19) = v310;
        if (*((_QWORD *)v130 + 19))
        {
          v309 = GetCFBooleanValue(*((const __CFNumber **)v548 + 19));
          *((_DWORD *)v548 + 43) = v309;
        }
        AABC::SetUserBrightness((AABC *)context, *((float *)v548 + 44), *((_DWORD *)v548 + 43));
        if ((*((_BYTE *)context + 3417) & 1) == 0 && *((_DWORD *)v548 + 43))
        {
          v308 = DisplaySliderToLogicalBrightness(*((_QWORD *)context + 51), *((float *)context + 133));
          *((float *)context + 855) = v308;
        }
        if (*((_DWORD *)v548 + 43))
          AABC::setAABCurveUpdateReason((uint64_t)context, 0);
      }
      else
      {
        v307 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
        v306 = CFNumberGetTypeID();
        if (v307 == v306)
        {
          v131 = v548;
          v132 = context;
          *((_DWORD *)v548 + 37) = 0;
          *((_DWORD *)v131 + 37) = v132[133];
          CFNumberGetValue(*((CFNumberRef *)v131 + 106), kCFNumberFloatType, v581);
          AABC::SetUserBrightness((AABC *)context, *((float *)v548 + 37), 1);
          if ((*((_BYTE *)context + 3417) & 1) == 0)
            *((float *)context + 855) = DisplaySliderToLogicalBrightness(*((_QWORD *)context + 51), *((float *)context + 133));
        }
      }
      return;
    }
    v305 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("DisplayNitsKey"));
    if ((_BYTE)v305)
    {
      v304 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
      v303 = CFDictionaryGetTypeID();
      if (v304 == v303)
      {
        v133 = v548;
        v134 = context;
        *((_DWORD *)v548 + 36) = 0;
        *((_DWORD *)v133 + 36) = v134[133];
        *((_DWORD *)v133 + 35) = 0;
        *((_DWORD *)v133 + 35) = 0;
        *((_QWORD *)v133 + 16) = 0;
        v302 = CFDictionaryGetValue(*((CFDictionaryRef *)v133 + 106), CFSTR("Brightness"));
        v135 = v548;
        *((_QWORD *)v548 + 16) = v302;
        if (*((_QWORD *)v135 + 16))
        {
          v301 = CFNumberGetTypeID();
          v300 = CFGetTypeID(*((CFTypeRef *)v548 + 16));
          if (v301 == v300)
          {
            v136 = (CFNumberRef *)v548;
            *((_DWORD *)v548 + 31) = 0;
            v299 = CFNumberGetValue(v136[16], kCFNumberFloatType, v580);
            if ((_BYTE)v299)
            {
              v298 = DisplayLogicalToSliderBrightness(*((_QWORD *)context + 51), *((float *)v548 + 31));
              *((float *)v548 + 36) = v298;
            }
          }
        }
        v137 = (CFDictionaryRef *)v548;
        *((_QWORD *)v548 + 14) = 0;
        v297 = CFDictionaryGetValue(v137[106], CFSTR("Commit"));
        v138 = v548;
        *((_QWORD *)v548 + 14) = v297;
        if (*((_QWORD *)v138 + 14))
        {
          v296 = GetCFBooleanValue(*((const __CFNumber **)v548 + 14));
          *((_DWORD *)v548 + 35) = v296;
        }
        AABC::SetUserBrightness((AABC *)context, *((float *)v548 + 36), *((_DWORD *)v548 + 35));
      }
      else
      {
        v295 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
        v294 = CFNumberGetTypeID();
        if (v295 == v294)
        {
          v139 = (CFNumberRef *)v548;
          *((_DWORD *)v548 + 27) = 0;
          v293 = CFNumberGetValue(v139[106], kCFNumberFloatType, v579);
          if ((_BYTE)v293)
          {
            v292 = DisplayLogicalToSliderBrightness(*((_QWORD *)context + 51), *((float *)v548 + 27));
            AABC::SetUserBrightness((AABC *)context, v292, 1);
            if (*((float *)context + 855) < *((float *)context + 180))
              *((_DWORD *)context + 855) = *((_DWORD *)v548 + 27);
          }
        }
      }
      return;
    }
    v291 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("DisplayAutoBrightnessStatus"));
    if ((_BYTE)v291)
    {
      v290 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
      v289 = CFDictionaryGetTypeID();
      if (v290 == v289)
      {
        v140 = v548;
        *((_DWORD *)v548 + 26) = 0;
        *((_DWORD *)v140 + 26) = 0;
        *((_DWORD *)v140 + 25) = 0;
        *((_DWORD *)v140 + 25) = 0;
        *((_QWORD *)v140 + 11) = 0;
        v288 = CFDictionaryGetValue(*((CFDictionaryRef *)v140 + 106), CFSTR("DisplayAutoBrightnessActive"));
        v141 = v548;
        *((_QWORD *)v548 + 11) = v288;
        if (*((_QWORD *)v141 + 11))
        {
          v287 = CFGetTypeID(*((CFTypeRef *)v548 + 11));
          v286 = CFBooleanGetTypeID();
          if (v287 == v286)
          {
            v285 = CFBooleanGetValue(*((CFBooleanRef *)v548 + 11));
            *((_DWORD *)v548 + 26) = v285;
          }
        }
        v284 = CFDictionaryGetValue(*((CFDictionaryRef *)v548 + 106), CFSTR("DisplayAutoBrightnessDelay"));
        v142 = v548;
        *((_QWORD *)v548 + 11) = v284;
        if (*((_QWORD *)v142 + 11))
        {
          v283 = CFGetTypeID(*((CFTypeRef *)v548 + 11));
          v282 = CFNumberGetTypeID();
          if (v283 == v282)
            CFNumberGetValue(*((CFNumberRef *)v548 + 11), kCFNumberFloatType, v578);
        }
        AABC::SetAutoBrightnessStatus((AABC *)context, *((_DWORD *)v548 + 26), *((float *)v548 + 25));
      }
      return;
    }
    v281 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("DisplayBrightnessFadePeriod"));
    if ((_BYTE)v281)
    {
      v280 = CFNumberGetTypeID();
      v279 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
      if (v280 == v279)
      {
        CFNumberGetValue(*((CFNumberRef *)v548 + 106), kCFNumberFloatType, (char *)context + 500);
        *((_QWORD *)v548 + 10) = 0;
        if (_logHandle)
        {
          v278 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
          {
            v277 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else
          {
            v276 = init_default_corebrightness_log();
            v277 = v276;
          }
          v278 = v277;
        }
        v143 = (os_log_t *)v548;
        *((_QWORD *)v548 + 10) = v278;
        v577 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v143[10], OS_LOG_TYPE_DEBUG))
        {
          v273 = (os_log_t)*((_QWORD *)v548 + 10);
          *(_DWORD *)v274 = v577;
          *(double *)&v144 = *((float *)context + 125);
          v275 = v622;
          __os_log_helper_16_0_2_4_0_8_0((uint64_t)v622, 2, v144);
          _os_log_debug_impl(&dword_1B5291000, v273, v274[0], "[%x]: _fadePeriod=%f", v622, 0x12u);
        }
      }
      return;
    }
    v272 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("DisplayBrightnessFactorWithFade"));
    if ((_BYTE)v272)
    {
      v271 = CFNumberGetTypeID();
      v270 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
      if (v271 == v270)
      {
        v145 = v548;
        v146 = context;
        *((_DWORD *)v548 + 18) = 0;
        *((_DWORD *)v145 + 18) = v146[124];
        CFNumberGetValue(*((CFNumberRef *)v145 + 106), kCFNumberFloatType, v576);
        AABC::SetDisplayFactor((AABC *)context, *((float *)v548 + 18), 0);
      }
      else if (*((_QWORD *)v548 + 106))
      {
        v269 = CFDictionaryGetTypeID();
        v268 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
        if (v269 == v268)
        {
          v147 = (CFDictionaryRef *)v548;
          *((_QWORD *)v548 + 8) = 0;
          v267 = CFDictionaryGetValue(v147[106], CFSTR("DisplayBrightnessFadePeriod"));
          v148 = v548;
          *((_QWORD *)v548 + 8) = v267;
          if (*((_QWORD *)v148 + 8))
          {
            v266 = CFNumberGetTypeID();
            v265 = CFGetTypeID(*((CFTypeRef *)v548 + 8));
            if (v266 == v265)
            {
              CFNumberGetValue(*((CFNumberRef *)v548 + 8), kCFNumberFloat32Type, (char *)context + 500);
              *((_QWORD *)v548 + 7) = 0;
              if (_logHandle)
              {
                v264 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v263 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  v262 = init_default_corebrightness_log();
                  v263 = v262;
                }
                v264 = v263;
              }
              v149 = (os_log_t *)v548;
              *((_QWORD *)v548 + 7) = v264;
              v575 = OS_LOG_TYPE_DEBUG;
              if (os_log_type_enabled(v149[7], OS_LOG_TYPE_DEBUG))
              {
                v259 = (os_log_t)*((_QWORD *)v548 + 7);
                *(_DWORD *)v260 = v575;
                *(double *)&v150 = *((float *)context + 125);
                v261 = v621;
                __os_log_helper_16_0_2_4_0_8_0((uint64_t)v621, 2, v150);
                _os_log_debug_impl(&dword_1B5291000, v259, v260[0], "[%x]: _fadePeriod=%f", v621, 0x12u);
              }
            }
          }
          v151 = (CFDictionaryRef *)v548;
          *((_QWORD *)v548 + 5) = 0;
          v258 = CFDictionaryGetValue(v151[106], CFSTR("DisplayBrightnessFactor"));
          v152 = v548;
          *((_QWORD *)v548 + 5) = v258;
          if (*((_QWORD *)v152 + 5))
          {
            v257 = CFNumberGetTypeID();
            v256 = CFGetTypeID(*((CFTypeRef *)v548 + 5));
            if (v257 == v256)
            {
              v153 = v548;
              v154 = context;
              *((_DWORD *)v548 + 9) = 0;
              *((_DWORD *)v153 + 9) = v154[124];
              CFNumberGetValue(*((CFNumberRef *)v153 + 5), kCFNumberFloat32Type, v574);
              AABC::SetDisplayFactor((AABC *)context, *((float *)v548 + 9), 0);
            }
          }
        }
      }
LABEL_381:
      AABC::NotifyCPMSWhenDisplayChangeState((AABC *)context, *((float *)context + 124) > 0.0);
      return;
    }
    v255 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("DisplayBrightnessFactor"));
    if ((_BYTE)v255)
    {
      v254 = CFNumberGetTypeID();
      v253 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
      if (v254 == v253)
      {
        v155 = v548;
        v156 = context;
        *((_DWORD *)v548 + 8) = 0;
        *((_DWORD *)v155 + 8) = v156[124];
        CFNumberGetValue(*((CFNumberRef *)v155 + 106), kCFNumberFloatType, v573);
        AABC::SetDisplayFactor((AABC *)context, *((float *)v548 + 8), 0);
      }
      goto LABEL_381;
    }
    v252 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("DominoStateUpdate"));
    if ((_BYTE)v252)
    {
      v251 = CFBooleanGetTypeID();
      v250 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
      if (v251 == v250)
      {
        v572 = 0;
        v249 = CFBooleanGetValue(*((CFBooleanRef *)v548 + 106));
        v572 = v249;
        if ((*((_BYTE *)context + 3417) & 1) != v249)
        {
          v157 = context;
          *((_BYTE *)context + 3417) = v572 != 0;
          if ((v157[3417] & 1) != 0)
          {
            v167 = context;
            *((_BYTE *)context + 3418) = *((_DWORD *)context + 130) == 0;
            LogicalBrightness = DisplayGetLogicalBrightness(v167[51]);
            v168 = (AABC *)context;
            *((float *)context + 855) = LogicalBrightness;
            AABC::UpdateAutoBrightnessEnabledStatus(v168, (const __CFNumber *)*MEMORY[0x1E0C9AE50]);
            DisplaySetProperty(*((_QWORD *)context + 51), (uint64_t)CFSTR("DisplayBrightnessAuto"), MEMORY[0x1E0C9AAB0]);
            v169 = (float *)context;
            *((_DWORD *)v548 + 1) = 0;
            v245 = AABC::IlluminanceToLuminance((uint64_t)v169, v169 + 262, v169[136], v169[139]);
            v170 = (float *)context;
            v171 = v548;
            *((float *)v548 + 1) = v245;
            *(_DWORD *)v171 = 0;
            v244 = AABC::IlluminanceToLuminance((uint64_t)v170, v170 + 802, v170[136], v170[139]);
            v172 = context;
            v173 = (float *)v548;
            *(float *)v548 = v244;
            v173[1] = fminf(v173[1], *v173);
            if ((v172[3418] & 1) == 0)
              *((float *)v548 + 1) = fminf(*((float *)context + 855), *((float *)v548 + 1));
            v174 = (float *)context;
            v175 = (float *)v548;
            *((float *)v548 + 1) = fmaxf(*((float *)v548 + 1), *((float *)context + 180));
            v175[1] = fminf(v175[1], v174[182]);
            AABC::UpdateDisplayBrightness_Block6((uint64_t)v174, 1, 2, 1, v175[1]);
          }
          else
          {
            if ((*((_BYTE *)context + 3418) & 1) != 0)
            {
              v160 = (float *)context;
              *((_DWORD *)v548 + 5) = 0;
              v248 = AABC::IlluminanceToLuminance((uint64_t)v160, v160 + 262, v160[136], v160[139]);
              v161 = (float *)context;
              v162 = (float *)v548;
              *((float *)v548 + 5) = v248;
              v162[5] = fmaxf(v162[5], v161[180]);
              v162[5] = fminf(v162[5], v161[182]);
              AABC::UpdateDisplayBrightness_Block6((uint64_t)v161, 1, 2, 1, v162[5]);
            }
            else
            {
              AABC::CancelRamp((AABC *)context);
              v158 = (float *)context;
              v159 = v548;
              *((_DWORD *)v548 + 6) = 0;
              *((_DWORD *)v159 + 6) = 10;
              AABC::SetBrightness((AABC *)v158, v158[855], 0.5, *((_DWORD *)v159 + 6), (void (*)(void *))AABC::_RampDoneCallback, (uint64_t)v158);
            }
            v163 = v548;
            v164 = context;
            *((_DWORD *)v548 + 4) = 0;
            *((_DWORD *)v163 + 4) = v164[3418] & 1;
            *((_QWORD *)v163 + 1) = 0;
            if (*((_DWORD *)v163 + 4))
              v247 = *MEMORY[0x1E0C9AE50];
            else
              v247 = *MEMORY[0x1E0C9AE40];
            v165 = (AABC *)context;
            v166 = (const __CFNumber **)v548;
            *((_QWORD *)v548 + 1) = v247;
            AABC::UpdateAutoBrightnessEnabledStatus(v165, v166[1]);
            DisplaySetProperty(*((_QWORD *)context + 51), (uint64_t)CFSTR("DisplayBrightnessAuto"), objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", *((unsigned int *)v548 + 4)));
          }
        }
      }
    }
    else
    {
      v243 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("ActivateALS"));
      if ((_BYTE)v243)
      {
        v242 = CFBooleanGetTypeID();
        v241 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
        if (v242 == v241)
        {
          v570 = 0;
          v570 = CFBooleanGetValue(*((CFBooleanRef *)v548 + 106));
          v569 = 0.0;
          v176 = 1.0;
          if (!v570)
            v176 = 0.0;
          v177 = v176;
          v569 = v177;
          AABC::SetDisplayFactor((AABC *)context, v177, 1);
        }
      }
      else
      {
        v240 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("DisplayBrightnessFactorPending"));
        if (!(_BYTE)v240)
        {
          v239 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("UserInteractedWithUI"));
          if ((_BYTE)v239)
          {
            Current = CFAbsoluteTimeGetCurrent();
            v568 = Current;
            if (*((double *)context + 85) + 3.0 >= Current)
            {
              v564 = 0;
              if (_logHandle)
              {
                v231 = (os_log_t)_logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v230 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  v229 = init_default_corebrightness_log();
                  v230 = v229;
                }
                v231 = v230;
              }
              v564 = v231;
              v563 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v231, OS_LOG_TYPE_DEFAULT))
              {
                v226 = v564;
                *(_DWORD *)v227 = v563;
                v228 = v620;
                __os_log_helper_16_0_1_8_0((uint64_t)v620, 0x4008000000000000);
                _os_log_impl(&dword_1B5291000, v564, v563, "User interacted with UI in first %f sec of fast ramp mode -> postpone switching to slow mode.", v620, 0xCu);
              }
              *((double *)context + 86) = *((double *)context + 85) + 3.0;
            }
            else
            {
              oslog = 0;
              if (_logHandle)
              {
                v237 = (os_log_t)_logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v236 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  v235 = init_default_corebrightness_log();
                  v236 = v235;
                }
                v237 = v236;
              }
              oslog = v237;
              v566 = OS_LOG_TYPE_INFO;
              if (os_log_type_enabled(v237, OS_LOG_TYPE_INFO))
              {
                v232 = oslog;
                *(_DWORD *)v233 = v566;
                v234 = v565;
                __os_log_helper_16_0_0(v565);
                _os_log_impl(&dword_1B5291000, v232, v233[0], "User interacted with UI -> end fast ramp mode", v565, 2u);
              }
              if ((*((_BYTE *)context + 443) & 1) != 0)
              {
                AABC::CancelFastRampMode((CFAbsoluteTime *)context);
              }
              else if (*((_DWORD *)context + 169))
              {
                *((_QWORD *)context + 86) = *((_QWORD *)context + 85);
              }
            }
            *((_BYTE *)context + 3320) = 1;
          }
          else
          {
            v225 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("ALSTurnOn"));
            if ((_BYTE)v225)
            {
              v562 = 0;
              v224 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
              v223 = CFBooleanGetTypeID();
              if (v224 == v223)
              {
                v562 = CFBooleanGetValue(*((CFBooleanRef *)v548 + 106));
                if (v562 != *((_DWORD *)context + 131))
                {
                  v178 = (float *)context;
                  *((_DWORD *)context + 131) = v562;
                  *((_DWORD *)v178 + 160) = v562 != 0;
                  v178[104] = 1.0;
                  AABC::UpdateALSState((CFDictionaryRef *)v178, 4);
                }
              }
            }
            else
            {
              v222 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("IOHIDALSTestMode"));
              if ((_BYTE)v222)
              {
                v221 = CFNumberGetTypeID();
                v220 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
                if (v221 == v220)
                {
                  v179 = (char *)context;
                  v180 = (CFNumberRef *)v548;
                  *((_DWORD *)context + 160) = 0;
                  CFNumberGetValue(v180[106], kCFNumberSInt32Type, v179 + 640);
                  AABC::UpdateALSState((CFDictionaryRef *)context, 4);
                }
              }
              else
              {
                v219 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("Aggressivity"));
                if ((_BYTE)v219)
                {
                  v218 = CFNumberGetTypeID();
                  v217 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
                  if (v218 == v217)
                  {
                    v561 = 0;
                    v561 = *((_DWORD *)context + 142);
                    CFNumberGetValue(*((CFNumberRef *)v548 + 106), kCFNumberIntType, &v561);
                    PerceptualLuminanceThresholding::SetAggressivity(*((PerceptualLuminanceThresholding **)context + 502), v561);
                  }
                }
                else
                {
                  v216 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("EcoMode"));
                  if ((_BYTE)v216)
                  {
                    v215 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
                    v214 = CFBooleanGetTypeID();
                    if (v215 == v214)
                    {
                      v213 = CFBooleanGetValue(*((CFBooleanRef *)v548 + 106));
                      AABC::_UpdateEcoModeState(context, (_BYTE)v213 != 0);
                    }
                    else
                    {
                      v212 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
                      v211 = CFNumberGetTypeID();
                      if (v212 == v211)
                      {
                        v560 = 0;
                        CFNumberGetValue(*((CFNumberRef *)v548 + 106), kCFNumberIntType, &v560);
                        AABC::_UpdateEcoModeState(context, v560 != 0);
                      }
                    }
                  }
                  else
                  {
                    v210 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("PreStrobe"));
                    if ((_BYTE)v210)
                    {
                      if (*((_QWORD *)v548 + 106))
                      {
                        v209 = CFNumberGetTypeID();
                        v208 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
                        if (v209 == v208)
                        {
                          v559 = 0;
                          CFNumberGetValue(*((CFNumberRef *)v548 + 106), kCFNumberIntType, &v559);
                          if (*((_QWORD *)context + 59))
                          {
                            service = (IOHIDServiceClientRef)*((_QWORD *)context + 59);
                            if (v559)
                              property = (CFTypeRef)*MEMORY[0x1E0C9AE50];
                            else
                              property = (CFTypeRef)*MEMORY[0x1E0C9AE40];
                            IOHIDServiceClientSetProperty(service, CFSTR("MuonEnabled"), property);
                          }
                          *((_BYTE *)context + 506) = v559 != 0;
                        }
                      }
                    }
                    else if (*((_QWORD *)v548 + 106)
                           && (v205 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("BrightnessWeakCap")), (_BYTE)v205))
                    {
                      v204 = CFNumberGetTypeID();
                      v203 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
                      if (v204 == v203)
                      {
                        v558 = 100.0;
                        CFNumberGetValue(*((CFNumberRef *)v548 + 106), kCFNumberFloatType, &v558);
                        AABC::CancelRamp((AABC *)context);
                        if (v558 >= 100.0)
                        {
                          v182 = context;
                          *((_DWORD *)context + 1020) = *((_DWORD *)context + 182);
                          v182[4084] = 0;
                        }
                        else
                        {
                          v202 = DisplaySliderToLogicalBrightness(*((_QWORD *)context + 51), v558);
                          v181 = context;
                          *((float *)context + 1020) = v202;
                          v181[4084] = 1;
                          *((_DWORD *)v181 + 1022) = *((_DWORD *)v181 + 136);
                          v557 = 0;
                          if (_logHandle)
                          {
                            v201 = (os_log_t)_logHandle;
                          }
                          else
                          {
                            if (_COREBRIGHTNESS_LOG_DEFAULT)
                              v200 = _COREBRIGHTNESS_LOG_DEFAULT;
                            else
                              v200 = init_default_corebrightness_log();
                            v201 = v200;
                          }
                          v557 = v201;
                          v556 = OS_LOG_TYPE_INFO;
                          if (os_log_type_enabled(v201, OS_LOG_TYPE_INFO))
                          {
                            v197 = v557;
                            *(_DWORD *)v198 = v556;
                            v199 = v555;
                            __os_log_helper_16_0_0(v555);
                            _os_log_impl(&dword_1B5291000, v197, v198[0], "Enabling weak cap\n", v555, 2u);
                          }
                        }
                        *((_BYTE *)context + 4092) = 1;
                      }
                    }
                    else if (*((_QWORD *)v548 + 106)
                           && (v196 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("RLuxEnable")), (_BYTE)v196))
                    {
                      v195 = CFBooleanGetTypeID();
                      v194 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
                      if (v195 == v194)
                      {
                        v554 = 0;
                        v193 = CFBooleanGetValue(*((CFBooleanRef *)v548 + 106));
                        v554 = v193;
                        v192 = (_BYTE)v193 == 0;
                        v553[0] = std::bitset<3ul>::operator[][abi:ne180100]((uint64_t)context + 304, 2);
                        v553[1] = v183;
                        std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator=[abi:ne180100]((uint64_t)v553, (_BYTE)v193 == 0);
                        AABC::evaluateAABRearConditions((id *)context);
                      }
                    }
                    else if (*((_QWORD *)v548 + 106)
                           && (v191 = CFEqual(*((CFTypeRef *)v548 + 107), CFSTR("AliasingMitigationFilterDuration")),
                               (_BYTE)v191))
                    {
                      v190 = CFNumberGetTypeID();
                      v189 = CFGetTypeID(*((CFTypeRef *)v548 + 106));
                      if (v190 == v189)
                      {
                        v552 = 0;
                        CFNumberGetValue(*((CFNumberRef *)v548 + 106), kCFNumberIntType, &v552);
                        AABC::resetFilter((uint64_t)context, (uint64_t *)context + 27);
                        if (v552 < 0)
                          AABC::setFilterDuration((uint64_t)context, (uint64_t)context + 216, 5);
                        else
                          AABC::setFilterDuration((uint64_t)context, (uint64_t)context + 216, v552);
                      }
                    }
                    else
                    {
                      v551 = 0;
                      if (_logHandle)
                      {
                        v188 = (os_log_t)_logHandle;
                      }
                      else
                      {
                        if (_COREBRIGHTNESS_LOG_DEFAULT)
                        {
                          v187 = _COREBRIGHTNESS_LOG_DEFAULT;
                        }
                        else
                        {
                          v186 = init_default_corebrightness_log();
                          v187 = v186;
                        }
                        v188 = v187;
                      }
                      v551 = v188;
                      v550 = OS_LOG_TYPE_DEBUG;
                      if (os_log_type_enabled(v188, OS_LOG_TYPE_DEBUG))
                      {
                        v184[9] = (_Unwind_Exception *)v551;
                        *(_DWORD *)v185 = v550;
                        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v619, 1, *((_QWORD *)v548 + 107), *((_QWORD *)v548 + 106));
                        _os_log_debug_impl(&dword_1B5291000, v551, v550, "[%x]: unknown key=%@ property=%@", v619, 0x1Cu);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void sub_1B52E1DFC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

id getMLFeatureValueClass()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLFeatureValueClass_softClass;
  v13 = getMLFeatureValueClass_softClass;
  if (!getMLFeatureValueClass_softClass)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLFeatureValueClass_block_invoke;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLFeatureValueClass_block_invoke((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

id getMLFeatureValueClass_0()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLFeatureValueClass_softClass_0;
  v13 = getMLFeatureValueClass_softClass_0;
  if (!getMLFeatureValueClass_softClass_0)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLFeatureValueClass_block_invoke_0;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLFeatureValueClass_block_invoke_0((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

id getMLFeatureValueClass_1()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLFeatureValueClass_softClass_1;
  v13 = getMLFeatureValueClass_softClass_1;
  if (!getMLFeatureValueClass_softClass_1)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLFeatureValueClass_block_invoke_1;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLFeatureValueClass_block_invoke_1((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

id getMLFeatureValueClass_2()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLFeatureValueClass_softClass_2;
  v13 = getMLFeatureValueClass_softClass_2;
  if (!getMLFeatureValueClass_softClass_2)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLFeatureValueClass_block_invoke_2;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLFeatureValueClass_block_invoke_2((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

id getMLFeatureValueClass_3()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLFeatureValueClass_softClass_3;
  v13 = getMLFeatureValueClass_softClass_3;
  if (!getMLFeatureValueClass_softClass_3)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLFeatureValueClass_block_invoke_3;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLFeatureValueClass_block_invoke_3((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

uint64_t __os_log_helper_16_2_3_8_64_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

id getMLPredictionOptionsClass()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLPredictionOptionsClass_softClass;
  v13 = getMLPredictionOptionsClass_softClass;
  if (!getMLPredictionOptionsClass_softClass)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLPredictionOptionsClass_block_invoke;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLPredictionOptionsClass_block_invoke((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

id getMLPredictionOptionsClass_0()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLPredictionOptionsClass_softClass_0;
  v13 = getMLPredictionOptionsClass_softClass_0;
  if (!getMLPredictionOptionsClass_softClass_0)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLPredictionOptionsClass_block_invoke_0;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLPredictionOptionsClass_block_invoke_0((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

id getMLPredictionOptionsClass_1()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLPredictionOptionsClass_softClass_1;
  v13 = getMLPredictionOptionsClass_softClass_1;
  if (!getMLPredictionOptionsClass_softClass_1)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLPredictionOptionsClass_block_invoke_1;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLPredictionOptionsClass_block_invoke_1((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

id getMLPredictionOptionsClass_2()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLPredictionOptionsClass_softClass_2;
  v13 = getMLPredictionOptionsClass_softClass_2;
  if (!getMLPredictionOptionsClass_softClass_2)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLPredictionOptionsClass_block_invoke_2;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLPredictionOptionsClass_block_invoke_2((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

id getMLPredictionOptionsClass_3()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLPredictionOptionsClass_softClass_3;
  v13 = getMLPredictionOptionsClass_softClass_3;
  if (!getMLPredictionOptionsClass_softClass_3)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLPredictionOptionsClass_block_invoke_3;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLPredictionOptionsClass_block_invoke_3((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

float DisplayNits2milliAmps(uint64_t a1, int a2)
{
  int v2;
  int v4;
  int v5;

  v5 = IOFixedDivide(a2, (int)(float)(*(float *)(a1 + 1324) * 65536.0));
  v2 = IOFixedMultiply(v5, v5);
  v4 = IOFixedMultiply(v2, *(_DWORD *)(a1 + 292));
  return (float)(int)(v4 + IOFixedMultiply(*(_DWORD *)(a1 + 296), v5) + *(_DWORD *)(a1 + 300)) / 65536.0;
}

uint64_t IOFixedMultiply(int a1, int a2)
{
  return (a1 * (uint64_t)a2) >> 16;
}

uint64_t IOFixedDivide(int a1, int a2)
{
  return ((uint64_t)a1 << 16) / a2;
}

void DisplaySetCurrentEDRHeadroom(uint64_t a1, float a2)
{
  NSObject *v2;
  void (*v3)(void);
  int v4;
  int v5;
  float (*v6)(uint64_t);
  void *v7;
  uint64_t v8;
  float v9;
  float v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v2 = *(NSObject **)(a1 + 144);
  v3 = (void (*)(void))MEMORY[0x1E0C809B0];
  v4 = -1073741824;
  v5 = 0;
  v6 = __DisplaySetCurrentEDRHeadroom_block_invoke;
  v7 = &__block_descriptor_44_e5_v8__0l;
  v8 = v11;
  v9 = a2;
  disp_dispatch_sync(v2, &v3);
}

uint64_t __DisplayUpdateAAPStateInternal(uint64_t result, uint64_t a2, char a3)
{
  if ((*(_BYTE *)(result + 12282) & 1) != 0)
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(result + 12472))(result, a2, a3 & 1);
  return result;
}

void __DisplayUpdateAAPStateLookup(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t inited;
  NSObject *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  char v13;
  float v14;
  float v15;
  float v16;
  int v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float PercentageFromIndex;
  float v26;
  int v27;
  int IndexFromValue;
  BOOL v29;
  char v30;
  uint8_t v32[32];
  uint8_t v33[48];
  uint8_t v34[56];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v30 = a3 & 1;
  v29 = 0;
  if (*(_DWORD *)a2)
  {
    switch(*(_DWORD *)a2)
    {
      case 1:
        *(_DWORD *)(a1 + 12304) = *(_DWORD *)(a2 + 4);
        v29 = (*(_BYTE *)(a1 + 12280) & 1) != 0;
        break;
      case 2:
        if ((float)((float)(vabds_f32(*(float *)(a2 + 4), *(float *)(a1 + 12300)) / *(float *)(a1 + 12300)) * 100.0) > *(float *)(a1 + 12268))
        {
          *(_DWORD *)(a1 + 12300) = *(_DWORD *)(a2 + 4);
          v29 = (*(_BYTE *)(a1 + 12280) & 1) != 0;
        }
        break;
      case 3:
        *(_DWORD *)(a1 + 12296) = *(_DWORD *)(a2 + 4);
        *(_BYTE *)(a1 + 12285) = *(float *)(a1 + 12296) != 1.0;
        v29 = (*(_BYTE *)(a1 + 12285) & 1) != 0;
        break;
    }
  }
  else
  {
    v13 = 1;
    if ((*(_BYTE *)(a2 + 4) & 1) == 0)
      v13 = *(_BYTE *)(a1 + 12284);
    *(_BYTE *)(a1 + 12280) = v13 & 1;
    if ((*(_BYTE *)(a1 + 12280) & 1) != 0)
      v29 = 1;
    else
      __DisplaySetAAPFactorWithFade(a1, 0, 0, 0.0, *(float *)(a1 + 12252));
  }
  if (v29)
  {
    v23 = *(float *)(a1 + 12304);
    v22 = *(float *)(a1 + 12300);
    IndexFromValue = __DisplayGetIndexFromValue(0, *(_DWORD *)(a1 + 12312) - 1, *(_QWORD *)(a1 + 12320), v23);
    PercentageFromIndex = __DisplayGetPercentageFromIndex(IndexFromValue, *(_DWORD *)(a1 + 12312) - 1, *(float **)(a1 + 12320), v23);
    if (IndexFromValue != *(_DWORD *)(a1 + 12288) || (v30 & 1) != 0)
    {
      v27 = __DisplayGetIndexFromValue(0, *(_DWORD *)(a1 + 12328) - 1, *(_QWORD *)(a1 + 12336), v22);
      v24 = __DisplayGetPercentageFromIndex(v27, *(_DWORD *)(a1 + 12328) - 1, *(float **)(a1 + 12336), v22);
      *(_DWORD *)(a1 + 12288) = IndexFromValue;
      if (v24 == 0.0)
        v12 = *(float *)(*(_QWORD *)(a1 + 12352) + 272 * v27 + 4 * IndexFromValue);
      else
        v12 = *(float *)(*(_QWORD *)(a1 + 12352) + 272 * (v27 + 1) + 4 * IndexFromValue);
      if (PercentageFromIndex == 0.0)
        v11 = *(float *)(*(_QWORD *)(a1 + 12352) + 272 * v27 + 4 * IndexFromValue);
      else
        v11 = *(float *)(*(_QWORD *)(a1 + 12352) + 272 * v27 + 4 * (IndexFromValue + 1));
      if (v24 == 0.0 || PercentageFromIndex == 0.0)
        v10 = *(float *)(*(_QWORD *)(a1 + 12352) + 272 * v27 + 4 * IndexFromValue);
      else
        v10 = *(float *)(*(_QWORD *)(a1 + 12352) + 272 * (v27 + 1) + 4 * (IndexFromValue + 1));
      v20 = *(float *)(*(_QWORD *)(a1 + 12352) + 272 * v27 + 4 * IndexFromValue);
      v18 = (float)(v20 + (float)((float)(v12 - v20) * v24))
          + (float)((float)((float)(v11 + (float)((float)(v10 - v11) * v24))
                          - (float)(v20 + (float)((float)(v12 - v20) * v24)))
                  * PercentageFromIndex);
      if ((*(_BYTE *)(a1 + 12285) & 1) != 0 && (*(_BYTE *)(a1 + 12292) & 1) != 0)
      {
        v15 = *(float *)(a1 + 12296);
        v17 = __DisplayGetIndexFromValue(0, *(_DWORD *)(a1 + 12360) - 1, *(_QWORD *)(a1 + 12368), v15);
        if (v17 && v17 != *(_DWORD *)(a1 + 12360) - 1)
        {
          v26 = *(float *)(*(_QWORD *)(a1 + 12368) + 4 * v17);
          v16 = (float)(v15 - v26) / (float)(*(float *)(*(_QWORD *)(a1 + 12368) + 4 * (v17 + 1)) - v26);
        }
        else
        {
          v16 = 0.0;
        }
        if (v16 == 0.0)
          v9 = *(float *)(*(_QWORD *)(a1 + 12384) + 4 * v17);
        else
          v9 = *(float *)(*(_QWORD *)(a1 + 12384) + 4 * (v17 + 1));
        v21 = *(float *)(*(_QWORD *)(a1 + 12384) + 4 * v17);
        v14 = v21 + (float)((float)(v9 - v21) * v16);
        if (_logHandle)
        {
          v8 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            inited = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            inited = init_default_corebrightness_log();
          v8 = inited;
        }
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v34, COERCE__INT64(v18), COERCE__INT64(v14), COERCE__INT64((float)(v18 * v14)), COERCE__INT64(v22), COERCE__INT64(v23));
          _os_log_debug_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEBUG, "Starting New HDR Ramp with LUT: UnScaledFactor:=%0.4f HDRScale:=%0.4f ScaledFactor:=%0.4f Lux:=%0.4f Nits:=%0.4f\n", v34, 0x34u);
        }
        v18 = v18 * v14;
      }
      else if ((*(_BYTE *)(a1 + 12285) & 1) == 0 || (*(_BYTE *)(a1 + 12292) & 1) != 0)
      {
        if (_logHandle)
        {
          v4 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v3 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v3 = init_default_corebrightness_log();
          v4 = v3;
        }
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v32, COERCE__INT64(v18), COERCE__INT64(v22), COERCE__INT64(v23));
          _os_log_debug_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEBUG, "Starting New AAP Ramp: Factor:=%0.4f Lux:=%0.4f Nits:=%0.4f\n", v32, 0x20u);
        }
      }
      else
      {
        if (_logHandle)
        {
          v6 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v5 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v5 = init_default_corebrightness_log();
          v6 = v5;
        }
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v33, COERCE__INT64(v18), COERCE__INT64(v22), COERCE__INT64(v23), COERCE__INT64(*(float *)(a1 + 12296)));
          _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "Starting New HDR AAP Ramp: Factor:=%0.4f Lux:=%0.4f Nits:=%0.4f HDRFactor:=%0.4f\n", v33, 0x2Au);
        }
      }
      v19 = (float)(v18 - 1.0) / 15.0;
      if (*(float *)(a1 + 12392) >= v19)
        __DisplaySetAAPFactorWithFade(a1, 0, 0, v19, *(float *)(a1 + 12276));
      else
        __DisplaySetAAPFactorWithFade(a1, 0, 0, v19, *(float *)(a1 + 12272));
    }
  }
}

float __DisplaySetAAPFactorWithFade(uint64_t a1, void (*a2)(uint64_t), uint64_t a3, float a4, float a5)
{
  float result;
  double v6;
  double v7;

  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a5 = *(float *)(a1 + 376);
  *(double *)(a1 + 12400) = a5;
  if (*(double *)(a1 + 12400) == 0.0)
  {
    *(float *)(a1 + 12424) = a4;
    *(float *)(a1 + 12416) = a4;
    *(float *)(a1 + 12420) = a4;
    __DisplaySetAAPFactor((_BYTE *)a1, a4);
    if (a2)
      a2(a3);
  }
  else
  {
    result = *(float *)(a1 + 12392);
    if (result != a4)
    {
      *(_QWORD *)(a1 + 12440) = a2;
      *(_QWORD *)(a1 + 12448) = a3;
      *(CFAbsoluteTime *)(a1 + 12408) = CFAbsoluteTimeGetCurrent();
      v7 = *(float *)(a1 + 12488);
      if (v7 == 0.0)
        v7 = 0.100000001;
      *(_DWORD *)(a1 + 12420) = *(_DWORD *)(a1 + 12392);
      *(_DWORD *)(a1 + 12424) = *(_DWORD *)(a1 + 12392);
      *(float *)(a1 + 12416) = a4;
      HIDWORD(v6) = HIDWORD(v7);
      *(float *)&v6 = v7;
      __DisplayStartFade((_BYTE *)a1, v6);
    }
  }
  return result;
}

void sub_1B52F23BC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void AABC::HandleProxEvent(AABC *this, __IOHIDServiceClient *a2, __IOHIDEvent *a3)
{
  float v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  os_log_type_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v15;
  uint8_t v17[7];
  os_log_type_t v18;
  NSObject *v19;
  os_log_type_t v20;
  os_log_t v21;
  uint8_t v22[7];
  os_log_type_t v23;
  NSObject *v24;
  int IntegerValue;
  __IOHIDEvent *v26;
  __IOHIDServiceClient *v27;
  AABC *v28;
  uint8_t v29[16];
  uint8_t v30[24];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v28 = this;
  v27 = a2;
  v26 = a3;
  IntegerValue = IOHIDEventGetIntegerValue();
  if (AABC::ignoreProxEventsInAOD((uint64_t)this, -[CBAODState AODState](+[CBAODState sharedInstance](CBAODState, "sharedInstance"), "AODState")))
  {
    v24 = 0;
    if (_logHandle)
    {
      v15 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v15 = inited;
    }
    v24 = v15;
    v23 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      log = v24;
      type = v23;
      __os_log_helper_16_0_0(v22);
      _os_log_impl(&dword_1B5291000, log, type, "Ongoing AOD transition IN/OUT -> Ignoring Prox Events!!", v22, 2u);
    }
  }
  else if ((IntegerValue & 0x200) != 0 || (IntegerValue & 0x40) != 0 || (IntegerValue & 0x100) != 0)
  {
    v21 = 0;
    if (_logHandle)
    {
      v11 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v10 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v10 = init_default_corebrightness_log();
      v11 = v10;
    }
    v21 = v11;
    v20 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_2_4_0_4_0((uint64_t)v30, 64, IntegerValue);
      _os_log_debug_impl(&dword_1B5291000, v21, v20, "[%x]: setting _proxState = kProxTriggered (proxMask=%x)", v30, 0xEu);
    }
    *((_DWORD *)this + 987) = 1;
    if ((*((_BYTE *)this + 3937) & 1) != 0)
    {
      if (*((float *)this + 154) < *((float *)this + 155))
      {
        v19 = 0;
        if (_logHandle)
        {
          v9 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v8 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v8 = init_default_corebrightness_log();
          v9 = v8;
        }
        v19 = v9;
        v18 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          v6 = v19;
          v7 = v18;
          __os_log_helper_16_0_0(v17);
          _os_log_impl(&dword_1B5291000, v6, v7, "Cancel ramp, prox. mitigation", v17, 2u);
        }
        AABC::CancelRamp(this);
      }
      DisplayCancelRestrictionFactorFade(*((_QWORD *)this + 51), 1);
    }
  }
  else
  {
    if (_logHandle)
    {
      v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v4 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v4 = init_default_corebrightness_log();
      v5 = v4;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_2_4_0_4_0((uint64_t)v29, 64, IntegerValue);
      _os_log_debug_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEBUG, "[%x]: setting _proxState = kProxReleased (proxMask=%x)", v29, 0xEu);
    }
    if (*((_DWORD *)this + 169))
    {
      *((_DWORD *)this + 987) = 0;
    }
    else
    {
      *((_DWORD *)this + 987) = 2;
      v3 = (double)(unint64_t)IOHIDEventGetTimeStamp() * *(double *)&AABC::_sMachTimebaseFactor;
      *((float *)this + 986) = v3;
    }
  }
}

BOOL AABC::ignoreProxEventsInAOD(uint64_t a1, uint64_t a2)
{
  BOOL v3;

  v3 = 1;
  if (a2 != 2)
  {
    v3 = 1;
    if (a2 != 3)
      return a2 == 1;
  }
  return v3;
}

uint64_t __os_log_helper_16_2_3_8_32_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

uint64_t ___ZN4AABC20InitializeCPMSModuleEv_block_invoke(uint64_t a1, void *a2)
{
  return AABC::ProcessCPMSBudget(*(_QWORD *)(a1 + 32), a2);
}

void ___ZN4AABC17ProcessCPMSBudgetEP12NSDictionaryIP8NSStringP8NSNumberE_block_invoke(uint64_t a1)
{
  float v1;
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  uint64_t v7;
  NSObject *v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  os_log_type_t v14;
  uint64_t inited;
  NSObject *v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  BOOL v21;
  uint64_t v22;
  AABC *v24;
  char v25;
  float v26;
  unsigned int v27;
  uint8_t v28[7];
  char v29;
  NSObject *v30;
  char v31;
  float v32;
  unsigned int APLColumnOrDefault;
  os_log_type_t v34;
  os_log_t v35;
  char v36;
  float v37;
  unsigned int HDRAPLColumn;
  id v39;
  float v40;
  float v41;
  float v42;
  uint64_t v43;
  uint64_t v44;
  uint8_t v45[32];
  uint8_t v46[32];
  uint8_t v47[24];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v44 = a1;
  v43 = a1;
  v24 = *(AABC **)(a1 + 40);
  v41 = -1.0;
  v40 = -1.0;
  v42 = -1.0;
  v39 = 0;
  if (objc_msgSend(*(id *)(a1 + 32), "valueForKey:", *MEMORY[0x1E0D09978]))
  {
    HDRAPLColumn = 0;
    HDRAPLColumn = DisplayGetHDRAPLColumn(*((_QWORD *)v24 + 51));
    v39 = (id)objc_msgSend(*(id *)(a1 + 32), "valueForKey:", *MEMORY[0x1E0D09978]);
    v37 = 0.0;
    v22 = *((_QWORD *)v24 + 51);
    objc_msgSend(v39, "floatValue");
    v37 = DisplayPowerToPhysicalBrightness(v22, HDRAPLColumn, v1);
    v36 = 0;
    v21 = *((float *)v24 + 1026) == -1.0
       || (float)((float)(vabds_f32(v37, *((float *)v24 + 1026)) / *((float *)v24 + 1026)) * 100.0) > *((float *)v24 + 1029);
    v36 = v21;
    if (v37 > *(float *)(*(_QWORD *)(a1 + 48)
                        + 212
                        + 4 * (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 4) - 1))
             * 0.95)
      v36 = 1;
    if ((v36 & 1) != 0
      || v37 == *(float *)(*(_QWORD *)(a1 + 48)
                         + 212
                         + 4 * (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 4) - 1)))
    {
      v42 = v37;
      *((float *)v24 + 1026) = v37;
      v35 = 0;
      if (_logHandle)
      {
        v20 = _logHandle;
      }
      else
      {
        v19 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        v20 = v19;
      }
      v35 = v20;
      v34 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
        objc_msgSend(v39, "floatValue");
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v47, COERCE__INT64(v2), COERCE__INT64(v42));
        _os_log_impl(&dword_1B5291000, v35, v34, "Received an updated CPMS Budget for HDR:%f watts converted to %f nits", v47, 0x16u);
      }
    }
  }
  if (objc_msgSend(*(id *)(a1 + 32), "valueForKey:", *MEMORY[0x1E0D09950]))
  {
    APLColumnOrDefault = 0;
    APLColumnOrDefault = DisplayGetAPLColumnOrDefault(*((_QWORD *)v24 + 51), 0x64u);
    AABC::CancelRamp(v24);
    v39 = (id)objc_msgSend(*(id *)(a1 + 32), "valueForKey:", *MEMORY[0x1E0D09950]);
    v32 = 0.0;
    v18 = *((_QWORD *)v24 + 51);
    objc_msgSend(v39, "floatValue");
    v32 = DisplayPowerToPhysicalBrightness(v18, APLColumnOrDefault, v3);
    v31 = 0;
    v17 = *((float *)v24 + 1024) == -1.0
       || (float)((float)(vabds_f32(v32, *((float *)v24 + 1024)) / *((float *)v24 + 1024)) * 100.0) > *((float *)v24 + 1027);
    v31 = v17;
    if (v32 > *(float *)(*(_QWORD *)(a1 + 48)
                        + 212
                        + 4 * (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 4) - 1))
             * 0.95)
      v31 = 1;
    if ((v31 & 1) != 0
      || v32 == *(float *)(*(_QWORD *)(a1 + 48)
                         + 212
                         + 4 * (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 4) - 1)))
    {
      v41 = v32;
      *((float *)v24 + 1024) = v32;
      if (v41 >= *((float *)v24 + 182))
      {
        *((_DWORD *)v24 + 1020) = *((_DWORD *)v24 + 182);
        *((_BYTE *)v24 + 4084) = 0;
      }
      else
      {
        *((float *)v24 + 1020) = v41;
        *((_BYTE *)v24 + 4084) = 1;
        *((_DWORD *)v24 + 1022) = *((_DWORD *)v24 + 136);
        v30 = 0;
        if (_logHandle)
        {
          v16 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            inited = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            inited = init_default_corebrightness_log();
          v16 = inited;
        }
        v30 = v16;
        v29 = 1;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          v13 = v30;
          v14 = v29;
          __os_log_helper_16_0_0(v28);
          _os_log_impl(&dword_1B5291000, v13, v14, "Enabling weak cap\n", v28, 2u);
        }
      }
      *((_BYTE *)v24 + 4092) = 1;
      if (_logHandle)
      {
        v12 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v11 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v11 = init_default_corebrightness_log();
        v12 = v11;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        objc_msgSend(v39, "floatValue");
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v46, COERCE__INT64(v4), COERCE__INT64(v41));
        _os_log_impl(&dword_1B5291000, v12, OS_LOG_TYPE_INFO, "Received an updated CPMS Budget for UPO:%f watts converted to %f nits", v46, 0x16u);
      }
    }
  }
  if (objc_msgSend(*(id *)(a1 + 32), "valueForKey:", *MEMORY[0x1E0D09980]))
  {
    v27 = DisplayGetAPLColumnOrDefault(*((_QWORD *)v24 + 51), 0x64u);
    v39 = (id)objc_msgSend(*(id *)(a1 + 32), "valueForKey:", *MEMORY[0x1E0D09980]);
    v10 = *((_QWORD *)v24 + 51);
    objc_msgSend(v39, "floatValue");
    v26 = DisplayPowerToPhysicalBrightness(v10, v27, v5);
    v9 = *((float *)v24 + 1025) == -1.0
      || (float)((float)(vabds_f32(v26, *((float *)v24 + 1025)) / *((float *)v24 + 1025)) * 100.0) > *((float *)v24 + 1028);
    v25 = v9;
    if (v26 > *(float *)(*(_QWORD *)(a1 + 48)
                        + 212
                        + 4 * (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 4) - 1))
             * 0.95)
      v25 = 1;
    if ((v25 & 1) != 0
      || v26 == *(float *)(*(_QWORD *)(a1 + 48)
                         + 212
                         + 4 * (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 4) - 1)))
    {
      v40 = v26;
      *((float *)v24 + 1025) = v26;
      if (_logHandle)
      {
        v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v7 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v7 = init_default_corebrightness_log();
        v8 = v7;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        objc_msgSend(v39, "floatValue");
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v45, COERCE__INT64(v6), COERCE__INT64(v40));
        _os_log_impl(&dword_1B5291000, v8, OS_LOG_TYPE_INFO, "Received an updated CPMS Budget for CLTM:%f watts converted to %f nits", v45, 0x16u);
      }
    }
  }
  DisplayUpdateCPMSBudget(*((_QWORD *)v24 + 51), (uint64_t)&v40);

}

void __DisplayUpdateCPMSBudgetInternal(float *a1, float *a2)
{
  double v2;
  float v3;
  NSObject *v4;
  os_log_type_t v5;
  uint64_t v6;
  NSObject *v7;
  float *v8;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v12;
  uint64_t v13;
  BOOL v14;
  float v15;
  float v16;
  float v17;
  uint8_t v18[15];
  char v19;
  NSObject *v20;
  float v21;
  float v22;
  uint8_t v23[7];
  char v24;
  NSObject *v25;
  unsigned int HDRAPLColumn;
  uint64_t v27;
  BOOL v28;
  float v29;
  float v30;
  float v31;
  unsigned int APLColumnOrDefault;
  float v33;
  float *v34;
  float *v35;
  int v36;

  v35 = a1;
  v34 = a2;
  v33 = 0.0;
  if (((_BYTE)a1[3020] & 1) != 0)
    v16 = v35[3018];
  else
    v16 = fminf(v35[3018], v35[3019]);
  v33 = v16;
  APLColumnOrDefault = DisplayGetAPLColumnOrDefault((uint64_t)v35, 0x64u);
  if (v34[1] != -1.0)
  {
    *((_BYTE *)v35 + 12080) = 0;
    v35[3019] = __DisplayPhysicalBrightnessToPowerInternal((uint64_t)v35, APLColumnOrDefault, v34[1]);
    v31 = 0.0;
    v30 = 0.0;
    v30 = v34[1];
    v31 = v30 < v35[132] ? 7.0 : 2.5;
    _DisplaySetBrightnessWeakCapWithFade(v35, 1, v30, v31);
    if (*((_QWORD *)v35 + 2))
    {
      *(float *)&v2 = v34[1];
      (*((void (**)(_QWORD, const __CFString *, uint64_t))v35 + 2))(*((_QWORD *)v35 + 3), CFSTR("CPMS.UPO.Cap"), objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v2));
    }
  }
  if (*v34 != -1.0)
  {
    v35[3018] = __DisplayPhysicalBrightnessToPowerInternal((uint64_t)v35, APLColumnOrDefault, *v34);
    _DisplaySetBrightnessMaxPhysicalWithFade((uint64_t)v35, *v34, 0.0);
    if (*((_QWORD *)v35 + 2))
    {
      *(float *)&v2 = *v34;
      (*((void (**)(_QWORD, const __CFString *, uint64_t))v35 + 2))(*((_QWORD *)v35 + 3), CFSTR("CPMS.CLTM.Cap"), objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v2));
    }
  }
  v29 = 0.0;
  if (((_BYTE)v35[3020] & 1) != 0)
    v15 = v35[3018];
  else
    v15 = fminf(v35[3018], v35[3019]);
  v29 = v15;
  if (*((_QWORD *)v35 + 2))
  {
    v28 = 0;
    v14 = 0;
    if (v35[3018] < v35[3019])
      v14 = *v34 != -1.0;
    v28 = v14;
    v27 = 0;
    if (v14 && *(float *)&__DisplayUpdateCPMSBudgetInternal_prevCap > v29
      || (__DisplayUpdateCPMSBudgetInternal_prevMinWasCLTM & 1) != 0
      && *(float *)&__DisplayUpdateCPMSBudgetInternal_prevCap < v29)
    {
      v13 = *MEMORY[0x1E0C9AE40];
    }
    else
    {
      v13 = *MEMORY[0x1E0C9AE50];
    }
    v27 = v13;
    __DisplayUpdateCPMSBudgetInternal_prevMinWasCLTM = v28;
    __DisplayUpdateCPMSBudgetInternal_prevCap = LODWORD(v29);
    (*((void (**)(_QWORD, const __CFString *, uint64_t))v35 + 2))(*((_QWORD *)v35 + 3), CFSTR("CPMSCurrentCap"), v13);
  }
  if (v34[2] != -1.0 && (*((_BYTE *)v35 + 1517) & 1) != 0)
  {
    HDRAPLColumn = DisplayGetHDRAPLColumn((uint64_t)v35);
    v35[3017] = __DisplayPhysicalBrightnessToPowerInternal((uint64_t)v35, HDRAPLColumn, v34[2]);
    v35[3017] = fmaxf(v35[3017], v29);
    v25 = 0;
    if (_logHandle)
    {
      v12 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v12 = inited;
    }
    v25 = v12;
    v24 = 1;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      log = v25;
      type = v24;
      __os_log_helper_16_0_0(v23);
      _os_log_impl(&dword_1B5291000, log, type, "CPMS:HDR cap changed: Resetting HDR Nit Cap", v23, 2u);
    }
    v35[3026] = v34[2];
    *((_DWORD *)v35 + 64) = (int)(float)(v35[3026] * 65536.0);
    if (v33 >= v29)
    {
      if (((_BYTE)v35[3045] & 1) != 0)
      {
        __DisplaySetHDRFactorWithFade((uint64_t)v35, 0, 0, v35[3026] / v35[416], 1.0);
      }
      else
      {
        v35[3027] = v34[2];
        v22 = _DisplayComputeEDRNitsCap((uint64_t)v35);
        SetLibEDRBrightness((uint64_t)v35, v35[375], v22, v35[298], v35[3132]);
        *((_DWORD *)v35 + 64) = (int)(float)(v35[3027] * 65536.0);
      }
    }
  }
  if ((*((_BYTE *)v35 + 1517) & 1) != 0)
  {
    if (v33 < v29)
    {
      v20 = 0;
      if (_logHandle)
      {
        v7 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v6 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v6 = init_default_corebrightness_log();
        v7 = v6;
      }
      v20 = v7;
      v19 = 1;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        v4 = v20;
        v5 = v19;
        __os_log_helper_16_0_0(v18);
        _os_log_impl(&dword_1B5291000, v4, v5, "CPMS:CLTM/UPO cap raised: Resetting HDR Nit Cap", v18, 2u);
      }
      if (((_BYTE)v35[3045] & 1) != 0)
      {
        v36 = *((_DWORD *)v35 + 3046);
        __DisplaySetHDRFactorWithFade((uint64_t)v35, 0, 0, v35[3026] / v35[416], v35[3046]);
      }
      else
      {
        v35[3027] = v35[3026];
        v17 = _DisplayComputeEDRNitsCap((uint64_t)v35);
        SetLibEDRBrightness((uint64_t)v35, v35[375], v17, v35[298], v35[3132]);
        *((_DWORD *)v35 + 64) = (int)(float)(v35[3027] * 65536.0);
      }
    }
  }
  else
  {
    v21 = 0.0;
    v21 = (float)(((_BYTE)v35[3045] & 1) == 1);
    v8 = v35;
    v3 = DisplayPowerToPhysicalBrightness((uint64_t)v35, APLColumnOrDefault, v29);
    __DisplaySetHDRFactorWithFade((uint64_t)v8, 0, 0, v3 / v35[416], v21);
  }
  if (v34[2] != -1.0)
  {
    if (*((_QWORD *)v35 + 2))
    {
      *(float *)&v2 = v34[2];
      (*((void (**)(_QWORD, const __CFString *, uint64_t))v35 + 2))(*((_QWORD *)v35 + 3), CFSTR("CPMS.HDR.Cap"), objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v2));
    }
  }
}

void __DisplayStartFade(_BYTE *a1, double a2)
{
  double v2;
  double v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  os_log_type_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t inited;
  NSObject *v11;
  uint8_t v12[15];
  os_log_type_t v13;
  os_log_t oslog;
  uint64_t block;
  int v16;
  int v17;
  void (*v18)(uint64_t);
  void *v19;
  void *v20;
  dispatch_block_t v21;
  uint64_t v22;
  os_log_type_t v23;
  os_log_t v24;
  float v25;
  float v26;
  void *v27;
  uint8_t v28[16];
  uint8_t v29[40];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v27 = a1;
  v26 = *(float *)&a2;
  if ((a1[321] & 1) != 0)
  {
    v25 = 1.0 / v26;
    if ((*((_BYTE *)v27 + 322) & 1) != 0 || (a2 = *((double *)v27 + 1576), a2 > 0.0))
    {
      v25 = 120.0;
      LODWORD(a2) = 1123024896;
      objc_msgSend(*((id *)v27 + 26), "setPreferredFramesPerSecond:", a2);
      if ((objc_msgSend(*((id *)v27 + 26), "isPaused") & 1) != 0)
        objc_msgSend(*((id *)v27 + 26), "resume");
      *((float *)v27 + 54) = 1.0 / v25;
    }
    else if ((objc_msgSend(*((id *)v27 + 26), "isPaused") & 1) != 0)
    {
      *(float *)&v2 = v25;
      objc_msgSend(*((id *)v27 + 26), "setPreferredFramesPerSecond:", v2);
      objc_msgSend(*((id *)v27 + 26), "resume");
      *((float *)v27 + 54) = v26;
    }
    else if (v26 < *((float *)v27 + 54))
    {
      v24 = 0;
      if (_logHandle)
      {
        v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v11 = inited;
      }
      v24 = v11;
      v23 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v29, COERCE__INT64(v26), COERCE__INT64(*((float *)v27 + 54)), COERCE__INT64(v25));
        _os_log_impl(&dword_1B5291000, v24, v23, "Requested interval: %fsec is lower than current: %fsec, update CADisplayLink to %fhz", v29, 0x20u);
      }
      *(float *)&v3 = v25;
      objc_msgSend(*((id *)v27 + 26), "setPreferredFramesPerSecond:", v3);
      *((float *)v27 + 54) = v26;
    }
  }
  else
  {
    if (*((_QWORD *)v27 + 1560) && v26 < *((float *)v27 + 3122))
    {
      dispatch_release(*((dispatch_object_t *)v27 + 1560));
      *((_QWORD *)v27 + 1560) = 0;
    }
    if (*((_QWORD *)v27 + 1560))
    {
      if (_logHandle)
      {
        v5 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v4 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v4 = init_default_corebrightness_log();
        v5 = v4;
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_1_8_32((uint64_t)v28, (uint64_t)"void __DisplayStartFade(DisplayRef, float)");
        _os_log_debug_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEBUG, "%s: Reusing current ramp timer\n", v28, 0xCu);
      }
    }
    else
    {
      *((float *)v27 + 3122) = v26;
      *((_QWORD *)v27 + 1560) = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *((dispatch_queue_t *)v27 + 18));
      if (*((_QWORD *)v27 + 1560))
      {
        v22 = 0;
        v22 = (unint64_t)(float)(*((float *)v27 + 3122) * 1000000000.0);
        dispatch_source_set_timer(*((dispatch_source_t *)v27 + 1560), 0, v22, 0);
        if ((*((_BYTE *)v27 + 160) & 1) != 0)
        {
          dispatch_set_context(*((dispatch_object_t *)v27 + 1560), v27);
          dispatch_source_set_event_handler_f(*((dispatch_source_t *)v27 + 1560), (dispatch_function_t)__DisplayFadeCallback);
        }
        else
        {
          v21 = 0;
          block = MEMORY[0x1E0C809B0];
          v16 = -1073741824;
          v17 = 0;
          v18 = ____DisplayStartFade_block_invoke;
          v19 = &__block_descriptor_40_e5_v8__0l;
          v20 = v27;
          v21 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, QOS_CLASS_USER_INITIATED, 0, &block);
          if (v21)
          {
            dispatch_source_set_event_handler(*((dispatch_source_t *)v27 + 1560), v21);
            _Block_release(v21);
          }
        }
        dispatch_resume(*((dispatch_object_t *)v27 + 1560));
      }
      else
      {
        oslog = 0;
        if (_logHandle)
        {
          v9 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v8 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v8 = init_default_corebrightness_log();
          v9 = v8;
        }
        oslog = v9;
        v13 = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          v6 = oslog;
          v7 = v13;
          __os_log_helper_16_0_0(v12);
          _os_log_error_impl(&dword_1B5291000, v6, v7, "Could not create ramp timer\n", v12, 2u);
        }
      }
    }
  }
}

float __DisplaySetHDRFactorWithFade(uint64_t a1, void (*a2)(uint64_t), uint64_t a3, float a4, float a5)
{
  float result;
  double v6;
  double v7;
  float v8;
  float v9;

  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a5 = *(float *)(a1 + 376);
  *(double *)(a1 + 12192) = a5;
  if (*(double *)(a1 + 12192) == 0.0)
  {
    *(float *)(a1 + 12216) = a4;
    *(float *)(a1 + 12208) = a4;
    *(float *)(a1 + 12212) = a4;
    *(float *)(a1 + 12108) = a4 * fmaxf(*(float *)(a1 + 1664), *(float *)(a1 + 1536));
    v9 = _DisplayComputeEDRNitsCap(a1);
    SetLibEDRBrightness(a1, *(float *)(a1 + 1500), v9, *(float *)(a1 + 1192), *(float *)(a1 + 12528));
    if (a2)
      a2(a3);
    result = *(float *)(a1 + 12108) * 65536.0;
    *(_DWORD *)(a1 + 256) = (int)result;
  }
  else
  {
    v8 = *(float *)(a1 + 12108) / fmaxf(*(float *)(a1 + 1664), *(float *)(a1 + 1544));
    if (!float_equal(v8, a4))
    {
      *(_QWORD *)(a1 + 12232) = a2;
      *(_QWORD *)(a1 + 12240) = a3;
      *(CFAbsoluteTime *)(a1 + 12200) = CFAbsoluteTimeGetCurrent();
      v7 = *(float *)(a1 + 12488);
      if (v7 == 0.0)
        v7 = 0.100000001;
      *(float *)(a1 + 12212) = v8;
      *(float *)(a1 + 12216) = v8;
      *(float *)(a1 + 12208) = a4;
      HIDWORD(v6) = HIDWORD(v7);
      *(float *)&v6 = v7;
      __DisplayStartFade((_BYTE *)a1, v6);
    }
  }
  return result;
}

uint64_t AABC::ProcessCPMSBudget(uint64_t a1, void *a2)
{
  id v2;
  NSObject *v3;
  uint64_t block;
  int v7;
  int v8;
  void (*v9)(uint64_t);
  void *v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t CPMSAPLTable;
  id v15;
  uint64_t v16;

  v16 = a1;
  v15 = a2;
  CPMSAPLTable = 0;
  CPMSAPLTable = DisplayGetCPMSAPLTable(*(_QWORD *)(a1 + 408));
  v2 = v15;
  v3 = *(NSObject **)(a1 + 4072);
  block = MEMORY[0x1E0C809B0];
  v7 = -1073741824;
  v8 = 0;
  v9 = ___ZN4AABC17ProcessCPMSBudgetEP12NSDictionaryIP8NSStringP8NSNumberE_block_invoke;
  v10 = &unk_1E68E9FA0;
  v12 = a1;
  v11 = v15;
  v13 = CPMSAPLTable;
  dispatch_async(v3, &block);
  return objc_msgSend(*(id *)(a1 + 4128), "acknowledgePowerBudget:forClientId:error:", v15, objc_msgSend(*(id *)(a1 + 4120), "clientId"), 0);
}

void _DisplaySetRestrictionFactorWithFade(uint64_t a1, char a2, float a3, float a4, float a5, float a6)
{
  double Current;
  uint64_t inited;
  NSObject *v8;
  uint64_t v9;
  char v10;
  char v11;
  unint64_t v15;
  uint8_t v16[24];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v15 = __PAIR64__(LODWORD(a6), LODWORD(a5));
  v11 = a2 & 1;
  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a4 = *(float *)(a1 + 376);
  v10 = 0;
  if (_logHandle)
  {
    v8 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v8 = inited;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v16, COERCE__INT64(a3), COERCE__INT64(a4));
    _os_log_debug_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEBUG, "factor: %f fadePeriod: %f", v16, 0x16u);
  }
  *(_QWORD *)(a1 + 976) = v15;
  if ((v11 & 1) != 0)
    v9 = a1 + 984;
  else
    v9 = a1 + 1056;
  if ((v11 & 1) != 0 && (*(_BYTE *)(a1 + 1048) & 1) != 0 || (v11 & 1) == 0 && (*(_BYTE *)(a1 + 1120) & 1) != 0)
  {
    v10 = 1;
    a4 = 0.0;
  }
  if (a4 == 0.0)
  {
    *(float *)v9 = a3;
    *(float *)(v9 + 28) = a3;
    *(float *)(v9 + 32) = a3;
    *(float *)(v9 + 24) = a3;
    *(_QWORD *)(v9 + 8) = 0;
    if ((v10 & 1) == 0)
      __DisplaySetLogicalBrightnessWithFadeInternal(a1, 12288, 0, 0, *(float *)(a1 + 1252), 0.0);
  }
  else
  {
    *(_QWORD *)(v9 + 48) = 0;
    *(_QWORD *)(v9 + 56) = 0;
    *(double *)(v9 + 8) = a4;
    Current = CFAbsoluteTimeGetCurrent();
    *(double *)(v9 + 16) = Current;
    *(_DWORD *)(v9 + 28) = *(_DWORD *)v9;
    *(_DWORD *)(v9 + 32) = *(_DWORD *)v9;
    *(float *)(v9 + 24) = a3;
    LODWORD(Current) = 1015580809;
    __DisplayStartFade((_BYTE *)a1, Current);
  }
}

void _DisplaySetBrightnessMaxPhysicalWithFade(uint64_t a1, float a2, float a3)
{
  double v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t inited;
  NSObject *v13;
  float UpdateFrequency;
  float v15;
  float v16;
  uint8_t v20[48];
  uint8_t v21[64];
  uint8_t v22[32];
  uint8_t v23[32];
  uint8_t v24[24];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a3 = *(float *)(a1 + 376);
  if (_logHandle)
  {
    v13 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v13 = inited;
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v24, COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_impl(&dword_1B5291000, v13, OS_LOG_TYPE_DEFAULT, "Thermal Brightness Cap: %f fadePeriod: %f", v24, 0x16u);
  }
  *(float *)(a1 + 460) = a2;
  *(float *)(a1 + 456) = _DisplayLogicalToSliderBrightnessInternal(a1, a2);
  *(double *)(a1 + 472) = a3;
  if (a3 == 0.0)
  {
    *(float *)(a1 + 464) = a2;
    if (*(_DWORD *)(a1 + 36))
    {
      _DisplaySetAmbient(a1, 0, *(float *)(a1 + 1184));
    }
    else
    {
      v16 = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
      *(float *)(a1 + 492) = v16;
      *(float *)(a1 + 496) = v16;
      *(float *)(a1 + 488) = v16;
      __DisplaySetLogicalBrightnessInternal((const void *)a1, 12298, *(float *)(a1 + 1256));
      if (_logHandle)
      {
        v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v10 = init_default_corebrightness_log();
        v11 = v10;
      }
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v23, (uint64_t)"Max cap", COERCE__INT64(a2), COERCE__INT64(*(float *)(a1 + 1260)));
        _os_log_impl(&dword_1B5291000, v11, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: Thermal Brightness Cap: %f, nits = %f", v23, 0x20u);
      }
    }
  }
  else
  {
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 512) = 0;
    *(CFAbsoluteTime *)(a1 + 480) = CFAbsoluteTimeGetCurrent();
    if (_logHandle)
    {
      v9 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v8 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v8 = init_default_corebrightness_log();
      v9 = v8;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v22, *(_QWORD *)(a1 + 472), *(_QWORD *)(a1 + 480), *(_QWORD *)(a1 + 12480));
      _os_log_debug_impl(&dword_1B5291000, v9, OS_LOG_TYPE_DEBUG, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v22, 0x20u);
    }
    v15 = (float)(a2 - *(float *)(a1 + 464)) / a3;
    UpdateFrequency = __DisplayGetUpdateFrequency(a1, v15);
    if (_logHandle)
    {
      v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v6 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v6 = init_default_corebrightness_log();
      v7 = v6;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_2_6_8_32_8_0_8_0_8_0_8_0_8_0((uint64_t)v21, (uint64_t)"Max cap", COERCE__INT64(*(float *)(a1 + 464)), COERCE__INT64(a2), COERCE__INT64(a3), COERCE__INT64(v15), COERCE__INT64(UpdateFrequency));
      _os_log_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: MAX begin ramp L: %0.2f -> L: %0.2f t: %f rate: %0.2f nits/s %0.2fhz", v21, 0x3Eu);
    }
    *(float *)(a1 + 492) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 464));
    *(_DWORD *)(a1 + 496) = *(_DWORD *)(a1 + 492);
    *(float *)(a1 + 488) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
    if (_logHandle)
    {
      v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v4 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v4 = init_default_corebrightness_log();
      v5 = v4;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v20, COERCE__INT64(*(float *)(a1 + 464)), COERCE__INT64(a2), COERCE__INT64(*(float *)(a1 + 496)), COERCE__INT64(*(float *)(a1 + 488)));
      _os_log_debug_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEBUG, "display->brightness.restriction.max.Lcurrent=%f L=%f display->brightness.restriction.max.fade.Pstart=%f display->brightness.restriction.max.fade.Ptarget=%f\n", v20, 0x2Au);
    }
    *(float *)&v3 = 1.0 / UpdateFrequency;
    __DisplayStartFade((_BYTE *)a1, v3);
  }
}

void DisplayUpdateCPMSBudget(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  void (*v3)(void);
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  if (*(_QWORD *)(a1 + 144))
  {
    v2 = *(NSObject **)(v11 + 144);
    v3 = (void (*)(void))MEMORY[0x1E0C809B0];
    v4 = -1073741824;
    v5 = 0;
    v6 = __DisplayUpdateCPMSBudget_block_invoke;
    v7 = &__block_descriptor_48_e5_v8__0l;
    v8 = v11;
    v9 = v10;
    disp_dispatch_sync(v2, &v3);
  }
}

uint64_t DisplayStartFastEDRRamp(uint64_t a1, float a2, double a3)
{
  NSObject *v3;
  void (*v5)(void);
  int v6;
  int v7;
  void (*v8)(uint64_t);
  void *v9;
  double v10;
  uint64_t v11;
  float v12;
  double v13;
  float v14;
  uint64_t v15;

  v15 = a1;
  v14 = a2;
  v13 = a3;
  v3 = *(NSObject **)(a1 + 144);
  v5 = (void (*)(void))MEMORY[0x1E0C809B0];
  v6 = -1073741824;
  v7 = 0;
  v8 = __DisplayStartFastEDRRamp_block_invoke;
  v9 = &__block_descriptor_52_e5_v8__0l;
  v10 = a3;
  v11 = v15;
  v12 = a2;
  disp_dispatch_sync(v3, &v5);
  return 1;
}

void DisplaySetRestrictionFactorWithFade(uint64_t a1, char a2, float a3, float a4, float a5, float a6)
{
  NSObject *v6;
  void (*v7)(void);
  int v8;
  int v9;
  void (*v10)(uint64_t);
  void *v11;
  uint64_t v12;
  float v13;
  float v14;
  unint64_t v15;
  char v16;
  char v17;
  float v18;
  float v19;
  uint64_t v20;
  unint64_t v21;

  v21 = __PAIR64__(LODWORD(a6), LODWORD(a5));
  v20 = a1;
  v19 = a3;
  v18 = a4;
  v17 = a2 & 1;
  v6 = *(NSObject **)(a1 + 144);
  v7 = (void (*)(void))MEMORY[0x1E0C809B0];
  v8 = -1073741824;
  v9 = 0;
  v10 = __DisplaySetRestrictionFactorWithFade_block_invoke;
  v11 = &__block_descriptor_57_e5_v8__0l;
  v12 = v20;
  v13 = a3;
  v14 = a4;
  v16 = a2 & 1;
  v15 = __PAIR64__(LODWORD(a6), LODWORD(a5));
  disp_dispatch_sync(v6, &v7);
}

uint64_t DisplayGetCPMSAPLTable(uint64_t a1)
{
  return __DisplayGetCPMSAPLTableInternal(a1);
}

double CFXUpdateCompensatedBacklight(uint64_t a1, float a2)
{
  uint64_t v2;
  double v3;

  v2 = mach_absolute_time();
  *(float *)&v3 = a2;
  return _CFXUpdateCompensatedBacklight(a1, v2, v3);
}

void *createCustomCurve@<X0>(const float *a1@<X0>, const float *a2@<X1>, unsigned int a3@<W2>, _DWORD *a4@<X8>)
{
  void *result;

  if (a3 >= 0x7FFFFFFF)
    __assert_rtn("createCustomCurve", "CBSoftWake.mm", 19, "size < INT_MAX");
  if (a3 >= 0x14)
    __assert_rtn("createCustomCurve", "CBSoftWake.mm", 20, "size < 20");
  memcpy(a4, a1, 4 * a3);
  result = memcpy(a4 + 20, a2, 4 * a3);
  a4[40] = a3;
  return result;
}

uint64_t canTransition(uint64_t a1, uint64_t a2)
{
  BOOL v3;
  char v4;

  if (a1 || (v4 = 1, a2 != 1))
  {
    v3 = 0;
    if (a1 == 1)
      v3 = a2 == 0;
    v4 = v3;
  }
  return v4 & 1;
}

void *dumpCArrayIntoDictionary(unint64_t a1, uint64_t a2)
{
  unint64_t i;
  void *v4;

  v4 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionaryWithCapacity:", a1);
  for (i = 0; i < a1; ++i)
    objc_msgSend(v4, "setObject:forKey:", (*(uint64_t (**)(uint64_t, unint64_t))(a2 + 16))(a2, i), objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%tu"), i));
  return v4;
}

uint64_t __os_log_helper_16_2_11_8_32_8_32_4_0_4_0_4_0_4_0_8_0_8_0_8_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 11;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 32;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 4;
  *(_DWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 35) = 4;
  *(_DWORD *)(result + 36) = a6;
  *(_BYTE *)(result + 40) = 0;
  *(_BYTE *)(result + 41) = 4;
  *(_DWORD *)(result + 42) = a7;
  *(_BYTE *)(result + 46) = 0;
  *(_BYTE *)(result + 47) = 8;
  *(_QWORD *)(result + 48) = a8;
  *(_BYTE *)(result + 56) = 0;
  *(_BYTE *)(result + 57) = 8;
  *(_QWORD *)(result + 58) = a9;
  *(_BYTE *)(result + 66) = 0;
  *(_BYTE *)(result + 67) = 8;
  *(_QWORD *)(result + 68) = a10;
  *(_BYTE *)(result + 76) = 0;
  *(_BYTE *)(result + 77) = 8;
  *(_QWORD *)(result + 78) = a11;
  *(_BYTE *)(result + 86) = 0;
  *(_BYTE *)(result + 87) = 4;
  *(_DWORD *)(result + 88) = a12;
  return result;
}

uint64_t __os_log_helper_16_2_6_8_32_8_32_4_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 6;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 32;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 49) = 8;
  *(_QWORD *)(result + 50) = a7;
  return result;
}

float std::__math::fabs[abi:ne180100](float a1)
{
  return fabsf(a1);
}

double std::__math::fmax[abi:ne180100]<int,float,0>(int a1, float a2)
{
  return std::__math::fmax[abi:ne180100]<int>((double)a1, a2);
}

float std::__math::fmax[abi:ne180100](float a1, float a2)
{
  return fmaxf(a1, a2);
}

float std::__math::fmin[abi:ne180100](float a1, float a2)
{
  return fminf(a1, a2);
}

uint64_t __os_log_helper_16_2_2_8_32_4_0(uint64_t result, uint64_t a2, int a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  return result;
}

double std::__math::fmin[abi:ne180100]<int,unsigned int,0>(int a1, int a2, double a3, double a4)
{
  LODWORD(a4) = a2;
  return std::__math::fmin[abi:ne180100]<int>((double)a1, (double)*(unint64_t *)&a4);
}

void sub_1B52FE730()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

_QWORD *std::valarray<float>::valarray(_QWORD *a1, float *a2, unint64_t a3)
{
  std::valarray<float>::valarray(a1, a2, a3);
  return a1;
}

{
  *a1 = 0;
  a1[1] = 0;
  std::valarray<float>::resize(a1, a3, *a2);
  return a1;
}

_QWORD *std::valarray<float>::~valarray(_QWORD *a1)
{
  std::valarray<float>::~valarray(a1);
  return a1;
}

{
  uint64_t v3;

  v3 = std::valarray<float>::size[abi:ne180100](a1);
  std::valarray<float>::__clear((uint64_t)a1, v3);
  return a1;
}

_QWORD *std::valarray<float>::valarray(_QWORD *a1, unint64_t a2)
{
  std::valarray<float>::valarray(a1, a2);
  return a1;
}

{
  void *v2;
  unint64_t i;
  char v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;

  v8 = a1;
  v7 = a2;
  v9 = a1;
  *a1 = 0;
  a1[1] = 0;
  if (v7)
  {
    std::allocator<float>::allocator[abi:ne180100]((uint64_t)&v6);
    v2 = std::allocator<float>::allocate[abi:ne180100]((uint64_t)&v6, v7);
    a1[1] = v2;
    *a1 = v2;
    for (i = v7; i; --i)
    {
      *(_DWORD *)a1[1] = 0;
      a1[1] += 4;
    }
  }
  return v9;
}

uint64_t std::valarray<float>::size[abi:ne180100](_QWORD *a1)
{
  return (a1[1] - *a1) / 4;
}

uint64_t std::valarray<float>::operator[][abi:ne180100](_QWORD *a1, uint64_t a2)
{
  return *a1 + 4 * a2;
}

{
  return *a1 + 4 * a2;
}

uint64_t std::operator/[abi:ne180100]<std::valarray<float>,0>@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  __n128 v8;
  char v9;
  __n128 v10[2];
  uint64_t v11;
  _QWORD *v12;

  v12 = a1;
  v11 = a2;
  v3 = std::valarray<float>::size[abi:ne180100](a1);
  std::__scalar_expr<float>::__scalar_expr[abi:ne180100](&v8, a2, v3);
  std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100](v10, (uint64_t)&v9, (unint64_t)a1, &v8);
  return std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::__val_expr[abi:ne180100](a3, (uint64_t)v10);
}

float **std::valarray<float>::operator=<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>(float **a1, uint64_t a2)
{
  uint64_t i;
  float *v5;
  unint64_t v6;

  v6 = std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::size[abi:ne180100](a2);
  if (std::valarray<float>::size[abi:ne180100](a1) != v6)
    std::valarray<float>::resize(a1, v6, 0.0);
  v5 = *a1;
  for (i = 0; i != v6; ++i)
    *v5++ = std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::operator[][abi:ne180100](a2, i);
  return a1;
}

void *std::operator/[abi:ne180100]<std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,0>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v3;
  __n128 v8;
  char v9;
  _BYTE v10[48];
  uint64_t v11;
  uint64_t v12;

  v12 = a1;
  v11 = a2;
  v3 = std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::size[abi:ne180100](a1);
  std::__scalar_expr<float>::__scalar_expr[abi:ne180100](&v8, a2, v3);
  std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100]((uint64_t)v10, (uint64_t)&v9, a1, &v8);
  return std::__val_expr<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>::__val_expr[abi:ne180100](a3, v10);
}

__n128 *std::operator-[abi:ne180100]<std::valarray<float>,std::valarray<float>,0>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __n128 *a3@<X8>)
{
  char v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = a1;
  v7 = a2;
  std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100]((uint64_t)&v6, (uint64_t)&v5, a1, a2);
  return std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](a3, &v6);
}

float **std::valarray<float>::operator=<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>(float **a1, uint64_t a2)
{
  uint64_t i;
  float *v5;
  unint64_t v6;

  v6 = std::__val_expr<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>::size[abi:ne180100](a2);
  if (std::valarray<float>::size[abi:ne180100](a1) != v6)
    std::valarray<float>::resize(a1, v6, 0.0);
  v5 = *a1;
  for (i = 0; i != v6; ++i)
    *v5++ = std::__val_expr<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>::operator[][abi:ne180100](a2, i);
  return a1;
}

_DWORD *std::min[abi:ne180100]<int>(_DWORD *a1, _DWORD *a2)
{
  return std::min[abi:ne180100]<int,std::__less<void,void>>(a1, a2);
}

_DWORD *std::max[abi:ne180100]<int>(_DWORD *a1, _DWORD *a2)
{
  return std::max[abi:ne180100]<int,std::__less<void,void>>(a1, a2);
}

_QWORD *std::valarray<float>::valarray(_QWORD *a1, _DWORD *a2, unint64_t a3)
{
  std::valarray<float>::valarray(a1, a2, a3);
  return a1;
}

{
  void *v3;
  unint64_t i;
  char v7;
  unint64_t v8;
  _DWORD *v9;
  _QWORD *v10;
  _QWORD *v11;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v11 = a1;
  *a1 = 0;
  a1[1] = 0;
  if (v8)
  {
    std::allocator<float>::allocator[abi:ne180100]((uint64_t)&v7);
    v3 = std::allocator<float>::allocate[abi:ne180100]((uint64_t)&v7, v8);
    a1[1] = v3;
    *a1 = v3;
    for (i = v8; i; --i)
    {
      *(_DWORD *)a1[1] = *v9;
      a1[1] += 4;
      ++v9;
    }
  }
  return v11;
}

__n128 *std::operator>[abi:ne180100]<std::valarray<float>,std::valarray<float>,0>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __n128 *a3@<X8>)
{
  char v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = a1;
  v7 = a2;
  std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100]((uint64_t)&v6, (uint64_t)&v5, a1, a2);
  return std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](a3, &v6);
}

BOOL std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::max[abi:ne180100](uint64_t a1)
{
  BOOL v2;
  BOOL v4;
  unint64_t i;
  BOOL v6;
  unint64_t v7;

  v7 = std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::size[abi:ne180100](a1);
  if (v7)
    v2 = std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::operator[][abi:ne180100](a1, 0);
  else
    v2 = 0;
  v6 = v2;
  for (i = 1; i < v7; ++i)
  {
    v4 = std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::operator[][abi:ne180100](a1, i);
    if (v6 < v4)
      v6 = v4;
  }
  return v6;
}

uint64_t __os_log_helper_16_0_12_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 12;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 62) = 0;
  *(_BYTE *)(result + 63) = 8;
  *(_QWORD *)(result + 64) = a8;
  *(_BYTE *)(result + 72) = 0;
  *(_BYTE *)(result + 73) = 8;
  *(_QWORD *)(result + 74) = a9;
  *(_BYTE *)(result + 82) = 0;
  *(_BYTE *)(result + 83) = 8;
  *(_QWORD *)(result + 84) = a10;
  *(_BYTE *)(result + 92) = 0;
  *(_BYTE *)(result + 93) = 8;
  *(_QWORD *)(result + 94) = a11;
  *(_BYTE *)(result + 102) = 0;
  *(_BYTE *)(result + 103) = 8;
  *(_QWORD *)(result + 104) = a12;
  *(_BYTE *)(result + 112) = 0;
  *(_BYTE *)(result + 113) = 8;
  *(_QWORD *)(result + 114) = a13;
  return result;
}

uint64_t *std::valarray<float>::operator=(uint64_t *a1, uint64_t *a2)
{
  if (a1 == a2)
    return a1;
  else
    return std::valarray<float>::__assign_range(a1, (_DWORD *)*a2, (_DWORD *)a2[1]);
}

CoreBrightness::MitigationState *CoreBrightness::MitigationState::MitigationState(CoreBrightness::MitigationState *this)
{
  CoreBrightness::MitigationState::MitigationState(this);
  return this;
}

double CoreBrightness::MitigationState::MitigationState(CoreBrightness::MitigationState *this)
{
  double result;

  *(_DWORD *)this = 0;
  *((_BYTE *)this + 4) = 0;
  *((_DWORD *)this + 2) = 5;
  *((_DWORD *)this + 3) = 60;
  *((_DWORD *)this + 4) = 5;
  *((_DWORD *)this + 5) = 3;
  *((float *)this + 6) = 4.0;
  *((float *)this + 7) = 3.0;
  *((float *)this + 8) = 3.0;
  *((_DWORD *)this + 9) = 15;
  *((_DWORD *)this + 10) = 3;
  *((_DWORD *)this + 11) = *((_DWORD *)this + 9);
  *((_DWORD *)this + 12) = *((_DWORD *)this + 10);
  result = 0.0;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 26) = 0;
  return result;
}

double std::__math::fmax[abi:ne180100]<int>(double a1, double a2)
{
  return fmax(a1, a2);
}

double std::__math::fmin[abi:ne180100]<int>(double a1, double a2)
{
  return fmin(a1, a2);
}

void std::valarray<float>::resize(_QWORD *a1, unint64_t a2, float a3)
{
  uint64_t v3;
  void *v4;
  unint64_t i;
  char v7;
  float v8;
  unint64_t v9;
  _QWORD *v10;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v3 = std::valarray<float>::size[abi:ne180100](a1);
  std::valarray<float>::__clear((uint64_t)a1, v3);
  if (v9)
  {
    std::allocator<float>::allocator[abi:ne180100]((uint64_t)&v7);
    v4 = std::allocator<float>::allocate[abi:ne180100]((uint64_t)&v7, v9);
    a1[1] = v4;
    *a1 = v4;
    for (i = v9; i; --i)
    {
      *(float *)a1[1] = v8;
      a1[1] += 4;
    }
  }
}

void std::valarray<float>::__clear(uint64_t a1, uint64_t a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;

  v5 = a1;
  v4 = a2;
  if (*(_QWORD *)a1)
  {
    while (*(_QWORD *)(a1 + 8) != *(_QWORD *)a1)
      *(_QWORD *)(a1 + 8) -= 4;
    std::allocator<float>::allocator[abi:ne180100]((uint64_t)&v3);
    std::allocator<float>::deallocate[abi:ne180100]((uint64_t)&v3, *(void **)a1);
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = 0;
  }
}

uint64_t std::allocator<float>::allocator[abi:ne180100](uint64_t a1)
{
  std::allocator<float>::allocator[abi:ne180100](a1);
  return a1;
}

{
  std::__non_trivial_if<true>::__non_trivial_if[abi:ne180100]();
  return a1;
}

void *std::allocator<float>::allocate[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 > std::allocator_traits<std::allocator<float>>::max_size[abi:ne180100]<std::allocator<float>,void>())
    std::__throw_bad_array_new_length[abi:ne180100]();
  return std::__libcpp_allocate[abi:ne180100](4 * a2);
}

void std::allocator<float>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
  std::__libcpp_deallocate[abi:ne180100](a2);
}

void std::__libcpp_deallocate[abi:ne180100](void *a1)
{
  std::__do_deallocate_handle_size[abi:ne180100]<>(a1);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void std::__do_deallocate_handle_size[abi:ne180100]<>(void *a1)
{
  std::__libcpp_operator_delete[abi:ne180100]<void *>(a1);
}

void std::__libcpp_operator_delete[abi:ne180100]<void *>(void *a1)
{
  operator delete(a1);
}

uint64_t std::allocator_traits<std::allocator<float>>::max_size[abi:ne180100]<std::allocator<float>,void>()
{
  return std::allocator<float>::max_size[abi:ne180100]();
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(exception, MEMORY[0x1E0DE4E98], MEMORY[0x1E0DE4390]);
}

void *std::__libcpp_allocate[abi:ne180100](size_t a1)
{
  return std::__libcpp_operator_new[abi:ne180100]<unsigned long>(a1);
}

uint64_t std::allocator<float>::max_size[abi:ne180100]()
{
  return 0x3FFFFFFFFFFFFFFFLL;
}

void *std::__libcpp_operator_new[abi:ne180100]<unsigned long>(size_t a1)
{
  return operator new(a1);
}

_QWORD *std::__scalar_expr<float>::__scalar_expr[abi:ne180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  std::__scalar_expr<float>::__scalar_expr[abi:ne180100](a1, a2, a3);
  return a1;
}

__n128 *std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100](__n128 *a1, uint64_t a2, unint64_t a3, __n128 *a4)
{
  std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100](a1, a2, a3, a4);
  return a1;
}

uint64_t std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::__val_expr[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::__val_expr[abi:ne180100](a1, a2);
  return a1;
}

_QWORD *std::__scalar_expr<float>::__scalar_expr[abi:ne180100](_QWORD *result, uint64_t a2, uint64_t a3)
{
  *result = a2;
  result[1] = a3;
  return result;
}

__n128 std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100](__n128 *a1, uint64_t a2, unint64_t a3, __n128 *a4)
{
  __n128 result;

  a1->n128_u64[1] = a3;
  result = *a4;
  a1[1] = *a4;
  return result;
}

__n128 std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::__val_expr[abi:ne180100](uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  result = *(__n128 *)(a2 + 16);
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::size[abi:ne180100](uint64_t a1)
{
  return std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::size[abi:ne180100](a1);
}

float std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::operator[][abi:ne180100](a1, a2);
}

uint64_t std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::size[abi:ne180100](uint64_t a1)
{
  return std::valarray<float>::size[abi:ne180100](*(_QWORD **)(a1 + 8));
}

float std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  float *v2;
  float *v4;

  v4 = (float *)std::valarray<float>::operator[][abi:ne180100](*(_QWORD **)(a1 + 8), a2);
  v2 = (float *)std::__scalar_expr<float>::operator[][abi:ne180100](a1 + 16);
  return std::divides<float>::operator()[abi:ne180100](a1, v4, v2);
}

float std::divides<float>::operator()[abi:ne180100](uint64_t a1, float *a2, float *a3)
{
  return *a2 / *a3;
}

uint64_t std::__scalar_expr<float>::operator[][abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100](a1, a2, a3, a4);
  return a1;
}

__n128 *std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](__n128 *a1, __n128 *a2)
{
  std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](a1, a2);
  return a1;
}

uint64_t std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100](uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_QWORD *)(result + 8) = a3;
  *(_QWORD *)(result + 16) = a4;
  return result;
}

__n128 std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  return result;
}

uint64_t std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::size[abi:ne180100](uint64_t a1)
{
  return std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::size[abi:ne180100](a1);
}

uint64_t std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4)
{
  std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100](a1, a2, a3, a4);
  return a1;
}

void *std::__val_expr<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>::__val_expr[abi:ne180100](void *a1, const void *a2)
{
  std::__val_expr<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>::__val_expr[abi:ne180100](a1, a2);
  return a1;
}

{
  memcpy(a1, a2, 0x30uLL);
  return a1;
}

uint64_t std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::size[abi:ne180100](uint64_t a1)
{
  return std::valarray<float>::size[abi:ne180100](*(_QWORD **)(a1 + 8));
}

__n128 std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4)
{
  __n128 result;

  *(_OWORD *)(a1 + 8) = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a3 + 16);
  result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  return result;
}

uint64_t std::__val_expr<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>::size[abi:ne180100](uint64_t a1)
{
  return std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::size[abi:ne180100](a1);
}

float std::__val_expr<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::operator[][abi:ne180100](a1, a2);
}

uint64_t std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::size[abi:ne180100](uint64_t a1)
{
  return std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::size[abi:ne180100](a1 + 8);
}

float std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  float *v2;
  float v5;
  uint64_t v6;
  uint64_t v7;

  v7 = a1;
  v6 = a2;
  v5 = std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::operator[][abi:ne180100](a1 + 8, a2);
  v2 = (float *)std::__scalar_expr<float>::operator[][abi:ne180100](a1 + 32);
  return std::divides<float>::operator()[abi:ne180100](a1, &v5, v2);
}

float std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::operator[][abi:ne180100](a1, a2);
}

float std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  float *v2;
  float *v4;

  v4 = (float *)std::valarray<float>::operator[][abi:ne180100](*(_QWORD **)(a1 + 8), a2);
  v2 = (float *)std::valarray<float>::operator[][abi:ne180100](*(_QWORD **)(a1 + 16), a2);
  return std::minus<float>::operator()[abi:ne180100](a1, v4, v2);
}

float std::minus<float>::operator()[abi:ne180100](uint64_t a1, float *a2, float *a3)
{
  return *a2 - *a3;
}

_DWORD *std::max[abi:ne180100]<int,std::__less<void,void>>(_DWORD *a1, _DWORD *a2)
{
  char v6;

  if (std::__less<void,void>::operator()[abi:ne180100]<int,int>((uint64_t)&v6, a1, a2))
    return a2;
  else
    return a1;
}

BOOL std::__less<void,void>::operator()[abi:ne180100]<int,int>(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return *a2 < *a3;
}

_DWORD *std::min[abi:ne180100]<int,std::__less<void,void>>(_DWORD *a1, _DWORD *a2)
{
  char v6;

  if (std::__less<void,void>::operator()[abi:ne180100]<int,int>((uint64_t)&v6, a2, a1))
    return a2;
  else
    return a1;
}

uint64_t std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100](a1, a2, a3, a4);
  return a1;
}

__n128 *std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](__n128 *a1, __n128 *a2)
{
  std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](a1, a2);
  return a1;
}

uint64_t std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100](uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_QWORD *)(result + 8) = a3;
  *(_QWORD *)(result + 16) = a4;
  return result;
}

__n128 std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  return result;
}

uint64_t std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::size[abi:ne180100](uint64_t a1)
{
  return std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::size[abi:ne180100](a1);
}

BOOL std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::operator[][abi:ne180100](a1, a2);
}

BOOL std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  float *v2;
  float *v4;

  v4 = (float *)std::valarray<float>::operator[][abi:ne180100](*(_QWORD **)(a1 + 8), a2);
  v2 = (float *)std::valarray<float>::operator[][abi:ne180100](*(_QWORD **)(a1 + 16), a2);
  return std::greater<float>::operator()[abi:ne180100](a1, v4, v2);
}

uint64_t std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::size[abi:ne180100](uint64_t a1)
{
  return std::valarray<float>::size[abi:ne180100](*(_QWORD **)(a1 + 8));
}

BOOL std::greater<float>::operator()[abi:ne180100](uint64_t a1, float *a2, float *a3)
{
  return *a2 > *a3;
}

uint64_t *std::valarray<float>::__assign_range(uint64_t *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v3;
  char v6;
  unint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  uint64_t *v10;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v7 = a3 - a2;
  if (std::valarray<float>::size[abi:ne180100](a1) == v7)
  {
    std::copy[abi:ne180100]<float const*,float *>((uint64_t)v9, (uint64_t)v8, *a1);
  }
  else
  {
    v3 = std::valarray<float>::size[abi:ne180100](a1);
    std::valarray<float>::__clear((uint64_t)a1, v3);
    std::allocator<float>::allocator[abi:ne180100]((uint64_t)&v6);
    *a1 = (uint64_t)std::allocator<float>::allocate[abi:ne180100]((uint64_t)&v6, v7);
    a1[1] = *a1 + 4 * v7;
    std::uninitialized_copy[abi:ne180100]<float const*,float *>(v9, v8, *a1);
  }
  return a1;
}

uint64_t std::uninitialized_copy[abi:ne180100]<float const*,float *>(_DWORD *a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v3;

  std::__uninitialized_copy[abi:ne180100]<float,float const*,float const*,float *,std::__always_false>(a1, a2, a3);
  return v3;
}

uint64_t std::copy[abi:ne180100]<float const*,float *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,float const*,float const*,float *>(a1, a2, a3);
  return v3;
}

uint64_t std::__uninitialized_copy[abi:ne180100]<float,float const*,float const*,float *,std::__always_false>(_DWORD *a1, _DWORD *a2, uint64_t a3)
{
  int v4;
  _QWORD v5[2];
  _DWORD *v6;
  _DWORD *v7;
  _QWORD v8[3];

  v7 = a1;
  v6 = a2;
  v5[1] = a3;
  for (v5[0] = a3; ; v5[0] += 4)
  {
    LOBYTE(v4) = 0;
    if (v7 != v6)
      v4 = std::__always_false::operator()[abi:ne180100]<float *&>() ^ 1;
    if ((v4 & 1) == 0)
      break;
    v8[2] = v5[0];
    *(_DWORD *)v5[0] = *v7++;
  }
  std::pair<float const*,float *>::pair[abi:ne180100]<float const*,float *,0>(v8, &v7, v5);
  return v8[0];
}

uint64_t std::__always_false::operator()[abi:ne180100]<float *&>()
{
  return 0;
}

uint64_t std::__destroy[abi:ne180100]<float *>(uint64_t a1, uint64_t a2)
{
  while (a1 != a2)
  {
    std::__destroy_at[abi:ne180100]<float,0>();
    a1 += 4;
  }
  return a1;
}

_QWORD *std::pair<float const*,float *>::pair[abi:ne180100]<float const*,float *,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  std::pair<float const*,float *>::pair[abi:ne180100]<float const*,float *,0>(a1, a2, a3);
  return a1;
}

_QWORD *std::pair<float const*,float *>::pair[abi:ne180100]<float const*,float *,0>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

uint64_t std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,float const*,float const*,float *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,float const*,float const*,float *>(a1, a2, a3);
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,float const*,float const*,float *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,float const*,float const*,float *,0>(a1, a2, a3);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,float const*,float const*,float *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v13 = (const void *)std::__unwrap_range[abi:ne180100]<float const*,float const*>(a1, a2);
  v14 = v3;
  v7 = v3;
  std::__unwrap_iter[abi:ne180100]<float *,std::__unwrap_iter_impl<float *,true>,0>();
  v11 = std::__copy_trivial::operator()[abi:ne180100]<float const,float,0>((uint64_t)&v10, v13, v7, v4);
  v12 = v5;
  v9 = std::__rewrap_range[abi:ne180100]<float const*,float const*>(v17, v11);
  v8 = std::__rewrap_iter[abi:ne180100]<float *,float *,std::__unwrap_iter_impl<float *,true>>(v15, v12);
  return std::make_pair[abi:ne180100]<float const*,float *>(&v9, &v8);
}

uint64_t std::__unwrap_range[abi:ne180100]<float const*,float const*>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  _QWORD v6[3];

  v6[2] = a1;
  v6[1] = a2;
  std::__unwrap_iter[abi:ne180100]<float const*,std::__unwrap_iter_impl<float const*,true>,0>();
  v6[0] = v2;
  std::__unwrap_iter[abi:ne180100]<float const*,std::__unwrap_iter_impl<float const*,true>,0>();
  v5 = v3;
  return std::make_pair[abi:ne180100]<float const*,float const*>(v6, &v5);
}

uint64_t std::__copy_trivial::operator()[abi:ne180100]<float const,float,0>(uint64_t a1, const void *a2, uint64_t a3, char *a4)
{
  return std::__copy_trivial_impl[abi:ne180100]<float const,float>(a2, a3, a4);
}

void std::__unwrap_iter[abi:ne180100]<float *,std::__unwrap_iter_impl<float *,true>,0>()
{
  std::__unwrap_iter_impl<float *,true>::__unwrap[abi:ne180100]();
}

uint64_t std::make_pair[abi:ne180100]<float const*,float *>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  std::pair<float const*,float *>::pair[abi:ne180100]<float const*,float *,0>(&v3, a1, a2);
  return v3;
}

uint64_t std::__rewrap_range[abi:ne180100]<float const*,float const*>(uint64_t a1, uint64_t a2)
{
  return std::__rewrap_iter[abi:ne180100]<float const*,float const*,std::__unwrap_iter_impl<float const*,true>>(a1, a2);
}

uint64_t std::__rewrap_iter[abi:ne180100]<float *,float *,std::__unwrap_iter_impl<float *,true>>(uint64_t a1, uint64_t a2)
{
  return std::__unwrap_iter_impl<float *,true>::__rewrap[abi:ne180100](a1, a2);
}

uint64_t std::make_pair[abi:ne180100]<float const*,float const*>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  std::pair<float const*,float const*>::pair[abi:ne180100]<float const*,float const*,0>(&v3, a1, a2);
  return v3;
}

void std::__unwrap_iter[abi:ne180100]<float const*,std::__unwrap_iter_impl<float const*,true>,0>()
{
  std::__unwrap_iter_impl<float const*,true>::__unwrap[abi:ne180100]();
}

_QWORD *std::pair<float const*,float const*>::pair[abi:ne180100]<float const*,float const*,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  std::pair<float const*,float const*>::pair[abi:ne180100]<float const*,float const*,0>(a1, a2, a3);
  return a1;
}

_QWORD *std::pair<float const*,float const*>::pair[abi:ne180100]<float const*,float const*,0>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

void std::__unwrap_iter_impl<float const*,true>::__unwrap[abi:ne180100]()
{
  std::__to_address[abi:ne180100]<float const>();
}

uint64_t std::__copy_trivial_impl[abi:ne180100]<float const,float>(const void *a1, uint64_t a2, char *a3)
{
  char *v4;
  uint64_t v5;
  char *v6;
  _QWORD v7[2];

  v7[1] = a1;
  v7[0] = a2;
  v6 = a3;
  v5 = (a2 - (uint64_t)a1) / 4;
  std::__constexpr_memmove[abi:ne180100]<float,float const,0>(a3, a1, v5);
  v4 = &v6[4 * v5];
  return std::make_pair[abi:ne180100]<float const*&,float *>(v7, &v4);
}

void *std::__constexpr_memmove[abi:ne180100]<float,float const,0>(void *a1, const void *a2, uint64_t a3)
{
  if (a3)
    memmove(a1, a2, 4 * (a3 - 1) + 4);
  return a1;
}

uint64_t std::make_pair[abi:ne180100]<float const*&,float *>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  std::pair<float const*,float *>::pair[abi:ne180100]<float const*&,float *,0>(&v3, a1, a2);
  return v3;
}

_QWORD *std::pair<float const*,float *>::pair[abi:ne180100]<float const*&,float *,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  std::pair<float const*,float *>::pair[abi:ne180100]<float const*&,float *,0>(a1, a2, a3);
  return a1;
}

_QWORD *std::pair<float const*,float *>::pair[abi:ne180100]<float const*&,float *,0>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

void std::__unwrap_iter_impl<float *,true>::__unwrap[abi:ne180100]()
{
  std::__to_address[abi:ne180100]<float>();
}

uint64_t std::__rewrap_iter[abi:ne180100]<float const*,float const*,std::__unwrap_iter_impl<float const*,true>>(uint64_t a1, uint64_t a2)
{
  return std::__unwrap_iter_impl<float const*,true>::__rewrap[abi:ne180100](a1, a2);
}

uint64_t std::__unwrap_iter_impl<float const*,true>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  std::__to_address[abi:ne180100]<float const>();
  return a1 + 4 * ((a2 - v2) / 4);
}

uint64_t std::__unwrap_iter_impl<float *,true>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  std::__to_address[abi:ne180100]<float>();
  return a1 + 4 * ((a2 - v2) / 4);
}

id getMLModelClass()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLModelClass_softClass;
  v13 = getMLModelClass_softClass;
  if (!getMLModelClass_softClass)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLModelClass_block_invoke;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLModelClass_block_invoke((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

id getMLArrayBatchProviderClass()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLArrayBatchProviderClass_softClass;
  v13 = getMLArrayBatchProviderClass_softClass;
  if (!getMLArrayBatchProviderClass_softClass)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLArrayBatchProviderClass_block_invoke;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLArrayBatchProviderClass_block_invoke((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

uint64_t __getMLFeatureValueClass_block_invoke(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary();
  Class = objc_getClass("MLFeatureValue");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLFeatureValueClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CoreMLLibrary()
{
  uint64_t v1;

  v1 = CoreMLLibraryCore();
  if (!v1)
    abort_report_np();
  return v1;
}

uint64_t CoreMLLibraryCore()
{
  if (!CoreMLLibraryCore_frameworkLibrary)
    __CoreMLLibraryCore_block_invoke();
  return CoreMLLibraryCore_frameworkLibrary;
}

uint64_t __getMLModelClass_block_invoke(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary();
  Class = objc_getClass("MLModel");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLModelClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLPredictionOptionsClass_block_invoke(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary();
  Class = objc_getClass("MLPredictionOptions");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLPredictionOptionsClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLArrayBatchProviderClass_block_invoke(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary();
  Class = objc_getClass("MLArrayBatchProvider");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLArrayBatchProviderClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

BOOL isBrightnessAdjustmentPossible(NSDictionary *a1)
{
  float v1;
  float v2;
  float v4;

  objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a1, "objectForKeyedSubscript:", CFSTR("MinNits")), "floatValue");
  v4 = v1;
  objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a1, "objectForKeyedSubscript:", CFSTR("MaxNits")), "floatValue");
  return vabds_f32(v4, v2) > 0.5;
}

uint64_t __os_log_helper_16_2_2_8_32_8_32(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 32;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  return result;
}

void sub_1B5308B88()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_5_8_32_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 5;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  return result;
}

uint64_t __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 5;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  return result;
}

uint64_t std::__math::isnan[abi:ne180100]()
{
  return 0;
}

void sub_1B530B3E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 56), 8);
  _Unwind_Resume(a1);
}

void sub_1B530B56C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 56), 8);
  _Unwind_Resume(a1);
}

void sub_1B530BC60()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void sub_1B530BE50(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj)
{
  uint64_t v9;

  *(_QWORD *)(v9 - 32) = a1;
  *(_DWORD *)(v9 - 36) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v9 - 32));
}

uint64_t __os_log_helper_16_2_4_8_32_8_32_8_32_8_64(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 32;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 32;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 64;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_32_8_64(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 64;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_32_8_32_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 32;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 32;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

uint64_t __os_log_helper_16_0_2_4_0_4_0(uint64_t result, int a2, int a3)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 4;
  *(_DWORD *)(result + 10) = a3;
  return result;
}

void sub_1B530DCE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_1B530ED8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_1B530EED0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_1B530EFD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_1B530F080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_1B53115F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj, uint64_t a11, uint64_t a12, int a13, int a14, _Unwind_Exception *exception_object)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_1B5311F30(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  uint64_t v10;

  *(_QWORD *)(v10 - 24) = a1;
  *(_DWORD *)(v10 - 28) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v10 - 24));
}

void sub_1B5312218(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id obj)
{
  uint64_t v11;

  *(_QWORD *)(v11 - 24) = a1;
  *(_DWORD *)(v11 - 28) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v11 - 24));
}

void sub_1B5315A54(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  uint64_t v10;

  *(_QWORD *)(v10 - 24) = a1;
  *(_DWORD *)(v10 - 28) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v10 - 24));
}

void sub_1B5316648(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id obj)
{
  uint64_t v13;

  *(_QWORD *)(v13 - 56) = a1;
  *(_DWORD *)(v13 - 60) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v13 - 56));
}

void sub_1B5316830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  _Block_object_dispose(&a20, 8);
  _Unwind_Resume(a1);
}

uint64_t std::vector<float>::push_back[abi:ne180100](uint64_t *a1, float *a2)
{
  unint64_t *v2;
  uint64_t result;
  unint64_t v5;
  uint64_t v6;

  v5 = a1[1];
  std::vector<float>::__end_cap[abi:ne180100]();
  if (v5 >= *v2)
  {
    result = std::vector<float>::__push_back_slow_path<float const&>(a1, a2);
    v6 = result;
  }
  else
  {
    result = (uint64_t)std::vector<float>::__construct_one_at_end[abi:ne180100]<float const&>((uint64_t)a1, a2);
    v6 = v5 + 4;
  }
  a1[1] = v6;
  return result;
}

uint64_t std::vector<float>::back[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) - 4;
}

uint64_t __os_log_helper_16_0_4_4_0_8_0_4_0_8_0(uint64_t result, int a2, uint64_t a3, int a4, uint64_t a5)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 4;
  *(_DWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 24) = 0;
  *(_BYTE *)(result + 25) = 8;
  *(_QWORD *)(result + 26) = a5;
  return result;
}

uint64_t __os_log_helper_16_2_7_4_0_8_0_8_32_8_32_8_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 7;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 32;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 32;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 49) = 8;
  *(_QWORD *)(result + 50) = a7;
  *(_BYTE *)(result + 58) = 0;
  *(_BYTE *)(result + 59) = 8;
  *(_QWORD *)(result + 60) = a8;
  return result;
}

float std::__math::round[abi:ne180100](float a1)
{
  return round(a1);
}

BOOL std::vector<float>::empty[abi:ne180100](_QWORD *a1)
{
  return *a1 == a1[1];
}

uint64_t std::vector<float>::size[abi:ne180100](_QWORD *a1)
{
  return (a1[1] - *a1) / 4;
}

uint64_t std::vector<float>::operator[][abi:ne180100](_QWORD *a1, uint64_t a2)
{
  return *a1 + 4 * a2;
}

uint64_t std::vector<float>::front[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t *std::vector<float>::~vector[abi:ne180100](uint64_t *a1)
{
  std::vector<float>::~vector[abi:ne180100](a1);
  return a1;
}

{
  uint64_t *v3[2];

  v3[1] = a1;
  std::vector<float>::__destroy_vector::__destroy_vector[abi:ne180100](v3, (uint64_t)a1);
  std::vector<float>::__destroy_vector::operator()[abi:ne180100](v3);
  return a1;
}

_QWORD *std::vector<float>::vector[abi:ne180100](_QWORD *a1)
{
  std::vector<float>::vector[abi:ne180100](a1);
  return a1;
}

{
  *a1 = 0;
  a1[1] = 0;
  std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1 + 2);
  return a1;
}

void std::vector<float>::__end_cap[abi:ne180100]()
{
  std::__compressed_pair<float *>::first[abi:ne180100]();
}

{
  std::__compressed_pair<float *>::first[abi:ne180100]();
}

_QWORD *std::vector<float>::__construct_one_at_end[abi:ne180100]<float const&>(uint64_t a1, float *a2)
{
  uint64_t v2;
  _DWORD *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float *v8;
  uint64_t v9;

  v9 = a1;
  v8 = a2;
  std::vector<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, 1);
  std::vector<float>::__alloc[abi:ne180100]();
  v5 = v2;
  std::__to_address[abi:ne180100]<float>();
  std::allocator_traits<std::allocator<float>>::construct[abi:ne180100]<float,float const&,void>(v5, v3, v8);
  v7 += 4;
  return std::vector<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1B531891C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15)
{
  std::vector<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&a15);
  _Unwind_Resume(a1);
}

uint64_t std::vector<float>::__push_back_slow_path<float const&>(uint64_t *a1, float *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  uint64_t v7;
  unint64_t v9;
  uint64_t v10;
  void *v11[2];
  uint64_t v12;
  uint64_t v13;
  float *v14;
  uint64_t *v15;

  v15 = a1;
  v14 = a2;
  std::vector<float>::__alloc[abi:ne180100]();
  v13 = v2;
  v3 = std::vector<float>::size[abi:ne180100](a1);
  v9 = std::vector<float>::__recommend[abi:ne180100](a1, v3 + 1);
  v4 = std::vector<float>::size[abi:ne180100](a1);
  std::__split_buffer<float>::__split_buffer(v11, v9, v4, v13);
  v10 = v13;
  std::__to_address[abi:ne180100]<float>();
  std::allocator_traits<std::allocator<float>>::construct[abi:ne180100]<float,float const&,void>(v10, v5, v14);
  v12 += 4;
  std::vector<float>::__swap_out_circular_buffer(a1, v11);
  v7 = a1[1];
  std::__split_buffer<float>::~__split_buffer(v11);
  return v7;
}

void sub_1B5318A04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, _Unwind_Exception *exception_object, void *a16)
{
  std::__split_buffer<float>::~__split_buffer(&a16);
  _Unwind_Resume(a1);
}

void std::__compressed_pair<float *>::first[abi:ne180100]()
{
  std::__compressed_pair_elem<float *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<float *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<float *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<float *,0,false>::__get[abi:ne180100]();
}

_QWORD *std::vector<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  std::vector<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](a1, a2, a3);
  return a1;
}

float std::allocator_traits<std::allocator<float>>::construct[abi:ne180100]<float,float const&,void>(uint64_t a1, _DWORD *a2, float *a3)
{
  return std::allocator<float>::construct[abi:ne180100]<float,float const&>(a1, a2, a3);
}

void std::vector<float>::__alloc[abi:ne180100]()
{
  std::__compressed_pair<float *>::second[abi:ne180100]();
}

{
  std::__compressed_pair<float *>::second[abi:ne180100]();
}

_QWORD *std::vector<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](_QWORD *a1)
{
  std::vector<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](a1);
  return a1;
}

_QWORD *std::vector<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](_QWORD *result, uint64_t a2, uint64_t a3)
{
  *result = a2;
  result[1] = *(_QWORD *)(a2 + 8);
  result[2] = *(_QWORD *)(a2 + 8) + 4 * a3;
  return result;
}

float std::allocator<float>::construct[abi:ne180100]<float,float const&>(uint64_t a1, _DWORD *a2, float *a3)
{
  float result;

  result = *a3;
  *a2 = *(_DWORD *)a3;
  return result;
}

void std::__compressed_pair<float *>::second[abi:ne180100]()
{
  std::__compressed_pair_elem<std::allocator<float>,1,true>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<std::allocator<float>,1,true>::__get[abi:ne180100]();
}

_QWORD *std::vector<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](_QWORD *result)
{
  *(_QWORD *)(*result + 8) = result[1];
  return result;
}

unint64_t std::vector<float>::__recommend[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD v7[2];

  v7[1] = a1;
  v7[0] = a2;
  v6 = std::vector<float>::max_size((uint64_t)a1);
  if (v7[0] > v6)
    std::vector<float>::__throw_length_error[abi:ne180100]();
  v5 = std::vector<float>::capacity[abi:ne180100](a1);
  if (v5 >= v6 / 2)
    return v6;
  v4 = 2 * v5;
  return *std::max[abi:ne180100]<unsigned long>(&v4, v7);
}

void **std::__split_buffer<float>::__split_buffer(void **a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__split_buffer<float>::__split_buffer(a1, a2, a3, a4);
  return a1;
}

{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v9;
  _QWORD v11[2];
  uint64_t v12;
  unint64_t v13;
  void **v14;
  void **v15;

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11[1] = a4;
  v15 = a1;
  v11[0] = 0;
  std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<float> &>(a1 + 3, (uint64_t)v11, a4);
  if (v13)
  {
    v4 = std::__split_buffer<float>::__alloc[abi:ne180100]((uint64_t)a1);
    *a1 = std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v13);
    v13 = v5;
  }
  else
  {
    *a1 = 0;
  }
  v6 = (uint64_t)*a1 + 4 * v12;
  a1[2] = (void *)v6;
  a1[1] = (void *)v6;
  v9 = (unint64_t)*a1 + 4 * v13;
  std::__split_buffer<float>::__end_cap[abi:ne180100]();
  *v7 = v9;
  return v15;
}

void std::vector<float>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v10[2];
  uint64_t v11[2];
  unint64_t v12[2];
  _QWORD v13[2];
  _QWORD *v14;
  uint64_t *v15;

  v15 = a1;
  v14 = a2;
  std::vector<float>::__annotate_delete[abi:ne180100]();
  std::vector<float>::__alloc[abi:ne180100]();
  v7 = v2;
  std::reverse_iterator<float *>::reverse_iterator[abi:ne180100](v12, a1[1]);
  std::reverse_iterator<float *>::reverse_iterator[abi:ne180100](v11, *a1);
  std::reverse_iterator<float *>::reverse_iterator[abi:ne180100](v10, v14[1]);
  v13[0] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<float>,std::reverse_iterator<float *>,std::reverse_iterator<float *>,float,void>(v7, v12[0], v12[1], v11[0], v11[1], v10[0], v10[1]);
  v13[1] = v3;
  v4 = std::reverse_iterator<float *>::base[abi:ne180100]((uint64_t)v13);
  v14[1] = v4;
  std::swap[abi:ne180100]<float *>(a1, v14 + 1);
  std::swap[abi:ne180100]<float *>(a1 + 1, v14 + 2);
  std::vector<float>::__end_cap[abi:ne180100]();
  v8 = v5;
  std::__split_buffer<float>::__end_cap[abi:ne180100]();
  std::swap[abi:ne180100]<float *>(v8, v6);
  *v14 = v14[1];
  std::vector<float>::size[abi:ne180100](a1);
  std::vector<float>::__annotate_new[abi:ne180100]();
}

void **std::__split_buffer<float>::~__split_buffer(void **a1)
{
  std::__split_buffer<float>::~__split_buffer(a1);
  return a1;
}

{
  uint64_t v2;
  void *v3;

  std::__split_buffer<float>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
  {
    v2 = std::__split_buffer<float>::__alloc[abi:ne180100]((uint64_t)a1);
    v3 = *a1;
    std::__split_buffer<float>::capacity[abi:ne180100](a1);
    std::allocator_traits<std::allocator<float>>::deallocate[abi:ne180100](v2, v3);
  }
  return a1;
}

void std::vector<float>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

uint64_t std::vector<float>::capacity[abi:ne180100](_QWORD *a1)
{
  _QWORD *v1;

  std::vector<float>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 4;
}

_QWORD *std::max[abi:ne180100]<unsigned long>(_QWORD *a1, _QWORD *a2)
{
  return std::max[abi:ne180100]<unsigned long,std::__less<void,void>>(a1, a2);
}

_QWORD *std::min[abi:ne180100]<unsigned long>(_QWORD *a1, _QWORD *a2)
{
  return std::min[abi:ne180100]<unsigned long,std::__less<void,void>>(a1, a2);
}

uint64_t std::numeric_limits<long>::max[abi:ne180100]()
{
  return std::__libcpp_numeric_limits<long,true>::max[abi:ne180100]();
}

_QWORD *std::min[abi:ne180100]<unsigned long,std::__less<void,void>>(_QWORD *a1, _QWORD *a2)
{
  char v6;

  if (std::__less<void,void>::operator()[abi:ne180100]<unsigned long,unsigned long>((uint64_t)&v6, a2, a1))
    return a2;
  else
    return a1;
}

BOOL std::__less<void,void>::operator()[abi:ne180100]<unsigned long,unsigned long>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a2 < *a3;
}

uint64_t std::__libcpp_numeric_limits<long,true>::max[abi:ne180100]()
{
  return 0x7FFFFFFFFFFFFFFFLL;
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E68E8D38, MEMORY[0x1E0DE42D0]);
}

void sub_1B5319010(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  __cxa_free_exception(a9);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::length_error::length_error[abi:ne180100](a1, a2);
  return a1;
}

{
  std::logic_error *result;

  std::logic_error::logic_error(a1, a2);
  result = a1;
  a1->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5020] + 16);
  return result;
}

_QWORD *std::max[abi:ne180100]<unsigned long,std::__less<void,void>>(_QWORD *a1, _QWORD *a2)
{
  char v6;

  if (std::__less<void,void>::operator()[abi:ne180100]<unsigned long,unsigned long>((uint64_t)&v6, a1, a2))
    return a2;
  else
    return a1;
}

_QWORD *std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<float> &>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<float> &>(a1, a2, a3);
  return a1;
}

{
  std::__compressed_pair_elem<float *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<float> &,1,false>::__compressed_pair_elem[abi:ne180100]<std::allocator<float> &,void>(a1 + 1, a3);
  return a1;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(uint64_t a1, unint64_t a2)
{
  return std::allocator<float>::allocate[abi:ne180100](a1, a2);
}

uint64_t std::__split_buffer<float>::__alloc[abi:ne180100](uint64_t a1)
{
  return std::__compressed_pair<float *>::second[abi:ne180100](a1 + 24);
}

void std::__split_buffer<float>::__end_cap[abi:ne180100]()
{
  std::__compressed_pair<float *>::first[abi:ne180100]();
}

{
  std::__compressed_pair<float *>::first[abi:ne180100]();
}

_QWORD *std::__compressed_pair_elem<float *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(_QWORD *result)
{
  *result = 0;
  return result;
}

_QWORD *std::__compressed_pair_elem<std::allocator<float> &,1,false>::__compressed_pair_elem[abi:ne180100]<std::allocator<float> &,void>(_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

uint64_t std::__compressed_pair<float *>::second[abi:ne180100](uint64_t a1)
{
  return std::__compressed_pair_elem<std::allocator<float> &,1,false>::__get[abi:ne180100](a1 + 8);
}

uint64_t std::__compressed_pair_elem<std::allocator<float> &,1,false>::__get[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<float>,std::reverse_iterator<float *>,std::reverse_iterator<float *>,float,void>(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return std::move[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(a2, a3, a4, a5, a6, a7);
}

_QWORD *std::reverse_iterator<float *>::reverse_iterator[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::reverse_iterator<float *>::reverse_iterator[abi:ne180100](a1, a2);
  return a1;
}

uint64_t std::reverse_iterator<float *>::base[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t *std::swap[abi:ne180100]<float *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *result;
  *result = *a2;
  *a2 = v2;
  return result;
}

uint64_t std::move[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;

  v13 = a1;
  v14 = a2;
  v11 = a3;
  v12 = a4;
  v9 = a5;
  v10 = a6;
  std::__move[abi:ne180100]<std::_ClassicAlgPolicy,std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>>(a1, a2, a3, a4, a5, a6, &v7);
  return v8;
}

_OWORD *std::__move[abi:ne180100]<std::_ClassicAlgPolicy,std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial,std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>>(a1, a2, a3, a4, a5, a6, a7);
}

_OWORD *std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial,std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>,0>(a1, a2, a3, a4, a5, a6, a7);
}

_OWORD *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>,0>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  __n128 v13[3];
  _OWORD v14[2];
  unint64_t v15;
  unint64_t v16;
  __int128 v17;
  __int128 v18;
  __n128 v19;
  __int128 v20;
  __int128 v21;
  __n128 v22;
  _OWORD v23[2];
  __int128 v24;
  __int128 v25;
  __n128 v26;

  v26.n128_u64[0] = a1;
  v26.n128_u64[1] = a2;
  *(_QWORD *)&v25 = a3;
  *((_QWORD *)&v25 + 1) = a4;
  *(_QWORD *)&v24 = a5;
  *((_QWORD *)&v24 + 1) = a6;
  v22 = v26;
  v21 = v25;
  std::__unwrap_range[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(a1, a2, a3, a4, v23);
  v18 = v23[0];
  v17 = v23[1];
  v14[1] = v24;
  std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>,0>();
  v15 = v7;
  v16 = v8;
  std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>>(v18, *((uint64_t *)&v18 + 1), v17, *((uint64_t *)&v17 + 1), v7, v8, &v19);
  v13[2] = v26;
  v13[1] = v19;
  *(_QWORD *)&v14[0] = std::__rewrap_range[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(v26.n128_i64[0], v26.n128_i64[1], v19.n128_i64[0]);
  *((_QWORD *)&v14[0] + 1) = v9;
  v13[0].n128_u64[0] = std::__rewrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>>(v24, *((uint64_t *)&v24 + 1), v20);
  v13[0].n128_u64[1] = v10;
  return std::make_pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(v14, v13, a7);
}

_OWORD *std::__unwrap_range[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  __n128 v11[2];
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __n128 v15;

  v15.n128_u64[0] = a1;
  v15.n128_u64[1] = a2;
  v13 = a3;
  v14 = a4;
  v11[1] = v15;
  std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>,0>();
  *(_QWORD *)&v12 = v5;
  *((_QWORD *)&v12 + 1) = v6;
  std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>,0>();
  v11[0].n128_u64[0] = v7;
  v11[0].n128_u64[1] = v8;
  return std::make_pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(&v12, v11, a5);
}

_OWORD *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, unint64_t a5@<X5>, unint64_t a6@<X6>, _OWORD *a7@<X8>)
{
  int v8;
  __n128 v10;
  _QWORD v11[2];
  __int128 v12;

  *(_QWORD *)&v12 = a1;
  *((_QWORD *)&v12 + 1) = a2;
  v11[0] = a3;
  v11[1] = a4;
  v10.n128_u64[0] = a5;
  v10.n128_u64[1] = a6;
  while (std::operator!=[abi:ne180100]<float *,float *>((uint64_t)&v12, (uint64_t)v11))
  {
    v8 = *(_DWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<std::reverse_iterator<float *> &,0>((uint64_t)&v12);
    *(_DWORD *)std::reverse_iterator<float *>::operator*[abi:ne180100]((uint64_t)&v10) = v8;
    std::reverse_iterator<float *>::operator++[abi:ne180100]((uint64_t)&v12);
    std::reverse_iterator<float *>::operator++[abi:ne180100]((uint64_t)&v10);
  }
  return std::make_pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(&v12, &v10, a7);
}

void std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>,0>()
{
  std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>::__unwrap[abi:ne180100]();
}

_OWORD *std::make_pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>@<X0>(_OWORD *a1@<X0>, __n128 *a2@<X1>, _OWORD *a3@<X8>)
{
  return std::pair<std::reverse_iterator<float *>,std::reverse_iterator<float *>>::pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,0>(a3, a1, a2);
}

uint64_t std::__rewrap_range[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__rewrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>>(a1, a2, a3);
}

uint64_t std::__rewrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>::__rewrap[abi:ne180100](a1, a2, a3);
}

BOOL std::operator!=[abi:ne180100]<float *,float *>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = std::reverse_iterator<float *>::base[abi:ne180100](a1);
  return v3 != std::reverse_iterator<float *>::base[abi:ne180100](a2);
}

uint64_t std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<std::reverse_iterator<float *> &,0>(uint64_t a1)
{
  std::_IterOps<std::_ClassicAlgPolicy>::__validate_iter_reference[abi:ne180100]<std::reverse_iterator<float *> &>();
  return std::reverse_iterator<float *>::operator*[abi:ne180100](a1);
}

uint64_t std::reverse_iterator<float *>::operator*[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) - 4;
}

uint64_t std::reverse_iterator<float *>::operator++[abi:ne180100](uint64_t result)
{
  *(_QWORD *)(result + 8) -= 4;
  return result;
}

_OWORD *std::pair<std::reverse_iterator<float *>,std::reverse_iterator<float *>>::pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,0>(_OWORD *a1, _OWORD *a2, __n128 *a3)
{
  std::pair<std::reverse_iterator<float *>,std::reverse_iterator<float *>>::pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,0>(a1, a2, a3);
  return a1;
}

__n128 std::pair<std::reverse_iterator<float *>,std::reverse_iterator<float *>>::pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,0>(_OWORD *a1, _OWORD *a2, __n128 *a3)
{
  __n128 result;

  *a1 = *a2;
  result = *a3;
  a1[1] = *a3;
  return result;
}

uint64_t std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

_QWORD *std::reverse_iterator<float *>::reverse_iterator[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  result[1] = a2;
  return result;
}

void std::__split_buffer<float>::clear[abi:ne180100](uint64_t a1)
{
  std::__split_buffer<float>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
}

void std::allocator_traits<std::allocator<float>>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
  std::allocator<float>::deallocate[abi:ne180100](a1, a2);
}

uint64_t std::__split_buffer<float>::capacity[abi:ne180100](_QWORD *a1)
{
  _QWORD *v1;

  std::__split_buffer<float>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 4;
}

void std::__split_buffer<float>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__split_buffer<float>::__destruct_at_end[abi:ne180100](a1, a2);
}

{
  while (a2 != *(_QWORD *)(a1 + 16))
  {
    std::__split_buffer<float>::__alloc[abi:ne180100](a1);
    *(_QWORD *)(a1 + 16) -= 4;
    std::__to_address[abi:ne180100]<float>();
    std::allocator_traits<std::allocator<float>>::destroy[abi:ne180100]<float,void>();
  }
}

void std::allocator_traits<std::allocator<float>>::destroy[abi:ne180100]<float,void>()
{
  std::allocator<float>::destroy[abi:ne180100]();
}

_QWORD *std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(_QWORD *a1)
{
  std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1);
  return a1;
}

{
  std::__compressed_pair_elem<float *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<float>,1,true>::__compressed_pair_elem[abi:ne180100]((uint64_t)a1);
  return a1;
}

uint64_t std::__compressed_pair_elem<std::allocator<float>,1,true>::__compressed_pair_elem[abi:ne180100](uint64_t a1)
{
  std::allocator<float>::allocator[abi:ne180100](a1);
  return a1;
}

_QWORD *std::vector<float>::__destroy_vector::__destroy_vector[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::vector<float>::__destroy_vector::__destroy_vector[abi:ne180100](a1, a2);
  return a1;
}

void std::vector<float>::__destroy_vector::operator()[abi:ne180100](uint64_t **a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;

  if (**a1)
  {
    std::vector<float>::__clear[abi:ne180100](*a1);
    std::vector<float>::__annotate_delete[abi:ne180100]();
    std::vector<float>::__alloc[abi:ne180100]();
    v3 = v1;
    v2 = (void *)**a1;
    std::vector<float>::capacity[abi:ne180100](*a1);
    std::allocator_traits<std::allocator<float>>::deallocate[abi:ne180100](v3, v2);
  }
}

_QWORD *std::vector<float>::__destroy_vector::__destroy_vector[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

void std::vector<float>::__clear[abi:ne180100](uint64_t *a1)
{
  std::vector<float>::__base_destruct_at_end[abi:ne180100]((uint64_t)a1, *a1);
}

void std::vector<float>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 8); a2 != i; i -= 4)
  {
    std::vector<float>::__alloc[abi:ne180100]();
    std::__to_address[abi:ne180100]<float>();
    std::allocator_traits<std::allocator<float>>::destroy[abi:ne180100]<float,void>();
  }
  *(_QWORD *)(a1 + 8) = a2;
}

void sub_1B531B22C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15, _Unwind_Exception *exception_object)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

uint64_t findBin(float *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  float *v8;

  v8 = a1;
  v7 = a2;
  v6 = a2;
  v5 = std::vector<CBBOLTS::Bin>::begin[abi:ne180100](a2);
  v4 = std::vector<CBBOLTS::Bin>::end[abi:ne180100]((uint64_t)v6);
  while (std::operator!=[abi:ne180100]<CBBOLTS::Bin *>((uint64_t)&v5, (uint64_t)&v4))
  {
    v3 = std::__wrap_iter<CBBOLTS::Bin *>::operator*[abi:ne180100]((uint64_t)&v5);
    if (CBBOLTS::Bin::curveUpdateSatisfiesCondition(v3, v8))
      return v3;
    std::__wrap_iter<CBBOLTS::Bin *>::operator++[abi:ne180100](&v5);
  }
  return std::vector<CBBOLTS::Bin>::front[abi:ne180100]((uint64_t)v7);
}

uint64_t std::vector<CBBOLTS::Bin>::begin[abi:ne180100](uint64_t *a1)
{
  return std::vector<CBBOLTS::Bin>::__make_iter[abi:ne180100]((uint64_t)a1, *a1);
}

{
  return std::vector<CBBOLTS::Bin>::__make_iter[abi:ne180100]((uint64_t)a1, *a1);
}

uint64_t std::vector<CBBOLTS::Bin>::end[abi:ne180100](uint64_t a1)
{
  return std::vector<CBBOLTS::Bin>::__make_iter[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
}

{
  return std::vector<CBBOLTS::Bin>::__make_iter[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
}

BOOL std::operator!=[abi:ne180100]<CBBOLTS::Bin *>(uint64_t a1, uint64_t a2)
{
  return !std::operator==[abi:ne180100]<CBBOLTS::Bin *>(a1, a2);
}

uint64_t std::__wrap_iter<CBBOLTS::Bin *>::operator*[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

BOOL CBBOLTS::Bin::curveUpdateSatisfiesCondition(uint64_t a1, float *a2)
{
  BOOL v3;

  v3 = 0;
  if (*a2 >= *(float *)(a1 + 24))
    return *a2 < *(float *)(a1 + 28);
  return v3;
}

_QWORD *std::__wrap_iter<CBBOLTS::Bin *>::operator++[abi:ne180100](_QWORD *result)
{
  *result += 48;
  return result;
}

uint64_t std::vector<CBBOLTS::Bin>::front[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

void CBBOLTS::Bin::push(_QWORD *a1, unint64_t a2, unint64_t a3)
{
  __n128 v4;

  v4.n128_u64[0] = a2;
  v4.n128_u64[1] = a3;
  while ((unint64_t)std::list<AAB::CurveUpdate>::size[abi:ne180100]() >= a1[5])
    std::list<AAB::CurveUpdate>::pop_front((uint64_t)a1);
  std::list<AAB::CurveUpdate>::push_back(a1, &v4);
}

uint64_t std::list<AAB::CurveUpdate>::size[abi:ne180100]()
{
  uint64_t v0;

  std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
  return *(_QWORD *)v0;
}

void std::list<AAB::CurveUpdate>::pop_front(uint64_t a1)
{
  _QWORD *v1;
  void *v2;

  std::__list_imp<AAB::CurveUpdate>::__unlink_nodes(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 8));
  std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
  --*v1;
  std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]();
  std::__list_imp<AAB::CurveUpdate>::__delete_node[abi:ne180100]<>(a1, v2);
}

void std::list<AAB::CurveUpdate>::push_back(_QWORD *a1, __n128 *a2)
{
  uint64_t v2;
  _QWORD *v3;

  std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate>((uint64_t)a1, 0, 0, a2);
  std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]();
  std::list<AAB::CurveUpdate>::__link_nodes_at_back(a1, v2, v2);
  std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
  ++*v3;
}

{
  uint64_t v2;
  _QWORD *v3;

  std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate const&>((uint64_t)a1, 0, 0, a2);
  std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]();
  std::list<AAB::CurveUpdate>::__link_nodes_at_back(a1, v2, v2);
  std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
  ++*v3;
}

uint64_t *CBBOLTS::serializeBins@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *result;
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[4];
  CBBOLTS::Bin *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20[3];
  __n128 v21;
  _QWORD v22[3];
  uint64_t i;
  CBBOLTS::Bin *v24;
  uint64_t v25;
  _QWORD v26[2];
  char v27;
  uint64_t *v28;
  uint64_t *v29;

  v29 = a2;
  v28 = a1;
  v27 = 0;
  std::vector<AAB::CurveUpdate>::vector[abi:ne180100](a2);
  v26[1] = v28;
  v26[0] = std::vector<CBBOLTS::Bin>::begin[abi:ne180100](v28);
  v25 = std::vector<CBBOLTS::Bin>::end[abi:ne180100]((uint64_t)v28);
  while (std::operator!=[abi:ne180100]<CBBOLTS::Bin const*>((uint64_t)v26, (uint64_t)&v25))
  {
    v24 = (CBBOLTS::Bin *)std::__wrap_iter<CBBOLTS::Bin const*>::operator*[abi:ne180100]((uint64_t)v26);
    i = 0;
    CBBOLTS::Bin::updates(v24, v22);
    v4 = std::list<AAB::CurveUpdate>::size[abi:ne180100]();
    std::list<AAB::CurveUpdate>::~list((uint64_t)v22);
    for (i = v4; ; ++i)
    {
      v3 = i;
      if (v3 >= *(_QWORD *)(CBBOLTS::Bin::configuration(v24) + 16))
        break;
      v21.n128_u64[0] = *(_QWORD *)(CBBOLTS::Bin::configuration(v24) + 8);
      v21.n128_u64[1] = -1;
      std::vector<AAB::CurveUpdate>::push_back[abi:ne180100](a2, &v21);
    }
    std::__wrap_iter<CBBOLTS::Bin const*>::operator++[abi:ne180100](v26);
  }
  std::vector<AAB::CurveUpdate>::vector[abi:ne180100](v20);
  v19 = v28;
  v18 = std::vector<CBBOLTS::Bin>::begin[abi:ne180100](v28);
  v17 = std::vector<CBBOLTS::Bin>::end[abi:ne180100]((uint64_t)v19);
  while (std::operator!=[abi:ne180100]<CBBOLTS::Bin const*>((uint64_t)&v18, (uint64_t)&v17))
  {
    v16 = (CBBOLTS::Bin *)std::__wrap_iter<CBBOLTS::Bin const*>::operator*[abi:ne180100]((uint64_t)&v18);
    CBBOLTS::Bin::updates(v16, v15);
    v15[3] = v15;
    v14 = std::list<AAB::CurveUpdate>::begin[abi:ne180100]((uint64_t)v15);
    v13 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
    while (std::operator!=[abi:ne180100](&v14, &v13))
    {
      v12 = (__n128 *)std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
      std::vector<AAB::CurveUpdate>::push_back[abi:ne180100](v20, v12);
      std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v14);
    }
    std::list<AAB::CurveUpdate>::~list((uint64_t)v15);
    std::__wrap_iter<CBBOLTS::Bin const*>::operator++[abi:ne180100](&v18);
  }
  v11 = std::vector<AAB::CurveUpdate>::begin[abi:ne180100](v20);
  v10 = std::vector<AAB::CurveUpdate>::end[abi:ne180100]((uint64_t)v20);
  std::sort[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>(v11, v10);
  v8 = std::vector<AAB::CurveUpdate>::end[abi:ne180100]((uint64_t)a2);
  std::__wrap_iter<AAB::CurveUpdate const*>::__wrap_iter[abi:ne180100]<AAB::CurveUpdate*,0>(&v9, (uint64_t)&v8);
  v7 = std::vector<AAB::CurveUpdate>::begin[abi:ne180100](v20);
  v6 = std::vector<AAB::CurveUpdate>::end[abi:ne180100]((uint64_t)v20);
  std::vector<AAB::CurveUpdate>::insert<std::__wrap_iter<AAB::CurveUpdate*>,0>(a2, v9, v7, v6);
  v27 = 1;
  result = std::vector<AAB::CurveUpdate>::~vector[abi:ne180100](v20);
  if ((v27 & 1) == 0)
    return std::vector<AAB::CurveUpdate>::~vector[abi:ne180100](a2);
  return result;
}

_QWORD *std::vector<AAB::CurveUpdate>::vector[abi:ne180100](_QWORD *a1)
{
  std::vector<AAB::CurveUpdate>::vector[abi:ne180100](a1);
  return a1;
}

{
  *a1 = 0;
  a1[1] = 0;
  std::__compressed_pair<AAB::CurveUpdate *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1 + 2);
  return a1;
}

BOOL std::operator!=[abi:ne180100]<CBBOLTS::Bin const*>(uint64_t a1, uint64_t a2)
{
  return !std::operator==[abi:ne180100]<CBBOLTS::Bin const*>(a1, a2);
}

uint64_t std::__wrap_iter<CBBOLTS::Bin const*>::operator*[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

_QWORD *CBBOLTS::Bin::updates@<X0>(CBBOLTS::Bin *this@<X0>, _QWORD *a2@<X8>)
{
  return std::list<AAB::CurveUpdate>::list(a2, (uint64_t)this);
}

uint64_t std::list<AAB::CurveUpdate>::~list(uint64_t a1)
{
  std::list<AAB::CurveUpdate>::~list(a1);
  return a1;
}

{
  std::__list_imp<AAB::CurveUpdate>::~__list_imp(a1);
  return a1;
}

uint64_t CBBOLTS::Bin::configuration(CBBOLTS::Bin *this)
{
  return (uint64_t)this + 24;
}

uint64_t std::vector<AAB::CurveUpdate>::push_back[abi:ne180100](uint64_t *a1, __n128 *a2)
{
  unint64_t *v2;
  uint64_t result;
  unint64_t v5;
  uint64_t v6;

  v5 = a1[1];
  std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  if (v5 >= *v2)
  {
    result = std::vector<AAB::CurveUpdate>::__push_back_slow_path<AAB::CurveUpdate>(a1, a2);
    v6 = result;
  }
  else
  {
    result = (uint64_t)std::vector<AAB::CurveUpdate>::__construct_one_at_end[abi:ne180100]<AAB::CurveUpdate>((uint64_t)a1, a2);
    v6 = v5 + 16;
  }
  a1[1] = v6;
  return result;
}

{
  unint64_t *v2;
  uint64_t result;
  unint64_t v5;
  uint64_t v6;

  v5 = a1[1];
  std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  if (v5 >= *v2)
  {
    result = std::vector<AAB::CurveUpdate>::__push_back_slow_path<AAB::CurveUpdate const&>(a1, a2);
    v6 = result;
  }
  else
  {
    result = (uint64_t)std::vector<AAB::CurveUpdate>::__construct_one_at_end[abi:ne180100]<AAB::CurveUpdate const&>((uint64_t)a1, a2);
    v6 = v5 + 16;
  }
  a1[1] = v6;
  return result;
}

_QWORD *std::__wrap_iter<CBBOLTS::Bin const*>::operator++[abi:ne180100](_QWORD *result)
{
  *result += 48;
  return result;
}

uint64_t std::list<AAB::CurveUpdate>::begin[abi:ne180100](uint64_t a1)
{
  return std::__list_imp<AAB::CurveUpdate>::begin[abi:ne180100](a1);
}

{
  return std::__list_imp<AAB::CurveUpdate>::begin[abi:ne180100](a1);
}

uint64_t std::list<AAB::CurveUpdate>::end[abi:ne180100]()
{
  return std::__list_imp<AAB::CurveUpdate>::end[abi:ne180100]();
}

{
  return std::__list_imp<AAB::CurveUpdate>::end[abi:ne180100]();
}

BOOL std::operator!=[abi:ne180100](_QWORD *a1, _QWORD *a2)
{
  return !std::operator==[abi:ne180100](a1, a2);
}

{
  return !std::operator==[abi:ne180100](a1, a2);
}

uint64_t std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]()
{
  uint64_t v0;

  std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]();
  return std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100](v0);
}

uint64_t std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100](uint64_t result)
{
  *(_QWORD *)result = *(_QWORD *)(*(_QWORD *)result + 8);
  return result;
}

void std::sort[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>(uint64_t a1, uint64_t a2)
{
  char v2;
  uint64_t v3;
  uint64_t v4;

  v4 = a1;
  v3 = a2;
  std::__sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<AAB::CurveUpdate *>,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>(a1, a2, (uint64_t)&v2);
}

uint64_t std::vector<AAB::CurveUpdate>::begin[abi:ne180100](uint64_t *a1)
{
  return std::vector<AAB::CurveUpdate>::__make_iter[abi:ne180100]((uint64_t)a1, *a1);
}

uint64_t std::vector<AAB::CurveUpdate>::end[abi:ne180100](uint64_t a1)
{
  return std::vector<AAB::CurveUpdate>::__make_iter[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
}

uint64_t std::vector<AAB::CurveUpdate>::insert<std::__wrap_iter<AAB::CurveUpdate*>,0>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  v4 = std::distance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>>(a3, a4);
  return std::vector<AAB::CurveUpdate>::__insert_with_size[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate*>,std::__wrap_iter<AAB::CurveUpdate*>>(a1, a2, a3, a4, v4);
}

uint64_t *std::__wrap_iter<AAB::CurveUpdate const*>::__wrap_iter[abi:ne180100]<AAB::CurveUpdate*,0>(uint64_t *a1, uint64_t a2)
{
  std::__wrap_iter<AAB::CurveUpdate const*>::__wrap_iter[abi:ne180100]<AAB::CurveUpdate*,0>(a1, a2);
  return a1;
}

{
  uint64_t v2;
  uint64_t *result;

  v2 = std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](a2);
  result = a1;
  *a1 = v2;
  return result;
}

uint64_t *std::vector<AAB::CurveUpdate>::~vector[abi:ne180100](uint64_t *a1)
{
  std::vector<AAB::CurveUpdate>::~vector[abi:ne180100](a1);
  return a1;
}

{
  uint64_t *v3[2];

  v3[1] = a1;
  std::vector<AAB::CurveUpdate>::__destroy_vector::__destroy_vector[abi:ne180100](v3, (uint64_t)a1);
  std::vector<AAB::CurveUpdate>::__destroy_vector::operator()[abi:ne180100](v3);
  return a1;
}

void CBBOLTS::addCurveUpdateToBuffer(uint64_t a1, unint64_t a2, unint64_t a3)
{
  dispatch_time_t v3;
  NSObject *v4;
  NSObject *source;
  uint64_t handler;
  int v8;
  int v9;
  void (*v10)(uint64_t);
  void *v11;
  uint64_t v12;
  uint64_t v13;
  __n128 v14;

  v14.n128_u64[0] = a2;
  v14.n128_u64[1] = a3;
  v13 = a1;
  if (!*(_QWORD *)(a1 + 24) || std::list<AAB::CurveUpdate>::empty[abi:ne180100]())
  {
    while ((unint64_t)std::list<AAB::CurveUpdate>::size[abi:ne180100]() >= *(_QWORD *)(a1 + 80))
      std::list<AAB::CurveUpdate>::pop_front(a1 + 88);
    std::list<AAB::CurveUpdate>::push_back((_QWORD *)(a1 + 88), &v14);
  }
  else
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 24));
    dispatch_release(*(dispatch_object_t *)(a1 + 24));
    *(_QWORD *)(a1 + 24) = 0;
    *(__n128 *)std::list<AAB::CurveUpdate>::back[abi:ne180100]() = v14;
  }
  if (*(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 24) = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(a1 + 16));
    source = *(NSObject **)(a1 + 24);
    v3 = dispatch_time(0, 5000000000);
    dispatch_source_set_timer(source, v3, 0xFFFFFFFFFFFFFFFFLL, 0);
    v4 = *(NSObject **)(a1 + 24);
    handler = MEMORY[0x1E0C809B0];
    v8 = -1073741824;
    v9 = 0;
    v10 = ___ZN7CBBOLTS22addCurveUpdateToBufferEN3AAB11CurveUpdateE_block_invoke;
    v11 = &__block_descriptor_40_e5_v8__0l;
    v12 = a1;
    dispatch_source_set_event_handler(v4, &handler);
    dispatch_resume(*(dispatch_object_t *)(a1 + 24));
  }
}

BOOL std::list<AAB::CurveUpdate>::empty[abi:ne180100]()
{
  return std::__list_imp<AAB::CurveUpdate>::empty[abi:ne180100]();
}

uint64_t std::list<AAB::CurveUpdate>::back[abi:ne180100]()
{
  uint64_t v0;

  std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]();
  return std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100](v0);
}

void ___ZN7CBBOLTS22addCurveUpdateToBufferEN3AAB11CurveUpdateE_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 24));
  dispatch_release(*(dispatch_object_t *)(v1 + 24));
  *(_QWORD *)(v1 + 24) = 0;
}

BOOL CBBOLTS::binUpdates@<W0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v3;
  _BOOL8 result;
  _QWORD *Bin;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[2];
  __n128 *v10;
  uint64_t v11;
  _QWORD v12[2];
  char v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;

  v16 = a3;
  v15 = a1;
  v14 = a2;
  v13 = 0;
  std::vector<CBBOLTS::Bin>::vector[abi:ne180100](a3);
  v3 = std::vector<CBBOLTS::BinConfiguration>::size[abi:ne180100](v14);
  std::vector<CBBOLTS::Bin>::reserve(a3, v3);
  v12[1] = v14;
  v12[0] = std::vector<CBBOLTS::BinConfiguration>::begin[abi:ne180100](v14);
  v11 = std::vector<CBBOLTS::BinConfiguration>::end[abi:ne180100]((uint64_t)v14);
  while (std::operator!=[abi:ne180100]<CBBOLTS::BinConfiguration const*>((uint64_t)v12, (uint64_t)&v11))
  {
    v10 = (__n128 *)std::__wrap_iter<CBBOLTS::BinConfiguration const*>::operator*[abi:ne180100]((uint64_t)v12);
    std::vector<CBBOLTS::Bin>::emplace_back<CBBOLTS::BinConfiguration const&>(a3, v10);
    std::__wrap_iter<CBBOLTS::BinConfiguration const*>::operator++[abi:ne180100](v12);
  }
  v9[1] = v15;
  v9[0] = std::list<AAB::CurveUpdate>::begin[abi:ne180100](v15);
  v8 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  while (1)
  {
    result = std::operator!=[abi:ne180100](v9, &v8);
    if (!result)
      break;
    v7 = std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
    Bin = (_QWORD *)findBin((float *)v7, a3);
    CBBOLTS::Bin::push(Bin, *(_QWORD *)v7, *(_QWORD *)(v7 + 8));
    std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)v9);
  }
  return result;
}

_QWORD *std::vector<CBBOLTS::Bin>::vector[abi:ne180100](_QWORD *a1)
{
  std::vector<CBBOLTS::Bin>::vector[abi:ne180100](a1);
  return a1;
}

{
  *a1 = 0;
  a1[1] = 0;
  std::__compressed_pair<CBBOLTS::Bin *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1 + 2);
  return a1;
}

void **std::vector<CBBOLTS::Bin>::reserve(uint64_t *a1, unint64_t a2)
{
  void **result;
  uint64_t v3;
  uint64_t v4;
  void *v7[5];
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;

  v10 = a1;
  v9 = a2;
  result = (void **)std::vector<CBBOLTS::Bin>::capacity[abi:ne180100](a1);
  if (a2 > (unint64_t)result)
  {
    if (v9 > std::vector<CBBOLTS::Bin>::max_size((uint64_t)a1))
      std::vector<CBBOLTS::Bin>::__throw_length_error[abi:ne180100]();
    std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
    v8 = v3;
    v4 = std::vector<CBBOLTS::Bin>::size[abi:ne180100](a1);
    std::__split_buffer<CBBOLTS::Bin>::__split_buffer(v7, v9, v4, v8);
    std::vector<CBBOLTS::Bin>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<CBBOLTS::Bin>::~__split_buffer(v7);
  }
  return result;
}

uint64_t std::vector<CBBOLTS::BinConfiguration>::size[abi:ne180100](_QWORD *a1)
{
  return (a1[1] - *a1) / 24;
}

uint64_t std::vector<CBBOLTS::BinConfiguration>::begin[abi:ne180100](uint64_t *a1)
{
  return std::vector<CBBOLTS::BinConfiguration>::__make_iter[abi:ne180100]((uint64_t)a1, *a1);
}

uint64_t std::vector<CBBOLTS::BinConfiguration>::end[abi:ne180100](uint64_t a1)
{
  return std::vector<CBBOLTS::BinConfiguration>::__make_iter[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
}

BOOL std::operator!=[abi:ne180100]<CBBOLTS::BinConfiguration const*>(uint64_t a1, uint64_t a2)
{
  return !std::operator==[abi:ne180100]<CBBOLTS::BinConfiguration const*>(a1, a2);
}

uint64_t std::__wrap_iter<CBBOLTS::BinConfiguration const*>::operator*[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t std::vector<CBBOLTS::Bin>::emplace_back<CBBOLTS::BinConfiguration const&>(uint64_t *a1, __n128 *a2)
{
  unint64_t *v2;
  uint64_t result;
  unint64_t v5;
  uint64_t v6;

  v5 = a1[1];
  std::vector<CBBOLTS::Bin>::__end_cap[abi:ne180100]();
  if (v5 >= *v2)
  {
    result = std::vector<CBBOLTS::Bin>::__emplace_back_slow_path<CBBOLTS::BinConfiguration const&>(a1, a2);
    v6 = result;
  }
  else
  {
    result = (uint64_t)std::vector<CBBOLTS::Bin>::__construct_one_at_end[abi:ne180100]<CBBOLTS::BinConfiguration const&>((uint64_t)a1, a2);
    v6 = v5 + 48;
  }
  a1[1] = v6;
  return result;
}

_QWORD *std::__wrap_iter<CBBOLTS::BinConfiguration const*>::operator++[abi:ne180100](_QWORD *result)
{
  *result += 24;
  return result;
}

uint64_t *std::vector<CBBOLTS::Bin>::~vector[abi:ne180100](uint64_t *a1)
{
  std::vector<CBBOLTS::Bin>::~vector[abi:ne180100](a1);
  return a1;
}

{
  uint64_t *v3[2];

  v3[1] = a1;
  std::vector<CBBOLTS::Bin>::__destroy_vector::__destroy_vector[abi:ne180100](v3, (uint64_t)a1);
  std::vector<CBBOLTS::Bin>::__destroy_vector::operator()[abi:ne180100](v3);
  return a1;
}

float CBBOLTS::setCurveBasedOnModelPrediction(uint64_t a1, void *a2, void *a3)
{
  int v3;
  int v4;
  int v5;
  float v6;
  int v7;
  int v8;
  int v9;
  float v10;
  float result;
  float v12;

  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:"), "floatValue");
  *(_DWORD *)a1 = v3;
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:"), "floatValue");
  *(_DWORD *)(a1 + 8) = v4;
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:"), "floatValue");
  *(_DWORD *)(a1 + 20) = v5;
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:"), "floatValue");
  v12 = v6;
  objc_msgSend((id)objc_msgSend(a3, "objectAtIndexedSubscript:", 0), "floatValue");
  *(_DWORD *)(a1 + 4) = v7;
  objc_msgSend((id)objc_msgSend(a3, "objectAtIndexedSubscript:", 1), "floatValue");
  *(_DWORD *)(a1 + 12) = v8;
  objc_msgSend((id)objc_msgSend(a3, "objectAtIndexedSubscript:", 2), "floatValue");
  *(_DWORD *)(a1 + 28) = v9;
  objc_msgSend((id)objc_msgSend(a3, "objectAtIndexedSubscript:", 3), "floatValue");
  *(_DWORD *)(a1 + 16) = 0;
  *(float *)(a1 + 24) = *(float *)(a1 + 12)
                      - (float)((float)((float)(*(float *)(a1 + 28) - *(float *)(a1 + 12))
                                      / (float)(*(float *)(a1 + 20) - *(float *)(a1 + 8)))
                              * *(float *)(a1 + 8));
  *(float *)(a1 + 84) = (float)(v10 - *(float *)(a1 + 28)) / (float)(v12 - *(float *)(a1 + 20));
  *(_DWORD *)(a1 + 32) = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(CFAbsoluteTime *)(a1 + 88) = CFAbsoluteTimeGetCurrent();
  *(_DWORD *)(a1 + 96) = 3;
  result = 150000.0;
  *(_DWORD *)(a1 + 100) = 1209170944;
  return result;
}

uint64_t CBBOLTS::CBBOLTS(uint64_t a1, void *a2, uint64_t a3, _QWORD *a4)
{
  NSObject *v5;
  os_log_type_t v6;
  uint64_t inited;
  NSObject *v8;
  NSObject *log;
  os_log_type_t type;
  NSObject *v11;
  uint8_t v14[7];
  char v15;
  NSObject *v16;
  uint8_t v17[3];
  char v18;
  NSObject *v19;
  _QWORD *v20;
  uint64_t v21;
  id v22;
  uint64_t v23;
  uint64_t v24;

  v23 = a1;
  v22 = a2;
  v21 = a3;
  v20 = a4;
  v24 = a1;
  AAB::PreferenceUpdateCurveStrategy::PreferenceUpdateCurveStrategy((AAB::PreferenceUpdateCurveStrategy *)a1);
  *(_QWORD *)a1 = &unk_1E68E9578;
  *(_QWORD *)(a1 + 8) = os_log_create("com.apple.CoreBrightness.CBBOLTS", "default");
  *(_QWORD *)(a1 + 16) = dispatch_queue_create("CBBOLTS", 0);
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  std::vector<CBBOLTS::BinConfiguration>::vector[abi:ne180100]((_QWORD *)(a1 + 56), a4);
  *(_QWORD *)(a1 + 80) = v21;
  std::list<AAB::CurveUpdate>::list[abi:ne180100]((_QWORD *)(a1 + 88));
  if (!*(_QWORD *)(a1 + 8))
  {
    v19 = 0;
    v11 = (_COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log());
    v19 = v11;
    v18 = 16;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      log = v19;
      type = v18;
      __os_log_helper_16_0_0(v17);
      _os_log_error_impl(&dword_1B5291000, log, type, "Failed to create CBBOLTS log handle", v17, 2u);
    }
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    v16 = 0;
    if (*(_QWORD *)(a1 + 8))
    {
      v8 = *(NSObject **)(a1 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v8 = inited;
    }
    v16 = v8;
    v15 = 16;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v5 = v16;
      v6 = v15;
      __os_log_helper_16_0_0(v14);
      _os_log_error_impl(&dword_1B5291000, v5, v6, "Failed to create CBBOLTS queue", v14, 2u);
    }
  }
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 40) = v22;
  *(_BYTE *)(a1 + 216) = 0;
  return v24;
}

{
  CBBOLTS::CBBOLTS(a1, a2, a3, a4);
  return a1;
}

{
  NSObject *v5;
  os_log_type_t v6;
  uint64_t inited;
  NSObject *v8;
  NSObject *log;
  os_log_type_t type;
  NSObject *v11;
  uint8_t v14[7];
  char v15;
  NSObject *v16;
  uint8_t v17[3];
  char v18;
  NSObject *v19;
  _QWORD *v20;
  uint64_t v21;
  id v22;
  uint64_t v23;
  uint64_t v24;

  v23 = a1;
  v22 = a2;
  v21 = a3;
  v20 = a4;
  v24 = a1;
  AAB::PreferenceUpdateCurveStrategy::PreferenceUpdateCurveStrategy((AAB::PreferenceUpdateCurveStrategy *)a1);
  *(_QWORD *)a1 = &unk_1E68E9578;
  *(_QWORD *)(a1 + 8) = os_log_create("com.apple.CoreBrightness.CBBOLTS", "default");
  *(_QWORD *)(a1 + 16) = dispatch_queue_create("CBBOLTS", 0);
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  std::vector<CBBOLTS::BinConfiguration>::vector[abi:ne180100]((_QWORD *)(a1 + 56), a4);
  *(_QWORD *)(a1 + 80) = v21;
  std::list<AAB::CurveUpdate>::list[abi:ne180100]((_QWORD *)(a1 + 88));
  if (!*(_QWORD *)(a1 + 8))
  {
    v19 = 0;
    v11 = (_COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log());
    v19 = v11;
    v18 = 16;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      log = v19;
      type = v18;
      __os_log_helper_16_0_0(v17);
      _os_log_error_impl(&dword_1B5291000, log, type, "Failed to create CBBOLTS log handle", v17, 2u);
    }
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    v16 = 0;
    if (*(_QWORD *)(a1 + 8))
    {
      v8 = *(NSObject **)(a1 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v8 = inited;
    }
    v16 = v8;
    v15 = 16;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v5 = v16;
      v6 = v15;
      __os_log_helper_16_0_0(v14);
      _os_log_error_impl(&dword_1B5291000, v5, v6, "Failed to create CBBOLTS queue", v14, 2u);
    }
  }
  *(_QWORD *)(a1 + 48) = v22;
  *(_QWORD *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 216) = 0;
  return v24;
}

{
  CBBOLTS::CBBOLTS(a1, a2, a3, a4);
  return a1;
}

AAB::PreferenceUpdateCurveStrategy *AAB::PreferenceUpdateCurveStrategy::PreferenceUpdateCurveStrategy(AAB::PreferenceUpdateCurveStrategy *this)
{
  AAB::PreferenceUpdateCurveStrategy *result;

  AAB::UpdateCurveStrategy::UpdateCurveStrategy(this);
  result = this;
  *(_QWORD *)this = &unk_1E68E9688;
  return result;
}

{
  AAB::PreferenceUpdateCurveStrategy::PreferenceUpdateCurveStrategy(this);
  return this;
}

_QWORD *std::vector<CBBOLTS::BinConfiguration>::vector[abi:ne180100](_QWORD *a1, _QWORD *a2)
{
  std::vector<CBBOLTS::BinConfiguration>::vector[abi:ne180100](a1, a2);
  return a1;
}

{
  uint64_t *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *result;
  uint64_t v7;

  *a1 = 0;
  a1[1] = 0;
  std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]();
  std::__compressed_pair<CBBOLTS::BinConfiguration *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<CBBOLTS::BinConfiguration>>(a1 + 2);
  *a1 = *a2;
  a1[1] = a2[1];
  std::vector<CBBOLTS::BinConfiguration>::__end_cap[abi:ne180100]();
  v7 = *v2;
  std::vector<CBBOLTS::BinConfiguration>::__end_cap[abi:ne180100]();
  *v3 = v7;
  std::vector<CBBOLTS::BinConfiguration>::__end_cap[abi:ne180100]();
  v5 = v4;
  result = a1;
  *v5 = 0;
  a2[1] = 0;
  *a2 = 0;
  return result;
}

_QWORD *std::list<AAB::CurveUpdate>::list[abi:ne180100](_QWORD *a1)
{
  std::list<AAB::CurveUpdate>::list[abi:ne180100](a1);
  return a1;
}

{
  std::__list_imp<AAB::CurveUpdate>::__list_imp(a1);
  return a1;
}

uint64_t *std::vector<CBBOLTS::BinConfiguration>::~vector[abi:ne180100](uint64_t *a1)
{
  std::vector<CBBOLTS::BinConfiguration>::~vector[abi:ne180100](a1);
  return a1;
}

{
  uint64_t *v3[2];

  v3[1] = a1;
  std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::__destroy_vector[abi:ne180100](v3, (uint64_t)a1);
  std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::operator()[abi:ne180100](v3);
  return a1;
}

void AAB::PreferenceUpdateCurveStrategy::~PreferenceUpdateCurveStrategy(AAB::PreferenceUpdateCurveStrategy *this)
{
  AAB::UpdateCurveStrategy::~UpdateCurveStrategy(this);
}

{
  AAB::PreferenceUpdateCurveStrategy::~PreferenceUpdateCurveStrategy(this);
}

{
  AAB::PreferenceUpdateCurveStrategy::~PreferenceUpdateCurveStrategy(this);
  MEMORY[0x1B5E4A400](this, 0x81C40B8603338);
}

void CBBOLTS::~CBBOLTS(CBBOLTS *this)
{
  NSObject *v1;
  uint64_t block;
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  CBBOLTS *v8;
  CBBOLTS *v9;
  CBBOLTS *v10;

  v9 = this;
  v10 = this;
  *(_QWORD *)this = &unk_1E68E9578;
  if (*((_QWORD *)this + 2))
  {
    v1 = *((_QWORD *)this + 2);
    block = MEMORY[0x1E0C809B0];
    v4 = -1073741824;
    v5 = 0;
    v6 = ___ZN7CBBOLTSD2Ev_block_invoke;
    v7 = &__block_descriptor_40_e5_v8__0l;
    v8 = this;
    dispatch_sync(v1, &block);
    dispatch_release(*((dispatch_object_t *)this + 2));
    *((_QWORD *)this + 2) = 0;
  }
  else
  {
    if (*((_QWORD *)this + 3))
    {
      dispatch_source_cancel(*((dispatch_source_t *)this + 3));
      dispatch_release(*((dispatch_object_t *)this + 3));
      *((_QWORD *)this + 3) = 0;
    }
    if (*((_QWORD *)this + 4))
    {
      dispatch_source_cancel(*((dispatch_source_t *)this + 4));
      dispatch_release(*((dispatch_object_t *)this + 4));
      *((_QWORD *)this + 4) = 0;
    }

  }
  std::list<AAB::CurveUpdate>::~list((uint64_t)this + 88);
  std::vector<CBBOLTS::BinConfiguration>::~vector[abi:ne180100]((uint64_t *)this + 7);
  AAB::PreferenceUpdateCurveStrategy::~PreferenceUpdateCurveStrategy(this);
}

{
  CBBOLTS::~CBBOLTS(this);
}

{
  CBBOLTS::~CBBOLTS(this);
  MEMORY[0x1B5E4A400](this, 0x10A1C40123D1288);
}

void ___ZN7CBBOLTSD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v1 + 24))
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v1 + 24));
    dispatch_release(*(dispatch_object_t *)(v1 + 24));
    *(_QWORD *)(v1 + 24) = 0;
  }
  if (*(_QWORD *)(v1 + 32))
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v1 + 32));
    dispatch_release(*(dispatch_object_t *)(v1 + 32));
    *(_QWORD *)(v1 + 32) = 0;
  }

}

uint64_t CBBOLTS::createUsingModelURL(CBBOLTS *this, NSURL *a2)
{
  CBBOLTS *v3;
  uint64_t v4;
  uint64_t v5[4];
  CBBOLTS *v6;
  _BYTE __dst[168];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6 = this;
  v5[3] = 0;
  v4 = operator new();
  v3 = v6;
  memcpy(__dst, &unk_1B545C788, sizeof(__dst));
  std::vector<CBBOLTS::BinConfiguration>::vector[abi:ne180100](v5, (uint64_t)__dst, 7);
  CBBOLTS::CBBOLTS(v4, v3, 100, v5);
  std::vector<CBBOLTS::BinConfiguration>::~vector[abi:ne180100](v5);
  return v4;
}

void sub_1B531E33C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, __int16 a16, char a17, char a18, int a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if ((a18 & 1) != 0)
    MEMORY[0x1B5E4A400](a15, a14);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<CBBOLTS::BinConfiguration>::vector[abi:ne180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  std::vector<CBBOLTS::BinConfiguration>::vector[abi:ne180100](a1, a2, a3);
  return a1;
}

{
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  _BYTE v10[23];
  uint64_t v11;
  _QWORD *v12;
  _QWORD v13[2];
  _QWORD *v14;

  v13[0] = a2;
  v13[1] = a3;
  v12 = a1;
  v14 = a1;
  *a1 = 0;
  a1[1] = 0;
  v11 = 0;
  std::__compressed_pair<CBBOLTS::BinConfiguration *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1 + 2);
  std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::__destroy_vector[abi:ne180100](&v9, (uint64_t)a1);
  std::__make_exception_guard[abi:ne180100]<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>(v9, (uint64_t)v10);
  if (std::initializer_list<CBBOLTS::BinConfiguration>::size[abi:ne180100]((uint64_t)v13))
  {
    v3 = std::initializer_list<CBBOLTS::BinConfiguration>::size[abi:ne180100]((uint64_t)v13);
    std::vector<CBBOLTS::BinConfiguration>::__vallocate[abi:ne180100](a1, v3);
    v6 = std::initializer_list<CBBOLTS::BinConfiguration>::begin[abi:ne180100]((uint64_t)v13);
    v7 = std::initializer_list<CBBOLTS::BinConfiguration>::end[abi:ne180100](v13);
    v4 = std::initializer_list<CBBOLTS::BinConfiguration>::size[abi:ne180100]((uint64_t)v13);
    std::vector<CBBOLTS::BinConfiguration>::__construct_at_end<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>((uint64_t)a1, v6, v7, v4);
  }
  std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::__complete[abi:ne180100]((uint64_t)v10);
  std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v10);
  return v14;
}

uint64_t CBBOLTS::loadModel(CBBOLTS *this)
{
  NSURL *v1;
  NSObject *v3;
  NSObject *v4;
  os_signpost_type_t v5;
  os_signpost_id_t v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  os_signpost_type_t v10;
  os_signpost_id_t spid;
  uint64_t v12;
  NSObject *v13;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v17;
  uint8_t v19[8];
  unint64_t v20;
  char v21;
  NSObject *v22;
  uint8_t v23[8];
  unint64_t v24;
  char v25;
  NSObject *v26;
  uint8_t v27[7];
  char v28;
  NSObject *v29;
  CBBOLTS *v30;
  char v31;
  uint8_t v32[24];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v30 = this;
  if (!*((_QWORD *)this + 5))
  {
    v29 = 0;
    if (*((_QWORD *)this + 1))
    {
      v17 = *((_QWORD *)this + 1);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v17 = inited;
    }
    v29 = v17;
    v28 = 1;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      log = v29;
      type = v28;
      __os_log_helper_16_0_0(v27);
      _os_log_impl(&dword_1B5291000, log, type, "Loading BOLTS ML model.", v27, 2u);
    }
    v26 = 0;
    if (*((_QWORD *)this + 1))
    {
      v13 = *((_QWORD *)this + 1);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v12 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v12 = init_default_corebrightness_log();
      v13 = v12;
    }
    v26 = v13;
    v25 = 1;
    v24 = 0xEEEEB0B5B2B2EEEELL;
    if (os_signpost_enabled(v13))
    {
      v9 = v26;
      v10 = v25;
      spid = v24;
      __os_log_helper_16_0_0(v23);
      _os_signpost_emit_with_name_impl(&dword_1B5291000, v9, v10, spid, "LoadBOLTSModel", (const char *)&unk_1B546AB41, v23, 2u);
    }
    *((_QWORD *)this + 5) = CBBOLTS::initializeMLABModelFromURL(*((CBBOLTS **)this + 6), v1);
    v22 = 0;
    if (*((_QWORD *)this + 1))
    {
      v8 = *((_QWORD *)this + 1);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v7 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v7 = init_default_corebrightness_log();
      v8 = v7;
    }
    v22 = v8;
    v21 = 2;
    v20 = 0xEEEEB0B5B2B2EEEELL;
    if (os_signpost_enabled(v8))
    {
      v4 = v22;
      v5 = v21;
      v6 = v20;
      __os_log_helper_16_0_0(v19);
      _os_signpost_emit_with_name_impl(&dword_1B5291000, v4, v5, v6, "LoadBOLTSModel", (const char *)&unk_1B546AB41, v19, 2u);
    }
  }
  if (*((_QWORD *)this + 5))
  {
    v31 = 1;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v3 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v3 = init_default_corebrightness_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_64((uint64_t)v32, *((_QWORD *)this + 6));
      _os_log_error_impl(&dword_1B5291000, v3, OS_LOG_TYPE_ERROR, "Failed to create model using URL %@", v32, 0xCu);
    }
    v31 = 0;
  }
  return v31 & 1;
}

MLAB *CBBOLTS::initializeMLABModelFromURL(CBBOLTS *this, NSURL *a2)
{
  MLAB *v2;
  NSObject *inited;
  MLAB *v5;
  id v6;
  uint64_t v7;
  CBBOLTS *v8;
  uint8_t v10[24];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v8 = this;
  v7 = 0;
  v6 = objc_alloc_init((Class)getMLModelConfigurationClass());
  objc_msgSend(v6, "setComputeUnits:", 0);
  v2 = [MLAB alloc];
  v5 = -[MLAB initWithContentsOfURL:configuration:error:](v2, "initWithContentsOfURL:configuration:error:", v8, v6, &v7);

  if (v5 && !v7)
    return v5;
  if (_COREBRIGHTNESS_LOG_DEFAULT)
    inited = _COREBRIGHTNESS_LOG_DEFAULT;
  else
    inited = init_default_corebrightness_log();
  if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
  {
    __os_log_helper_16_2_1_8_64((uint64_t)v10, v7);
    _os_log_error_impl(&dword_1B5291000, inited, OS_LOG_TYPE_ERROR, "Error during model initialisation: %@", v10, 0xCu);
  }

  return 0;
}

void CBBOLTS::unloadModel(dispatch_source_t *this, float a2)
{
  dispatch_time_t v2;
  NSObject *v3;
  NSObject *source;
  uint64_t handler;
  int v7;
  int v8;
  void (*v9)(uint64_t);
  void *v10;
  dispatch_source_t *v11;
  float v12;
  dispatch_source_t *v13;

  v13 = this;
  v12 = a2;
  if (this[4])
  {
    dispatch_source_cancel(this[4]);
    dispatch_release(this[4]);
    this[4] = 0;
  }
  if (this[2])
  {
    this[4] = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, this[2]);
    source = this[4];
    v2 = dispatch_time(0, (uint64_t)(float)(v12 * 1000000000.0));
    dispatch_source_set_timer(source, v2, 0xFFFFFFFFFFFFFFFFLL, 0);
    v3 = this[4];
    handler = MEMORY[0x1E0C809B0];
    v7 = -1073741824;
    v8 = 0;
    v9 = ___ZN7CBBOLTS11unloadModelEf_block_invoke;
    v10 = &__block_descriptor_40_e5_v8__0l;
    v11 = this;
    dispatch_source_set_event_handler(v3, &handler);
    dispatch_resume(this[4]);
  }
}

void ___ZN7CBBOLTS11unloadModelEf_block_invoke(uint64_t a1)
{
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v4;
  uint64_t v5;
  uint8_t v6[7];
  char v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;

  v10 = a1;
  v9 = a1;
  v5 = *(_QWORD *)(a1 + 32);
  dispatch_source_cancel(*(dispatch_source_t *)(v5 + 32));
  dispatch_release(*(dispatch_object_t *)(v5 + 32));
  *(_QWORD *)(v5 + 32) = 0;
  if (*(_QWORD *)(v5 + 40))
  {
    v8 = 0;
    if (*(_QWORD *)(v5 + 8))
    {
      v4 = *(NSObject **)(v5 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v4 = inited;
    }
    v8 = v4;
    v7 = 1;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      log = v8;
      type = v7;
      __os_log_helper_16_0_0(v6);
      _os_log_impl(&dword_1B5291000, log, type, "Unloading BOLTS ML model.", v6, 2u);
    }

    *(_QWORD *)(v5 + 40) = 0;
  }
}

uint64_t CBBOLTS::compileModel(CBBOLTS *this, NSString *a2)
{
  dispatch_time_t v2;
  NSObject *inited;
  NSObject *dsema;
  uint64_t v6;
  void *MLModelClass;
  NSObject *log;
  os_log_type_t type;
  NSObject *v10;
  intptr_t v11;
  uint64_t v12;
  int v13;
  int v14;
  intptr_t (*v15)(uint64_t, void *, void *);
  void *v16;
  dispatch_semaphore_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  int v22;
  int v23;
  void (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  int v29;
  int v30;
  void (*v31)(uint64_t, uint64_t);
  void (*v32)(uint64_t);
  uint64_t v33;
  uint8_t v34[15];
  char v35;
  NSObject *v36;
  dispatch_semaphore_t v37;
  CBBOLTS *v38;
  uint64_t v39;
  uint8_t v40[24];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v38 = this;
  v37 = dispatch_semaphore_create(0);
  if (v37)
  {
    v27 = 0;
    v28 = &v27;
    v29 = 1375731712;
    v30 = 48;
    v31 = __Block_byref_object_copy__3;
    v32 = __Block_byref_object_dispose__3;
    v33 = 0;
    v20 = 0;
    v21 = &v20;
    v22 = 1375731712;
    v23 = 48;
    v24 = __Block_byref_object_copy__3;
    v25 = __Block_byref_object_dispose__3;
    v26 = 0;
    MLModelClass = (void *)getMLModelClass();
    v6 = objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:", v38);
    v12 = MEMORY[0x1E0C809B0];
    v13 = -1073741824;
    v14 = 0;
    v15 = ___ZN7CBBOLTS12compileModelEP8NSString_block_invoke;
    v16 = &unk_1E68EA308;
    v18 = &v27;
    v19 = &v20;
    v17 = v37;
    objc_msgSend(MLModelClass, "compileModelAtURL:completionHandler:", v6, &v12);
    dsema = v37;
    v2 = dispatch_time(0, 2000000000);
    v11 = dispatch_semaphore_wait(dsema, v2);
    if (!v28[5] || v21[5] || v11)
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
      {
        __os_log_helper_16_2_1_8_64((uint64_t)v40, v21[5]);
        _os_log_error_impl(&dword_1B5291000, inited, OS_LOG_TYPE_ERROR, "Failed to compile model: %@", v40, 0xCu);
      }

      v39 = 0;
    }
    else
    {

      v39 = v28[5];
    }
    _Block_object_dispose(&v20, 8);
    _Block_object_dispose(&v27, 8);
  }
  else
  {
    v36 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v10 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v10 = init_default_corebrightness_log();
    v36 = v10;
    v35 = 16;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      log = v36;
      type = v35;
      __os_log_helper_16_0_0(v34);
      _os_log_error_impl(&dword_1B5291000, log, type, "Failed to create model compilation semaphore", v34, 2u);
    }
    return 0;
  }
  return v39;
}

void sub_1B531F0F8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t getMLModelClass(void)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  unint64_t *(*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  int v10;
  int v11;
  void (*v12)(uint64_t, uint64_t);
  void (*v13)(uint64_t);
  unint64_t v14;

  v8 = 0;
  v9 = &v8;
  v10 = 1375731712;
  v11 = 48;
  v12 = __Block_byref_object_copy__3;
  v13 = __Block_byref_object_dispose__3;
  v14 = 0;
  v14 = std::atomic_load_explicit[abi:ne180100]<void *>(&getMLModelClass(void)::softClass, 0);
  if (!v9[5])
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = ___ZL15getMLModelClassv_block_invoke;
    v6 = &unk_1E68E9ED8;
    v7 = &v8;
    ___ZL15getMLModelClassv_block_invoke((uint64_t)&v2);
  }
  v1 = v9[5];
  _Block_object_dispose(&v8, 8);
  return v1;
}

intptr_t ___ZN7CBBOLTS12compileModelEP8NSString_block_invoke(uint64_t a1, void *a2, void *a3)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40) = a3;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t CBBOLTS::createFromUncompiledModelPath(CBBOLTS *this, NSString *a2)
{
  NSURL *v2;
  NSObject *inited;
  CBBOLTS *v5;
  uint8_t v6[24];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5 = (CBBOLTS *)CBBOLTS::compileModel(this, a2);
  if (_COREBRIGHTNESS_LOG_DEFAULT)
    inited = _COREBRIGHTNESS_LOG_DEFAULT;
  else
    inited = init_default_corebrightness_log();
  if (os_log_type_enabled(inited, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_1_8_64((uint64_t)v6, (uint64_t)v5);
    _os_log_debug_impl(&dword_1B5291000, inited, OS_LOG_TYPE_DEBUG, "MLAB path %@", v6, 0xCu);
  }
  return CBBOLTS::createUsingModelURL(v5, v2);
}

uint64_t CBBOLTS::makePrediction(uint64_t a1, uint64_t *a2, float a3)
{
  double v3;
  double v4;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  os_log_type_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  id v14;
  id v15;
  id v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  id v22;
  NSObject *v23;
  os_log_type_t v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  os_log_type_t v30;
  uint64_t v31;
  NSObject *v32;
  NSObject *log;
  os_log_type_t v34;
  uint64_t inited;
  NSObject *v36;
  double v38;
  uint8_t v39[15];
  os_log_type_t v40;
  os_log_t v41;
  int v42;
  os_log_type_t v43;
  os_log_t oslog;
  double Current;
  uint64_t v46;
  uint64_t v47;
  unint64_t j;
  id v49;
  id v50;
  id v51;
  unint64_t i;
  id v53;
  uint8_t v54[7];
  os_log_type_t v55;
  NSObject *v56;
  os_log_type_t v57;
  os_log_t v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[2];
  uint8_t v62[7];
  os_log_type_t v63;
  NSObject *v64;
  uint8_t v65[3];
  os_log_type_t type;
  NSObject *v67;
  uint64_t v68[3];
  float v69;
  uint64_t *v70;
  uint64_t v71;
  uint64_t v72;
  uint8_t v73[16];
  uint8_t v74[16];
  _QWORD v75[2];
  _QWORD v76[2];
  _QWORD v77[2];
  _QWORD v78[3];
  _QWORD v79[3];
  _QWORD v80[3];
  _QWORD v81[3];
  uint8_t v82[40];
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  v71 = a1;
  v70 = a2;
  v69 = a3;
  CBBOLTS::serializeBins(a2, v68);
  v67 = 0;
  if (*(_QWORD *)(a1 + 8))
  {
    v36 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v36 = inited;
  }
  v67 = v36;
  type = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    log = v67;
    v34 = type;
    __os_log_helper_16_0_0(v65);
    _os_log_impl(&dword_1B5291000, log, v34, "==== MLAB INPUT =====", v65, 2u);
  }
  v64 = 0;
  if (*(_QWORD *)(a1 + 8))
  {
    v32 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v31 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v31 = init_default_corebrightness_log();
    v32 = v31;
  }
  v64 = v32;
  v63 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    v29 = v64;
    v30 = v63;
    __os_log_helper_16_0_0(v62);
    _os_log_impl(&dword_1B5291000, v29, v30, "Lux Nits Timestamp", v62, 2u);
  }
  v61[1] = v68;
  v61[0] = std::vector<AAB::CurveUpdate>::begin[abi:ne180100](v68);
  v60 = std::vector<AAB::CurveUpdate>::end[abi:ne180100]((uint64_t)v68);
  while (std::operator!=[abi:ne180100]<AAB::CurveUpdate *>((uint64_t)v61, (uint64_t)&v60))
  {
    v59 = std::__wrap_iter<AAB::CurveUpdate *>::operator*[abi:ne180100]((uint64_t)v61);
    v58 = 0;
    if (*(_QWORD *)(a1 + 8))
    {
      v28 = *(NSObject **)(a1 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v27 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v27 = init_default_corebrightness_log();
      v28 = v27;
    }
    v58 = v28;
    v57 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v82, COERCE__INT64(*(float *)v59), COERCE__INT64(*(float *)(v59 + 4)), *(_QWORD *)(v59 + 8));
      _os_log_impl(&dword_1B5291000, v58, v57, "%f %f %lld", v82, 0x20u);
    }
    std::__wrap_iter<AAB::CurveUpdate *>::operator++[abi:ne180100](v61);
  }
  v56 = 0;
  if (*(_QWORD *)(a1 + 8))
  {
    v26 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v25 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v25 = init_default_corebrightness_log();
    v26 = v25;
  }
  v56 = v26;
  v55 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    v23 = v56;
    v24 = v55;
    __os_log_helper_16_0_0(v54);
    _os_log_impl(&dword_1B5291000, v23, v24, "=====================", v54, 2u);
  }
  v22 = objc_alloc((Class)getMLMultiArrayClass());
  v81[0] = &unk_1E6916790;
  v81[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", std::vector<AAB::CurveUpdate>::size[abi:ne180100](v68));
  v81[2] = &unk_1E69167A8;
  v53 = (id)objc_msgSend(v22, "initWithShape:dataType:error:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v81, 3), 65568, 0);
  for (i = 0; i < std::vector<AAB::CurveUpdate>::size[abi:ne180100](v68); ++i)
  {
    v20 = (void *)MEMORY[0x1E0CB37E8];
    LODWORD(v3) = *(_DWORD *)std::vector<AAB::CurveUpdate>::operator[][abi:ne180100](v68, i);
    v21 = objc_msgSend(v20, "numberWithFloat:", v3);
    v80[0] = &unk_1E69167C0;
    v80[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", i);
    v80[2] = &unk_1E69167C0;
    objc_msgSend(v53, "setObject:forKeyedSubscript:", v21, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v80, 3));
    v18 = (void *)MEMORY[0x1E0CB37E8];
    LODWORD(v4) = *(_DWORD *)(std::vector<AAB::CurveUpdate>::operator[][abi:ne180100](v68, i) + 4);
    v19 = objc_msgSend(v18, "numberWithFloat:", v4);
    v79[0] = &unk_1E69167C0;
    v79[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", i);
    v79[2] = &unk_1E6916790;
    objc_msgSend(v53, "setObject:forKeyedSubscript:", v19, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v79, 3));
    v17 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", *(_QWORD *)(std::vector<AAB::CurveUpdate>::operator[][abi:ne180100](v68, i) + 8));
    v78[0] = &unk_1E69167C0;
    v78[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", i);
    v78[2] = &unk_1E69167D8;
    objc_msgSend(v53, "setObject:forKeyedSubscript:", v17, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v78, 3));
  }
  v16 = objc_alloc((Class)getMLMultiArrayClass());
  v77[0] = &unk_1E6916790;
  v77[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", std::vector<AAB::CurveUpdate>::size[abi:ne180100](v68));
  v51 = (id)objc_msgSend(v16, "initWithShape:dataType:error:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v77, 2), 65568, 0);
  v15 = objc_alloc((Class)getMLMultiArrayClass());
  v76[0] = &unk_1E6916790;
  v76[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", std::vector<AAB::CurveUpdate>::size[abi:ne180100](v68));
  v50 = (id)objc_msgSend(v15, "initWithShape:dataType:error:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v76, 2), 65568, 0);
  v14 = objc_alloc((Class)getMLMultiArrayClass());
  v75[0] = &unk_1E6916790;
  v75[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", std::vector<AAB::CurveUpdate>::size[abi:ne180100](v68));
  v49 = (id)objc_msgSend(v14, "initWithShape:dataType:error:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v75, 2), 65568, 0);
  for (j = 0; j < std::vector<AAB::CurveUpdate>::size[abi:ne180100](v68); ++j)
  {
    objc_msgSend(v51, "setObject:atIndexedSubscript:", &unk_1E69167C0, j);
    objc_msgSend(v50, "setObject:atIndexedSubscript:", &unk_1E69167C0, j);
    objc_msgSend(v49, "setObject:atIndexedSubscript:", &unk_1E69167C0, j);
  }
  v47 = 0;
  v46 = 0;
  Current = CFAbsoluteTimeGetCurrent();
  if ((CBBOLTS::loadModel((CBBOLTS *)a1) & 1) != 0)
  {
    v46 = objc_msgSend(*(id *)(a1 + 40), "predictionFromInput_x:target_lux:target_nits:target_weight:error:", v53, v50, v49, v51, &v47);
    if (v47)
    {
      oslog = 0;
      if (*(_QWORD *)(a1 + 8))
      {
        v13 = *(NSObject **)(a1 + 8);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v12 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v12 = init_default_corebrightness_log();
        v13 = v12;
      }
      oslog = v13;
      v43 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        __os_log_helper_16_2_1_8_64((uint64_t)v74, v47);
        _os_log_error_impl(&dword_1B5291000, oslog, v43, "Failed to make a prediction: %@", v74, 0xCu);
      }
      v72 = 0;
      v42 = 1;
      goto LABEL_71;
    }
  }
  else
  {
    v41 = 0;
    if (*(_QWORD *)(a1 + 8))
    {
      v11 = *(NSObject **)(a1 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v10 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v10 = init_default_corebrightness_log();
      v11 = v10;
    }
    v41 = v11;
    v40 = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v8 = v41;
      v9 = v40;
      __os_log_helper_16_0_0(v39);
      _os_log_error_impl(&dword_1B5291000, v8, v9, "Failed to load model.", v39, 2u);
    }
  }
  CBBOLTS::unloadModel((dispatch_source_t *)a1, v69);
  v38 = CFAbsoluteTimeGetCurrent();
  if (*(_QWORD *)(a1 + 8))
  {
    v7 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v6 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v6 = init_default_corebrightness_log();
    v7 = v6;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v73, COERCE__INT64(v38 - Current));
    _os_log_impl(&dword_1B5291000, v7, OS_LOG_TYPE_INFO, "Loading ML model + prediction took %f seconds", v73, 0xCu);
  }
  v72 = v46;
  v42 = 1;
LABEL_71:
  std::vector<AAB::CurveUpdate>::~vector[abi:ne180100](v68);
  return v72;
}

void sub_1B53202A0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

BOOL std::operator!=[abi:ne180100]<AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  return !std::operator==[abi:ne180100]<AAB::CurveUpdate *>(a1, a2);
}

uint64_t std::__wrap_iter<AAB::CurveUpdate *>::operator*[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

_QWORD *std::__wrap_iter<AAB::CurveUpdate *>::operator++[abi:ne180100](_QWORD *result)
{
  *result += 16;
  return result;
}

uint64_t getMLMultiArrayClass(void)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  unint64_t *(*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  int v10;
  int v11;
  void (*v12)(uint64_t, uint64_t);
  void (*v13)(uint64_t);
  unint64_t v14;

  v8 = 0;
  v9 = &v8;
  v10 = 1375731712;
  v11 = 48;
  v12 = __Block_byref_object_copy__3;
  v13 = __Block_byref_object_dispose__3;
  v14 = 0;
  v14 = std::atomic_load_explicit[abi:ne180100]<void *>(&getMLMultiArrayClass(void)::softClass, 0);
  if (!v9[5])
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = ___ZL20getMLMultiArrayClassv_block_invoke;
    v6 = &unk_1E68E9ED8;
    v7 = &v8;
    ___ZL20getMLMultiArrayClassv_block_invoke((uint64_t)&v2);
  }
  v1 = v9[5];
  _Block_object_dispose(&v8, 8);
  return v1;
}

uint64_t std::vector<AAB::CurveUpdate>::size[abi:ne180100](_QWORD *a1)
{
  return (a1[1] - *a1) / 16;
}

uint64_t std::vector<AAB::CurveUpdate>::operator[][abi:ne180100](_QWORD *a1, uint64_t a2)
{
  return *a1 + 16 * a2;
}

uint64_t *CBBOLTS::UpdateCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  CBBOLTS::Bin *v4;
  void *v5;
  uint64_t v7;
  NSObject *v8;
  void *context;
  NSObject *v10;
  os_log_type_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  unint64_t v16;
  NSObject *v17;
  os_log_type_t v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v24;
  void *Prediction;
  uint8_t v27[7];
  os_log_type_t v28;
  os_log_t v29;
  os_log_type_t v30;
  os_log_t oslog;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[4];
  unint64_t i;
  uint8_t v37[7];
  os_log_type_t v38;
  NSObject *v39;
  uint8_t v40[3];
  char v41;
  NSObject *v42;
  uint64_t v43[3];
  _DWORD *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint8_t v48[96];
  uint8_t v49[56];
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v47 = a1;
  v46 = a2;
  v45 = a3;
  v44 = a4;
  CBBOLTS::binUpdates(a2, (uint64_t *)(a1 + 56), v43);
  v42 = 0;
  if (*(_QWORD *)(a1 + 8))
  {
    v24 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v24 = inited;
  }
  v42 = v24;
  v41 = 1;
  if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
  {
    log = v42;
    type = v41;
    __os_log_helper_16_0_0(v40);
    _os_log_impl(&dword_1B5291000, log, type, "----- Binning -----", v40, 2u);
  }
  v39 = 0;
  if (*(_QWORD *)(a1 + 8))
  {
    v20 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v19 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v19 = init_default_corebrightness_log();
    v20 = v19;
  }
  v39 = v20;
  v38 = OS_LOG_TYPE_INFO;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
  {
    v17 = v39;
    v18 = v38;
    __os_log_helper_16_0_0(v37);
    _os_log_impl(&dword_1B5291000, v17, v18, "Bin Lux Nits Timestamp", v37, 2u);
  }
  for (i = 0; ; ++i)
  {
    v16 = i;
    if (v16 >= std::vector<CBBOLTS::Bin>::size[abi:ne180100](v43))
      break;
    v4 = (CBBOLTS::Bin *)std::vector<CBBOLTS::Bin>::operator[][abi:ne180100](v43, i);
    CBBOLTS::Bin::updates(v4, v35);
    v35[3] = v35;
    v34 = std::list<AAB::CurveUpdate>::begin[abi:ne180100]((uint64_t)v35);
    v33 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
    while (std::operator!=[abi:ne180100](&v34, &v33))
    {
      v32 = std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
      oslog = 0;
      if (*(_QWORD *)(a1 + 8))
      {
        v15 = *(NSObject **)(a1 + 8);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v14 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v14 = init_default_corebrightness_log();
        v15 = v14;
      }
      oslog = v15;
      v30 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v49, i, COERCE__INT64(*(float *)v32), COERCE__INT64(*(float *)(v32 + 4)), *(_QWORD *)(v32 + 8));
        _os_log_impl(&dword_1B5291000, oslog, v30, "%lu %f %f %lld", v49, 0x2Au);
      }
      std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v34);
    }
    std::list<AAB::CurveUpdate>::~list((uint64_t)v35);
  }
  v29 = 0;
  if (*(_QWORD *)(a1 + 8))
  {
    v13 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v12 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v12 = init_default_corebrightness_log();
    v13 = v12;
  }
  v29 = v13;
  v28 = OS_LOG_TYPE_INFO;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    v10 = v29;
    v11 = v28;
    __os_log_helper_16_0_0(v27);
    _os_log_impl(&dword_1B5291000, v10, v11, "-------------------", v27, 2u);
  }
  v44[24] = 3;
  v5 = memcpy((void *)(a1 + 224), v44, 0x68uLL);
  context = (void *)MEMORY[0x1B5E4A8B0](v5);
  Prediction = (void *)CBBOLTS::makePrediction(a1, v43, 5.0);
  if (Prediction)
  {
    CBBOLTS::setCurveBasedOnModelPrediction(a1 + 224, (void *)objc_msgSend(Prediction, "LTM_output_E"), (void *)objc_msgSend(Prediction, "LTM_output_L"));
    *(_BYTE *)(a1 + 216) = 1;
    if (*(_QWORD *)(a1 + 8))
    {
      v8 = *(NSObject **)(a1 + 8);
    }
    else
    {
      v7 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v8 = v7;
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_9_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v48, COERCE__INT64(*(float *)(a1 + 224)), COERCE__INT64(*(float *)(a1 + 232)), COERCE__INT64(*(float *)(a1 + 240)), COERCE__INT64(*(float *)(a1 + 244)), COERCE__INT64(*(float *)(a1 + 228)), COERCE__INT64(*(float *)(a1 + 236)), COERCE__INT64(*(float *)(a1 + 248)), COERCE__INT64(*(float *)(a1 + 252)), COERCE__INT64(*(float *)(a1 + 308)));
      _os_log_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEFAULT, "User adjustment -> predict LTM curve: E0a %f, E0b %f, E1 %f, E2 %f, L0a %f, L0b %f, L1 %f, L2 %f, thirdSlope %f", v48, 0x5Cu);
    }
  }
  objc_autoreleasePoolPop(context);
  return std::vector<CBBOLTS::Bin>::~vector[abi:ne180100](v43);
}

void sub_1B5320C6C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t std::vector<CBBOLTS::Bin>::size[abi:ne180100](_QWORD *a1)
{
  return (a1[1] - *a1) / 48;
}

uint64_t std::vector<CBBOLTS::Bin>::operator[][abi:ne180100](_QWORD *a1, uint64_t a2)
{
  return *a1 + 48 * a2;
}

uint64_t __os_log_helper_16_0_4_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  return result;
}

uint64_t *CBBOLTS::UpdateCurveWithPrediction(uint64_t a1, uint64_t a2)
{
  CBBOLTS::Bin *v2;
  uint64_t v4;
  NSObject *v5;
  void *context;
  NSObject *v7;
  os_log_type_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  unint64_t v13;
  NSObject *v14;
  os_log_type_t v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v21;
  void *Prediction;
  uint8_t v24[7];
  os_log_type_t v25;
  os_log_t v26;
  os_log_type_t v27;
  os_log_t oslog;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD v32[4];
  unint64_t i;
  uint8_t v34[7];
  char v35;
  NSObject *v36;
  uint8_t v37[3];
  char v38;
  NSObject *v39;
  uint64_t v40[5];
  uint8_t v41[96];
  uint8_t v42[56];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v40[4] = a1;
  v40[3] = a2;
  CBBOLTS::binUpdates(a2, (uint64_t *)(a1 + 56), v40);
  v39 = 0;
  if (*(_QWORD *)(a1 + 8))
  {
    v21 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v21 = inited;
  }
  v39 = v21;
  v38 = 1;
  if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
  {
    log = v39;
    type = v38;
    __os_log_helper_16_0_0(v37);
    _os_log_impl(&dword_1B5291000, log, type, "----- Binning -----", v37, 2u);
  }
  v36 = 0;
  if (*(_QWORD *)(a1 + 8))
  {
    v17 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v16 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v16 = init_default_corebrightness_log();
    v17 = v16;
  }
  v36 = v17;
  v35 = 1;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    v14 = v36;
    v15 = v35;
    __os_log_helper_16_0_0(v34);
    _os_log_impl(&dword_1B5291000, v14, v15, "Bin Lux Nits Timestamp", v34, 2u);
  }
  for (i = 0; ; ++i)
  {
    v13 = i;
    if (v13 >= std::vector<CBBOLTS::Bin>::size[abi:ne180100](v40))
      break;
    v2 = (CBBOLTS::Bin *)std::vector<CBBOLTS::Bin>::operator[][abi:ne180100](v40, i);
    CBBOLTS::Bin::updates(v2, v32);
    v32[3] = v32;
    v31 = std::list<AAB::CurveUpdate>::begin[abi:ne180100]((uint64_t)v32);
    v30 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
    while (std::operator!=[abi:ne180100](&v31, &v30))
    {
      v29 = std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
      oslog = 0;
      if (*(_QWORD *)(a1 + 8))
      {
        v12 = *(NSObject **)(a1 + 8);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v11 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v11 = init_default_corebrightness_log();
        v12 = v11;
      }
      oslog = v12;
      v27 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v42, i, COERCE__INT64(*(float *)v29), COERCE__INT64(*(float *)(v29 + 4)), *(_QWORD *)(v29 + 8));
        _os_log_impl(&dword_1B5291000, oslog, v27, "%lu %f %f %lld", v42, 0x2Au);
      }
      std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v31);
    }
    std::list<AAB::CurveUpdate>::~list((uint64_t)v32);
  }
  v26 = 0;
  if (*(_QWORD *)(a1 + 8))
  {
    v10 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v9 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v9 = init_default_corebrightness_log();
    v10 = v9;
  }
  v26 = v10;
  v25 = OS_LOG_TYPE_INFO;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v7 = v26;
    v8 = v25;
    __os_log_helper_16_0_0(v24);
    _os_log_impl(&dword_1B5291000, v7, v8, "-------------------", v24, 2u);
  }
  context = (void *)MEMORY[0x1B5E4A8B0]();
  Prediction = (void *)CBBOLTS::makePrediction(a1, v40, 2.0);
  if (Prediction)
  {
    CBBOLTS::setCurveBasedOnModelPrediction(a1 + 224, (void *)objc_msgSend(Prediction, "LTM_output_E"), (void *)objc_msgSend(Prediction, "LTM_output_L"));
    *(_BYTE *)(a1 + 216) = 1;
    if (*(_QWORD *)(a1 + 8))
    {
      v5 = *(NSObject **)(a1 + 8);
    }
    else
    {
      v4 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v5 = v4;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_9_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v41, COERCE__INT64(*(float *)(a1 + 224)), COERCE__INT64(*(float *)(a1 + 232)), COERCE__INT64(*(float *)(a1 + 240)), COERCE__INT64(*(float *)(a1 + 244)), COERCE__INT64(*(float *)(a1 + 228)), COERCE__INT64(*(float *)(a1 + 236)), COERCE__INT64(*(float *)(a1 + 248)), COERCE__INT64(*(float *)(a1 + 252)), COERCE__INT64(*(float *)(a1 + 308)));
      _os_log_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEFAULT, "Restore from user updates sequence -> predict LTM curve: E0a %f, E0b %f, E1 %f, E2 %f, L0a %f, L0b %f, L1 %f, L2 %f, thirdSlope %f", v41, 0x5Cu);
    }
  }
  objc_autoreleasePoolPop(context);
  return std::vector<CBBOLTS::Bin>::~vector[abi:ne180100](v40);
}

void sub_1B5321510()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void CBBOLTS::UpdateCurves_Internal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;
  NSObject *v4;
  os_log_type_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  os_log_type_t v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v17;
  uint64_t block;
  int v20;
  int v21;
  uint64_t *(*v22)(uint64_t);
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint8_t v27[7];
  char v28;
  NSObject *v29;
  os_log_type_t v30;
  os_log_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[2];
  uint8_t v35[7];
  char v36;
  NSObject *v37;
  uint8_t v38[15];
  char v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint8_t v44[40];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v43 = a1;
  v42 = a2;
  v41 = a3;
  v40 = 0;
  if (*(_QWORD *)(a1 + 8))
  {
    v17 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v17 = inited;
  }
  v40 = v17;
  v39 = 1;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    log = v40;
    type = v39;
    __os_log_helper_16_0_0(v38);
    _os_log_impl(&dword_1B5291000, log, type, "+++++ User adjustments buffer +++++", v38, 2u);
  }
  v37 = 0;
  if (*(_QWORD *)(a1 + 8))
  {
    v13 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v12 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v12 = init_default_corebrightness_log();
    v13 = v12;
  }
  v37 = v13;
  v36 = 1;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    v10 = v37;
    v11 = v36;
    __os_log_helper_16_0_0(v35);
    _os_log_impl(&dword_1B5291000, v10, v11, "Lux Nits Timestamp", v35, 2u);
  }
  v34[1] = a1 + 88;
  v34[0] = std::list<AAB::CurveUpdate>::begin[abi:ne180100](a1 + 88);
  v33 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  while (std::operator!=[abi:ne180100](v34, &v33))
  {
    v32 = std::__list_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
    v31 = 0;
    if (*(_QWORD *)(a1 + 8))
    {
      v9 = *(NSObject **)(a1 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v8 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v8 = init_default_corebrightness_log();
      v9 = v8;
    }
    v31 = v9;
    v30 = OS_LOG_TYPE_INFO;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v44, COERCE__INT64(*(float *)v32), COERCE__INT64(*(float *)(v32 + 4)), *(_QWORD *)(v32 + 8));
      _os_log_impl(&dword_1B5291000, v31, v30, "%f %f %lld", v44, 0x20u);
    }
    std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)v34);
  }
  v29 = 0;
  if (*(_QWORD *)(a1 + 8))
  {
    v7 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v6 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v6 = init_default_corebrightness_log();
    v7 = v6;
  }
  v29 = v7;
  v28 = 1;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v4 = v29;
    v5 = v28;
    __os_log_helper_16_0_0(v27);
    _os_log_impl(&dword_1B5291000, v4, v5, "+++++++++++++++++++++++++++++++++++", v27, 2u);
  }
  v3 = *(NSObject **)(a1 + 16);
  block = MEMORY[0x1E0C809B0];
  v20 = -1073741824;
  v21 = 0;
  v22 = ___ZN7CBBOLTS21UpdateCurves_InternalERN3AAB5CurveEPS1__block_invoke;
  v23 = &__block_descriptor_56_e5_v8__0l;
  v24 = a1;
  v25 = v42;
  v26 = v41;
  dispatch_async(v3, &block);
}

uint64_t std::__list_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]()
{
  uint64_t v0;

  std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]();
  return std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100](v0);
}

uint64_t std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100](uint64_t result)
{
  *(_QWORD *)result = *(_QWORD *)(*(_QWORD *)result + 8);
  return result;
}

void CBBOLTS::UpdateCurve(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5, float a6)
{
  NSObject *v6;
  uint64_t block;
  int v9;
  int v10;
  void (*v11)(uint64_t);
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  float v22;

  v21 = __PAIR64__(LODWORD(a5), LODWORD(a4));
  v22 = a6;
  v20 = a1;
  v19 = a2;
  v18 = a3;
  if (*(_QWORD *)(a1 + 16))
  {
    v6 = *(NSObject **)(a1 + 16);
    block = MEMORY[0x1E0C809B0];
    v9 = -1073741824;
    v10 = 0;
    v11 = ___ZN7CBBOLTS11UpdateCurveEP3AABNS0_21CurveUpdateParametersERNS0_5CurveE_block_invoke;
    v12 = &__block_descriptor_68_e5_v8__0l;
    v13 = a1;
    v16 = v21;
    v17 = v22;
    v14 = v19;
    v15 = v18;
    dispatch_sync(v6, &block);
  }
}

void ___ZN7CBBOLTS11UpdateCurveEP3AABNS0_21CurveUpdateParametersERNS0_5CurveE_block_invoke(uint64_t a1)
{
  double v1;
  uint64_t v2;
  NSObject **v4;
  unint64_t v5;
  unint64_t LocalizedTimestamp;

  v4 = *(NSObject ***)(a1 + 32);
  LODWORD(v5) = *(_DWORD *)(a1 + 56);
  HIDWORD(v5) = *(_DWORD *)(a1 + 64);
  LocalizedTimestamp = getLocalizedTimestamp();
  CBBOLTS::addCurveUpdateToBuffer((uint64_t)v4, v5, LocalizedTimestamp);
  v2 = *(_QWORD *)(a1 + 56);
  LODWORD(v1) = v2;
  AAB::PreferenceUpdateCurveStrategy::UpdateCurve(v1, *((float *)&v2 + 1), *(float *)(a1 + 64), (uint64_t)v4, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  CBBOLTS::UpdateCurves_Internal((uint64_t)v4, *(_QWORD *)(a1 + 48), 0);
  CBBOLTS::saveBufferToPreferences(v4);
}

uint64_t getLocalizedTimestamp(void)
{
  uint64_t v0;
  double Current;

  Current = CFAbsoluteTimeGetCurrent();
  v0 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E0C99E80], "localTimeZone"), "secondsFromGMT");
  return (uint64_t)(Current + (double)v0 + *MEMORY[0x1E0C9ADF8]);
}

void CBBOLTS::saveBufferToPreferences(NSObject **this)
{
  NSObject *v1;
  uint64_t block;
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  CBBOLTS *v8;
  CBBOLTS *v9;

  v9 = (CBBOLTS *)this;
  if (this[2])
  {
    v1 = this[2];
    block = MEMORY[0x1E0C809B0];
    v4 = -1073741824;
    v5 = 0;
    v6 = ___ZNK7CBBOLTS23saveBufferToPreferencesEv_block_invoke;
    v7 = &__block_descriptor_40_e5_v8__0l;
    v8 = (CBBOLTS *)this;
    dispatch_async(v1, &block);
  }
}

void CBBOLTS::UpdateCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, float a6, float a7, float a8)
{
  NSObject *v8;
  uint64_t block;
  int v11;
  int v12;
  void (*v13)(uint64_t);
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  float v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  float v28;

  v27 = __PAIR64__(LODWORD(a7), LODWORD(a6));
  v28 = a8;
  v26 = a1;
  v25 = a2;
  v24 = a3;
  v23 = a4;
  v22 = a5;
  if (*(_QWORD *)(a1 + 16))
  {
    v8 = *(NSObject **)(a1 + 16);
    block = MEMORY[0x1E0C809B0];
    v11 = -1073741824;
    v12 = 0;
    v13 = ___ZN7CBBOLTS25UpdateCurveAndCappedCurveEP3AABNS0_21CurveUpdateParametersERNS0_5CurveERKNS0_8CurveCapES4__block_invoke;
    v14 = &__block_descriptor_84_e5_v8__0l;
    v15 = a1;
    v20 = v27;
    v21 = v28;
    v16 = v25;
    v17 = v24;
    v18 = v22;
    v19 = v23;
    dispatch_sync(v8, &block);
  }
}

void ___ZN7CBBOLTS25UpdateCurveAndCappedCurveEP3AABNS0_21CurveUpdateParametersERNS0_5CurveERKNS0_8CurveCapES4__block_invoke(uint64_t a1)
{
  double v1;
  uint64_t v2;
  uint64_t v3;
  CBBOLTS *v5;
  unint64_t v6;
  unint64_t LocalizedTimestamp;

  v5 = *(CBBOLTS **)(a1 + 32);
  LODWORD(v6) = *(_DWORD *)(a1 + 72);
  HIDWORD(v6) = *(_DWORD *)(a1 + 80);
  LocalizedTimestamp = getLocalizedTimestamp();
  CBBOLTS::addCurveUpdateToBuffer((uint64_t)v5, v6, LocalizedTimestamp);
  if (CBBOLTS::useBOLTS(v5))
  {
    v2 = *(_QWORD *)(a1 + 72);
    LODWORD(v1) = v2;
    AAB::PreferenceUpdateCurveStrategy::UpdateCurve(v1, *((float *)&v2 + 1), *(float *)(a1 + 80), (uint64_t)v5, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
    CBBOLTS::UpdateCurves_Internal((uint64_t)v5, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 72);
    LODWORD(v1) = v3;
    AAB::PreferenceUpdateCurveStrategy::UpdateCurveAndCappedCurve((uint64_t)v5, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(float **)(a1 + 64), *(_QWORD *)(a1 + 56), v1, *((float *)&v3 + 1), *(float *)(a1 + 80));
    *(_DWORD *)(*(_QWORD *)(a1 + 56) + 96) = 3;
    memcpy((char *)v5 + 224, *(const void **)(a1 + 56), 0x68uLL);
    memcpy((char *)v5 + 112, (char *)v5 + 224, 0x68uLL);
  }
  CBBOLTS::saveBufferToPreferences((NSObject **)v5);
}

BOOL CBBOLTS::useBOLTS(CBBOLTS *this)
{
  const char *v1;
  int v2;
  BOOL v4;
  uint64_t v5;
  BOOL v6;
  uint64_t inited;
  NSObject *v8;
  BOOL v9;
  BOOL v11;
  _QWORD v12[3];
  CBBOLTS::Bin *v13;
  uint64_t v14;
  _QWORD v15[2];
  int v16;
  uint64_t v17[3];
  BOOL v18;
  CBBOLTS *v19;
  uint8_t v20[24];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v19 = this;
  v18 = (unint64_t)std::list<AAB::CurveUpdate>::size[abi:ne180100]() > 5;
  CBBOLTS::binUpdates((uint64_t)this + 88, (uint64_t *)this + 7, v17);
  v16 = 0;
  v15[1] = v17;
  v15[0] = std::vector<CBBOLTS::Bin>::begin[abi:ne180100](v17);
  v14 = std::vector<CBBOLTS::Bin>::end[abi:ne180100]((uint64_t)v17);
  while (std::operator!=[abi:ne180100]<CBBOLTS::Bin *>((uint64_t)v15, (uint64_t)&v14))
  {
    v13 = (CBBOLTS::Bin *)std::__wrap_iter<CBBOLTS::Bin *>::operator*[abi:ne180100]((uint64_t)v15);
    CBBOLTS::Bin::updates(v13, v12);
    v9 = std::list<AAB::CurveUpdate>::size[abi:ne180100]() == 0;
    std::list<AAB::CurveUpdate>::~list((uint64_t)v12);
    if (!v9)
      ++v16;
    std::__wrap_iter<CBBOLTS::Bin *>::operator++[abi:ne180100](v15);
  }
  v11 = v16 > 2;
  if (*((_QWORD *)this + 1))
  {
    v8 = *((_QWORD *)this + 1);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v8 = inited;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 0;
    if (v18)
      v6 = v11;
    v1 = "Use";
    if (!v6)
      v1 = "Don't use";
    v5 = (uint64_t)v1;
    v2 = std::list<AAB::CurveUpdate>::size[abi:ne180100]();
    __os_log_helper_16_2_3_8_32_4_0_4_0((uint64_t)v20, v5, v2, v16);
    _os_log_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEFAULT, "%s the BOLTS curve update strategy. Num of adjustments = %d; Num of updated Bins = %d",
      v20,
      0x18u);
  }
  v4 = 0;
  if (v18)
    v4 = v11;
  std::vector<CBBOLTS::Bin>::~vector[abi:ne180100](v17);
  return v4;
}

void sub_1B532222C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

_QWORD *CBBOLTS::curveUpdates@<X0>(CBBOLTS *this@<X0>, _QWORD *a2@<X8>)
{
  return std::list<AAB::CurveUpdate>::list(a2, (uint64_t)this + 88);
}

_QWORD *std::list<AAB::CurveUpdate>::list(_QWORD *a1, uint64_t a2)
{
  std::list<AAB::CurveUpdate>::list(a1, a2);
  return a1;
}

{
  __n128 *v3;
  uint64_t v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;

  v9 = a1;
  v8 = a2;
  v10 = a1;
  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
  std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::select_on_container_copy_construction[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,void,void>();
  std::__list_imp<AAB::CurveUpdate>::__list_imp(a1, (uint64_t)&v7);
  v6 = std::list<AAB::CurveUpdate>::begin[abi:ne180100](v8);
  v5 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  while (std::operator!=[abi:ne180100](&v6, &v5))
  {
    v3 = (__n128 *)std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
    std::list<AAB::CurveUpdate>::push_back(a1, v3);
    std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v6);
  }
  return v10;
}

void CBBOLTS::SetCurveUpdates(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint64_t block;
  int v5;
  int v6;
  BOOL (*v7)(uint64_t);
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  std::list<AAB::CurveUpdate>::operator=(a1 + 88, a2);
  while ((unint64_t)std::list<AAB::CurveUpdate>::size[abi:ne180100]() > *(_QWORD *)(a1 + 80))
    std::list<AAB::CurveUpdate>::pop_front(a1 + 88);
  v2 = *(NSObject **)(a1 + 16);
  block = MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = ___ZN7CBBOLTS15SetCurveUpdatesERNSt3__14listIN3AAB11CurveUpdateENS0_9allocatorIS3_EEEE_block_invoke;
  v8 = &__block_descriptor_40_e5_v8__0l;
  v9 = a1;
  dispatch_async(v2, &block);
}

uint64_t std::list<AAB::CurveUpdate>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  if (a1 != a2)
  {
    std::__list_imp<AAB::CurveUpdate>::__copy_assign_alloc[abi:ne180100]();
    v5 = std::list<AAB::CurveUpdate>::begin[abi:ne180100](a2);
    v4 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
    std::list<AAB::CurveUpdate>::assign<std::__list_const_iterator<AAB::CurveUpdate,void *>>(a1, v5, v4);
  }
  return a1;
}

BOOL ___ZN7CBBOLTS15SetCurveUpdatesERNSt3__14listIN3AAB11CurveUpdateENS0_9allocatorIS3_EEEE_block_invoke(uint64_t a1)
{
  _BOOL8 result;
  CBBOLTS *v2;

  v2 = *(CBBOLTS **)(a1 + 32);
  if (CBBOLTS::useBOLTS(v2))
  {
    CBBOLTS::UpdateCurveWithPrediction((uint64_t)v2, (uint64_t)v2 + 88);
    memcpy((char *)v2 + 112, (char *)v2 + 224, 0x68uLL);
  }
  CBBOLTS::saveBufferToPreferences((NSObject **)v2);
  result = CBBOLTS::useBOLTS(v2);
  if (!result)
    *((_BYTE *)v2 + 216) = 0;
  return result;
}

uint64_t CBBOLTS::cappedCurve(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  char v4;
  uint64_t block;
  int v6;
  int v7;
  void **(*v8)(void **);
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  int v15;
  int v16;
  char v17;
  uint64_t v18;
  uint64_t v19;

  v19 = a1;
  v18 = a2;
  v13 = 0;
  v14 = &v13;
  v15 = 0x20000000;
  v16 = 32;
  v17 = 0;
  v2 = *(NSObject **)(a1 + 16);
  block = MEMORY[0x1E0C809B0];
  v6 = -1073741824;
  v7 = 0;
  v8 = ___ZN7CBBOLTS11cappedCurveERN3AAB5CurveE_block_invoke;
  v9 = &unk_1E68EA390;
  v11 = v19;
  v12 = a2;
  v10 = &v13;
  dispatch_sync(v2, &block);
  v4 = *((_BYTE *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  return v4 & 1;
}

void CBBOLTS::setCappedCurve(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v2 = *(NSObject **)(a1 + 16);
  v3 = MEMORY[0x1E0C809B0];
  v4 = -1073741824;
  v5 = 0;
  v6 = ___ZN7CBBOLTS14setCappedCurveERN3AAB5CurveE_block_invoke;
  v7 = &__block_descriptor_48_e5_v8__0l;
  v8 = v11;
  v9 = a2;
  dispatch_sync(v2, &v3);
}

void ___ZN7CBBOLTS14setCappedCurveERN3AAB5CurveE_block_invoke(uint64_t a1)
{
  uint64_t inited;
  NSObject *v2;
  uint64_t v3;
  uint8_t v4[104];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 32);
  memcpy((void *)(v3 + 112), *(const void **)(a1 + 40), 0x68uLL);
  *(_DWORD *)(v3 + 208) = 3;
  memcpy((void *)(v3 + 224), (const void *)(v3 + 112), 0x68uLL);
  if (*(_QWORD *)(v3 + 8))
  {
    v2 = *(NSObject **)(v3 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v2 = inited;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_9_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v4, COERCE__INT64(*(float *)(v3 + 112)), COERCE__INT64(*(float *)(v3 + 120)), COERCE__INT64(*(float *)(v3 + 128)), COERCE__INT64(*(float *)(v3 + 132)), COERCE__INT64(*(float *)(v3 + 116)), COERCE__INT64(*(float *)(v3 + 124)), COERCE__INT64(*(float *)(v3 + 136)), COERCE__INT64(*(float *)(v3 + 140)), COERCE__INT64(*(float *)(v3 + 196)));
    _os_log_impl(&dword_1B5291000, v2, OS_LOG_TYPE_DEFAULT, "Setting capped LTM curve: E0a %f, E0b %f, E1 %f, E2 %f, L0a %f, L0b %f, L1 %f, L2 %f, thirdSlope %f", v4, 0x5Cu);
  }
}

void CBBOLTS::preservePreferences(NSObject **this)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  CBBOLTS *v8;
  CBBOLTS *v9;

  v9 = (CBBOLTS *)this;
  v2 = this[2];
  v3 = MEMORY[0x1E0C809B0];
  v4 = -1073741824;
  v5 = 0;
  v6 = ___ZN7CBBOLTS19preservePreferencesEv_block_invoke;
  v7 = &__block_descriptor_40_e5_v8__0l;
  v8 = (CBBOLTS *)this;
  dispatch_async(v2, &v3);
}

void ___ZN7CBBOLTS19preservePreferencesEv_block_invoke(uint64_t a1)
{
  uint64_t inited;
  NSObject *v2;
  uint64_t v3;
  uint8_t v4[104];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 32);
  memcpy((void *)(v3 + 112), (const void *)(v3 + 224), 0x68uLL);
  if (*(_QWORD *)(v3 + 8))
  {
    v2 = *(NSObject **)(v3 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v2 = inited;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_9_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v4, COERCE__INT64(*(float *)(v3 + 224)), COERCE__INT64(*(float *)(v3 + 232)), COERCE__INT64(*(float *)(v3 + 240)), COERCE__INT64(*(float *)(v3 + 244)), COERCE__INT64(*(float *)(v3 + 228)), COERCE__INT64(*(float *)(v3 + 236)), COERCE__INT64(*(float *)(v3 + 248)), COERCE__INT64(*(float *)(v3 + 252)), COERCE__INT64(*(float *)(v3 + 308)));
    _os_log_impl(&dword_1B5291000, v2, OS_LOG_TYPE_DEFAULT, "Preserve current LTM curve: E0a %f, E0b %f, E1 %f, E2 %f, L0a %f, L0b %f, L1 %f, L2 %f, thirdSlope %f", v4, 0x5Cu);
  }
}

uint64_t __os_log_helper_16_2_3_8_32_4_0_4_0(uint64_t result, uint64_t a2, int a3, int a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 4;
  *(_DWORD *)(result + 20) = a4;
  return result;
}

void CBBOLTS::Reset(NSObject **this)
{
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v4;
  uint8_t v6[15];
  os_log_type_t v7;
  NSObject *v8;
  CBBOLTS *v9;

  v9 = (CBBOLTS *)this;
  v8 = 0;
  if (this[1])
  {
    v4 = this[1];
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v4 = inited;
  }
  v8 = v4;
  v7 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    log = v8;
    type = v7;
    __os_log_helper_16_0_0(v6);
    _os_log_impl(&dword_1B5291000, log, type, "Reseting buffer", v6, 2u);
  }
  CBBOLTS::resetBuffer(this);
}

void CBBOLTS::resetBuffer(NSObject **this)
{
  NSObject *v1;
  uint64_t block;
  int v4;
  int v5;
  uint64_t (*v6)(uint64_t);
  void *v7;
  CBBOLTS *v8;
  CBBOLTS *v9;

  v9 = (CBBOLTS *)this;
  if (this[2])
  {
    v1 = this[2];
    block = MEMORY[0x1E0C809B0];
    v4 = -1073741824;
    v5 = 0;
    v6 = ___ZN7CBBOLTS11resetBufferEv_block_invoke;
    v7 = &__block_descriptor_40_e5_v8__0l;
    v8 = (CBBOLTS *)this;
    dispatch_sync(v1, &block);
  }
}

uint64_t CBBOLTS::switchModel(NSObject **this, NSURL *a2)
{
  NSObject *v2;
  uint64_t block;
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t);
  void *v9;
  MLAB *v10;
  CBBOLTS *v11;
  MLAB *v12;
  CBBOLTS *v13;
  CBBOLTS *v14;
  char v15;

  v14 = (CBBOLTS *)this;
  v13 = (CBBOLTS *)a2;
  if (this[2])
  {
    v12 = CBBOLTS::initializeMLABModelFromURL(v13, a2);
    if (v12)
    {
      v2 = this[2];
      block = MEMORY[0x1E0C809B0];
      v6 = -1073741824;
      v7 = 0;
      v8 = ___ZN7CBBOLTS11switchModelEP5NSURL_block_invoke;
      v9 = &unk_1E68EA3D8;
      v11 = (CBBOLTS *)this;
      v10 = v12;
      dispatch_sync(v2, &block);
      v15 = 1;
    }
    else
    {
      v15 = 0;
    }
  }
  else
  {
    v15 = 0;
  }
  return v15 & 1;
}

uint64_t ___ZN7CBBOLTS11switchModelEP5NSURL_block_invoke(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 40);

  result = a1;
  *(_QWORD *)(v3 + 40) = *(_QWORD *)(a1 + 32);
  return result;
}

uint64_t ___ZN7CBBOLTS11resetBufferEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  CFStringRef *v3;
  CFStringRef *v4;
  uint64_t v5[4];

  v5[3] = a1;
  v5[2] = a1;
  v2 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v2 + 216) = 0;
  std::initializer_list<AAB::CurveUpdate>::initializer_list[abi:ne180100](v5);
  std::list<AAB::CurveUpdate>::operator=[abi:ne180100](v2 + 88, v5[0], v5[1]);
  v3 = (CFStringRef *)MEMORY[0x1E0C9B260];
  v4 = (CFStringRef *)MEMORY[0x1E0C9B230];
  CFPreferencesSetValue(CFSTR("BOLTSBuffer"), 0, CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B230]);
  return CFPreferencesSynchronize(CFSTR("com.apple.CoreBrightness"), *v3, *v4);
}

_QWORD *std::initializer_list<AAB::CurveUpdate>::initializer_list[abi:ne180100](_QWORD *a1)
{
  std::initializer_list<AAB::CurveUpdate>::initializer_list[abi:ne180100](a1);
  return a1;
}

uint64_t std::list<AAB::CurveUpdate>::operator=[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 *v3;
  __n128 *v5;
  _QWORD v7[2];

  v7[0] = a2;
  v7[1] = a3;
  v5 = (__n128 *)std::initializer_list<AAB::CurveUpdate>::begin[abi:ne180100]((uint64_t)v7);
  v3 = (__n128 *)std::initializer_list<AAB::CurveUpdate>::end[abi:ne180100](v7);
  std::list<AAB::CurveUpdate>::assign<AAB::CurveUpdate const*>(a1, v5, v3);
  return a1;
}

uint64_t getMLModelConfigurationClass(void)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  unint64_t *(*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  int v10;
  int v11;
  void (*v12)(uint64_t, uint64_t);
  void (*v13)(uint64_t);
  unint64_t v14;

  v8 = 0;
  v9 = &v8;
  v10 = 1375731712;
  v11 = 48;
  v12 = __Block_byref_object_copy__3;
  v13 = __Block_byref_object_dispose__3;
  v14 = 0;
  v14 = std::atomic_load_explicit[abi:ne180100]<void *>(&getMLModelConfigurationClass(void)::softClass, 0);
  if (!v9[5])
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = ___ZL28getMLModelConfigurationClassv_block_invoke;
    v6 = &unk_1E68E9ED8;
    v7 = &v8;
    ___ZL28getMLModelConfigurationClassv_block_invoke((uint64_t)&v2);
  }
  v1 = v9[5];
  _Block_object_dispose(&v8, 8);
  return v1;
}

void ___ZNK7CBBOLTS23saveBufferToPreferencesEv_block_invoke(uint64_t a1)
{
  double v1;
  double v2;
  CFStringRef *v3;
  CFStringRef *v4;
  void *v5;
  void *context;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];
  CFPropertyListRef v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[3];
  _QWORD v15[4];

  v15[3] = *MEMORY[0x1E0C80C00];
  v13 = a1;
  v12 = a1;
  v7 = *(_QWORD *)(a1 + 32);
  context = (void *)MEMORY[0x1B5E4A8B0]();
  v11 = (CFPropertyListRef)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v10[1] = v7 + 88;
  v10[0] = std::list<AAB::CurveUpdate>::begin[abi:ne180100](v7 + 88);
  v9 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  while (std::operator!=[abi:ne180100](v10, &v9))
  {
    v8 = std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
    v5 = (void *)v11;
    v14[0] = CFSTR("Lux");
    LODWORD(v1) = *(_DWORD *)v8;
    v15[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v1);
    v14[1] = CFSTR("Nits");
    LODWORD(v2) = *(_DWORD *)(v8 + 4);
    v15[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v2);
    v14[2] = CFSTR("Timestamp");
    v15[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", *(_QWORD *)(v8 + 8));
    objc_msgSend(v5, "addObject:", objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v15, v14, 3));
    std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)v10);
  }
  v3 = (CFStringRef *)MEMORY[0x1E0C9B260];
  v4 = (CFStringRef *)MEMORY[0x1E0C9B230];
  CFPreferencesSetValue(CFSTR("BOLTSBuffer"), v11, CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B230]);
  CFPreferencesSynchronize(CFSTR("com.apple.CoreBrightness"), *v3, *v4);
  objc_autoreleasePoolPop(context);
}

void CBBOLTS::loadBufferFromPreferences(NSObject **this)
{
  NSObject *v1;
  uint64_t block;
  int v4;
  int v5;
  uint64_t *(*v6)(uint64_t);
  void *v7;
  CBBOLTS *v8;
  CBBOLTS *v9;

  v9 = (CBBOLTS *)this;
  if (this[2])
  {
    v1 = this[2];
    block = MEMORY[0x1E0C809B0];
    v4 = -1073741824;
    v5 = 0;
    v6 = ___ZN7CBBOLTS25loadBufferFromPreferencesEv_block_invoke;
    v7 = &__block_descriptor_40_e5_v8__0l;
    v8 = (CBBOLTS *)this;
    dispatch_async(v1, &block);
  }
}

void ___ZN7CBBOLTS25loadBufferFromPreferencesEv_block_invoke_2(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  float v4;
  float v5;
  uint64_t inited;
  NSObject *v7;
  NSObject *log;
  os_log_type_t type;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  __n128 v13;
  os_log_type_t v14;
  os_log_t oslog;
  uint8_t v16[15];
  char v17;
  NSObject *v18;
  uint64_t v19;
  float v20;
  float v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  id v25;
  uint64_t v26;
  uint8_t v27[40];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v26 = a1;
  v25 = a2;
  v24 = a3;
  v23 = a4;
  v22 = a1;
  v12 = *(_QWORD *)(a1 + 32);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v21 = 0.0;
    v20 = 0.0;
    v19 = -1;
    objc_msgSend(v25, "objectForKeyedSubscript:", CFSTR("Lux"));
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0
      && (objc_msgSend(v25, "objectForKeyedSubscript:", CFSTR("Nits")),
          objc_opt_class(),
          (objc_opt_isKindOfClass() & 1) != 0)
      && (objc_msgSend(v25, "objectForKeyedSubscript:", CFSTR("Timestamp")),
          objc_opt_class(),
          (objc_opt_isKindOfClass() & 1) != 0))
    {
      objc_msgSend((id)objc_msgSend(v25, "objectForKeyedSubscript:", CFSTR("Lux")), "floatValue");
      v21 = v4;
      objc_msgSend((id)objc_msgSend(v25, "objectForKeyedSubscript:", CFSTR("Nits")), "floatValue");
      v20 = v5;
      v19 = objc_msgSend((id)objc_msgSend(v25, "objectForKeyedSubscript:", CFSTR("Timestamp")), "longLongValue");
      oslog = 0;
      if (*(_QWORD *)(v12 + 8))
      {
        v7 = *(NSObject **)(v12 + 8);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v7 = inited;
      }
      oslog = v7;
      v14 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v27, COERCE__INT64(v21), COERCE__INT64(v20), v19);
        _os_log_debug_impl(&dword_1B5291000, oslog, v14, "Adding curve update from preferences: %f %f %lld", v27, 0x20u);
      }
      v13.n128_u64[0] = __PAIR64__(LODWORD(v20), LODWORD(v21));
      v13.n128_u64[1] = v19;
      std::list<AAB::CurveUpdate>::push_back((_QWORD *)(v12 + 88), &v13);
    }
    else
    {
      v18 = 0;
      if (*(_QWORD *)(v12 + 8))
      {
        v11 = *(NSObject **)(v12 + 8);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v10 = init_default_corebrightness_log();
        v11 = v10;
      }
      v18 = v11;
      v17 = 16;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        log = v18;
        type = v17;
        __os_log_helper_16_0_0(v16);
        _os_log_error_impl(&dword_1B5291000, log, type, "Wrongly formatted BOLTS buffer", v16, 2u);
      }
    }
  }
}

uint64_t AAB::UpdateCurveStrategy::UpdateAlternativeCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __n128 a6, __n128 a7, __n128 a8)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __n128, __n128, __n128))(*(_QWORD *)a1 + 32))(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t AAB::UpdateCurveStrategy::alternativeCappedCurve()
{
  return 0;
}

uint64_t CBBOLTS::curveType(CBBOLTS *this)
{
  return 3;
}

uint64_t AAB::UpdateCurveStrategy::alternativeCurveType(AAB::UpdateCurveStrategy *this)
{
  return (*(uint64_t (**)(AAB::UpdateCurveStrategy *))(*(_QWORD *)this + 104))(this);
}

BOOL std::operator==[abi:ne180100]<CBBOLTS::Bin *>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = std::__wrap_iter<CBBOLTS::Bin *>::base[abi:ne180100](a1);
  return v3 == std::__wrap_iter<CBBOLTS::Bin *>::base[abi:ne180100](a2);
}

uint64_t std::__wrap_iter<CBBOLTS::Bin *>::base[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

BOOL std::operator==[abi:ne180100]<CBBOLTS::Bin const*>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = std::__wrap_iter<CBBOLTS::Bin const*>::base[abi:ne180100](a1);
  return v3 == std::__wrap_iter<CBBOLTS::Bin const*>::base[abi:ne180100](a2);
}

uint64_t std::__wrap_iter<CBBOLTS::Bin const*>::base[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t std::__list_imp<AAB::CurveUpdate>::~__list_imp(uint64_t a1)
{
  std::__list_imp<AAB::CurveUpdate>::clear(a1);
  return a1;
}

void std::__list_imp<AAB::CurveUpdate>::clear(uint64_t a1)
{
  _QWORD *v1;
  void *v2;
  uint64_t *v4;
  uint64_t v5;

  if (!std::__list_imp<AAB::CurveUpdate>::empty[abi:ne180100]())
  {
    v5 = *(_QWORD *)(a1 + 8);
    v4 = (uint64_t *)std::__list_imp<AAB::CurveUpdate>::__end_as_link[abi:ne180100]();
    std::__list_imp<AAB::CurveUpdate>::__unlink_nodes(v5, *v4);
    std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
    *v1 = 0;
    while ((uint64_t *)v5 != v4)
    {
      std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]();
      v5 = *(_QWORD *)(v5 + 8);
      std::__list_imp<AAB::CurveUpdate>::__delete_node[abi:ne180100]<>(a1, v2);
    }
  }
}

BOOL std::__list_imp<AAB::CurveUpdate>::empty[abi:ne180100]()
{
  _QWORD *v0;

  std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
  return *v0 == 0;
}

uint64_t std::__list_imp<AAB::CurveUpdate>::__end_as_link[abi:ne180100]()
{
  uint64_t result;

  std::__list_node_base<AAB::CurveUpdate,void *>::__self[abi:ne180100]();
  std::__list_node_pointer_traits<AAB::CurveUpdate,void *>::__unsafe_link_pointer_cast[abi:ne180100]();
  return result;
}

uint64_t std::__list_imp<AAB::CurveUpdate>::__unlink_nodes(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)result + 8) = *(_QWORD *)(a2 + 8);
  **(_QWORD **)(a2 + 8) = *(_QWORD *)result;
  return result;
}

void std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]()
{
  std::__compressed_pair<unsigned long>::first[abi:ne180100]();
}

{
  std::__compressed_pair<unsigned long>::first[abi:ne180100]();
}

void std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]()
{
  std::__list_node_base<AAB::CurveUpdate,void *>::__self[abi:ne180100]();
}

void std::__list_imp<AAB::CurveUpdate>::__delete_node[abi:ne180100]<>(uint64_t a1, void *a2)
{
  uint64_t v2;
  uint64_t v3;

  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
  v3 = v2;
  std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100]((uint64_t)a2);
  std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::destroy[abi:ne180100]<AAB::CurveUpdate,void,void>();
  std::__destroy_at[abi:ne180100]<std::__list_node<AAB::CurveUpdate,void *>,0>((uint64_t)a2);
  std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::deallocate[abi:ne180100](v3, a2);
}

void std::__compressed_pair<unsigned long>::first[abi:ne180100]()
{
  std::__compressed_pair_elem<unsigned long,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<unsigned long,0,false>::__get[abi:ne180100]();
}

void std::__list_node_base<AAB::CurveUpdate,void *>::__self[abi:ne180100]()
{
  std::pointer_traits<std::__list_node_base<AAB::CurveUpdate,void *> *>::pointer_to[abi:ne180100]();
}

void std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]()
{
  std::__compressed_pair<unsigned long>::second[abi:ne180100]();
}

{
  std::__compressed_pair<unsigned long>::second[abi:ne180100]();
}

void std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::destroy[abi:ne180100]<AAB::CurveUpdate,void,void>()
{
  std::__destroy_at[abi:ne180100]<AAB::CurveUpdate,0>();
}

uint64_t std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100](uint64_t a1)
{
  return a1 + 16;
}

uint64_t std::__destroy_at[abi:ne180100]<std::__list_node<AAB::CurveUpdate,void *>,0>(uint64_t a1)
{
  return std::__list_node<AAB::CurveUpdate,void *>::~__list_node[abi:ne180100](a1);
}

void std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
  std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::deallocate[abi:ne180100](a1, a2);
}

void std::__compressed_pair<unsigned long>::second[abi:ne180100]()
{
  std::__compressed_pair_elem<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,1,true>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,1,true>::__get[abi:ne180100]();
}

uint64_t std::__list_node<AAB::CurveUpdate,void *>::~__list_node[abi:ne180100](uint64_t a1)
{
  std::__list_node<AAB::CurveUpdate,void *>::~__list_node[abi:ne180100]();
  return a1;
}

void std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
  std::__libcpp_deallocate[abi:ne180100](a2);
}

BOOL std::operator==[abi:ne180100]<CBBOLTS::BinConfiguration const*>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = std::__wrap_iter<CBBOLTS::BinConfiguration const*>::base[abi:ne180100](a1);
  return v3 == std::__wrap_iter<CBBOLTS::BinConfiguration const*>::base[abi:ne180100](a2);
}

uint64_t std::__wrap_iter<CBBOLTS::BinConfiguration const*>::base[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

_QWORD *AAB::UpdateCurveStrategy::UpdateCurveStrategy(_QWORD *this)
{
  *this = &unk_1E68E9600;
  return this;
}

void AAB::UpdateCurveStrategy::~UpdateCurveStrategy(AAB::UpdateCurveStrategy *this)
{
  __break(1u);
}

{
  __break(1u);
}

uint64_t AAB::UpdateCurveStrategy::UpdateCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, __n128 a6, __n128 a7, __n128 a8)
{
  float CapForE;
  unint64_t v14;
  float v15;

  v14 = __PAIR64__(a7.n128_u32[0], a6.n128_u32[0]);
  v15 = a8.n128_f32[0];
  (*(void (**)(uint64_t, uint64_t, uint64_t, __n128, __n128, __n128))(*(_QWORD *)a1 + 24))(a1, a2, a3, a6, a7, a8);
  CapForE = AAB::findCapForE(a4, *((float *)&v14 + 1));
  if (v15 > CapForE)
    v15 = CapForE;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, float, float, float))(*(_QWORD *)a1 + 24))(a1, a2, a5, *(float *)&v14, *((float *)&v14 + 1), v15);
}

_QWORD *AAB::UpdateCurveStrategy::curveUpdates@<X0>(_QWORD *a1@<X8>)
{
  return std::list<AAB::CurveUpdate>::list[abi:ne180100](a1);
}

uint64_t AAB::UpdateCurveStrategy::cappedCurve()
{
  return 0;
}

unint64_t std::atomic_load_explicit[abi:ne180100]<void *>(unint64_t *a1, int a2)
{
  return std::__atomic_base<void *,false>::load[abi:ne180100](a1, a2);
}

unint64_t CoreMLLibrary(void)
{
  unint64_t v1;
  char *v2;

  v2 = 0;
  v1 = CoreMLLibraryCore(&v2);
  if (!v1)
    abort_report_np();
  if (v2)
    free(v2);
  return v1;
}

unint64_t *std::atomic_store_explicit[abi:ne180100]<void *>(unint64_t *a1, unint64_t a2, int a3)
{
  return std::__atomic_base<void *,false>::store[abi:ne180100](a1, a2, a3);
}

unint64_t std::__atomic_base<void *,false>::load[abi:ne180100](unint64_t *a1, int a2)
{
  return std::__cxx_atomic_load[abi:ne180100]<void *>(a1, a2);
}

unint64_t std::__cxx_atomic_load[abi:ne180100]<void *>(unint64_t *a1, int a2)
{
  BOOL v2;

  v2 = a2 == 2 || a2 == 1;
  if (!v2 && a2 != 5)
    return *a1;
  return atomic_load(a1);
}

unint64_t CoreMLLibraryCore(char **a1)
{
  if (!std::atomic_load_explicit[abi:ne180100]<void *>(&CoreMLLibraryCore(char **)::frameworkLibrary, 0))
    ___ZL17CoreMLLibraryCorePPc_block_invoke();
  return std::atomic_load_explicit[abi:ne180100]<void *>(&CoreMLLibraryCore(char **)::frameworkLibrary, 0);
}

unint64_t *std::__atomic_base<void *,false>::store[abi:ne180100](unint64_t *a1, unint64_t a2, int a3)
{
  return std::__cxx_atomic_store[abi:ne180100]<void *>(a1, a2, a3);
}

unint64_t *std::__cxx_atomic_store[abi:ne180100]<void *>(unint64_t *result, unint64_t a2, int a3)
{
  if (a3 == 3 || a3 == 5)
    atomic_store(a2, result);
  else
    *result = a2;
  return result;
}

BOOL std::operator==[abi:ne180100]<AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](a1);
  return v3 == std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](a2);
}

uint64_t std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

_QWORD *std::__list_imp<AAB::CurveUpdate>::__list_imp(_QWORD *a1)
{
  int v3;
  _QWORD *v4;

  v4 = a1;
  std::__list_node_base<AAB::CurveUpdate,void *>::__list_node_base[abi:ne180100](a1);
  v3 = 0;
  std::__compressed_pair<unsigned long>::__compressed_pair[abi:ne180100]<int,std::__default_init_tag>(a1 + 2, &v3);
  return a1;
}

_QWORD *std::__list_node_base<AAB::CurveUpdate,void *>::__list_node_base[abi:ne180100](_QWORD *a1)
{
  std::__list_node_base<AAB::CurveUpdate,void *>::__list_node_base[abi:ne180100](a1);
  return a1;
}

{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *result;

  std::__list_node_base<AAB::CurveUpdate,void *>::__self[abi:ne180100]();
  std::__list_node_pointer_traits<AAB::CurveUpdate,void *>::__unsafe_link_pointer_cast[abi:ne180100]();
  *a1 = v1;
  std::__list_node_base<AAB::CurveUpdate,void *>::__self[abi:ne180100]();
  std::__list_node_pointer_traits<AAB::CurveUpdate,void *>::__unsafe_link_pointer_cast[abi:ne180100]();
  v3 = v2;
  result = a1;
  a1[1] = v3;
  return result;
}

_QWORD *std::__compressed_pair<unsigned long>::__compressed_pair[abi:ne180100]<int,std::__default_init_tag>(_QWORD *a1, int *a2)
{
  std::__compressed_pair<unsigned long>::__compressed_pair[abi:ne180100]<int,std::__default_init_tag>(a1, a2);
  return a1;
}

{
  std::__compressed_pair_elem<unsigned long,0,false>::__compressed_pair_elem[abi:ne180100]<int,void>(a1, a2);
  std::__compressed_pair_elem<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,1,true>::__compressed_pair_elem[abi:ne180100]((uint64_t)a1);
  return a1;
}

_QWORD *std::__compressed_pair_elem<unsigned long,0,false>::__compressed_pair_elem[abi:ne180100]<int,void>(_QWORD *result, int *a2)
{
  *result = *a2;
  return result;
}

uint64_t std::__compressed_pair_elem<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,1,true>::__compressed_pair_elem[abi:ne180100](uint64_t a1)
{
  std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::allocator[abi:ne180100](a1);
  return a1;
}

uint64_t std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::allocator[abi:ne180100](uint64_t a1)
{
  std::__non_trivial_if<true>::__non_trivial_if[abi:ne180100]();
  return a1;
}

_QWORD *std::__list_imp<AAB::CurveUpdate>::__list_imp(_QWORD *a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  _QWORD *v6;

  v6 = a1;
  v5 = a2;
  std::__list_node_base<AAB::CurveUpdate,void *>::__list_node_base[abi:ne180100](a1);
  v4 = 0;
  std::__compressed_pair<unsigned long>::__compressed_pair[abi:ne180100]<int,std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>(a1 + 2, &v4);
  return a1;
}

_QWORD *std::__compressed_pair<unsigned long>::__compressed_pair[abi:ne180100]<int,std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>(_QWORD *a1, int *a2)
{
  std::__compressed_pair<unsigned long>::__compressed_pair[abi:ne180100]<int,std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>(a1, a2);
  return a1;
}

{
  std::__compressed_pair_elem<unsigned long,0,false>::__compressed_pair_elem[abi:ne180100]<int,void>(a1, a2);
  std::__compressed_pair_elem<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,1,true>::__compressed_pair_elem[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,void>();
  return a1;
}

uint64_t std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate const&>(uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  __n128 *v7;
  uint64_t v9;
  uint64_t v10;
  _BYTE v11[24];
  uint64_t v12;
  __n128 *v13;
  uint64_t v14;
  uint64_t v15[2];

  v15[1] = a1;
  v15[0] = a2;
  v14 = a3;
  v13 = a4;
  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
  v12 = v4;
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__allocation_guard[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>((uint64_t)v11, 1);
  v5 = (_QWORD *)std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__get[abi:ne180100]((uint64_t)v11);
  std::__construct_at[abi:ne180100]<std::__list_node<AAB::CurveUpdate,void *>,std::__list_node_base<AAB::CurveUpdate,void *> *&,std::__list_node_base<AAB::CurveUpdate,void *> *&,std::__list_node<AAB::CurveUpdate,void *>*>(v5, v15, &v14);
  v10 = v12;
  v6 = std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__get[abi:ne180100]((uint64_t)v11);
  v7 = (__n128 *)std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100](v6);
  std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&,void>(v10, v7, v13);
  v9 = std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__release_ptr[abi:ne180100]((uint64_t)v11);
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::~__allocation_guard[abi:ne180100]((uint64_t)v11);
  return v9;
}

void sub_1B5324B68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, int a17, _Unwind_Exception *exception_object)
{
  uint64_t v18;

  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::~__allocation_guard[abi:ne180100](v18 - 64);
  _Unwind_Resume(a1);
}

void std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]()
{
  std::__list_node_base<AAB::CurveUpdate,void *>::__self[abi:ne180100]();
}

uint64_t std::list<AAB::CurveUpdate>::__link_nodes_at_back(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = std::__list_imp<AAB::CurveUpdate>::__end_as_link[abi:ne180100]();
  *(_QWORD *)(a3 + 8) = result;
  *(_QWORD *)a2 = *a1;
  *(_QWORD *)(*(_QWORD *)a2 + 8) = a2;
  *a1 = a3;
  return result;
}

uint64_t std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__allocation_guard[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>(uint64_t a1, uint64_t a2)
{
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__allocation_guard[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>(a1, a2);
  return a1;
}

{
  void *v2;
  uint64_t result;

  *(_QWORD *)(a1 + 8) = a2;
  v2 = std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::allocate[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  result = a1;
  *(_QWORD *)(a1 + 16) = v2;
  return result;
}

_QWORD *std::__construct_at[abi:ne180100]<std::__list_node<AAB::CurveUpdate,void *>,std::__list_node_base<AAB::CurveUpdate,void *> *&,std::__list_node_base<AAB::CurveUpdate,void *> *&,std::__list_node<AAB::CurveUpdate,void *>*>(_QWORD *a1, uint64_t *a2, uint64_t *a3)
{
  std::__list_node<AAB::CurveUpdate,void *>::__list_node[abi:ne180100](a1, *a2, *a3);
  return a1;
}

uint64_t std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__get[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

double std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&,void>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  double result;

  *(_QWORD *)&result = std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&>(a1, a2, a3).n128_u64[0];
  return result;
}

uint64_t std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__release_ptr[abi:ne180100](uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  return v2;
}

uint64_t std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::~__allocation_guard[abi:ne180100](uint64_t a1)
{
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::~__allocation_guard[abi:ne180100](a1);
  return a1;
}

{
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__destroy[abi:ne180100](a1);
  return a1;
}

void *std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::allocate[abi:ne180100](uint64_t a1, unint64_t a2)
{
  return std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::allocate[abi:ne180100](a1, a2);
}

void *std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::allocate[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 > std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::max_size[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,void>())
    std::__throw_bad_array_new_length[abi:ne180100]();
  return std::__libcpp_allocate[abi:ne180100](32 * a2);
}

uint64_t std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::max_size[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,void>()
{
  return std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::max_size[abi:ne180100]();
}

uint64_t std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::max_size[abi:ne180100]()
{
  return 0x7FFFFFFFFFFFFFFLL;
}

_QWORD *std::__list_node<AAB::CurveUpdate,void *>::__list_node[abi:ne180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  std::__list_node<AAB::CurveUpdate,void *>::__list_node[abi:ne180100](a1, a2, a3);
  return a1;
}

{
  std::__list_node_base<AAB::CurveUpdate,void *>::__list_node_base[abi:ne180100](a1, a2, a3);
  return a1;
}

_QWORD *std::__list_node_base<AAB::CurveUpdate,void *>::__list_node_base[abi:ne180100](_QWORD *result, uint64_t a2, uint64_t a3)
{
  *result = a2;
  result[1] = a3;
  return result;
}

__n128 std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

void std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__destroy[abi:ne180100](uint64_t a1)
{
  if (*(_QWORD *)(a1 + 16))
    std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::deallocate[abi:ne180100](a1, *(void **)(a1 + 16));
}

uint64_t std::vector<CBBOLTS::Bin>::__make_iter[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  std::__wrap_iter<CBBOLTS::Bin *>::__wrap_iter[abi:ne180100](&v3, a2);
  return v3;
}

{
  uint64_t v3;

  std::__wrap_iter<CBBOLTS::Bin const*>::__wrap_iter[abi:ne180100](&v3, a2);
  return v3;
}

_QWORD *std::__wrap_iter<CBBOLTS::Bin *>::__wrap_iter[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::__wrap_iter<CBBOLTS::Bin *>::__wrap_iter[abi:ne180100](a1, a2);
  return a1;
}

_QWORD *std::__wrap_iter<CBBOLTS::Bin *>::__wrap_iter[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

uint64_t std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate>(uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  __n128 *v7;
  uint64_t v9;
  uint64_t v10;
  _BYTE v11[24];
  uint64_t v12;
  __n128 *v13;
  uint64_t v14;
  uint64_t v15[2];

  v15[1] = a1;
  v15[0] = a2;
  v14 = a3;
  v13 = a4;
  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
  v12 = v4;
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__allocation_guard[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>((uint64_t)v11, 1);
  v5 = (_QWORD *)std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__get[abi:ne180100]((uint64_t)v11);
  std::__construct_at[abi:ne180100]<std::__list_node<AAB::CurveUpdate,void *>,std::__list_node_base<AAB::CurveUpdate,void *> *&,std::__list_node_base<AAB::CurveUpdate,void *> *&,std::__list_node<AAB::CurveUpdate,void *>*>(v5, v15, &v14);
  v10 = v12;
  v6 = std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__get[abi:ne180100]((uint64_t)v11);
  v7 = (__n128 *)std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100](v6);
  std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,void>(v10, v7, v13);
  v9 = std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__release_ptr[abi:ne180100]((uint64_t)v11);
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::~__allocation_guard[abi:ne180100]((uint64_t)v11);
  return v9;
}

void sub_1B532509C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, int a17, _Unwind_Exception *exception_object)
{
  uint64_t v18;

  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::~__allocation_guard[abi:ne180100](v18 - 64);
  _Unwind_Resume(a1);
}

double std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,void>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  double result;

  *(_QWORD *)&result = std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(a1, a2, a3).n128_u64[0];
  return result;
}

__n128 std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

_QWORD *std::__compressed_pair<AAB::CurveUpdate *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(_QWORD *a1)
{
  std::__compressed_pair<AAB::CurveUpdate *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1);
  return a1;
}

{
  std::__compressed_pair_elem<AAB::CurveUpdate *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate>,1,true>::__compressed_pair_elem[abi:ne180100]((uint64_t)a1);
  return a1;
}

_QWORD *std::__compressed_pair_elem<AAB::CurveUpdate *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(_QWORD *result)
{
  *result = 0;
  return result;
}

uint64_t std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate>,1,true>::__compressed_pair_elem[abi:ne180100](uint64_t a1)
{
  std::allocator<AAB::CurveUpdate>::allocator[abi:ne180100](a1);
  return a1;
}

uint64_t std::allocator<AAB::CurveUpdate>::allocator[abi:ne180100](uint64_t a1)
{
  std::__non_trivial_if<true>::__non_trivial_if[abi:ne180100]();
  return a1;
}

_QWORD *std::vector<AAB::CurveUpdate>::__destroy_vector::__destroy_vector[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::vector<AAB::CurveUpdate>::__destroy_vector::__destroy_vector[abi:ne180100](a1, a2);
  return a1;
}

void std::vector<AAB::CurveUpdate>::__destroy_vector::operator()[abi:ne180100](uint64_t **a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;

  if (**a1)
  {
    std::vector<AAB::CurveUpdate>::__clear[abi:ne180100](*a1);
    std::vector<AAB::CurveUpdate>::__annotate_delete[abi:ne180100]();
    std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
    v3 = v1;
    v2 = (void *)**a1;
    std::vector<AAB::CurveUpdate>::capacity[abi:ne180100](*a1);
    std::allocator_traits<std::allocator<AAB::CurveUpdate>>::deallocate[abi:ne180100](v3, v2);
  }
}

_QWORD *std::vector<AAB::CurveUpdate>::__destroy_vector::__destroy_vector[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

void std::vector<AAB::CurveUpdate>::__clear[abi:ne180100](uint64_t *a1)
{
  std::vector<AAB::CurveUpdate>::__base_destruct_at_end[abi:ne180100]((uint64_t)a1, *a1);
}

void std::allocator_traits<std::allocator<AAB::CurveUpdate>>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
  std::allocator<AAB::CurveUpdate>::deallocate[abi:ne180100](a1, a2);
}

void std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]()
{
  std::__compressed_pair<AAB::CurveUpdate *>::second[abi:ne180100]();
}

{
  std::__compressed_pair<AAB::CurveUpdate *>::second[abi:ne180100]();
}

uint64_t std::vector<AAB::CurveUpdate>::capacity[abi:ne180100](_QWORD *a1)
{
  _QWORD *v1;

  std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 16;
}

void std::vector<AAB::CurveUpdate>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 8); a2 != i; i -= 16)
  {
    std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
    std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
    std::allocator_traits<std::allocator<AAB::CurveUpdate>>::destroy[abi:ne180100]<AAB::CurveUpdate,void>();
  }
  *(_QWORD *)(a1 + 8) = a2;
}

void std::allocator_traits<std::allocator<AAB::CurveUpdate>>::destroy[abi:ne180100]<AAB::CurveUpdate,void>()
{
  std::allocator<AAB::CurveUpdate>::destroy[abi:ne180100]();
}

void std::allocator<AAB::CurveUpdate>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
  std::__libcpp_deallocate[abi:ne180100](a2);
}

void std::__compressed_pair<AAB::CurveUpdate *>::second[abi:ne180100]()
{
  std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate>,1,true>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate>,1,true>::__get[abi:ne180100]();
}

void std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]()
{
  std::__compressed_pair<AAB::CurveUpdate *>::first[abi:ne180100]();
}

{
  std::__compressed_pair<AAB::CurveUpdate *>::first[abi:ne180100]();
}

void std::__compressed_pair<AAB::CurveUpdate *>::first[abi:ne180100]()
{
  std::__compressed_pair_elem<AAB::CurveUpdate *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<AAB::CurveUpdate *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<AAB::CurveUpdate *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<AAB::CurveUpdate *,0,false>::__get[abi:ne180100]();
}

_QWORD *std::__wrap_iter<CBBOLTS::Bin const*>::__wrap_iter[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::__wrap_iter<CBBOLTS::Bin const*>::__wrap_iter[abi:ne180100](a1, a2);
  return a1;
}

_QWORD *std::__wrap_iter<CBBOLTS::Bin const*>::__wrap_iter[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

_QWORD *std::vector<AAB::CurveUpdate>::__construct_one_at_end[abi:ne180100]<AAB::CurveUpdate>(uint64_t a1, __n128 *a2)
{
  uint64_t v2;
  __n128 *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __n128 *v8;
  uint64_t v9;

  v9 = a1;
  v8 = a2;
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, 1);
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  v5 = v2;
  std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
  std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,void>(v5, v3, v8);
  v7 += 16;
  return std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1B5325738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15)
{
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&a15);
  _Unwind_Resume(a1);
}

uint64_t std::vector<AAB::CurveUpdate>::__push_back_slow_path<AAB::CurveUpdate>(uint64_t *a1, __n128 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __n128 *v5;
  uint64_t v7;
  unint64_t v9;
  uint64_t v10;
  void *v11[2];
  uint64_t v12;
  uint64_t v13;
  __n128 *v14;
  uint64_t *v15;

  v15 = a1;
  v14 = a2;
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  v13 = v2;
  v3 = std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
  v9 = std::vector<AAB::CurveUpdate>::__recommend[abi:ne180100](a1, v3 + 1);
  v4 = std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
  std::__split_buffer<AAB::CurveUpdate>::__split_buffer(v11, v9, v4, v13);
  v10 = v13;
  std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
  std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,void>(v10, v5, v14);
  v12 += 16;
  std::vector<AAB::CurveUpdate>::__swap_out_circular_buffer(a1, v11);
  v7 = a1[1];
  std::__split_buffer<AAB::CurveUpdate>::~__split_buffer(v11);
  return v7;
}

void sub_1B5325820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, _Unwind_Exception *exception_object, void *a16)
{
  std::__split_buffer<AAB::CurveUpdate>::~__split_buffer(&a16);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](a1, a2, a3);
  return a1;
}

double std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,void>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  double result;

  *(_QWORD *)&result = std::allocator<AAB::CurveUpdate>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(a1, a2, a3).n128_u64[0];
  return result;
}

_QWORD *std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](_QWORD *a1)
{
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](a1);
  return a1;
}

_QWORD *std::vector<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](_QWORD *result, uint64_t a2, uint64_t a3)
{
  *result = a2;
  result[1] = *(_QWORD *)(a2 + 8);
  result[2] = *(_QWORD *)(a2 + 8) + 16 * a3;
  return result;
}

__n128 std::allocator<AAB::CurveUpdate>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

_QWORD *std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](_QWORD *result)
{
  *(_QWORD *)(*result + 8) = result[1];
  return result;
}

unint64_t std::vector<AAB::CurveUpdate>::__recommend[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD v7[2];

  v7[1] = a1;
  v7[0] = a2;
  v6 = std::vector<AAB::CurveUpdate>::max_size((uint64_t)a1);
  if (v7[0] > v6)
    std::vector<AAB::CurveUpdate>::__throw_length_error[abi:ne180100]();
  v5 = std::vector<AAB::CurveUpdate>::capacity[abi:ne180100](a1);
  if (v5 >= v6 / 2)
    return v6;
  v4 = 2 * v5;
  return *std::max[abi:ne180100]<unsigned long>(&v4, v7);
}

void **std::__split_buffer<AAB::CurveUpdate>::__split_buffer(void **a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__split_buffer<AAB::CurveUpdate>::__split_buffer(a1, a2, a3, a4);
  return a1;
}

{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v9;
  _QWORD v11[2];
  uint64_t v12;
  unint64_t v13;
  void **v14;
  void **v15;

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11[1] = a4;
  v15 = a1;
  v11[0] = 0;
  std::__compressed_pair<AAB::CurveUpdate *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<AAB::CurveUpdate> &>(a1 + 3, (uint64_t)v11, a4);
  if (v13)
  {
    v4 = std::__split_buffer<AAB::CurveUpdate>::__alloc[abi:ne180100]((uint64_t)a1);
    *a1 = std::__allocate_at_least[abi:ne180100]<std::allocator<AAB::CurveUpdate>>(v4, v13);
    v13 = v5;
  }
  else
  {
    *a1 = 0;
  }
  v6 = (uint64_t)*a1 + 16 * v12;
  a1[2] = (void *)v6;
  a1[1] = (void *)v6;
  v9 = (unint64_t)*a1 + 16 * v13;
  std::__split_buffer<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  *v7 = v9;
  return v15;
}

void std::vector<AAB::CurveUpdate>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v10[2];
  uint64_t v11[2];
  unint64_t v12[2];
  _QWORD v13[2];
  _QWORD *v14;
  uint64_t *v15;

  v15 = a1;
  v14 = a2;
  std::vector<AAB::CurveUpdate>::__annotate_delete[abi:ne180100]();
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  v7 = v2;
  std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](v12, a1[1]);
  std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](v11, *a1);
  std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](v10, v14[1]);
  v13[0] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<AAB::CurveUpdate>,std::reverse_iterator<AAB::CurveUpdate*>,std::reverse_iterator<AAB::CurveUpdate*>,AAB::CurveUpdate,void>(v7, v12[0], v12[1], v11[0], v11[1], v10[0], v10[1]);
  v13[1] = v3;
  v4 = std::reverse_iterator<AAB::CurveUpdate *>::base[abi:ne180100]((uint64_t)v13);
  v14[1] = v4;
  std::swap[abi:ne180100]<AAB::CurveUpdate *>(a1, v14 + 1);
  std::swap[abi:ne180100]<AAB::CurveUpdate *>(a1 + 1, v14 + 2);
  std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  v8 = v5;
  std::__split_buffer<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  std::swap[abi:ne180100]<AAB::CurveUpdate *>(v8, v6);
  *v14 = v14[1];
  std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
  std::vector<AAB::CurveUpdate>::__annotate_new[abi:ne180100]();
}

void **std::__split_buffer<AAB::CurveUpdate>::~__split_buffer(void **a1)
{
  std::__split_buffer<AAB::CurveUpdate>::~__split_buffer(a1);
  return a1;
}

{
  uint64_t v2;
  void *v3;

  std::__split_buffer<AAB::CurveUpdate>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
  {
    v2 = std::__split_buffer<AAB::CurveUpdate>::__alloc[abi:ne180100]((uint64_t)a1);
    v3 = *a1;
    std::__split_buffer<AAB::CurveUpdate>::capacity[abi:ne180100](a1);
    std::allocator_traits<std::allocator<AAB::CurveUpdate>>::deallocate[abi:ne180100](v2, v3);
  }
  return a1;
}

uint64_t std::vector<AAB::CurveUpdate>::max_size(uint64_t a1)
{
  uint64_t v2;
  _QWORD v3[2];

  v3[1] = a1;
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  v3[0] = std::allocator_traits<std::allocator<AAB::CurveUpdate>>::max_size[abi:ne180100]<std::allocator<AAB::CurveUpdate>,void>();
  v2 = std::numeric_limits<long>::max[abi:ne180100]();
  return *std::min[abi:ne180100]<unsigned long>(v3, &v2);
}

void std::vector<AAB::CurveUpdate>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

uint64_t std::allocator_traits<std::allocator<AAB::CurveUpdate>>::max_size[abi:ne180100]<std::allocator<AAB::CurveUpdate>,void>()
{
  return std::allocator<AAB::CurveUpdate>::max_size[abi:ne180100]();
}

uint64_t std::allocator<AAB::CurveUpdate>::max_size[abi:ne180100]()
{
  return 0xFFFFFFFFFFFFFFFLL;
}

_QWORD *std::__compressed_pair<AAB::CurveUpdate *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<AAB::CurveUpdate> &>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  std::__compressed_pair<AAB::CurveUpdate *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<AAB::CurveUpdate> &>(a1, a2, a3);
  return a1;
}

{
  std::__compressed_pair_elem<AAB::CurveUpdate *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate> &,1,false>::__compressed_pair_elem[abi:ne180100]<std::allocator<AAB::CurveUpdate> &,void>(a1 + 1, a3);
  return a1;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<AAB::CurveUpdate>>(uint64_t a1, unint64_t a2)
{
  return std::allocator<AAB::CurveUpdate>::allocate[abi:ne180100](a1, a2);
}

uint64_t std::__split_buffer<AAB::CurveUpdate>::__alloc[abi:ne180100](uint64_t a1)
{
  return std::__compressed_pair<AAB::CurveUpdate *>::second[abi:ne180100](a1 + 24);
}

void std::__split_buffer<AAB::CurveUpdate>::__end_cap[abi:ne180100]()
{
  std::__compressed_pair<AAB::CurveUpdate *>::first[abi:ne180100]();
}

{
  std::__compressed_pair<AAB::CurveUpdate *>::first[abi:ne180100]();
}

_QWORD *std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate> &,1,false>::__compressed_pair_elem[abi:ne180100]<std::allocator<AAB::CurveUpdate> &,void>(_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

void *std::allocator<AAB::CurveUpdate>::allocate[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 > std::allocator_traits<std::allocator<AAB::CurveUpdate>>::max_size[abi:ne180100]<std::allocator<AAB::CurveUpdate>,void>())
    std::__throw_bad_array_new_length[abi:ne180100]();
  return std::__libcpp_allocate[abi:ne180100](16 * a2);
}

uint64_t std::__compressed_pair<AAB::CurveUpdate *>::second[abi:ne180100](uint64_t a1)
{
  return std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate> &,1,false>::__get[abi:ne180100](a1 + 8);
}

uint64_t std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate> &,1,false>::__get[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<AAB::CurveUpdate>,std::reverse_iterator<AAB::CurveUpdate*>,std::reverse_iterator<AAB::CurveUpdate*>,AAB::CurveUpdate,void>(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return std::move[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(a2, a3, a4, a5, a6, a7);
}

_QWORD *std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](a1, a2);
  return a1;
}

uint64_t std::reverse_iterator<AAB::CurveUpdate *>::base[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t *std::swap[abi:ne180100]<AAB::CurveUpdate *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *result;
  *result = *a2;
  *a2 = v2;
  return result;
}

uint64_t std::move[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;

  v13 = a1;
  v14 = a2;
  v11 = a3;
  v12 = a4;
  v9 = a5;
  v10 = a6;
  std::__move[abi:ne180100]<std::_ClassicAlgPolicy,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(a1, a2, a3, a4, a5, a6, &v7);
  return v8;
}

_OWORD *std::__move[abi:ne180100]<std::_ClassicAlgPolicy,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(a1, a2, a3, a4, a5, a6, a7);
}

_OWORD *std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,0>(a1, a2, a3, a4, a5, a6, a7);
}

_OWORD *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,0>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  __n128 v13[3];
  _OWORD v14[2];
  unint64_t v15;
  unint64_t v16;
  __int128 v17;
  __int128 v18;
  __n128 v19;
  __int128 v20;
  __int128 v21;
  __n128 v22;
  _OWORD v23[2];
  __int128 v24;
  __int128 v25;
  __n128 v26;

  v26.n128_u64[0] = a1;
  v26.n128_u64[1] = a2;
  *(_QWORD *)&v25 = a3;
  *((_QWORD *)&v25 + 1) = a4;
  *(_QWORD *)&v24 = a5;
  *((_QWORD *)&v24 + 1) = a6;
  v22 = v26;
  v21 = v25;
  std::__unwrap_range[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(a1, a2, a3, a4, v23);
  v18 = v23[0];
  v17 = v23[1];
  v14[1] = v24;
  std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>,0>();
  v15 = v7;
  v16 = v8;
  std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(v18, *((uint64_t *)&v18 + 1), v17, *((uint64_t *)&v17 + 1), v7, v8, &v19);
  v13[2] = v26;
  v13[1] = v19;
  *(_QWORD *)&v14[0] = std::__rewrap_range[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(v26.n128_i64[0], v26.n128_i64[1], v19.n128_i64[0]);
  *((_QWORD *)&v14[0] + 1) = v9;
  v13[0].n128_u64[0] = std::__rewrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>>(v24, *((uint64_t *)&v24 + 1), v20);
  v13[0].n128_u64[1] = v10;
  return std::make_pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(v14, v13, a7);
}

_OWORD *std::__unwrap_range[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  __n128 v11[2];
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __n128 v15;

  v15.n128_u64[0] = a1;
  v15.n128_u64[1] = a2;
  v13 = a3;
  v14 = a4;
  v11[1] = v15;
  std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>,0>();
  *(_QWORD *)&v12 = v5;
  *((_QWORD *)&v12 + 1) = v6;
  std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>,0>();
  v11[0].n128_u64[0] = v7;
  v11[0].n128_u64[1] = v8;
  return std::make_pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(&v12, v11, a5);
}

_OWORD *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, unint64_t a5@<X5>, unint64_t a6@<X6>, _OWORD *a7@<X8>)
{
  _OWORD *v8;
  __n128 v10;
  _QWORD v11[2];
  __int128 v12;

  *(_QWORD *)&v12 = a1;
  *((_QWORD *)&v12 + 1) = a2;
  v11[0] = a3;
  v11[1] = a4;
  v10.n128_u64[0] = a5;
  v10.n128_u64[1] = a6;
  while (std::operator!=[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>((uint64_t)&v12, (uint64_t)v11))
  {
    v8 = (_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *> &,0>((uint64_t)&v12);
    *(_OWORD *)std::reverse_iterator<AAB::CurveUpdate *>::operator*[abi:ne180100]((uint64_t)&v10) = *v8;
    std::reverse_iterator<AAB::CurveUpdate *>::operator++[abi:ne180100]((uint64_t)&v12);
    std::reverse_iterator<AAB::CurveUpdate *>::operator++[abi:ne180100]((uint64_t)&v10);
  }
  return std::make_pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(&v12, &v10, a7);
}

void std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>,0>()
{
  std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>::__unwrap[abi:ne180100]();
}

_OWORD *std::make_pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>@<X0>(_OWORD *a1@<X0>, __n128 *a2@<X1>, _OWORD *a3@<X8>)
{
  return std::pair<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>::pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,0>(a3, a1, a2);
}

uint64_t std::__rewrap_range[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__rewrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>>(a1, a2, a3);
}

uint64_t std::__rewrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>::__rewrap[abi:ne180100](a1, a2, a3);
}

BOOL std::operator!=[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = std::reverse_iterator<AAB::CurveUpdate *>::base[abi:ne180100](a1);
  return v3 != std::reverse_iterator<AAB::CurveUpdate *>::base[abi:ne180100](a2);
}

uint64_t std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *> &,0>(uint64_t a1)
{
  std::_IterOps<std::_ClassicAlgPolicy>::__validate_iter_reference[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *> &>();
  return std::reverse_iterator<AAB::CurveUpdate *>::operator*[abi:ne180100](a1);
}

uint64_t std::reverse_iterator<AAB::CurveUpdate *>::operator*[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) - 16;
}

uint64_t std::reverse_iterator<AAB::CurveUpdate *>::operator++[abi:ne180100](uint64_t result)
{
  *(_QWORD *)(result + 8) -= 16;
  return result;
}

_OWORD *std::pair<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>::pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,0>(_OWORD *a1, _OWORD *a2, __n128 *a3)
{
  std::pair<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>::pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,0>(a1, a2, a3);
  return a1;
}

__n128 std::pair<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>::pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,0>(_OWORD *a1, _OWORD *a2, __n128 *a3)
{
  __n128 result;

  *a1 = *a2;
  result = *a3;
  a1[1] = *a3;
  return result;
}

uint64_t std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

_QWORD *std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  result[1] = a2;
  return result;
}

void std::__split_buffer<AAB::CurveUpdate>::clear[abi:ne180100](uint64_t a1)
{
  std::__split_buffer<AAB::CurveUpdate>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
}

uint64_t std::__split_buffer<AAB::CurveUpdate>::capacity[abi:ne180100](_QWORD *a1)
{
  _QWORD *v1;

  std::__split_buffer<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 16;
}

void std::__split_buffer<AAB::CurveUpdate>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__split_buffer<AAB::CurveUpdate>::__destruct_at_end[abi:ne180100](a1, a2);
}

{
  while (a2 != *(_QWORD *)(a1 + 16))
  {
    std::__split_buffer<AAB::CurveUpdate>::__alloc[abi:ne180100](a1);
    *(_QWORD *)(a1 + 16) -= 16;
    std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
    std::allocator_traits<std::allocator<AAB::CurveUpdate>>::destroy[abi:ne180100]<AAB::CurveUpdate,void>();
  }
}

uint64_t std::__list_imp<AAB::CurveUpdate>::begin[abi:ne180100](uint64_t a1)
{
  uint64_t v2;

  std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v2, *(_QWORD *)(a1 + 8));
  return v2;
}

{
  uint64_t v2;

  std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](&v2, *(_QWORD *)(a1 + 8));
  return v2;
}

_QWORD *std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](a1, a2);
  return a1;
}

_QWORD *std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

uint64_t std::__list_imp<AAB::CurveUpdate>::end[abi:ne180100]()
{
  uint64_t v0;
  uint64_t v2;

  v0 = std::__list_imp<AAB::CurveUpdate>::__end_as_link[abi:ne180100]();
  std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v2, v0);
  return v2;
}

{
  uint64_t v0;
  uint64_t v2;

  v0 = std::__list_imp<AAB::CurveUpdate>::__end_as_link[abi:ne180100]();
  std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](&v2, v0);
  return v2;
}

BOOL std::operator==[abi:ne180100](_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

{
  return *a1 == *a2;
}

_QWORD *std::vector<AAB::CurveUpdate>::__construct_one_at_end[abi:ne180100]<AAB::CurveUpdate const&>(uint64_t a1, __n128 *a2)
{
  uint64_t v2;
  __n128 *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __n128 *v8;
  uint64_t v9;

  v9 = a1;
  v8 = a2;
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, 1);
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  v5 = v2;
  std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
  std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&,void>(v5, v3, v8);
  v7 += 16;
  return std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1B5326A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15)
{
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&a15);
  _Unwind_Resume(a1);
}

uint64_t std::vector<AAB::CurveUpdate>::__push_back_slow_path<AAB::CurveUpdate const&>(uint64_t *a1, __n128 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __n128 *v5;
  uint64_t v7;
  unint64_t v9;
  uint64_t v10;
  void *v11[2];
  uint64_t v12;
  uint64_t v13;
  __n128 *v14;
  uint64_t *v15;

  v15 = a1;
  v14 = a2;
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  v13 = v2;
  v3 = std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
  v9 = std::vector<AAB::CurveUpdate>::__recommend[abi:ne180100](a1, v3 + 1);
  v4 = std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
  std::__split_buffer<AAB::CurveUpdate>::__split_buffer(v11, v9, v4, v13);
  v10 = v13;
  std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
  std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&,void>(v10, v5, v14);
  v12 += 16;
  std::vector<AAB::CurveUpdate>::__swap_out_circular_buffer(a1, v11);
  v7 = a1[1];
  std::__split_buffer<AAB::CurveUpdate>::~__split_buffer(v11);
  return v7;
}

void sub_1B5326B6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, _Unwind_Exception *exception_object, void *a16)
{
  std::__split_buffer<AAB::CurveUpdate>::~__split_buffer(&a16);
  _Unwind_Resume(a1);
}

double std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&,void>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  double result;

  *(_QWORD *)&result = std::allocator<AAB::CurveUpdate>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&>(a1, a2, a3).n128_u64[0];
  return result;
}

__n128 std::allocator<AAB::CurveUpdate>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t std::vector<AAB::CurveUpdate>::__make_iter[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  std::__wrap_iter<AAB::CurveUpdate *>::__wrap_iter[abi:ne180100](&v3, a2);
  return v3;
}

_QWORD *std::__wrap_iter<AAB::CurveUpdate *>::__wrap_iter[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::__wrap_iter<AAB::CurveUpdate *>::__wrap_iter[abi:ne180100](a1, a2);
  return a1;
}

_QWORD *std::__wrap_iter<AAB::CurveUpdate *>::__wrap_iter[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

void std::__sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<AAB::CurveUpdate *>,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 *v3;
  __n128 *v4;
  __n128 *v5;

  std::__debug_randomize_range[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>>();
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(a1);
  v5 = v3;
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(a2);
  std::__sort_dispatch[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>(v5, v4, a3);
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(a1);
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(a2);
  std::__check_strict_weak_ordering_sorted[abi:ne180100]<AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>();
}

uint64_t std::__sort_dispatch[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>(__n128 *a1, __n128 *a2, uint64_t a3)
{
  uint64_t v3;

  v3 = std::__log2i[abi:ne180100]<long>(a2 - a1);
  return std::__introsort<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,false>(a1, a2, a3, 2 * v3, 1);
}

void std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(uint64_t a1)
{
  std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>::__unwrap[abi:ne180100](a1);
}

uint64_t std::__log2i[abi:ne180100]<long>(unint64_t a1)
{
  if (a1)
    return 63 - (int)std::__libcpp_clz[abi:ne180100](a1);
  else
    return 0;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,false>(__n128 *a1, __n128 *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t result;
  char v6;
  BOOL v7;
  __n128 *v8;
  __n128 *v9;
  uint64_t v10;
  int64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  __n128 *v17;
  __n128 *v18;

  v18 = a1;
  v17 = a2;
  v16 = a3;
  v15 = a4;
  v14 = a5 & 1;
  v13 = 24;
  v12 = 128;
  while (1)
  {
    v11 = v17 - v18;
    if ((unint64_t)v11 <= 5)
      __asm { BR              X8 }
    if (v11 < 24)
      break;
    if (!v15)
      return std::__partial_sort[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate *>(v18, v17, v17, v16);
    --v15;
    v10 = v11 / 2;
    if (v11 <= 128)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(&v18[v10], v18, v17 - 1, v16);
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v18, &v18[v10], v17 - 1, v16);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v18 + 1, &v18[v10 - 1], v17 - 2, v16);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v18 + 2, &v18[v10 + 1], v17 - 3, v16);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(&v18[v10 - 1], &v18[v10], &v18[v10 + 1], v16);
      v9 = &v18[v10];
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *>(&v18, &v9);
    }
    if ((v14 & 1) != 0
      || CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v16, (uint64_t)&v18[-1], (uint64_t)v18))
    {
      v8 = (__n128 *)std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &>(v18, v17, v16);
      if ((v6 & 1) == 0)
        goto LABEL_22;
      v7 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v18, v8, v16);
      result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v8 + 1, v17, v16);
      if ((result & 1) != 0)
      {
        if (v7)
          return result;
        v17 = v8;
      }
      else if (v7)
      {
        v18 = v8 + 1;
      }
      else
      {
LABEL_22:
        std::__introsort<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,false>(v18, v8, v16, v15, v14 & 1);
        v14 = 0;
        v18 = v8 + 1;
      }
    }
    else
    {
      v18 = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &>(v18, v17, v16);
    }
  }
  if ((v14 & 1) != 0)
    return std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>((_BOOL8)v18, v17, v16);
  else
    return std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>((uint64_t)v18, (uint64_t)v17, v16);
}

unint64_t std::__libcpp_clz[abi:ne180100](unint64_t a1)
{
  return __clz(a1);
}

{
  return __clz(a1);
}

BOOL CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_QWORD *)(a2 + 8) < *(_QWORD *)(a3 + 8);
}

double std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(__n128 **a1, __n128 **a2)
{
  return std::iter_swap[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(*a1, *a2);
}

uint64_t std::__sort3_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(__n128 *a1, __n128 *a2, __n128 *a3, uint64_t a4)
{
  return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(a1, a2, a3, a4);
}

double std::__sort4_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, uint64_t a5)
{
  return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(a1, a2, a3, a4, a5);
}

double std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5, uint64_t a6)
{
  return std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(a1, a2, a3, a4, a5, a6);
}

BOOL std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(_BOOL8 result, _OWORD *a2, uint64_t a3)
{
  _OWORD *v3;
  BOOL v4;
  _OWORD *v5;
  __int128 v6;
  _OWORD *v7;
  _OWORD *i;
  uint64_t v9;
  _OWORD *v10;
  _OWORD *v11;

  v11 = (_OWORD *)result;
  v10 = a2;
  v9 = a3;
  if ((_OWORD *)result != a2)
  {
    for (i = v11 + 1; i != v10; ++i)
    {
      v7 = i - 1;
      result = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v9, (uint64_t)i, (uint64_t)(i - 1));
      if (result)
      {
        v6 = *(_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&i);
        v5 = v7;
        v7 = i;
        do
        {
          v3 = (_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v5);
          *v7 = *v3;
          v7 = v5;
          result = 0;
          v4 = 0;
          if (v5 != v11)
          {
            result = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v9, (uint64_t)&v6, (uint64_t)--v5);
            v4 = result;
          }
        }
        while (v4);
        *v7 = v6;
      }
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(uint64_t result, uint64_t a2, uint64_t a3)
{
  _OWORD *v3;
  _OWORD *v4;
  __int128 v5;
  _OWORD *v6;
  uint64_t v7[2];
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = result;
  v9 = a2;
  v8 = a3;
  if (result != a2)
  {
    v7[1] = v10 - 16;
    for (v7[0] = v10 + 16; v7[0] != v9; v7[0] += 16)
    {
      v6 = (_OWORD *)(v7[0] - 16);
      result = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v8, v7[0], v7[0] - 16);
      if ((result & 1) != 0)
      {
        v5 = *(_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)v7);
        v4 = v6;
        v6 = (_OWORD *)v7[0];
        do
        {
          v3 = (_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v4);
          *v6 = *v3;
          v6 = v4--;
          result = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v8, (uint64_t)&v5, (uint64_t)v4);
        }
        while ((result & 1) != 0);
        *v6 = v5;
      }
    }
  }
  return result;
}

uint64_t std::__partial_sort[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2, __n128 *a3, uint64_t a4)
{
  __n128 *v5;

  if (a1 == a2)
    return std::_IterOps<std::_ClassicAlgPolicy>::next[abi:ne180100]<AAB::CurveUpdate *>((uint64_t)a2, (uint64_t)a3);
  std::__debug_randomize_range[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *>();
  v5 = std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3, a4);
  std::__debug_randomize_range[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *>();
  return (uint64_t)v5;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2, __n128 *a3, uint64_t a4)
{
  unsigned int v5;
  unsigned int v6;
  __n128 *v8;
  __n128 *v9;
  __n128 *v10;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a4, (uint64_t)a2, (uint64_t)a1))
  {
    if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a4, (uint64_t)v8, (uint64_t)v9))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v10, &v8);
      return 1;
    }
    else
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v10, &v9);
      v6 = 1;
      if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a4, (uint64_t)v8, (uint64_t)v9))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v9, &v8);
        return 2;
      }
      return v6;
    }
  }
  else if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a4, (uint64_t)v8, (uint64_t)v9))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v9, &v8);
    v5 = 1;
    if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a4, (uint64_t)v9, (uint64_t)v10))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v10, &v9);
      return 2;
    }
    return v5;
  }
  else
  {
    return 0;
  }
}

double std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *>(__n128 **a1, __n128 **a2)
{
  return std::iter_swap[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(*a1, *a2);
}

__n128 *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &>(__n128 *a1, __n128 *a2, uint64_t a3)
{
  __n128 *v3;
  _BOOL4 v5;
  __n128 *v6;
  __n128 v7;
  __n128 *v8;
  __n128 *v9;
  uint64_t v10;
  __n128 *v11;
  __n128 *v12;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v9 = a1;
  v8 = a2;
  v7 = *(__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v12);
  if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v10, (uint64_t)&v7, (uint64_t)&v11[-1]))
  {
    do
      ++v12;
    while (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v10, (uint64_t)&v7, (uint64_t)v12));
  }
  else
  {
    do
    {
      ++v12;
      LOBYTE(v5) = 0;
      if (v12 < v11)
        v5 = !CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v10, (uint64_t)&v7, (uint64_t)v12);
    }
    while (v5);
  }
  if (v12 < v11)
  {
    do
      --v11;
    while (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v10, (uint64_t)&v7, (uint64_t)v11));
  }
  while (v12 < v11)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v12, &v11);
    do
      ++v12;
    while (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v10, (uint64_t)&v7, (uint64_t)v12));
    do
      --v11;
    while (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v10, (uint64_t)&v7, (uint64_t)v11));
  }
  v6 = v12 - 1;
  if (v9 != &v12[-1])
  {
    v3 = (__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v6);
    *v9 = *v3;
  }
  *v6 = v7;
  return v12;
}

uint64_t std::__bitset_partition[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &>(__n128 *a1, __n128 *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  __n128 *v5;
  _BOOL4 v7;
  __n128 *v8;
  unint64_t v9;
  unint64_t v10;
  __n128 *v11;
  BOOL v12;
  __n128 v13;
  __n128 *v14;
  __n128 *v15;
  uint64_t v16;
  __n128 *v17;
  __n128 *v18;

  v18 = a1;
  v17 = a2;
  v16 = a3;
  v15 = a1;
  v14 = a2;
  v13 = *(__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v18);
  if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v16, (uint64_t)&v13, (uint64_t)&v17[-1]))
  {
    do
      ++v18;
    while (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v16, (uint64_t)&v13, (uint64_t)v18));
  }
  else
  {
    do
    {
      ++v18;
      LOBYTE(v7) = 0;
      if (v18 < v17)
        v7 = !CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v16, (uint64_t)&v13, (uint64_t)v18);
    }
    while (v7);
  }
  if (v18 < v17)
  {
    do
      --v17;
    while (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v16, (uint64_t)&v13, (uint64_t)v17));
  }
  v12 = v18 >= v17;
  if (v18 < v17)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v18, &v17);
    ++v18;
  }
  v11 = v17 - 1;
  v10 = 0;
  v9 = 0;
  while (v11 - v18 >= 127)
  {
    if (!v10)
      std::__populate_left_bitset[abi:ne180100]<CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate>((_BOOL8)v18, v16, (uint64_t)&v13, &v10);
    if (!v9)
      std::__populate_right_bitset[abi:ne180100]<CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate>((_BOOL8)v11, v16, (uint64_t)&v13, &v9);
    std::__swap_bitmap_pos[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *>((uint64_t)v18, (uint64_t)v11, &v10, &v9);
    if (v10)
      v3 = 0;
    else
      v3 = 64;
    v18 += v3;
    if (v9)
      v4 = 0;
    else
      v4 = 64;
    v11 -= v4;
  }
  std::__bitset_partition_partial_blocks[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate>((uint64_t *)&v18, (uint64_t *)&v11, v16, (uint64_t)&v13, &v10, &v9);
  std::__swap_bitmap_pos_within[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *>(&v18, &v11, &v10, &v9);
  v8 = v18 - 1;
  if (v15 != &v18[-1])
  {
    v5 = (__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v8);
    *v15 = *v5;
  }
  *v8 = v13;
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,BOOL &>(&v8, &v12);
}

uint64_t std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &>(__n128 *a1, __n128 *a2, uint64_t a3)
{
  __n128 *v3;
  _BOOL4 v5;
  __n128 *v6;
  BOOL v7;
  __n128 v8;
  __n128 *v9;
  __n128 *v10;
  uint64_t v11;
  __n128 *v12;
  __n128 *v13;

  v13 = a1;
  v12 = a2;
  v11 = a3;
  v10 = a1;
  v9 = a2;
  v8 = *(__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v13);
  do
    ++v13;
  while (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v13, (uint64_t)&v8));
  if (v10 == &v13[-1])
  {
    do
    {
      LOBYTE(v5) = 0;
      if (v13 < v12)
        v5 = !CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)--v12, (uint64_t)&v8);
    }
    while (v5);
  }
  else
  {
    do
      --v12;
    while (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v12, (uint64_t)&v8));
  }
  v7 = v13 >= v12;
  while (v13 < v12)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v13, &v12);
    do
      ++v13;
    while (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v13, (uint64_t)&v8));
    do
      --v12;
    while (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v12, (uint64_t)&v8));
  }
  v6 = v13 - 1;
  if (v10 != &v13[-1])
  {
    v3 = (__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v6);
    *v10 = *v3;
  }
  *v6 = v8;
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,BOOL &>(&v6, &v7);
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2, uint64_t a3)
{
  __n128 *v3;
  BOOL v5;
  unint64_t v6;
  __n128 *v7;
  __n128 v8;
  __n128 *i;
  int v10;
  int v11;
  __n128 *v12;
  uint64_t v13;
  __n128 *v14;
  __n128 *v15;

  v15 = a1;
  v14 = a2;
  v13 = a3;
  v6 = a2 - a1;
  if (v6 <= 5)
    __asm { BR              X8 }
  v12 = v15 + 2;
  std::__sort3_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(v15, v15 + 1, v15 + 2, v13);
  v11 = 8;
  v10 = 0;
  for (i = v15 + 3; i != v14; ++i)
  {
    if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v13, (uint64_t)i, (uint64_t)v12))
    {
      v8 = *(__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&i);
      v7 = v12;
      v12 = i;
      do
      {
        v3 = (__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v7);
        *v12 = *v3;
        v12 = v7;
        v5 = 0;
        if (v7 != v15)
          v5 = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v13, (uint64_t)&v8, (uint64_t)--v7);
      }
      while (v5);
      *v12 = v8;
      if (++v10 == 8)
        return ++i == v14;
    }
    v12 = i;
  }
  return 1;
}

double std::iter_swap[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2)
{
  double result;

  *(_QWORD *)&result = std::swap[abi:ne180100]<AAB::CurveUpdate>(a1, a2).n128_u64[0];
  return result;
}

__n128 std::swap[abi:ne180100]<AAB::CurveUpdate>(__n128 *a1, __n128 *a2)
{
  __n128 result;
  __n128 v3;

  v3 = *a1;
  *a1 = *a2;
  result = v3;
  *a2 = v3;
  return result;
}

double std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, uint64_t a5)
{
  double result;
  __n128 *v7;
  __n128 *v8;
  __n128 *v9;
  __n128 *v10;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v7 = a4;
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(a1, a2, a3, a5);
  if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a5, (uint64_t)v7, (uint64_t)v8))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v8, &v7);
    if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a5, (uint64_t)v8, (uint64_t)v9))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v9, &v8);
      if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a5, (uint64_t)v9, (uint64_t)v10))
        return std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v10, &v9);
    }
  }
  return result;
}

double std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5, uint64_t a6)
{
  double result;
  __n128 *v8;
  __n128 *v9;
  __n128 *v10;
  __n128 *v11;
  __n128 *v12;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v9 = a4;
  v8 = a5;
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(a1, a2, a3, a4, a6);
  if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a6, (uint64_t)v8, (uint64_t)v9))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v9, &v8);
    if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a6, (uint64_t)v9, (uint64_t)v10))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v10, &v9);
      if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a6, (uint64_t)v10, (uint64_t)v11))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v11, &v10);
        if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a6, (uint64_t)v11, (uint64_t)v12))
          return std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v12, &v11);
      }
    }
  }
  return result;
}

uint64_t std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>(uint64_t a1)
{
  std::_IterOps<std::_ClassicAlgPolicy>::__validate_iter_reference[abi:ne180100]<AAB::CurveUpdate *&>();
  return *(_QWORD *)a1;
}

uint64_t std::_IterOps<std::_ClassicAlgPolicy>::next[abi:ne180100]<AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  return a2;
}

__n128 *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2, __n128 *a3, uint64_t a4)
{
  __n128 *i;
  uint64_t v6;
  uint64_t v7;
  __n128 *v8;
  __n128 *v9;
  __n128 *v10;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v7 = a4;
  if (a1 == a2)
    return (__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::next[abi:ne180100]<AAB::CurveUpdate *>((uint64_t)v9, (uint64_t)v8);
  std::__make_heap[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>((uint64_t)v10, (uint64_t)v9, v7);
  v6 = v9 - v10;
  for (i = v9; i != v8; ++i)
  {
    if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v7, (uint64_t)i, (uint64_t)v10))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&i, &v10);
      std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>((uint64_t)v10, v7, v6, v10);
    }
  }
  std::__sort_heap[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>((uint64_t)v10, v9, v7);
  return i;
}

void std::__make_heap[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t i;
  uint64_t v4;

  v4 = (a2 - a1) / 16;
  if (v4 > 1)
  {
    for (i = (v4 - 2) / 2; i >= 0; --i)
      std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(a1, a3, v4, (_OWORD *)(a1 + 16 * i));
  }
}

double std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  double result;
  _OWORD *v5;
  __int128 v6;
  _OWORD *v7;
  uint64_t v8;
  _OWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v9 = a4;
  v8 = ((uint64_t)a4 - a1) / 16;
  if (a3 >= 2 && (v10 - 2) / 2 >= v8)
  {
    v8 = 2 * v8 + 1;
    v7 = (_OWORD *)(v12 + 16 * v8);
    if (v8 + 1 < v10
      && CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v7, (uint64_t)(v7 + 1)))
    {
      ++v7;
      ++v8;
    }
    if (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v7, (uint64_t)v9))
    {
      v6 = *(_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v9);
      do
      {
        v5 = (_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v7);
        *v9 = *v5;
        v9 = v7;
        if ((v10 - 2) / 2 < v8)
          break;
        v8 = 2 * v8 + 1;
        v7 = (_OWORD *)(v12 + 16 * v8);
        if (v8 + 1 < v10
          && CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v7, (uint64_t)(v7 + 1)))
        {
          ++v7;
          ++v8;
        }
      }
      while (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v7, (uint64_t)&v6));
      result = *(double *)&v6;
      *v9 = v6;
    }
  }
  return result;
}

void std::__sort_heap[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  uint64_t i;
  _OWORD *v5;

  v5 = a2;
  for (i = ((uint64_t)a2 - a1) / 16; i > 1; --i)
    std::__pop_heap[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0,AAB::CurveUpdate *>(a1, v5--, a3, i);
  std::__check_strict_weak_ordering_sorted[abi:ne180100]<AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>();
}

double std::__pop_heap[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0,AAB::CurveUpdate *>(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  double result;
  _OWORD *v5;
  __int128 v6;
  _OWORD *v9;
  uint64_t v10;

  v10 = a1;
  v9 = a2;
  if (a4 > 1)
  {
    v6 = *(_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v10);
    v5 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v10, a3, a4);
    if (v5 == --v9)
    {
      result = *(double *)&v6;
      *v5 = v6;
    }
    else
    {
      *v5 = *(_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v9);
      *v9 = v6;
      return std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v10, v5 + 1, a3, ((uint64_t)v5 - v10 + 16) / 16);
    }
  }
  return result;
}

_OWORD *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _OWORD *v3;
  uint64_t v5;
  _OWORD *v6;
  _OWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v7 = (_OWORD *)a1;
  v6 = (_OWORD *)a1;
  v5 = 0;
  do
  {
    v6 += v5 + 1;
    v5 = 2 * v5 + 1;
    if (v5 + 1 < v8
      && CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v9, (uint64_t)v6, (uint64_t)(v6 + 1)))
    {
      ++v6;
      ++v5;
    }
    v3 = (_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v6);
    *v7 = *v3;
    v7 = v6;
  }
  while (v5 <= (v8 - 2) / 2);
  return v7;
}

double std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  double result;
  _OWORD *v5;
  double v6[3];
  _OWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD *v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v8 = a4;
  if (a4 > 1)
  {
    v8 = (v8 - 2) / 2;
    v7 = (_OWORD *)(v11 + 16 * v8);
    if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v9, (uint64_t)v7, (uint64_t)--v10))
    {
      *(_OWORD *)v6 = *(_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v10);
      do
      {
        v5 = (_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v7);
        *v10 = *v5;
        v10 = v7;
        if (!v8)
          break;
        v8 = (v8 - 1) / 2;
        v7 = (_OWORD *)(v11 + 16 * v8);
      }
      while (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v9, (uint64_t)v7, (uint64_t)v6));
      result = v6[0];
      *v10 = *(_OWORD *)v6;
    }
  }
  return result;
}

BOOL std::__populate_left_bitset[abi:ne180100]<CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate>(_BOOL8 result, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  int i;
  uint64_t v5;

  v5 = result;
  for (i = 0; i < 64; ++i)
  {
    result = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a2, v5, a3);
    *a4 |= (unint64_t)!result << i;
    v5 += 16;
  }
  return result;
}

BOOL std::__populate_right_bitset[abi:ne180100]<CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate>(_BOOL8 result, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  int i;
  uint64_t v5;

  v5 = result;
  for (i = 0; i < 64; ++i)
  {
    result = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a2, v5, a3);
    *a4 |= (unint64_t)result << i;
    v5 -= 16;
  }
  return result;
}

void std::__swap_bitmap_pos[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  __n128 *v7;
  __n128 *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11 = a4;
  while (1)
  {
    v6 = 0;
    if (*v12)
      v6 = *v11 != 0;
    if (!v6)
      break;
    v10 = (int)std::__libcpp_ctz[abi:ne180100](*v12);
    v4 = std::__libcpp_blsr[abi:ne180100](*v12);
    *v12 = v4;
    v9 = (int)std::__libcpp_ctz[abi:ne180100](*v11);
    v5 = std::__libcpp_blsr[abi:ne180100](*v11);
    *v11 = v5;
    v8 = (__n128 *)(v14 + 16 * v10);
    v7 = (__n128 *)(v13 - 16 * v9);
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(&v8, &v7);
  }
}

void std::__bitset_partition_partial_blocks[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate>(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, unint64_t *a5, unint64_t *a6)
{
  uint64_t v6;
  uint64_t v7;
  int j;
  uint64_t v9;
  int i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v14 = (*a2 - *a1) / 16 + 1;
  if (*a5 || *a6)
  {
    if (*a5)
    {
      v13 = 64;
      v12 = (*a2 - *a1) / 16 - 63;
    }
    else
    {
      v13 = (*a2 - *a1) / 16 - 63;
      v12 = 64;
    }
  }
  else
  {
    v13 = v14 / 2;
    v12 = v14 - v14 / 2;
  }
  if (!*a5)
  {
    v11 = *a1;
    for (i = 0; i < v13; ++i)
    {
      *a5 |= (unint64_t)!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a3, v11, a4) << i;
      v11 += 16;
    }
  }
  if (!*a6)
  {
    v9 = *a2;
    for (j = 0; j < v12; ++j)
    {
      *a6 |= (unint64_t)CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a3, v9, a4) << j;
      v9 -= 16;
    }
  }
  std::__swap_bitmap_pos[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *>(*a1, *a2, a5, a6);
  if (*a5)
    v7 = 0;
  else
    v7 = v13;
  *a1 += 16 * v7;
  if (*a6)
    v6 = 0;
  else
    v6 = v12;
  *a2 -= 16 * v6;
}

void std::__swap_bitmap_pos_within[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *>(__n128 **a1, __n128 **a2, unint64_t *a3, unint64_t *a4)
{
  int v4;
  int v5;
  __n128 *v6;
  uint64_t v7;
  __n128 *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t *v11;
  __n128 **v12;
  __n128 **v13;

  v13 = a1;
  v12 = a2;
  v11 = a3;
  v10 = a4;
  if (*a3)
  {
    while (*v11)
    {
      v4 = std::__libcpp_clz[abi:ne180100](*v11);
      v9 = 63 - v4;
      *v11 &= (1 << (63 - v4)) - 1;
      v8 = &(*v13)[v9];
      if (v8 != *v12)
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v8, v12);
      --*v12;
    }
    *v13 = *v12 + 1;
  }
  else if (*v10)
  {
    while (*v10)
    {
      v5 = std::__libcpp_clz[abi:ne180100](*v10);
      v7 = 63 - v5;
      *v10 &= (1 << (63 - v5)) - 1;
      v6 = &(*v12)[-v7];
      if (v6 != *v13)
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v6, v13);
      ++*v13;
    }
  }
}

uint64_t std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,BOOL &>(_QWORD *a1, _BYTE *a2)
{
  uint64_t v3;

  std::pair<AAB::CurveUpdate *,BOOL>::pair[abi:ne180100]<AAB::CurveUpdate *&,BOOL &,0>((uint64_t)&v3, a1, a2);
  return v3;
}

unint64_t std::__libcpp_ctz[abi:ne180100](unint64_t a1)
{
  return __clz(__rbit64(a1));
}

uint64_t std::__libcpp_blsr[abi:ne180100](uint64_t a1)
{
  return a1 ^ a1 & -a1;
}

double std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(__n128 **a1, __n128 **a2)
{
  return std::iter_swap[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(*a1, *a2);
}

uint64_t std::pair<AAB::CurveUpdate *,BOOL>::pair[abi:ne180100]<AAB::CurveUpdate *&,BOOL &,0>(uint64_t a1, _QWORD *a2, _BYTE *a3)
{
  std::pair<AAB::CurveUpdate *,BOOL>::pair[abi:ne180100]<AAB::CurveUpdate *&,BOOL &,0>(a1, a2, a3);
  return a1;
}

uint64_t std::pair<AAB::CurveUpdate *,BOOL>::pair[abi:ne180100]<AAB::CurveUpdate *&,BOOL &,0>(uint64_t result, _QWORD *a2, _BYTE *a3)
{
  *(_QWORD *)result = *a2;
  *(_BYTE *)(result + 8) = *a3 & 1;
  return result;
}

void std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>::__unwrap[abi:ne180100](uint64_t a1)
{
  uint64_t v1;

  v1 = a1;
  std::__to_address[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,void>(&v1);
}

void std::__to_address[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,void>(uint64_t *a1)
{
  std::__to_address_helper<std::__wrap_iter<AAB::CurveUpdate *>,void>::__call[abi:ne180100](a1);
}

void std::__to_address_helper<std::__wrap_iter<AAB::CurveUpdate *>,void>::__call[abi:ne180100](uint64_t *a1)
{
  std::pointer_traits<std::__wrap_iter<AAB::CurveUpdate *>>::to_address[abi:ne180100](*a1);
}

void std::pointer_traits<std::__wrap_iter<AAB::CurveUpdate *>>::to_address[abi:ne180100](uint64_t a1)
{
  uint64_t v1;

  v1 = a1;
  std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100]((uint64_t)&v1);
  std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
}

uint64_t std::vector<AAB::CurveUpdate>::__insert_with_size[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate*>,std::__wrap_iter<AAB::CurveUpdate*>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v10;
  uint64_t v12;
  void *v13[5];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v32 = a2;
  v31 = a3;
  v30 = a4;
  v29 = a1;
  v28 = a5;
  v27 = a5;
  v12 = *a1;
  v25 = std::vector<AAB::CurveUpdate>::begin[abi:ne180100](a1);
  v26 = v12 + 16 * std::operator-[abi:ne180100]<AAB::CurveUpdate const*,AAB::CurveUpdate*>((uint64_t)&v32, (uint64_t)&v25);
  if (v28 > 0)
  {
    v10 = v28;
    std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
    if (v10 > (*v5 - a1[1]) / 16)
    {
      std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
      v14 = v6;
      v7 = std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
      v8 = std::vector<AAB::CurveUpdate>::__recommend[abi:ne180100](a1, v7 + v28);
      std::__split_buffer<AAB::CurveUpdate>::__split_buffer(v13, v8, (v26 - *a1) / 16, v14);
      std::__split_buffer<AAB::CurveUpdate>::__construct_at_end_with_size<std::__wrap_iter<AAB::CurveUpdate*>>((uint64_t)v13, v31, v27);
      v26 = std::vector<AAB::CurveUpdate>::__swap_out_circular_buffer(a1, v13, v26);
      std::__split_buffer<AAB::CurveUpdate>::~__split_buffer(v13);
    }
    else
    {
      v24 = v28;
      v23 = a1[1];
      v21 = v31;
      std::next[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,0>();
      v22 = v21;
      v20 = (a1[1] - v26) / 16;
      if (v28 > v20)
      {
        v22 = v31;
        v19 = (a1[1] - v26) / 16;
        std::advance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,long,long,void>(&v22);
        v18 = v22;
        v17 = v30;
        std::vector<AAB::CurveUpdate>::__construct_at_end<std::__wrap_iter<AAB::CurveUpdate*>,std::__wrap_iter<AAB::CurveUpdate*>>((uint64_t)a1, v22, v30, v28 - v19);
        v28 = v20;
      }
      if (v28 > 0)
      {
        std::vector<AAB::CurveUpdate>::__move_range((uint64_t)a1, v26, v23, v26 + 16 * v24);
        v16 = v31;
        v15 = v22;
        std::copy[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(v31, v22, v26);
      }
    }
  }
  return std::vector<AAB::CurveUpdate>::__make_iter[abi:ne180100]((uint64_t)a1, v26);
}

uint64_t std::distance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>>(uint64_t a1, uint64_t a2)
{
  return std::__distance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>>(a1, a2);
}

uint64_t std::operator-[abi:ne180100]<AAB::CurveUpdate const*,AAB::CurveUpdate*>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = std::__wrap_iter<AAB::CurveUpdate const*>::base[abi:ne180100](a1);
  return (v3 - std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](a2)) / 16;
}

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> std::next[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,0>()
{
  uint64_t v0;

  std::advance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,long,long,void>(&v0);
}

_QWORD *std::advance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,long,long,void>(_QWORD *a1)
{
  uint64_t v1;

  std::__convert_to_integral[abi:ne180100]();
  return std::__advance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>>(a1, v1);
}

_QWORD *std::vector<AAB::CurveUpdate>::__construct_at_end<std::__wrap_iter<AAB::CurveUpdate*>,std::__wrap_iter<AAB::CurveUpdate*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = a2;
  v10 = a3;
  v9 = a1;
  v8 = a4;
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, a4);
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  v7 = std::__uninitialized_allocator_copy[abi:ne180100]<std::allocator<AAB::CurveUpdate>,std::__wrap_iter<AAB::CurveUpdate*>,std::__wrap_iter<AAB::CurveUpdate*>,AAB::CurveUpdate*>(v4, v11, v10, v7);
  return std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1B5329A18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15, uint64_t a16, uint64_t a17)
{
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&a17);
  _Unwind_Resume(a1);
}

uint64_t std::vector<AAB::CurveUpdate>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  __n128 *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __n128 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = *(_QWORD *)(a1 + 8);
  v12 = (v13 - a4) / 16;
  v11 = (__n128 *)(a2 + 16 * v12);
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v9, a1, (uint64_t)(a3 - (_QWORD)v11) / 16);
  v8 = v10;
  while ((unint64_t)v11 < v15)
  {
    std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
    v7 = v4;
    std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
    std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,void>(v7, v5, v11++);
    v8 += 16;
    v10 = v8;
  }
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v9);
  return std::move_backward[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(v16, v16 + 16 * v12, v13);
}

uint64_t std::copy[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(a1, a2, a3);
  return v3;
}

uint64_t std::__split_buffer<AAB::CurveUpdate>::__construct_at_end_with_size<std::__wrap_iter<AAB::CurveUpdate*>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 *v3;
  __n128 *v4;
  __n128 *v6;
  uint64_t v7;
  _QWORD v9[5];
  uint64_t v10;

  v10 = a2;
  v9[4] = a1;
  v9[3] = a3;
  std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](v9, (_QWORD *)(a1 + 16), a3);
  while (v9[0] != v9[1])
  {
    v7 = std::__split_buffer<AAB::CurveUpdate>::__alloc[abi:ne180100](a1);
    std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
    v6 = v3;
    v4 = (__n128 *)std::__wrap_iter<AAB::CurveUpdate *>::operator*[abi:ne180100]((uint64_t)&v10);
    std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate&,void>(v7, v6, v4);
    v9[0] += 16;
    std::__wrap_iter<AAB::CurveUpdate *>::operator++[abi:ne180100](&v10);
  }
  return std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100]((uint64_t)v9);
}

uint64_t std::vector<AAB::CurveUpdate>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v14[2];
  uint64_t v15[2];
  unint64_t v16[2];
  _QWORD v17[2];
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t *v21;

  v21 = a1;
  v20 = a2;
  v19 = a3;
  std::vector<AAB::CurveUpdate>::__annotate_delete[abi:ne180100]();
  v18 = v20[1];
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  v11 = v3;
  std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](v16, v19);
  std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](v15, *a1);
  std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](v14, v20[1]);
  v17[0] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<AAB::CurveUpdate>,std::reverse_iterator<AAB::CurveUpdate*>,std::reverse_iterator<AAB::CurveUpdate*>,AAB::CurveUpdate,void>(v11, v16[0], v16[1], v15[0], v15[1], v14[0], v14[1]);
  v17[1] = v4;
  v5 = std::reverse_iterator<AAB::CurveUpdate *>::base[abi:ne180100]((uint64_t)v17);
  v20[1] = v5;
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  v7 = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<AAB::CurveUpdate>,AAB::CurveUpdate*,AAB::CurveUpdate*,AAB::CurveUpdate,void>(v6, v19, a1[1], v20[2]);
  v20[2] = v7;
  std::swap[abi:ne180100]<AAB::CurveUpdate *>(a1, v20 + 1);
  std::swap[abi:ne180100]<AAB::CurveUpdate *>(a1 + 1, v20 + 2);
  std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  v12 = v8;
  std::__split_buffer<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  std::swap[abi:ne180100]<AAB::CurveUpdate *>(v12, v9);
  *v20 = v20[1];
  std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
  std::vector<AAB::CurveUpdate>::__annotate_new[abi:ne180100]();
  return v18;
}

uint64_t std::__wrap_iter<AAB::CurveUpdate const*>::base[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

_QWORD *std::__advance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>>(_QWORD *a1, uint64_t a2)
{
  return std::__wrap_iter<AAB::CurveUpdate *>::operator+=[abi:ne180100](a1, a2);
}

_QWORD *std::__wrap_iter<AAB::CurveUpdate *>::operator+=[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result += 16 * a2;
  return result;
}

uint64_t std::__uninitialized_allocator_copy[abi:ne180100]<std::allocator<AAB::CurveUpdate>,std::__wrap_iter<AAB::CurveUpdate*>,std::__wrap_iter<AAB::CurveUpdate*>,AAB::CurveUpdate*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;

  v9 = std::__unwrap_range[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(a2, a3);
  v8 = v4;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  v6 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<AAB::CurveUpdate>,AAB::CurveUpdate,AAB::CurveUpdate,AAB::CurveUpdate,(void *)0>(a1, v9, v8, v5);
  return std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(a4, v6);
}

uint64_t std::__unwrap_range[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[2];
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v8 = a1;
  v7 = a2;
  v5[1] = a1;
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(a1);
  v6 = v2;
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(v7);
  v5[0] = v3;
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(&v6, v5);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<AAB::CurveUpdate>,AAB::CurveUpdate,AAB::CurveUpdate,AAB::CurveUpdate,(void *)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return std::copy[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(a2, a3, a4);
}

void std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>()
{
  std::__unwrap_iter_impl<AAB::CurveUpdate *,true>::__unwrap[abi:ne180100]();
}

uint64_t std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(uint64_t a1, uint64_t a2)
{
  return std::__unwrap_iter_impl<AAB::CurveUpdate *,true>::__rewrap[abi:ne180100](a1, a2);
}

uint64_t std::make_pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,0>(&v3, a1, a2);
  return v3;
}

_QWORD *std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,0>(a1, a2, a3);
  return a1;
}

_QWORD *std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,0>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

uint64_t std::copy[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3);
  return v3;
}

uint64_t std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3);
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *,0>(a1, a2, a3);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v13 = (const void *)std::__unwrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2);
  v14 = v3;
  v7 = v3;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  v11 = std::__copy_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>((uint64_t)&v10, v13, v7, v4);
  v12 = v5;
  v9 = std::__rewrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(v17, v11);
  v8 = std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(v15, v12);
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(&v9, &v8);
}

uint64_t std::__unwrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  _QWORD v6[3];

  v6[2] = a1;
  v6[1] = a2;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  v6[0] = v2;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  v5 = v3;
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(v6, &v5);
}

uint64_t std::__copy_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>(uint64_t a1, const void *a2, uint64_t a3, char *a4)
{
  return std::__copy_trivial_impl[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(a2, a3, a4);
}

uint64_t std::__rewrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  return std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(a1, a2);
}

uint64_t std::__copy_trivial_impl[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(const void *a1, uint64_t a2, char *a3)
{
  char *v4;
  uint64_t v5;
  char *v6;
  _QWORD v7[2];

  v7[1] = a1;
  v7[0] = a2;
  v6 = a3;
  v5 = (a2 - (uint64_t)a1) / 16;
  std::__constexpr_memmove[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>(a3, a1, v5);
  v4 = &v6[16 * v5];
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *>(v7, &v4);
}

void *std::__constexpr_memmove[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>(void *a1, const void *a2, uint64_t a3)
{
  if (a3)
    memmove(a1, a2, 16 * (a3 - 1) + 16);
  return a1;
}

uint64_t std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *,0>(&v3, a1, a2);
  return v3;
}

_QWORD *std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *,0>(a1, a2, a3);
  return a1;
}

_QWORD *std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *,0>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

void std::__unwrap_iter_impl<AAB::CurveUpdate *,true>::__unwrap[abi:ne180100]()
{
  std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
}

uint64_t std::__unwrap_iter_impl<AAB::CurveUpdate *,true>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
  return a1 + 16 * ((a2 - v2) / 16);
}

uint64_t std::move_backward[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  std::__move_backward[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3);
  return v3;
}

uint64_t std::__move_backward[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3);
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *,0>(a1, a2, a3);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v13 = (const void *)std::__unwrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2);
  v14 = v3;
  v7 = v3;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  v11 = std::__move_backward_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>((uint64_t)&v10, v13, v7, v4);
  v12 = v5;
  v9 = std::__rewrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(v17, v11);
  v8 = std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(v15, v12);
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(&v9, &v8);
}

uint64_t std::__move_backward_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return std::__copy_backward_trivial_impl[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(a2, a3, a4);
}

uint64_t std::__copy_backward_trivial_impl[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  void *v5;
  _QWORD v6[2];

  v6[1] = a1;
  v6[0] = a2;
  v4 = (a2 - (uint64_t)a1) / 16;
  v5 = (void *)(a3 - 16 * v4);
  std::__constexpr_memmove[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>(v5, a1, v4);
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(v6, &v5);
}

uint64_t std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&,0>(&v3, a1, a2);
  return v3;
}

_QWORD *std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&,0>(a1, a2, a3);
  return a1;
}

_QWORD *std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&,0>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

uint64_t std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(a1, a2, a3);
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,0>(a1, a2, a3);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v7;
  _QWORD v8[2];
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = a1;
  v18 = a2;
  v17 = a3;
  v14 = a1;
  v13 = a2;
  v15 = (const void *)std::__unwrap_range[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(a1, a2);
  v16 = v3;
  v7 = v3;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  v11 = std::__copy_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>((uint64_t)&v10, v15, v7, v4);
  v12 = v5;
  v8[1] = v19;
  v9 = std::__rewrap_range[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(v19, v11);
  v8[0] = std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(v17, v12);
  return std::make_pair[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(&v9, v8);
}

uint64_t std::make_pair[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  std::pair<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>::pair[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,0>(&v3, a1, a2);
  return v3;
}

uint64_t std::__rewrap_range[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  return std::__rewrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>>(a1, a2);
}

_QWORD *std::pair<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>::pair[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  std::pair<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>::pair[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,0>(a1, a2, a3);
  return a1;
}

_QWORD *std::pair<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>::pair[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,0>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

uint64_t std::__rewrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>>(uint64_t a1, uint64_t a2)
{
  return std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>::__rewrap[abi:ne180100](a1, a2);
}

uint64_t std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;

  v5 = a1;
  std::__to_address[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,void>(&v5);
  return std::__wrap_iter<AAB::CurveUpdate *>::operator+[abi:ne180100](&v5, (a2 - v2) / 16);
}

uint64_t std::__wrap_iter<AAB::CurveUpdate *>::operator+[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *a1;
  std::__wrap_iter<AAB::CurveUpdate *>::operator+=[abi:ne180100](&v3, a2);
  return v3;
}

_QWORD *std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](a1, a2, a3);
  return a1;
}

double std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate&,void>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  double result;

  *(_QWORD *)&result = std::allocator<AAB::CurveUpdate>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate&>(a1, a2, a3).n128_u64[0];
  return result;
}

uint64_t std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](uint64_t a1)
{
  std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](a1);
  return a1;
}

_QWORD *std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](_QWORD *result, _QWORD *a2, uint64_t a3)
{
  *result = *a2;
  result[1] = *a2 + 16 * a3;
  result[2] = a2;
  return result;
}

__n128 std::allocator<AAB::CurveUpdate>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate&>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](uint64_t result)
{
  **(_QWORD **)(result + 16) = *(_QWORD *)result;
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<AAB::CurveUpdate>,AAB::CurveUpdate*,AAB::CurveUpdate*,AAB::CurveUpdate,void>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return std::move[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(a2, a3, a4);
}

uint64_t std::move[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  std::__move[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3);
  return v3;
}

uint64_t std::__move[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3);
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *,0>(a1, a2, a3);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v13 = (const void *)std::__unwrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2);
  v14 = v3;
  v7 = v3;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  v11 = std::__move_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>((uint64_t)&v10, v13, v7, v4);
  v12 = v5;
  v9 = std::__rewrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(v17, v11);
  v8 = std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(v15, v12);
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(&v9, &v8);
}

uint64_t std::__move_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>(uint64_t a1, const void *a2, uint64_t a3, char *a4)
{
  return std::__copy_trivial_impl[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(a2, a3, a4);
}

uint64_t std::__distance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v4 = a1;
  v3 = a2;
  return std::operator-[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>((uint64_t)&v3, (uint64_t)&v4);
}

uint64_t std::operator-[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](a1);
  return (v3 - std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](a2)) / 16;
}

_QWORD *std::__compressed_pair<CBBOLTS::Bin *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(_QWORD *a1)
{
  std::__compressed_pair<CBBOLTS::Bin *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1);
  return a1;
}

{
  std::__compressed_pair_elem<CBBOLTS::Bin *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin>,1,true>::__compressed_pair_elem[abi:ne180100]((uint64_t)a1);
  return a1;
}

_QWORD *std::__compressed_pair_elem<CBBOLTS::Bin *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(_QWORD *result)
{
  *result = 0;
  return result;
}

uint64_t std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin>,1,true>::__compressed_pair_elem[abi:ne180100](uint64_t a1)
{
  std::allocator<CBBOLTS::Bin>::allocator[abi:ne180100](a1);
  return a1;
}

uint64_t std::allocator<CBBOLTS::Bin>::allocator[abi:ne180100](uint64_t a1)
{
  std::__non_trivial_if<true>::__non_trivial_if[abi:ne180100]();
  return a1;
}

_QWORD *std::vector<CBBOLTS::Bin>::__destroy_vector::__destroy_vector[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::vector<CBBOLTS::Bin>::__destroy_vector::__destroy_vector[abi:ne180100](a1, a2);
  return a1;
}

void std::vector<CBBOLTS::Bin>::__destroy_vector::operator()[abi:ne180100](uint64_t **a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;

  if (**a1)
  {
    std::vector<CBBOLTS::Bin>::__clear[abi:ne180100](*a1);
    std::vector<CBBOLTS::Bin>::__annotate_delete[abi:ne180100]();
    std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
    v3 = v1;
    v2 = (void *)**a1;
    std::vector<CBBOLTS::Bin>::capacity[abi:ne180100](*a1);
    std::allocator_traits<std::allocator<CBBOLTS::Bin>>::deallocate[abi:ne180100](v3, v2);
  }
}

_QWORD *std::vector<CBBOLTS::Bin>::__destroy_vector::__destroy_vector[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

void std::vector<CBBOLTS::Bin>::__clear[abi:ne180100](uint64_t *a1)
{
  std::vector<CBBOLTS::Bin>::__base_destruct_at_end[abi:ne180100]((uint64_t)a1, *a1);
}

void std::allocator_traits<std::allocator<CBBOLTS::Bin>>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
  std::allocator<CBBOLTS::Bin>::deallocate[abi:ne180100](a1, a2);
}

void std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]()
{
  std::__compressed_pair<CBBOLTS::Bin *>::second[abi:ne180100]();
}

{
  std::__compressed_pair<CBBOLTS::Bin *>::second[abi:ne180100]();
}

uint64_t std::vector<CBBOLTS::Bin>::capacity[abi:ne180100](_QWORD *a1)
{
  _QWORD *v1;

  std::vector<CBBOLTS::Bin>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 48;
}

void std::vector<CBBOLTS::Bin>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  CBBOLTS::Bin *v3;
  uint64_t v4;
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 8); a2 != i; i -= 48)
  {
    std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
    v4 = v2;
    std::__to_address[abi:ne180100]<CBBOLTS::Bin>();
    std::allocator_traits<std::allocator<CBBOLTS::Bin>>::destroy[abi:ne180100]<CBBOLTS::Bin,void>(v4, v3);
  }
  *(_QWORD *)(a1 + 8) = a2;
}

void std::allocator_traits<std::allocator<CBBOLTS::Bin>>::destroy[abi:ne180100]<CBBOLTS::Bin,void>(uint64_t a1, CBBOLTS::Bin *a2)
{
  std::allocator<CBBOLTS::Bin>::destroy[abi:ne180100](a1, a2);
}

void std::allocator<CBBOLTS::Bin>::destroy[abi:ne180100](uint64_t a1, CBBOLTS::Bin *a2)
{
  CBBOLTS::Bin::~Bin(a2);
}

void CBBOLTS::Bin::~Bin(CBBOLTS::Bin *this)
{
  CBBOLTS::Bin::~Bin(this);
}

{
  std::list<AAB::CurveUpdate>::~list((uint64_t)this);
}

void std::allocator<CBBOLTS::Bin>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
  std::__libcpp_deallocate[abi:ne180100](a2);
}

void std::__compressed_pair<CBBOLTS::Bin *>::second[abi:ne180100]()
{
  std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin>,1,true>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin>,1,true>::__get[abi:ne180100]();
}

void std::vector<CBBOLTS::Bin>::__end_cap[abi:ne180100]()
{
  std::__compressed_pair<CBBOLTS::Bin *>::first[abi:ne180100]();
}

{
  std::__compressed_pair<CBBOLTS::Bin *>::first[abi:ne180100]();
}

void std::__compressed_pair<CBBOLTS::Bin *>::first[abi:ne180100]()
{
  std::__compressed_pair_elem<CBBOLTS::Bin *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<CBBOLTS::Bin *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<CBBOLTS::Bin *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<CBBOLTS::Bin *,0,false>::__get[abi:ne180100]();
}

uint64_t std::vector<CBBOLTS::Bin>::max_size(uint64_t a1)
{
  uint64_t v2;
  _QWORD v3[2];

  v3[1] = a1;
  std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
  v3[0] = std::allocator_traits<std::allocator<CBBOLTS::Bin>>::max_size[abi:ne180100]<std::allocator<CBBOLTS::Bin>,void>();
  v2 = std::numeric_limits<long>::max[abi:ne180100]();
  return *std::min[abi:ne180100]<unsigned long>(v3, &v2);
}

void std::vector<CBBOLTS::Bin>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void **std::__split_buffer<CBBOLTS::Bin>::__split_buffer(void **a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__split_buffer<CBBOLTS::Bin>::__split_buffer(a1, a2, a3, a4);
  return a1;
}

{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v9;
  _QWORD v11[2];
  uint64_t v12;
  unint64_t v13;
  void **v14;
  void **v15;

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11[1] = a4;
  v15 = a1;
  v11[0] = 0;
  std::__compressed_pair<CBBOLTS::Bin *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<CBBOLTS::Bin> &>(a1 + 3, (uint64_t)v11, a4);
  if (v13)
  {
    v4 = std::__split_buffer<CBBOLTS::Bin>::__alloc[abi:ne180100]((uint64_t)a1);
    *a1 = std::__allocate_at_least[abi:ne180100]<std::allocator<CBBOLTS::Bin>>(v4, v13);
    v13 = v5;
  }
  else
  {
    *a1 = 0;
  }
  v6 = (uint64_t)*a1 + 48 * v12;
  a1[2] = (void *)v6;
  a1[1] = (void *)v6;
  v9 = (unint64_t)*a1 + 48 * v13;
  std::__split_buffer<CBBOLTS::Bin>::__end_cap[abi:ne180100]();
  *v7 = v9;
  return v15;
}

void std::vector<CBBOLTS::Bin>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v10[2];
  uint64_t v11[2];
  uint64_t v12[2];
  _QWORD v13[2];
  _QWORD *v14;
  uint64_t *v15;

  v15 = a1;
  v14 = a2;
  std::vector<CBBOLTS::Bin>::__annotate_delete[abi:ne180100]();
  std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
  v7 = v2;
  std::reverse_iterator<CBBOLTS::Bin *>::reverse_iterator[abi:ne180100](v12, a1[1]);
  std::reverse_iterator<CBBOLTS::Bin *>::reverse_iterator[abi:ne180100](v11, *a1);
  std::reverse_iterator<CBBOLTS::Bin *>::reverse_iterator[abi:ne180100](v10, v14[1]);
  v13[0] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>,std::reverse_iterator<CBBOLTS::Bin*>,std::reverse_iterator<CBBOLTS::Bin*>>(v7, v12[0], v12[1], v11[0], v11[1], v10[0], v10[1]);
  v13[1] = v3;
  v4 = std::reverse_iterator<CBBOLTS::Bin *>::base[abi:ne180100]((uint64_t)v13);
  v14[1] = v4;
  std::swap[abi:ne180100]<CBBOLTS::Bin *>(a1, v14 + 1);
  std::swap[abi:ne180100]<CBBOLTS::Bin *>(a1 + 1, v14 + 2);
  std::vector<CBBOLTS::Bin>::__end_cap[abi:ne180100]();
  v8 = v5;
  std::__split_buffer<CBBOLTS::Bin>::__end_cap[abi:ne180100]();
  std::swap[abi:ne180100]<CBBOLTS::Bin *>(v8, v6);
  *v14 = v14[1];
  std::vector<CBBOLTS::Bin>::size[abi:ne180100](a1);
  std::vector<CBBOLTS::Bin>::__annotate_new[abi:ne180100]();
}

void **std::__split_buffer<CBBOLTS::Bin>::~__split_buffer(void **a1)
{
  std::__split_buffer<CBBOLTS::Bin>::~__split_buffer(a1);
  return a1;
}

{
  uint64_t v2;
  void *v3;

  std::__split_buffer<CBBOLTS::Bin>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
  {
    v2 = std::__split_buffer<CBBOLTS::Bin>::__alloc[abi:ne180100]((uint64_t)a1);
    v3 = *a1;
    std::__split_buffer<CBBOLTS::Bin>::capacity[abi:ne180100](a1);
    std::allocator_traits<std::allocator<CBBOLTS::Bin>>::deallocate[abi:ne180100](v2, v3);
  }
  return a1;
}

uint64_t std::allocator_traits<std::allocator<CBBOLTS::Bin>>::max_size[abi:ne180100]<std::allocator<CBBOLTS::Bin>,void>()
{
  return std::allocator<CBBOLTS::Bin>::max_size[abi:ne180100]();
}

uint64_t std::allocator<CBBOLTS::Bin>::max_size[abi:ne180100]()
{
  return 0x555555555555555;
}

_QWORD *std::__compressed_pair<CBBOLTS::Bin *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<CBBOLTS::Bin> &>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  std::__compressed_pair<CBBOLTS::Bin *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<CBBOLTS::Bin> &>(a1, a2, a3);
  return a1;
}

{
  std::__compressed_pair_elem<CBBOLTS::Bin *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin> &,1,false>::__compressed_pair_elem[abi:ne180100]<std::allocator<CBBOLTS::Bin> &,void>(a1 + 1, a3);
  return a1;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CBBOLTS::Bin>>(uint64_t a1, unint64_t a2)
{
  return std::allocator<CBBOLTS::Bin>::allocate[abi:ne180100](a1, a2);
}

uint64_t std::__split_buffer<CBBOLTS::Bin>::__alloc[abi:ne180100](uint64_t a1)
{
  return std::__compressed_pair<CBBOLTS::Bin *>::second[abi:ne180100](a1 + 24);
}

void std::__split_buffer<CBBOLTS::Bin>::__end_cap[abi:ne180100]()
{
  std::__compressed_pair<CBBOLTS::Bin *>::first[abi:ne180100]();
}

{
  std::__compressed_pair<CBBOLTS::Bin *>::first[abi:ne180100]();
}

_QWORD *std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin> &,1,false>::__compressed_pair_elem[abi:ne180100]<std::allocator<CBBOLTS::Bin> &,void>(_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

void *std::allocator<CBBOLTS::Bin>::allocate[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 > std::allocator_traits<std::allocator<CBBOLTS::Bin>>::max_size[abi:ne180100]<std::allocator<CBBOLTS::Bin>,void>())
    std::__throw_bad_array_new_length[abi:ne180100]();
  return std::__libcpp_allocate[abi:ne180100](48 * a2);
}

uint64_t std::__compressed_pair<CBBOLTS::Bin *>::second[abi:ne180100](uint64_t a1)
{
  return std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin> &,1,false>::__get[abi:ne180100](a1 + 8);
}

uint64_t std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin> &,1,false>::__get[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>,std::reverse_iterator<CBBOLTS::Bin*>,std::reverse_iterator<CBBOLTS::Bin*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 v12;
  __n128 v13[2];
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  _QWORD v18[2];
  __int128 v19;

  v18[0] = a2;
  v18[1] = a3;
  v17[0] = a4;
  v17[1] = a5;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = a1;
  v14 = v16;
  std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>::_AllocatorDestroyRangeReverse[abi:ne180100](&v12, a1, (uint64_t)&v14, (uint64_t)&v16);
  std::__make_exception_guard[abi:ne180100]<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>(&v12, v13);
  while (std::operator!=[abi:ne180100]<CBBOLTS::Bin *,CBBOLTS::Bin *>((uint64_t)v18, (uint64_t)v17))
  {
    v9 = v15;
    std::__to_address[abi:ne180100]<std::reverse_iterator<CBBOLTS::Bin *>,void>((uint64_t)&v16);
    v10 = v7;
    v11 = std::reverse_iterator<CBBOLTS::Bin *>::operator*[abi:ne180100]((uint64_t)v18);
    std::allocator_traits<std::allocator<CBBOLTS::Bin>>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::Bin,void>(v9, v10, v11);
    std::reverse_iterator<CBBOLTS::Bin *>::operator++[abi:ne180100]((uint64_t)v18);
    std::reverse_iterator<CBBOLTS::Bin *>::operator++[abi:ne180100]((uint64_t)&v16);
  }
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::__complete[abi:ne180100]((uint64_t)v13);
  v19 = v16;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v19;
}

_QWORD *std::reverse_iterator<CBBOLTS::Bin *>::reverse_iterator[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::reverse_iterator<CBBOLTS::Bin *>::reverse_iterator[abi:ne180100](a1, a2);
  return a1;
}

uint64_t std::reverse_iterator<CBBOLTS::Bin *>::base[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t *std::swap[abi:ne180100]<CBBOLTS::Bin *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *result;
  *result = *a2;
  *a2 = v2;
  return result;
}

__n128 *std::__make_exception_guard[abi:ne180100]<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>@<X0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  __n128 v3;
  unint64_t v4;
  __n128 *v5;
  __n128 *v6;

  v6 = a2;
  v5 = a1;
  v3 = *a1;
  v4 = a1[1].n128_u64[0];
  return std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::__exception_guard_exceptions[abi:ne180100](a2, &v3);
}

_QWORD *std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>::_AllocatorDestroyRangeReverse[abi:ne180100](_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>::_AllocatorDestroyRangeReverse[abi:ne180100](a1, a2, a3, a4);
  return a1;
}

BOOL std::operator!=[abi:ne180100]<CBBOLTS::Bin *,CBBOLTS::Bin *>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = std::reverse_iterator<CBBOLTS::Bin *>::base[abi:ne180100](a1);
  return v3 != std::reverse_iterator<CBBOLTS::Bin *>::base[abi:ne180100](a2);
}

uint64_t std::allocator_traits<std::allocator<CBBOLTS::Bin>>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::Bin,void>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::allocator<CBBOLTS::Bin>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::Bin>(a1, a2, a3);
}

void std::__to_address[abi:ne180100]<std::reverse_iterator<CBBOLTS::Bin *>,void>(uint64_t a1)
{
  std::__to_address_helper<std::reverse_iterator<CBBOLTS::Bin *>,void>::__call[abi:ne180100](a1);
}

uint64_t std::reverse_iterator<CBBOLTS::Bin *>::operator*[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) - 48;
}

uint64_t std::reverse_iterator<CBBOLTS::Bin *>::operator++[abi:ne180100](uint64_t result)
{
  *(_QWORD *)(result + 8) -= 48;
  return result;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::__complete[abi:ne180100](uint64_t result)
{
  *(_BYTE *)(result + 24) = 1;
  return result;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::~__exception_guard_exceptions[abi:ne180100](a1);
  return a1;
}

{
  if ((*(_BYTE *)(a1 + 24) & 1) == 0)
    std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>::operator()[abi:ne180100](a1);
  return a1;
}

__n128 *std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::__exception_guard_exceptions[abi:ne180100](__n128 *a1, __n128 *a2)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::__exception_guard_exceptions[abi:ne180100](a1, a2);
  return a1;
}

__n128 std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::__exception_guard_exceptions[abi:ne180100](__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a1[1].n128_u8[8] = 0;
  return result;
}

_QWORD *std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>::_AllocatorDestroyRangeReverse[abi:ne180100](_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *result = a2;
  result[1] = a3;
  result[2] = a4;
  return result;
}

uint64_t std::allocator<CBBOLTS::Bin>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::Bin>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CBBOLTS::Bin::Bin(a2, a3);
}

uint64_t CBBOLTS::Bin::Bin(uint64_t a1, uint64_t a2)
{
  CBBOLTS::Bin::Bin(a1, a2);
  return a1;
}

__n128 CBBOLTS::Bin::Bin(uint64_t a1, uint64_t a2)
{
  __n128 result;

  std::list<AAB::CurveUpdate>::list((_QWORD *)a1, (uint64_t *)a2);
  result = *(__n128 *)(a2 + 24);
  *(__n128 *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

_QWORD *std::list<AAB::CurveUpdate>::list(_QWORD *a1, uint64_t *a2)
{
  std::list<AAB::CurveUpdate>::list(a1, a2);
  return a1;
}

{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  _QWORD *v8;

  v8 = a1;
  v7 = a2;
  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
  std::__list_imp<AAB::CurveUpdate>::__list_imp(a1, v2);
  v5 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v6, &v5);
  std::list<AAB::CurveUpdate>::splice((uint64_t)a1, v6, v7);
  return a1;
}

void std::list<AAB::CurveUpdate>::splice(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  if (!std::list<AAB::CurveUpdate>::empty[abi:ne180100]())
  {
    v8 = (_QWORD *)a3[1];
    v7 = *a3;
    std::__list_imp<AAB::CurveUpdate>::__unlink_nodes((uint64_t)v8, *a3);
    std::list<AAB::CurveUpdate>::__link_nodes(a2, v8, v7);
    std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
    v6 = *v3;
    std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
    *v4 += v6;
    std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
    *v5 = 0;
  }
}

_QWORD *std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](_QWORD *a1, _QWORD *a2)
{
  std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](a1, a2);
  return a1;
}

uint64_t std::list<AAB::CurveUpdate>::__link_nodes(uint64_t result, _QWORD *a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)result + 8) = a2;
  *a2 = *(_QWORD *)result;
  *(_QWORD *)result = a3;
  *(_QWORD *)(a3 + 8) = result;
  return result;
}

_QWORD *std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

void std::__to_address_helper<std::reverse_iterator<CBBOLTS::Bin *>,void>::__call[abi:ne180100](uint64_t a1)
{
  std::reverse_iterator<CBBOLTS::Bin *>::operator->[abi:ne180100](a1);
  std::__to_address[abi:ne180100]<CBBOLTS::Bin>();
}

uint64_t std::reverse_iterator<CBBOLTS::Bin *>::operator->[abi:ne180100](uint64_t a1)
{
  return std::reverse_iterator<CBBOLTS::Bin *>::operator*[abi:ne180100](a1);
}

BOOL std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v3;
  _BYTE v4[40];
  _BYTE v5[40];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)a1;
  std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::reverse_iterator[abi:ne180100]((uint64_t)v5, **(_QWORD **)(a1 + 16), *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8));
  std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::reverse_iterator[abi:ne180100]((uint64_t)v4, **(_QWORD **)(a1 + 8), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8));
  return std::__allocator_destroy[abi:ne180100]<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin*>>,std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin*>>>(v3, (uint64_t)v5, (uint64_t)v4);
}

BOOL std::__allocator_destroy[abi:ne180100]<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin*>>,std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BOOL8 result;
  CBBOLTS::Bin *v4;

  while (1)
  {
    result = std::operator!=[abi:ne180100]<std::reverse_iterator<CBBOLTS::Bin *>,std::reverse_iterator<CBBOLTS::Bin *>>(a2, a3);
    if (!result)
      break;
    std::__to_address[abi:ne180100]<std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>,void>(a2);
    std::allocator_traits<std::allocator<CBBOLTS::Bin>>::destroy[abi:ne180100]<CBBOLTS::Bin,void>(a1, v4);
    std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::operator++[abi:ne180100](a2);
  }
  return result;
}

uint64_t std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::reverse_iterator[abi:ne180100](uint64_t a1, unint64_t a2, unint64_t a3)
{
  std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::reverse_iterator[abi:ne180100](a1, a2, a3);
  return a1;
}

BOOL std::operator!=[abi:ne180100]<std::reverse_iterator<CBBOLTS::Bin *>,std::reverse_iterator<CBBOLTS::Bin *>>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[2];
  _QWORD v6[2];
  uint64_t v7;
  uint64_t v8;

  v8 = a1;
  v7 = a2;
  v6[0] = std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::base[abi:ne180100](a1);
  v6[1] = v2;
  v5[0] = std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::base[abi:ne180100](v7);
  v5[1] = v3;
  return std::operator!=[abi:ne180100]<CBBOLTS::Bin *,CBBOLTS::Bin *>((uint64_t)v6, (uint64_t)v5);
}

void std::__to_address[abi:ne180100]<std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>,void>(uint64_t a1)
{
  std::__to_address_helper<std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>,void>::__call[abi:ne180100](a1);
}

uint64_t std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::operator++[abi:ne180100](uint64_t a1)
{
  std::reverse_iterator<CBBOLTS::Bin *>::operator--[abi:ne180100](a1 + 24);
  return a1;
}

uint64_t std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::base[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

void std::__to_address_helper<std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>,void>::__call[abi:ne180100](uint64_t a1)
{
  std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::operator->[abi:ne180100](a1);
  std::__to_address[abi:ne180100]<CBBOLTS::Bin>();
}

uint64_t std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::operator->[abi:ne180100](uint64_t a1)
{
  return std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::operator*[abi:ne180100](a1);
}

uint64_t std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::operator*[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  __int128 v3;
  uint64_t v4;

  v4 = a1;
  v3 = *(_OWORD *)(a1 + 24);
  v1 = std::reverse_iterator<CBBOLTS::Bin *>::operator--[abi:ne180100]((uint64_t)&v3);
  return std::reverse_iterator<CBBOLTS::Bin *>::operator*[abi:ne180100](v1);
}

uint64_t std::reverse_iterator<CBBOLTS::Bin *>::operator--[abi:ne180100](uint64_t result)
{
  *(_QWORD *)(result + 8) += 48;
  return result;
}

__n128 std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::reverse_iterator[abi:ne180100](uint64_t a1, unint64_t a2, unint64_t a3)
{
  __n128 result;
  __n128 v4;

  v4.n128_u64[0] = a2;
  v4.n128_u64[1] = a3;
  *(__n128 *)(a1 + 8) = v4;
  result = v4;
  *(__n128 *)(a1 + 24) = v4;
  return result;
}

_QWORD *std::reverse_iterator<CBBOLTS::Bin *>::reverse_iterator[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  result[1] = a2;
  return result;
}

void std::__split_buffer<CBBOLTS::Bin>::clear[abi:ne180100](uint64_t a1)
{
  std::__split_buffer<CBBOLTS::Bin>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
}

uint64_t std::__split_buffer<CBBOLTS::Bin>::capacity[abi:ne180100](_QWORD *a1)
{
  _QWORD *v1;

  std::__split_buffer<CBBOLTS::Bin>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 48;
}

void std::__split_buffer<CBBOLTS::Bin>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__split_buffer<CBBOLTS::Bin>::__destruct_at_end[abi:ne180100](a1, a2);
}

{
  CBBOLTS::Bin *v2;
  uint64_t v3;

  while (a2 != *(_QWORD *)(a1 + 16))
  {
    v3 = std::__split_buffer<CBBOLTS::Bin>::__alloc[abi:ne180100](a1);
    *(_QWORD *)(a1 + 16) -= 48;
    std::__to_address[abi:ne180100]<CBBOLTS::Bin>();
    std::allocator_traits<std::allocator<CBBOLTS::Bin>>::destroy[abi:ne180100]<CBBOLTS::Bin,void>(v3, v2);
  }
}

uint64_t std::vector<CBBOLTS::BinConfiguration>::__make_iter[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  std::__wrap_iter<CBBOLTS::BinConfiguration const*>::__wrap_iter[abi:ne180100](&v3, a2);
  return v3;
}

_QWORD *std::__wrap_iter<CBBOLTS::BinConfiguration const*>::__wrap_iter[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::__wrap_iter<CBBOLTS::BinConfiguration const*>::__wrap_iter[abi:ne180100](a1, a2);
  return a1;
}

_QWORD *std::__wrap_iter<CBBOLTS::BinConfiguration const*>::__wrap_iter[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

_QWORD *std::vector<CBBOLTS::Bin>::__construct_one_at_end[abi:ne180100]<CBBOLTS::BinConfiguration const&>(uint64_t a1, __n128 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __n128 *v8;
  uint64_t v9;

  v9 = a1;
  v8 = a2;
  std::vector<CBBOLTS::Bin>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, 1);
  std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
  v5 = v2;
  std::__to_address[abi:ne180100]<CBBOLTS::Bin>();
  std::allocator_traits<std::allocator<CBBOLTS::Bin>>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::BinConfiguration const&,void>(v5, v3, v8);
  v7 += 48;
  return std::vector<CBBOLTS::Bin>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1B532C7C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15)
{
  std::vector<CBBOLTS::Bin>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&a15);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CBBOLTS::Bin>::__emplace_back_slow_path<CBBOLTS::BinConfiguration const&>(uint64_t *a1, __n128 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unint64_t v9;
  uint64_t v10;
  void *v11[2];
  uint64_t v12;
  uint64_t v13;
  __n128 *v14;
  uint64_t *v15;

  v15 = a1;
  v14 = a2;
  std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
  v13 = v2;
  v3 = std::vector<CBBOLTS::Bin>::size[abi:ne180100](a1);
  v9 = std::vector<CBBOLTS::Bin>::__recommend[abi:ne180100](a1, v3 + 1);
  v4 = std::vector<CBBOLTS::Bin>::size[abi:ne180100](a1);
  std::__split_buffer<CBBOLTS::Bin>::__split_buffer(v11, v9, v4, v13);
  v10 = v13;
  std::__to_address[abi:ne180100]<CBBOLTS::Bin>();
  std::allocator_traits<std::allocator<CBBOLTS::Bin>>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::BinConfiguration const&,void>(v10, v5, v14);
  v12 += 48;
  std::vector<CBBOLTS::Bin>::__swap_out_circular_buffer(a1, v11);
  v7 = a1[1];
  std::__split_buffer<CBBOLTS::Bin>::~__split_buffer(v11);
  return v7;
}

void sub_1B532C8A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, _Unwind_Exception *exception_object, void *a16)
{
  std::__split_buffer<CBBOLTS::Bin>::~__split_buffer(&a16);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<CBBOLTS::Bin>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  std::vector<CBBOLTS::Bin>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](a1, a2, a3);
  return a1;
}

uint64_t std::allocator_traits<std::allocator<CBBOLTS::Bin>>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::BinConfiguration const&,void>(uint64_t a1, uint64_t a2, __n128 *a3)
{
  return std::allocator<CBBOLTS::Bin>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::BinConfiguration const&>(a1, a2, a3);
}

_QWORD *std::vector<CBBOLTS::Bin>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](_QWORD *a1)
{
  std::vector<CBBOLTS::Bin>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](a1);
  return a1;
}

_QWORD *std::vector<CBBOLTS::Bin>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](_QWORD *result, uint64_t a2, uint64_t a3)
{
  *result = a2;
  result[1] = *(_QWORD *)(a2 + 8);
  result[2] = *(_QWORD *)(a2 + 8) + 48 * a3;
  return result;
}

uint64_t std::allocator<CBBOLTS::Bin>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::BinConfiguration const&>(uint64_t a1, uint64_t a2, __n128 *a3)
{
  __n128 v4;
  unint64_t v5;
  __n128 *v6;
  uint64_t v7;
  uint64_t v8;

  v8 = a1;
  v7 = a2;
  v6 = a3;
  v4 = *a3;
  v5 = a3[1].n128_u64[0];
  return CBBOLTS::Bin::Bin(a2, &v4);
}

uint64_t CBBOLTS::Bin::Bin(uint64_t a1, __n128 *a2)
{
  CBBOLTS::Bin::Bin(a1, a2);
  return a1;
}

__n128 CBBOLTS::Bin::Bin(uint64_t a1, __n128 *a2)
{
  __n128 result;

  std::list<AAB::CurveUpdate>::list[abi:ne180100]((_QWORD *)a1);
  result = *a2;
  *(__n128 *)(a1 + 24) = *a2;
  *(_QWORD *)(a1 + 40) = a2[1].n128_u64[0];
  return result;
}

_QWORD *std::vector<CBBOLTS::Bin>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](_QWORD *result)
{
  *(_QWORD *)(*result + 8) = result[1];
  return result;
}

unint64_t std::vector<CBBOLTS::Bin>::__recommend[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD v7[2];

  v7[1] = a1;
  v7[0] = a2;
  v6 = std::vector<CBBOLTS::Bin>::max_size((uint64_t)a1);
  if (v7[0] > v6)
    std::vector<CBBOLTS::Bin>::__throw_length_error[abi:ne180100]();
  v5 = std::vector<CBBOLTS::Bin>::capacity[abi:ne180100](a1);
  if (v5 >= v6 / 2)
    return v6;
  v4 = 2 * v5;
  return *std::max[abi:ne180100]<unsigned long>(&v4, v7);
}

void std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]()
{
  std::__compressed_pair<CBBOLTS::BinConfiguration *>::second[abi:ne180100]();
}

{
  std::__compressed_pair<CBBOLTS::BinConfiguration *>::second[abi:ne180100]();
}

_QWORD *std::__compressed_pair<CBBOLTS::BinConfiguration *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<CBBOLTS::BinConfiguration>>(_QWORD *a1)
{
  std::__compressed_pair<CBBOLTS::BinConfiguration *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<CBBOLTS::BinConfiguration>>(a1);
  return a1;
}

{
  std::__compressed_pair_elem<CBBOLTS::BinConfiguration *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<CBBOLTS::BinConfiguration>,1,true>::__compressed_pair_elem[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,void>();
  return a1;
}

void std::vector<CBBOLTS::BinConfiguration>::__end_cap[abi:ne180100]()
{
  std::__compressed_pair<CBBOLTS::BinConfiguration *>::first[abi:ne180100]();
}

{
  std::__compressed_pair<CBBOLTS::BinConfiguration *>::first[abi:ne180100]();
}

void std::__compressed_pair<CBBOLTS::BinConfiguration *>::second[abi:ne180100]()
{
  std::__compressed_pair_elem<std::allocator<CBBOLTS::BinConfiguration>,1,true>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<std::allocator<CBBOLTS::BinConfiguration>,1,true>::__get[abi:ne180100]();
}

_QWORD *std::__compressed_pair_elem<CBBOLTS::BinConfiguration *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(_QWORD *result)
{
  *result = 0;
  return result;
}

void std::__compressed_pair<CBBOLTS::BinConfiguration *>::first[abi:ne180100]()
{
  std::__compressed_pair_elem<CBBOLTS::BinConfiguration *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<CBBOLTS::BinConfiguration *,0,false>::__get[abi:ne180100]();
}

_QWORD *std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::__destroy_vector[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::__destroy_vector[abi:ne180100](a1, a2);
  return a1;
}

void std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::operator()[abi:ne180100](uint64_t **a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;

  if (**a1)
  {
    std::vector<CBBOLTS::BinConfiguration>::__clear[abi:ne180100](*a1);
    std::vector<CBBOLTS::BinConfiguration>::__annotate_delete[abi:ne180100]();
    std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]();
    v3 = v1;
    v2 = (void *)**a1;
    std::vector<CBBOLTS::BinConfiguration>::capacity[abi:ne180100](*a1);
    std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::deallocate[abi:ne180100](v3, v2);
  }
}

_QWORD *std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::__destroy_vector[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

void std::vector<CBBOLTS::BinConfiguration>::__clear[abi:ne180100](uint64_t *a1)
{
  std::vector<CBBOLTS::BinConfiguration>::__base_destruct_at_end[abi:ne180100]((uint64_t)a1, *a1);
}

void std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
  std::allocator<CBBOLTS::BinConfiguration>::deallocate[abi:ne180100](a1, a2);
}

uint64_t std::vector<CBBOLTS::BinConfiguration>::capacity[abi:ne180100](_QWORD *a1)
{
  _QWORD *v1;

  std::vector<CBBOLTS::BinConfiguration>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 24;
}

void std::vector<CBBOLTS::BinConfiguration>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 8); a2 != i; i -= 24)
  {
    std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]();
    std::__to_address[abi:ne180100]<CBBOLTS::BinConfiguration>();
    std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::destroy[abi:ne180100]<CBBOLTS::BinConfiguration,void>();
  }
  *(_QWORD *)(a1 + 8) = a2;
}

void std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::destroy[abi:ne180100]<CBBOLTS::BinConfiguration,void>()
{
  std::allocator<CBBOLTS::BinConfiguration>::destroy[abi:ne180100]();
}

void std::allocator<CBBOLTS::BinConfiguration>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
  std::__libcpp_deallocate[abi:ne180100](a2);
}

_QWORD *std::__compressed_pair<CBBOLTS::BinConfiguration *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(_QWORD *a1)
{
  std::__compressed_pair<CBBOLTS::BinConfiguration *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1);
  return a1;
}

{
  std::__compressed_pair_elem<CBBOLTS::BinConfiguration *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<CBBOLTS::BinConfiguration>,1,true>::__compressed_pair_elem[abi:ne180100]((uint64_t)a1);
  return a1;
}

uint64_t std::__make_exception_guard[abi:ne180100]<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](a2, a1);
}

uint64_t std::initializer_list<CBBOLTS::BinConfiguration>::size[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

void std::vector<CBBOLTS::BinConfiguration>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void *v7;

  if (a2 > std::vector<CBBOLTS::BinConfiguration>::max_size((uint64_t)a1))
    std::vector<CBBOLTS::BinConfiguration>::__throw_length_error[abi:ne180100]();
  std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]();
  v7 = std::__allocate_at_least[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>>(v2, a2);
  *a1 = v7;
  a1[1] = v7;
  v5 = *a1 + 24 * v3;
  std::vector<CBBOLTS::BinConfiguration>::__end_cap[abi:ne180100]();
  *v4 = v5;
  std::vector<CBBOLTS::BinConfiguration>::__annotate_new[abi:ne180100]();
}

_QWORD *std::vector<CBBOLTS::BinConfiguration>::__construct_at_end<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v8 = a4;
  std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, a4);
  std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]();
  v7 = std::__uninitialized_allocator_copy[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(v4, v10, v9, v7);
  return std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1B532D3A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15)
{
  std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&a15);
  _Unwind_Resume(a1);
}

uint64_t std::initializer_list<CBBOLTS::BinConfiguration>::begin[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t std::initializer_list<CBBOLTS::BinConfiguration>::end[abi:ne180100](_QWORD *a1)
{
  return *a1 + 24 * a1[1];
}

uint64_t std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::__complete[abi:ne180100](uint64_t result)
{
  *(_BYTE *)(result + 8) = 1;
  return result;
}

uint64_t std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](a1);
  return a1;
}

{
  if ((*(_BYTE *)(a1 + 8) & 1) == 0)
    std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)a1);
  return a1;
}

uint64_t std::__compressed_pair_elem<std::allocator<CBBOLTS::BinConfiguration>,1,true>::__compressed_pair_elem[abi:ne180100](uint64_t a1)
{
  std::allocator<CBBOLTS::BinConfiguration>::allocator[abi:ne180100](a1);
  return a1;
}

uint64_t std::allocator<CBBOLTS::BinConfiguration>::allocator[abi:ne180100](uint64_t a1)
{
  std::__non_trivial_if<true>::__non_trivial_if[abi:ne180100]();
  return a1;
}

uint64_t std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](a1, a2);
  return a1;
}

uint64_t std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = a2;
  *(_BYTE *)(result + 8) = 0;
  return result;
}

uint64_t std::vector<CBBOLTS::BinConfiguration>::max_size(uint64_t a1)
{
  uint64_t v2;
  _QWORD v3[2];

  v3[1] = a1;
  std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]();
  v3[0] = std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::max_size[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,void>();
  v2 = std::numeric_limits<long>::max[abi:ne180100]();
  return *std::min[abi:ne180100]<unsigned long>(v3, &v2);
}

void std::vector<CBBOLTS::BinConfiguration>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>>(uint64_t a1, unint64_t a2)
{
  return std::allocator<CBBOLTS::BinConfiguration>::allocate[abi:ne180100](a1, a2);
}

uint64_t std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::max_size[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,void>()
{
  return std::allocator<CBBOLTS::BinConfiguration>::max_size[abi:ne180100]();
}

uint64_t std::allocator<CBBOLTS::BinConfiguration>::max_size[abi:ne180100]()
{
  return 0xAAAAAAAAAAAAAAALL;
}

void *std::allocator<CBBOLTS::BinConfiguration>::allocate[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 > std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::max_size[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,void>())
    std::__throw_bad_array_new_length[abi:ne180100]();
  return std::__libcpp_allocate[abi:ne180100](24 * a2);
}

_QWORD *std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](a1, a2, a3);
  return a1;
}

uint64_t std::__uninitialized_allocator_copy[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;

  v9 = std::__unwrap_range[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(a2, a3);
  v8 = v4;
  std::__unwrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration *,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>,0>();
  v6 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,CBBOLTS::BinConfiguration const,CBBOLTS::BinConfiguration,CBBOLTS::BinConfiguration,(void *)0>(a1, v9, v8, v5);
  return std::__rewrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration *,CBBOLTS::BinConfiguration *,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>>(a4, v6);
}

_QWORD *std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](_QWORD *a1)
{
  std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](a1);
  return a1;
}

_QWORD *std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](_QWORD *result, uint64_t a2, uint64_t a3)
{
  *result = a2;
  result[1] = *(_QWORD *)(a2 + 8);
  result[2] = *(_QWORD *)(a2 + 8) + 24 * a3;
  return result;
}

uint64_t std::__unwrap_range[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  _QWORD v6[3];

  v6[2] = a1;
  v6[1] = a2;
  std::__unwrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration const*,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>,0>();
  v6[0] = v2;
  std::__unwrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration const*,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>,0>();
  v5 = v3;
  return std::make_pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(v6, &v5);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,CBBOLTS::BinConfiguration const,CBBOLTS::BinConfiguration,CBBOLTS::BinConfiguration,(void *)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return std::copy[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(a2, a3, a4);
}

void std::__unwrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration *,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>,0>()
{
  std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>::__unwrap[abi:ne180100]();
}

uint64_t std::__rewrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration *,CBBOLTS::BinConfiguration *,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>>(uint64_t a1, uint64_t a2)
{
  return std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>::__rewrap[abi:ne180100](a1, a2);
}

uint64_t std::make_pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,0>(&v3, a1, a2);
  return v3;
}

void std::__unwrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration const*,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>,0>()
{
  std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>::__unwrap[abi:ne180100]();
}

_QWORD *std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,0>(a1, a2, a3);
  return a1;
}

_QWORD *std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,0>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

void std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>::__unwrap[abi:ne180100]()
{
  std::__to_address[abi:ne180100]<CBBOLTS::BinConfiguration const>();
}

uint64_t std::copy[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(a1, a2, a3);
  return v3;
}

uint64_t std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(a1, a2, a3);
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*,0>(a1, a2, a3);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v13 = (const void *)std::__unwrap_range[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(a1, a2);
  v14 = v3;
  v7 = v3;
  std::__unwrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration *,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>,0>();
  v11 = std::__copy_trivial::operator()[abi:ne180100]<CBBOLTS::BinConfiguration const,CBBOLTS::BinConfiguration,0>((uint64_t)&v10, v13, v7, v4);
  v12 = v5;
  v9 = std::__rewrap_range[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(v17, v11);
  v8 = std::__rewrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration *,CBBOLTS::BinConfiguration *,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>>(v15, v12);
  return std::make_pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(&v9, &v8);
}

uint64_t std::__copy_trivial::operator()[abi:ne180100]<CBBOLTS::BinConfiguration const,CBBOLTS::BinConfiguration,0>(uint64_t a1, const void *a2, uint64_t a3, char *a4)
{
  return std::__copy_trivial_impl[abi:ne180100]<CBBOLTS::BinConfiguration const,CBBOLTS::BinConfiguration>(a2, a3, a4);
}

uint64_t std::make_pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*,0>(&v3, a1, a2);
  return v3;
}

uint64_t std::__rewrap_range[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(uint64_t a1, uint64_t a2)
{
  return std::__rewrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>>(a1, a2);
}

uint64_t std::__copy_trivial_impl[abi:ne180100]<CBBOLTS::BinConfiguration const,CBBOLTS::BinConfiguration>(const void *a1, uint64_t a2, char *a3)
{
  char *v4;
  uint64_t v5;
  char *v6;
  _QWORD v7[2];

  v7[1] = a1;
  v7[0] = a2;
  v6 = a3;
  v5 = (a2 - (uint64_t)a1) / 24;
  std::__constexpr_memmove[abi:ne180100]<CBBOLTS::BinConfiguration,CBBOLTS::BinConfiguration const,0>(a3, a1, v5);
  v4 = &v6[24 * v5];
  return std::make_pair[abi:ne180100]<CBBOLTS::BinConfiguration const*&,CBBOLTS::BinConfiguration*>(v7, &v4);
}

void *std::__constexpr_memmove[abi:ne180100]<CBBOLTS::BinConfiguration,CBBOLTS::BinConfiguration const,0>(void *a1, const void *a2, uint64_t a3)
{
  if (a3)
    memmove(a1, a2, 24 * (a3 - 1) + 24);
  return a1;
}

uint64_t std::make_pair[abi:ne180100]<CBBOLTS::BinConfiguration const*&,CBBOLTS::BinConfiguration*>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*&,CBBOLTS::BinConfiguration*,0>(&v3, a1, a2);
  return v3;
}

_QWORD *std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*&,CBBOLTS::BinConfiguration*,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*&,CBBOLTS::BinConfiguration*,0>(a1, a2, a3);
  return a1;
}

_QWORD *std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*&,CBBOLTS::BinConfiguration*,0>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

_QWORD *std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*,0>(a1, a2, a3);
  return a1;
}

_QWORD *std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*,0>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

uint64_t std::__rewrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>>(uint64_t a1, uint64_t a2)
{
  return std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>::__rewrap[abi:ne180100](a1, a2);
}

uint64_t std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  std::__to_address[abi:ne180100]<CBBOLTS::BinConfiguration const>();
  return a1 + 24 * ((a2 - v2) / 24);
}

void std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>::__unwrap[abi:ne180100]()
{
  std::__to_address[abi:ne180100]<CBBOLTS::BinConfiguration>();
}

uint64_t std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  std::__to_address[abi:ne180100]<CBBOLTS::BinConfiguration>();
  return a1 + 24 * ((a2 - v2) / 24);
}

_QWORD *std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](_QWORD *result)
{
  *(_QWORD *)(*result + 8) = result[1];
  return result;
}

_QWORD *std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](a1, a2);
  return a1;
}

_QWORD *std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

void std::__list_imp<AAB::CurveUpdate>::__copy_assign_alloc[abi:ne180100]()
{
  std::__list_imp<AAB::CurveUpdate>::__copy_assign_alloc[abi:ne180100]();
}

_QWORD *std::list<AAB::CurveUpdate>::assign<std::__list_const_iterator<AAB::CurveUpdate,void *>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::list<AAB::CurveUpdate>::__assign_with_sentinel[abi:ne180100]<std::__list_const_iterator<AAB::CurveUpdate,void *>,std::__list_const_iterator<AAB::CurveUpdate,void *>>(a1, a2, a3);
}

_QWORD *std::list<AAB::CurveUpdate>::__assign_with_sentinel[abi:ne180100]<std::__list_const_iterator<AAB::CurveUpdate,void *>,std::__list_const_iterator<AAB::CurveUpdate,void *>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;
  _OWORD *v4;
  BOOL v5;
  uint64_t *v7;
  uint64_t v8[4];
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[2];
  uint64_t v12;
  uint64_t v13;

  v13 = a2;
  v12 = a3;
  v11[1] = a1;
  v11[0] = std::list<AAB::CurveUpdate>::begin[abi:ne180100](a1);
  v10 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  while (1)
  {
    v5 = 0;
    if (std::operator!=[abi:ne180100](&v13, &v12))
      v5 = std::operator!=[abi:ne180100](v11, &v10);
    if (!v5)
      break;
    v4 = (_OWORD *)std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
    *(_OWORD *)std::__list_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]() = *v4;
    std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v13);
    std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)v11);
  }
  if (std::operator==[abi:ne180100](v11, &v10))
  {
    std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v9, &v10);
    v8[3] = v13;
    v8[2] = v12;
    result = std::list<AAB::CurveUpdate>::__insert_with_sentinel[abi:ne180100]<std::__list_const_iterator<AAB::CurveUpdate,void *>,std::__list_const_iterator<AAB::CurveUpdate,void *>>(a1, v9, v13, v12);
    v8[1] = (uint64_t)result;
  }
  else
  {
    std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](v8, v11);
    std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v7, &v10);
    return (_QWORD *)std::list<AAB::CurveUpdate>::erase(a1, v8[0], v7);
  }
  return result;
}

_QWORD *std::list<AAB::CurveUpdate>::__insert_with_sentinel[abi:ne180100]<std::__list_const_iterator<AAB::CurveUpdate,void *>,std::__list_const_iterator<AAB::CurveUpdate,void *>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 *v4;
  uint64_t v5;
  __n128 *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _QWORD v14[2];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;

  v19 = a2;
  v18 = a3;
  v17 = a4;
  v16 = a1;
  std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](&v20, a2);
  if (std::operator!=[abi:ne180100](&v18, &v17))
  {
    v4 = (__n128 *)std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
    v14[1] = std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate const&>(a1, 0, 0, v4);
    v15 = 1;
    std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]();
    std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](v14, v5);
    v20 = (_QWORD *)v14[0];
    v13 = v14[0];
    std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v18);
    while (std::operator!=[abi:ne180100](&v18, &v17))
    {
      v11 = v13;
      v6 = (__n128 *)std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
      std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate const&>(a1, v11, 0, v6);
      std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]();
      *(_QWORD *)(v13 + 8) = v7;
      std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v18);
      std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v13);
      ++v15;
    }
    std::list<AAB::CurveUpdate>::__link_nodes(v19, v20, v13);
    v10 = v15;
    std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
    *v8 += v10;
  }
  return v20;
}

uint64_t std::list<AAB::CurveUpdate>::erase(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v3;
  void *v4;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v8 = a2;
  v7 = a3;
  if (std::operator!=[abi:ne180100](&v8, &v7))
  {
    std::__list_imp<AAB::CurveUpdate>::__unlink_nodes(v8, *v7);
    while (std::operator!=[abi:ne180100](&v8, &v7))
    {
      std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v8);
      std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
      --*v3;
      std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]();
      std::__list_imp<AAB::CurveUpdate>::__delete_node[abi:ne180100]<>(a1, v4);
    }
  }
  std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](&v9, (uint64_t)v7);
  return v9;
}

_QWORD *std::initializer_list<AAB::CurveUpdate>::initializer_list[abi:ne180100](_QWORD *result)
{
  *result = 0;
  result[1] = 0;
  return result;
}

_QWORD *std::list<AAB::CurveUpdate>::assign<AAB::CurveUpdate const*>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  return std::list<AAB::CurveUpdate>::__assign_with_sentinel[abi:ne180100]<AAB::CurveUpdate const*,AAB::CurveUpdate const*>(a1, a2, a3);
}

uint64_t std::initializer_list<AAB::CurveUpdate>::begin[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t std::initializer_list<AAB::CurveUpdate>::end[abi:ne180100](_QWORD *a1)
{
  return *a1 + 16 * a1[1];
}

_QWORD *std::list<AAB::CurveUpdate>::__assign_with_sentinel[abi:ne180100]<AAB::CurveUpdate const*,AAB::CurveUpdate const*>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  _QWORD *result;
  __n128 *v4;
  BOOL v5;
  uint64_t *v7;
  uint64_t v8[2];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 *v12;
  __n128 *v13;
  uint64_t v14;

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11 = std::list<AAB::CurveUpdate>::begin[abi:ne180100](a1);
  v10 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  while (1)
  {
    v5 = 0;
    if (v13 != v12)
      v5 = std::operator!=[abi:ne180100](&v11, &v10);
    if (!v5)
      break;
    v4 = v13;
    *(__n128 *)std::__list_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]() = *v4;
    ++v13;
    std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v11);
  }
  if (std::operator==[abi:ne180100](&v11, &v10))
  {
    std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v9, &v10);
    result = std::list<AAB::CurveUpdate>::__insert_with_sentinel[abi:ne180100]<AAB::CurveUpdate const*,AAB::CurveUpdate const*>(a1, v9, v13, v12);
    v8[1] = (uint64_t)result;
  }
  else
  {
    std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](v8, &v11);
    std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v7, &v10);
    return (_QWORD *)std::list<AAB::CurveUpdate>::erase(a1, v8[0], v7);
  }
  return result;
}

_QWORD *std::list<AAB::CurveUpdate>::__insert_with_sentinel[abi:ne180100]<AAB::CurveUpdate const*,AAB::CurveUpdate const*>(uint64_t a1, uint64_t a2, __n128 *a3, __n128 *a4)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v8;
  uint64_t v10;
  _QWORD v11[2];
  uint64_t v12;
  __n128 *v13;
  __n128 *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;

  v16 = a2;
  v15 = a1;
  v14 = a3;
  v13 = a4;
  std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](&v17, a2);
  if (v14 != v13)
  {
    v11[1] = std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate const&>(a1, 0, 0, v14);
    v12 = 1;
    std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]();
    std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](v11, v4);
    v17 = (_QWORD *)v11[0];
    v10 = v11[0];
    ++v14;
    while (v14 != v13)
    {
      std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate const&>(a1, v10, 0, v14);
      std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]();
      *(_QWORD *)(v10 + 8) = v5;
      ++v14;
      std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v10);
      ++v12;
    }
    std::list<AAB::CurveUpdate>::__link_nodes(v16, v17, v10);
    v8 = v12;
    std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
    *v6 += v8;
  }
  return v17;
}

void sub_1B532EB98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id obj, int a12, int a13, _Unwind_Exception *exception_object)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_1B532EC6C(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj)
{
  uint64_t v9;

  *(_QWORD *)(v9 - 24) = a1;
  *(_DWORD *)(v9 - 28) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v9 - 24));
}

void sub_1B532F80C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void sub_1B532FA68()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void sub_1B532FCCC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_0_2_8_0_4_0(uint64_t result, uint64_t a2, int a3)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  return result;
}

uint64_t __os_log_helper_16_2_4_8_64_8_64_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 64;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  return result;
}

float BULuminanceToPerceptual(float a1, float a2, float a3)
{
  float v4;

  v4 = logf(fmaxf(a1, a2) / a3);
  return (float)(v4 / logf(a3 / a2)) + 1.0;
}

float BUPerceptualToLuminance(float a1, float a2, float a3)
{
  return a3 * powf(a3 / a2, a1 - 1.0);
}

float BUIlluminanceToLuminance(uint64_t a1, float a2)
{
  float v3;
  int i;
  float v5;

  v5 = 0.0;
  if (*(int *)(a1 + 160) <= 1)
  {
    if (*(_DWORD *)(a1 + 160) == 1)
      v3 = *(float *)(a1 + 80);
    else
      v3 = 0.0;
    v5 = v3;
  }
  else
  {
    for (i = 0; i < *(_DWORD *)(a1 + 160) - 1; ++i)
    {
      if (a2 <= *(float *)(a1 + 4 * (i + 1)))
      {
        if ((float)(*(float *)(a1 + 4 * (i + 1)) - *(float *)(a1 + 4 * i)) != 0.0)
          v5 = *(float *)(a1 + 80 + 4 * i)
             + (float)((float)((float)(*(float *)(a1 + 80 + 4 * (i + 1)) - *(float *)(a1 + 80 + 4 * i))
                             / (float)(*(float *)(a1 + 4 * (i + 1)) - *(float *)(a1 + 4 * i)))
                     * (float)(a2 - *(float *)(a1 + 4 * i)));
        return fmaxf(fmaxf(v5, 0.0), *(float *)(a1 + 80));
      }
      if (i == *(_DWORD *)(a1 + 160) - 2)
      {
        v5 = *(float *)(a1 + 80 + 4 * (i + 1));
        return fmaxf(fmaxf(v5, 0.0), *(float *)(a1 + 80));
      }
    }
  }
  return fmaxf(fmaxf(v5, 0.0), *(float *)(a1 + 80));
}

float BULuminanceToIlluminance(float *a1, float a2)
{
  float v3;
  int i;
  float v5;
  float v6;

  v6 = 0.0;
  if (*((int *)a1 + 40) <= 1)
  {
    if (*((_DWORD *)a1 + 40) == 1)
      v3 = *a1;
    else
      v3 = 0.0;
    v6 = v3;
  }
  else
  {
    for (i = 0; i < *((_DWORD *)a1 + 40) - 1; ++i)
    {
      if (a2 <= a1[i + 21])
      {
        if ((float)(a1[i + 1] - a1[i]) != 0.0)
        {
          v5 = (float)(a1[i + 21] - a1[i + 20]) / (float)(a1[i + 1] - a1[i]);
          if (v5 == 0.0)
            v6 = fminf(a1[i], 20000.0);
          else
            v6 = fminf((float)((float)(a2 - a1[i + 20]) + (float)(a1[i] * v5)) / v5, 20000.0);
        }
        return fmaxf(v6, 0.0);
      }
      if (i == *((_DWORD *)a1 + 40) - 2)
        return fmaxf(fminf(a1[i + 1], 20000.0), 0.0);
    }
  }
  return fmaxf(v6, 0.0);
}

void PerceptualLuminanceThresholding::PerceptualLuminanceThresholding(PerceptualLuminanceThresholding *this, float a2, float a3, char a4, float a5)
{
  char v6;

  v6 = a4 & 1;
  *(_QWORD *)this = &unk_1E68E93F0;
  *((float *)this + 2) = a5;
  *((_QWORD *)this + 2) = os_log_create("com.apple.CoreBrightness.AABC", "PLT");
  *((_DWORD *)this + 6) = 1045220557;
  *((_DWORD *)this + 7) = 1036831949;
  *((float *)this + 8) = a3;
  *((float *)this + 9) = a2;
  *((_BYTE *)this + 164) = v6 & 1;
}

unint64_t PerceptualLuminanceThresholding::_reconfigureTimeConstantTable(unint64_t this)
{
  BOOL v1;
  unint64_t v2;
  unsigned int i;

  v2 = this;
  if ((*(_BYTE *)(this + 164) & 1) != 0)
  {
    for (i = 0; ; ++i)
    {
      this = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::size[abi:ne180100]();
      v1 = 0;
      if (i < this)
      {
        this = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100](v2 + 60, i);
        v1 = *(float *)this < 0.0;
      }
      if (!v1)
        break;
      *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100](v2 + 60, i)+ 4) = 5.0;
    }
  }
  return this;
}

uint64_t std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::size[abi:ne180100]()
{
  return 13;
}

uint64_t std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return a1 + 8 * a2;
}

{
  return a1 + 8 * a2;
}

void *PerceptualLuminanceThresholding::UpdateTimeConstantTable(PerceptualLuminanceThresholding *this, unsigned int a2)
{
  float *v2;
  uint64_t v3;
  float *v4;
  uint64_t v5;
  float *v6;
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float v10;
  void *result;
  float v12;
  float v13;
  float v14;
  float v15;
  _DWORD __b[26];
  float v18;
  int v19;
  unsigned int v20;
  PerceptualLuminanceThresholding *v21;

  v21 = this;
  v20 = a2;
  v19 = 0;
  v19 = *((_DWORD *)this + 9);
  v18 = 0.0;
  v18 = *((float *)this + 8);
  __b[0] = -1027080192;
  __b[1] = v19;
  __b[2] = -1.0;
  __b[3] = v19;
  __b[4] = -1097229926;
  __b[5] = v19;
  __b[6] = -1102263091;
  __b[7] = v19;
  __b[8] = -1110651699;
  __b[9] = v19;
  __b[10] = 0;
  __b[11] = v19;
  __b[12] = 0;
  *(float *)&__b[13] = v18 * 2.0;
  __b[14] = 1025758986;
  *(float *)&__b[15] = v18 * 2.0;
  __b[16] = 1036831949;
  *(float *)&__b[17] = v18 * 1.714;
  __b[18] = 1045220557;
  *(float *)&__b[19] = v18 * 1.143;
  __b[20] = 1050253722;
  *(float *)&__b[21] = v18;
  __b[22] = 1.0;
  *(float *)&__b[23] = v18;
  __b[24] = 1120403456;
  *(float *)&__b[25] = v18;
  if (a2)
  {
    v2 = (float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 1);
    v12 = (float)-*v2 / (float)v20;
    v3 = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 1);
    *(float *)(v3 + 4) = *(float *)(v3 + 4) * v12;
    v4 = (float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 2);
    v13 = (float)-*v4 / (float)v20;
    v5 = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 2);
    *(float *)(v5 + 4) = *(float *)(v5 + 4) * v13;
    v6 = (float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 3);
    v14 = (float)-*v6 / (float)v20;
    v7 = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 3);
    *(float *)(v7 + 4) = *(float *)(v7 + 4) * v14;
    v8 = (float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 4);
    v15 = (float)-*v8 / (float)v20;
    v9 = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 4);
    *(float *)(v9 + 4) = *(float *)(v9 + 4) * v15;
    v10 = 5.0 / (float)v20;
    *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 5)+ 4) = v10;
  }
  result = memcpy((char *)this + 60, __b, 0x68uLL);
  if ((*((_BYTE *)this + 164) & 1) != 0)
    return (void *)PerceptualLuminanceThresholding::_reconfigureTimeConstantTable((unint64_t)this);
  return result;
}

void *PerceptualLuminanceThresholding::SetAggressivity(PerceptualLuminanceThresholding *this, unsigned int a2)
{
  float v2;
  uint64_t inited;
  NSObject *v5;
  double v6;
  uint8_t v9[56];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *((_DWORD *)this + 10) = a2;
  if (a2)
    v6 = 1.0 / (float)(*((float *)this + 2) * (float)a2);
  else
    v6 = 1.0;
  v2 = v6;
  *((float *)this + 11) = v2;
  *((float *)this + 12) = (float)a2;
  *((_DWORD *)this + 13) = 1128792064;
  *((_DWORD *)this + 14) = 1060320051;
  if (*((_QWORD *)this + 2))
  {
    v5 = *((_QWORD *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v5 = inited;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_5_4_0_8_0_8_0_8_0_8_0((uint64_t)v9, a2, COERCE__INT64(*((float *)this + 11)), COERCE__INT64(*((float *)this + 12)), COERCE__INT64(*((float *)this + 13)), COERCE__INT64(*((float *)this + 14)));
    _os_log_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEFAULT, "Setting aggressivity %d, Parameters: %f, %f, %f, %f", v9, 0x30u);
  }
  return PerceptualLuminanceThresholding::UpdateTimeConstantTable(this, a2);
}

uint64_t __os_log_helper_16_0_5_4_0_8_0_8_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 5;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  return result;
}

float PerceptualLuminanceThresholding::DurationFromPerceptualDelta(PerceptualLuminanceThresholding *this, float a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t inited;
  NSObject *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v14;
  int i;
  float v16;
  uint8_t v18[72];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v16 = 0.0;
  for (i = 0;
        i < (unint64_t)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::size[abi:ne180100]();
        ++i)
  {
    if (a2 <= *(float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i))
    {
      if (i)
      {
        v10 = a2
            - *(float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i - 1);
        v9 = *(float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i);
        v14 = v10
            / (float)(v9
                    - *(float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i - 1));
        v11 = *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i)+ 4);
        v12 = v11
            - *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i - 1)+ 4);
        v16 = *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i - 1)+ 4)+ (float)(v14 * v12);
      }
      else
      {
        v16 = *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, 0)+ 4);
      }
      if (*((_QWORD *)this + 2))
      {
        v8 = *((_QWORD *)this + 2);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v8 = inited;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(double *)&v4 = *(float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i - 1);
        *(double *)&v5 = *(float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i);
        *(double *)&v6 = *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i - 1)+ 4);
        v2 = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i);
        __os_log_helper_16_0_7_8_0_8_0_4_0_8_0_8_0_8_0_8_0((uint64_t)v18, COERCE__INT64(a2), COERCE__INT64(v16), i, v4, v5, v6, COERCE__INT64(*(float *)(v2 + 4)));
        _os_log_debug_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEBUG, "Pdelta=%f timeConstant=%f i=%d  Pdeltas={%f, %f}  Ts={%f, %f}", v18, 0x44u);
      }
      return v16;
    }
  }
  return v16;
}

uint64_t __os_log_helper_16_0_7_8_0_8_0_4_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 7;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 49) = 8;
  *(_QWORD *)(result + 50) = a7;
  *(_BYTE *)(result + 58) = 0;
  *(_BYTE *)(result + 59) = 8;
  *(_QWORD *)(result + 60) = a8;
  return result;
}

void PerceptualLuminanceThresholding_1nit::PerceptualLuminanceThresholding_1nit(PerceptualLuminanceThresholding_1nit *this, unsigned int a2, float a3, float a4, char a5)
{
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v8;
  uint8_t v10[11];
  os_log_type_t v11;
  NSObject *v12;
  char v13;
  float v14;
  float v15;
  unsigned int v16;
  PerceptualLuminanceThresholding_1nit *v17;
  PerceptualLuminanceThresholding_1nit *v18;

  v17 = this;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = a5 & 1;
  v18 = this;
  PerceptualLuminanceThresholding::PerceptualLuminanceThresholding(this, a3, a4, a5 & 1, 1.0);
  *(_QWORD *)this = &unk_1E68E9420;
  *((float *)this + 42) = 0.25;
  *((_DWORD *)this + 43) = 1052602532;
  *((_DWORD *)this + 44) = 1036831949;
  v12 = 0;
  if (*((_QWORD *)this + 2))
  {
    v8 = *((_QWORD *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v8 = inited;
  }
  v12 = v8;
  v11 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    log = v12;
    type = v11;
    __os_log_helper_16_0_0(v10);
    _os_log_impl(&dword_1B5291000, log, type, "Using 1nit PLT logic", v10, 2u);
  }
  PerceptualLuminanceThresholding::SetPthresholdDim((uint64_t)this, 0.1);
  PerceptualLuminanceThresholding::SetAggressivity(this, v16);
}

{
  PerceptualLuminanceThresholding_1nit::PerceptualLuminanceThresholding_1nit(this, a2, a3, a4, a5 & 1);
}

uint64_t PerceptualLuminanceThresholding::SetPthresholdDim(uint64_t this, float a2)
{
  *(float *)(this + 24) = a2;
  return this;
}

void PerceptualLuminanceThresholding::~PerceptualLuminanceThresholding(PerceptualLuminanceThresholding *this)
{
  ;
}

{
  __break(1u);
}

{
  __break(1u);
}

uint64_t PerceptualLuminanceThresholding_1nit::shallUpdateBacklight(PerceptualLuminanceThresholding_1nit *this, float a2, float a3, float a4, char a5, char a6, float a7, float a8)
{
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  os_log_type_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  BOOL v21;
  NSObject *v22;
  os_log_type_t v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t inited;
  NSObject *v27;
  uint8_t v29[15];
  os_log_type_t v30;
  os_log_t v31;
  BOOL v32;
  int v33;
  os_log_type_t v34;
  os_log_t v35;
  BOOL v36;
  int v37;
  os_log_type_t v38;
  os_log_t v39;
  BOOL v40;
  uint8_t v41[7];
  os_log_type_t v42;
  os_log_t oslog;
  os_log_type_t type;
  os_log_t v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  char v54;
  char v55;
  float v56;
  float v57;
  float v58;
  PerceptualLuminanceThresholding_1nit *v59;
  char v60;
  uint8_t v61[32];
  uint8_t v62[32];
  uint8_t v63[48];
  uint8_t v64[32];
  uint8_t v65[152];
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v59 = this;
  v58 = a2;
  v57 = a3;
  v56 = a4;
  v55 = a5 & 1;
  v54 = a6 & 1;
  v53 = a7;
  v52 = a8;
  v51 = a4 - a2;
  v50 = 0.0;
  v49 = 1.0;
  v48 = 1.0;
  if (a3 > *((float *)this + 42))
  {
    if (v57 > *((float *)this + 43))
      v50 = *((float *)this + 44);
    else
      v50 = linear_interpolation(v57, *((float *)this + 42), *((float *)this + 42), *((float *)this + 43), *((float *)this + 44));
  }
  else
  {
    v50 = *((float *)this + 42);
  }
  if (*((_DWORD *)this + 10))
  {
    v48 = *((float *)this + 12);
    if (v58 > v50)
    {
      v49 = *((float *)this + 11);
      if (v52 < *((float *)this + 14) && v53 > *((float *)this + 13))
        v49 = v49 / 2.0;
    }
  }
  v47 = v50 * v49;
  v46 = 0.0;
  v46 = *((float *)this + 7) * v48;
  v45 = 0;
  if (*((_QWORD *)this + 2))
  {
    v27 = *((_QWORD *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v27 = inited;
  }
  v45 = v27;
  type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_14_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v65, (uint64_t)"shallUpdateBacklight", COERCE__INT64(v58), COERCE__INT64(v57), COERCE__INT64(v56), COERCE__INT64(v51), COERCE__INT64(v47), COERCE__INT64(v50), COERCE__INT64(v49), COERCE__INT64(v46), COERCE__INT64(*((float *)this + 7)), COERCE__INT64(v48), COERCE__INT64(*((float *)this + 42)), COERCE__INT64(*((float *)this + 43)), COERCE__INT64(*((float *)this + 44)));
    _os_log_debug_impl(&dword_1B5291000, v45, type, "%s: Pstart=%f Pcurrent=%f Pnewtarget=%f Pdelta=%f Pthreshold_dim=%f (%f * %f) Pthreshold_brighten=%f (%f * %f) plt_x=%f plt_y=%f plt_z=%f", v65, 0x8Eu);
  }
  if (v56 >= 0.97 && v51 > 0.0)
  {
    oslog = 0;
    if (*((_QWORD *)this + 2))
    {
      v25 = *((_QWORD *)this + 2);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v24 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v24 = init_default_corebrightness_log();
      v25 = v24;
    }
    oslog = v25;
    v42 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      v22 = oslog;
      v23 = v42;
      __os_log_helper_16_0_0(v41);
      _os_log_debug_impl(&dword_1B5291000, v22, v23, "Forcing backlight update due to (Pnewtarget >= 0.97f && Pdelta > 0)", v41, 2u);
    }
    v60 = 1;
    return v60 & 1;
  }
  v40 = 0;
  v21 = 1;
  if (v51 <= v46)
    v21 = v51 < (float)-v47;
  v40 = v21;
  if ((v55 & 1) == 0 && v40)
  {
    v39 = 0;
    if (*((_QWORD *)this + 2))
    {
      v20 = *((_QWORD *)this + 2);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v19 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v19 = init_default_corebrightness_log();
      v20 = v19;
    }
    v39 = v20;
    v38 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_2_8_0_8_0((uint64_t)v64, COERCE__INT64((float)-v47), COERCE__INT64(v46));
      _os_log_debug_impl(&dword_1B5291000, v39, v38, "Ramp is not in progress. Thresholds (%f, %f) are satisfied", v64, 0x16u);
    }
    v60 = 1;
    return v60 & 1;
  }
  if ((v55 & 1) != 0 && v40)
  {
    v37 = 1041865114;
    v36 = vabds_f32(v52, 1.0) > 0.15;
    if (v36 || (v54 & 1) != 0)
    {
      v35 = 0;
      if (*((_QWORD *)this + 2))
      {
        v18 = *((_QWORD *)this + 2);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v17 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v17 = init_default_corebrightness_log();
        v18 = v17;
      }
      v35 = v18;
      v34 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v63, COERCE__INT64((float)-v47), COERCE__INT64(v46), 0x402E000020000000, COERCE__INT64(v52));
        _os_log_debug_impl(&dword_1B5291000, v35, v34, "Ramp in progress. Thresholds (%f,%f) are satisfied. Lux change is bigger than %.1f%% (ratio %.3f)", v63, 0x2Au);
      }
      v60 = 1;
      return v60 & 1;
    }
  }
  v33 = 1030590824;
  v32 = fabsf(v51) > 0.058;
  if ((v55 & 1) == 0 || v58 > *((float *)this + 42) || v56 > *((float *)this + 42))
    goto LABEL_87;
  v31 = 0;
  if (*((_QWORD *)this + 2))
  {
    v16 = *((_QWORD *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v15 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v15 = init_default_corebrightness_log();
    v16 = v15;
  }
  v31 = v16;
  v30 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    v13 = v31;
    v14 = v30;
    __os_log_helper_16_0_0(v29);
    _os_log_debug_impl(&dword_1B5291000, v13, v14, "1nit PLT extension", v29, 2u);
  }
  if (v56 > v57)
  {
    if (*((_QWORD *)this + 2))
    {
      v12 = *((_QWORD *)this + 2);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v11 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v11 = init_default_corebrightness_log();
      v12 = v11;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_2_8_0_8_0((uint64_t)v62, COERCE__INT64(v56), COERCE__INT64(v57));
      _os_log_debug_impl(&dword_1B5291000, v12, OS_LOG_TYPE_DEBUG, "Not changing ramp target, because Pnewtarget=%f > Pcurrent=%f", v62, 0x16u);
    }
    v60 = 0;
    return v60 & 1;
  }
  if (!v32)
  {
LABEL_87:
    v60 = 0;
    return v60 & 1;
  }
  if (*((_QWORD *)this + 2))
  {
    v10 = *((_QWORD *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v9 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v9 = init_default_corebrightness_log();
    v10 = v9;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v61, 0xBFADB22D00000000, 0x3FADB22D00000000);
    _os_log_debug_impl(&dword_1B5291000, v10, OS_LOG_TYPE_DEBUG, "Ramp to stuck zone in progress. Thresholds (%f,%f) are satisfied.", v61, 0x16u);
  }
  v60 = 1;
  return v60 & 1;
}

uint64_t __os_log_helper_16_2_14_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 14;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 62) = 0;
  *(_BYTE *)(result + 63) = 8;
  *(_QWORD *)(result + 64) = a8;
  *(_BYTE *)(result + 72) = 0;
  *(_BYTE *)(result + 73) = 8;
  *(_QWORD *)(result + 74) = a9;
  *(_BYTE *)(result + 82) = 0;
  *(_BYTE *)(result + 83) = 8;
  *(_QWORD *)(result + 84) = a10;
  *(_BYTE *)(result + 92) = 0;
  *(_BYTE *)(result + 93) = 8;
  *(_QWORD *)(result + 94) = a11;
  *(_BYTE *)(result + 102) = 0;
  *(_BYTE *)(result + 103) = 8;
  *(_QWORD *)(result + 104) = a12;
  *(_BYTE *)(result + 112) = 0;
  *(_BYTE *)(result + 113) = 8;
  *(_QWORD *)(result + 114) = a13;
  *(_BYTE *)(result + 122) = 0;
  *(_BYTE *)(result + 123) = 8;
  *(_QWORD *)(result + 124) = a14;
  *(_BYTE *)(result + 132) = 0;
  *(_BYTE *)(result + 133) = 8;
  *(_QWORD *)(result + 134) = a15;
  return result;
}

void PerceptualLuminanceThresholding_1nit::SetFloatProperty(PerceptualLuminanceThresholding_1nit *this, NSString *a2, float a3)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t inited;
  NSObject *v10;
  float v12;
  id v13;
  PerceptualLuminanceThresholding_1nit *v14;
  uint8_t v15[32];
  uint8_t v16[32];
  uint8_t v17[32];
  uint8_t v18[24];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v14 = this;
  v13 = a2;
  v12 = a3;
  if (*((_QWORD *)this + 2))
  {
    v10 = *((_QWORD *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v10 = inited;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_2_8_64_8_0((uint64_t)v18, (uint64_t)v13, COERCE__INT64(v12));
    _os_log_debug_impl(&dword_1B5291000, v10, OS_LOG_TYPE_DEBUG, "Received property %@ = %f", v18, 0x16u);
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("PLT_X")) & 1) != 0)
  {
    if (v12 >= *((float *)this + 43))
    {
      if (*((_QWORD *)this + 2))
      {
        v8 = *((_QWORD *)this + 2);
      }
      else
      {
        v7 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        v8 = v7;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v17, COERCE__INT64(v12), COERCE__INT64(*((float *)this + 43)));
        _os_log_debug_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEBUG, "Clamping PLT_X=%f to PLT_Y=%f (X can't be larger than Y)", v17, 0x16u);
      }
    }
    *((float *)this + 42) = *std::min[abi:ne180100]<float>(&v12, (float *)this + 43);
  }
  else if ((objc_msgSend(v13, "isEqualToString:", CFSTR("PLT_Y")) & 1) != 0)
  {
    if (v12 <= *((float *)this + 42))
    {
      if (*((_QWORD *)this + 2))
      {
        v6 = *((_QWORD *)this + 2);
      }
      else
      {
        v5 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        v6 = v5;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v16, COERCE__INT64(v12), COERCE__INT64(*((float *)this + 42)));
        _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "Clamping PLT_Y=%f to PLT_X=%f (Y can't be smaller than X)", v16, 0x16u);
      }
    }
    *((float *)this + 43) = *std::max[abi:ne180100]<float>(&v12, (float *)this + 42);
  }
  else if ((objc_msgSend(v13, "isEqualToString:", CFSTR("PLT_Z")) & 1) != 0)
  {
    *((float *)this + 44) = v12;
  }
  if (*((_QWORD *)this + 2))
  {
    v4 = *((_QWORD *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v3 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v3 = init_default_corebrightness_log();
    v4 = v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v15, COERCE__INT64(*((float *)this + 42)), COERCE__INT64(*((float *)this + 43)), COERCE__INT64(*((float *)this + 44)));
    _os_log_debug_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEBUG, "PLT_X=%f PLT_Y=%f PLT_Z=%f", v15, 0x20u);
  }
}

float *std::min[abi:ne180100]<float>(float *a1, float *a2)
{
  return std::min[abi:ne180100]<float,std::__less<void,void>>(a1, a2);
}

float *std::max[abi:ne180100]<float>(float *a1, float *a2)
{
  return std::max[abi:ne180100]<float,std::__less<void,void>>(a1, a2);
}

void PerceptualLuminanceThresholding_legacy::PerceptualLuminanceThresholding_legacy(PerceptualLuminanceThresholding_legacy *this, unsigned int a2, float a3, float a4, char a5)
{
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v8;
  uint8_t v10[11];
  os_log_type_t v11;
  NSObject *v12;
  char v13;
  float v14;
  float v15;
  unsigned int v16;
  PerceptualLuminanceThresholding_legacy *v17;
  PerceptualLuminanceThresholding_legacy *v18;

  v17 = this;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = a5 & 1;
  v18 = this;
  PerceptualLuminanceThresholding::PerceptualLuminanceThresholding(this, a3, a4, a5 & 1, 2.0);
  *(_QWORD *)this = &unk_1E68E9450;
  v12 = 0;
  if (*((_QWORD *)this + 2))
  {
    v8 = *((_QWORD *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v8 = inited;
  }
  v12 = v8;
  v11 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    log = v12;
    type = v11;
    __os_log_helper_16_0_0(v10);
    _os_log_impl(&dword_1B5291000, log, type, "Using legacy PLT logic", v10, 2u);
  }
  PerceptualLuminanceThresholding::SetAggressivity(this, v16);
}

{
  PerceptualLuminanceThresholding_legacy::PerceptualLuminanceThresholding_legacy(this, a2, a3, a4, a5 & 1);
}

void PerceptualLuminanceThresholding_legacy::SetFloatProperty(PerceptualLuminanceThresholding_legacy *this, NSString *a2, float a3)
{
  ;
}

uint64_t PerceptualLuminanceThresholding_legacy::shallUpdateBacklight(PerceptualLuminanceThresholding_legacy *this, float a2, float a3, float a4, char a5, char a6, float a7, float a8)
{
  NSObject *v9;
  os_log_type_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t inited;
  NSObject *v14;
  uint8_t v16[7];
  os_log_type_t v17;
  os_log_t oslog;
  os_log_type_t v19;
  os_log_t v20;
  float v21;
  float v22;
  char v23;
  float v24;
  float v25;
  float v26;
  char v27;
  char v28;
  float v29;
  float v30;
  float v31;
  PerceptualLuminanceThresholding_legacy *v32;
  uint8_t v33[40];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v32 = this;
  v31 = a2;
  v30 = a3;
  v29 = a4;
  v28 = a5 & 1;
  v27 = a6 & 1;
  v26 = a7;
  v25 = a8;
  v24 = a4 - a2;
  v23 = 0;
  v22 = 0.0;
  v22 = *((float *)this + 6);
  v21 = 0.0;
  v21 = *((float *)this + 7);
  if (*((_DWORD *)this + 10))
  {
    v21 = *((float *)this + 7) * *((float *)this + 12);
    if (v31 > *((float *)this + 6))
    {
      v22 = *((float *)this + 6) * *((float *)this + 11);
      v20 = 0;
      if (*((_QWORD *)this + 2))
      {
        v14 = *((_QWORD *)this + 2);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v14 = inited;
      }
      v20 = v14;
      v19 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v33, COERCE__INT64(*((float *)this + 6)), COERCE__INT64(v22), COERCE__INT64(v31));
        _os_log_debug_impl(&dword_1B5291000, v20, v19, "%f %f %f", v33, 0x20u);
      }
      if (v25 < *((float *)this + 14) && v26 > *((float *)this + 13))
      {
        oslog = 0;
        if (*((_QWORD *)this + 2))
        {
          v12 = *((_QWORD *)this + 2);
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v11 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v11 = init_default_corebrightness_log();
          v12 = v11;
        }
        oslog = v12;
        v17 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          v9 = oslog;
          v10 = v17;
          __os_log_helper_16_0_0(v16);
          _os_log_debug_impl(&dword_1B5291000, v9, v10, "Double aggressivity", v16, 2u);
        }
        v22 = v22 / 2.0;
      }
    }
  }
  if ((v28 & 1) != 0)
  {
    if (v29 < 0.97 || v24 <= 0.0)
    {
      if (v24 <= v21)
      {
        if (v24 < (float)-v22 && (v25 <= 0.85 || v25 >= 1.15 || (v27 & 1) != 0))
          v23 = 1;
      }
      else if (v25 <= 0.85 || v25 >= 1.15 || (v27 & 1) != 0)
      {
        v23 = 1;
      }
    }
    else
    {
      v23 = 1;
    }
  }
  else if (v29 < 0.97 || v24 <= 0.0)
  {
    if (v24 <= v21)
    {
      if (v24 < (float)-v22)
        v23 = 1;
    }
    else
    {
      v23 = 1;
    }
  }
  else
  {
    v23 = 1;
  }
  return v23 & 1;
}

void PerceptualLuminanceThresholding_1nit::~PerceptualLuminanceThresholding_1nit(PerceptualLuminanceThresholding_1nit *this)
{
  PerceptualLuminanceThresholding_1nit::~PerceptualLuminanceThresholding_1nit(this);
}

{
  PerceptualLuminanceThresholding_1nit::~PerceptualLuminanceThresholding_1nit(this);
  MEMORY[0x1B5E4A400](this, 0x1081C40BE6C51FCLL);
}

{
  PerceptualLuminanceThresholding::~PerceptualLuminanceThresholding(this);
}

void PerceptualLuminanceThresholding_legacy::~PerceptualLuminanceThresholding_legacy(PerceptualLuminanceThresholding_legacy *this)
{
  PerceptualLuminanceThresholding_legacy::~PerceptualLuminanceThresholding_legacy(this);
}

{
  PerceptualLuminanceThresholding_legacy::~PerceptualLuminanceThresholding_legacy(this);
  MEMORY[0x1B5E4A400](this, 0x1081C40B823A476);
}

{
  PerceptualLuminanceThresholding::~PerceptualLuminanceThresholding(this);
}

float *std::min[abi:ne180100]<float,std::__less<void,void>>(float *a1, float *a2)
{
  char v6;

  if (std::__less<void,void>::operator()[abi:ne180100]<float,float>((uint64_t)&v6, a2, a1))
    return a2;
  else
    return a1;
}

BOOL std::__less<void,void>::operator()[abi:ne180100]<float,float>(uint64_t a1, float *a2, float *a3)
{
  return *a2 < *a3;
}

float *std::max[abi:ne180100]<float,std::__less<void,void>>(float *a1, float *a2)
{
  char v6;

  if (std::__less<void,void>::operator()[abi:ne180100]<float,float>((uint64_t)&v6, a1, a2))
    return a2;
  else
    return a1;
}

char *strstr[abi:ne180100](char *a1, const char *a2)
{
  return strstr(a1, a2);
}

uint64_t __os_log_helper_16_0_4_8_0_4_0_8_0_8_0(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  return result;
}

uint64_t __os_log_helper_16_0_8_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 8;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 62) = 0;
  *(_BYTE *)(result + 63) = 8;
  *(_QWORD *)(result + 64) = a8;
  *(_BYTE *)(result + 72) = 0;
  *(_BYTE *)(result + 73) = 8;
  *(_QWORD *)(result + 74) = a9;
  return result;
}

void sub_1B5337C9C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_3_8_64_8_64_8_64(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 64;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 64;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

void sub_1B53389E4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void sub_1B5338F38()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_2_4_0_8_64(uint64_t result, int a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 64;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  return result;
}

void sub_1B533C940()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 6;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  return result;
}

void sub_1B53412E4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_3_8_64_8_64_8_34(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 64;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 34;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_64_8_0_8_64(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 64;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

void sub_1B5341AD8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void sub_1B5341E28()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_2_8_0_8_64(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 64;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_64_8_64_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 64;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 32;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

void sub_1B53433F4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void sub_1B5344580()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_4_8_32_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_64_8_64_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 64;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

uint64_t __os_log_helper_16_0_3_8_0_4_0_8_0(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  return result;
}

uint64_t keyboardUsesAdjustedBrightnessCurve(int a1)
{
  char v2;

  v2 = 0;
  if (a1 == 630 || a1 == 631 || a1 == 632 || a1 == 633 || a1 == 634 || a1 == 635 || a1 == 636 || a1 == 637)
    v2 = 1;
  return v2 & 1;
}

uint64_t __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 7;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 62) = 0;
  *(_BYTE *)(result + 63) = 8;
  *(_QWORD *)(result + 64) = a8;
  return result;
}

id getMLModelClass_0()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLModelClass_softClass_0;
  v13 = getMLModelClass_softClass_0;
  if (!getMLModelClass_softClass_0)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLModelClass_block_invoke_0;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLModelClass_block_invoke_0((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

id getMLArrayBatchProviderClass_0()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLArrayBatchProviderClass_softClass_0;
  v13 = getMLArrayBatchProviderClass_softClass_0;
  if (!getMLArrayBatchProviderClass_softClass_0)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLArrayBatchProviderClass_block_invoke_0;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLArrayBatchProviderClass_block_invoke_0((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

uint64_t __getMLFeatureValueClass_block_invoke_0(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_0();
  Class = objc_getClass("MLFeatureValue");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLFeatureValueClass_softClass_0 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CoreMLLibrary_0()
{
  uint64_t v1;

  v1 = CoreMLLibraryCore_0();
  if (!v1)
    abort_report_np();
  return v1;
}

uint64_t CoreMLLibraryCore_0()
{
  if (!CoreMLLibraryCore_frameworkLibrary_0)
    __CoreMLLibraryCore_block_invoke_0();
  return CoreMLLibraryCore_frameworkLibrary_0;
}

uint64_t __getMLModelClass_block_invoke_0(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_0();
  Class = objc_getClass("MLModel");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLModelClass_softClass_0 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLPredictionOptionsClass_block_invoke_0(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_0();
  Class = objc_getClass("MLPredictionOptions");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLPredictionOptionsClass_softClass_0 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLArrayBatchProviderClass_block_invoke_0(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_0();
  Class = objc_getClass("MLArrayBatchProvider");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLArrayBatchProviderClass_softClass_0 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void CBHybridUpdateCurveStrategy::CBHybridUpdateCurveStrategy(CBHybridUpdateCurveStrategy *this, AAB::UpdateCurveStrategy *a2, AAB::UpdateCurveStrategy *a3)
{
  NSObject *v3;
  os_log_type_t v4;
  NSObject *inited;
  NSObject *v6;
  os_log_type_t v7;
  NSObject *v8;
  NSObject *log;
  os_log_type_t type;
  NSObject *v11;
  uint8_t v13[7];
  char v14;
  NSObject *v15;
  uint8_t v16[7];
  char v17;
  NSObject *v18;
  uint8_t v19[11];
  char v20;
  NSObject *v21;
  AAB::UpdateCurveStrategy *v22;
  AAB::UpdateCurveStrategy *v23;
  CBHybridUpdateCurveStrategy *v24;
  CBHybridUpdateCurveStrategy *v25;

  v24 = this;
  v23 = a2;
  v22 = a3;
  v25 = this;
  AAB::UpdateCurveStrategy::UpdateCurveStrategy(this);
  *(_QWORD *)this = &unk_1E68E94F0;
  *((_QWORD *)this + 1) = os_log_create("com.apple.CoreBrightness.CBHybridUpdateCurveStrategy", "default");
  if (!*((_QWORD *)this + 1))
  {
    v21 = 0;
    v11 = (_COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log());
    v21 = v11;
    v20 = 16;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      log = v21;
      type = v20;
      __os_log_helper_16_0_0(v19);
      _os_log_error_impl(&dword_1B5291000, log, type, "Failed to create CBHybridUpdateCurveStrategy log handle", v19, 2u);
    }
  }
  if (!v23)
  {
    v18 = 0;
    v8 = (_COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log());
    v18 = v8;
    v17 = 16;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v6 = v18;
      v7 = v17;
      __os_log_helper_16_0_0(v16);
      _os_log_error_impl(&dword_1B5291000, v6, v7, "Baseline strategy is null.", v16, 2u);
    }
  }
  if (!v22)
  {
    v15 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v15 = inited;
    v14 = 16;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
    {
      v3 = v15;
      v4 = v14;
      __os_log_helper_16_0_0(v13);
      _os_log_error_impl(&dword_1B5291000, v3, v4, "Alternative strategy is null.", v13, 2u);
    }
  }
  *((_QWORD *)this + 2) = v23;
  *((_QWORD *)this + 3) = v22;
}

{
  CBHybridUpdateCurveStrategy::CBHybridUpdateCurveStrategy(this, a2, a3);
}

void CBHybridUpdateCurveStrategy::~CBHybridUpdateCurveStrategy(CBHybridUpdateCurveStrategy *this)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)this = &unk_1E68E94F0;
  if (*((_QWORD *)this + 2))
  {
    v2 = *((_QWORD *)this + 2);
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  }
  if (*((_QWORD *)this + 3))
  {
    v1 = *((_QWORD *)this + 3);
    if (v1)
      (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  }
  if (*((_QWORD *)this + 1))
  {

    *((_QWORD *)this + 1) = 0;
  }
  AAB::UpdateCurveStrategy::~UpdateCurveStrategy(this);
}

{
  CBHybridUpdateCurveStrategy::~CBHybridUpdateCurveStrategy(this);
}

{
  CBHybridUpdateCurveStrategy::~CBHybridUpdateCurveStrategy(this);
  MEMORY[0x1B5E4A400](this, 0xA1C40711E6FFCLL);
}

void CBHybridUpdateCurveStrategy::UpdateCurve(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5, float a6)
{
  uint64_t v6;
  NSObject *log;
  os_log_type_t v8;
  NSObject *inited;
  uint8_t v10[15];
  os_log_type_t type;
  os_log_t oslog;
  unint64_t v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  float v19;

  v18 = __PAIR64__(LODWORD(a5), LODWORD(a4));
  v19 = a6;
  v17 = a1;
  v16 = a2;
  v15 = a3;
  if (*(_QWORD *)(a1 + 16))
  {
    v6 = *(_QWORD *)(a1 + 16);
    v13 = v18;
    v14 = v19;
    (*(void (**)(uint64_t, uint64_t, uint64_t, float, float, float))(*(_QWORD *)v6 + 24))(v6, v16, v15, *(float *)&v18, *((float *)&v18 + 1), v19);
  }
  else
  {
    oslog = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    oslog = inited;
    type = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
    {
      log = oslog;
      v8 = type;
      __os_log_helper_16_0_0(v10);
      _os_log_error_impl(&dword_1B5291000, log, v8, "Baseline strategy were not initialized.", v10, 2u);
    }
  }
}

void CBHybridUpdateCurveStrategy::UpdateCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, float a6, float a7, float a8)
{
  uint64_t v8;
  NSObject *log;
  os_log_type_t v10;
  NSObject *inited;
  uint8_t v12[15];
  os_log_type_t type;
  os_log_t oslog;
  unint64_t v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  float v23;

  v22 = __PAIR64__(LODWORD(a7), LODWORD(a6));
  v23 = a8;
  v21 = a1;
  v20 = a2;
  v19 = a3;
  v18 = a4;
  v17 = a5;
  if (*(_QWORD *)(a1 + 16))
  {
    v8 = *(_QWORD *)(a1 + 16);
    v15 = v22;
    v16 = v23;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, float, float, float))(*(_QWORD *)v8 + 32))(v8, v20, v19, v18, v17, *(float *)&v22, *((float *)&v22 + 1), v23);
  }
  else
  {
    oslog = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    oslog = inited;
    type = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
    {
      log = oslog;
      v10 = type;
      __os_log_helper_16_0_0(v12);
      _os_log_error_impl(&dword_1B5291000, log, v10, "Baseline strategy were not initialized.", v12, 2u);
    }
  }
}

void CBHybridUpdateCurveStrategy::UpdateAlternativeCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, float a6, float a7, float a8)
{
  uint64_t v8;
  NSObject *log;
  os_log_type_t v10;
  NSObject *inited;
  uint8_t v12[15];
  os_log_type_t type;
  os_log_t oslog;
  unint64_t v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  float v23;

  v22 = __PAIR64__(LODWORD(a7), LODWORD(a6));
  v23 = a8;
  v21 = a1;
  v20 = a2;
  v19 = a3;
  v18 = a4;
  v17 = a5;
  if (*(_QWORD *)(a1 + 24))
  {
    v8 = *(_QWORD *)(a1 + 24);
    v15 = v22;
    v16 = v23;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, float, float, float))(*(_QWORD *)v8 + 32))(v8, v20, v19, v18, v17, *(float *)&v22, *((float *)&v22 + 1), v23);
  }
  else
  {
    oslog = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    oslog = inited;
    type = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
    {
      log = oslog;
      v10 = type;
      __os_log_helper_16_0_0(v12);
      _os_log_error_impl(&dword_1B5291000, log, v10, "Alternative strategy were not initialized.", v12, 2u);
    }
  }
}

uint64_t CBHybridUpdateCurveStrategy::curveUpdates@<X0>(CBHybridUpdateCurveStrategy *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  uint64_t v5[3];
  uint64_t v6[3];
  char v7;
  CBHybridUpdateCurveStrategy *v8;
  _QWORD *v9;

  v9 = a2;
  v8 = this;
  v7 = 0;
  std::list<AAB::CurveUpdate>::list[abi:ne180100](a2);
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 2) + 48))(v6);
  std::list<AAB::CurveUpdate>::operator=((uint64_t)a2, v6);
  std::list<AAB::CurveUpdate>::~list((uint64_t)v6);
  result = std::list<AAB::CurveUpdate>::empty[abi:ne180100]();
  if ((result & 1) != 0)
  {
    (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 3) + 48))(v5);
    std::list<AAB::CurveUpdate>::operator=((uint64_t)a2, v5);
    return std::list<AAB::CurveUpdate>::~list((uint64_t)v5);
  }
  return result;
}

uint64_t std::list<AAB::CurveUpdate>::operator=(uint64_t a1, uint64_t *a2)
{
  std::list<AAB::CurveUpdate>::__move_assign(a1, a2);
  return a1;
}

uint64_t CBHybridUpdateCurveStrategy::SetCurveUpdates(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = result;
  if (*(_QWORD *)(result + 16))
    result = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(result + 16) + 56))(*(_QWORD *)(result + 16), a2);
  if (*(_QWORD *)(v2 + 24))
    return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 24) + 56))(*(_QWORD *)(v2 + 24), a2);
  return result;
}

uint64_t CBHybridUpdateCurveStrategy::Reset(uint64_t this)
{
  uint64_t v1;

  v1 = this;
  if (*(_QWORD *)(this + 16))
    this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(this + 16) + 16))(*(_QWORD *)(this + 16));
  if (*(_QWORD *)(v1 + 24))
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 24) + 16))(*(_QWORD *)(v1 + 24));
  return this;
}

uint64_t CBHybridUpdateCurveStrategy::alternativeCappedCurve(uint64_t a1, uint64_t a2)
{
  char v3;

  v3 = 0;
  if (*(_QWORD *)(a1 + 24))
    v3 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24), a2) & 1;
  return v3 & 1;
}

uint64_t CBHybridUpdateCurveStrategy::cappedCurve(uint64_t a1, uint64_t a2)
{
  char v3;

  v3 = 0;
  if (*(_QWORD *)(a1 + 16))
    v3 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 16) + 64))(*(_QWORD *)(a1 + 16), a2) & 1;
  return v3 & 1;
}

uint64_t CBHybridUpdateCurveStrategy::setCappedCurve(uint64_t result, uint64_t a2)
{
  if (*(_QWORD *)(result + 16))
    return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(result + 16) + 80))(*(_QWORD *)(result + 16), a2);
  return result;
}

uint64_t CBHybridUpdateCurveStrategy::setAlternativeCappedCurve(uint64_t result, uint64_t a2)
{
  if (*(_QWORD *)(result + 24))
    return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(result + 24) + 80))(*(_QWORD *)(result + 24), a2);
  return result;
}

uint64_t CBHybridUpdateCurveStrategy::preservePreferences(uint64_t this)
{
  uint64_t v1;

  v1 = this;
  if (*(_QWORD *)(this + 16))
    this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(this + 16) + 96))(*(_QWORD *)(this + 16));
  if (*(_QWORD *)(v1 + 24))
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 24) + 96))(*(_QWORD *)(v1 + 24));
  return this;
}

uint64_t CBHybridUpdateCurveStrategy::curveType(CBHybridUpdateCurveStrategy *this)
{
  if (*((_QWORD *)this + 2))
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 104))(*((_QWORD *)this + 2));
  else
    return 0;
}

uint64_t CBHybridUpdateCurveStrategy::alternativeCurveType(CBHybridUpdateCurveStrategy *this)
{
  if (*((_QWORD *)this + 3))
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 104))(*((_QWORD *)this + 3));
  else
    return 0;
}

void std::list<AAB::CurveUpdate>::__move_assign(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;

  v6 = a1;
  v5 = a2;
  std::list<AAB::CurveUpdate>::clear[abi:ne180100](a1);
  std::__list_imp<AAB::CurveUpdate>::__move_assign_alloc[abi:ne180100]();
  v3 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v4, &v3);
  std::list<AAB::CurveUpdate>::splice(a1, v4, v5);
}

void std::list<AAB::CurveUpdate>::clear[abi:ne180100](uint64_t a1)
{
  std::__list_imp<AAB::CurveUpdate>::clear(a1);
}

void std::__list_imp<AAB::CurveUpdate>::__move_assign_alloc[abi:ne180100]()
{
  std::__list_imp<AAB::CurveUpdate>::__move_assign_alloc[abi:ne180100]();
}

{
  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
}

uint64_t __os_log_helper_16_0_4_8_0_4_0_4_0_4_0(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 4;
  *(_DWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 24) = 0;
  *(_BYTE *)(result + 25) = 4;
  *(_DWORD *)(result + 26) = a5;
  return result;
}

CFStringRef createAmmoliteKey(const char *a1, int a2)
{
  CFStringEncoding SystemEncoding;
  const __CFAllocator *alloc;

  if (a2 >= 0)
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%s-%d"), a1, a2);
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  SystemEncoding = CFStringGetSystemEncoding();
  return CFStringCreateWithCString(alloc, a1, SystemEncoding);
}

BOOL CFXAmmoliteSupported(io_registry_entry_t a1)
{
  BOOL ExactDataFromIOService;
  const __CFString *cf;
  int v4;
  int v5;
  io_registry_entry_t v6;

  v6 = a1;
  v5 = 0;
  v4 = 0;
  if (!readExactDataFromIOService(a1, CFSTR("pab-scaler-index"), (UInt8 *)&v5, 4))
    v5 = -1;
  cf = createAmmoliteKey("aml-table-factor", v5);
  ExactDataFromIOService = 0;
  if (cf)
  {
    ExactDataFromIOService = readExactDataFromIOService(v6, cf, (UInt8 *)&v4, 4);
    CFRelease(cf);
  }
  if (!ExactDataFromIOService)
    return readExactDataFromIOService(v6, CFSTR("aml-table-factor"), (UInt8 *)&v4, 4);
  return ExactDataFromIOService;
}

_QWORD *CFXAmmoliteCreate(io_registry_entry_t a1, uint64_t a2)
{
  double v2;
  float v3;
  float v4;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  CFTypeID v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  int n;
  CFIndex m;
  int k;
  int j;
  int i;
  float *v25;
  const UInt8 *BytePtr;
  CFIndex v27;
  const __CFData *cf;
  float v29;
  float v30;
  float v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  os_log_type_t v35;
  os_log_t v36;
  os_log_type_t v37;
  os_log_t v38;
  os_log_type_t v39;
  os_log_t v40;
  os_log_type_t v41;
  os_log_t v42;
  os_log_type_t v43;
  os_log_t v44;
  os_log_type_t type;
  os_log_t oslog;
  CFStringRef key;
  const __CFString *v48;
  const __CFString *v49;
  const __CFString *v50;
  const __CFString *AmmoliteKey;
  int v52;
  int v53;
  CFTypeRef v54;
  _QWORD *v55;
  uint64_t v56;
  io_registry_entry_t entry;
  _QWORD __b[5];
  uint8_t v60[112];
  uint8_t v61[16];
  uint8_t v62[16];
  uint8_t v63[48];
  uint8_t v64[16];
  uint8_t v65[16];
  uint8_t v66[16];
  uint8_t v67[32];
  uint8_t v68[32];
  uint8_t v69[32];
  uint8_t v70[16];
  uint8_t v71[32];
  uint8_t v72[24];
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  entry = a1;
  v56 = a2;
  if (!a1)
    return 0;
  v55 = 0;
  v54 = os_log_create("com.apple.CBColorModule.Primary.Ammolite", "default");
  v53 = 0;
  v52 = 0;
  key = 0;
  v48 = 0;
  v49 = 0;
  v50 = 0;
  AmmoliteKey = 0;
  if (readExactDataFromIOService(entry, CFSTR("pab-scaler-index"), (UInt8 *)&v53, 4))
  {
    oslog = 0;
    if (v54)
      v19 = v54;
    else
      v19 = MEMORY[0x1E0C81028];
    oslog = v19;
    type = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_2_2_8_32_4_0((uint64_t)v72, (uint64_t)"CFXAmmoliteCreate", v53);
      _os_log_debug_impl(&dword_1B5291000, oslog, type, "%s: Display vendor index is %d", v72, 0x12u);
    }
    if (v53 < 0)
    {
      v53 = -1;
    }
    else
    {
      AmmoliteKey = createAmmoliteKey("aml-table-factor", v53);
      if (AmmoliteKey && readExactDataFromIOService(entry, AmmoliteKey, (UInt8 *)&v52, 4))
      {
        v44 = 0;
        if (v54)
          v18 = v54;
        else
          v18 = MEMORY[0x1E0C81028];
        v44 = v18;
        v43 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_2_2_8_32_4_0((uint64_t)v71, (uint64_t)"CFXAmmoliteCreate", v53);
          _os_log_impl(&dword_1B5291000, v44, v43, "%s: Ammolite configuration found for display vendor index: %d", v71, 0x12u);
        }
      }
      else
      {
        v53 = -1;
      }
    }
  }
  else
  {
    v53 = -1;
  }
  if (v53 < 0)
  {
    if (!readExactDataFromIOService(entry, CFSTR("aml-table-factor"), (UInt8 *)&v52, 4))
    {
      if (AmmoliteKey)
      {
        v40 = 0;
        if (v54)
          v16 = v54;
        else
          v16 = MEMORY[0x1E0C81028];
        v40 = v16;
        v39 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_2_3_8_32_8_66_8_32((uint64_t)v69, (uint64_t)"CFXAmmoliteCreate", (uint64_t)AmmoliteKey, (uint64_t)"aml-table-factor");
          _os_log_impl(&dword_1B5291000, v40, v39, "%s: Ammolite is not supported on this device (unable to find %{public}@ or %s in EDT)", v69, 0x20u);
        }
      }
      else
      {
        v38 = 0;
        if (v54)
          v15 = v54;
        else
          v15 = MEMORY[0x1E0C81028];
        v38 = v15;
        v37 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_2_2_8_32_8_32((uint64_t)v68, (uint64_t)"CFXAmmoliteCreate", (uint64_t)"aml-table-factor");
          _os_log_impl(&dword_1B5291000, v38, v37, "%s: Ammolite is not supported on this device (unable to find %s in EDT)", v68, 0x16u);
        }
      }
      goto LABEL_113;
    }
    v42 = 0;
    if (v54)
      v17 = v54;
    else
      v17 = MEMORY[0x1E0C81028];
    v42 = v17;
    v41 = OS_LOG_TYPE_INFO;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v70, (uint64_t)"CFXAmmoliteCreate");
      _os_log_impl(&dword_1B5291000, v42, v41, "%s: Ammolite global configuration found (no display vendor specific config found)", v70, 0xCu);
    }
  }
  v36 = 0;
  if (v54)
    v14 = v54;
  else
    v14 = MEMORY[0x1E0C81028];
  v36 = v14;
  v35 = OS_LOG_TYPE_INFO;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    __os_log_helper_16_2_2_8_32_4_0((uint64_t)v67, (uint64_t)"CFXAmmoliteCreate", v52);
    _os_log_impl(&dword_1B5291000, v36, v35, "%s: Ammolite factor: %d", v67, 0x12u);
  }
  v34 = 0;
  v33 = 0;
  v32 = 0;
  v50 = createAmmoliteKey("aml-abs-lux-thresh", v53);
  if (v50 && readExactDataFromIOService(entry, v50, (UInt8 *)&v34, 4))
  {
    v49 = createAmmoliteKey("aml-rel-lux-thresh", v53);
    if (v49 && readExactDataFromIOService(entry, v49, (UInt8 *)&v33, 4))
    {
      v48 = createAmmoliteKey("aml-period", v53);
      if (v48 && readExactDataFromIOService(entry, v48, (UInt8 *)&v32, 4))
      {
        v31 = (float)v34 / 65536.0;
        v30 = (float)v33 / 65536.0;
        v29 = (float)v32 / 65536.0;
        if (v54)
          v10 = v54;
        else
          v10 = MEMORY[0x1E0C81028];
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_2_4_8_32_8_0_8_0_8_0((uint64_t)v63, (uint64_t)"CFXAmmoliteCreate", COERCE__INT64(v31), COERCE__INT64(v30), COERCE__INT64(v29));
          _os_log_impl(&dword_1B5291000, v10, OS_LOG_TYPE_INFO, "%s: Ammolite: absLux = %f relLux = %f period = %f", v63, 0x2Au);
        }
        key = createAmmoliteKey("aml-table", v53);
        if (key)
        {
          cf = (const __CFData *)IORegistryEntrySearchCFProperty(entry, "IOService", key, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
          if (cf && (v9 = CFGetTypeID(cf), v9 == CFDataGetTypeID()))
          {
            if (CFDataGetLength(cf) % 40)
              __assert_rtn("CFXAmmoliteCreate", "Ammolite.c", 156, "CFDataGetLength(elemData) % rowSize == 0");
            v27 = CFDataGetLength(cf) / 40;
            BytePtr = CFDataGetBytePtr(cf);
            v25 = (float *)malloc_type_malloc(40 * v27, 0x10000400A747E1EuLL);
            for (i = 0; i < v27; ++i)
            {
              LODWORD(v2) = v52;
              v2 = (double)*(unint64_t *)&v2;
              v3 = (double)*(int *)&BytePtr[40 * i] / v2;
              v25[10 * i] = v3;
              for (j = 0; j < 3; ++j)
              {
                for (k = 0; k < 3; ++k)
                {
                  LODWORD(v2) = v52;
                  v2 = (double)*(unint64_t *)&v2;
                  v4 = (double)*(int *)&BytePtr[40 * i + 4 + 12 * j + 4 * k] / v2;
                  v25[10 * i + 1 + 3 * j + k] = v4;
                }
              }
            }
            if (v54)
              v7 = v54;
            else
              v7 = MEMORY[0x1E0C81028];
            if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_2_1_8_32((uint64_t)v61, (uint64_t)"CFXAmmoliteCreate");
              _os_log_debug_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEBUG, "%s: Ammolite table:", v61, 0xCu);
            }
            for (m = 0; m < v27; ++m)
            {
              if (v54)
                v6 = v54;
              else
                v6 = MEMORY[0x1E0C81028];
              if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
              {
                __os_log_helper_16_2_11_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v60, (uint64_t)"CFXAmmoliteCreate", COERCE__INT64(v25[10 * m]), COERCE__INT64(v25[10 * m + 1]), COERCE__INT64(v25[10 * m + 2]), COERCE__INT64(v25[10 * m + 3]), COERCE__INT64(v25[10 * m + 4]), COERCE__INT64(v25[10 * m + 5]), COERCE__INT64(v25[10 * m + 6]), COERCE__INT64(v25[10 * m + 7]), COERCE__INT64(v25[10 * m + 8]), COERCE__INT64(v25[10 * m + 9]));
                _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "%s: \t%f: %f %f %f %f %f %f %f %f %f", v60, 0x70u);
              }
            }
            v55 = malloc_type_malloc(0x38uLL, 0x102004028F26F39uLL);
            v55[6] = v54;
            v55[1] = v27;
            *((_BYTE *)v55 + 24) = 0;
            *((_DWORD *)v55 + 7) = 0;
            *((float *)v55 + 8) = v31;
            *((float *)v55 + 9) = v30;
            *((float *)v55 + 10) = v29;
            *v55 = v25;
            v55[2] = v56;
            CFRelease(cf);
          }
          else
          {
            if (cf)
              CFRelease(cf);
            if (v54)
              v8 = v54;
            else
              v8 = MEMORY[0x1E0C81028];
            if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            {
              __os_log_helper_16_2_1_8_32((uint64_t)v62, (uint64_t)"CFXAmmoliteCreate");
              _os_log_error_impl(&dword_1B5291000, v8, OS_LOG_TYPE_ERROR, "%s: Unable to read Ammolite table data from device tree", v62, 0xCu);
            }
          }
        }
      }
      else
      {
        if (v54)
          v11 = v54;
        else
          v11 = MEMORY[0x1E0C81028];
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          __os_log_helper_16_2_1_8_32((uint64_t)v64, (uint64_t)"CFXAmmoliteCreate");
          _os_log_error_impl(&dword_1B5291000, v11, OS_LOG_TYPE_ERROR, "%s: Unable to read Ammolite period from device tree", v64, 0xCu);
        }
      }
    }
    else
    {
      if (v54)
        v12 = v54;
      else
        v12 = MEMORY[0x1E0C81028];
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        __os_log_helper_16_2_1_8_32((uint64_t)v65, (uint64_t)"CFXAmmoliteCreate");
        _os_log_error_impl(&dword_1B5291000, v12, OS_LOG_TYPE_ERROR, "%s: Unable to read Ammolite relative threshold from device tree", v65, 0xCu);
      }
    }
  }
  else
  {
    if (v54)
      v13 = v54;
    else
      v13 = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v66, (uint64_t)"CFXAmmoliteCreate");
      _os_log_error_impl(&dword_1B5291000, v13, OS_LOG_TYPE_ERROR, "%s: Unable to read Ammolite absolute threshold from device tree", v66, 0xCu);
    }
  }
LABEL_113:
  if (!v55 && v54)
    CFRelease(v54);
  __b[0] = AmmoliteKey;
  __b[1] = v50;
  __b[2] = v49;
  __b[3] = v48;
  __b[4] = key;
  for (n = 0; n < 5; ++n)
  {
    if (__b[n])
      CFRelease((CFTypeRef)__b[n]);
  }
  return v55;
}

uint64_t __os_log_helper_16_2_3_8_32_8_66_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 66;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 32;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

uint64_t __os_log_helper_16_2_11_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 11;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 62) = 0;
  *(_BYTE *)(result + 63) = 8;
  *(_QWORD *)(result + 64) = a8;
  *(_BYTE *)(result + 72) = 0;
  *(_BYTE *)(result + 73) = 8;
  *(_QWORD *)(result + 74) = a9;
  *(_BYTE *)(result + 82) = 0;
  *(_BYTE *)(result + 83) = 8;
  *(_QWORD *)(result + 84) = a10;
  *(_BYTE *)(result + 92) = 0;
  *(_BYTE *)(result + 93) = 8;
  *(_QWORD *)(result + 94) = a11;
  *(_BYTE *)(result + 102) = 0;
  *(_BYTE *)(result + 103) = 8;
  *(_QWORD *)(result + 104) = a12;
  return result;
}

void CFXAmmoliteFree(uint64_t a1)
{
  NSObject *v1;
  uint8_t v3[24];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_QWORD *)(a1 + 48))
      v1 = *(NSObject **)(a1 + 48);
    else
      v1 = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v3, (uint64_t)"CFXAmmoliteFree");
      _os_log_impl(&dword_1B5291000, v1, OS_LOG_TYPE_INFO, "%s: Turning Ammolite off", v3, 0xCu);
    }
    CFRelease(*(CFTypeRef *)(a1 + 48));
    free(*(void **)a1);
    free((void *)a1);
  }
}

uint64_t CFXAmmoliteFadeInternal(uint64_t a1, int a2, uint64_t a3, double a4)
{
  float v4;
  int j;
  int i;
  char v8;
  double v9;
  double v10;
  double v11;
  double v12;
  _DWORD __dst[9];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v12 = a4 - *(double *)(a1 + 8);
  v9 = v12 / *(double *)a1;
  v8 = 0;
  if (*(double *)a1 == 0.0 || v9 >= 1.0 || v12 < 0.0)
  {
    memcpy(__dst, (const void *)(a1 + 20), sizeof(__dst));
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 16) = 1;
  }
  else
  {
    v10 = v9 * (float)(a2 - 1);
    v11 = (1.0 - (v10 - (double)(int)v10)) * *(float *)(a3 + 4 * (int)v10)
        + (v10 - (double)(int)v10) * *(float *)(a3 + 4 * ((int)v10 + 1));
    for (i = 0; i < 3; ++i)
    {
      for (j = 0; j < 3; ++j)
      {
        v4 = *(float *)(a1 + 92 + 12 * i + 4 * j)
           + v11 * (float)(*(float *)(a1 + 20 + 12 * i + 4 * j) - *(float *)(a1 + 92 + 12 * i + 4 * j));
        *(float *)&__dst[3 * i + j] = v4;
      }
    }
    v8 = 1;
  }
  __memcpy_chk();
  return v8 & 1;
}

uint64_t __os_log_helper_16_2_3_4_0_8_64_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 64;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  return result;
}

uint64_t __os_log_helper_16_0_2_4_0_8_0(uint64_t result, int a2, uint64_t a3)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  return result;
}

uint64_t __os_log_helper_16_2_4_8_64_4_0_8_0_8_0(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  return result;
}

uint64_t __os_log_helper_16_0_3_4_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  return result;
}

uint64_t __os_log_helper_16_2_4_4_0_8_66_8_66_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 66;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 66;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  return result;
}

void sub_1B535AFF8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_5_8_64_8_0_8_64_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 5;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 64;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  return result;
}

float linear_interpolation(float a1, float a2, float a3, float a4, float a5)
{
  return a3 + (float)((float)((float)(a5 - a3) / (float)(a4 - a2)) * (float)(a1 - a2));
}

float *find_bound(float *result, unint64_t a2, float a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t i;

  if (result && a2)
  {
    if (a3 >= *result)
    {
      if (a3 < result[a2 - 1])
      {
        for (i = 1; i < a2; ++i)
        {
          if (a3 >= result[i - 1] && a3 < result[i])
          {
            *a4 = i - 1;
            *a5 = i;
            return result;
          }
        }
      }
      else
      {
        *a4 = a2 - 2;
        *a5 = a2 - 1;
      }
    }
    else
    {
      *a4 = 0;
      *a5 = 1;
    }
  }
  else
  {
    *a4 = 0;
    *a5 = 0;
  }
  return result;
}

float matrix_element(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return *(float *)(a1 + 4 * (a2 * a4 + a3));
}

float two_dimensional_interpolation(float *a1, unint64_t a2, float *a3, unint64_t a4, uint64_t a5, float a6, float a7)
{
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  float *v26;
  unint64_t v27;
  float *v28;
  float v29;
  float v30;

  v30 = a6;
  v29 = a7;
  v28 = a1;
  v27 = a2;
  v26 = a3;
  v25 = a4;
  v24 = a5;
  if (!a1 || !v26 || !v24 || v27 < 2 || v25 < 2)
    return NAN;
  v30 = clamp(v30, *v28, v28[v27 - 1]);
  v29 = clamp(v29, *v26, v26[v25 - 1]);
  v23 = 0;
  v22 = 0;
  find_bound(v28, v27, v30, &v23, &v22);
  v21 = 0;
  v20 = 0;
  find_bound(v26, v25, v29, &v21, &v20);
  v19 = v28[v23];
  v18 = v28[v22];
  v17 = v26[v21];
  v16 = v26[v20];
  v15 = 1.0;
  if (!float_equal((float)(v18 - v19) * (float)(v16 - v17), 0.0))
    v15 = 1.0 / (float)((float)(v18 - v19) * (float)(v16 - v17));
  v14 = (float)((float)(v18 - v30) * (float)(v29 - v17)) * v15;
  v13 = (float)((float)(v30 - v19) * (float)(v16 - v29)) * v15;
  v12 = (float)((float)(v30 - v19) * (float)(v29 - v17)) * v15;
  v9 = (float)((float)(v18 - v30) * (float)(v16 - v29)) * v15;
  v8 = matrix_element(v24, v21, v23, v27);
  v10 = (float)(v14 * matrix_element(v24, v20, v23, v27)) + (float)(v9 * v8);
  v11 = v10 + (float)(v13 * matrix_element(v24, v21, v22, v27));
  return v11 + (float)(v12 * matrix_element(v24, v20, v22, v27));
}

float __mach_time_to_nanoseconds_block_invoke(uint64_t a1)
{
  float result;
  mach_timebase_info info;
  uint64_t v3;
  uint64_t v4;

  v4 = a1;
  v3 = a1;
  mach_timebase_info(&info);
  result = (float)info.numer / (float)info.denom;
  *(float *)&mach_time_to_nanoseconds::machTimeBaseFactor = result;
  return result;
}

float mach_time_now_in_nanoseconds()
{
  uint64_t v0;

  v0 = mach_absolute_time();
  return mach_time_to_nanoseconds(v0);
}

unint64_t create_integer_array_from_cfdata(const void *a1, UInt8 **a2)
{
  CFTypeID v3;
  UInt8 *buffer;
  unint64_t count;
  CFRange v8;

  count = 0;
  buffer = 0;
  if (a1)
  {
    v3 = CFGetTypeID(a1);
    if (v3 == CFDataGetTypeID())
    {
      count = CFDataGetLength((CFDataRef)a1) / 4uLL;
      buffer = (UInt8 *)malloc_type_calloc(count, 4uLL, 0x100004052888210uLL);
      if (buffer)
      {
        v8.location = 0;
        v8.length = 4 * count;
        CFDataGetBytes((CFDataRef)a1, v8, buffer);
      }
      else
      {
        count = 0;
      }
    }
  }
  *a2 = buffer;
  return count;
}

uint64_t get_integer_from_cfdata(const void *a1, _DWORD *a2)
{
  CFTypeID v3;
  UInt8 buffer[7];
  char v5;
  _DWORD *v6;
  CFTypeRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFRange v12;

  v7 = a1;
  v6 = a2;
  v5 = 0;
  *(_DWORD *)buffer = 0;
  if (a1)
  {
    v3 = CFGetTypeID(v7);
    if (v3 == CFDataGetTypeID() && CFDataGetLength((CFDataRef)v7) == 4)
    {
      v9 = 0;
      v8 = 4;
      v10 = 0;
      v11 = 4;
      v12.location = 0;
      v12.length = 4;
      CFDataGetBytes((CFDataRef)v7, v12, buffer);
      v5 = 1;
    }
  }
  *v6 = *(_DWORD *)buffer;
  return v5 & 1;
}

uint64_t get_uint32_from_cfdata(const void *a1, unsigned int *a2)
{
  CFTypeID v3;
  UInt8 buffer[7];
  char v5;
  unsigned int *v6;
  CFTypeRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFRange v12;

  v7 = a1;
  v6 = a2;
  v5 = 0;
  if (a1)
  {
    v3 = CFGetTypeID(v7);
    if (v3 == CFDataGetTypeID())
    {
      *(_DWORD *)buffer = 0;
      if (CFDataGetLength((CFDataRef)v7) == 4)
      {
        v9 = 0;
        v8 = 4;
        v10 = 0;
        v11 = 4;
        v12.location = 0;
        v12.length = 4;
        CFDataGetBytes((CFDataRef)v7, v12, buffer);
        v5 = 1;
        *v6 = *(_DWORD *)buffer;
      }
    }
  }
  return v5 & 1;
}

uint64_t get_float_from_cfdata(const void *a1, _DWORD *a2)
{
  CFTypeID v3;
  UInt8 buffer[7];
  char v5;
  _DWORD *v6;
  CFTypeRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFRange v12;

  v7 = a1;
  v6 = a2;
  v5 = 0;
  *(_DWORD *)buffer = 2143289344;
  if (a1)
  {
    v3 = CFGetTypeID(v7);
    if (v3 == CFDataGetTypeID() && CFDataGetLength((CFDataRef)v7) == 4)
    {
      v9 = 0;
      v8 = 4;
      v10 = 0;
      v11 = 4;
      v12.location = 0;
      v12.length = 4;
      CFDataGetBytes((CFDataRef)v7, v12, buffer);
      v5 = 1;
    }
  }
  *v6 = *(_DWORD *)buffer;
  return v5 & 1;
}

unint64_t load_integer_array_from_edt(io_registry_entry_t a1, const __CFString *a2, UInt8 **a3)
{
  CFTypeRef cf;
  unint64_t integer_array_from_cfdata;

  cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if (cf)
  {
    integer_array_from_cfdata = create_integer_array_from_cfdata(cf, a3);
    CFRelease(cf);
  }
  else
  {
    integer_array_from_cfdata = 0;
    *a3 = 0;
  }
  return integer_array_from_cfdata;
}

unint64_t load_float_array_from_edt(io_registry_entry_t a1, const __CFString *a2, _QWORD *a3)
{
  UInt8 *v4;
  CFTypeRef cf;
  unint64_t v6;
  _QWORD *v7;
  const __CFString *v8;
  io_registry_entry_t v9;

  v9 = a1;
  v8 = a2;
  v7 = a3;
  v6 = 0;
  cf = 0;
  cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if (cf)
  {
    v4 = 0;
    v6 = create_integer_array_from_cfdata(cf, &v4);
    *v7 = v4;
    CFRelease(cf);
  }
  else
  {
    v6 = 0;
    *v7 = 0;
  }
  return v6;
}

float load_float_from_edt(io_registry_entry_t a1, const __CFString *a2)
{
  CFTypeRef cf;
  float v4;
  CFStringRef key;
  io_registry_entry_t v6;

  v6 = a1;
  key = a2;
  v4 = NAN;
  cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if (cf)
  {
    get_float_from_cfdata(cf, &v4);
    CFRelease(cf);
  }
  return v4;
}

uint64_t load_int_from_edt(io_registry_entry_t a1, const __CFString *a2, _DWORD *a3)
{
  CFTypeRef cf;
  char v5;

  v5 = 0;
  cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if (cf)
  {
    v5 = get_integer_from_cfdata(cf, a3) & 1;
    CFRelease(cf);
  }
  return v5 & 1;
}

uint64_t load_uint_from_edt(io_registry_entry_t a1, const __CFString *a2, unsigned int *a3)
{
  CFTypeRef cf;
  char v5;

  v5 = 0;
  cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if (cf)
  {
    v5 = get_uint32_from_cfdata(cf, a3) & 1;
    CFRelease(cf);
  }
  return v5 & 1;
}

float load_fixed_float_from_edt(io_registry_entry_t a1, const __CFString *a2)
{
  int v3;
  CFTypeRef cf;
  float v5;
  const __CFString *v6;
  io_registry_entry_t v7;

  v7 = a1;
  v6 = a2;
  v5 = NAN;
  cf = 0;
  cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if (cf)
  {
    v3 = 0;
    if ((get_integer_from_cfdata(cf, &v3) & 1) != 0)
      v5 = (float)v3 / 65536.0;
    CFRelease(cf);
  }
  return v5;
}

double scaleForExponent(int a1)
{
  int i;
  int j;
  double v4;

  v4 = 1.0;
  if (a1 >= 8)
  {
    for (i = 16; i > a1; --i)
      v4 = v4 * 10.0;
  }
  else
  {
    for (j = 0; j < a1; ++j)
      v4 = v4 * 10.0;
    return 1.0 / v4;
  }
  return v4;
}

float LuminanceToPerceptual(float a1, float a2, float a3)
{
  float v4;

  v4 = logf(fmaxf(a1, a2) / a3);
  return (float)(v4 / logf(a3 / a2)) + 1.0;
}

float PerceptualToLuminance(float a1, float a2, float a3)
{
  return a3 * powf(a3 / a2, a1 - 1.0);
}

uint64_t __os_log_helper_16_2_4_8_64_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  return result;
}

uint64_t CFXStoreComment(uint64_t result, const __CFString *a2)
{
  if (result)
  {
    if (a2)
      return CFStringGetCString(a2, (char *)(result + 1820), 256, 0x8000100u);
  }
  return result;
}

FILE *CFXForceLogCommit(FILE *result)
{
  if (result)
    return _CFXCommitLog(result);
  return result;
}

FILE *_CFXCommitLog(FILE *result)
{
  FILE *__stream;
  FILE *v2;
  char v3[256];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v2 = result;
  if (SLODWORD(result[11]._offset) > 0)
  {
    __sprintf_chk(v3, 0, 0x100uLL, "%s/%s_%s.csv", "/var/mobile/Library/Logs/CrashReporter/harmony", "HarmonyLog", (const char *)&result[13]._ub._size + 5);
    mkdir("/var/mobile/Library/Logs/CrashReporter/harmony", 0x1EDu);
    result = fopen(v3, "a");
    __stream = result;
    if (result)
    {
      fwrite("date,time,orientation_s,nChannels_s,R_s,G_s,B_s,C_s,Y_s,x_s,y_s,CCT1_s,x_restricted,y_restricted,brightness_d,sample_ignored,adptLevel,x_algo,y_algo,R_wp,G_wp,B_wp,ramp_in_progress,ramp_period,transition_count,comments\n", 1uLL, 0xDBuLL, result);
      fwrite(*(const void **)&v2[11]._blksize, 1uLL, SLODWORD(v2[11]._offset), __stream);
      result = (FILE *)fclose(__stream);
    }
    LODWORD(v2[11]._offset) = 0;
  }
  return result;
}

uint64_t CFXEnableLog(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 1801) = a2 & 1;
  return result;
}

uint64_t CFXAnsiBinFromChromaticity(float *a1)
{
  return ansiBinFromChromaticity(a1);
}

uint64_t CFXSetTarget(uint64_t a1, float *a2, char a3, char a4, float a5, float a6)
{
  return _CFXSetTarget(a1, a2, a3 & 1, a4 & 1, a5, a6) & 1;
}

uint64_t CFXZeroSample(uint64_t result)
{
  if (result)
    return __memset_chk();
  return result;
}

void *CFXCreate()
{
  void *v1;

  v1 = malloc_type_malloc(0xA30uLL, 0x10F004054DC366FuLL);
  if (v1)
  {
    __memset_chk();
    *((_QWORD *)v1 + 14) = &MemoryColorCoeff;
    *((CFAbsoluteTime *)v1 + 17) = CFAbsoluteTimeGetCurrent();
    *((_BYTE *)v1 + 144) = 1;
    *((float *)v1 + 49) = 1.0;
    *((_BYTE *)v1 + 1800) = 0;
    *((_QWORD *)v1 + 44) = &rampProfile;
    *((_DWORD *)v1 + 90) = 201;
    *((_QWORD *)v1 + 93) = &CCT_Shifted_Table;
    *((_DWORD *)v1 + 188) = 66;
    *((float *)v1 + 535) = 1.0;
    _CFXInitStats((uint64_t)v1 + 760);
    *((_QWORD *)v1 + 8) = &CCT_BB_Table;
    *((_DWORD *)v1 + 18) = 813;
    *((_QWORD *)v1 + 282) = 0;
    __memset_chk();
    *((_BYTE *)v1 + 2280) = 1;
    *((float *)v1 + 579) = 1.0;
    *((float *)v1 + 575) = 1.0;
    *((float *)v1 + 571) = 1.0;
    *((float *)v1 + 588) = 1.0;
    *((float *)v1 + 584) = 1.0;
    *((float *)v1 + 580) = 1.0;
    *((float *)v1 + 597) = 1.0;
    *((float *)v1 + 593) = 1.0;
    *((float *)v1 + 589) = 1.0;
    _CFXClearReport((uint64_t)v1);
    __memcpy_chk();
    *((_DWORD *)v1 + 529) = 1050408072;
    *((_DWORD *)v1 + 530) = 1050941587;
    __memcpy_chk();
    __memcpy_chk();
    __memcpy_chk();
    *((_DWORD *)v1 + 531) = 1172084122;
    *((_DWORD *)v1 + 23) = 1172084122;
    __memcpy_chk();
    _CFXIdentity((float *)v1 + 176);
    *((_DWORD *)v1 + 185) = 0;
    *((float *)v1 + 563) = -1.0;
    *((_BYTE *)v1 + 2448) = 1;
    *((_DWORD *)v1 + 613) = 0;
    *((_DWORD *)v1 + 614) = 0;
    *((_DWORD *)v1 + 615) = 0;
    *((_BYTE *)v1 + 2520) = 0;
    *((_DWORD *)v1 + 631) = 0;
    *((_DWORD *)v1 + 632) = 0;
    *((_DWORD *)v1 + 633) = 0;
    *((_BYTE *)v1 + 2552) = 0;
    *((_QWORD *)v1 + 320) = 0;
    *((_QWORD *)v1 + 321) = 0;
    *((_QWORD *)v1 + 322) = 0;
    *((_QWORD *)v1 + 323) = 0;
    *((_QWORD *)v1 + 324) = 0;
    *((_DWORD *)v1 + 650) = 0;
  }
  return v1;
}

float _CFXInitStats(uint64_t a1)
{
  float result;

  __memset_chk();
  *(_QWORD *)(a1 + 32) = 0x404E000000000000;
  *(_DWORD *)a1 = -1;
  result = 5.0;
  *(float *)(a1 + 44) = 5.0;
  return result;
}

double _CFXClearReport(uint64_t a1)
{
  double result;
  uint64_t v2;

  if (a1)
  {
    __memset_chk();
    v2 = mach_absolute_time();
    *(_QWORD *)(a1 + 1016) = v2;
    *(_QWORD *)(a1 + 1232) = v2;
    *(_DWORD *)(a1 + 1228) = *(_DWORD *)(a1 + 224);
    *(double *)(a1 + 1640) = (double)v2;
    if (*(_QWORD *)(a1 + 104) && **(float **)(a1 + 104) > 0.0)
      *(_BYTE *)(a1 + 1648) = 1;
    *(double *)(a1 + 1744) = (double)v2;
    if (*(_QWORD *)(a1 + 96))
    {
      *(_DWORD *)(a1 + 1736) = (int)(float)(**(float **)(a1 + 96) * 10.0);
      if (*(int *)(a1 + 1736) > 9)
        *(_DWORD *)(a1 + 1736) = 9;
    }
    result = (double)v2;
    *(double *)(a1 + 1776) = (double)v2;
    *(_QWORD *)(a1 + 1616) = v2;
  }
  return result;
}

void _CFXReleaseTwilightNightShiftAdaptation(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 2552) & 1) != 0)
  {
    if (*(_QWORD *)(a1 + 2568))
      free(*(void **)(a1 + 2568));
    if (*(_QWORD *)(a1 + 2584))
      free(*(void **)(a1 + 2584));
    if (*(_QWORD *)(a1 + 2592))
      free(*(void **)(a1 + 2592));
  }
}

void CFXRelease(void **a1)
{
  if (a1)
  {
    _CFXClearStats((uint64_t)(a1 + 95));
    if (a1[12])
    {
      if (*((_QWORD *)a1[12] + 7))
        free(*((void **)a1[12] + 7));
      if (*((_QWORD *)a1[12] + 12))
        free(*((void **)a1[12] + 12));
      if (*((_QWORD *)a1[12] + 17))
        free(*((void **)a1[12] + 17));
      free(a1[12]);
      _CFXCloseLog((uint64_t)a1);
    }
    if (a1[13])
      free(a1[13]);
    _CFXReleaseTwilightNightShiftAdaptation((uint64_t)a1);
    free(a1);
  }
}

float _CFXClearStats(uint64_t a1)
{
  float result;
  _QWORD *v2;
  _QWORD *i;

  for (i = *(_QWORD **)(a1 + 8); i; i = v2)
  {
    v2 = (_QWORD *)i[1];
    free(i);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)a1 = -1;
  *(_DWORD *)(a1 + 40) = 0;
  result = 5.0;
  *(float *)(a1 + 44) = 5.0;
  return result;
}

void _CFXCloseLog(uint64_t a1)
{
  if (a1)
  {
    if (*(_QWORD *)(a1 + 1808))
      _CFXCommitLog((FILE *)a1);
    free(*(void **)(a1 + 1808));
  }
}

uint64_t CFXInstallCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    *(_QWORD *)(result + 328) = a2;
    *(_QWORD *)(result + 336) = a3;
  }
  return result;
}

void CFXSetWhitePointType(_DWORD *a1, int a2)
{
  if (a2 == 1)
  {
    __memcpy_chk();
    a1[23] = 1170948096;
    a1[529] = 1050680396;
    a1[530] = 1051226834;
    __memcpy_chk();
    __memcpy_chk();
    __memcpy_chk();
    a1[531] = 1170948096;
    __memcpy_chk();
    syslog(7, "D65 whitepoint");
  }
  else
  {
    syslog(7, "Legacy whitepoint");
  }
}

uint64_t CFXGetCurrentMatrix(uint64_t a1)
{
  NSObject *oslog;
  char v4;
  uint8_t v5[24];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4 = 0;
  if (a1)
  {
    oslog = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_0_2_4_0_8_0((uint64_t)v5, *(_BYTE *)(*(_QWORD *)(a1 + 96) + 184) & 1, COERCE__INT64(**(float **)(a1 + 96)));
      _os_log_impl(&dword_1B5291000, oslog, OS_LOG_TYPE_INFO, "ctx->harmony->adaptationEnabled: %i ctx->harmony->strength: %f", v5, 0x12u);
    }
    __memcpy_chk();
    v4 = 1;
  }
  return v4 & 1;
}

uint64_t CFXSetABShift(uint64_t a1, _DWORD *a2)
{
  char v3;

  v3 = 0;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      if (a2)
      {
        *(_DWORD *)(*(_QWORD *)(a1 + 96) + 292) = *a2;
        *(_DWORD *)(*(_QWORD *)(a1 + 96) + 296) = a2[1];
        v3 = 1;
        *(_BYTE *)(*(_QWORD *)(a1 + 96) + 300) = 1;
        if (*(_QWORD *)(a1 + 328))
          (*(void (**)(_QWORD, _QWORD))(a1 + 328))(*(_QWORD *)(a1 + 336), 0);
      }
    }
  }
  return v3 & 1;
}

uint64_t CFXGetABShift(uint64_t a1, _DWORD *a2)
{
  char v3;

  v3 = 0;
  if (a1 && *(_QWORD *)(a1 + 96) && a2)
  {
    *a2 = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 292);
    a2[1] = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 296);
    v3 = 1;
  }
  return v3 & 1;
}

uint64_t CFXGetMagicCoeff(uint64_t a1, uint64_t a2)
{
  int i;
  char v4;

  if (*(_QWORD *)(a1 + 112))
  {
    for (i = 0; i < 6; ++i)
      *(_DWORD *)(a2 + 4 * i) = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 4 * i);
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  return v4 & 1;
}

uint64_t CFXSetMagicCoeff(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2)
      return __memcpy_chk();
    else
      *(_QWORD *)(result + 112) = 0;
  }
  return result;
}

uint64_t CFXColorRampEnableLogging(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 1800) = a2 & 1;
  return result;
}

uint64_t CFXInitializeAmbientAdaptation(uint64_t a1)
{
  int j;
  int i;
  uint64_t v4;
  char v6;

  v6 = 0;
  if (!*(_QWORD *)(a1 + 96))
  {
    *(_QWORD *)(a1 + 96) = malloc_type_malloc(0x158uLL, 0x10E004084D8D114uLL);
    if (*(_QWORD *)(a1 + 96))
    {
      __memset_chk();
      v4 = *(_QWORD *)(a1 + 96);
      *(_DWORD *)v4 = 0;
      *(_DWORD *)(v4 + 152) = 994352038;
      *(_DWORD *)(v4 + 156) = 1024416809;
      *(_DWORD *)(v4 + 180) = 1114636288;
      *(float *)(v4 + 176) = 20.0;
      *(float *)(v4 + 160) = 5.0;
      *(float *)(v4 + 164) = 5.0;
      *(float *)(v4 + 168) = 5.0;
      *(float *)(v4 + 172) = 5.0;
      *(float *)(v4 + 188) = 2.0;
      *(_DWORD *)(v4 + 148) = 18;
      *(_QWORD *)(v4 + 40) = "k+OA";
      *(_QWORD *)(v4 + 48) = &defaultPolygonLarge;
      *(_QWORD *)(v4 + 64) = &AggressiveLUT_x;
      *(_DWORD *)(v4 + 72) = 29;
      *(_QWORD *)(v4 + 80) = &AggressiveLUT_y;
      *(_DWORD *)(v4 + 88) = 55;
      *(_QWORD *)(v4 + 96) = malloc_type_malloc(8 * *(int *)(v4 + 88), 0x80040B8603338uLL);
      if (*(_QWORD *)(v4 + 96))
      {
        for (i = 0; i < *(_DWORD *)(v4 + 88); ++i)
          *(_QWORD *)(*(_QWORD *)(v4 + 96) + 8 * i) = (char *)&AggressiveLUT + 116 * i;
      }
      *(_QWORD *)(v4 + 104) = &RelaxedLUT_x;
      *(_DWORD *)(v4 + 112) = 29;
      *(_QWORD *)(v4 + 120) = &RelaxedLUT_y;
      *(_DWORD *)(v4 + 128) = 55;
      *(_QWORD *)(v4 + 136) = malloc_type_malloc(8 * *(int *)(v4 + 128), 0x80040B8603338uLL);
      if (*(_QWORD *)(v4 + 136))
      {
        for (j = 0; j < *(_DWORD *)(v4 + 128); ++j)
          *(_QWORD *)(*(_QWORD *)(v4 + 136) + 8 * j) = (char *)&RelaxedLUT + 116 * j;
      }
      *(_BYTE *)(v4 + 144) = 1;
      *(_BYTE *)(v4 + 145) = 1;
      *(float *)(v4 + 192) = 10.0;
      *(float *)(v4 + 196) = 15.0;
      *(float *)(v4 + 200) = 25.0;
      *(_DWORD *)(v4 + 204) = 1108082688;
      *(_DWORD *)(v4 + 208) = 1167867904;
      *(_DWORD *)(v4 + 212) = 1053027365;
      *(_DWORD *)(v4 + 216) = 1053093869;
      __memcpy_chk();
      *(_DWORD *)(a1 + 92) = 1170948096;
      *(_DWORD *)(a1 + 2116) = 1050680396;
      *(_DWORD *)(a1 + 2120) = 1051226834;
      __memcpy_chk();
      __memcpy_chk();
      __memcpy_chk();
      *(_DWORD *)(a1 + 2124) = 1170948096;
      __memcpy_chk();
      *(_DWORD *)(v4 + 224) = 0;
      *(_DWORD *)(v4 + 228) = 1045220557;
      *(_DWORD *)(v4 + 232) = 1045220557;
      *(_DWORD *)(v4 + 236) = 1036831949;
      *(_DWORD *)(v4 + 240) = 1036831949;
      *(_DWORD *)(v4 + 244) = 1036831949;
      *(_DWORD *)(v4 + 248) = 1;
      *(float *)(v4 + 252) = 1.0;
      v6 = 1;
      _CFXInitializeLog(a1);
      CFXEnableFades(a1, 1);
      *(_BYTE *)(v4 + 288) = 1;
      *(_BYTE *)(a1 + 344) = 1;
      *(_DWORD *)(v4 + 292) = 0;
      *(_DWORD *)(v4 + 296) = 0;
      *(_BYTE *)(v4 + 301) = 0;
      *(_BYTE *)(v4 + 328) = 1;
      *(_DWORD *)(v4 + 332) = 1049247089;
      *(_DWORD *)(v4 + 336) = 1049247089;
      *(_DWORD *)(v4 + 340) = 1049247089;
      *(float *)(v4 + 308) = fminf(*(float *)v4, *(float *)(v4 + 332));
    }
  }
  return v6 & 1;
}

uint64_t _CFXInitializeLog(uint64_t a1)
{
  uint64_t result;

  *(_QWORD *)(a1 + 1808) = 0;
  *(_DWORD *)(a1 + 1816) = 0;
  result = __memset_chk();
  *(_BYTE *)(a1 + 2076) = 0;
  *(_DWORD *)(a1 + 2104) = 0;
  return result;
}

float CFXEnableFades(uint64_t a1, char a2)
{
  float result;

  if ((a2 & 1) != (*(_BYTE *)(a1 + 364) & 1))
  {
    *(_BYTE *)(a1 + 364) = a2 & 1;
    if ((a2 & 1) != 0)
    {
      _CFXIdentity((float *)(a1 + 496));
      _CFXIdentity((float *)(a1 + 460));
      _CFXIdentity((float *)(a1 + 388));
      _CFXIdentity((float *)(a1 + 424));
      *(_BYTE *)(a1 + 384) = 1;
      _CFXIdentity((float *)(a1 + 628));
      _CFXIdentity((float *)(a1 + 556));
      result = _CFXIdentity((float *)(a1 + 592));
      *(_BYTE *)(a1 + 552) = 1;
      if (*(_QWORD *)(a1 + 96))
      {
        *(_BYTE *)(*(_QWORD *)(a1 + 96) + 272) = 1;
        result = **(float **)(a1 + 96);
        *(float *)(*(_QWORD *)(a1 + 96) + 276) = result;
        *(float *)(*(_QWORD *)(a1 + 96) + 280) = result;
        *(float *)(*(_QWORD *)(a1 + 96) + 284) = result;
      }
    }
  }
  return result;
}

float CFXSetStrengthRampTweakFactor(uint64_t a1, float result)
{
  if (a1)
  {
    if (*(_QWORD *)(a1 + 96))
      *(float *)(*(_QWORD *)(a1 + 96) + 252) = result;
  }
  return result;
}

float CFXGetStrengthRampTweakFactor(uint64_t a1)
{
  float v2;

  v2 = -1.0;
  if (a1 && *(_QWORD *)(a1 + 96))
    return *(float *)(*(_QWORD *)(a1 + 96) + 252);
  return v2;
}

uint64_t CFXGetAdaptationModesMapping(uint64_t a1, uint64_t a2, int a3)
{
  char v4;

  v4 = 0;
  if (a1 && *(_QWORD *)(a1 + 96) && a2 && a3 >= 6)
  {
    __memcpy_chk();
    v4 = 1;
  }
  return v4 & 1;
}

uint64_t CFXSetAdaptationModesMapping(uint64_t a1, uint64_t a2, int a3)
{
  char v4;

  v4 = 0;
  if (a1 && *(_QWORD *)(a1 + 96) && a2 && a3 >= 6)
  {
    __memcpy_chk();
    v4 = 1;
  }
  return v4 & 1;
}

void CFXSetAmbientAdaptationMode(uint64_t a1, unsigned int a2, float a3)
{
  CFAbsoluteTime v3;
  float v4;

  if (a1 && *(_QWORD *)(a1 + 96))
  {
    v4 = _CFXGetStrengthFromMode(a1, a2);
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 96) + 184) & 1) != 0)
    {
      *(float *)&v3 = v4;
      CFXSetAmbientAdaptationStrength(a1, v3, a3);
    }
    *(_DWORD *)(*(_QWORD *)(a1 + 96) + 248) = a2;
  }
}

CFAbsoluteTime CFXSuspendHarmony(uint64_t a1, char a2, CFAbsoluteTime result)
{
  int v3;
  float v4;

  v4 = *(float *)&result;
  if (a1 && *(_QWORD *)(a1 + 96))
  {
    *(_BYTE *)(*(_QWORD *)(a1 + 96) + 301) = a2 & 1;
    if ((a2 & 1) != 0)
    {
      if ((*(_BYTE *)(a1 + 364) & 1) != 0)
      {
        *(_BYTE *)(*(_QWORD *)(a1 + 96) + 272) = 0;
        *(_DWORD *)(*(_QWORD *)(a1 + 96) + 284) = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 280);
        *(_DWORD *)(*(_QWORD *)(a1 + 96) + 276) = 0;
        *(CFAbsoluteTime *)(*(_QWORD *)(a1 + 96) + 264) = CFAbsoluteTimeGetCurrent();
        result = v4;
        *(double *)(*(_QWORD *)(a1 + 96) + 256) = v4;
        if (*(_QWORD *)(a1 + 328))
          (*(void (**)(_QWORD, _QWORD))(a1 + 328))(*(_QWORD *)(a1 + 336), 0);
      }
    }
    else
    {
      v3 = **(_DWORD **)(a1 + 96);
      **(_DWORD **)(a1 + 96) = 0;
      LODWORD(result) = v3;
      return CFXSetAmbientAdaptationStrength(a1, result, v4);
    }
  }
  return result;
}

void CFXEnableAmbientAdaptation(uint64_t a1, char a2)
{
  CFAbsoluteTime v2;
  CFAbsoluteTime v3;
  char v5;

  v5 = a2 & 1;
  if (a1 && *(_QWORD *)(a1 + 96) && (a2 & 1) != (*(_BYTE *)(*(_QWORD *)(a1 + 96) + 184) & 1))
  {
    _CFXClearStats(a1 + 760);
    *(_BYTE *)(*(_QWORD *)(a1 + 96) + 184) = v5 & 1;
    if ((v5 & 1) != 0)
    {
      _CFXSetNativeWhitePointCorrection(a1, 1, 1, *(float *)(*(_QWORD *)(a1 + 96) + 188));
      *(float *)&v2 = _CFXGetStrengthFromMode(a1, *(_DWORD *)(*(_QWORD *)(a1 + 96) + 248));
      CFXSetAmbientAdaptationStrength(a1, v2, *(float *)(*(_QWORD *)(a1 + 96) + 188));
    }
    _CFXUpdateTarget(a1, (float *)(a1 + 80), 1, 0, *(float *)(*(_QWORD *)(a1 + 96) + 188));
    if ((v5 & 1) == 0)
    {
      LODWORD(v3) = 0;
      CFXSetAmbientAdaptationStrength(a1, v3, *(float *)(*(_QWORD *)(a1 + 96) + 188));
      _CFXSetNativeWhitePointCorrection(a1, 0, 1, *(float *)(*(_QWORD *)(a1 + 96) + 188));
    }
  }
}

void _CFXSetNativeWhitePointCorrection(uint64_t a1, char a2, int a3, float a4)
{
  double v4;
  float v5;
  float v6;
  double v7;
  BOOL v8;
  char v9;
  double Current;
  float v11;

  if ((*(_BYTE *)(a1 + 2520) & 1) != 0)
  {
    if ((a2 & 1) != 0)
      *(_DWORD *)(a1 + 2524) |= a3;
    else
      *(_DWORD *)(a1 + 2524) &= ~a3;
    v4 = 1.0;
    if (!*(_DWORD *)(a1 + 2524))
      v4 = 0.0;
    v5 = v4;
    v11 = v5;
    if (*(float *)(a1 + 2252) >= 0.0)
      a4 = *(float *)(a1 + 2252);
    if (v5 == *(float *)(a1 + 2456))
      a4 = 0.0;
    if ((a2 & 1) == 0 || (v9 = 1, *(float *)(a1 + 2452) <= 0.0))
    {
      v8 = 0;
      if ((a2 & 1) == 0)
        v8 = *(float *)(a1 + 2452) == 0.0;
      v9 = v8;
    }
    Current = CFAbsoluteTimeGetCurrent();
    if ((v9 & 1) != 0)
    {
      if ((*(_BYTE *)(a1 + 2448) & 1) != 0)
        v7 = 0.0;
      else
        v7 = Current - *(float *)(a1 + 2460);
      v6 = v7;
      a4 = fmaxf(fminf(a4, v6), 0.0);
    }
    if ((*(_BYTE *)(a1 + 364) & 1) != 0)
    {
      syslog(7, "NativeWPMatrixRamp to %f in %fs\n", v11, a4);
      *(_BYTE *)(a1 + 2448) = 0;
      *(_DWORD *)(a1 + 2460) = *(_DWORD *)(a1 + 2456);
      *(float *)(a1 + 2452) = v11;
      *(double *)(a1 + 2432) = a4;
      *(double *)(a1 + 2440) = Current;
      if (*(_QWORD *)(a1 + 328))
        (*(void (**)(_QWORD, _QWORD))(a1 + 328))(*(_QWORD *)(a1 + 336), 0);
    }
  }
}

uint64_t _CFXLogSample(uint64_t a1, char a2)
{
  int v2;
  int v3;
  int v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  int v11;
  uint64_t result;
  _QWORD v13[19];
  char *v14;
  int v15;
  _QWORD *v16;
  uint64_t v17;
  char *componentDesc;
  int v19;
  double v20;
  unint64_t v21;
  float v22;
  int i;
  int v24;
  CFAbsoluteTime v25;
  CFAbsoluteTime at;
  CFCalendarRef calendar;
  BOOL v28;
  float v29[3];
  unsigned __int8 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  char v36[1024];
  float v37;
  float v38;
  float v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v31 = a1;
  v19 = 1;
  v30 = a2 & 1;
  *(_QWORD *)v29 = 0;
  CFXTristimulus2Chromaticity((float *)(a1 + 80), v29);
  v37 = (float)(*(float *)(v31 + 156) + *(float *)(v31 + 160)) + *(float *)(v31 + 164);
  v38 = (float)(*(float *)(v31 + 168) + *(float *)(v31 + 172)) + *(float *)(v31 + 176);
  v39 = (float)(*(float *)(v31 + 180) + *(float *)(v31 + 184)) + *(float *)(v31 + 188);
  v28 = 0;
  v20 = *(double *)(v31 + 136);
  v28 = v20 - CFAbsoluteTimeGetCurrent() > 0.0;
  calendar = CFCalendarCopyCurrent();
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  if (calendar)
  {
    v17 = 0;
    at = CFAbsoluteTimeGetCurrent();
    componentDesc = "yMdHms";
    CFCalendarDecomposeAbsoluteTime(calendar, at, "yMdHms", &v32, (char *)&v32 + 4, &v33, (char *)&v33 + 4, &v34, (char *)&v34 + 4);
    v25 = 0.0;
    CFCalendarComposeAbsoluteTime(calendar, &v25, "yMdHms", v32, HIDWORD(v32), v33, HIDWORD(v33), v34, HIDWORD(v34));
    v35 = (int)((at - v25) * 1000000.0);
    CFRelease(calendar);
  }
  v15 = 0;
  __sprintf_chk((char *)(v31 + 2077), 0, 0x14uLL, "%04d-%02d-%02d_%02d-%02d-%02d", v32, HIDWORD(v32), v33, HIDWORD(v33), v34, HIDWORD(v34));
  v24 = 0;
  v2 = *(_DWORD *)(v31 + 24);
  v3 = *(_DWORD *)(v31 + 52);
  v16 = v13;
  v24 = __sprintf_chk(v36, 0, 0x400uLL, "%04d/%02d/%02d,%02d:%02d:%02d.%06d,%d,%d,", v32, HIDWORD(v32), v33, HIDWORD(v33), v34, HIDWORD(v34), v35, v2, v3);
  for (i = 0; i < *(_DWORD *)(v31 + 52); ++i)
  {
    v4 = __sprintf_chk(&v36[v24], 0, 0xFFFFFFFFFFFFFFFFLL, "%.4f,", *(float *)(v31 + 28 + 4 * i));
    v24 += v4;
  }
  v22 = -1.0;
  v21 = 0xBF800000BF800000;
  if ((v30 & 1) != 0)
  {
    v22 = *(float *)(v31 + 2100);
    v21 = *(_QWORD *)(v31 + 2108);
  }
  v14 = v36;
  v5 = *(float *)(v31 + 4);
  v6 = *(float *)(v31 + 12);
  v7 = *(float *)(v31 + 16);
  v8 = *(float *)(v31 + 20);
  v9 = *(float *)(v31 + 56);
  v10 = *(float *)(v31 + 152);
  v11 = *(_DWORD *)(v31 + 2104);
  v13[18] = v13;
  __sprintf_chk(&v36[v24], 0, 0xFFFFFFFFFFFFFFFFLL, "%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%d,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%d,%f,%d,%s\n", v5, v6, v7, v8, v29[0], v29[1], v9, (v30 ^ 1) & 1, v22, *(float *)&v21, *((float *)&v21 + 1), v37, v38, v39, v28,
    v10,
    v11,
    (const char *)(v31 + 1820));
  result = _CFXLogString(v31, v14);
  *(_BYTE *)(v31 + 2076) = 0;
  *(_BYTE *)(v31 + 1820) = 0;
  *(_DWORD *)(v31 + 2104) = 0;
  return result;
}

uint64_t CFXResetAdaptation(uint64_t result, float a2)
{
  uint64_t v2;
  float v4[9];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v2 = result;
  if (result
    && (*(_QWORD *)(result + 104) && **(float **)(result + 104) > 0.0
     || *(_QWORD *)(result + 96) && (*(_BYTE *)(*(_QWORD *)(result + 96) + 184) & 1) != 0))
  {
    _CFXIdentity(v4);
    result = _CFXSetTarget(v2, v4, 1, 0, 0.0, a2);
    *(_BYTE *)(v2 + 344) = 1;
    if (*(_QWORD *)(v2 + 96))
      *(_BYTE *)(*(_QWORD *)(v2 + 96) + 220) = 1;
  }
  return result;
}

uint64_t CFXInitializeBlueLightReduction(uint64_t a1)
{
  char v3;

  v3 = 0;
  if (!*(_QWORD *)(a1 + 104))
  {
    *(_QWORD *)(a1 + 104) = malloc_type_malloc(0x34uLL, 0x1000040CC89259EuLL);
    if (*(_QWORD *)(a1 + 104))
    {
      **(_DWORD **)(a1 + 104) = 0;
      *(float *)(*(_QWORD *)(a1 + 104) + 4) = 2.0;
      *(_DWORD *)(*(_QWORD *)(a1 + 104) + 28) = 1166024704;
      *(_DWORD *)(*(_QWORD *)(a1 + 104) + 32) = 1169915904;
      *(_DWORD *)(*(_QWORD *)(a1 + 104) + 36) = 1160298496;
      *(_DWORD *)(*(_QWORD *)(a1 + 104) + 40) = 1166024704;
      *(_QWORD *)(*(_QWORD *)(a1 + 104) + 20) = *(_QWORD *)(a1 + 2116);
      CFXChromaticity2Tristimulus((float *)(*(_QWORD *)(a1 + 104) + 20), (float *)(*(_QWORD *)(a1 + 104) + 8), 150.0);
      *(float *)(*(_QWORD *)(a1 + 104) + 44) = -1.0;
      *(_BYTE *)(*(_QWORD *)(a1 + 104) + 48) = 0;
      v3 = 1;
    }
  }
  return v3 & 1;
}

uint64_t CFXInitializeTwilightNightShiftAdaptation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _CFXReleaseTwilightNightShiftAdaptation(a1);
  *(_BYTE *)(a1 + 2552) = 1;
  *(_QWORD *)(a1 + 2560) = a3;
  *(_QWORD *)(a1 + 2568) = a2;
  *(_QWORD *)(a1 + 2576) = a5;
  *(_QWORD *)(a1 + 2584) = a4;
  *(_QWORD *)(a1 + 2592) = a6;
  return 1;
}

uint64_t CFXEnableBlueLightReduction(uint64_t result, char a2, float a3, float a4)
{
  float v4;
  float v5;
  float v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  v10 = a2 & 1;
  v9 = result;
  if (!*(_QWORD *)(result + 104))
    result = CFXInitializeBlueLightReduction(result);
  if (*(_QWORD *)(v9 + 104)
    && ((v10 & 1) != 0 || a3 != **(float **)(v9 + 104) || (*(_BYTE *)(*(_QWORD *)(v9 + 104) + 48) & 1) != 0))
  {
    if (a3 > 0.0 && (*(_BYTE *)(v9 + 1648) & 1) == 0 || a3 == 0.0 && (*(_BYTE *)(v9 + 1648) & 1) != 0)
    {
      v8 = mach_absolute_time();
      v7 = MachTimeToSeconds((unint64_t)((double)v8 - *(double *)(v9 + 1640)));
      if ((*(_BYTE *)(v9 + 1648) & 1) != 0)
        *(double *)(v9 + 1624) = *(double *)(v9 + 1624) + v7;
      else
        *(double *)(v9 + 1632) = *(double *)(v9 + 1632) + v7;
      *(double *)(v9 + 1640) = (double)v8;
      *(_BYTE *)(v9 + 1648) = a3 > 0.0;
    }
    **(float **)(v9 + 104) = a3;
    v6 = fminf(fmaxf(a3, 0.0), 1.0);
    if (*(float *)(*(_QWORD *)(v9 + 104) + 44) >= 0.0)
      v6 = *(float *)(*(_QWORD *)(v9 + 104) + 44);
    v4 = (float)(v6 * *(float *)(*(_QWORD *)(v9 + 104) + 28)) + (1.0 - v6) * *(float *)(v9 + 2124);
    _CFXCCT2xy_Shifted(v9, (float *)(*(_QWORD *)(v9 + 104) + 20), v4);
    CFXChromaticity2Tristimulus((float *)(*(_QWORD *)(v9 + 104) + 20), (float *)(*(_QWORD *)(v9 + 104) + 8), 150.0);
    if (a4 < 0.0)
      v5 = *(float *)(*(_QWORD *)(v9 + 104) + 4);
    else
      v5 = a4;
    _CFXSetNativeWhitePointCorrection(v9, a3 > 0.0, 2, v5);
    result = _CFXUpdateBLRTarget(v9, v5);
    *(_BYTE *)(*(_QWORD *)(v9 + 104) + 48) = 0;
  }
  return result;
}

float _CFXCCT2xy_Shifted(uint64_t a1, float *a2, float a3)
{
  return _CFXCCT2xy_Generic(a3, a1, *(_QWORD *)(a1 + 744), *(_DWORD *)(a1 + 752), a2);
}

uint64_t _CFXUpdateBLRTarget(uint64_t a1, float a2)
{
  float *v3;
  float v6[9];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v3 = *(float **)(a1 + 104);
  _CFXIdentity(v6);
  if (v3 && (*v3 > 0.0 || v3[11] >= 0.0))
    _CFXGetTarget(a1, (float *)(*(_QWORD *)(a1 + 104) + 8), v6, 0, 0, 0, 0, 1, 1.0);
  return _CFXSetBLRTarget(a1, v6, 1, 1, a2, 1.0);
}

float CFXGetBlueLightReductionTargetCCT(uint64_t a1)
{
  float v2;

  v2 = 0.0;
  if (a1 && *(_QWORD *)(a1 + 104))
    return *(float *)(*(_QWORD *)(a1 + 104) + 28);
  return v2;
}

float CFXOverrideBlueLightReductionCCTRange(uint64_t a1, float result, float a3, float a4)
{
  if (a1)
  {
    if (*(_QWORD *)(a1 + 104))
    {
      *(float *)(*(_QWORD *)(a1 + 104) + 36) = a3;
      *(float *)(*(_QWORD *)(a1 + 104) + 32) = result;
      result = a4;
      *(float *)(*(_QWORD *)(a1 + 104) + 40) = a4;
      *(float *)(*(_QWORD *)(a1 + 104) + 28) = a4;
    }
  }
  return result;
}

float CFXGetBlueLightReductionCCTRange(uint64_t a1, _DWORD *a2, _DWORD *a3, float *a4)
{
  float result;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 104))
    {
      *a3 = *(_DWORD *)(*(_QWORD *)(a1 + 104) + 36);
      *a2 = *(_DWORD *)(*(_QWORD *)(a1 + 104) + 32);
      result = *(float *)(*(_QWORD *)(a1 + 104) + 40);
      *a4 = result;
    }
  }
  return result;
}

uint64_t CFXSetBlueReductionFactorOverride(uint64_t result, float a2, float a3)
{
  float v3;
  float v4;
  float v5;
  float v6;
  uint64_t v7;

  v7 = result;
  if (result && *(_QWORD *)(result + 104))
  {
    *(float *)(*(_QWORD *)(result + 104) + 44) = a2;
    if (a2 >= 0.0)
      v5 = a2;
    else
      v5 = **(float **)(result + 104);
    v6 = fminf(fmaxf(v5, 0.0), 1.0);
    v3 = (float)(v6 * *(float *)(*(_QWORD *)(result + 104) + 28)) + (1.0 - v6) * *(float *)(result + 2124);
    _CFXCCT2xy_Shifted(result, (float *)(*(_QWORD *)(result + 104) + 20), v3);
    CFXChromaticity2Tristimulus((float *)(*(_QWORD *)(v7 + 104) + 20), (float *)(*(_QWORD *)(v7 + 104) + 8), 150.0);
    v4 = fmax(a3, 0.0);
    return _CFXUpdateBLRTarget(v7, v4);
  }
  return result;
}

void CFXSetBlueLightReductionTargetCCT(uint64_t a1, char a2, float a3, float a4, float a5)
{
  float v5;
  float v6;
  float v7;
  float v8;
  char v10;

  v10 = a2 & 1;
  if (a1 && *(_QWORD *)(a1 + 104))
  {
    v5 = fmax(a3, *(float *)(*(_QWORD *)(a1 + 104) + 36));
    *(float *)(*(_QWORD *)(a1 + 104) + 28) = fminf(v5, *(float *)(*(_QWORD *)(a1 + 104) + 32));
    v8 = fminf(fmaxf(**(float **)(a1 + 104), 0.0), 1.0);
    if (a5 == 0.0)
    {
      *(float *)(*(_QWORD *)(a1 + 104) + 44) = -1.0;
    }
    else
    {
      *(float *)(*(_QWORD *)(a1 + 104) + 44) = 1.0;
      v8 = 1.0;
    }
    v6 = (float)(v8 * *(float *)(*(_QWORD *)(a1 + 104) + 28)) + (1.0 - v8) * *(float *)(a1 + 2124);
    _CFXCCT2xy_Shifted(a1, (float *)(*(_QWORD *)(a1 + 104) + 20), v6);
    CFXChromaticity2Tristimulus((float *)(*(_QWORD *)(a1 + 104) + 20), (float *)(*(_QWORD *)(a1 + 104) + 8), 150.0);
    if (a4 < 0.0)
      v7 = *(float *)(*(_QWORD *)(a1 + 104) + 4);
    else
      v7 = a4;
    if ((v10 & 1) != 0)
    {
      *(_BYTE *)(*(_QWORD *)(a1 + 104) + 48) = 1;
    }
    else
    {
      _CFXSetNativeWhitePointCorrection(a1, a5 != 0.0, 4, v7);
      _CFXUpdateBLRTarget(a1, v7);
    }
  }
}

void CFXCancelColorFade(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v6[2];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v4 = a1;
  if (a1)
  {
    v3 = v4 + 368;
    if ((*(_BYTE *)(v4 + 384) & 1) == 0)
    {
      *(_BYTE *)(v3 + 16) = 1;
      *(_QWORD *)v3 = 0;
      __memcpy_chk();
      v2 = 0;
      v1 = 0;
      _CFXGetWPFromMatrix(v4, (float *)(v3 + 20), &v2, &v1);
      CFXChromaticity2uv((float *)&v2, v6);
      *(float *)(v4 + 120) = v6[0];
      *(float *)(v4 + 124) = v6[1];
    }
  }
}

BOOL _CFXIsIdentity(float *a1)
{
  BOOL v2;

  v2 = 0;
  if (float_equal(*a1, 1.0))
  {
    v2 = 0;
    if (float_equal(a1[1], 0.0))
    {
      v2 = 0;
      if (float_equal(a1[2], 0.0))
      {
        v2 = 0;
        if (float_equal(a1[3], 0.0))
        {
          v2 = 0;
          if (float_equal(a1[4], 1.0))
          {
            v2 = 0;
            if (float_equal(a1[5], 0.0))
            {
              v2 = 0;
              if (float_equal(a1[6], 0.0))
              {
                v2 = 0;
                if (float_equal(a1[7], 0.0))
                  return float_equal(a1[8], 1.0);
              }
            }
          }
        }
      }
    }
  }
  return v2;
}

float _CFXCorrectForNativeWP(uint64_t a1, float *a2, float a3)
{
  float result;
  double v4;
  float v5;
  int j;
  int i;
  float v8;
  float v9;

  if ((*(_BYTE *)(a1 + 2520) & 1) == 0)
    return _CFXIdentity(a2);
  v9 = fminf(fmaxf(a3, 0.0), 1.0);
  result = 1.0 - v9;
  v8 = result;
  for (i = 0; i < 3; ++i)
  {
    for (j = 0; j < 3; ++j)
    {
      v4 = 1.0;
      if (i != j)
        v4 = 0.0;
      v5 = v4;
      result = (float)(v8 * v5) + (float)(v9 * *(float *)(a1 + 2472 + 12 * i + 4 * j));
      a2[3 * i + j] = result;
    }
  }
  return result;
}

void _CFXGetXYZD50Matrix(uint64_t a1, float *a2, float *a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  _QWORD v12[13];
  float *v13;
  float *v14;
  uint64_t v15;
  _BYTE v16[36];
  _BYTE v17[36];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v15 = a1;
  v14 = a2;
  v13 = a3;
  v12[10] = v17;
  _CFXGetLMSD50Matrix(a1, a2);
  v12[11] = v16;
  Mul33MatrixBy33Matrix((uint64_t)v17, (uint64_t)Mcat, (uint64_t)v16);
  Mul33MatrixBy33Matrix((uint64_t)&InvMcat, (uint64_t)v16, (uint64_t)v13);
  v3 = *v13;
  v4 = v13[1];
  v5 = v13[2];
  v6 = v13[3];
  v7 = v13[4];
  v8 = v13[5];
  v9 = v13[6];
  v10 = v13[7];
  v11 = v13[8];
  v12[12] = v12;
  syslog(7, "XYZD50M = %f %f %f; %f %f %f; %f %f %f\n", v3, v4, v5, v6, v7, v8, v9, v10, v11);
}

void _CFXGetsRGBD50Matrix(uint64_t a1, float *a2, float *a3)
{
  float v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  _QWORD v13[15];
  float *v14;
  float *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  float v19[4];
  _BYTE v20[36];
  _BYTE v21[36];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v16 = a1;
  v15 = a2;
  v14 = a3;
  v13[10] = v21;
  _CFXGetLMSD50Matrix(a1, a2);
  v13[11] = v20;
  Mul33MatrixBy33Matrix((uint64_t)v21, v16 + 2144, (uint64_t)v20);
  Mul33MatrixBy33Matrix(v16 + 2180, (uint64_t)v20, (uint64_t)v14);
  v19[2] = 1.0;
  v19[1] = 1.0;
  v19[0] = 1.0;
  v13[12] = &v17;
  v17 = 0;
  v18 = 0;
  Mul33MatrixBy31Vector(v14, v19, (float *)&v17);
  v13[13] = v14;
  v3 = MaxOfVector((float *)&v17);
  Div33MatrixByScalar((uint64_t)v14, (uint64_t)v14, v3);
  v4 = *v14;
  v5 = v14[1];
  v6 = v14[2];
  v7 = v14[3];
  v8 = v14[4];
  v9 = v14[5];
  v10 = v14[6];
  v11 = v14[7];
  v12 = v14[8];
  v13[14] = v13;
  syslog(7, "sRGBD50M = %f %f %f; %f %f %f; %f %f %f\n", v4, v5, v6, v7, v8, v9, v10, v11, v12);
}

void _CFXGetXYZMatrixWithLMSIlluminant(uint64_t a1, float *a2, float *a3, float *a4)
{
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  _QWORD v13[12];
  float *v14;
  float *v15;
  float *v16;
  uint64_t v17;
  _BYTE v18[36];
  _BYTE v19[36];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13[9] = v19;
  _CFXGetLMSMatrixWithLMSIlluminant(a1, a2, a3);
  v13[10] = v18;
  Mul33MatrixBy33Matrix((uint64_t)v19, (uint64_t)Mcat, (uint64_t)v18);
  Mul33MatrixBy33Matrix((uint64_t)&InvMcat, (uint64_t)v18, (uint64_t)v14);
  v4 = *v14;
  v5 = v14[1];
  v6 = v14[2];
  v7 = v14[3];
  v8 = v14[4];
  v9 = v14[5];
  v10 = v14[6];
  v11 = v14[7];
  v12 = v14[8];
  v13[11] = v13;
  syslog(7, "XYZM = %f %f %f; %f %f %f; %f %f %f\n", v4, v5, v6, v7, v8, v9, v10, v11, v12);
}

void _CFXGetsRGBMatrixWithLMSIlluminant(uint64_t a1, float *a2, float *a3, float *a4)
{
  float v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  _QWORD v14[14];
  float *v15;
  float *v16;
  float *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  float v21[4];
  _BYTE v22[36];
  _BYTE v23[36];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v18 = a1;
  v17 = a2;
  v16 = a3;
  v15 = a4;
  v14[9] = v23;
  _CFXGetLMSMatrixWithLMSIlluminant(a1, a2, a3);
  v14[10] = v22;
  Mul33MatrixBy33Matrix((uint64_t)v23, v18 + 2144, (uint64_t)v22);
  Mul33MatrixBy33Matrix(v18 + 2180, (uint64_t)v22, (uint64_t)v15);
  v21[2] = 1.0;
  v21[1] = 1.0;
  v21[0] = 1.0;
  v14[11] = &v19;
  v19 = 0;
  v20 = 0;
  Mul33MatrixBy31Vector(v15, v21, (float *)&v19);
  v14[12] = v15;
  v4 = MaxOfVector((float *)&v19);
  Div33MatrixByScalar((uint64_t)v15, (uint64_t)v15, v4);
  v5 = *v15;
  v6 = v15[1];
  v7 = v15[2];
  v8 = v15[3];
  v9 = v15[4];
  v10 = v15[5];
  v11 = v15[6];
  v12 = v15[7];
  v13 = v15[8];
  v14[13] = v14;
  syslog(7, "sRGBM = %f %f %f; %f %f %f; %f %f %f\n", v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

double CFXClearReport(uint64_t a1)
{
  double result;

  if (a1)
    return _CFXClearReport(a1);
  return result;
}

double CFXGetReport(uint64_t a1, uint64_t a2)
{
  double v2;
  double *v3;
  double v4;
  double *v5;
  double v6;
  double *v7;
  double v8;
  double *v9;
  double result;
  int v11;
  int v12;
  char v13;
  int v14;
  int v15;
  int v16;
  int v17;
  double v18;
  double v19;
  uint64_t v20;

  if (a1 && a2)
  {
    v20 = mach_absolute_time();
    v2 = MachTimeToSeconds(v20 - *(_QWORD *)(a1 + 1016));
    v3 = (double *)(a1 + 808 + 8 * *(int *)(a1 + 1012));
    *v3 = *v3 + v2;
    v4 = MachTimeToSeconds(v20 - *(_QWORD *)(a1 + 1232));
    v5 = (double *)(a1 + 1024 + 8 * *(int *)(a1 + 1228));
    *v5 = *v5 + v4;
    v6 = MachTimeToSeconds(v20 - *(_QWORD *)(a1 + 1616));
    v7 = (double *)(a1 + 1240 + 8 * *(int *)(a1 + 1608));
    *v7 = *v7 + v6;
    v18 = MachTimeToSeconds((unint64_t)((double)v20 - *(double *)(a1 + 1640)));
    if ((*(_BYTE *)(a1 + 1648) & 1) != 0)
      *(double *)(a1 + 1624) = *(double *)(a1 + 1624) + v18;
    else
      *(double *)(a1 + 1632) = *(double *)(a1 + 1632) + v18;
    if (*(_QWORD *)(a1 + 96) && (*(_BYTE *)(*(_QWORD *)(a1 + 96) + 184) & 1) != 0)
    {
      v8 = MachTimeToSeconds((unint64_t)((double)v20 - *(double *)(a1 + 1744)));
      v9 = (double *)(a1 + 1656 + 8 * *(int *)(a1 + 1736));
      *v9 = *v9 + v8;
    }
    v19 = MachTimeToSeconds((unint64_t)((double)v20 - *(double *)(a1 + 1776)));
    *(double *)(a1 + 1752) = *(double *)(a1 + 1752) + v19;
    *(double *)(a1 + 1760) = *(double *)(a1 + 1760) + v19 * *(float *)(a1 + 1788);
    *(double *)(a1 + 1768) = *(double *)(a1 + 1768) + v19 * *(float *)(a1 + 1784);
    if (*(_QWORD *)(a1 + 104))
      *(_DWORD *)(a1 + 1652) = *(_DWORD *)(*(_QWORD *)(a1 + 104) + 28);
    __memcpy_chk();
    v17 = *(_DWORD *)(a1 + 1012);
    v16 = *(_DWORD *)(a1 + 1228);
    v15 = *(_DWORD *)(a1 + 1736);
    v14 = *(_DWORD *)(a1 + 1608);
    v13 = *(_BYTE *)(a1 + 1648) & 1;
    v12 = *(_DWORD *)(a1 + 1788);
    v11 = *(_DWORD *)(a1 + 1784);
    __memset_chk();
    *(_QWORD *)(a1 + 1016) = v20;
    *(_DWORD *)(a1 + 1012) = v17;
    *(_QWORD *)(a1 + 1232) = v20;
    *(_DWORD *)(a1 + 1228) = v16;
    *(double *)(a1 + 1640) = (double)v20;
    *(_BYTE *)(a1 + 1648) = v13 & 1;
    *(_DWORD *)(a1 + 1736) = v15;
    *(double *)(a1 + 1744) = (double)v20;
    *(_DWORD *)(a1 + 1788) = v12;
    *(_DWORD *)(a1 + 1784) = v11;
    result = (double)v20;
    *(double *)(a1 + 1776) = (double)v20;
    *(_QWORD *)(a1 + 1616) = v20;
    *(_DWORD *)(a1 + 1608) = v14;
  }
  return result;
}

float CFXOverrideRampPeriod(uint64_t a1, float result)
{
  if (a1)
    *(float *)(a1 + 2252) = result;
  return result;
}

uint64_t CFXGetLuxThreshold(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  char v4;

  if (a1 && a2 < 4)
  {
    *a3 = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 192 + 4 * a2);
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  return v4 & 1;
}

void CFXInitAmmolite(uint64_t a1, io_registry_entry_t a2)
{
  if (!CFXAmmoliteEnabled(a1))
  {
    syslog(7, "CFXInitAmmolite() - proceeding with enablement");
    if (*(_QWORD *)(a1 + 2256))
      __assert_rtn("CFXInitAmmolite", "ColorEffects.c", 3774, "cfx->ammolite == NULL");
    *(_QWORD *)(a1 + 2256) = CFXAmmoliteCreate(a2, a1 + 2264);
    if (CFXAmmoliteEnabled(a1))
      _CFXUpdateTarget(a1, (float *)(a1 + 80), 1, 0, *(float *)(*(_QWORD *)(a1 + 2256) + 40));
  }
}

BOOL CFXAmmoliteEnabled(uint64_t a1)
{
  return *(_QWORD *)(a1 + 2256) != 0;
}

void CFXAmmoliteDisable(uint64_t a1)
{
  if (CFXAmmoliteEnabled(a1))
  {
    syslog(7, "CFXAmmoliteDisable() - proceeding with disablement");
    _CFXUpdateTarget(a1, (float *)(a1 + 80), 1, 0, *(float *)(*(_QWORD *)(a1 + 2256) + 40));
    *(_BYTE *)(a1 + 2280) = 0;
    _CFXIdentity((float *)(a1 + 2284));
    __memcpy_chk();
    *(double *)(a1 + 2264) = *(float *)(*(_QWORD *)(a1 + 2256) + 40);
    *(CFAbsoluteTime *)(a1 + 2272) = CFAbsoluteTimeGetCurrent();
  }
  CFXAmmoliteFree(*(_QWORD *)(a1 + 2256));
  *(_QWORD *)(a1 + 2256) = 0;
}

void CFXSetNativeWhitePoint(uint64_t a1, _DWORD *a2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  uint64_t v11;
  float v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  float *v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v19 = a1;
  v18 = a2;
  v17 = a1;
  if (a1)
  {
    if (v18)
    {
      *(_DWORD *)(v17 + 2464) = *v18;
      *(_DWORD *)(v17 + 2468) = v18[1];
      v13 = &v24;
      v24 = 0;
      v25 = 0;
      v16 = (float *)&v22;
      v22 = 0;
      v23 = 0;
      v12 = 1.0;
      CFXChromaticity2Tristimulus((float *)(v17 + 2116), (float *)&v24, 1.0);
      CFXChromaticity2Tristimulus((float *)(v17 + 2464), (float *)&v22, 1.0);
      v14 = &v20;
      v20 = 0;
      v21 = 0;
      CFXTristimulus2lms((float *)&v22, (float *)&v20);
      _CFXGetMatrix(v17, (float *)&v24, v17 + 2472, (float *)&v20);
      v2 = *(float *)(v17 + 2472);
      v3 = *(float *)(v17 + 2476);
      v4 = *(float *)(v17 + 2480);
      v5 = *(float *)(v17 + 2484);
      v6 = *(float *)(v17 + 2488);
      v7 = *(float *)(v17 + 2492);
      v8 = *(float *)(v17 + 2496);
      v9 = *(float *)(v17 + 2500);
      v10 = *(float *)(v17 + 2504);
      v15 = &v11;
      syslog(7, "NativeWPMatrix = %f %f %f; %f %f %f; %f %f %f\n", v2, v3, v4, v5, v6, v7, v8, v9, v10);
      Mul33MatrixBy31Vector(InvMrgb2xyzD65, v16, (float *)(v17 + 2508));
      *(_BYTE *)(v17 + 2520) = 1;
    }
  }
}

void CFXSetOutputFormat(uint64_t a1, int a2, int a3, float *a4)
{
  uint64_t v5;
  float v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_DWORD *)(a1 + 2528) = a2;
    *(_DWORD *)(a1 + 2532) = a3;
    if (a3 == 2)
    {
      if (a4)
      {
        v5 = 0;
        v6 = 0.0;
        CFXChromaticity2Tristimulus(a4, (float *)&v5, 1.0);
        CFXTristimulus2lms((float *)&v5, (float *)(a1 + 2536));
        syslog(7, "Custom Illuminant XYZ = (%f, %f, %f), LMS = (%f, %f, %f)\n", *(float *)&v5, *((float *)&v5 + 1), v6, *(float *)(a1 + 2536), *(float *)(a1 + 2540), *(float *)(a1 + 2544));
      }
    }
  }
}

uint64_t CFXEnableMitigations(uint64_t result, char a2)
{
  if (result)
  {
    if (*(_QWORD *)(result + 96))
      *(_BYTE *)(*(_QWORD *)(result + 96) + 303) = a2 & 1;
  }
  return result;
}

float CFXGetAdaptationStrength(uint64_t a1)
{
  if (a1 && *(_QWORD *)(a1 + 96))
    return *(float *)(*(_QWORD *)(a1 + 96) + 308);
  else
    return 0.0;
}

float CFXEnableOverrides(uint64_t a1, uint64_t a2)
{
  float result;
  uint64_t v3;
  uint64_t v4;
  char v5;

  if (a1)
  {
    v5 = 0;
    if (a2)
    {
      v5 = *(_BYTE *)(a2 + 1) & 1;
      if (v5)
      {
        if (*(_QWORD *)(a1 + 96))
        {
          v4 = *(_QWORD *)(a1 + 96);
          *(_DWORD *)(v4 + 180) = *(_DWORD *)(a2 + 4);
          *(_DWORD *)(v4 + 176) = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(v4 + 160) = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(v4 + 164) = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(v4 + 168) = *(_DWORD *)(a2 + 12);
          result = *(float *)(a2 + 12);
          *(float *)(v4 + 172) = result;
        }
      }
    }
    if ((v5 & 1) == 0)
    {
      if (*(_QWORD *)(a1 + 96))
      {
        v3 = *(_QWORD *)(a1 + 96);
        *(_DWORD *)(v3 + 180) = 1114636288;
        *(float *)(v3 + 176) = 20.0;
        result = 5.0;
        *(float *)(v3 + 160) = 5.0;
        *(float *)(v3 + 164) = 5.0;
        *(float *)(v3 + 168) = 5.0;
        *(float *)(v3 + 172) = 5.0;
      }
    }
  }
  return result;
}

float CFXGetTwilightStrength(uint64_t a1)
{
  return *(float *)(a1 + 2600);
}

uint64_t CFXSetTwilightStrength(uint64_t result, float a2)
{
  *(float *)(result + 2600) = a2;
  return result;
}

uint64_t _CFXLogString(uint64_t result, const char *a2)
{
  int v2;
  uint64_t v4;

  v4 = result;
  if (result)
  {
    if (!*(_QWORD *)(result + 1808))
    {
      *(_QWORD *)(result + 1808) = malloc_type_malloc(0x32000uLL, 0xAFD7CAA4uLL);
      *(_DWORD *)(v4 + 1816) = 0;
      mkdir("/var/mobile/Library/Logs/CrashReporter/harmony", 0x1EDu);
    }
    v2 = strlen(a2);
    if (v2 + *(_DWORD *)(v4 + 1816) > 204800)
      _CFXCommitLog((FILE *)v4);
    result = __memcpy_chk();
    *(_DWORD *)(v4 + 1816) += v2;
  }
  return result;
}

float _CFXCCT2xy_Generic(float a1, uint64_t a2, uint64_t a3, int a4, float *a5)
{
  float result;
  float v6;
  float v7;
  int i;
  int v9;
  float v10;
  float v11;

  v9 = a4 / 3;
  for (i = 0; i < v9 && a1 > *(float *)(a3 + 4 * i); ++i)
    ;
  if (i == v9)
  {
    v11 = *(float *)(a3 + 4 * (2 * v9 - 1));
    v10 = *(float *)(a3 + 4 * (3 * v9 - 1));
  }
  else if (i)
  {
    v7 = *(float *)(a3 + 4 * i);
    v6 = *(float *)(a3 + 4 * (i - 1));
    v11 = (float)((float)((float)(a1 - v7) / (float)(v6 - v7)) * *(float *)(a3 + 4 * (i - 1 + v9)))
        + (float)((float)(1.0 - (float)((float)(a1 - v7) / (float)(v6 - v7))) * *(float *)(a3 + 4 * (i + v9)));
    v10 = (float)((float)((float)(a1 - v7) / (float)(v6 - v7)) * *(float *)(a3 + 4 * (i - 1 + 2 * v9)))
        + (float)((float)(1.0 - (float)((float)(a1 - v7) / (float)(v6 - v7))) * *(float *)(a3 + 4 * (i + 2 * v9)));
  }
  else
  {
    v11 = *(float *)(a3 + 4 * v9);
    v10 = *(float *)(a3 + 8 * v9);
  }
  *a5 = v11;
  result = v10;
  a5[1] = v10;
  return result;
}

uint64_t _CFXSetBLRTarget(uint64_t a1, float *a2, char a3, char a4, float a5, float a6)
{
  float v6;
  float v7;
  double v8;
  double *v9;
  void (*v11)(uint64_t, uint64_t);
  uint64_t v12;
  char v13;
  int v14;
  double v15;
  uint64_t v16;
  int v17;
  float v18;
  float v19[3];
  int v20;
  uint64_t v21;
  double Current;
  float v23;
  char v24;
  char v25;
  float v26;
  float *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  float v33[3];
  float __dst[9];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v28 = a1;
  v27 = a2;
  v26 = a5;
  v25 = a3 & 1;
  v24 = a4 & 1;
  v23 = a6;
  if (*(float *)(a1 + 2252) >= 0.0)
    v26 = *(float *)(v28 + 2252);
  Current = CFAbsoluteTimeGetCurrent();
  v21 = mach_absolute_time();
  if ((*(_BYTE *)(v28 + 364) & 1) != 0)
  {
    memcpy(__dst, v27, sizeof(__dst));
  }
  else
  {
    if (*(_QWORD *)(v28 + 112))
    {
      _CFXMagic(v27, __dst, *(float **)(v28 + 112));
      v33[2] = 1.0;
      v33[1] = 1.0;
      v33[0] = 1.0;
      v31 = 0;
      v32 = 0;
      Mul33MatrixBy31Vector(__dst, v33, (float *)&v31);
      v6 = MaxOfVector((float *)&v31);
      Div33MatrixByScalar((uint64_t)__dst, (uint64_t)__dst, v6);
    }
    else
    {
      memcpy(__dst, v27, sizeof(__dst));
    }
    v20 = 0;
    *(_QWORD *)v19 = 0;
    v18 = 0.0;
    _CFXGetWPFromMatrix(v28, __dst, v19, &v18);
    v7 = 1.0 / v18;
    *(float *)(v28 + 2140) = v7;
    v29 = 0;
    v30 = 0;
    CFXChromaticity2Tristimulus(v19, (float *)&v29, 100.0);
    v16 = 0;
    v17 = 0;
    CFXTristimulus2Lab((float *)&v29, (float *)&v16);
    v20 = binFromAb((float *)&v16 + 1);
    if (v20 != *(_DWORD *)(v28 + 1228))
    {
      v15 = 0.0;
      v15 = MachTimeToSeconds(v21 - *(_QWORD *)(v28 + 1232));
      v9 = (double *)(v28 + 1024 + 8 * *(int *)(v28 + 1228));
      v8 = *v9 + v15;
      *v9 = v8;
      *(_QWORD *)(v28 + 1232) = v21;
      *(_DWORD *)(v28 + 1228) = v20;
      *(_DWORD *)(v28 + 320) = v20;
    }
    LODWORD(v8) = *(_DWORD *)(v28 + 1784);
    _CFXUpdateCompensatedBacklight(v28, v21, v8);
  }
  *(_DWORD *)(v28 + 288) = 9;
  __memcpy_chk();
  __memcpy_chk();
  __memcpy_chk();
  v14 = 0;
  _CFXGetWPFromMatrix(v28, __dst, (_QWORD *)(v28 + 296), &v14);
  *(float *)(v28 + 248) = v26;
  *(float *)(v28 + 292) = 1.0;
  *(_BYTE *)(v28 + 240) = 0;
  *(double *)(v28 + 232) = Current + v26;
  v13 = 0;
  if ((*(_BYTE *)(v28 + 364) & 1) != 0)
  {
    __memcpy_chk();
    __memcpy_chk();
    *(double *)(v28 + 536) = *(float *)(v28 + 248);
    *(double *)(v28 + 544) = Current;
    v13 = 1;
    *(_BYTE *)(v28 + 552) = 0;
  }
  if (*(_QWORD *)(v28 + 328))
  {
    v11 = *(void (**)(uint64_t, uint64_t))(v28 + 328);
    v12 = *(_QWORD *)(v28 + 336);
    if ((v13 & 1) != 0)
      v11(v12, 0);
    else
      v11(v12, v28 + 248);
  }
  return 1;
}

uint64_t _CFXGetLMSMatrixWithLMSIlluminant(uint64_t a1, float *a2, float *a3)
{
  _DWORD __b[9];
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  v11 = 0;
  v8 = 0;
  v9 = 0;
  CFXChromaticity2Tristimulus(a2, (float *)&v10, 1.0);
  CFXTristimulus2lms((float *)&v10, (float *)&v8);
  v6 = 0;
  v7 = 0;
  Div31VectorBy31Vector((float *)&v8, a3, (float *)&v6);
  memset(__b, 0, sizeof(__b));
  __b[4] = HIDWORD(v6);
  __b[0] = v6;
  __b[8] = v7;
  return __memcpy_chk();
}

uint64_t _CFXGetLMSD50Matrix(uint64_t a1, float *a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v3 = 0x3F829D7C3F7F0EA2;
  v4 = 1062305199;
  return _CFXGetLMSMatrixWithLMSIlluminant(a1, a2, (float *)&v3);
}

void StockholmALSCoExEnableNotificationHandler(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *log;
  os_log_type_t v6;
  uint64_t inited;
  NSObject *v8;
  uint8_t v9[7];
  os_log_type_t type;
  os_log_t oslog;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = a5;
  if (a2)
  {
    v12 = v16;
    oslog = 0;
    if (*(_QWORD *)(v16 + 8))
    {
      v8 = *(NSObject **)(v12 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v8 = inited;
    }
    oslog = v8;
    type = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      log = oslog;
      v6 = type;
      __os_log_helper_16_0_0(v9);
      _os_log_impl(&dword_1B5291000, log, v6, "StockholmCoEx Color samples swallowing ON", v9, 2u);
    }
    *(_BYTE *)(v12 + 288) = 1;
  }
}

void StockholmALSCoExDisableNotificationHandler(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *log;
  os_log_type_t v6;
  uint64_t inited;
  NSObject *v8;
  uint8_t v9[7];
  os_log_type_t type;
  os_log_t oslog;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = a5;
  if (a2)
  {
    v12 = v16;
    oslog = 0;
    if (*(_QWORD *)(v16 + 8))
    {
      v8 = *(NSObject **)(v12 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v8 = inited;
    }
    oslog = v8;
    type = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      log = oslog;
      v6 = type;
      __os_log_helper_16_0_0(v9);
      _os_log_impl(&dword_1B5291000, log, v6, "StockholmCoEx Color samples swallowing OFF", v9, 2u);
    }
    *(_BYTE *)(v12 + 288) = 0;
  }
}

uint64_t __os_log_helper_16_2_3_8_66_8_66_8_64(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 66;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 66;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 64;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_64_4_0(uint64_t result, uint64_t a2, int a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  return result;
}

void sub_1B5369A6C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void sub_1B5369E08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15, _Unwind_Exception *exception_object, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  _Block_object_dispose(&a22, 8);
  _Unwind_Resume(a1);
}

uint64_t __os_log_helper_16_2_4_8_0_4_0_8_64_8_64(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 18) = 64;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 64;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  return result;
}

uint64_t __os_log_helper_16_0_3_4_0_4_0_4_0(uint64_t result, int a2, int a3, int a4)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 4;
  *(_DWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 14) = 0;
  *(_BYTE *)(result + 15) = 4;
  *(_DWORD *)(result + 16) = a4;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_66_8_66(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 66;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 66;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  return result;
}

void sub_1B536CA94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, int a19, _Unwind_Exception *exception_object)
{
  uint64_t v20;

  _Block_object_dispose((const void *)(v20 - 72), 8);
  _Unwind_Resume(a1);
}

void sub_1B536F8E0(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  uint64_t v10;

  *(_QWORD *)(v10 - 24) = a1;
  *(_DWORD *)(v10 - 28) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v10 - 24));
}

uint64_t __os_log_helper_16_2_3_8_66_8_66_8_66(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 66;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 66;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 66;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_66_8_64_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 66;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 64;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

uint64_t __os_log_helper_16_0_4_4_0_4_0_4_0_4_0(uint64_t result, int a2, int a3, int a4, int a5)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 4;
  *(_DWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 14) = 0;
  *(_BYTE *)(result + 15) = 4;
  *(_DWORD *)(result + 16) = a4;
  *(_BYTE *)(result + 20) = 0;
  *(_BYTE *)(result + 21) = 4;
  *(_DWORD *)(result + 22) = a5;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_66_4_0(uint64_t result, uint64_t a2, int a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 66;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  return result;
}

void sub_1B5373FE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

float linearBrightnessToPerceptualBrightness(float a1)
{
  float v2;

  if (a1 < 0.0)
    return 0.0;
  v2 = log2f(a1);
  return (float)(v2 / log2f(500.0)) + 1.0;
}

float perceptualBrightnessToLinearBrightness(float a1)
{
  if (a1 == 0.0)
    return 0.0;
  else
    return powf(500.0, a1 - 1.0);
}

float AAB::DefaultCurve@<S0>(uint64_t a1@<X0>, int a2@<W1>, char a3@<W2>, float *a4@<X3>, uint64_t a5@<X4>, float *a6@<X5>, uint64_t a7@<X8>, float a8@<S0>, float a9@<S1>, float a10@<S2>)
{
  float result;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;

  if (a2)
  {
    if (a2 == 1)
    {
      v17 = 1.0;
    }
    else if (a2 == 2)
    {
      v17 = 2.0;
    }
    else
    {
      v17 = 1.0;
    }
  }
  else
  {
    v17 = 0.5;
  }
  *(_DWORD *)(a7 + 16) = 0;
  *(float *)(a7 + 24) = (float)((float)((float)(a9 - 100.0) / 420.0) * -30.0) + 100.0;
  *(_DWORD *)(a7 + 20) = 1157234688;
  *(float *)(a7 + 28) = (float)((float)((float)(a9 - 100.0) / 420.0) * 1970.0) + 100.0;
  *(_DWORD *)a7 = 0;
  *(float *)(a7 + 4) = a8;
  *(float *)(a7 + 8) = 30.0;
  *(float *)(a7 + 12) = a8 + (float)((float)((float)(100.0 - a8) / 30.0) * (float)(*(float *)(a7 + 8) - 0.0));
  if ((a3 & 1) != 0)
  {
    *(_DWORD *)(a7 + 20) = 1142292480;
    *(_DWORD *)(a7 + 28) = 1125515264;
    v16 = (float)(*(float *)(a7 + 28) - *(float *)(a7 + 12)) / (float)(*(float *)(a7 + 20) - *(float *)(a7 + 8));
    *(_DWORD *)(a7 + 16) = 0;
    *(float *)(a7 + 24) = *(float *)(a7 + 28) - (float)((float)(*(float *)(a7 + 20) - *(float *)(a7 + 16)) * v16);
  }
  if (a5 && *(float *)(a5 + 4) >= 0.0)
    *(_DWORD *)(a7 + 12) = *(_DWORD *)(a5 + 4);
  if (a6 && *a6 >= 0.0 && a6[1] >= 0.0)
  {
    *(float *)(a7 + 20) = *a6;
    *(float *)(a7 + 28) = a6[1];
    v15 = (float)(*(float *)(a7 + 28) - *(float *)(a7 + 12)) / (float)(*(float *)(a7 + 20) - *(float *)(a7 + 8));
    *(_DWORD *)(a7 + 16) = 0;
    *(float *)(a7 + 24) = *(float *)(a7 + 28) - (float)((float)(*(float *)(a7 + 20) - *(float *)(a7 + 16)) * v15);
  }
  v14 = -(float)(*(float *)(a7 + 24) - (float)(*(float *)(a7 + 24) * v17));
  if (v17 == 2.0)
  {
    v13 = (float)(*(float *)(a7 + 12) - *(float *)(a7 + 4)) / (float)(*(float *)(a7 + 8) - *(float *)a7);
    *(float *)(a7 + 24) = *(float *)(a7 + 24) - (float)(*(float *)(a7 + 24) - (float)(*(float *)(a7 + 24) * v17));
    *(float *)(a7 + 28) = *(float *)(a7 + 28) + v14;
    *(_DWORD *)(a7 + 8) = 1114636288;
    *(float *)(a7 + 12) = *(float *)(a7 + 24)
                        + (float)((float)((float)(*(float *)(a7 + 28) - *(float *)(a7 + 24))
                                        / (float)(*(float *)(a7 + 20) - *(float *)(a7 + 16)))
                                * *(float *)(a7 + 8));
    *(float *)(a7 + 4) = *(float *)(a7 + 12) - (float)(v13 * *(float *)(a7 + 8));
  }
  else if (v17 == 0.5)
  {
    *(float *)(a7 + 24) = *(float *)(a7 + 24) - (float)(*(float *)(a7 + 24) - (float)(*(float *)(a7 + 24) * v17));
    *(float *)(a7 + 28) = *(float *)(a7 + 28) + v14;
    *(float *)(a7 + 4) = *(float *)(a7 + 4) + v14;
    *(float *)(a7 + 12) = *(float *)(a7 + 12) + v14;
  }
  (*(void (**)(uint64_t, const char *, ...))(*(_QWORD *)a1 + 16))(a1, "%s: curve: (_E1 = %0.2f, _L1 = %0.4f) (_E2 = %0.2f, _L2 = %0.4f)", "DefaultCurve", *(float *)(a7 + 16), *(float *)(a7 + 24), *(float *)(a7 + 20), *(float *)(a7 + 28));
  (*(void (**)(uint64_t, const char *, ...))(*(_QWORD *)a1 + 16))(a1, "%s:  dark  (E0a = %0.2f, L0a = %0.4f) (E0b = %0.2f, L0b = %0.4f)", "DefaultCurve", *(float *)a7, *(float *)(a7 + 4), *(float *)(a7 + 8), *(float *)(a7 + 12));
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a7 + 28);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a7 + 4);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a7 + 20);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)a7;
  *(_DWORD *)(a7 + 68) = 0;
  *(_DWORD *)(a7 + 72) = 2;
  *(_DWORD *)(a7 + 76) = 1;
  *(_DWORD *)(a7 + 32) = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a7 + 44) = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a7 + 36) = 0;
  *(_DWORD *)(a7 + 48) = 0;
  *(_DWORD *)(a7 + 40) = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a7 + 52) = *(_DWORD *)(a1 + 52);
  *(_DWORD *)(a7 + 64) = -1;
  *(_BYTE *)(a7 + 80) = 0;
  *(_DWORD *)(a7 + 56) = 0;
  *(_DWORD *)(a7 + 60) = 0;
  *(float *)(a7 + 100) = -1.0;
  *(float *)(a1 + 56) = a10;
  *(float *)(a1 + 60) = a8;
  if (a4 && *a4 > 0.0 && a4[1] > 0.0)
  {
    result = (float)(a4[1] - *(float *)(a7 + 28)) / (float)(*a4 - *(float *)(a7 + 20));
    *(float *)(a7 + 84) = result;
  }
  else
  {
    result = *(float *)(a7 + 28) / *(float *)(a7 + 20);
    *(float *)(a7 + 84) = result;
  }
  return result;
}

float AAB::LuminanceToIlluminance(float a1, uint64_t a2, float *a3)
{
  float v4;
  float v5;
  float v6;

  v6 = 0.0;
  if (a1 >= a3[3])
  {
    if (a1 >= a3[7])
    {
      v5 = a3[21];
      v4 = a3[7] - (float)(v5 * a3[5]);
    }
    else
    {
      v5 = (float)(a3[7] - a3[6]) / (float)(a3[5] - a3[4]);
      v4 = a3[6];
    }
  }
  else
  {
    v5 = (float)(a3[3] - a3[1]) / (float)(a3[2] - *a3);
    v4 = a3[1];
  }
  if (v5 != 0.0)
    return (float)(a1 - v4) / v5;
  return v6;
}

float AAB::LuminanceToIlluminance(AAB *this, float a2, const CustomCurve *a3)
{
  float v4;
  int i;
  float v6;
  float v7;

  v7 = 0.0;
  if (a3->size <= 1)
  {
    if (a3->size == 1)
      v4 = a3->_E[0];
    else
      v4 = 0.0;
    v7 = v4;
  }
  else
  {
    for (i = 0; i < a3->size - 1; ++i)
    {
      if (a2 <= a3->_L[i + 1])
      {
        if ((float)(a3->_E[i + 1] - a3->_E[i]) != 0.0)
        {
          v6 = (float)(a3->_L[i + 1] - a3->_L[i]) / (float)(a3->_E[i + 1] - a3->_E[i]);
          if (v6 == 0.0)
            v7 = fminf(a3->_E[i], 20000.0);
          else
            v7 = fminf((float)((float)(a2 - a3->_L[i]) + (float)(a3->_E[i] * v6)) / v6, 20000.0);
        }
        return fmaxf(v7, 0.0);
      }
      if (i == a3->size - 2)
        return fmaxf(fminf(a3->_E[i + 1], 20000.0), 0.0);
    }
  }
  return fmaxf(v7, 0.0);
}

uint64_t AAB::UpdateCurve_Block3(uint64_t a1, uint64_t a2, float a3, float a4, float a5)
{
  _BYTE v7[16];
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  float v11;

  v10 = __PAIR64__(LODWORD(a4), LODWORD(a3));
  v11 = a5;
  v9 = a1;
  v8 = a2;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v7, a1 + 72);
  (*(void (**)(_QWORD, uint64_t, uint64_t, float, float, float))(**(_QWORD **)(a1 + 64) + 24))(*(_QWORD *)(a1 + 64), a1, v8, *(float *)&v10, *((float *)&v10 + 1), v11);
  *(CFAbsoluteTime *)(v8 + 88) = CFAbsoluteTimeGetCurrent();
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v7);
}

void sub_1B5375B08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object, uint64_t a14, uint64_t a15, char a16)
{
  std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t std::unique_lock<std::mutex>::unique_lock[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100](a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 8) = 1;
  std::mutex::lock(*(std::mutex **)a1);
  return a1;
}

uint64_t std::unique_lock<std::mutex>::~unique_lock[abi:ne180100](uint64_t a1)
{
  std::unique_lock<std::mutex>::~unique_lock[abi:ne180100](a1);
  return a1;
}

{
  if ((*(_BYTE *)(a1 + 8) & 1) != 0)
    std::mutex::unlock(*(std::mutex **)a1);
  return a1;
}

uint64_t AAB::UpdateCurve_Block3_WithCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float a5, float a6, float a7)
{
  _BYTE v9[16];
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  float v15;

  v14 = __PAIR64__(LODWORD(a6), LODWORD(a5));
  v15 = a7;
  v13 = a1;
  v12 = a2;
  v11 = a3;
  v10 = a4;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v9, a1 + 72);
  (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, float, float, float))(**(_QWORD **)(a1 + 64) + 32))(*(_QWORD *)(a1 + 64), a1, v12, v11, v10, *(float *)&v14, *((float *)&v14 + 1), v15);
  *(CFAbsoluteTime *)(v12 + 88) = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(v10 + 88) = CFAbsoluteTimeGetCurrent();
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v9);
}

void sub_1B5375C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, _Unwind_Exception *exception_object, uint64_t a16, uint64_t a17, char a18)
{
  std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)&a18);
  _Unwind_Resume(a1);
}

uint64_t AAB::UpdateCurve_Block3_WithCappedCurve_AlternativeCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, float a7, float a8, float a9)
{
  _BYTE v11[16];
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  float v19;

  v18 = __PAIR64__(LODWORD(a8), LODWORD(a7));
  v19 = a9;
  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = a5;
  v12 = a6;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v11, a1 + 72);
  (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, float, float, float))(**(_QWORD **)(a1 + 64) + 32))(*(_QWORD *)(a1 + 64), a1, v16, v15, v14, *(float *)&v18, *((float *)&v18 + 1), v19);
  (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, float, float, float))(**(_QWORD **)(a1 + 64) + 40))(*(_QWORD *)(a1 + 64), a1, v13, v15, v12, *(float *)&v18, *((float *)&v18 + 1), v19);
  *(CFAbsoluteTime *)(v16 + 88) = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(v14 + 88) = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(v13 + 88) = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(v12 + 88) = CFAbsoluteTimeGetCurrent();
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v11);
}

void sub_1B5375DA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, int a16, _Unwind_Exception *exception_object, uint64_t a18, uint64_t a19, char a20)
{
  std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)&a20);
  _Unwind_Resume(a1);
}

uint64_t AAB::GetCurveUpdates@<X0>(AAB *this@<X0>, uint64_t a2@<X8>)
{
  _BYTE v4[16];
  AAB *v5;
  uint64_t v6;

  v6 = a2;
  v5 = this;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v4, (uint64_t)this + 72);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 8) + 48))(*((_QWORD *)this + 8));
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v4);
}

void sub_1B5375E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object, char a14)
{
  std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)&a14);
  _Unwind_Resume(a1);
}

uint64_t AAB::SetCurveUpdates(uint64_t a1, uint64_t a2)
{
  _BYTE v4[16];
  uint64_t v5;
  uint64_t v6;

  v6 = a1;
  v5 = a2;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v4, a1 + 72);
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 64) + 56))(*(_QWORD *)(a1 + 64), v5);
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v4);
}

void sub_1B5375E94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object, char a14)
{
  std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)&a14);
  _Unwind_Resume(a1);
}

uint64_t AAB::TraditionalUpdateCurveStrategy::UpdateCurve(double a1, float a2, float a3, uint64_t a4, float *a5, uint64_t a6)
{
  float v6;
  float v7;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;

  (*(void (**)(float *, const char *, ...))(*(_QWORD *)a5 + 8))(a5, "%s: inputs: Esensor=%f Luser=%f %x", "UpdateCurve", a2, a3);
  v16 = (float)(*(float *)(a6 + 28) - *(float *)(a6 + 24)) / (float)(*(float *)(a6 + 20) - *(float *)(a6 + 16));
  v15 = *(float *)(a6 + 24) / v16;
  if (v15 <= 0.0)
    v15 = (float)(*(float *)(a6 + 16) + *(float *)(a6 + 20)) / 2.0;
  if (v15 > 300.0)
    v15 = 300.0;
  if (v15 > a5[6] / 1.2)
  {
    v6 = a5[6] / 1.2;
    v15 = v6;
  }
  if (v15 < 30.0)
    v15 = 30.0;
  if (v15 < a5[5] * 1.2)
  {
    v7 = a5[5] * 1.2;
    v15 = v7;
  }
  a5[7] = v15;
  a5[8] = a2;
  a5[9] = a3;
  if (a2 >= *(float *)(a6 + 8) || (float)(*(float *)(a6 + 24) + (float)(v16 * *(float *)(a6 + 8))) >= 200.0)
  {
    if (a2 <= v15)
    {
      a5[5] = a2;
      v9 = (float)(*(float *)(a6 + 28) - a3) / (float)(*(float *)(a6 + 20) - a5[5]);
      (**(void (***)(float *, const char *, ...))a5)(a5, "Esensor: %0.2f Luser: %0.4f Eth_dyn=%0.2f _Mmax=%0.4f _Mmin=%0.4f slope=%0.4f CCCC", a2, a3, v15, a5[2], a5[3], v9);
      v10 = fmaxf(fminf(v9, a5[2]), a5[3]);
      (*(void (**)(float *, const char *, ...))(*(_QWORD *)a5 + 8))(a5, "%s: <= Eth_dyn=%f _Mmax=%f _Mmin=%f slope=%f", "UpdateCurve", v15, a5[2], a5[3], v10);
      *(float *)(a6 + 28) = a3 + (float)(v10 * (float)(*(float *)(a6 + 20) - a5[5]));
      *(float *)(a6 + 24) = a3 + (float)(v10 * (float)(*(float *)(a6 + 16) - a5[5]));
      if ((float)(*(float *)(a6 + 24) + (float)(v10 * *(float *)(a6 + 8))) >= 200.0)
      {
        *(_DWORD *)(a6 + 4) = *(_DWORD *)(a6 + 24);
        *(float *)(a6 + 12) = *(float *)(a6 + 24) + (float)(v10 * *(float *)(a6 + 8));
      }
      else
      {
        *(_DWORD *)(a6 + 8) = *(_DWORD *)(a6 + 8);
        *(float *)(a6 + 12) = *(float *)(a6 + 24) + (float)(v10 * *(float *)(a6 + 8));
        *(float *)(a6 + 4) = *(float *)(a6 + 12)
                           - (float)(std::__math::fmax[abi:ne180100](fminf((float)(*(float *)(a6 + 12) - *(float *)(a6 + 4))/ (float)(*(float *)(a6 + 8) - *(float *)a6), a5[4]), v10)* *(float *)(a6 + 8));
      }
    }
    else
    {
      a5[6] = a2;
      v11 = fmaxf(fminf((float)(a3 - *(float *)(a6 + 24)) / (float)(a5[6] - *(float *)(a6 + 16)), a5[2]), a5[3]);
      (**(void (***)(float *, const char *, ...))a5)(a5, "Esensor: %0.2f Luser: %0.4f Eth_dyn=%0.2f _Mmax=%0.4f _Mmin=%0.4f slope=%0.4f", a2, a3, v15, a5[2], a5[3], v11);
      if (a5[6] < 200.0)
      {
        *(_DWORD *)(a6 + 20) = 1128792064;
        *(float *)(a6 + 28) = a3 + (float)(v11 * (float)(*(float *)(a6 + 20) - a5[6]));
      }
      else
      {
        *(float *)(a6 + 20) = a5[6];
        *(float *)(a6 + 28) = a3;
      }
      *(float *)(a6 + 24) = *(float *)(a6 + 28) + (float)(v11 * (float)(*(float *)(a6 + 16) - *(float *)(a6 + 20)));
      if ((float)(*(float *)(a6 + 24) + (float)(v11 * *(float *)(a6 + 8))) >= 200.0)
      {
        *(_DWORD *)(a6 + 4) = *(_DWORD *)(a6 + 24);
        *(float *)(a6 + 12) = *(float *)(a6 + 24) + (float)(v11 * *(float *)(a6 + 8));
      }
      else
      {
        *(_DWORD *)(a6 + 8) = *(_DWORD *)(a6 + 8);
        *(float *)(a6 + 12) = *(float *)(a6 + 24) + (float)(v11 * *(float *)(a6 + 8));
        *(float *)(a6 + 4) = *(float *)(a6 + 12)
                           - (float)(std::__math::fmax[abi:ne180100](fminf((float)(*(float *)(a6 + 12) - *(float *)(a6 + 4))/ (float)(*(float *)(a6 + 8) - *(float *)a6), a5[4]), v11)* *(float *)(a6 + 8));
      }
    }
  }
  else
  {
    v14 = fmaxf(fminf((float)(*(float *)(a6 + 12) - a3) / (float)(*(float *)(a6 + 8) - a2), a5[4]), v16);
    *(float *)(a6 + 4) = a3 - (float)(v14 * a2);
    *(float *)(a6 + 12) = *(float *)(a6 + 4) + (float)(v14 * *(float *)(a6 + 8));
    a5[5] = *(float *)(a6 + 8);
    v12 = (float)(*(float *)(a6 + 28) - *(float *)(a6 + 12)) / (float)(*(float *)(a6 + 20) - a5[5]);
    (**(void (***)(float *, const char *, ...))a5)(a5, "Esensor: %0.2f Luser: %0.4f Eth_dyn=%f _Mmax=%0.4f _Mmin=%0.4f slope=%0.4f", a2, a3, v15, a5[2], a5[3], v12);
    v13 = fmaxf(fminf(v12, a5[2]), a5[3]);
    *(float *)(a6 + 28) = *(float *)(a6 + 12) + (float)(v13 * (float)(*(float *)(a6 + 20) - a5[5]));
    *(float *)(a6 + 24) = *(float *)(a6 + 12) + (float)(v13 * (float)(*(float *)(a6 + 16) - a5[5]));
  }
  return (*(uint64_t (**)(float *, const char *, ...))(*(_QWORD *)a5 + 8))(a5, "%s: outputs: E1=%f L1=%f E2=%f L2=%f", "UpdateCurve", *(float *)(a6 + 16), *(float *)(a6 + 24), *(float *)(a6 + 20), *(float *)(a6 + 28));
}

float AAB::FitCurveToReferencePoints(float *a1, uint64_t a2, int a3)
{
  float result;
  float i;
  float j;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;

  result = 0.0;
  if (a3)
  {
    if (a3 == 1)
    {
      if (a1[11] < *(float *)(a2 + 8))
      {
        result = a1[11];
        if (result < *(float *)(a2 + 8))
        {
          for (i = a1[13] - (float)(a1[3] * (float)(a1[12] - *(float *)(a2 + 8)));
                i >= (float)(a1[13] - (float)(a1[2] * (float)(a1[12] - *(float *)(a2 + 8))));
                i = i - 0.01)
          {
            v15 = (float)(i - a1[10]) / (float)(*(float *)(a2 + 8) - a1[11]);
            if (v15 <= (float)((float)(a1[13] - i) / (float)(a1[12] - *(float *)(a2 + 8))) || v15 < a1[4])
              break;
          }
          v12 = (float)(a1[13] - i) / (float)(a1[12] - *(float *)(a2 + 8));
          *(float *)(a2 + 12) = a1[13] - (float)(v12 * (float)(a1[12] - *(float *)(a2 + 8)));
          if (a1[12] < 301.0)
            *(_DWORD *)(a2 + 20) = 1133936640;
          else
            *(float *)(a2 + 20) = a1[12];
          *(float *)(a2 + 28) = a1[13] + (float)(v12 * (float)(*(float *)(a2 + 20) - a1[12]));
          *(float *)(a2 + 24) = *(float *)(a2 + 28) - (float)(v12 * *(float *)(a2 + 20));
          result = *(float *)(a2 + 12)
                 - (float)(fminf(fmaxf((float)(*(float *)(a2 + 12) - a1[10]) / (float)(*(float *)(a2 + 8) - a1[11]), v12), a1[4])* (float)(*(float *)(a2 + 8) - *(float *)a2));
          *(float *)(a2 + 4) = result;
        }
      }
      else
      {
        v11 = fminf(fmaxf((float)(a1[13] - a1[10]) / (float)(a1[12] - a1[11]), a1[3]), a1[2]);
        if (a1[12] < 301.0)
          *(_DWORD *)(a2 + 20) = 1133936640;
        else
          *(float *)(a2 + 20) = a1[12];
        *(float *)(a2 + 28) = a1[13] + (float)(v11 * (float)(*(float *)(a2 + 20) - a1[12]));
        *(float *)(a2 + 24) = *(float *)(a2 + 28) - (float)(v11 * *(float *)(a2 + 20));
        *(float *)(a2 + 12) = *(float *)(a2 + 28) - (float)(v11 * (float)(*(float *)(a2 + 20) - *(float *)(a2 + 8)));
        result = *(float *)(a2 + 12)
               - (float)(fmaxf(fminf(a1[4], (float)(*(float *)(a2 + 12) - a1[15]) / (float)(*(float *)(a2 + 8) - *(float *)a2)), v11)* *(float *)(a2 + 8));
        *(float *)(a2 + 4) = result;
      }
    }
  }
  else if (a1[11] == *(float *)(a2 + 8))
  {
    *(float *)(a2 + 12) = a1[10];
    v7 = fminf(fmaxf((float)(a1[13] - *(float *)(a2 + 12)) / (float)(a1[12] - *(float *)(a2 + 8)), a1[3]), a1[2]);
    *(float *)(a2 + 28) = *(float *)(a2 + 12) + (float)(v7 * (float)(*(float *)(a2 + 20) - *(float *)(a2 + 8)));
    *(float *)(a2 + 24) = *(float *)(a2 + 28) - (float)(v7 * *(float *)(a2 + 20));
    result = a1[10]
           - (float)(fmaxf(fminf(a1[4], (float)(a1[10] - a1[15]) / (float)(*(float *)(a2 + 8) - *(float *)a2)), v7)
                   * a1[11]);
    *(float *)(a2 + 4) = result;
  }
  else if (a1[11] >= *(float *)(a2 + 8))
  {
    v10 = fminf(fmaxf((float)(a1[13] - a1[10]) / (float)(a1[12] - a1[11]), a1[3]), a1[2]);
    *(float *)(a2 + 28) = a1[10] + (float)(v10 * (float)(*(float *)(a2 + 20) - a1[11]));
    *(float *)(a2 + 24) = *(float *)(a2 + 28) - (float)(v10 * *(float *)(a2 + 20));
    *(float *)(a2 + 12) = *(float *)(a2 + 28) - (float)(v10 * (float)(*(float *)(a2 + 20) - *(float *)(a2 + 8)));
    result = *(float *)(a2 + 12)
           - (float)(fmaxf(fminf(a1[4], (float)(*(float *)(a2 + 12) - a1[15]) / (float)(*(float *)(a2 + 8) - *(float *)a2)), v10)* *(float *)(a2 + 8));
    *(float *)(a2 + 4) = result;
  }
  else
  {
    v13 = a1[4];
    for (j = a1[10]; j < a1[14]; j = j + 0.01)
    {
      v13 = (float)(j - a1[10]) / (float)(*(float *)(a2 + 8) - a1[11]);
      if (v13 > a1[3])
      {
        v8 = (float)(a1[13] - j) / (float)(a1[12] - *(float *)(a2 + 8));
        if (v13 >= a1[4])
        {
          v13 = a1[4];
          break;
        }
        if (v8 <= a1[3]
          || v13 >= v8
          && v8 <= a1[2]
          && (float)(j - (float)(v13 * (float)(*(float *)(a2 + 8) - *(float *)a2))) <= a1[15]
          && *(float *)a2 != a1[11])
        {
          break;
        }
      }
    }
    v14 = fminf(v13, a1[4]);
    *(float *)(a2 + 4) = a1[10] - (float)(v14 * a1[11]);
    *(float *)(a2 + 12) = a1[10] + (float)(v14 * (float)(*(float *)(a2 + 8) - a1[11]));
    v9 = fminf(fmaxf((float)(a1[13] - *(float *)(a2 + 12)) / (float)(a1[12] - *(float *)(a2 + 8)), a1[3]), a1[2]);
    *(float *)(a2 + 28) = *(float *)(a2 + 12) + (float)(v9 * (float)(*(float *)(a2 + 20) - *(float *)(a2 + 8)));
    result = *(float *)(a2 + 28) - (float)(v9 * *(float *)(a2 + 20));
    *(float *)(a2 + 24) = result;
  }
  return result;
}

uint64_t AAB::UpdateAge(uint64_t result, _DWORD *a2)
{
  if (a2[9] != (_DWORD)result)
  {
    if (a2[10] != (_DWORD)result)
      a2[11] = a2[10];
    a2[10] = a2[9];
  }
  a2[9] = result;
  return result;
}

uint64_t AAB::Reset(AAB *this)
{
  _BYTE v3[16];
  AAB *v4;

  v4 = this;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v3, (uint64_t)this + 72);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 8) + 16))(*((_QWORD *)this + 8));
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v3);
}

void sub_1B5377318(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object, char a13)
{
  std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t AAB::SetUpdateStrategy(AAB *this, AAB::UpdateCurveStrategy *a2)
{
  uint64_t v3;
  _BYTE v5[16];
  AAB::UpdateCurveStrategy *v6;
  AAB *v7;

  v7 = this;
  v6 = a2;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v5, (uint64_t)this + 72);
  if (v6)
  {
    if (*((_QWORD *)this + 8))
    {
      if (*((AAB::UpdateCurveStrategy **)this + 8) != v6)
      {
        v3 = *((_QWORD *)this + 8);
        if (v3)
          (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
      }
    }
    *((_QWORD *)this + 8) = v6;
  }
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v5);
}

float AAB::PreferenceUpdateCurveStrategy::UpdateCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, double a6, float a7, float a8)
{
  double v8;
  float CapForE;
  unint64_t v15;
  float v16;

  v15 = __PAIR64__(LODWORD(a7), LODWORD(a6));
  v16 = a8;
  AAB::PreferenceUpdateCurveStrategy::UpdateCurve(a6, a7, a8, a1, a2, a3);
  CapForE = AAB::findCapForE(a4, *(float *)&v15);
  if (v16 > CapForE)
    v16 = CapForE;
  LODWORD(v8) = v15;
  return AAB::PreferenceUpdateCurveStrategy::UpdateCurve(v8, *((float *)&v15 + 1), v16, a1, a2, a5);
}

float AAB::PreferenceUpdateCurveStrategy::UpdateCurve(double a1, float a2, float a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  float result;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  int v13;
  int v14;

  v12 = a6 + 32;
  *(float *)(a6 + 100) = -1.0;
  v11 = *(float *)(a6 + 20) + (float)((float)(*(float *)(a5 + 56) - *(float *)(a6 + 28)) / *(float *)(a6 + 84));
  if (a2 > 300.0)
  {
    v13 = 2;
    *(_BYTE *)(a6 + 80) = 0;
  }
  else if (a2 > *(float *)(a6 + 8))
  {
    v13 = 1;
    *(_BYTE *)(a6 + 80) = 0;
  }
  else
  {
    v13 = 0;
  }
  if (v13 != 1 && *(_DWORD *)(a6 + 64) != -1)
  {
    *(_DWORD *)(a6 + 32 + 4 * *(unsigned int *)(a6 + 64)) = *(_DWORD *)(a6 + 56);
    *(_DWORD *)(a6 + 44 + 4 * *(unsigned int *)(a6 + 64)) = *(_DWORD *)(a6 + 60);
  }
  *(_DWORD *)(a6 + 64) = -1;
  AAB::UpdateAge(v13, (_DWORD *)v12);
  *(float *)(v12 + 4 * v13) = a2;
  *(float *)(v12 + 12 + 4 * v13) = a3;
  if (*(_DWORD *)(v12 + 36) || *(_DWORD *)(v12 + 40) != 2)
  {
    if (*(_DWORD *)(v12 + 36) != 2 || *(_DWORD *)(v12 + 40))
    {
      v10 = *(float *)(v12 + 4) - *(float *)v12;
      v9 = *(float *)(v12 + 8) - *(float *)(v12 + 4);
      if (*(_DWORD *)(v12 + 36) == 1)
      {
        if (v10 > v9)
        {
          *(_DWORD *)(a5 + 44) = *(_DWORD *)v12;
          *(_DWORD *)(a5 + 40) = *(_DWORD *)(v12 + 12);
          *(_DWORD *)(a5 + 48) = *(_DWORD *)(v12 + 4);
          *(_DWORD *)(a5 + 52) = *(_DWORD *)(v12 + 16);
          v14 = 1;
          AAB::FitCurveToReferencePoints((float *)a5, a6, 1);
        }
        else
        {
          *(_DWORD *)(a5 + 44) = *(_DWORD *)(v12 + 4);
          *(_DWORD *)(a5 + 40) = *(_DWORD *)(v12 + 16);
          *(_DWORD *)(a5 + 48) = *(_DWORD *)(v12 + 8);
          *(_DWORD *)(a5 + 52) = *(_DWORD *)(v12 + 20);
          v14 = 0;
          AAB::FitCurveToReferencePoints((float *)a5, a6, 0);
        }
      }
      else
      {
        if (*(_DWORD *)(v12 + 36))
        {
          *(_DWORD *)(a5 + 48) = *(_DWORD *)(v12 + 8);
          *(_DWORD *)(a5 + 52) = *(_DWORD *)(v12 + 20);
          v14 = 1;
          if (v10 > v9)
          {
            *(_DWORD *)(a5 + 44) = *(_DWORD *)v12;
            *(_DWORD *)(a5 + 40) = *(_DWORD *)(v12 + 12);
          }
          else
          {
            *(_DWORD *)(a5 + 44) = *(_DWORD *)(v12 + 4);
            *(_DWORD *)(a5 + 40) = *(_DWORD *)(v12 + 16);
          }
        }
        else
        {
          *(_DWORD *)(a5 + 44) = *(_DWORD *)v12;
          *(_DWORD *)(a5 + 40) = *(_DWORD *)(v12 + 12);
          v14 = 0;
          if (v10 > v9)
          {
            *(_DWORD *)(a5 + 48) = *(_DWORD *)(v12 + 4);
            *(_DWORD *)(a5 + 52) = *(_DWORD *)(v12 + 16);
          }
          else
          {
            if ((*(_BYTE *)(v12 + 48) & 1) == 0)
            {
              *(_DWORD *)(v12 + 8) = *(_DWORD *)(a6 + 20);
              *(_DWORD *)(v12 + 20) = *(_DWORD *)(a6 + 28);
              *(_BYTE *)(v12 + 48) = 1;
            }
            *(_DWORD *)(a5 + 48) = *(_DWORD *)(v12 + 8);
            *(_DWORD *)(a5 + 52) = *(_DWORD *)(v12 + 20);
          }
        }
        AAB::FitCurveToReferencePoints((float *)a5, a6, v14);
      }
    }
    else
    {
      *(_DWORD *)(a5 + 44) = *(_DWORD *)v12;
      *(_DWORD *)(a5 + 40) = *(_DWORD *)(v12 + 12);
      *(_DWORD *)(a5 + 48) = *(_DWORD *)(v12 + 8);
      *(_DWORD *)(a5 + 52) = *(_DWORD *)(v12 + 20);
      v14 = 1;
      AAB::FitCurveToReferencePoints((float *)a5, a6, 1);
    }
  }
  else
  {
    *(_DWORD *)(a5 + 44) = *(_DWORD *)v12;
    *(_DWORD *)(a5 + 40) = *(_DWORD *)(v12 + 12);
    *(_DWORD *)(a5 + 48) = *(_DWORD *)(v12 + 8);
    *(_DWORD *)(a5 + 52) = *(_DWORD *)(v12 + 20);
    v14 = 0;
    AAB::FitCurveToReferencePoints((float *)a5, a6, 0);
  }
  if (*(_DWORD *)(v12 + 36) == 1)
  {
    if (v14)
    {
      v8 = (float)(*(float *)(a6 + 28) - *(float *)(a6 + 12)) / (float)(*(float *)(a6 + 20) - *(float *)(a6 + 8));
      *(_DWORD *)(v12 + 32) = 2;
      *(_DWORD *)(v12 + 24) = *(_DWORD *)(v12 + 8);
      *(float *)(v12 + 28) = *(float *)(a6 + 28) + (float)(v8 * (float)(*(float *)(v12 + 8) - *(float *)(a6 + 20)));
    }
    else
    {
      *(_DWORD *)(v12 + 24) = *(_DWORD *)(a6 + 8);
      *(_DWORD *)(v12 + 28) = *(_DWORD *)(a6 + 12);
      *(_DWORD *)(v12 + 32) = 0;
    }
  }
  v7 = *(float *)(a6 + 28) / *(float *)(a6 + 20);
  if ((float)(*(float *)(a6 + 20) + (float)((float)(*(float *)(a5 + 56) - *(float *)(a6 + 28)) / v7)) < v11)
    *(float *)(a6 + 84) = fmaxf((float)(*(float *)(a5 + 56) - *(float *)(a6 + 28)) / (float)(v11 - *(float *)(a6 + 20)), (float)(*(float *)(a6 + 28) - *(float *)(a6 + 12))/ (float)(*(float *)(a6 + 20) - *(float *)(a6 + 8)));
  else
    *(float *)(a6 + 84) = v7;
  *(float *)(a5 + 32) = a2;
  result = a3;
  *(float *)(a5 + 36) = a3;
  return result;
}

float AAB::findCapForE(float *a1, float a2)
{
  float v2;
  float v4;
  int i;
  float v6;

  v6 = a1[4];
  if (a2 <= *a1)
    return a1[4];
  if (a2 >= a1[3])
    return a1[7];
  for (i = 1; i < 4; ++i)
  {
    if (a2 < a1[i])
    {
      v4 = a1[i - 1];
      v2 = a1[i + 3];
      return v2 + (float)((float)((float)(a2 - v4) / (float)(a1[i] - v4)) * (float)(a1[i + 4] - v2));
    }
  }
  return v6;
}

void AAB::curveToCustomCurve(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a3 + 160) = 4;
  *(_DWORD *)a3 = *(_DWORD *)a2;
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a3 + 12) = 1184645120;
  *(_DWORD *)(a3 + 80) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a3 + 84) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a3 + 88) = *(_DWORD *)(a2 + 28);
  *(float *)(a3 + 92) = AAB::IlluminanceToLuminance(a1, (float *)a2, 20000.0);
}

BOOL lineIntersection(float *a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  float v10;
  float v11;
  float v12;
  float v13;
  BOOL v14;

  v14 = 0;
  if ((float)(a4 - a2) == 0.0)
  {
    return 0;
  }
  else
  {
    v13 = (float)(a5 - a3) / (float)(a4 - a2);
    v12 = (float)(a9 - a7) / (float)(a8 - a6);
    v11 = a3 - (float)(v13 * a2);
    if ((float)(v13 - v12) == 0.0)
    {
      return 0;
    }
    else
    {
      v10 = (float)((float)(a7 - (float)(v12 * a6)) - v11) / (float)(v13 - v12);
      *a1 = v10;
      a1[1] = v11 + (float)(v13 * v10);
      if (a2 <= v10 && a6 <= v10 && a4 >= v10)
        return a8 >= v10;
      return v14;
    }
  }
}

float getY(float a1, float a2, float a3, float a4, float a5)
{
  return (float)(a2 - (float)((float)((float)(a4 - a2) / (float)(a3 - a1)) * a1))
       + (float)((float)((float)(a4 - a2) / (float)(a3 - a1)) * a5);
}

void AAB::findDarkerCurve(AAB *this, CustomCurve *a2, CustomCurve *a3, CustomCurve *a4)
{
  BOOL v4;
  float v5;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18[3];
  int v19;
  int v20;
  int v21;
  CustomCurve *v22;
  CustomCurve *v23;
  AAB *v24;

  v24 = this;
  v23 = a2;
  v22 = a3;
  v21 = 0;
  v20 = 0;
  v19 = 0;
  if (COERCE_INT(*(float *)this * 10000.0) == COERCE_INT(a2->_E[0] * 10000.0))
  {
    v22->_E[0] = *(float *)this;
    if (*((float *)this + 20) >= a2->_L[0])
      v5 = a2->_L[0];
    else
      v5 = *((float *)this + 20);
    v22->_L[0] = v5;
  }
  else if (*(float *)this >= a2->_E[0])
  {
    v22->_E[0] = a2->_E[0];
    v22->_L[0] = a2->_L[0];
  }
  else
  {
    v22->_E[0] = *(float *)this;
    v22->_L[0] = *((float *)this + 20);
  }
  ++v19;
  while (1)
  {
    v4 = 0;
    if (v21 + 1 < *((_DWORD *)this + 40))
      v4 = v20 + 1 < a2->size;
    if (!v4)
      break;
    *(_QWORD *)v18 = 0;
    v16 = *((float *)this + v21);
    v17 = *((float *)this + v21 + 20);
    v14 = *((float *)this + v21 + 1);
    v15 = *((float *)this + v21 + 21);
    v12 = a2->_E[v20];
    v13 = a2->_L[v20];
    v10 = a2->_E[v20 + 1];
    v11 = a2->_L[v20 + 1];
    if (lineIntersection(v18, v16, v17, v14, v15, v12, v13, v10, v11))
    {
      v22->_E[v19] = v18[0];
      v22->_L[v19++] = v18[1];
    }
    if (*((float *)this + v21 + 1) > a2->_E[v20 + 1])
    {
      v8 = getY(v16, v17, v14, v15, a2->_E[v20 + 1]);
      if (v8 > a2->_L[v20 + 1])
      {
        v22->_E[v19] = a2->_E[v20 + 1];
        v22->_L[v19++] = a2->_L[v20 + 1];
      }
      ++v20;
    }
    else
    {
      v9 = getY(v12, v13, v10, v11, *((float *)this + v21 + 1));
      if (v9 > *((float *)this + v21 + 21))
      {
        v22->_E[v19] = *((float *)this + v21 + 1);
        v22->_L[v19++] = *((float *)this + v21 + 21);
      }
      ++v21;
    }
  }
  if (*((_DWORD *)this + 40) - 1 > v21 && *((float *)this + ++v21 + 20) < a2->_L[v20])
  {
    v22->_E[v19] = *((float *)this + v21);
    v22->_L[v19++] = *((float *)this + v21 + 20);
  }
  if (a2->size - 1 > v20 && a2->_L[++v20] < *((float *)this + v21 + 20))
  {
    v22->_E[v19] = a2->_E[v20];
    v22->_L[v19++] = a2->_L[v20];
  }
  v22->size = v19;
}

float AAB::customCurveToCurve@<S0>(const CustomCurve *a1@<X1>, float *a2@<X8>)
{
  float result;

  memset(a2, 0, 0x68uLL);
  if (a1->size == 4)
  {
    *a2 = a1->_E[0];
    a2[2] = a1->_E[1];
    a2[5] = a1->_E[2];
    a2[1] = a1->_L[0];
    a2[3] = a1->_L[1];
    a2[7] = a1->_L[2];
    a2[4] = 0.0;
    a2[6] = a2[3] - (float)((float)(a2[2] - a2[4]) * (float)((float)(a2[7] - a2[3]) / (float)(a2[5] - a2[2])));
    result = (float)(a1->_L[3] - a1->_L[2]) / (float)(a1->_E[3] - a1->_E[2]);
    a2[21] = result;
  }
  return result;
}

void AAB::TraditionalUpdateCurveStrategy::~TraditionalUpdateCurveStrategy(AAB::TraditionalUpdateCurveStrategy *this)
{
  AAB::TraditionalUpdateCurveStrategy::~TraditionalUpdateCurveStrategy(this);
}

{
  AAB::TraditionalUpdateCurveStrategy::~TraditionalUpdateCurveStrategy(this);
  MEMORY[0x1B5E4A400](this, 0x81C40B8603338);
}

{
  AAB::UpdateCurveStrategy::~UpdateCurveStrategy(this);
}

uint64_t AAB::TraditionalUpdateCurveStrategy::curveType(AAB::TraditionalUpdateCurveStrategy *this)
{
  return 1;
}

uint64_t AAB::PreferenceUpdateCurveStrategy::curveType(AAB::PreferenceUpdateCurveStrategy *this)
{
  return 2;
}

void sub_1B5379DFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

void sub_1B537A010(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t __os_log_helper_16_2_3_8_66_8_66_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 66;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 66;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 32;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_66_8_66_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 66;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 66;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

uint64_t __os_log_helper_16_2_4_8_0_8_32_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 32;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_32_8_0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_32_8_64_8_64(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 64;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 64;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

void load_libEDR()
{
  NSObject *oslog;
  uint8_t v1[24];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  oslog = MEMORY[0x1E0C81028];
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
  {
    __os_log_helper_16_2_1_8_32((uint64_t)v1, (uint64_t)"load_libEDR");
    _os_log_impl(&dword_1B5291000, oslog, OS_LOG_TYPE_INFO, "%s: ", v1, 0xCu);
  }
  if (load_libEDR_onceToken_libEDRLoad != -1)
    dispatch_once(&load_libEDR_onceToken_libEDRLoad, &__block_literal_global_9);
}

void __load_libEDR_block_invoke()
{
  char *v0;
  char *v1;
  char *v2;
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *oslog;
  void *v14;
  uint64_t (*v15)(_QWORD, float, float, float, float);
  uint64_t (*v16)(_QWORD);
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  NSObject *v21;
  uint8_t v22[32];
  uint8_t v23[32];
  uint8_t v24[32];
  uint8_t v25[32];
  uint8_t v26[32];
  uint8_t v27[32];
  uint8_t v28[32];
  uint8_t v29[24];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  libEDRHandle = (uint64_t)dlopen("/System/Library/PrivateFrameworks/libEDR.framework/libEDR", 1);
  if (libEDRHandle)
  {
    v14 = dlsym((void *)libEDRHandle, "EDRServerStartService");
    if (v14)
    {
      edrServiceStartFunction = v14;
    }
    else
    {
      oslog = MEMORY[0x1E0C81028];
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v0 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v28, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerStartService", (uint64_t)v0);
        _os_log_error_impl(&dword_1B5291000, oslog, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v28, 0x20u);
      }
    }
    v15 = (uint64_t (*)(_QWORD, float, float, float, float))dlsym((void *)libEDRHandle, "EDRServerSetDisplayBrightnessForDisplay");
    if (v15)
    {
      edrServerSetDisplayBrightnessFunction = v15;
    }
    else
    {
      v12 = MEMORY[0x1E0C81028];
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v1 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v27, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerSetDisplayBrightnessForDisplay", (uint64_t)v1);
        _os_log_error_impl(&dword_1B5291000, v12, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v27, 0x20u);
      }
    }
    v16 = (uint64_t (*)(_QWORD))dlsym((void *)libEDRHandle, "EDRServerAddMainDisplay");
    if (v16)
    {
      edrServerAddMainDisplayFunction = v16;
    }
    else
    {
      v11 = MEMORY[0x1E0C81028];
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v2 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v26, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerAddMainDisplay", (uint64_t)v2);
        _os_log_error_impl(&dword_1B5291000, v11, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v26, 0x20u);
      }
    }
    v17 = dlsym((void *)libEDRHandle, "EDRServerAddDisplay");
    if (v17)
    {
      edrServerAddDisplayFunction = v17;
    }
    else
    {
      v10 = MEMORY[0x1E0C81028];
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v3 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v25, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerAddDisplay", (uint64_t)v3);
        _os_log_error_impl(&dword_1B5291000, v10, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v25, 0x20u);
      }
    }
    v18 = dlsym((void *)libEDRHandle, "EDRServerRemoveDisplay");
    if (v18)
    {
      edrServerRemoveDisplayFunction = v18;
    }
    else
    {
      v9 = MEMORY[0x1E0C81028];
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v4 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v24, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerRemoveDisplay", (uint64_t)v4);
        _os_log_error_impl(&dword_1B5291000, v9, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v24, 0x20u);
      }
    }
    v19 = dlsym((void *)libEDRHandle, "EDRServerGetCurrentDisplayPropertiesForDisplay");
    if (v19)
    {
      edrServerGetCurrentDisplayPropertiesFunction = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v19;
    }
    else
    {
      v8 = MEMORY[0x1E0C81028];
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v5 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v23, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerGetCurrentDisplayPropertiesForDisplay", (uint64_t)v5);
        _os_log_error_impl(&dword_1B5291000, v8, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v23, 0x20u);
      }
    }
    v20 = dlsym((void *)libEDRHandle, "EDRServerRegisterCallbackBlockOnQueue");
    if (v20)
    {
      edrServerRegisterCallbackBlockOnQueueFunction = (uint64_t (*)(_QWORD, _QWORD))v20;
    }
    else
    {
      v7 = MEMORY[0x1E0C81028];
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        v6 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v22, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerRegisterCallbackBlockOnQueue", (uint64_t)v6);
        _os_log_error_impl(&dword_1B5291000, v7, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v22, 0x20u);
      }
    }
  }
  else
  {
    v21 = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v29, (uint64_t)"load_libEDR_block_invoke");
      _os_log_error_impl(&dword_1B5291000, v21, OS_LOG_TYPE_ERROR, "%s: libEDR.framework not found!\n", v29, 0xCu);
    }
  }
}

BOOL CBEDRServerStartServer()
{
  load_libEDR();
  if (CBEDRServerStartServer_onceToken_libEDRServiceStar != -1)
    dispatch_once(&CBEDRServerStartServer_onceToken_libEDRServiceStar, &__block_literal_global_10);
  return libEDRHandle != 0;
}

uint64_t __os_log_helper_16_2_6_8_32_4_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 6;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 49) = 8;
  *(_QWORD *)(result + 50) = a7;
  return result;
}

void CBEDRServerAddMainDisplay(unsigned int a1)
{
  NSObject *oslog;
  NSObject *v2;
  uint8_t v4[16];
  uint8_t v5[24];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (edrServerAddMainDisplayFunction)
  {
    v2 = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_2_8_32_4_0((uint64_t)v5, (uint64_t)"CBEDRServerAddMainDisplay", a1);
      _os_log_impl(&dword_1B5291000, v2, OS_LOG_TYPE_INFO, "%s: main display: %u", v5, 0x12u);
    }
    edrServerAddMainDisplayFunction(a1);
  }
  else
  {
    oslog = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v4, (uint64_t)"CBEDRServerAddMainDisplay");
      _os_log_error_impl(&dword_1B5291000, oslog, OS_LOG_TYPE_ERROR, "%s: missing edrServerSetMainDisplayFunction", v4, 0xCu);
    }
  }
}

void CBEDRServerAddDisplay(unsigned int a1)
{
  NSObject *oslog;
  NSObject *v2;
  uint8_t v4[16];
  uint8_t v5[24];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (edrServerAddDisplayFunction)
  {
    v2 = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_2_8_32_4_0((uint64_t)v5, (uint64_t)"CBEDRServerAddDisplay", a1);
      _os_log_impl(&dword_1B5291000, v2, OS_LOG_TYPE_INFO, "%s: adding display: %u", v5, 0x12u);
    }
    edrServerAddDisplayFunction(a1);
  }
  else
  {
    oslog = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v4, (uint64_t)"CBEDRServerAddDisplay");
      _os_log_error_impl(&dword_1B5291000, oslog, OS_LOG_TYPE_ERROR, "%s: missing edrServerAddDisplayFunction", v4, 0xCu);
    }
  }
}

void CBEDRServerRemoveDisplay(unsigned int a1)
{
  NSObject *oslog;
  NSObject *v2;
  uint8_t v4[16];
  uint8_t v5[24];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (edrServerRemoveDisplayFunction)
  {
    v2 = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_2_8_32_4_0((uint64_t)v5, (uint64_t)"CBEDRServerRemoveDisplay", a1);
      _os_log_impl(&dword_1B5291000, v2, OS_LOG_TYPE_INFO, "%s: removing display: %u", v5, 0x12u);
    }
    edrServerRemoveDisplayFunction(a1);
  }
  else
  {
    oslog = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v4, (uint64_t)"CBEDRServerRemoveDisplay");
      _os_log_error_impl(&dword_1B5291000, oslog, OS_LOG_TYPE_ERROR, "%s: missing edrServerRemoveDisplayFunction", v4, 0xCu);
    }
  }
}

void CBEDRServerGetCurrentDisplayPropertiesForDisplay(unsigned int a1, float *a2, float *a3, float *a4, float *a5, float *a6)
{
  NSObject *v6;
  NSObject *oslog;
  uint8_t v14[16];
  uint8_t v15[72];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (edrServerGetCurrentDisplayPropertiesFunction)
  {
    edrServerGetCurrentDisplayPropertiesFunction(a1, a2, a3, a4, a5, a6);
    oslog = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_2_7_8_32_4_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v15, (uint64_t)"CBEDRServerGetCurrentDisplayPropertiesForDisplay", a1, COERCE__INT64(*a2), COERCE__INT64(*a3), COERCE__INT64(*a4), COERCE__INT64(*a5), COERCE__INT64(*a6));
      _os_log_debug_impl(&dword_1B5291000, oslog, OS_LOG_TYPE_DEBUG, "%s: display: %u | backlight: %f | EDR factor: %f | max luminance: %f | ambient illuminance: %f | brightness scaler: %f", v15, 0x44u);
    }
  }
  else
  {
    v6 = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v14, (uint64_t)"CBEDRServerGetCurrentDisplayPropertiesForDisplay");
      _os_log_error_impl(&dword_1B5291000, v6, OS_LOG_TYPE_ERROR, "%s: missing edrServerGetCurrentDisplayPropertiesFunction", v14, 0xCu);
    }
  }
}

uint64_t __os_log_helper_16_2_7_8_32_4_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 7;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 49) = 8;
  *(_QWORD *)(result + 50) = a7;
  *(_BYTE *)(result + 58) = 0;
  *(_BYTE *)(result + 59) = 8;
  *(_QWORD *)(result + 60) = a8;
  return result;
}

void CBEDRServerRegisterCallbackBlockOnQueue(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  NSObject *oslog;
  uint8_t v6[16];
  uint8_t v7[40];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (edrServerRegisterCallbackBlockOnQueueFunction)
  {
    oslog = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v7, (uint64_t)"CBEDRServerRegisterCallbackBlockOnQueue", a2, a1);
      _os_log_impl(&dword_1B5291000, oslog, OS_LOG_TYPE_INFO, "%s: register callback (%p) on a queue (%p)", v7, 0x20u);
    }
    edrServerRegisterCallbackBlockOnQueueFunction(a1, a2);
  }
  else
  {
    v2 = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v6, (uint64_t)"CBEDRServerRegisterCallbackBlockOnQueue");
      _os_log_error_impl(&dword_1B5291000, v2, OS_LOG_TYPE_ERROR, "%s: missing edrServerRegisterCallbackBlockOnQueueFunction", v6, 0xCu);
    }
  }
}

unint64_t nextBufferIndex(uint64_t a1, uint64_t a2)
{
  return (a1 + a2) % 0x64uLL;
}

unint64_t previousBufferIndex(uint64_t a1)
{
  return (a1 + 99) % 0x64uLL;
}

BOOL aabParamsDiffer(const CBAABParams *a1, const CBAABParams *a2)
{
  BOOL v3;

  v3 = 1;
  if (a1->e0a == a2->e0a)
  {
    v3 = 1;
    if (a1->e0b == a2->e0b)
    {
      v3 = 1;
      if (a1->e1 == a2->e1)
      {
        v3 = 1;
        if (a1->e2 == a2->e2)
        {
          v3 = 1;
          if (a1->l0a == a2->l0a)
          {
            v3 = 1;
            if (a1->l0b == a2->l0b)
            {
              v3 = 1;
              if (a1->l1 == a2->l1)
              {
                v3 = 1;
                if (a1->l2 == a2->l2)
                  return a1->thirdSlope != a2->thirdSlope;
              }
            }
          }
        }
      }
    }
  }
  return v3;
}

uint64_t localizeTimestamp(uint64_t a1)
{
  uint64_t v1;

  v1 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E0C99E80], "localTimeZone"), "secondsFromGMT");
  return (uint64_t)((double)(a1 + v1) + *MEMORY[0x1E0C9ADF8]);
}

uint64_t std::array<CBSliderCommitInfo,100ul>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return a1 + 232 * a2;
}

void TrackedState::TrackedState(TrackedState *this)
{
  TrackedState::TrackedState(this);
}

{
  this->darkThemeApplied = 0;
  this->landscapeOrientation = 0;
  this->autobrightnessEnabled = 0;
  this->ecoModeEnabled = 0;
}

uint64_t CBU_IsHarmonySupported()
{
  NSObject *oslog;
  size_t v2;
  char v3;
  uint8_t v4[24];
  char __s1[1024];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  bzero(__s1, 0x400uLL);
  v2 = 1024;
  if (sysctlbyname("kern.bootargs", __s1, &v2, 0, 0) || !strstr(__s1, "FORCE_HARMONY_SUPPORT"))
  {
    v3 = 0;
  }
  else
  {
    oslog = MEMORY[0x1E0C81028];
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v4, (uint64_t)"CBU_IsHarmonySupported");
      _os_log_impl(&dword_1B5291000, oslog, OS_LOG_TYPE_INFO, "%s: boot-arg to enforce harmony support", v4, 0xCu);
    }
    v3 = 1;
  }
  return v3 & 1;
}

uint64_t CBU_IsNightShiftSupported()
{
  return MGGetBoolAnswer() & 1;
}

BOOL CBU_IsSoftWakeSupported()
{
  return CBU_IsWatch();
}

BOOL CBU_IsWatch()
{
  return MGGetSInt32Answer() == 6;
}

uint64_t CBU_IsSliderCommitTelemetrySupported()
{
  return 1;
}

uint64_t CBU_SyncDisplayStateControlSupported()
{
  if (CBU_SyncDisplayStateControlSupported_SDSC_onceToken != -1)
    dispatch_once(&CBU_SyncDisplayStateControlSupported_SDSC_onceToken, &__block_literal_global_10);
  return CBU_SyncDisplayStateControlSupported_SDSCEnabled & 1;
}

uint64_t CBU_ForceUpdateFrequencyAndFrameSkip()
{
  if (CBU_ForceUpdateFrequencyAndFrameSkip_once != -1)
    dispatch_once(&CBU_ForceUpdateFrequencyAndFrameSkip_once, &__block_literal_global_20);
  return CBU_ForceUpdateFrequencyAndFrameSkip_force & 1;
}

uint64_t CBU_ForceFrameAfterBrightnessUpdate()
{
  if (CBU_ForceFrameAfterBrightnessUpdate_once != -1)
    dispatch_once(&CBU_ForceFrameAfterBrightnessUpdate_once, &__block_literal_global_24);
  return CBU_ForceFrameAfterBrightnessUpdate_force & 1;
}

uint64_t CBU_IsSyncBrightnessTransactionsSupported()
{
  return MGGetBoolAnswer() & 1;
}

uint64_t CBU_RampLumaBoostFactorInAOD()
{
  if (CBU_RampLumaBoostFactorInAOD_once != -1)
    dispatch_once(&CBU_RampLumaBoostFactorInAOD_once, &__block_literal_global_66);
  return CBU_RampLumaBoostFactorInAOD_result & 1;
}

uint64_t CBU_ShouldWaitForALS()
{
  _QWORD v1[9];
  char v2;
  __int128 v3;
  int v4;
  __int128 v5;
  int v6;
  __int128 v7;
  int v8;
  __int128 v9;
  int v10;
  __int128 v11;
  int v12;
  __int128 v13;
  int v14;
  __int128 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = 0;
  v15 = xmmword_1B5461A90;
  v16 = 414393924;
  v13 = xmmword_1B5461AA4;
  v14 = 897736383;
  v11 = xmmword_1B5461AB8;
  v12 = -996295886;
  v9 = xmmword_1B5461ACC;
  v10 = -453987047;
  v7 = xmmword_1B5461AE0;
  v8 = -337121064;
  v5 = xmmword_1B5461AF4;
  v6 = 450980336;
  v3 = xmmword_1B5461B08;
  v4 = -1431778695;
  v1[8] = v1;
  v1[0] = &v13;
  v1[1] = &v11;
  v1[2] = &v9;
  v1[3] = &v7;
  v1[4] = &v5;
  v1[5] = &v3;
  v1[6] = 0;
  v1[7] = 0;
  return MGIsDeviceOneOfType() & 1;
}

BOOL CBU_IsPad()
{
  return MGGetSInt32Answer() == 3;
}

void CBU_GetNightShiftCCTRange(io_registry_entry_t a1, float *a2, float *a3, float *a4, float *a5)
{
  CFTypeID v5;
  CFTypeID v6;
  CFTypeID v7;
  CFTypeID TypeID;
  const __CFData *cf;
  const __CFData *cfa;
  const __CFData *cfb;
  const __CFData *cfc;

  if (a2 && a3 && a4 && a5)
  {
    cf = (const __CFData *)IORegistryEntrySearchCFProperty(a1, "IOService", CFSTR("blr-cct-min"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (cf)
    {
      TypeID = CFDataGetTypeID();
      if (TypeID == CFGetTypeID(cf) && (unint64_t)CFDataGetLength(cf) >= 4)
        *a2 = (float)*(unsigned int *)CFDataGetBytePtr(cf);
      CFRelease(cf);
    }
    cfa = (const __CFData *)IORegistryEntrySearchCFProperty(a1, "IOService", CFSTR("blr-cct-max"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (cfa)
    {
      v7 = CFDataGetTypeID();
      if (v7 == CFGetTypeID(cfa) && (unint64_t)CFDataGetLength(cfa) >= 4)
        *a4 = (float)*(unsigned int *)CFDataGetBytePtr(cfa);
      CFRelease(cfa);
    }
    cfb = (const __CFData *)IORegistryEntrySearchCFProperty(a1, "IOService", CFSTR("blr-cct-default"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (cfb)
    {
      v6 = CFDataGetTypeID();
      if (v6 == CFGetTypeID(cfb) && (unint64_t)CFDataGetLength(cfb) >= 4)
        *a3 = (float)*(unsigned int *)CFDataGetBytePtr(cfb);
      CFRelease(cfb);
    }
    cfc = (const __CFData *)IORegistryEntrySearchCFProperty(a1, "IOService", CFSTR("blr-cct-warning"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (cfc)
    {
      v5 = CFDataGetTypeID();
      if (v5 == CFGetTypeID(cfc) && (unint64_t)CFDataGetLength(cfc) >= 4)
        *a5 = (float)*(unsigned int *)CFDataGetBytePtr(cfc);
      CFRelease(cfc);
    }
  }
}

uint64_t CBU_ShouldNotHandleExistingInternalDisplayAttachment()
{
  if (CBU_ShouldNotHandleExistingInternalDisplayAttachment_once != -1)
    dispatch_once(&CBU_ShouldNotHandleExistingInternalDisplayAttachment_once, &__block_literal_global_88);
  return CBU_ShouldNotHandleExistingInternalDisplayAttachment_result & 1;
}

uint64_t CBU_DeviceHasGrimaldi()
{
  return MGGetBoolAnswer() & 1;
}

unint64_t readDataFromIOService(io_registry_entry_t a1, const __CFString *a2, UInt8 *a3, CFIndex *a4)
{
  CFIndex v5;
  CFTypeID v6;
  unint64_t Length;
  unint64_t v8;
  CFTypeRef cf;
  CFRange v13;

  cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if (!cf)
    return 0;
  v6 = CFGetTypeID(cf);
  if (v6 == CFDataGetTypeID())
  {
    Length = CFDataGetLength((CFDataRef)cf);
    if (Length >= *a4)
      v5 = *a4;
    else
      v5 = Length;
    *a4 = v5;
    v13.location = 0;
    v13.length = v5;
    CFDataGetBytes((CFDataRef)cf, v13, a3);
    v8 = Length;
  }
  else
  {
    v8 = 0;
  }
  CFRelease(cf);
  return v8;
}

BOOL readExactDataFromIOService(io_registry_entry_t a1, const __CFString *a2, UInt8 *a3, CFIndex a4)
{
  CFIndex v5[4];
  io_registry_entry_t v6;

  v6 = a1;
  v5[3] = (CFIndex)a2;
  v5[2] = (CFIndex)a3;
  v5[1] = a4;
  v5[0] = a4;
  return a4 == readDataFromIOService(a1, a2, a3, v5);
}

void sub_1B538E2B4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t aabUpdateStrategyTypeToString(unint64_t a1)
{
  if (a1 <= 3)
    __asm { BR              X8 }
  return 0;
}

{
  if (a1 <= 3)
    __asm { BR              X8 }
  return 0;
}

id getMLModelClass_1()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLModelClass_softClass_1;
  v13 = getMLModelClass_softClass_1;
  if (!getMLModelClass_softClass_1)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLModelClass_block_invoke_1;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLModelClass_block_invoke_1((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

id getMLArrayBatchProviderClass_1()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLArrayBatchProviderClass_softClass_1;
  v13 = getMLArrayBatchProviderClass_softClass_1;
  if (!getMLArrayBatchProviderClass_softClass_1)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLArrayBatchProviderClass_block_invoke_1;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLArrayBatchProviderClass_block_invoke_1((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

uint64_t __getMLFeatureValueClass_block_invoke_1(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_1();
  Class = objc_getClass("MLFeatureValue");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLFeatureValueClass_softClass_1 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CoreMLLibrary_1()
{
  uint64_t v1;

  v1 = CoreMLLibraryCore_1();
  if (!v1)
    abort_report_np();
  return v1;
}

uint64_t CoreMLLibraryCore_1()
{
  if (!CoreMLLibraryCore_frameworkLibrary_1)
    __CoreMLLibraryCore_block_invoke_1();
  return CoreMLLibraryCore_frameworkLibrary_1;
}

uint64_t __getMLModelClass_block_invoke_1(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_1();
  Class = objc_getClass("MLModel");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLModelClass_softClass_1 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLPredictionOptionsClass_block_invoke_1(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_1();
  Class = objc_getClass("MLPredictionOptions");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLPredictionOptionsClass_softClass_1 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLArrayBatchProviderClass_block_invoke_1(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_1();
  Class = objc_getClass("MLArrayBatchProvider");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLArrayBatchProviderClass_softClass_1 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t getMLModelConfigurationClass()
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  void (*v13)(uint64_t, uint64_t);
  void (*v14)(uint64_t);
  uint64_t v15;

  v9 = 0;
  v10 = &v9;
  v11 = 1375731712;
  v12 = 48;
  v13 = __Block_byref_object_copy__14;
  v14 = __Block_byref_object_dispose__14;
  v8 = getMLModelConfigurationClass_softClass;
  v15 = getMLModelConfigurationClass_softClass;
  if (!getMLModelConfigurationClass_softClass)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLModelConfigurationClass_block_invoke;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLModelConfigurationClass_block_invoke((uint64_t)&v2);
  }
  v1 = v10[5];
  _Block_object_dispose(&v9, 8);
  return v1;
}

uint64_t __os_log_helper_16_0_11_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 11;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 62) = 0;
  *(_BYTE *)(result + 63) = 8;
  *(_QWORD *)(result + 64) = a8;
  *(_BYTE *)(result + 72) = 0;
  *(_BYTE *)(result + 73) = 8;
  *(_QWORD *)(result + 74) = a9;
  *(_BYTE *)(result + 82) = 0;
  *(_BYTE *)(result + 83) = 8;
  *(_QWORD *)(result + 84) = a10;
  *(_BYTE *)(result + 92) = 0;
  *(_BYTE *)(result + 93) = 8;
  *(_QWORD *)(result + 94) = a11;
  *(_BYTE *)(result + 102) = 0;
  *(_BYTE *)(result + 103) = 8;
  *(_QWORD *)(result + 104) = a12;
  return result;
}

uint64_t __getMLModelConfigurationClass_block_invoke(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_2();
  Class = objc_getClass("MLModelConfiguration");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    result = abort_report_np();
  getMLModelConfigurationClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t CoreMLLibrary_2()
{
  uint64_t v1;

  v1 = CoreMLLibraryCore_2();
  if (!v1)
    abort_report_np();
  return v1;
}

uint64_t CoreMLLibraryCore_2()
{
  if (!CoreMLLibraryCore_frameworkLibrary_2)
    __CoreMLLibraryCore_block_invoke_2();
  return CoreMLLibraryCore_frameworkLibrary_2;
}

uint64_t __getMLMultiArrayClass_block_invoke(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_2();
  Class = objc_getClass("MLMultiArray");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    result = abort_report_np();
  getMLMultiArrayClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

BOOL isDisplayAvailable(CADisplay *a1)
{
  BOOL v2;

  v2 = 0;
  if (a1)
  {
    v2 = 0;
    if (objc_msgSend((id)-[CADisplay currentMode](a1, "currentMode"), "width"))
      return objc_msgSend((id)-[CADisplay currentMode](a1, "currentMode"), "height") != 0;
  }
  return v2;
}

uint64_t __os_log_helper_16_2_4_8_66_8_66_8_66_8_66(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 66;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 66;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 66;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 66;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  return result;
}

uint64_t __os_log_helper_16_2_2_4_0_8_66(uint64_t result, int a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 66;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  return result;
}

void sub_1B53977F0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_2_8_0_8_66(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 66;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  return result;
}

void sub_1B5398D20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object)
{
  uint64_t v14;

  _Block_object_dispose((const void *)(v14 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t __os_log_helper_16_2_3_8_66_4_0_8_0(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 66;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  return result;
}

void sub_1B539AAD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

uint64_t __os_log_helper_16_2_3_8_0_8_66_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 66;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

void handleShutdownNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v5;
  uint64_t block;
  int v7;
  int v8;
  void (*v9)(uint64_t);
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = a5;
  v12 = a2;
  v5 = *(NSObject **)(a2 + 24);
  block = MEMORY[0x1E0C809B0];
  v7 = -1073741824;
  v8 = 0;
  v9 = __handleShutdownNotification_block_invoke;
  v10 = &unk_1E68E9E60;
  v11 = a2;
  dispatch_async(v5, &block);
}

void handleAvailabilityNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v5;
  uint64_t block;
  int v7;
  int v8;
  void (*v9)(uint64_t);
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = a5;
  v12 = a2;
  if (a2)
  {
    v5 = *(NSObject **)(v12 + 24);
    block = MEMORY[0x1E0C809B0];
    v7 = -1073741824;
    v8 = 0;
    v9 = __handleAvailabilityNotification_block_invoke;
    v10 = &unk_1E68E9E60;
    v11 = v12;
    dispatch_async(v5, &block);
  }
}

void deviceManagementArrivalCallback(void *a1, io_iterator_t a2)
{
  NSObject *inited;
  NSObject *log;
  os_log_type_t type;
  NSObject *v5;
  io_object_t v6;
  uint8_t v7[7];
  char v8;
  NSObject *v9;
  io_iterator_t v10;
  id v11;
  uint8_t v12[24];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v11 = a1;
  v10 = a2;
  if (a1 && v10)
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    if (os_log_type_enabled(inited, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v12, (uint64_t)v11);
      _os_log_impl(&dword_1B5291000, inited, OS_LOG_TYPE_DEFAULT, "Device management arrived refcon=%p", v12, 0xCu);
    }
    while (1)
    {
      v6 = IOIteratorNext(v10);
      if (!v6)
        break;
      if (v11)
        objc_msgSend(v11, "handleDeviceManagementArrival:", v6);
    }
  }
  else
  {
    v9 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v5 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v5 = init_default_corebrightness_log();
    v9 = v5;
    v8 = 16;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      log = v9;
      type = v8;
      __os_log_helper_16_0_0(v7);
      _os_log_error_impl(&dword_1B5291000, log, type, "error: invalid input", v7, 2u);
    }
  }
}

uint64_t __os_log_helper_16_0_3_8_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  return result;
}

uint64_t __os_log_helper_16_2_4_8_0_8_0_8_0_8_66(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 66;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_32_8_66_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 66;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

void __handleShutdownNotification_block_invoke(uint64_t a1)
{
  NSObject *log;
  os_log_type_t type;
  NSObject *inited;
  uint8_t v5[7];
  os_log_type_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;

  v9 = a1;
  v8 = a1;
  if (*(_QWORD *)(a1 + 32))
  {
    objc_msgSend(*(id *)(a1 + 32), "stopRamp");
    objc_msgSend(*(id *)(a1 + 32), "setUserActive:", 0);
    objc_msgSend(*(id *)(a1 + 32), "updateBacklightDeviceWithReason:", 4);
    v7 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v7 = inited;
    v6 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_DEFAULT))
    {
      log = v7;
      type = v6;
      __os_log_helper_16_0_0(v5);
      _os_log_impl(&dword_1B5291000, log, type, "Got shutdown notification -> turned off keyboard backlight", v5, 2u);
    }
  }
}

void __handleAvailabilityNotification_block_invoke(uint64_t a1)
{
  id v2;
  id v3;

  if (*(_QWORD *)(a1 + 32))
  {
    if (GSEventIsHardwareKeyboardAttached())
    {
      v3 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithBool:", 1);
      objc_msgSend(*(id *)(a1 + 32), "KBAvailabilityUpdateHandler:", v3);

    }
    else
    {
      objc_msgSend(*(id *)(a1 + 32), "stopRamp");
      v2 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithBool:", 0);
      objc_msgSend(*(id *)(a1 + 32), "KBAvailabilityUpdateHandler:", v2);

    }
  }
}

uint64_t __os_log_helper_16_2_4_4_0_8_0_8_0_8_32(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 32;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  return result;
}

uint64_t __os_log_helper_16_2_17_4_0_8_0_8_0_8_32_8_0_8_0_8_32_8_0_8_32_8_0_8_32_8_0_8_32_8_0_8_0_8_32_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 17;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 32;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 49) = 8;
  *(_QWORD *)(result + 50) = a7;
  *(_BYTE *)(result + 58) = 32;
  *(_BYTE *)(result + 59) = 8;
  *(_QWORD *)(result + 60) = a8;
  *(_BYTE *)(result + 68) = 0;
  *(_BYTE *)(result + 69) = 8;
  *(_QWORD *)(result + 70) = a9;
  *(_BYTE *)(result + 78) = 32;
  *(_BYTE *)(result + 79) = 8;
  *(_QWORD *)(result + 80) = a10;
  *(_BYTE *)(result + 88) = 0;
  *(_BYTE *)(result + 89) = 8;
  *(_QWORD *)(result + 90) = a11;
  *(_BYTE *)(result + 98) = 32;
  *(_BYTE *)(result + 99) = 8;
  *(_QWORD *)(result + 100) = a12;
  *(_BYTE *)(result + 108) = 0;
  *(_BYTE *)(result + 109) = 8;
  *(_QWORD *)(result + 110) = a13;
  *(_BYTE *)(result + 118) = 32;
  *(_BYTE *)(result + 119) = 8;
  *(_QWORD *)(result + 120) = a14;
  *(_BYTE *)(result + 128) = 0;
  *(_BYTE *)(result + 129) = 8;
  *(_QWORD *)(result + 130) = a15;
  *(_BYTE *)(result + 138) = 0;
  *(_BYTE *)(result + 139) = 8;
  *(_QWORD *)(result + 140) = a16;
  *(_BYTE *)(result + 148) = 32;
  *(_BYTE *)(result + 149) = 8;
  *(_QWORD *)(result + 150) = a17;
  *(_BYTE *)(result + 158) = 0;
  *(_BYTE *)(result + 159) = 8;
  *(_QWORD *)(result + 160) = a18;
  return result;
}

uint64_t __os_log_helper_16_0_7_4_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 7;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 49) = 8;
  *(_QWORD *)(result + 50) = a7;
  *(_BYTE *)(result + 58) = 0;
  *(_BYTE *)(result + 59) = 8;
  *(_QWORD *)(result + 60) = a8;
  return result;
}

void sub_1B53B3304()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_0_10_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 10;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 62) = 0;
  *(_BYTE *)(result + 63) = 8;
  *(_QWORD *)(result + 64) = a8;
  *(_BYTE *)(result + 72) = 0;
  *(_BYTE *)(result + 73) = 8;
  *(_QWORD *)(result + 74) = a9;
  *(_BYTE *)(result + 82) = 0;
  *(_BYTE *)(result + 83) = 8;
  *(_QWORD *)(result + 84) = a10;
  *(_BYTE *)(result + 92) = 0;
  *(_BYTE *)(result + 93) = 8;
  *(_QWORD *)(result + 94) = a11;
  return result;
}

uint64_t __os_log_helper_16_2_8_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 8;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 62) = 0;
  *(_BYTE *)(result + 63) = 8;
  *(_QWORD *)(result + 64) = a8;
  *(_BYTE *)(result + 72) = 0;
  *(_BYTE *)(result + 73) = 8;
  *(_QWORD *)(result + 74) = a9;
  return result;
}

float std::__math::sqrt[abi:ne180100](float a1)
{
  return sqrtf(a1);
}

uint64_t __os_log_helper_16_0_8_4_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 8;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 49) = 8;
  *(_QWORD *)(result + 50) = a7;
  *(_BYTE *)(result + 58) = 0;
  *(_BYTE *)(result + 59) = 8;
  *(_QWORD *)(result + 60) = a8;
  *(_BYTE *)(result + 68) = 0;
  *(_BYTE *)(result + 69) = 8;
  *(_QWORD *)(result + 70) = a9;
  return result;
}

uint64_t __os_log_helper_16_2_16_4_0_8_0_8_32_8_0_8_0_8_32_8_0_8_32_8_0_8_32_8_0_8_32_8_0_8_0_8_32_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 16;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 32;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 48) = 32;
  *(_BYTE *)(result + 49) = 8;
  *(_QWORD *)(result + 50) = a7;
  *(_BYTE *)(result + 58) = 0;
  *(_BYTE *)(result + 59) = 8;
  *(_QWORD *)(result + 60) = a8;
  *(_BYTE *)(result + 68) = 32;
  *(_BYTE *)(result + 69) = 8;
  *(_QWORD *)(result + 70) = a9;
  *(_BYTE *)(result + 78) = 0;
  *(_BYTE *)(result + 79) = 8;
  *(_QWORD *)(result + 80) = a10;
  *(_BYTE *)(result + 88) = 32;
  *(_BYTE *)(result + 89) = 8;
  *(_QWORD *)(result + 90) = a11;
  *(_BYTE *)(result + 98) = 0;
  *(_BYTE *)(result + 99) = 8;
  *(_QWORD *)(result + 100) = a12;
  *(_BYTE *)(result + 108) = 32;
  *(_BYTE *)(result + 109) = 8;
  *(_QWORD *)(result + 110) = a13;
  *(_BYTE *)(result + 118) = 0;
  *(_BYTE *)(result + 119) = 8;
  *(_QWORD *)(result + 120) = a14;
  *(_BYTE *)(result + 128) = 0;
  *(_BYTE *)(result + 129) = 8;
  *(_QWORD *)(result + 130) = a15;
  *(_BYTE *)(result + 138) = 32;
  *(_BYTE *)(result + 139) = 8;
  *(_QWORD *)(result + 140) = a16;
  *(_BYTE *)(result + 148) = 0;
  *(_BYTE *)(result + 149) = 8;
  *(_QWORD *)(result + 150) = a17;
  return result;
}

uint64_t __os_log_helper_16_0_9_4_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 9;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 49) = 8;
  *(_QWORD *)(result + 50) = a7;
  *(_BYTE *)(result + 58) = 0;
  *(_BYTE *)(result + 59) = 8;
  *(_QWORD *)(result + 60) = a8;
  *(_BYTE *)(result + 68) = 0;
  *(_BYTE *)(result + 69) = 8;
  *(_QWORD *)(result + 70) = a9;
  *(_BYTE *)(result + 78) = 0;
  *(_BYTE *)(result + 79) = 8;
  *(_QWORD *)(result + 80) = a10;
  return result;
}

float std::__math::exp[abi:ne180100](float a1)
{
  return expf(a1);
}

float std::__math::cos[abi:ne180100](float a1)
{
  return cosf(a1);
}

float std::__math::sin[abi:ne180100](float a1)
{
  return sinf(a1);
}

uint64_t __os_log_helper_16_2_6_8_64_8_64_8_0_4_0_4_0_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 6;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 64;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 4;
  *(_DWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 4;
  *(_DWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 44) = 32;
  *(_BYTE *)(result + 45) = 8;
  *(_QWORD *)(result + 46) = a7;
  return result;
}

uint64_t __os_log_helper_16_0_4_8_0_8_0_4_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  return result;
}

id getMLModelClass_2()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLModelClass_softClass_2;
  v13 = getMLModelClass_softClass_2;
  if (!getMLModelClass_softClass_2)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLModelClass_block_invoke_2;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLModelClass_block_invoke_2((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

id getMLArrayBatchProviderClass_2()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLArrayBatchProviderClass_softClass_2;
  v13 = getMLArrayBatchProviderClass_softClass_2;
  if (!getMLArrayBatchProviderClass_softClass_2)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLArrayBatchProviderClass_block_invoke_2;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLArrayBatchProviderClass_block_invoke_2((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

uint64_t __getMLFeatureValueClass_block_invoke_2(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_3();
  Class = objc_getClass("MLFeatureValue");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLFeatureValueClass_softClass_2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CoreMLLibrary_3()
{
  uint64_t v1;

  v1 = CoreMLLibraryCore_3();
  if (!v1)
    abort_report_np();
  return v1;
}

uint64_t CoreMLLibraryCore_3()
{
  if (!CoreMLLibraryCore_frameworkLibrary_3)
    __CoreMLLibraryCore_block_invoke_3();
  return CoreMLLibraryCore_frameworkLibrary_3;
}

uint64_t __getMLModelClass_block_invoke_2(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_3();
  Class = objc_getClass("MLModel");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLModelClass_softClass_2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLPredictionOptionsClass_block_invoke_2(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_3();
  Class = objc_getClass("MLPredictionOptions");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLPredictionOptionsClass_softClass_2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLArrayBatchProviderClass_block_invoke_2(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_3();
  Class = objc_getClass("MLArrayBatchProvider");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLArrayBatchProviderClass_softClass_2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void displayArrivalCallback(void *a1, io_iterator_t a2)
{
  NSObject *inited;
  NSObject *log;
  os_log_type_t type;
  NSObject *v5;
  io_object_t v6;
  uint8_t v7[7];
  char v8;
  NSObject *v9;
  io_iterator_t v10;
  id v11;
  uint8_t v12[24];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v11 = a1;
  v10 = a2;
  if (a1 && v10)
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    if (os_log_type_enabled(inited, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v12, (uint64_t)v11);
      _os_log_impl(&dword_1B5291000, inited, OS_LOG_TYPE_DEFAULT, "display arrived refcon=%p", v12, 0xCu);
    }
    while (1)
    {
      v6 = IOIteratorNext(v10);
      if (!v6)
        break;
      objc_msgSend(v11, "handleDisplayArrival:", v6);
    }
  }
  else
  {
    v9 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v5 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v5 = init_default_corebrightness_log();
    v9 = v5;
    v8 = 16;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      log = v9;
      type = v8;
      __os_log_helper_16_0_0(v7);
      _os_log_error_impl(&dword_1B5291000, log, type, "error: invalid input", v7, 2u);
    }
  }
}

uint64_t __os_log_helper_16_2_3_4_0_8_0_8_66(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 66;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  return result;
}

void sub_1B53D27E8(uint64_t a1, int a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 120) = a1;
  *(_DWORD *)(v2 - 124) = a2;
  _Block_object_dispose((const void *)(v2 - 64), 8);
  _Unwind_Resume(*(_Unwind_Exception **)(v2 - 120));
}

void sub_1B53D3194()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_2_8_66_8_32(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 66;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 32;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  return result;
}

uint64_t __os_log_helper_16_0_4_8_0_8_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 4;
  *(_DWORD *)(result + 34) = a5;
  return result;
}

float _DisplayPerceptualLuminanceToLuminanceInternal(uint64_t a1, float a2)
{
  float v3;

  v3 = *(float *)(a1 + 1312);
  return v3 * powf(v3 / *(float *)(a1 + 1320), a2 - 1.0);
}

float DisplayPerceptualLuminanceToLuminance(uint64_t a1, float a2)
{
  NSObject *v2;
  float v4;
  void (*v5)(void);
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t);
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  float v12;
  uint64_t v13;
  float *v14;
  int v15;
  int v16;
  int v17;
  float v18;
  uint64_t v19;

  v19 = a1;
  v18 = a2;
  v13 = 0;
  v14 = (float *)&v13;
  v15 = 0x20000000;
  v16 = 32;
  v17 = 0;
  v2 = *(NSObject **)(a1 + 144);
  v5 = (void (*)(void))MEMORY[0x1E0C809B0];
  v6 = -1073741824;
  v7 = 0;
  v8 = __DisplayPerceptualLuminanceToLuminance_block_invoke;
  v9 = &unk_1E68EB3F0;
  v10 = &v13;
  v11 = v19;
  v12 = a2;
  disp_dispatch_sync(v2, &v5);
  v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1B53DCA38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

float DisplayReflectedLuminanceToPerceptualLuminance(uint64_t a1, float a2)
{
  NSObject *v2;
  float v4;
  void (*v5)(void);
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t);
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  float v12;
  uint64_t v13;
  float *v14;
  int v15;
  int v16;
  int v17;
  float v18;
  uint64_t v19;

  v19 = a1;
  v18 = a2;
  v13 = 0;
  v14 = (float *)&v13;
  v15 = 0x20000000;
  v16 = 32;
  v17 = 0;
  v2 = *(NSObject **)(a1 + 144);
  v5 = (void (*)(void))MEMORY[0x1E0C809B0];
  v6 = -1073741824;
  v7 = 0;
  v8 = __DisplayReflectedLuminanceToPerceptualLuminance_block_invoke;
  v9 = &unk_1E68EB3F0;
  v10 = &v13;
  v11 = v19;
  v12 = a2;
  disp_dispatch_sync(v2, &v5);
  v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1B53DCB68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

float _DisplayReflectedLuminanceToPerceptualLuminanceInternal(uint64_t a1, float a2)
{
  float v2;
  float v4;
  float v5;

  v5 = fminf(fmaxf(a2, 0.01), *(float *)(a1 + 1312));
  v2 = *(float *)(a1 + 1312) / 0.01;
  v4 = logf(v2);
  return (float)(logf(v5 / *(float *)(a1 + 1312)) / v4) + 1.0;
}

float _DisplayPerceptualLuminanceToReflectedLuminanceInternal(uint64_t a1, float a2)
{
  float v2;
  float v4;

  v4 = *(float *)(a1 + 1312);
  v2 = v4 / 0.01;
  return v4 * powf(v2, a2 - 1.0);
}

float DisplayPerceptualLuminanceToReflectedLuminance(uint64_t a1, float a2)
{
  NSObject *v2;
  float v4;
  void (*v5)(void);
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t);
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  float v12;
  uint64_t v13;
  float *v14;
  int v15;
  int v16;
  int v17;
  float v18;
  uint64_t v19;

  v19 = a1;
  v18 = a2;
  v13 = 0;
  v14 = (float *)&v13;
  v15 = 0x20000000;
  v16 = 32;
  v17 = 0;
  v2 = *(NSObject **)(a1 + 144);
  v5 = (void (*)(void))MEMORY[0x1E0C809B0];
  v6 = -1073741824;
  v7 = 0;
  v8 = __DisplayPerceptualLuminanceToReflectedLuminance_block_invoke;
  v9 = &unk_1E68EB3F0;
  v10 = &v13;
  v11 = v19;
  v12 = a2;
  disp_dispatch_sync(v2, &v5);
  v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1B53DCDC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t DisplayGetTypeID()
{
  if (!__kHIDDisplayTypeID)
    pthread_once(&__displayTypeInit, (void (*)(void))__DisplayRegister);
  return __kHIDDisplayTypeID;
}

uint64_t __DisplayRegister()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  __kHIDDisplayTypeID = result;
  return result;
}

uint64_t DisplaySetHarmonyEnabled(uint64_t result, char a2)
{
  *(_BYTE *)(result + 12515) = a2 & 1;
  return result;
}

uint64_t DisplaySetBLREnabled(uint64_t result, char a2)
{
  *(_BYTE *)(result + 12512) = a2 & 1;
  return result;
}

CFTypeRef DisplayCreate(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return DisplayCreateWithID(a1, a2, a3, 0);
}

CFTypeRef DisplayCreateWithID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const __CFAllocator *v4;
  io_object_t v5;
  NSObject *v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  CFTypeRef v10;
  float v11;
  float v12;
  float v13;
  int *v14;
  void *v15;
  int v16;
  int v17;
  CFMutableDictionaryRef Mutable;
  uint64_t v19;
  float GlobalScalarFromDevice;
  CBBacklightNode *v21;
  BOOL v22;
  int v23;
  double v24;
  float v25;
  float v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  double v32;
  float v33;
  BOOL v34;
  const char *v35;
  float float_from_edt;
  float v37;
  dispatch_queue_t v38;
  dispatch_queue_t v39;
  dispatch_queue_t v40;
  dispatch_queue_t v41;
  double v42;
  double v43;
  double v44;
  double v45;
  const __CFAllocator *v46;
  BOOL v47;
  uint64_t Uint32FromCFDataAndRelease;
  CBDisplayRamps *v49;
  void *v51;
  CFAllocatorRef *v52;
  void *v53;
  CBSoftWakeDisplayDelegate *v54;
  CFTypeID v55;
  CFTypeID v56;
  CFAllocatorRef *v57;
  CFTypeID v58;
  CFTypeID v59;
  CFStringRef *v60;
  CFStringRef *v61;
  NSObject *v62;
  os_log_type_t v63;
  uint64_t v64;
  NSObject *v65;
  NSObject *v66;
  os_log_type_t v67;
  uint64_t v68;
  NSObject *v69;
  CFTypeID v70;
  CFStringRef *v71;
  CFStringRef *v72;
  NSObject *v73;
  os_log_type_t v74;
  uint64_t v75;
  NSObject *v76;
  NSObject *v77;
  os_log_type_t v78;
  uint64_t v79;
  NSObject *v80;
  uint64_t v81;
  NSObject *v82;
  NSObject *v83;
  os_log_type_t v84;
  uint64_t v85;
  NSObject *v86;
  NSObject *v87;
  os_log_type_t v88;
  uint64_t v89;
  NSObject *v90;
  uint64_t v91;
  NSObject *v92;
  BOOL v93;
  BOOL v94;
  CFAllocatorRef *v95;
  __CFDictionary *v96;
  uint64_t v97;
  NSObject *v98;
  uint64_t v99;
  NSObject *v100;
  __CFDictionary *v101;
  __CFDictionary *v102;
  CFTypeID v103;
  CFTypeID v104;
  CFTypeID v105;
  CFTypeID v106;
  CFTypeID v107;
  void *context;
  NSObject *v109;
  os_log_type_t v110;
  uint64_t v111;
  NSObject *v112;
  CFTypeID v113;
  CFTypeID v114;
  CFTypeID v115;
  CFTypeID TypeID;
  uint64_t v117;
  NSObject *v118;
  uint64_t v119;
  NSObject *v120;
  uint64_t v121;
  NSObject *v122;
  uint64_t v123;
  NSObject *v124;
  uint64_t v125;
  NSObject *v126;
  CFTypeID v127;
  CFAllocatorRef *v128;
  uint64_t v129;
  NSObject *v130;
  uint64_t v131;
  NSObject *v132;
  uint64_t v133;
  NSObject *v134;
  uint64_t v135;
  NSObject *v136;
  uint64_t v137;
  NSObject *v138;
  uint64_t v139;
  NSObject *v140;
  uint64_t v141;
  NSObject *v142;
  uint64_t v143;
  NSObject *v144;
  uint64_t v145;
  NSObject *v146;
  uint64_t v147;
  NSObject *v148;
  CFTypeID v149;
  NSObject *log;
  os_log_type_t v151;
  uint64_t inited;
  NSObject *v153;
  CFTypeRef v154;
  int v155;
  CFTypeRef v156;
  int v157;
  CFTypeRef v158;
  float v159;
  CFTypeRef v160;
  id v161;
  int v162;
  CFTypeRef v163;
  int v164;
  CFTypeRef v165;
  int v166;
  CFTypeRef v167;
  CFTypeRef v168;
  float v169;
  CFTypeRef v170;
  CFTypeRef v171;
  _DWORD idx[3];
  CFArrayRef theArray;
  CFTypeRef v174;
  CFTypeRef v175;
  float v176;
  float v177;
  float v178;
  float v179;
  char v180;
  int v181;
  CFTypeRef v182;
  CFTypeRef v183;
  uint8_t v184[7];
  os_log_type_t v185;
  os_log_t v186;
  uint8_t v187[15];
  os_log_type_t v188;
  os_log_t v189;
  CFTypeRef v190;
  CFTypeRef v191;
  int v192;
  int v193;
  uint8_t v194[7];
  os_log_type_t v195;
  os_log_t v196;
  uint8_t v197[15];
  os_log_type_t v198;
  os_log_t v199;
  unsigned int v200;
  CFTypeRef v201;
  os_log_type_t v202;
  os_log_t v203;
  CFTypeRef v204;
  uint8_t v205[7];
  os_log_type_t v206;
  os_log_t v207;
  uint8_t v208[15];
  os_log_type_t v209;
  os_log_t v210;
  os_log_type_t v211;
  os_log_t v212;
  char v213;
  CFTypeRef v214;
  int v215;
  char v216;
  CFTypeRef v217;
  int v218;
  char v219;
  char v220;
  CFTypeRef v221;
  uint64_t v222;
  os_log_type_t v223;
  os_log_t v224;
  os_log_type_t v225;
  os_log_t v226;
  CFNumberRef v227;
  CFDictionaryRef v228;
  CFDictionaryRef v229;
  int v230;
  CFTypeRef v231;
  int v232;
  CFTypeRef v233;
  int v234;
  CFTypeRef v235;
  int v236;
  CFTypeRef v237;
  int v238;
  CFTypeRef v239;
  unsigned int v240;
  CFTypeRef AABCapDictionary;
  CFTypeRef AABConstraintDictionary;
  CFTypeRef v243;
  int v244;
  int v245;
  CFTypeRef v246;
  int v247;
  CFTypeRef v248;
  CFTypeRef v249;
  CFDictionaryRef RestrictionDictionary;
  id v251;
  char v252;
  CFTypeRef v253;
  int v255;
  CFTypeRef v256;
  int v257;
  CFTypeRef v258;
  int v259;
  void *value;
  uint8_t v261[7];
  os_log_type_t v262;
  os_log_t v263;
  CFTypeRef v264;
  os_log_type_t v265;
  os_log_t v266;
  os_log_type_t v267;
  os_log_t v268;
  int v269;
  os_log_type_t v270;
  os_log_t v271;
  float v272;
  size_t k;
  os_log_type_t v274;
  os_log_t v275;
  float v276;
  unint64_t j;
  float v278;
  os_log_type_t v279;
  os_log_t v280;
  float v281;
  float v282;
  int v283;
  unsigned int i;
  const UInt8 *BytePtr;
  float *v286;
  size_t count;
  unsigned int v288;
  unsigned int v289;
  unsigned int v290;
  CFTypeRef v291;
  os_log_type_t v292;
  os_log_t v293;
  os_log_type_t v294;
  os_log_t v295;
  os_log_type_t v296;
  os_log_t v297;
  os_log_type_t v298;
  os_log_t v299;
  os_log_type_t v300;
  os_log_t v301;
  os_log_type_t v302;
  os_log_t v303;
  os_log_type_t v304;
  os_log_t v305;
  os_log_type_t v306;
  os_log_t v307;
  os_log_type_t v308;
  os_log_t v309;
  os_log_type_t v310;
  os_log_t v311;
  float valuePtr;
  uint8_t v313[15];
  os_log_type_t type;
  os_log_t oslog;
  CFNumberRef number;
  CFDictionaryRef v317;
  CFDictionaryRef theDict;
  mach_timebase_info info;
  CFTypeRef v320;
  CFTypeRef CFProperty;
  CFTypeRef cf;
  CFTypeRef Private;
  int v324;
  dispatch_queue_t target;
  io_object_t object;
  CFAllocatorRef allocator;
  CFTypeRef v329;
  CFTypeRef v330;
  __int128 v331;
  _QWORD v332[4];
  _QWORD v333[4];
  CFTypeRef v334;
  void *keys;
  void *values;
  CFTypeRef v337;
  CFTypeRef v338;
  unint64_t v339;
  float v340;
  char __b[256];
  __int128 v342;
  int v343;
  __int128 v344;
  int v345;
  __int128 v346;
  int v347;
  __int128 v348;
  int v349;
  uint8_t v350[16];
  uint8_t v351[16];
  uint8_t v352[32];
  uint8_t v353[16];
  _QWORD v354[6];
  _QWORD v355[6];
  uint8_t v356[32];
  uint8_t v357[32];
  uint64_t v358;
  int v359;
  uint8_t v360[32];
  uint8_t v361[32];
  uint8_t v362[64];
  __int128 v363;
  int v364;
  __int128 v365;
  int v366;
  uint8_t v367[16];
  uint8_t v368[16];
  uint8_t v369[16];
  uint8_t v370[16];
  uint8_t v371[16];
  uint8_t v372[16];
  uint8_t v373[16];
  uint8_t v374[16];
  uint8_t v375[16];
  uint8_t v376[24];
  uint64_t v377;

  v4 = (const __CFAllocator *)MEMORY[0x1E0C80A78](a1, a2, a3, a4);
  v377 = *MEMORY[0x1E0C80C00];
  allocator = v4;
  object = v5;
  target = v6;
  v324 = v7;
  _logHandle = (uint64_t)os_log_create("com.apple.CoreBrightness.Display", "default");
  cf = 0;
  CFProperty = 0;
  v320 = 0;
  Private = (CFTypeRef)__DisplayCreatePrivate();
  if (!Private)
    return 0;
  *((_DWORD *)Private + 69) = 0;
  *((float *)Private + 70) = -1.0;
  *((_DWORD *)Private + 55) = 0;
  *((_DWORD *)Private + 56) = 0;
  *((_DWORD *)Private + 57) = 0;
  *((_QWORD *)Private + 2) = 0;
  *((_DWORD *)Private + 10) = 0;
  *((_DWORD *)Private + 3148) = v324;
  *((_DWORD *)Private + 3149) = 0;
  *((_DWORD *)Private + 3150) = 0;
  *((_BYTE *)Private + 321) = 0;
  *((_BYTE *)Private + 322) = 0;
  *((_BYTE *)Private + 323) = 0;
  *((_QWORD *)Private + 26) = 0;
  *((_DWORD *)Private + 54) = 1199570944;
  *((_BYTE *)Private + 12712) = 0;
  info = 0;
  mach_timebase_info(&info);
  LODWORD(v9) = info.denom;
  LODWORD(v8) = info.numer;
  *((double *)Private + 7) = (double)v8 / (double)v9 * 0.000000001;
  if (!object)
    goto LABEL_495;
  if (IOObjectRetain(object))
    goto LABEL_495;
  *((_DWORD *)Private + 20) = object;
  *((_QWORD *)Private + 15) = 0;
  *((_QWORD *)Private + 16) = 0;
  v10 = CFRetain(CFSTR("CBUser-0"));
  *((_QWORD *)Private + 1590) = v10;
  v317 = 0;
  number = 0;
  theDict = (CFDictionaryRef)IORegistryEntryCreateCFProperty(object, CFSTR("IODisplayParameters"), allocator, 0);
  if (!theDict)
    goto LABEL_495;
  v317 = (CFDictionaryRef)CFDictionaryGetValue(theDict, CFSTR("brightness"));
  if (v317)
  {
    number = (CFNumberRef)CFDictionaryGetValue(v317, CFSTR("value"));
    if (number)
    {
      CFNumberGetValue(number, kCFNumberSInt32Type, (char *)Private + 1244);
      number = (CFNumberRef)CFDictionaryGetValue(v317, CFSTR("min"));
      if (number)
      {
        CFNumberGetValue(number, kCFNumberSInt32Type, (char *)Private + 1236);
        number = (CFNumberRef)CFDictionaryGetValue(v317, CFSTR("max"));
        if (number)
          CFNumberGetValue(number, kCFNumberSInt32Type, (char *)Private + 1240);
      }
    }
  }
  CFRelease(theDict);
  cf = IORegistryEntryCreateCFProperty(object, CFSTR("new-backlight-architecture"), allocator, 0);
  if (cf && cf == (CFTypeRef)*MEMORY[0x1E0C9AE50])
  {
    *((_DWORD *)Private + 8) = 1;
    oslog = 0;
    if (_logHandle)
    {
      v153 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v153 = inited;
    }
    oslog = v153;
    type = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
    {
      log = oslog;
      v151 = type;
      __os_log_helper_16_0_0(v313);
      _os_log_impl(&dword_1B5291000, log, v151, "New backlight architecture.", v313, 2u);
    }
  }
  else
  {
    pthread_once(&__displayThreadInit, (void (*)(void))__DisplayBrightnessThreadInit);
    *((_DWORD *)Private + 9) = 1;
  }
  if (cf)
    CFRelease(cf);
  CFProperty = IORegistryEntryCreateCFProperty(object, CFSTR("backlight-calibration-parameters"), allocator, 0);
  if (CFProperty)
  {
    v149 = CFGetTypeID(CFProperty);
    if (v149 == CFDictionaryGetTypeID())
    {
      number = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, CFSTR("current-for-max-backlight"));
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1288);
      *((float *)Private + 322) = *((float *)Private + 322) / 65536.0;
      number = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, CFSTR("current-for-mid-backlight"));
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1292);
      *((float *)Private + 323) = *((float *)Private + 323) / 65536.0;
      number = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, CFSTR("hardware-max-current-limit"));
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1296);
      *((float *)Private + 324) = *((float *)Private + 324) / 65536.0;
      number = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, CFSTR("lMaxProduct"));
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1300);
      *((float *)Private + 325) = *((float *)Private + 325) / 65536.0;
      number = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, CFSTR("lMidProduct"));
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1304);
      *((float *)Private + 326) = *((float *)Private + 326) / 65536.0;
      number = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, CFSTR("lMinProduct"));
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1308);
      *((float *)Private + 327) = *((float *)Private + 327) / 65536.0;
      number = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, CFSTR("lMaxPanel"));
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1312);
      *((float *)Private + 328) = *((float *)Private + 328) / 65536.0;
      number = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, CFSTR("lMidPanel"));
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1316);
      *((float *)Private + 329) = *((float *)Private + 329) / 65536.0;
      number = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, CFSTR("lMinPanel"));
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1320);
      *((float *)Private + 330) = *((float *)Private + 330) / 65536.0;
      *((_DWORD *)Private + 331) = *((_DWORD *)Private + 328);
      number = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, CFSTR("milliAmps2NitsScaleFactor"));
      if (number)
      {
        valuePtr = 0.0;
        valuePtr = *((float *)Private + 328);
        CFNumberGetValue(number, kCFNumberFloatType, &valuePtr);
        if (valuePtr > 0.0)
          *((float *)Private + 331) = valuePtr / 65536.0;
      }
      v311 = 0;
      if (_logHandle)
      {
        v148 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v147 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v147 = init_default_corebrightness_log();
        v148 = v147;
      }
      v311 = v148;
      v310 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v376, COERCE__INT64(*((float *)Private + 322)));
        _os_log_impl(&dword_1B5291000, v311, v310, "I_max=%f", v376, 0xCu);
      }
      v309 = 0;
      if (_logHandle)
      {
        v146 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v145 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v145 = init_default_corebrightness_log();
        v146 = v145;
      }
      v309 = v146;
      v308 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v375, COERCE__INT64(*((float *)Private + 323)));
        _os_log_impl(&dword_1B5291000, v309, v308, "I_mid=%f", v375, 0xCu);
      }
      v307 = 0;
      if (_logHandle)
      {
        v144 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v143 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v143 = init_default_corebrightness_log();
        v144 = v143;
      }
      v307 = v144;
      v306 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v374, COERCE__INT64(*((float *)Private + 324)));
        _os_log_impl(&dword_1B5291000, v307, v306, "Ihw_max=%f", v374, 0xCu);
      }
      v305 = 0;
      if (_logHandle)
      {
        v142 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v141 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v141 = init_default_corebrightness_log();
        v142 = v141;
      }
      v305 = v142;
      v304 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v373, COERCE__INT64(*((float *)Private + 325)));
        _os_log_impl(&dword_1B5291000, v305, v304, "Lmax_product=%f", v373, 0xCu);
      }
      v303 = 0;
      if (_logHandle)
      {
        v140 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v139 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v139 = init_default_corebrightness_log();
        v140 = v139;
      }
      v303 = v140;
      v302 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v372, COERCE__INT64(*((float *)Private + 326)));
        _os_log_impl(&dword_1B5291000, v303, v302, "Lmid_product=%f", v372, 0xCu);
      }
      v301 = 0;
      if (_logHandle)
      {
        v138 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v137 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v137 = init_default_corebrightness_log();
        v138 = v137;
      }
      v301 = v138;
      v300 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v371, COERCE__INT64(*((float *)Private + 327)));
        _os_log_impl(&dword_1B5291000, v301, v300, "Lmin_product=%f", v371, 0xCu);
      }
      v299 = 0;
      if (_logHandle)
      {
        v136 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v135 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v135 = init_default_corebrightness_log();
        v136 = v135;
      }
      v299 = v136;
      v298 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v370, COERCE__INT64(*((float *)Private + 328)));
        _os_log_impl(&dword_1B5291000, v299, v298, "Lmax_panel=%f", v370, 0xCu);
      }
      v297 = 0;
      if (_logHandle)
      {
        v134 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v133 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v133 = init_default_corebrightness_log();
        v134 = v133;
      }
      v297 = v134;
      v296 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v134, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v369, COERCE__INT64(*((float *)Private + 329)));
        _os_log_impl(&dword_1B5291000, v297, v296, "Lmid_panel=%f", v369, 0xCu);
      }
      v295 = 0;
      if (_logHandle)
      {
        v132 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v131 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v131 = init_default_corebrightness_log();
        v132 = v131;
      }
      v295 = v132;
      v294 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v368, COERCE__INT64(*((float *)Private + 330)));
        _os_log_impl(&dword_1B5291000, v295, v294, "Lmin_panel=%f", v368, 0xCu);
      }
      v293 = 0;
      if (_logHandle)
      {
        v130 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v129 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v129 = init_default_corebrightness_log();
        v130 = v129;
      }
      v293 = v130;
      v292 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v367, COERCE__INT64(*((float *)Private + 331)));
        _os_log_impl(&dword_1B5291000, v293, v292, "milliAmps2NitsScaleFactor=%f", v367, 0xCu);
      }
      if (-[CBAODState enableAODLiveON](+[CBAODState sharedInstance](CBAODState, "sharedInstance"), "enableAODLiveON"))
      {
        v365 = xmmword_1B54623FC;
        v366 = 713503427;
        v363 = xmmword_1B5462410;
        v364 = -1632750650;
        if ((MGIsDeviceOneOfType() & 1) != 0)
          *((float *)Private + 330) = 2.0;
      }
    }
    CFRelease(CFProperty);
  }
  else
  {
    *((float *)Private + 330) = 5.0;
    *((float *)Private + 327) = 5.0;
    *((_DWORD *)Private + 329) = 1124859904;
    *((_DWORD *)Private + 326) = 1124859904;
    *((_DWORD *)Private + 328) = 1137180672;
    *((_DWORD *)Private + 325) = 1137180672;
    v11 = _DisplaySliderToLogicalBrightnessInternal((uint64_t)Private, 0.0);
    *((float *)Private + 330) = v11;
    *((float *)Private + 327) = v11;
    v12 = _DisplaySliderToLogicalBrightnessInternal((uint64_t)Private, 0.5);
    *((float *)Private + 329) = v12;
    *((float *)Private + 326) = v12;
    v13 = _DisplaySliderToLogicalBrightnessInternal((uint64_t)Private, 1.0);
    *((float *)Private + 328) = v13;
    *((float *)Private + 325) = v13;
    *((_DWORD *)Private + 331) = *((_DWORD *)Private + 328);
  }
  *((_DWORD *)Private + 386) = *((_DWORD *)Private + 328);
  *((_DWORD *)Private + 383) = *((_DWORD *)Private + 330);
  *((_BYTE *)Private + 1548) = 0;
  v291 = 0;
  v128 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  v291 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("digital-dimming-min-nits"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  v290 = 0;
  v290 = (float)(*((float *)Private + 383) * 65536.0);
  _DisplayGetUint32FromCFDataAndRelease(v291, &v290);
  *((float *)Private + 382) = (float)v290 / 65536.0;
  v291 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("user-accessible-max-nits"), *v128, 3u);
  v289 = 0;
  v289 = (float)(*((float *)Private + 386) * 65536.0);
  _DisplayGetUint32FromCFDataAndRelease(v291, &v289);
  *((float *)Private + 384) = (float)v289 / 65536.0;
  v291 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("aot-accessible-min-nits"), *v128, 3u);
  v288 = 0;
  v288 = (float)(*((float *)Private + 330) * 65536.0);
  _DisplayGetUint32FromCFDataAndRelease(v291, &v288);
  *((float *)Private + 385) = (float)v288 / 65536.0;
  *((_BYTE *)Private + 1516) = *((float *)Private + 383) > *((float *)Private + 382);
  *((_BYTE *)Private + 1517) = *((float *)Private + 386) > *((float *)Private + 384);
  v320 = IORegistryEntryCreateCFProperty(object, CFSTR("backlight-marketing-table"), *v128, 0);
  if (v320)
  {
    v127 = CFGetTypeID(v320);
    if (v127 == CFDataGetTypeID())
    {
      count = CFDataGetLength((CFDataRef)v320) / 4uLL;
      v286 = (float *)malloc_type_calloc(count, 4uLL, 0x100004052888210uLL);
      BytePtr = CFDataGetBytePtr((CFDataRef)v320);
      for (i = 0; i < (uint64_t)count; ++i)
      {
        v283 = 0;
        v14 = (int *)BytePtr;
        BytePtr += 4;
        v283 = *v14;
        v286[i] = (float)v283 / 65536.0;
      }
      v282 = 0.0;
      v282 = *((float *)Private + 386);
      v281 = 0.0;
      v281 = *((float *)Private + 383);
      v280 = 0;
      if (_logHandle)
      {
        v126 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v125 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v125 = init_default_corebrightness_log();
        v126 = v125;
      }
      v280 = v126;
      v279 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v362, COERCE__INT64(*((float *)Private + 386)), COERCE__INT64(*((float *)Private + 383)), COERCE__INT64(*((float *)Private + 384)), COERCE__INT64(*((float *)Private + 382)), 0x3FF0000000000000, count);
        _os_log_debug_impl(&dword_1B5291000, v280, v279, "Digital dimming params: hardware max: %f, hardware min: %f, user accessible max: %f, dig.dimming min: %f, midpointfactor: %f, mark table entries count: %ld", v362, 0x3Eu);
      }
      v278 = 1.0;
      if ((*((_BYTE *)Private + 1516) & 1) != 0)
      {
        for (j = 0; j < (uint64_t)count / 2; ++j)
        {
          v276 = 0.0;
          v276 = (float)(*((float *)Private + 382) / v281)
               + (float)((float)((float)j / (float)((uint64_t)count / 2 - 1))
                       * (float)(1.0 - (float)(*((float *)Private + 382) / v281)));
          v286[j] = v286[j] * v276;
          v275 = 0;
          if (_logHandle)
          {
            v124 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v123 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v123 = init_default_corebrightness_log();
            v124 = v123;
          }
          v275 = v124;
          v274 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v124, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v361, j, COERCE__INT64(v286[j]), COERCE__INT64(v276));
            _os_log_debug_impl(&dword_1B5291000, v275, v274, "Rescaled marketing table %ld: %f (factor %f)", v361, 0x20u);
          }
        }
      }
      if ((*((_BYTE *)Private + 1517) & 1) != 0)
      {
        for (k = (uint64_t)count / 2; k < count; ++k)
        {
          v272 = 0.0;
          v272 = (float)((float)((float)(k - (uint64_t)count / 2) / (float)(uint64_t)(count - 1 - (uint64_t)count / 2))
                       * (float)((float)(*((float *)Private + 384) / v282) - 1.0))
               + 1.0;
          v286[k] = v286[k] * v272;
          v271 = 0;
          if (_logHandle)
          {
            v122 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v121 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v121 = init_default_corebrightness_log();
            v122 = v121;
          }
          v271 = v122;
          v270 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v122, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v360, k, COERCE__INT64(v286[k]), COERCE__INT64(v272));
            _os_log_debug_impl(&dword_1B5291000, v271, v270, "Rescaled marketing table %ld: %f (factor %f)", v360, 0x20u);
          }
        }
      }
      *((_QWORD *)Private + 9) = v286;
      *((_DWORD *)Private + 16) = count;
    }
    CFRelease(v320);
  }
  else
  {
    if (*((_DWORD *)Private + 8))
      goto LABEL_495;
    v358 = 0x430C000040A00000;
    v359 = 1137180672;
    v269 = 3;
    v15 = malloc_type_calloc(3uLL, 4uLL, 0x100004052888210uLL);
    *((_QWORD *)Private + 9) = v15;
    *((_DWORD *)Private + 16) = v269;
    __memcpy_chk();
  }
  v268 = 0;
  if (_logHandle)
  {
    v120 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v119 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v119 = init_default_corebrightness_log();
    v120 = v119;
  }
  v268 = v120;
  v267 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v120, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v357, COERCE__INT64(*((float *)Private + 330)), COERCE__INT64(*((float *)Private + 329)), COERCE__INT64(*((float *)Private + 328)));
    _os_log_debug_impl(&dword_1B5291000, v268, v267, "Original panel calibration data: %f %f %f", v357, 0x20u);
  }
  if ((*((_BYTE *)Private + 1516) & 1) != 0)
  {
    v16 = *((_DWORD *)Private + 382);
    *((_DWORD *)Private + 330) = v16;
    *((_DWORD *)Private + 327) = v16;
  }
  if ((*((_BYTE *)Private + 1517) & 1) != 0)
  {
    v17 = *((_DWORD *)Private + 384);
    *((_DWORD *)Private + 328) = v17;
    *((_DWORD *)Private + 325) = v17;
  }
  v266 = 0;
  if (_logHandle)
  {
    v118 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v117 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v117 = init_default_corebrightness_log();
    v118 = v117;
  }
  v266 = v118;
  v265 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v118, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v356, COERCE__INT64(*((float *)Private + 330)), COERCE__INT64(*((float *)Private + 329)), COERCE__INT64(*((float *)Private + 328)));
    _os_log_debug_impl(&dword_1B5291000, v266, v265, "Overridden panel calibration data: %f %f %f", v356, 0x20u);
  }
  *((_DWORD *)Private + 75) = 0;
  v264 = 0;
  v264 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("nits2mAmps0thOrderCoef"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if (v264)
  {
    TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v264) && (unint64_t)CFDataGetLength((CFDataRef)v264) >= 4)
    {
      CFDataGetBytePtr((CFDataRef)v264);
      __memcpy_chk();
    }
  }
  if (v264)
    CFRelease(v264);
  *((_DWORD *)Private + 74) = 1310720;
  v264 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("nits2mAmps1stOrderCoef"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if (v264)
  {
    v115 = CFDataGetTypeID();
    if (v115 == CFGetTypeID(v264) && (unint64_t)CFDataGetLength((CFDataRef)v264) >= 4)
    {
      CFDataGetBytePtr((CFDataRef)v264);
      __memcpy_chk();
    }
  }
  if (v264)
    CFRelease(v264);
  *((_DWORD *)Private + 73) = 0;
  v264 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("nits2mAmps2ndOrderCoef"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if (v264)
  {
    v114 = CFDataGetTypeID();
    if (v114 == CFGetTypeID(v264) && (unint64_t)CFDataGetLength((CFDataRef)v264) >= 4)
    {
      CFDataGetBytePtr((CFDataRef)v264);
      __memcpy_chk();
    }
  }
  if (v264)
    CFRelease(v264);
  *((_DWORD *)Private + 76) = 1072064102;
  *((_BYTE *)Private + 312) = 0;
  *((float *)Private + 79) = -1.0;
  *((_DWORD *)Private + 77) = 0;
  v264 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("display-type-A"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if (v264)
  {
    v113 = CFDataGetTypeID();
    if (v113 == CFGetTypeID(v264))
    {
      CFDataGetBytePtr((CFDataRef)v264);
      __memcpy_chk();
      v263 = 0;
      if (_logHandle)
      {
        v112 = _logHandle;
      }
      else
      {
        v111 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        v112 = v111;
      }
      v263 = v112;
      v262 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
      {
        v109 = v263;
        v110 = v262;
        __os_log_helper_16_0_0(v261);
        _os_log_impl(&dword_1B5291000, v109, v110, "New backlight architecture.", v261, 2u);
      }
    }
  }
  if (v264)
    CFRelease(v264);
  Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)Private + 24) = Mutable;
  if (*((_QWORD *)Private + 24))
  {
    context = (void *)MEMORY[0x1B5E4A8B0](Mutable, v19);
    value = 0;
    v354[0] = CFSTR("HardwareAccessibleMaxNits");
    v355[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", *((float *)Private + 386));
    v354[1] = CFSTR("UserAccessibleMaxNits");
    v355[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", *((float *)Private + 384));
    v354[2] = CFSTR("HardwareAccessibleMinNits");
    v355[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", *((float *)Private + 383));
    v354[3] = CFSTR("MinNitsAccessibleWithDigitalDimming");
    v355[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", *((float *)Private + 382));
    v354[4] = CFSTR("DigitalDimmingSupported");
    v355[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", *((_BYTE *)Private + 1516) & 1);
    v354[5] = CFSTR("ExtrabrightEDRSupported");
    v355[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", *((_BYTE *)Private + 1517) & 1);
    value = (void *)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v355, v354, 6);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("VirtualBrightnessLimits"), value);
    objc_autoreleasePoolPop(context);
    number = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1320);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayPanelLuminanceMin"), number);
      CFRelease(number);
    }
    number = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1316);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayPanelLuminanceMid"), number);
      CFRelease(number);
    }
    number = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1312);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayPanelLuminanceMax"), number);
      CFRelease(number);
    }
    number = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1308);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayProductLuminanceMin"), number);
      CFRelease(number);
    }
    number = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1304);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayProductLuminanceMid"), number);
      CFRelease(number);
    }
    number = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1300);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayProductLuminanceMax"), number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 21) = 0;
    *((_DWORD *)Private + 22) = 1;
    *((_QWORD *)Private + 12) = 0;
    number = CFNumberCreate(allocator, kCFNumberIntType, (char *)Private + 308);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayTypeA"), number);
      CFRelease(number);
    }
    v259 = 0;
    v258 = 0;
    v258 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("default-curve-version"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (v258)
    {
      v107 = CFDataGetTypeID();
      if (v107 == CFGetTypeID(v258))
      {
        v259 = *(_DWORD *)CFDataGetBytePtr((CFDataRef)v258);
        number = CFNumberCreate(allocator, kCFNumberIntType, &v259);
        if (number)
        {
          CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DefaultCurveVersion"), number);
          CFRelease(number);
        }
      }
      CFRelease(v258);
    }
    v257 = 0;
    v256 = 0;
    v256 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("raise-high-curve"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (v256)
    {
      v106 = CFDataGetTypeID();
      if (v106 == CFGetTypeID(v256))
      {
        v257 = *(_DWORD *)CFDataGetBytePtr((CFDataRef)v256);
        number = CFNumberCreate(allocator, kCFNumberIntType, &v257);
        if (number)
        {
          CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("RaiseHighCurve"), number);
          CFRelease(number);
        }
      }
      CFRelease(v256);
    }
    v255 = 0;
    if (!(load_int_from_edt(object, CFSTR("plt-logic-version"), &v255) & 1))
      v255 = 0;
    v253 = CFNumberCreate(allocator, kCFNumberIntType, &v255);
    if (v253)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("plt-logic-version"), v253);
      CFRelease(v253);
    }
    *((float *)Private + 285) = 1.0;
    *((_BYTE *)Private + 1048) = 0;
    *((_BYTE *)Private + 1120) = 0;
    v252 = 0;
    GlobalScalarFromDevice = _DisplayGetGlobalScalarFromDevice((uint64_t)Private, object);
    *((float *)Private + 285) = GlobalScalarFromDevice;
    *((_BYTE *)Private + 972) = 0;
    v21 = [CBBacklightNode alloc];
    v251 = -[CBBacklightNode initWithService:](v21, "initWithService:", object);
    RestrictionDictionary = _DisplayCreateRestrictionDictionary(object, v251);
    if (RestrictionDictionary)
    {
      v249 = CFDictionaryGetValue(RestrictionDictionary, CFSTR("multi_point"));
      if (v249)
      {
        v105 = CFGetTypeID(v249);
        if (v105 == CFBooleanGetTypeID())
        {
          v22 = CFBooleanGetValue((CFBooleanRef)v249) != 0;
          *((_BYTE *)Private + 972) = v22;
        }
      }
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("BrightnessRestrictions"), RestrictionDictionary);
      CFRelease(RestrictionDictionary);
      v252 = 1;
    }

    if (*((float *)Private + 285) < 1.0 || (v252 & 1) != 0)
    {
      CFPreferencesSynchronize(CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
      if ((v252 & 1) != 0)
      {
        v248 = 0;
        v248 = CFPreferencesCopyValue(CFSTR("DynamicSliderEnable"), CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
        if (v248)
        {
          v104 = CFGetTypeID(v248);
          if (v104 == CFNumberGetTypeID())
          {
            v247 = 1;
            CFNumberGetValue((CFNumberRef)v248, kCFNumberIntType, &v247);
            *((_BYTE *)Private + 1048) = v247 == 0;
            *((_BYTE *)Private + 1120) = v247 == 0;
            CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DynamicSliderEnable"), v248);
          }
          CFRelease(v248);
        }
      }
      if (*((float *)Private + 285) < 1.0)
      {
        v246 = 0;
        v246 = CFPreferencesCopyValue(CFSTR("BrightnessGlobalScalar"), CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
        if (v246)
        {
          v103 = CFGetTypeID(v246);
          if (v103 == CFNumberGetTypeID())
          {
            v245 = 1;
            CFNumberGetValue((CFNumberRef)v246, kCFNumberIntType, &v245);
            if (!v245)
            {
              *((float *)Private + 285) = 1.0;
              CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("BrightnessGlobalScalar"), CFSTR("disabled"));
            }
          }
          CFRelease(v246);
        }
      }
    }
    v244 = 0;
    v243 = 0;
    v243 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("supports-edm"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    _DisplayGetUint32FromCFDataAndRelease(v243, &v244);
    v102 = (__CFDictionary *)*((_QWORD *)Private + 24);
    if (v244)
      CFDictionarySetValue(v102, CFSTR("EDMSupported"), (const void *)*MEMORY[0x1E0C9AE50]);
    else
      CFDictionarySetValue(v102, CFSTR("EDMSupported"), (const void *)*MEMORY[0x1E0C9AE40]);
    AABConstraintDictionary = _DisplayCreateAABConstraintDictionary(object);
    if (AABConstraintDictionary)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("AABConstraints"), AABConstraintDictionary);
      CFRelease(AABConstraintDictionary);
    }
    AABCapDictionary = _DisplayCreateAABCapDictionary(object);
    if (AABCapDictionary)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("AABCurveCap"), AABCapDictionary);
      CFRelease(AABCapDictionary);
    }
    *((_BYTE *)Private + 232) = 0;
    *((_DWORD *)Private + 62) = 0;
    *((float *)Private + 61) = -1.0;
    *((_DWORD *)Private + 63) = -1;
    *((_DWORD *)Private + 65) = -1;
    *((_DWORD *)Private + 64) = -1;
    v240 = 0;
    v239 = 0;
    v239 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("pre-strobe-dim-period"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if ((_DisplayGetUint32FromCFDataAndRelease(v239, &v240) & 1) != 0)
    {
      *((float *)Private + 61) = (float)v240 / 1000.0;
      *((_DWORD *)Private + 62) = 0;
    }
    v239 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)Private + 244);
    if (v239)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("PreStrobeDimPeriod"), v239);
      CFRelease(v239);
    }
    v238 = 0;
    v237 = 0;
    v237 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("pre-strobe-current"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if ((_DisplayGetUint32FromCFDataAndRelease(v237, &v238) & 1) != 0)
      *((_DWORD *)Private + 62) = 1;
    v236 = 0;
    v235 = 0;
    v235 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("pre-strobe-nit"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if ((_DisplayGetUint32FromCFDataAndRelease(v235, &v236) & 1) != 0)
    {
      *((_DWORD *)Private + 62) = 1;
      v23 = v236 << 16;
      *((_DWORD *)Private + 63) = v236 << 16;
      *((_DWORD *)Private + 64) = v23;
    }
    v234 = 0;
    v233 = 0;
    v233 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("pre-strobe-drop-als-samples"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    _DisplayGetUint32FromCFDataAndRelease(v233, &v234);
    v101 = (__CFDictionary *)*((_QWORD *)Private + 24);
    if (v234)
      CFDictionarySetValue(v101, CFSTR("PreStrobeDropALSSamples"), (const void *)*MEMORY[0x1E0C9AE50]);
    else
      CFDictionarySetValue(v101, CFSTR("PreStrobeDropALSSamples"), (const void *)*MEMORY[0x1E0C9AE40]);
    v232 = 0;
    v231 = 0;
    v231 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("sync-wake-ramp"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if ((_DisplayGetUint32FromCFDataAndRelease(v231, &v232) & 1) != 0)
      *((_DWORD *)Private + 21) = v232 != 0;
    v230 = -1;
    v229 = 0;
    v229 = (CFDictionaryRef)IORegistryEntryCreateCFProperty(*((_DWORD *)Private + 20), CFSTR("IODisplayParameters"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (v229)
    {
      v228 = (CFDictionaryRef)CFDictionaryGetValue(v229, CFSTR("brightness"));
      if (v228)
      {
        v227 = (CFNumberRef)CFDictionaryGetValue(v228, CFSTR("value"));
        if (v227)
        {
          CFNumberGetValue(v227, kCFNumberSInt32Type, &v230);
          *((_DWORD *)Private + 26) = v230 != 0;
        }
      }
      v226 = 0;
      if (_logHandle)
      {
        v100 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v99 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v99 = init_default_corebrightness_log();
        v100 = v99;
      }
      v226 = v100;
      v225 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_1_8_66((uint64_t)v353, (uint64_t)v229);
        _os_log_impl(&dword_1B5291000, v226, v225, "display parameters = %{public}@", v353, 0xCu);
      }
      CFRelease(v229);
    }
    v24 = 1.0;
    if (!v230)
      v24 = 0.0;
    v25 = v24;
    *((float *)Private + 87) = v25;
    v224 = 0;
    if (_logHandle)
    {
      v98 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v97 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v97 = init_default_corebrightness_log();
      v98 = v97;
    }
    v224 = v98;
    v223 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_2_4_0_8_0((uint64_t)v352, v230, COERCE__INT64(*((float *)Private + 87)));
      _os_log_impl(&dword_1B5291000, v224, v223, "brightness %d -> factor %f", v352, 0x12u);
    }
    *((_DWORD *)Private + 350) = *((_DWORD *)Private + 87);
    number = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 348);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayBrightnessFactor"), number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 353) = 0;
    *((float *)Private + 354) = 1.0;
    *((_DWORD *)Private + 355) = 0;
    *((float *)Private + 84) = (float)(*((_DWORD *)Private + 311) - *((_DWORD *)Private + 309))
                             / (float)(*((_DWORD *)Private + 310) - *((_DWORD *)Private + 309));
    number = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 336);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayBrightness"), number);
      CFRelease(number);
    }
    if (cf)
    {
      v26 = _DisplaySliderToLogicalBrightnessInternal((uint64_t)Private, *((float *)Private + 84));
      *((float *)Private + 313) = v26;
      *((_DWORD *)Private + 314) = *((_DWORD *)Private + 313);
      *((_DWORD *)Private + 372) = *((_DWORD *)Private + 314);
      *((_DWORD *)Private + 373) = *((_DWORD *)Private + 313);
      *((_DWORD *)Private + 315) = *((_DWORD *)Private + 314);
      *((_DWORD *)Private + 318) = *((_DWORD *)Private + 314);
      v222 = 0;
      HIDWORD(v222) = *((_DWORD *)Private + 315);
      LODWORD(v222) = 1;
      __DisplayUpdateAAPStateInternal((uint64_t)Private, (uint64_t)&v222, 0);
      v221 = 0;
      v221 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloat32Type, (char *)Private + 1256);
      if (v221)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayNitsKey"), v221);
        CFRelease(v221);
      }
    }
    *((_DWORD *)Private + 98) = 0;
    v27 = *((_DWORD *)Private + 330);
    *((_DWORD *)Private + 99) = v27;
    *((_DWORD *)Private + 100) = v27;
    *((float *)Private + 114) = 1.0;
    v28 = *((_DWORD *)Private + 328);
    *((_DWORD *)Private + 115) = v28;
    *((_DWORD *)Private + 116) = v28;
    *((float *)Private + 130) = 1.0;
    v29 = *((_DWORD *)Private + 328);
    *((_DWORD *)Private + 131) = v29;
    *((_DWORD *)Private + 132) = v29;
    *((_QWORD *)Private + 69) = 0x407E000000000000;
    *((_QWORD *)Private + 68) = 0x404E000000000000;
    *((CFAbsoluteTime *)Private + 67) = CFAbsoluteTimeGetCurrent();
    *((_QWORD *)Private + 72) = *((_QWORD *)Private + 67);
    *((_QWORD *)Private + 74) = 0;
    *((_BYTE *)Private + 584) = 1;
    *((double *)Private + 70) = 30.0;
    *((double *)Private + 71) = 0.5;
    *((_DWORD *)Private + 160) = 1;
    *((float *)Private + 162) = 1.0;
    *((_QWORD *)Private + 82) = 0x3FE99999A0000000;
    *((float *)Private + 170) = 1.0;
    *((float *)Private + 172) = 1.0;
    *((float *)Private + 171) = 1.0;
    *((_DWORD *)Private + 173) = 0;
    *((float *)Private + 174) = 1.0;
    *((_DWORD *)Private + 175) = 0;
    *((_DWORD *)Private + 180) = 1140457472;
    *((_DWORD *)Private + 181) = 1140457472;
    *((_DWORD *)Private + 208) = 1120403456;
    *((float *)Private + 264) = 1.0;
    v30 = *((_DWORD *)Private + 264);
    *((_DWORD *)Private + 272) = v30;
    *((_DWORD *)Private + 270) = v30;
    *((_DWORD *)Private + 271) = v30;
    *((_QWORD *)Private + 133) = 0;
    *((float *)Private + 246) = 1.0;
    v31 = *((_DWORD *)Private + 246);
    *((_DWORD *)Private + 254) = v31;
    *((_DWORD *)Private + 252) = v31;
    *((_DWORD *)Private + 253) = v31;
    *((_QWORD *)Private + 124) = 0;
    *((_DWORD *)Private + 245) = *((_DWORD *)Private + 329);
    *((_DWORD *)Private + 244) = *((_DWORD *)Private + 329);
    *((float *)Private + 86) = 1.0;
    number = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 344);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayBrightnessMax"), number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 85) = 0;
    if (*((_DWORD *)Private + 9))
      *((float *)Private + 85) = (float)(*((_DWORD *)Private + 309) + 1) / (float)*((int *)Private + 310);
    number = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 340);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayBrightnessMin"), number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 307) = 1050253722;
    *((float *)Private + 296) = 0.5;
    __DisplayUpdateAmbientProperties((uint64_t)Private, *((float *)Private + 84));
    *((_DWORD *)Private + 300) = 1063675494;
    *((_DWORD *)Private + 298) = 0;
    number = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1200);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayBrightnessAutoWeightMax"), number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 299) = 1036831949;
    number = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1196);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayBrightnessAutoWeightMin"), number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 3184) = 10;
    *((_DWORD *)Private + 3183) = 0;
    *((_DWORD *)Private + 3182) = 0;
    __memset_chk();
    *((float *)Private + 3235) = -1.0;
    v219 = MGGetBoolAnswer() & 1;
    v220 = v219;
    v32 = 1.0;
    if (!v219)
      v32 = 0.0;
    v33 = v32;
    *((float *)Private + 301) = v33;
    v96 = (__CFDictionary *)*((_QWORD *)Private + 24);
    if ((v220 & 1) != 0)
      CFDictionarySetValue(v96, CFSTR("DisplayBrightnessAuto"), (const void *)*MEMORY[0x1E0C9AE50]);
    else
      CFDictionarySetValue(v96, CFSTR("DisplayBrightnessAuto"), (const void *)*MEMORY[0x1E0C9AE40]);
    *((_DWORD *)Private + 50) = 6;
    number = CFNumberCreate(allocator, kCFNumberIntType, (char *)Private + 200);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("LogLevel"), number);
      CFRelease(number);
    }
    v218 = 0;
    v217 = 0;
    v95 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    v217 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("use-cabal"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    v216 = _DisplayGetUint32FromCFDataAndRelease(v217, &v218) & 1;
    v215 = 0;
    v214 = 0;
    v214 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("use-new-AAP-ramp"), *v95, 3u);
    v213 = _DisplayGetUint32FromCFDataAndRelease(v214, &v215) & 1;
    if ((v216 & 1) != 0 || (v213 & 1) != 0)
    {
      v94 = 1;
      if (!v215)
        v94 = v218 != 0;
      *((_BYTE *)Private + 12282) = v94;
      v93 = 1;
      if (!v215)
        v93 = v218 != 0;
      *((_BYTE *)Private + 12248) = v93;
      v212 = 0;
      if (_logHandle)
      {
        v92 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v91 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v91 = init_default_corebrightness_log();
        v92 = v91;
      }
      v212 = v92;
      v211 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_2_4_0_4_0((uint64_t)v351, v218, v215);
        _os_log_impl(&dword_1B5291000, v212, v211, "Use Cabal = %d, new AAP ramp = %d", v351, 0xEu);
      }
      if (v218)
      {
        v210 = 0;
        if (_logHandle)
        {
          v90 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v89 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v89 = init_default_corebrightness_log();
          v90 = v89;
        }
        v210 = v90;
        v209 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
        {
          v87 = v210;
          v88 = v209;
          __os_log_helper_16_0_0(v208);
          _os_log_impl(&dword_1B5291000, v87, v88, "AAP factor calculation function = DisplayUpdateAAPStateLookup", v208, 2u);
        }
        *((_QWORD *)Private + 1559) = __DisplayUpdateAAPStateLookup;
      }
      else
      {
        v207 = 0;
        if (_logHandle)
        {
          v86 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v85 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v85 = init_default_corebrightness_log();
          v86 = v85;
        }
        v207 = v86;
        v206 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
        {
          v83 = v207;
          v84 = v206;
          __os_log_helper_16_0_0(v205);
          _os_log_impl(&dword_1B5291000, v83, v84, "AAP factor calculation function = DisplayUpdateAAPStateStandard", v205, 2u);
        }
        *((_QWORD *)Private + 1559) = __DisplayUpdateAAPStateStandard;
      }
    }
    v204 = IORegistryEntryCreateCFProperty(object, CFSTR("use-AAP"), allocator, 0);
    if (v204)
    {
      v34 = GetCFBooleanValue((const __CFNumber *)v204) != 0;
      *((_BYTE *)Private + 12248) = v34;
      v203 = 0;
      if (_logHandle)
      {
        v82 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v81 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v81 = init_default_corebrightness_log();
        v82 = v81;
      }
      v203 = v82;
      v202 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        if ((*((_BYTE *)Private + 12248) & 1) != 0)
          v35 = "";
        else
          v35 = "don't ";
        __os_log_helper_16_2_1_8_32((uint64_t)v350, (uint64_t)v35);
        _os_log_impl(&dword_1B5291000, v203, v202, "%suse AAP", v350, 0xCu);
      }
      CFRelease(v204);
    }
    if ((*((_BYTE *)Private + 12248) & 1) != 0)
    {
      *((_DWORD *)Private + 3098) = 0;
      *((_DWORD *)Private + 3115) = 1053609165;
      *((_DWORD *)Private + 3114) = 0;
      *((float *)Private + 3069) = 2.0;
      *((float *)Private + 3068) = 5.0;
      *((float *)Private + 3063) = 2.0;
      *((_DWORD *)Private + 3065) = 1161527296;
      *((_DWORD *)Private + 3066) = 1175232512;
      *((_DWORD *)Private + 3064) = 1140457472;
      *((_DWORD *)Private + 3072) = -1;
      *((_BYTE *)Private + 12284) = 0;
      *((_BYTE *)Private + 12285) = 0;
      *((_BYTE *)Private + 12292) = 0;
      *((float *)Private + 3117) = -1.0;
      *((float *)Private + 3067) = 10.0;
      *((_DWORD *)Private + 3075) = 0;
      *((_DWORD *)Private + 3076) = 0;
      *((_DWORD *)Private + 3107) = 0;
      *((float *)Private + 3108) = 1.0;
      *((_DWORD *)Private + 3109) = 0;
      *((_DWORD *)Private + 392) = 0;
      *((_DWORD *)Private + 393) = 0;
      *((CFAbsoluteTime *)Private + 1551) = CFAbsoluteTimeGetCurrent();
      *((float *)Private + 3117) = -1.0;
      v201 = 0;
      v201 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("use-lut"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
      v200 = 0;
      _DisplayGetUint32FromCFDataAndRelease(v201, &v200);
      v348 = xmmword_1B5462430;
      v349 = 460218192;
      v346 = xmmword_1B5462444;
      v347 = 2144905009;
      v344 = xmmword_1B5462458;
      v345 = 127894440;
      v342 = xmmword_1B546246C;
      v343 = 1070997468;
      if ((MGIsDeviceOneOfType() & 1) != 0)
      {
        *((_QWORD *)Private + 1540) = DBV_SDR_XDR;
        *((_DWORD *)Private + 3078) = 68;
        *((_QWORD *)Private + 1542) = LUX_SDR_XDR;
        *((_DWORD *)Private + 3082) = 92;
        *((_QWORD *)Private + 1544) = &LUT31_SDR_XDR;
        *((_DWORD *)Private + 3086) = 92;
        *((_DWORD *)Private + 3087) = 68;
        v199 = 0;
        if (_logHandle)
        {
          v80 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v79 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v79 = init_default_corebrightness_log();
          v80 = v79;
        }
        v199 = v80;
        v198 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
        {
          v77 = v199;
          v78 = v198;
          __os_log_helper_16_0_0(v197);
          _os_log_impl(&dword_1B5291000, v77, v78, "select XDR PCC configuration", v197, 2u);
        }
      }
      else
      {
        *((_QWORD *)Private + 1540) = *(&D_SDRs + v200);
        *((_DWORD *)Private + 3078) = 68;
        *((_QWORD *)Private + 1542) = *(&L_SDRs + v200);
        *((_DWORD *)Private + 3082) = 92;
        *((_QWORD *)Private + 1544) = *(&A_SDRs + v200);
        *((_DWORD *)Private + 3086) = 92;
        *((_DWORD *)Private + 3087) = 68;
        v196 = 0;
        if (_logHandle)
        {
          v76 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v75 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v75 = init_default_corebrightness_log();
          v76 = v75;
        }
        v196 = v76;
        v195 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
        {
          v73 = v196;
          v74 = v195;
          __os_log_helper_16_0_0(v194);
          _os_log_impl(&dword_1B5291000, v73, v74, "select non-XDR PCC configuration", v194, 2u);
        }
      }
      *((_QWORD *)Private + 1546) = &HDR_LUT_PT;
      *((_DWORD *)Private + 3090) = 100;
      *((_QWORD *)Private + 1548) = &HDR_SCALE_DOWN;
      *((_DWORD *)Private + 3094) = 100;
    }
    v193 = 0;
    if (*((_DWORD *)Private + 8))
    {
      v193 = 1;
      v192 = 0;
      v192 = (int)(float)(*((float *)Private + 329) * 65536.0);
      v191 = CFNumberCreate(allocator, kCFNumberIntType, &v192);
      if (v191)
      {
        __DisplaySetBLDriverProperty((uint64_t)Private, CFSTR("DisplayBrightnessNitsNVRAM"), v191);
        CFRelease(v191);
      }
    }
    number = CFNumberCreate(allocator, kCFNumberIntType, &v193);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("DisplayBackLightArchitecture"), number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 3055) = 0;
    *((float *)Private + 3056) = 1.0;
    *((_DWORD *)Private + 3057) = 0;
    *((float *)Private + 3053) = 1.0;
    *((float *)Private + 3054) = 1.0;
    *((float *)Private + 3052) = 1.0;
    *((_BYTE *)Private + 12180) = 0;
    v71 = (CFStringRef *)MEMORY[0x1E0C9B260];
    v72 = (CFStringRef *)MEMORY[0x1E0C9B250];
    CFPreferencesSynchronize(CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
    v190 = 0;
    v190 = CFPreferencesCopyValue(CFSTR("CBCPMSRampHDR"), CFSTR("com.apple.CoreBrightness"), *v71, *v72);
    if (v190)
    {
      v70 = CFGetTypeID(v190);
      if (v70 == CFBooleanGetTypeID())
        *((_BYTE *)Private + 12180) = v190 == (CFTypeRef)*MEMORY[0x1E0C9AE50];
    }
    if (v190)
      CFRelease(v190);
    *((_BYTE *)Private + 12180) = 1;
    float_from_edt = load_float_from_edt(object, CFSTR("cpms-hdr-reset-duration"));
    *((float *)Private + 3046) = float_from_edt;
    v37 = load_float_from_edt(object, CFSTR("cpms-hdr-cap-multiplier"));
    *((float *)Private + 3047) = v37;
    memset(__b, 0, sizeof(__b));
    __sprintf_chk(__b, 0, 0x100uLL, "Display: %p", Private);
    if (target)
    {
      v189 = 0;
      if (_logHandle)
      {
        v69 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v68 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v68 = init_default_corebrightness_log();
        v69 = v68;
      }
      v189 = v69;
      v188 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
      {
        v66 = v189;
        v67 = v188;
        __os_log_helper_16_0_0(v187);
        _os_log_impl(&dword_1B5291000, v66, v67, "Using root queue \n", v187, 2u);
      }
      *((_BYTE *)Private + 160) = 1;
      v38 = dispatch_queue_create_with_target_V2(__b, 0, target);
      *((_QWORD *)Private + 18) = v38;
    }
    else
    {
      v186 = 0;
      if (_logHandle)
      {
        v65 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v64 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v64 = init_default_corebrightness_log();
        v65 = v64;
      }
      v186 = v65;
      v185 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        v62 = v186;
        v63 = v185;
        __os_log_helper_16_0_0(v184);
        _os_log_impl(&dword_1B5291000, v62, v63, "Using default queue \n", v184, 2u);
      }
      *((_BYTE *)Private + 160) = 0;
      v39 = dispatch_queue_create(__b, 0);
      *((_QWORD *)Private + 18) = v39;
    }
    __sprintf_chk(__b, 0, 0x100uLL, "DisplayAsync: %p", Private);
    v40 = dispatch_queue_create(__b, 0);
    *((_QWORD *)Private + 21) = v40;
    __sprintf_chk(__b, 0, 0x100uLL, "DisplayAsyncCPMS: %p", Private);
    v41 = dispatch_queue_create(__b, 0);
    *((_QWORD *)Private + 19) = v41;
    *((_DWORD *)Private + 3125) = 0;
    *((float *)Private + 3124) = -1.0;
    *((_BYTE *)Private + 12522) = 1;
    *((_BYTE *)Private + 12514) = 0;
    *((_BYTE *)Private + 12520) = CBU_IsNightShiftSupported() & 1;
    v183 = 0;
    v183 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v183)
    {
      if ((*((_BYTE *)Private + 12520) & 1) != 0)
        CFDictionaryAddValue((CFMutableDictionaryRef)v183, CFSTR("SupportsNightMode"), (const void *)*MEMORY[0x1E0C9AE50]);
      else
        CFDictionaryAddValue((CFMutableDictionaryRef)v183, CFSTR("SupportsNightMode"), (const void *)*MEMORY[0x1E0C9AE40]);
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("SupportedColorFX"), v183);
      CFRelease(v183);
    }
    *((_QWORD *)Private + 1572) = 0;
    *((_DWORD *)Private + 3146) = 300;
    __DisplayInitializeReport((uint64_t)Private);
    number = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (char *)Private + 12584);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("PowerLogReportInterval"), number);
      CFRelease(number);
    }
    *((_BYTE *)Private + 12515) = 0;
    *((_BYTE *)Private + 12512) = 0;
    *((_BYTE *)Private + 12513) = 0;
    CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("BlueReductionEnabled"), (const void *)*MEMORY[0x1E0C9AE40]);
    *((float *)Private + 3132) = 1.0;
    if ((*((_BYTE *)Private + 12514) & 1) != 0 || (*((_BYTE *)Private + 12520) & 1) != 0)
    {
      *((_QWORD *)Private + 1563) = CFXCreate();
      if (*((_QWORD *)Private + 1563))
      {
        CFXInstallCallback(*((_QWORD *)Private + 1563), (uint64_t)ColorRampCallback_0, (uint64_t)Private);
        v182 = 0;
        v182 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("default-whitepoint-type"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
        v181 = 0;
        if ((_DisplayGetUint32FromCFDataAndRelease(v182, &v181) & 1) != 0)
          CFXSetWhitePointType(*((_DWORD **)Private + 1563), v181);
        if ((*((_BYTE *)Private + 12520) & 1) != 0)
        {
          v180 = 0;
          v180 = CFXInitializeBlueLightReduction(*((_QWORD *)Private + 1563)) & 1;
          if (v180)
          {
            v179 = 0.0;
            v178 = 0.0;
            v177 = 0.0;
            v176 = 0.0;
            CFXGetBlueLightReductionCCTRange(*((_QWORD *)Private + 1563), &v177, &v179, &v178);
            v176 = v178;
            CBU_GetNightShiftCCTRange(object, &v179, &v178, &v177, &v176);
            v175 = 0;
            v175 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v176);
            if (v175)
            {
              CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("BlueLightReductionCCTWarningKey"), v175);
              CFRelease(v175);
            }
            v60 = (CFStringRef *)MEMORY[0x1E0C9B260];
            v61 = (CFStringRef *)MEMORY[0x1E0C9B250];
            CFPreferencesSynchronize(CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
            v174 = 0;
            v174 = CFPreferencesCopyValue(CFSTR("CBBlueLightReductionCCTRange"), CFSTR("com.apple.CoreBrightness"), *v60, *v61);
            if (v174)
            {
              v59 = CFArrayGetTypeID();
              if (v59 == CFGetTypeID(v174))
              {
                theArray = (CFArrayRef)v174;
                if (CFArrayGetCount((CFArrayRef)v174) == 3)
                {
                  v339 = 0xBF800000BF800000;
                  v340 = -1.0;
                  memset(idx, 0, sizeof(idx));
                  while (idx[0] < 3)
                  {
                    *(_QWORD *)&idx[1] = CFArrayGetValueAtIndex(theArray, idx[0]);
                    if (*(_QWORD *)&idx[1])
                    {
                      v58 = CFNumberGetTypeID();
                      if (v58 == CFGetTypeID(*(CFTypeRef *)&idx[1]))
                        CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)&v339 + 4 * idx[0]);
                    }
                    ++idx[0];
                  }
                  if (*(float *)&v339 != -1.0 && *((float *)&v339 + 1) != -1.0 && v340 != -1.0)
                  {
                    v178 = *((float *)&v339 + 1);
                    LODWORD(v179) = v339;
                    v177 = v340;
                  }
                }
              }
              CFRelease(v174);
            }
            CFXOverrideBlueLightReductionCCTRange(*((_QWORD *)Private + 1563), v177, v179, v178);
            values = 0;
            v337 = 0;
            v338 = 0;
            v57 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
            values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v179);
            v337 = CFNumberCreate(*v57, kCFNumberFloatType, &v178);
            v338 = CFNumberCreate(*v57, kCFNumberFloatType, &v177);
            if (values)
            {
              if (v337)
              {
                if (v338)
                {
                  v171 = 0;
                  v171 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 3, MEMORY[0x1E0C9B378]);
                  if (v171)
                  {
                    CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("BlueLightReductionCCTRange"), v171);
                    CFRelease(v171);
                  }
                }
              }
            }
            if (values)
              CFRelease(values);
            if (v337)
              CFRelease(v337);
            if (v338)
              CFRelease(v338);
            v170 = 0;
            v170 = CFPreferencesCopyValue(CFSTR("CBBlueLightReductionCCTTargetRaw"), CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
            v169 = 0.0;
            v169 = CFXGetBlueLightReductionTargetCCT(*((_QWORD *)Private + 1563));
            if (v170)
            {
              v56 = CFGetTypeID(v170);
              if (v56 == CFNumberGetTypeID())
              {
                CFNumberGetValue((CFNumberRef)v170, kCFNumberFloatType, &v169);
                v169 = fminf(fmaxf(v169, v179), v177);
                CFXSetBlueLightReductionTargetCCT(*((_QWORD *)Private + 1563), 0, v169, 0.0, 0.0);
              }
              CFRelease(v170);
            }
            keys = CFSTR("BlueLightReductionCCTTargetValue");
            v334 = 0;
            v334 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v169);
            if (v334)
            {
              v168 = 0;
              v168 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&keys, &v334, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              CFRelease(v334);
              if (v168)
              {
                CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("BlueLightReductionCCTTargetKey"), v168);
                CFRelease(v168);
              }
            }
          }
        }
      }
      if (CFPreferencesAppSynchronize((CFStringRef)*MEMORY[0x1E0C9B248]))
      {
        v167 = 0;
        v167 = CFPreferencesCopyAppValue(CFSTR("CBCarryLogEnabled"), (CFStringRef)*MEMORY[0x1E0C9B248]);
        v166 = 0;
        if (!v167)
          v167 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &v166);
        if (v167)
        {
          v55 = CFNumberGetTypeID();
          if (v55 == CFGetTypeID(v167))
          {
            CFNumberGetValue((CFNumberRef)v167, kCFNumberIntType, &v166);
            CFXEnableLog(*((_QWORD *)Private + 1563), v166 != 0);
            CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("CarryLogEnabled"), v167);
          }
          CFRelease(v167);
        }
      }
    }
    *((_DWORD *)Private + 287) = 0;
    *((_BYTE *)Private + 1144) = 0;
    *((_BYTE *)Private + 960) = 0;
    *((_DWORD *)Private + 241) = 0;
    *((_DWORD *)Private + 242) = 0;
    *((_DWORD *)Private + 3136) = 0;
    *((_QWORD *)Private + 1567) = 0;
    *((_BYTE *)Private + 12548) = 0;
    *((_DWORD *)Private + 3138) = 0;
    *((_DWORD *)Private + 3139) = 0;
    *((_DWORD *)Private + 282) = 0;
    *((_DWORD *)Private + 283) = 0;
    *((_DWORD *)Private + 284) = 0;
    *((_DWORD *)Private + 317) = 0;
    *((_BYTE *)Private + 1284) = 0;
    *((float *)Private + 388) = 1.0;
    *((_DWORD *)Private + 389) = 1;
    *((_DWORD *)Private + 390) = 0;
    if (+[CBSoftWakeDisplayDelegate isSupported](CBSoftWakeDisplayDelegate, "isSupported"))
      v54 = objc_alloc_init(CBSoftWakeDisplayDelegate);
    else
      v54 = 0;
    *((_QWORD *)Private + 41) = v54;
    *((float *)Private + 288) = 10.0;
    *((_DWORD *)Private + 289) = *((_DWORD *)Private + 384);
    *((float *)Private + 290) = 16.0;
    *((_DWORD *)Private + 291) = *((_DWORD *)Private + 386);
    *((float *)Private + 293) = 10.0;
    *((_BYTE *)Private + 1176) = 1;
    v165 = 0;
    v165 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("bright-dot-mitigation-nits1"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    v164 = 0;
    if ((_DisplayGetUint32FromCFDataAndRelease(v165, &v164) & 1) != 0)
      *((float *)Private + 289) = (float)v164 / 65536.0;
    *((_DWORD *)Private + 292) = *((_DWORD *)Private + 289);
    v163 = 0;
    v163 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("bright-dot-mitigation-nits2"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    v162 = 0;
    if ((_DisplayGetUint32FromCFDataAndRelease(v163, &v162) & 1) != 0)
      *((float *)Private + 291) = (float)v162 / 65536.0;
    v53 = (void *)MEMORY[0x1B5E4A8B0]();
    if (*((_QWORD *)Private + 24))
    {
      v161 = 0;
      v161 = (id)*((_QWORD *)Private + 24);
      v332[0] = CFSTR("brightDotsMitigationLux1");
      LODWORD(v42) = *((_DWORD *)Private + 288);
      v333[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v42);
      v332[1] = CFSTR("brightDotsMitigationLux2");
      LODWORD(v43) = *((_DWORD *)Private + 290);
      v333[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v43);
      v332[2] = CFSTR("brightDotsMitigationNits1");
      LODWORD(v44) = *((_DWORD *)Private + 289);
      v333[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v44);
      v332[3] = CFSTR("brightDotsMitigationNits2");
      LODWORD(v45) = *((_DWORD *)Private + 291);
      v333[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v45);
      objc_msgSend(v161, "setObject:forKey:", objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v333, v332, 4), CFSTR("BrightDotsMitigationParameters"));
    }
    objc_autoreleasePoolPop(v53);
    v160 = 0;
    v160 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (char *)Private + 1560);
    if (v160)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("BrightnessCLTMMode"), v160);
      CFRelease(v160);
    }
    v159 = 4.0;
    v331 = xmmword_1E68EB438;
    v329 = 0;
    v330 = 0;
    v52 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    v329 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (char *)Private + 1556);
    v330 = CFNumberCreate(*v52, kCFNumberFloatType, &v159);
    v46 = CFGetAllocator(Private);
    v158 = CFDictionaryCreate(v46, (const void **)&v331, &v329, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v158)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), CFSTR("BrightnessCLTM"), v158);
      CFRelease(v158);
    }
    if (v329)
      CFRelease(v329);
    if (v330)
      CFRelease(v330);
    v47 = _DisplayCheckEDRSupport((uint64_t)Private);
    *((_DWORD *)Private + 3149) = v47;
    if (*((_DWORD *)Private + 3149) == 1)
    {
      CBEDRServerAddMainDisplay(*((_DWORD *)Private + 3148));
      SetLibEDRBrightness((uint64_t)Private, *((float *)Private + 314), *((float *)Private + 386), *((float *)Private + 298), *((float *)Private + 3132));
    }
    *((_BYTE *)Private + 1504) = 0;
    *((_DWORD *)Private + 377) = (int)*((float *)Private + 326);
    *((_DWORD *)Private + 378) = (int)*((float *)Private + 386);
    v157 = 0;
    v156 = 0;
    v156 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("has-2dbl"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if ((_DisplayGetUint32FromCFDataAndRelease(v156, &v157) & 1) != 0)
      *((_BYTE *)Private + 323) = v157 != 0;
    v155 = 0;
    v154 = IORegistryEntrySearchCFProperty(object, "IOService", CFSTR("supports-aurora"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    Uint32FromCFDataAndRelease = _DisplayGetUint32FromCFDataAndRelease(v154, &v155);
    v51 = (void *)MEMORY[0x1B5E4A8B0](Uint32FromCFDataAndRelease);
    if (*((_QWORD *)Private + 24))
      objc_msgSend(*((id *)Private + 24), "setObject:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v155 == 1), CFSTR("AuroraSupported"));
    objc_autoreleasePoolPop(v51);
    *((float *)Private + 3236) = 1.0;
    *((_BYTE *)Private + 13008) = 0;
    *((_QWORD *)Private + 1619) = 0;
    *((_DWORD *)Private + 3254) = 1150681088;
    *((float *)Private + 3255) = 4.0;
    *((float *)Private + 3256) = 4.0;
    v49 = objc_alloc_init(CBDisplayRamps);
    *((_QWORD *)Private + 33) = v49;
    return Private;
  }
LABEL_495:
  if (*((_DWORD *)Private + 20))
    IOObjectRelease(*((_DWORD *)Private + 20));
  if (*((_QWORD *)Private + 9))
  {
    free(*((void **)Private + 9));
    *((_QWORD *)Private + 9) = 0;
    *((_DWORD *)Private + 16) = 0;
  }
  CFRelease(Private);
  return 0;
}

uint64_t __DisplayCreatePrivate()
{
  uint64_t Instance;

  DisplayGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return 0;
  __memset_chk();
  return Instance;
}

uint64_t __DisplayBrightnessThreadInit()
{
  uint64_t result;
  mach_msg_type_number_t port_info_outCnt;
  ipc_space_t task;
  integer_t port_info_out;
  kern_return_t inserted;
  pthread_t v5;
  pthread_attr_t __b;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  memset(&__b, 0, sizeof(__b));
  inserted = 0;
  port_info_out = 0;
  task = 0;
  task = *MEMORY[0x1E0C83DA0];
  port_info_outCnt = 1;
  if (mach_port_allocate(task, 1u, (mach_port_name_t *)&__brightnessPort))
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1378, "KERN_SUCCESS == ret");
  inserted = mach_port_insert_right(task, __brightnessPort, __brightnessPort, 0x14u);
  if (inserted)
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1381, "KERN_SUCCESS == ret");
  inserted = mach_port_get_attributes(task, __brightnessPort, 1, &port_info_out, &port_info_outCnt);
  if (inserted)
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1384, "KERN_SUCCESS == ret");
  port_info_out = 1024;
  inserted = MEMORY[0x1B5E4A7CC](task, __brightnessPort, 1, &port_info_out, port_info_outCnt);
  if (inserted)
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1389, "KERN_SUCCESS == ret");
  __brightnessDict = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (pthread_attr_init(&__b))
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1397, "!pthread_attr_init(&attr)");
  if (pthread_attr_setdetachstate(&__b, 2))
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1398, "!pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED)");
  if (pthread_create(&v5, &__b, (void *(__cdecl *)(void *))brightnessThread, 0))
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1399, "!pthread_create( &tid, &attr, brightnessThread, NULL)");
  if (pthread_attr_destroy(&__b))
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1400, "!pthread_attr_destroy(&attr)");
  result = pthread_mutex_init(&__brightnessLock, 0);
  if ((_DWORD)result)
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1401, "!pthread_mutex_init(&__brightnessLock, NULL)");
  return result;
}

float _DisplaySliderToLogicalBrightnessInternal(uint64_t a1, float a2)
{
  float v3;
  float v4;
  float v5;

  v4 = a2;
  if (a1 && *(_QWORD *)(a1 + 72))
  {
    v3 = a2 * (float)(*(_DWORD *)(a1 + 64) - 1);
    if (v3 >= *(_DWORD *)(a1 + 64) - 1)
      v4 = *(float *)(*(_QWORD *)(a1 + 72) + 4 * (*(_DWORD *)(a1 + 64) - 1));
    else
      v4 = __interpolate((float)v3, *(float *)(*(_QWORD *)(a1 + 72) + 4 * v3), (float)(v3 + 1), *(float *)(*(_QWORD *)(a1 + 72) + 4 * (v3 + 1)), v3);
  }
  v5 = v4;
  if (a1)
  {
    if (v4 < *(float *)(a1 + 1304))
      return __interpolate(*(float *)(a1 + 1308), *(float *)(a1 + 1320), *(float *)(a1 + 1304), *(float *)(a1 + 1316), v4);
    else
      return __interpolate(*(float *)(a1 + 1304), *(float *)(a1 + 1316), *(float *)(a1 + 1300), *(float *)(a1 + 1312), v4);
  }
  return v5;
}

float _DisplayGetGlobalScalarFromDevice(uint64_t a1, io_registry_entry_t a2)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  os_log_type_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t inited;
  NSObject *v20;
  CFAllocatorRef *v21;
  CFDictionaryRef value;
  uint8_t v23[7];
  os_log_type_t v24;
  os_log_t v25;
  os_log_type_t type;
  os_log_t oslog;
  unsigned int v28;
  CFTypeRef v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  float valuePtr;
  io_registry_entry_t v36;
  uint64_t v37;
  void *values;
  void *keys;
  uint8_t v41[48];
  uint8_t v42[16];
  uint8_t v43[16];
  uint8_t v44[16];
  uint8_t v45[16];
  uint8_t v46[16];
  uint8_t v47[8];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v37 = a1;
  v36 = a2;
  valuePtr = 1.0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 1.0;
  if ((_DisplayGetGlobalScalarDisplayParams(a2, (float *)&v31, (float *)&v31 + 1) & 1) == 0)
  {
LABEL_73:
    if (v37)
    {
      if (*(_QWORD *)(v37 + 192))
      {
        keys = CFSTR("Scalar");
        values = 0;
        values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &valuePtr);
        if (values)
        {
          value = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          if (value)
          {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(v37 + 192), CFSTR("BrightnessGlobalScalar"), value);
            CFRelease(value);
          }
          CFRelease(values);
        }
      }
    }
    return valuePtr;
  }
  *(_DWORD *)(v37 + 12176) = v31;
  v30 = 0;
  v29 = 0;
  v21 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  v29 = IORegistryEntrySearchCFProperty(v36, "IOService", CFSTR("pab-scaler-index"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  _DisplayGetUint32FromCFDataAndRelease(v29, &v30);
  v28 = 0;
  v29 = IORegistryEntrySearchCFProperty(v36, "IOService", CFSTR("first-paneltype-pab-index"), *v21, 3u);
  _DisplayGetUint32FromCFDataAndRelease(v29, &v28);
  oslog = 0;
  if (_logHandle)
  {
    v20 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v20 = inited;
  }
  oslog = v20;
  type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v47, v30);
    _os_log_debug_impl(&dword_1B5291000, oslog, type, "PAB scaler index (as returned by iBoot) = %u", v47, 8u);
  }
  if (v30 < v28)
  {
    v25 = 0;
    if (_logHandle)
    {
      v18 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v17 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v17 = init_default_corebrightness_log();
      v18 = v17;
    }
    v25 = v18;
    v24 = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v15 = v25;
      v16 = v24;
      __os_log_helper_16_0_0(v23);
      _os_log_error_impl(&dword_1B5291000, v15, v16, "PAB scaler: incorrect first-paneltype-pab-index in EDT! Using a default scaler", v23, 2u);
    }
    goto LABEL_73;
  }
  v30 -= v28;
  if (_logHandle)
  {
    v14 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v13 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v13 = init_default_corebrightness_log();
    v14 = v13;
  }
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v46, v30);
    _os_log_debug_impl(&dword_1B5291000, v14, OS_LOG_TYPE_DEBUG, "PAB scaler index (after making it 0-based) = %u", v46, 8u);
  }
  if ((_DisplayGetScalerForKeyAndIndex(v36, CFSTR("gs-i-nominal"), v30, (float *)&v32, 1000.0) & 1) == 0)
    goto LABEL_73;
  if (_logHandle)
  {
    v12 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v11 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v11 = init_default_corebrightness_log();
    v12 = v11;
  }
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v45, COERCE__INT64(*(float *)&v32));
    _os_log_debug_impl(&dword_1B5291000, v12, OS_LOG_TYPE_DEBUG, "I_nominal = %f", v45, 0xCu);
  }
  if ((_DisplayGetScalerForKeyAndIndex(v36, CFSTR("gs-i-threshold"), v30, (float *)&v32 + 1, 1000.0) & 1) == 0)
    goto LABEL_73;
  if (_logHandle)
  {
    v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v9 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v9 = init_default_corebrightness_log();
    v10 = v9;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v44, COERCE__INT64(*((float *)&v32 + 1)));
    _os_log_debug_impl(&dword_1B5291000, v10, OS_LOG_TYPE_DEBUG, "I_threshold = %f", v44, 0xCu);
  }
  if ((_DisplayGetScalerForKeyAndIndex(v36, CFSTR("gs-b-min"), v30, (float *)&v33, 1000.0) & 1) == 0)
    goto LABEL_73;
  if (_logHandle)
  {
    v8 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v7 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v7 = init_default_corebrightness_log();
    v8 = v7;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v43, COERCE__INT64(*(float *)&v33));
    _os_log_debug_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEBUG, "B-min = %f", v43, 0xCu);
  }
  if ((_DisplayGetScalerForKeyAndIndex(v36, CFSTR("gs-slope"), v30, (float *)&v33 + 1, 1000.0) & 1) == 0)
    goto LABEL_73;
  if (_logHandle)
  {
    v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v5 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v5 = init_default_corebrightness_log();
    v6 = v5;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v42, COERCE__INT64(*((float *)&v33 + 1)));
    _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "Slope = %f", v42, 0xCu);
  }
  if (_logHandle)
  {
    v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v3 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v3 = init_default_corebrightness_log();
    v4 = v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_5_4_0_8_0_8_0_8_0_8_0((uint64_t)v41, v30, COERCE__INT64(*(float *)&v32), COERCE__INT64(*((float *)&v32 + 1)), COERCE__INT64(*(float *)&v33), COERCE__INT64(*((float *)&v33 + 1)));
    _os_log_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEFAULT, "{ \"pab_scaler_index\": %u, \"I_nominal\": %.3f, \"I_threshold\": %.3f, \"B-min\": %.3f, \"Slope\": %.3f }", v41, 0x30u);
  }
  return _DisplayCalculateGlobalScalar(v37, (float *)&v31);
}

CFMutableDictionaryRef _DisplayCreateRestrictionDictionary(io_registry_entry_t a1, void *a2)
{
  int v3;
  CFTypeRef v4;
  uint64_t v5;
  id v6;
  io_registry_entry_t v7;

  v7 = a1;
  v6 = a2;
  v5 = 0;
  v4 = 0;
  v4 = IORegistryEntrySearchCFProperty(a1, "IOService", CFSTR("multi-point-restriction"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  v3 = 0;
  _DisplayGetUint32FromCFDataAndRelease(v4, &v3);
  if (v3)
    return (CFMutableDictionaryRef)objc_msgSend(v6, "copyRestrictionDictionaryMultiPoint");
  else
    return _DisplayCreateRestrictionDictionarySinglePoint(v7);
}

CFMutableDictionaryRef _DisplayCreateAABConstraintDictionary(io_registry_entry_t a1)
{
  float v2;
  unsigned int v3;
  void *value;
  CFMutableDictionaryRef theDict;
  int capacity;
  float capacity_4;
  float v8;
  float v9;
  float v10;
  float v11;
  float valuePtr;
  io_registry_entry_t v13;

  v13 = a1;
  valuePtr = -1.0;
  v11 = -1.0;
  v10 = -1.0;
  v9 = -1.0;
  v8 = -1.0;
  capacity_4 = -1.0;
  capacity = 2;
  theDict = 0;
  value = 0;
  value = (void *)IORegistryEntrySearchCFProperty(a1, "IOService", CFSTR("aab-constraint-emax"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  v3 = 0;
  if ((_DisplayGetUint32FromCFDataAndRelease(value, &v3) & 1) != 0)
  {
    valuePtr = (float)v3;
    ++capacity;
  }
  value = (void *)IORegistryEntrySearchCFProperty(v13, "IOService", CFSTR("aab-constraint-lmax"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if ((_DisplayGetUint32FromCFDataAndRelease(value, &v3) & 1) != 0)
  {
    v11 = (float)v3;
    ++capacity;
  }
  value = (void *)IORegistryEntrySearchCFProperty(v13, "IOService", CFSTR("aab-constraint-e2"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if ((_DisplayGetUint32FromCFDataAndRelease(value, &v3) & 1) != 0)
  {
    v10 = (float)v3;
    ++capacity;
  }
  value = (void *)IORegistryEntrySearchCFProperty(v13, "IOService", CFSTR("aab-constraint-l2"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if ((_DisplayGetUint32FromCFDataAndRelease(value, &v3) & 1) != 0)
  {
    v9 = (float)v3;
    ++capacity;
  }
  value = (void *)IORegistryEntrySearchCFProperty(v13, "IOService", CFSTR("aab-constraint-l0b"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if ((_DisplayGetUint32FromCFDataAndRelease(value, &v3) & 1) != 0)
  {
    v8 = (float)v3;
    ++capacity;
  }
  value = (void *)IORegistryEntrySearchCFProperty(v13, "IOService", CFSTR("aab-constraint-emax-threshold"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if ((_DisplayGetUint32FromCFDataAndRelease(value, &v3) & 1) != 0)
  {
    capacity_4 = (float)v3;
    ++capacity;
  }
  if (capacity > 0)
  {
    theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], capacity, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (theDict)
    {
      if (valuePtr > 0.0)
      {
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &valuePtr);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("EmaxAlgo"), value);
          CFRelease(value);
        }
      }
      if (v11 > 0.0)
      {
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v11);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("LmaxAlgo"), value);
          CFRelease(value);
        }
      }
      if (v10 > 0.0)
      {
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v10);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("E2"), value);
          CFRelease(value);
        }
      }
      if (v9 > 0.0)
      {
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v9);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("L2"), value);
          CFRelease(value);
        }
      }
      if (v8 > 0.0)
      {
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v8);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("L0b"), value);
          CFRelease(value);
        }
        v2 = 30.0;
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v2);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("E0b"), value);
          CFRelease(value);
        }
      }
      if (capacity_4 > 0.0)
      {
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &capacity_4);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("EmaxThreshold"), value);
          CFRelease(value);
        }
      }
    }
  }
  return theDict;
}

CFMutableDictionaryRef _DisplayCreateAABCapDictionary(io_registry_entry_t a1)
{
  CFTypeID v2;
  CFTypeID TypeID;
  CFAllocatorRef *v4;
  CFNumberRef v5;
  double v6;
  unsigned int v7;
  CFTypeRef v8;
  CFTypeRef cf;
  float v10;
  int j;
  CFMutableArrayRef Mutable;
  void *value;
  float valuePtr;
  int i;
  CFMutableArrayRef theArray;
  CFRange v17;
  CFDataRef theData;
  CFRange range;
  CFDataRef v20;
  const __CFData *v21;
  const __CFData *v22;
  CFMutableDictionaryRef v23;
  int v24;
  int v25;
  io_registry_entry_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _WORD v35[4];
  _WORD buffer[4];
  uint64_t v37;
  CFRange v38;
  CFRange v39;

  v37 = *MEMORY[0x1E0C80C00];
  v26 = a1;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  v4 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  v22 = (const __CFData *)IORegistryEntrySearchCFProperty(a1, "IOService", CFSTR("aab-cap-e"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  v21 = 0;
  v21 = (const __CFData *)IORegistryEntrySearchCFProperty(v26, "IOService", CFSTR("aab-cap-l"), *v4, 3u);
  if (v22)
  {
    TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v22))
    {
      v20 = v22;
      if (CFDataGetLength(v22) == 8)
      {
        v32 = 0;
        v31 = 8;
        v33 = 0;
        v34 = 8;
        range.location = 0;
        range.length = 8;
        v38.location = 0;
        v38.length = 8;
        CFDataGetBytes(v20, v38, (UInt8 *)buffer);
        v25 = 1;
      }
    }
    CFRelease(v22);
  }
  if (v21)
  {
    v2 = CFDataGetTypeID();
    if (v2 == CFGetTypeID(v21))
    {
      theData = v21;
      if (CFDataGetLength(v21) == 8)
      {
        v28 = 0;
        v27 = 8;
        v29 = 0;
        v30 = 8;
        v17.location = 0;
        v17.length = 8;
        v39.location = 0;
        v39.length = 8;
        CFDataGetBytes(theData, v39, (UInt8 *)v35);
        v24 = 1;
      }
    }
    CFRelease(v21);
  }
  if (v25 && v24)
  {
    theArray = 0;
    theArray = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4, MEMORY[0x1E0C9B378]);
    if (theArray)
    {
      for (i = 0; i < 4; ++i)
      {
        valuePtr = 0.0;
        valuePtr = (float)(__int16)buffer[i];
        value = 0;
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &valuePtr);
        if (value)
        {
          CFArrayAppendValue(theArray, value);
          CFRelease(value);
        }
      }
    }
    Mutable = 0;
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      for (j = 0; j < 4; ++j)
      {
        v10 = 0.0;
        v10 = (float)(__int16)v35[j];
        cf = 0;
        cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v10);
        if (cf)
        {
          CFArrayAppendValue(Mutable, cf);
          CFRelease(cf);
        }
      }
    }
    if (theArray)
    {
      if (CFArrayGetCount(theArray) == 4)
      {
        if (Mutable)
        {
          if (CFArrayGetCount(Mutable) == 4)
          {
            v23 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            if (v23)
            {
              CFDictionaryAddValue(v23, CFSTR("E"), theArray);
              CFDictionaryAddValue(v23, CFSTR("L"), Mutable);
            }
          }
        }
      }
    }
    if (theArray)
      CFRelease(theArray);
    if (Mutable)
      CFRelease(Mutable);
  }
  if (v23)
  {
    v8 = 0;
    v8 = IORegistryEntrySearchCFProperty(v26, "IOService", CFSTR("aab-cap-reverttime"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    v7 = 0;
    if ((_DisplayGetUint32FromCFDataAndRelease(v8, &v7) & 1) != 0)
    {
      v6 = (double)v7;
      v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &v6);
      if (v5)
      {
        CFDictionaryAddValue(v23, CFSTR("revertTime"), v5);
        CFRelease(v5);
      }
    }
  }
  return v23;
}

void __DisplayUpdateAmbientProperties(uint64_t a1, float a2)
{
  float v2;
  float v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t inited;
  NSObject *v7;
  float v8;
  float v9;
  float v10;
  float v11;
  uint8_t v14[64];
  uint8_t v15[24];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (_logHandle)
  {
    v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v7 = inited;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v15, COERCE__INT64(*(float *)(a1 + 1204)));
    _os_log_debug_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEBUG, "autobrightness=%f\n", v15, 0xCu);
  }
  if (*(float *)(a1 + 1204) == 0.0)
  {
    *(_DWORD *)(a1 + 1208) = 0;
    *(float *)(a1 + 1212) = a2;
  }
  else
  {
    v9 = *(float *)(a1 + 1196);
    v8 = *(float *)(a1 + 1200);
    if (a2 > 0.5)
    {
      v11 = (float)(1.0 - v9) + (float)(v9 * a2);
      v3 = -(0.5 * (float)((float)(v8 + 1.0) + (float)(-2.0 * v9)) - (v8 + 1.0 - v9) * a2);
      v10 = v3;
    }
    else
    {
      v2 = (float)((float)((float)(v8 - v9) + 1.0) * a2) + 0.5 - (float)(v8 / 2.0);
      v11 = v2;
      v10 = v9 * a2;
    }
    *(float *)(a1 + 1208) = v11 - v10;
    *(float *)(a1 + 1212) = v10;
  }
  if (_logHandle)
  {
    v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v4 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v4 = init_default_corebrightness_log();
    v5 = v4;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v14, COERCE__INT64(a2), COERCE__INT64(*(float *)(a1 + 1196)), COERCE__INT64(*(float *)(a1 + 1200)), COERCE__INT64(*(float *)(a1 + 1208)), COERCE__INT64(*(float *)(a1 + 1212)));
    _os_log_debug_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEBUG, "brightness=%f min=%f max=%f slope=%f intercept=%f\n", v14, 0x34u);
  }
}

float __DisplayUpdateAAPStateStandard(uint64_t a1, uint64_t a2)
{
  float result;
  float v3;
  BOOL v4;

  v4 = 0;
  if (*(_DWORD *)a2)
  {
    if (*(_DWORD *)a2 == 1)
    {
      if ((*(_BYTE *)(a1 + 1232) & 1) != 0)
      {
        if (*(float *)(a1 + 12256) > *(float *)(a2 + 4))
        {
          if ((*(_BYTE *)(a1 + 12280) & 1) != 0)
          {
            *(_BYTE *)(a1 + 12280) = 0;
            __DisplaySetAAPFactorWithFade(a1, 0, 0, 0.0, *(float *)(a1 + 12252));
          }
        }
        else
        {
          *(_BYTE *)(a1 + 12280) = 1;
          v4 = *(float *)(a1 + 12304) < *(float *)(a1 + 12256);
        }
      }
      result = *(float *)(a2 + 4);
      *(float *)(a1 + 12304) = result;
    }
    else if (*(_DWORD *)a2 == 2)
    {
      result = (float)(vabds_f32(*(float *)(a2 + 4), *(float *)(a1 + 12300)) / *(float *)(a1 + 12300)) * 100.0;
      if (result > *(float *)(a1 + 12268))
      {
        result = *(float *)(a2 + 4);
        *(float *)(a1 + 12300) = result;
        v4 = (*(_BYTE *)(a1 + 12280) & 1) != 0;
      }
    }
  }
  else
  {
    *(_BYTE *)(a1 + 12280) = *(_BYTE *)(a2 + 4) & 1;
    if ((*(_BYTE *)(a1 + 12280) & 1) != 0)
    {
      result = *(float *)(a1 + 12304);
      v4 = result >= *(float *)(a1 + 12256);
    }
    else
    {
      result = __DisplaySetAAPFactorWithFade(a1, 0, 0, 0.0, *(float *)(a1 + 12252));
    }
  }
  if (v4)
  {
    if (*(float *)(a1 + 12300) >= *(float *)(a1 + 12260))
    {
      if (*(float *)(a1 + 12300) < *(float *)(a1 + 12264))
        v3 = (float)((float)(*(float *)(a1 + 12460) - *(float *)(a1 + 12456))
                   * (float)(*(float *)(a1 + 12300) - *(float *)(a1 + 12260)))
           / (float)(*(float *)(a1 + 12264) - *(float *)(a1 + 12260));
      else
        v3 = *(float *)(a1 + 12460);
    }
    else
    {
      v3 = *(float *)(a1 + 12456);
    }
    if (*(float *)(a1 + 12392) >= v3)
      return __DisplaySetAAPFactorWithFade(a1, 0, 0, v3, *(float *)(a1 + 12276));
    else
      return __DisplaySetAAPFactorWithFade(a1, 0, 0, v3, *(float *)(a1 + 12272));
  }
  return result;
}

uint64_t GetCFBooleanValue(const __CFNumber *a1)
{
  CFTypeID v2;
  CFTypeID TypeID;
  int valuePtr;
  const __CFNumber *v5;

  v5 = a1;
  valuePtr = 0;
  if (a1)
  {
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v5))
    {
      CFNumberGetValue(v5, kCFNumberIntType, &valuePtr);
    }
    else
    {
      v2 = CFBooleanGetTypeID();
      if (v2 == CFGetTypeID(v5))
        return CFEqual(v5, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
    }
  }
  return valuePtr;
}

{
  CFTypeID v2;
  CFTypeID TypeID;
  int valuePtr;
  const __CFNumber *v5;

  v5 = a1;
  valuePtr = 0;
  if (a1)
  {
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v5))
    {
      CFNumberGetValue(v5, kCFNumberIntType, &valuePtr);
    }
    else
    {
      v2 = CFBooleanGetTypeID();
      if (v2 == CFGetTypeID(v5))
        return CFEqual(v5, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
    }
  }
  return valuePtr;
}

void __DisplayInitializeReport(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 12520) & 1) != 0 || (*(_BYTE *)(a1 + 12514) & 1) != 0)
  {
    if (*(_QWORD *)(a1 + 12504))
      CFXClearReport(*(_QWORD *)(a1 + 12504));
    __DisplayResetLogTimer(a1, 0);
  }
}

BOOL _DisplayCheckEDRSupport(uint64_t a1)
{
  char v2;
  uint64_t inited;
  NSObject *v4;
  BOOL started;
  char v6;
  uint8_t v8[8];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  started = 0;
  if (CBU_IsWatch() || CBU_IsAccessory())
  {
    v6 = 0;
  }
  else if ((*(_BYTE *)(a1 + 321) & 1) == 0 || *(_DWORD *)(a1 + 12592))
  {
    v6 = 1;
  }
  else
  {
    v6 = 0;
    if (_logHandle)
    {
      v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v4 = inited;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v8, *(_DWORD *)(a1 + 12592));
      _os_log_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEFAULT, "Not supporting LibEDR, uses CBEDR instead: displayID: %u", v8, 8u);
    }
  }
  if ((v6 & 1) == 1)
    started = CBEDRServerStartServer();
  v2 = 0;
  if (started)
    v2 = v6;
  return (v2 & 1) != 0;
}

uint64_t DisplayIsNightShiftEnabled(uint64_t a1)
{
  NSObject *v1;
  unsigned int v3;
  void (*v4)(void);
  int v5;
  int v6;
  uint64_t (*v7)(uint64_t);
  void *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;

  v16 = a1;
  v11 = 0;
  v12 = &v11;
  v13 = 0x20000000;
  v14 = 32;
  v15 = 0;
  v1 = *(NSObject **)(a1 + 144);
  v4 = (void (*)(void))MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = __DisplayIsNightShiftEnabled_block_invoke;
  v8 = &unk_1E68EB450;
  v9 = &v11;
  v10 = v16;
  disp_dispatch_sync(v1, &v4);
  v3 = *((_DWORD *)v12 + 6);
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1B53E554C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

uint64_t DisplayNotify(unsigned __int8 a1)
{
  uint64_t state64;
  int out_token;
  unsigned __int8 v4;

  v4 = a1;
  out_token = 0;
  state64 = a1;
  notify_register_check("com.apple.iokit.hid.displayStatus", &out_token);
  notify_set_state(out_token, state64);
  return notify_post("com.apple.iokit.hid.displayStatus");
}

void DisplaySetState(uint64_t a1, int a2)
{
  NSObject *v2;
  void (*v3)(void);
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v2 = *(NSObject **)(a1 + 144);
  v3 = (void (*)(void))MEMORY[0x1E0C809B0];
  v4 = -1073741824;
  v5 = 0;
  v6 = __DisplaySetState_block_invoke;
  v7 = &__block_descriptor_44_e5_v8__0l;
  v8 = v11;
  v9 = a2;
  disp_dispatch_sync(v2, &v3);
}

uint64_t DisplayOpen(char *a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;
  dispatch_queue_t v4;
  const char *v5;
  uint64_t v6;
  IONotificationPortRef v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t inited;
  NSObject *v12;
  CFTypeID v13;
  CFTypeID TypeID;
  __CFDictionary *theDict;
  const __CFAllocator *v16;
  const __CFAllocator *allocator;
  CFMutableDictionaryRef v18;
  uint64_t v19;
  int v20;
  int v21;
  void (*v22)(uint64_t, int);
  void *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  char *v28;
  _QWORD v29[2];
  int v30;
  int v31;
  int v32;
  _QWORD v33[2];
  int v34;
  int v35;
  int v36;
  _QWORD v37[2];
  int v38;
  int v39;
  int v40;
  _QWORD v41[2];
  int v42;
  int v43;
  int v44;
  os_log_type_t v45;
  os_log_t v46;
  char v47;
  char v48;
  os_log_type_t v49;
  os_log_t v50;
  int v51;
  CFTypeRef v52;
  const __CFNumber *CFProperty;
  int v54;
  BOOL v55;
  CFTypeRef v56;
  uint64_t v57;
  int v58;
  int i;
  const __CFArray *DisplayList;
  _DWORD *ValueAtIndex;
  uint64_t v62;
  CFNumberRef v63;
  CFNumberRef v64;
  unsigned __int8 v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  uint8_t v69[16];
  uint8_t v70[24];
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v68 = a1;
  v67 = a2;
  v66 = a3;
  v65 = 0;
  v64 = 0;
  v63 = 0;
  *((_QWORD *)a1 + 2) = a2;
  *((_QWORD *)v68 + 3) = v66;
  if ((v68[12248] & 1) != 0)
  {
    allocator = CFGetAllocator(v68);
    v64 = CFNumberCreate(allocator, kCFNumberFloatType, v68 + 12460);
    v16 = CFGetAllocator(v68);
    v63 = CFNumberCreate(v16, kCFNumberFloatType, v68 + 12456);
  }
  v65 = 1;
  if (v64)
  {
    DisplaySetProperty((uint64_t)v68, (uint64_t)CFSTR("DisplayAAPFactorMax"), (uint64_t)v64);
    CFRelease(v64);
  }
  if (v63)
  {
    DisplaySetProperty((uint64_t)v68, (uint64_t)CFSTR("DisplayAAPFactorMin"), (uint64_t)v63);
    CFRelease(v63);
  }
  notify_register_check("com.apple.iokit.hid.displayStatus", (int *)v68 + 12);
  if (*((float *)v68 + 87) == 0.0)
  {
    *((_DWORD *)v68 + 11) = 0;
  }
  else
  {
    *((_DWORD *)v68 + 11) = 1;
    v62 = 0;
    v62 = *((int *)v68 + 11);
    notify_set_state(*((_DWORD *)v68 + 12), v62);
    notify_post("com.apple.iokit.hid.displayStatus");
  }
  if (*((_QWORD *)v68 + 24))
  {
    theDict = (__CFDictionary *)*((_QWORD *)v68 + 24);
    if (*((_DWORD *)v68 + 11))
      CFDictionarySetValue(theDict, CFSTR("DisplayOn"), (const void *)*MEMORY[0x1E0C9AE50]);
    else
      CFDictionarySetValue(theDict, CFSTR("DisplayOn"), (const void *)*MEMORY[0x1E0C9AE40]);
  }
  *((_DWORD *)v68 + 312) = -1;
  *((_DWORD *)v68 + 27) = 0;
  ValueAtIndex = 0;
  DisplayList = (const __CFArray *)IOMobileFramebufferCreateDisplayList();
  if (DisplayList)
  {
    for (i = 0; i < CFArrayGetCount(DisplayList); ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(DisplayList, i);
      if (!ValueAtIndex[2])
        break;
    }
    CFRelease(DisplayList);
    if (ValueAtIndex)
    {
      v58 = 0;
      v57 = IOMobileFramebufferOpenByName();
    }
  }
  *((_DWORD *)v68 + 34) = 1;
  *((_DWORD *)v68 + 35) = -1;
  *((float *)v68 + 94) = -1.0;
  v68[380] = 0;
  v56 = 0;
  v56 = IORegistryEntrySearchCFProperty(*((_DWORD *)v68 + 20), "IOService", CFSTR("ignore-IOMFB"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  v55 = 0;
  if (v56)
  {
    TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v56))
    {
      v54 = 0;
      _DisplayGetUint32FromCFDataAndRelease(v56, &v54);
      v55 = v54 != 0;
    }
    else
    {
      CFRelease(v56);
    }
  }
  if (v55 || (v68[312] & 1) != 0)
    *((_DWORD *)v68 + 34) = 0;
  if ((v68[312] & 1) == 0)
  {
    v3 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
    v4 = dispatch_queue_create(0, v3);
    *((_QWORD *)v68 + 15) = v4;
  }
  v68[320] = 0;
  if (CBU_IsWatch())
    v68[320] = 1;
  *((float *)v68 + 3098) = -1.0;
  __DisplaySetAAPFactor(v68, *((float *)v68 + 3114));
  *((_DWORD *)v68 + 71) = 0;
  v68[288] = 0;
  v68[289] = 0;
  CFProperty = 0;
  CFProperty = (const __CFNumber *)IORegistryEntryCreateCFProperty(*((_DWORD *)v68 + 20), CFSTR("nitsThresholdPLC"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (CFProperty)
  {
    v13 = CFNumberGetTypeID();
    if (v13 == CFGetTypeID(CFProperty))
    {
      CFNumberGetValue(CFProperty, kCFNumberIntType, v68 + 284);
      v68[288] = 1;
    }
    CFRelease(CFProperty);
  }
  if (*((_DWORD *)v68 + 27))
  {
    v52 = 0;
    v52 = IORegistryEntrySearchCFProperty(*((_DWORD *)v68 + 27), "IOService", CFSTR("limit_max_physical_brightness"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    v51 = 0;
    v51 = (int)(float)(*((float *)v68 + 386) * 65536.0);
    if ((_DisplayGetUint32FromCFNumberAndRelease(v52, &v51) & 1) != 0)
      *((float *)v68 + 386) = (float)v51 / 65536.0;
    v50 = 0;
    if (_logHandle)
    {
      v12 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v12 = inited;
    }
    v50 = v12;
    v49 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v70, COERCE__INT64(*((float *)v68 + 386)));
      _os_log_debug_impl(&dword_1B5291000, v50, v49, "New hardwareAccessibleMaxNits: %f", v70, 0xCu);
    }
  }
  v47 = MGGetBoolAnswer() & 1;
  v48 = v47;
  *((_DWORD *)v68 + 3179) = v47 != 0;
  v46 = 0;
  if (_logHandle)
  {
    v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v9 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v9 = init_default_corebrightness_log();
    v10 = v9;
  }
  v46 = v10;
  v45 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    if ((v48 & 1) != 0)
      v5 = "OLED";
    else
      v5 = "LCD";
    __os_log_helper_16_2_1_8_32((uint64_t)v69, (uint64_t)v5);
    _os_log_impl(&dword_1B5291000, v46, v45, "Device has %s display.", v69, 0xCu);
  }
  if (*((_DWORD *)v68 + 3149) == 1)
  {
    v41[0] = 0;
    v41[1] = v41;
    v42 = 0x20000000;
    v43 = 32;
    v44 = 0;
    v37[0] = 0;
    v37[1] = v37;
    v38 = 0x20000000;
    v39 = 32;
    v40 = 0;
    v33[0] = 0;
    v33[1] = v33;
    v34 = 0x20000000;
    v35 = 32;
    v36 = 0;
    v29[0] = 0;
    v29[1] = v29;
    v30 = 0x20000000;
    v31 = 32;
    v32 = 0;
    v6 = *((_QWORD *)v68 + 18);
    v19 = MEMORY[0x1E0C809B0];
    v20 = -1073741824;
    v21 = 0;
    v22 = __DisplayOpen_block_invoke;
    v23 = &unk_1E68EB498;
    v28 = v68;
    v24 = v41;
    v25 = v37;
    v26 = v33;
    v27 = v29;
    CBEDRServerRegisterCallbackBlockOnQueue(v6, (uint64_t)&v19);
    v68[12181] = 0;
    if ((objc_msgSend(MEMORY[0x1E0D09930], "isCPMSSupported") & 1) == 1)
    {
      v68[12181] = 1;
      if ((DisplayHasDCP((uint64_t)v68) & 1) != 0)
      {
        *((_QWORD *)v68 + 1516) = IOReportCopyChannelsInGroup();
        if (*((_QWORD *)v68 + 1516))
          *((_QWORD *)v68 + 1518) = IOReportCreateSubscription();
      }
      else
      {
        *((_QWORD *)v68 + 1516) = 0;
        *((_QWORD *)v68 + 1517) = 0;
        *((_QWORD *)v68 + 1518) = 0;
        *((_QWORD *)v68 + 1519) = 0;
        *((_QWORD *)v68 + 1520) = 0;
        *((_QWORD *)v68 + 1521) = 0;
        v18 = IOServiceMatching("IOMobileFramebuffer");
        *((_QWORD *)v68 + 1516) = IOReportCopyChannelsWithID();
        if (*((_QWORD *)v68 + 1516))
          *((_QWORD *)v68 + 1518) = IOReportCreateSubscription();
        *((_QWORD *)v68 + 1519) = IOReportCopyChannelsWithID();
        if (*((_QWORD *)v68 + 1519))
          *((_QWORD *)v68 + 1521) = IOReportCreateSubscription();
        *((_QWORD *)v68 + 1511) = 0;
        *((_QWORD *)v68 + 1512) = 0;
        *((_QWORD *)v68 + 1514) = 0;
        *((_DWORD *)v68 + 3030) = 0;
        if (v18)
          CFRelease(v18);
      }
    }
    _Block_object_dispose(v29, 8);
    _Block_object_dispose(v33, 8);
    _Block_object_dispose(v37, 8);
    _Block_object_dispose(v41, 8);
  }
  if (*((_DWORD *)v68 + 21))
  {
    v8 = IONotificationPortCreate(*MEMORY[0x1E0CBBAA8]);
    *((_QWORD *)v68 + 22) = v8;
    if (*((_QWORD *)v68 + 22))
    {
      if (*((_QWORD *)v68 + 18))
      {
        IONotificationPortSetDispatchQueue(*((IONotificationPortRef *)v68 + 22), *((dispatch_queue_t *)v68 + 18));
        IOServiceAddInterestNotification(*((IONotificationPortRef *)v68 + 22), *((_DWORD *)v68 + 20), "IOGeneralInterest", (IOServiceInterestCallback)BacklightGeneralInterestNotificationCallback, v68, (io_object_t *)v68 + 46);
      }
    }
  }
  _DisplayReduceBacklightCompensation((uint64_t)v68, 1.0);
  return v65;
}

void sub_1B53E69E8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void __DisplaySetAAPFactor(_BYTE *a1, float a2)
{
  const __CFAllocator *v2;
  float v3;
  float v4;
  uint64_t inited;
  NSObject *v6;
  CFNumberRef property;
  int v8;
  CFNumberRef v9;
  os_log_type_t v10;
  os_log_t v11;
  int v12;
  int v13;
  float valuePtr;
  uint64_t v15;
  uint8_t v16[24];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v15 = (uint64_t)a1;
  valuePtr = a2;
  if ((a1[12248] & 1) != 0)
  {
    if (*(_DWORD *)(v15 + 108))
    {
      valuePtr = fminf(fmaxf(valuePtr, *(float *)(v15 + 12456)), *(float *)(v15 + 12460));
      v13 = (int)(float)(valuePtr * 1023.0);
      v12 = 0;
      v12 = (int)(float)(*(float *)(v15 + 12392) * 1023.0);
      if (v13 != v12 || *(float *)(v15 + 12468) >= 0.0)
      {
        v11 = 0;
        if (_logHandle)
        {
          v6 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            inited = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            inited = init_default_corebrightness_log();
          v6 = inited;
        }
        v11 = v6;
        v10 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          if (*(float *)(v15 + 12468) >= 0.0)
            v4 = *(float *)(v15 + 12468);
          else
            v4 = valuePtr;
          __os_log_helper_16_0_1_8_0((uint64_t)v16, COERCE__INT64(v4));
          _os_log_debug_impl(&dword_1B5291000, v11, v10, "AAP factor=%0.4f", v16, 0xCu);
        }
        *(float *)(v15 + 12392) = valuePtr;
        v9 = 0;
        v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &valuePtr);
        if (v9)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v15 + 192), CFSTR("DisplayAAPFactor"), v9);
          CFRelease(v9);
        }
        if (!-[CBAODState isAODActive](+[CBAODState sharedInstance](CBAODState, "sharedInstance"), "isAODActive"))
        {
          if ((*(_BYTE *)(v15 + 321) & 1) != 0 && (CBU_PassContrastEnhancerStrengthThroughSyncDBV() & 1) != 0)
          {
            SendSyncDBVNotification(v15, 0, (float)*(int *)(v15 + 1248) / 65536.0);
          }
          else
          {
            v8 = 0;
            if (*(float *)(v15 + 12468) >= 0.0)
              v3 = *(float *)(v15 + 12468);
            else
              v3 = *(float *)(v15 + 12392);
            v8 = (int)(float)(v3 * 65536.0);
            v2 = CFGetAllocator((CFTypeRef)v15);
            property = CFNumberCreate(v2, kCFNumberSInt32Type, &v8);
            if (property)
            {
              IORegistryEntrySetCFProperty(*(_DWORD *)(v15 + 108), CFSTR("IOMFBContrastEnhancerStrength"), property);
              CFRelease(property);
            }
          }
        }
      }
    }
  }
}

uint64_t _DisplayGetUint32FromCFNumberAndRelease(const void *a1, _DWORD *a2)
{
  CFTypeID v3;
  int valuePtr;
  char v5;
  _DWORD *v6;
  CFTypeRef v7;

  v7 = a1;
  v6 = a2;
  v5 = 0;
  if (a1)
  {
    v3 = CFGetTypeID(v7);
    if (v3 == CFNumberGetTypeID())
    {
      valuePtr = 0;
      if (CFNumberGetByteSize((CFNumberRef)v7) == 4)
      {
        CFNumberGetValue((CFNumberRef)v7, kCFNumberSInt32Type, &valuePtr);
        *v6 = valuePtr;
        v5 = 1;
      }
    }
    CFRelease(v7);
  }
  return v5 & 1;
}

void __DisplayStartAPLCPMSTimer(dispatch_object_t *a1, float a2)
{
  uint64_t inited;
  NSObject *v3;
  NSObject *log;
  os_log_type_t v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t v8[7];
  os_log_type_t type;
  os_log_t oslog;
  uint64_t block;
  int v12;
  int v13;
  void (*v14)(uint64_t);
  void *v15;
  dispatch_object_t *v16;
  dispatch_block_t v17;
  uint64_t v18;
  uint64_t v19;
  float v20;
  dispatch_object_t *v21;
  uint8_t v22[24];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v21 = a1;
  v20 = a2;
  if ((objc_msgSend(MEMORY[0x1E0D09930], "isCPMSSupported") & 1) == 1)
  {
    if (v21[1514] && v20 < *((float *)v21 + 3030))
    {
      dispatch_release(v21[1514]);
      v21[1514] = 0;
    }
    if (v21[1514])
    {
      if (_logHandle)
      {
        v3 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v3 = inited;
      }
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_1_8_32((uint64_t)v22, (uint64_t)"void __DisplayStartAPLCPMSTimer(DisplayRef, float)");
        _os_log_debug_impl(&dword_1B5291000, v3, OS_LOG_TYPE_DEBUG, "%s: Reusing current HDR Callback Timer\n", v22, 0xCu);
      }
    }
    else
    {
      *((float *)v21 + 3030) = v20;
      v21[1514] = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v21[18]);
      if (v21[1514])
      {
        v19 = 0;
        v18 = 0;
        v18 = (unint64_t)(float)(*((float *)v21 + 3030) * 1000000000.0);
        dispatch_source_set_timer(v21[1514], 0, v18, 0);
        if (((_BYTE)v21[20] & 1) != 0)
        {
          dispatch_set_context(v21[1514], v21);
          dispatch_source_set_event_handler_f(v21[1514], (dispatch_function_t)__DisplayCPMSHDRCallback);
        }
        else
        {
          v17 = 0;
          block = MEMORY[0x1E0C809B0];
          v12 = -1073741824;
          v13 = 0;
          v14 = ____DisplayStartAPLCPMSTimer_block_invoke;
          v15 = &__block_descriptor_40_e5_v8__0l;
          v16 = v21;
          v17 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, QOS_CLASS_DEFAULT, 0, &block);
          if (v17)
          {
            dispatch_source_set_event_handler(v21[1514], v17);
            _Block_release(v17);
          }
        }
        dispatch_resume(v21[1514]);
      }
      else
      {
        oslog = 0;
        if (_logHandle)
        {
          v7 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v6 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v6 = init_default_corebrightness_log();
          v7 = v6;
        }
        oslog = v7;
        type = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          log = oslog;
          v5 = type;
          __os_log_helper_16_0_0(v8);
          _os_log_error_impl(&dword_1B5291000, log, v5, "Could not create HDR Callback Timer\n", v8, 2u);
        }
      }
    }
  }
}

uint64_t __DisplayProcessHDRStatusForCoreAnalytics(uint64_t a1)
{
  return +[CBAnalytics hdrSession:](CBAnalytics, "hdrSession:", *(_BYTE *)(a1 + 12082) & 1);
}

void BacklightGeneralInterestNotificationCallback(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t inited;
  NSObject *v6;
  uint8_t v7[16];
  uint8_t v8[8];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a3 == -536870352)
    {
      *(_DWORD *)(a1 + 104) = 1;
      if (_logHandle)
      {
        v6 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v6 = inited;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_4_0((uint64_t)v8, -536870352);
        _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "Backlight ON: %x", v8, 8u);
      }
    }
    else if (a3 == -536870384)
    {
      *(_DWORD *)(a1 + 104) = 0;
      if (_logHandle)
      {
        v4 = _logHandle;
      }
      else
      {
        v3 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        v4 = v3;
      }
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_4_0((uint64_t)v7, -536870384);
        _os_log_debug_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEBUG, "Backlight OFF: %x", v7, 8u);
      }
    }
  }
}

void _DisplayReduceBacklightCompensation(uint64_t a1, float a2)
{
  CFAllocatorRef *v2;
  CFDictionaryRef cf;
  int v4;
  _DWORD valuePtr[2];
  uint64_t v6;
  void *keys[2];
  void *values;
  CFNumberRef v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v6 = a1;
  *(float *)&valuePtr[1] = a2;
  valuePtr[0] = (int)(float)(a2 * 65536.0);
  v4 = 0x20000;
  values = 0;
  v9 = 0;
  v2 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, valuePtr);
  v9 = CFNumberCreate(*v2, kCFNumberIntType, &v4);
  *(_OWORD *)keys = xmmword_1E68EB6E0;
  if (values)
  {
    if (v9)
    {
      cf = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (cf)
      {
        __DisplaySetBLDriverProperty(v6, CFSTR("CompensationTweak"), cf);
        CFRelease(cf);
      }
    }
  }
  if (values)
    CFRelease(values);
  if (v9)
    CFRelease(v9);
}

void DisplayClose(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 176))
  {
    IONotificationPortDestroy(*(IONotificationPortRef *)(a1 + 176));
    *(_QWORD *)(a1 + 176) = 0;
  }
  if (*(_DWORD *)(a1 + 184))
  {
    IOObjectRelease(*(_DWORD *)(a1 + 184));
    *(_DWORD *)(a1 + 184) = 0;
  }
}

void _DisplaySetLockState(uint64_t a1, int a2)
{
  NSObject *v2;
  void (*v3)(void);
  int v4;
  int v5;
  uint64_t (*v6)(uint64_t);
  void *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v2 = *(NSObject **)(a1 + 144);
  v3 = (void (*)(void))MEMORY[0x1E0C809B0];
  v4 = -1073741824;
  v5 = 0;
  v6 = ___DisplaySetLockState_block_invoke;
  v7 = &__block_descriptor_44_e5_v8__0l;
  v8 = v11;
  v9 = a2;
  disp_dispatch_sync(v2, &v3);
}

uint64_t DisplayGetProperty(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint64_t v4;
  void (*v5)(void);
  int v6;
  int v7;
  const void *(*v8)(uint64_t);
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = a1;
  v18 = a2;
  v13 = 0;
  v14 = &v13;
  v15 = 0x20000000;
  v16 = 32;
  v17 = 0;
  v2 = *(NSObject **)(a1 + 144);
  v5 = (void (*)(void))MEMORY[0x1E0C809B0];
  v6 = -1073741824;
  v7 = 0;
  v8 = __DisplayGetProperty_block_invoke;
  v9 = &unk_1E68EA390;
  v10 = &v13;
  v11 = v19;
  v12 = a2;
  disp_dispatch_sync(v2, &v5);
  v4 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1B53E78FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

float DisplayInitializeFastEDR(uint64_t a1)
{
  float result;

  *(_QWORD *)(a1 + 12608) = 0;
  result = 1.0;
  *(float *)(a1 + 12624) = 1.0;
  *(float *)(a1 + 12632) = 1.0;
  *(float *)(a1 + 12628) = 1.0;
  *(_QWORD *)(a1 + 12640) = 0;
  return result;
}

float DisplayInitializeRTPLCEDRRamp(uint64_t a1)
{
  float result;

  *(_QWORD *)(a1 + 12656) = 0;
  result = 1.0;
  *(float *)(a1 + 12672) = 1.0;
  *(float *)(a1 + 12680) = 1.0;
  *(float *)(a1 + 12676) = 1.0;
  *(_QWORD *)(a1 + 12688) = 0;
  *(_BYTE *)(a1 + 12704) = 0;
  return result;
}

uint64_t DisplayStartRTPLCEDRCapRamp(uint64_t a1, char a2, float a3, float a4, float a5)
{
  NSObject *v5;
  void (*v7)(void);
  int v8;
  int v9;
  void (*v10)(uint64_t);
  void *v11;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  char v16;
  char v17;
  float v18;
  float v19;
  float v20;
  uint64_t v21;

  v21 = a1;
  v20 = a3;
  v19 = a4;
  v18 = a5;
  v17 = a2 & 1;
  v5 = *(NSObject **)(a1 + 144);
  v7 = (void (*)(void))MEMORY[0x1E0C809B0];
  v8 = -1073741824;
  v9 = 0;
  v10 = __DisplayStartRTPLCEDRCapRamp_block_invoke;
  v11 = &__block_descriptor_53_e5_v8__0l;
  v16 = a2 & 1;
  v13 = a3;
  v12 = v21;
  v14 = a4;
  v15 = a5;
  disp_dispatch_sync(v5, &v7);
  return 1;
}

uint64_t __os_log_helper_16_2_8_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 8;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 62) = 0;
  *(_BYTE *)(result + 63) = 8;
  *(_QWORD *)(result + 64) = a8;
  *(_BYTE *)(result + 72) = 32;
  *(_BYTE *)(result + 73) = 8;
  *(_QWORD *)(result + 74) = a9;
  return result;
}

double __DisplayRTPLCEDRUpdateFade(uint64_t a1, uint64_t a2, double a3)
{
  float v3;
  double result;
  float v5;
  double v6;

  v6 = (a3 - *(double *)(a2 + 8)) / *(double *)a2;
  if (v6 >= 1.0)
  {
    *(_DWORD *)(a2 + 20) = *(_DWORD *)(a2 + 16);
    result = 0.0;
    *(_QWORD *)a2 = 0;
    *(_BYTE *)(a1 + 12704) = 0;
  }
  else
  {
    v3 = -v6;
    v5 = *(float *)(a2 + 24);
    *(float *)&result = v5 * powf(fabsf(v5 / *(float *)(a2 + 16)), v3);
    *(_DWORD *)(a2 + 20) = LODWORD(result);
  }
  return result;
}

float DisplayGetCurrentRTPLCHeadroomCap(uint64_t a1)
{
  NSObject *v1;
  float v3;
  void (*v4)(void);
  int v5;
  int v6;
  float (*v7)(uint64_t);
  void *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  int v13;
  int v14;
  float v15;
  uint64_t v16;

  v16 = a1;
  v11 = 0;
  v12 = (float *)&v11;
  v13 = 0x20000000;
  v14 = 32;
  v15 = 1.0;
  v1 = *(NSObject **)(a1 + 144);
  v4 = (void (*)(void))MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = __DisplayGetCurrentRTPLCHeadroomCap_block_invoke;
  v8 = &unk_1E68EB450;
  v9 = &v11;
  v10 = v16;
  disp_dispatch_sync(v1, &v4);
  v3 = v12[6];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1B53E80B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

double __DisplayFastEDRUpdateFade(double a1, uint64_t a2, uint64_t a3)
{
  float v3;
  double result;
  float v5;
  double v6;

  v6 = (a1 - *(double *)(a3 + 8)) / *(double *)a3;
  if (v6 >= 1.0)
  {
    *(_DWORD *)(a3 + 20) = *(_DWORD *)(a3 + 16);
    result = 0.0;
    *(_QWORD *)a3 = 0;
  }
  else
  {
    v3 = -v6;
    v5 = *(float *)(a3 + 24);
    *(float *)&result = v5 * powf(fabsf(v5 / *(float *)(a3 + 16)), v3);
    *(_DWORD *)(a3 + 20) = LODWORD(result);
  }
  return result;
}

void DisplayClockCapRamp(uint64_t a1)
{
  NSObject *v1;
  void (*v2)(void);
  int v3;
  int v4;
  void (*v5)(uint64_t, double);
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v8 = a1;
  v1 = *(NSObject **)(a1 + 144);
  v2 = (void (*)(void))MEMORY[0x1E0C809B0];
  v3 = -1073741824;
  v4 = 0;
  v5 = __DisplayClockCapRamp_block_invoke;
  v6 = &__block_descriptor_40_e5_v8__0l;
  v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

void DisplayStopCapRamp(uint64_t a1)
{
  NSObject *v1;
  void (*v2)(void);
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v8 = a1;
  v1 = *(NSObject **)(a1 + 144);
  v2 = (void (*)(void))MEMORY[0x1E0C809B0];
  v3 = -1073741824;
  v4 = 0;
  v5 = __DisplayStopCapRamp_block_invoke;
  v6 = &__block_descriptor_40_e5_v8__0l;
  v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

void DisplaySetDCPPowerAssertionForAOT(uint64_t a1, char a2)
{
  NSObject *v2;
  uint64_t v3;
  void (*v4)(void);
  int v5;
  int v6;
  void (*v7)(uint64_t);
  void *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD v11[2];
  int v12;
  int v13;
  uint64_t v14;
  char v15;
  uint64_t v16;

  v16 = a1;
  v15 = a2 & 1;
  v11[0] = 0;
  v11[1] = v11;
  v12 = 0x20000000;
  v13 = 32;
  v14 = 0;
  if ((a2 & 1) == 1)
    v3 = *MEMORY[0x1E0C9AE50];
  else
    v3 = *MEMORY[0x1E0C9AE40];
  v14 = v3;
  v2 = *(NSObject **)(v16 + 144);
  v4 = (void (*)(void))MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = __DisplaySetDCPPowerAssertionForAOT_block_invoke;
  v8 = &unk_1E68EB450;
  v10 = v16;
  v9 = v11;
  disp_dispatch_sync(v2, &v4);
  _Block_object_dispose(v11, 8);
}

void sub_1B53E8430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object)
{
  uint64_t v13;

  _Block_object_dispose((const void *)(v13 - 48), 8);
  _Unwind_Resume(a1);
}

float DisplaySliderToLogicalBrightness(uint64_t a1, float a2)
{
  NSObject *v2;
  float v4;
  void (*v5)(void);
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t);
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  float v12;
  uint64_t v13;
  float *v14;
  int v15;
  int v16;
  int v17;
  float v18;
  uint64_t v19;

  v19 = a1;
  v18 = a2;
  v13 = 0;
  v14 = (float *)&v13;
  v15 = 0x20000000;
  v16 = 32;
  v17 = 0;
  v2 = *(NSObject **)(a1 + 144);
  v5 = (void (*)(void))MEMORY[0x1E0C809B0];
  v6 = -1073741824;
  v7 = 0;
  v8 = __DisplaySliderToLogicalBrightness_block_invoke;
  v9 = &unk_1E68EB3F0;
  v10 = &v13;
  v11 = v19;
  v12 = a2;
  disp_dispatch_sync(v2, &v5);
  v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1B53E855C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

float DisplayLogicalToSliderBrightness(uint64_t a1, float a2)
{
  NSObject *v2;
  float v4;
  void (*v5)(void);
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t);
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  float v12;
  uint64_t v13;
  float *v14;
  int v15;
  int v16;
  int v17;
  float v18;
  uint64_t v19;

  v19 = a1;
  v18 = a2;
  v13 = 0;
  v14 = (float *)&v13;
  v15 = 0x20000000;
  v16 = 32;
  v17 = 0;
  v2 = *(NSObject **)(a1 + 144);
  v5 = (void (*)(void))MEMORY[0x1E0C809B0];
  v6 = -1073741824;
  v7 = 0;
  v8 = __DisplayLogicalToSliderBrightness_block_invoke;
  v9 = &unk_1E68EB3F0;
  v10 = &v13;
  v11 = v19;
  v12 = a2;
  disp_dispatch_sync(v2, &v5);
  v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1B53E8690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

void __ShortcutAllRamps(_BYTE *a1)
{
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v4;
  uint8_t v5[15];
  os_log_type_t v6;
  NSObject *v7;
  _BYTE *v8;

  v8 = a1;
  v7 = 0;
  if (_logHandle)
  {
    v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v4 = inited;
  }
  v7 = v4;
  v6 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    log = v7;
    type = v6;
    __os_log_helper_16_0_0(v5);
    _os_log_impl(&dword_1B5291000, log, type, "Display has been turned off, shortcutting all ramps", v5, 2u);
  }
  *((_QWORD *)v8 + 174) = 0;
  *((_QWORD *)v8 + 52) = 0;
  *((_QWORD *)v8 + 60) = 0;
  *((_QWORD *)v8 + 75) = 0;
  *((_QWORD *)v8 + 84) = 0;
  *((_QWORD *)v8 + 125) = 0;
  *((_QWORD *)v8 + 134) = 0;
  *((_QWORD *)v8 + 1620) = 0;
  *((_QWORD *)v8 + 168) = 0;
  *((_QWORD *)v8 + 181) = 0;
  *((_QWORD *)v8 + 1525) = 0;
  *((_QWORD *)v8 + 1577) = 0;
  *((_QWORD *)v8 + 1583) = 0;
  *((_QWORD *)v8 + 198) = 0;
  *((_QWORD *)v8 + 1551) = 0;
  *((_QWORD *)v8 + 106) = 0;
  __DisplayFadeCallback(v8);
}

void DisplaySetCabalFactorOverride(uint64_t a1, float a2)
{
  NSObject *v2;
  void (*v3)(void);
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  uint64_t v8;
  float v9;
  float v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v2 = *(NSObject **)(a1 + 144);
  v3 = (void (*)(void))MEMORY[0x1E0C809B0];
  v4 = -1073741824;
  v5 = 0;
  v6 = __DisplaySetCabalFactorOverride_block_invoke;
  v7 = &__block_descriptor_44_e5_v8__0l;
  v9 = a2;
  v8 = v11;
  disp_dispatch_sync(v2, &v3);
}

void _DisplaySetBrightnessWeakCapWithFade(_BYTE *a1, char a2, float a3, float a4)
{
  double v4;
  NSObject *v5;
  os_log_type_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  os_log_type_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t inited;
  NSObject *v22;
  uint8_t v23[15];
  os_log_type_t v24;
  os_log_t v25;
  os_log_type_t v26;
  os_log_t v27;
  os_log_type_t v28;
  os_log_t v29;
  float UpdateFrequency;
  float v31;
  os_log_type_t v32;
  os_log_t v33;
  os_log_type_t v34;
  os_log_t v35;
  uint8_t v36[15];
  os_log_type_t v37;
  os_log_t oslog;
  float v39;
  os_log_type_t type;
  os_log_t v41;
  char v42;
  float v43;
  float v44;
  _BYTE *v45;
  uint8_t v46[48];
  uint8_t v47[64];
  uint8_t v48[32];
  uint8_t v49[32];
  uint8_t v50[24];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v45 = a1;
  v44 = a3;
  v43 = a4;
  v42 = a2 & 1;
  if ((a1[380] & 1) != 0)
    v43 = *((float *)v45 + 94);
  v41 = 0;
  if (_logHandle)
  {
    v22 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v22 = inited;
  }
  v41 = v22;
  type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v50, COERCE__INT64(v44), COERCE__INT64(v43));
    _os_log_debug_impl(&dword_1B5291000, v41, type, "max: %f fadePeriod: %f", v50, 0x16u);
  }
  if ((v42 & 1) != 0)
  {
    *((float *)v45 + 131) = v44;
    *((float *)v45 + 130) = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v45, v44);
    if (*((float *)v45 + 87) < 1.0)
      v43 = 0.0;
  }
  else
  {
    v45[12080] = 1;
  }
  *((double *)v45 + 74) = v43;
  if (v43 == 0.0)
  {
    *((float *)v45 + 132) = v44;
    v39 = _DisplayLuminanceToPerceptualLuminanceInternal((uint64_t)v45, v44);
    *((float *)v45 + 153) = v39;
    *((float *)v45 + 154) = v39;
    *((float *)v45 + 152) = v39;
    __DisplaySetLogicalBrightnessInternal(v45, 12298, *((float *)v45 + 314));
    v45[584] = 1;
    oslog = 0;
    if (_logHandle)
    {
      v20 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v19 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v19 = init_default_corebrightness_log();
      v20 = v19;
    }
    oslog = v20;
    v37 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      v17 = oslog;
      v18 = v37;
      __os_log_helper_16_0_0(v36);
      _os_log_debug_impl(&dword_1B5291000, v17, v18, "Weak cap: user interacted\n", v36, 2u);
    }
    v35 = 0;
    if (_logHandle)
    {
      v16 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v15 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v15 = init_default_corebrightness_log();
      v16 = v15;
    }
    v35 = v16;
    v34 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v49, (uint64_t)"Weak Cap", COERCE__INT64(v44), COERCE__INT64(*((float *)v45 + 315)));
      _os_log_impl(&dword_1B5291000, v35, v34, "[BRT update: %s]: Weak cap: %f, nits = %f", v49, 0x20u);
    }
  }
  else
  {
    *((_QWORD *)v45 + 78) = 0;
    *((_QWORD *)v45 + 79) = 0;
    *((CFAbsoluteTime *)v45 + 75) = CFAbsoluteTimeGetCurrent();
    v33 = 0;
    if (_logHandle)
    {
      v14 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v13 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v13 = init_default_corebrightness_log();
      v14 = v13;
    }
    v33 = v14;
    v32 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v48, *((_QWORD *)v45 + 74), *((_QWORD *)v45 + 75), *((_QWORD *)v45 + 1560));
      _os_log_debug_impl(&dword_1B5291000, v33, v32, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v48, 0x20u);
    }
    v31 = 0.0;
    v31 = (float)(v44 - *((float *)v45 + 132)) / v43;
    UpdateFrequency = __DisplayGetUpdateFrequency((uint64_t)v45, v31);
    v29 = 0;
    if (_logHandle)
    {
      v12 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v11 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v11 = init_default_corebrightness_log();
      v12 = v11;
    }
    v29 = v12;
    v28 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_2_6_8_32_8_0_8_0_8_0_8_0_8_0((uint64_t)v47, (uint64_t)"Weak Cap", COERCE__INT64(*((float *)v45 + 132)), COERCE__INT64(v44), COERCE__INT64(v43), COERCE__INT64(v31), COERCE__INT64(UpdateFrequency));
      _os_log_impl(&dword_1B5291000, v29, v28, "[BRT update: %s]: weak cap begin ramp L: %0.2f -> L: %0.2f t: %f rate: %0.2f nits/s %0.2fhz", v47, 0x3Eu);
    }
    *((float *)v45 + 153) = _DisplayLuminanceToPerceptualLuminanceInternal((uint64_t)v45, *((float *)v45 + 132));
    *((_DWORD *)v45 + 154) = *((_DWORD *)v45 + 153);
    *((float *)v45 + 152) = _DisplayLuminanceToPerceptualLuminanceInternal((uint64_t)v45, v44);
    v27 = 0;
    if (_logHandle)
    {
      v10 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v9 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v9 = init_default_corebrightness_log();
      v10 = v9;
    }
    v27 = v10;
    v26 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v46, COERCE__INT64(*((float *)v45 + 132)), COERCE__INT64(v44), COERCE__INT64(*((float *)v45 + 154)), COERCE__INT64(*((float *)v45 + 152)));
      _os_log_debug_impl(&dword_1B5291000, v27, v26, "display->brightness.restriction.weakCap.Lcurrent=%f L=%f display->brightness.restriction.max.fade.Pstart=%f display->brightness.restriction.max.fade.Ptarget=%f\n", v46, 0x2Au);
    }
    *(float *)&v4 = 1.0 / UpdateFrequency;
    __DisplayStartFade(v45, v4);
    v45[584] = 1;
    v25 = 0;
    if (_logHandle)
    {
      v8 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v7 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v7 = init_default_corebrightness_log();
      v8 = v7;
    }
    v25 = v8;
    v24 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      v5 = v25;
      v6 = v24;
      __os_log_helper_16_0_0(v23);
      _os_log_debug_impl(&dword_1B5291000, v5, v6, "Weak cap: user interacted\n", v23, 2u);
    }
  }
}

void __DisplaySetBrightnessWithFade(uint64_t a1, int a2, float a3, float a4)
{
  uint64_t inited;
  NSObject *v5;
  float v6;
  float v7;
  float v10;
  uint8_t v12[24];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v10 = a3;
  *(float *)(a1 + 336) = a3;
  if (*(_DWORD *)(a1 + 36))
  {
    __DisplayUpdateAmbientProperties(a1, a3);
    v7 = __DisplayCalculateBrightnessAtAmbient((float *)a1, *(float *)(a1 + 1184));
    if (_logHandle)
    {
      v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v5 = inited;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v12, COERCE__INT64(v10));
      _os_log_debug_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEBUG, "User Brightness Level=%f\n", v12, 0xCu);
    }
    __DisplaySetLogicalBrightnessLegacy((float *)a1, 0, v7, 0.0);
  }
  else
  {
    if (a3 >= *(float *)(a1 + 340))
    {
      if (a3 > *(float *)(a1 + 344))
        v10 = *(float *)(a1 + 344);
    }
    else
    {
      v10 = *(float *)(a1 + 340);
    }
    v6 = _DisplaySliderToLogicalBrightnessInternal(a1, v10);
    _DisplaySetLogicalBrightnessWithFade(a1, a2, 0, 0, v6, a4);
  }
}

void __DisplayReportCommit(NSObject **a1, float a2)
{
  const __CFAllocator *v2;
  NSObject *v3;
  uint64_t block;
  int v5;
  int v6;
  void (*v7)(uint64_t);
  void *v8;
  NSObject **v9;
  CFDictionaryRef v10;
  CFDictionaryRef v11;
  float valuePtr;
  NSObject **v13;
  void *values;
  uint64_t v15;
  void *keys[2];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = a1;
  valuePtr = a2;
  *(_OWORD *)keys = xmmword_1E68EB768;
  values = 0;
  v15 = 0;
  values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &valuePtr);
  v15 = *MEMORY[0x1E0C9AE50];
  if (values)
  {
    v2 = CFGetAllocator(v13);
    v11 = CFDictionaryCreate(v2, (const void **)keys, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v11)
    {
      v3 = v13[18];
      block = MEMORY[0x1E0C809B0];
      v5 = -1073741824;
      v6 = 0;
      v7 = ____DisplayReportCommit_block_invoke;
      v8 = &__block_descriptor_48_e5_v8__0l;
      v9 = v13;
      v10 = v11;
      dispatch_async(v3, &block);
    }
  }
  if (values)
    CFRelease(values);
}

uint64_t __os_log_helper_16_2_5_8_32_8_0_8_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 5;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 4;
  *(_DWORD *)(result + 44) = a6;
  return result;
}

void _DisplaySetLogicalBrightnessWithFade(uint64_t a1, int a2, void (*a3)(uint64_t), uint64_t a4, float a5, float a6)
{
  float v6;
  BOOL v7;
  BOOL v8;
  uint64_t inited;
  NSObject *v10;
  uint8_t v17[24];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  *(float *)(a1 + 1252) = a5;
  *(double *)(a1 + 1336) = a6;
  if (_logHandle)
  {
    v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v10 = inited;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v17, COERCE__INT64(a5), COERCE__INT64(a6));
    _os_log_debug_impl(&dword_1B5291000, v10, OS_LOG_TYPE_DEBUG, "L=%f fadePeriod=%f\n", v17, 0x16u);
  }
  if (a6 == 0.0 || a5 == 0.0)
  {
    v8 = 0;
    if (*(double *)(a1 + 1384) != 0.0)
    {
      v8 = 0;
      if (*(float *)(a1 + 1400) > 0.0)
        v8 = *(float *)(a1 + 1400) < 1.0;
    }
    v7 = 0;
    if (*(double *)(a1 + 1384) == 0.0)
    {
      v7 = 0;
      if (*(float *)(a1 + 348) > 0.0)
        v7 = *(float *)(a1 + 348) < 1.0;
    }
    if (v8 || v7)
      *(float *)(a1 + 1256) = a5;
    else
      __DisplaySetLogicalBrightnessWithFadeInternal(a1, a2 | 0x1000, 0, 0, a5, 0.0);
    if (a3)
      a3(a4);
  }
  else if ((a2 & 0x10) != 0 && (_DisplayRampIsRunning(a1) & 1) != 0)
  {
    *(float *)(a1 + 1352) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1252));
  }
  else
  {
    v6 = *(double *)(a1 + 1336);
    __DisplaySetLogicalBrightnessWithFadeInternal(a1, a2, (uint64_t)a3, a4, *(float *)(a1 + 1252), v6);
  }
}

uint64_t __DisplayGetPowerAccumulator(uint64_t a1)
{
  uint64_t v2;
  const void *Samples;
  uint64_t v4;
  uint64_t *v5;
  int v6;
  int v7;
  unint64_t v8;
  uint64_t v9;

  v9 = a1;
  v4 = 0;
  v5 = &v4;
  v6 = 0x20000000;
  v7 = 32;
  v8 = 0x8000000000000000;
  if (*(_QWORD *)(a1 + 12144))
  {
    if (*(_QWORD *)(v9 + 12136))
    {
      Samples = (const void *)IOReportCreateSamples();
      if (Samples)
      {
        IOReportIterate();
        CFRelease(Samples);
      }
    }
  }
  v2 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v2;
}

uint64_t __DisplayGetPowerAccumulatorDCP(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *log;
  os_signpost_type_t type;
  os_signpost_id_t spid;
  uint64_t inited;
  NSObject *v10;
  const void *Samples;
  uint64_t v12;
  uint64_t *v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  int v19;
  int v20;
  unint64_t v21;
  uint8_t v22[8];
  unint64_t v23;
  char v24;
  NSObject *v25;
  _QWORD *v26;
  uint64_t v27;
  uint8_t v28[24];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v27 = a1;
  v26 = a2;
  v25 = 0;
  if (_logHandle)
  {
    v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v10 = inited;
  }
  v25 = v10;
  v24 = 1;
  v23 = 0xEEEEB0B5B2B2EEEELL;
  if (os_signpost_enabled(v10))
  {
    log = v25;
    type = v24;
    spid = v23;
    __os_log_helper_16_0_0(v22);
    _os_signpost_emit_with_name_impl(&dword_1B5291000, log, type, spid, "DisplayGetPowerAccumulatorDCP", (const char *)&unk_1B546AB41, v22, 2u);
  }
  v17 = 0;
  v18 = &v17;
  v19 = 0x20000000;
  v20 = 32;
  v21 = 0x8000000000000000;
  v12 = 0;
  v13 = &v12;
  v14 = 0x20000000;
  v15 = 32;
  v16 = 0;
  if (*(_QWORD *)(v27 + 12144))
  {
    if (*(_QWORD *)(v27 + 12136))
    {
      Samples = (const void *)IOReportCreateSamples();
      if (Samples)
      {
        IOReportIterate();
        CFRelease(Samples);
      }
    }
  }
  if (v26)
    *v26 = v13[3];
  if (_logHandle)
  {
    v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v4 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v4 = init_default_corebrightness_log();
    v5 = v4;
  }
  if (os_signpost_enabled(v5))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v28, v18[3]);
    _os_signpost_emit_with_name_impl(&dword_1B5291000, v5, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "DisplayGetPowerAccumulatorDCP", "power accumulator = %llu", v28, 0xCu);
  }
  v3 = v18[3];
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v17, 8);
  return v3;
}

void sub_1B53EA230()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void _DisplaySetBrightness(uint64_t a1, float a2)
{
  __DisplaySetBrightness(a1, 12288, a2);
}

void __DisplaySetBrightness(uint64_t a1, int a2, float a3)
{
  __DisplaySetBrightnessWithFade(a1, a2, a3, 0.0);
}

void _DisplaySetAdaptiveDimmingLimitWithFade(uint64_t a1, float a2, float a3)
{
  uint64_t (*v3)(uint64_t);
  double v4;
  uint64_t inited;
  NSObject *v6;
  CFAbsoluteTime Current;
  uint8_t v11[40];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(a1 + 888) = Current;
  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a3 = *(float *)(a1 + 376);
  *(_DWORD *)(a1 + 832) = *(_DWORD *)(a1 + 1260);
  v3 = 0;
  if (!*(_DWORD *)(a1 + 228))
    v3 = _DisplayAdaptiveDimmingLeftCallback;
  *(_QWORD *)(a1 + 872) = v3;
  *(_QWORD *)(a1 + 880) = a1;
  *(double *)(a1 + 840) = a3;
  *(CFAbsoluteTime *)(a1 + 848) = Current;
  if (_logHandle)
  {
    v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v6 = inited;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v11, COERCE__INT64(*(float *)(a1 + 1260)), COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "AutoDim begin ramp : %0.2f -> %0.2f t: %f", v11, 0x20u);
  }
  *(float *)(a1 + 860) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1260));
  *(_DWORD *)(a1 + 864) = *(_DWORD *)(a1 + 860);
  *(float *)(a1 + 856) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
  LODWORD(v4) = 1015580809;
  __DisplayStartFade((_BYTE *)a1, v4);
}

float __DisplayCalculateBrightnessAtAmbient(float *a1, float a2)
{
  uint64_t inited;
  NSObject *v4;
  float v5;
  float v6;
  uint8_t v8[56];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v6 = a2;
  if (a2 >= 0.0)
  {
    if (a2 > 1.0)
      v6 = 1.0;
  }
  else
  {
    v6 = 0.0;
  }
  v5 = a1[303] + (float)(a1[302] * v6);
  if (_logHandle)
  {
    v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v4 = inited;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v8, COERCE__INT64(v6), COERCE__INT64(a1[302]), COERCE__INT64(a1[303]), COERCE__INT64(a1[84]), COERCE__INT64(v5));
    _os_log_debug_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEBUG, "ambient=%f slope=%f intercept=%f user=%f brightness=%f\n", v8, 0x34u);
  }
  if (v5 > a1[86])
    return a1[86];
  if (v5 < a1[85])
    return a1[85];
  return v5;
}

void __DisplaySetLogicalBrightnessLegacy(float *a1, mach_port_t a2, float a3, double a4)
{
  float v4;
  float v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t inited;
  NSObject *v11;
  float v12;
  float v13;
  char v14;
  double v16;
  float v17;
  uint8_t v19[64];
  uint8_t v20[32];
  uint8_t v21[56];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v17 = a3;
  v16 = a4;
  v14 = 0;
  if (a3 >= a1[85])
  {
    if (a3 > a1[86])
      v17 = a1[86];
  }
  else
  {
    v17 = a1[85];
  }
  if (v17 <= a1[114])
  {
    if (v17 < a1[98])
      v17 = a1[98];
  }
  else
  {
    v17 = a1[114];
  }
  if (a4 == -1.0)
  {
    v4 = fabs((float)(a1[88] - v17));
    v13 = v4;
    v16 = (float)(a1[306] + (float)(a1[305] * v4));
    if (_logHandle)
    {
      v11 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v11 = inited;
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v21, COERCE__INT64(a1[305]), COERCE__INT64(a1[306]), COERCE__INT64((float)(v13 * 64.0)), *(uint64_t *)&v16, COERCE__INT64(v16 / (float)(v13 * 64.0)));
      _os_log_debug_impl(&dword_1B5291000, v11, OS_LOG_TYPE_DEBUG, "slope=%f intercept=%f delta=%f fadePeriod=%f steptime=%f\n", v21, 0x34u);
    }
    if (v16 <= 0.0)
      v16 = -1.0;
    v14 = 1;
  }
  if (_logHandle)
  {
    v9 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v8 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v8 = init_default_corebrightness_log();
    v9 = v8;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_4_0((uint64_t)v20, COERCE__INT64(v17), *(uint64_t *)&v16, (a2 & 1) != 0);
    _os_log_debug_impl(&dword_1B5291000, v9, OS_LOG_TYPE_DEBUG, "brightness=%f fadePeriod=%f block=%d\n", v20, 0x1Cu);
  }
  if (!v14 || a1[87] == 1.0)
  {
    a1[88] = v17;
    __DisplaySetPhysicalBrightnessLegacy(a1, a2, v17, v16);
  }
  else
  {
    v5 = (float)(a1[88] * a1[87]) + 0.01;
    v12 = v5;
    if (v17 >= v5)
      a1[89] = v17;
    else
      a1[89] = v5;
    if (_logHandle)
    {
      v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v6 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v6 = init_default_corebrightness_log();
      v7 = v6;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v19, COERCE__INT64(a1[88]), COERCE__INT64(a1[87]), COERCE__INT64(a1[89]), COERCE__INT64(v17), COERCE__INT64(v12));
      _os_log_debug_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEBUG, "logical=%f factor=%f pending=%f brightness=%f minPendingBrightness=%f\n", v19, 0x34u);
    }
  }
}

uint64_t setClientOverrideState(uint64_t result, char a2, char a3)
{
  *(_BYTE *)(result + 960) = *(_BYTE *)(result + 960) & ~(1 << a2) | ((a3 & 1) << a2);
  return result;
}

uint64_t evaluateClientOverrides(uint64_t a1)
{
  BOOL v2;
  BOOL ClientOverrideState;

  ClientOverrideState = getClientOverrideState(a1, 0);
  v2 = getClientOverrideState(a1, 1);
  if (ClientOverrideState)
  {
    if (*(float *)(a1 + 964) >= *(float *)(a1 + 400))
      return 0;
    else
      return 2;
  }
  else if (v2)
  {
    return 1;
  }
  else
  {
    return 3;
  }
}

void _DisplaySetBrightnessMinPhysicalWithFade(uint64_t a1, float a2, float a3)
{
  double v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t inited;
  NSObject *v15;
  float UpdateFrequency;
  float v17;
  float v18;
  float v19;
  uint8_t v23[48];
  uint8_t v24[64];
  uint8_t v25[64];
  uint8_t v26[32];
  uint8_t v27[32];
  uint8_t v28[24];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a3 = *(float *)(a1 + 376);
  v19 = fmaxf(a2, *(float *)(a1 + 1320));
  if (_logHandle)
  {
    v15 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v15 = inited;
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v28, COERCE__INT64(v19), COERCE__INT64(a3));
    _os_log_impl(&dword_1B5291000, v15, OS_LOG_TYPE_DEFAULT, "min: %f fadePeriod: %f", v28, 0x16u);
  }
  if (v19 != *(float *)(a1 + 396))
  {
    *(float *)(a1 + 396) = v19;
    *(float *)(a1 + 392) = _DisplayLogicalToSliderBrightnessInternal(a1, v19);
    *(double *)(a1 + 408) = a3;
    if (a3 == 0.0)
    {
      *(float *)(a1 + 400) = v19;
      if (*(_DWORD *)(a1 + 36))
      {
        _DisplaySetAmbient(a1, 0, *(float *)(a1 + 1184));
      }
      else
      {
        v18 = _DisplayLuminanceToPerceptualLuminanceInternal(a1, v19);
        *(float *)(a1 + 428) = v18;
        *(float *)(a1 + 432) = v18;
        *(float *)(a1 + 424) = v18;
        __DisplaySetLogicalBrightnessInternal((const void *)a1, 12290, *(float *)(a1 + 1256));
        if (_logHandle)
        {
          v13 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v12 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v12 = init_default_corebrightness_log();
          v13 = v12;
        }
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v27, (uint64_t)"Min cap", COERCE__INT64(a2), COERCE__INT64(*(float *)(a1 + 1260)));
          _os_log_impl(&dword_1B5291000, v13, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: Min brightness: %f, nits = %f", v27, 0x20u);
        }
      }
    }
    else
    {
      *(_QWORD *)(a1 + 440) = 0;
      *(_QWORD *)(a1 + 448) = 0;
      *(CFAbsoluteTime *)(a1 + 416) = CFAbsoluteTimeGetCurrent();
      if (_logHandle)
      {
        v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v10 = init_default_corebrightness_log();
        v11 = v10;
      }
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v26, *(_QWORD *)(a1 + 408), *(_QWORD *)(a1 + 416), *(_QWORD *)(a1 + 12480));
        _os_log_debug_impl(&dword_1B5291000, v11, OS_LOG_TYPE_DEBUG, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v26, 0x20u);
      }
      v17 = (float)(v19 - *(float *)(a1 + 400)) / a3;
      UpdateFrequency = __DisplayGetUpdateFrequency(a1, v17);
      if (_logHandle)
      {
        v9 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v8 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v8 = init_default_corebrightness_log();
        v9 = v8;
      }
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v25, COERCE__INT64(*(float *)(a1 + 400)), COERCE__INT64(v19), COERCE__INT64(a3), COERCE__INT64(v17), COERCE__INT64(UpdateFrequency));
        _os_log_debug_impl(&dword_1B5291000, v9, OS_LOG_TYPE_DEBUG, "MIN begin ramp L: %0.2f -> L: %0.2f t: %f rate: %0.2f nits/s %0.2fhz", v25, 0x34u);
      }
      if (_logHandle)
      {
        v7 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v6 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v6 = init_default_corebrightness_log();
        v7 = v6;
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_6_8_32_8_0_8_0_8_0_8_0_8_0((uint64_t)v24, (uint64_t)"Min cap", COERCE__INT64(*(float *)(a1 + 400)), COERCE__INT64(v19), COERCE__INT64(a3), COERCE__INT64(v17), COERCE__INT64(UpdateFrequency));
        _os_log_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: MIN begin ramp L: %0.2f -> L: %0.2f t: %f rate: %0.2f nits/s %0.2fhz", v24, 0x3Eu);
      }
      *(float *)(a1 + 428) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 400));
      *(_DWORD *)(a1 + 432) = *(_DWORD *)(a1 + 428);
      *(float *)(a1 + 424) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, v19);
      if (_logHandle)
      {
        v5 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v4 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v4 = init_default_corebrightness_log();
        v5 = v4;
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v23, COERCE__INT64(*(float *)(a1 + 400)), COERCE__INT64(v19), COERCE__INT64(*(float *)(a1 + 432)), COERCE__INT64(*(float *)(a1 + 424)));
        _os_log_debug_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEBUG, "display->brightness.restriction.min.Lcurrent=%f L=%f display->brightness.restriction.min.fade.Pstart=%f display->brightness.restriction.min.fade.Ptarget=%f\n", v23, 0x2Au);
      }
      *(float *)&v3 = 1.0 / UpdateFrequency;
      __DisplayStartFade((_BYTE *)a1, v3);
    }
  }
}

void _DisplaySetAmbient(uint64_t a1, char a2, float a3)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t inited;
  NSObject *v6;
  float v7;
  uint8_t v10[16];
  uint8_t v11[24];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a3 >= 0.0 && a3 <= 1.0)
  {
    if (*(float *)(a1 + 348) == 1.0)
    {
      if (a2)
        *(_DWORD *)(a1 + 1220) = *(_DWORD *)(a1 + 1228);
      else
        *(float *)(a1 + 1220) = 1.5;
      *(_DWORD *)(a1 + 1224) = 0;
    }
    *(float *)(a1 + 1184) = a3;
    if (_logHandle)
    {
      v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v6 = inited;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_2_8_0_8_0((uint64_t)v11, COERCE__INT64(*(float *)(a1 + 1220)), COERCE__INT64(*(float *)(a1 + 1224)));
      _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "ALS: slope=%f intercept=%f \n", v11, 0x16u);
    }
    v7 = __DisplayCalculateBrightnessAtAmbient((float *)a1, a3);
    if (_logHandle)
    {
      v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v3 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v3 = init_default_corebrightness_log();
      v4 = v3;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v10, COERCE__INT64(v7));
      _os_log_debug_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEBUG, "Brightness For Ambient Level=%f\n", v10, 0xCu);
    }
    __DisplaySetLogicalBrightnessLegacy((float *)a1, 2u, v7, -1.0);
  }
}

void _DisplaySetBrightnessEcoModeFactorWithFade(uint64_t a1, float a2, float a3)
{
  float v3;
  double v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t inited;
  NSObject *v12;
  uint8_t v16[32];
  uint8_t v17[48];
  uint8_t v18[32];
  uint8_t v19[24];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a3 = *(float *)(a1 + 376);
  if (_logHandle)
  {
    v12 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v12 = inited;
  }
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v19, COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_debug_impl(&dword_1B5291000, v12, OS_LOG_TYPE_DEBUG, "factor: %f fadePeriod: %f", v19, 0x16u);
  }
  if (a2 != *(float *)(a1 + 648))
  {
    if (a3 == 0.0)
    {
      *(float *)(a1 + 648) = a2;
      *(float *)(a1 + 684) = a2;
      *(float *)(a1 + 688) = a2;
      *(float *)(a1 + 680) = a2;
      *(_QWORD *)(a1 + 664) = 0;
      v3 = 0.5 * (float)(*(float *)(a1 + 648) - 0.8) / 0.199999988 + 0.5;
      _DisplayReduceBacklightCompensation(a1, v3);
      __DisplaySetLogicalBrightnessWithFadeInternal(a1, 12288, 0, 0, *(float *)(a1 + 1252), 0.0);
    }
    else
    {
      *(_QWORD *)(a1 + 704) = 0;
      *(_QWORD *)(a1 + 712) = 0;
      *(double *)(a1 + 664) = a3;
      *(CFAbsoluteTime *)(a1 + 672) = CFAbsoluteTimeGetCurrent();
      if (_logHandle)
      {
        v10 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v9 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v9 = init_default_corebrightness_log();
        v10 = v9;
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v18, *(_QWORD *)(a1 + 664), *(_QWORD *)(a1 + 672), *(_QWORD *)(a1 + 12480));
        _os_log_debug_impl(&dword_1B5291000, v10, OS_LOG_TYPE_DEBUG, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v18, 0x20u);
      }
      if (_logHandle)
      {
        v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v7 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v7 = init_default_corebrightness_log();
        v8 = v7;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v17, COERCE__INT64(*(float *)(a1 + 648)), COERCE__INT64(a2), COERCE__INT64(a3), 0x404E000000000000);
        _os_log_debug_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEBUG, "EcoModeFactor begin ramp Factor: %0.2f -> Factor: %0.2f t: %f rate: %0.2fhz", v17, 0x2Au);
      }
      *(_DWORD *)(a1 + 684) = *(_DWORD *)(a1 + 648);
      *(_DWORD *)(a1 + 688) = *(_DWORD *)(a1 + 648);
      *(float *)(a1 + 680) = a2;
      LODWORD(v4) = 1015580809;
      __DisplayStartFade((_BYTE *)a1, v4);
    }
  }
  if (_logHandle)
  {
    v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v5 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v5 = init_default_corebrightness_log();
    v6 = v5;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v16, (uint64_t)"Eco Mode", COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: factor = %f, fadePeriod = %f", v16, 0x20u);
  }
}

void _DisplaySetBrightnessEcoModeLimitWithFade(uint64_t a1, float a2, float a3)
{
  double v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t inited;
  NSObject *v7;
  uint8_t v11[32];
  uint8_t v12[56];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a3 = *(float *)(a1 + 376);
  *(_DWORD *)(a1 + 780) = *(_DWORD *)(a1 + 1260);
  *(_QWORD *)(a1 + 816) = 0;
  *(_QWORD *)(a1 + 824) = 0;
  *(double *)(a1 + 784) = a3;
  *(CFAbsoluteTime *)(a1 + 792) = CFAbsoluteTimeGetCurrent();
  if (_logHandle)
  {
    v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v7 = inited;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v12, COERCE__INT64(*(float *)(a1 + 1260)), COERCE__INT64(a2), COERCE__INT64(a3), 0x404E000000000000);
    _os_log_debug_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEBUG, "EcoModeLimit begin ramp : %0.2f -> %0.2f t: %f rate: %0.2fhz", v12, 0x2Au);
  }
  *(float *)(a1 + 804) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1260));
  *(_DWORD *)(a1 + 808) = *(_DWORD *)(a1 + 804);
  *(float *)(a1 + 800) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
  LODWORD(v3) = 1015580809;
  __DisplayStartFade((_BYTE *)a1, v3);
  if (_logHandle)
  {
    v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v4 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v4 = init_default_corebrightness_log();
    v5 = v4;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v11, (uint64_t)"Eco Mode", COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: target = %f, fadePeriod = %f", v11, 0x20u);
  }
}

void _DisplaySetBrightnessDominoModeLimitWithFade(uint64_t a1, float a2, float a3)
{
  double v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t inited;
  NSObject *v7;
  uint8_t v11[32];
  uint8_t v12[56];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 760) = 0;
  *(_QWORD *)(a1 + 768) = 0;
  *(double *)(a1 + 728) = a3;
  *(CFAbsoluteTime *)(a1 + 736) = CFAbsoluteTimeGetCurrent();
  if (_logHandle)
  {
    v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v7 = inited;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v12, COERCE__INT64(*(float *)(a1 + 724)), COERCE__INT64(a2), COERCE__INT64(a3), 0x404E000000000000);
    _os_log_debug_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEBUG, "DominoModeLimit begin ramp : %0.2f -> %0.2f t: %f rate: %0.2fhz", v12, 0x2Au);
  }
  *(float *)(a1 + 748) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 724));
  *(_DWORD *)(a1 + 752) = *(_DWORD *)(a1 + 748);
  *(float *)(a1 + 744) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
  LODWORD(v3) = 1015580809;
  __DisplayStartFade((_BYTE *)a1, v3);
  if (_logHandle)
  {
    v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v4 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v4 = init_default_corebrightness_log();
    v5 = v4;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v11, (uint64_t)"Domino Mode", COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: target = %f, fadePeriod = %f", v11, 0x20u);
  }
}

double __DisplayCancelFactorFade(uint64_t a1)
{
  double result;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v5;
  uint8_t v6[15];
  char v7;
  NSObject *v8;
  uint64_t v9;

  v9 = a1;
  if ((_DisplayRampIsRunning(a1) & 1) != 0)
  {
    v8 = 0;
    if (_logHandle)
    {
      v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v5 = inited;
    }
    v8 = v5;
    v7 = 2;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      log = v8;
      type = v7;
      __os_log_helper_16_0_0(v6);
      _os_log_debug_impl(&dword_1B5291000, log, type, "cancel factor ramp", v6, 2u);
    }
    *(_DWORD *)(v9 + 88) = 0;
    if (*(_QWORD *)(v9 + 1424))
      (*(void (**)(_QWORD))(v9 + 1424))(*(_QWORD *)(v9 + 1376));
    result = 0.0;
    *(_QWORD *)(v9 + 1384) = 0;
  }
  return result;
}

void _DisplayUpdateWeakCapOnFactorChange(uint64_t a1, float a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  NSObject *v6;
  os_log_type_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t inited;
  NSObject *v11;
  float v12;
  uint8_t v13[15];
  os_log_type_t v14;
  os_log_t oslog;
  double v16;
  char v17;
  os_log_type_t v18;
  os_log_t v19;
  float v20;
  float v21;
  double v22;
  double v23;
  double Current;
  float v25;
  uint64_t v26;
  uint8_t v27[24];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v26 = a1;
  v25 = a2;
  if (*(float *)(a1 + 348) < 1.0 && v25 == 1.0)
  {
    if (*(float *)(v26 + 524) < *(float *)(v26 + 1312) && *(float *)(v26 + 528) > *(float *)(v26 + 524))
    {
      Current = CFAbsoluteTimeGetCurrent();
      v23 = 0.0;
      v2 = Current - *(double *)(v26 + 536) - *(double *)(v26 + 544);
      v23 = fmaxf(v2, 0.0);
      v22 = 0.0;
      v22 = *(double *)(v26 + 552) - *(double *)(v26 + 544);
      v3 = v23;
      v4 = v22;
      v23 = fminf(v3, v4);
      v5 = v23 / v22;
      v21 = v5 * (float)(*(float *)(v26 + 528) - *(float *)(v26 + 524));
      *(float *)(v26 + 528) = *(float *)(v26 + 528) - v21;
      *(_QWORD *)(v26 + 592) = 0;
      v20 = 0.0;
      v20 = _DisplayLuminanceToPerceptualLuminanceInternal(v26, *(float *)(v26 + 528));
      *(float *)(v26 + 612) = v20;
      *(float *)(v26 + 616) = v20;
      *(float *)(v26 + 608) = v20;
      v19 = 0;
      if (_logHandle)
      {
        v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v11 = inited;
      }
      v19 = v11;
      v18 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v27, COERCE__INT64(*(float *)(v26 + 528)));
        _os_log_debug_impl(&dword_1B5291000, v19, v18, "Display: Update weak cap to %f on factor change", v27, 0xCu);
      }
      *(double *)(v26 + 576) = Current;
    }
  }
  else if (*(float *)(v26 + 348) == 1.0 && v25 < 1.0)
  {
    v17 = 0;
    v17 = *(_BYTE *)(v26 + 584) & 1;
    v16 = CFAbsoluteTimeGetCurrent();
    if (v16 - *(double *)(v26 + 576) > *(double *)(v26 + 560))
      v17 = 1;
    if ((v17 & 1) != 0)
    {
      *(double *)(v26 + 536) = v16;
      *(_BYTE *)(v26 + 584) = 0;
      oslog = 0;
      if (_logHandle)
      {
        v9 = _logHandle;
      }
      else
      {
        v8 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        v9 = v8;
      }
      oslog = v9;
      v14 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        v6 = oslog;
        v7 = v14;
        __os_log_helper_16_0_0(v13);
        _os_log_debug_impl(&dword_1B5291000, v6, v7, "Weak cap: Resetting timer\n", v13, 2u);
      }
    }
    if (*(float *)(v26 + 524) < *(float *)(v26 + 1312))
    {
      *(_QWORD *)(v26 + 592) = 0;
      v12 = _DisplayLuminanceToPerceptualLuminanceInternal(v26, *(float *)(v26 + 528));
      *(float *)(v26 + 612) = v12;
      *(float *)(v26 + 616) = v12;
      *(float *)(v26 + 608) = v12;
    }
  }
}

void _DisplaySetBrightnessFactor(uint64_t a1, float a2)
{
  NSObject *v2;
  NSObject *v3;
  int v4;
  NSObject *v5;
  int v6;
  int v7;
  NSObject *v8;
  os_log_type_t v9;
  uint64_t v10;
  NSObject *v11;
  __CFDictionary *theDict;
  uint64_t inited;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t (*v20)(uint64_t);
  void *v21;
  uint64_t v22;
  uint8_t v23[15];
  os_log_type_t v24;
  os_log_t oslog;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t (*v29)(uint64_t);
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t block;
  int v35;
  int v36;
  uint64_t (*v37)(uint64_t);
  void *v38;
  uint64_t v39;
  os_log_type_t v40;
  os_log_t v41;
  CFNumberRef v42;
  double v43;
  void *v44;
  os_log_type_t v45;
  os_log_t v46;
  CFNumberRef v47;
  double v48;
  int v49;
  float v50;
  uint64_t v51;
  uint8_t v52[16];
  uint8_t v53[24];
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v51 = a1;
  v50 = a2;
  v49 = a2 > 0.0;
  if (*(_DWORD *)(a1 + 44) != v49)
  {
    if (*(_DWORD *)(v51 + 44) || v49 != 1)
    {
      if (*(_DWORD *)(v51 + 44) == 1 && !v49)
      {
        if (*(_QWORD *)(v51 + 328)
          && (objc_msgSend(*(id *)(v51 + 328), "isActive") & 1) != 0
          && !objc_msgSend(*(id *)(v51 + 328), "action:", 0))
        {
          v44 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", 0);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v51 + 192), CFSTR("CBSoftWakeActive"), v44);

        }
        v43 = 0.0;
        v43 = (double)mach_absolute_time() * *(double *)(v51 + 56);
        v42 = 0;
        v42 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &v43);
        if (v42)
        {
          if (*(_QWORD *)(v51 + 192))
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(v51 + 192), CFSTR("EventTimestampDisplayOff"), v42);
          v41 = 0;
          if (_logHandle)
          {
            v14 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              inited = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              inited = init_default_corebrightness_log();
            v14 = inited;
          }
          v41 = v14;
          v40 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            __os_log_helper_16_0_1_8_0((uint64_t)v52, *(uint64_t *)&v43);
            _os_log_impl(&dword_1B5291000, v41, v40, "ts=%f Setting kCBEventTimestampDisplayOffKey", v52, 0xCu);
          }
          CFRelease(v42);
        }
        _DisplayResetAdaptiveDimming(v51);
      }
    }
    else
    {
      v48 = 0.0;
      v48 = (double)mach_absolute_time() * *(double *)(v51 + 56);
      v47 = 0;
      v47 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &v48);
      if (v47)
      {
        if (*(_QWORD *)(v51 + 192))
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v51 + 192), CFSTR("EventTimestampDisplayOn"), v47);
        v46 = 0;
        if (_logHandle)
        {
          v16 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v15 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v15 = init_default_corebrightness_log();
          v16 = v15;
        }
        v46 = v16;
        v45 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v53, *(uint64_t *)&v48);
          _os_log_impl(&dword_1B5291000, v46, v45, "ts=%f Setting kCBEventTimestampDisplayOnKey", v53, 0xCu);
        }
        CFRelease(v47);
      }
      if ((DisplayHasDCP(v51) & 1) != 0 && *(_DWORD *)(v51 + 108))
      {
        __memset_chk();
        *(_DWORD *)(v51 + 12732) = 0;
        *(_DWORD *)(v51 + 12728) = 0;
        *(float *)(v51 + 12940) = -1.0;
      }
    }
    *(_DWORD *)(v51 + 44) = v49;
    if (*(_QWORD *)(v51 + 144))
    {
      v2 = *(NSObject **)(v51 + 144);
      block = MEMORY[0x1E0C809B0];
      v35 = -1073741824;
      v36 = 0;
      v37 = ___DisplaySetBrightnessFactor_block_invoke;
      v38 = &__block_descriptor_40_e5_v8__0l;
      v39 = v51;
      dispatch_async(v2, &block);
    }
    if (*(_QWORD *)(v51 + 192))
    {
      theDict = *(__CFDictionary **)(v51 + 192);
      if (*(_DWORD *)(v51 + 44))
        CFDictionarySetValue(theDict, CFSTR("DisplayOn"), (const void *)*MEMORY[0x1E0C9AE50]);
      else
        CFDictionarySetValue(theDict, CFSTR("DisplayOn"), (const void *)*MEMORY[0x1E0C9AE40]);
    }
    v33 = v49;
    v3 = *(NSObject **)(v51 + 168);
    v26 = MEMORY[0x1E0C809B0];
    v27 = -1073741824;
    v28 = 0;
    v29 = ___DisplaySetBrightnessFactor_block_invoke_2;
    v30 = &__block_descriptor_48_e5_v8__0l;
    v31 = v51;
    v32 = v49;
    dispatch_async(v3, &v26);
  }
  if (*(float *)(v51 + 348) == 0.0 && v50 > 0.0)
    __DisplayInitializeReport(v51);
  *(float *)(v51 + 348) = v50;
  if (*(float *)(v51 + 348) == 0.0)
  {
    if ((*(_BYTE *)(v51 + 232) & 1) != 0)
    {
      oslog = 0;
      if (_logHandle)
      {
        v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v10 = init_default_corebrightness_log();
        v11 = v10;
      }
      oslog = v11;
      v24 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v8 = oslog;
        v9 = v24;
        __os_log_helper_16_0_0(v23);
        _os_log_debug_impl(&dword_1B5291000, v8, v9, "Pre-strobe OFF (display off) \n", v23, 2u);
      }
      *(_BYTE *)(v51 + 232) = 0;
    }
    if (!getClientOverrideState(v51, 1))
    {
      *(_DWORD *)(v51 + 392) = 0;
      v4 = *(_DWORD *)(v51 + 1320);
      *(_DWORD *)(v51 + 396) = v4;
      *(_DWORD *)(v51 + 400) = v4;
    }
    if (*(_DWORD *)(v51 + 32))
    {
      if (*(float *)(v51 + 1204) > 0.0)
      {
        *(_DWORD *)(v51 + 1252) = *(_DWORD *)(v51 + 1320);
        *(_DWORD *)(v51 + 1492) = *(_DWORD *)(v51 + 1320);
      }
    }
    *(_BYTE *)(v51 + 12522) = 0;
    v5 = *(NSObject **)(v51 + 144);
    v17 = MEMORY[0x1E0C809B0];
    v18 = -1073741824;
    v19 = 0;
    v20 = ___DisplaySetBrightnessFactor_block_invoke_528;
    v21 = &__block_descriptor_40_e5_v8__0l;
    v22 = v51;
    dispatch_async(v5, &v17);
    v6 = *(_DWORD *)(v51 + 1080);
    *(_DWORD *)(v51 + 1084) = v6;
    *(_DWORD *)(v51 + 1056) = v6;
    *(_QWORD *)(v51 + 1064) = 0;
    v7 = *(_DWORD *)(v51 + 1008);
    *(_DWORD *)(v51 + 1012) = v7;
    *(_DWORD *)(v51 + 984) = v7;
    *(_QWORD *)(v51 + 992) = 0;
    __DisplayCommitReport(v51, 1);
  }
}

float __DisplayCalculateBrightnessFromFactorChange(uint64_t a1, int a2)
{
  uint64_t inited;
  NSObject *v4;
  uint8_t v8[24];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (_logHandle)
  {
    v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v4 = inited;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v8, COERCE__INT64(*(float *)(a1 + 348)), COERCE__INT64(*(float *)(a1 + 356)));
    _os_log_debug_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEBUG, "Brightness factor=%f pending=%f\n", v8, 0x16u);
  }
  if (*(float *)(a1 + 348) == 1.0 && *(float *)(a1 + 356) != 0.0)
    *(_DWORD *)(a1 + 352) = *(_DWORD *)(a1 + 356);
  if (a2)
    return *(float *)(a1 + 352);
  else
    return __DisplayCalculateBrightnessAtAmbient((float *)a1, *(float *)(a1 + 1184));
}

double __DisplayCancelReflectedBrightnessFadeInternal(uint64_t a1)
{
  double result;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v5;
  uint8_t v6[15];
  char v7;
  NSObject *v8;
  uint64_t v9;

  v9 = a1;
  if ((*(_BYTE *)(a1 + 12248) & 1) != 0 && (_DisplayRampIsRunning(v9) & 1) != 0)
  {
    v8 = 0;
    if (_logHandle)
    {
      v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v5 = inited;
    }
    v8 = v5;
    v7 = 2;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      log = v8;
      type = v7;
      __os_log_helper_16_0_0(v6);
      _os_log_debug_impl(&dword_1B5291000, log, type, "cancel AAP ramp", v6, 2u);
    }
    if ((*(_BYTE *)(v9 + 12282) & 1) == 0)
      __DisplayUpdateAAPFactor(v9);
    if (*(_QWORD *)(v9 + 1608))
      (*(void (**)(_QWORD))(v9 + 1608))(*(_QWORD *)(v9 + 1616));
    result = 0.0;
    *(_QWORD *)(v9 + 1576) = 0;
  }
  return result;
}

double __DisplayCancelAAPFade(_BYTE *a1)
{
  double result;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v5;
  uint8_t v6[15];
  char v7;
  NSObject *v8;
  _BYTE *v9;

  v9 = a1;
  if ((a1[12248] & 1) != 0 && (_DisplayRampIsRunning((uint64_t)v9) & 1) != 0)
  {
    v8 = 0;
    if (_logHandle)
    {
      v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v5 = inited;
    }
    v8 = v5;
    v7 = 2;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      log = v8;
      type = v7;
      __os_log_helper_16_0_0(v6);
      _os_log_debug_impl(&dword_1B5291000, log, type, "cancel AAP ramp", v6, 2u);
    }
    __DisplaySetAAPFactor(v9, 0.0);
    if (*((_QWORD *)v9 + 1555))
      (*((void (**)(_QWORD))v9 + 1555))(*((_QWORD *)v9 + 1556));
    result = 0.0;
    *((_QWORD *)v9 + 1550) = 0;
  }
  return result;
}

void __DisplaySetLogicalBrightnessWithFadeInternal(uint64_t a1, int a2, uint64_t a3, uint64_t a4, float a5, float a6)
{
  uint64_t v6;
  NSObject *v7;
  uint64_t inited;
  NSObject *v9;
  float UpdateFrequency;
  float v11;
  float v12;
  uint8_t v17[80];
  uint8_t v18[40];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a6 = *(float *)(a1 + 376);
  if (a6 == 0.0)
  {
    v12 = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1256));
    *(_QWORD *)(a1 + 1336) = 0;
    *(float *)(a1 + 1356) = v12;
    *(float *)(a1 + 1360) = v12;
    *(float *)(a1 + 1352) = v12;
    __DisplaySetLogicalBrightnessInternal((const void *)a1, a2 | 0x1000, a5);
  }
  else
  {
    *(_DWORD *)(a1 + 1328) = a2;
    *(_QWORD *)(a1 + 1368) = a3;
    *(_QWORD *)(a1 + 1376) = a4;
    *(CFAbsoluteTime *)(a1 + 1344) = CFAbsoluteTimeGetCurrent();
    *(double *)(a1 + 1336) = a6;
    if (_logHandle)
    {
      v9 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v9 = inited;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v18, *(_QWORD *)(a1 + 1336), *(_QWORD *)(a1 + 1344), *(_QWORD *)(a1 + 12480));
      _os_log_impl(&dword_1B5291000, v9, OS_LOG_TYPE_DEFAULT, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v18, 0x20u);
    }
    v11 = (float)(a5 - *(float *)(a1 + 1256)) / a6;
    UpdateFrequency = __DisplayGetUpdateFrequency(a1, v11);
    *(float *)(a1 + 1356) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1256));
    *(_DWORD *)(a1 + 1360) = *(_DWORD *)(a1 + 1356);
    *(float *)(a1 + 1352) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a5);
    if (_logHandle)
    {
      v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v6 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v6 = init_default_corebrightness_log();
      v7 = v6;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v17, COERCE__INT64(*(float *)(a1 + 1256)), COERCE__INT64(a5), COERCE__INT64(*(float *)(a1 + 1360)), COERCE__INT64(*(float *)(a1 + 1352)), COERCE__INT64(a6), COERCE__INT64(v11), COERCE__INT64(UpdateFrequency));
      _os_log_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEFAULT, "begin ramping L: %0.2f -> L: %0.2f Brightness: %f -> %f t: %f rate: %0.2f nits/s %0.2fhz", v17, 0x48u);
    }
    if ((a2 & 0x80u) != 0)
      UpdateFrequency = 120.0;
    __DisplayStartFade(a1, 1.0 / UpdateFrequency);
  }
}

void _DisplaySetFactorWithFade(uint64_t a1, float a2, float a3)
{
  double v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t inited;
  NSObject *v9;
  int v10;
  float v11;
  uint8_t v15[48];
  uint8_t v16[32];
  uint8_t v17[24];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a3 = *(float *)(a1 + 376);
  if (_logHandle)
  {
    v9 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v9 = inited;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v17, COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_impl(&dword_1B5291000, v9, OS_LOG_TYPE_DEFAULT, "factor: %f fadePeriod: %f", v17, 0x16u);
  }
  if (a2 != *(float *)(a1 + 348) || *(double *)(a1 + 1384) > 0.0)
  {
    if ((*(_BYTE *)(a1 + 12282) & 1) == 0)
      *(_DWORD *)(a1 + 12392) = 0;
    *(_QWORD *)(a1 + 96) = 0;
    if (a3 == 0.0)
    {
      _DisplaySetBrightnessFactor(a1, a2);
      *(float *)(a1 + 1404) = a2;
      *(float *)(a1 + 1408) = a2;
      *(float *)(a1 + 1400) = a2;
      *(_QWORD *)(a1 + 1384) = 0;
      v11 = *(float *)(a1 + 1252);
      *(_DWORD *)(a1 + 1488) = *(_DWORD *)(a1 + 1492);
      v10 = 4098;
      if (*(float *)(a1 + 348) == 1.0)
        v10 = 4106;
      __DisplaySetLogicalBrightnessWithFadeInternal(a1, v10 | 0x2000, 0, 0, v11, 0.0);
    }
    else
    {
      *(_QWORD *)(a1 + 1424) = 0;
      *(_QWORD *)(a1 + 1432) = 0;
      *(double *)(a1 + 1384) = a3;
      *(CFAbsoluteTime *)(a1 + 1392) = CFAbsoluteTimeGetCurrent();
      if (_logHandle)
      {
        v7 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v6 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v6 = init_default_corebrightness_log();
        v7 = v6;
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v16, *(_QWORD *)(a1 + 1384), *(_QWORD *)(a1 + 1392), *(_QWORD *)(a1 + 12480));
        _os_log_debug_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEBUG, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v16, 0x20u);
      }
      if (_logHandle)
      {
        v5 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v4 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v4 = init_default_corebrightness_log();
        v5 = v4;
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v15, COERCE__INT64(*(float *)(a1 + 348)), COERCE__INT64(a2), COERCE__INT64(a3), COERCE__INT64(60.0));
        _os_log_debug_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEBUG, "FACTOR begin ramp Factor: %0.2f -> Factor: %0.2f t: %f rate: %0.2fhz", v15, 0x2Au);
      }
      *(_DWORD *)(a1 + 1404) = *(_DWORD *)(a1 + 348);
      *(_DWORD *)(a1 + 1408) = *(_DWORD *)(a1 + 348);
      *(float *)(a1 + 1400) = a2;
      *(float *)&v3 = 1.0 / 60.0;
      __DisplayStartFade((_BYTE *)a1, v3);
    }
  }
}

void __DisplaySendPLCUpdate(uint64_t a1, char a2)
{
  const void *v2;
  char v3;

  v3 = a2 & 1;
  if ((a2 & 1) != 0)
    v2 = (const void *)*MEMORY[0x1E0C9AE50];
  else
    v2 = (const void *)*MEMORY[0x1E0C9AE40];
  if ((a2 & 1) == 1)
  {
    if (*(_QWORD *)(a1 + 16))
      (*(void (**)(_QWORD, const __CFString *, const void *))(a1 + 16))(*(_QWORD *)(a1 + 24), CFSTR("nitsExceedsPLCThreshold"), v2);
    if (*(_DWORD *)(a1 + 108))
      IORegistryEntrySetCFProperty(*(_DWORD *)(a1 + 108), CFSTR("enablePLCMode"), v2);
    __DisplaySetBLDriverProperty(a1, CFSTR("plc-update"), v2);
  }
  else
  {
    __DisplaySetBLDriverProperty(a1, CFSTR("plc-update"), v2);
    if (*(_DWORD *)(a1 + 108))
      IORegistryEntrySetCFProperty(*(_DWORD *)(a1 + 108), CFSTR("enablePLCMode"), v2);
    if (*(_QWORD *)(a1 + 16))
      (*(void (**)(_QWORD, const __CFString *, const void *))(a1 + 16))(*(_QWORD *)(a1 + 24), CFSTR("nitsExceedsPLCThreshold"), v2);
  }
  *(_BYTE *)(a1 + 289) = v3 & 1;
}

void _DisplaySetBrightnessMaxPhysicalZeroWithFade(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  double v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t inited;
  NSObject *v11;
  float UpdateFrequency;
  float v13;
  uint8_t v19[48];
  uint8_t v20[64];
  uint8_t v21[40];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a5 = *(float *)(a1 + 376);
  *(float *)(a1 + 460) = a4;
  *(float *)(a1 + 456) = _DisplayLogicalToSliderBrightnessInternal(a1, a4);
  *(double *)(a1 + 472) = a5;
  *(_QWORD *)(a1 + 504) = a2;
  *(_QWORD *)(a1 + 512) = a3;
  *(CFAbsoluteTime *)(a1 + 480) = CFAbsoluteTimeGetCurrent();
  if (_logHandle)
  {
    v11 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v11 = inited;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v21, *(_QWORD *)(a1 + 472), *(_QWORD *)(a1 + 480), *(_QWORD *)(a1 + 12480));
    _os_log_debug_impl(&dword_1B5291000, v11, OS_LOG_TYPE_DEBUG, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v21, 0x20u);
  }
  v13 = (float)(a4 - *(float *)(a1 + 464)) / a5;
  UpdateFrequency = __DisplayGetUpdateFrequency(a1, v13);
  if (_logHandle)
  {
    v9 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v8 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v8 = init_default_corebrightness_log();
    v9 = v8;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_2_6_8_32_8_0_8_0_8_0_8_0_8_0((uint64_t)v20, (uint64_t)"Max cap", COERCE__INT64(*(float *)(a1 + 464)), COERCE__INT64(a4), COERCE__INT64(a5), COERCE__INT64(v13), COERCE__INT64(UpdateFrequency));
    _os_log_impl(&dword_1B5291000, v9, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: MAX begin ramp L: %0.2f -> L: %0.2f t: %f rate: %0.2f nits/s %0.2fhz", v20, 0x3Eu);
  }
  *(float *)(a1 + 492) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 464));
  *(_DWORD *)(a1 + 496) = *(_DWORD *)(a1 + 492);
  *(float *)(a1 + 488) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a4);
  if (_logHandle)
  {
    v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v6 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v6 = init_default_corebrightness_log();
    v7 = v6;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v19, COERCE__INT64(*(float *)(a1 + 464)), COERCE__INT64(*(float *)(a1 + 460)), COERCE__INT64(*(float *)(a1 + 496)), COERCE__INT64(*(float *)(a1 + 488)));
    _os_log_debug_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEBUG, "display->brightness.restriction.max.Lcurrent=%f L=%f display->brightness.restriction.max.fade.Pstart=%f display->brightness.restriction.max.fade.Ptarget=%f\n", v19, 0x2Au);
  }
  *(float *)&v5 = 1.0 / UpdateFrequency;
  __DisplayStartFade((_BYTE *)a1, v5);
}

void _DisplayRampDoneCallback(uint64_t a1)
{
  if (a1)
  {
    if (_DisplayCLTMRev2Applicable(a1))
    {
      *(_DWORD *)(a1 + 464) = 0;
      SetBLDriverNitsValueIfNotInLPM(a1, 0);
    }
  }
}

void SetPreStrobeState(_BYTE *a1, char a2)
{
  const __CFAllocator *v2;
  NSObject *v3;
  uint64_t inited;
  NSObject *v5;
  uint64_t block;
  int v7;
  int v8;
  void (*v9)(uint64_t);
  void *v10;
  _BYTE *v11;
  char v12;
  os_log_type_t v13;
  os_log_t v14;
  CFNumberRef v15;
  int valuePtr;
  int v17;
  char v18;
  _BYTE *v19;
  uint8_t v20[24];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v19 = a1;
  v18 = a2 & 1;
  if ((a1[232] & 1) != (a2 & 1))
  {
    v17 = 0;
    if ((v18 & 1) != 0)
    {
      *((_DWORD *)v19 + 59) = *((_DWORD *)v19 + 35);
      v17 = 44236800;
      if (*((int *)v19 + 64) > 0)
      {
        v17 = *((_DWORD *)v19 + 64);
        if (*((int *)v19 + 63) > 0)
        {
          if (*((_DWORD *)v19 + 64) < *((_DWORD *)v19 + 63))
            v17 = 44236800;
          else
            v17 = *((_DWORD *)v19 + 63);
        }
      }
    }
    else
    {
      v17 = *((_DWORD *)v19 + 59);
    }
    v19[232] = v18 & 1;
    if ((DisplayHasDCP((uint64_t)v19) & 1) != 0 && *((_DWORD *)v19 + 27))
    {
      valuePtr = 0;
      valuePtr = *((_DWORD *)v19 + 378);
      if ((v18 & 1) != 0 && v17 > valuePtr)
        valuePtr = v17;
      v2 = CFGetAllocator(v19);
      v15 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
      if (v15)
      {
        if ((v19[321] & 1) == 0)
          IORegistryEntrySetCFProperty(*((_DWORD *)v19 + 27), CFSTR("BLNitsCap"), v15);
        *((float *)v19 + 60) = (float)valuePtr / 65536.0;
        CFRelease(v15);
      }
      v14 = 0;
      if (_logHandle)
      {
        v5 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v5 = inited;
      }
      v14 = v5;
      v13 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v20, COERCE__INT64((float)valuePtr / 65536.0), COERCE__INT64((float)v17 / 65536.0));
        _os_log_debug_impl(&dword_1B5291000, v14, v13, "Pre-strobe: setting Cap=%f and Nits=%f \n", v20, 0x16u);
      }
    }
    if ((v19[1516] & 1) != 0)
    {
      v3 = *((_QWORD *)v19 + 18);
      block = MEMORY[0x1E0C809B0];
      v7 = -1073741824;
      v8 = 0;
      v9 = __SetPreStrobeState_block_invoke;
      v10 = &__block_descriptor_41_e5_v8__0l;
      v11 = v19;
      v12 = v18 & 1;
      dispatch_async(v3, &block);
    }
    SetIOMFBBrightness(v19, v17, 1);
  }
}

float _DisplayGetGlobalScalarFromDictionary(uint64_t a1, io_registry_entry_t a2, const __CFDictionary *a3)
{
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  CFTypeID v7;
  CFTypeID TypeID;
  int valuePtr;
  CFTypeRef cf;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float v15;
  float v16;
  CFDictionaryRef v17;
  io_registry_entry_t v18;
  uint64_t v19;

  v19 = a1;
  v18 = a2;
  v17 = a3;
  v16 = -1.0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 1.0;
  v11 = 1;
  if (!a1 || !v18 || !v17)
    return _DisplayGetGlobalScalarFromDevice(v19, v18);
  cf = CFDictionaryGetValue(v17, CFSTR("enable"));
  if (cf)
  {
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(cf))
    {
      valuePtr = 1;
      CFNumberGetValue((CFNumberRef)cf, kCFNumberIntType, &valuePtr);
      v11 = valuePtr != 0;
    }
  }
  if (v11)
  {
    if ((_DisplayGetGlobalScalarDisplayParams(v18, (float *)&v12, (float *)&v12 + 1) & 1) == 0)
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    cf = CFDictionaryGetValue(v17, CFSTR("I_nominal"));
    if (!cf)
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    v7 = CFNumberGetTypeID();
    if (v7 != CFGetTypeID(cf))
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, &v13);
    cf = CFDictionaryGetValue(v17, CFSTR("I_threshold"));
    if (!cf)
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    v6 = CFNumberGetTypeID();
    if (v6 != CFGetTypeID(cf))
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, (char *)&v13 + 4);
    cf = CFDictionaryGetValue(v17, CFSTR("B_min"));
    if (!cf)
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    v5 = CFNumberGetTypeID();
    if (v5 != CFGetTypeID(cf))
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, &v14);
    cf = CFDictionaryGetValue(v17, CFSTR("Slope"));
    if (!cf)
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    v4 = CFNumberGetTypeID();
    if (v4 != CFGetTypeID(cf))
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, (char *)&v14 + 4);
    return _DisplayCalculateGlobalScalar(v19, (float *)&v12);
  }
  else
  {
    v16 = 1.0;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v19 + 192), CFSTR("BrightnessGlobalScalar"), CFSTR("disabled"));
    return v16;
  }
}

void DisplayEnableFullBrightnessRangeAccessOverride(uint64_t a1, char a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  os_log_type_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v19;
  float v20;
  unint64_t j;
  uint64_t v22;
  unsigned int v23;
  uint8_t v24[15];
  char v25;
  NSObject *v26;
  os_log_type_t v27;
  os_log_t v28;
  float v29;
  float v30;
  float v31;
  unint64_t i;
  uint64_t v33;
  unsigned int v34;
  uint8_t v35[7];
  char v36;
  NSObject *v37;
  char v38;
  uint64_t v39;
  uint8_t v40[32];
  uint8_t v41[40];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v39 = a1;
  v38 = a2 & 1;
  if ((a2 & 1) != 0)
  {
    if ((*(_BYTE *)(v39 + 1548) & 1) == 0)
    {
      v37 = 0;
      if (_logHandle)
      {
        v19 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v19 = inited;
      }
      v37 = v19;
      v36 = 2;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        log = v37;
        type = v36;
        __os_log_helper_16_0_0(v35);
        _os_log_debug_impl(&dword_1B5291000, log, type, "DisplayEnableFullBrightnessRangeAccessOverride: Enable", v35, 2u);
      }
      v2 = *(_DWORD *)(v39 + 1544);
      *(_DWORD *)(v39 + 1312) = v2;
      *(_DWORD *)(v39 + 1300) = v2;
      v34 = 0;
      v34 = *(_DWORD *)(v39 + 64);
      v33 = 0;
      v33 = *(_QWORD *)(v39 + 72);
      if ((*(_BYTE *)(v39 + 1517) & 1) != 0)
      {
        for (i = v34 / 2; i < v34; ++i)
        {
          v31 = 0.0;
          v31 = *(float *)(v39 + 1544);
          v30 = 1.0;
          v29 = 0.0;
          v29 = (float)((float)((float)(i - v34 / 2) / (float)(v34 - 1 - v34 / 2))
                      * (float)((float)(*(float *)(v39 + 1536) / v31) - 1.0))
              + 1.0;
          if (v29 > 0.0)
            *(float *)(v33 + 4 * i) = *(float *)(v33 + 4 * i) / v29;
          v28 = 0;
          if (_logHandle)
          {
            v15 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v14 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v14 = init_default_corebrightness_log();
            v15 = v14;
          }
          v28 = v15;
          v27 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v41, i, COERCE__INT64(*(float *)(v33 + 4 * i)), COERCE__INT64(v29));
            _os_log_debug_impl(&dword_1B5291000, v28, v27, "Rescaled marketing table %ld: %f (factor %f)", v41, 0x20u);
          }
        }
      }
      v3 = *(_DWORD *)(v39 + 1312);
      *(_DWORD *)(v39 + 460) = v3;
      *(_DWORD *)(v39 + 464) = v3;
      v4 = *(_DWORD *)(v39 + 1312);
      *(_DWORD *)(v39 + 460) = v4;
      *(_DWORD *)(v39 + 528) = v4;
      *(_BYTE *)(v39 + 1548) = 1;
    }
  }
  else if ((*(_BYTE *)(v39 + 1548) & 1) != 0)
  {
    v26 = 0;
    if (_logHandle)
    {
      v13 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v12 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v12 = init_default_corebrightness_log();
      v13 = v12;
    }
    v26 = v13;
    v25 = 2;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v10 = v26;
      v11 = v25;
      __os_log_helper_16_0_0(v24);
      _os_log_debug_impl(&dword_1B5291000, v10, v11, "DisplayEnableFullBrightnessRangeAccessOverride: Disable", v24, 2u);
    }
    v5 = *(_DWORD *)(v39 + 1536);
    *(_DWORD *)(v39 + 1312) = v5;
    *(_DWORD *)(v39 + 1300) = v5;
    v23 = *(_DWORD *)(v39 + 64);
    v22 = *(_QWORD *)(v39 + 72);
    if ((*(_BYTE *)(v39 + 1517) & 1) != 0)
    {
      for (j = v23 / 2; j < v23; ++j)
      {
        v20 = (float)((float)((float)(j - v23 / 2) / (float)(v23 - 1 - v23 / 2))
                    * (float)((float)(*(float *)(v39 + 1536) / *(float *)(v39 + 1544)) - 1.0))
            + 1.0;
        *(float *)(v22 + 4 * j) = *(float *)(v22 + 4 * j) * v20;
        if (_logHandle)
        {
          v9 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v8 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v8 = init_default_corebrightness_log();
          v9 = v8;
        }
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v40, j, COERCE__INT64(*(float *)(v22 + 4 * j)), COERCE__INT64(v20));
          _os_log_debug_impl(&dword_1B5291000, v9, OS_LOG_TYPE_DEBUG, "Rescaled marketing table %ld: %f (factor %f)", v40, 0x20u);
        }
      }
    }
    v6 = *(_DWORD *)(v39 + 1312);
    *(_DWORD *)(v39 + 460) = v6;
    *(_DWORD *)(v39 + 464) = v6;
    v7 = *(_DWORD *)(v39 + 1312);
    *(_DWORD *)(v39 + 460) = v7;
    *(_DWORD *)(v39 + 528) = v7;
    *(_BYTE *)(v39 + 1548) = 0;
  }
}

void _DisplaySetAuroraFactorWithFade(uint64_t a1, float a2, float a3)
{
  double v3;
  double Current;
  void *context;
  uint64_t inited;
  NSObject *v7;
  char v8;
  uint8_t v12[24];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a3 = *(float *)(a1 + 376);
  v8 = 0;
  if (_logHandle)
  {
    v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v7 = inited;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v12, COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_debug_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEBUG, "factor: %f fadePeriod: %f", v12, 0x16u);
  }
  if ((*(_BYTE *)(a1 + 13008) & 1) != 0)
  {
    v8 = 1;
    a3 = 0.0;
  }
  if (a3 == 0.0)
  {
    *(float *)(a1 + 12944) = a2;
    *(float *)(a1 + 12972) = a2;
    *(float *)(a1 + 12976) = a2;
    *(float *)(a1 + 12968) = a2;
    *(_QWORD *)(a1 + 12952) = 0;
    if (*(_QWORD *)(a1 + 16))
    {
      context = (void *)MEMORY[0x1B5E4A8B0]();
      *(float *)&v3 = a2;
      (*(void (**)(_QWORD, const __CFString *, uint64_t))(a1 + 16))(*(_QWORD *)(a1 + 24), CFSTR("AuroraFactor"), objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v3));
      (*(void (**)(_QWORD, const __CFString *, _QWORD))(a1 + 16))(*(_QWORD *)(a1 + 24), CFSTR("AuroraRampInProgress"), *MEMORY[0x1E0C9AE40]);
      objc_autoreleasePoolPop(context);
    }
    if ((v8 & 1) == 0 && (_DisplayRampIsRunning(a1) & 1) == 0)
      __DisplaySetLogicalBrightnessWithFadeInternal(a1, 12288, 0, 0, *(float *)(a1 + 1252), 0.0);
  }
  else
  {
    *(_QWORD *)(a1 + 12992) = 0;
    *(_QWORD *)(a1 + 13000) = 0;
    *(double *)(a1 + 12952) = a3;
    Current = CFAbsoluteTimeGetCurrent();
    *(double *)(a1 + 12960) = Current;
    *(_DWORD *)(a1 + 12972) = *(_DWORD *)(a1 + 12944);
    *(_DWORD *)(a1 + 12976) = *(_DWORD *)(a1 + 12944);
    *(float *)(a1 + 12968) = a2;
    LODWORD(Current) = 1015580809;
    __DisplayStartFade((_BYTE *)a1, Current);
  }
}

uint64_t _DisplayRampIsRunning(uint64_t a1)
{
  int v2;
  char v3;

  v3 = 1;
  if (!*(_QWORD *)(a1 + 12480))
  {
    LOBYTE(v2) = 0;
    if ((*(_BYTE *)(a1 + 321) & 1) != 0)
      v2 = objc_msgSend(*(id *)(a1 + 208), "isPaused") ^ 1;
    v3 = v2;
  }
  return v3 & 1;
}

float _DisplayGetAmbient(uint64_t a1)
{
  return *(float *)(a1 + 1184);
}

float _DisplayGetBrightness(uint64_t a1)
{
  NSObject *v1;
  float v3;
  void (*v4)(void);
  int v5;
  int v6;
  float (*v7)(uint64_t);
  void *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;

  v16 = a1;
  v11 = 0;
  v12 = (float *)&v11;
  v13 = 0x20000000;
  v14 = 32;
  v15 = 0;
  v1 = *(NSObject **)(a1 + 144);
  v4 = (void (*)(void))MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = ___DisplayGetBrightness_block_invoke;
  v8 = &unk_1E68EB450;
  v9 = &v11;
  v10 = v16;
  disp_dispatch_sync(v1, &v4);
  v3 = v12[6];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1B53EFE90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

float _DisplayResetAdaptiveDimming(uint64_t a1)
{
  float result;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v5;
  uint8_t v6[15];
  char v7;
  NSObject *v8;
  uint64_t v9;

  v9 = a1;
  v8 = 0;
  if (_logHandle)
  {
    v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v5 = inited;
  }
  v8 = v5;
  v7 = 2;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    log = v8;
    type = v7;
    __os_log_helper_16_0_0(v6);
    _os_log_debug_impl(&dword_1B5291000, log, type, "Display powering off; reset AutoDim state", v6, 2u);
  }
  *(_DWORD *)(v9 + 228) = 0;
  result = 100.0;
  *(_DWORD *)(v9 + 832) = 1120403456;
  return result;
}

uint64_t __DisplayCommitReport(uint64_t result, char a2)
{
  float v2;
  float v3;
  double v4;
  CFNumberRef value;
  CFNumberRef valuea;
  __CFDictionary *theDict;
  float v8;
  float valuePtr;
  _BYTE v10[944];
  double v11;
  double v12;
  double v13;
  char v14;
  uint64_t v15;

  v15 = result;
  v14 = a2;
  if ((*(_BYTE *)(result + 12520) & 1) != 0 || (*(_BYTE *)(v15 + 12514) & 1) != 0)
  {
    if (v14)
      result = __DisplayResetLogTimer(v15, 1);
    if (*(_QWORD *)(v15 + 12504))
    {
      bzero(v10, 0x200uLL);
      CFXGetReport(*(_QWORD *)(v15 + 12504), (uint64_t)v10);
      v2 = v12 / v11;
      valuePtr = v2;
      v3 = v13 / v11;
      v8 = v3;
      valuePtr = fmaxf(fminf(v2, *(float *)(v15 + 1312)), *(float *)(v15 + 1320));
      v8 = fmaxf(fminf(v3, *(float *)(v15 + 1312)), *(float *)(v15 + 1320));
      theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 10, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (theDict)
      {
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &valuePtr);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("AvgBacklightNits"), value);
          CFRelease(value);
        }
        valuea = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v8);
        if (valuea)
        {
          CFDictionaryAddValue(theDict, CFSTR("AvgLogicalBrightnessNits"), valuea);
          CFRelease(valuea);
        }
        if (*(_QWORD *)(v15 + 16))
          (*(void (**)(_QWORD, const __CFString *, __CFDictionary *))(v15 + 16))(*(_QWORD *)(v15 + 24), CFSTR("PowerLogReport"), theDict);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(v15 + 192), CFSTR("PowerLogReport"), theDict);
        CFRelease(theDict);
      }
      return __DisplayReportToCA(v15, (uint64_t)v10, v4);
    }
  }
  return result;
}

float _DisplayGetBrightnessFactor(uint64_t a1)
{
  NSObject *v1;
  float v3;
  void (*v4)(void);
  int v5;
  int v6;
  float (*v7)(uint64_t);
  void *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;

  v16 = a1;
  v11 = 0;
  v12 = (float *)&v11;
  v13 = 0x20000000;
  v14 = 32;
  v15 = 0;
  v1 = *(NSObject **)(a1 + 144);
  v4 = (void (*)(void))MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = ___DisplayGetBrightnessFactor_block_invoke;
  v8 = &unk_1E68EB450;
  v9 = &v11;
  v10 = v16;
  disp_dispatch_sync(v1, &v4);
  v3 = v12[6];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1B53F04B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

void DisplaySetAuroraFactorWithFade(uint64_t a1, float a2, float a3)
{
  NSObject *v3;
  void (*v4)(void);
  int v5;
  int v6;
  void (*v7)(uint64_t);
  void *v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v3 = *(NSObject **)(a1 + 144);
  v4 = (void (*)(void))MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = __DisplaySetAuroraFactorWithFade_block_invoke;
  v8 = &__block_descriptor_48_e5_v8__0l;
  v9 = v14;
  v10 = a2;
  v11 = a3;
  disp_dispatch_sync(v3, &v4);
}

float DisplayGetRestrictionFactorForNits(uint64_t a1, char a2, float a3)
{
  NSObject *v3;
  float v5;
  void (*v6)(void);
  int v7;
  int v8;
  float (*v9)(uint64_t);
  void *v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  float *v15;
  int v16;
  int v17;
  int v18;
  char v19;
  float v20;
  uint64_t v21;

  v21 = a1;
  v20 = a3;
  v19 = a2 & 1;
  v14 = 0;
  v15 = (float *)&v14;
  v16 = 0x20000000;
  v17 = 32;
  v18 = 0;
  v3 = *(NSObject **)(a1 + 144);
  v6 = (void (*)(void))MEMORY[0x1E0C809B0];
  v7 = -1073741824;
  v8 = 0;
  v9 = __DisplayGetRestrictionFactorForNits_block_invoke;
  v10 = &unk_1E68EB568;
  v11 = &v14;
  v13 = a2 & 1;
  v12 = v21;
  disp_dispatch_sync(v3, &v6);
  v5 = v20 / v15[6];
  _Block_object_dispose(&v14, 8);
  return v5;
}

void sub_1B53F0698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

float _DisplayGetBrightnessMaxPhysical(uint64_t a1)
{
  NSObject *v1;
  float v3;
  void (*v4)(void);
  int v5;
  int v6;
  float (*v7)(uint64_t);
  void *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;

  v16 = a1;
  v11 = 0;
  v12 = (float *)&v11;
  v13 = 0x20000000;
  v14 = 32;
  v15 = 0;
  v1 = *(NSObject **)(a1 + 144);
  v4 = (void (*)(void))MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = ___DisplayGetBrightnessMaxPhysical_block_invoke;
  v8 = &unk_1E68EB450;
  v9 = &v11;
  v10 = v16;
  disp_dispatch_sync(v1, &v4);
  v3 = v12[6];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1B53F07D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

float DisplayGetBrightnessMaxPhysical(uint64_t a1)
{
  return *(float *)(a1 + 464);
}

float DisplayGetWeakCap(uint64_t a1)
{
  NSObject *v1;
  float v3;
  void (*v4)(void);
  int v5;
  int v6;
  void (*v7)(uint64_t);
  void *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;

  v16 = a1;
  v11 = 0;
  v12 = (float *)&v11;
  v13 = 0x20000000;
  v14 = 32;
  v15 = 0;
  v1 = *(NSObject **)(a1 + 144);
  v4 = (void (*)(void))MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = __DisplayGetWeakCap_block_invoke;
  v8 = &unk_1E68EB450;
  v9 = &v11;
  v10 = v16;
  disp_dispatch_sync(v1, &v4);
  v3 = v12[6];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1B53F08F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

void DisplayUpdateWeakCapOnSignificantAmbientChange(uint64_t a1)
{
  NSObject *v1;
  void (*v2)(void);
  int v3;
  int v4;
  void (*v5)(uint64_t);
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v8 = a1;
  v1 = *(NSObject **)(a1 + 144);
  v2 = (void (*)(void))MEMORY[0x1E0C809B0];
  v3 = -1073741824;
  v4 = 0;
  v5 = __DisplayUpdateWeakCapOnSignificantAmbientChange_block_invoke;
  v6 = &__block_descriptor_40_e5_v8__0l;
  v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

void _DisplayUpdateWeakCapOnSignificantAmbientChange(float *a1)
{
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v4;
  uint8_t v5[15];
  char v6;
  NSObject *v7;
  float *v8;

  v8 = a1;
  if (a1[131] < a1[328] && v8[132] > v8[131])
  {
    v7 = 0;
    if (_logHandle)
    {
      v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v4 = inited;
    }
    v7 = v4;
    v6 = 2;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      log = v7;
      type = v6;
      __os_log_helper_16_0_0(v5);
      _os_log_debug_impl(&dword_1B5291000, log, type, "Display: Resetting weak cap on significant ambient change", v5, 2u);
    }
    _DisplaySetBrightnessWeakCapWithFade(v8, 0, v8[131], 10.0);
  }
}

float _DisplayGetBrightnessMinPhysical(uint64_t a1)
{
  NSObject *v1;
  float v3;
  void (*v4)(void);
  int v5;
  int v6;
  float (*v7)(uint64_t);
  void *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;

  v16 = a1;
  v11 = 0;
  v12 = (float *)&v11;
  v13 = 0x20000000;
  v14 = 32;
  v15 = 0;
  v1 = *(NSObject **)(a1 + 144);
  v4 = (void (*)(void))MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = ___DisplayGetBrightnessMinPhysical_block_invoke;
  v8 = &unk_1E68EB450;
  v10 = v16;
  v9 = &v11;
  disp_dispatch_sync(v1, &v4);
  v3 = v12[6];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1B53F0C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

float __DisplayGetUpdateFrequency(uint64_t a1, float a2)
{
  float v3;
  float v4;
  uint64_t inited;
  NSObject *v6;
  unsigned int v7;
  float v8;
  float v9;
  float v10;
  uint8_t v12[40];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v10 = fminf(fmaxf(fabsf(a2), 1.0), 20.0);
  v8 = (float)((float)(v10 - 1.0) / 20.0) * 95.0;
  v7 = v8;
  if (v8 == 95.0)
    v9 = __DisplayNitsPerSecondToUpdateFrequency[v8];
  else
    v9 = __interpolate((float)v7, __DisplayNitsPerSecondToUpdateFrequency[v7], (float)(v7 + 1), __DisplayNitsPerSecondToUpdateFrequency[v7 + 1], v8);
  if ((*(_BYTE *)(a1 + 321) & 1) == 0 && (CBU_ForceUpdateFrequencyAndFrameSkip() & 1) != 0)
  {
    if (v9 > 30.0)
      v9 = 60.0;
    else
      v9 = 30.0;
  }
  if (_logHandle)
  {
    v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v6 = inited;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_8_0_8_0_4_0_4_0((uint64_t)v12, COERCE__INT64(v10), COERCE__INT64(v9), v7, 96);
    _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "rate: %0.2f nits/s %0.2fhz         [%u/%u]", v12, 0x22u);
  }
  if (*(float *)(a1 + 384) == 0.0)
    v4 = 1.0;
  else
    v4 = *(float *)(a1 + 384);
  if (*(float *)(a1 + 388) == 0.0)
    v3 = 80.0;
  else
    v3 = *(float *)(a1 + 388);
  return fminf(fmaxf(v9, v4), v3);
}

void _DisplayScheduleAsync(uint64_t a1)
{
  NSObject *v1;
  void (*v2)(void);
  int v3;
  int v4;
  void (*v5)(uint64_t);
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v8 = a1;
  v1 = *(NSObject **)(a1 + 144);
  v2 = (void (*)(void))MEMORY[0x1E0C809B0];
  v3 = -1073741824;
  v4 = 0;
  v5 = ___DisplayScheduleAsync_block_invoke;
  v6 = &__block_descriptor_40_e5_v8__0l;
  v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

void _DisplayUnscheduleAsync(uint64_t a1)
{
  NSObject *v1;
  void (*v2)(void);
  int v3;
  int v4;
  void (*v5)(uint64_t);
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v8 = a1;
  v1 = *(NSObject **)(a1 + 144);
  v2 = (void (*)(void))MEMORY[0x1E0C809B0];
  v3 = -1073741824;
  v4 = 0;
  v5 = ___DisplayUnscheduleAsync_block_invoke;
  v6 = &__block_descriptor_40_e5_v8__0l;
  v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

float DisplayGetDeviceBrightness(uint64_t a1)
{
  return *(float *)(a1 + 1260);
}

float DisplayGetPhysicalBrightness(uint64_t a1)
{
  return *(float *)(a1 + 1264);
}

float DisplayGetLogicalBrightness(uint64_t a1)
{
  return *(float *)(a1 + 1256);
}

void DisplayAccessoryInitializeBrightnessOverrides(uint64_t a1)
{
  const __CFString *v1;
  CFTypeID v2;
  float valuePtr;
  CFTypeRef cf;
  const __CFString *v5;
  uint64_t v6;

  v6 = a1;
  CFPreferencesAppSynchronize(CFSTR("com.apple.CoreBrightness"));
  v5 = 0;
  v1 = CFSTR("DisplayTypeAOverride");
  if (!*(_DWORD *)(v6 + 308))
    v1 = CFSTR("DisplayTypeBOverride");
  v5 = v1;
  cf = CFPreferencesCopyAppValue(v1, CFSTR("com.apple.CoreBrightness"));
  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (v2 == CFNumberGetTypeID())
    {
      valuePtr = -1.0;
      CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, &valuePtr);
      *(float *)(v6 + 316) = valuePtr;
    }
    CFRelease(cf);
  }
}

float DisplayGetVirtualBrightness(float *a1)
{
  if (*((_DWORD *)a1 + 10))
    return a1[372];
  else
    return a1[314];
}

void DisplaySetLogicalBrightness(uint64_t a1, int a2, float a3)
{
  DisplaySetLogicalBrightnessWithFade(a1, a2, 0, 0, a3, 0.0);
}

void DisplaySetLogicalBrightnessWithFade(uint64_t a1, int a2, uint64_t a3, uint64_t a4, float a5, float a6)
{
  NSObject *v6;
  void (*v7)(void);
  int v8;
  int v9;
  void (*v10)(uint64_t);
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float v15;
  int v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  float v20;
  int v21;
  float v22;
  uint64_t v23;

  v23 = a1;
  v22 = a5;
  v21 = a2;
  v20 = a6;
  v19 = a3;
  v18 = a4;
  v6 = *(NSObject **)(a1 + 144);
  v7 = (void (*)(void))MEMORY[0x1E0C809B0];
  v8 = -1073741824;
  v9 = 0;
  v10 = __DisplaySetLogicalBrightnessWithFade_block_invoke;
  v11 = &__block_descriptor_68_e5_v8__0l;
  v12 = v23;
  v15 = a5;
  v16 = a2;
  v17 = a6;
  v13 = a3;
  v14 = a4;
  disp_dispatch_sync(v6, &v7);
}

void DisplaySetVirtualBrightnessWithFade(uint64_t a1, int a2, uint64_t a3, uint64_t a4, float a5, float a6)
{
  NSObject *v6;
  NSObject *v7;
  void (*v8)(void);
  int v9;
  int v10;
  void (*v11)(uint64_t);
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  int v17;
  float v18;
  void (*v19)(void);
  int v20;
  int v21;
  void (*v22)(uint64_t);
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float v27;
  float v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  int v32;
  float v33;
  uint64_t v34;

  v34 = a1;
  v33 = a5;
  v32 = a2;
  v31 = a6;
  v30 = a3;
  v29 = a4;
  if (*(_DWORD *)(a1 + 40))
  {
    v6 = *(NSObject **)(v34 + 144);
    v19 = (void (*)(void))MEMORY[0x1E0C809B0];
    v20 = -1073741824;
    v21 = 0;
    v22 = __DisplaySetVirtualBrightnessWithFade_block_invoke;
    v23 = &__block_descriptor_64_e5_v8__0l;
    v24 = v34;
    v27 = v33;
    v28 = v31;
    v25 = v30;
    v26 = v29;
    disp_dispatch_sync(v6, &v19);
  }
  else
  {
    v7 = *(NSObject **)(v34 + 144);
    v8 = (void (*)(void))MEMORY[0x1E0C809B0];
    v9 = -1073741824;
    v10 = 0;
    v11 = __DisplaySetVirtualBrightnessWithFade_block_invoke_2;
    v12 = &__block_descriptor_68_e5_v8__0l;
    v13 = v34;
    v16 = v33;
    v17 = v32;
    v18 = v31;
    v14 = v30;
    v15 = v29;
    disp_dispatch_sync(v7, &v8);
  }
}

void _DisplaySetVirtualBrightnessWithFade(uint64_t a1, unsigned int a2, void (*a3)(uint64_t), uint64_t a4, float a5, float a6)
{
  float v6;
  BOOL v7;
  BOOL v8;
  uint64_t inited;
  NSObject *v10;
  uint8_t v17[24];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a6 = *(float *)(a1 + 376);
  *(float *)(a1 + 1492) = a5;
  *(double *)(a1 + 1440) = a6;
  if (_logHandle)
  {
    v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v10 = inited;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v17, COERCE__INT64(a5), COERCE__INT64(a6));
    _os_log_debug_impl(&dword_1B5291000, v10, OS_LOG_TYPE_DEBUG, "L=%f fadePeriod=%f\n", v17, 0x16u);
  }
  if (a6 == 0.0 || a5 == 0.0)
  {
    v8 = 0;
    if (*(double *)(a1 + 1384) != 0.0)
    {
      v8 = 0;
      if (*(float *)(a1 + 1400) > 0.0)
        v8 = *(float *)(a1 + 1400) < 1.0;
    }
    v7 = 0;
    if (*(double *)(a1 + 1384) == 0.0)
    {
      v7 = 0;
      if (*(float *)(a1 + 348) > 0.0)
        v7 = *(float *)(a1 + 348) < 1.0;
    }
    if (v8 || v7)
      *(float *)(a1 + 1488) = a5;
    else
      __DisplaySetVirtualBrightnessWithFadeInternal(a1, a5, 0.0, a2 | 0x1000, 0, 0);
    if (a3)
      a3(a4);
  }
  else if ((a2 & 0x10) != 0 && (_DisplayRampIsRunning(a1) & 1) != 0)
  {
    *(float *)(a1 + 1456) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1492));
  }
  else
  {
    v6 = *(double *)(a1 + 1440);
    __DisplaySetVirtualBrightnessWithFadeInternal(a1, *(float *)(a1 + 1492), v6, a2, (uint64_t)a3, a4);
  }
}

uint64_t __os_log_helper_16_0_5_8_0_8_0_4_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 5;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  return result;
}

void DisplayCancelBrightnessFade(uint64_t a1)
{
  NSObject *v1;
  void (*v2)(void);
  int v3;
  int v4;
  double (*v5)(uint64_t);
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v8 = a1;
  v1 = *(NSObject **)(a1 + 144);
  v2 = (void (*)(void))MEMORY[0x1E0C809B0];
  v3 = -1073741824;
  v4 = 0;
  v5 = __DisplayCancelBrightnessFade_block_invoke;
  v6 = &__block_descriptor_40_e5_v8__0l;
  v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

void __DisplayUpdateAAPFactor(uint64_t a1)
{
  uint64_t inited;
  NSObject *v2;
  float v3;
  float v4;
  float v5;
  uint8_t v7[56];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 12248) & 1) != 0 && !*(_DWORD *)(a1 + 40))
  {
    v5 = *(float *)(a1 + 1572);
    if (v5 <= 0.0)
      v4 = 200.0;
    else
      v4 = *(float *)(a1 + 1256) / v5;
    if ((float)(v4 * 0.005) > 1.0)
      v4 = 200.0;
    v3 = (float)(powf(v4 * 0.005, -0.45) - 1.0) / 5.0;
    if (_logHandle)
    {
      v2 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v2 = inited;
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v7, COERCE__INT64(*(float *)(a1 + 1256)), COERCE__INT64(v5), COERCE__INT64(v4), COERCE__INT64(v3));
      _os_log_impl(&dword_1B5291000, v2, OS_LOG_TYPE_DEFAULT, "Lcurrent=%0.4f Lr=%0.4f DR=%0.4f factor=%0.4f\n", v7, 0x2Au);
    }
    __DisplaySetAAPFactor((_BYTE *)a1, v3);
  }
}

void DisplayCancelReflectedBrightnessFade(uint64_t a1)
{
  NSObject *v1;
  void (*v2)(void);
  int v3;
  int v4;
  double (*v5)(uint64_t);
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v8 = a1;
  v1 = *(NSObject **)(a1 + 144);
  v2 = (void (*)(void))MEMORY[0x1E0C809B0];
  v3 = -1073741824;
  v4 = 0;
  v5 = __DisplayCancelReflectedBrightnessFade_block_invoke;
  v6 = &__block_descriptor_40_e5_v8__0l;
  v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

void __DisplayFadeUpdateFade(double a1, uint64_t a2, uint64_t a3)
{
  float v3;
  float v4;
  uint64_t inited;
  NSObject *v6;
  double v7;
  double v8;
  uint8_t v11[72];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v8 = a1 - *(double *)(a3 + 8);
  v7 = v8 / *(double *)a3;
  if (v7 >= 1.0)
  {
    v4 = fmin(1.0, *(float *)(a3 + 16));
    *(float *)(a3 + 20) = v4;
    if (_logHandle)
    {
      v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v6 = inited;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v11, *(uint64_t *)&a1, *(uint64_t *)&v8, *(_QWORD *)a3, *(uint64_t *)&v7, COERCE__INT64(*(float *)(a3 + 24)), COERCE__INT64(*(float *)(a3 + 16)));
      _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Pstart=%f fade->Ptarget=%f [finished]\n", v11, 0x3Eu);
    }
    if (*(_QWORD *)(a3 + 32))
      (*(void (**)(_QWORD))(a3 + 32))(*(_QWORD *)(a3 + 40));
    *(_QWORD *)a3 = 0;
  }
  else
  {
    v3 = fmin(1.0, *(float *)(a3 + 24) + (float)(*(float *)(a3 + 16) - *(float *)(a3 + 24)) * v7);
    *(float *)(a3 + 20) = v3;
  }
}

void __DisplayFadeUpdateAuroraFactorFade(uint64_t a1, uint64_t a2, double a3)
{
  float v3;
  double v4;
  void (*v5)(uint64_t, const __CFString *, _QWORD);
  uint64_t v6;
  uint64_t inited;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  float v11;
  float v12;
  float v13;
  double v14;
  double v15;
  uint8_t v19[64];
  uint8_t v20[72];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v15 = a3 - *(double *)(a2 + 8);
  v14 = v15 / *(double *)a2;
  if (*(float *)(a2 + 20) == *(float *)(a2 + 16))
    v14 = 1.0;
  if (v14 >= 1.0)
  {
    *(_DWORD *)(a2 + 20) = *(_DWORD *)(a2 + 16);
    if (_logHandle)
    {
      v8 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v8 = inited;
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v19, *(uint64_t *)&a3, *(uint64_t *)&v15, *(_QWORD *)a2, *(uint64_t *)&v14, COERCE__INT64(*(float *)(a2 + 24)), COERCE__INT64(*(float *)(a2 + 16)));
      _os_log_debug_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Fstart=%f fade->Ftarget=%f [finished]\n", v19, 0x3Eu);
    }
    if (*(_QWORD *)(a2 + 40))
      (*(void (**)(_QWORD))(a2 + 40))(*(_QWORD *)(a2 + 48));
    HIDWORD(v4) = 0;
    *(_QWORD *)a2 = 0;
  }
  else
  {
    v13 = 2.0;
    v12 = *(float *)(a1 + 13020);
    if (*(float *)(a2 + 24) > *(float *)(a2 + 16))
    {
      v13 = 1.0 / 2.0;
      v12 = *(float *)(a1 + 13024);
    }
    v3 = v14 * (float)(fabsf(log2f(*(float *)(a2 + 16) / *(float *)(a2 + 24))) * v12);
    v11 = *(float *)(a2 + 24);
    *(float *)(a2 + 20) = v11 * powf(v13, v3 / v12);
    if (_logHandle)
    {
      v10 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v9 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v9 = init_default_corebrightness_log();
      v10 = v9;
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v20, *(uint64_t *)&a3, *(uint64_t *)&v15, *(_QWORD *)a2, *(uint64_t *)&v14, COERCE__INT64(*(float *)(a2 + 24)), COERCE__INT64(*(float *)(a2 + 16)), COERCE__INT64(*(float *)(a2 + 20)));
      _os_log_debug_impl(&dword_1B5291000, v10, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Fstart=%f fade->Ftarget=%f Factor=%f\n", v20, 0x48u);
    }
  }
  if (*(_QWORD *)(a1 + 16))
  {
    LODWORD(v4) = *(_DWORD *)(a2 + 20);
    (*(void (**)(_QWORD, const __CFString *, uint64_t))(a1 + 16))(*(_QWORD *)(a1 + 24), CFSTR("AuroraFactor"), objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v4));
    v5 = *(void (**)(uint64_t, const __CFString *, _QWORD))(a1 + 16);
    v6 = *(_QWORD *)(a1 + 24);
    if (*(double *)(a1 + 12952) <= 0.0)
      v5(v6, CFSTR("AuroraRampInProgress"), *MEMORY[0x1E0C9AE40]);
    else
      v5(v6, CFSTR("AuroraRampInProgress"), *MEMORY[0x1E0C9AE50]);
  }
}

void DisplayCancelRestrictionFactorFade(uint64_t a1, int a2)
{
  NSObject *v2;
  void (*v3)(void);
  int v4;
  int v5;
  uint64_t (*v6)(uint64_t);
  void *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v2 = *(NSObject **)(a1 + 144);
  v3 = (void (*)(void))MEMORY[0x1E0C809B0];
  v4 = -1073741824;
  v5 = 0;
  v6 = __DisplayCancelRestrictionFactorFade_block_invoke;
  v7 = &__block_descriptor_44_e5_v8__0l;
  v8 = v11;
  v9 = a2;
  disp_dispatch_sync(v2, &v3);
}

BOOL __DisplayFactorFade_IsRunning(double *a1)
{
  return *a1 > 0.0;
}

uint64_t __DisplayFactorFade_Direction(uint64_t a1)
{
  if (__DisplayFactorFade_IsRunning((double *)a1))
  {
    if (*(float *)(a1 + 16) <= *(float *)(a1 + 24))
      return *(float *)(a1 + 16) < *(float *)(a1 + 24);
    else
      return 2;
  }
  else
  {
    return 0;
  }
}

uint64_t __DisplayFactorFade_Cancel(uint64_t a1)
{
  char v3;

  if (__DisplayFactorFade_IsRunning((double *)a1))
  {
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 20);
    *(_QWORD *)a1 = 0;
    if (*(_QWORD *)(a1 + 40))
      (*(void (**)(_QWORD))(a1 + 40))(*(_QWORD *)(a1 + 48));
    v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  return v3 & 1;
}

void DisplayCancelVirtualFade(uint64_t a1)
{
  NSObject *v1;
  void (*v2)(void);
  int v3;
  int v4;
  double (*v5)(uint64_t);
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v8 = a1;
  v1 = *(NSObject **)(a1 + 144);
  v2 = (void (*)(void))MEMORY[0x1E0C809B0];
  v3 = -1073741824;
  v4 = 0;
  v5 = __DisplayCancelVirtualFade_block_invoke;
  v6 = &__block_descriptor_40_e5_v8__0l;
  v7 = v8;
  disp_dispatch_sync(v1, &v2);
  DisplayCancelBrightnessFade(v8);
}

void __DisplaySetVirtualBrightnessWithFadeInternal(uint64_t a1, float a2, float a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  double v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t inited;
  NSObject *v12;
  float UpdateFrequency;
  float v14;
  float v15;
  uint8_t v19[48];
  uint8_t v20[64];
  uint8_t v21[40];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 380) & 1) != 0)
    a3 = *(float *)(a1 + 376);
  if (a3 == 0.0)
  {
    v15 = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1488));
    *(_QWORD *)(a1 + 1440) = 0;
    *(float *)(a1 + 1460) = v15;
    *(float *)(a1 + 1464) = v15;
    *(float *)(a1 + 1456) = v15;
    __DisplaySetLogicalBrightnessInternal((const void *)a1, 0x2000, *(float *)(a1 + 1256));
  }
  else
  {
    *(_QWORD *)(a1 + 1472) = a5;
    *(_QWORD *)(a1 + 1480) = a6;
    *(CFAbsoluteTime *)(a1 + 1448) = CFAbsoluteTimeGetCurrent();
    *(double *)(a1 + 1440) = a3;
    if (_logHandle)
    {
      v12 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v12 = inited;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v21, *(_QWORD *)(a1 + 1440), *(_QWORD *)(a1 + 1448), *(_QWORD *)(a1 + 12480));
      _os_log_debug_impl(&dword_1B5291000, v12, OS_LOG_TYPE_DEBUG, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v21, 0x20u);
    }
    v14 = (float)(a2 - *(float *)(a1 + 1488)) / a3;
    UpdateFrequency = __DisplayGetUpdateFrequency(a1, v14);
    if (_logHandle)
    {
      v10 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v9 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v9 = init_default_corebrightness_log();
      v10 = v9;
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v20, COERCE__INT64(*(float *)(a1 + 1488)), COERCE__INT64(a2), COERCE__INT64(a3), COERCE__INT64(v14), COERCE__INT64(UpdateFrequency));
      _os_log_debug_impl(&dword_1B5291000, v10, OS_LOG_TYPE_DEBUG, "begin virtual ramp L: %0.2f -> L: %0.2f t: %f rate: %0.2f nits/s %0.2fhz", v20, 0x34u);
    }
    *(float *)(a1 + 1460) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1488));
    *(_DWORD *)(a1 + 1464) = *(_DWORD *)(a1 + 1460);
    *(float *)(a1 + 1456) = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
    if (_logHandle)
    {
      v8 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v7 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v7 = init_default_corebrightness_log();
      v8 = v7;
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v19, COERCE__INT64(*(float *)(a1 + 1488)), COERCE__INT64(a2), COERCE__INT64(*(float *)(a1 + 1464)), COERCE__INT64(*(float *)(a1 + 1456)));
      _os_log_debug_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEBUG, "display->brightness.Lvirtual=%f L=%f display->brightness.virtualFade.Pstart=%f display->brightness.virtualFade.Ptarget=%f\n", v19, 0x2Au);
    }
    *(float *)&v6 = 1.0 / UpdateFrequency;
    __DisplayStartFade((_BYTE *)a1, v6);
  }
}

void __BLPropertyChangedCallback(uint64_t a1, const void *a2, uint64_t a3)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  int v6;
  _QWORD *(*v7)(_QWORD *);
  void *v8;
  uint64_t v9;
  CFTypeRef v10;
  uint64_t v11;
  uint64_t v12;
  CFTypeRef v13;
  uint64_t v14;

  v14 = a1;
  v13 = a2;
  v12 = a3;
  if (a2)
  {
    if (CFEqual(v13, CFSTR("brightness-nits")))
    {
      v3 = *(NSObject **)(v14 + 144);
      v4 = MEMORY[0x1E0C809B0];
      v5 = -1073741824;
      v6 = 0;
      v7 = ____BLPropertyChangedCallback_block_invoke;
      v8 = &__block_descriptor_56_e5_v8__0l;
      v9 = v14;
      v10 = v13;
      v11 = v12;
      dispatch_async(v3, &v4);
    }
  }
}

uint64_t DisplayGetHDRAPLColumn(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  dispatch_once_t *v10;

  v8 = a1;
  v2 = MEMORY[0x1E0C809B0];
  v3 = -1073741824;
  v4 = 0;
  v5 = __DisplayGetHDRAPLColumn_block_invoke;
  v6 = &__block_descriptor_40_e5_v8__0l;
  v7 = a1;
  v10 = &DisplayGetHDRAPLColumn_hdrToken;
  v9 = &v2;
  if (DisplayGetHDRAPLColumn_hdrToken != -1)
    dispatch_once(v10, v9);
  return DisplayGetHDRAPLColumn_hdrColumn;
}

float DisplayPhysicalBrightnessToPower(uint64_t a1, unsigned int a2, float a3)
{
  return __DisplayPhysicalBrightnessToPowerInternal(a1, a2, a3);
}

void __DisplayRelease(uint64_t a1)
{
  NSObject *v1;
  void (*v2)(void);
  int v3;
  int v4;
  void (*v5)(uint64_t);
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v9 = a1;
  v8 = a1;
  if ((objc_msgSend(MEMORY[0x1E0D09930], "isCPMSSupported") & 1) == 1)
  {
    if (*(_QWORD *)(v8 + 12128))
    {
      CFRelease(*(CFTypeRef *)(v8 + 12128));
      *(_QWORD *)(v8 + 12128) = 0;
    }
    if (*(_QWORD *)(v8 + 12136))
    {
      CFRelease(*(CFTypeRef *)(v8 + 12136));
      *(_QWORD *)(v8 + 12136) = 0;
    }
    if (*(_QWORD *)(v8 + 12144))
    {
      CFRelease(*(CFTypeRef *)(v8 + 12144));
      *(_QWORD *)(v8 + 12144) = 0;
    }
    if (*(_QWORD *)(v8 + 12152))
    {
      CFRelease(*(CFTypeRef *)(v8 + 12152));
      *(_QWORD *)(v8 + 12152) = 0;
    }
    if (*(_QWORD *)(v8 + 12160))
    {
      CFRelease(*(CFTypeRef *)(v8 + 12160));
      *(_QWORD *)(v8 + 12160) = 0;
    }
    if (*(_QWORD *)(v8 + 12168))
    {
      CFRelease(*(CFTypeRef *)(v8 + 12168));
      *(_QWORD *)(v8 + 12168) = 0;
    }
    if (*(_QWORD *)(v8 + 12112))
    {
      dispatch_release(*(dispatch_object_t *)(v8 + 12112));
      *(_QWORD *)(v8 + 12112) = 0;
    }
  }
  if (*(_QWORD *)(v8 + 72))
  {
    free(*(void **)(v8 + 72));
    *(_QWORD *)(v8 + 72) = 0;
    *(_DWORD *)(v8 + 64) = 0;
  }
  if (*(_QWORD *)(v8 + 144))
  {
    v1 = *(NSObject **)(v8 + 144);
    v2 = (void (*)(void))MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = ____DisplayRelease_block_invoke;
    v6 = &__block_descriptor_40_e5_v8__0l;
    v7 = v8;
    disp_dispatch_sync(v1, &v2);
  }
  if (*(_QWORD *)(v8 + 120))
  {
    dispatch_release(*(dispatch_object_t *)(v8 + 120));
    *(_QWORD *)(v8 + 120) = 0;
  }
  if (*(_QWORD *)(v8 + 144))
  {
    dispatch_release(*(dispatch_object_t *)(v8 + 144));
    *(_QWORD *)(v8 + 144) = 0;
  }
  if (*(_QWORD *)(v8 + 168))
  {
    dispatch_release(*(dispatch_object_t *)(v8 + 168));
    *(_QWORD *)(v8 + 168) = 0;
  }
  if (*(_QWORD *)(v8 + 152))
  {
    dispatch_release(*(dispatch_object_t *)(v8 + 152));
    *(_QWORD *)(v8 + 152) = 0;
  }
  if (*(_QWORD *)(v8 + 12536))
    CFRelease(*(CFTypeRef *)(v8 + 12536));
  if (*(_QWORD *)(v8 + 12720))
    CFRelease(*(CFTypeRef *)(v8 + 12720));
  CBEDRServerRemoveDisplay(*(_DWORD *)(v8 + 12592));
  *(_DWORD *)(v8 + 12596) = 0;
  if (*(_QWORD *)(v8 + 328))
  {

    *(_QWORD *)(v8 + 328) = 0;
  }
  if (*(_QWORD *)(v8 + 264))
  {

    *(_QWORD *)(v8 + 264) = 0;
  }
}

uint64_t brightnessThread(uint64_t a1)
{
  char *v1;
  BOOL v3;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v7;
  mach_msg_header_t msg[3];
  char v9;
  NSObject *v10;
  mach_msg_header_t __b[3];
  mach_error_t v12;
  uint64_t v13;
  uint8_t v14[24];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = a1;
  v12 = 0;
  memset(__b, 0, sizeof(__b));
  while (1)
  {
    __b[0].msgh_size = 72;
    __b[0].msgh_local_port = __brightnessPort;
    v12 = mach_msg_receive(__b);
    if (v12)
      break;
    memcpy(msg, __b, sizeof(msg));
    while (1)
    {
      v3 = 0;
      if ((__b[2].msgh_remote_port & 4) == 0)
      {
        v3 = 0;
        if (*(double *)&__b[1].msgh_voucher_port == 0.0)
          v3 = mach_msg(msg, 258, 0, 0x48u, __brightnessPort, 0, 0) == 0;
      }
      if (!v3)
        break;
      memcpy(__b, msg, sizeof(__b));
    }
    __DisplaySetPhysicalBrightnessLegacyOnThread(*(float **)&__b[1].msgh_bits, *(unint64_t *)&__b[2].msgh_bits, __b[2].msgh_remote_port, *(float *)&__b[1].msgh_remote_port, *(double *)&__b[1].msgh_voucher_port);
    if (*(double *)&__b[1].msgh_voucher_port != 0.0 && *(float *)&__b[1].msgh_remote_port != 0.0)
      usleep((*(double *)&__b[1].msgh_voucher_port * 1000000.0));
  }
  v10 = 0;
  if (_logHandle)
  {
    v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v7 = inited;
  }
  v10 = v7;
  v9 = 16;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    log = v10;
    type = v9;
    v1 = mach_error_string(v12);
    __os_log_helper_16_2_1_8_34((uint64_t)v14, (uint64_t)v1);
    _os_log_error_impl(&dword_1B5291000, log, type, "brightnessThread: mach_msg_receive() failed: %{public}s\n", v14, 0xCu);
  }
  return v13;
}

uint64_t __os_log_helper_16_2_1_8_34(uint64_t result, uint64_t a2)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 1;
  *(_BYTE *)(result + 2) = 34;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  return result;
}

void __DisplaySetPhysicalBrightnessLegacyOnThread(float *a1, unint64_t a2, int a3, float a4, double a5)
{
  const __CFAllocator *v5;
  const __CFAllocator *v6;
  const __CFAllocator *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  os_log_type_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t inited;
  NSObject *v21;
  uint8_t v22[7];
  os_log_type_t v23;
  os_log_t oslog;
  uint8_t v25[15];
  os_log_type_t v26;
  NSObject *v27;
  os_log_type_t v28;
  os_log_t v29;
  float v30;
  int v31;
  int v32;
  int valuePtr;
  kern_return_t v34;
  int v35;
  unint64_t v36;
  double v37;
  float v38;
  float *v39;
  uint8_t v40[32];
  uint8_t v41[48];
  uint8_t v42[32];
  CFNumberRef v43;
  CFNumberRef v44;
  CFNumberRef v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v39 = a1;
  v38 = a4;
  v37 = a5;
  v36 = a2;
  v35 = a3;
  v34 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  valuePtr = 0;
  v32 = 0;
  v31 = 0;
  v30 = a4;
  pthread_mutex_lock(&__brightnessLock);
  v29 = 0;
  if (_logHandle)
  {
    v21 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v21 = inited;
  }
  v29 = v21;
  v28 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v42, v36, __brightnessTS);
    _os_log_debug_impl(&dword_1B5291000, v29, v28, "timeStamp=%lld __brightnessTS=%lld\n", v42, 0x16u);
  }
  if (v36 > __brightnessTS)
  {
    __brightnessTS = v36;
    v30 = v30 * v39[87];
    if (v39[87] != 0.0)
    {
      if (v30 >= v39[85])
      {
        if (v30 > v39[86])
          v30 = v39[86];
      }
      else
      {
        v30 = v39[85];
      }
    }
    valuePtr = (int)(ceil((float)(v30 * (float)(*((_DWORD *)v39 + 310) - *((_DWORD *)v39 + 309))))
                   + (double)*((int *)v39 + 309));
    if (valuePtr != *((_DWORD *)v39 + 311))
    {
      v5 = CFGetAllocator(v39);
      v43 = CFNumberCreate(v5, kCFNumberSInt32Type, &valuePtr);
      if (v43)
      {
        v31 = (int)(v37 * 65536.0);
        v6 = CFGetAllocator(v39);
        v44 = CFNumberCreate(v6, kCFNumberSInt32Type, &v31);
        if (v44)
        {
          CFDictionarySetValue((CFMutableDictionaryRef)__brightnessDict, (const void *)__brightnessKeys, v43);
          CFDictionarySetValue((CFMutableDictionaryRef)__brightnessDict, off_1EF1034C8[0], v44);
          if ((v35 & 2) != 0)
          {
            CFDictionaryRemoveValue((CFMutableDictionaryRef)__brightnessDict, off_1EF1034D0);
          }
          else
          {
            v32 = (int)(ceil((float)(v39[84] * (float)(*((_DWORD *)v39 + 310) - *((_DWORD *)v39 + 309))))
                      + (double)*((int *)v39 + 309));
            v7 = CFGetAllocator(v39);
            v45 = CFNumberCreate(v7, kCFNumberSInt32Type, &v32);
            if (!v45)
              goto LABEL_61;
            CFDictionarySetValue((CFMutableDictionaryRef)__brightnessDict, off_1EF1034D0, v45);
          }
          v34 = IORegistryEntrySetCFProperties(*((_DWORD *)v39 + 20), (CFTypeRef)__brightnessDict);
          if (!v34)
          {
            if (valuePtr || !*((_DWORD *)v39 + 311))
            {
              if (valuePtr && !*((_DWORD *)v39 + 311))
              {
                oslog = 0;
                if (_logHandle)
                {
                  v15 = _logHandle;
                }
                else
                {
                  v14 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
                  v15 = v14;
                }
                oslog = v15;
                v23 = OS_LOG_TYPE_DEFAULT;
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
                {
                  v12 = oslog;
                  v13 = v23;
                  __os_log_helper_16_0_0(v22);
                  _os_log_impl(&dword_1B5291000, v12, v13, "Brightness ON.\n", v22, 2u);
                }
              }
            }
            else
            {
              v27 = 0;
              if (_logHandle)
              {
                v19 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                  v18 = _COREBRIGHTNESS_LOG_DEFAULT;
                else
                  v18 = init_default_corebrightness_log();
                v19 = v18;
              }
              v27 = v19;
              v26 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
              {
                v16 = v27;
                v17 = v26;
                __os_log_helper_16_0_0(v25);
                _os_log_impl(&dword_1B5291000, v16, v17, "Brightness OFF.\n", v25, 2u);
              }
            }
            *((_DWORD *)v39 + 311) = valuePtr;
            if (_logHandle)
            {
              v11 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
                v10 = _COREBRIGHTNESS_LOG_DEFAULT;
              else
                v10 = init_default_corebrightness_log();
              v11 = v10;
            }
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_0_5_8_0_8_0_4_0_8_0_4_0((uint64_t)v41, COERCE__INT64(v30), COERCE__INT64(v39[87]), valuePtr, *(uint64_t *)&v37, v31);
              _os_log_debug_impl(&dword_1B5291000, v11, OS_LOG_TYPE_DEBUG, "brightness=%f factor=%f deviceBrightness=%d fadePeriod=%f fixedFadePeriod=0x%08x\n", v41, 0x2Cu);
            }
            if (v39[86] < 1.0)
            {
              if (_logHandle)
              {
                v9 = _logHandle;
              }
              else
              {
                v8 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
                v9 = v8;
              }
              if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
              {
                __os_log_helper_16_0_2_8_0_8_0((uint64_t)v40, COERCE__INT64(v30), COERCE__INT64(v39[86]));
                _os_log_impl(&dword_1B5291000, v9, OS_LOG_TYPE_DEFAULT, "Device brightness %f based on max brightness of %f\n", v40, 0x16u);
              }
            }
          }
        }
      }
    }
  }
LABEL_61:
  pthread_mutex_unlock(&__brightnessLock);
  if (v43)
    CFRelease(v43);
  if (v44)
    CFRelease(v44);
  if (v45)
    CFRelease(v45);
}

uint64_t __os_log_helper_16_0_5_8_0_8_0_4_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 5;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 4;
  *(_DWORD *)(result + 40) = a6;
  return result;
}

uint64_t _DisplayGetGlobalScalarDisplayParams(io_registry_entry_t a1, float *a2, float *a3)
{
  unsigned int v4;
  unsigned int v5;
  CFTypeRef v6;
  char v7;
  float *v8;
  float *v9;
  io_registry_entry_t v10;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v7 = 0;
  if (a2)
  {
    if (v8)
    {
      v6 = 0;
      v6 = IORegistryEntrySearchCFProperty(v10, "IOService", CFSTR("luminance-ratio"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
      v5 = 0;
      if ((_DisplayGetUint32FromCFDataAndRelease(v6, &v5) & 1) != 0)
      {
        v6 = IORegistryEntrySearchCFProperty(v10, "IOService", CFSTR("vbatt-current"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
        v4 = 0;
        if ((_DisplayGetUint32FromCFDataAndRelease(v6, &v4) & 1) != 0 && v4 != -1 && v5 != -1)
        {
          v5 = ((v5 & 0xFF00) << 8) + (v5 << 24) + ((v5 & 0xFF0000) >> 8) + ((v5 & 0xFF000000) >> 24);
          v4 = ((v4 & 0xFF00) << 8) + (v4 << 24) + ((v4 & 0xFF0000) >> 8) + ((v4 & 0xFF000000) >> 24);
          *v9 = (float)v4 / 16777000.0;
          *v8 = (float)v5 / 16777000.0;
          v7 = 1;
        }
      }
    }
  }
  return v7 & 1;
}

uint64_t _DisplayGetScalerForKeyAndIndex(io_registry_entry_t a1, const __CFString *a2, unsigned int a3, float *a4, float a5)
{
  UInt8 *v6;
  size_t v7;
  CFTypeRef cf;
  char v9;
  float v10;
  float *v11;
  unsigned int v12;
  const __CFString *v13;
  io_registry_entry_t v14;

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = 0;
  cf = 0;
  cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  v7 = 0;
  v6 = 0;
  if (cf)
    v6 = _DisplayCreateUint32ArrayFromCFData(cf, &v7);
  if (v6 && v7)
  {
    if (v7 <= v12)
      *v11 = (float)*(unsigned int *)v6 / v10;
    else
      *v11 = (float)*(unsigned int *)&v6[4 * v12] / v10;
    v9 = 1;
  }
  if (v6)
    free(v6);
  if (cf)
    CFRelease(cf);
  return v9 & 1;
}

float _DisplayCalculateGlobalScalar(uint64_t a1, float *a2)
{
  float v2;
  CFAllocatorRef *v4;
  int j;
  CFDictionaryRef value;
  int i;
  char v8;
  float numValues_4;
  float v10;
  float v11;
  const void *__b[7];
  const void *__dst[8];

  __dst[7] = *(const void **)MEMORY[0x1E0C80C00];
  v11 = 1.0;
  if (a1 && a2)
  {
    v10 = *a2 / a2[2];
    if (v10 > a2[3])
    {
      v2 = 1.0 - (float)(a2[5] * (float)(v10 - a2[3]));
      numValues_4 = v2;
      if ((float)(v2 * a2[1]) < a2[4])
        numValues_4 = a2[4] / a2[1];
      a2[6] = numValues_4;
      v11 = numValues_4;
    }
    memcpy(__dst, &off_1E68EB5F0, 0x38uLL);
    memset(__b, 0, sizeof(__b));
    v4 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    __b[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, a2 + 2);
    __b[1] = CFNumberCreate(*v4, kCFNumberFloatType, a2 + 3);
    __b[2] = CFNumberCreate(*v4, kCFNumberFloatType, a2 + 4);
    __b[3] = CFNumberCreate(*v4, kCFNumberFloatType, a2 + 5);
    __b[4] = CFNumberCreate(*v4, kCFNumberFloatType, a2 + 6);
    __b[5] = CFNumberCreate(*v4, kCFNumberFloatType, a2);
    __b[6] = CFNumberCreate(*v4, kCFNumberFloatType, a2 + 1);
    v8 = 1;
    for (i = 0; i < 7; ++i)
    {
      if (!__b[i])
      {
        v8 = 0;
        break;
      }
    }
    if ((v8 & 1) != 0)
    {
      value = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __dst, __b, 7, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (value)
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 192), CFSTR("BrightnessGlobalScalar"), value);
        CFRelease(value);
      }
    }
    for (j = 0; j < 7; ++j)
    {
      if (__b[j])
        CFRelease(__b[j]);
    }
  }
  return v11;
}

CFMutableDictionaryRef _DisplayCreateRestrictionDictionarySinglePoint(io_registry_entry_t a1)
{
  float v1;
  float v2;
  unsigned int v4;
  void *value;
  CFMutableDictionaryRef theDict;
  int capacity;
  float capacity_4;
  float v9;
  float v10;
  float v11;
  float valuePtr;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  io_registry_entry_t v18;

  v18 = a1;
  v17 = 0.0;
  v16 = -1.0;
  v15 = 0.0;
  v14 = 0.0;
  v13 = -1.0;
  valuePtr = 0.0;
  v11 = -1.0;
  v10 = 0.0;
  v9 = 0.0;
  capacity_4 = -1.0;
  capacity = 0;
  theDict = 0;
  value = 0;
  value = (void *)IORegistryEntrySearchCFProperty(a1, "IOService", CFSTR("min-restriction-factor"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  v4 = 0;
  if ((_DisplayGetUint32FromCFDataAndRelease(value, &v4) & 1) != 0)
  {
    v1 = (float)v4 / 1000.0;
    v17 = v1;
    value = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", CFSTR("min-restriction-enableth"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if ((_DisplayGetUint32FromCFDataAndRelease(value, &v4) & 1) != 0)
      v15 = (float)v4;
    else
      v17 = 0.0;
    value = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", CFSTR("min-restriction-disableth"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if ((_DisplayGetUint32FromCFDataAndRelease(value, &v4) & 1) != 0)
      v14 = (float)v4;
    else
      v17 = 0.0;
    if (v17 > 0.0)
      capacity += 3;
    value = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", CFSTR("min-restriction-disableth2"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if ((_DisplayGetUint32FromCFDataAndRelease(value, &v4) & 1) != 0)
      v13 = (float)v4;
  }
  value = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", CFSTR("max-restriction-factor"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
  if ((_DisplayGetUint32FromCFDataAndRelease(value, &v4) & 1) != 0)
  {
    v2 = (float)v4 / 1000.0;
    valuePtr = v2;
    value = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", CFSTR("max-restriction-enableth"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if ((_DisplayGetUint32FromCFDataAndRelease(value, &v4) & 1) != 0)
      v10 = (float)v4;
    else
      valuePtr = 0.0;
    value = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", CFSTR("max-restriction-disableth"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if ((_DisplayGetUint32FromCFDataAndRelease(value, &v4) & 1) != 0)
      v9 = (float)v4;
    else
      valuePtr = 0.0;
    if (valuePtr > 0.0)
      capacity += 3;
    value = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", CFSTR("max-restriction-disableth2"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if ((_DisplayGetUint32FromCFDataAndRelease(value, &v4) & 1) != 0)
      capacity_4 = (float)v4;
  }
  if (capacity > 0)
  {
    theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], capacity, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (theDict)
    {
      if (valuePtr > 0.0)
      {
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &valuePtr);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("max_Factor"), value);
          CFRelease(value);
        }
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v10);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("max_enableTh"), value);
          CFRelease(value);
        }
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v9);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("max_disableTh"), value);
          CFRelease(value);
        }
        if (v11 > 0.0)
        {
          value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v11);
          if (value)
          {
            CFDictionaryAddValue(theDict, CFSTR("max_Factor_AABOff"), value);
            CFRelease(value);
          }
        }
        if (capacity_4 > 0.0)
        {
          value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &capacity_4);
          if (value)
          {
            CFDictionaryAddValue(theDict, CFSTR("max_disableTh_highbound"), value);
            CFRelease(value);
          }
        }
      }
      if (v17 > 0.0)
      {
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v17);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("min_Factor"), value);
          CFRelease(value);
        }
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v15);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("min_enableTh"), value);
          CFRelease(value);
        }
        value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v14);
        if (value)
        {
          CFDictionaryAddValue(theDict, CFSTR("min_disableTh"), value);
          CFRelease(value);
        }
        if (v16 > 0.0)
        {
          value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v16);
          if (value)
          {
            CFDictionaryAddValue(theDict, CFSTR("min_Factor_AABOff"), value);
            CFRelease(value);
          }
        }
        if (v13 > 0.0)
        {
          value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v13);
          if (value)
          {
            CFDictionaryAddValue(theDict, CFSTR("min_disableTh_lowbound"), value);
            CFRelease(value);
          }
        }
      }
    }
  }
  return theDict;
}

void __DisplayResetLogTimer(uint64_t a1, char a2)
{
  if (a2)
  {
    if (*(_QWORD *)(a1 + 12576))
    {
      dispatch_release(*(dispatch_object_t *)(a1 + 12576));
      *(_QWORD *)(a1 + 12576) = 0;
    }
  }
  else if (!*(_QWORD *)(a1 + 12576))
  {
    *(_QWORD *)(a1 + 12576) = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(a1 + 144));
    if (*(_QWORD *)(a1 + 12576))
    {
      dispatch_set_context(*(dispatch_object_t *)(a1 + 12576), (void *)a1);
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 12576), 0, 1000000000 * *(int *)(a1 + 12584), 0);
      dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 12576), (dispatch_function_t)__DisplayLogTimerCallback);
      dispatch_resume(*(dispatch_object_t *)(a1 + 12576));
      *(_BYTE *)(a1 + 12568) = 1;
    }
  }
}

uint64_t __DisplayLogTimerCallback(uint64_t result)
{
  if (result)
  {
    if (*(_BYTE *)(result + 12568))
      *(_BYTE *)(result + 12568) = 0;
    else
      return __DisplayCommitReport(result, 0);
  }
  return result;
}

void SetWiggledDigitalDimmingScalar(uint64_t a1, float a2)
{
  NSObject *v2;
  uint64_t block;
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  uint64_t v8;
  float v9;
  float v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  if (a2 == 1.0)
    SetWiggledDigitalDimmingScalar_direction = -1;
  v2 = *(NSObject **)(v11 + 144);
  block = MEMORY[0x1E0C809B0];
  v4 = -1073741824;
  v5 = 0;
  v6 = __SetWiggledDigitalDimmingScalar_block_invoke;
  v7 = &__block_descriptor_44_e5_v8__0l;
  v8 = v11;
  v9 = v10;
  dispatch_async(v2, &block);
}

void __DisplaySetPhysicalBrightnessLegacy(float *a1, mach_port_t a2, float a3, double a4)
{
  char *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t inited;
  NSObject *v12;
  mach_msg_header_t __b[3];
  mach_error_t v14;
  os_log_type_t v15;
  os_log_t v16;
  uint64_t v17;
  mach_port_t v18;
  double v19;
  float v20;
  float *v21;
  uint8_t v22[16];
  uint8_t v23[16];
  uint8_t v24[16];
  uint8_t v25[24];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v21 = a1;
  v20 = a3;
  v19 = a4;
  v18 = a2;
  v17 = mach_absolute_time();
  v16 = 0;
  if (_logHandle)
  {
    v12 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v12 = inited;
  }
  v16 = v12;
  v15 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v25, COERCE__INT64(v20), *(uint64_t *)&v19);
    _os_log_debug_impl(&dword_1B5291000, v16, v15, "brightness=%f fadePeriod=%lf\n", v25, 0x16u);
  }
  if ((v18 & 1) != 0)
  {
    if (_logHandle)
    {
      v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v5 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v5 = init_default_corebrightness_log();
      v6 = v5;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v22, v17);
      _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "Calling __DisplaySetPhysicalBrightnessLegacyOnThread directly at ts=%lld\n", v22, 0xCu);
    }
    __DisplaySetPhysicalBrightnessLegacyOnThread(v21, v17, v18, v20, v19);
  }
  else
  {
    v14 = 0;
    memset(__b, 0, sizeof(__b));
    __b[0].msgh_bits = 19;
    __b[0].msgh_size = 64;
    __b[0].msgh_remote_port = __brightnessPort;
    __b[0].msgh_local_port = 0;
    __b[0].msgh_id = 1112688980;
    *(_QWORD *)&__b[1].msgh_bits = v21;
    *(float *)&__b[1].msgh_remote_port = v20;
    *(double *)&__b[1].msgh_voucher_port = v19;
    *(_QWORD *)&__b[2].msgh_bits = v17;
    __b[2].msgh_remote_port = v18;
    if (_logHandle)
    {
      v10 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v9 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v9 = init_default_corebrightness_log();
      v10 = v9;
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v24, v17);
      _os_log_debug_impl(&dword_1B5291000, v10, OS_LOG_TYPE_DEBUG, "Queueing brightness at ts=%lld\n", v24, 0xCu);
    }
    v14 = mach_msg_send(__b);
    if (v14)
    {
      if (_logHandle)
      {
        v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v7 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v7 = init_default_corebrightness_log();
        v8 = v7;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v4 = mach_error_string(v14);
        __os_log_helper_16_2_1_8_34((uint64_t)v23, (uint64_t)v4);
        _os_log_error_impl(&dword_1B5291000, v8, OS_LOG_TYPE_ERROR, "mach_msg_send() failed: %{public}s\n", v23, 0xCu);
      }
    }
  }
}

uint64_t __DisplayReportToCA(uint64_t a1, uint64_t a2, double a3)
{
  LODWORD(a3) = *(_DWORD *)(a1 + 1288);
  return +[CBAnalytics displayMaxCurrent:](CBAnalytics, "displayMaxCurrent:", a3, a2, a1);
}

uint64_t _DisplayAdaptiveDimmingLeftCallback(uint64_t a1)
{
  if (!a1)
    __assert_rtn("_DisplayAdaptiveDimmingLeftCallback", "Display.m", 10093, "callbackData");
  return +[CBAnalytics autoDimLeave:](CBAnalytics, "autoDimLeave:", CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 888));
}

void __DisplayCPMSHDRCallback(uint64_t a1)
{
  float v1;
  float InstantPower;
  uint64_t PowerAccumulator;
  double v4;
  double Current;

  if (a1)
  {
    if ((DisplayHasDCP(a1) & 1) != 0)
    {
      __DisplayCPMSHDRCallbackDCPStage1((NSObject **)a1);
    }
    else
    {
      Current = CFAbsoluteTimeGetCurrent();
      v4 = Current - *(double *)(a1 + 12088);
      PowerAccumulator = __DisplayGetPowerAccumulator(a1);
      v1 = (float)(unint64_t)(PowerAccumulator - *(_QWORD *)(a1 + 12096)) / (1000.0 * v4);
      InstantPower = v1;
      if (v1 == 0.0)
      {
        InstantPower = (float)(unint64_t)__DisplayGetInstantPower(a1);
      }
      else
      {
        *(_QWORD *)(a1 + 12096) = PowerAccumulator;
        *(double *)(a1 + 12088) = Current;
      }
      if ((*(_BYTE *)(a1 + 12081) & 1) != 0)
        __DisplayEvaluateCPMSHDRPowerConstraint(a1, InstantPower);
      *(_BYTE *)(a1 + 12081) = 1;
    }
  }
}

uint64_t __DisplayGetInstantPower(uint64_t a1)
{
  uint64_t v2;
  const void *Samples;
  uint64_t v4;
  uint64_t *v5;
  int v6;
  int v7;
  unint64_t v8;
  uint64_t v9;

  v9 = a1;
  v4 = 0;
  v5 = &v4;
  v6 = 0x20000000;
  v7 = 32;
  v8 = 0x8000000000000000;
  if (*(_QWORD *)(a1 + 12168))
  {
    if (*(_QWORD *)(v9 + 12160))
    {
      Samples = (const void *)IOReportCreateSamples();
      if (Samples)
      {
        IOReportIterate();
        CFRelease(Samples);
      }
    }
  }
  v2 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v2;
}

void __DisplayEvaluateCPMSHDRPowerConstraint(uint64_t a1, float a2)
{
  uint64_t inited;
  NSObject *v3;
  float v4;
  unsigned int HDRAPLColumn;
  float CPMSPowerConstraint;
  uint8_t v9[40];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  CPMSPowerConstraint = __DisplayGetCPMSPowerConstraint(a1);
  HDRAPLColumn = DisplayGetHDRAPLColumn(a1);
  v4 = __DisplayPhysicalBrightnessToPowerInternal(a1, HDRAPLColumn, *(float *)(a1 + 1544));
  if ((*(_BYTE *)(a1 + 12082) & 1) == 0 && CPMSPowerConstraint < v4)
    *(_BYTE *)(a1 + 12082) = 1;
  if (_logHandle)
  {
    v3 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v3 = inited;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v9, COERCE__INT64(a2), COERCE__INT64(CPMSPowerConstraint), COERCE__INT64(v4));
    _os_log_debug_impl(&dword_1B5291000, v3, OS_LOG_TYPE_DEBUG, "CPMS: Current Power Output:%f Budget Constraint:%f/%f", v9, 0x20u);
  }
  if (a2 > CPMSPowerConstraint)
    __DisplayUpdateHDRCap(a1);
}

void __DisplayCPMSHDRCallbackDCPStage1(NSObject **a1)
{
  NSObject *v1;
  uint64_t block;
  int v3;
  int v4;
  void (*v5)(_QWORD *);
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  NSObject **v10;
  _QWORD v11[2];
  int v12;
  int v13;
  CFAbsoluteTime Current;
  _QWORD v15[2];
  int v16;
  int v17;
  uint64_t v18;
  _QWORD v19[2];
  int v20;
  int v21;
  uint64_t v22;
  NSObject **v23;

  v23 = a1;
  v19[0] = 0;
  v19[1] = v19;
  v20 = 0x20000000;
  v21 = 32;
  v22 = 0;
  v15[0] = 0;
  v15[1] = v15;
  v16 = 0x20000000;
  v17 = 32;
  v18 = 0;
  v11[0] = 0;
  v11[1] = v11;
  v12 = 0x20000000;
  v13 = 32;
  Current = 0.0;
  Current = CFAbsoluteTimeGetCurrent();
  CFRetain(v23);
  v1 = v23[19];
  block = MEMORY[0x1E0C809B0];
  v3 = -1073741824;
  v4 = 0;
  v5 = ____DisplayCPMSHDRCallbackDCPStage1_block_invoke;
  v6 = &unk_1E68EB698;
  v7 = v15;
  v10 = v23;
  v8 = v19;
  v9 = v11;
  dispatch_async(v1, &block);
  _Block_object_dispose(v11, 8);
  _Block_object_dispose(v15, 8);
  _Block_object_dispose(v19, 8);
}

void sub_1B53F7444(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,int a26,_Unwind_Exception *exception_object)
{
  uint64_t v27;

  _Block_object_dispose((const void *)(v27 - 88), 8);
  _Block_object_dispose((const void *)(v27 - 56), 8);
  _Unwind_Resume(a1);
}

void __DisplayUpdateHDRCap(uint64_t a1)
{
  float v1;
  uint64_t inited;
  NSObject *v3;
  float v4;
  float v5;
  unsigned int APLColumnOrDefault;
  float CPMSPowerConstraint;
  uint8_t v9[24];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  CPMSPowerConstraint = __DisplayGetCPMSPowerConstraint(a1);
  APLColumnOrDefault = DisplayGetAPLColumnOrDefault(a1, 0x64u);
  v5 = DisplayPowerToPhysicalBrightness(a1, APLColumnOrDefault, CPMSPowerConstraint);
  v4 = fmaxf(*(float *)(a1 + 12108) * *(float *)(a1 + 12188), v5);
  if (*(float *)(a1 + 12108) > v5)
  {
    if (_logHandle)
    {
      v3 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v3 = inited;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_0_2_8_0_8_0((uint64_t)v9, COERCE__INT64(*(float *)(a1 + 12108)), COERCE__INT64(v4));
      _os_log_impl(&dword_1B5291000, v3, OS_LOG_TYPE_INFO, "CPMS: Current HDR Power consumption is too high. Lowering from %f to %f", v9, 0x16u);
    }
    if ((*(_BYTE *)(a1 + 12180) & 1) != 0)
    {
      __DisplaySetHDRFactorWithFade(a1, 0, 0, v4 / *(float *)(a1 + 1664), 1.0);
    }
    else
    {
      *(float *)(a1 + 12108) = v4;
      v1 = _DisplayComputeEDRNitsCap(a1);
      SetLibEDRBrightness(a1, *(float *)(a1 + 1500), v1, *(float *)(a1 + 1192), *(float *)(a1 + 12528));
    }
  }
}

void __DisplayCPMSHDRCallbackDCPStage2(uint64_t a1, uint64_t a2, unint64_t a3, double a4)
{
  float v4;
  float v5;

  v4 = (float)(unint64_t)(a2 - *(_QWORD *)(a1 + 12096)) / (1000.0 * (a4 - *(double *)(a1 + 12088)));
  v5 = v4;
  if (v4 == 0.0)
  {
    v5 = (float)a3;
  }
  else
  {
    *(_QWORD *)(a1 + 12096) = a2;
    *(double *)(a1 + 12088) = a4;
  }
  if ((*(_BYTE *)(a1 + 12081) & 1) != 0)
    __DisplayEvaluateCPMSHDRPowerConstraint(a1, v5);
  *(_BYTE *)(a1 + 12081) = 1;
}

uint64_t __os_log_helper_16_0_4_8_0_8_0_4_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 4;
  *(_DWORD *)(result + 30) = a5;
  return result;
}

id getMLModelClass_3()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLModelClass_softClass_3;
  v13 = getMLModelClass_softClass_3;
  if (!getMLModelClass_softClass_3)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLModelClass_block_invoke_3;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLModelClass_block_invoke_3((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

id getMLArrayBatchProviderClass_3()
{
  id v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t);
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;

  v9 = 0;
  v10 = &v9;
  v11 = 1342177280;
  v12 = 32;
  v8 = getMLArrayBatchProviderClass_softClass_3;
  v13 = getMLArrayBatchProviderClass_softClass_3;
  if (!getMLArrayBatchProviderClass_softClass_3)
  {
    v2 = MEMORY[0x1E0C809B0];
    v3 = -1073741824;
    v4 = 0;
    v5 = __getMLArrayBatchProviderClass_block_invoke_3;
    v6 = &unk_1E68E9ED8;
    v7 = &v9;
    __getMLArrayBatchProviderClass_block_invoke_3((uint64_t)&v2);
  }
  v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);
  return v1;
}

uint64_t __getMLFeatureValueClass_block_invoke_3(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_4();
  Class = objc_getClass("MLFeatureValue");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLFeatureValueClass_softClass_3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CoreMLLibrary_4()
{
  uint64_t v1;

  v1 = CoreMLLibraryCore_4();
  if (!v1)
    abort_report_np();
  return v1;
}

uint64_t CoreMLLibraryCore_4()
{
  if (!CoreMLLibraryCore_frameworkLibrary_4)
    __CoreMLLibraryCore_block_invoke_4();
  return CoreMLLibraryCore_frameworkLibrary_4;
}

uint64_t __getMLModelClass_block_invoke_3(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_4();
  Class = objc_getClass("MLModel");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLModelClass_softClass_3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLPredictionOptionsClass_block_invoke_3(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_4();
  Class = objc_getClass("MLPredictionOptions");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLPredictionOptionsClass_softClass_3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLArrayBatchProviderClass_block_invoke_3(uint64_t a1)
{
  Class Class;
  uint64_t result;

  CoreMLLibrary_4();
  Class = objc_getClass("MLArrayBatchProvider");
  result = a1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = Class;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    result = abort_report_np();
  getMLArrayBatchProviderClass_softClass_3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void AABC::SetDeviceInSleeve(NSObject **this, char a2)
{
  NSObject *v2;
  uint64_t block;
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  AABC *v8;
  char v9;
  char v10;
  AABC *v11;

  v11 = (AABC *)this;
  v10 = a2 & 1;
  v2 = this[509];
  block = MEMORY[0x1E0C809B0];
  v4 = -1073741824;
  v5 = 0;
  v6 = ___ZN4AABC17SetDeviceInSleeveEb_block_invoke;
  v7 = &__block_descriptor_41_e5_v8__0l;
  v8 = v11;
  v9 = a2 & 1;
  dispatch_sync(v2, &block);
}

AABC *AABCFactoryFunction(AABC *a1, const __CFAllocator *a2)
{
  if (AABCFactoryFunction::pred != -1)
    dispatch_once(&AABCFactoryFunction::pred, &__block_literal_global_14);
  return AABC::alloc(a1, a2);
}

AABC *AABC::alloc(AABC *this, const __CFAllocator *a2)
{
  AAB::UpdateCurveStrategy *v2;
  __CFAllocator *v5;

  v5 = (__CFAllocator *)operator new();
  *(_QWORD *)v5 = 0;
  AAB::PreferenceUpdateCurveStrategy::PreferenceUpdateCurveStrategy(v5);
  return AABC::alloc(this, v5, v2);
}

AABC *AABC::alloc(AABC *this, const __CFAllocator *a2, AAB::UpdateCurveStrategy *a3)
{
  const __CFAllocator *v3;
  UInt8 byte7;
  AAB::UpdateCurveStrategy *v6;
  AABC *v7;
  UInt8 *p_byte7;
  __CFUUID *v9;
  AABC *v10;
  AAB::UpdateCurveStrategy *v11;
  AABC *v12;

  v12 = this;
  v11 = a2;
  v10 = (AABC *)CFAllocatorAllocate(this, 4184, 0);
  if (v10)
  {
    v7 = v10;
    v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE30];
    p_byte7 = &byte7;
    v9 = CFUUIDGetConstantUUIDWithBytes(v3, 0x96u, 0x5Fu, 0xC3u, 0xCBu, 0x16u, 0xB8u, 0x48u, 0x2Fu, 0xA6u, 0xC6u, 0x48u, 0x63u, 7u, 0x52u, 0x16u, 0xE9u);
    AABC::AABC(v7, v9, v11);
    return v7;
  }
  else
  {
    v6 = v11;
    if (v11)
      (*(void (**)(AAB::UpdateCurveStrategy *))(*(_QWORD *)v6 + 8))(v6);
  }
  return v10;
}

void AABC::AABC(AABC *this, const __CFUUID *a2, AAB::UpdateCurveStrategy *a3)
{
  AABC::AABC(this, a2, a3);
}

{
  CBSoftWakeAABCDelegate *v3;
  uint64_t inited;
  NSObject *v5;
  uint8_t v7[8];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  AAB::AAB(this, a3);
  *(_QWORD *)this = &unk_1E68E97F0;
  *((_BYTE *)this + 136) = 0;
  *((_BYTE *)this + 144) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_BYTE *)this + 160) = 0;
  *((_BYTE *)this + 161) = 0;
  AABC::ALSFilter::ALSFilter((AABC *)((char *)this + 168));
  AABC::ALSFilter::ALSFilter((AABC *)((char *)this + 216));
  *((_BYTE *)this + 264) = 0;
  *((_QWORD *)this + 35) = 0;
  *((_DWORD *)this + 72) = 0;
  *((_QWORD *)this + 37) = 0;
  std::bitset<3ul>::bitset[abi:ne180100]((_QWORD *)this + 38, 0);
  *((float *)this + 78) = -1.0;
  *((_BYTE *)this + 316) = 0;
  *((_DWORD *)this + 81) = 17;
  *((_DWORD *)this + 92) = 0;
  *((_DWORD *)this + 93) = 0;
  *((_DWORD *)this + 94) = 1;
  *((_BYTE *)this + 400) = 0;
  *((_BYTE *)this + 401) = 0;
  *((_QWORD *)this + 51) = 0;
  *((_QWORD *)this + 53) = 0;
  *((_QWORD *)this + 54) = 0;
  *((_BYTE *)this + 440) = 0;
  *((_BYTE *)this + 441) = 0;
  *((_BYTE *)this + 442) = 0;
  *((_BYTE *)this + 443) = 0;
  *((_BYTE *)this + 444) = 0;
  *((_BYTE *)this + 445) = 0;
  *((_DWORD *)this + 112) = 0;
  *((_BYTE *)this + 452) = 0;
  *((_QWORD *)this + 58) = 0;
  *((_QWORD *)this + 59) = 0;
  *((_QWORD *)this + 60) = 0;
  *((_DWORD *)this + 122) = 0;
  *((_DWORD *)this + 123) = 0;
  *((_DWORD *)this + 124) = 0;
  *((_BYTE *)this + 504) = 0;
  *((_BYTE *)this + 505) = 0;
  *((_BYTE *)this + 506) = 0;
  *((_DWORD *)this + 127) = 0;
  *((_DWORD *)this + 128) = 1;
  *((_DWORD *)this + 129) = 1;
  *((_DWORD *)this + 130) = 0;
  *((_DWORD *)this + 131) = 0;
  *((_DWORD *)this + 132) = 0;
  *((float *)this + 133) = 0.5;
  *((_DWORD *)this + 134) = 1138819072;
  *((float *)this + 135) = -1.0;
  *((float *)this + 136) = -1.0;
  *((float *)this + 137) = -1.0;
  *((_DWORD *)this + 138) = 1138819072;
  *((_DWORD *)this + 141) = 0;
  *((_DWORD *)this + 142) = 1;
  *((_DWORD *)this + 147) = 255;
  *((_QWORD *)this + 74) = 0;
  *((_DWORD *)this + 150) = 0;
  *((_DWORD *)this + 151) = 0;
  *((_DWORD *)this + 152) = 0;
  *((_DWORD *)this + 154) = 0;
  *((_DWORD *)this + 155) = 0;
  *((_DWORD *)this + 156) = 0;
  *((_BYTE *)this + 628) = 0;
  memset((char *)this + 632, 0, 0x28uLL);
  *((_DWORD *)this + 168) = 0;
  *((_DWORD *)this + 169) = 0;
  *((_QWORD *)this + 85) = 0;
  *((_QWORD *)this + 86) = 0;
  *((_QWORD *)this + 87) = 1045220557;
  *((_DWORD *)this + 176) = 0;
  *((float *)this + 177) = 5.0;
  *((_DWORD *)this + 178) = 1124859904;
  *((_DWORD *)this + 179) = 1140457472;
  *((float *)this + 180) = 5.0;
  *((_DWORD *)this + 181) = 1124859904;
  *((_DWORD *)this + 182) = 1140457472;
  *((_DWORD *)this + 183) = 5;
  *((_BYTE *)this + 1552) = 0;
  *((_DWORD *)this + 719) = 0;
  *((_DWORD *)this + 720) = 0;
  *((_DWORD *)this + 721) = 0;
  *((_BYTE *)this + 2888) = 0;
  *((_BYTE *)this + 3320) = 0;
  *((_BYTE *)this + 3401) = 0;
  *((_DWORD *)this + 851) = 1;
  *((_BYTE *)this + 3416) = 0;
  *((_BYTE *)this + 3417) = 0;
  *((_BYTE *)this + 3418) = 1;
  *((_DWORD *)this + 855) = 0;
  *((_OWORD *)this + 214) = AABC::_defaultSettings;
  *((_OWORD *)this + 215) = xmmword_1B5462528;
  *((_DWORD *)this + 864) = 3;
  *((_BYTE *)this + 3460) = 0;
  *((_QWORD *)this + 489) = 0;
  *((_BYTE *)this + 3937) = 1;
  *((float *)this + 985) = 3.0;
  *((_DWORD *)this + 986) = 0;
  *((_DWORD *)this + 987) = 0;
  *((_DWORD *)this + 988) = 0;
  *((_DWORD *)this + 989) = 0;
  *((_DWORD *)this + 990) = 0;
  *((_DWORD *)this + 991) = 0;
  *((_DWORD *)this + 992) = 0;
  *((_QWORD *)this + 497) = 0;
  *((_DWORD *)this + 996) = 0;
  *((_DWORD *)this + 997) = 1045220557;
  *((_DWORD *)this + 998) = 1045220557;
  *((_DWORD *)this + 999) = 981668463;
  *((_DWORD *)this + 1000) = 1036831949;
  *((_DWORD *)this + 1001) = 1036831949;
  *((_DWORD *)this + 1002) = 0;
  *((_QWORD *)this + 502) = 0;
  *((_DWORD *)this + 1006) = 0;
  *((_DWORD *)this + 1008) = 0;
  *((_QWORD *)this + 505) = 1;
  *((_DWORD *)this + 1012) = 0;
  *((_QWORD *)this + 509) = 0;
  *((_BYTE *)this + 4160) = 0;
  *((_QWORD *)this + 521) = 0;
  *((_BYTE *)this + 4176) = 0;
  _logHandle = (uint64_t)os_log_create("com.apple.CoreBrightness.AABC", "default");
  if (_logHandle)
  {
    v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v5 = inited;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v7, 4);
    _os_log_debug_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEBUG, "[%x]: ", v7, 8u);
  }
  memset((char *)this + 632, 0, 0x28uLL);
  *((_DWORD *)this + 158) = 0;
  *((_DWORD *)this + 167) = 0;
  *((_DWORD *)this + 166) = *((_DWORD *)this + 167);
  *((_DWORD *)this + 162) = 0;
  *((_DWORD *)this + 163) = 0;
  *((_DWORD *)this + 164) = 0;
  *((_DWORD *)this + 165) = 0;
  *((_BYTE *)this + 3368) = 0;
  *((_QWORD *)this + 422) = 0;
  *((_QWORD *)this + 424) = 0x4072C00000000000;
  *((_QWORD *)this + 423) = 0;
  *((_DWORD *)this + 843) = 3;
  *((_BYTE *)this + 4084) = 0;
  *((_DWORD *)this + 1022) = 0;
  *((_DWORD *)this + 1020) = 0;
  *((_BYTE *)this + 4092) = 0;
  memset((char *)this + 3704, 0, 0xD0uLL);
  *((_DWORD *)this + 926) = -1;
  *((_QWORD *)this + 488) = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 1);
  *((_QWORD *)this + 490) = objc_alloc_init(AABCHistograms);
  *((_QWORD *)this + 491) = objc_alloc_init(ALSOcclusionStats);
  if (+[CBSoftWakeAABCDelegate isSupported](CBSoftWakeAABCDelegate, "isSupported"))
    v3 = objc_alloc_init(CBSoftWakeAABCDelegate);
  else
    v3 = 0;
  *((_QWORD *)this + 507) = v3;
  AABC::UpdateState((uint64_t)this, 0);
}

void AABC::operator delete(void *a1)
{
  uint64_t inited;
  NSObject *v2;
  uint8_t v4[24];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (_logHandle)
  {
    v2 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v2 = inited;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v4, (uint64_t)a1);
    _os_log_impl(&dword_1B5291000, v2, OS_LOG_TYPE_INFO, "%p", v4, 0xCu);
  }
  (*(void (**)(void *))(*(_QWORD *)a1 + 32))(a1);
  CFAllocatorDeallocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1);
}

void sub_1B53FD598(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void AAB::AAB(AAB *this, AAB::UpdateCurveStrategy *a2)
{
  *(_QWORD *)this = &unk_1E68E97C0;
  *((_DWORD *)this + 2) = 1070315492;
  *((_DWORD *)this + 3) = 1031954742;
  *((_DWORD *)this + 4) = 1070315492;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = 1157234688;
  *((_DWORD *)this + 7) = 1133903872;
  *((float *)this + 8) = -1.0;
  *((float *)this + 9) = -1.0;
  *((_QWORD *)this + 8) = a2;
  std::mutex::mutex[abi:ne180100]((_QWORD *)this + 9);
}

AABC::ALSFilter *AABC::ALSFilter::ALSFilter(AABC::ALSFilter *this)
{
  AABC::ALSFilter::ALSFilter(this);
  return this;
}

{
  AABC::ALSFilter *result;

  std::vector<float>::vector[abi:ne180100](this);
  result = this;
  *((_WORD *)this + 12) = 0;
  *((_WORD *)this + 20) = 0;
  return result;
}

_QWORD *std::bitset<3ul>::bitset[abi:ne180100](_QWORD *a1, char a2)
{
  std::bitset<3ul>::bitset[abi:ne180100](a1, a2);
  return a1;
}

{
  std::__bitset<1ul,3ul>::__bitset(a1, a2);
  return a1;
}

void AABC::UpdateState(uint64_t a1, int a2)
{
  uint64_t v2;
  NSObject *v3;
  unint64_t v4;
  uint64_t inited;
  NSObject *v6;
  uint8_t v9[48];
  uint8_t v10[40];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 368) != a2)
  {
    if (_logHandle)
    {
      v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v6 = inited;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_2_3_4_0_8_32_8_32((uint64_t)v10, 1, (uint64_t)(&kAABStateStr)[*(unsigned int *)(a1 + 368)], (uint64_t)(&kAABStateStr)[a2]);
      _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "[%x]: _state=%s -> state=%s", v10, 0x1Cu);
    }
    *(_DWORD *)(a1 + 368) = a2;
    v4 = *(unsigned int *)(a1 + 368);
    if (v4 <= 4)
      __asm { BR              X8 }
    if (*(_DWORD *)(a1 + 640) && *(float *)(a1 + 632) < 0.05)
      *(_DWORD *)(a1 + 632) = 1045220557;
    if (_logHandle)
    {
      v3 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v2 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v2 = init_default_corebrightness_log();
      v3 = v2;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_4_0_8_0_8_0_8_0((uint64_t)v9, 2, COERCE__INT64(*(float *)(a1 + 632)), COERCE__INT64(*(float *)(a1 + 4004)), COERCE__INT64(*(float *)(a1 + 3992)));
      _os_log_debug_impl(&dword_1B5291000, v3, OS_LOG_TYPE_DEBUG, "[%x]: _als.interval=%f _Pthreshold_brighten=%f _Pthreshold_dim=%f", v9, 0x26u);
    }
  }
}

void AABC::ALSFilter::~ALSFilter(AABC::ALSFilter *this)
{
  AABC::ALSFilter::~ALSFilter(this);
}

{
  std::vector<float>::~vector[abi:ne180100]((uint64_t *)this);
}

void AAB::~AAB(AAB *this)
{
  uint64_t v1;

  *(_QWORD *)this = &unk_1E68E97C0;
  if (*((_QWORD *)this + 8))
  {
    v1 = *((_QWORD *)this + 8);
    if (v1)
      (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 72));
}

void AABC::~AABC(id *this)
{
  uint64_t inited;
  NSObject *v2;
  uint8_t v4[8];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  *this = &unk_1E68E97F0;
  if (_logHandle)
  {
    v2 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v2 = inited;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v4, 4);
    _os_log_debug_impl(&dword_1B5291000, v2, OS_LOG_TYPE_DEBUG, "[%x]: ", v4, 8u);
  }

  if (this[507])
  {

    this[507] = 0;
  }
  objc_msgSend(this[19], "stop");

  if (this[521])
  AABC::ALSFilter::~ALSFilter((AABC::ALSFilter *)(this + 27));
  AABC::ALSFilter::~ALSFilter((AABC::ALSFilter *)(this + 21));
  AAB::~AAB((AAB *)this);
}

{
  AABC::~AABC(this);
}

{
  AABC::~AABC(this);
  AABC::operator delete(this);
}

void sub_1B53FE77C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

uint64_t AABC::HandleDigitizerEvent(AABC *this, __IOHIDServiceClient *a2, __IOHIDEvent *a3)
{
  uint64_t v4;
  int v5;
  int v6;
  void (*v7)(_QWORD *, uint64_t, id *);
  void *v8;
  AABC *v9;
  __IOHIDEvent *v10;
  __IOHIDServiceClient *v11;
  __IOHIDEvent *v12;
  __IOHIDServiceClient *v13;
  AABC *v14;

  v14 = this;
  v13 = a2;
  v12 = a3;
  v4 = MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = ___ZN4AABC20HandleDigitizerEventEP20__IOHIDServiceClientP12__IOHIDEvent_block_invoke;
  v8 = &__block_descriptor_56_e35_v24__0____IOHIDServiceClient__8_v16l;
  v9 = this;
  v10 = a3;
  v11 = a2;
  return AABC::enumerateALSes((uint64_t)this, (uint64_t)&v4);
}

void AABC::HandleKeyboardEvent(AABC *this, __IOHIDServiceClient *a2, __IOHIDEvent *a3)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t inited;
  NSObject *v18;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t IntegerValue;
  uint8_t v24[16];
  uint8_t v25[16];
  uint8_t v26[16];
  uint8_t v27[16];
  uint8_t v28[16];
  uint8_t v29[16];
  uint8_t v30[16];
  uint8_t v31[40];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  IntegerValue = IOHIDEventGetIntegerValue();
  v22 = IOHIDEventGetIntegerValue();
  v21 = IOHIDEventGetIntegerValue();
  v20 = 0;
  if (_logHandle)
  {
    v18 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v18 = inited;
  }
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_4_0_8_0_8_0_8_0((uint64_t)v31, 2, IntegerValue, v22, v21);
    _os_log_debug_impl(&dword_1B5291000, v18, OS_LOG_TYPE_DEBUG, "[%x]: downEvent=%lx usagePage=%lx usage=%lx", v31, 0x26u);
  }
  if (v22 == 12)
  {
    switch(v21)
    {
      case 48:
        if (_logHandle)
        {
          v16 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v15 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v15 = init_default_corebrightness_log();
          v16 = v15;
        }
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v30, IntegerValue);
          _os_log_debug_impl(&dword_1B5291000, v16, OS_LOG_TYPE_DEBUG, "downEvent=%lx usagePage=kHIDPage_Consumer usage=kHIDUsage_Csmr_Power", v30, 0xCu);
        }
        if (IntegerValue)
          v20 = 1;
        break;
      case 64:
        if (_logHandle)
        {
          v12 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v11 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v11 = init_default_corebrightness_log();
          v12 = v11;
        }
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v28, IntegerValue);
          _os_log_debug_impl(&dword_1B5291000, v12, OS_LOG_TYPE_DEBUG, "downEvent=%lx usagePage=kHIDPage_Consumer usage=kHIDUsage_Csmr_Menu", v28, 0xCu);
        }
        if (IntegerValue)
          v20 = 1;
        break;
      case 547:
        if (_logHandle)
        {
          v14 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v13 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v13 = init_default_corebrightness_log();
          v14 = v13;
        }
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v29, IntegerValue);
          _os_log_debug_impl(&dword_1B5291000, v14, OS_LOG_TYPE_DEBUG, "downEvent=%lx usagePage=kHIDPage_Consumer usage=kHIDUsage_Csmr_ACHome", v29, 0xCu);
        }
        if (IntegerValue)
          v20 = 1;
        break;
    }
  }
  else if (v22 == 65289)
  {
    if (v21 == 1)
    {
      if (_logHandle)
      {
        v10 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v9 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v9 = init_default_corebrightness_log();
        v10 = v9;
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v27, IntegerValue);
        _os_log_debug_impl(&dword_1B5291000, v10, OS_LOG_TYPE_DEBUG, "downEvent=%lx usagePage=kHIDPage_AppleVendorSmartCover usage=kHIDUsage_AppleVendorSmartCover_Open", v27, 0xCu);
      }
      if (IntegerValue)
        *((_DWORD *)this + 1012) = 2;
      else
        *((_DWORD *)this + 1012) = 1;
    }
    else if (v21 == 2)
    {
      if (_logHandle)
      {
        v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v7 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v7 = init_default_corebrightness_log();
        v8 = v7;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v26, IntegerValue);
        _os_log_debug_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEBUG, "downEvent=%lx usagePage=kHIDPage_AppleVendorSmartCover usage=kHIDUsage_AppleVendorSmartCover_Flap1", v26, 0xCu);
      }
      if (*((_DWORD *)this + 1012) != 1)
      {
        if (IntegerValue)
        {
          *((_DWORD *)this + 1012) = 3;
        }
        else
        {
          *((_DWORD *)this + 1012) = 2;
          v20 = 1;
        }
      }
    }
    if (_logHandle)
    {
      v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v5 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v5 = init_default_corebrightness_log();
      v6 = v5;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v25, *((_DWORD *)this + 1012));
      _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "usagePage=kHIDPage_AppleVendorSmartCover SmartCoverState=%d", v25, 8u);
    }
  }
  if (*((_DWORD *)this + 128) && (v20 & 1) != 0 && !*((_DWORD *)this + 122))
  {
    if (*((_QWORD *)this + 58))
      *((_DWORD *)this + 158) = *(_DWORD *)(*((_QWORD *)this + 58) + 40);
    if (*((_DWORD *)this + 160) && *((float *)this + 158) < 0.05)
      *((_DWORD *)this + 158) = 1045220557;
    if (_logHandle)
    {
      v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v3 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v3 = init_default_corebrightness_log();
      v4 = v3;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v24, COERCE__INT64(*((float *)this + 158)));
      _os_log_debug_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEBUG, "Keyboard/Cover event -> turn on ALS sensor with interval %f.", v24, 0xCu);
    }
    *((_DWORD *)this + 167) = 1;
    AABC::UpdateALSState((CFDictionaryRef *)this, 17);
  }
}

uint64_t __os_log_helper_16_0_4_4_0_8_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  return result;
}

void AABC::UpdateALSState(CFDictionaryRef *this, int a2)
{
  const __CFDictionary *theDict;
  _QWORD __b[7];
  int v5;
  CFDictionaryRef *v6;

  v6 = this;
  v5 = a2;
  memset(__b, 0, sizeof(__b));
  __b[0] = this;
  memcpy(&__b[1], this + 79, 0x28uLL);
  LODWORD(__b[6]) = v5;
  theDict = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], this[53]);
  if (theDict)
  {
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)AABC::UpdateALSStateFunction, __b);
    CFRelease(theDict);
  }
}

void AABC::ArmFirstALSSampleTimer(AABC *this)
{
  uint64_t v1;
  dispatch_time_t v2;
  NSObject *source;
  uint64_t inited;
  NSObject *v5;
  _QWORD __b[6];
  uint8_t v8[24];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  __b[5] = this;
  if (!*((_DWORD *)this + 150))
  {
    memset(__b, 0, 0x28uLL);
    __b[1] = this;
    if (_logHandle)
    {
      v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v5 = inited;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(double *)&v1 = CFAbsoluteTimeGetCurrent();
      __os_log_helper_16_0_1_8_0((uint64_t)v8, v1);
      _os_log_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEFAULT, "ts=%f Arming first sample timeout", v8, 0xCu);
    }
    *((_QWORD *)this + 74) = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *((dispatch_queue_t *)this + 509));
    if (*((_QWORD *)this + 74))
    {
      dispatch_set_context(*((dispatch_object_t *)this + 74), this);
      source = *((_QWORD *)this + 74);
      v2 = dispatch_time(0, (uint64_t)(float)(*((float *)this + 852) * 1000000000.0));
      dispatch_source_set_timer(source, v2, 0xFFFFFFFFFFFFFFFFLL, 0);
      dispatch_source_set_event_handler_f(*((dispatch_source_t *)this + 74), (dispatch_function_t)AABC::FirstALSSampleTimeout);
      dispatch_resume(*((dispatch_object_t *)this + 74));
    }
  }
}

void AABC::FirstALSSampleTimeout(AABC *this, void *a2)
{
  AABC::FirstALSSampleTimeout(this);
}

void AABC::FirstALSSampleTimeout(AABC *this)
{
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t inited;
  NSObject *v12;
  float v14;
  CFNumberRef v15;
  uint64_t v16[2];
  uint8_t v17[16];
  uint8_t v18[32];
  uint8_t v19[32];
  uint8_t v20[16];
  uint8_t v21[24];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v16[1] = (uint64_t)this;
  if (*((_QWORD *)this + 48))
  {
    v16[0] = 0;
    *(double *)v16 = (double)mach_absolute_time() * *(double *)&AABC::_sMachTimebaseFactor;
    v15 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, v16);
    if (v15)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), CFSTR("EventTimestampFirstALSSampleTimeout"), v15);
      if (_logHandle)
      {
        v12 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v12 = inited;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v21, v16[0]);
        _os_log_impl(&dword_1B5291000, v12, OS_LOG_TYPE_DEFAULT, "ts=%f FirstALSSampleTimeout fired", v21, 0xCu);
      }
      CFRelease(v15);
    }
  }
  if (_logHandle)
  {
    v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v9 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v9 = init_default_corebrightness_log();
    v10 = v9;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v20, 4);
    _os_log_debug_impl(&dword_1B5291000, v10, OS_LOG_TYPE_DEBUG, "[%x]: ", v20, 8u);
  }
  *((_BYTE *)this + 442) = 1;
  if ((*((_BYTE *)this + 443) & 1) != 0)
    *((_BYTE *)this + 441) = 1;
  if (_logHandle)
  {
    v8 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v7 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v7 = init_default_corebrightness_log();
    v8 = v7;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if ((*((_BYTE *)this + 441) & 1) != 0)
      v1 = "YES";
    else
      v1 = "NO";
    __os_log_helper_16_2_2_8_32_8_0((uint64_t)v19, (uint64_t)v1, COERCE__INT64(*((float *)this + 852)));
    _os_log_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEFAULT, "TIMEOUT!! - Potentially busted ALS? %s!!! (timeout=%f)\n", v19, 0x16u);
  }
  if (*((_QWORD *)this + 74))
  {
    if (!*((_DWORD *)this + 150))
    {
      if (*((_DWORD *)this + 169))
      {
        if (*((_QWORD *)this + 58))
          *((_DWORD *)this + 158) = *(_DWORD *)(*((_QWORD *)this + 58) + 44);
        if (*((_DWORD *)this + 160) && *((float *)this + 158) < 0.05)
          *((_DWORD *)this + 158) = 1045220557;
        *((_DWORD *)this + 167) = 2;
        AABC::UpdateALSState((CFDictionaryRef *)this, 17);
      }
      if (*((_DWORD *)this + 128) && (*((_BYTE *)this + 443) & 1) == 0)
      {
        *((_DWORD *)this + 136) = 1138819072;
        *((_DWORD *)this + 137) = 1138819072;
        *((_DWORD *)this + 139) = 1138819072;
        *((_DWORD *)this + 138) = 1138819072;
        AABC::_UpdateSemanticAmbientLightLevel((uint64_t)this, 0);
        ++*((_DWORD *)this + 150);
        v14 = fminf(fmaxf(AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139)), *((float *)this + 180)), *((float *)this + 182));
        if (_logHandle)
        {
          v6 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v5 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v5 = init_default_corebrightness_log();
          v6 = v5;
        }
        if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
        {
          *(double *)&v2 = CFAbsoluteTimeGetCurrent();
          __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v18, v2, COERCE__INT64(*((float *)this + 136)), COERCE__INT64(v14));
          _os_log_impl(&dword_1B5291000, v6, OS_LOG_TYPE_INFO, "ts=%f Timeout waiting for first ALS sample _Esensor_trusted=%0.4f L=%0.4f. Switching to fast mode\n", v18, 0x20u);
        }
        AABC::UpdateDisplayBrightness_Block6((uint64_t)this, 0, 2, 0, v14);
      }
    }
    dispatch_release(*((dispatch_object_t *)this + 74));
    *((_QWORD *)this + 74) = 0;
  }
  else
  {
    if (_logHandle)
    {
      v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v3 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v3 = init_default_corebrightness_log();
      v4 = v3;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v17, 1);
      _os_log_debug_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEBUG, "[%x]: timer invalid", v17, 8u);
    }
  }
}

float AABC::IlluminanceToLuminance(uint64_t a1, float *a2, float a3, float a4)
{
  uint64_t inited;
  NSObject *v6;
  float v8;
  uint8_t v12[56];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v8 = a4;
  if (a2[25] > 0.0)
    v8 = fminf(a2[25], a3);
  if (_logHandle)
  {
    v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v6 = inited;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v12, COERCE__INT64(a3), COERCE__INT64(a4), COERCE__INT64(a2[25]), COERCE__INT64(v8));
    _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "E %f, Ecapped %f, EmaxCap %f => finalE %f", v12, 0x2Au);
  }
  return AABC::IlluminanceToLuminance(a1, a2, v8);
}

uint64_t AABC::open(AABC *this, io_registry_entry_t a2, int a3, void (*a4)(void *, const __CFString *, const void *), void *a5)
{
  CBAnalyticsScheduler *v5;
  float v6;
  const char *v7;
  uint64_t v9;
  NSObject *v10;
  __CFDictionary *v11;
  __CFDictionary *theDict;
  CFDictionaryKeyCallBacks *keyCallBacks;
  CFDictionaryValueCallBacks *valueCallBacks;
  CFAllocatorRef *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  NSObject *v27;
  CFTypeID v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  NSObject *v32;
  CFTypeID v33;
  uint64_t v34;
  NSObject *v35;
  CFTypeID v36;
  uint64_t v37;
  NSObject *v38;
  CFTypeID TypeID;
  uint64_t v40;
  NSObject *v41;
  CFTypeID v42;
  uint64_t v43;
  NSObject *v44;
  CFTypeID v45;
  uint64_t v46;
  NSObject *v47;
  CFTypeID v48;
  uint64_t v49;
  NSObject *v50;
  CFTypeID v51;
  CFTypeID v52;
  uint64_t inited;
  NSObject *v54;
  CFDictionaryRef OutlierRemovalDictionary;
  const __CFNumber *cf;
  int v58;
  int v59;
  void *value;
  uint64_t v61;
  int v62;
  int v63;
  void (*v64)(uint64_t);
  void *v65;
  AABC *v66;
  os_log_type_t v67;
  os_log_t v68;
  int v69;
  int v70;
  os_log_type_t v71;
  os_log_t oslog;
  int v73;
  os_log_type_t v74;
  os_log_t v75;
  int v76;
  int v77;
  os_log_type_t v78;
  os_log_t v79;
  int v80;
  os_log_type_t v81;
  os_log_t v82;
  int v83;
  os_log_type_t v84;
  os_log_t v85;
  uint64_t v86;
  uint64_t v87;
  CFDataRef v88;
  int v89;
  os_log_type_t v90;
  os_log_t v91;
  os_log_type_t v92;
  os_log_t v93;
  os_log_type_t v94;
  os_log_t v95;
  int v96;
  os_log_type_t v97;
  os_log_t v98;
  _BOOL4 v99;
  os_log_type_t v100;
  os_log_t v101;
  uint64_t v102;
  uint64_t v103;
  CFDataRef v104;
  unsigned int v105;
  os_log_type_t v106;
  os_log_t v107;
  uint64_t v108;
  uint64_t v109;
  CFDataRef v110;
  int v111;
  os_log_type_t v112;
  os_log_t v113;
  uint64_t v114;
  uint64_t v115;
  CFDataRef v116;
  int v117;
  os_log_type_t v118;
  os_log_t v119;
  uint64_t v120;
  uint64_t v121;
  CFDataRef v122;
  int buffer;
  int valuePtr;
  CFTypeRef CFProperty;
  int v126;
  os_log_type_t type;
  os_log_t v128;
  void *v129;
  void (*v130)(void *, const __CFString *, const void *);
  int v131;
  io_registry_entry_t v132;
  AABC *v133;
  dispatch_block_t v134;
  dispatch_once_t *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint8_t v156[16];
  uint8_t v157[16];
  uint8_t v158[16];
  uint8_t v159[16];
  uint8_t v160[16];
  uint8_t v161[16];
  uint8_t v162[16];
  uint8_t v163[16];
  uint8_t v164[16];
  uint8_t v165[16];
  uint8_t v166[16];
  uint8_t v167[32];
  uint8_t v168[32];
  uint8_t v169[32];
  uint8_t v170[32];
  uint8_t v171[8];
  uint64_t v172;
  CFRange v173;
  CFRange v174;
  CFRange v175;
  CFRange v176;
  CFRange v177;

  v172 = *MEMORY[0x1E0C80C00];
  v133 = this;
  v132 = a2;
  v131 = a3;
  v130 = a4;
  v129 = a5;
  v128 = 0;
  if (_logHandle)
  {
    v54 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v54 = inited;
  }
  v128 = v54;
  type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v171, 4);
    _os_log_debug_impl(&dword_1B5291000, v128, type, "[%x]: ", v171, 8u);
  }
  v126 = MGGetSInt32Answer();
  *((_DWORD *)this + 80) = v126;
  *((_QWORD *)this + 48) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_DWORD *)this + 140) = 0;
  *((_BYTE *)this + 1152) = 0;
  *((float *)this + 289) = -1.0;
  *((float *)this + 290) = -1.0;
  *((float *)this + 291) = -1.0;
  *((float *)this + 292) = -1.0;
  *((float *)this + 293) = -1.0;
  *((float *)this + 294) = -1.0;
  *((float *)this + 295) = -1.0;
  if (v132)
  {
    CFProperty = 0;
    CFProperty = IORegistryEntryCreateCFProperty(v132, CFSTR("crgb"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (CFProperty)
    {
      v52 = CFGetTypeID(CFProperty);
      if (v52 == CFNumberGetTypeID())
      {
        valuePtr = 0;
        CFNumberGetValue((CFNumberRef)CFProperty, kCFNumberIntType, &valuePtr);
        if (valuePtr)
          *((_BYTE *)this + 1152) = 1;
      }
      CFRelease(CFProperty);
    }
    CFProperty = 0;
    CFProperty = IORegistryEntrySearchCFProperty(v132, "IOService", CFSTR("ALSBrightenPdeltaSlow"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (CFProperty)
    {
      v51 = CFGetTypeID(CFProperty);
      if (v51 == CFDataGetTypeID())
      {
        buffer = 0;
        v122 = (CFDataRef)CFProperty;
        if (CFDataGetLength((CFDataRef)CFProperty) == 4)
        {
          v153 = 0;
          v152 = 4;
          v154 = 0;
          v155 = 4;
          v120 = 0;
          v121 = 4;
          v173.location = 0;
          v173.length = 4;
          CFDataGetBytes(v122, v173, (UInt8 *)&buffer);
          *((float *)this + 1000) = (float)buffer / 65536.0;
          v119 = 0;
          if (_logHandle)
          {
            v50 = _logHandle;
          }
          else
          {
            v49 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            v50 = v49;
          }
          v119 = v50;
          v118 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_4_0_8_0((uint64_t)v170, 1, COERCE__INT64(*((float *)this + 1000)));
            _os_log_debug_impl(&dword_1B5291000, v119, v118, "[%x]: _Pthreshold_brighten_slow overriden to %f in ioreg", v170, 0x12u);
          }
        }
      }
      CFRelease(CFProperty);
    }
    CFProperty = 0;
    CFProperty = IORegistryEntrySearchCFProperty(v132, "IOService", CFSTR("ALSBrightenPdeltaFast"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (CFProperty)
    {
      v48 = CFGetTypeID(CFProperty);
      if (v48 == CFDataGetTypeID())
      {
        v117 = 0;
        v116 = (CFDataRef)CFProperty;
        if (CFDataGetLength((CFDataRef)CFProperty) == 4)
        {
          v149 = 0;
          v148 = 4;
          v150 = 0;
          v151 = 4;
          v114 = 0;
          v115 = 4;
          v174.location = 0;
          v174.length = 4;
          CFDataGetBytes(v116, v174, (UInt8 *)&v117);
          *((float *)this + 999) = (float)v117 / 65536.0;
          v113 = 0;
          if (_logHandle)
          {
            v47 = _logHandle;
          }
          else
          {
            v46 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            v47 = v46;
          }
          v113 = v47;
          v112 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_4_0_8_0((uint64_t)v169, 1, COERCE__INT64(*((float *)this + 999)));
            _os_log_debug_impl(&dword_1B5291000, v113, v112, "[%x]: _Pthreshold_brighten_fast overriden to %f in ioreg", v169, 0x12u);
          }
        }
      }
      CFRelease(CFProperty);
    }
    CFProperty = 0;
    CFProperty = IORegistryEntrySearchCFProperty(v132, "IOService", CFSTR("ALSDimPdeltaSlow"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (CFProperty)
    {
      v45 = CFGetTypeID(CFProperty);
      if (v45 == CFDataGetTypeID())
      {
        v111 = 0;
        v110 = (CFDataRef)CFProperty;
        if (CFDataGetLength((CFDataRef)CFProperty) == 4)
        {
          v145 = 0;
          v144 = 4;
          v146 = 0;
          v147 = 4;
          v108 = 0;
          v109 = 4;
          v175.location = 0;
          v175.length = 4;
          CFDataGetBytes(v110, v175, (UInt8 *)&v111);
          *((float *)this + 997) = (float)v111 / 65536.0;
          v107 = 0;
          if (_logHandle)
          {
            v44 = _logHandle;
          }
          else
          {
            v43 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            v44 = v43;
          }
          v107 = v44;
          v106 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_4_0_8_0((uint64_t)v168, 1, COERCE__INT64(*((float *)this + 997)));
            _os_log_debug_impl(&dword_1B5291000, v107, v106, "[%x]: _Pthreshold_dim_slow overriden to %f in ioreg", v168, 0x12u);
          }
        }
      }
      CFRelease(CFProperty);
    }
    CFProperty = 0;
    CFProperty = IORegistryEntrySearchCFProperty(v132, "IOService", CFSTR("ALSRampLuxThreshold"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (CFProperty)
    {
      v42 = CFGetTypeID(CFProperty);
      if (v42 == CFDataGetTypeID())
      {
        v105 = 0;
        v104 = (CFDataRef)CFProperty;
        if (CFDataGetLength((CFDataRef)CFProperty) == 4)
        {
          v141 = 0;
          v140 = 4;
          v142 = 0;
          v143 = 4;
          v102 = 0;
          v103 = 4;
          v176.location = 0;
          v176.length = 4;
          CFDataGetBytes(v104, v176, (UInt8 *)&v105);
          *((float *)this + 1002) = (float)v105;
          v101 = 0;
          if (_logHandle)
          {
            v41 = _logHandle;
          }
          else
          {
            v40 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            v41 = v40;
          }
          v101 = v41;
          v100 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_4_0_8_0((uint64_t)v167, 1, COERCE__INT64(*((float *)this + 1002)));
            _os_log_debug_impl(&dword_1B5291000, v101, v100, "[%x]: _AbsoluteLuxThreshold overriden to %f in ioreg", v167, 0x12u);
          }
        }
      }
      CFRelease(CFProperty);
    }
    CFProperty = 0;
    v99 = 1;
    CFProperty = IORegistryEntrySearchCFProperty(v132, "IOService", CFSTR("AABNoDimming"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (CFProperty)
    {
      TypeID = CFDataGetTypeID();
      if (TypeID == CFGetTypeID(CFProperty) && CFDataGetLength((CFDataRef)CFProperty) > 0)
      {
        v99 = *CFDataGetBytePtr((CFDataRef)CFProperty) == 0;
        v98 = 0;
        if (_logHandle)
        {
          v38 = _logHandle;
        }
        else
        {
          v37 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          v38 = v37;
        }
        v98 = v38;
        v97 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_0_1_4_0((uint64_t)v166, v99);
          _os_log_impl(&dword_1B5291000, v98, v97, "Full dimming overridden to %d in ioreg", v166, 8u);
        }
      }
      CFRelease(CFProperty);
    }
    CFProperty = 0;
    v96 = 3;
    CFProperty = IORegistryEntrySearchCFProperty(v132, "IOService", CFSTR("AABDimPolicy"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (CFProperty)
    {
      v36 = CFDataGetTypeID();
      if (v36 == CFGetTypeID(CFProperty) && CFDataGetLength((CFDataRef)CFProperty) > 0)
      {
        v96 = *CFDataGetBytePtr((CFDataRef)CFProperty);
        v95 = 0;
        if (_logHandle)
        {
          v35 = _logHandle;
        }
        else
        {
          v34 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          v35 = v34;
        }
        v95 = v35;
        v94 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_4_0((uint64_t)v165, 4, v99);
          _os_log_debug_impl(&dword_1B5291000, v95, v94, "[%x]: Dim policy overridden to %d", v165, 0xEu);
        }
      }
      CFRelease(CFProperty);
    }
    CFProperty = 0;
    *((_BYTE *)this + 136) = 0;
    CFProperty = IORegistryEntrySearchCFProperty(v132, "IOService", CFSTR("is-accessory"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (CFProperty)
    {
      v33 = CFDataGetTypeID();
      if (v33 == CFGetTypeID(CFProperty) && CFDataGetLength((CFDataRef)CFProperty) > 0)
      {
        *((_BYTE *)this + 136) = *CFDataGetBytePtr((CFDataRef)CFProperty) != 0;
        v93 = 0;
        if (_logHandle)
        {
          v32 = _logHandle;
        }
        else
        {
          v31 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          v32 = v31;
        }
        v93 = v32;
        v92 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_4_0((uint64_t)v164, 16, *((_BYTE *)this + 136) & 1);
          _os_log_debug_impl(&dword_1B5291000, v93, v92, "[%x]: isAccessory ? %d\n", v164, 0xEu);
        }
      }
      CFRelease(CFProperty);
    }
    CFProperty = 0;
    *((_DWORD *)this + 858) = 1;
    if (v99)
    {
      v91 = 0;
      if (_logHandle)
      {
        v30 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v29 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v29 = init_default_corebrightness_log();
        v30 = v29;
      }
      v91 = v30;
      v90 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_4_0_4_0((uint64_t)v163, 4, v96);
        _os_log_debug_impl(&dword_1B5291000, v91, v90, "[%x]: Turning on dimming with policy %d", v163, 0xEu);
      }
      if (v96 < 8)
        *((_DWORD *)this + 858) = v96;
    }
    else
    {
      *((_DWORD *)this + 858) = 0;
    }
    *((_DWORD *)this + 859) = *((_DWORD *)this + 858);
    CFProperty = IORegistryEntrySearchCFProperty(v132, "IOService", CFSTR("min-curve-version"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3u);
    if (CFProperty)
    {
      v28 = CFGetTypeID(CFProperty);
      if (v28 == CFDataGetTypeID())
      {
        v89 = 0;
        v88 = (CFDataRef)CFProperty;
        if (CFDataGetLength((CFDataRef)CFProperty) == 4)
        {
          v137 = 0;
          v136 = 4;
          v138 = 0;
          v139 = 4;
          v86 = 0;
          v87 = 4;
          v177.location = 0;
          v177.length = 4;
          CFDataGetBytes(v88, v177, (UInt8 *)&v89);
          if (v89 > 5)
          {
            *((_DWORD *)this + 183) = v89;
            v85 = 0;
            if (_logHandle)
            {
              v27 = _logHandle;
            }
            else
            {
              v26 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              v27 = v26;
            }
            v85 = v27;
            v84 = OS_LOG_TYPE_DEBUG;
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_0_1_4_0((uint64_t)v162, *((_DWORD *)this + 183));
              _os_log_debug_impl(&dword_1B5291000, v85, v84, "Min curve version set to %d", v162, 8u);
            }
          }
        }
      }
      CFRelease(CFProperty);
    }
    CFProperty = 0;
    v83 = 0;
    if ((load_int_from_edt(v132, CFSTR("supports-float-lux"), &v83) & 1) == 0)
      v83 = 0;
    *((_BYTE *)this + 3936) = v83 != 0;
    v82 = 0;
    if (_logHandle)
    {
      v25 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v24 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v24 = init_default_corebrightness_log();
      v25 = v24;
    }
    v82 = v25;
    v81 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v161, *((_BYTE *)this + 3936) & 1);
      _os_log_debug_impl(&dword_1B5291000, v82, v81, "supports-float-lux=%d", v161, 8u);
    }
  }
  *((_DWORD *)this + 93) = v131;
  *((_QWORD *)this + 42) = -1;
  v80 = MGGetSInt32Answer();
  *((_QWORD *)this + 42) = v80;
  if (*((uint64_t *)this + 42) <= 0)
  {
    v73 = MGGetSInt32Answer();
    *((_QWORD *)this + 42) = v73;
    oslog = 0;
    if (_logHandle)
    {
      v19 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v18 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v18 = init_default_corebrightness_log();
      v19 = v18;
    }
    oslog = v19;
    v71 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v158, *((_QWORD *)this + 42));
      _os_log_debug_impl(&dword_1B5291000, oslog, v71, "Cover color: 0x%llX\n", v158, 0xCu);
    }
    if (*((_QWORD *)this + 42) != -1)
    {
      v69 = MGGetSInt32Answer();
      v70 = v69;
      v68 = 0;
      if (_logHandle)
      {
        v17 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v16 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v16 = init_default_corebrightness_log();
        v17 = v16;
      }
      v68 = v17;
      v67 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_4_0((uint64_t)v157, v70);
        _os_log_debug_impl(&dword_1B5291000, v68, v67, "Enclosure color: 0x%X\n", v157, 8u);
      }
      if (v70 != -1)
        *((_QWORD *)this + 42) |= (uint64_t)v70 << 32;
    }
  }
  else
  {
    v79 = 0;
    if (_logHandle)
    {
      v23 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v22 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v22 = init_default_corebrightness_log();
      v23 = v22;
    }
    v79 = v23;
    v78 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v160, *((_QWORD *)this + 42));
      _os_log_debug_impl(&dword_1B5291000, v79, v78, "Cover color (new): 0x%llX\n", v160, 0xCu);
    }
    v76 = MGGetSInt32Answer();
    v77 = v76;
    v75 = 0;
    if (_logHandle)
    {
      v21 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v20 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v20 = init_default_corebrightness_log();
      v21 = v20;
    }
    v75 = v21;
    v74 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v159, v77);
      _os_log_debug_impl(&dword_1B5291000, v75, v74, "Enclosure color (new): 0x%X\n", v159, 8u);
    }
    if (v77 != -1)
      *((_QWORD *)this + 42) |= (uint64_t)v77 << 32;
  }
  v5 = +[CBAnalyticsScheduler sharedInstance](CBAnalyticsScheduler, "sharedInstance");
  v61 = MEMORY[0x1E0C809B0];
  v62 = -1073741824;
  v63 = 0;
  v64 = ___ZN4AABC4openEjiPFvPvPK10__CFStringPKvES0__block_invoke;
  v65 = &__block_descriptor_40_e5_v8__0l;
  v66 = this;
  *((_QWORD *)this + 489) = -[CBAnalyticsScheduler registerHandler:](v5, "registerHandler:", &v61);
  *((_DWORD *)this + 125) = 0;
  if (*((_DWORD *)this + 94))
  {
    v135 = &AABC::open(unsigned int,int,void (*)(void *,__CFString const*,void const*),void *)::pred;
    v134 = &__block_literal_global_155;
    if (AABC::open(unsigned int,int,void (*)(void *,__CFString const*,void const*),void *)::pred != -1)
      dispatch_once(v135, v134);
    v15 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    keyCallBacks = (CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    *((_QWORD *)this + 53) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], 0);
    valueCallBacks = (CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    *((_QWORD *)this + 54) = CFDictionaryCreateMutable(*v15, 0, keyCallBacks, MEMORY[0x1E0C9B3A0]);
    *((_QWORD *)this + 44) = v130;
    *((_QWORD *)this + 45) = v129;
    value = 0;
    *((_QWORD *)this + 49) = CFDictionaryCreateMutable(*v15, 0, keyCallBacks, valueCallBacks);
    value = CFNumberCreate(*v15, kCFNumberFloatType, (char *)this + 3452);
    if (value)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("ALSMaxDimDuration"), value);
      CFRelease(value);
    }
    value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 3448);
    if (value)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("ALSMaxBrightenDuration"), value);
      CFRelease(value);
    }
    value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 3444);
    if (value)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("ALSSpikeFilterDuration"), value);
      CFRelease(value);
    }
    value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (char *)this + 3432);
    if (value)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("ALSDimPolicy"), value);
      CFRelease(value);
    }
    theDict = (__CFDictionary *)*((_QWORD *)this + 49);
    if (*((_DWORD *)this + 860))
      CFDictionarySetValue(theDict, CFSTR("ALSLockScreenAutoBrightness"), (const void *)*MEMORY[0x1E0C9AE50]);
    else
      CFDictionarySetValue(theDict, CFSTR("ALSLockScreenAutoBrightness"), (const void *)*MEMORY[0x1E0C9AE40]);
    v59 = 1;
    value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &v59);
    if (value)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("ALSAlgorithm"), value);
      CFRelease(value);
    }
    v58 = 1036831949;
    value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v58);
    if (value)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), CFSTR("ALSIntPeriod"), value);
      CFRelease(value);
    }
    cf = (const __CFNumber *)IORegistryEntryCreateCFProperty(v132, CFSTR("AutoRateControl"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (cf)
    {
      *((_DWORD *)this + 162) = GetCFBooleanValue(cf);
      CFRelease(cf);
    }
    v11 = (__CFDictionary *)*((_QWORD *)this + 48);
    if (*((_DWORD *)this + 162))
      CFDictionarySetValue(v11, CFSTR("BoostPriority"), (const void *)*MEMORY[0x1E0C9AE50]);
    else
      CFDictionarySetValue(v11, CFSTR("BoostPriority"), (const void *)*MEMORY[0x1E0C9AE40]);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("AAPEnabled"), (const void *)*MEMORY[0x1E0C9AE50]);
    OutlierRemovalDictionary = AABC::createOutlierRemovalDictionary((uint64_t)this, (_BYTE *)this + 3368);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), CFSTR("OutlierRemoval"), OutlierRemovalDictionary);
    CFRelease(OutlierRemovalDictionary);
    *((float *)this + 852) = 0.25;
    if ((*((_BYTE *)this + 136) & 1) != 0)
    {
      *((float *)this + 853) = 2.0;
    }
    else
    {
      v6 = 4.0;
      if (!*((_DWORD *)this + 162))
        v6 = 30.0;
      *((float *)this + 853) = v6;
    }
    *((_BYTE *)this + 3472) = 0;
    *((_BYTE *)this + 3473) = 0;
    *((_DWORD *)this + 869) = 0;
    *((_DWORD *)this + 870) = 0;
    *((_DWORD *)this + 871) = 0;
    *((float *)this + 872) = 1.0;
    *((float *)this + 873) = 1.0;
    *((_BYTE *)this + 3588) = 0;
    *((_BYTE *)this + 3589) = 0;
    *((_DWORD *)this + 898) = 0;
    *((_DWORD *)this + 899) = 0;
    *((_DWORD *)this + 900) = 0;
    *((_DWORD *)this + 901) = 1061997773;
    *((float *)this + 902) = 1.0;
  }
  AABC::ParseCustomAABCurvesFromEDT(this, v132);
  if (_logHandle)
  {
    v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v9 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v9 = init_default_corebrightness_log();
    v10 = v9;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    if (*((_DWORD *)this + 94))
      v7 = "true";
    else
      v7 = "false";
    __os_log_helper_16_2_1_8_32((uint64_t)v156, (uint64_t)v7);
    _os_log_impl(&dword_1B5291000, v10, OS_LOG_TYPE_INFO, "ambient adaptive brightness plugin _plugInEnabled=%s", v156, 0xCu);
  }
  return v132;
}

void ___ZN4AABC4openEjiPFvPvPK10__CFStringPKvES0__block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t block;
  int v4;
  int v5;
  uint64_t (*v6)(uint64_t);
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = a1;
  v9 = a1;
  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 4072);
  block = MEMORY[0x1E0C809B0];
  v4 = -1073741824;
  v5 = 0;
  v6 = ___ZN4AABC4openEjiPFvPvPK10__CFStringPKvES0__block_invoke_2;
  v7 = &__block_descriptor_40_e5_v8__0l;
  v8 = v1;
  dispatch_async(v2, &block);
}

uint64_t ___ZN4AABC4openEjiPFvPvPK10__CFStringPKvES0__block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  BOOL v3;
  _BYTE __dst[208];
  uint64_t v5;
  uint64_t v6;

  v6 = a1;
  v5 = a1;
  v2 = *(_QWORD *)(a1 + 32);
  +[CBAnalytics alsSelectionSwaps:](CBAnalytics, "alsSelectionSwaps:", *(unsigned int *)(v2 + 3896));
  *(_DWORD *)(v2 + 3896) = 0;
  memcpy(__dst, (const void *)(v2 + 3704), sizeof(__dst));
  memset((void *)(v2 + 3808), 0, 0x48uLL);
  memset((void *)(v2 + 3712), 0, 0x60uLL);
  +[CBAnalytics alsSelectionTimes:count:](CBAnalytics, "alsSelectionTimes:count:", &__dst[104], 9);
  +[CBAnalytics alsSelectionDeltas:count:](CBAnalytics, "alsSelectionDeltas:count:", &__dst[8], 12);
  +[CBAnalytics deviceColor:](CBAnalytics, "deviceColor:", *(_QWORD *)(v2 + 336));
  +[CBAnalytics cuveLevel:](CBAnalytics, "cuveLevel:", *(unsigned int *)(v2 + 3404));
  v3 = 0;
  if (*(_DWORD *)(v2 + 512))
    v3 = *(_DWORD *)(v2 + 520) == 0;
  +[CBAnalytics autoBrightnessEnabled:byUser:](CBAnalytics, "autoBrightnessEnabled:byUser:", v3, 0);
  objc_msgSend(*(id *)(v2 + 3920), "submit");
  return objc_msgSend(*(id *)(v2 + 3928), "submit");
}

double ___ZN4AABC4openEjiPFvPvPK10__CFStringPKvES0__block_invoke_3(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  double result;
  mach_timebase_info info;
  uint64_t v5;
  uint64_t v6;

  v6 = a1;
  v5 = a1;
  mach_timebase_info(&info);
  LODWORD(v1) = info.numer;
  LODWORD(v2) = info.denom;
  result = (double)v1 / (double)v2 * 0.000000001;
  AABC::_sMachTimebaseFactor = *(_QWORD *)&result;
  return result;
}

CFDictionaryRef AABC::createOutlierRemovalDictionary(uint64_t a1, _BYTE *a2)
{
  CFAllocatorRef *v3;
  const void *v4;
  CFDictionaryRef v5;
  const void *__b[5];
  const void *__dst[6];

  __dst[5] = *(const void **)MEMORY[0x1E0C80C00];
  memcpy(__dst, off_1E68EB998, 0x28uLL);
  memset(__b, 0, sizeof(__b));
  if ((*a2 & 1) != 0)
    v4 = (const void *)*MEMORY[0x1E0C9AE50];
  else
    v4 = (const void *)*MEMORY[0x1E0C9AE40];
  __b[0] = v4;
  v3 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  __b[1] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, a2 + 4);
  __b[2] = CFNumberCreate(*v3, kCFNumberDoubleType, a2 + 8);
  __b[3] = CFNumberCreate(*v3, kCFNumberDoubleType, a2 + 24);
  __b[4] = CFNumberCreate(*v3, kCFNumberDoubleType, a2 + 16);
  v5 = CFDictionaryCreate(*v3, __dst, __b, 5, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFRelease(__b[4]);
  CFRelease(__b[3]);
  CFRelease(__b[2]);
  CFRelease(__b[1]);
  return v5;
}

void AABC::ParseCustomAABCurvesFromEDT(AABC *this, io_registry_entry_t a2)
{
  const char *v2;
  uint64_t inited;
  NSObject *v4;
  int v6;
  unint64_t v7;
  void *v8;
  io_registry_entry_t v9;
  AABC *v10;
  uint8_t v11[24];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v10 = this;
  v9 = a2;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  if ((load_int_from_edt(a2, CFSTR("support-custom-curve"), &v6) & 1) != 0)
  {
    if (v6)
    {
      v7 = load_float_array_from_edt(v9, CFSTR("low-curve-lux-points"), &v8);
      if (v8)
      {
        if (v7 == 4)
        {
          memcpy((char *)this + 1556, v8, 0x10uLL);
          free(v8);
          v8 = 0;
          v7 = load_float_array_from_edt(v9, CFSTR("low-curve-nits-points"), &v8);
          if (v8)
          {
            if (v7 == 4)
            {
              memcpy((char *)this + 1636, v8, 0x10uLL);
              free(v8);
              v8 = 0;
              *((_DWORD *)this + 429) = 4;
              v7 = load_float_array_from_edt(v9, CFSTR("med-curve-lux-points"), &v8);
              if (v8)
              {
                if (v7 == 4)
                {
                  memcpy((char *)this + 1720, v8, 0x10uLL);
                  free(v8);
                  v8 = 0;
                  v7 = load_float_array_from_edt(v9, CFSTR("med-curve-nits-points"), &v8);
                  if (v8)
                  {
                    if (v7 == 4)
                    {
                      memcpy((char *)this + 1800, v8, 0x10uLL);
                      free(v8);
                      v8 = 0;
                      *((_DWORD *)this + 470) = 4;
                      v7 = load_float_array_from_edt(v9, CFSTR("high-curve-lux-points"), &v8);
                      if (v8)
                      {
                        if (v7 == 4)
                        {
                          memcpy((char *)this + 1884, v8, 0x10uLL);
                          free(v8);
                          v8 = 0;
                          v7 = load_float_array_from_edt(v9, CFSTR("high-curve-nits-points"), &v8);
                          if (v8 && v7 == 4)
                          {
                            memcpy((char *)this + 1964, v8, 0x10uLL);
                            free(v8);
                            v8 = 0;
                            *((_DWORD *)this + 511) = 4;
                            *((_BYTE *)this + 1552) = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (_logHandle)
  {
    v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v4 = inited;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if ((*((_BYTE *)this + 1552) & 1) != 0)
      v2 = "success";
    else
      v2 = "failure";
    __os_log_helper_16_2_1_8_32((uint64_t)v11, (uint64_t)v2);
    _os_log_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEFAULT, "Parsing AAB Curve from EDT: %s", v11, 0xCu);
  }
  if (v8)
    free(v8);
}

void AABC::close(AABC *this)
{
  uint64_t v1;
  uint64_t inited;
  NSObject *v3;
  uint8_t v5[8];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (_logHandle)
  {
    v3 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v3 = inited;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v5, 4);
    _os_log_debug_impl(&dword_1B5291000, v3, OS_LOG_TYPE_DEBUG, "[%x]: ", v5, 8u);
  }
  AABC::CancelFirstSampleTimeout((dispatch_object_t *)this);
  -[CBAnalyticsScheduler removeHandler:](+[CBAnalyticsScheduler sharedInstance](CBAnalyticsScheduler, "sharedInstance"), "removeHandler:", *((_QWORD *)this + 489));
  if (*((_QWORD *)this + 48))
  {
    CFRelease(*((CFTypeRef *)this + 48));
    *((_QWORD *)this + 48) = 0;
  }
  if (*((_QWORD *)this + 497))
  {
    v1 = *((_QWORD *)this + 497);
    if (v1)
      MEMORY[0x1B5E4A400](v1, 0x1000C4052888210);
    *((_QWORD *)this + 497) = 0;
  }
  if (*((_QWORD *)this + 53))
  {
    CFRelease(*((CFTypeRef *)this + 53));
    *((_QWORD *)this + 53) = 0;
  }
  if (*((_QWORD *)this + 54))
  {
    CFRelease(*((CFTypeRef *)this + 54));
    *((_QWORD *)this + 54) = 0;
  }
}

void AABC::registerDisplay(AABC *this, __Display *a2)
{
  int v2;
  const char *v3;
  const char *v4;
  float v5;
  float v6;
  PerceptualLuminanceThresholding_legacy *v7;
  PerceptualLuminanceThresholding_1nit *v8;
  CFDictionaryRef v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  CFTypeID v16;
  CFTypeID v17;
  CFTypeID v18;
  CFTypeID v19;
  CFTypeID v20;
  uint64_t v21;
  NSObject *v22;
  CFTypeID v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  CFTypeID v27;
  uint64_t v28;
  NSObject *v29;
  CFTypeID v30;
  uint64_t v31;
  NSObject *v32;
  CFTypeID v33;
  uint64_t v34;
  NSObject *v35;
  CFTypeID v36;
  uint64_t v37;
  NSObject *v38;
  CFTypeID v39;
  uint64_t v40;
  NSObject *v41;
  CFTypeID v42;
  uint64_t v43;
  NSObject *v44;
  CFTypeID v45;
  uint64_t v46;
  NSObject *v47;
  CFTypeID v48;
  uint64_t v49;
  NSObject *v50;
  CFTypeID v51;
  CFTypeID v52;
  CFTypeID v53;
  CFTypeID v54;
  CFTypeID v55;
  CFTypeID v56;
  CFTypeID v57;
  CFTypeID TypeID;
  CFTypeID v59;
  CFTypeID v60;
  uint64_t v61;
  NSObject *v62;
  uint64_t v63;
  NSObject *v64;
  uint64_t v65;
  NSObject *v66;
  CFTypeID v67;
  uint64_t v68;
  uint64_t v69;
  NSObject *v70;
  float LogicalBrightness;
  uint64_t v72;
  NSObject *v73;
  uint64_t v74;
  NSObject *v75;
  CBExtendedDisplayMitigation *v76;
  BOOL v77;
  uint64_t inited;
  NSObject *v79;
  int m;
  CFArrayRef value;
  int v83;
  int k;
  os_log_type_t v85;
  os_log_t v86;
  os_log_type_t v87;
  os_log_t v88;
  os_log_type_t v89;
  os_log_t oslog;
  CFTypeRef v91;
  CFTypeRef cf;
  _DWORD v93[4];
  _DWORD v94[4];
  int v95;
  int v96;
  os_log_type_t v97;
  os_log_t v98;
  char v99;
  char v100;
  CFDictionaryRef v101;
  uint64_t v102;
  CFNumberRef v103;
  CFNumberRef v104;
  CFNumberRef v105;
  int v106;
  CFNumberRef v107;
  CFNumberRef v108;
  CFNumberRef v109;
  int v110;
  CFNumberRef v111;
  os_log_type_t v112;
  os_log_t v113;
  os_log_type_t v114;
  os_log_t v115;
  os_log_type_t v116;
  os_log_t v117;
  os_log_type_t v118;
  os_log_t v119;
  os_log_type_t v120;
  os_log_t v121;
  os_log_type_t v122;
  os_log_t v123;
  os_log_type_t v124;
  os_log_t v125;
  os_log_type_t v126;
  os_log_t v127;
  int j;
  os_log_type_t v129;
  os_log_t v130;
  int v131;
  float valuePtr;
  int i;
  int v134;
  float v135;
  const __CFNumber *ValueAtIndex;
  _DWORD v137[4];
  _DWORD v138[4];
  _DWORD v139[4];
  _DWORD idx[4];
  int v141;
  int v142;
  char v143;
  char v144;
  char v145;
  char v146;
  CFTypeRef v147;
  os_log_type_t v148;
  os_log_t v149;
  id v150;
  os_log_type_t v151;
  os_log_t v152;
  os_log_type_t v153;
  os_log_t v154;
  _QWORD v155[2];
  BOOL v156;
  CFDictionaryRef v157;
  os_log_type_t v158;
  os_log_t v159;
  os_log_type_t v160;
  os_log_t v161;
  CFDictionaryRef v162;
  os_log_type_t v163;
  os_log_t v164;
  CFBooleanRef v165;
  BOOL v166;
  CFBooleanRef v167;
  CFNumberRef Property;
  os_log_type_t type;
  os_log_t v170;
  __Display *v171;
  AABC *v172;
  const void *__b[9];
  const void *__dst[9];
  void *values[3];
  uint8_t v176[48];
  uint8_t v177[48];
  uint8_t v178[96];
  uint8_t v179[16];
  __int128 v180;
  int v181;
  uint8_t v182[16];
  uint8_t v183[16];
  uint8_t v184[16];
  uint8_t v185[16];
  uint8_t v186[16];
  uint8_t v187[16];
  uint8_t v188[16];
  uint8_t v189[16];
  uint8_t v190[16];
  uint8_t v191[16];
  uint8_t v192[16];
  uint8_t v193[16];
  uint8_t v194[16];
  uint8_t v195[16];
  uint8_t v196[16];
  uint8_t v197[8];
  uint64_t v198;

  v198 = *MEMORY[0x1E0C80C00];
  v172 = this;
  v171 = a2;
  v170 = 0;
  if (_logHandle)
  {
    v79 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v79 = inited;
  }
  v170 = v79;
  type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v197, 4);
    _os_log_debug_impl(&dword_1B5291000, v170, type, "[%x]: ", v197, 8u);
  }
  if (v171 && !*((_QWORD *)this + 51))
  {
    *((_QWORD *)this + 51) = v171;
    Property = 0;
    Property = (CFNumberRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("DisplayProductLuminanceMax"));
    if (Property)
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 716);
    Property = (CFNumberRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("plt-logic-version"));
    if (Property)
      CFNumberGetValue(Property, kCFNumberIntType, (char *)this + 4024);
    Property = (CFNumberRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("DisplayProductLuminanceMid"));
    if (Property)
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 712);
    Property = (CFNumberRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("DisplayProductLuminanceMin"));
    if (Property)
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 708);
    Property = (CFNumberRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("DisplayPanelLuminanceMax"));
    if (Property)
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 728);
    Property = (CFNumberRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("DisplayPanelLuminanceMid"));
    if (Property)
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 724);
    Property = (CFNumberRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("DisplayPanelLuminanceMin"));
    if (Property)
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 720);
    v167 = 0;
    v167 = (CFBooleanRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("PreStrobeDropALSSamples"));
    if (v167)
      *((_BYTE *)this + 505) = CFBooleanGetValue(v167) != 0;
    Property = (CFNumberRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("DisplayTypeA"));
    if (Property)
      CFNumberGetValue(Property, kCFNumberIntType, (char *)this + 2876);
    Property = (CFNumberRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("DefaultCurveVersion"));
    if (Property)
      CFNumberGetValue(Property, kCFNumberIntType, (char *)this + 2880);
    Property = (CFNumberRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("RaiseHighCurve"));
    if (Property)
      CFNumberGetValue(Property, kCFNumberIntType, (char *)this + 2884);
    v166 = 0;
    v165 = 0;
    v165 = (CFBooleanRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("EDMSupported"));
    if (v165)
    {
      v77 = 0;
      if (CFBooleanGetValue(v165))
        v77 = +[CBExtendedDisplayMitigation isSupported](CBExtendedDisplayMitigation, "isSupported");
      v166 = v77;
    }
    if (v166)
      v76 = objc_alloc_init(CBExtendedDisplayMitigation);
    else
      v76 = 0;
    *((_QWORD *)this + 508) = v76;
    v164 = 0;
    if (_logHandle)
    {
      v75 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v74 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v74 = init_default_corebrightness_log();
      v75 = v74;
    }
    v164 = v75;
    v163 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v196, v166);
      _os_log_debug_impl(&dword_1B5291000, v164, v163, "Extended display mitigation supported: %d", v196, 8u);
    }
    v162 = 0;
    v162 = (CFDictionaryRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("AABConstraints"));
    if (v162)
    {
      Property = (CFNumberRef)CFDictionaryGetValue(v162, CFSTR("EmaxAlgo"));
      if (Property)
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1156);
      Property = (CFNumberRef)CFDictionaryGetValue(v162, CFSTR("LmaxAlgo"));
      if (Property)
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1160);
      Property = (CFNumberRef)CFDictionaryGetValue(v162, CFSTR("E2"));
      if (Property)
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1172);
      Property = (CFNumberRef)CFDictionaryGetValue(v162, CFSTR("L2"));
      if (Property)
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1176);
      Property = (CFNumberRef)CFDictionaryGetValue(v162, CFSTR("E0b"));
      if (Property)
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1164);
      Property = (CFNumberRef)CFDictionaryGetValue(v162, CFSTR("L0b"));
      if (Property)
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1168);
      Property = (CFNumberRef)CFDictionaryGetValue(v162, CFSTR("EmaxThreshold"));
      if (Property)
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1180);
    }
    Property = (CFNumberRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("DisplayBrightnessFactor"));
    if (Property)
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 416);
    v161 = 0;
    if (_logHandle)
    {
      v73 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v72 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v72 = init_default_corebrightness_log();
      v73 = v72;
    }
    v161 = v73;
    v160 = OS_LOG_TYPE_INFO;
    if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v195, COERCE__INT64(*((float *)this + 104)));
      _os_log_impl(&dword_1B5291000, v161, v160, "Initial factor %f", v195, 0xCu);
    }
    *((float *)this + 4) = (float)(100.0 - *((float *)this + 177)) / 30.0;
    LogicalBrightness = DisplayGetLogicalBrightness(*((_QWORD *)this + 51));
    *((float *)this + 155) = LogicalBrightness;
    *((float *)this + 154) = LogicalBrightness;
    *((float *)this + 855) = DisplayGetLogicalBrightness(*((_QWORD *)this + 51));
    *((float *)this + 1007) = (float)((float)(*((float *)this + 179) - *((float *)this + 177)) / *((float *)this + 3))
                            / 2.0;
    if (*((float *)this + 295) <= 0.0)
    {
      if (*((float *)this + 289) > 0.0)
        *((_DWORD *)this + 1007) = *((_DWORD *)this + 289);
    }
    else
    {
      *((_DWORD *)this + 1007) = *((_DWORD *)this + 295);
    }
    if (*((float *)this + 292) > 0.0)
      *((float *)this + 4) = (float)(*((float *)this + 292) - *((float *)this + 177)) / 30.0;
    v159 = 0;
    if (_logHandle)
    {
      v70 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v69 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v69 = init_default_corebrightness_log();
      v70 = v69;
    }
    v159 = v70;
    v158 = OS_LOG_TYPE_INFO;
    if (os_log_type_enabled(v70, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v194, COERCE__INT64(*((float *)this + 1007)));
      _os_log_impl(&dword_1B5291000, v159, v158, "_Emax_logical: %0.4f", v194, 0xCu);
    }
    v157 = 0;
    v156 = 0;
    *((_DWORD *)this + 900) = *((_DWORD *)this + 1007);
    *((_DWORD *)this + 866) = *((_DWORD *)this + 181);
    *((_DWORD *)this + 867) = *((_DWORD *)this + 181);
    *((_DWORD *)this + 299) = 0;
    *((_DWORD *)this + 298) = 0;
    *((_DWORD *)this + 297) = 0;
    *((_DWORD *)this + 296) = 0;
    v2 = *((_DWORD *)this + 182);
    *((_DWORD *)this + 303) = v2;
    *((_DWORD *)this + 302) = v2;
    *((_DWORD *)this + 301) = v2;
    *((_DWORD *)this + 300) = v2;
    *((_QWORD *)this + 152) = 0x40AC200000000000;
    *(_QWORD *)((char *)v155 + 1) = 0;
    CFPreferencesSynchronize(CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
    v155[0] = CFPreferencesGetAppBooleanValue(CFSTR("BrightnessRestrictionsFromPreferences"), CFSTR("com.apple.CoreBrightness"), 0) != 0;
    *((_BYTE *)this + 452) = CFPreferencesGetAppBooleanValue(CFSTR("StoreDemoMode"), CFSTR("/var/mobile/Library/Preferences/com.apple.demo-settings"), 0) != 0;
    v68 = *((_QWORD *)this + 51);
    if ((*((_BYTE *)this + 452) & 1) != 0)
      DisplaySetProperty(v68, (uint64_t)CFSTR("CBStoreDemoModeIsPresent"), *MEMORY[0x1E0C9AE50]);
    else
      DisplaySetProperty(v68, (uint64_t)CFSTR("CBStoreDemoModeIsPresent"), *MEMORY[0x1E0C9AE40]);
    if ((*((_BYTE *)this + 452) & 1) != 0 || (v155[0] & 1) != 0)
    {
      *(_QWORD *)((char *)v155 + 1) = CFPreferencesCopyValue(CFSTR("BrightnessRestrictions"), CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
      if (*(_QWORD *)((char *)v155 + 1)
        && (v67 = CFGetTypeID(*(CFTypeRef *)((char *)v155 + 1)), v67 == CFDictionaryGetTypeID()))
      {
        v157 = *(CFDictionaryRef *)((char *)v155 + 1);
        v156 = 1;
        v154 = 0;
        if (_logHandle)
        {
          v66 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v65 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v65 = init_default_corebrightness_log();
          v66 = v65;
        }
        v154 = v66;
        v153 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          if ((*((_BYTE *)this + 452) & 1) != 0)
            v3 = "YES";
          else
            v3 = "NO";
          __os_log_helper_16_2_1_8_32((uint64_t)v193, (uint64_t)v3);
          _os_log_impl(&dword_1B5291000, v154, v153, "BrightnessRestrictions were loaded from CFPreferences (StoreDemoMode = %s)", v193, 0xCu);
        }
      }
      else
      {
        v152 = 0;
        if (_logHandle)
        {
          v64 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v63 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v63 = init_default_corebrightness_log();
          v64 = v63;
        }
        v152 = v64;
        v151 = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
        {
          if ((*((_BYTE *)this + 452) & 1) != 0)
            v4 = "YES";
          else
            v4 = "NO";
          __os_log_helper_16_2_1_8_32((uint64_t)v192, (uint64_t)v4);
          _os_log_error_impl(&dword_1B5291000, v152, v151, "Failed to load BrightnessRestrictions from CFPreferences (StoreDemoMode = %s)", v192, 0xCu);
        }
      }
    }
    v150 = 0;
    v150 = (id)CFPreferencesCopyValue(CFSTR("DisplayOffTimeToRevertAABCurve"), CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      objc_msgSend(v150, "floatValue");
      *((double *)this + 152) = v5;
      v149 = 0;
      if (_logHandle)
      {
        v62 = _logHandle;
      }
      else
      {
        v61 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        v62 = v61;
      }
      v149 = v62;
      v148 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
      {
        objc_msgSend(v150, "floatValue");
        __os_log_helper_16_0_1_8_0((uint64_t)v191, COERCE__INT64(v6));
        _os_log_impl(&dword_1B5291000, v149, v148, "Display off time to revert AAB curve were overriden to %f seconds.", v191, 0xCu);
      }
    }

    if (!v157)
    {
      v157 = (CFDictionaryRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("BrightnessRestrictions"));
      if (v157)
      {
        v147 = CFDictionaryGetValue(v157, CFSTR("multi_point"));
        if (v147)
        {
          v60 = CFGetTypeID(v147);
          if (v60 == CFNumberGetTypeID())
            v156 = CFBooleanGetValue((CFBooleanRef)v147) != 0;
        }
      }
    }
    if (v156)
    {
      v146 = 0;
      v145 = 0;
      v144 = 0;
      v143 = 0;
      if (v157)
      {
        v142 = 0;
        v141 = 6;
        *(_QWORD *)&idx[1] = CFDictionaryGetValue(v157, CFSTR("min_thresholds"));
        if (*(_QWORD *)&idx[1])
        {
          v59 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v59 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)&idx[1]) == v141)
          {
            for (idx[0] = 0; idx[0] < v141; ++idx[0])
            {
              *(_QWORD *)&v139[1] = CFArrayGetValueAtIndex(*(CFArrayRef *)&idx[1], idx[0]);
              if (*(_QWORD *)&v139[1])
              {
                TypeID = CFNumberGetTypeID();
                if (TypeID == CFGetTypeID(*(CFTypeRef *)&v139[1]))
                {
                  CFNumberGetValue(*(CFNumberRef *)&v139[1], kCFNumberFloatType, (char *)this + 4 * idx[0] + 3492);
                  ++v142;
                }
              }
            }
            if (v142 == v141)
              v144 = 1;
          }
        }
        v142 = 0;
        v141 = 6;
        *(_QWORD *)&idx[1] = CFDictionaryGetValue(v157, CFSTR("min_factors"));
        if (*(_QWORD *)&idx[1])
        {
          v57 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v57 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)&idx[1]) == v141)
          {
            for (v139[0] = 0; v139[0] < v141; ++v139[0])
            {
              *(_QWORD *)&v138[1] = CFArrayGetValueAtIndex(*(CFArrayRef *)&idx[1], v139[0]);
              if (*(_QWORD *)&v138[1])
              {
                v56 = CFNumberGetTypeID();
                if (v56 == CFGetTypeID(*(CFTypeRef *)&v138[1]))
                {
                  CFNumberGetValue(*(CFNumberRef *)&v138[1], kCFNumberFloatType, (char *)this + 4 * v139[0] + 3516);
                  ++v142;
                }
              }
            }
            if (v142 == v141)
              v143 = 1;
          }
        }
        if ((v144 & 1) != 0 && (v143 & 1) != 0)
          v146 = 1;
        v144 = 0;
        v143 = 0;
        v142 = 0;
        v141 = 6;
        *(_QWORD *)&idx[1] = CFDictionaryGetValue(v157, CFSTR("max_thresholds"));
        if (*(_QWORD *)&idx[1])
        {
          v55 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v55 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)&idx[1]) == v141)
          {
            for (v138[0] = 0; v138[0] < v141; ++v138[0])
            {
              *(_QWORD *)&v137[1] = CFArrayGetValueAtIndex(*(CFArrayRef *)&idx[1], v138[0]);
              if (*(_QWORD *)&v137[1])
              {
                v54 = CFNumberGetTypeID();
                if (v54 == CFGetTypeID(*(CFTypeRef *)&v137[1]))
                {
                  CFNumberGetValue(*(CFNumberRef *)&v137[1], kCFNumberFloatType, (char *)this + 4 * v138[0] + 3608);
                  ++v142;
                }
              }
            }
            if (v142 == v141)
              v144 = 1;
          }
        }
        v142 = 0;
        v141 = 6;
        *(_QWORD *)&idx[1] = CFDictionaryGetValue(v157, CFSTR("max_factors"));
        if (*(_QWORD *)&idx[1])
        {
          v53 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v53 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)&idx[1]) == v141)
          {
            for (v137[0] = 0; v137[0] < v141; ++v137[0])
            {
              ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(*(CFArrayRef *)&idx[1], v137[0]);
              if (ValueAtIndex)
              {
                v52 = CFNumberGetTypeID();
                if (v52 == CFGetTypeID(ValueAtIndex))
                {
                  CFNumberGetValue(ValueAtIndex, kCFNumberFloatType, (char *)this + 4 * v137[0] + 3632);
                  ++v142;
                }
              }
            }
            if (v142 == v141)
              v143 = 1;
          }
        }
        if ((v144 & 1) != 0 && (v143 & 1) != 0)
          v145 = 1;
        if ((v146 & 1) != 0)
        {
          *((_BYTE *)this + 3472) = 1;
          *((_BYTE *)this + 3473) = 1;
          *((_DWORD *)this + 869) = 2143289344;
          *((_DWORD *)this + 870) = 2143289344;
          *((float *)this + 871) = 2.5;
          *((float *)this + 872) = 5.0;
          memcpy((char *)this + 3540, (char *)this + 3492, 0x30uLL);
          v135 = 1.0;
          v134 = 6;
          if ((*((_BYTE *)this + 452) & 1) != 0)
            v135 = *((float *)this + 891);
          for (i = 0; i < v134; ++i)
            *((float *)this + i + 891) = v135;
        }
        else
        {
          *((_BYTE *)this + 3472) = 0;
        }
        if ((v145 & 1) != 0)
        {
          *((_BYTE *)this + 3588) = 1;
          *((_BYTE *)this + 3589) = 1;
          *((_DWORD *)this + 898) = 2143289344;
          *((_DWORD *)this + 899) = 2143289344;
          *((float *)this + 900) = 2.5;
          *((float *)this + 901) = 5.0;
          memcpy((char *)this + 3656, (char *)this + 3608, 0x30uLL);
          valuePtr = 1.0;
          v131 = 6;
          *(_QWORD *)&idx[1] = CFDictionaryGetValue(v157, CFSTR("max_factor_aab_off"));
          if ((*((_BYTE *)this + 452) & 1) != 0)
          {
            valuePtr = *((float *)this + v131 + 919);
          }
          else if (*(_QWORD *)&idx[1])
          {
            v51 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
            if (v51 == CFNumberGetTypeID())
            {
              CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, &valuePtr);
              v130 = 0;
              if (_logHandle)
              {
                v50 = _logHandle;
              }
              else
              {
                v49 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
                v50 = v49;
              }
              v130 = v50;
              v129 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
              {
                __os_log_helper_16_0_1_8_0((uint64_t)v190, COERCE__INT64(valuePtr));
                _os_log_impl(&dword_1B5291000, v130, v129, "MAX - FACTOR AAB OFF %f", v190, 0xCu);
              }
            }
          }
          for (j = 0; j < v131; ++j)
            *((float *)this + j + 920) = valuePtr;
        }
        else
        {
          *((_BYTE *)this + 3588) = 0;
        }
        *(_QWORD *)&idx[1] = CFDictionaryGetValue(v157, CFSTR("max_rise_time_fast_threshold"));
        if (*(_QWORD *)&idx[1])
        {
          v48 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v48 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3592);
            v127 = 0;
            if (_logHandle)
            {
              v47 = _logHandle;
            }
            else
            {
              v46 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              v47 = v46;
            }
            v127 = v47;
            v126 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v189, COERCE__INT64(*((float *)this + 898)));
              _os_log_impl(&dword_1B5291000, v127, v126, "MAX - RISE TIME FAST THRESHOLD %f", v189, 0xCu);
            }
          }
        }
        *(_QWORD *)&idx[1] = CFDictionaryGetValue(v157, CFSTR("max_rise_time_fast"));
        if (*(_QWORD *)&idx[1])
        {
          v45 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v45 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3596);
            v125 = 0;
            if (_logHandle)
            {
              v44 = _logHandle;
            }
            else
            {
              v43 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              v44 = v43;
            }
            v125 = v44;
            v124 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v188, COERCE__INT64(*((float *)this + 899)));
              _os_log_impl(&dword_1B5291000, v125, v124, "MAX - RISE TIME FAST %f s", v188, 0xCu);
            }
          }
        }
        *(_QWORD *)&idx[1] = CFDictionaryGetValue(v157, CFSTR("max_rise_time"));
        if (*(_QWORD *)&idx[1])
        {
          v42 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v42 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3600);
            v123 = 0;
            if (_logHandle)
            {
              v41 = _logHandle;
            }
            else
            {
              v40 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              v41 = v40;
            }
            v123 = v41;
            v122 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v187, COERCE__INT64(*((float *)this + 900)));
              _os_log_impl(&dword_1B5291000, v123, v122, "MAX - RISE TIME %f s", v187, 0xCu);
            }
          }
        }
        *(_QWORD *)&idx[1] = CFDictionaryGetValue(v157, CFSTR("max_fall_time"));
        if (*(_QWORD *)&idx[1])
        {
          v39 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v39 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3604);
            v121 = 0;
            if (_logHandle)
            {
              v38 = _logHandle;
            }
            else
            {
              v37 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              v38 = v37;
            }
            v121 = v38;
            v120 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v186, COERCE__INT64(*((float *)this + 901)));
              _os_log_impl(&dword_1B5291000, v121, v120, "MAX - FALL TIME %f s", v186, 0xCu);
            }
          }
        }
        *(_QWORD *)&idx[1] = CFDictionaryGetValue(v157, CFSTR("min_rise_time"));
        if (*(_QWORD *)&idx[1])
        {
          v36 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v36 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3484);
            v119 = 0;
            if (_logHandle)
            {
              v35 = _logHandle;
            }
            else
            {
              v34 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              v35 = v34;
            }
            v119 = v35;
            v118 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v185, COERCE__INT64(*((float *)this + 871)));
              _os_log_impl(&dword_1B5291000, v119, v118, "MIN - RISE TIME %f s", v185, 0xCu);
            }
          }
        }
        *(_QWORD *)&idx[1] = CFDictionaryGetValue(v157, CFSTR("min_fall_time"));
        if (*(_QWORD *)&idx[1])
        {
          v33 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v33 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3488);
            v117 = 0;
            if (_logHandle)
            {
              v32 = _logHandle;
            }
            else
            {
              v31 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              v32 = v31;
            }
            v117 = v32;
            v116 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v184, COERCE__INT64(*((float *)this + 872)));
              _os_log_impl(&dword_1B5291000, v117, v116, "MIN - FALL TIME %f s", v184, 0xCu);
            }
          }
        }
        *(_QWORD *)&idx[1] = CFDictionaryGetValue(v157, CFSTR("pivoting_L"));
        if (*(_QWORD *)&idx[1])
        {
          v30 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v30 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3464);
            v115 = 0;
            if (_logHandle)
            {
              v29 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
                v28 = _COREBRIGHTNESS_LOG_DEFAULT;
              else
                v28 = init_default_corebrightness_log();
              v29 = v28;
            }
            v115 = v29;
            v114 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v183, COERCE__INT64(*((float *)this + 866)));
              _os_log_impl(&dword_1B5291000, v115, v114, "Pivoting at L = %f", v183, 0xCu);
            }
            *((_DWORD *)this + 867) = *((_DWORD *)this + 866);
          }
        }
        *(_QWORD *)&idx[1] = CFDictionaryGetValue(v157, CFSTR("pivoting_L_max"));
        if (*(_QWORD *)&idx[1])
        {
          v27 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v27 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3468);
            v113 = 0;
            if (_logHandle)
            {
              v26 = _logHandle;
            }
            else
            {
              v25 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              v26 = v25;
            }
            v113 = v26;
            v112 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v182, COERCE__INT64(*((float *)this + 867)));
              _os_log_impl(&dword_1B5291000, v113, v112, "Max pivoting at L = %f", v182, 0xCu);
            }
          }
        }
      }
    }
    else if (v157)
    {
      v111 = (CFNumberRef)CFDictionaryGetValue(v157, CFSTR("min_Factor"));
      if (v111)
      {
        v110 = 0;
        CFNumberGetValue(v111, kCFNumberFloatType, &v110);
        *((_DWORD *)this + 872) = v110;
        v109 = (CFNumberRef)CFDictionaryGetValue(v157, CFSTR("min_enableTh"));
        if (v109)
          CFNumberGetValue(v109, kCFNumberFloatType, (char *)this + 3476);
        v108 = (CFNumberRef)CFDictionaryGetValue(v157, CFSTR("min_disableTh"));
        if (v108)
          CFNumberGetValue(v108, kCFNumberFloatType, (char *)this + 3480);
        if (v109 && v108)
          *((_BYTE *)this + 3472) = 1;
        v107 = (CFNumberRef)CFDictionaryGetValue(v157, CFSTR("min_Factor_AABOff"));
        if (v107)
          CFNumberGetValue(v107, kCFNumberFloatType, (char *)this + 3492);
        v108 = (CFNumberRef)CFDictionaryGetValue(v157, CFSTR("min_disableTh_lowbound"));
        if (v108)
          CFNumberGetValue(v108, kCFNumberFloatType, (char *)this + 3484);
        else
          *((float *)this + 871) = *((float *)this + 870) - 200.0;
      }
      v111 = (CFNumberRef)CFDictionaryGetValue(v157, CFSTR("max_Factor"));
      if (v111)
      {
        v106 = 0;
        CFNumberGetValue(v111, kCFNumberFloatType, &v106);
        *((_DWORD *)this + 901) = v106;
        v105 = (CFNumberRef)CFDictionaryGetValue(v157, CFSTR("max_enableTh"));
        if (v105)
          CFNumberGetValue(v105, kCFNumberFloatType, (char *)this + 3592);
        v104 = (CFNumberRef)CFDictionaryGetValue(v157, CFSTR("max_disableTh"));
        if (v104)
          CFNumberGetValue(v104, kCFNumberFloatType, (char *)this + 3596);
        if (v105 && v104)
          *((_BYTE *)this + 3588) = 1;
        v103 = (CFNumberRef)CFDictionaryGetValue(v157, CFSTR("max_Factor_AABOff"));
        if (v103)
          CFNumberGetValue(v103, kCFNumberFloatType, (char *)this + 3608);
        v104 = (CFNumberRef)CFDictionaryGetValue(v157, CFSTR("max_disableTh_highbound"));
        if (v104)
          CFNumberGetValue(v104, kCFNumberFloatType, (char *)this + 3600);
      }
    }
    if ((*((_BYTE *)this + 136) & 1) != 0)
    {
      if (*((_DWORD *)this + 720) == 1)
      {
        *((_DWORD *)this + 864) = 2;
        *((float *)this + 35) = 2.0;
        v180 = xmmword_1B5462538;
        v181 = -584398440;
        if ((MGIsDeviceOfType() & 1) != 0)
          *((float *)this + 35) = 15.0;
      }
      if ((_os_feature_enabled_impl() & 1) != 0)
        AABC::setupAABCurvesFromPlist(this);
      else
        AABC::setupAABCurves(this);
      v102 = 0;
      if ((*((_BYTE *)this + 136) & 1) != 0)
        v24 = *MEMORY[0x1E0C9AE50];
      else
        v24 = *MEMORY[0x1E0C9AE40];
      v102 = v24;
      DisplaySetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("ProductTypeAccessory"), v24);
      DisplayAccessoryInitializeBrightnessOverrides(*((_QWORD *)this + 51));
    }
    if (*(_QWORD *)((char *)v155 + 1))
      CFRelease(*(CFTypeRef *)((char *)v155 + 1));
    v101 = 0;
    *(_QWORD *)((char *)v155 + 1) = CFPreferencesCopyValue(CFSTR("AABCurveCap"), CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
    if (*(_QWORD *)((char *)v155 + 1)
      && (v23 = CFGetTypeID(*(CFTypeRef *)((char *)v155 + 1)), v23 == CFDictionaryGetTypeID()))
    {
      v101 = *(CFDictionaryRef *)((char *)v155 + 1);
    }
    else
    {
      v101 = (CFDictionaryRef)DisplayGetProperty(*((_QWORD *)this + 51), (uint64_t)CFSTR("AABCurveCap"));
    }
    v100 = 0;
    v99 = 0;
    v98 = 0;
    if (_logHandle)
    {
      v22 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v21 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v21 = init_default_corebrightness_log();
      v22 = v21;
    }
    v98 = v22;
    v97 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v179, (uint64_t)v101);
      _os_log_impl(&dword_1B5291000, v98, v97, "AAB Curve Cap = %p\n", v179, 0xCu);
    }
    if (v101)
    {
      v96 = 0;
      v95 = 4;
      *(_QWORD *)&v94[1] = CFDictionaryGetValue(v101, CFSTR("E"));
      if (*(_QWORD *)&v94[1])
      {
        v20 = CFGetTypeID(*(CFTypeRef *)&v94[1]);
        if (v20 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)&v94[1]) == v95)
        {
          for (v94[0] = 0; v94[0] < v95; ++v94[0])
          {
            *(_QWORD *)&v93[1] = CFArrayGetValueAtIndex(*(CFArrayRef *)&v94[1], v94[0]);
            if (*(_QWORD *)&v93[1])
            {
              v19 = CFNumberGetTypeID();
              if (v19 == CFGetTypeID(*(CFTypeRef *)&v93[1]))
              {
                CFNumberGetValue(*(CFNumberRef *)&v93[1], kCFNumberFloatType, (char *)this + 4 * v94[0] + 1184);
                ++v96;
              }
            }
          }
          if (v96 == v95)
            v100 = 1;
        }
      }
      v96 = 0;
      *(_QWORD *)&v94[1] = CFDictionaryGetValue(v101, CFSTR("L"));
      if (*(_QWORD *)&v94[1])
      {
        v18 = CFGetTypeID(*(CFTypeRef *)&v94[1]);
        if (v18 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)&v94[1]) == v95)
        {
          for (v93[0] = 0; v93[0] < v95; ++v93[0])
          {
            cf = CFArrayGetValueAtIndex(*(CFArrayRef *)&v94[1], v93[0]);
            if (cf)
            {
              v17 = CFNumberGetTypeID();
              if (v17 == CFGetTypeID(cf))
              {
                CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, (char *)this + 4 * v93[0] + 1200);
                ++v96;
                if (*((float *)this + v93[0] + 300) < 0.0)
                  *((_DWORD *)this + v93[0] + 300) = *((_DWORD *)this + 182);
                if (*((float *)this + v93[0] + 300) < *((float *)this + 180))
                  *((_DWORD *)this + v93[0] + 300) = *((_DWORD *)this + 180);
              }
            }
          }
          if (v96 == v95)
            v99 = 1;
        }
      }
      v91 = CFDictionaryGetValue(v101, CFSTR("revertTime"));
      if (v91)
      {
        v16 = CFNumberGetTypeID();
        if (v16 == CFGetTypeID(v91))
          CFNumberGetValue((CFNumberRef)v91, kCFNumberDoubleType, (char *)this + 1216);
      }
    }
    if ((v100 & 1) != 0 && (v99 & 1) != 0)
    {
      oslog = 0;
      if (_logHandle)
      {
        v15 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v14 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v14 = init_default_corebrightness_log();
        v15 = v14;
      }
      oslog = v15;
      v89 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_8_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v178, COERCE__INT64(*((float *)this + 296)), COERCE__INT64(*((float *)this + 300)), COERCE__INT64(*((float *)this + 297)), COERCE__INT64(*((float *)this + 301)), COERCE__INT64(*((float *)this + 298)), COERCE__INT64(*((float *)this + 302)), COERCE__INT64(*((float *)this + 299)), COERCE__INT64(*((float *)this + 303)));
        _os_log_impl(&dword_1B5291000, oslog, v89, "AAB Curve Cap found: (%f, %f) - (%f, %f) - (%f, %f) - (%f, %f)", v178, 0x52u);
      }
      *((_BYTE *)this + 3401) = 1;
    }
    if (*(_QWORD *)((char *)v155 + 1))
      CFRelease(*(CFTypeRef *)((char *)v155 + 1));
    if ((*((_BYTE *)this + 400) & 1) == 0)
    {
      AABC::CreateDefaultCurves(this);
      *((CFAbsoluteTime *)this + 414) = CFAbsoluteTimeGetCurrent();
      v88 = 0;
      if (_logHandle)
      {
        v13 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v12 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v12 = init_default_corebrightness_log();
        v13 = v12;
      }
      v88 = v13;
      v87 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v177, COERCE__INT64(*((float *)this + 266)), COERCE__INT64(*((float *)this + 268)), COERCE__INT64(*((float *)this + 267)), COERCE__INT64(*((float *)this + 269)));
        _os_log_impl(&dword_1B5291000, v88, v87, "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f", v177, 0x2Au);
      }
      v86 = 0;
      if (_logHandle)
      {
        v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v10 = init_default_corebrightness_log();
        v11 = v10;
      }
      v86 = v11;
      v85 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v176, COERCE__INT64(*((float *)this + 262)), COERCE__INT64(*((float *)this + 263)), COERCE__INT64(*((float *)this + 264)), COERCE__INT64(*((float *)this + 265)));
        _os_log_impl(&dword_1B5291000, v86, v85, "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v176, 0x2Au);
      }
      *((_BYTE *)this + 400) = 1;
      memset(values, 0, sizeof(values));
      for (k = 0; k < 3; ++k)
      {
        v83 = 1;
        memcpy(__dst, off_1E68EB848, sizeof(__dst));
        memset(__b, 0, sizeof(__b));
        __b[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &v83);
        __b[1] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 104 * k + 752);
        __b[2] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 104 * k + 760);
        __b[3] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 104 * k + 756);
        __b[4] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 104 * k + 764);
        __b[5] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 104 * k + 736);
        __b[6] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 104 * k + 740);
        __b[7] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 104 * k + 744);
        __b[8] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)this + 104 * k + 748);
        v9 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __dst, __b, 9, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        values[k] = v9;
        CFRelease(__b[8]);
        CFRelease(__b[7]);
        CFRelease(__b[6]);
        CFRelease(__b[5]);
        CFRelease(__b[4]);
        CFRelease(__b[3]);
        CFRelease(__b[2]);
        CFRelease(__b[1]);
        CFRelease(__b[0]);
      }
      value = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)values, 3, MEMORY[0x1E0C9B378]);
      for (m = 0; m < 3; ++m)
        CFRelease(values[m]);
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), CFSTR("ALSDefaultCurves"), value);
    }
    *((_DWORD *)this + 86) = 1017370378;
    *((_DWORD *)this + 87) = 0;
    AABC::setupDefaultsForAoT(this);
    if (*((_DWORD *)this + 1006) == 1)
    {
      v8 = (PerceptualLuminanceThresholding_1nit *)operator new();
      PerceptualLuminanceThresholding_1nit::PerceptualLuminanceThresholding_1nit(v8, *((_DWORD *)this + 142), *((float *)this + 863), *((float *)this + 862), *((_BYTE *)this + 136) & 1);
      *((_QWORD *)this + 502) = v8;
    }
    else
    {
      v7 = (PerceptualLuminanceThresholding_legacy *)operator new();
      PerceptualLuminanceThresholding_legacy::PerceptualLuminanceThresholding_legacy(v7, *((_DWORD *)this + 142), *((float *)this + 863), *((float *)this + 862), *((_BYTE *)this + 136) & 1);
      *((_QWORD *)this + 502) = v7;
    }
    PerceptualLuminanceThresholding::SetBrightenDuration(*((_QWORD *)this + 502), 2.5);
    PerceptualLuminanceThresholding::SetMaxDimDuration(*((_QWORD *)this + 502), 60.0);
    PerceptualLuminanceThresholding::UpdateTimeConstantTable(*((PerceptualLuminanceThresholding **)this + 502), *((_DWORD *)this + 142));
    *((_BYTE *)this + 2888) = CBU_IsSyncBrightnessTransactionsSupported() & 1;
  }
}

void sub_1B5407000()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void AABC::setupAABCurvesFromPlist(AABC *this)
{
  const __CFDictionary *Value;
  const __CFDictionary *v2;
  CFAbsoluteTime v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  os_log_type_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  os_log_type_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  NSObject *v31;
  NSObject *v32;
  os_log_type_t v33;
  uint64_t v34;
  NSObject *v35;
  NSObject *log;
  os_log_type_t v37;
  uint64_t inited;
  NSObject *v39;
  uint8_t v41[7];
  os_log_type_t v42;
  os_log_t v43;
  os_log_type_t v44;
  os_log_t v45;
  uint8_t v46[7];
  os_log_type_t v47;
  os_log_t v48;
  uint8_t v49[7];
  os_log_type_t v50;
  os_log_t v51;
  os_log_type_t v52;
  os_log_t v53;
  os_log_type_t v54;
  os_log_t v55;
  os_log_type_t v56;
  os_log_t v57;
  os_log_type_t v58;
  os_log_t v59;
  os_log_type_t v60;
  os_log_t v61;
  os_log_type_t v62;
  os_log_t v63;
  uint8_t v64[7];
  os_log_type_t v65;
  os_log_t v66;
  void *key;
  void *v68;
  uint8_t v69[7];
  os_log_type_t type;
  os_log_t oslog;
  double Current;
  char v73;
  CFURLRef url;
  SInt32 errorCode;
  CFDataRef resourceData;
  CFErrorRef error;
  CFStringRef filePath;
  CFDictionaryRef v79;
  CFDictionaryRef theDict;
  AABC *v81;
  uint8_t v82[16];
  uint8_t v83[16];
  uint8_t v84[16];
  uint8_t v85[16];
  uint8_t v86[16];
  uint8_t v87[16];
  uint8_t v88[32];
  __int128 v89;
  int v90;
  __int128 v91;
  int v92;
  __int128 v93;
  int v94;
  __int128 v95;
  int v96;
  uint64_t v97;

  v97 = *MEMORY[0x1E0C80C00];
  v81 = this;
  theDict = 0;
  v79 = 0;
  filePath = 0;
  error = 0;
  resourceData = 0;
  errorCode = 0;
  url = 0;
  v73 = 0;
  Current = CFAbsoluteTimeGetCurrent();
  v79 = (CFDictionaryRef)CFPreferencesCopyValue(CFSTR("CurveOverride"), CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
  if (v79)
  {
    oslog = 0;
    if (_logHandle)
    {
      v39 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v39 = inited;
    }
    oslog = v39;
    type = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      log = oslog;
      v37 = type;
      __os_log_helper_16_0_0(v69);
      _os_log_impl(&dword_1B5291000, log, v37, "using curve data from user defaults", v69, 2u);
    }
LABEL_87:
    Value = (const __CFDictionary *)CFDictionaryGetValue(v79, CFSTR("A"));
    v73 = AABC::populateCurveValuesFromDictionary(this, Value, (CustomCurve *)((char *)this + 1224), 20) & 1;
    if (v73)
    {
      v2 = (const __CFDictionary *)CFDictionaryGetValue(v79, CFSTR("B"));
      v73 = AABC::populateCurveValuesFromDictionary(this, v2, (CustomCurve *)((char *)this + 1388), 20) & 1;
      if (v73)
      {
        v45 = 0;
        if (_logHandle)
        {
          v11 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v10 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v10 = init_default_corebrightness_log();
          v11 = v10;
        }
        v45 = v11;
        v44 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          v3 = CFAbsoluteTimeGetCurrent();
          __os_log_helper_16_0_1_8_0((uint64_t)v82, COERCE__INT64(v3 - Current));
          _os_log_impl(&dword_1B5291000, v45, v44, "loading curves took %0.4fs", v82, 0xCu);
        }
        if (CFPreferencesGetAppBooleanValue(CFSTR("WriteCurveUserDefault"), CFSTR("com.apple.CoreBrightness"), 0))
        {
          AABC::writeCurveToUserDefaults(this, (CustomCurve *)((char *)this + 1224), CFSTR("CustomCurveA"), v4);
          AABC::writeCurveToUserDefaults(this, (CustomCurve *)((char *)this + 1388), CFSTR("CustomCurveB"), v5);
        }
      }
      else
      {
        v48 = 0;
        if (_logHandle)
        {
          v15 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v14 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v14 = init_default_corebrightness_log();
          v15 = v14;
        }
        v48 = v15;
        v47 = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          v12 = v48;
          v13 = v47;
          __os_log_helper_16_0_0(v46);
          _os_log_error_impl(&dword_1B5291000, v12, v13, "error reading curve B from plist", v46, 2u);
        }
      }
    }
    else
    {
      v51 = 0;
      if (_logHandle)
      {
        v19 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v18 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v18 = init_default_corebrightness_log();
        v19 = v18;
      }
      v51 = v19;
      v50 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        v16 = v51;
        v17 = v50;
        __os_log_helper_16_0_0(v49);
        _os_log_error_impl(&dword_1B5291000, v16, v17, "error reading curve A from plist", v49, 2u);
      }
    }
    goto LABEL_117;
  }
  v68 = (void *)MGCopyAnswer();
  key = CFSTR("1");
  v95 = xmmword_1B546254C;
  v96 = 1425254930;
  if ((MGIsDeviceOfType() & 1) != 0)
  {
    key = CFSTR("1");
  }
  else
  {
    v93 = xmmword_1B5462560;
    v94 = 1899561076;
    if ((MGIsDeviceOfType() & 1) != 0)
    {
      key = CFSTR("1");
    }
    else
    {
      v91 = xmmword_1B5462574;
      v92 = -584398440;
      if ((MGIsDeviceOfType() & 1) != 0)
      {
        key = CFSTR("2");
      }
      else
      {
        v89 = xmmword_1B5462588;
        v90 = -879476163;
        if ((MGIsDeviceOfType() & 1) != 0)
        {
          key = CFSTR("3");
        }
        else
        {
          v66 = 0;
          if (_logHandle)
          {
            v35 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v34 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v34 = init_default_corebrightness_log();
            v35 = v34;
          }
          v66 = v35;
          v65 = OS_LOG_TYPE_ERROR;
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            v32 = v66;
            v33 = v65;
            __os_log_helper_16_0_0(v64);
            _os_log_error_impl(&dword_1B5291000, v32, v33, "unknown model", v64, 2u);
          }
        }
      }
    }
  }
  v63 = 0;
  if (_logHandle)
  {
    v31 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v30 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v30 = init_default_corebrightness_log();
    v31 = v30;
  }
  v63 = v31;
  v62 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_2_2_8_64_8_64((uint64_t)v88, (uint64_t)key, (uint64_t)v68);
    _os_log_impl(&dword_1B5291000, v63, v62, "loading curve from plist for model %@ and enclosure color %@", v88, 0x16u);
  }
  filePath = CFStringCreateWithCString(0, "/System/Library/PrivateFrameworks/CoreBrightness.framework/DefaultCurves.plist", 0x8000100u);
  url = CFURLCreateWithFileSystemPath(0, filePath, kCFURLPOSIXPathStyle, 0);
  CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)*MEMORY[0x1E0C9AE00], url, &resourceData, 0, 0, &errorCode);
  if (errorCode)
  {
    v61 = 0;
    if (_logHandle)
    {
      v29 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v28 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v28 = init_default_corebrightness_log();
      v29 = v28;
    }
    v61 = v29;
    v60 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_2_1_8_64((uint64_t)v87, (uint64_t)filePath);
      _os_log_impl(&dword_1B5291000, v61, v60, "unable to open %@", v87, 0xCu);
    }
  }
  else
  {
    theDict = (CFDictionaryRef)CFPropertyListCreateWithData(0, resourceData, 0, 0, &error);
    if (theDict)
    {
      v79 = (CFDictionaryRef)CFDictionaryGetValue(theDict, key);
      if (v79)
      {
        if (!CFDictionaryGetCountOfKey(v79, v68))
        {
          v55 = 0;
          if (_logHandle)
          {
            v23 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v22 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v22 = init_default_corebrightness_log();
            v23 = v22;
          }
          v55 = v23;
          v54 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            __os_log_helper_16_2_1_8_64((uint64_t)v84, (uint64_t)v68);
            _os_log_impl(&dword_1B5291000, v55, v54, "no entry found for color %@, using white instead", v84, 0xCu);
          }
          v68 = CFSTR("2");
        }
        v79 = (CFDictionaryRef)CFDictionaryGetValue(v79, v68);
        if (v79)
          goto LABEL_87;
        v53 = 0;
        if (_logHandle)
        {
          v21 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v20 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v20 = init_default_corebrightness_log();
          v21 = v20;
        }
        v53 = v21;
        v52 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_2_1_8_64((uint64_t)v83, (uint64_t)v68);
          _os_log_impl(&dword_1B5291000, v53, v52, "no entry found for color %@", v83, 0xCu);
        }
      }
      else
      {
        v57 = 0;
        if (_logHandle)
        {
          v25 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v24 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v24 = init_default_corebrightness_log();
          v25 = v24;
        }
        v57 = v25;
        v56 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_2_1_8_64((uint64_t)v85, (uint64_t)key);
          _os_log_impl(&dword_1B5291000, v57, v56, "no entry found for accessory with index %@", v85, 0xCu);
        }
      }
    }
    else
    {
      v59 = 0;
      if (_logHandle)
      {
        v27 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v26 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v26 = init_default_corebrightness_log();
        v27 = v26;
      }
      v59 = v27;
      v58 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_1_8_64((uint64_t)v86, (uint64_t)error);
        _os_log_impl(&dword_1B5291000, v59, v58, "error reading plist: %@", v86, 0xCu);
      }
      if (error)
        CFRelease(error);
    }
  }
LABEL_117:
  if ((v73 & 1) == 0)
  {
    v43 = 0;
    if (_logHandle)
    {
      v9 = _logHandle;
    }
    else
    {
      v8 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v9 = v8;
    }
    v43 = v9;
    v42 = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v6 = v43;
      v7 = v42;
      __os_log_helper_16_0_0(v41);
      _os_log_error_impl(&dword_1B5291000, v6, v7, "error reading default curve", v41, 2u);
    }
  }
  if (resourceData)
    CFRelease(resourceData);
  if (url)
    CFRelease(url);
  if (theDict)
    CFRelease(theDict);
  if (filePath)
    CFRelease(filePath);
}

void AABC::setupAABCurves(AABC *this)
{
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  AABC *v5;
  float v6;
  float v7;
  float v8;
  AABC *v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  size_t v18;
  CFNumberRef v19;
  CFNumberRef v20;
  const __CFAllocator *v21;
  CFIndex v22;
  const __CFString *v23;
  const __CFString *v24;
  CFTypeID v25;
  CFTypeID v26;
  AABC *v27;
  uint64_t v28;
  uint64_t v29;
  size_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  size_t v35;
  size_t v36;
  CFNumberRef v37;
  CFNumberRef v38;
  const __CFAllocator *v39;
  CFIndex v40;
  const __CFString *v41;
  const __CFString *v42;
  const __CFString *v43;
  const __CFString *v44;
  uint64_t v45;
  CFStringRef *v46;
  CFStringRef *v47;
  CFStringRef v48;
  const CFArrayCallBacks *v49;
  CFAllocatorRef *v50;
  const void **v51;
  CFStringRef *v52;
  CFStringRef *v53;
  CFStringRef v54;
  unint64_t v55;
  const void **v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  const void **v60;
  _BYTE *v61;
  _BYTE *v62;
  size_t v63;
  _BYTE *v64;
  _BYTE *v65;
  size_t v66;
  _BYTE *v67;
  _BYTE *v68;
  size_t v69;
  _BYTE *v70;
  _BYTE *v71;
  size_t v72;
  int v73;
  CFTypeID v74;
  int v75;
  CFTypeID v76;
  CFTypeID v77;
  int v78;
  CFTypeID v79;
  CFTypeID v80;
  const CFArrayCallBacks *v81;
  CFAllocatorRef *v82;
  const void **v83;
  CFStringRef *v84;
  CFStringRef *v85;
  CFStringRef v86;
  unint64_t v87;
  const void **v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  const void **v92;
  _BYTE *v93;
  _BYTE *v94;
  uint64_t v95;
  _BYTE *v96;
  _BYTE *v97;
  uint64_t v98;
  _BYTE *v99;
  _BYTE *v100;
  uint64_t v101;
  _BYTE *v102;
  _BYTE *v103;
  uint64_t v104;
  int v105;
  CFTypeID v106;
  int v107;
  CFTypeID v108;
  CFTypeID TypeID;
  int v110;
  CFTypeID v111;
  CFTypeID v112;
  CFTypeID v113;
  const void **v114;
  AABC *v115;
  CFNumberRef v116;
  int v117;
  int i1;
  CFDictionaryRef v119;
  int nn;
  int mm;
  uint64_t v122;
  uint64_t v123;
  uint64_t *v124;
  CFTypeRef v125;
  int kk;
  CFTypeRef v127;
  int jj;
  unsigned __int8 v129;
  unsigned __int8 v130;
  CFTypeRef v131;
  const __CFDictionary *v132;
  int ii;
  CFDictionaryRef v134;
  int n;
  int m;
  uint64_t v137;
  uint64_t v138;
  uint64_t *v139;
  int k;
  float v141;
  float v142;
  const __CFNumber *v143;
  int j;
  const __CFNumber *ValueAtIndex;
  int i;
  unsigned __int8 v147;
  unsigned __int8 Count;
  CFTypeRef Value;
  const __CFDictionary *v150;
  char v151;
  CFTypeRef v152;
  float v153;
  CFTypeRef v154;
  BOOL v155;
  int v156;
  int v157;
  AABC *v158;
  CFArrayRef v159;
  CFArrayRef v160;
  _BYTE v161[44];
  _BYTE v162[44];
  _BYTE v163[48];
  _BYTE v164[48];
  _BYTE v165[48];
  _BYTE v166[48];
  _BYTE v167[48];
  _BYTE v168[48];
  const void *v169[2];
  CFArrayRef v170;
  CFArrayRef v171;
  _BYTE v172[68];
  _BYTE v173[68];
  _BYTE v174[68];
  _BYTE v175[68];
  _BYTE v176[60];
  _BYTE v177[60];
  _BYTE v178[60];
  _BYTE __dst[60];
  void *keys[4];

  v114 = v169;
  keys[3] = *(void **)MEMORY[0x1E0C80C00];
  v158 = this;
  v115 = this;
  v156 = MGGetSInt32Answer();
  v157 = v156;
  if (v156 != 1 && v157 != 2)
    v157 = 1;
  v155 = 0;
  v154 = 0;
  v1 = CFPreferencesCopyValue(CFSTR("CustomCurveVersion"), CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
  v154 = v1;
  if (v1)
  {
    v113 = CFGetTypeID(v154);
    if (v113 == CFNumberGetTypeID())
    {
      v153 = 0.0;
      v152 = v154;
      CFNumberGetValue((CFNumberRef)v154, kCFNumberFloatType, &v153);
      v155 = v153 == 1.1;
    }
    CFRelease(v154);
  }
  v151 = 1;
  if (*((_DWORD *)v115 + 720) != 1 && v155)
  {
    v1 = CFPreferencesCopyValue(CFSTR("CustomCurveA"), CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
    v154 = v1;
    if (v1)
    {
      v112 = CFGetTypeID(v154);
      if (v112 == CFDictionaryGetTypeID())
      {
        v150 = (const __CFDictionary *)v154;
        Count = 0;
        v147 = 0;
        Value = CFDictionaryGetValue((CFDictionaryRef)v154, CFSTR("Ea"));
        if (Value)
        {
          v111 = CFGetTypeID(Value);
          if (v111 == CFArrayGetTypeID())
          {
            Count = CFArrayGetCount((CFArrayRef)Value);
            if (Count <= 0x14u)
              v110 = Count;
            else
              v110 = 20;
            Count = v110;
            for (i = 0; i < Count; ++i)
            {
              ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)Value, i);
              if (ValueAtIndex)
              {
                TypeID = CFNumberGetTypeID();
                if (TypeID == CFGetTypeID(ValueAtIndex))
                  CFNumberGetValue(ValueAtIndex, kCFNumberFloatType, (char *)v115 + 4 * i + 1224);
              }
            }
          }
        }
        Value = CFDictionaryGetValue(v150, CFSTR("La"));
        if (Value)
        {
          v108 = CFGetTypeID(Value);
          if (v108 == CFArrayGetTypeID())
          {
            v147 = CFArrayGetCount((CFArrayRef)Value);
            if (v147 <= 0x14u)
              v107 = v147;
            else
              v107 = 20;
            v147 = v107;
            for (j = 0; j < v147; ++j)
            {
              v143 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)Value, j);
              if (v143)
              {
                v106 = CFNumberGetTypeID();
                if (v106 == CFGetTypeID(v143))
                  CFNumberGetValue(v143, kCFNumberFloatType, (char *)v115 + 4 * j + 1304);
              }
            }
          }
        }
        if (Count <= (int)v147)
          v105 = Count;
        else
          v105 = v147;
        *((_DWORD *)v115 + 346) = v105;
        CFRelease(v150);
        v151 = 0;
      }
      else
      {
        CFRelease(v154);
      }
    }
  }
  if ((v151 & 1) != 0)
  {
    v5 = v115;
    *((_OWORD *)v114 + 34) = xmmword_1E68EBB30;
    if (*((_DWORD *)v5 + 720) == 1)
    {
      v142 = 0.0;
      v141 = 0.0;
      v6 = *((float *)v115 + 177) + 0.735 * (float)(*((float *)v115 + 179) - *((float *)v115 + 177));
      v141 = v6;
      if (v157 == 1)
      {
        v7 = *((float *)v115 + 177) + 0.0028 * (float)(*((float *)v115 + 179) - *((float *)v115 + 177));
        v142 = v7;
        v102 = __dst;
        v104 = 60;
        memcpy(__dst, &unk_1B546259C, sizeof(__dst));
        v103 = v178;
        memcpy(v178, &unk_1B54625D8, sizeof(v178));
        memcpy((char *)v115 + 1224, __dst, 0x3CuLL);
        v1 = memcpy((char *)v115 + 1304, v178, 0x3CuLL);
        *((_DWORD *)v115 + 346) = 15;
      }
      else if (v157 == 2)
      {
        v8 = *((float *)v115 + 177) + 0.0018 * (float)(*((float *)v115 + 179) - *((float *)v115 + 177));
        v142 = v8;
        v99 = v177;
        v101 = 60;
        memcpy(v177, &unk_1B5462614, sizeof(v177));
        v100 = v176;
        memcpy(v176, &unk_1B5462650, sizeof(v176));
        memcpy((char *)v115 + 1224, v177, 0x3CuLL);
        v1 = memcpy((char *)v115 + 1304, v176, 0x3CuLL);
        *((_DWORD *)v115 + 346) = 15;
      }
      for (k = 0; k < *((_DWORD *)v115 + 346); ++k)
      {
        v9 = v115;
        *((float *)v115 + k + 326) = fminf(v141, *((float *)v115 + k + 326));
        *((float *)v9 + k + 326) = fmaxf(v142, *((float *)v9 + k + 326));
      }
    }
    else if (v157 == 1)
    {
      v96 = v175;
      v98 = 68;
      memcpy(v175, &unk_1B546268C, sizeof(v175));
      v97 = v174;
      memcpy(v174, &unk_1B54626D0, sizeof(v174));
      memcpy((char *)v115 + 1224, v175, 0x44uLL);
      v1 = memcpy((char *)v115 + 1304, v174, 0x44uLL);
      *((_DWORD *)v115 + 346) = 17;
    }
    else if (v157 == 2)
    {
      v93 = v173;
      v95 = 68;
      memcpy(v173, &unk_1B5462714, sizeof(v173));
      v94 = v172;
      memcpy(v172, &unk_1B5462758, sizeof(v172));
      memcpy((char *)v115 + 1224, v173, 0x44uLL);
      v1 = memcpy((char *)v115 + 1304, v172, 0x44uLL);
      *((_DWORD *)v115 + 346) = 17;
    }
    v10 = *((unsigned int *)v115 + 346);
    v139 = &v45;
    v87 = (8 * v10 + 15) & 0xFFFFFFFFFFFFFFF0;
    MEMORY[0x1E0C80A78](v1, v2, v3, v4);
    v88 = (const void **)((char *)&v45 - v87);
    v138 = v11;
    v89 = 512;
    if ((unint64_t)(8 * v11) <= 0x200)
      v12 = 8 * v11;
    else
      v12 = 512;
    bzero((char *)&v45 - v87, v12);
    v91 = *((unsigned int *)v115 + 346);
    v90 = (8 * v91 + 15) & 0xFFFFFFFFFFFFFFF0;
    MEMORY[0x1E0C80A78](v13, v14, v15, v16);
    v92 = (const void **)((char *)&v45 - v90);
    v137 = v91;
    if ((unint64_t)(8 * v91) <= 0x200)
      v18 = 8 * v91;
    else
      v18 = v17;
    bzero((char *)&v45 - v90, v18);
    for (m = 0; m < *((_DWORD *)v115 + 346); ++m)
    {
      v19 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)v115 + 4 * m + 1224);
      v88[m] = v19;
    }
    for (n = 0; n < *((_DWORD *)v115 + 346); ++n)
    {
      v20 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)v115 + 4 * n + 1304);
      v92[n] = v20;
    }
    v83 = (const void **)&v170;
    v170 = 0;
    v171 = 0;
    v82 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    v21 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v22 = *((int *)v115 + 346);
    v81 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    v170 = CFArrayCreate(v21, v88, v22, MEMORY[0x1E0C9B378]);
    v171 = CFArrayCreate(*v82, v92, *((int *)v115 + 346), v81);
    v134 = 0;
    v134 = CFDictionaryCreate(*v82, (const void **)keys, v83, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v84 = (CFStringRef *)MEMORY[0x1E0C9B260];
    v23 = (const __CFString *)*MEMORY[0x1E0C9B260];
    v85 = (CFStringRef *)MEMORY[0x1E0C9B250];
    v24 = (const __CFString *)*MEMORY[0x1E0C9B250];
    v86 = CFSTR("com.apple.CoreBrightness");
    CFPreferencesSetValue(CFSTR("CustomCurveA"), v134, CFSTR("com.apple.CoreBrightness"), v23, v24);
    CFPreferencesSynchronize(v86, *v84, *v85);
    for (ii = 0; ii < *((_DWORD *)v115 + 346); ++ii)
    {
      CFRelease(v88[ii]);
      CFRelease(v92[ii]);
    }
    CFRelease(v134);
  }
  v151 = 1;
  if (*((_DWORD *)v115 + 720) != 1 && v155)
  {
    v1 = CFPreferencesCopyValue(CFSTR("CustomCurveB"), CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
    v154 = v1;
    if (v1)
    {
      v80 = CFGetTypeID(v154);
      if (v80 == CFDictionaryGetTypeID())
      {
        v132 = (const __CFDictionary *)v154;
        v131 = 0;
        v130 = 0;
        v129 = 0;
        v131 = CFDictionaryGetValue((CFDictionaryRef)v154, CFSTR("Eb"));
        if (v131)
        {
          v79 = CFGetTypeID(v131);
          if (v79 == CFArrayGetTypeID())
          {
            v130 = CFArrayGetCount((CFArrayRef)v131);
            if (v130 <= 0x14u)
              v78 = v130;
            else
              v78 = 20;
            v130 = v78;
            for (jj = 0; jj < v130; ++jj)
            {
              v127 = 0;
              v127 = CFArrayGetValueAtIndex((CFArrayRef)v131, jj);
              if (v127)
              {
                v77 = CFNumberGetTypeID();
                v25 = CFGetTypeID(v127);
                if (v77 == v25)
                  CFNumberGetValue((CFNumberRef)v127, kCFNumberFloatType, (char *)v115 + 4 * jj + 1388);
              }
            }
          }
        }
        v131 = CFDictionaryGetValue(v132, CFSTR("Lb"));
        if (v131)
        {
          v76 = CFGetTypeID(v131);
          if (v76 == CFArrayGetTypeID())
          {
            v129 = CFArrayGetCount((CFArrayRef)v131);
            if (v129 <= 0x14u)
              v75 = v129;
            else
              v75 = 20;
            v129 = v75;
            for (kk = 0; kk < v129; ++kk)
            {
              v125 = 0;
              v125 = CFArrayGetValueAtIndex((CFArrayRef)v131, kk);
              if (v125)
              {
                v74 = CFNumberGetTypeID();
                v26 = CFGetTypeID(v125);
                if (v74 == v26)
                  CFNumberGetValue((CFNumberRef)v125, kCFNumberFloatType, (char *)v115 + 4 * kk + 1468);
              }
            }
          }
        }
        if (v130 <= (int)v129)
          v73 = v130;
        else
          v73 = v129;
        *((_DWORD *)v115 + 387) = v73;
        CFRelease(v132);
        v151 = 0;
      }
      else
      {
        CFRelease(v154);
      }
    }
  }
  if ((v151 & 1) != 0)
  {
    v27 = v115;
    *(_OWORD *)v114 = xmmword_1E68EBB40;
    if (*((_DWORD *)v27 + 720) == 1)
    {
      if (v157 == 1)
      {
        v70 = v168;
        v72 = 48;
        memcpy(v168, &unk_1B546279C, sizeof(v168));
        v71 = v167;
        memcpy(v167, &unk_1B54627CC, sizeof(v167));
        memcpy((char *)v115 + 1388, v168, 0x30uLL);
        v1 = memcpy((char *)v115 + 1468, v71, v72);
        *((_DWORD *)v115 + 387) = 12;
      }
      else if (v157 == 2)
      {
        v67 = v166;
        v69 = 48;
        memcpy(v166, &unk_1B54627FC, sizeof(v166));
        v68 = v165;
        memcpy(v165, &unk_1B546282C, sizeof(v165));
        memcpy((char *)v115 + 1388, v166, 0x30uLL);
        v1 = memcpy((char *)v115 + 1468, v68, v69);
        *((_DWORD *)v115 + 387) = 12;
      }
    }
    else if (v157 == 1)
    {
      v64 = v164;
      v66 = 48;
      memcpy(v164, &unk_1B546285C, sizeof(v164));
      v65 = v163;
      memcpy(v163, &unk_1B546288C, sizeof(v163));
      memcpy((char *)v115 + 1388, v164, 0x30uLL);
      v1 = memcpy((char *)v115 + 1468, v65, v66);
      *((_DWORD *)v115 + 387) = 12;
    }
    else if (v157 == 2)
    {
      v61 = v162;
      v63 = 44;
      memcpy(v162, &unk_1B54628BC, sizeof(v162));
      v62 = v161;
      memcpy(v161, &unk_1B54628E8, sizeof(v161));
      memcpy((char *)v115 + 1388, v162, 0x2CuLL);
      v1 = memcpy((char *)v115 + 1468, v62, v63);
      *((_DWORD *)v115 + 387) = 11;
    }
    v28 = *((unsigned int *)v115 + 387);
    v124 = &v45;
    v55 = (8 * v28 + 15) & 0xFFFFFFFFFFFFFFF0;
    MEMORY[0x1E0C80A78](v1, v2, v3, v4);
    v56 = (const void **)((char *)&v45 - v55);
    v123 = v29;
    v57 = 512;
    if ((unint64_t)(8 * v29) <= 0x200)
      v30 = 8 * v29;
    else
      v30 = 512;
    bzero((char *)&v45 - v55, v30);
    v59 = *((unsigned int *)v115 + 387);
    v58 = (8 * v59 + 15) & 0xFFFFFFFFFFFFFFF0;
    MEMORY[0x1E0C80A78](v31, v32, v33, v34);
    v60 = (const void **)((char *)&v45 - v58);
    v122 = v59;
    if ((unint64_t)(8 * v59) <= 0x200)
      v36 = 8 * v59;
    else
      v36 = v35;
    bzero((char *)&v45 - v58, v36);
    for (mm = 0; mm < *((_DWORD *)v115 + 387); ++mm)
    {
      v37 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)v115 + 4 * mm + 1388);
      v56[mm] = v37;
    }
    for (nn = 0; nn < *((_DWORD *)v115 + 387); ++nn)
    {
      v38 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, (char *)v115 + 4 * nn + 1468);
      v60[nn] = v38;
    }
    v51 = (const void **)&v159;
    v159 = 0;
    v160 = 0;
    v50 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    v39 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v40 = *((int *)v115 + 387);
    v49 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    v159 = CFArrayCreate(v39, v56, v40, MEMORY[0x1E0C9B378]);
    v160 = CFArrayCreate(*v50, v60, *((int *)v115 + 387), v49);
    v119 = 0;
    v119 = CFDictionaryCreate(*v50, v169, v51, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v52 = (CFStringRef *)MEMORY[0x1E0C9B260];
    v41 = (const __CFString *)*MEMORY[0x1E0C9B260];
    v53 = (CFStringRef *)MEMORY[0x1E0C9B250];
    v42 = (const __CFString *)*MEMORY[0x1E0C9B250];
    v54 = CFSTR("com.apple.CoreBrightness");
    CFPreferencesSetValue(CFSTR("CustomCurveB"), v119, CFSTR("com.apple.CoreBrightness"), v41, v42);
    CFPreferencesSynchronize(v54, *v52, *v53);
    for (i1 = 0; i1 < *((_DWORD *)v115 + 387); ++i1)
    {
      CFRelease(v56[i1]);
      CFRelease(v60[i1]);
    }
    CFRelease(v119);
  }
  if (!v155)
  {
    v117 = 1066192077;
    v116 = 0;
    v116 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &v117);
    v46 = (CFStringRef *)MEMORY[0x1E0C9B260];
    v43 = (const __CFString *)*MEMORY[0x1E0C9B260];
    v47 = (CFStringRef *)MEMORY[0x1E0C9B250];
    v44 = (const __CFString *)*MEMORY[0x1E0C9B250];
    v48 = CFSTR("com.apple.CoreBrightness");
    CFPreferencesSetValue(CFSTR("CustomCurveVersion"), v116, CFSTR("com.apple.CoreBrightness"), v43, v44);
    CFPreferencesSynchronize(v48, *v46, *v47);
    CFRelease(v116);
  }
}

void *AABC::CreateDefaultCurves(AABC *this)
{
  void *result;
  NSObject *v2;
  os_log_type_t v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v9;
  _BYTE v11[108];
  float v12;
  int j;
  float v14;
  uint8_t v15[7];
  os_log_type_t v16;
  NSObject *v17;
  float v18[27];
  int i;
  uint8_t v20[15];
  os_log_type_t v21;
  NSObject *v22;
  AABC *v23;

  v23 = this;
  if ((*((_BYTE *)this + 1552) & 1) != 0)
  {
    v22 = 0;
    if (_logHandle)
    {
      v9 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v9 = inited;
    }
    v22 = v9;
    v21 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      log = v22;
      type = v21;
      __os_log_helper_16_0_0(v20);
      _os_log_impl(&dword_1B5291000, log, type, "Creating AAB Curves from the customCurves.", v20, 2u);
    }
    for (i = 0; i < 3; ++i)
    {
      AAB::customCurveToCurve((const CustomCurve *)((char *)this + 164 * i + 1556), v18);
      memcpy((char *)this + 104 * i + 736, v18, 0x68uLL);
    }
  }
  else
  {
    v17 = 0;
    if (_logHandle)
    {
      v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v4 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v4 = init_default_corebrightness_log();
      v5 = v4;
    }
    v17 = v5;
    v16 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v2 = v17;
      v3 = v16;
      __os_log_helper_16_0_0(v15);
      _os_log_impl(&dword_1B5291000, v2, v3, "No AAB curve present in EDT. Creating Default curves.", v15, 2u);
    }
    v14 = 0.0;
    v14 = *((float *)this + 178);
    if (*((_DWORD *)this + 80) == 6)
      v14 = 149.54;
    for (j = 0; j < 3; ++j)
    {
      v12 = 0.0;
      v12 = *((float *)this + 177);
      if (*((_DWORD *)this + 721) && j == 2)
        v12 = 5.0;
      AAB::DefaultCurve((uint64_t)this, j, *((_BYTE *)this + 1152) & 1, (float *)this + 289, (uint64_t)this + 1164, (float *)this + 293, (uint64_t)v11, v12, v14, *((float *)this + 182));
      memcpy((char *)this + 104 * j + 736, v11, 0x68uLL);
    }
  }
  memcpy((char *)this + 1048, (char *)this + 104 * *((unsigned int *)this + 851) + 736, 0x68uLL);
  *((_DWORD *)this + 286) = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 8) + 104))(*((_QWORD *)this + 8));
  memcpy((char *)this + 2896, (char *)this + 1048, 0x68uLL);
  memcpy((char *)this + 3000, (char *)this + 1048, 0x68uLL);
  *((_DWORD *)this + 774) = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 8) + 112))(*((_QWORD *)this + 8));
  memcpy((char *)this + 3104, (char *)this + 3000, 0x68uLL);
  (*(void (**)(_QWORD, char *))(**((_QWORD **)this + 8) + 80))(*((_QWORD *)this + 8), (char *)this + 2896);
  (*(void (**)(_QWORD, char *))(**((_QWORD **)this + 8) + 88))(*((_QWORD *)this + 8), (char *)this + 3104);
  result = memcpy((char *)this + 3208, (char *)this + 1048, 0x68uLL);
  *((_DWORD *)this + 832) = 0;
  *((_QWORD *)this + 417) = 0;
  *((_QWORD *)this + 418) = 0;
  *((_QWORD *)this + 419) = 0;
  *((_DWORD *)this + 840) = 0;
  return result;
}

void AABC::setupDefaultsForAoT(AABC *this)
{
  void *v1;
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  void *context;
  uint64_t v10;
  int k;
  id v12;
  id v13;
  uint64_t v14;
  int j;
  id v16;
  id v17;
  uint64_t v18;
  int i;
  id v20;
  id v21;
  _BYTE __b[164];
  AABC *v23;
  _QWORD v24[3];
  _QWORD v25[3];
  _QWORD v26[2];
  _QWORD v27[2];
  _QWORD v28[2];
  _QWORD v29[2];
  _QWORD v30[2];
  _QWORD v31[2];
  __int128 v32;
  int v33;
  __int128 v34;
  int v35;
  __int128 v36;
  int v37;
  __int128 v38;
  int v39;
  __int128 v40;
  int v41;
  __int128 v42;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v23 = this;
  v42 = xmmword_1B5462914;
  v43 = 1184645120;
  LODWORD(v40) = *((_DWORD *)this + 177);
  *(_QWORD *)((char *)&v40 + 4) = COERCE_UNSIGNED_INT(30.0) | 0x42C4000000000000;
  HIDWORD(v40) = 1140457472;
  v41 = 1140457472;
  *((_OWORD *)this + 128) = xmmword_1B5462914;
  *((_DWORD *)this + 516) = v43;
  *((_OWORD *)this + 133) = v40;
  *((_DWORD *)this + 536) = v41;
  *((_DWORD *)this + 552) = 5;
  v38 = xmmword_1B5462928;
  v39 = 1184645120;
  LODWORD(v36) = *((_DWORD *)this + 177);
  *(_QWORD *)((char *)&v36 + 4) = COERCE_UNSIGNED_INT(30.0) | 0x42C4000000000000;
  HIDWORD(v36) = 1140457472;
  v37 = 1140457472;
  *(_OWORD *)((char *)this + 2212) = xmmword_1B5462928;
  *((_DWORD *)this + 557) = v39;
  *(_OWORD *)((char *)this + 2292) = v36;
  *((_DWORD *)this + 577) = v37;
  *((_DWORD *)this + 593) = 5;
  v34 = xmmword_1B546293C;
  v35 = 1184645120;
  LODWORD(v32) = *((_DWORD *)this + 177);
  *(_QWORD *)((char *)&v32 + 4) = COERCE_UNSIGNED_INT(30.0) | 0x42C4000000000000;
  HIDWORD(v32) = 1140457472;
  v33 = 1140457472;
  *(_OWORD *)((char *)this + 2376) = xmmword_1B546293C;
  *((_DWORD *)this + 598) = v35;
  *(_OWORD *)((char *)this + 2456) = v32;
  *((_DWORD *)this + 618) = v33;
  *((_DWORD *)this + 634) = 5;
  memcpy((char *)this + 2540, (char *)this + 164 * *((unsigned int *)this + 851) + 2048, 0xA4uLL);
  memset(__b, 0, sizeof(__b));
  v1 = memcpy((char *)this + 2704, __b, 0xA4uLL);
  *((_DWORD *)this + 717) = 0;
  context = (void *)MEMORY[0x1B5E4A8B0](v1);
  v21 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v20 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (i = 0; i < *((_DWORD *)this + 552); ++i)
  {
    LODWORD(v2) = *((_DWORD *)this + i + 512);
    objc_msgSend(v21, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v2));
    LODWORD(v3) = *((_DWORD *)this + i + 532);
    objc_msgSend(v20, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v3));
  }
  v30[0] = CFSTR("lux");
  v31[0] = v21;
  v30[1] = CFSTR("nits");
  v31[1] = v20;
  v18 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v31, v30, 2);

  v17 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v16 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (j = 0; j < *((_DWORD *)this + 593); ++j)
  {
    LODWORD(v4) = *((_DWORD *)this + j + 553);
    objc_msgSend(v17, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v4));
    LODWORD(v5) = *((_DWORD *)this + j + 573);
    objc_msgSend(v16, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v5));
  }
  v28[0] = CFSTR("lux");
  v29[0] = v17;
  v28[1] = CFSTR("nits");
  v29[1] = v16;
  v14 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v29, v28, 2);

  v13 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v12 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (k = 0; k < *((_DWORD *)this + 634); ++k)
  {
    LODWORD(v6) = *((_DWORD *)this + k + 594);
    objc_msgSend(v13, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v6));
    LODWORD(v7) = *((_DWORD *)this + k + 614);
    objc_msgSend(v12, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v7));
  }
  v26[0] = CFSTR("lux");
  v27[0] = v13;
  v26[1] = CFSTR("nits");
  v27[1] = v12;
  v10 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v27, v26, 2);

  v24[0] = CFSTR("CurveLevelLow");
  v25[0] = v18;
  v24[1] = CFSTR("CurveLevelMed");
  v25[1] = v14;
  v24[2] = CFSTR("CurveLevelHigh");
  v25[2] = v10;
  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), CFSTR("AOTCurve"), (const void *)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v25, v24, 3));
  objc_autoreleasePoolPop(context);
}

uint64_t PerceptualLuminanceThresholding::SetBrightenDuration(uint64_t this, float a2)
{
  *(float *)(this + 32) = a2;
  return this;
}

uint64_t PerceptualLuminanceThresholding::SetMaxDimDuration(uint64_t this, float a2)
{
  *(float *)(this + 36) = a2;
  return this;
}

void AABC::unregisterDisplay(AABC *this, __Display *a2)
{
  uint64_t v2;
  uint64_t inited;
  NSObject *v4;
  uint8_t v6[8];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (_logHandle)
  {
    v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v4 = inited;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v6, 4);
    _os_log_debug_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEBUG, "[%x]: ", v6, 8u);
  }
  *((_QWORD *)this + 51) = 0;
  v2 = *((_QWORD *)this + 502);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  *((_QWORD *)this + 502) = 0;
}

CBDigitizerFilter *AABC::newDigitizerFilterForALS(AABC *this, const AABC::ALS *a2)
{
  CBDigitizerFilter *v4;

  v4 = -[CBDigitizerFilter initWithALSNode:andLogCategory:]([CBDigitizerFilter alloc], "initWithALSNode:andLogCategory:", *((_QWORD *)a2 + 4), "lux");
  -[CBFilter scheduleWithDispatchQueue:](v4, "scheduleWithDispatchQueue:", *((_QWORD *)this + 509));
  return v4;
}

void AABC::registerService(AABC *this, __IOHIDServiceClient *a2)
{
  void *v2;
  CBDigitizerFilter *v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  CFTypeID v8;
  BOOL v9;
  NSObject *v10;
  os_log_type_t v11;
  uint64_t v12;
  NSObject *v13;
  CFTypeID v14;
  NSObject *v15;
  os_log_type_t v16;
  uint64_t v17;
  NSObject *v18;
  CFTypeID v19;
  NSObject *v20;
  os_log_type_t v21;
  uint64_t v22;
  NSObject *v23;
  CFTypeID v24;
  NSObject *v25;
  os_log_type_t v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  CBALSNode *v30;
  CFTypeID v31;
  CFTypeID v32;
  CFTypeID v33;
  CFTypeID v34;
  CFTypeID v35;
  CFTypeID v36;
  CFTypeID v37;
  CFTypeID v38;
  CFTypeID v39;
  CFTypeID v40;
  NSObject *v41;
  os_log_type_t v42;
  uint64_t v43;
  NSObject *v44;
  AABC::ALS *v45;
  CFIndex v46;
  CFTypeID v47;
  uint64_t inited;
  NSObject *v49;
  uint64_t v51;
  int v52;
  int v53;
  CBDigitizerFilter *(*v54)(CBDigitizerFilter *, uint64_t, const AABC::ALS *);
  void *v55;
  AABC *v56;
  os_log_type_t v57;
  os_log_t v58;
  os_log_type_t v59;
  os_log_t v60;
  CFTypeRef v61;
  int v62;
  os_log_type_t v63;
  os_log_t v64;
  int v65;
  os_log_type_t v66;
  os_log_t v67;
  int v68;
  os_log_type_t v69;
  os_log_t v70;
  int v71;
  int v72;
  uint8_t v73[15];
  os_log_type_t v74;
  os_log_t v75;
  unsigned int v76;
  CFTypeRef property;
  CFMutableArrayRef Mutable;
  int valuePtr;
  char v80;
  CFTypeRef cf;
  os_log_type_t v82;
  os_log_t oslog;
  void *value;
  int i;
  CFArrayRef theArray;
  char v87;
  CFTypeRef v88;
  CFTypeRef v89;
  os_log_type_t v90;
  os_log_t v91;
  __IOHIDServiceClient *v92;
  AABC *v93;
  uint8_t v94[32];
  uint8_t v95[32];
  uint8_t v96[32];
  uint8_t v97[32];
  uint8_t v98[32];
  uint8_t v99[16];
  uint8_t v100[8];
  uint64_t v101;

  v101 = *MEMORY[0x1E0C80C00];
  v93 = this;
  v92 = a2;
  v91 = 0;
  if (_logHandle)
  {
    v49 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v49 = inited;
  }
  v91 = v49;
  v90 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v100, 4);
    _os_log_debug_impl(&dword_1B5291000, v91, v90, "[%x]: ", v100, 8u);
  }
  if (v92)
  {
    v89 = IOHIDServiceClientCopyProperty(v92, CFSTR("Built-In"));
    if (v89)
    {
      if (v89 == (CFTypeRef)*MEMORY[0x1E0C9AE50])
      {
        v88 = IOHIDServiceClientCopyProperty(v92, CFSTR("DeviceUsagePairs"));
        if (v88)
        {
          v47 = CFGetTypeID(v88);
          if (v47 == CFArrayGetTypeID())
          {
            v87 = 0;
            theArray = (CFArrayRef)v88;
            for (i = 0; ; ++i)
            {
              v46 = i;
              if (v46 >= CFArrayGetCount(theArray))
                break;
              if (IOHIDServiceClientConformsTo(v92, 0xFF00u, 4u))
              {
                value = 0;
                v45 = (AABC::ALS *)operator new();
                AABC::ALS::ALS(v45);
                value = v45;
                *((_QWORD *)v45 + 2) = v92;
                *((_QWORD *)this + 41) = v92;
                if (!*((_QWORD *)this + 58))
                {
                  v2 = value;
                  *((_QWORD *)this + 58) = value;
                  *((_QWORD *)this + 57) = v2;
                }
                CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 53), v92, value);
                *((_DWORD *)this + 112) = CFDictionaryGetCount(*((CFDictionaryRef *)this + 53));
                oslog = 0;
                if (_logHandle)
                {
                  v44 = _logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT)
                    v43 = _COREBRIGHTNESS_LOG_DEFAULT;
                  else
                    v43 = init_default_corebrightness_log();
                  v44 = v43;
                }
                oslog = v44;
                v82 = OS_LOG_TYPE_DEBUG;
                if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
                {
                  v41 = oslog;
                  v42 = v82;
                  __os_log_helper_16_0_1_4_0((uint64_t)v99, *((_DWORD *)this + 112));
                  _os_log_debug_impl(&dword_1B5291000, v41, v42, "Total expected events %d", v99, 8u);
                }
                cf = 0;
                cf = IOHIDServiceClientCopyProperty(v92, CFSTR("Orientation"));
                if (cf)
                {
                  v40 = CFGetTypeID(cf);
                  if (v40 == CFNumberGetTypeID())
                    CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, (char *)value + 4);
                }
                if (cf)
                  CFRelease(cf);
                cf = 0;
                cf = IOHIDServiceClientCopyProperty(v92, CFSTR("Placement"));
                if (cf)
                {
                  v39 = CFGetTypeID(cf);
                  if (v39 == CFNumberGetTypeID())
                    CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, value);
                }
                if (cf)
                  CFRelease(cf);
                cf = 0;
                cf = IOHIDServiceClientCopyProperty(v92, CFSTR("ALSSensorType"));
                if (cf)
                {
                  v38 = CFGetTypeID(cf);
                  if (v38 == CFNumberGetTypeID())
                  {
                    CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, (char *)value + 8);
                    *((_BYTE *)this + 144) = (*((_BYTE *)this + 144) & 1 | (*((_DWORD *)value + 2) == 8)) != 0;
                    *((_BYTE *)this + 144) = (*((_BYTE *)this + 144) & 1 | (*((_DWORD *)value + 2) == 9)) != 0;
                  }
                }
                if (cf)
                  CFRelease(cf);
                cf = 0;
                v80 = 1;
                cf = IOHIDServiceClientCopyProperty(v92, CFSTR("FDRCalibration"));
                if (cf)
                {
                  v37 = CFGetTypeID(cf);
                  if (v37 == CFBooleanGetTypeID())
                  {
                    if (GetCFBooleanValue((const __CFNumber *)cf))
                    {
                      *((_BYTE *)this + 445) = 1;
                      AABC::lazyLoadIntegrationTimes(this, v92, (AABC::ALS *)value);
                      v80 = 0;
                    }
                  }
                }
                if (cf)
                  CFRelease(cf);
                if ((v80 & 1) != 0)
                {
                  cf = IOHIDServiceClientCopyProperty(v92, CFSTR("ALSSuperFastIntegrationTime"));
                  if (cf)
                  {
                    v36 = CFGetTypeID(cf);
                    if (v36 == CFNumberGetTypeID())
                    {
                      CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, (char *)value + 40);
                      *((float *)value + 10) = *((float *)value + 10) / 1000000.0;
                    }
                  }
                  if (cf)
                    CFRelease(cf);
                  cf = 0;
                  cf = IOHIDServiceClientCopyProperty(v92, CFSTR("ALSFastIntegrationTime"));
                  if (cf)
                  {
                    v35 = CFGetTypeID(cf);
                    if (v35 == CFNumberGetTypeID())
                    {
                      CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, (char *)value + 44);
                      *((float *)value + 11) = *((float *)value + 11) / 1000000.0;
                    }
                  }
                  if (cf)
                    CFRelease(cf);
                  cf = 0;
                  cf = IOHIDServiceClientCopyProperty(v92, CFSTR("ALSSlowIntegrationTime"));
                  if (cf)
                  {
                    v34 = CFGetTypeID(cf);
                    if (v34 == CFNumberGetTypeID())
                    {
                      CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, (char *)value + 48);
                      *((float *)value + 12) = *((float *)value + 12) / 1000000.0;
                    }
                  }
                  if (cf)
                    CFRelease(cf);
                  cf = 0;
                }
                cf = IOHIDServiceClientCopyProperty(v92, CFSTR("ALSSensorMin"));
                if (cf)
                {
                  v33 = CFGetTypeID(cf);
                  if (v33 == CFNumberGetTypeID())
                    CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, (char *)value + 52);
                }
                if (cf)
                  CFRelease(cf);
                cf = 0;
                cf = IOHIDServiceClientCopyProperty(v92, CFSTR("ALSSensorMax"));
                if (cf)
                {
                  v32 = CFGetTypeID(cf);
                  if (v32 == CFNumberGetTypeID())
                    CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, (char *)value + 56);
                }
                if (cf)
                  CFRelease(cf);
                cf = 0;
                cf = IOHIDServiceClientCopyProperty(v92, CFSTR("FastModeFilter"));
                if (cf)
                {
                  v31 = CFGetTypeID(cf);
                  if (v31 == CFNumberGetTypeID())
                  {
                    valuePtr = 0;
                    if (CFNumberGetValue((CFNumberRef)cf, kCFNumberIntType, &valuePtr))
                      *((_BYTE *)this + 3460) = valuePtr != 0;
                  }
                  CFRelease(cf);
                }
                v30 = [CBALSNode alloc];
                v29 = -[CBALSNode initWithALSServiceClient:](v30, "initWithALSServiceClient:", v92);
                *((_QWORD *)value + 4) = v29;
                *((_BYTE *)this + 3937) = (*((_BYTE *)this + 3937) & 1 & objc_msgSend(*((id *)value + 4), "useProxForOcclusion") & 1) != 0;
                if (*((_QWORD *)this + 59) && !*((_QWORD *)value + 3))
                {
                  v3 = AABC::newDigitizerFilterForALS(this, (const AABC::ALS *)value);
                  *((_QWORD *)value + 3) = v3;
                }
                if (*((_DWORD *)this + 93))
                {
                  if (*((_QWORD *)this + 51))
                  {
                    Mutable = 0;
                    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3, MEMORY[0x1E0C9B378]);
                    if (Mutable)
                    {
                      property = 0;
                      v76 = 0;
                      v76 = (float)(*((float *)this + 180) * 65536.0);
                      property = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &v76);
                      if (property)
                      {
                        CFArraySetValueAtIndex(Mutable, 0, property);
                        CFRelease(property);
                      }
                      property = 0;
                      v76 = (float)(*((float *)this + 181) * 65536.0);
                      property = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &v76);
                      if (property)
                      {
                        CFArraySetValueAtIndex(Mutable, 1, property);
                        CFRelease(property);
                      }
                      property = 0;
                      v76 = (float)(*((float *)this + 182) * 65536.0);
                      property = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &v76);
                      if (property)
                      {
                        CFArraySetValueAtIndex(Mutable, 2, property);
                        CFRelease(property);
                      }
                      property = 0;
                      IOHIDServiceClientSetProperty(v92, CFSTR("ALSLPannelValues"), Mutable);
                      CFRelease(Mutable);
                      Mutable = 0;
                      if (*((float *)this + 104) == 0.0)
                      {
                        v75 = 0;
                        if (_logHandle)
                        {
                          v28 = _logHandle;
                        }
                        else
                        {
                          if (_COREBRIGHTNESS_LOG_DEFAULT)
                            v27 = _COREBRIGHTNESS_LOG_DEFAULT;
                          else
                            v27 = init_default_corebrightness_log();
                          v28 = v27;
                        }
                        v75 = v28;
                        v74 = OS_LOG_TYPE_INFO;
                        if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
                        {
                          v25 = v75;
                          v26 = v74;
                          __os_log_helper_16_0_0(v73);
                          _os_log_impl(&dword_1B5291000, v25, v26, "Initial factor =0. Stopping ALS", v73, 2u);
                        }
                        v72 = 0;
                        if (!*((_DWORD *)this + 162))
                        {
                          property = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &v72);
                          IOHIDServiceClientSetProperty(v92, CFSTR("ReportInterval"), property);
                          CFRelease(property);
                        }
                        v72 = 0;
                        property = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &v72);
                        IOHIDServiceClientSetProperty(v92, CFSTR("ALSIntegrationMode"), property);
                        CFRelease(property);
                      }
                    }
                  }
                }
                if (*((_DWORD *)this + 162) && value == *((void **)this + 58))
                {
                  cf = IOHIDServiceClientCopyProperty(v92, CFSTR("SlowModeReportInterval"));
                  if (cf)
                  {
                    v24 = CFGetTypeID(cf);
                    if (v24 == CFNumberGetTypeID())
                    {
                      v71 = 0;
                      if (CFNumberGetValue((CFNumberRef)cf, kCFNumberIntType, &v71))
                        *((float *)this + 163) = (float)v71 / 1000000.0;
                    }
                    CFRelease(cf);
                    v70 = 0;
                    if (_logHandle)
                    {
                      v23 = _logHandle;
                    }
                    else
                    {
                      if (_COREBRIGHTNESS_LOG_DEFAULT)
                        v22 = _COREBRIGHTNESS_LOG_DEFAULT;
                      else
                        v22 = init_default_corebrightness_log();
                      v23 = v22;
                    }
                    v70 = v23;
                    v69 = OS_LOG_TYPE_DEBUG;
                    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
                    {
                      v20 = v70;
                      v21 = v69;
                      __os_log_helper_16_0_2_4_0_8_0((uint64_t)v98, 16, COERCE__INT64(*((float *)this + 163)));
                      _os_log_debug_impl(&dword_1B5291000, v20, v21, "[%x]: SlowModeReportInverval value %f.", v98, 0x12u);
                    }
                  }
                  cf = 0;
                  cf = IOHIDServiceClientCopyProperty(v92, CFSTR("FastModeReportInterval"));
                  if (cf)
                  {
                    v19 = CFGetTypeID(cf);
                    if (v19 == CFNumberGetTypeID())
                    {
                      v68 = 0;
                      if (CFNumberGetValue((CFNumberRef)cf, kCFNumberIntType, &v68))
                        *((float *)this + 164) = (float)v68 / 1000000.0;
                    }
                    CFRelease(cf);
                    v67 = 0;
                    if (_logHandle)
                    {
                      v18 = _logHandle;
                    }
                    else
                    {
                      if (_COREBRIGHTNESS_LOG_DEFAULT)
                        v17 = _COREBRIGHTNESS_LOG_DEFAULT;
                      else
                        v17 = init_default_corebrightness_log();
                      v18 = v17;
                    }
                    v67 = v18;
                    v66 = OS_LOG_TYPE_DEBUG;
                    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
                    {
                      v15 = v67;
                      v16 = v66;
                      __os_log_helper_16_0_2_4_0_8_0((uint64_t)v97, 16, COERCE__INT64(*((float *)this + 164)));
                      _os_log_debug_impl(&dword_1B5291000, v15, v16, "[%x]: FastModeReportInverval value %f.", v97, 0x12u);
                    }
                  }
                  cf = 0;
                  cf = IOHIDServiceClientCopyProperty(v92, CFSTR("SuperFastModeReportInterval"));
                  if (cf)
                  {
                    v14 = CFGetTypeID(cf);
                    if (v14 == CFNumberGetTypeID())
                    {
                      v65 = 0;
                      if (CFNumberGetValue((CFNumberRef)cf, kCFNumberIntType, &v65))
                        *((float *)this + 165) = (float)v65 / 1000000.0;
                    }
                    CFRelease(cf);
                    v64 = 0;
                    if (_logHandle)
                    {
                      v13 = _logHandle;
                    }
                    else
                    {
                      if (_COREBRIGHTNESS_LOG_DEFAULT)
                        v12 = _COREBRIGHTNESS_LOG_DEFAULT;
                      else
                        v12 = init_default_corebrightness_log();
                      v13 = v12;
                    }
                    v64 = v13;
                    v63 = OS_LOG_TYPE_DEBUG;
                    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
                    {
                      v10 = v64;
                      v11 = v63;
                      __os_log_helper_16_0_2_4_0_8_0((uint64_t)v96, 16, COERCE__INT64(*((float *)this + 165)));
                      _os_log_debug_impl(&dword_1B5291000, v10, v11, "[%x]: SuperFastModeReportInverval value %f.", v96, 0x12u);
                    }
                  }
                  cf = 0;
                }
                v9 = 1;
                if (AABC::getALSSensorTypeFromService((id *)this, v92) != 8)
                  v9 = AABC::getALSSensorTypeFromService((id *)this, v92) == 9;
                *((_BYTE *)this + 161) = v9;
                *((_BYTE *)this + 264) = v9;
                if ((*((_BYTE *)this + 161) & 1) != 0)
                  AABC::setFilterDuration((uint64_t)this, (uint64_t)this + 216, 5);
              }
              if (IOHIDServiceClientConformsTo(v92, 0xFF00u, 8u))
              {
                v62 = 1;
                v61 = IOHIDServiceClientCopyProperty(v92, CFSTR("Placement"));
                if (v61)
                {
                  v8 = CFGetTypeID(v61);
                  if (v8 == CFNumberGetTypeID())
                    CFNumberGetValue((CFNumberRef)v61, kCFNumberSInt32Type, &v62);
                }
                if (v61)
                  CFRelease(v61);
                if (v62 == 1)
                {
                  *((_QWORD *)this + 60) = v92;
                  v60 = 0;
                  if (_logHandle)
                  {
                    v7 = _logHandle;
                  }
                  else
                  {
                    v6 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
                    v7 = v6;
                  }
                  v60 = v7;
                  v59 = OS_LOG_TYPE_DEBUG;
                  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
                  {
                    __os_log_helper_16_2_3_4_0_8_64_8_32((uint64_t)v95, 8, (uint64_t)v92, (uint64_t)(&kDimPolicyStr)[*((unsigned int *)this + 859)]);
                    _os_log_debug_impl(&dword_1B5291000, v60, v59, "[%x]: _prox=%@ _settings._internal._dimPolicy=%s", v95, 0x1Cu);
                  }
                }
              }
              if (IOHIDServiceClientConformsTo(v92, 0xDu, 0xCu))
              {
                *((_QWORD *)this + 59) = v92;
                v87 = 1;
                v58 = 0;
                if (_logHandle)
                {
                  v5 = _logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT)
                    v4 = _COREBRIGHTNESS_LOG_DEFAULT;
                  else
                    v4 = init_default_corebrightness_log();
                  v5 = v4;
                }
                v58 = v5;
                v57 = OS_LOG_TYPE_DEBUG;
                if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
                {
                  __os_log_helper_16_2_2_4_0_8_64((uint64_t)v94, 32, *((_QWORD *)this + 59));
                  _os_log_debug_impl(&dword_1B5291000, v58, v57, "[%x]: _digitizer=%@", v94, 0x12u);
                }
              }
            }
            if ((v87 & 1) != 0)
            {
              v51 = MEMORY[0x1E0C809B0];
              v52 = -1073741824;
              v53 = 0;
              v54 = ___ZN4AABC15registerServiceEP20__IOHIDServiceClient_block_invoke;
              v55 = &__block_descriptor_40_e35_v24__0____IOHIDServiceClient__8_v16l;
              v56 = this;
              AABC::enumerateALSes((uint64_t)this, (uint64_t)&v51);
            }
          }
        }
        if (v88)
          CFRelease(v88);
      }
      CFRelease(v89);
    }
  }
}

void sub_1B540BC9C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

AABC::ALS *AABC::ALS::ALS(AABC::ALS *this)
{
  AABC::ALS::ALS(this);
  return this;
}

uint64_t AABC::lazyLoadIntegrationTimes(AABC *this, __IOHIDServiceClient *a2, AABC::ALS *a3)
{
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v10;
  CFTypeID v11;
  CFTypeRef v13;
  CFTypeRef v14;
  CFTypeRef v15;
  uint8_t v16[15];
  char v17;
  NSObject *v18;
  const __CFNumber *v19;
  char v20;
  float *v21;
  IOHIDServiceClientRef v22;
  AABC *v23;

  v23 = this;
  v22 = a2;
  v21 = (float *)a3;
  v20 = 0;
  v19 = (const __CFNumber *)IOHIDServiceClientCopyProperty(a2, CFSTR("Calibrated"));
  if (v19)
  {
    v11 = CFGetTypeID(v19);
    if (v11 == CFBooleanGetTypeID())
    {
      if (GetCFBooleanValue(v19))
      {
        v18 = 0;
        if (_logHandle)
        {
          v10 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            inited = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            inited = init_default_corebrightness_log();
          v10 = inited;
        }
        v18 = v10;
        v17 = 1;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          log = v18;
          type = v17;
          __os_log_helper_16_0_0(v16);
          _os_log_impl(&dword_1B5291000, log, type, "Driver has been calibrated -> setting integration times.", v16, 2u);
        }
        v13 = IOHIDServiceClientCopyProperty(v22, CFSTR("ALSSuperFastIntegrationTime"));
        if (v13)
        {
          v6 = CFGetTypeID(v13);
          if (v6 == CFNumberGetTypeID())
          {
            CFNumberGetValue((CFNumberRef)v13, kCFNumberFloatType, v21 + 10);
            v21[10] = v21[10] / 1000000.0;
          }
        }
        if (v13)
          CFRelease(v13);
        v14 = IOHIDServiceClientCopyProperty(v22, CFSTR("ALSFastIntegrationTime"));
        if (v14)
        {
          v5 = CFGetTypeID(v14);
          if (v5 == CFNumberGetTypeID())
          {
            CFNumberGetValue((CFNumberRef)v14, kCFNumberFloatType, v21 + 11);
            v21[11] = v21[11] / 1000000.0;
          }
        }
        if (v14)
          CFRelease(v14);
        v15 = IOHIDServiceClientCopyProperty(v22, CFSTR("ALSSlowIntegrationTime"));
        if (v15)
        {
          v4 = CFGetTypeID(v15);
          if (v4 == CFNumberGetTypeID())
          {
            CFNumberGetValue((CFNumberRef)v15, kCFNumberFloatType, v21 + 12);
            v21[12] = v21[12] / 1000000.0;
          }
        }
        if (v15)
          CFRelease(v15);
        *((_BYTE *)this + 445) = 0;
        v20 = 1;
      }
    }
  }
  if (v19)
    CFRelease(v19);
  return v20 & 1;
}

uint64_t AABC::getALSSensorTypeFromService(id *this, __IOHIDServiceClient *a2)
{
  uint64_t v3;

  v3 = objc_msgSend(this[53], "objectForKey:", a2, 0, a2, this);
  if (v3)
    return *(unsigned int *)(v3 + 8);
  else
    return 0;
}

void AABC::setFilterDuration(uint64_t a1, uint64_t a2, __int16 a3)
{
  *(_WORD *)(a2 + 24) = a3;
}

uint64_t __os_log_helper_16_2_3_4_0_8_64_8_32(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 64;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 32;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  return result;
}

uint64_t AABC::enumerateALSes(uint64_t a1, uint64_t a2)
{
  void *v2;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t (*v7)(uint64_t, uint64_t, uint64_t);
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v2 = *(void **)(a1 + 424);
  v4 = MEMORY[0x1E0C809B0];
  v5 = -1073741824;
  v6 = 0;
  v7 = ___ZN4AABC14enumerateALSesEU13block_pointerFvP20__IOHIDServiceClientPNS_3ALSEE_block_invoke;
  v8 = &unk_1E68EBC00;
  v9 = a2;
  return objc_msgSend(v2, "enumerateKeysAndObjectsUsingBlock:", &v4);
}

void AABC::unregisterService(CFMutableDictionaryRef *this, __IOHIDServiceClient *a2)
{
  uint64_t inited;
  NSObject *v3;
  id *v5;
  void *value;
  os_log_type_t v7;
  os_log_t v8;
  CFMutableDictionaryRef v9;
  AABC *v10;
  uint8_t v11[8];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v10 = (AABC *)this;
  v9 = a2;
  v8 = 0;
  if (_logHandle)
  {
    v3 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v3 = inited;
  }
  v8 = v3;
  v7 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v11, 4);
    _os_log_debug_impl(&dword_1B5291000, v8, v7, "[%x]: ", v11, 8u);
  }
  if (this[59] && this[59] == v9)
    this[59] = 0;
  if (this[60] && this[60] == v9)
    this[60] = 0;
  value = 0;
  if (CFDictionaryGetValueIfPresent(this[53], v9, (const void **)&value))
  {
    v5 = (id *)value;
    if (*((_QWORD *)value + 3))

    if (v5[4])
    if (v5)
    {
      AABC::ALS::~ALS((AABC::ALS *)v5);
      MEMORY[0x1B5E4A400](v5, 0x10A0C404818E04CLL);
    }
    CFDictionaryRemoveValue(this[53], v9);
    if (this[54])
      CFDictionaryRemoveValue(this[54], v9);
  }
}

void AABC::ALS::~ALS(AABC::ALS *this)
{
  AABC::ALS::~ALS(this);
}

{
  std::vector<float>::~vector[abi:ne180100]((uint64_t *)this + 16);
  std::vector<float>::~vector[abi:ne180100]((uint64_t *)this + 11);
}

CBAPEndpoint *AABC::registerEndpoint(id *this, CBAPEndpoint *a2)
{
  CBAPEndpoint *result;
  char v4;
  CBAPEndpoint *v5;
  AABC *v6;

  v6 = (AABC *)this;
  v5 = a2;
  result = a2;
  this[521] = result;
  if (*((_DWORD *)this + 80) == 6)
  {
    AABC::sendCrossTalkConfigToDCP((IOHIDServiceClientRef *)this);
    result = (CBAPEndpoint *)AABC::sendAOTCurvesToDCP((AABC *)this);
  }
  if (*((_DWORD *)this + 80) == 1)
  {
    v4 = 0;
    return (CBAPEndpoint *)objc_msgSend(this[521], "sendCommand:inputBuffer:inputBufferSize:", 232, &v4, 1);
  }
  return result;
}

void AABC::sendCrossTalkConfigToDCP(IOHIDServiceClientRef *this)
{
  const __CFDictionary *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  os_log_t log;
  os_log_type_t v10[4];
  uint8_t *buf;
  NSObject *inited;
  os_log_t v13;
  id v14;
  _DWORD *v15;
  __CFString *v16;
  id v17;
  id v18;
  uint64_t *v19;
  id v20;
  id v21;
  id v22;
  void *context;
  mach_port_t mainPort;
  IOOptionBits options;
  id v26;
  IOHIDServiceClientRef *v27;
  os_log_type_t v28[7];
  os_log_type_t type;
  os_log_t oslog;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t (*v34)(uint64_t, void *, uint64_t);
  void *v35;
  _BYTE *v36;
  _BYTE *v37;
  id v38;
  unsigned int i;
  id v40;
  const __CFString *v41;
  uint64_t v42;
  int v43;
  int v44;
  uint64_t (*v45)(uint64_t, void *, uint64_t);
  void *v46;
  _BYTE *v47;
  _BYTE *v48;
  io_registry_entry_t entry;
  id v50;
  CFNumberRef number;
  int v52;
  char v53;
  _BYTE v54[3];
  _DWORD v55[2];
  _BYTE v56[64];
  _BYTE v57[268];
  uint64_t valuePtr[2];

  valuePtr[1] = (uint64_t)this;
  v27 = this;
  valuePtr[0] = 0;
  v52 = 0;
  v53 = 0;
  number = 0;
  number = (CFNumberRef)IOHIDServiceClientGetRegistryID(this[41]);
  if (number)
    CFNumberGetValue(number, kCFNumberSInt64Type, valuePtr);
  if (valuePtr[0])
  {
    context = (void *)MEMORY[0x1B5E4A8B0]();
    v50 = 0;
    options = 0;
    entry = 0;
    mainPort = *MEMORY[0x1E0CBBAA8];
    v1 = IORegistryEntryIDMatching(valuePtr[0]);
    entry = IOServiceGetMatchingService(mainPort, v1);
    v50 = (id)IORegistryEntryCreateCFProperty(entry, CFSTR("ALSSCalDBV"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    v26 = v50;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v55[1] = objc_msgSend(v50, "unsignedIntValue");
      LOBYTE(v52) = 1;
    }
    v50 = (id)IORegistryEntryCreateCFProperty(entry, CFSTR("ALSSNumRects"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    v22 = v50;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v55[0] = objc_msgSend(v50, "unsignedIntValue");
      BYTE1(v52) = 1;
    }
    v50 = (id)IORegistryEntryCreateCFProperty(entry, CFSTR("ALSSRGBCoefficients"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    v21 = v50;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v48 = v57;
      v42 = MEMORY[0x1E0C809B0];
      v43 = -1073741824;
      v44 = 0;
      v45 = ___ZN4AABC24sendCrossTalkConfigToDCPEv_block_invoke;
      v46 = &__block_descriptor_40_e15_v32__0_8Q16_B24l;
      v47 = v57;
      objc_msgSend(v50, "enumerateObjectsUsingBlock:", &v42);
      BYTE2(v52) = 1;
    }
    v41 = CFSTR("ALSSRect");
    v40 = 0;
    v19 = &v8;
    v40 = (id)objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:", CFSTR("0"), CFSTR("1"), CFSTR("2"), CFSTR("3"), CFSTR("4"), CFSTR("5"), CFSTR("6"), CFSTR("7"), CFSTR("8"), CFSTR("9"), CFSTR("10"), CFSTR("11"), CFSTR("12"), CFSTR("13"), CFSTR("14"), CFSTR("15"), 0);
    v50 = (id)IORegistryEntryCreateCFProperty(entry, CFSTR("ALSSRectConfig"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    v20 = v50;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      for (i = 0; i < v55[0]; ++i)
      {
        v38 = 0;
        v17 = v50;
        v16 = (__CFString *)v41;
        v2 = objc_msgSend(v40, "objectAtIndexedSubscript:", (int)i);
        v3 = -[__CFString stringByAppendingString:](v16, "stringByAppendingString:", v2);
        v38 = (id)objc_msgSend(v17, "objectForKey:", v3);
        v18 = v38;
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v4 = objc_msgSend((id)objc_msgSend(v38, "objectAtIndexedSubscript:", 0), "unsignedIntValue");
          v15 = v55;
          *(_DWORD *)&v57[16 * i + 12] = v4;
          v5 = objc_msgSend((id)objc_msgSend(v38, "objectAtIndexedSubscript:", 1), "unsignedIntValue");
          v15[4 * i + 22] = v5;
          v6 = objc_msgSend((id)objc_msgSend(v38, "objectAtIndexedSubscript:", 2), "unsignedIntValue");
          v15[4 * i + 23] = v6;
          v7 = objc_msgSend((id)objc_msgSend(v38, "objectAtIndexedSubscript:", 3), "unsignedIntValue");
          v15[4 * i + 24] = v7;
          HIBYTE(v52) = 1;
        }
        else
        {
          HIBYTE(v52) = 0;
        }
      }
    }
    v50 = (id)IORegistryEntryCreateCFProperty(entry, CFSTR("ALSSWindowCoefficients"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    v14 = v50;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v37 = v56;
      v31 = MEMORY[0x1E0C809B0];
      v32 = -1073741824;
      v33 = 0;
      v34 = ___ZN4AABC24sendCrossTalkConfigToDCPEv_block_invoke_2;
      v35 = &__block_descriptor_40_e15_v32__0_8Q16_B24l;
      v36 = v56;
      objc_msgSend(v50, "enumerateObjectsUsingBlock:", &v31);
      v53 = 1;
    }
    objc_autoreleasePoolPop(context);
    if ((std::all_of[abi:ne180100]<BOOL *,AABC::sendCrossTalkConfigToDCP(void)::$_0>(&v52, v54) & 1) != 0)
    {
      -[__IOHIDServiceClient sendCommand:inputBuffer:inputBufferSize:](v27[521], "sendCommand:inputBuffer:inputBufferSize:", 232, v55, 340);
    }
    else
    {
      oslog = 0;
      if (_logHandle)
      {
        v13 = (os_log_t)_logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v13 = inited;
      }
      oslog = v13;
      type = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        log = oslog;
        *(_DWORD *)v10 = type;
        buf = (uint8_t *)v28;
        __os_log_helper_16_0_0(v28);
        _os_log_error_impl(&dword_1B5291000, log, v10[0], "No valid calibration for crosstalk, lux might be incorrect!", buf, 2u);
      }
    }
  }
}

uint64_t AABC::sendAOTCurvesToDCP(AABC *this)
{
  int j;
  int i;
  _QWORD v4[22];

  v4[21] = *MEMORY[0x1E0C80C00];
  for (i = 0; i < 3; ++i)
  {
    for (j = 0; j < *((_DWORD *)this + 41 * i + 552); ++j)
    {
      *((_DWORD *)&v4[7 * i] + j) = (int)(*((float *)this + 41 * i + j + 512) * 65536.0);
      *((_DWORD *)&v4[7 * i + 3] + j) = (int)(*((float *)this + 41 * i + j + 532) * 65536.0);
    }
    v4[7 * i + 6] = *((int *)this + 41 * i + 552);
  }
  return objc_msgSend(*((id *)this + 521), "sendCommand:inputBuffer:inputBufferSize:", 228, v4, 168);
}

void AABC::scheduleWithDispatchQueue(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  NSObject *v3;
  os_log_type_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t inited;
  NSObject *v10;
  uint64_t handler;
  int v13;
  int v14;
  void (*v15)(uint64_t);
  void *v16;
  uint64_t v17;
  uint8_t v18[7];
  char v19;
  NSObject *v20;
  os_log_type_t v21;
  os_log_t v22;
  os_log_type_t v23;
  os_log_t v24;
  uint64_t v25;
  uint64_t v26;
  uint8_t v27[16];
  uint8_t v28[8];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v26 = a1;
  v25 = a2;
  v24 = 0;
  if (_logHandle)
  {
    v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v10 = inited;
  }
  v24 = v10;
  v23 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v28, 4);
    _os_log_debug_impl(&dword_1B5291000, v24, v23, "[%x]: ", v28, 8u);
  }
  if (*(_DWORD *)(a1 + 376))
  {
    v22 = 0;
    if (_logHandle)
    {
      v8 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v7 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v7 = init_default_corebrightness_log();
      v8 = v7;
    }
    v22 = v8;
    v21 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v27, *(_DWORD *)(a1 + 3436));
      _os_log_debug_impl(&dword_1B5291000, v22, v21, "_settings._internal._dimPolicy=%x", v27, 8u);
    }
    *(_QWORD *)(a1 + 4072) = v25;
    if (!*(_DWORD *)(a1 + 648))
    {
      v20 = 0;
      if (_logHandle)
      {
        v6 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v5 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v5 = init_default_corebrightness_log();
        v6 = v5;
      }
      v20 = v6;
      v19 = 2;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        v3 = v20;
        v4 = v19;
        __os_log_helper_16_0_0(v18);
        _os_log_debug_impl(&dword_1B5291000, v3, v4, "lockstate notification enabled \n", v18, 2u);
      }
      v2 = *(NSObject **)(a1 + 4072);
      handler = MEMORY[0x1E0C809B0];
      v13 = -1073741824;
      v14 = 0;
      v15 = ___ZN4AABC25scheduleWithDispatchQueueEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke;
      v16 = &__block_descriptor_40_e8_v12__0i8l;
      v17 = a1;
      notify_register_dispatch("com.apple.springboard.lockstate", (int *)(a1 + 4032), v2, &handler);
    }
    AABC::InitializeCPMSModule((AABC *)a1);
    *(_QWORD *)(a1 + 152) = -[AccessoryDetection initWithAABC:]([AccessoryDetection alloc], "initWithAABC:", a1);
    objc_msgSend(*(id *)(a1 + 152), "start");
  }
}

void ___ZN4AABC25scheduleWithDispatchQueueEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke(uint64_t a1)
{
  uint64_t inited;
  NSObject *v2;
  AABC *v3;
  uint8_t v4[24];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v3 = *(AABC **)(a1 + 32);
  notify_get_state(*((_DWORD *)v3 + 1008), (uint64_t *)v3 + 505);
  if (_logHandle)
  {
    v2 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v2 = inited;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_4_0_8_0((uint64_t)v4, 2, *((_QWORD *)v3 + 505));
    _os_log_debug_impl(&dword_1B5291000, v2, OS_LOG_TYPE_DEBUG, "[%x]: _lockState=%llx", v4, 0x12u);
  }
  if (!*((_QWORD *)v3 + 505))
  {
    if (*((_DWORD *)v3 + 175))
    {
      AABC::CancelFastRampMode((CFAbsoluteTime *)v3);
      *((_DWORD *)v3 + 175) = 0;
    }
    *((_DWORD *)v3 + 996) = 0;
  }
}

void AABC::CancelFastRampMode(CFAbsoluteTime *this)
{
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v4;
  uint8_t v6[15];
  char v7;
  NSObject *v8;
  CFAbsoluteTime *v9;

  v9 = this;
  if (*((_DWORD *)this + 169))
  {
    v8 = 0;
    if (_logHandle)
    {
      v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v4 = inited;
    }
    v8 = v4;
    v7 = 1;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      log = v8;
      type = v7;
      __os_log_helper_16_0_0(v6);
      _os_log_impl(&dword_1B5291000, log, type, "end fast ramp mode", v6, 2u);
    }
    this[86] = CFAbsoluteTimeGetCurrent();
    *((_DWORD *)this + 169) = 0;
    if (*((_DWORD *)this + 92) == 2)
      AABC::UpdateState((uint64_t)this, 3);
  }
}

void AABC::InitializeCPMSModule(AABC *this)
{
  id v1;
  id v2;
  id v3;
  void *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  os_log_type_t v10;
  uint64_t v11;
  NSObject *v12;
  CFTypeID v13;
  CFStringRef *v14;
  CFStringRef *v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t inited;
  NSObject *v19;
  _DWORD v21[3];
  id v22;
  os_log_type_t v23;
  os_log_t v24;
  char v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t (*v29)(uint64_t, void *);
  void *v30;
  AABC *v31;
  id v32;
  id v33;
  id v34;
  id v35;
  id v36;
  id v37;
  id v38;
  id v39;
  id v40;
  id v41;
  os_log_type_t v42;
  os_log_t v43;
  uint8_t v44[7];
  os_log_type_t v45;
  os_log_t v46;
  CFNumberRef v47;
  CFNumberRef Value;
  CFNumberRef number;
  CFDictionaryRef theDict;
  CFTypeRef cf;
  os_log_type_t v52;
  os_log_t oslog;
  os_log_type_t type;
  os_log_t v55;
  int v56;
  float v57;
  unsigned int HDRAPLColumn;
  int APLIndex;
  float v60;
  unsigned int APLColumnOrDefault;
  int v62;
  _DWORD *CPMSAPLTable;
  int v64;
  int v65;
  AABC *v66;
  _QWORD v67[3];
  _QWORD v68[3];
  uint8_t v69[16];
  uint8_t v70[48];
  uint8_t v71[32];
  uint8_t v72[24];
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v66 = this;
  *((_QWORD *)this + 516) = 0;
  *((_QWORD *)this + 515) = 0;
  v64 = MGGetSInt32Answer();
  v65 = v64;
  if ((v64 == 6 || v65 == 1 || v65 == 3) && (objc_msgSend(MEMORY[0x1E0D09930], "isCPMSSupported") & 1) == 1)
  {
    CPMSAPLTable = 0;
    CPMSAPLTable = (_DWORD *)DisplayGetCPMSAPLTable(*((_QWORD *)this + 51));
    if (CPMSAPLTable)
    {
      v62 = 1125842944;
      APLColumnOrDefault = 0;
      APLColumnOrDefault = DisplayGetAPLColumnOrDefault(*((_QWORD *)this + 51), 0x64u);
      v60 = 0.0;
      v60 = DisplayPhysicalBrightnessToPower(*((_QWORD *)this + 51), APLColumnOrDefault, 155.0);
      APLIndex = 0;
      APLIndex = DisplayGetAPLIndex(*((_QWORD *)this + 51), APLColumnOrDefault);
      HDRAPLColumn = 0;
      HDRAPLColumn = DisplayGetHDRAPLColumn(*((_QWORD *)this + 51));
      v57 = 0.0;
      v57 = DisplayPhysicalBrightnessToPower(*((_QWORD *)this + 51), HDRAPLColumn, 155.0);
      v56 = 0;
      v56 = DisplayGetAPLIndex(*((_QWORD *)this + 51), HDRAPLColumn);
      v55 = 0;
      if (_logHandle)
      {
        v19 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v19 = inited;
      }
      v55 = v19;
      type = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      {
        __os_log_helper_16_0_3_4_0_8_0_4_0((uint64_t)v72, APLColumnOrDefault, COERCE__INT64(v60), APLIndex);
        _os_log_impl(&dword_1B5291000, v55, type, "CPMS InitializeCPMSModule, cltm/upo apl: %d, budgetMin: %f, apl_inndex: %d", v72, 0x18u);
      }
      oslog = 0;
      if (_logHandle)
      {
        v17 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v16 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v16 = init_default_corebrightness_log();
        v17 = v16;
      }
      oslog = v17;
      v52 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        __os_log_helper_16_0_3_4_0_8_0_4_0((uint64_t)v71, HDRAPLColumn, COERCE__INT64(v57), v56);
        _os_log_impl(&dword_1B5291000, oslog, v52, "CPMS InitializeCPMSModule, hdrapl: %d, hdrbudgetMin: %f, hdr_apl_inndex: %d", v71, 0x18u);
      }
      v14 = (CFStringRef *)MEMORY[0x1E0C9B260];
      v15 = (CFStringRef *)MEMORY[0x1E0C9B250];
      CFPreferencesSynchronize(CFSTR("com.apple.CoreBrightness"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
      cf = 0;
      cf = CFPreferencesCopyValue(CFSTR("CBCPMSPowerConstraints"), CFSTR("com.apple.CoreBrightness"), *v14, *v15);
      if (cf && (v13 = CFGetTypeID(cf), v13 == CFDictionaryGetTypeID()))
      {
        theDict = (CFDictionaryRef)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("CLTMRestriction"));
        if (theDict)
        {
          number = (CFNumberRef)CFDictionaryGetValue(theDict, CFSTR("Min"));
          if (number)
            CFNumberGetValue(number, kCFNumberIntType, (char *)this + 4152);
          number = (CFNumberRef)CFDictionaryGetValue(theDict, CFSTR("Max"));
          if (number)
            CFNumberGetValue(number, kCFNumberIntType, (char *)this + 4156);
        }
        else
        {
          *((_DWORD *)this + 1038) = (int)v60;
          *((_DWORD *)this + 1039) = (int)*(float *)&CPMSAPLTable[50 * APLIndex + 103 + CPMSAPLTable[1] - 1];
        }
        theDict = (CFDictionaryRef)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("UPORestriction"));
        if (theDict)
        {
          Value = (CFNumberRef)CFDictionaryGetValue(theDict, CFSTR("Min"));
          if (Value)
            CFNumberGetValue(Value, kCFNumberIntType, (char *)this + 4136);
          Value = (CFNumberRef)CFDictionaryGetValue(theDict, CFSTR("Max"));
          if (Value)
            CFNumberGetValue(Value, kCFNumberIntType, (char *)this + 4140);
        }
        else
        {
          *((_DWORD *)this + 1034) = (int)v60;
          *((_DWORD *)this + 1035) = (int)*(float *)&CPMSAPLTable[50 * APLIndex + 103 + CPMSAPLTable[1] - 1];
        }
        theDict = (CFDictionaryRef)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("HDRRestriction"));
        if (theDict)
        {
          v47 = (CFNumberRef)CFDictionaryGetValue(theDict, CFSTR("Min"));
          if (v47)
            CFNumberGetValue(v47, kCFNumberIntType, (char *)this + 4144);
          v47 = (CFNumberRef)CFDictionaryGetValue(theDict, CFSTR("Max"));
          if (v47)
            CFNumberGetValue(v47, kCFNumberIntType, (char *)this + 4148);
        }
        else
        {
          *((_DWORD *)this + 1036) = (int)v57;
          *((_DWORD *)this + 1037) = (int)*(float *)&CPMSAPLTable[50 * v56 + 103 + *CPMSAPLTable - 1];
        }
      }
      else
      {
        *((_DWORD *)this + 1034) = (int)v60;
        *((_DWORD *)this + 1035) = (int)*(float *)&CPMSAPLTable[50 * APLIndex + 103 + CPMSAPLTable[1] - 1];
        *((_DWORD *)this + 1038) = (int)v60;
        *((_DWORD *)this + 1039) = (int)*(float *)&CPMSAPLTable[50 * APLIndex + 103 + CPMSAPLTable[1] - 1];
        *((_DWORD *)this + 1036) = (int)v57;
        *((_DWORD *)this + 1037) = (int)*(float *)&CPMSAPLTable[50 * v56 + 103 + CPMSAPLTable[1] - 1];
      }
      if (cf)
        CFRelease(cf);
      *((float *)this + 1025) = -1.0;
      *((float *)this + 1026) = -1.0;
      *((float *)this + 1024) = -1.0;
      *((float *)this + 1029) = 5.0;
      *((float *)this + 1027) = 5.0;
      *((float *)this + 1028) = 5.0;
      v46 = 0;
      if (_logHandle)
      {
        v12 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v11 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v11 = init_default_corebrightness_log();
        v12 = v11;
      }
      v46 = v12;
      v45 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        v9 = v46;
        v10 = v45;
        __os_log_helper_16_0_0(v44);
        _os_log_impl(&dword_1B5291000, v9, v10, "Registering CPMS Client", v44, 2u);
      }
      v43 = 0;
      if (_logHandle)
      {
        v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v7 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v7 = init_default_corebrightness_log();
        v8 = v7;
      }
      v43 = v8;
      v42 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_6_4_0_4_0_4_0_4_0_4_0_4_0((uint64_t)v70, *((_DWORD *)this + 1034), *((_DWORD *)this + 1035), *((_DWORD *)this + 1038), *((_DWORD *)this + 1039), *((_DWORD *)this + 1036), *((_DWORD *)this + 1037));
        _os_log_impl(&dword_1B5291000, v43, v42, "CPMS budgets[min/max]: UPO %d/%d, CLTM %d/%d, HDR %d/%d", v70, 0x26u);
      }
      *((_QWORD *)this + 516) = objc_msgSend(MEMORY[0x1E0D09930], "sharedCPMSAgent");
      *((_QWORD *)this + 515) = objc_alloc_init(MEMORY[0x1E0D09940]);
      if (*((_QWORD *)this + 515))
      {
        objc_msgSend(*((id *)this + 515), "setClientId:", 7);
        v41 = 0;
        v41 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", *((unsigned int *)this + 1036));
        v40 = 0;
        v40 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", *((unsigned int *)this + 1037));
        v39 = 0;
        v39 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", *((unsigned int *)this + 1034));
        v38 = 0;
        v38 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", *((unsigned int *)this + 1035));
        v37 = 0;
        v37 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", *((unsigned int *)this + 1038));
        v36 = 0;
        v36 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", *((unsigned int *)this + 1039));
        v35 = 0;
        v35 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D20]), "initWithObjects:", v41, v40, 0);
        v34 = 0;
        v1 = objc_alloc(MEMORY[0x1E0C99D20]);
        v34 = (id)objc_msgSend(v1, "initWithObjects:", v39, v38, 0);
        v33 = 0;
        v2 = objc_alloc(MEMORY[0x1E0C99D20]);
        v33 = (id)objc_msgSend(v2, "initWithObjects:", v37, v36, 0);
        v32 = 0;
        v3 = objc_alloc(MEMORY[0x1E0C99D80]);
        v32 = (id)objc_msgSend(v3, "initWithObjectsAndKeys:", v35, *MEMORY[0x1E0D09978], v34, *MEMORY[0x1E0D09950], v33, *MEMORY[0x1E0D09968], 0);
        objc_msgSend(*((id *)this + 515), "setPowerLevels:", v32);
        objc_msgSend(*((id *)this + 515), "setIsContinuous:", 1);
        objc_msgSend(*((id *)this + 515), "setPowerBudgetUpdateMinimumPeriod:", 1000);
        v26 = MEMORY[0x1E0C809B0];
        v27 = -1073741824;
        v28 = 0;
        v29 = ___ZN4AABC20InitializeCPMSModuleEv_block_invoke;
        v30 = &__block_descriptor_40_e22_v16__0__NSDictionary_8l;
        v31 = this;
        objc_msgSend(*((id *)this + 515), "setNotificationCallback:", &v26);
        objc_msgSend(*((id *)this + 515), "setGetCurrentPower:", &__block_literal_global_735);
        v25 = 0;
        v25 = objc_msgSend(*((id *)this + 516), "registerClientWithDescription:error:", *((_QWORD *)this + 515), 0) & 1;
        if (v25 == 1)
        {
          v24 = 0;
          if (_logHandle)
          {
            v6 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v5 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v5 = init_default_corebrightness_log();
            v6 = v5;
          }
          v24 = v6;
          v23 = OS_LOG_TYPE_INFO;
          if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
          {
            __os_log_helper_16_2_1_8_66((uint64_t)v69, objc_msgSend(*((id *)this + 515), "description"));
            _os_log_impl(&dword_1B5291000, v24, v23, "Successfully Registered CPMS Client\n%{public}@\n", v69, 0xCu);
          }
          v22 = 0;
          v4 = (void *)*((_QWORD *)this + 516);
          v67[0] = *MEMORY[0x1E0D09978];
          v68[0] = v40;
          v67[1] = *MEMORY[0x1E0D09950];
          v68[1] = v38;
          v67[2] = *MEMORY[0x1E0D09968];
          v68[2] = v36;
          v22 = (id)objc_msgSend(v4, "copyPowerBudgetForRequest:forClient:error:", objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v68, v67, 3), objc_msgSend(*((id *)this + 515), "clientId"), 0);
          if (v22)
          {
            objc_msgSend(*((id *)this + 516), "acknowledgePowerBudget:forClientId:error:", v22, objc_msgSend(*((id *)this + 515), "clientId"), 0);

          }
          v21[0] = fmaxf(*(float *)&CPMSAPLTable[CPMSAPLTable[1] - 1 + 53], *((float *)this + 182));
          v21[1] = v21[0];
          v21[2] = v21[0];
          DisplayUpdateCPMSBudget(*((_QWORD *)this + 51), (uint64_t)v21);
        }

      }
    }
  }
}

void AABC::unscheduleFromDispatchQueue(uint64_t a1)
{
  uint64_t inited;
  NSObject *v2;
  uint8_t v3[8];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 376))
  {
    if (*(_DWORD *)(a1 + 4032))
      notify_cancel(*(_DWORD *)(a1 + 4032));
    if (_logHandle)
    {
      v2 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v2 = inited;
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v3, 4);
      _os_log_debug_impl(&dword_1B5291000, v2, OS_LOG_TYPE_DEBUG, "[%x]: ", v3, 8u);
    }
  }
}

CFDictionaryRef AABC::createCurvePrefsDictionary(uint64_t a1, void *a2)
{
  CFArrayCallBacks *callBacks;
  CFAllocatorRef *v4;
  CFDictionaryRef v5;
  CFNumberRef cf;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  _BOOL4 v11;
  CFTypeRef v12;
  CFTypeRef v13;
  CFTypeRef v14;
  CFTypeRef v15;
  CFTypeRef v16;
  CFTypeRef v17;
  void *valuePtr;
  uint64_t v19;
  const void *__b[11];
  CFNumberRef v21;
  CFNumberRef v22;
  CFNumberRef v23;
  const void *__dst[12];

  __dst[11] = *(const void **)MEMORY[0x1E0C80C00];
  v19 = a1;
  valuePtr = a2;
  memcpy(__dst, &off_1E68EB8D0, 0x58uLL);
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v4 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  v21 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, valuePtr);
  v22 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 4);
  v23 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 8);
  v17 = 0;
  callBacks = (CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  v17 = CFArrayCreate(*v4, (const void **)&v21, 3, MEMORY[0x1E0C9B378]);
  CFRelease(v21);
  CFRelease(v22);
  CFRelease(v23);
  v21 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 12);
  v22 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 16);
  v23 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 20);
  v16 = 0;
  v16 = CFArrayCreate(*v4, (const void **)&v21, 3, callBacks);
  CFRelease(v21);
  CFRelease(v22);
  CFRelease(v23);
  v15 = 0;
  v15 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 24);
  v14 = 0;
  v14 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 28);
  v13 = 0;
  v13 = CFNumberCreate(*v4, kCFNumberIntType, (char *)valuePtr + 32);
  v21 = CFNumberCreate(*v4, kCFNumberIntType, (char *)valuePtr + 36);
  v22 = CFNumberCreate(*v4, kCFNumberIntType, (char *)valuePtr + 40);
  v23 = CFNumberCreate(*v4, kCFNumberIntType, (char *)valuePtr + 44);
  v12 = 0;
  v12 = CFArrayCreate(*v4, (const void **)&v21, 3, callBacks);
  CFRelease(v21);
  CFRelease(v22);
  CFRelease(v23);
  v11 = 0;
  v11 = (*((_BYTE *)valuePtr + 48) & 1) != 0;
  v10 = CFNumberCreate(*v4, kCFNumberIntType, &v11);
  v9 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 52);
  v8 = CFNumberCreate(*v4, kCFNumberDoubleType, (char *)valuePtr + 56);
  v7 = CFNumberCreate(*v4, kCFNumberIntType, (char *)valuePtr + 64);
  cf = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 68);
  __b[0] = v17;
  __b[1] = v16;
  __b[2] = v15;
  __b[3] = v14;
  __b[4] = v13;
  __b[5] = v12;
  __b[6] = v10;
  __b[7] = v9;
  __b[8] = v8;
  __b[9] = v7;
  __b[10] = cf;
  v5 = CFDictionaryCreate(*v4, __dst, __b, 11, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFRelease(cf);
  CFRelease(v7);
  CFRelease(v8);
  CFRelease(v9);
  CFRelease(v10);
  CFRelease(v12);
  CFRelease(v13);
  CFRelease(v14);
  CFRelease(v15);
  CFRelease(v16);
  CFRelease(v17);
  return v5;
}

const void *AABC::readCurvePrefsFromDictionary(uint64_t a1, const __CFDictionary *a2, uint64_t a3)
{
  const void *result;
  CFTypeID TypeID;
  CFTypeID v5;
  CFTypeID v6;
  CFTypeID v7;
  CFTypeID v8;
  CFTypeID v9;
  CFTypeID v10;
  CFTypeID v11;
  CFTypeID v12;
  CFTypeID v13;
  CFTypeID v14;
  CFTypeID v15;
  CFTypeID v16;
  CFTypeID v17;
  CFTypeID v18;
  int valuePtr;
  int k;
  CFTypeRef v21;
  int j;
  CFTypeRef v23;
  int i;
  CFTypeRef ValueAtIndex;
  CFTypeRef Value;
  uint64_t v27;
  CFDictionaryRef v28;
  uint64_t v29;

  v29 = a1;
  v28 = a2;
  v27 = a3;
  Value = CFDictionaryGetValue(a2, CFSTR("Eprefs"));
  if (Value)
  {
    v18 = CFGetTypeID(Value);
    if (v18 == CFArrayGetTypeID())
    {
      ValueAtIndex = 0;
      for (i = 0; i < 3; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)Value, i);
        if (ValueAtIndex)
        {
          v17 = CFGetTypeID(ValueAtIndex);
          if (v17 == CFNumberGetTypeID())
            CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberFloatType, (void *)(v27 + 4 * i));
        }
      }
    }
  }
  Value = CFDictionaryGetValue(v28, CFSTR("Lprefs"));
  if (Value)
  {
    v16 = CFGetTypeID(Value);
    if (v16 == CFArrayGetTypeID())
    {
      v23 = 0;
      for (j = 0; j < 3; ++j)
      {
        v23 = CFArrayGetValueAtIndex((CFArrayRef)Value, j);
        if (v23)
        {
          v15 = CFGetTypeID(v23);
          if (v15 == CFNumberGetTypeID())
            CFNumberGetValue((CFNumberRef)v23, kCFNumberFloatType, (void *)(v27 + 12 + 4 * j));
        }
      }
    }
  }
  Value = CFDictionaryGetValue(v28, CFSTR("Eoverride"));
  if (Value)
  {
    v14 = CFGetTypeID(Value);
    if (v14 == CFNumberGetTypeID())
      CFNumberGetValue((CFNumberRef)Value, kCFNumberFloatType, (void *)(v27 + 24));
  }
  Value = CFDictionaryGetValue(v28, CFSTR("Loverride"));
  if (Value)
  {
    v13 = CFGetTypeID(Value);
    if (v13 == CFNumberGetTypeID())
      CFNumberGetValue((CFNumberRef)Value, kCFNumberFloatType, (void *)(v27 + 28));
  }
  Value = CFDictionaryGetValue(v28, CFSTR("overridePref"));
  if (Value)
  {
    v12 = CFGetTypeID(Value);
    if (v12 == CFNumberGetTypeID())
      CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, (void *)(v27 + 32));
  }
  Value = CFDictionaryGetValue(v28, CFSTR("age"));
  if (Value)
  {
    v11 = CFGetTypeID(Value);
    if (v11 == CFArrayGetTypeID())
    {
      v21 = 0;
      for (k = 0; k < 3; ++k)
      {
        v21 = CFArrayGetValueAtIndex((CFArrayRef)Value, k);
        if (v21)
        {
          v10 = CFGetTypeID(v21);
          if (v10 == CFNumberGetTypeID())
            CFNumberGetValue((CFNumberRef)v21, kCFNumberIntType, (void *)(v27 + 36 + 4 * k));
        }
      }
    }
  }
  Value = CFDictionaryGetValue(v28, CFSTR("justOverriddenBrightValue"));
  if (Value)
  {
    v9 = CFGetTypeID(Value);
    if (v9 == CFNumberGetTypeID())
    {
      valuePtr = 0;
      CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, &valuePtr);
      *(_BYTE *)(v27 + 48) = valuePtr != 0;
    }
  }
  Value = 0;
  Value = CFDictionaryGetValue(v28, CFSTR("thirdSlope"));
  if (Value)
  {
    v8 = CFGetTypeID(Value);
    if (v8 == CFNumberGetTypeID())
      CFNumberGetValue((CFNumberRef)Value, kCFNumberFloatType, (void *)(v27 + 52));
  }
  Value = 0;
  Value = CFDictionaryGetValue(v28, CFSTR("timestamp"));
  if (Value)
  {
    v7 = CFGetTypeID(Value);
    if (v7 == CFNumberGetTypeID())
      CFNumberGetValue((CFNumberRef)Value, kCFNumberDoubleType, (void *)(v27 + 56));
  }
  *(_DWORD *)(v27 + 64) = 0;
  Value = 0;
  Value = CFDictionaryGetValue(v28, CFSTR("curveType"));
  if (Value)
  {
    v6 = CFGetTypeID(Value);
    if (v6 == CFNumberGetTypeID())
      CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, (void *)(v27 + 64));
  }
  *(float *)(v27 + 68) = -1.0;
  Value = 0;
  result = CFDictionaryGetValue(v28, CFSTR("EmaxCap"));
  Value = result;
  if (result)
  {
    v5 = CFGetTypeID(Value);
    TypeID = CFNumberGetTypeID();
    result = (const void *)v5;
    if (v5 == TypeID)
      return (const void *)CFNumberGetValue((CFNumberRef)Value, kCFNumberFloatType, (void *)(v27 + 68));
  }
  return result;
}

CFDictionaryRef AABC::createCurveDictionary(uint64_t a1, void *a2)
{
  CFAllocatorRef *v4;
  CFDictionaryRef v5;
  int v6;
  void *v7;
  uint64_t v8;
  const void *__b[11];
  const void *__dst[12];

  __dst[11] = *(const void **)MEMORY[0x1E0C80C00];
  v8 = a1;
  v7 = a2;
  v6 = 0;
  v6 = *(_DWORD *)(a1 + 732);
  memcpy(__dst, &off_1E68EB928, 0x58uLL);
  memset(__b, 0, sizeof(__b));
  v4 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  __b[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &v6);
  __b[1] = CFNumberCreate(*v4, kCFNumberFloatType, (const void *)(a1 + 532));
  __b[2] = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 16);
  __b[3] = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 24);
  __b[4] = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 20);
  __b[5] = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 28);
  __b[6] = CFNumberCreate(*v4, kCFNumberFloatType, v7);
  __b[7] = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 4);
  __b[8] = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 8);
  __b[9] = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 12);
  __b[10] = AABC::createCurvePrefsDictionary(a1, (char *)v7 + 32);
  v5 = CFDictionaryCreate(*v4, __dst, __b, 11, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFRelease(__b[10]);
  CFRelease(__b[9]);
  CFRelease(__b[8]);
  CFRelease(__b[7]);
  CFRelease(__b[6]);
  CFRelease(__b[5]);
  CFRelease(__b[4]);
  CFRelease(__b[3]);
  CFRelease(__b[2]);
  CFRelease(__b[1]);
  CFRelease(__b[0]);
  return v5;
}

CFDictionaryRef AABC::createCurveDescriptorDictionary(uint64_t a1, _DWORD *a2)
{
  CFAllocatorRef *v3;
  uint64_t v4;
  CFDictionaryRef v5;
  int j;
  CFArrayRef v7;
  int i;
  CFTypeRef v10;
  uint64_t v11;
  CFTypeRef cf;
  void *values[3];
  void *keys[2];
  const __CFString *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)keys = xmmword_1E68EB980;
  v15 = CFSTR("badCurves");
  memset(values, 0, sizeof(values));
  for (i = 0; i < 3; ++i)
    values[i] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &a2[2 * i + 2]);
  v7 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)values, 3, MEMORY[0x1E0C9B378]);
  for (j = 0; j < 3; ++j)
    CFRelease(values[j]);
  v11 = 0;
  cf = 0;
  v10 = v7;
  if (a2[8])
    v4 = *MEMORY[0x1E0C9AE50];
  else
    v4 = *MEMORY[0x1E0C9AE40];
  v11 = v4;
  v3 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, a2);
  v5 = CFDictionaryCreate(*v3, (const void **)keys, &v10, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFRelease(cf);
  CFRelease(v10);
  return v5;
}

const __CFNumber *AABC::readOutlierRemovalFromDictionary(uint64_t a1, const __CFDictionary *a2, BOOL *a3)
{
  const __CFNumber *result;
  CFTypeID TypeID;
  CFTypeID v5;
  CFTypeID v6;
  CFTypeID v7;
  CFTypeID v8;
  CFTypeID v9;
  const void *Value;
  const void *v11;
  const void *v12;
  const void *v13;
  const __CFNumber *v14;

  Value = CFDictionaryGetValue(a2, CFSTR("enabled"));
  if (Value)
  {
    v9 = CFGetTypeID(Value);
    if (v9 == CFBooleanGetTypeID())
      *a3 = CFBooleanGetValue((CFBooleanRef)Value) != 0;
  }
  v11 = CFDictionaryGetValue(a2, CFSTR("badCurvesToStick"));
  if (v11)
  {
    v8 = CFGetTypeID(v11);
    if (v8 == CFNumberGetTypeID())
      CFNumberGetValue((CFNumberRef)v11, kCFNumberIntType, a3 + 4);
  }
  v12 = CFDictionaryGetValue(a2, CFSTR("revertTime"));
  if (v12)
  {
    v7 = CFGetTypeID(v12);
    if (v7 == CFNumberGetTypeID())
      CFNumberGetValue((CFNumberRef)v12, kCFNumberDoubleType, a3 + 8);
  }
  v13 = CFDictionaryGetValue(a2, CFSTR("resetTime"));
  if (v13)
  {
    v6 = CFGetTypeID(v13);
    if (v6 == CFNumberGetTypeID())
      CFNumberGetValue((CFNumberRef)v13, kCFNumberDoubleType, a3 + 24);
  }
  result = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("displayOffTime"));
  v14 = result;
  if (result)
  {
    v5 = CFGetTypeID(result);
    TypeID = CFNumberGetTypeID();
    result = (const __CFNumber *)v5;
    if (v5 == TypeID)
      return (const __CFNumber *)CFNumberGetValue(v14, kCFNumberDoubleType, a3 + 16);
  }
  return result;
}

const __CFNumber *AABC::readCurveDescriptorFromDictionary(uint64_t a1, const __CFDictionary *a2, _DWORD *a3)
{
  const __CFNumber *result;
  CFTypeID TypeID;
  CFTypeID v5;
  CFTypeID v6;
  CFTypeID v7;
  CFTypeID v8;
  CFTypeRef cf;
  uint64_t idx;
  unsigned int Count;
  const void *Value;
  const void *v13;
  const __CFNumber *v14;

  Value = CFDictionaryGetValue(a2, CFSTR("timestamps"));
  if (Value)
  {
    v8 = CFGetTypeID(Value);
    if (v8 == CFArrayGetTypeID())
    {
      Count = CFArrayGetCount((CFArrayRef)Value);
      for (idx = 0; idx < Count && idx < 3; ++idx)
      {
        cf = CFArrayGetValueAtIndex((CFArrayRef)Value, idx);
        if (cf)
        {
          v7 = CFGetTypeID(cf);
          if (v7 == CFNumberGetTypeID())
            CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &a3[2 * idx + 2]);
        }
      }
    }
  }
  v13 = CFDictionaryGetValue(a2, CFSTR("reverted"));
  if (v13)
  {
    v6 = CFGetTypeID(v13);
    if (v6 == CFBooleanGetTypeID())
      a3[8] = CFBooleanGetValue((CFBooleanRef)v13);
  }
  result = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("badCurves"));
  v14 = result;
  if (result)
  {
    v5 = CFGetTypeID(result);
    TypeID = CFNumberGetTypeID();
    result = (const __CFNumber *)v5;
    if (v5 == TypeID)
      return (const __CFNumber *)CFNumberGetValue(v14, kCFNumberIntType, a3);
  }
  return result;
}

void AABC::readCurveFromDictionary(uint64_t a1, const __CFDictionary *a2, float *a3)
{
  uint64_t inited;
  NSObject *v4;
  CFTypeID v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  CFTypeID v10;
  CFTypeID v11;
  CFTypeID v12;
  CFTypeID v13;
  CFTypeID v14;
  CFTypeID v15;
  CFTypeID v16;
  CFTypeID v17;
  CFTypeID v18;
  CFTypeID v19;
  int v21;
  int v22;
  int v23;
  float v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int valuePtr;
  const __CFDictionary *Value;
  float *v32;
  CFDictionaryRef v33;
  uint64_t v34;
  uint8_t v35[16];
  uint8_t v36[48];
  uint8_t v37[56];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v34 = a1;
  v33 = a2;
  v32 = a3;
  valuePtr = -1;
  Value = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("version"));
  if (Value)
  {
    v19 = CFGetTypeID(Value);
    if (v19 == CFNumberGetTypeID())
      CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
  }
  if (valuePtr < *(_DWORD *)(a1 + 732) || valuePtr > 6)
  {
    if (_logHandle)
    {
      v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v4 = inited;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v35, valuePtr);
      _os_log_impl(&dword_1B5291000, v4, OS_LOG_TYPE_INFO, "unsupported curve version %d", v35, 8u);
    }
  }
  else
  {
    v29 = 0;
    v29 = *(_DWORD *)(a1 + 532);
    v28 = 0;
    v28 = *((_DWORD *)v32 + 4);
    v27 = 0;
    v27 = *((_DWORD *)v32 + 6);
    v26 = 0;
    v26 = *((_DWORD *)v32 + 5);
    v25 = 0;
    v25 = *((_DWORD *)v32 + 7);
    v24 = 0.0;
    v24 = *v32;
    v23 = 0;
    v23 = *((_DWORD *)v32 + 1);
    v22 = 0;
    v22 = *((_DWORD *)v32 + 2);
    v21 = 0;
    v21 = *((_DWORD *)v32 + 3);
    Value = (const __CFDictionary *)CFDictionaryGetValue(v33, CFSTR("S"));
    if (Value)
    {
      v18 = CFGetTypeID(Value);
      if (v18 == CFNumberGetTypeID())
        CFNumberGetValue(Value, kCFNumberFloatType, &v29);
    }
    Value = (const __CFDictionary *)CFDictionaryGetValue(v33, CFSTR("E1"));
    if (Value)
    {
      v17 = CFGetTypeID(Value);
      if (v17 == CFNumberGetTypeID())
        CFNumberGetValue(Value, kCFNumberFloatType, &v28);
    }
    Value = (const __CFDictionary *)CFDictionaryGetValue(v33, CFSTR("L1"));
    if (Value)
    {
      v16 = CFGetTypeID(Value);
      if (v16 == CFNumberGetTypeID())
        CFNumberGetValue(Value, kCFNumberFloatType, &v27);
    }
    Value = (const __CFDictionary *)CFDictionaryGetValue(v33, CFSTR("E2"));
    if (Value)
    {
      v15 = CFGetTypeID(Value);
      if (v15 == CFNumberGetTypeID())
        CFNumberGetValue(Value, kCFNumberFloatType, &v26);
    }
    Value = (const __CFDictionary *)CFDictionaryGetValue(v33, CFSTR("L2"));
    if (Value)
    {
      v14 = CFGetTypeID(Value);
      if (v14 == CFNumberGetTypeID())
        CFNumberGetValue(Value, kCFNumberFloatType, &v25);
    }
    Value = (const __CFDictionary *)CFDictionaryGetValue(v33, CFSTR("E0a"));
    if (Value)
    {
      v13 = CFGetTypeID(Value);
      if (v13 == CFNumberGetTypeID())
        CFNumberGetValue(Value, kCFNumberFloatType, &v24);
    }
    Value = (const __CFDictionary *)CFDictionaryGetValue(v33, CFSTR("L0a"));
    if (Value)
    {
      v12 = CFGetTypeID(Value);
      if (v12 == CFNumberGetTypeID())
        CFNumberGetValue(Value, kCFNumberFloatType, &v23);
    }
    Value = (const __CFDictionary *)CFDictionaryGetValue(v33, CFSTR("E0b"));
    if (Value)
    {
      v11 = CFGetTypeID(Value);
      if (v11 == CFNumberGetTypeID())
        CFNumberGetValue(Value, kCFNumberFloatType, &v22);
    }
    Value = (const __CFDictionary *)CFDictionaryGetValue(v33, CFSTR("L0b"));
    if (Value)
    {
      v10 = CFGetTypeID(Value);
      if (v10 == CFNumberGetTypeID())
        CFNumberGetValue(Value, kCFNumberFloatType, &v21);
    }
    *(_DWORD *)(a1 + 532) = v29;
    *((_DWORD *)v32 + 4) = v28;
    *((_DWORD *)v32 + 6) = v27;
    *((_DWORD *)v32 + 5) = v26;
    *((_DWORD *)v32 + 7) = v25;
    *v32 = v24;
    *((_DWORD *)v32 + 1) = v23;
    *((_DWORD *)v32 + 2) = v22;
    *((_DWORD *)v32 + 3) = v21;
    if (_logHandle)
    {
      v9 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v8 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v8 = init_default_corebrightness_log();
      v9 = v8;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v37, COERCE__INT64(v32[4]), COERCE__INT64(v32[6]), COERCE__INT64(v32[5]), COERCE__INT64(v32[7]));
      _os_log_debug_impl(&dword_1B5291000, v9, OS_LOG_TYPE_DEBUG, "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f", v37, 0x2Au);
    }
    if (_logHandle)
    {
      v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v6 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v6 = init_default_corebrightness_log();
      v7 = v6;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v36, COERCE__INT64(*v32), COERCE__INT64(v32[1]), COERCE__INT64(v32[2]), COERCE__INT64(v32[3]));
      _os_log_debug_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEBUG, "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v36, 0x2Au);
    }
    Value = (const __CFDictionary *)CFDictionaryGetValue(v33, CFSTR("Prefs"));
    if (Value)
    {
      v5 = CFGetTypeID(Value);
      if (v5 == CFDictionaryGetTypeID())
        AABC::readCurvePrefsFromDictionary(a1, Value, (uint64_t)(v32 + 8));
    }
  }
}

BOOL AABC::isCurveGood(uint64_t a1, uint64_t a2)
{
  return *(float *)(a2 + 4) < *(float *)(a1 + 724) && *(float *)(a2 + 12) < (float)(*(float *)(a1 + 728) / 2.0);
}

uint64_t AABC::writeOutlierRemovalPreferences(uint64_t this, int a2)
{
  CFStringRef *v2;
  CFPropertyListRef value;

  if ((*(_BYTE *)(this + 3368) & 1) != 0)
  {
    CFPreferencesAppSynchronize((CFStringRef)*MEMORY[0x1E0C9B248]);
    if (a2)
      value = (CFPropertyListRef)*MEMORY[0x1E0C9AE50];
    else
      value = (CFPropertyListRef)*MEMORY[0x1E0C9AE40];
    v2 = (CFStringRef *)MEMORY[0x1E0C9B248];
    CFPreferencesSetAppValue(CFSTR("CBCurveSticks"), value, (CFStringRef)*MEMORY[0x1E0C9B248]);
    return CFPreferencesAppSynchronize(*v2);
  }
  return this;
}

float AABC::LuminanceToIlluminance(uint64_t a1, float *a2, float a3)
{
  return fmaxf(0.0, AAB::LuminanceToIlluminance(a3, a1, a2));
}

uint64_t __os_log_helper_16_2_3_4_0_8_64_8_64(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 64;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 64;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  return result;
}

void AABC::_setInternalProperty(__CFString *this, __CFString *a2, AABC *a3, AABC *a4)
{
  AABC::setInternalProperty(a3, this, a2);
}

void AABC::setInternalProperty(AABC *this, __CFString *a2, void *a3)
{
  CFTypeID v3;
  CFTypeID v4;
  CFTypeID v5;
  uint64_t v6;
  NSObject *v7;
  CFTypeID v8;
  CFTypeID v9;
  uint64_t v10;
  NSObject *v11;
  CFTypeID v12;
  uint64_t v13;
  NSObject *v14;
  CFTypeID v15;
  uint64_t v16;
  NSObject *v17;
  CFTypeID v18;
  CFTypeID v19;
  uint64_t v20;
  NSObject *v21;
  CFTypeID v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  CFTypeID v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  NSObject *v31;
  CFTypeID v32;
  uint64_t inited;
  NSObject *v34;
  unsigned int v36;
  int v37;
  int v38;
  os_log_type_t v39;
  os_log_t v40;
  CFTypeRef cf;
  int v42;
  int v43;
  os_log_type_t v44;
  os_log_t v45;
  float v46;
  os_log_type_t v47;
  os_log_t v48;
  int v49;
  os_log_type_t v50;
  os_log_t v51;
  float v52;
  float valuePtr;
  os_log_type_t v54;
  os_log_t v55;
  os_log_type_t v56;
  os_log_t v57;
  os_log_type_t v58;
  os_log_t v59;
  os_log_type_t v60;
  os_log_t v61;
  os_log_type_t v62;
  os_log_t v63;
  os_log_type_t type;
  os_log_t oslog;
  void *value;
  void *key;
  AABC *v68;
  uint8_t v69[16];
  uint8_t v70[32];
  uint8_t v71[32];
  uint8_t v72[32];
  uint8_t v73[32];
  uint8_t v74[32];
  uint8_t v75[32];
  uint8_t v76[32];
  uint8_t v77[32];
  uint8_t v78[40];
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  v68 = this;
  key = a2;
  value = a3;
  oslog = 0;
  if (_logHandle)
  {
    v34 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v34 = inited;
  }
  oslog = v34;
  type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v78, 2, (uint64_t)key, (uint64_t)value);
    _os_log_debug_impl(&dword_1B5291000, oslog, type, "[%x]: key=%@ property=%@", v78, 0x1Cu);
  }
  if (*((_DWORD *)this + 94))
  {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), key, value);
    if (CFEqual(key, CFSTR("ALSSpikeFilterDuration")))
    {
      v32 = CFGetTypeID(value);
      if (v32 == CFNumberGetTypeID())
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, (char *)this + 3444);
        v63 = 0;
        if (_logHandle)
        {
          v31 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v30 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v30 = init_default_corebrightness_log();
          v31 = v30;
        }
        v63 = v31;
        v62 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_8_0((uint64_t)v77, 2, COERCE__INT64(*((float *)this + 861)));
          _os_log_debug_impl(&dword_1B5291000, v63, v62, "[%x]: updated spike filter history %fs", v77, 0x12u);
        }
        CFDictionaryApplyFunction(*((CFDictionaryRef *)this + 53), (CFDictionaryApplierFunction)AABC::ClearHistoryFunction, this);
      }
    }
    else if (CFEqual(key, CFSTR("ALSMaxBrightenDuration")))
    {
      v61 = 0;
      if (_logHandle)
      {
        v29 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v28 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v28 = init_default_corebrightness_log();
        v29 = v28;
      }
      v61 = v29;
      v60 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v76, 2, (uint64_t)key, (uint64_t)value);
        _os_log_debug_impl(&dword_1B5291000, v61, v60, "[%x]: ALSMaxBrightenDuration key=%@ property=%@", v76, 0x1Cu);
      }
      v27 = CFGetTypeID(value);
      if (v27 == CFNumberGetTypeID())
      {
        v59 = 0;
        if (_logHandle)
        {
          v26 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v25 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v25 = init_default_corebrightness_log();
          v26 = v25;
        }
        v59 = v26;
        v58 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v75, 2, (uint64_t)key, (uint64_t)value);
          _os_log_debug_impl(&dword_1B5291000, v59, v58, "[%x]: ALSMaxBrightenDuration2 key=%@ property=%@", v75, 0x1Cu);
        }
        CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, (char *)this + 3448);
        PerceptualLuminanceThresholding::SetBrightenDuration(*((_QWORD *)this + 502), *((float *)this + 862));
        PerceptualLuminanceThresholding::UpdateTimeConstantTable(*((PerceptualLuminanceThresholding **)this + 502), *((_DWORD *)this + 142));
      }
    }
    else if (CFEqual(key, CFSTR("ALSMaxDimDuration")))
    {
      v57 = 0;
      if (_logHandle)
      {
        v24 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v23 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v23 = init_default_corebrightness_log();
        v24 = v23;
      }
      v57 = v24;
      v56 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v74, 2, (uint64_t)key, (uint64_t)value);
        _os_log_debug_impl(&dword_1B5291000, v57, v56, "[%x]: ALSMaxDimDuration key=%@ property=%@", v74, 0x1Cu);
      }
      v22 = CFGetTypeID(value);
      if (v22 == CFNumberGetTypeID())
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, (char *)this + 3452);
        PerceptualLuminanceThresholding::SetMaxDimDuration(*((_QWORD *)this + 502), *((float *)this + 863));
        PerceptualLuminanceThresholding::UpdateTimeConstantTable(*((PerceptualLuminanceThresholding **)this + 502), *((_DWORD *)this + 142));
      }
    }
    else if (CFEqual(key, CFSTR("ALSBrightenPdeltaSlow")))
    {
      v55 = 0;
      if (_logHandle)
      {
        v21 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v20 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v20 = init_default_corebrightness_log();
        v21 = v20;
      }
      v55 = v21;
      v54 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v73, 2, (uint64_t)key, (uint64_t)value);
        _os_log_debug_impl(&dword_1B5291000, v55, v54, "[%x]: ALSBrightenPdeltaSlow key=%@ property=%@", v73, 0x1Cu);
      }
      v19 = CFGetTypeID(value);
      if (v19 == CFNumberGetTypeID())
      {
        valuePtr = 0.0;
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &valuePtr))
        {
          *((float *)this + 1000) = valuePtr;
          *((float *)this + 1001) = valuePtr;
          PerceptualLuminanceThresholding::SetPthresholdBrighten(*((_QWORD *)this + 502), valuePtr);
        }
      }
    }
    else if (CFEqual(key, CFSTR("PLT_X")) || CFEqual(key, CFSTR("PLT_Y")) || CFEqual(key, CFSTR("PLT_Z")))
    {
      v18 = CFGetTypeID(value);
      if (v18 == CFNumberGetTypeID())
      {
        v52 = 0.0;
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &v52))
          (***((void (****)(_QWORD, void *, float))this + 502))(*((_QWORD *)this + 502), key, v52);
      }
    }
    else if (CFEqual(key, CFSTR("ALSBrightenPdeltaFast")))
    {
      v51 = 0;
      if (_logHandle)
      {
        v17 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v16 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v16 = init_default_corebrightness_log();
        v17 = v16;
      }
      v51 = v17;
      v50 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v72, 2, (uint64_t)key, (uint64_t)value);
        _os_log_debug_impl(&dword_1B5291000, v51, v50, "[%x]: ALSBrightenPdeltaFast key=%@ property=%@", v72, 0x1Cu);
      }
      v15 = CFGetTypeID(value);
      if (v15 == CFNumberGetTypeID())
      {
        v49 = 0;
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &v49))
          *((_DWORD *)this + 999) = v49;
      }
    }
    else if (CFEqual(key, CFSTR("ALSDimPdeltaSlow")))
    {
      v48 = 0;
      if (_logHandle)
      {
        v14 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v13 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v13 = init_default_corebrightness_log();
        v14 = v13;
      }
      v48 = v14;
      v47 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v71, 2, (uint64_t)key, (uint64_t)value);
        _os_log_debug_impl(&dword_1B5291000, v48, v47, "[%x]: ALSDimPdeltaSlow key=%@ property=%@", v71, 0x1Cu);
      }
      v12 = CFGetTypeID(value);
      if (v12 == CFNumberGetTypeID())
      {
        v46 = 0.0;
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &v46))
        {
          *((float *)this + 997) = v46;
          *((float *)this + 998) = v46;
          PerceptualLuminanceThresholding::SetPthresholdDim(*((_QWORD *)this + 502), v46);
        }
      }
    }
    else if (CFEqual(key, CFSTR("ALSRampLuxThreshold")))
    {
      v45 = 0;
      if (_logHandle)
      {
        v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v10 = init_default_corebrightness_log();
        v11 = v10;
      }
      v45 = v11;
      v44 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v70, 2, (uint64_t)key, (uint64_t)value);
        _os_log_debug_impl(&dword_1B5291000, v45, v44, "[%x]: ALSRampLuxThreshold key=%@ property=%@", v70, 0x1Cu);
      }
      v9 = CFGetTypeID(value);
      if (v9 == CFNumberGetTypeID())
      {
        v43 = 0;
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &v43))
          *((_DWORD *)this + 1002) = v43;
      }
    }
    else if (CFEqual(key, CFSTR("ALSDimPolicy")))
    {
      v8 = CFGetTypeID(value);
      if (v8 == CFNumberGetTypeID())
      {
        v42 = 0;
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &v42);
        *((_DWORD *)this + 858) = v42;
        AABC::SetALSDimPolicy((uint64_t)this, *((_DWORD *)this + 858));
        cf = 0;
        cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (char *)this + 3432);
        if (cf)
        {
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), CFSTR("ALSDimPolicy"), cf);
          CFRelease(cf);
        }
      }
    }
    else if (CFEqual(key, CFSTR("ALSLockScreenAutoBrightness")))
    {
      *((_DWORD *)this + 860) = GetCFBooleanValue((const __CFNumber *)value);
      v40 = 0;
      if (_logHandle)
      {
        v7 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v6 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v6 = init_default_corebrightness_log();
        v7 = v6;
      }
      v40 = v7;
      v39 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_4_0_4_0((uint64_t)v69, 2, *((_DWORD *)this + 860));
        _os_log_debug_impl(&dword_1B5291000, v40, v39, "[%x]: _settings._internal._lockScreenAutoBrightness=%x", v69, 0xEu);
      }
    }
    else if (CFEqual(key, CFSTR("AutoBrightnessProxEnabled")))
    {
      *((_BYTE *)this + 3937) = GetCFBooleanValue((const __CFNumber *)value) != 0;
    }
    else if (CFEqual(key, CFSTR("AutoBrightnessProxDelay")))
    {
      v5 = CFGetTypeID(value);
      if (v5 == CFNumberGetTypeID())
      {
        v38 = 0;
        v38 = (int)*((float *)this + 985);
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &v38))
          *((float *)this + 985) = (float)v38;
      }
    }
    else if (CFEqual(key, CFSTR("AutoBrightnessLogMask")))
    {
      v4 = CFGetTypeID(value);
      if (v4 == CFNumberGetTypeID())
      {
        v37 = 0;
        v37 = *((_DWORD *)this + 81);
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &v37))
          *((_DWORD *)this + 81) = v37 | 1;
      }
    }
    else if (CFEqual(key, CFSTR("AutoBrightnessLuxFilter")))
    {
      v3 = CFGetTypeID(value);
      if (v3 == CFNumberGetTypeID())
      {
        v36 = 0;
        v36 = *((_DWORD *)this + 864);
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &v36))
        {
          if (v36 < 4)
            *((_DWORD *)this + 864) = v36;
        }
      }
    }
    else if (CFEqual(key, CFSTR("AutoBrightnessResetAllLuxFilters")))
    {
      if ((*((_BYTE *)this + 264) & 1) != 0)
        AABC::resetMovingAverage(this);
      if ((*((_BYTE *)this + 161) & 1) != 0)
        AABC::resetFilter((uint64_t)this, (uint64_t *)this + 27);
      AABC::resetMedianFilter((CFDictionaryRef *)this);
    }
  }
}

void AABC::ClearHistoryFunction(AABC *this, __IOHIDServiceClient *a2, AABC::ALS *a3, AABC *a4)
{
  std::vector<float>::resize((uint64_t *)a2 + 11, 0);
  if (*((_DWORD *)a3 + 162))
  {
    if (*((float *)a3 + 163) > 0.0 && *((_DWORD *)a3 + 167) == 3
      || *((float *)a3 + 164) > 0.0 && *((_DWORD *)a3 + 167) == 2
      || *((float *)a3 + 165) > 0.0 && *((_DWORD *)a3 + 167) == 1)
    {
      *((_DWORD *)a2 + 20) = (float)(*((float *)a3 + 861) / *((float *)a3 + 158));
    }
    else
    {
      *((_DWORD *)a2 + 20) = 0;
    }
  }
  else
  {
    *((_DWORD *)a2 + 20) = (float)(*((float *)a3 + 861) / *((float *)a3 + 158));
  }
  *((_DWORD *)a2 + 18) = 0;
  *((_DWORD *)a2 + 19) = 0;
  std::vector<float>::resize((uint64_t *)a2 + 11, *((unsigned int *)a2 + 20));
}

void std::vector<float>::resize(uint64_t *a1, unint64_t a2)
{
  unint64_t v3;

  v3 = std::vector<float>::size[abi:ne180100](a1);
  if (v3 >= a2)
  {
    if (v3 > a2)
      std::vector<float>::__destruct_at_end[abi:ne180100](a1, *a1 + 4 * a2);
  }
  else
  {
    std::vector<float>::__append(a1, a2 - v3);
  }
}

uint64_t AABC::SetALSDimPolicy(uint64_t a1, int a2)
{
  unint64_t v3;
  uint64_t inited;
  NSObject *v5;
  uint8_t v7[8];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(a1 + 3436) = a2;
  if (_logHandle)
  {
    v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v5 = inited;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v7, *(_DWORD *)(a1 + 3436));
    _os_log_impl(&dword_1B5291000, v5, OS_LOG_TYPE_INFO, "_settings._internal._dimPolicy=%x", v7, 8u);
  }
  v3 = *(unsigned int *)(a1 + 3436);
  if (v3 <= 7)
    __asm { BR              X8 }
  *(_DWORD *)(a1 + 3436) = 3;
  if (*(_DWORD *)(a1 + 3436) == 4 || *(_DWORD *)(a1 + 3436) == 5)
    *(_DWORD *)(a1 + 3992) = 1045220557;
  else
    *(_DWORD *)(a1 + 3992) = *(_DWORD *)(a1 + 3988);
  return PerceptualLuminanceThresholding::SetPthresholdDim(*(_QWORD *)(a1 + 4016), *(float *)(a1 + 3992));
}

uint64_t PerceptualLuminanceThresholding::SetPthresholdBrighten(uint64_t this, float a2)
{
  *(float *)(this + 28) = a2;
  return this;
}

float AABC::resetMovingAverage(AABC *this)
{
  float result;

  *((_QWORD *)this + 35) = 0;
  result = 0.0;
  *((_DWORD *)this + 72) = 0;
  return result;
}

void AABC::resetFilter(uint64_t a1, uint64_t *a2)
{
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v5;
  uint8_t v6[7];
  os_log_type_t v7;
  NSObject *v8;
  uint64_t *v9;
  uint64_t v10;

  v10 = a1;
  v9 = a2;
  v8 = 0;
  if (_logHandle)
  {
    v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v5 = inited;
  }
  v8 = v5;
  v7 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    log = v8;
    type = v7;
    __os_log_helper_16_0_0(v6);
    _os_log_impl(&dword_1B5291000, log, type, "RESETTING filter", v6, 2u);
  }
  std::vector<float>::clear[abi:ne180100](v9);
  *((_WORD *)v9 + 20) = 0;
}

void AABC::resetMedianFilter(CFDictionaryRef *this)
{
  _DWORD *v2;
  int i;
  const void **v4;
  CFIndex Count;

  Count = CFDictionaryGetCount(this[53]);
  v4 = (const void **)operator new[]();
  CFDictionaryGetKeysAndValues(this[53], 0, v4);
  for (i = 0; i < Count; ++i)
  {
    v2 = v4[i];
    v2[18] = 0;
    v2[19] = 0;
  }
  if (v4)
    MEMORY[0x1B5E4A3E8](v4, 0x20C8093837F09);
}

void AABC::UpdateSensorOverride(AABC *this, __IOHIDServiceClient *a2, AABC::ALS *a3, const void *a4)
{
  uint64_t inited;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  CFTypeID v8;
  CFTypeID v9;
  CFTypeID v10;
  CFTypeID v11;
  const void *v12;
  const void *Value;
  float valuePtr;
  int v15;
  const __CFNumber *v16;
  __IOHIDServiceClient *v17;
  AABC *v18;
  uint8_t v19[16];
  uint8_t v20[24];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v18 = this;
  v17 = a2;
  v16 = a3;
  v15 = 0;
  valuePtr = -1.0;
  v11 = CFGetTypeID(a3);
  if (v11 == CFNumberGetTypeID())
  {
    CFNumberGetValue(v16, kCFNumberFloatType, &valuePtr);
  }
  else
  {
    v10 = CFGetTypeID(v16);
    if (v10 == CFDictionaryGetTypeID())
    {
      Value = CFDictionaryGetValue(v16, CFSTR("AABSensorOverrideOrientation"));
      v12 = CFDictionaryGetValue(v16, CFSTR("AABSensorOverrideValue"));
      if (Value)
      {
        if (v12)
        {
          v9 = CFGetTypeID(Value);
          if (v9 == CFNumberGetTypeID())
          {
            v8 = CFGetTypeID(v12);
            if (v8 == CFNumberGetTypeID())
            {
              CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, &v15);
              CFNumberGetValue((CFNumberRef)v12, kCFNumberFloat32Type, &valuePtr);
            }
          }
        }
      }
    }
  }
  if (!v15 || *((_DWORD *)v17 + 1) == v15)
  {
    if (valuePtr < 0.0)
    {
      *((_BYTE *)v17 + 68) = 0;
      if (_logHandle)
      {
        v5 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v5 = inited;
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_4_0((uint64_t)v19, v15);
        _os_log_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEFAULT, "Disable sensor override for ALS with orientation %d", v19, 8u);
      }
    }
    else
    {
      *((float *)v17 + 16) = valuePtr;
      *((_BYTE *)v17 + 68) = 1;
      if (_logHandle)
      {
        v7 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v6 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v6 = init_default_corebrightness_log();
        v7 = v6;
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_2_4_0_8_0((uint64_t)v20, v15, COERCE__INT64(valuePtr));
        _os_log_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEFAULT, "ALS with orientation %d has been overridden to %f Lux.", v20, 0x12u);
      }
    }
  }
}

void AABC::CancelRamp(AABC *this)
{
  if (*((_DWORD *)this + 128) && *((_DWORD *)this + 127) && (*((_BYTE *)this + 628) & 1) != 0)
    DisplayCancelVirtualFade(*((_QWORD *)this + 51));
}

void AABC::handleAODStateUpdateProperty(uint64_t a1, int a2, float a3)
{
  double v3;
  float v4;
  float BrightnessMaxPhysical;
  uint64_t v6;
  float v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t inited;
  NSObject *v11;
  float IntegerValue;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  void *v18;
  char v19;
  int v20;
  id v21;
  objc_object *v22;
  CFTypeRef v23;
  float v24;
  float v25;
  float v26;
  os_log_type_t v27;
  os_log_t v28;
  os_log_type_t v29;
  os_log_t v30;
  float v31;
  float v32;
  float BrightnessMinPhysical;
  float v34;
  int v35;
  uint64_t v36;
  uint8_t v37[16];
  uint8_t v38[16];
  uint8_t v39[16];
  uint8_t v40[24];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v36 = a1;
  v35 = a2;
  v34 = a3;
  BrightnessMinPhysical = 0.0;
  BrightnessMinPhysical = _DisplayGetBrightnessMinPhysical(*(_QWORD *)(a1 + 408));
  AABC::NotifyCPMSWhenDisplayChangeState((AABC *)a1, v35 == 0);
  if (v35 == 1)
  {
    *(_DWORD *)(a1 + 2868) = 2;
    if (*(_DWORD *)(a1 + 676))
      AABC::CancelFastRampMode((CFAbsoluteTime *)a1);
    if (*(_QWORD *)(a1 + 4056) && (objc_msgSend(*(id *)(a1 + 4056), "isActive") & 1) != 0)
    {
      objc_msgSend(*(id *)(a1 + 4056), "action:", 0);
      DisplaySetProperty(*(_QWORD *)(a1 + 408), (uint64_t)CFSTR("CBSoftWakeActive"), (uint64_t)&unk_1E6916D30);
    }
    AABC::CancelFirstSampleTimeout((dispatch_object_t *)a1);
    *(float *)(a1 + 620) = DisplayGetLogicalBrightness(*(_QWORD *)(a1 + 408));
    v32 = 0.0;
    v32 = AABC::LuminanceToIlluminance(a1, (float *)(a1 + 1048), *(float *)(a1 + 620));
    v31 = AABC::IlluminanceToLuminance((AABC *)a1, v32, (CustomCurve *)(a1 + 2540));
    if (v31 >= *(float *)(a1 + 620))
    {
      if (*(float *)(a1 + 624) < v32)
      {
        v31 = AABC::IlluminanceToLuminance((AABC *)a1, *(float *)(a1 + 624), (CustomCurve *)(a1 + 2540));
        v30 = 0;
        if (_logHandle)
        {
          v16 = _logHandle;
        }
        else
        {
          v15 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          v16 = v15;
        }
        v30 = v16;
        v29 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v40, COERCE__INT64(*(float *)(a1 + 624)), COERCE__INT64(v31));
          _os_log_impl(&dword_1B5291000, v30, v29, "Target AOT Brightness >= Current brightness ; Using _Eprevious(: %f) instead: %f",
            v40,
            0x16u);
        }
      }
      if (v31 > *(float *)(a1 + 620))
      {
        v31 = *(float *)(a1 + 620);
        v28 = 0;
        if (_logHandle)
        {
          v14 = _logHandle;
        }
        else
        {
          v13 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          v14 = v13;
        }
        v28 = v14;
        v27 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v39, COERCE__INT64(v31));
          _os_log_impl(&dword_1B5291000, v28, v27, "Target AOT Brightness >= Current brightness ; Capping to Current Brightness: %f",
            v39,
            0xCu);
        }
      }
    }
    *(_DWORD *)(a1 + 2872) = *(_DWORD *)(a1 + 620);
    if (*(_DWORD *)(a1 + 520))
    {
      if ((*(_BYTE *)(a1 + 452) & 1) != 0)
        v31 = 200.0;
      DisplaySetLogicalBrightnessWithFade(*(_QWORD *)(a1 + 408), 12296, (uint64_t)AABC::_RampDoneCallback, a1, v31, v34);
    }
    else
    {
      AABC::SetBrightness((AABC *)a1, v31, v34, 10, (void (*)(void *))AABC::_RampDoneCallback, a1);
    }
  }
  else if (!v35)
  {
    v26 = 0.0;
    v25 = 0.0;
    v24 = 0.0;
    v23 = 0;
    v21 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", 0);
    v22 = (objc_object *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D80]), "initWithObjectsAndKeys:", v21, CFSTR("AOTState"), 0);
    AABC::setAlwaysOnProperty((id *)a1, CFSTR("AOTState"), v22);
    IOHIDServiceClientSetProperty(*(IOHIDServiceClientRef *)(a1 + 328), CFSTR("AOTState"), v22);

    v20 = 0;
    v20 = *(_DWORD *)(a1 + 2868);
    *(_DWORD *)(a1 + 2868) = 3;
    if (*(_DWORD *)(a1 + 520))
    {
      v25 = *(float *)(a1 + 2872);
      DisplaySetLogicalBrightnessWithFade(*(_QWORD *)(a1 + 408), 12296, (uint64_t)AABC::_RampDoneCallback, a1, v25, v34);
    }
    else
    {
      v19 = 1;
      objc_msgSend(*(id *)(a1 + 4168), "sendCommand:inputBuffer:inputBufferSize:", 230, &v19, 1);
      v23 = (CFTypeRef)IOHIDServiceClientCopyEvent();
      if (v23)
      {
        if ((*(_BYTE *)(a1 + 3936) & 1) != 0)
        {
          IOHIDEventGetDoubleValue();
          *(float *)&v3 = v3;
          IntegerValue = *(float *)&v3;
        }
        else
        {
          IntegerValue = (float)IOHIDEventGetIntegerValue();
        }
        v24 = IntegerValue;
        CFRelease(v23);
      }
      *(float *)(a1 + 624) = v24;
      v4 = AABC::IlluminanceToLuminance(a1, (float *)(a1 + 1048), v24);
      v25 = fmaxf(BrightnessMinPhysical, v4);
      BrightnessMaxPhysical = _DisplayGetBrightnessMaxPhysical(*(_QWORD *)(a1 + 408));
      v25 = fminf(BrightnessMaxPhysical, v25);
      if (v20 == 1)
      {
        v18 = (void *)objc_msgSend(*(id *)(a1 + 4168), "copyProperty:", CFSTR("CurrentBrightness"));
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v26 = (float)(int)objc_msgSend(v18, "intValue") / 65536.0;
          if (_logHandle)
          {
            v11 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              inited = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              inited = init_default_corebrightness_log();
            v11 = inited;
          }
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_1_8_0((uint64_t)v38, COERCE__INT64(v26));
            _os_log_debug_impl(&dword_1B5291000, v11, OS_LOG_TYPE_DEBUG, "Exiting AOT, CurrentAoTNits: %f", v38, 0xCu);
          }
        }
        else
        {
          if (_logHandle)
          {
            v9 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v8 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v8 = init_default_corebrightness_log();
            v9 = v8;
          }
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            v6 = objc_msgSend((id)objc_msgSend((id)objc_opt_class(), "description"), "UTF8String");
            __os_log_helper_16_2_1_8_32((uint64_t)v37, v6);
            _os_log_error_impl(&dword_1B5291000, v9, OS_LOG_TYPE_ERROR, "Returned property is not an NSNumber!, class: %s", v37, 0xCu);
          }
        }

        v7 = v26;
        *(float *)(a1 + 616) = v26;
        *(float *)(a1 + 620) = v7;
        AABC::SetBrightness((AABC *)a1, v26, 0.0, 12296, 0, 0);
      }
      *(float *)(a1 + 616) = v25;
      AABC::SetBrightness((AABC *)a1, v25, v34, 10, (void (*)(void *))AABC::_RampDoneCallback, a1);
    }
  }
  DisplaySetState(*(_QWORD *)(a1 + 408), v35 == 0);
}

uint64_t ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  void *v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t (*v12)(uint64_t, void *, uint64_t, uint64_t);
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t (*v21)(uint64_t, void *, uint64_t, uint64_t);
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 v29;
  id v30;
  id v31;
  id v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = a1;
  v36 = a2;
  v35 = a3;
  v34 = a4;
  v33 = a1;
  v6 = *(_QWORD *)(a1 + 48);
  v32 = a3;
  v31 = (id)objc_msgSend(a3, "valueForKey:", CFSTR("lux"));
  v30 = (id)objc_msgSend(v32, "valueForKey:", CFSTR("nits"));
  v29 = objc_msgSend(v31, "count");
  *(_DWORD *)(v6 + 2048 + 164 * *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) + 160) = v29;
  v28 = objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", v29);
  v27 = objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", v29);
  v5 = MEMORY[0x1E0C809B0];
  v18 = MEMORY[0x1E0C809B0];
  v19 = -1073741824;
  v20 = 0;
  v21 = ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke_2;
  v22 = &unk_1E68EBAB8;
  v25 = v6;
  v26 = v29;
  v24 = *(_QWORD *)(a1 + 40);
  v23 = v28;
  objc_msgSend(v31, "enumerateObjectsUsingBlock:", &v18);
  v9 = v5;
  v10 = -1073741824;
  v11 = 0;
  v12 = ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke_3;
  v13 = &unk_1E68EBAB8;
  v16 = v6;
  v17 = v29;
  v15 = *(_QWORD *)(a1 + 40);
  v14 = v27;
  objc_msgSend(v30, "enumerateObjectsUsingBlock:", &v9);
  v8 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionaryWithCapacity:", 2);
  objc_msgSend(v8, "setObject:forKey:", v28, CFSTR("Lux"));
  objc_msgSend(v8, "setObject:forKey:", v27, CFSTR("Nits"));
  objc_msgSend(*(id *)(a1 + 32), "setObject:forKey:", v8, v36);
  result = a1;
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke_2(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  float v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  id v14;
  float v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;

  v12 = a1;
  v23 = *MEMORY[0x1E0C80C00];
  v22 = a1;
  v21 = a2;
  v20 = a3;
  v19 = a4;
  v18 = a1;
  v11 = *(_QWORD *)(a1 + 48);
  v4 = *(unsigned __int8 *)(a1 + 56);
  v17 = &v10;
  v13 = (char *)&v10 - ((4 * v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = v4;
  v15 = 0.0;
  objc_msgSend(a2, "floatValue");
  v5 = v12;
  v6 = v13;
  v15 = v7;
  *(float *)(v11 + 2048 + 164 * *(int *)(*(_QWORD *)(*(_QWORD *)(v12 + 40) + 8) + 24) + 4 * v20) = v7;
  *(_DWORD *)&v6[4 * v20] = (int)(float)(v15 * 65536.0);
  v14 = *(id *)(v5 + 32);
  v8 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", *(int *)&v6[4 * v20]);
  return objc_msgSend(v14, "addObject:", v8);
}

uint64_t ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke_3(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  float v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  id v14;
  float v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;

  v12 = a1;
  v23 = *MEMORY[0x1E0C80C00];
  v22 = a1;
  v21 = a2;
  v20 = a3;
  v19 = a4;
  v18 = a1;
  v11 = *(_QWORD *)(a1 + 48);
  v4 = *(unsigned __int8 *)(a1 + 56);
  v17 = &v10;
  v13 = (char *)&v10 - ((4 * v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = v4;
  v15 = 0.0;
  objc_msgSend(a2, "floatValue");
  v5 = v12;
  v6 = v13;
  v15 = v7;
  *(float *)(v11 + 2048 + 164 * *(int *)(*(_QWORD *)(*(_QWORD *)(v12 + 40) + 8) + 24) + 80 + 4 * v20) = v7;
  *(_DWORD *)&v6[4 * v20] = (int)(float)(v15 * 65536.0);
  v14 = *(id *)(v5 + 32);
  v8 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", *(int *)&v6[4 * v20]);
  return objc_msgSend(v14, "addObject:", v8);
}

uint64_t __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 5;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 4;
  *(_DWORD *)(result + 44) = a6;
  return result;
}

void *AABC::AlignCurveTypeWithStrategy(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  void *result;
  uint64_t inited;
  NSObject *v5;
  _BYTE __dst[104];
  os_log_type_t v8;
  os_log_t v9;
  char v10;
  _DWORD *v11;
  _DWORD *v12;
  uint64_t v13;
  uint8_t v14[24];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = a1;
  v12 = a2;
  v11 = a3;
  v10 = 0;
  result = (void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 104))(*(_QWORD *)(a1 + 64));
  if ((_DWORD)result == 3 && v11[24] == 3
    || (result = (void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 104))(*(_QWORD *)(a1 + 64)),
        (_DWORD)result == 2)
    && v11[24] == 2
    || (result = (void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 104))(*(_QWORD *)(a1 + 64)),
        (_DWORD)result == 3)
    && !v12[24])
  {
    v10 = 1;
  }
  if ((v10 & 1) != 0)
  {
    v9 = 0;
    if (_logHandle)
    {
      v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v5 = inited;
    }
    v9 = v5;
    v8 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_2_4_0_4_0((uint64_t)v14, v12[24], v11[24]);
      _os_log_impl(&dword_1B5291000, v9, v8, "Switch curve with alternative curve in order to align curves with update curve strategies. Curve = %d, Alternative curve = %d.", v14, 0xEu);
    }
    memcpy(__dst, v11, sizeof(__dst));
    memcpy(v11, v12, 0x68uLL);
    return memcpy(v12, __dst, 0x68uLL);
  }
  return result;
}

uint64_t AABC::getCurveUpdatesFromArray@<X0>(AABC *this@<X0>, objc_object *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  int v6;
  int v7;
  void (*v8)(uint64_t, void *, uint64_t, _BYTE *);
  void *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  int v13;
  int v14;
  _QWORD *(*v15)(uint64_t, uint64_t);
  uint64_t (*v16)(uint64_t);
  uint64_t v17;
  _QWORD v18[3];
  id v19;
  AABC *v20;
  _QWORD *v21;

  v21 = a3;
  v20 = this;
  v19 = a2;
  v11 = 0;
  v12 = &v11;
  v13 = 301989888;
  v14 = 72;
  v15 = __Block_byref_object_copy__17;
  v16 = __Block_byref_object_dispose__17;
  v17 = 0;
  std::list<AAB::CurveUpdate>::list[abi:ne180100](v18);
  if (v19)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v5 = MEMORY[0x1E0C809B0];
      v6 = -1073741824;
      v7 = 0;
      v8 = ___ZN4AABC24getCurveUpdatesFromArrayEP11objc_object_block_invoke;
      v9 = &unk_1E68EAFC8;
      v10 = &v11;
      objc_msgSend(v19, "enumerateObjectsUsingBlock:", &v5);
    }
  }
  std::list<AAB::CurveUpdate>::list(a3, (uint64_t)(v12 + 6));
  _Block_object_dispose(&v11, 8);
  return std::list<AAB::CurveUpdate>::~list((uint64_t)v18);
}

void AABC::revertToGoodCurve(uint64_t a1, unsigned int a2)
{
  uint64_t updated;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t inited;
  NSObject *v8;
  NSObject *v9;
  os_log_type_t v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *log;
  os_log_type_t v14;
  uint64_t v15;
  NSObject *v16;
  uint8_t v18[7];
  os_log_type_t v19;
  os_log_t v20;
  uint8_t v21[7];
  os_log_type_t type;
  os_log_t oslog;
  unsigned int v24;
  uint64_t v25;
  uint8_t v26[16];
  uint8_t v27[112];
  uint8_t v28[104];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v25 = a1;
  v24 = a2;
  memcpy((void *)(a1 + 1048), (const void *)(a1 + 2896), 0x68uLL);
  if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 64) + 64))(*(_QWORD *)(a1 + 64), a1 + 2896) & 1) == 0)
  {
    oslog = 0;
    if (_logHandle)
    {
      v16 = _logHandle;
    }
    else
    {
      v15 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v16 = v15;
    }
    oslog = v16;
    type = OS_LOG_TYPE_INFO;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      log = oslog;
      v14 = type;
      __os_log_helper_16_0_0(v21);
      _os_log_impl(&dword_1B5291000, log, v14, "Baseline curve strategy does not have the capped curve available -> use default.", v21, 2u);
    }
  }
  memcpy((void *)(a1 + 1048), (const void *)(a1 + 2896), 0x68uLL);
  if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 64) + 72))(*(_QWORD *)(a1 + 64), a1 + 3104) & 1) == 0)
  {
    v20 = 0;
    if (_logHandle)
    {
      v12 = _logHandle;
    }
    else
    {
      v11 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v12 = v11;
    }
    v20 = v12;
    v19 = OS_LOG_TYPE_INFO;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v9 = v20;
      v10 = v19;
      __os_log_helper_16_0_0(v18);
      _os_log_impl(&dword_1B5291000, v9, v10, "Alternative curve strategy does not have the alternative capped curve available -> use default.", v18, 2u);
    }
  }
  memcpy((void *)(a1 + 3000), (const void *)(a1 + 3104), 0x68uLL);
  if (_logHandle)
  {
    v8 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v8 = inited;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_10_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_4_0((uint64_t)v28, COERCE__INT64(*(float *)(a1 + 3104)), COERCE__INT64(*(float *)(a1 + 3112)), COERCE__INT64(*(float *)(a1 + 3120)), COERCE__INT64(*(float *)(a1 + 3124)), COERCE__INT64(*(float *)(a1 + 3108)), COERCE__INT64(*(float *)(a1 + 3116)), COERCE__INT64(*(float *)(a1 + 3128)), COERCE__INT64(*(float *)(a1 + 3132)), COERCE__INT64(*(float *)(a1 + 3188)), *(_DWORD *)(a1 + 3200));
    _os_log_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEFAULT, "revert alternative curve to alternative good curve: E0a %f, E0b %f, E1 %f, E2 %f, L0a %f, L0b %f, L1 %f, L2 %f, thirdSlope %f, type %d", v28, 0x62u);
  }
  if (_logHandle)
  {
    v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v5 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v5 = init_default_corebrightness_log();
    v6 = v5;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_10_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_4_0((uint64_t)v27, COERCE__INT64(*(float *)(a1 + 2896)), COERCE__INT64(*(float *)(a1 + 2904)), COERCE__INT64(*(float *)(a1 + 2912)), COERCE__INT64(*(float *)(a1 + 2916)), COERCE__INT64(*(float *)(a1 + 2900)), COERCE__INT64(*(float *)(a1 + 2908)), COERCE__INT64(*(float *)(a1 + 2920)), COERCE__INT64(*(float *)(a1 + 2924)), COERCE__INT64(*(float *)(a1 + 2980)), *(_DWORD *)(a1 + 2992));
    _os_log_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEFAULT, "revert curve to good curve: E0a %f, E0b %f, E1 %f, E2 %f, L0a %f, L0b %f, L1 %f, L2 %f, thirdSlope %f, type %d", v27, 0x62u);
  }
  if (_logHandle)
  {
    v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v3 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v3 = init_default_corebrightness_log();
    v4 = v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    updated = AABCurveUpdateReasonToString(v24);
    __os_log_helper_16_2_1_8_66((uint64_t)v26, updated);
    _os_log_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEFAULT, "[Revert curve] %{public}@", v26, 0xCu);
  }
  AABC::setAABCurveUpdateReason(a1, v24);
}

void AABC::readOutlierRemovalPreferences(AABC *this)
{
  CFTypeID v1;
  CFStringRef *v2;
  CFTypeRef cf;

  if ((*((_BYTE *)this + 3368) & 1) != 0)
  {
    v2 = (CFStringRef *)MEMORY[0x1E0C9B248];
    CFPreferencesAppSynchronize((CFStringRef)*MEMORY[0x1E0C9B248]);
    cf = CFPreferencesCopyAppValue(CFSTR("CBCurveSticks"), *v2);
    if (cf)
    {
      v1 = CFGetTypeID(cf);
      if (v1 == CFBooleanGetTypeID())
      {
        if (CFBooleanGetValue((CFBooleanRef)cf))
          *((_DWORD *)this + 832) = *((_DWORD *)this + 843);
      }
      CFRelease(cf);
    }
  }
}

uint64_t ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke_520(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    if (*(_QWORD *)(a3 + 24))
      return objc_msgSend(*(id *)(a3 + 24), "setProperty:forKey:", *(_QWORD *)(result + 32), *(_QWORD *)(result + 40));
  }
  return result;
}

void AABC::UpdateAutoBrightnessEnabledStatus(AABC *this, const __CFNumber *a2)
{
  uint64_t inited;
  NSObject *v3;
  int v5;
  BOOL v6;
  os_log_type_t v7;
  os_log_t v8;
  int CFBooleanValue;
  const __CFNumber *v10;
  AABC *v11;
  uint8_t v12[8];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v11 = this;
  v10 = a2;
  CFBooleanValue = GetCFBooleanValue(a2);
  v8 = 0;
  if (_logHandle)
  {
    v3 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v3 = inited;
  }
  v8 = v3;
  v7 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v12, CFBooleanValue);
    _os_log_impl(&dword_1B5291000, v8, v7, "autoBrightnessEnabled=%x", v12, 8u);
  }
  *((_DWORD *)this + 130) = CFBooleanValue == 0;
  v6 = CFBooleanValue != 0;
  v5 = 0;
  DisplayUpdateAAPState(*((_QWORD *)this + 51), (uint64_t)&v5, 1, 1);
  if (CFBooleanValue)
    *((_DWORD *)this + 128) = 0;
  AABC::SetAutoBrightnessState(this, CFBooleanValue);
  if (*((_DWORD *)this + 130))
    AABC::_UpdateNitsRestrictions(this, *((float *)this + 136), -1.0, 1);
  if (*((_QWORD *)this + 44))
  {
    if (CFBooleanValue)
      (*((void (**)(_QWORD, const __CFString *, _QWORD))this + 44))(*((_QWORD *)this + 45), CFSTR("DisplayBrightnessAuto"), *MEMORY[0x1E0C9AE50]);
    else
      (*((void (**)(_QWORD, const __CFString *, _QWORD))this + 44))(*((_QWORD *)this + 45), CFSTR("DisplayBrightnessAuto"), *MEMORY[0x1E0C9AE40]);
  }
}

void AABC::SetDisplayOrientation(uint64_t a1, int a2)
{
  uint64_t inited;
  NSObject *v3;
  uint8_t v5[24];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(a1 + 704) = a2;
  if (_logHandle)
  {
    v3 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v3 = inited;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_3_4_0_8_32_4_0((uint64_t)v5, 4, (uint64_t)(&kOrientationString)[a2], a2);
    _os_log_debug_impl(&dword_1B5291000, v3, OS_LOG_TYPE_DEBUG, "[%x]: orientation=%s (%x)", v5, 0x18u);
  }
}

void AABC::SetUserBrightness(AABC *this, float a2, int a3)
{
  float v3;
  const char *v4;
  float v5;
  double v6;
  NSObject *v7;
  os_log_type_t v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  os_log_type_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  const char *v17;
  uint64_t v18;
  NSObject *v19;
  float v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  NSObject *v32;
  CFAllocatorRef *v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  NSObject *v41;
  uint64_t inited;
  NSObject *v43;
  uint8_t v45[15];
  os_log_type_t v46;
  os_log_t v47;
  double v48;
  uint8_t v49[7];
  os_log_type_t v50;
  os_log_t v51;
  char v52;
  os_log_type_t v53;
  os_log_t v54;
  os_log_type_t v55;
  os_log_t v56;
  uint64_t v57;
  float v58;
  uint64_t v59;
  float v60;
  os_log_type_t v61;
  os_log_t v62;
  os_log_type_t v63;
  os_log_t v64;
  os_log_type_t v65;
  os_log_t v66;
  os_log_type_t v67;
  os_log_t v68;
  os_log_type_t v69;
  os_log_t v70;
  os_log_type_t v71;
  os_log_t v72;
  uint64_t v73;
  float v74;
  uint64_t v75;
  float v76;
  CFTypeRef cf;
  void *value;
  os_log_type_t v79;
  os_log_t v80;
  float v81;
  float v82;
  float valuePtr;
  float v84;
  unsigned int v85;
  unsigned int j;
  unsigned int v87;
  double Current;
  os_log_type_t v89;
  os_log_t v90;
  os_log_type_t v91;
  os_log_t v92;
  int i;
  char *__str;
  float __dst[26];
  float v96;
  os_log_type_t v97;
  os_log_t v98;
  os_log_type_t type;
  os_log_t oslog;
  int v101;
  float v102;
  AABC *v103;
  uint8_t v104[48];
  uint8_t v105[64];
  uint8_t v106[64];
  uint8_t v107[64];
  uint8_t v108[80];
  uint8_t v109[80];
  uint8_t v110[80];
  uint8_t v111[80];
  uint8_t v112[112];
  uint8_t v113[16];
  uint8_t v114[48];
  _BYTE v115[256];
  void *__b[20];
  uint8_t v117[32];
  uint8_t v118[8];
  uint64_t v119;

  v119 = *MEMORY[0x1E0C80C00];
  v103 = this;
  v102 = a2;
  v101 = a3;
  oslog = 0;
  if (_logHandle)
  {
    v43 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v43 = inited;
  }
  oslog = v43;
  type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v118, 4);
    _os_log_debug_impl(&dword_1B5291000, oslog, type, "[%x]: ", v118, 8u);
  }
  if ((*((_BYTE *)this + 3320) & 1) != 0)
    AABC::CancelFastRampMode((CFAbsoluteTime *)this);
  *((float *)this + 133) = v102;
  v98 = 0;
  if (_logHandle)
  {
    v41 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v40 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v40 = init_default_corebrightness_log();
    v41 = v40;
  }
  v98 = v41;
  v97 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_4_0_8_0((uint64_t)v117, 2, COERCE__INT64(*((float *)this + 133)));
    _os_log_debug_impl(&dword_1B5291000, v98, v97, "[%x]: _S=%f", v117, 0x12u);
  }
  if (!*((_DWORD *)this + 130))
  {
    v96 = 0.0;
    v96 = *((float *)this + 155);
    if (*((_QWORD *)this + 51))
      v96 = DisplaySliderToLogicalBrightness(*((_QWORD *)this + 51), *((float *)this + 133));
    v3 = v96;
    *((float *)this + 155) = v96;
    *((float *)this + 154) = v3;
    if (*((float *)this + 123) == 1.0)
    {
      memcpy(__dst, (char *)this + 1048, sizeof(__dst));
      if (v101)
      {
        memset(__b, 0, sizeof(__b));
        backtrace(__b, 20);
        memset(v115, 0, sizeof(v115));
        __str = v115;
        for (i = 0; i < 20 && __b[i]; ++i)
          snprintf(__str, 0x100uLL, "%p ", __b[i]);
        v92 = 0;
        if (_logHandle)
        {
          v39 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v38 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v38 = init_default_corebrightness_log();
          v39 = v38;
        }
        v92 = v39;
        v91 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          if (v101)
            v4 = "commit";
          else
            v4 = ".";
          __os_log_helper_16_2_4_8_0_8_0_8_0_8_32((uint64_t)v114, COERCE__INT64(*((float *)this + 133)), COERCE__INT64(*((float *)this + 136)), COERCE__INT64(v96), (uint64_t)v4);
          _os_log_impl(&dword_1B5291000, v92, v91, "_S: %0.4f Esensor: %0.4f Luser: %0.4f %s", v114, 0x2Au);
        }
        v90 = 0;
        if (_logHandle)
        {
          v37 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v36 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v36 = init_default_corebrightness_log();
          v37 = v36;
        }
        v90 = v37;
        v89 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_2_1_8_32((uint64_t)v113, (uint64_t)v115);
          _os_log_debug_impl(&dword_1B5291000, v90, v89, "backtrace=%s", v113, 0xCu);
        }
        if (*((_DWORD *)this + 92) == 4)
        {
          AABC::UpdateState((uint64_t)this, 3);
          if ((*((_BYTE *)this + 3368) & 1) != 0
            && *((_DWORD *)this + 832)
            && *((_DWORD *)this + 832) < *((_DWORD *)this + 843)
            && *((_DWORD *)this + 840))
          {
            Current = CFAbsoluteTimeGetCurrent();
            v87 = 0;
            for (j = 0; j < *((_DWORD *)this + 832); ++j)
            {
              if (Current > *((double *)this + (int)j + 417) + *((double *)this + 424))
                ++v87;
            }
            if (v87)
            {
              v85 = 3 - v87;
              memmove((char *)this + 3336, (char *)this + 8 * v87 + 3336, 8 * (3 - v87));
              bzero((char *)this + 64 * (unint64_t)(3 - v87) + 3336, 8 * v87);
              *((_DWORD *)this + 832) -= v87;
              if (!*((_DWORD *)this + 832))
              {
                AABC::revertToGoodCurve((uint64_t)this, 4u);
                *((_DWORD *)this + 840) = 0;
              }
            }
          }
          *((_DWORD *)this + 988) = 0;
          *((_DWORD *)this + 989) = 0;
          *((_DWORD *)this + 151) = 0;
          *((_DWORD *)this + 991) = *((_DWORD *)this + 992);
          *((_DWORD *)this + 141) = 0;
          AABC::_UpdateEsensorTrusted(this, *((float *)this + 134));
          *((_DWORD *)this + 152) = *((_DWORD *)this + 136);
          if ((*((_BYTE *)this + 4084) & 1) != 0)
            *((_DWORD *)this + 1022) = *((_DWORD *)this + 136);
          if ((*((_BYTE *)this + 3401) & 1) != 0)
          {
            if (*((_QWORD *)this + 48))
            {
              v84 = 0.0;
              v84 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139));
              valuePtr = v96 - v84;
              v82 = 0.0;
              v82 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 750, *((float *)this + 136), *((float *)this + 139));
              v81 = v96 - v82;
              v80 = 0;
              if (_logHandle)
              {
                v35 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                  v34 = _COREBRIGHTNESS_LOG_DEFAULT;
                else
                  v34 = init_default_corebrightness_log();
                v35 = v34;
              }
              v80 = v35;
              v79 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
              {
                __os_log_helper_16_0_10_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v112, COERCE__INT64(*((float *)this + 136)), COERCE__INT64(*((float *)this + 139)), COERCE__INT64(v84), COERCE__INT64(v96), COERCE__INT64(valuePtr), COERCE__INT64(*((float *)this + 136)), COERCE__INT64(*((float *)this + 139)), COERCE__INT64(v82), COERCE__INT64(v96), COERCE__INT64(v81));
                _os_log_impl(&dword_1B5291000, v80, v79, "Nits update: %f (capped %f) Lux => %f Nits -> %f Nits ( %f)\nAlternative Nits update: %f (capped %f) Lux => %f Nits -> %f Nits ( %f)", v112, 0x66u);
              }
              value = 0;
              v33 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
              value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &valuePtr);
              cf = 0;
              cf = CFNumberCreate(*v33, kCFNumberFloatType, &v81);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), CFSTR("AABCurveUpdateNitsDelta"), value);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), CFSTR("AABCurveUpdateNitsDeltaAlternative"), cf);
              CFRelease(value);
              CFRelease(cf);
            }
            LODWORD(v75) = *((_DWORD *)this + 136);
            HIDWORD(v75) = *((_DWORD *)this + 139);
            v76 = v96;
            v73 = v75;
            v74 = v96;
            AAB::UpdateCurve_Block3_WithCappedCurve_AlternativeCurve((uint64_t)this, (uint64_t)__dst, (uint64_t)this + 1184, (uint64_t)this + 2896, (uint64_t)this + 3000, (uint64_t)this + 3104, *(float *)&v75, *((float *)&v75 + 1), v96);
            v72 = 0;
            if (_logHandle)
            {
              v32 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
                v31 = _COREBRIGHTNESS_LOG_DEFAULT;
              else
                v31 = init_default_corebrightness_log();
              v32 = v31;
            }
            v72 = v32;
            v71 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_8_4_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v111, *((_DWORD *)this + 774), COERCE__INT64(*((float *)this + 750)), COERCE__INT64(*((float *)this + 751)), COERCE__INT64(*((float *)this + 752)), COERCE__INT64(*((float *)this + 753)), COERCE__INT64(*((float *)this + 755)), COERCE__INT64(*((float *)this + 757)), COERCE__INT64(*((float *)this + 771)));
              _os_log_impl(&dword_1B5291000, v72, v71, "ALTERNATIVE CURVE [type = %d] - (%f, %f) - (%f, %f) - (%f, %f) - (%f)\n", v111, 0x4Eu);
            }
            v70 = 0;
            if (_logHandle)
            {
              v30 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
                v29 = _COREBRIGHTNESS_LOG_DEFAULT;
              else
                v29 = init_default_corebrightness_log();
              v30 = v29;
            }
            v70 = v30;
            v69 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_8_4_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v110, *((_DWORD *)this + 800), COERCE__INT64(*((float *)this + 776)), COERCE__INT64(*((float *)this + 777)), COERCE__INT64(*((float *)this + 778)), COERCE__INT64(*((float *)this + 779)), COERCE__INT64(*((float *)this + 781)), COERCE__INT64(*((float *)this + 783)), COERCE__INT64(*((float *)this + 797)));
              _os_log_impl(&dword_1B5291000, v70, v69, "ALTERNATIVE GOOD CURVE [type = %d] - (%f, %f) - (%f, %f) - (%f, %f) - (%f)\n", v110, 0x4Eu);
            }
            v68 = 0;
            if (_logHandle)
            {
              v28 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
                v27 = _COREBRIGHTNESS_LOG_DEFAULT;
              else
                v27 = init_default_corebrightness_log();
              v28 = v27;
            }
            v68 = v28;
            v67 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_8_4_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v109, SLODWORD(__dst[24]), COERCE__INT64(__dst[0]), COERCE__INT64(__dst[1]), COERCE__INT64(__dst[2]), COERCE__INT64(__dst[3]), COERCE__INT64(__dst[5]), COERCE__INT64(__dst[7]), COERCE__INT64(__dst[21]));
              _os_log_impl(&dword_1B5291000, v68, v67, "CURVE [type = %d] - (%f, %f) - (%f, %f) - (%f, %f) - (%f)\n", v109, 0x4Eu);
            }
            v66 = 0;
            if (_logHandle)
            {
              v26 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
                v25 = _COREBRIGHTNESS_LOG_DEFAULT;
              else
                v25 = init_default_corebrightness_log();
              v26 = v25;
            }
            v66 = v26;
            v65 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_8_4_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v108, *((_DWORD *)this + 748), COERCE__INT64(*((float *)this + 724)), COERCE__INT64(*((float *)this + 725)), COERCE__INT64(*((float *)this + 726)), COERCE__INT64(*((float *)this + 727)), COERCE__INT64(*((float *)this + 729)), COERCE__INT64(*((float *)this + 731)), COERCE__INT64(*((float *)this + 745)));
              _os_log_impl(&dword_1B5291000, v66, v65, "GOOD CURVE [type = %d] - (%f, %f) - (%f, %f) - (%f, %f) - (%f)\n", v108, 0x4Eu);
            }
            v64 = 0;
            if (_logHandle)
            {
              v24 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
                v23 = _COREBRIGHTNESS_LOG_DEFAULT;
              else
                v23 = init_default_corebrightness_log();
              v24 = v23;
            }
            v64 = v24;
            v63 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v107, COERCE__INT64(*((float *)this + 270)), COERCE__INT64(*((float *)this + 273)), COERCE__INT64(*((float *)this + 271)), COERCE__INT64(*((float *)this + 274)), COERCE__INT64(*((float *)this + 272)), COERCE__INT64(*((float *)this + 275)));
              _os_log_impl(&dword_1B5291000, v64, v63, "CURVE Prefs: (%f, %f), (%f, %f), (%f, %f)\n", v107, 0x3Eu);
            }
            v62 = 0;
            if (_logHandle)
            {
              v22 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
                v21 = _COREBRIGHTNESS_LOG_DEFAULT;
              else
                v21 = init_default_corebrightness_log();
              v22 = v21;
            }
            v62 = v22;
            v61 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v106, COERCE__INT64(*((float *)this + 732)), COERCE__INT64(*((float *)this + 735)), COERCE__INT64(*((float *)this + 733)), COERCE__INT64(*((float *)this + 736)), COERCE__INT64(*((float *)this + 734)), COERCE__INT64(*((float *)this + 737)));
              _os_log_impl(&dword_1B5291000, v62, v61, "GOOD CURVE Prefs: (%f, %f), (%f, %f), (%f, %f)\n", v106, 0x3Eu);
            }
          }
          else
          {
            LODWORD(v59) = *((_DWORD *)this + 136);
            HIDWORD(v59) = *((_DWORD *)this + 139);
            v60 = v96;
            v57 = v59;
            v58 = v96;
            AAB::UpdateCurve_Block3((uint64_t)this, (uint64_t)__dst, *(float *)&v59, *((float *)&v59 + 1), v96);
          }
          v20 = v96;
          v5 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139));
          *(float *)&v6 = v20;
          +[CBAnalytics autoBrightnessUserChange:lowPower:](CBAnalytics, "autoBrightnessUserChange:lowPower:", v20 > v5, *((_BYTE *)this + 3416) & 1, v6);
          memcpy((char *)this + 1048, __dst, 0x68uLL);
          v56 = 0;
          if (_logHandle)
          {
            v19 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v18 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v18 = init_default_corebrightness_log();
            v19 = v18;
          }
          v56 = v19;
          v55 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            if (*((float *)this + 136) <= *((float *)this + 7))
              v17 = "E1 & L1";
            else
              v17 = "E2 & L2";
            __os_log_helper_16_2_5_8_0_8_0_8_0_8_0_8_32((uint64_t)v105, COERCE__INT64(*((float *)this + 266)), COERCE__INT64(*((float *)this + 268)), COERCE__INT64(*((float *)this + 267)), COERCE__INT64(*((float *)this + 269)), (uint64_t)v17);
            _os_log_impl(&dword_1B5291000, v56, v55, "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f  [updated %s]", v105, 0x34u);
          }
          v54 = 0;
          if (_logHandle)
          {
            v16 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v15 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v15 = init_default_corebrightness_log();
            v16 = v15;
          }
          v54 = v16;
          v53 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v104, COERCE__INT64(*((float *)this + 262)), COERCE__INT64(*((float *)this + 263)), COERCE__INT64(*((float *)this + 264)), COERCE__INT64(*((float *)this + 265)));
            _os_log_impl(&dword_1B5291000, v54, v53, "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v104, 0x2Au);
          }
          if ((*((_BYTE *)this + 3368) & 1) != 0)
          {
            *((_BYTE *)this + 3400) = 0;
            v52 = 0;
            if (AABC::isCurveGood((uint64_t)this, (uint64_t)this + 1048))
            {
              memcpy((char *)this + 2896, (char *)this + 1048, 0x68uLL);
              v51 = 0;
              if (_logHandle)
              {
                v14 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                  v13 = _COREBRIGHTNESS_LOG_DEFAULT;
                else
                  v13 = init_default_corebrightness_log();
                v14 = v13;
              }
              v51 = v14;
              v50 = OS_LOG_TYPE_DEBUG;
              if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
              {
                v11 = v51;
                v12 = v50;
                __os_log_helper_16_0_0(v49);
                _os_log_debug_impl(&dword_1B5291000, v11, v12, "Session curve is good", v49, 2u);
              }
              if ((v52 & 1) != 0
                || !*((_DWORD *)this + 832)
                || *((_DWORD *)this + 832) == *((_DWORD *)this + 843)
                || !*((_DWORD *)this + 840))
              {
                *((_DWORD *)this + 832) = 0;
                *((_DWORD *)this + 840) = 0;
                *((_QWORD *)this + 417) = 0;
                *((_QWORD *)this + 418) = 0;
                *((_QWORD *)this + 419) = 0;
              }
            }
            else
            {
              v48 = CFAbsoluteTimeGetCurrent();
              if (*((_DWORD *)this + 832))
              {
                if (*((_DWORD *)this + 832) < *((_DWORD *)this + 843)
                  && v48 > *((double *)this + 417) + *((double *)this + 422)
                  && *((_DWORD *)this + 840))
                {
                  *((double *)this + (*((_DWORD *)this + 832))++ + 417) = v48;
                  *((_DWORD *)this + 840) = 0;
                }
              }
              else
              {
                *((double *)this + *((unsigned int *)this + 832) + 417) = v48;
                *((_DWORD *)this + 832) = 1;
                *((_DWORD *)this + 840) = 0;
              }
            }
          }
        }
      }
      else if (*((_DWORD *)this + 92) == 3)
      {
        v47 = 0;
        if (_logHandle)
        {
          v10 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v9 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v9 = init_default_corebrightness_log();
          v10 = v9;
        }
        v47 = v10;
        v46 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          v7 = v47;
          v8 = v46;
          __os_log_helper_16_0_0(v45);
          _os_log_debug_impl(&dword_1B5291000, v7, v8, "Cancel ramp, turning on auto-brightness", v45, 2u);
        }
        AABC::CancelRamp(this);
        AABC::UpdateState((uint64_t)this, 4);
      }
    }
  }
}

void AABC::setAABCurveUpdateReason(uint64_t a1, unsigned int a2)
{
  uint64_t updated;
  uint64_t inited;
  NSObject *v4;
  CFNumberRef v6;
  unsigned int valuePtr;
  uint64_t v8;
  uint8_t v9[24];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v8 = a1;
  valuePtr = a2;
  if (*(_QWORD *)(a1 + 384))
  {
    v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 384), CFSTR("AABCurveUpdateReason"), v6);
    if (_logHandle)
    {
      v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v4 = inited;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      updated = AABCurveUpdateReasonToString(valuePtr);
      __os_log_helper_16_2_1_8_66((uint64_t)v9, updated);
      _os_log_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEFAULT, "[aabParamsUpdateReason] %{public}@", v9, 0xCu);
    }
    CFRelease(v6);
  }
}

void AABC::SetAutoBrightnessStatus(AABC *this, int a2, float a3)
{
  const char *v3;
  NSObject *v4;
  os_log_type_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t inited;
  NSObject *v17;
  uint8_t v19[7];
  char v20;
  NSObject *v21;
  os_log_type_t v22;
  os_log_t v23;
  float v24;
  os_log_type_t v25;
  os_log_t v26;
  os_log_type_t v27;
  os_log_t v28;
  os_log_type_t v29;
  os_log_t v30;
  os_log_type_t v31;
  os_log_t v32;
  float v33;
  int v34;
  AABC *v35;
  uint8_t v36[32];
  uint8_t v37[16];
  uint8_t v38[32];
  uint8_t v39[32];
  uint8_t v40[8];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v35 = this;
  v34 = a2;
  v33 = a3;
  v32 = 0;
  if (_logHandle)
  {
    v17 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v17 = inited;
  }
  v32 = v17;
  v31 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v40, 4);
    _os_log_debug_impl(&dword_1B5291000, v32, v31, "[%x]: ", v40, 8u);
  }
  v34 |= *((_DWORD *)this + 860) | 1;
  v30 = 0;
  if (_logHandle)
  {
    v15 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v14 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v14 = init_default_corebrightness_log();
    v15 = v14;
  }
  v30 = v15;
  v29 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_3_4_0_8_32_8_0((uint64_t)v39, 2, (uint64_t)"true", COERCE__INT64(v33));
    _os_log_debug_impl(&dword_1B5291000, v30, v29, "[%x]: active=%s duration=%f", v39, 0x1Cu);
  }
  if (*((_DWORD *)this + 127) == v34)
  {
    if (*((_DWORD *)this + 128) && *((_DWORD *)this + 127) && v33 > 0.0)
    {
      AABC::UpdateState((uint64_t)this, 2);
      AABC::BeginFastRampMode((CFAbsoluteTime *)this, v33, 0.2);
    }
  }
  else
  {
    v28 = 0;
    if (_logHandle)
    {
      v13 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v12 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v12 = init_default_corebrightness_log();
      v13 = v12;
    }
    v28 = v13;
    v27 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      if (*((_DWORD *)this + 128))
        v3 = "true";
      else
        v3 = "false";
      __os_log_helper_16_2_3_8_32_8_32_8_0((uint64_t)v38, (uint64_t)v3, (uint64_t)"true", COERCE__INT64(*((float *)this + 136)));
      _os_log_impl(&dword_1B5291000, v28, v27, "_autoBrightnessEnabled=%s active=%s _Esensor_trusted=%f", v38, 0x20u);
    }
    if (*((_DWORD *)this + 128))
    {
      if (v33 <= 0.0)
      {
        if (*((_DWORD *)this + 860))
        {
          AABC::UpdateState((uint64_t)this, 3);
        }
        else
        {
          *((_DWORD *)this + 175) = 1;
          AABC::UpdateState((uint64_t)this, 2);
          AABC::BeginFastRampMode((CFAbsoluteTime *)this, *((float *)this + 853), 0.2);
        }
      }
      else
      {
        AABC::UpdateState((uint64_t)this, 2);
        AABC::BeginFastRampMode((CFAbsoluteTime *)this, v33, 0.2);
      }
      v26 = 0;
      if (_logHandle)
      {
        v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v10 = init_default_corebrightness_log();
        v11 = v10;
      }
      v26 = v11;
      v25 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_4_0_4_0((uint64_t)v37, 2, *((_DWORD *)this + 150));
        _os_log_debug_impl(&dword_1B5291000, v26, v25, "[%x]: _Esamples=%x", v37, 0xEu);
      }
      if (*((_DWORD *)this + 150))
      {
        v24 = 0.0;
        v24 = fminf(fmaxf(AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139)), *((float *)this + 180)), *((float *)this + 182));
        v23 = 0;
        if (_logHandle)
        {
          v9 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v8 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v8 = init_default_corebrightness_log();
          v9 = v8;
        }
        v23 = v9;
        v22 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_8_0((uint64_t)v36, 2, COERCE__INT64(v24));
          _os_log_debug_impl(&dword_1B5291000, v23, v22, "[%x]: L=%f", v36, 0x12u);
        }
        AABC::UpdateDisplayBrightness_Block6((uint64_t)this, 1, 2, 0, v24);
        *((_DWORD *)this + 151) = 0;
      }
    }
    else
    {
      v21 = 0;
      if (_logHandle)
      {
        v7 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v6 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v6 = init_default_corebrightness_log();
        v7 = v6;
      }
      v21 = v7;
      v20 = 1;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        v4 = v21;
        v5 = v20;
        __os_log_helper_16_0_0(v19);
        _os_log_impl(&dword_1B5291000, v4, v5, "Cancel ramp, manual brightness", v19, 2u);
      }
      AABC::CancelRamp(this);
      AABC::UpdateState((uint64_t)this, 1);
    }
    *((_DWORD *)this + 127) = v34;
  }
}

void AABC::SetDisplayFactor(AABC *this, float a2, char a3)
{
  uint64_t inited;
  NSObject *v4;
  char v6;
  uint8_t v8[24];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v6 = a3 & 1;
  if (_logHandle)
  {
    v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v4 = inited;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_2_8_0_4_0((uint64_t)v8, COERCE__INT64(a2), v6 & 1);
    _os_log_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEFAULT, "Factor=%0.4f reasonActivateALS=%d", v8, 0x12u);
  }
  if ((v6 & 1) != 0)
  {
    if (*((float *)this + 124) <= 0.0)
      AABC::SetDisplayFactor(this, a2);
    *((_BYTE *)this + 504) = v6 & 1;
  }
  else
  {
    *((float *)this + 124) = a2;
    if ((*((_BYTE *)this + 504) & 1) != 0 && a2 > 0.0)
    {
      AABC::SetDisplayFactor(this, 0.0);
      AABC::SetDisplayFactor(this, a2);
    }
    else
    {
      AABC::SetDisplayFactor(this, a2);
    }
    *((_BYTE *)this + 504) = 0;
  }
}

void AABC::NotifyCPMSWhenDisplayChangeState(AABC *this, char a2)
{
  void *v2;
  id v4;
  id v5;
  id v6;
  void *v7;
  char v8;
  _QWORD v9[3];
  _QWORD v10[4];

  v10[3] = *MEMORY[0x1E0C80C00];
  v8 = a2 & 1;
  if ((objc_msgSend(MEMORY[0x1E0D09930], "isCPMSSupported") & 1) == 1)
  {
    if ((v8 & 1) != 0)
    {
      v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", *((unsigned int *)this + 1037));
      v6 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", *((unsigned int *)this + 1039));
      v5 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", *((unsigned int *)this + 1035));
    }
    else
    {
      v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:");
      v6 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", 0);
      v5 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", 0);
    }
    if (*((_QWORD *)this + 516) && *((_QWORD *)this + 515))
    {
      v2 = (void *)*((_QWORD *)this + 516);
      v9[0] = *MEMORY[0x1E0D09978];
      v10[0] = v7;
      v9[1] = *MEMORY[0x1E0D09950];
      v10[1] = v5;
      v9[2] = *MEMORY[0x1E0D09968];
      v10[2] = v6;
      v4 = (id)objc_msgSend(v2, "copyPowerBudgetForRequest:forClient:error:", objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v10, v9, 3), objc_msgSend(*((id *)this + 515), "clientId"), 0);
      if (v4)
      {
        if ((v8 & 1) != 0)
          AABC::ProcessCPMSBudget((uint64_t)this, v4);
      }

    }
  }
}

void AABC::SetBrightness(AABC *this, float a2, float a3, int a4, void (*a5)(void *), uint64_t a6)
{
  uint64_t inited;
  NSObject *v7;
  uint8_t v14[40];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (_logHandle)
  {
    v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v7 = inited;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_4_0_8_0_8_0((uint64_t)v14, 1, COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_debug_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEBUG, "[%x]: L=%f duration=%f", v14, 0x1Cu);
  }
  if (*((_DWORD *)this + 128))
  {
    if (*((_DWORD *)this + 127))
      DisplaySetVirtualBrightnessWithFade(*((_QWORD *)this + 51), a4, (uint64_t)a5, a6, a2, a3);
  }
}

void AABC::_RampDoneCallback(AABC *this, AABC *a2)
{
  AABC::RampDoneCallback(this);
}

void *AABC::_UpdateEcoModeState(void *this, char a2)
{
  const char *v2;
  uint64_t inited;
  NSObject *v4;
  void *v5;
  char v6;
  uint8_t v7[24];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6 = a2 & 1;
  v5 = this;
  if ((a2 & 1) != (*((_BYTE *)this + 3416) & 1))
  {
    if (_logHandle)
    {
      v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v4 = inited;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if ((v6 & 1) != 0)
        v2 = "ON";
      else
        v2 = "OFF";
      __os_log_helper_16_2_1_8_32((uint64_t)v7, (uint64_t)v2);
      _os_log_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEFAULT, "%s \n", v7, 0xCu);
    }
    *((_BYTE *)v5 + 3416) = v6 & 1;
    if ((*((_BYTE *)v5 + 3416) & 1) != 0)
      return PerceptualLuminanceThresholding::SetAggressivity(*((PerceptualLuminanceThresholding **)v5 + 502), 2u);
    else
      return PerceptualLuminanceThresholding::SetAggressivity(*((PerceptualLuminanceThresholding **)v5 + 502), 1u);
  }
  return this;
}

uint64_t std::bitset<3ul>::operator[][abi:ne180100](uint64_t a1, char a2)
{
  return std::__bitset<1ul,3ul>::__make_ref[abi:ne180100](a1, a2);
}

uint64_t std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator=[abi:ne180100](uint64_t result, char a2)
{
  if ((a2 & 1) != 0)
    **(_QWORD **)result |= *(_QWORD *)(result + 8);
  else
    **(_QWORD **)result &= ~*(_QWORD *)(result + 8);
  return result;
}

void AABC::evaluateAABRearConditions(id *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  _BOOL4 v5;
  _BOOL4 v6;
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v10;
  char v11;
  char v12;
  _QWORD v14[2];
  _QWORD v15[2];
  _QWORD v16[2];
  os_log_type_t v17;
  NSObject *v18;
  const __CFString *v19;
  char v20;
  char v21;
  char v22;
  id *v23;
  uint8_t v24[40];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v23 = this;
  if ((objc_msgSend(this[37], "isRearALSSupported") & 1) != 0)
  {
    v22 = 0;
    v22 = objc_msgSend(this[37], "started") & 1;
    v21 = 0;
    v12 = 0;
    if (std::bitset<3ul>::none[abi:ne180100](this + 38))
      v12 = v22 ^ 1;
    v21 = v12 & 1;
    v20 = 0;
    v11 = 0;
    if (std::bitset<3ul>::any[abi:ne180100](this + 38))
      v11 = v22;
    v20 = v11;
    v19 = CFSTR("none");
    if ((v21 & 1) != 0)
    {
      objc_msgSend(this[37], "startSampling");
      v19 = CFSTR("starting");
    }
    else if ((v20 & 1) != 0)
    {
      objc_msgSend(this[37], "stopSampling");
      v19 = CFSTR("stopping");
    }
    v18 = 0;
    if (_logHandle)
    {
      v10 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v10 = inited;
    }
    v18 = v10;
    v17 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      log = v18;
      type = v17;
      v16[0] = std::bitset<3ul>::operator[][abi:ne180100]((uint64_t)(this + 38), 0);
      v16[1] = v1;
      v5 = std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator BOOL[abi:ne180100]((uint64_t)v16);
      v15[0] = std::bitset<3ul>::operator[][abi:ne180100]((uint64_t)(this + 38), 1);
      v15[1] = v2;
      v6 = std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator BOOL[abi:ne180100]((uint64_t)v15);
      v14[0] = std::bitset<3ul>::operator[][abi:ne180100]((uint64_t)(this + 38), 2);
      v14[1] = v3;
      v4 = std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator BOOL[abi:ne180100]((uint64_t)v14);
      __os_log_helper_16_2_5_4_0_4_0_4_0_4_0_8_64((uint64_t)v24, v5, v6, v4, v22 & 1, (uint64_t)v19);
      _os_log_impl(&dword_1B5291000, log, type, "Grimaldi; { \"aod_forbidden\": %d, \"factor_forbidden\": %d, \"property_forbidden\": %d, \"isStarted\": %d, \"st"
        "ate_change\": \"%@\" }",
        v24,
        0x24u);
    }
  }
}

uint64_t AABC::populateCurveValuesFromDictionary(AABC *this, const __CFDictionary *a2, CustomCurve *a3, int a4)
{
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t inited;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  CFTypeID v13;
  CFTypeID v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  os_log_type_t v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  os_log_type_t v22;
  uint64_t v23;
  NSObject *v24;
  NSObject *v25;
  os_log_type_t v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *log;
  os_log_type_t type;
  uint64_t v31;
  NSObject *v32;
  int j;
  int i;
  int idx;
  uint8_t v37[7];
  os_log_type_t v38;
  os_log_t v39;
  uint8_t v40[7];
  os_log_type_t v41;
  os_log_t oslog;
  uint8_t v43[7];
  char v44;
  NSObject *v45;
  uint8_t v46[7];
  char v47;
  NSObject *v48;
  char v49;
  int Count;
  float v51;
  float FloatFromDictionary;
  CFTypeRef v53;
  CFTypeRef ValueAtIndex;
  CFArrayRef v55;
  CFArrayRef CFArrayFromDictionary;
  int v57;
  CustomCurve *v58;
  const __CFDictionary *v59;
  AABC *v60;
  uint8_t v61[32];
  uint8_t v62[16];
  uint8_t v63[16];
  uint8_t v64[32];
  uint8_t v65[24];
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v60 = this;
  v59 = a2;
  v58 = a3;
  v57 = a4;
  v55 = 0;
  ValueAtIndex = 0;
  v53 = 0;
  FloatFromDictionary = 0.0;
  v51 = 0.0;
  Count = 0;
  v49 = 0;
  CFArrayFromDictionary = (CFArrayRef)GetCFArrayFromDictionary(a2, CFSTR("E"));
  if (CFArrayFromDictionary)
  {
    v55 = (CFArrayRef)GetCFArrayFromDictionary(v59, CFSTR("L"));
    if (v55)
    {
      Count = CFArrayGetCount(CFArrayFromDictionary);
      if (CFArrayGetCount(v55) == Count)
      {
        if (Count)
        {
          if (Count <= v57)
          {
            for (idx = 0; idx < Count; ++idx)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(v55, idx);
              v53 = CFArrayGetValueAtIndex(CFArrayFromDictionary, idx);
              if (!ValueAtIndex
                || !v53
                || (v14 = CFGetTypeID(ValueAtIndex), v14 != CFNumberGetTypeID())
                || (v13 = CFGetTypeID(v53), v13 != CFNumberGetTypeID()))
              {
                if (_logHandle)
                {
                  v10 = _logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT)
                    inited = _COREBRIGHTNESS_LOG_DEFAULT;
                  else
                    inited = init_default_corebrightness_log();
                  v10 = inited;
                }
                if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
                {
                  __os_log_helper_16_0_1_4_0((uint64_t)v63, idx);
                  _os_log_error_impl(&dword_1B5291000, v10, OS_LOG_TYPE_ERROR, "invalid curve data at index %d", v63, 8u);
                }
                return v49 & 1;
              }
              CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberFloatType, &v58->_L[idx]);
              CFNumberGetValue((CFNumberRef)v53, kCFNumberFloatType, &v58->_E[idx]);
              if (_logHandle)
              {
                v12 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                  v11 = _COREBRIGHTNESS_LOG_DEFAULT;
                else
                  v11 = init_default_corebrightness_log();
                v12 = v11;
              }
              if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
              {
                __os_log_helper_16_0_3_4_0_8_0_8_0((uint64_t)v64, idx, COERCE__INT64(v58->_E[idx]), COERCE__INT64(v58->_L[idx]));
                _os_log_impl(&dword_1B5291000, v12, OS_LOG_TYPE_DEFAULT, "[%d] nits(%f) = %f", v64, 0x1Cu);
              }
            }
            v58->size = Count;
            if (_logHandle)
            {
              v8 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
                v7 = _COREBRIGHTNESS_LOG_DEFAULT;
              else
                v7 = init_default_corebrightness_log();
              v8 = v7;
            }
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_0_1_4_0((uint64_t)v62, v58->size);
              _os_log_debug_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEBUG, "curve size: %d", v62, 8u);
            }
            FloatFromDictionary = GetFloatFromDictionary(v59, CFSTR("m1"));
            if (FloatFromDictionary > 0.0)
              FloatFromDictionary = *((float *)this + 177)
                                  + (float)(FloatFromDictionary
                                          * (float)(*((float *)this + 179) - *((float *)this + 177)));
            v51 = GetFloatFromDictionary(v59, CFSTR("m2"));
            if (v51 > 0.0)
              v51 = *((float *)this + 177) + (float)(v51 * (float)(*((float *)this + 179) - *((float *)this + 177)));
            if (_logHandle)
            {
              v6 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
                v5 = _COREBRIGHTNESS_LOG_DEFAULT;
              else
                v5 = init_default_corebrightness_log();
              v6 = v5;
            }
            if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_0_2_8_0_8_0((uint64_t)v61, COERCE__INT64(v51), COERCE__INT64(FloatFromDictionary));
              _os_log_debug_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEBUG, "minThreshold: %f maxThreshold: %f", v61, 0x16u);
            }
            if (FloatFromDictionary > 0.0)
            {
              for (i = 0; i < v58->size; ++i)
                v58->_L[i] = fminf(FloatFromDictionary, v58->_L[i]);
            }
            if (v51 > 0.0)
            {
              for (j = 0; j < v58->size; ++j)
                v58->_L[j] = fmaxf(v51, v58->_L[j]);
            }
            v49 = 1;
          }
          else
          {
            if (_logHandle)
            {
              v16 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
                v15 = _COREBRIGHTNESS_LOG_DEFAULT;
              else
                v15 = init_default_corebrightness_log();
              v16 = v15;
            }
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              __os_log_helper_16_0_2_4_0_4_0((uint64_t)v65, v57, Count);
              _os_log_error_impl(&dword_1B5291000, v16, OS_LOG_TYPE_ERROR, "lux and nits array too large for display type (max: %d, actual: %d)", v65, 0xEu);
            }
          }
        }
        else
        {
          v39 = 0;
          if (_logHandle)
          {
            v20 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v19 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v19 = init_default_corebrightness_log();
            v20 = v19;
          }
          v39 = v20;
          v38 = OS_LOG_TYPE_ERROR;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            v17 = v39;
            v18 = v38;
            __os_log_helper_16_0_0(v37);
            _os_log_error_impl(&dword_1B5291000, v17, v18, "lux and nits arrays are empty", v37, 2u);
          }
        }
      }
      else
      {
        oslog = 0;
        if (_logHandle)
        {
          v24 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v23 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v23 = init_default_corebrightness_log();
          v24 = v23;
        }
        oslog = v24;
        v41 = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          v21 = oslog;
          v22 = v41;
          __os_log_helper_16_0_0(v40);
          _os_log_error_impl(&dword_1B5291000, v21, v22, "lux and nits arrays differ in size", v40, 2u);
        }
      }
    }
    else
    {
      v45 = 0;
      if (_logHandle)
      {
        v28 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v27 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v27 = init_default_corebrightness_log();
        v28 = v27;
      }
      v45 = v28;
      v44 = 16;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        v25 = v45;
        v26 = v44;
        __os_log_helper_16_0_0(v43);
        _os_log_error_impl(&dword_1B5291000, v25, v26, "invalid or missing L (nits) array", v43, 2u);
      }
    }
  }
  else
  {
    v48 = 0;
    if (_logHandle)
    {
      v32 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v31 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v31 = init_default_corebrightness_log();
      v32 = v31;
    }
    v48 = v32;
    v47 = 16;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      log = v48;
      type = v47;
      __os_log_helper_16_0_0(v46);
      _os_log_error_impl(&dword_1B5291000, log, type, "invalid or missing E (lux) array", v46, 2u);
    }
  }
  return v49 & 1;
}

CFTypeRef GetCFArrayFromDictionary(const __CFDictionary *a1, const __CFString *a2)
{
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v6;
  CFTypeID v7;
  CFTypeID v8;
  uint8_t v9[7];
  char v10;
  NSObject *v11;
  CFTypeRef Value;
  uint64_t v13;
  const void *v14;
  const __CFDictionary *v15;

  v15 = a1;
  v14 = a2;
  v13 = 0;
  if (a1 && (v8 = CFGetTypeID(v15), v8 == CFDictionaryGetTypeID()))
  {
    Value = CFDictionaryGetValue(v15, v14);
    if (Value)
    {
      v7 = CFGetTypeID(Value);
      if (v7 == CFArrayGetTypeID())
        return Value;
    }
  }
  else
  {
    v11 = 0;
    if (_logHandle)
    {
      v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v6 = inited;
    }
    v11 = v6;
    v10 = 16;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      log = v11;
      type = v10;
      __os_log_helper_16_0_0(v9);
      _os_log_error_impl(&dword_1B5291000, log, type, "GetCFArrayFromDictionary: ref is NULL or not a dictionary", v9, 2u);
    }
  }
  return (CFTypeRef)v13;
}

float GetFloatFromDictionary(const __CFDictionary *a1, const __CFString *a2)
{
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v6;
  CFTypeID v7;
  CFTypeID v8;
  uint8_t v9[7];
  char v10;
  NSObject *v11;
  CFTypeRef Value;
  float valuePtr;
  const void *v14;
  const __CFDictionary *v15;

  v15 = a1;
  v14 = a2;
  valuePtr = 0.0;
  if (a1 && (v8 = CFGetTypeID(v15), v8 == CFDictionaryGetTypeID()))
  {
    Value = CFDictionaryGetValue(v15, v14);
    if (Value)
    {
      v7 = CFGetTypeID(Value);
      if (v7 == CFNumberGetTypeID())
        CFNumberGetValue((CFNumberRef)Value, kCFNumberFloatType, &valuePtr);
    }
  }
  else
  {
    v11 = 0;
    if (_logHandle)
    {
      v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v6 = inited;
    }
    v11 = v6;
    v10 = 16;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      log = v11;
      type = v10;
      __os_log_helper_16_0_0(v9);
      _os_log_error_impl(&dword_1B5291000, log, type, "GetCFNumberValueAsFloat: ref is NULL or not a dictionary", v9, 2u);
    }
  }
  return valuePtr;
}

void AABC::writeCurveToUserDefaults(AABC *this, CustomCurve *a2, const __CFString *a3, uint64_t a4)
{
  uint64_t v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  size_t v11;
  const __CFAllocator *v12;
  CFNumberRef v13;
  CFAllocatorRef *v14;
  CFNumberType v15;
  CFNumberRef v16;
  const __CFAllocator *v17;
  const __CFString *v18;
  const __CFString *v19;
  _BYTE v20[16];
  const CFArrayCallBacks *v21;
  CFAllocatorRef *v22;
  const void **v23;
  CFStringRef *v24;
  CFStringRef *v25;
  CFStringRef v26;
  CFAllocatorRef *v27;
  uint64_t v28;
  unint64_t v29;
  const void **v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  const void **v34;
  int j;
  CFDictionaryRef v36;
  int i;
  uint64_t v38;
  uint64_t v39;
  _BYTE *v40;
  int size;
  CFStringRef v42;
  CustomCurve *v43;
  AABC *v44;
  void *keys[2];
  CFArrayRef v46;
  CFArrayRef v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v44 = this;
  v43 = a2;
  v42 = a3;
  size = 0;
  size = a2->size;
  v40 = v20;
  v29 = (8 * size + 15) & 0xFFFFFFFFFFFFFFF0;
  MEMORY[0x1E0C80A78](this, a2, a3, a4);
  v30 = (const void **)&v20[-v29];
  v39 = v4;
  v31 = 512;
  if ((unint64_t)(8 * v4) <= 0x200)
    v5 = 8 * v4;
  else
    v5 = 512;
  bzero(&v20[-v29], v5);
  v33 = size;
  v32 = (8 * size + 15) & 0xFFFFFFFFFFFFFFF0;
  MEMORY[0x1E0C80A78](v6, v7, v8, v9);
  v34 = (const void **)&v20[-v32];
  v38 = v33;
  if ((unint64_t)(8 * v33) <= 0x200)
    v11 = 8 * v33;
  else
    v11 = v10;
  bzero(&v20[-v32], v11);
  for (i = 0; i < size; ++i)
  {
    v27 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v28 = 12;
    v13 = CFNumberCreate(v12, kCFNumberFloatType, &v43->_E[i]);
    v14 = v27;
    v15 = v28;
    v30[i] = v13;
    v16 = CFNumberCreate(*v14, v15, &v43->_L[i]);
    v34[i] = v16;
  }
  v23 = (const void **)&v46;
  v46 = 0;
  v47 = 0;
  v22 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v21 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  v46 = CFArrayCreate(v17, v30, size, MEMORY[0x1E0C9B378]);
  v47 = CFArrayCreate(*v22, v34, size, v21);
  *(_OWORD *)keys = xmmword_1E68EBB20;
  v36 = 0;
  v36 = CFDictionaryCreate(*v22, (const void **)keys, v23, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v24 = (CFStringRef *)MEMORY[0x1E0C9B260];
  v18 = (const __CFString *)*MEMORY[0x1E0C9B260];
  v25 = (CFStringRef *)MEMORY[0x1E0C9B250];
  v19 = (const __CFString *)*MEMORY[0x1E0C9B250];
  v26 = CFSTR("com.apple.CoreBrightness");
  CFPreferencesSetValue(v42, v36, CFSTR("com.apple.CoreBrightness"), v18, v19);
  CFPreferencesSynchronize(v26, *v24, *v25);
  for (j = 0; j < size; ++j)
  {
    CFRelease(v30[j]);
    CFRelease(v34[j]);
  }
  CFRelease(v46);
  CFRelease(v47);
  CFRelease(v36);
}

void ___ZN4AABC24getCurveUpdatesFromArrayEP11objc_object_block_invoke(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  float v4;
  float v5;
  _QWORD *v6;
  uint64_t inited;
  NSObject *v8;
  NSObject *log;
  os_log_type_t type;
  uint64_t v11;
  NSObject *v12;
  __n128 v14;
  os_log_type_t v15;
  os_log_t oslog;
  uint8_t v17[15];
  char v18;
  NSObject *v19;
  uint64_t v20;
  float v21;
  float v22;
  uint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  id v26;
  uint64_t v27;
  uint8_t v28[40];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v27 = a1;
  v26 = a2;
  v25 = a3;
  v24 = a4;
  v23 = a1;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v22 = 0.0;
    v21 = 0.0;
    v20 = -1;
    objc_msgSend(v26, "objectForKeyedSubscript:", CFSTR("Lux"));
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0
      && (objc_msgSend(v26, "objectForKeyedSubscript:", CFSTR("Nits")),
          objc_opt_class(),
          (objc_opt_isKindOfClass() & 1) != 0)
      && (objc_msgSend(v26, "objectForKeyedSubscript:", CFSTR("Timestamp")),
          objc_opt_class(),
          (objc_opt_isKindOfClass() & 1) != 0))
    {
      objc_msgSend((id)objc_msgSend(v26, "objectForKeyedSubscript:", CFSTR("Lux")), "floatValue");
      v22 = v4;
      objc_msgSend((id)objc_msgSend(v26, "objectForKeyedSubscript:", CFSTR("Nits")), "floatValue");
      v21 = v5;
      v20 = objc_msgSend((id)objc_msgSend(v26, "objectForKeyedSubscript:", CFSTR("Timestamp")), "longLongValue");
      oslog = 0;
      if (_logHandle)
      {
        v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v8 = inited;
      }
      oslog = v8;
      v15 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v28, COERCE__INT64(v22), COERCE__INT64(v21), v20);
        _os_log_debug_impl(&dword_1B5291000, oslog, v15, "Adding curve update from ALS user preferences: %f %f %lld", v28, 0x20u);
      }
      v6 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48);
      v14.n128_u64[0] = __PAIR64__(LODWORD(v21), LODWORD(v22));
      v14.n128_u64[1] = v20;
      std::list<AAB::CurveUpdate>::push_back(v6, &v14);
    }
    else
    {
      v19 = 0;
      if (_logHandle)
      {
        v12 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v11 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v11 = init_default_corebrightness_log();
        v12 = v11;
      }
      v19 = v12;
      v18 = 16;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        log = v19;
        type = v18;
        __os_log_helper_16_0_0(v17);
        _os_log_error_impl(&dword_1B5291000, log, type, "Wrongly formatted BOLTS buffer", v17, 2u);
      }
      *v24 = 1;
    }
  }
}

void ___ZN4AABC17SetDeviceInSleeveEb_block_invoke(uint64_t a1)
{
  const char *v1;
  NSObject *inited;
  uint64_t v4;
  uint8_t v5[24];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  if (_COREBRIGHTNESS_LOG_DEFAULT)
    inited = _COREBRIGHTNESS_LOG_DEFAULT;
  else
    inited = init_default_corebrightness_log();
  if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
  {
    if ((*(_BYTE *)(a1 + 40) & 1) != 0)
      v1 = "yes";
    else
      v1 = "no";
    __os_log_helper_16_2_1_8_32((uint64_t)v5, (uint64_t)v1);
    _os_log_error_impl(&dword_1B5291000, inited, OS_LOG_TYPE_ERROR, "deviceInSleeve=%s", v5, 0xCu);
  }
  *(_BYTE *)(v4 + 160) = *(_BYTE *)(a1 + 40) & 1;
  if ((*(_BYTE *)(v4 + 160) & 1) != 0)
    AABC::setFilterDuration(v4, v4 + 168, 4);
  else
    AABC::resetFilter(v4, (uint64_t *)(v4 + 168));
}

void std::vector<float>::clear[abi:ne180100](uint64_t *a1)
{
  std::vector<float>::size[abi:ne180100](a1);
  std::vector<float>::__clear[abi:ne180100](a1);
  std::vector<float>::__annotate_shrink[abi:ne180100]();
}

void std::sort[abi:ne180100]<std::__wrap_iter<float *>>(uint64_t a1, uint64_t a2)
{
  std::sort[abi:ne180100]<std::__wrap_iter<float *>,std::__less<void,void>>(a1, a2);
}

uint64_t std::vector<float>::begin[abi:ne180100](uint64_t *a1)
{
  return std::vector<float>::__make_iter[abi:ne180100]((uint64_t)a1, *a1);
}

uint64_t std::vector<float>::end[abi:ne180100](uint64_t a1)
{
  return std::vector<float>::__make_iter[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
}

uint64_t std::array<float,3ul>::size[abi:ne180100]()
{
  return 3;
}

uint64_t std::array<float,3ul>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return a1 + 4 * a2;
}

uint64_t AABC::initAABRear(AABC *this, AABRear *a2)
{
  *((_QWORD *)this + 37) = a2;
  return 1;
}

BOOL std::bitset<3ul>::none[abi:ne180100](_QWORD *a1)
{
  return !std::bitset<3ul>::any[abi:ne180100](a1);
}

BOOL std::bitset<3ul>::any[abi:ne180100](_QWORD *a1)
{
  return std::__bitset<1ul,3ul>::any[abi:ne180100](a1);
}

BOOL std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator BOOL[abi:ne180100](uint64_t a1)
{
  return (**(_QWORD **)a1 & *(_QWORD *)(a1 + 8)) != 0;
}

uint64_t __os_log_helper_16_2_5_4_0_4_0_4_0_4_0_8_64(uint64_t result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 5;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 4;
  *(_DWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 14) = 0;
  *(_BYTE *)(result + 15) = 4;
  *(_DWORD *)(result + 16) = a4;
  *(_BYTE *)(result + 20) = 0;
  *(_BYTE *)(result + 21) = 4;
  *(_DWORD *)(result + 22) = a5;
  *(_BYTE *)(result + 26) = 64;
  *(_BYTE *)(result + 27) = 8;
  *(_QWORD *)(result + 28) = a6;
  return result;
}

uint64_t __os_log_helper_16_2_4_8_0_8_0_8_0_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 32;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  return result;
}

uint64_t __os_log_helper_16_2_5_8_0_8_0_8_0_8_0_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 5;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 32;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  return result;
}

uint64_t __os_log_helper_16_2_3_4_0_8_32_4_0(uint64_t result, int a2, uint64_t a3, int a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 32;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 4;
  *(_DWORD *)(result + 20) = a4;
  return result;
}

void AABC::SetDisplayFactor(AABC *this, float a2)
{
  const char *v2;
  double v3;
  uint64_t v4;
  uint64_t v5;
  double *v6;
  float v7;
  NSObject *v8;
  os_log_type_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  char v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t inited;
  NSObject *v26;
  char v28;
  uint8_t v29[7];
  os_log_type_t v30;
  os_log_t v31;
  unint64_t v32;
  uint64_t v33;
  CFTypeRef property;
  id v35;
  _QWORD v36[2];
  os_log_type_t v37;
  os_log_t v38;
  float v39;
  float v40;
  _QWORD v41[2];
  os_log_type_t v42;
  os_log_t oslog;
  os_log_type_t v44;
  os_log_t v45;
  id v46;
  float v47;
  float v48;
  os_log_type_t v49;
  os_log_t v50;
  os_log_type_t v51;
  os_log_t v52;
  os_log_type_t v53;
  os_log_t v54;
  CFAbsoluteTime v55;
  CFAbsoluteTime Current;
  char v57;
  float v58;
  os_log_type_t type;
  os_log_t v60;
  float v61;
  AABC *v62;
  uint8_t v63[32];
  uint8_t v64[16];
  uint8_t v65[16];
  uint8_t v66[32];
  uint8_t v67[48];
  uint8_t v68[48];
  uint8_t v69[24];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v62 = this;
  v61 = a2;
  v60 = 0;
  if (_logHandle)
  {
    v26 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v26 = inited;
  }
  v60 = v26;
  type = OS_LOG_TYPE_INFO;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v69, COERCE__INT64(v61));
    _os_log_impl(&dword_1B5291000, v60, type, "Factor=%0.4f", v69, 0xCu);
  }
  if (v61 != *((float *)this + 123))
  {
    v58 = 0.0;
    v58 = *((float *)this + 123);
    *((float *)this + 123) = v61;
    *((_DWORD *)this + 122) = *((float *)this + 123) > 0.0;
    if (v58 == 0.0 && *((float *)this + 123) > 0.0)
    {
      *((_DWORD *)this + 141) = 0;
      *((_DWORD *)this + 152) = 0;
      *((_DWORD *)this + 153) = 0;
      if (*((_QWORD *)this + 521) && (*((_DWORD *)this + 80) == 6 || *((_DWORD *)this + 80) == 1))
      {
        v57 = 0;
        objc_msgSend(*((id *)this + 521), "sendCommand:inputBuffer:inputBufferSize:", 233, &v57, 1);
      }
      if ((*((_BYTE *)this + 3368) & 1) != 0
        && *((_DWORD *)this + 832)
        && *((_DWORD *)this + 832) < *((_DWORD *)this + 843))
      {
        if (*((_DWORD *)this + 840))
        {
          AABC::revertToGoodCurve((uint64_t)this, 4u);
          *((_DWORD *)this + 840) = 1;
        }
        else
        {
          Current = CFAbsoluteTimeGetCurrent();
          if (Current > *((double *)this + (*((_DWORD *)this + 832) - 1) + 417) + *((double *)this + 422)
            && Current > *((double *)this + 414) + *((double *)this + 423))
          {
            AABC::revertToGoodCurve((uint64_t)this, 4u);
            *((_DWORD *)this + 840) = 1;
          }
        }
      }
      if ((*((_BYTE *)this + 3401) & 1) != 0)
      {
        v55 = CFAbsoluteTimeGetCurrent();
        if (v55 - *((double *)this + 414) >= *((double *)this + 152))
          AABC::revertToGoodCurve((uint64_t)this, 1u);
      }
      v54 = 0;
      if (_logHandle)
      {
        v24 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v23 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v23 = init_default_corebrightness_log();
        v24 = v23;
      }
      v54 = v24;
      v53 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v68, COERCE__INT64(*((float *)this + 266)), COERCE__INT64(*((float *)this + 268)), COERCE__INT64(*((float *)this + 267)), COERCE__INT64(*((float *)this + 269)));
        _os_log_debug_impl(&dword_1B5291000, v54, v53, "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f", v68, 0x2Au);
      }
      v52 = 0;
      if (_logHandle)
      {
        v22 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v21 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v21 = init_default_corebrightness_log();
        v22 = v21;
      }
      v52 = v22;
      v51 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v67, COERCE__INT64(*((float *)this + 262)), COERCE__INT64(*((float *)this + 263)), COERCE__INT64(*((float *)this + 264)), COERCE__INT64(*((float *)this + 265)));
        _os_log_debug_impl(&dword_1B5291000, v52, v51, "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v67, 0x2Au);
      }
      v50 = 0;
      if (_logHandle)
      {
        v20 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v19 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v19 = init_default_corebrightness_log();
        v20 = v19;
      }
      v50 = v20;
      v49 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        v18 = 0;
        if (*((_QWORD *)this + 60))
          v18 = *((_BYTE *)this + 3937);
        if ((v18 & 1) != 0)
          v2 = "yes";
        else
          v2 = "no";
        __os_log_helper_16_2_2_8_32_8_32((uint64_t)v66, (uint64_t)v2, (uint64_t)(&kDimPolicyStr)[*((unsigned int *)this + 859)]);
        _os_log_debug_impl(&dword_1B5291000, v50, v49, "prox mitigation: %s dimPolicy: %s", v66, 0x16u);
      }
      *((_DWORD *)this + 996) = 0;
      if (*((_DWORD *)this + 860))
        AABC::SetAutoBrightnessStatus(this, 1, *((float *)this + 853));
      AABC::UpdateState((uint64_t)this, 2);
      AABC::BeginFastRampMode((CFAbsoluteTime *)this, *((float *)this + 853), 0.2);
      if (*((_DWORD *)this + 150))
      {
        v48 = 0.0;
        v48 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139));
        if ((*((_BYTE *)this + 3417) & 1) != 0)
        {
          v47 = 0.0;
          v47 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 802, *((float *)this + 136), *((float *)this + 139));
          v48 = fminf(v48, v47);
          if ((*((_BYTE *)this + 3418) & 1) == 0)
            v48 = fminf(*((float *)this + 855), v47);
        }
        v48 = fminf(fmaxf(v48, *((float *)this + 180)), *((float *)this + 182));
        AABC::UpdateDisplayBrightness_Block6((uint64_t)this, 0, 2, 0, v48);
      }
      else
      {
        if ((*((_BYTE *)this + 144) & 1) != 0 && *((_QWORD *)this + 57) && *(_QWORD *)(*((_QWORD *)this + 57) + 32))
        {
          v46 = 0;
          LODWORD(v3) = 0.5;
          v46 = (id)objc_msgSend(*(id *)(*((_QWORD *)this + 57) + 32), "copyALSEventWithinTimeout:", v3);
          if (v46)
          {
            v45 = 0;
            if (_logHandle)
            {
              v17 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
                v16 = _COREBRIGHTNESS_LOG_DEFAULT;
              else
                v16 = init_default_corebrightness_log();
              v17 = v16;
            }
            v45 = v17;
            v44 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_2_1_8_66((uint64_t)v65, (uint64_t)v46);
              _os_log_impl(&dword_1B5291000, v45, v44, "Use copied event: %{public}@", v65, 0xCu);
            }
            AABC::HandleALSEvent(this, *((__IOHIDServiceClient **)this + 41), (__IOHIDEvent *)objc_msgSend(v46, "event"));

          }
          if (!*((_DWORD *)this + 150) && (*((_BYTE *)this + 444) & 1) != 0)
          {
            oslog = 0;
            if (_logHandle)
            {
              v15 = _logHandle;
            }
            else
            {
              v14 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              v15 = v14;
            }
            oslog = v15;
            v42 = OS_LOG_TYPE_ERROR;
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v64, COERCE__INT64(*((float *)this + 852)));
              _os_log_error_impl(&dword_1B5291000, oslog, v42, "Copy event failed => arm first ALS sample TIMEOUT routine (timeout=%f)", v64, 0xCu);
            }
          }
        }
        if (!*((_DWORD *)this + 150))
          AABC::ArmFirstALSSampleTimer(this);
      }
      v41[0] = std::bitset<3ul>::operator[][abi:ne180100]((uint64_t)this + 304, 1);
      v41[1] = v4;
      std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator=[abi:ne180100]((uint64_t)v41, 0);
      AABC::evaluateAABRearConditions((id *)this);
    }
    else if (*((float *)this + 123) == 1.0)
    {
      *((_DWORD *)this + 141) = 0;
      *((_DWORD *)this + 151) = 0;
      *((_DWORD *)this + 152) = 0;
      *((_DWORD *)this + 153) = 0;
      v40 = 0.0;
      v40 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139));
      if ((*((_BYTE *)this + 3417) & 1) != 0)
      {
        v39 = 0.0;
        v39 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 802, *((float *)this + 136), *((float *)this + 139));
        v40 = fminf(v40, v39);
        if ((*((_BYTE *)this + 3418) & 1) == 0)
          v40 = fminf(*((float *)this + 855), v39);
      }
      v40 = fminf(fmaxf(v40, *((float *)this + 180)), *((float *)this + 182));
      v38 = 0;
      if (_logHandle)
      {
        v13 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v12 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v12 = init_default_corebrightness_log();
        v13 = v12;
      }
      v38 = v13;
      v37 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_4_0_8_0((uint64_t)v63, 2, COERCE__INT64(v40));
        _os_log_debug_impl(&dword_1B5291000, v38, v37, "[%x]: L=%f", v63, 0x12u);
      }
      if (*((_DWORD *)this + 128) && *((_DWORD *)this + 127))
        AABC::UpdateDisplayBrightness_Block6((uint64_t)this, 0, 2, 0, v40);
    }
    else if (*((float *)this + 123) == 0.0)
    {
      v36[0] = std::bitset<3ul>::operator[][abi:ne180100]((uint64_t)this + 304, 1);
      v36[1] = v5;
      std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator=[abi:ne180100]((uint64_t)v36, 1);
      AABC::evaluateAABRearConditions((id *)this);
      AABC::CancelFirstSampleTimeout((dispatch_object_t *)this);
      if (*((_DWORD *)this + 80) == 6 && *((_DWORD *)this + 717) == 1 && *((_QWORD *)this + 41))
      {
        v35 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", 0);
        property = (CFTypeRef)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D80]), "initWithObjectsAndKeys:", v35, CFSTR("AOTState"), 0);
        AABC::setAlwaysOnProperty((id *)this, CFSTR("AOTState"), (objc_object *)property);
        IOHIDServiceClientSetProperty(*((IOHIDServiceClientRef *)this + 41), CFSTR("AOTState"), property);

      }
      AABC::UpdateState((uint64_t)this, 0);
      v33 = mach_absolute_time();
      if (*((int *)this + 926) >= 0)
      {
        v32 = 0;
        v32 = v33 - *((_QWORD *)this + 485);
        v6 = (double *)((char *)this + 8 * *((int *)this + 926) + 3808);
        *v6 = *v6 + (double)v32 * *(double *)&AABC::_sMachTimebaseFactor;
      }
      *((_DWORD *)this + 926) = -1;
      objc_msgSend(*((id *)this + 488), "removeAllObjects");
      v7 = (double)v33 * *(double *)&AABC::_sMachTimebaseFactor;
      *((float *)this + 168) = v7;
      *((_DWORD *)this + 87) = 0;
      if ((*((_BYTE *)this + 3401) & 1) != 0 && (*((_BYTE *)this + 3320) & 1) != 0)
      {
        *((CFAbsoluteTime *)this + 414) = CFAbsoluteTimeGetCurrent();
        v31 = 0;
        if (_logHandle)
        {
          v11 = _logHandle;
        }
        else
        {
          v10 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          v11 = v10;
        }
        v31 = v11;
        v30 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          v8 = v31;
          v9 = v30;
          __os_log_helper_16_0_0(v29);
          _os_log_impl(&dword_1B5291000, v8, v9, "User interacted in the session. Resetting counter for AAB cap\n", v29, 2u);
        }
      }
      if ((*((_BYTE *)this + 3368) & 1) != 0)
        *((CFAbsoluteTime *)this + 414) = CFAbsoluteTimeGetCurrent();
      if (*((_QWORD *)this + 54))
      {
        CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 54));
        *((_BYTE *)this + 440) = 0;
        *((_BYTE *)this + 442) = 0;
        *((_BYTE *)this + 443) = 0;
      }
      if ((*((_BYTE *)this + 3320) & 1) != 0)
        *((_BYTE *)this + 3320) = 0;
      if (*((_QWORD *)this + 507) && (objc_msgSend(*((id *)this + 507), "isActive") & 1) != 0)
        objc_msgSend(*((id *)this + 507), "action:", 0);
      AABC::_UpdateNitsRestrictions(this, -1.0, 0.2, 1);
      if (*((_QWORD *)this + 521) && (*((_DWORD *)this + 80) == 6 || *((_DWORD *)this + 80) == 1))
      {
        v28 = 0;
        objc_msgSend(*((id *)this + 521), "sendCommand:inputBuffer:inputBufferSize:", 234, &v28, 1);
        DisplaySetDCPPowerAssertionForAOT(*((_QWORD *)this + 51), 0);
        *((_BYTE *)this + 4176) = 0;
      }
      if ((*((_BYTE *)this + 160) & 1) != 0)
        AABC::resetFilter((uint64_t)this, (uint64_t *)this + 21);
      if ((*((_BYTE *)this + 264) & 1) != 0)
        AABC::resetMovingAverage(this);
      if ((*((_BYTE *)this + 161) & 1) != 0)
        AABC::resetFilter((uint64_t)this, (uint64_t *)this + 27);
    }
  }
}

float AABC::BeginFastRampMode(CFAbsoluteTime *this, float a2, float a3)
{
  float result;
  uint64_t inited;
  NSObject *v5;
  uint8_t v9[24];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (_logHandle)
  {
    v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v5 = inited;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v9, COERCE__INT64(a2));
    _os_log_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEFAULT, "begin fast ramp mode for %.1fs", v9, 0xCu);
  }
  this[85] = CFAbsoluteTimeGetCurrent();
  this[86] = this[85] + a2;
  *((_DWORD *)this + 169) = 1;
  result = a3;
  *((float *)this + 174) = a3;
  return result;
}

uint64_t AABC::setAlwaysOnProperty(id *this, NSString *a2, objc_object *a3)
{
  uint64_t result;
  os_log_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t inited;
  NSObject *v8;
  void *v10;
  int v11;
  os_log_type_t v12;
  os_log_t v13;
  int v14;
  id v15;
  id v16;
  id *v17;
  uint8_t v18[16];
  uint8_t v19[24];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v17 = this;
  v16 = a2;
  v15 = a3;
  if (-[NSString isEqualToString:](a2, "isEqualToString:", CFSTR("CurrentBrightness")))
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      if (this[521])
      {
        v14 = objc_msgSend(v15, "intValue");
        v13 = 0;
        if (_logHandle)
        {
          v8 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            inited = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            inited = init_default_corebrightness_log();
          v8 = inited;
        }
        v13 = v8;
        v12 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_2_8_0_4_0((uint64_t)v19, COERCE__INT64((double)v14 / 65536.0), v14);
          _os_log_impl(&dword_1B5291000, v13, v12, "Setting CurrentBrightness to %f, %d (IOFixed)", v19, 0x12u);
        }
        objc_msgSend(this[521], "sendCommand:inputBuffer:inputBufferSize:", 225, &v14, 4);
      }
    }
  }
  result = objc_msgSend(v16, "isEqualToString:", CFSTR("AOTState"));
  if ((result & 1) != 0)
  {
    objc_opt_class();
    result = objc_opt_isKindOfClass();
    if ((result & 1) != 0)
    {
      if (this[521])
      {
        v11 = 0;
        v10 = (void *)objc_msgSend(v15, "valueForKey:", CFSTR("AOTState"));
        objc_opt_class();
        result = objc_opt_isKindOfClass();
        if ((result & 1) != 0)
        {
          v11 = objc_msgSend(v10, "intValue");
          if (_logHandle)
          {
            v6 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v5 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v5 = init_default_corebrightness_log();
            v6 = v5;
          }
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            v4 = v6;
            __os_log_helper_16_0_1_4_0((uint64_t)v18, v11);
            _os_log_impl(&dword_1B5291000, v6, OS_LOG_TYPE_DEFAULT, "Sending AOTState to DCP, aotState: %d", v18, 8u);
          }
          return objc_msgSend(this[521], "sendCommand:inputBuffer:inputBufferSize:", 227, &v11, 4, v4);
        }
      }
    }
  }
  return result;
}

void AABC::SetALSInterval(AABC *this, float a2)
{
  uint64_t inited;
  NSObject *v3;
  uint8_t v6[24];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (_logHandle)
  {
    v3 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v3 = inited;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_4_0_8_0((uint64_t)v6, 16, COERCE__INT64(a2));
    _os_log_debug_impl(&dword_1B5291000, v3, OS_LOG_TYPE_DEBUG, "[%x]: interval=%f", v6, 0x12u);
  }
  *((float *)this + 158) = a2;
  AABC::UpdateALSState((CFDictionaryRef *)this, 1);
}

uint64_t AABC::AutobrightnessOn_UpdateCurve(AABC *this)
{
  float LogicalBrightness;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  uint64_t inited;
  NSObject *v7;
  float v9;
  uint8_t v10[48];
  uint8_t v11[56];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  LogicalBrightness = DisplayGetLogicalBrightness(*((_QWORD *)this + 51));
  *((float *)this + 155) = LogicalBrightness;
  *((float *)this + 154) = LogicalBrightness;
  AABC::_UpdateEsensorTrusted(this, *((float *)this + 134));
  AAB::UpdateCurve_Block3((uint64_t)this, (uint64_t)this + 1048, *((float *)this + 136), *((float *)this + 139), *((float *)this + 155));
  if (_logHandle)
  {
    v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v7 = inited;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    if (*((float *)this + 136) <= *((float *)this + 7))
      v5 = "L1 & L2";
    else
      v5 = "E2 & L2";
    __os_log_helper_16_2_5_8_0_8_0_8_0_8_0_8_32((uint64_t)v11, COERCE__INT64(*((float *)this + 266)), COERCE__INT64(*((float *)this + 268)), COERCE__INT64(*((float *)this + 267)), COERCE__INT64(*((float *)this + 269)), (uint64_t)v5);
    _os_log_debug_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEBUG, "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f  [updated %s]", v11, 0x34u);
  }
  if (_logHandle)
  {
    v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      v3 = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      v3 = init_default_corebrightness_log();
    v4 = v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v10, COERCE__INT64(*((float *)this + 262)), COERCE__INT64(*((float *)this + 263)), COERCE__INT64(*((float *)this + 264)), COERCE__INT64(*((float *)this + 265)));
    _os_log_debug_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEBUG, "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v10, 0x2Au);
  }
  v9 = fminf(fmaxf(AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139)), *((float *)this + 180)), *((float *)this + 182));
  *((float *)this + 151) = v9;
  return AABC::UpdateDisplayBrightness_Block6((uint64_t)this, 0, 2, 0, v9);
}

void AABC::SetAutoBrightnessState(AABC *this, int a2)
{
  const char *v2;
  const char *v3;
  float LogicalBrightness;
  NSObject *v5;
  os_log_type_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t inited;
  NSObject *v17;
  uint8_t v19[15];
  os_log_type_t v20;
  os_log_t oslog;
  float v22;
  float v23;
  os_log_type_t v24;
  os_log_t v25;
  os_log_type_t v26;
  os_log_t v27;
  os_log_type_t v28;
  os_log_t v29;
  BOOL v30;
  os_log_type_t v31;
  os_log_t v32;
  int v33;
  AABC *v34;
  uint8_t v35[48];
  uint8_t v36[64];
  uint8_t v37[32];
  uint8_t v38[8];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v34 = this;
  v33 = a2;
  v32 = 0;
  if (_logHandle)
  {
    v17 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v17 = inited;
  }
  v32 = v17;
  v31 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v38, 4);
    _os_log_debug_impl(&dword_1B5291000, v32, v31, "[%x]: ", v38, 8u);
  }
  if (*((_DWORD *)this + 128) != v33)
  {
    if (*((_QWORD *)this + 521) && *((_DWORD *)this + 80) == 6)
    {
      v30 = v33 != 0;
      objc_msgSend(*((id *)this + 521), "sendCommand:inputBuffer:inputBufferSize:", 240, &v30, 1);
    }
    v29 = 0;
    if (_logHandle)
    {
      v15 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v14 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v14 = init_default_corebrightness_log();
      v15 = v14;
    }
    v29 = v15;
    v28 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      if (v33)
        v2 = "true";
      else
        v2 = "false";
      if (*((_DWORD *)this + 127))
        v3 = "true";
      else
        v3 = "false";
      __os_log_helper_16_2_2_8_32_8_32((uint64_t)v37, (uint64_t)v2, (uint64_t)v3);
      _os_log_impl(&dword_1B5291000, v29, v28, "autoBrightnessEnabled=%s _autoBrightnessActive=%s", v37, 0x16u);
    }
    if (v33 && *((_DWORD *)this + 127))
    {
      AABC::setAABCurveUpdateReason((uint64_t)this, 3u);
      LogicalBrightness = DisplayGetLogicalBrightness(*((_QWORD *)this + 51));
      *((float *)this + 155) = LogicalBrightness;
      *((float *)this + 154) = LogicalBrightness;
      AABC::_UpdateEsensorTrusted(this, *((float *)this + 134));
      v27 = 0;
      if (_logHandle)
      {
        v13 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v12 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v12 = init_default_corebrightness_log();
        v13 = v12;
      }
      v27 = v13;
      v26 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        if (*((float *)this + 136) <= *((float *)this + 7))
          v11 = "L1 & L2";
        else
          v11 = "E2 & L2";
        __os_log_helper_16_2_5_8_0_8_0_8_0_8_0_8_32((uint64_t)v36, COERCE__INT64(*((float *)this + 266)), COERCE__INT64(*((float *)this + 268)), COERCE__INT64(*((float *)this + 267)), COERCE__INT64(*((float *)this + 269)), (uint64_t)v11);
        _os_log_debug_impl(&dword_1B5291000, v27, v26, "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f  [updated %s]", v36, 0x34u);
      }
      v25 = 0;
      if (_logHandle)
      {
        v10 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v9 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v9 = init_default_corebrightness_log();
        v10 = v9;
      }
      v25 = v10;
      v24 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v35, COERCE__INT64(*((float *)this + 262)), COERCE__INT64(*((float *)this + 263)), COERCE__INT64(*((float *)this + 264)), COERCE__INT64(*((float *)this + 265)));
        _os_log_debug_impl(&dword_1B5291000, v25, v24, "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v35, 0x2Au);
      }
      AABC::UpdateState((uint64_t)this, 3);
      v23 = 0.0;
      v23 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139));
      if ((*((_BYTE *)this + 3417) & 1) != 0)
      {
        v22 = 0.0;
        v22 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 802, *((float *)this + 136), *((float *)this + 139));
        if ((*((_BYTE *)this + 3418) & 1) == 0)
          v23 = fminf(*((float *)this + 855), v22);
      }
      v23 = fminf(fmaxf(v23, *((float *)this + 180)), *((float *)this + 182));
      *((float *)this + 151) = v23;
      *((_DWORD *)this + 128) = v33;
      AABC::UpdateDisplayBrightness_Block6((uint64_t)this, 1, 2, 1, v23);
    }
    else
    {
      oslog = 0;
      if (_logHandle)
      {
        v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v7 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v7 = init_default_corebrightness_log();
        v8 = v7;
      }
      oslog = v8;
      v20 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        v5 = oslog;
        v6 = v20;
        __os_log_helper_16_0_0(v19);
        _os_log_debug_impl(&dword_1B5291000, v5, v6, "Cancel ramp, disabling auto-brightness", v19, 2u);
      }
      AABC::CancelRamp(this);
    }
    *((_DWORD *)this + 128) = v33;
    +[CBAnalytics autoBrightnessEnabled:byUser:](CBAnalytics, "autoBrightnessEnabled:byUser:", *((_DWORD *)this + 128) != 0, 1);
    *((_DWORD *)this + 128) = 1;
  }
}

uint64_t __os_log_helper_16_2_3_4_0_8_32_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 32;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_32_8_32_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 32;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  return result;
}

float AABC::IlluminanceToLuminanceAggregated_AOD(uint64_t a1, AAB *a2, float *a3, float a4)
{
  const CustomCurve *v4;
  uint64_t inited;
  NSObject *v7;
  float v8;
  float v9;
  float v10;
  uint8_t v13[56];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10 = AAB::IlluminanceToLuminance(a1, a3, a4);
  v9 = AAB::IlluminanceToLuminance(a2, a4, v4);
  v8 = fminf(v10, v9);
  if (_logHandle)
  {
    v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v7 = inited;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v13, COERCE__INT64(a4), COERCE__INT64(v10), COERCE__INT64(v9), COERCE__INT64(v8));
    _os_log_impl(&dword_1B5291000, v7, OS_LOG_TYPE_DEFAULT, "IlluminanceToLuminanceAggregated_AOD: E = %f | normal L = %f | AOD L = %f >>> L %f", v13, 0x2Au);
  }
  return v8;
}

float AABC::IlluminanceToLuminance(AABC *this, float a2, CustomCurve *a3)
{
  const CustomCurve *v3;

  if (AABC::isAODCurveActive((uint64_t)this, -[CBAODState AODState](+[CBAODState sharedInstance](CBAODState, "sharedInstance"), "AODState")))
  {
    return AABC::IlluminanceToLuminanceAggregated_AOD((uint64_t)this, (AABC *)((char *)this + 2540), (float *)this + 262, a2);
  }
  else
  {
    return AAB::IlluminanceToLuminance((AAB *)a3, a2, v3);
  }
}

float AABC::LuminanceToIlluminance(AABC *this, float a2, CustomCurve *a3)
{
  return fmaxf(0.0, AAB::LuminanceToIlluminance(this, a2, a3));
}

uint64_t __os_log_helper_16_0_10_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 10;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 62) = 0;
  *(_BYTE *)(result + 63) = 8;
  *(_QWORD *)(result + 64) = a8;
  *(_BYTE *)(result + 72) = 0;
  *(_BYTE *)(result + 73) = 8;
  *(_QWORD *)(result + 74) = a9;
  *(_BYTE *)(result + 82) = 0;
  *(_BYTE *)(result + 83) = 8;
  *(_QWORD *)(result + 84) = a10;
  *(_BYTE *)(result + 92) = 0;
  *(_BYTE *)(result + 93) = 4;
  *(_DWORD *)(result + 94) = a11;
  return result;
}

uint64_t AABCurveUpdateReasonToString(unsigned int a1)
{
  if (a1 <= 4uLL)
    __asm { BR              X8 }
  return 0;
}

uint64_t AABC::IsProxEmulationTriggered(AABC *this, int *a2)
{
  NSObject *v3;
  os_log_type_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t inited;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint8_t v14[15];
  os_log_type_t v15;
  os_log_t oslog;
  os_log_type_t v17;
  os_log_t v18;
  os_log_type_t v19;
  os_log_t v20;
  os_log_type_t v21;
  os_log_t v22;
  float v23;
  unsigned int v24;
  int *v25;
  AABC *v26;
  uint8_t v27[16];
  uint8_t v28[32];
  uint8_t v29[40];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v26 = this;
  v25 = a2;
  v24 = 0;
  v23 = 0.5;
  if (*((float *)this + 152) <= 250.0)
  {
    if (*((float *)this + 152) > 100.0)
      v23 = 0.4;
  }
  else
  {
    v23 = 0.2;
  }
  *v25 = 0;
  if (*((float *)this + 136) >= (float)(v23 * *((float *)this + 152)) || *((float *)this + 136) >= 200.0)
  {
    v18 = 0;
    if (_logHandle)
    {
      v8 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v8 = inited;
    }
    v18 = v8;
    v17 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v27, COERCE__INT64(*((float *)this + 136)));
      _os_log_debug_impl(&dword_1B5291000, v18, v17, "Unrestricting prox emulation. E_sensor = %f", v27, 0xCu);
    }
    if (*((_DWORD *)this + 141) == 1)
      *((float *)this + 154) = DisplayGetVirtualBrightness(*((float **)this + 51));
    *((_DWORD *)this + 141) = 0;
    *((_DWORD *)this + 153) = *((_DWORD *)this + 136);
  }
  else if (*((_DWORD *)this + 141)
         && (*((_DWORD *)this + 141) != 2
          || *((float *)this + 136) > (float)(*((float *)this + 153) / 2.0)
          || *((float *)this + 136) > (float)(*((float *)this + 153) - 5.0)))
  {
    if (*((_DWORD *)this + 141) == 1
      && *((float *)this + 136) > (float)(*((float *)this + 153) * 2.0)
      && *((float *)this + 136) > (float)(*((float *)this + 153) + 20.0))
    {
      v20 = 0;
      if (_logHandle)
      {
        v10 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v9 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v9 = init_default_corebrightness_log();
        v10 = v9;
      }
      v20 = v10;
      v19 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v28, COERCE__INT64(*((float *)this + 152)), COERCE__INT64(*((float *)this + 153)), COERCE__INT64(*((float *)this + 136)));
        _os_log_debug_impl(&dword_1B5291000, v20, v19, "ALS possibly covered. E_maximum = %f, E_low = %f, E_sensor = %f", v28, 0x20u);
      }
      *((float *)this + 154) = DisplayGetVirtualBrightness(*((float **)this + 51));
      *((_DWORD *)this + 141) = 2;
      *((_DWORD *)this + 153) = *((_DWORD *)this + 136);
    }
  }
  else
  {
    v22 = 0;
    if (_logHandle)
    {
      v12 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v11 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v11 = init_default_corebrightness_log();
      v12 = v11;
    }
    v22 = v12;
    v21 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v29, COERCE__INT64(*((float *)this + 152)), COERCE__INT64(*((float *)this + 153)), COERCE__INT64(*((float *)this + 136)));
      _os_log_debug_impl(&dword_1B5291000, v22, v21, "ALS covered. Triggering prox emulation. E_maximum = %f, E_low = %f, E_sensor = %f", v29, 0x20u);
    }
    *((_DWORD *)this + 141) = 1;
  }
  if (*((_DWORD *)this + 141) == 1)
  {
    oslog = 0;
    if (_logHandle)
    {
      v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v5 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v5 = init_default_corebrightness_log();
      v6 = v5;
    }
    oslog = v6;
    v15 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      v3 = oslog;
      v4 = v15;
      __os_log_helper_16_0_0(v14);
      _os_log_debug_impl(&dword_1B5291000, v3, v4, "Restricting because of ALS covered", v14, 2u);
    }
    *v25 = 1;
    v24 = 1;
    *((float *)this + 153) = fminf(*((float *)this + 153), *((float *)this + 136));
  }
  return v24;
}

void AABC::_UpdateNitsRestrictionsSinglePoint(AABC *this, float a2, float a3, char a4)
{
  float v4;
  float v5;
  float v6;
  uint64_t v7;
  NSObject *v8;
  char v9;
  BOOL v10;
  double v11;
  uint64_t v12;
  uint64_t inited;
  NSObject *v14;
  char isTrustedOccluded;
  BOOL v16;
  float v18;
  float v19;
  float v20;
  float v21;
  float RestrictionFactorTarget;
  float v23;
  float v24;
  float v25;
  float v26;
  char v27;
  float v28;
  uint8_t v29[32];
  uint8_t v30[24];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v28 = a3;
  v27 = a4 & 1;
  v26 = a2;
  v25 = a2;
  if (a3 < 0.0)
    v28 = 2.5;
  if (a2 < 0.0)
  {
    v25 = 0.0;
    v26 = 0.0;
  }
  if ((*((_BYTE *)this + 3472) & 1) != 0)
  {
    if (*((_DWORD *)this + 130))
      v24 = *((float *)this + 873);
    else
      v24 = *((float *)this + 872);
    if (v25 < *((float *)this + 870))
    {
      if (v25 >= *((float *)this + 871))
      {
        v4 = (v24 - 1.0)
           * (float)((float)(v25 - *((float *)this + 870)) + (float)(*((float *)this + 870) - *((float *)this + 871)))
           / (float)(*((float *)this + 870) - *((float *)this + 871))
           + 1.0;
        v23 = v4;
      }
      else
      {
        v23 = 1.0;
      }
    }
    else
    {
      v23 = v24;
    }
    RestrictionFactorTarget = DisplayGetRestrictionFactorTarget(*((_QWORD *)this + 51), 1);
    v16 = 0;
    if (v25 > *((float *)this + 869))
      v16 = RestrictionFactorTarget < v24;
    isTrustedOccluded = 0;
    if (v23 < RestrictionFactorTarget)
      isTrustedOccluded = AABC::isTrustedOccluded((id **)this);
    if ((v27 & 1) != 0 || (v23 < RestrictionFactorTarget || v16) && (isTrustedOccluded & 1) == 0)
    {
      if (_logHandle)
      {
        v14 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v14 = inited;
      }
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v30, COERCE__INT64(v23), COERCE__INT64(v25));
        _os_log_debug_impl(&dword_1B5291000, v14, OS_LOG_TYPE_DEBUG, "Set minimum restriction %f for E=%f\n", v30, 0x16u);
      }
      if (v16)
        DisplaySetRestrictionFactorWithFade(*((_QWORD *)this + 51), 1, v23, v28, COERCE_FLOAT(*((_QWORD *)this + 433)), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 433))));
      else
        DisplaySetRestrictionFactorWithFade(*((_QWORD *)this + 51), 1, v23, v28 * 2.0, COERCE_FLOAT(*((_QWORD *)this + 433)), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 433))));
    }
  }
  if ((*((_BYTE *)this + 3588) & 1) != 0)
  {
    v20 = *((float *)this + 898);
    if (*((_DWORD *)this + 130))
      v21 = *((float *)this + 902);
    else
      v21 = *((float *)this + 901);
    if ((objc_msgSend(*((id *)this + 508), "isActive") & 1) != 0)
    {
      v12 = *((_QWORD *)this + 51);
      objc_msgSend(*((id *)this + 508), "getCap");
      v21 = fminf(v21, DisplayGetRestrictionFactorForNits(v12, 0, v5));
      v20 = *((float *)this + 899);
    }
    if (v26 <= *((float *)this + 899))
      v11 = v21;
    else
      v11 = v21
          + (1.0 - v21)
          * (float)(v26 - *((float *)this + 899))
          / (float)(*((float *)this + 900) - *((float *)this + 899));
    v6 = v11;
    v19 = v6;
    if (v6 > 1.0)
      v19 = 1.0;
    v18 = DisplayGetRestrictionFactorTarget(*((_QWORD *)this + 51), 0);
    v10 = 0;
    if (v26 < v20)
      v10 = v18 > v21;
    v9 = 0;
    if (v19 <= v18)
      v9 = AABC::isTrustedOccluded((id **)this);
    if ((v27 & 1) != 0 || v19 > v18 || v10 && (v9 & 1) == 0)
    {
      if (_logHandle)
      {
        v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v7 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v7 = init_default_corebrightness_log();
        v8 = v7;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v29, COERCE__INT64(v19), COERCE__INT64(v26));
        _os_log_debug_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEBUG, "Set maximum restriction %f for E=%f\n", v29, 0x16u);
      }
      if (v10)
        DisplaySetRestrictionFactorWithFade(*((_QWORD *)this + 51), 0, v19, v28 * 2.0, COERCE_FLOAT(*((_QWORD *)this + 433)), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 433))));
      else
        DisplaySetRestrictionFactorWithFade(*((_QWORD *)this + 51), 0, v19, v28, COERCE_FLOAT(*((_QWORD *)this + 433)), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 433))));
    }
  }
}

uint64_t AABC::GetNitsBin(AABC *this, float a2)
{
  if (a2 >= 10.0)
  {
    if (a2 >= 75.0)
    {
      if (a2 >= 100.0)
      {
        if (a2 >= 125.0)
        {
          if (a2 >= 150.0)
          {
            if (a2 >= 250.0)
            {
              if (a2 >= 350.0)
              {
                if (a2 >= 450.0)
                {
                  if (a2 >= 550.0)
                    return 9;
                  else
                    return 8;
                }
                else
                {
                  return 7;
                }
              }
              else
              {
                return 6;
              }
            }
            else
            {
              return 5;
            }
          }
          else
          {
            return 4;
          }
        }
        else
        {
          return 3;
        }
      }
      else
      {
        return 2;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t __os_log_helper_16_2_3_4_0_8_0_8_32(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 32;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  return result;
}

uint64_t __os_log_helper_16_2_8_4_0_8_0_8_32_8_32_4_0_8_32_4_0_8_32(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, int a8, uint64_t a9)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 8;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 32;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 32;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 4;
  *(_DWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 44) = 32;
  *(_BYTE *)(result + 45) = 8;
  *(_QWORD *)(result + 46) = a7;
  *(_BYTE *)(result + 54) = 0;
  *(_BYTE *)(result + 55) = 4;
  *(_DWORD *)(result + 56) = a8;
  *(_BYTE *)(result + 60) = 32;
  *(_BYTE *)(result + 61) = 8;
  *(_QWORD *)(result + 62) = a9;
  return result;
}

uint64_t __os_log_helper_16_0_7_4_0_4_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 7;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 4;
  *(_DWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 14) = 0;
  *(_BYTE *)(result + 15) = 8;
  *(_QWORD *)(result + 16) = a4;
  *(_BYTE *)(result + 24) = 0;
  *(_BYTE *)(result + 25) = 8;
  *(_QWORD *)(result + 26) = a5;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 35) = 8;
  *(_QWORD *)(result + 36) = a6;
  *(_BYTE *)(result + 44) = 0;
  *(_BYTE *)(result + 45) = 8;
  *(_QWORD *)(result + 46) = a7;
  *(_BYTE *)(result + 54) = 0;
  *(_BYTE *)(result + 55) = 8;
  *(_QWORD *)(result + 56) = a8;
  return result;
}

uint64_t __os_log_helper_16_2_2_4_0_8_32(uint64_t result, int a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 32;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  return result;
}

void ___ZN4AABC20HandleDigitizerEventEP20__IOHIDServiceClientP12__IOHIDEvent_block_invoke(_QWORD *a1, uint64_t a2, id *a3)
{
  NSObject *log;
  os_log_type_t type;
  uint64_t inited;
  NSObject *v6;
  AABC *v7;
  uint8_t v8[15];
  os_log_type_t v9;
  NSObject *v10;
  CBHIDEvent *v11;
  _QWORD *v12;
  id *v13;
  uint64_t v14;
  _QWORD *v15;

  v15 = a1;
  v14 = a2;
  v13 = a3;
  v12 = a1;
  v7 = (AABC *)a1[4];
  if (a3)
  {
    if (v13[3])
    {
      v11 = 0;
      v11 = -[CBHIDEvent initWithHIDEvent:andService:]([CBHIDEvent alloc], "initWithHIDEvent:andService:", a1[5], a1[6]);
      objc_msgSend(v13[3], "filterEvent:", v11);

      if ((AABC::ALS::isTouchObstructed(v13) & 1) != 0 && v13 == *((id **)v7 + 57))
      {
        if (*((float *)v7 + 154) < *((float *)v7 + 155))
        {
          v10 = 0;
          if (_logHandle)
          {
            v6 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              inited = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              inited = init_default_corebrightness_log();
            v6 = inited;
          }
          v10 = v6;
          v9 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            log = v10;
            type = v9;
            __os_log_helper_16_0_0(v8);
            _os_log_impl(&dword_1B5291000, log, type, "Cancel ramp, touch mitigation", v8, 2u);
          }
          AABC::CancelRamp(v7);
        }
        DisplayCancelRestrictionFactorFade(*((_QWORD *)v7 + 51), 1);
      }
    }
  }
}

void AABC::RampDoneCallback(AABC *this)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t inited;
  NSObject *v4;
  objc_object *property;
  id v7;
  objc_object *v8;
  float DeviceBrightness;
  _DWORD v10[2];
  AABC *v11;
  uint8_t v12[16];
  uint8_t v13[40];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v11 = this;
  *((_BYTE *)this + 628) = 0;
  *((float *)this + 155) = DisplayGetVirtualBrightness(*((float **)this + 51));
  v10[1] = *((_DWORD *)this + 155);
  v10[0] = 1;
  DisplayUpdateAAPState(*((_QWORD *)this + 51), (uint64_t)v10, 1, 0);
  AABC::UpdateALSState((CFDictionaryRef *)this, 8);
  if (*((_DWORD *)this + 128) && *((_DWORD *)this + 127))
  {
    DeviceBrightness = DisplayGetDeviceBrightness(*((_QWORD *)this + 51));
    if (_logHandle)
    {
      v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v4 = inited;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v13, (uint64_t)"ALS", COERCE__INT64(DeviceBrightness), COERCE__INT64(*((float *)this + 155)));
      _os_log_impl(&dword_1B5291000, v4, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: End Ramp: L_device = %0.4f L_current = %0.4f", v13, 0x20u);
    }
  }
  else
  {
    if (_logHandle)
    {
      v2 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v1 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v1 = init_default_corebrightness_log();
      v2 = v1;
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v12, COERCE__INT64(*((float *)this + 155)));
      _os_log_debug_impl(&dword_1B5291000, v2, OS_LOG_TYPE_DEBUG, "End Ramp: _L_current = %0.4f", v12, 0xCu);
    }
  }
  if (*((_DWORD *)this + 717) == 2)
  {
    *((_DWORD *)this + 717) = 1;
    v8 = (objc_object *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", (int)(float)(*((float *)this + 155) * 65536.0));
    AABC::setAlwaysOnProperty((id *)this, CFSTR("CurrentBrightness"), v8);
    v7 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", *((unsigned int *)this + 717));
    property = (objc_object *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D80]), "initWithObjectsAndKeys:", v7, CFSTR("AOTState"), 0);
    AABC::setAlwaysOnProperty((id *)this, CFSTR("AOTState"), property);
    IOHIDServiceClientSetProperty(*((IOHIDServiceClientRef *)this + 41), CFSTR("AOTState"), property);

  }
  else if (*((_DWORD *)this + 717) == 3)
  {
    AABC::UpdateState((uint64_t)this, 2);
    AABC::BeginFastRampMode((CFAbsoluteTime *)this, *((float *)this + 853), 0.2);
    *((_DWORD *)this + 717) = 0;
  }
}

uint64_t __os_log_helper_16_2_6_4_0_8_0_8_32_8_32_8_0_4_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 6;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 32;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 32;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 49) = 4;
  *(_DWORD *)(result + 50) = a7;
  return result;
}

uint64_t __os_log_helper_16_2_6_4_0_4_0_8_32_8_0_8_0_8_0(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 6;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 4;
  *(_DWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 14) = 32;
  *(_BYTE *)(result + 15) = 8;
  *(_QWORD *)(result + 16) = a4;
  *(_BYTE *)(result + 24) = 0;
  *(_BYTE *)(result + 25) = 8;
  *(_QWORD *)(result + 26) = a5;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 35) = 8;
  *(_QWORD *)(result + 36) = a6;
  *(_BYTE *)(result + 44) = 0;
  *(_BYTE *)(result + 45) = 8;
  *(_QWORD *)(result + 46) = a7;
  return result;
}

uint64_t __os_log_helper_16_2_6_4_0_8_0_8_0_8_0_8_0_8_32(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 6;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 8;
  *(_QWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 48) = 32;
  *(_BYTE *)(result + 49) = 8;
  *(_QWORD *)(result + 50) = a7;
  return result;
}

uint64_t __os_log_helper_16_2_4_4_0_8_32_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 32;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  return result;
}

uint64_t __os_log_helper_16_2_3_4_0_8_32_8_32(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 32;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 32;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  return result;
}

void AABC::UpdateALSStateFunction(__IOHIDServiceClient *a1, AABC::ALS *a2, uint64_t *a3)
{
  if (*(_DWORD *)(*a3 + 648))
    AABC::UpdateALSStateFunctionInternalAutoRate(*a3, a1, (uint64_t)a2, (int *)a3);
  else
    AABC::UpdateALSStateFunctionInternalNoAutoRate(*a3, a1, a2, (float *)a3);
}

void AABC::UpdateALSStateFunctionInternalAutoRate(uint64_t a1, __IOHIDServiceClient *a2, uint64_t a3, int *a4)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t inited;
  NSObject *v14;
  int v16;
  os_log_type_t v17;
  os_log_t v18;
  os_log_type_t v19;
  os_log_t v20;
  float v21;
  float v22;
  int valuePtr;
  os_log_type_t v24;
  os_log_t v25;
  CFNumberRef v26;
  CFNumberRef v27;
  os_log_type_t v28;
  os_log_t v29;
  int *v30;
  uint64_t v31;
  IOHIDServiceClientRef v32;
  uint64_t v33;
  uint8_t v34[16];
  uint8_t v35[32];
  uint8_t v36[16];
  uint8_t v37[16];
  uint8_t v38[24];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v33 = a1;
  v32 = a2;
  v31 = a3;
  v30 = a4;
  if (a4 && *(_QWORD *)v30 && *(_DWORD *)(*(_QWORD *)v30 + 372))
  {
    v29 = 0;
    if (_logHandle)
    {
      v14 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v14 = inited;
    }
    v29 = v14;
    v28 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_3_4_0_4_0_4_0((uint64_t)v38, 16, v30[12], *(_DWORD *)(a1 + 488));
      _os_log_debug_impl(&dword_1B5291000, v29, v28, "[%x]: function=%x _displayState=%d", v38, 0x14u);
    }
    v27 = 0;
    if ((v30[12] & 1) != 0 && *(_DWORD *)(a1 + 644) != 1)
    {
      *(_DWORD *)(a1 + 644) = 1;
      v26 = 0;
      v26 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (const void *)(a1 + 644));
      if (v26)
      {
        IOHIDServiceClientSetProperty(v32, CFSTR("IOHIDALSContinuousMode"), v26);
        CFRelease(v26);
      }
    }
    if ((v30[12] & 4) != 0)
    {
      v27 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, v30 + 4);
      if (v27)
      {
        v25 = 0;
        if (_logHandle)
        {
          v12 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v11 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v11 = init_default_corebrightness_log();
          v12 = v11;
        }
        v25 = v12;
        v24 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_4_0((uint64_t)v37, 16, v30[4]);
          _os_log_debug_impl(&dword_1B5291000, v25, v24, "[%x]: setting \"IOHIDALSTestMode\" %d", v37, 0xEu);
        }
        IOHIDServiceClientSetProperty(v32, CFSTR("IOHIDALSTestMode"), v27);
        CFRelease(v27);
      }
    }
    if ((v30[12] & 0x10) != 0)
    {
      valuePtr = 0;
      valuePtr = *(_DWORD *)(a1 + 668);
      v27 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
      if (v27)
      {
        IOHIDServiceClientSetProperty(v32, CFSTR("ALSIntegrationMode"), v27);
        CFRelease(v27);
      }
      if (*(_DWORD *)(a1 + 668) != *(_DWORD *)(a1 + 664))
      {
        *(_DWORD *)(a1 + 664) = *(_DWORD *)(a1 + 668);
        v22 = 0.0;
        v21 = 0.0;
        switch(*(_DWORD *)(a1 + 668))
        {
          case 3:
            v22 = *(float *)(a1 + 652);
            v21 = *(float *)(v31 + 48);
            break;
          case 2:
            v22 = *(float *)(a1 + 656);
            v21 = *(float *)(v31 + 44);
            break;
          case 1:
            v22 = *(float *)(a1 + 660);
            v21 = *(float *)(v31 + 40);
            break;
          default:
            if (*(_DWORD *)(a1 + 668))
            {
              v20 = 0;
              if (_logHandle)
              {
                v10 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                  v9 = _COREBRIGHTNESS_LOG_DEFAULT;
                else
                  v9 = init_default_corebrightness_log();
                v10 = v9;
              }
              v20 = v10;
              v19 = OS_LOG_TYPE_DEBUG;
              if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
              {
                __os_log_helper_16_0_1_4_0((uint64_t)v36, 1);
                _os_log_debug_impl(&dword_1B5291000, v20, v19, "[%x]: INVALID Integration mode. Behaviour undefined!", v36, 8u);
              }
              *(_DWORD *)(v31 + 80) = 0;
              *(_DWORD *)(a1 + 3960) = 1;
            }
            else
            {
              *(_DWORD *)(a1 + 600) = 0;
              *(float *)(a1 + 544) = -1.0;
              *(float *)(a1 + 548) = -1.0;
              *(float *)(a1 + 540) = -1.0;
              *(_DWORD *)(a1 + 556) = 0;
              *(float *)(a1 + 552) = -1.0;
              AABC::_UpdateSemanticAmbientLightLevel(a1, 0);
              *(_DWORD *)(v31 + 156) = 0;
              *(_DWORD *)(a1 + 624) = 0;
            }
            break;
        }
        if (v22 <= 0.0)
        {
          *(_DWORD *)(v31 + 80) = 0;
          *(_DWORD *)(a1 + 3960) = v21 > 0.0;
          *(float *)(a1 + 632) = v21;
          *(_DWORD *)(a1 + 3968) = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 3960) = (float)(7.0 / v22);
          *(_DWORD *)(v31 + 80) = (float)(*(float *)(a1 + 3444) / v22);
          *(float *)(a1 + 632) = v22;
          *(_DWORD *)(a1 + 3968) = (int)(4.0 / v22);
        }
        if (*(_QWORD *)(a1 + 3976))
        {
          v8 = *(_QWORD *)(a1 + 3976);
          if (v8)
            MEMORY[0x1B5E4A400](v8, 0x1000C4052888210);
          *(_QWORD *)(a1 + 3976) = 0;
        }
        *(_DWORD *)(a1 + 3952) = 0;
        *(_DWORD *)(a1 + 3956) = 0;
        if (*(_DWORD *)(a1 + 3960))
        {
          is_mul_ok(*(unsigned int *)(a1 + 3960), 4uLL);
          *(_QWORD *)(a1 + 3976) = operator new[]();
        }
        std::vector<float>::resize((uint64_t *)(v31 + 88), 0);
        *(_DWORD *)(v31 + 72) = 0;
        *(_DWORD *)(v31 + 76) = 0;
        std::vector<float>::resize((uint64_t *)(v31 + 88), *(unsigned int *)(v31 + 80));
        *(_DWORD *)(a1 + 3964) = *(_DWORD *)(a1 + 3968);
        v18 = 0;
        if (_logHandle)
        {
          v7 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v6 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v6 = init_default_corebrightness_log();
          v7 = v6;
        }
        v18 = v7;
        v17 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_5_4_0_4_0_4_0_4_0_4_0((uint64_t)v35, 16, *(_DWORD *)(v31 + 4), *(_DWORD *)(a1 + 668), *(_DWORD *)(a1 + 3960), *(_DWORD *)(v31 + 80));
          _os_log_debug_impl(&dword_1B5291000, v18, v17, "[%x]: als->orientation=%d - _als.integrationMode=%d, _Lhistory_max=%u als->_Ehistory_max=%u", v35, 0x20u);
        }
      }
    }
    if ((v30[12] & 8) != 0)
    {
      v16 = 0;
      v16 = (int)(float)(*(float *)(a1 + 620) * 65536.0);
      v27 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &v16);
      if (v27)
      {
        if (_logHandle)
        {
          v5 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v4 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v4 = init_default_corebrightness_log();
          v5 = v4;
        }
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_4_0((uint64_t)v34, 16, v30[3]);
          _os_log_debug_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEBUG, "[%x]: setting kIOHIDBacklightLevel %d", v34, 0xEu);
        }
        IOHIDServiceClientSetProperty(v32, CFSTR("IOHIDBacklightLevel"), v27);
        CFRelease(v27);
      }
    }
  }
  else if (v30 && *(_QWORD *)v30 && !*(_DWORD *)(*(_QWORD *)v30 + 372) && !*(_DWORD *)(a1 + 668))
  {
    *(_DWORD *)(a1 + 3960) = 0;
    *(_DWORD *)(a1 + 600) = 0;
    *(float *)(a1 + 544) = -1.0;
    *(float *)(a1 + 548) = -1.0;
    *(float *)(a1 + 540) = -1.0;
    *(_DWORD *)(a1 + 556) = 0;
    *(float *)(a1 + 552) = -1.0;
    *(_DWORD *)(a1 + 624) = 0;
    *(_DWORD *)(a1 + 3968) = 0;
  }
}

void AABC::UpdateALSStateFunctionInternalNoAutoRate(uint64_t a1, __IOHIDServiceClient *a2, AABC::ALS *a3, float *a4)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t inited;
  NSObject *v14;
  int v16;
  int v17;
  unsigned int v18;
  os_log_type_t v19;
  os_log_t oslog;
  os_log_type_t v21;
  os_log_t v22;
  unsigned int valuePtr;
  os_log_type_t v24;
  os_log_t v25;
  int v26;
  const char *v27;
  CFNumberRef v28;
  CFNumberRef v29;
  os_log_type_t v30;
  os_log_t v31;
  float *v32;
  AABC::ALS *v33;
  __IOHIDServiceClient *v34;
  uint64_t v35;
  uint8_t v36[16];
  uint8_t v37[16];
  uint8_t v38[32];
  uint8_t v39[32];
  uint8_t v40[24];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v35 = a1;
  v34 = a2;
  v33 = a3;
  v32 = a4;
  if (a4 && *(_QWORD *)v32 && *(_DWORD *)(*(_QWORD *)v32 + 372))
  {
    v31 = 0;
    if (_logHandle)
    {
      v14 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        inited = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        inited = init_default_corebrightness_log();
      v14 = inited;
    }
    v31 = v14;
    v30 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_3_4_0_4_0_4_0((uint64_t)v40, 16, *((_DWORD *)v32 + 12), *(_DWORD *)(a1 + 488));
      _os_log_debug_impl(&dword_1B5291000, v31, v30, "[%x]: function=%x _displayState=%d", v40, 0x14u);
    }
    if ((*(_BYTE *)(a1 + 445) & 1) != 0)
      AABC::lazyLoadIntegrationTimes((AABC *)a1, v34, v33);
    v29 = 0;
    if (((_DWORD)v32[12] & 1) != 0)
    {
      if (*(_DWORD *)(a1 + 644) != 1)
      {
        *(_DWORD *)(a1 + 644) = 1;
        v28 = 0;
        v28 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, (const void *)(a1 + 644));
        if (v28)
        {
          IOHIDServiceClientSetProperty(v34, CFSTR("IOHIDALSContinuousMode"), v28);
          CFRelease(v28);
        }
      }
      if (v32[2] != *((float *)v33 + 38))
      {
        *((float *)v33 + 38) = v32[2];
        v27 = "";
        v26 = 0;
        if (*((float *)v33 + 38) == *((float *)v33 + 10))
        {
          v27 = "(super-fast mode)";
        }
        else if (*((float *)v33 + 38) == *((float *)v33 + 11))
        {
          v27 = "(fast mode)";
          v26 = 2;
        }
        else if (*((float *)v33 + 38) == *((float *)v33 + 12))
        {
          v27 = "(slow mode)";
        }
        v25 = 0;
        if (_logHandle)
        {
          v12 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v11 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v11 = init_default_corebrightness_log();
          v12 = v11;
        }
        v25 = v12;
        v24 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_2_2_8_0_8_34((uint64_t)v39, COERCE__INT64(*((float *)v33 + 38)), (uint64_t)v27);
          _os_log_impl(&dword_1B5291000, v25, v24, "setting report interval: %fs %{public}s", v39, 0x16u);
        }
        valuePtr = 0;
        valuePtr = (float)(*((float *)v33 + 38) * 1000000.0);
        v29 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
        if (v29)
        {
          IOHIDServiceClientSetProperty(v34, CFSTR("ReportInterval"), v29);
          CFRelease(v29);
        }
        if (*((float *)v33 + 38) <= 0.0)
        {
          *(_DWORD *)(a1 + 3960) = 0;
          *((_DWORD *)v33 + 20) = 0;
          *(_DWORD *)(a1 + 600) = 0;
          *(float *)(a1 + 544) = -1.0;
          *(float *)(a1 + 548) = -1.0;
          *(float *)(a1 + 540) = -1.0;
          *(_DWORD *)(a1 + 556) = 0;
          *(float *)(a1 + 552) = -1.0;
          AABC::_UpdateSemanticAmbientLightLevel(a1, 0);
          *((_DWORD *)v33 + 39) = 0;
          *(_DWORD *)(a1 + 624) = 0;
          *(_DWORD *)(a1 + 3968) = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 3960) = (float)(7.0 / *(float *)(a1 + 632));
          if (v26 <= 0)
            *((_DWORD *)v33 + 20) = (float)(*(float *)(a1 + 3444) / *(float *)(a1 + 632));
          else
            *((_DWORD *)v33 + 20) = v26;
          *(_DWORD *)(a1 + 3968) = (int)(4.0 / *(float *)(a1 + 632));
        }
        v22 = 0;
        if (_logHandle)
        {
          v10 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v9 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v9 = init_default_corebrightness_log();
          v10 = v9;
        }
        v22 = v10;
        v21 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_4_4_0_8_0_4_0_4_0((uint64_t)v38, 16, COERCE__INT64(*((float *)v33 + 38)), *(_DWORD *)(a1 + 3960), *((_DWORD *)v33 + 20));
          _os_log_debug_impl(&dword_1B5291000, v22, v21, "[%x]: als->_alsCurrentInterval=%f, _Lhistory_max=%u als->_Ehistory_max=%u", v38, 0x1Eu);
        }
        if (*(_QWORD *)(a1 + 3976))
        {
          v8 = *(_QWORD *)(a1 + 3976);
          if (v8)
            MEMORY[0x1B5E4A400](v8, 0x1000C4052888210);
          *(_QWORD *)(a1 + 3976) = 0;
        }
        std::vector<float>::resize((uint64_t *)v33 + 11, 0);
        *((_DWORD *)v33 + 18) = 0;
        *((_DWORD *)v33 + 19) = 0;
        std::vector<float>::resize((uint64_t *)v33 + 11, *((unsigned int *)v33 + 20));
        *(_DWORD *)(a1 + 3952) = 0;
        *(_DWORD *)(a1 + 3956) = 0;
        if (*(_DWORD *)(a1 + 3960))
        {
          is_mul_ok(*(unsigned int *)(a1 + 3960), 4uLL);
          *(_QWORD *)(a1 + 3976) = operator new[]();
        }
        *(_DWORD *)(a1 + 3964) = *(_DWORD *)(a1 + 3968);
      }
    }
    if (((_DWORD)v32[12] & 4) != 0)
    {
      v29 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, v32 + 4);
      if (v29)
      {
        oslog = 0;
        if (_logHandle)
        {
          v7 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v6 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v6 = init_default_corebrightness_log();
          v7 = v6;
        }
        oslog = v7;
        v19 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_4_0((uint64_t)v37, 16, *((_DWORD *)v32 + 4));
          _os_log_debug_impl(&dword_1B5291000, oslog, v19, "[%x]: setting \"IOHIDALSTestMode\" %d", v37, 0xEu);
        }
        IOHIDServiceClientSetProperty(v34, CFSTR("IOHIDALSTestMode"), v29);
        CFRelease(v29);
      }
      if (*((_DWORD *)v32 + 4))
      {
        if (*(float *)(*(_QWORD *)v32 + 492) > 0.0 && *((float *)v33 + 38) < 0.05)
        {
          *((_DWORD *)v33 + 38) = 1045220557;
          v18 = 0;
          v18 = (float)(*((float *)v33 + 38) * 1000000.0);
          v29 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &v18);
          if (v29)
          {
            IOHIDServiceClientSetProperty(v34, CFSTR("ReportInterval"), v29);
            CFRelease(v29);
          }
        }
      }
    }
    if (((_DWORD)v32[12] & 0x10) != 0)
    {
      v17 = 0;
      v17 = *(_DWORD *)(a1 + 668);
      v29 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &v17);
      if (v29)
      {
        IOHIDServiceClientSetProperty(v34, CFSTR("ALSIntegrationMode"), v29);
        CFRelease(v29);
      }
    }
    if (((_DWORD)v32[12] & 8) != 0)
    {
      v16 = 0;
      v16 = (int)(float)(*(float *)(a1 + 620) * 65536.0);
      v29 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &v16);
      if (v29)
      {
        if (_logHandle)
        {
          v5 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v4 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v4 = init_default_corebrightness_log();
          v5 = v4;
        }
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_4_0((uint64_t)v36, 16, *((_DWORD *)v32 + 3));
          _os_log_debug_impl(&dword_1B5291000, v5, OS_LOG_TYPE_DEBUG, "[%x]: setting kIOHIDBacklightLevel %d", v36, 0xEu);
        }
        IOHIDServiceClientSetProperty(v34, CFSTR("IOHIDBacklightLevel"), v29);
        CFRelease(v29);
      }
    }
  }
  else if (v32 && *(_QWORD *)v32 && !*(_DWORD *)(*(_QWORD *)v32 + 372) && v32[2] <= 0.0)
  {
    *(_DWORD *)(a1 + 3960) = 0;
    *(_DWORD *)(a1 + 600) = 0;
    *(float *)(a1 + 544) = -1.0;
    *(float *)(a1 + 548) = -1.0;
    *(float *)(a1 + 540) = -1.0;
    *(_DWORD *)(a1 + 556) = 0;
    *(float *)(a1 + 552) = -1.0;
    *(_DWORD *)(a1 + 624) = 0;
    *(_DWORD *)(a1 + 3968) = 0;
  }
}

uint64_t __os_log_helper_16_0_5_4_0_4_0_4_0_4_0_4_0(uint64_t result, int a2, int a3, int a4, int a5, int a6)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 5;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 4;
  *(_DWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 14) = 0;
  *(_BYTE *)(result + 15) = 4;
  *(_DWORD *)(result + 16) = a4;
  *(_BYTE *)(result + 20) = 0;
  *(_BYTE *)(result + 21) = 4;
  *(_DWORD *)(result + 22) = a5;
  *(_BYTE *)(result + 26) = 0;
  *(_BYTE *)(result + 27) = 4;
  *(_DWORD *)(result + 28) = a6;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_0_8_34(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 34;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  return result;
}

uint64_t __os_log_helper_16_0_4_4_0_8_0_4_0_4_0(uint64_t result, int a2, uint64_t a3, int a4, int a5)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 4;
  *(_DWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 24) = 0;
  *(_BYTE *)(result + 25) = 4;
  *(_DWORD *)(result + 26) = a5;
  return result;
}

void *AABC::SetUpdateStrategy(AABC *this, AAB::UpdateCurveStrategy *a2)
{
  int v2;
  int v4;
  int v5;
  int v6;
  uint64_t inited;
  NSObject *v8;
  uint8_t v11[40];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (_logHandle)
  {
    v8 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v8 = inited;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 8) + 104))(*((_QWORD *)this + 8));
    v5 = (*(uint64_t (**)(AAB::UpdateCurveStrategy *))(*(_QWORD *)a2 + 104))(a2);
    v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 8) + 112))(*((_QWORD *)this + 8));
    v2 = (*(uint64_t (**)(AAB::UpdateCurveStrategy *))(*(_QWORD *)a2 + 112))(a2);
    __os_log_helper_16_0_4_4_0_4_0_4_0_4_0((uint64_t)v11, v4, v5, v6, v2);
    _os_log_impl(&dword_1B5291000, v8, OS_LOG_TYPE_DEFAULT, "Change curve update strategies! Curve type: %d => %d, Alternative curve type: %d => %d", v11, 0x1Au);
  }
  AAB::SetUpdateStrategy(this, a2);
  AABC::AlignCurveTypeWithStrategy((uint64_t)this, (_DWORD *)this + 262, (_DWORD *)this + 750);
  return AABC::AlignCurveTypeWithStrategy((uint64_t)this, (_DWORD *)this + 724, (_DWORD *)this + 776);
}

uint64_t __os_log_helper_16_0_3_4_0_8_0_4_0(uint64_t result, int a2, uint64_t a3, int a4)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 4;
  *(_DWORD *)(result + 20) = a4;
  return result;
}

uint64_t __os_log_helper_16_0_6_4_0_4_0_4_0_4_0_4_0_4_0(uint64_t result, int a2, int a3, int a4, int a5, int a6, int a7)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 6;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 4;
  *(_DWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 14) = 0;
  *(_BYTE *)(result + 15) = 4;
  *(_DWORD *)(result + 16) = a4;
  *(_BYTE *)(result + 20) = 0;
  *(_BYTE *)(result + 21) = 4;
  *(_DWORD *)(result + 22) = a5;
  *(_BYTE *)(result + 26) = 0;
  *(_BYTE *)(result + 27) = 4;
  *(_DWORD *)(result + 28) = a6;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 4;
  *(_DWORD *)(result + 34) = a7;
  return result;
}

uint64_t ___ZN4AABC20InitializeCPMSModuleEv_block_invoke_2()
{
  uint64_t v1;
  id v2;
  uint64_t v3;
  _QWORD v4[2];

  v4[1] = *MEMORY[0x1E0C80C00];
  v2 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB37E8]), "initWithInt:", 1);
  v3 = *MEMORY[0x1E0D09978];
  v4[0] = v2;
  v1 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v4, &v3, 1);

  return v1;
}

void AABC::handleAODStateUpdate(uint64_t a1, uint64_t a2, void *a3, float a4)
{
  uint64_t v4;
  float v5;
  float v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  PerceptualLuminanceThresholding_1nit *v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  PerceptualLuminanceThresholding_legacy *v23;
  uint64_t v24;
  uint64_t inited;
  NSObject *v26;
  _QWORD v28[2];
  os_log_type_t v29;
  os_log_t v30;
  float v31;
  os_log_type_t v32;
  os_log_t v33;
  id v34;
  float v35;
  os_log_type_t v36;
  os_log_t v37;
  float v38;
  os_log_type_t v39;
  os_log_t v40;
  os_log_type_t v41;
  os_log_t v42;
  os_log_type_t v43;
  os_log_t oslog;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  id v50;
  float v51;
  float v52;
  float PhysicalBrightness;
  _QWORD v54[2];
  os_log_type_t type;
  os_log_t v56;
  id v57;
  float v58;
  uint64_t v59;
  uint64_t v60;
  uint8_t v61[16];
  uint8_t v62[48];
  uint8_t v63[32];
  uint8_t v64[32];
  uint8_t v65[64];
  uint8_t v66[64];
  uint8_t v67[24];
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  v60 = a1;
  v59 = a2;
  v58 = a4;
  v57 = a3;
  v56 = 0;
  if (_logHandle)
  {
    v26 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
      inited = _COREBRIGHTNESS_LOG_DEFAULT;
    else
      inited = init_default_corebrightness_log();
    v26 = inited;
  }
  v56 = v26;
  type = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v67, v59, COERCE__INT64(v58));
    _os_log_impl(&dword_1B5291000, v56, type, "[AOD state] Update: %lu, transition time %f", v67, 0x16u);
  }
  switch(v59)
  {
    case 2:
      *(_DWORD *)(a1 + 3948) = 0;
      if (*(_DWORD *)(a1 + 676))
        AABC::CancelFastRampMode((CFAbsoluteTime *)a1);
      AABC::CancelRamp((AABC *)a1);
      v54[0] = std::bitset<3ul>::operator[][abi:ne180100](a1 + 304, 0);
      v54[1] = v4;
      std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator=[abi:ne180100]((uint64_t)v54, 1);
      AABC::evaluateAABRearConditions((id *)a1);
      if (*(_DWORD *)(a1 + 4024) == 1)
      {
        if (!*(_QWORD *)(a1 + 4016))
          __assert_rtn("handleAODStateUpdate", "AABC.mm", 10601, "_plt_logic");
        v24 = *(_QWORD *)(a1 + 4016);
        if (v24)
          (*(void (**)(uint64_t))(*(_QWORD *)v24 + 24))(v24);
        v23 = (PerceptualLuminanceThresholding_legacy *)operator new();
        PerceptualLuminanceThresholding_legacy::PerceptualLuminanceThresholding_legacy(v23, *(_DWORD *)(a1 + 568), *(float *)(a1 + 3452), *(float *)(a1 + 3448), *(_BYTE *)(a1 + 136) & 1);
        *(_QWORD *)(a1 + 4016) = v23;
      }
      break;
    case 3:
      *(float *)(a1 + 620) = DisplayGetLogicalBrightness(*(_QWORD *)(a1 + 408));
      PhysicalBrightness = 0.0;
      PhysicalBrightness = DisplayGetPhysicalBrightness(*(_QWORD *)(a1 + 408));
      v52 = 0.0;
      v52 = AABC::IlluminanceToLuminance((AABC *)a1, *(float *)(a1 + 556), (CustomCurve *)(a1 + 2540));
      v51 = PhysicalBrightness;
      if (v57)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v50 = (id)objc_msgSend(v57, "objectForKey:", CFSTR("NitsPhysical"));
          if (v50)
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              objc_msgSend(v50, "floatValue");
              v51 = v5;
            }
          }
        }
      }
      if (v52 < v51)
      {
        -[CBAODState AODTransitionTargetAlgoOptimised_dimmingThreshold](+[CBAODState sharedInstance](CBAODState, "sharedInstance"), "AODTransitionTargetAlgoOptimised_dimmingThreshold");
        v49 = v6;
        v48 = 0.0;
        v48 = DisplayLuminanceToPerceptualLuminance(*(_QWORD *)(a1 + 408), v51);
        v47 = 0.0;
        v47 = DisplayLuminanceToPerceptualLuminance(*(_QWORD *)(a1 + 408), v52);
        if (vabds_f32(v48, v47) > v49)
        {
          v46 = fmaxf(v48 - v49, 0.0);
          v45 = 0.0;
          v45 = DisplayPerceptualLuminanceToLuminance(*(_QWORD *)(a1 + 408), v46);
          oslog = 0;
          if (_logHandle)
          {
            v22 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
              v21 = _COREBRIGHTNESS_LOG_DEFAULT;
            else
              v21 = init_default_corebrightness_log();
            v22 = v21;
          }
          oslog = v22;
          v43 = OS_LOG_TYPE_INFO;
          if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
          {
            __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v66, COERCE__INT64(v48), COERCE__INT64(v47), COERCE__INT64(v52), COERCE__INT64(v49), COERCE__INT64(v46), COERCE__INT64(v45));
            _os_log_impl(&dword_1B5291000, oslog, v43, "[AOD state][Entering] cP=%f | tP=%f | tNits=%f | thrP=%f | adj_tP=%f | adj_nits=%f", v66, 0x3Eu);
          }
          v52 = v45;
        }
      }
      v52 = clamp(v52, *(float *)(a1 + 720), PhysicalBrightness);
      *(float *)(a1 + 624) = AABC::LuminanceToIlluminance((AABC *)a1, v52, (CustomCurve *)(a1 + 2540));
      *(_DWORD *)(a1 + 2872) = *(_DWORD *)(a1 + 620);
      *(float *)(a1 + 620) = v52;
      v42 = 0;
      if (_logHandle)
      {
        v20 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v19 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v19 = init_default_corebrightness_log();
        v20 = v19;
      }
      v42 = v20;
      v41 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v65, COERCE__INT64(v52), COERCE__INT64(*(float *)(a1 + 556)), COERCE__INT64(v51), COERCE__INT64(*(float *)(a1 + 544)), COERCE__INT64(*(float *)(a1 + 556)));
        _os_log_impl(&dword_1B5291000, v42, v41, "[AOD state][Entering] Target AOD Nits %f for lux %f (Physical Nits = %f, Trusted Lux = %f, Capped Trusted Lux = %f)", v65, 0x34u);
      }
      v40 = 0;
      if (_logHandle)
      {
        v18 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v17 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v17 = init_default_corebrightness_log();
        v18 = v17;
      }
      v40 = v18;
      v39 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        __os_log_helper_16_0_3_4_0_4_0_4_0((uint64_t)v64, *(_DWORD *)(a1 + 512), *(_DWORD *)(a1 + 508), *(_DWORD *)(a1 + 520));
        _os_log_impl(&dword_1B5291000, v40, v39, "[AOD state][Entering] AB enabled = %d, active = %d, do not update curve = %d", v64, 0x14u);
      }
      if (*(_DWORD *)(a1 + 520))
        DisplaySetLogicalBrightnessWithFade(*(_QWORD *)(a1 + 408), 12296, (uint64_t)AABC::_RampDoneCallback, a1, v52, v58);
      else
        AABC::SetBrightness((AABC *)a1, v52, v58, 10, (void (*)(void *))AABC::_RampDoneCallback, a1);
      AABC::logAODCurveToPowerLog((AABC *)a1);
      break;
    case 1:
      if (!*(_DWORD *)(a1 + 520))
      {
        v38 = 0.0;
        v38 = AABC::IlluminanceToLuminance((AABC *)a1, *(float *)(a1 + 556), (CustomCurve *)(a1 + 2540));
        *(float *)(a1 + 2872) = DisplayGetLogicalBrightness(*(_QWORD *)(a1 + 408));
        *(float *)(a1 + 620) = v38;
        v37 = 0;
        if (_logHandle)
        {
          v16 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v15 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v15 = init_default_corebrightness_log();
          v16 = v15;
        }
        v37 = v16;
        v36 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v63, COERCE__INT64(v38), COERCE__INT64(*(float *)(a1 + 556)));
          _os_log_impl(&dword_1B5291000, v37, v36, "[AOD state][On] Perform update - target AOD Nits %f for trusted lux %f", v63, 0x16u);
        }
        AABC::SetBrightness((AABC *)a1, v38, v58, 10, (void (*)(void *))AABC::_RampDoneCallback, a1);
        *(float *)(a1 + 616) = v38;
        *(_DWORD *)(a1 + 624) = *(_DWORD *)(a1 + 556);
      }
      *(_BYTE *)(a1 + 3320) = 0;
      break;
    case 4:
      v35 = 0.0;
      if (*(_DWORD *)(a1 + 4024) == 1)
      {
        if (!*(_QWORD *)(a1 + 4016))
          __assert_rtn("handleAODStateUpdate", "AABC.mm", 10702, "_plt_logic");
        v14 = *(_QWORD *)(a1 + 4016);
        if (v14)
          (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
        v13 = (PerceptualLuminanceThresholding_1nit *)operator new();
        PerceptualLuminanceThresholding_1nit::PerceptualLuminanceThresholding_1nit(v13, *(_DWORD *)(a1 + 568), *(float *)(a1 + 3452), *(float *)(a1 + 3448), *(_BYTE *)(a1 + 136) & 1);
        *(_QWORD *)(a1 + 4016) = v13;
      }
      *(float *)(a1 + 620) = DisplayGetLogicalBrightness(*(_QWORD *)(a1 + 408));
      if (v57)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v34 = (id)objc_msgSend(v57, "objectForKey:", CFSTR("NitsPhysical"));
          if (v34)
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              objc_msgSend(v34, "floatValue");
              *(_DWORD *)(a1 + 620) = v7;
            }
          }
        }
      }
      v35 = AABC::IlluminanceToLuminance(a1, (float *)(a1 + 1048), *(float *)(a1 + 544), *(float *)(a1 + 556));
      v35 = clamp(v35, *(float *)(a1 + 620), *(float *)(a1 + 728));
      v33 = 0;
      if (_logHandle)
      {
        v12 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v11 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v11 = init_default_corebrightness_log();
        v12 = v11;
      }
      v33 = v12;
      v32 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v62, COERCE__INT64(v35), COERCE__INT64(*(float *)(a1 + 556)), COERCE__INT64(*(float *)(a1 + 544)), COERCE__INT64(*(float *)(a1 + 556)));
        _os_log_impl(&dword_1B5291000, v33, v32, "[AOD state][Exiting] Normal mode Nits = %f for lux %f (Trusted Lux = %f, Capped Trusted Lux = %f)", v62, 0x2Au);
      }
      *(float *)(a1 + 616) = v35;
      AABC::SetBrightness((AABC *)a1, v35, v58, 10, (void (*)(void *))AABC::_RampDoneCallback, a1);
      break;
    case 0:
      if (!*(_DWORD *)(a1 + 520))
      {
        v31 = 0.0;
        v31 = AABC::IlluminanceToLuminance(a1, (float *)(a1 + 1048), *(float *)(a1 + 544), *(float *)(a1 + 556));
        v30 = 0;
        if (_logHandle)
        {
          v10 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v9 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v9 = init_default_corebrightness_log();
          v10 = v9;
        }
        v30 = v10;
        v29 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v61, COERCE__INT64(v31));
          _os_log_impl(&dword_1B5291000, v30, v29, "[AOD state][Off]  Display brightness should be on %f", v61, 0xCu);
        }
        AABC::UpdateState(a1, 2);
        if ((*(_BYTE *)(a1 + 3320) & 1) == 1)
          AABC::BeginFastRampMode((CFAbsoluteTime *)a1, 4.0, 0.2);
        else
          AABC::BeginFastRampMode((CFAbsoluteTime *)a1, 30.0, 0.2);
      }
      v28[0] = std::bitset<3ul>::operator[][abi:ne180100](a1 + 304, 0);
      v28[1] = v8;
      std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator=[abi:ne180100]((uint64_t)v28, 0);
      AABC::evaluateAABRearConditions((id *)a1);
      break;
  }
  if (*(float *)(a1 + 492) <= 0.0)
    DisplaySetState(*(_QWORD *)(a1 + 408), 0);
  else
    DisplaySetState(*(_QWORD *)(a1 + 408), v59 == 0);
}

void sub_1B54203B0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void AABC::logAODCurveToPowerLog(AABC *this)
{
  CustomCurve *v1;
  uint64_t inited;
  NSObject *v3;
  int j;
  id v6;
  CustomCurve v7;
  id v8;
  int i;
  char v10;
  CustomCurve v11;
  _BYTE __dst[164];
  CustomCurve v13;
  _BYTE __b[164];
  AABC *v15;
  uint8_t v16[40];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v15 = this;
  memset(__b, 0, sizeof(__b));
  AAB::curveToCustomCurve((uint64_t)this, (uint64_t)this + 1048, (uint64_t)__b);
  memset(&v13, 0, sizeof(v13));
  memcpy(__dst, __b, sizeof(__dst));
  memcpy(&v11, (char *)this + 2540, sizeof(v11));
  AAB::findDarkerCurve((AAB *)__dst, &v11, &v13, v1);
  v10 = 0;
  if (v13.size == *((_DWORD *)this + 716))
  {
    for (i = 0; i < v13.size; ++i)
    {
      if (COERCE_INT(v13._E[i] * 1000.0) != COERCE_INT(*((float *)this + i + 676) * 1000.0)
        || COERCE_INT(v13._L[i] * 1000.0) != COERCE_INT(*((float *)this + i + 696) * 1000.0))
      {
        v10 = 1;
        break;
      }
    }
  }
  else
  {
    v10 = 1;
  }
  if ((v10 & 1) != 0 && *((_QWORD *)this + 44))
  {
    v8 = 0;
    memcpy(&v7, &v13, sizeof(v7));
    v8 = (id)dictionaryForCustomCurve(&v7);
    v6 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D80]), "initWithObjectsAndKeys:", v8, CFSTR("CurveLevelHigh"), 0);
    (*((void (**)(_QWORD, const __CFString *, id))this + 44))(*((_QWORD *)this + 45), CFSTR("AODCurveUpdate"), v6);
    for (j = 0; j < v13.size; ++j)
    {
      if (_logHandle)
      {
        v3 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v3 = inited;
      }
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_3_4_0_8_0_8_0((uint64_t)v16, j, COERCE__INT64(v13._E[j]), COERCE__INT64(v13._L[j]));
        _os_log_impl(&dword_1B5291000, v3, OS_LOG_TYPE_DEFAULT, "AOD Darker Curve[%d] = (%f;%f)", v16, 0x1Cu);
      }
    }
    memcpy((char *)this + 2704, &v13, 0xA4uLL);

  }
}

uint64_t dictionaryForCustomCurve(CustomCurve *a1)
{
  id v1;
  double v2;
  id v3;
  double v4;
  unint64_t v6;
  CustomCurve *v7;
  unint64_t v8;
  uint64_t v9;
  id v10;
  id v11;
  int i;
  id v13;
  id v14;
  CustomCurve *v15;

  v7 = a1;
  v15 = a1;
  v8 = 0x1E0C99000uLL;
  v14 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v13 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (i = 0; i < v7->size; ++i)
  {
    v11 = 0;
    v6 = 0x1E0CB3000uLL;
    v1 = objc_alloc(MEMORY[0x1E0CB37E8]);
    *(float *)&v2 = v7->_E[i];
    v11 = (id)objc_msgSend(v1, "initWithFloat:", v2);
    v10 = 0;
    v3 = objc_alloc(MEMORY[0x1E0CB37E8]);
    *(float *)&v4 = v7->_L[i];
    v10 = (id)objc_msgSend(v3, "initWithFloat:", v4);
    objc_msgSend(v14, "addObject:", v11);
    objc_msgSend(v13, "addObject:", v10);

  }
  v9 = 0;
  v9 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99D80]), "initWithObjectsAndKeys:", v14, CFSTR("lux"), v13, CFSTR("nits"), 0);

  return v9;
}

uint64_t ___ZN4AABC24sendCrossTalkConfigToDCPEv_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t result;

  objc_opt_class();
  result = objc_opt_isKindOfClass();
  if ((result & 1) != 0)
  {
    result = objc_msgSend(a2, "unsignedIntValue");
    *(_DWORD *)(*(_QWORD *)(a1 + 32) + 4 * a3) = result;
  }
  return result;
}

uint64_t ___ZN4AABC24sendCrossTalkConfigToDCPEv_block_invoke_2(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t result;

  result = objc_msgSend(a2, "unsignedIntValue");
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 4 * a3) = result;
  return result;
}

uint64_t std::all_of[abi:ne180100]<BOOL *,AABC::sendCrossTalkConfigToDCP(void)::$_0>(_BYTE *a1, _BYTE *a2)
{
  char v5;
  char v6;

  while (a1 != a2)
  {
    if ((AABC::sendCrossTalkConfigToDCP(void)::$_0::operator()((uint64_t)&v5, *a1 & 1) & 1) == 0)
    {
      v6 = 0;
      return v6 & 1;
    }
    ++a1;
  }
  v6 = 1;
  return v6 & 1;
}

uint64_t ___ZN4AABC14enumerateALSesEU13block_pointerFvP20__IOHIDServiceClientPNS_3ALSEE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    if (a3)
      return (*(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16))();
  }
  return result;
}

_QWORD *std::mutex::mutex[abi:ne180100](_QWORD *a1)
{
  std::mutex::mutex[abi:ne180100](a1);
  return a1;
}

{
  *a1 = 850045863;
  memset(a1 + 1, 0, 0x38uLL);
  return a1;
}

_QWORD *std::__bitset<1ul,3ul>::__bitset(_QWORD *result, char a2)
{
  *result = a2 & 7;
  return result;
}

float AABC::ALS::ALS(AABC::ALS *this)
{
  float result;

  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 1028443341;
  *((_DWORD *)this + 11) = 1036831949;
  *((_DWORD *)this + 12) = 1053609165;
  *((_DWORD *)this + 13) = 0;
  *((_DWORD *)this + 14) = 1184645120;
  *((_DWORD *)this + 15) = 1138819072;
  *((_DWORD *)this + 16) = 1133903872;
  *((_BYTE *)this + 68) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 20) = 0;
  std::vector<float>::vector((_QWORD *)this + 11, 0);
  *((_DWORD *)this + 28) = 0;
  *((_DWORD *)this + 29) = 0;
  *((_DWORD *)this + 30) = 0;
  *((float *)this + 31) = -1.0;
  std::vector<float>::vector((_QWORD *)this + 16, 0);
  result = 450.0;
  *((_DWORD *)this + 39) = 1138819072;
  return result;
}

void sub_1B5420D40(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  *(_QWORD *)(v10 - 16) = a1;
  *(_DWORD *)(v10 - 20) = a2;
  std::vector<float>::~vector[abi:ne180100]((uint64_t *)(a10 + 88));
  _Unwind_Resume(*(_Unwind_Exception **)(v10 - 16));
}

_QWORD *std::vector<float>::vector(_QWORD *a1, unint64_t a2)
{
  std::vector<float>::vector(a1, a2);
  return a1;
}

{
  uint64_t v4;
  _BYTE v5[23];
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;

  v8 = a1;
  v7 = a2;
  v9 = a1;
  *a1 = 0;
  a1[1] = 0;
  v6 = 0;
  std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1 + 2);
  std::vector<float>::__destroy_vector::__destroy_vector[abi:ne180100](&v4, (uint64_t)a1);
  std::__make_exception_guard[abi:ne180100]<std::vector<float>::__destroy_vector>(v4, (uint64_t)v5);
  if (v7)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, v7);
    std::vector<float>::__construct_at_end((uint64_t)a1, v7);
  }
  std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::__complete[abi:ne180100]((uint64_t)v5);
  std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v5);
  return v9;
}

uint64_t std::__make_exception_guard[abi:ne180100]<std::vector<float>::__destroy_vector>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](a2, a1);
}

void std::vector<float>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void *v7;

  if (a2 > std::vector<float>::max_size((uint64_t)a1))
    std::vector<float>::__throw_length_error[abi:ne180100]();
  std::vector<float>::__alloc[abi:ne180100]();
  v7 = std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v2, a2);
  *a1 = v7;
  a1[1] = v7;
  v5 = *a1 + 4 * v3;
  std::vector<float>::__end_cap[abi:ne180100]();
  *v4 = v5;
  std::vector<float>::__annotate_new[abi:ne180100]();
}

_QWORD *std::vector<float>::__construct_at_end(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _DWORD *v3;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a1;
  v11 = a2;
  std::vector<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v8, a1, a2);
  v7 = v10;
  for (i = v9; i != v7; v9 = i)
  {
    std::vector<float>::__alloc[abi:ne180100]();
    v5 = v2;
    std::__to_address[abi:ne180100]<float>();
    _ZNSt3__116allocator_traitsINS_9allocatorIfEEE9constructB8ne180100IfJEvEEvRS2_PT_DpOT0_(v5, v3);
    i += 4;
  }
  return std::vector<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v8);
}

uint64_t std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::__complete[abi:ne180100](uint64_t result)
{
  *(_BYTE *)(result + 8) = 1;
  return result;
}

uint64_t std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](a1);
  return a1;
}

{
  if ((*(_BYTE *)(a1 + 8) & 1) == 0)
    std::vector<float>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)a1);
  return a1;
}

uint64_t std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](a1, a2);
  return a1;
}

uint64_t std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = a2;
  *(_BYTE *)(result + 8) = 0;
  return result;
}

float _ZNSt3__116allocator_traitsINS_9allocatorIfEEE9constructB8ne180100IfJEvEEvRS2_PT_DpOT0_(uint64_t a1, _DWORD *a2)
{
  return std::allocator<float>::construct[abi:ne180100]<float>(a1, a2);
}

float std::allocator<float>::construct[abi:ne180100]<float>(uint64_t a1, _DWORD *a2)
{
  float result;

  result = 0.0;
  *a2 = 0;
  return result;
}

void **std::vector<float>::__append(uint64_t *a1, unint64_t a2)
{
  _QWORD *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  void *v9[5];
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;

  v12 = a1;
  v11 = a2;
  std::vector<float>::__end_cap[abi:ne180100]();
  if ((*v2 - a1[1]) / 4 >= v11)
    return (void **)std::vector<float>::__construct_at_end((uint64_t)a1, v11);
  std::vector<float>::__alloc[abi:ne180100]();
  v10 = v4;
  v5 = std::vector<float>::size[abi:ne180100](a1);
  v7 = std::vector<float>::__recommend[abi:ne180100](a1, v5 + v11);
  v6 = std::vector<float>::size[abi:ne180100](a1);
  std::__split_buffer<float>::__split_buffer(v9, v7, v6, v10);
  std::__split_buffer<float>::__construct_at_end((uint64_t)v9, v11);
  std::vector<float>::__swap_out_circular_buffer(a1, v9);
  return std::__split_buffer<float>::~__split_buffer(v9);
}

void std::vector<float>::__destruct_at_end[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::vector<float>::size[abi:ne180100](a1);
  std::vector<float>::__base_destruct_at_end[abi:ne180100]((uint64_t)a1, a2);
  std::vector<float>::__annotate_shrink[abi:ne180100]();
}

uint64_t std::__split_buffer<float>::__construct_at_end(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  uint64_t v4;
  _QWORD v6[5];

  v6[4] = a1;
  v6[3] = a2;
  std::__split_buffer<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](v6, (_QWORD *)(a1 + 16), a2);
  while (v6[0] != v6[1])
  {
    v4 = std::__split_buffer<float>::__alloc[abi:ne180100](a1);
    std::__to_address[abi:ne180100]<float>();
    _ZNSt3__116allocator_traitsINS_9allocatorIfEEE9constructB8ne180100IfJEvEEvRS2_PT_DpOT0_(v4, v2);
    v6[0] += 4;
  }
  return std::__split_buffer<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100]((uint64_t)v6);
}

_QWORD *std::__split_buffer<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  std::__split_buffer<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](a1, a2, a3);
  return a1;
}

uint64_t std::__split_buffer<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](uint64_t a1)
{
  std::__split_buffer<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](a1);
  return a1;
}

_QWORD *std::__split_buffer<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](_QWORD *result, _QWORD *a2, uint64_t a3)
{
  *result = *a2;
  result[1] = *a2 + 4 * a3;
  result[2] = a2;
  return result;
}

uint64_t std::__split_buffer<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](uint64_t result)
{
  **(_QWORD **)(result + 16) = *(_QWORD *)result;
  return result;
}

uint64_t std::__bitset<1ul,3ul>::__make_ref[abi:ne180100](uint64_t a1, char a2)
{
  uint64_t v3;

  std::__bit_reference<std::__bitset<1ul,3ul>,true>::__bit_reference[abi:ne180100](&v3, a1, 1 << a2);
  return v3;
}

_QWORD *std::__bit_reference<std::__bitset<1ul,3ul>,true>::__bit_reference[abi:ne180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  std::__bit_reference<std::__bitset<1ul,3ul>,true>::__bit_reference[abi:ne180100](a1, a2, a3);
  return a1;
}

_QWORD *std::__bit_reference<std::__bitset<1ul,3ul>,true>::__bit_reference[abi:ne180100](_QWORD *result, uint64_t a2, uint64_t a3)
{
  *result = a2;
  result[1] = a3;
  return result;
}

_QWORD *std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<float>>(_QWORD *a1)
{
  std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<float>>(a1);
  return a1;
}

{
  std::__compressed_pair_elem<float *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<float>,1,true>::__compressed_pair_elem[abi:ne180100]<std::allocator<float>,void>();
  return a1;
}

uint64_t std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(_QWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6;
  _BYTE v7[16];
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v8 = a4;
  std::vector<float>::__destroy_vector::__destroy_vector[abi:ne180100](&v6, (uint64_t)a1);
  std::__make_exception_guard[abi:ne180100]<std::vector<float>::__destroy_vector>(v6, (uint64_t)v7);
  if (v8)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, v8);
    std::vector<float>::__construct_at_end<float *,float *>((uint64_t)a1, v10, v9, v8);
  }
  std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::__complete[abi:ne180100]((uint64_t)v7);
  return std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v7);
}

uint64_t std::__uninitialized_allocator_copy[abi:ne180100]<std::allocator<float>,float *,float *,float *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;

  v9 = std::__unwrap_range[abi:ne180100]<float *,float *>(a2, a3);
  v8 = v4;
  std::__unwrap_iter[abi:ne180100]<float *,std::__unwrap_iter_impl<float *,true>,0>();
  v6 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<float>,float,float,float,(void *)0>(a1, v9, v8, v5);
  return std::__rewrap_iter[abi:ne180100]<float *,float *,std::__unwrap_iter_impl<float *,true>>(a4, v6);
}

uint64_t std::__unwrap_range[abi:ne180100]<float *,float *>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  _QWORD v6[3];

  v6[2] = a1;
  v6[1] = a2;
  std::__unwrap_iter[abi:ne180100]<float *,std::__unwrap_iter_impl<float *,true>,0>();
  v6[0] = v2;
  std::__unwrap_iter[abi:ne180100]<float *,std::__unwrap_iter_impl<float *,true>,0>();
  v5 = v3;
  return std::make_pair[abi:ne180100]<float *,float *>(v6, &v5);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<float>,float,float,float,(void *)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return std::copy[abi:ne180100]<float *,float *>(a2, a3, a4);
}

uint64_t std::make_pair[abi:ne180100]<float *,float *>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  std::pair<float *,float *>::pair[abi:ne180100]<float *,float *,0>(&v3, a1, a2);
  return v3;
}

_QWORD *std::pair<float *,float *>::pair[abi:ne180100]<float *,float *,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  std::pair<float *,float *>::pair[abi:ne180100]<float *,float *,0>(a1, a2, a3);
  return a1;
}

_QWORD *std::pair<float *,float *>::pair[abi:ne180100]<float *,float *,0>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

uint64_t std::copy[abi:ne180100]<float *,float *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,float *,float *,float *>(a1, a2, a3);
  return v3;
}

uint64_t std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,float *,float *,float *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,float *,float *,float *>(a1, a2, a3);
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,float *,float *,float *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,float *,float *,float *,0>(a1, a2, a3);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,float *,float *,float *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v13 = (const void *)std::__unwrap_range[abi:ne180100]<float *,float *>(a1, a2);
  v14 = v3;
  v7 = v3;
  std::__unwrap_iter[abi:ne180100]<float *,std::__unwrap_iter_impl<float *,true>,0>();
  v11 = std::__copy_trivial::operator()[abi:ne180100]<float,float,0>((uint64_t)&v10, v13, v7, v4);
  v12 = v5;
  v9 = std::__rewrap_range[abi:ne180100]<float *,float *>(v17, v11);
  v8 = std::__rewrap_iter[abi:ne180100]<float *,float *,std::__unwrap_iter_impl<float *,true>>(v15, v12);
  return std::make_pair[abi:ne180100]<float *,float *>(&v9, &v8);
}

uint64_t std::__copy_trivial::operator()[abi:ne180100]<float,float,0>(uint64_t a1, const void *a2, uint64_t a3, char *a4)
{
  return std::__copy_trivial_impl[abi:ne180100]<float,float>(a2, a3, a4);
}

uint64_t std::__rewrap_range[abi:ne180100]<float *,float *>(uint64_t a1, uint64_t a2)
{
  return std::__rewrap_iter[abi:ne180100]<float *,float *,std::__unwrap_iter_impl<float *,true>>(a1, a2);
}

uint64_t std::__copy_trivial_impl[abi:ne180100]<float,float>(const void *a1, uint64_t a2, char *a3)
{
  char *v4;
  uint64_t v5;
  char *v6;
  _QWORD v7[2];

  v7[1] = a1;
  v7[0] = a2;
  v6 = a3;
  v5 = (a2 - (uint64_t)a1) / 4;
  std::__constexpr_memmove[abi:ne180100]<float,float,0>(a3, a1, v5);
  v4 = &v6[4 * v5];
  return std::make_pair[abi:ne180100]<float *&,float *>(v7, &v4);
}

void *std::__constexpr_memmove[abi:ne180100]<float,float,0>(void *a1, const void *a2, uint64_t a3)
{
  if (a3)
    memmove(a1, a2, 4 * (a3 - 1) + 4);
  return a1;
}

uint64_t std::make_pair[abi:ne180100]<float *&,float *>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  std::pair<float *,float *>::pair[abi:ne180100]<float *&,float *,0>(&v3, a1, a2);
  return v3;
}

_QWORD *std::pair<float *,float *>::pair[abi:ne180100]<float *&,float *,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  std::pair<float *,float *>::pair[abi:ne180100]<float *&,float *,0>(a1, a2, a3);
  return a1;
}

_QWORD *std::pair<float *,float *>::pair[abi:ne180100]<float *&,float *,0>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

uint64_t std::vector<float>::__make_iter[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  std::__wrap_iter<float *>::__wrap_iter[abi:ne180100](&v3, a2);
  return v3;
}

_QWORD *std::__wrap_iter<float *>::__wrap_iter[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  std::__wrap_iter<float *>::__wrap_iter[abi:ne180100](a1, a2);
  return a1;
}

_QWORD *std::__wrap_iter<float *>::__wrap_iter[abi:ne180100](_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

void std::sort[abi:ne180100]<std::__wrap_iter<float *>,std::__less<void,void>>(uint64_t a1, uint64_t a2)
{
  std::__sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<float *>,std::__less<void,void>>(a1, a2);
}

void std::__sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<float *>,std::__less<void,void>>(uint64_t a1, uint64_t a2)
{
  std::__debug_randomize_range[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<float *>,std::__wrap_iter<float *>>();
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<float *>,std::__unwrap_iter_impl<std::__wrap_iter<float *>,true>,0>(a1);
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<float *>,std::__unwrap_iter_impl<std::__wrap_iter<float *>,true>,0>(a2);
  std::__sort_dispatch[abi:ne180100]<std::_ClassicAlgPolicy,float,0>();
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<float *>,std::__unwrap_iter_impl<std::__wrap_iter<float *>,true>,0>(a1);
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<float *>,std::__unwrap_iter_impl<std::__wrap_iter<float *>,true>,0>(a2);
  std::__check_strict_weak_ordering_sorted[abi:ne180100]<float *,std::__less<void,void>>();
}

uint64_t std::__sort_dispatch[abi:ne180100]<std::_ClassicAlgPolicy,float,0>()
{
  return std::__sort<std::__less<float,float> &,float *>();
}

void std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<float *>,std::__unwrap_iter_impl<std::__wrap_iter<float *>,true>,0>(uint64_t a1)
{
  std::__unwrap_iter_impl<std::__wrap_iter<float *>,true>::__unwrap[abi:ne180100](a1);
}

void std::__unwrap_iter_impl<std::__wrap_iter<float *>,true>::__unwrap[abi:ne180100](uint64_t a1)
{
  uint64_t v1;

  v1 = a1;
  std::__to_address[abi:ne180100]<std::__wrap_iter<float *>,void>(&v1);
}

void std::__to_address[abi:ne180100]<std::__wrap_iter<float *>,void>(uint64_t *a1)
{
  std::__to_address_helper<std::__wrap_iter<float *>,void>::__call[abi:ne180100](a1);
}

void std::__to_address_helper<std::__wrap_iter<float *>,void>::__call[abi:ne180100](uint64_t *a1)
{
  std::pointer_traits<std::__wrap_iter<float *>>::to_address[abi:ne180100](*a1);
}

void std::pointer_traits<std::__wrap_iter<float *>>::to_address[abi:ne180100](uint64_t a1)
{
  uint64_t v1;

  v1 = a1;
  std::__wrap_iter<float *>::base[abi:ne180100]((uint64_t)&v1);
  std::__to_address[abi:ne180100]<float>();
}

uint64_t std::__wrap_iter<float *>::base[abi:ne180100](uint64_t a1)
{
  return *(_QWORD *)a1;
}

BOOL std::__bitset<1ul,3ul>::any[abi:ne180100](_QWORD *a1)
{
  return (*a1 & 7) != 0;
}

uint64_t AABC::sendCrossTalkConfigToDCP(void)::$_0::operator()(uint64_t a1, char a2)
{
  return a2 & 1;
}

uint64_t __os_log_helper_16_2_3_4_0_8_0_8_64(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 8;
  *(_QWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 18) = 64;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  return result;
}

uint64_t __os_log_helper_16_2_8_8_0_8_0_8_0_8_0_8_0_4_0_4_0_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 8;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 0;
  *(_BYTE *)(result + 53) = 4;
  *(_DWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 58) = 0;
  *(_BYTE *)(result + 59) = 4;
  *(_DWORD *)(result + 60) = a8;
  *(_BYTE *)(result + 64) = 32;
  *(_BYTE *)(result + 65) = 8;
  *(_QWORD *)(result + 66) = a9;
  return result;
}

uint64_t __os_log_helper_16_2_4_4_0_4_0_8_32_8_32(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 9) = 4;
  *(_DWORD *)(result + 10) = a3;
  *(_BYTE *)(result + 14) = 32;
  *(_BYTE *)(result + 15) = 8;
  *(_QWORD *)(result + 16) = a4;
  *(_BYTE *)(result + 24) = 32;
  *(_BYTE *)(result + 25) = 8;
  *(_QWORD *)(result + 26) = a5;
  return result;
}

double std::__math::fmin[abi:ne180100]<float,unsigned int,0>(int a1, float a2, double a3)
{
  LODWORD(a3) = a1;
  return std::__math::fmin[abi:ne180100]<int>(a2, (double)*(unint64_t *)&a3);
}

double std::__math::fmax[abi:ne180100]<int,int,0>(int a1, int a2)
{
  return std::__math::fmax[abi:ne180100]<int>((double)a1, (double)a2);
}

uint64_t aabUpdateStrategyTypeToString_0(unint64_t a1)
{
  if (a1 <= 3)
    __asm { BR              X8 }
  return 0;
}

float timeLengthAtFromPointToPoint(float a1, float a2, float a3, float a4, float a5)
{
  return (float)(a3 * (float)(1.0 - (float)((float)(a1 - a2) / (float)(a4 - a2))))
       + (float)(a5 * (float)((float)(a1 - a2) / (float)(a4 - a2)));
}

uint64_t __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_4_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 6;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 4;
  *(_DWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 48) = 0;
  *(_BYTE *)(result + 49) = 8;
  *(_QWORD *)(result + 50) = a7;
  return result;
}

void sub_1B54286F0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void CBAuroraParams::CBAuroraParams(CBAuroraParams *this)
{
  CBAuroraParams::CBAuroraParams(this);
}

{
  *(_QWORD *)this = os_log_create("com.apple.CoreBrightness.Aurora", "params");
  *((_DWORD *)this + 2) = 1174175744;
  *((_DWORD *)this + 3) = 1174175744;
  *((_DWORD *)this + 4) = 1174175744;
  *((_DWORD *)this + 5) = 1173110784;
  *((_DWORD *)this + 6) = 1173110784;
  *((_DWORD *)this + 7) = 1173110784;
  *((_DWORD *)this + 8) = 1183109120;
  *((_DWORD *)this + 9) = 1183109120;
  *((_DWORD *)this + 10) = 1183109120;
  *((_DWORD *)this + 11) = 1158148096;
  *((_DWORD *)this + 12) = 1149534208;
  *((float *)this + 13) = 1.0;
  *((_BYTE *)this + 56) = 0;
  *((float *)this + 15) = 4.0;
  *((float *)this + 16) = 4.0;
  *((float *)this + 17) = 0.75;
  *((_DWORD *)this + 18) = 1043878380;
  *((_DWORD *)this + 19) = 1051931443;
  *((_DWORD *)this + 20) = 1045220557;
  *((_DWORD *)this + 21) = 1053609165;
  *((_DWORD *)this + 22) = 1150681088;
  *((_DWORD *)this + 23) = 1066863165;
  *((_DWORD *)this + 24) = 1123024896;
  *((_BYTE *)this + 100) = 0;
  *((_BYTE *)this + 101) = 0;
  *((_BYTE *)this + 102) = 0;
}

void CBAuroraParams::loadFromCapabilities(CBAuroraParams *this, NSDictionary *a2)
{
  int v2;
  int v3;
  float v4;
  double v5;
  int v6;
  int v7;
  float v8;
  const char *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float v19;
  const char *v20;
  float v21;
  const char *v22;
  float v23;
  const char *v24;
  int v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  NSObject *v41;
  NSObject *v42;
  os_log_type_t v43;
  uint64_t v44;
  NSObject *v45;
  uint64_t v46;
  NSObject *v47;
  uint64_t v48;
  NSObject *v49;
  NSObject *v50;
  os_log_type_t v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t v54;
  NSObject *v55;
  uint64_t v56;
  NSObject *v57;
  uint64_t v58;
  NSObject *v59;
  uint64_t v60;
  NSObject *v61;
  uint64_t v62;
  NSObject *v63;
  uint64_t v64;
  NSObject *v65;
  float v66;
  uint64_t v67;
  NSObject *v68;
  uint64_t v69;
  NSObject *v70;
  NSObject *v71;
  os_log_type_t v72;
  uint64_t v73;
  NSObject *v74;
  uint64_t v75;
  NSObject *v76;
  NSObject *v77;
  os_log_type_t v78;
  uint64_t v79;
  NSObject *v80;
  uint64_t v81;
  NSObject *v82;
  NSObject *v83;
  os_log_type_t v84;
  uint64_t v85;
  NSObject *v86;
  uint64_t inited;
  NSObject *v88;
  uint8_t v90[15];
  os_log_type_t v91;
  NSObject *v92;
  os_log_type_t v93;
  os_log_t v94;
  id v95;
  os_log_type_t v96;
  os_log_t v97;
  uint8_t v98[15];
  os_log_type_t v99;
  NSObject *v100;
  os_log_type_t v101;
  os_log_t v102;
  id v103;
  os_log_type_t v104;
  os_log_t v105;
  os_log_type_t v106;
  os_log_t v107;
  os_log_type_t v108;
  os_log_t v109;
  os_log_type_t v110;
  os_log_t v111;
  os_log_type_t v112;
  os_log_t v113;
  os_log_type_t v114;
  os_log_t v115;
  os_log_type_t v116;
  os_log_t v117;
  uint8_t v118[7];
  os_log_type_t v119;
  NSObject *v120;
  os_log_type_t v121;
  os_log_t v122;
  uint64_t v123;
  int v124;
  int v125;
  float (*v126)(uint64_t, void *, uint64_t);
  void *v127;
  CBAuroraParams *v128;
  id v129;
  uint8_t v130[7];
  os_log_type_t v131;
  NSObject *v132;
  os_log_type_t v133;
  os_log_t v134;
  uint64_t v135;
  int v136;
  int v137;
  float (*v138)(uint64_t, void *, uint64_t);
  void *v139;
  CBAuroraParams *v140;
  id v141;
  uint8_t v142[15];
  os_log_type_t v143;
  NSObject *v144;
  os_log_type_t type;
  os_log_t v146;
  uint64_t v147;
  int v148;
  int v149;
  float (*v150)(uint64_t, void *, uint64_t);
  void *v151;
  CBAuroraParams *v152;
  id v153;
  id v154;
  id v155;
  CBAuroraParams *v156;
  uint8_t v157[16];
  uint8_t v158[16];
  uint8_t v159[16];
  uint8_t v160[16];
  uint8_t v161[16];
  uint8_t v162[16];
  uint8_t v163[16];
  uint8_t v164[16];
  uint8_t v165[32];
  uint8_t v166[16];
  uint8_t v167[32];
  uint8_t v168[16];
  uint8_t v169[16];
  uint8_t v170[16];
  uint8_t v171[16];
  uint8_t v172[16];
  uint8_t v173[16];
  uint8_t v174[16];
  uint8_t v175[16];
  uint8_t v176[16];
  uint8_t v177[24];
  uint64_t v178;

  v178 = *MEMORY[0x1E0C80C00];
  v156 = this;
  v155 = a2;
  v154 = -[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("Aurora"));
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraEnterLux"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v153 = (id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraEnterLux"));
    if (objc_msgSend(v153, "count") == 3)
    {
      v147 = MEMORY[0x1E0C809B0];
      v148 = -1073741824;
      v149 = 0;
      v150 = ___ZN14CBAuroraParams20loadFromCapabilitiesEP12NSDictionary_block_invoke;
      v151 = &__block_descriptor_40_e25_v32__0__NSNumber_8Q16_B24l;
      v152 = this;
      objc_msgSend(v153, "enumerateObjectsUsingBlock:", &v147);
      v146 = 0;
      if (*(_QWORD *)this)
      {
        v88 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        v88 = inited;
      }
      v146 = v88;
      type = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_1_8_64((uint64_t)v177, (uint64_t)v153);
        _os_log_impl(&dword_1B5291000, v146, type, "Aurora Initialization | Enter lux overriden from capabilities: %@", v177, 0xCu);
      }
    }
    else
    {
      v144 = 0;
      if (*(_QWORD *)this)
      {
        v86 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v85 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v85 = init_default_corebrightness_log();
        v86 = v85;
      }
      v144 = v86;
      v143 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
      {
        v83 = v144;
        v84 = v143;
        __os_log_helper_16_0_0(v142);
        _os_log_error_impl(&dword_1B5291000, v83, v84, "Aurora Initialization | Enter lux array length from capablities doesn't match number of curve levels", v142, 2u);
      }
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraExitLux"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v141 = (id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraExitLux"));
    if (objc_msgSend(v141, "count") == 3)
    {
      v135 = MEMORY[0x1E0C809B0];
      v136 = -1073741824;
      v137 = 0;
      v138 = ___ZN14CBAuroraParams20loadFromCapabilitiesEP12NSDictionary_block_invoke_277;
      v139 = &__block_descriptor_40_e25_v32__0__NSNumber_8Q16_B24l;
      v140 = this;
      objc_msgSend(v141, "enumerateObjectsUsingBlock:", &v135);
      v134 = 0;
      if (*(_QWORD *)this)
      {
        v82 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v81 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v81 = init_default_corebrightness_log();
        v82 = v81;
      }
      v134 = v82;
      v133 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_1_8_64((uint64_t)v176, (uint64_t)v141);
        _os_log_impl(&dword_1B5291000, v134, v133, "Aurora Initialization | Exit lux overriden from capabilities: %@", v176, 0xCu);
      }
    }
    else
    {
      v132 = 0;
      if (*(_QWORD *)this)
      {
        v80 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v79 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v79 = init_default_corebrightness_log();
        v80 = v79;
      }
      v132 = v80;
      v131 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
      {
        v77 = v132;
        v78 = v131;
        __os_log_helper_16_0_0(v130);
        _os_log_error_impl(&dword_1B5291000, v77, v78, "Aurora Initialization | Exit lux array length from capablities doesn't match number of curve levels", v130, 2u);
      }
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraSaturationLux"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v129 = (id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraSaturationLux"));
    if (objc_msgSend(v129, "count") == 3)
    {
      v123 = MEMORY[0x1E0C809B0];
      v124 = -1073741824;
      v125 = 0;
      v126 = ___ZN14CBAuroraParams20loadFromCapabilitiesEP12NSDictionary_block_invoke_280;
      v127 = &__block_descriptor_40_e25_v32__0__NSNumber_8Q16_B24l;
      v128 = this;
      objc_msgSend(v129, "enumerateObjectsUsingBlock:", &v123);
      v122 = 0;
      if (*(_QWORD *)this)
      {
        v76 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v75 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v75 = init_default_corebrightness_log();
        v76 = v75;
      }
      v122 = v76;
      v121 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_1_8_64((uint64_t)v175, (uint64_t)v129);
        _os_log_impl(&dword_1B5291000, v122, v121, "Aurora Initialization | Saturation lux overriden from capabilities: %@", v175, 0xCu);
      }
    }
    else
    {
      v120 = 0;
      if (*(_QWORD *)this)
      {
        v74 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v73 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v73 = init_default_corebrightness_log();
        v74 = v73;
      }
      v120 = v74;
      v119 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
      {
        v71 = v120;
        v72 = v119;
        __os_log_helper_16_0_0(v118);
        _os_log_error_impl(&dword_1B5291000, v71, v72, "Aurora Initialization | Saturation lux array length from capablities doesn't match number of curve levels", v118, 2u);
      }
    }
  }
  objc_msgSend(v155, "objectForKeyedSubscript:", CFSTR("MaxNits"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend((id)objc_msgSend(v155, "objectForKeyedSubscript:", CFSTR("MaxNits")), "floatValue");
    *((_DWORD *)this + 12) = v2;
    v117 = 0;
    if (*(_QWORD *)this)
    {
      v70 = *(NSObject **)this;
    }
    else
    {
      v69 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v70 = v69;
    }
    v117 = v70;
    v116 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v174, COERCE__INT64(*((float *)this + 12)));
      _os_log_impl(&dword_1B5291000, v117, v116, "Aurora Initialization | Nits maximum user accessible overriden from capabilities: %f", v174, 0xCu);
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraMaxNits"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraMaxNits")), "floatValue");
    *((_DWORD *)this + 11) = v3;
    v115 = 0;
    if (*(_QWORD *)this)
    {
      v68 = *(NSObject **)this;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v67 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v67 = init_default_corebrightness_log();
      v68 = v67;
    }
    v115 = v68;
    v114 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v173, COERCE__INT64(*((float *)this + 11)));
      _os_log_impl(&dword_1B5291000, v115, v114, "Aurora Initialization | Nits maximum overriden from capabilities: %f", v173, 0xCu);
    }
  }
  else
  {
    objc_msgSend(v155, "objectForKeyedSubscript:", CFSTR("MaxNitsPanel"));
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v66 = *((float *)this + 11);
      objc_msgSend((id)objc_msgSend(v155, "objectForKeyedSubscript:", CFSTR("MaxNitsPanel")), "floatValue");
      v4 = *(float *)&v5;
      *(float *)&v5 = v66;
      if (v66 != v4)
      {
        objc_msgSend((id)objc_msgSend(v155, "objectForKeyedSubscript:", CFSTR("MaxNitsPanel"), v5), "floatValue");
        *((_DWORD *)this + 11) = v6;
        v113 = 0;
        if (*(_QWORD *)this)
        {
          v65 = *(NSObject **)this;
        }
        else
        {
          v64 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          v65 = v64;
        }
        v113 = v65;
        v112 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v172, COERCE__INT64(*((float *)this + 11)));
          _os_log_impl(&dword_1B5291000, v113, v112, "Aurora Initialization | Nits maximum overriden from capabilities: %f", v172, 0xCu);
        }
      }
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraAverageAPCESamplingRate"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraAverageAPCESamplingRate")), "floatValue");
    *((_DWORD *)this + 13) = v7;
    v111 = 0;
    if (*(_QWORD *)this)
    {
      v63 = *(NSObject **)this;
    }
    else
    {
      v62 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v63 = v62;
    }
    v111 = v63;
    v110 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v171, COERCE__INT64(*((float *)this + 13)));
      _os_log_impl(&dword_1B5291000, v111, v110, "Aurora Initialization | Average APCE sampling rate overriden from capabilities: %f", v171, 0xCu);
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraIgnorePeakAPCE"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraIgnorePeakAPCE")), "floatValue");
    *((_BYTE *)this + 56) = v8 != 0.0;
    v109 = 0;
    if (*(_QWORD *)this)
    {
      v61 = *(NSObject **)this;
    }
    else
    {
      v60 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v61 = v60;
    }
    v109 = v61;
    v108 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
    {
      if ((*((_BYTE *)this + 56) & 1) != 0)
        v9 = "YES";
      else
        v9 = "NO";
      __os_log_helper_16_2_1_8_32((uint64_t)v170, (uint64_t)v9);
      _os_log_impl(&dword_1B5291000, v109, v108, "Aurora Initialization | Ignore peak APCE overriden from capabilities: %s", v170, 0xCu);
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraRampUpSpeed"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraRampUpSpeed")), "floatValue");
    *((_DWORD *)this + 15) = v10;
    v107 = 0;
    if (*(_QWORD *)this)
    {
      v59 = *(NSObject **)this;
    }
    else
    {
      v58 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v59 = v58;
    }
    v107 = v59;
    v106 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v169, COERCE__INT64(*((float *)this + 15)));
      _os_log_impl(&dword_1B5291000, v107, v106, "Aurora Initialization | Ramp up time overriden from capabilities: %f", v169, 0xCu);
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraRampDownSpeed"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraRampDownSpeed")), "floatValue");
    *((_DWORD *)this + 16) = v11;
    v105 = 0;
    if (*(_QWORD *)this)
    {
      v57 = *(NSObject **)this;
    }
    else
    {
      v56 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v57 = v56;
    }
    v105 = v57;
    v104 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v168, COERCE__INT64(*((float *)this + 16)));
      _os_log_impl(&dword_1B5291000, v105, v104, "Aurora Initialization | Ramp down time overriden from capabilities: %f", v168, 0xCu);
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraRampUpTapAPCEPoints"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v103 = (id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraRampUpTapAPCEPoints"));
    if (objc_msgSend(v103, "count") == 2)
    {
      objc_msgSend(v103, "objectAtIndexedSubscript:", 0);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0
        && (objc_msgSend(v103, "objectAtIndexedSubscript:", 1), objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        objc_msgSend((id)objc_msgSend(v103, "objectAtIndexedSubscript:", 0), "floatValue");
        *((_DWORD *)this + 18) = v12;
        objc_msgSend((id)objc_msgSend(v103, "objectAtIndexedSubscript:", 1), "floatValue");
        *((_DWORD *)this + 19) = v13;
        v102 = 0;
        if (*(_QWORD *)this)
        {
          v55 = *(NSObject **)this;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v54 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v54 = init_default_corebrightness_log();
          v55 = v54;
        }
        v102 = v55;
        v101 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v167, COERCE__INT64(*((float *)this + 18)), COERCE__INT64(*((float *)this + 19)));
          _os_log_impl(&dword_1B5291000, v102, v101, "Aurora Initialization | Ramp up tap APCE points overriden from capabilities - min: %f, max:%f", v167, 0x16u);
        }
      }
      else
      {
        v100 = 0;
        if (*(_QWORD *)this)
        {
          v53 = *(NSObject **)this;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v52 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v52 = init_default_corebrightness_log();
          v53 = v52;
        }
        v100 = v53;
        v99 = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
        {
          v50 = v100;
          v51 = v99;
          __os_log_helper_16_0_0(v98);
          _os_log_error_impl(&dword_1B5291000, v50, v51, "Aurora Initialization | Ramp up tap APCE points has unexpected types", v98, 2u);
        }
      }
    }
    else
    {
      v97 = 0;
      if (*(_QWORD *)this)
      {
        v49 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v48 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v48 = init_default_corebrightness_log();
        v49 = v48;
      }
      v97 = v49;
      v96 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v166, objc_msgSend(v103, "count"));
        _os_log_error_impl(&dword_1B5291000, v97, v96, "Aurora Initialization | Ramp up tap APCE points has unexpected number of values(%lu), expected 2", v166, 0xCu);
      }
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraRampDownTapAPCEPoints"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v95 = (id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraRampDownTapAPCEPoints"));
    if (objc_msgSend(v95, "count") == 2)
    {
      objc_msgSend(v95, "objectAtIndexedSubscript:", 0);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0
        && (objc_msgSend(v95, "objectAtIndexedSubscript:", 1), objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        objc_msgSend((id)objc_msgSend(v95, "objectAtIndexedSubscript:", 0), "floatValue");
        *((_DWORD *)this + 20) = v14;
        objc_msgSend((id)objc_msgSend(v95, "objectAtIndexedSubscript:", 1), "floatValue");
        *((_DWORD *)this + 21) = v15;
        v94 = 0;
        if (*(_QWORD *)this)
        {
          v47 = *(NSObject **)this;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v46 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v46 = init_default_corebrightness_log();
          v47 = v46;
        }
        v94 = v47;
        v93 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v165, COERCE__INT64(*((float *)this + 20)), COERCE__INT64(*((float *)this + 21)));
          _os_log_impl(&dword_1B5291000, v94, v93, "Aurora Initialization | Ramp down tap APCE points overriden from capabilities - min: %f, max:%f", v165, 0x16u);
        }
      }
      else
      {
        v92 = 0;
        if (*(_QWORD *)this)
        {
          v45 = *(NSObject **)this;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
            v44 = _COREBRIGHTNESS_LOG_DEFAULT;
          else
            v44 = init_default_corebrightness_log();
          v45 = v44;
        }
        v92 = v45;
        v91 = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          v42 = v92;
          v43 = v91;
          __os_log_helper_16_0_0(v90);
          _os_log_error_impl(&dword_1B5291000, v42, v43, "Aurora Initialization | Ramp down tap APCE points has unexpected types", v90, 2u);
        }
      }
    }
    else
    {
      if (*(_QWORD *)this)
      {
        v41 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          v40 = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          v40 = init_default_corebrightness_log();
        v41 = v40;
      }
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v164, objc_msgSend(v95, "count"));
        _os_log_error_impl(&dword_1B5291000, v41, OS_LOG_TYPE_ERROR, "Aurora Initialization | Ramp down tap APCE points has unexpected number of values(%lu), expected 2", v164, 0xCu);
      }
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraCPMSThreshold"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraCPMSThreshold")), "floatValue");
    *((_DWORD *)this + 22) = v16;
    if (*(_QWORD *)this)
    {
      v39 = *(NSObject **)this;
    }
    else
    {
      v38 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v39 = v38;
    }
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v163, COERCE__INT64(*((float *)this + 22)));
      _os_log_impl(&dword_1B5291000, v39, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | CPMS activation threshold overriden from capabilities: %f", v163, 0xCu);
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraCPMSEnterMultiplier"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraCPMSEnterMultiplier")), "floatValue");
    *((_DWORD *)this + 23) = v17;
    if (*(_QWORD *)this)
    {
      v37 = *(NSObject **)this;
    }
    else
    {
      v36 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v37 = v36;
    }
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v162, COERCE__INT64(*((float *)this + 23)));
      _os_log_impl(&dword_1B5291000, v37, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | CPMS enter delta overriden from capabilities: %f", v162, 0xCu);
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraSessionLimit"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraSessionLimit")), "floatValue");
    *((_DWORD *)this + 24) = v18;
    if (*(_QWORD *)this)
    {
      v35 = *(NSObject **)this;
    }
    else
    {
      v34 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v35 = v34;
    }
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v161, COERCE__INT64(*((float *)this + 24)));
      _os_log_impl(&dword_1B5291000, v35, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | Session limit overriden from capabilities: %f", v161, 0xCu);
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraIgnoreSessionLimit"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraIgnoreSessionLimit")), "floatValue");
    *((_BYTE *)this + 100) = v19 != 0.0;
    if (*(_QWORD *)this)
    {
      v33 = *(NSObject **)this;
    }
    else
    {
      v32 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v33 = v32;
    }
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      if ((*((_BYTE *)this + 100) & 1) != 0)
        v20 = "YES";
      else
        v20 = "NO";
      __os_log_helper_16_2_1_8_32((uint64_t)v160, (uint64_t)v20);
      _os_log_impl(&dword_1B5291000, v33, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | Ignore session limit overriden from capabilities: %s", v160, 0xCu);
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraIgnoreAPCE"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraIgnoreAPCE")), "floatValue");
    *((_BYTE *)this + 101) = v21 != 0.0;
    if (*(_QWORD *)this)
    {
      v31 = *(NSObject **)this;
    }
    else
    {
      v30 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v31 = v30;
    }
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      if ((*((_BYTE *)this + 101) & 1) != 0)
        v22 = "YES";
      else
        v22 = "NO";
      __os_log_helper_16_2_1_8_32((uint64_t)v159, (uint64_t)v22);
      _os_log_impl(&dword_1B5291000, v31, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | Ignore APCE overriden from capabilities: %s", v159, 0xCu);
    }
  }
  objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraAllowEDR"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", CFSTR("AuroraAllowEDR")), "floatValue");
    *((_BYTE *)this + 102) = v23 != 0.0;
    if (*(_QWORD *)this)
    {
      v29 = *(NSObject **)this;
    }
    else
    {
      v28 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      v29 = v28;
    }
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      if ((*((_BYTE *)this + 102) & 1) != 0)
        v24 = "YES";
      else
        v24 = "NO";
      __os_log_helper_16_2_1_8_32((uint64_t)v158, (uint64_t)v24);
      _os_log_impl(&dword_1B5291000, v29, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | Allow EDR overriden from capabilities: %s", v158, 0xCu);
    }
  }
  objc_msgSend(v155, "objectForKeyedSubscript:", CFSTR("EDRAuroraSecondsPerStop"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend((id)objc_msgSend(v155, "objectForKeyedSubscript:", CFSTR("EDRAuroraSecondsPerStop")), "floatValue");
    *((_DWORD *)this + 17) = v25;
    if (*(_QWORD *)this)
    {
      v27 = *(NSObject **)this;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v26 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v26 = init_default_corebrightness_log();
      v27 = v26;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v157, COERCE__INT64(*((float *)this + 17)));
      _os_log_impl(&dword_1B5291000, v27, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | Time for EDR ramps overriden from capabilities: %f", v157, 0xCu);
    }
  }
}

uint64_t __os_log_helper_16_2_11_8_32_8_32_8_32_8_32_8_32_8_32_8_32_8_32_8_32_8_32_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 11;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 32;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 32;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 32;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 32;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  *(_BYTE *)(result + 52) = 32;
  *(_BYTE *)(result + 53) = 8;
  *(_QWORD *)(result + 54) = a7;
  *(_BYTE *)(result + 62) = 32;
  *(_BYTE *)(result + 63) = 8;
  *(_QWORD *)(result + 64) = a8;
  *(_BYTE *)(result + 72) = 32;
  *(_BYTE *)(result + 73) = 8;
  *(_QWORD *)(result + 74) = a9;
  *(_BYTE *)(result + 82) = 32;
  *(_BYTE *)(result + 83) = 8;
  *(_QWORD *)(result + 84) = a10;
  *(_BYTE *)(result + 92) = 32;
  *(_BYTE *)(result + 93) = 8;
  *(_QWORD *)(result + 94) = a11;
  *(_BYTE *)(result + 102) = 32;
  *(_BYTE *)(result + 103) = 8;
  *(_QWORD *)(result + 104) = a12;
  return result;
}

uint64_t __os_log_helper_16_2_5_8_32_8_32_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 5;
  *(_BYTE *)(result + 2) = 32;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 32;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 8;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 33) = 8;
  *(_QWORD *)(result + 34) = a5;
  *(_BYTE *)(result + 42) = 0;
  *(_BYTE *)(result + 43) = 8;
  *(_QWORD *)(result + 44) = a6;
  return result;
}

float abs[abi:ne180100](float a1)
{
  return fabsf(a1);
}

uint64_t __os_log_helper_16_2_20_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_32_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  uint64_t result;

  result = a11;
  *(_BYTE *)a1 = 2;
  *(_BYTE *)(a1 + 1) = 20;
  *(_BYTE *)(a1 + 2) = 0;
  *(_BYTE *)(a1 + 3) = 8;
  *(_QWORD *)(a1 + 4) = a2;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 13) = 8;
  *(_QWORD *)(a1 + 14) = a3;
  *(_BYTE *)(a1 + 22) = 0;
  *(_BYTE *)(a1 + 23) = 8;
  *(_QWORD *)(a1 + 24) = a4;
  *(_BYTE *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 33) = 8;
  *(_QWORD *)(a1 + 34) = a5;
  *(_BYTE *)(a1 + 42) = 0;
  *(_BYTE *)(a1 + 43) = 8;
  *(_QWORD *)(a1 + 44) = a6;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 8;
  *(_QWORD *)(a1 + 54) = a7;
  *(_BYTE *)(a1 + 62) = 0;
  *(_BYTE *)(a1 + 63) = 8;
  *(_QWORD *)(a1 + 64) = a8;
  *(_BYTE *)(a1 + 72) = 32;
  *(_BYTE *)(a1 + 73) = 8;
  *(_QWORD *)(a1 + 74) = a9;
  *(_BYTE *)(a1 + 82) = 32;
  *(_BYTE *)(a1 + 83) = 8;
  *(_QWORD *)(a1 + 84) = a10;
  *(_BYTE *)(a1 + 92) = 0;
  *(_BYTE *)(a1 + 93) = 8;
  *(_QWORD *)(a1 + 94) = a11;
  *(_BYTE *)(a1 + 102) = 0;
  *(_BYTE *)(a1 + 103) = 8;
  *(_QWORD *)(a1 + 104) = a12;
  *(_BYTE *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 113) = 8;
  *(_QWORD *)(a1 + 114) = a13;
  *(_BYTE *)(a1 + 122) = 0;
  *(_BYTE *)(a1 + 123) = 8;
  *(_QWORD *)(a1 + 124) = a14;
  *(_BYTE *)(a1 + 132) = 0;
  *(_BYTE *)(a1 + 133) = 8;
  *(_QWORD *)(a1 + 134) = a15;
  *(_BYTE *)(a1 + 142) = 0;
  *(_BYTE *)(a1 + 143) = 8;
  *(_QWORD *)(a1 + 144) = a16;
  *(_BYTE *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + 153) = 8;
  *(_QWORD *)(a1 + 154) = a17;
  *(_BYTE *)(a1 + 162) = 0;
  *(_BYTE *)(a1 + 163) = 8;
  *(_QWORD *)(a1 + 164) = a18;
  *(_BYTE *)(a1 + 172) = 0;
  *(_BYTE *)(a1 + 173) = 8;
  *(_QWORD *)(a1 + 174) = a19;
  *(_BYTE *)(a1 + 182) = 0;
  *(_BYTE *)(a1 + 183) = 8;
  *(_QWORD *)(a1 + 184) = a20;
  *(_BYTE *)(a1 + 192) = 0;
  *(_BYTE *)(a1 + 193) = 8;
  *(_QWORD *)(a1 + 194) = a21;
  return result;
}

float ___ZN14CBAuroraParams20loadFromCapabilitiesEP12NSDictionary_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  float v3;
  float *v4;
  float result;
  uint64_t v6;
  float v7;

  v6 = *(_QWORD *)(a1 + 32);
  objc_msgSend(a2, "floatValue");
  v7 = v3;
  v4 = (float *)std::array<float,3ul>::operator[][abi:ne180100](v6 + 8, a3);
  result = v7;
  *v4 = v7;
  return result;
}

float ___ZN14CBAuroraParams20loadFromCapabilitiesEP12NSDictionary_block_invoke_277(uint64_t a1, void *a2, uint64_t a3)
{
  float v3;
  float *v4;
  float result;
  uint64_t v6;
  float v7;

  v6 = *(_QWORD *)(a1 + 32);
  objc_msgSend(a2, "floatValue");
  v7 = v3;
  v4 = (float *)std::array<float,3ul>::operator[][abi:ne180100](v6 + 20, a3);
  result = v7;
  *v4 = v7;
  return result;
}

float ___ZN14CBAuroraParams20loadFromCapabilitiesEP12NSDictionary_block_invoke_280(uint64_t a1, void *a2, uint64_t a3)
{
  float v3;
  float *v4;
  float result;
  uint64_t v6;
  float v7;

  v6 = *(_QWORD *)(a1 + 32);
  objc_msgSend(a2, "floatValue");
  v7 = v3;
  v4 = (float *)std::array<float,3ul>::operator[][abi:ne180100](v6 + 32, a3);
  result = v7;
  *v4 = v7;
  return result;
}

uint64_t __os_log_helper_16_2_4_8_0_4_0_4_0_8_66(uint64_t result, uint64_t a2, int a3, int a4, uint64_t a5)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 4;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 4;
  *(_DWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 24) = 66;
  *(_BYTE *)(result + 25) = 8;
  *(_QWORD *)(result + 26) = a5;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_0_4_0_8_66(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 3;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 18) = 66;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  return result;
}

void sub_1B5438590(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  uint64_t v10;

  *(_QWORD *)(v10 - 24) = a1;
  *(_DWORD *)(v10 - 28) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v10 - 24));
}

void sub_1B543C8C4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_0_5_8_0_4_0_8_0_8_0_4_0(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 5;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 18) = 0;
  *(_BYTE *)(result + 19) = 8;
  *(_QWORD *)(result + 20) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 4;
  *(_DWORD *)(result + 40) = a6;
  return result;
}

void sub_1B543DDB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1B543DF2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  uint64_t v12;

  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t APDSGrimaldiCallback(void **a1, const void **a2)
{
  NSObject *inited;
  NSObject *v4;
  uint8_t v7[32];
  uint8_t v8[24];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      if (*a2)
      {
        (*((void (**)(void))*a2 + 2))();
        _Block_release(*a2);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
          inited = _COREBRIGHTNESS_LOG_DEFAULT;
        else
          inited = init_default_corebrightness_log();
        if (os_log_type_enabled(inited, OS_LOG_TYPE_FAULT))
        {
          __os_log_helper_16_2_2_8_32_4_0((uint64_t)v7, (uint64_t)"APDSGrimaldiCallback", 86);
          _os_log_fault_impl(&dword_1B5291000, inited, OS_LOG_TYPE_FAULT, "%s:%d callbackData->responseBlock is NULL", v7, 0x12u);
        }
      }
      free(a2);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT)
        v4 = _COREBRIGHTNESS_LOG_DEFAULT;
      else
        v4 = init_default_corebrightness_log();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      {
        __os_log_helper_16_2_2_8_32_4_0((uint64_t)v8, (uint64_t)"APDSGrimaldiCallback", 82);
        _os_log_fault_impl(&dword_1B5291000, v4, OS_LOG_TYPE_FAULT, "%s:%d callbackData is NULL", v8, 0x12u);
      }
    }
    free(*a1);
    free(a1[2]);
    free(a1[1]);
    free(a1[3]);
    free(a1);
  }
  return 0;
}

uint64_t __os_log_helper_16_0_7_8_0_8_0_4_0_8_0_4_0_4_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6, int a7, int a8)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 7;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 4;
  *(_DWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 44) = 0;
  *(_BYTE *)(result + 45) = 4;
  *(_DWORD *)(result + 46) = a7;
  *(_BYTE *)(result + 50) = 0;
  *(_BYTE *)(result + 51) = 4;
  *(_DWORD *)(result + 52) = a8;
  return result;
}

uint64_t __os_log_helper_16_0_9_8_0_8_0_4_0_8_0_4_0_4_0_4_0_4_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6, int a7, int a8, int a9, int a10)
{
  *(_BYTE *)result = 0;
  *(_BYTE *)(result + 1) = 9;
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  *(_BYTE *)(result + 22) = 0;
  *(_BYTE *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 28) = 0;
  *(_BYTE *)(result + 29) = 8;
  *(_QWORD *)(result + 30) = a5;
  *(_BYTE *)(result + 38) = 0;
  *(_BYTE *)(result + 39) = 4;
  *(_DWORD *)(result + 40) = a6;
  *(_BYTE *)(result + 44) = 0;
  *(_BYTE *)(result + 45) = 4;
  *(_DWORD *)(result + 46) = a7;
  *(_BYTE *)(result + 50) = 0;
  *(_BYTE *)(result + 51) = 4;
  *(_DWORD *)(result + 52) = a8;
  *(_BYTE *)(result + 56) = 0;
  *(_BYTE *)(result + 57) = 4;
  *(_DWORD *)(result + 58) = a9;
  *(_BYTE *)(result + 62) = 0;
  *(_BYTE *)(result + 63) = 4;
  *(_DWORD *)(result + 64) = a10;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_64_8_66(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = 2;
  *(_BYTE *)(result + 2) = 64;
  *(_BYTE *)(result + 3) = 8;
  *(_QWORD *)(result + 4) = a2;
  *(_BYTE *)(result + 12) = 66;
  *(_BYTE *)(result + 13) = 8;
  *(_QWORD *)(result + 14) = a3;
  return result;
}

BOOL CBPreferencesHandlerStorePreferenceForUser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return +[CBPreferencesHandler storePreferenceForUser:withKey:andValue:](CBPreferencesHandler, "storePreferenceForUser:withKey:andValue:", a1, a2, a3);
}

BOOL CBPreferencesHandlerStorePreferenceForAllUsers(uint64_t a1, uint64_t a2)
{
  return +[CBPreferencesHandler storePreferenceForAllUsersForKey:andValue:](CBPreferencesHandler, "storePreferenceForAllUsersForKey:andValue:", a1, a2, a2, a1);
}

BOOL CBPreferencesHandlerStorePreferenceForAllUsersMultiple(uint64_t a1)
{
  return +[CBPreferencesHandler storePreferenceForAllUsersMultiple:](CBPreferencesHandler, "storePreferenceForAllUsersMultiple:", a1);
}

id CBPreferencesHandlerCopyPreferenceForUser(uint64_t a1, uint64_t a2)
{
  return +[CBPreferencesHandler copyPreferenceForUser:forKey:](CBPreferencesHandler, "copyPreferenceForUser:forKey:", a1, a2, a2, a1);
}

id CBPreferencesHandlerCopyPreferenceForAllUsers(uint64_t a1)
{
  return +[CBPreferencesHandler copyPreferenceForAllUsersForKey:](CBPreferencesHandler, "copyPreferenceForAllUsersForKey:", a1);
}

id CBPreferencesHandlerCopyPreferenceForAllUsersMultiple(uint64_t a1)
{
  return +[CBPreferencesHandler copyPreferenceForAllUsersMultiple:](CBPreferencesHandler, "copyPreferenceForAllUsersMultiple:", a1);
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x1E0D15428]();
}

uint64_t ApplePhotonDetectorServicesClose()
{
  return MEMORY[0x1E0CFE0E8]();
}

uint64_t ApplePhotonDetectorServicesGetCoex()
{
  return MEMORY[0x1E0CFE0F0]();
}

uint64_t ApplePhotonDetectorServicesGetGlobalCorrectionFactor()
{
  return MEMORY[0x1E0CFE0F8]();
}

uint64_t ApplePhotonDetectorServicesGetLuxAsync()
{
  return MEMORY[0x1E0CFE108]();
}

uint64_t ApplePhotonDetectorServicesOpen()
{
  return MEMORY[0x1E0CFE110]();
}

uint64_t BiomeLibrary()
{
  return MEMORY[0x1E0D01E18]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C97C58]();
  return result;
}

void *__cdecl CFAllocatorAllocate(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  return (void *)MEMORY[0x1E0C97C98](allocator, size, hint);
}

void CFAllocatorDeallocate(CFAllocatorRef allocator, void *ptr)
{
  MEMORY[0x1E0C97CB0](allocator, ptr);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1E0C97D20](allocator, values, numValues, callBacks);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1E0C97D90]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x1E0C97DC0](theArray, idx);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DD0](theArray, idx, value);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1E0C97FC8]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1E0C97FE0](BOOLean);
}

Boolean CFCalendarAddComponents(CFCalendarRef calendar, CFAbsoluteTime *at, CFOptionFlags options, const char *componentDesc, ...)
{
  return MEMORY[0x1E0C98220](calendar, at, options, componentDesc);
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  return MEMORY[0x1E0C98228](calendar, at, componentDesc);
}

CFCalendarRef CFCalendarCopyCurrent(void)
{
  return (CFCalendarRef)MEMORY[0x1E0C98230]();
}

CFCalendarRef CFCalendarCreateWithIdentifier(CFAllocatorRef allocator, CFCalendarIdentifier identifier)
{
  return (CFCalendarRef)MEMORY[0x1E0C98240](allocator, identifier);
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, componentDesc);
  v3 = va_arg(va, _QWORD);
  return MEMORY[0x1E0C98248](calendar, v3, at);
}

void CFCalendarSetTimeZone(CFCalendarRef calendar, CFTimeZoneRef tz)
{
  MEMORY[0x1E0C98298](calendar, tz);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
  MEMORY[0x1E0C983F0](theData, range.location, range.length, buffer);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1E0C98418]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98500](theDict, key, value);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98508](theDict, applier, context);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1E0C98518](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98530](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98538](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98558](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1E0C98570](theDict);
}

CFIndex CFDictionaryGetCountOfKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1E0C98578](theDict, key);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x1E0C985A0](theDict, keys, values);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1E0C985A8]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1E0C985C8](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  MEMORY[0x1E0C985D8](theDict);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x1E0C985E8](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98610](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1E0C98620](cf1, cf2);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x1E0C98718](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1E0C98738](cf);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  MEMORY[0x1E0C988B0](center, observer, callBack, name, object, suspensionBehavior);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988B8]();
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
  MEMORY[0x1E0C98900](center, observer, name, object);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1E0C98928](allocator, theType, valuePtr);
}

CFIndex CFNumberGetByteSize(CFNumberRef number)
{
  return MEMORY[0x1E0C98990](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1E0C989B8]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x1E0C989D0](number);
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return MEMORY[0x1E0C98A30](applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A40](key, applicationID);
}

CFDictionaryRef CFPreferencesCopyMultiple(CFArrayRef keysToFetch, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98A58](keysToFetch, applicationID, userName, hostName);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A60](key, applicationID, userName, hostName);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1E0C98A70](key, applicationID, keyExistsAndHasValidFormat);
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
  MEMORY[0x1E0C98A80](key, value, applicationID);
}

void CFPreferencesSetMultiple(CFDictionaryRef keysToSet, CFArrayRef keysToRemove, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  MEMORY[0x1E0C98A88](keysToSet, keysToRemove, applicationID, userName, hostName);
}

void CFPreferencesSetValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  MEMORY[0x1E0C98A90](key, value, applicationID, userName, hostName);
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return MEMORY[0x1E0C98A98](applicationID, userName, hostName);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AD0](allocator, data, options, format, error);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98BD0](cf);
}

void CFRunLoopRun(void)
{
  MEMORY[0x1E0C98CA8]();
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1E0C99018](alloc, formatOptions, format);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99098](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x1E0C99168]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1E0C99170]();
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return (CFTimeZoneRef)MEMORY[0x1E0C99280]();
}

Boolean CFURLCreateDataAndPropertiesFromResource(CFAllocatorRef alloc, CFURLRef url, CFDataRef *resourceData, CFDictionaryRef *properties, CFArrayRef desiredProperties, SInt32 *errorCode)
{
  return MEMORY[0x1E0C993B0](alloc, url, resourceData, properties, desiredProperties, errorCode);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99420](allocator, filePath, pathStyle, isDirectory);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)MEMORY[0x1E0C99558](alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6);
}

SInt32 CFUserNotificationCancel(CFUserNotificationRef userNotification)
{
  return MEMORY[0x1E0C995A0](userNotification);
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return (CFUserNotificationRef)MEMORY[0x1E0C995A8](allocator, flags, error, dictionary, timeout);
}

SInt32 CFUserNotificationReceiveResponse(CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags *responseFlags)
{
  return MEMORY[0x1E0C995E8](userNotification, responseFlags, timeout);
}

uint64_t GSEventIsHardwareKeyboardAttached()
{
  return MEMORY[0x1E0D27B50]();
}

CFDataRef IOCFSerialize(CFTypeRef object, CFOptionFlags options)
{
  return (CFDataRef)MEMORY[0x1E0CBAD30](object, options);
}

CFTypeRef IOCFUnserializeBinary(const char *buffer, size_t bufferSize, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString)
{
  return (CFTypeRef)MEMORY[0x1E0CBAD40](buffer, bufferSize, allocator, options, errorString);
}

IOReturn IOHIDDeviceClose(IOHIDDeviceRef device, IOOptionBits options)
{
  return MEMORY[0x1E0CBAE60](device, *(_QWORD *)&options);
}

CFArrayRef IOHIDDeviceCopyMatchingElements(IOHIDDeviceRef device, CFDictionaryRef matching, IOOptionBits options)
{
  return (CFArrayRef)MEMORY[0x1E0CBAE70](device, matching, *(_QWORD *)&options);
}

IOHIDDeviceRef IOHIDDeviceCreate(CFAllocatorRef allocator, io_service_t service)
{
  return (IOHIDDeviceRef)MEMORY[0x1E0CBAE78](allocator, *(_QWORD *)&service);
}

IOReturn IOHIDDeviceOpen(IOHIDDeviceRef device, IOOptionBits options)
{
  return MEMORY[0x1E0CBAEB8](device, *(_QWORD *)&options);
}

CFIndex IOHIDElementGetPhysicalMax(IOHIDElementRef element)
{
  return MEMORY[0x1E0CBAF70](element);
}

CFIndex IOHIDElementGetPhysicalMin(IOHIDElementRef element)
{
  return MEMORY[0x1E0CBAF78](element);
}

IOHIDElementType IOHIDElementGetType(IOHIDElementRef element)
{
  return MEMORY[0x1E0CBAFA0](element);
}

CFTypeID IOHIDElementGetTypeID(void)
{
  return MEMORY[0x1E0CBAFA8]();
}

uint32_t IOHIDElementGetUnitExponent(IOHIDElementRef element)
{
  return MEMORY[0x1E0CBAFB8](element);
}

uint32_t IOHIDElementGetUsage(IOHIDElementRef element)
{
  return MEMORY[0x1E0CBAFC0](element);
}

uint32_t IOHIDElementGetUsagePage(IOHIDElementRef element)
{
  return MEMORY[0x1E0CBAFC8](element);
}

uint64_t IOHIDEventCreateAmbientLightSensorEvent()
{
  return MEMORY[0x1E0CBB028]();
}

uint64_t IOHIDEventCreateVendorDefinedEvent()
{
  return MEMORY[0x1E0CBB0D0]();
}

uint64_t IOHIDEventGetChildren()
{
  return MEMORY[0x1E0CBB0F8]();
}

uint64_t IOHIDEventGetDataValue()
{
  return MEMORY[0x1E0CBB100]();
}

uint64_t IOHIDEventGetDoubleValue()
{
  return MEMORY[0x1E0CBB108]();
}

uint64_t IOHIDEventGetFloatValue()
{
  return MEMORY[0x1E0CBB128]();
}

uint64_t IOHIDEventGetIntegerValue()
{
  return MEMORY[0x1E0CBB130]();
}

uint64_t IOHIDEventGetTimeStamp()
{
  return MEMORY[0x1E0CBB158]();
}

uint64_t IOHIDEventGetType()
{
  return MEMORY[0x1E0CBB168]();
}

uint64_t IOHIDEventSetDoubleValue()
{
  return MEMORY[0x1E0CBB198]();
}

uint64_t IOHIDEventSetIntegerValue()
{
  return MEMORY[0x1E0CBB1B0]();
}

CFArrayRef IOHIDEventSystemClientCopyServices(IOHIDEventSystemClientRef client)
{
  return (CFArrayRef)MEMORY[0x1E0CBB1E8](client);
}

uint64_t IOHIDEventSystemClientCreate()
{
  return MEMORY[0x1E0CBB1F0]();
}

uint64_t IOHIDEventSystemClientCreateWithType()
{
  return MEMORY[0x1E0CBB1F8]();
}

uint64_t IOHIDEventSystemClientRegisterDeviceMatchingBlock()
{
  return MEMORY[0x1E0CBB208]();
}

uint64_t IOHIDEventSystemClientRegisterEventBlock()
{
  return MEMORY[0x1E0CBB218]();
}

uint64_t IOHIDEventSystemClientScheduleWithDispatchQueue()
{
  return MEMORY[0x1E0CBB248]();
}

uint64_t IOHIDEventSystemClientSetMatching()
{
  return MEMORY[0x1E0CBB268]();
}

uint64_t IOHIDEventSystemClientSetMatchingMultiple()
{
  return MEMORY[0x1E0CBB270]();
}

uint64_t IOHIDEventSystemClientUnregisterDeviceMatchingBlock()
{
  return MEMORY[0x1E0CBB280]();
}

uint64_t IOHIDEventSystemClientUnregisterEventBlock()
{
  return MEMORY[0x1E0CBB290]();
}

uint64_t IOHIDEventSystemClientUnscheduleFromDispatchQueue()
{
  return MEMORY[0x1E0CBB2B8]();
}

BOOLean_t IOHIDServiceClientConformsTo(IOHIDServiceClientRef service, uint32_t usagePage, uint32_t usage)
{
  return MEMORY[0x1E0CBB490](service, *(_QWORD *)&usagePage, *(_QWORD *)&usage);
}

uint64_t IOHIDServiceClientCopyEvent()
{
  return MEMORY[0x1E0CBB498]();
}

CFTypeRef IOHIDServiceClientCopyProperty(IOHIDServiceClientRef service, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1E0CBB4B0](service, key);
}

CFTypeRef IOHIDServiceClientGetRegistryID(IOHIDServiceClientRef service)
{
  return (CFTypeRef)MEMORY[0x1E0CBB4D0](service);
}

uint64_t IOHIDServiceClientRegisterRemovalBlock()
{
  return MEMORY[0x1E0CBB4E0]();
}

Boolean IOHIDServiceClientSetProperty(IOHIDServiceClientRef service, CFStringRef key, CFTypeRef property)
{
  return MEMORY[0x1E0CBB4F0](service, key, property);
}

void IOHIDTransactionAddElement(IOHIDTransactionRef transaction, IOHIDElementRef element)
{
  MEMORY[0x1E0CBB558](transaction, element);
}

IOReturn IOHIDTransactionCommit(IOHIDTransactionRef transaction)
{
  return MEMORY[0x1E0CBB568](transaction);
}

IOHIDTransactionRef IOHIDTransactionCreate(CFAllocatorRef allocator, IOHIDDeviceRef device, IOHIDTransactionDirectionType direction, IOOptionBits options)
{
  return (IOHIDTransactionRef)MEMORY[0x1E0CBB578](allocator, device, *(_QWORD *)&direction, *(_QWORD *)&options);
}

IOHIDValueRef IOHIDTransactionGetValue(IOHIDTransactionRef transaction, IOHIDElementRef element, IOOptionBits options)
{
  return (IOHIDValueRef)MEMORY[0x1E0CBB588](transaction, element, *(_QWORD *)&options);
}

void IOHIDTransactionSetValue(IOHIDTransactionRef transaction, IOHIDElementRef element, IOHIDValueRef value, IOOptionBits options)
{
  MEMORY[0x1E0CBB598](transaction, element, value, *(_QWORD *)&options);
}

IOHIDValueRef IOHIDValueCreateWithIntegerValue(CFAllocatorRef allocator, IOHIDElementRef element, uint64_t timeStamp, CFIndex value)
{
  return (IOHIDValueRef)MEMORY[0x1E0CBB610](allocator, element, timeStamp, value);
}

double_t IOHIDValueGetScaledValue(IOHIDValueRef value, IOHIDValueScaleType type)
{
  double_t result;

  MEMORY[0x1E0CBB638](value, *(_QWORD *)&type);
  return result;
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return MEMORY[0x1E0CBB668](*(_QWORD *)&iterator);
}

uint64_t IOMobileFramebufferCreateDisplayList()
{
  return MEMORY[0x1E0D39F68]();
}

uint64_t IOMobileFramebufferGetBlock()
{
  return MEMORY[0x1E0D39FB8]();
}

uint64_t IOMobileFramebufferGetMainDisplay()
{
  return MEMORY[0x1E0D3A020]();
}

uint64_t IOMobileFramebufferGetServiceObject()
{
  return MEMORY[0x1E0D3A048]();
}

uint64_t IOMobileFramebufferOpenByName()
{
  return MEMORY[0x1E0D3A078]();
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return (IONotificationPortRef)MEMORY[0x1E0CBB698](*(_QWORD *)&mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
  MEMORY[0x1E0CBB6A0](notify);
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
  MEMORY[0x1E0CBB6B8](notify, queue);
}

BOOLean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
{
  return MEMORY[0x1E0CBB6C8](*(_QWORD *)&object, className);
}

CFStringRef IOObjectCopyClass(io_object_t object)
{
  return (CFStringRef)MEMORY[0x1E0CBB6D0](*(_QWORD *)&object);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x1E0CBB6F0](*(_QWORD *)&object);
}

kern_return_t IOObjectRetain(io_object_t object)
{
  return MEMORY[0x1E0CBB6F8](*(_QWORD *)&object);
}

uint64_t IOPMCopyUserActivityLevelDescription()
{
  return MEMORY[0x1E0CBB7B0]();
}

uint64_t IOPMScheduleUserActiveChangedNotification()
{
  return MEMORY[0x1E0CBB7F8]();
}

uint64_t IOPMScheduleUserActivityLevelNotificationWithTimeout()
{
  return MEMORY[0x1E0CBB808]();
}

uint64_t IOPMSetUserActivityIdleTimeout()
{
  return MEMORY[0x1E0CBB828]();
}

uint64_t IOPMUnregisterNotification()
{
  return MEMORY[0x1E0CBB840]();
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x1E0CBB900](*(_QWORD *)&entry, key, allocator, *(_QWORD *)&options);
}

kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
{
  return MEMORY[0x1E0CBB988](*(_QWORD *)&entry, entryID);
}

CFMutableDictionaryRef IORegistryEntryIDMatching(uint64_t entryID)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0CBB990](entryID);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x1E0CBB9A0](*(_QWORD *)&entry, plane, key, allocator, *(_QWORD *)&options);
}

kern_return_t IORegistryEntrySetCFProperties(io_registry_entry_t entry, CFTypeRef properties)
{
  return MEMORY[0x1E0CBB9A8](*(_QWORD *)&entry, properties);
}

kern_return_t IORegistryEntrySetCFProperty(io_registry_entry_t entry, CFStringRef propertyName, CFTypeRef property)
{
  return MEMORY[0x1E0CBB9B0](*(_QWORD *)&entry, propertyName, property);
}

uint64_t IOReportChannelGetChannelName()
{
  return MEMORY[0x1E0DE0290]();
}

uint64_t IOReportCopyChannelsInGroup()
{
  return MEMORY[0x1E0DE02D8]();
}

uint64_t IOReportCopyChannelsWithID()
{
  return MEMORY[0x1E0DE02E0]();
}

uint64_t IOReportCreateSamples()
{
  return MEMORY[0x1E0DE02F8]();
}

uint64_t IOReportCreateSubscription()
{
  return MEMORY[0x1E0DE0310]();
}

uint64_t IOReportIterate()
{
  return MEMORY[0x1E0DE0338]();
}

uint64_t IOReportSimpleGetIntegerValue()
{
  return MEMORY[0x1E0DE0360]();
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return MEMORY[0x1E0CBB9C0](notifyPort, *(_QWORD *)&service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  return MEMORY[0x1E0CBB9C8](notifyPort, notificationType, matching, callback, refCon, notification);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x1E0CBB9E0](*(_QWORD *)&mainPort, matching);
}

kern_return_t IOServiceGetMatchingServices(mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  return MEMORY[0x1E0CBB9F0](*(_QWORD *)&mainPort, matching, existing);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0CBBA00](name);
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x1E0DE2B20]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x1E0DE2B50]();
}

uint64_t MGGetSInt32Answer()
{
  return MEMORY[0x1E0DE2B70]();
}

uint64_t MGIsDeviceOfType()
{
  return MEMORY[0x1E0DE2B88]();
}

uint64_t MGIsDeviceOneOfType()
{
  return MEMORY[0x1E0DE2B90]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1E0CB28A0](aClassName);
}

void NSLog(NSString *format, ...)
{
  MEMORY[0x1E0CB2D88](format);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1E0CB3200](aClass);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1E0C80928](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
  MEMORY[0x1E0C80940](a1, a2, *(_QWORD *)&a3);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x1E0C80958](aBlock);
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1E0C9A498]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1E0C9A4B0]();
}

uint64_t _IOHIDElementSetValue()
{
  return MEMORY[0x1E0CBBA68]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1E0DE4288](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1E0DE4388](this);
}

void std::mutex::lock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA0](this);
}

void std::mutex::unlock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA8](this);
}

void std::mutex::~mutex(std::mutex *this)
{
  MEMORY[0x1E0DE4AB8](this);
}

uint64_t std::__sort<std::__less<float,float> &,float *>()
{
  return MEMORY[0x1E0DE4AE8]();
}

void std::terminate(void)
{
  MEMORY[0x1E0DE4E18]();
}

uint64_t operator delete[]()
{
  return off_1E68E8D50();
}

void operator delete(void *__p)
{
  off_1E68E8D58(__p);
}

uint64_t operator delete()
{
  return off_1E68E8D60();
}

uint64_t operator new[]()
{
  return off_1E68E8D68();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_1E68E8D70(__sz);
}

uint64_t operator new()
{
  return off_1E68E8D78();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x1E0C80A58](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1E0DE5068](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1E0C80A98](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1E0DE5080](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x1E0DE5098]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x1E0DE50A0](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x1E0DE50B0](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1E0DE50B8](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x1E0DE50C0](a1);
}

void __cxa_rethrow(void)
{
  MEMORY[0x1E0DE50D0]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x1E0DE50D8](a1, lptinfo, a3);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1E0C80B68]();
}

uint64_t __memset_chk()
{
  return MEMORY[0x1E0C80B78]();
}

int __sprintf_chk(char *a1, int a2, size_t a3, const char *a4, ...)
{
  return MEMORY[0x1E0C80BE8](a1, *(_QWORD *)&a2, a3, a4);
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1E0C80C48]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1E0C81010]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81020](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81038](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81040](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C810D0](dso, log, type, spid, name, format, buf, *(_QWORD *)&size);
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1E0DA88F0]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x1E0C813B0]();
}

float atan2f(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C81628](a1, a2);
  return result;
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1E0C816B8](a1, *(_QWORD *)&a2);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

float cosf(float a1)
{
  float result;

  MEMORY[0x1E0C82B48](a1);
  return result;
}

void dispatch_activate(dispatch_object_t object)
{
  MEMORY[0x1E0C82BC0](object);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82BC8](when, queue, block);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  MEMORY[0x1E0C82BE8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1E0C82C68](flags, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority, block);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1E0C82D00](identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E38](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E50](label, attr, target);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x1E0C82E98](object);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA0](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA8](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1E0C82EB8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1E0C82EC8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82ED8](dsema, timeout);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
  MEMORY[0x1E0C82EE0](object, context);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x1E0C82F10](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1E0C82F20](type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F48](source, handler);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F58](source, handler);
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
  MEMORY[0x1E0C82F60](source, handler);
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  MEMORY[0x1E0C82F78](source, start, interval, leeway);
}

void dispatch_suspend(dispatch_object_t object)
{
  MEMORY[0x1E0C82F88](object);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82F90](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

dispatch_workloop_t dispatch_workloop_create_inactive(const char *label)
{
  return (dispatch_workloop_t)MEMORY[0x1E0C82FE0](label);
}

uint64_t dispatch_workloop_set_scheduler_priority()
{
  return MEMORY[0x1E0C83010]();
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1E0C83038]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1E0C83050](__handle, __symbol);
}

float expf(float a1)
{
  float result;

  MEMORY[0x1E0C83298](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1E0C832F8](a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1E0C83460](__filename, __mode);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C835E0](__ptr, __size, __nitems, __stream);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1E0C83A20]();
}

long double log10(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BC0](__x);
  return result;
}

float log2f(float a1)
{
  float result;

  MEMORY[0x1E0C83BF0](a1);
  return result;
}

float logf(float a1)
{
  float result;

  MEMORY[0x1E0C83C00](a1);
  return result;
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1E0C83C50]();
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x1E0C83C70]();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x1E0C83C80](*(_QWORD *)&error_value);
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return MEMORY[0x1E0C83CB0](msg, *(_QWORD *)&option, *(_QWORD *)&send_size, *(_QWORD *)&rcv_size, *(_QWORD *)&rcv_name, *(_QWORD *)&timeout, *(_QWORD *)&notify);
}

mach_msg_return_t mach_msg_receive(mach_msg_header_t *a1)
{
  return MEMORY[0x1E0C83CC8](a1);
}

mach_msg_return_t mach_msg_send(mach_msg_header_t *a1)
{
  return MEMORY[0x1E0C83CD0](a1);
}

kern_return_t mach_port_allocate(ipc_space_t task, mach_port_right_t right, mach_port_name_t *name)
{
  return MEMORY[0x1E0C83CE0](*(_QWORD *)&task, *(_QWORD *)&right, name);
}

kern_return_t mach_port_get_attributes(ipc_space_read_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info_out, mach_msg_type_number_t *port_info_outCnt)
{
  return MEMORY[0x1E0C83D20](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&flavor, port_info_out, port_info_outCnt);
}

kern_return_t mach_port_insert_right(ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly)
{
  return MEMORY[0x1E0C83D48](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&poly, *(_QWORD *)&polyPoly);
}

kern_return_t mach_port_set_attributes(ipc_space_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info, mach_msg_type_number_t port_infoCnt)
{
  return MEMORY[0x1E0C83D78](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&flavor, port_info, *(_QWORD *)&port_infoCnt);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1E0C83DB8](info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1E0C84160](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1E0C843D8](*(_QWORD *)&token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x1E0C843E8](*(_QWORD *)&token, state64);
}

BOOL notify_is_valid_token(int val)
{
  return MEMORY[0x1E0C843F0](*(_QWORD *)&val);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x1E0C843F8](name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return MEMORY[0x1E0C84400](name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1E0C84408](name, out_token, queue, handler);
}

uint32_t notify_set_state(int token, uint64_t state64)
{
  return MEMORY[0x1E0C84428](*(_QWORD *)&token, state64);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1E0DE7BA8](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1E0DE7BB8]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7BD0](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x1E0DE7BD8](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x1E0DE7BE0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7BE8](a1);
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
  MEMORY[0x1E0DE7C30](dest, src, size, atomic, hasStrong);
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x1E0DE7C90](obj);
}

void objc_exception_throw(id exception)
{
  MEMORY[0x1E0DE7CA0](exception);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1E0DE7CB0](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1E0DE7CD0](self, _cmd, offset, atomic);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D30](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1E0DE7D38]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1E0DE7D40]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1E0DE7D48]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1E0DE7D50]();
}

void objc_release(id a1)
{
  MEMORY[0x1E0DE7D78](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1E0DE7E50](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E68](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F88](self, _cmd, newValue, offset);
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F90](self, _cmd, newValue, offset);
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F98](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x1E0DE7FB0](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1E0DE7FC8](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1E0DE7FD0](obj);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1E0C84728](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1E0C84920](log);
}

os_signpost_id_t os_signpost_id_generate(os_log_t log)
{
  return MEMORY[0x1E0C84928](log);
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C84BB8](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C84BC0](a1, a2);
  return result;
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x1E0C84CB0](a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1E0C84CC8](a1);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1E0C84CD8](a1, *(_QWORD *)&a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1E0C84D50](a1, a2, a3, a4);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1E0C84E20](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E28](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E38](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1E0C84E68](a1, a2);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x1E0C84F88](__base, __nel, __width, __compar);
}

float sinf(float a1)
{
  float result;

  MEMORY[0x1E0C85420](a1);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1E0C85610](__s1, __s2);
}

float strtof(const char *a1, char **a2)
{
  float result;

  MEMORY[0x1E0C85628](a1, a2);
  return result;
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85658](__str, __endptr, *(_QWORD *)&__base);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1E0C85798](a1, *(_QWORD *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1E0C857A0](a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
  MEMORY[0x1E0C857D0](*(_QWORD *)&a1, a2);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x1E0C859E0](*(_QWORD *)&a1);
}

void xpc_activity_register(const char *identifier, xpc_object_t criteria, xpc_activity_handler_t handler)
{
  MEMORY[0x1E0C85D98](identifier, criteria, handler);
}

void xpc_activity_unregister(const char *identifier)
{
  MEMORY[0x1E0C85DD0](identifier);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C86208](keys, values, count);
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
  MEMORY[0x1E0C86360](xdict, key, value);
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
  MEMORY[0x1E0C86390](xdict, key, string);
}

void xpc_release(xpc_object_t object)
{
  MEMORY[0x1E0C86658](object);
}

