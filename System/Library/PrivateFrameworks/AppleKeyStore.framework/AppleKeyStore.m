uint64_t aks_get_device_state()
{
  return _get_device_state();
}

dispatch_queue_t __get_aks_client_dispatch_queue_block_invoke()
{
  dispatch_queue_t result;

  result = dispatch_queue_create("aks-client-queue", 0);
  get_aks_client_dispatch_queue_connection_queue = (uint64_t)result;
  return result;
}

uint64_t aks_get_lock_state(int a1, _DWORD *a2)
{
  uint64_t v4;
  mach_port_t aks_client_connection;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  v4 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      output = 0;
      input[0] = a1;
      outputCnt = 1;
      v4 = IOConnectCallMethod(aks_client_connection, 7u, input, 1u, 0, 0, &output, &outputCnt, 0, 0);
      if (!(_DWORD)v4)
        *a2 = output;
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_lock_state", ":", 824, "", 0, "", "");
  }
  return v4;
}

uint64_t aks_set_configuration(int a1, uint64_t a2, uint64_t a3, const __CFDictionary *a4)
{
  uint64_t v7;
  mach_port_t aks_client_connection;
  mach_port_t v9;
  CFTypeID TypeID;
  CFTypeID v11;
  CFTypeID v12;
  CFTypeID v13;
  CFTypeID v14;
  CFTypeID v15;
  CFTypeID v16;
  CFTypeID v17;
  CFTypeID v18;
  void *v20;
  rsize_t __n;
  void *__s;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  __n = 0;
  __s = 0;
  v7 = 3758097090;
  v20 = 0;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v9 = aks_client_connection;
    TypeID = CFNumberGetTypeID();
    if (!_copy_cf_key(a4, CFSTR("GracePeriod"), TypeID, (uint64_t)der_key_config_graceperiod, &v20))
    {
      v11 = CFNumberGetTypeID();
      if (!_copy_cf_key(a4, CFSTR("BackOffDelay"), v11, (uint64_t)der_key_config_backoff_delay, &v20))
      {
        v12 = CFNumberGetTypeID();
        if (!_copy_cf_key(a4, CFSTR("MaxUnlockAttempts"), v12, (uint64_t)der_key_config_max_unlock_attempts, &v20))
        {
          v13 = CFNumberGetTypeID();
          if (!_copy_cf_key(a4, CFSTR("EscrowPasscodePeriod"), v13, (uint64_t)der_key_config_escrow_passcode_period, &v20))
          {
            v14 = CFNumberGetTypeID();
            if (!_copy_cf_key(a4, CFSTR("EscrowTokenPeriod"), v14, (uint64_t)der_key_config_escrow_token_period, &v20))
            {
              v15 = CFDataGetTypeID();
              if (!_copy_cf_key(a4, CFSTR("UserUUID"), v15, (uint64_t)der_key_config_user_uuid, &v20))
              {
                v16 = CFDataGetTypeID();
                if (!_copy_cf_key(a4, CFSTR("BindKEKToKB"), v16, (uint64_t)der_key_config_bind_kek, &v20))
                {
                  v17 = CFBooleanGetTypeID();
                  if (!_copy_cf_key(a4, CFSTR("InactivityRebootEnabled"), v17, (uint64_t)der_key_inactivity_reboot_enabled, &v20))
                  {
                    v18 = CFBooleanGetTypeID();
                    if (!_copy_cf_key(a4, CFSTR("OnenessAutomaticMode"), v18, (uint64_t)der_key_oneness_automatic_mode, &v20)&& !encode_list_is_empty(&v20)&& (!a2 || !encode_list_add_data(&v20, (uint64_t)der_key_passcode, a2))&& !encode_list_dict(&v20, &__s, &__n))
                    {
                      input[0] = a1;
                      input[1] = (uint64_t)__s;
                      input[2] = __n;
                      v7 = IOConnectCallMethod(v9, 0x1Eu, input, 3u, 0, 0, 0, 0, 0, 0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_set_configuration", ":", 1488, "", 0, "", "");
    v7 = 3758097084;
  }
  encode_list_free(&v20);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v7;
}

uint64_t _copy_cf_key(const __CFDictionary *a1, const void *a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t result;
  const UInt8 *BytePtr;
  uint64_t v10;
  void *value;

  value = 0;
  result = CFDictionaryGetValueIfPresent(a1, a2, (const void **)&value);
  if ((_DWORD)result)
  {
    if (CFGetTypeID(value) == a3)
    {
      if (CFNumberGetTypeID() == a3)
      {
        v10 = 0;
        if (!CFNumberGetValue((CFNumberRef)value, kCFNumberSInt64Type, &v10)
          || encode_list_add_number(a5, a4, v10))
        {
          return 0xFFFFFFFFLL;
        }
        return 0;
      }
      if (CFBooleanGetTypeID() == a3)
      {
        CFBooleanGetValue((CFBooleanRef)value);
        if (encode_list_add_BOOL(a5, a4))
          return 0xFFFFFFFFLL;
      }
      else
      {
        if (CFDataGetTypeID() != a3)
          return 0xFFFFFFFFLL;
        BytePtr = CFDataGetBytePtr((CFDataRef)value);
        CFDataGetLength((CFDataRef)value);
        if (encode_list_add_data(a5, a4, (uint64_t)BytePtr))
          return 0xFFFFFFFFLL;
      }
      return 0;
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

BOOL encode_list_is_empty(_QWORD *a1)
{
  return *a1 == 0;
}

uint64_t encode_list_free(void **a1)
{
  void *v2;
  void *v3;

  if (!a1)
    return 0xFFFFFFFFLL;
  while (1)
  {
    v2 = *a1;
    if (!*a1)
      break;
    v3 = (void *)*((_QWORD *)v2 + 1);
    *a1 = *(void **)v2;
    if (v3)
    {
      memset_s(v3, *((_QWORD *)v2 + 2), 0, *((_QWORD *)v2 + 2));
      free(*((void **)v2 + 1));
    }
    memset_s(v2, 0x18uLL, 0, 0x18uLL);
    free(v2);
  }
  return 0;
}

uint64_t encode_list_dict(_QWORD *a1, _QWORD *a2, size_t *a3)
{
  uint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  rsize_t v11;
  void *v12;
  void *v13;
  _QWORD *v14;
  _OWORD *v15;
  size_t v16;
  char *v17;
  void *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v22;
  char v23;
  char *v25;
  char *v26;

  v3 = 0xFFFFFFFFLL;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        v7 = (_QWORD *)*a1;
        if (*a1)
        {
          v8 = 0;
          v9 = 0;
          v10 = 0;
          do
          {
            v10 += v7[2];
            v7 = (_QWORD *)*v7;
            v9 -= 16;
            --v8;
          }
          while (v7);
          if (v8 >= 0xF000000000000001 && (v11 = -v9, (v12 = calloc(-v9, 1uLL)) != 0))
          {
            v13 = v12;
            v14 = (_QWORD *)*a1;
            if (*a1)
            {
              v15 = v12;
              do
              {
                *v15++ = *(_OWORD *)(v14 + 1);
                v14 = (_QWORD *)*v14;
              }
              while (v14);
            }
            qsort(v12, -(uint64_t)v8, 0x10uLL, (int (__cdecl *)(const void *, const void *))_qsort_compare);
            v16 = ccder_sizeof();
            v17 = (char *)calloc(v16, 1uLL);
            v18 = v17;
            if (v17)
            {
              v25 = v17;
              v26 = &v17[v16];
              v19 = v8 - 1;
              v20 = (uint64_t)v13 - v9 - 8;
              while (!__CFADD__(v19++, 1))
              {
                v22 = v20 - 16;
                v23 = ccder_blob_encode_body();
                v20 = v22;
                if ((v23 & 1) == 0)
                  goto LABEL_16;
              }
              if (!ccder_blob_encode_tl() || v25 != v26)
              {
LABEL_16:
                v3 = 0xFFFFFFFFLL;
                goto LABEL_20;
              }
              v3 = 0;
              *a2 = v18;
              *a3 = v16;
              v18 = 0;
            }
            else
            {
              v3 = 4294967279;
            }
LABEL_20:
            memset_s(v13, v11, 0, v11);
            free(v13);
            if (v18)
            {
              memset_s(v18, v16, 0, v16);
              free(v18);
            }
          }
          else
          {
            return 0xFFFFFFFFLL;
          }
        }
      }
    }
  }
  return v3;
}

uint64_t encode_list_add_number(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  size_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  int v16;
  char *v17;
  int v18;
  char *v19;
  BOOL v20;
  _QWORD *v21;
  _QWORD *v22;
  char *v23;
  char *v24;
  _QWORD v25[2];

  v3 = a3;
  v25[1] = *MEMORY[0x24BDAC8D0];
  v5 = HIBYTE(a3);
  if ((HIBYTE(a3) + 1) > 1u)
  {
    v10 = 8;
  }
  else
  {
    v6 = 9;
    v7 = 48;
    v8 = 1;
    while ((unint64_t)(v6 - 2) >= 2)
    {
      v9 = a3 >> v7;
      --v6;
      v7 -= 8;
      if ((_DWORD)v5 != v9)
      {
        v8 = v6 - 1;
        goto LABEL_8;
      }
    }
    v6 = 2;
LABEL_8:
    if ((((a3 >> (8 * v8 - 8)) ^ v5) & 0x80) != 0)
      v10 = v6;
    else
      v10 = v8;
  }
  v25[0] = 0;
  result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    ccder_sizeof();
    v12 = ccder_sizeof();
    v13 = (char *)calloc(v12, 1uLL);
    if (v13)
    {
      v14 = v13;
      v15 = v10;
      do
      {
        *((_BYTE *)v25 + v15 - 1) = v3;
        v3 >>= 8;
        --v15;
      }
      while (v15);
      v23 = &v13[v12];
      if ((ccder_blob_encode_body() & 1) == 0 || !ccder_blob_encode_tl())
        goto LABEL_30;
      v16 = ccder_blob_encode_body();
      v17 = v23;
      if (!v16)
        v17 = 0;
      v24 = v17;
      v18 = ccder_blob_encode_tl();
      v19 = v24;
      if (!v18)
        v19 = 0;
      v20 = v19 && v19 == v14;
      if (v20 && (v21 = calloc(0x18uLL, 1uLL)) != 0)
      {
        v22 = v21;
        result = 0;
        v22[1] = v14;
        v22[2] = v12;
        *v22 = *a1;
        *a1 = v22;
      }
      else
      {
LABEL_30:
        memset_s(v14, v12, 0, v12);
        free(v14);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

void __get_aks_client_connection_block_invoke()
{
  if (!get_aks_client_connection_connection)
    get_aks_client_connection_connection = _copy_aks_client_connection("IOService:/IOResources/AppleKeyStore", "AppleKeyStore");
}

uint64_t _copy_aks_client_connection(char *path, const char *a2)
{
  mach_port_t v3;
  io_service_t v4;
  task_port_t *v5;
  io_object_t v6;
  kern_return_t v7;
  const __CFDictionary *v8;
  io_service_t MatchingService;
  io_object_t v10;
  uint64_t result;
  kern_return_t v12;
  io_connect_t connect;

  connect = 0;
  v3 = *MEMORY[0x24BDD8B20];
  v4 = IORegistryEntryFromPath(*MEMORY[0x24BDD8B20], path);
  v5 = (task_port_t *)MEMORY[0x24BDAEC58];
  if (!v4 || (v6 = v4, v7 = IOServiceOpen(v4, *MEMORY[0x24BDAEC58], 0, &connect), IOObjectRelease(v6), v7))
  {
    v8 = IOServiceMatching(a2);
    MatchingService = IOServiceGetMatchingService(v3, v8);
    if (MatchingService)
    {
      v10 = MatchingService;
      IOServiceOpen(MatchingService, *v5, 0, &connect);
      IOObjectRelease(v10);
    }
  }
  result = connect;
  if (connect)
  {
    v12 = IOConnectCallMethod(connect, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    result = connect;
    if (v12)
    {
      IOServiceClose(connect);
      return 0;
    }
  }
  return result;
}

uint64_t aks_get_configuration(uint64_t a1)
{
  int v1;
  __CFDictionary **v2;
  __CFDictionary **v3;
  int v4;
  uint64_t v5;
  mach_port_t aks_client_connection;
  mach_port_t v7;
  uint64_t v8;
  __CFDictionary *Mutable;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFTypeID TypeID;
  CFTypeID v19;
  CFTypeID v20;
  CFTypeID v21;
  CFTypeID v22;
  CFTypeID v23;
  CFTypeID v24;
  CFTypeID v25;
  CFTypeID v26;
  CFTypeID v27;
  CFTypeID v28;
  CFTypeID v29;
  CFTypeID v30;
  CFTypeID v31;
  CFTypeID v32;
  char number;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  __CFDictionary **v46;
  size_t v47[2];
  _QWORD v48[74];
  uint64_t input;
  _BYTE outputStruct[32768];
  uint64_t v51;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v4 = v1;
  v51 = *MEMORY[0x24BDAC8D0];
  v5 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (v3)
    {
      v7 = aks_client_connection;
      bzero(outputStruct, 0x8000uLL);
      v47[0] = 0x8000;
      input = v4;
      v8 = IOConnectCallMethod(v7, 0x1Fu, &input, 1u, 0, 0, 0, 0, outputStruct, v47);
      if ((_DWORD)v8)
      {
        return v8;
      }
      else if (v47[0] > 0x8000)
      {
        return 3758604298;
      }
      else
      {
        Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
        bzero(v48, 0x250uLL);
        v47[1] = (size_t)der_key_config_graceperiod;
        v48[4] = der_key_config_backoff_delay;
        v48[9] = der_key_config_max_unlock_attempts;
        v48[14] = der_key_config_escrow_passcode_period;
        v48[19] = der_key_config_escrow_token_period;
        v48[24] = der_key_config_flags;
        v48[29] = der_key_config_user_uuid;
        v48[34] = der_key_config_group_uuid;
        v48[39] = der_key_config_recovery_iterations;
        v48[44] = der_key_config_recovery_flags;
        v48[49] = der_key_config_recovery_target_iterations;
        v48[54] = der_key_memento_supported;
        v48[59] = der_key_memento_blob_exists;
        v48[64] = der_key_config_memento_passcode_generation;
        v48[69] = der_key_config_passcode_generation;
        der_dict_iterate();
        v10 = v48[0];
        v11 = v48[5];
        v12 = v48[10];
        v13 = v48[15];
        v14 = v48[20];
        v15 = v48[25];
        v16 = v48[30];
        v46 = v3;
        v17 = v48[35];
        v39 = v48[40];
        v40 = v48[45];
        v41 = v48[50];
        v42 = v48[55];
        v43 = v48[60];
        v44 = v48[65];
        v45 = v48[70];
        TypeID = CFNumberGetTypeID();
        _set_cf_key(Mutable, CFSTR("GracePeriod"), TypeID, v10);
        v19 = CFNumberGetTypeID();
        _set_cf_key(Mutable, CFSTR("BackOffDelay"), v19, v11);
        v20 = CFNumberGetTypeID();
        _set_cf_key(Mutable, CFSTR("MaxUnlockAttempts"), v20, v12);
        v21 = CFNumberGetTypeID();
        _set_cf_key(Mutable, CFSTR("EscrowPasscodePeriod"), v21, v13);
        v22 = CFNumberGetTypeID();
        _set_cf_key(Mutable, CFSTR("EscrowTokenPeriod"), v22, v14);
        v23 = CFNumberGetTypeID();
        _set_cf_key(Mutable, CFSTR("ConfigFlags"), v23, v15);
        v24 = CFDataGetTypeID();
        _set_cf_key(Mutable, CFSTR("UserUUID"), v24, v16);
        v25 = CFDataGetTypeID();
        _set_cf_key(Mutable, CFSTR("GroupUUID"), v25, v17);
        v26 = CFNumberGetTypeID();
        _set_cf_key(Mutable, CFSTR("RecoveryIterations"), v26, v39);
        v27 = CFNumberGetTypeID();
        _set_cf_key(Mutable, CFSTR("RecoveryFlags"), v27, v40);
        v28 = CFNumberGetTypeID();
        _set_cf_key(Mutable, CFSTR("RecoveryTargetIterations"), v28, v41);
        v29 = CFBooleanGetTypeID();
        _set_cf_key(Mutable, CFSTR("MementoSupported"), v29, v42);
        v30 = CFBooleanGetTypeID();
        _set_cf_key(Mutable, CFSTR("MementoBlobExists"), v30, v43);
        v31 = CFNumberGetTypeID();
        _set_cf_key(Mutable, CFSTR("MementoPasscodeGeneration"), v31, v44);
        v32 = CFNumberGetTypeID();
        _set_cf_key(Mutable, CFSTR("PasscodeGeneration"), v32, v45);
        number = der_get_number();
        v34 = (const void *)*MEMORY[0x24BDBD268];
        v35 = (const void *)*MEMORY[0x24BDBD270];
        if ((number & 2) != 0)
          v36 = (const void *)*MEMORY[0x24BDBD270];
        else
          v36 = (const void *)*MEMORY[0x24BDBD268];
        CFDictionarySetValue(Mutable, CFSTR("InactivityRebootEnabled"), v36);
        if ((number & 8) != 0)
          v37 = v35;
        else
          v37 = v34;
        CFDictionarySetValue(Mutable, CFSTR("OnenessAutomaticMode"), v37);
        v5 = 0;
        *v46 = Mutable;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_configuration", ":", 1556, "", 0, "", "");
  }
  return v5;
}

void _set_cf_key(__CFDictionary *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  CFNumberRef v7;
  int v8;
  const void **v9;
  const UInt8 *v10;
  CFNumberRef v11;
  CFIndex valuePtr;

  if (a4)
  {
    if (CFNumberGetTypeID() == a3)
    {
      valuePtr = der_get_number();
      v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], kCFNumberSInt64Type, &valuePtr);
      if (!v7)
        return;
LABEL_12:
      v11 = v7;
      CFDictionaryAddValue(a1, a2, v7);
      CFRelease(v11);
      return;
    }
    if (CFBooleanGetTypeID() == a3)
    {
      v8 = der_get_BOOL();
      v9 = (const void **)MEMORY[0x24BDBD270];
      if (!v8)
        v9 = (const void **)MEMORY[0x24BDBD268];
      CFDictionaryAddValue(a1, a2, *v9);
    }
    else if (CFDataGetTypeID() == a3)
    {
      valuePtr = 0;
      v10 = (const UInt8 *)ccder_decode_tl();
      if (v10)
      {
        v7 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], v10, valuePtr);
        goto LABEL_12;
      }
    }
  }
}

uint64_t der_get_BOOL()
{
  ccder_blob_decode_tl();
  return 0;
}

void AKSEventsUnregister(uint64_t a1)
{
  NSObject *v2;
  _QWORD block[5];

  if (a1)
  {
    IOObjectRelease(*(_DWORD *)(a1 + 16));
    IONotificationPortDestroy(*(IONotificationPortRef *)a1);
    v2 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = __AKSEventsUnregister_block_invoke;
    block[3] = &__block_descriptor_tmp_2;
    block[4] = a1;
    dispatch_barrier_async(v2, block);
  }
}

_QWORD *AKSEventsRegister(NSObject *a1, const void *a2)
{
  mach_port_t v4;
  const __CFDictionary *v5;
  io_service_t MatchingService;
  io_service_t v7;
  IONotificationPortRef v8;
  IONotificationPort *v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  NSObject *v13;
  NSObject *v14;
  const char *v15;
  NSObject *v16;
  const char *v17;
  uint32_t v18;
  NSObject *v19;
  const void *v20;
  io_object_t notification;
  uint8_t buf[4];
  const char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  notification = 0;
  if (!a1 || !a2)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v16 = MEMORY[0x24BDACB70];
      v17 = "bad arguments";
LABEL_12:
      v18 = 2;
LABEL_15:
      _os_log_impl(&dword_217DE1000, v16, OS_LOG_TYPE_DEFAULT, v17, buf, v18);
    }
LABEL_16:
    v9 = 0;
LABEL_17:
    v11 = 0;
    goto LABEL_18;
  }
  v4 = *MEMORY[0x24BDD8B18];
  v5 = IOServiceMatching("AppleKeyStore");
  MatchingService = IOServiceGetMatchingService(v4, v5);
  if (!MatchingService)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      v24 = "AppleKeyStore";
      v16 = MEMORY[0x24BDACB70];
      v17 = "failed to find %s service";
      v18 = 12;
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  v7 = MatchingService;
  v8 = IONotificationPortCreate(v4);
  if (!v8)
  {
    if (!os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
      goto LABEL_16;
    *(_WORD *)buf = 0;
    v16 = MEMORY[0x24BDACB70];
    v17 = "failed to create notification port for AKS";
    goto LABEL_12;
  }
  v9 = v8;
  v10 = calloc(1uLL, 0x20uLL);
  if (!v10)
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_217DE1000, MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT, "failed to allocate memory for event callback", buf, 2u);
    }
    goto LABEL_17;
  }
  v11 = v10;
  *v10 = v9;
  v12 = _Block_copy(a2);
  v11[1] = v12;
  if (v12)
  {
    v13 = dispatch_queue_create_with_target_V2("aks events", 0, a1);
    v11[3] = v13;
    IONotificationPortSetDispatchQueue(v9, v13);
    if (!IOServiceAddInterestNotification(v9, v7, "IOGeneralInterest", (IOServiceInterestCallback)aksNotificationCB, v11, &notification))
    {
      *((_DWORD *)v11 + 4) = notification;
      *((_DWORD *)v11 + 5) = 1902207865;
      return v11;
    }
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v14 = MEMORY[0x24BDACB70];
      v15 = "failed to add interest notification";
LABEL_35:
      _os_log_impl(&dword_217DE1000, v14, OS_LOG_TYPE_DEFAULT, v15, buf, 2u);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    v14 = MEMORY[0x24BDACB70];
    v15 = "failed to copy block";
    goto LABEL_35;
  }
LABEL_18:
  if (notification)
    IOObjectRelease(notification);
  if (v9)
    IONotificationPortDestroy(v9);
  if (v11)
  {
    v19 = v11[3];
    if (v19)
      dispatch_release(v19);
    v20 = (const void *)v11[1];
    if (v20)
      _Block_release(v20);
    free(v11);
    return 0;
  }
  return v11;
}

void aksNotificationCB(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  int v5;
  __CFDictionary *Mutable;
  __CFDictionary *v9;
  void (*v10)(void);
  int v11;
  NSObject *v12;
  const char *v13;
  uint32_t v14;
  _DWORD v15[2];
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    if (!os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
      return;
    v11 = 0;
    v5 = 0;
LABEL_10:
    v15[0] = 67109376;
    v15[1] = v11;
    v16 = 1024;
    v17 = v5;
    v12 = MEMORY[0x24BDACB70];
    v13 = "invalid context %d %d";
    v14 = 14;
    goto LABEL_11;
  }
  v5 = *(_DWORD *)(a1 + 20);
  if (v5 != 1902207865)
  {
    if (!os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
      return;
    v11 = 1;
    goto LABEL_10;
  }
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    if (!os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
      return;
    LOWORD(v15[0]) = 0;
    v12 = MEMORY[0x24BDACB70];
    v13 = "OOM";
    v14 = 2;
LABEL_11:
    _os_log_impl(&dword_217DE1000, v12, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)v15, v14);
    return;
  }
  v9 = Mutable;
  set_info_key(Mutable, CFSTR("h"), (int)a4);
  switch(a3)
  {
    case -469774324:
      v10 = *(void (**)(void))(*(_QWORD *)(a1 + 8) + 16);
      goto LABEL_19;
    case -469774323:
    case -469774321:
      set_lock_state(a4, v9);
      v10 = *(void (**)(void))(*(_QWORD *)(a1 + 8) + 16);
      goto LABEL_19;
    case -469774320:
      v10 = *(void (**)(void))(*(_QWORD *)(a1 + 8) + 16);
      goto LABEL_19;
    case -469774319:
      v10 = *(void (**)(void))(*(_QWORD *)(a1 + 8) + 16);
      goto LABEL_19;
    case -469774318:
      v10 = *(void (**)(void))(*(_QWORD *)(a1 + 8) + 16);
LABEL_19:
      v10();
      break;
    default:
      break;
  }
  CFRelease(v9);
}

void set_info_key(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  uint64_t valuePtr;

  valuePtr = a3;
  if (a1 && a2)
  {
    v5 = CFNumberCreate(0, kCFNumberLongLongType, &valuePtr);
    if (v5)
    {
      v6 = v5;
      CFDictionarySetValue(a1, a2, v5);
      CFRelease(v6);
    }
  }
}

uint64_t _get_device_state()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint32_t v3;
  uint32_t v4;
  uint64_t v5;
  mach_port_t aks_client_connection;
  mach_port_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  int v12[2];
  __int128 __s;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  int v18;
  _BYTE outputStruct[4096];
  uint64_t input[2];

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v4 = v3;
  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = v0;
  *(_QWORD *)v12 = 4096;
  v5 = 3758097084;
  v18 = 0;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  __s = 0u;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (v2)
    {
      v7 = aks_client_connection;
      bzero(outputStruct, 0x1000uLL);
      v8 = IOConnectCallMethod(v7, v4, input, 1u, 0, 0, 0, 0, outputStruct, (size_t *)v12);
      if ((_DWORD)v8)
      {
        return v8;
      }
      else
      {
        v5 = 0;
        if (!decode_extended_state((uint64_t)outputStruct, v12[0], (char *)&__s))
        {
          v9 = v16;
          *(_OWORD *)(v2 + 32) = v15;
          *(_OWORD *)(v2 + 48) = v9;
          *(_WORD *)(v2 + 64) = v17;
          v10 = v14;
          *(_OWORD *)v2 = __s;
          *(_OWORD *)(v2 + 16) = v10;
        }
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_get_device_state", ":", 2224, "", 0, "", "");
  }
  return v5;
}

uint64_t get_aks_client_connection()
{
  uint64_t result;

  if (get_aks_client_dispatch_queue_onceToken != -1)
    dispatch_once(&get_aks_client_dispatch_queue_onceToken, &__block_literal_global_168);
  dispatch_sync((dispatch_queue_t)get_aks_client_dispatch_queue_connection_queue, &__block_literal_global_150);
  result = get_aks_client_connection_connection;
  if (!get_aks_client_connection_connection)
  {
    syslog(3, "failed to open connection to %s\n", "AppleKeyStore");
    return get_aks_client_connection_connection;
  }
  return result;
}

uint64_t decode_extended_state(uint64_t a1, int a2, char *__s)
{
  uint64_t result;
  uint64_t number;
  _QWORD v7[57];
  __int128 v8;
  void *v9;
  void *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  result = 0xFFFFFFFFLL;
  if (a2 && a1)
  {
    if (__s)
    {
      memset_s(__s, 0x54uLL, 0, 0x54uLL);
      bzero(v7, 0x228uLL);
      v7[4] = der_key_state_lock_state;
      v7[9] = der_key_state_backoff;
      v7[14] = der_key_state_failed_attempts;
      v7[19] = der_key_state_generation_state;
      v7[24] = der_key_state_assertion_set;
      v7[29] = der_key_state_grace_period_enabled;
      v7[34] = der_key_state_recovery_countdown;
      v7[39] = der_key_state_more_state;
      v7[44] = der_key_keybag_handle;
      v7[49] = der_key_config_max_unlock_attempts;
      v7[54] = der_key_config_user_uuid;
      v9 = der_key_lock_time;
      v10 = der_key_cx_window;
      der_dict_iterate();
      *(_DWORD *)__s = der_get_number();
      *((_DWORD *)__s + 1) = der_get_number();
      *((_QWORD *)__s + 1) = der_get_number();
      *((_DWORD *)__s + 4) = der_get_number();
      *((_DWORD *)__s + 5) = der_get_number();
      *(_QWORD *)(__s + 26) = der_get_number();
      *(_QWORD *)(__s + 34) = der_get_number();
      *(_DWORD *)(__s + 42) = der_get_number();
      *(_DWORD *)(__s + 46) = der_get_number();
      der_utils_decode_implicit_raw_octet_string_copy(&v8, 4, (uint64_t)(__s + 50), 16);
      __s[66] = der_get_number();
      __s[67] = der_get_number();
      *(_QWORD *)(__s + 68) = der_get_number();
      number = der_get_number();
      result = 0;
      *(_QWORD *)(__s + 76) = number;
    }
  }
  return result;
}

uint64_t der_get_number()
{
  ccder_blob_decode_tl();
  return 0;
}

uint64_t der_dict_iterate()
{
  uint64_t result;

  result = ccder_blob_decode_range();
  if ((_DWORD)result)
  {
    if (ccder_blob_decode_sequence_tl())
    {
      result = ccder_blob_decode_tl();
      if ((_DWORD)result)
        return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t dict_find_params_cb(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  unint64_t v10;
  _BOOL4 v11;
  char v12;
  char v13;
  _QWORD *v14;

  if (*(_QWORD *)(a5 + 8) >= *(_QWORD *)a5)
  {
    v13 = 0;
  }
  else
  {
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = der_equal(*(const void **)(*(_QWORD *)(a5 + 24) + v9), *(_QWORD *)(*(_QWORD *)(a5 + 24) + v9)+ *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a5 + 24) + v9) + 1)+ 2, a1);
      if (v11)
        break;
      ++v10;
      v9 += 40;
      if (v10 >= *(_QWORD *)a5)
        goto LABEL_10;
    }
    v14 = (_QWORD *)(*(_QWORD *)(a5 + 24) + v9);
    if (v14[1])
    {
      v12 = 0;
      *(_BYTE *)(a5 + 16) = 1;
    }
    else
    {
      ++*(_QWORD *)(a5 + 8);
      v14[1] = a3;
      v14[2] = a3 + a4;
      v14[3] = a3;
      v14[4] = a3 + a4;
      v12 = 1;
    }
LABEL_10:
    v13 = v12 | !v11;
  }
  return v13 & 1;
}

BOOL der_equal(const void *a1, uint64_t a2, const void *a3)
{
  size_t v5;

  v5 = der_get_sizeof((uint64_t)a1);
  return v5 == der_get_sizeof((uint64_t)a3) && memcmp(a1, a3, v5) == 0;
}

uint64_t der_get_sizeof(uint64_t a1)
{
  if (ccder_blob_decode_tag() && ccder_blob_decode_len())
    return a1 - a1;
  else
    return 0;
}

uint64_t aks_get_extended_device_state()
{
  return _get_device_state();
}

uint64_t _applekeystored_client_send_uid(void *a1, uint64_t a2, unsigned int a3)
{
  xpc_object_t v6;
  void *v7;
  int64_t v8;

  v6 = xpc_dictionary_create(0, 0, 0);
  if (!v6)
    return 3758097084;
  v7 = v6;
  xpc_dictionary_set_uint64(v6, "_request", a2);
  xpc_dictionary_set_uint64(v7, "_uid", a3);
  v8 = _service_send_msg(a1, v7, 0);
  xpc_release(v7);
  return v8;
}

int64_t _service_send_msg(void *bytes, xpc_object_t xdict, _QWORD *a3)
{
  int64_t int64;
  _xpc_connection_s *v7;
  xpc_object_t v8;
  void *v9;

  int64 = 3758097084;
  if (xdict)
  {
    if (_service_get_connection_onceToken != -1)
      dispatch_once(&_service_get_connection_onceToken, &__block_literal_global);
    v7 = (_xpc_connection_s *)_service_get_connection_connection;
    if (_service_get_connection_connection)
    {
      if (bytes)
        xpc_dictionary_set_data(xdict, "_context", bytes, 0x30uLL);
      v8 = xpc_connection_send_message_with_reply_sync(v7, xdict);
      if (v8)
      {
        v9 = v8;
        if (MEMORY[0x219A18548]() == MEMORY[0x24BDACFB8] || (int64 = xpc_dictionary_get_int64(v9, "_rc"), !a3))
          xpc_release(v9);
        else
          *a3 = v9;
      }
    }
  }
  return int64;
}

uint64_t _applekeystored_client_send_secret(void *a1, uint64_t a2, const void *a3, int a4, const void *a5, int a6)
{
  xpc_object_t v12;
  void *v13;
  int64_t v14;

  v12 = xpc_dictionary_create(0, 0, 0);
  if (!v12)
    return 3758097084;
  v13 = v12;
  xpc_dictionary_set_uint64(v12, "_request", a2);
  if (a3)
    xpc_dictionary_set_data(v13, "_secret", a3, a4);
  if (a5)
    xpc_dictionary_set_data(v13, "_secret_new", a5, a6);
  v14 = _service_send_msg(a1, v13, 0);
  xpc_release(v13);
  return v14;
}

uint64_t applekeystored_client_kb_create(void *a1, const void *a2, int a3)
{
  return _applekeystored_client_send_secret(a1, 5uLL, a2, a3, 0, 0);
}

uint64_t applekeystored_client_kb_load(void *a1)
{
  return _applekeystored_client_send_secret(a1, 3uLL, 0, 0, 0, 0);
}

uint64_t applekeystored_client_kb_load_uid(unsigned int a1)
{
  return _applekeystored_client_send_uid(0, 8uLL, a1);
}

uint64_t applekeystored_client_kb_unload(void *a1)
{
  return _applekeystored_client_send_secret(a1, 7uLL, 0, 0, 0, 0);
}

uint64_t applekeystored_client_kb_change_secret(void *a1, const void *a2, int a3, const void *a4, int a5)
{
  return _applekeystored_client_send_secret(a1, 4uLL, a2, a3, a4, a5);
}

uint64_t applekeystored_client_kb_reset(void *a1, const void *a2, int a3)
{
  return _applekeystored_client_send_secret(a1, 6uLL, a2, a3, 0, 0);
}

uint64_t applekeystored_client_kb_save(void *a1)
{
  return _applekeystored_client_send_secret(a1, 0xAuLL, 0, 0, 0, 0);
}

uint64_t applekeystored_client_kb_unlock(void *a1, const void *a2, int a3)
{
  return _applekeystored_client_send_secret(a1, 0xBuLL, a2, a3, 0, 0);
}

uint64_t applekeystored_client_kb_is_locked(void *a1, BOOL *a2, BOOL *a3)
{
  xpc_object_t v6;
  void *v7;
  int64_t v8;
  xpc_object_t xdict;

  xdict = 0;
  if (a2)
    *a2 = 0;
  if (a3)
    *a3 = 0;
  v6 = xpc_dictionary_create(0, 0, 0);
  if (!v6)
    return 3758097084;
  v7 = v6;
  xpc_dictionary_set_uint64(v6, "_request", 9uLL);
  v8 = _service_send_msg(a1, v7, &xdict);
  if (!(_DWORD)v8)
  {
    if (a2)
      *a2 = xpc_dictionary_get_BOOL(xdict, "_locked");
    if (a3)
      *a3 = xpc_dictionary_get_BOOL(xdict, "_no_pin");
  }
  xpc_release(v7);
  if (xdict)
    xpc_release(xdict);
  return v8;
}

uint64_t applekeystored_client_stash_create(void *a1, const void *a2, int a3)
{
  xpc_object_t v6;
  void *v7;
  int64_t v8;

  v6 = xpc_dictionary_create(0, 0, 0);
  if (!v6)
    return 3758097084;
  v7 = v6;
  xpc_dictionary_set_uint64(v6, "_request", 1uLL);
  if (a2)
    xpc_dictionary_set_data(v7, "_key", a2, a3);
  v8 = _service_send_msg(a1, v7, 0);
  xpc_release(v7);
  return v8;
}

uint64_t applekeystored_client_stash_load(void *a1, const void *a2, int a3, BOOL a4)
{
  xpc_object_t v8;
  void *v9;
  int64_t v10;

  v8 = xpc_dictionary_create(0, 0, 0);
  if (!v8)
    return 3758097084;
  v9 = v8;
  xpc_dictionary_set_uint64(v8, "_request", 2uLL);
  if (a2)
    xpc_dictionary_set_data(v9, "_key", a2, a3);
  xpc_dictionary_set_BOOL(v9, "_destroy", a4);
  v10 = _service_send_msg(a1, v9, 0);
  xpc_release(v9);
  return v10;
}

uint64_t applekeystored_client_identity_create(const __CFUUID *a1, const __CFData *a2, unsigned int a3, const __CFData *a4)
{
  xpc_object_t v7;
  void *v8;
  const UInt8 *BytePtr;
  size_t Length;
  const UInt8 *v11;
  size_t v12;
  int64_t v13;
  CFUUIDBytes v15;

  v15 = CFUUIDGetUUIDBytes(a1);
  v7 = xpc_dictionary_create(0, 0, 0);
  if (!v7)
    return 3758097084;
  v8 = v7;
  xpc_dictionary_set_uint64(v7, "_request", 0xCuLL);
  if (a3 != -1)
    xpc_dictionary_set_uint64(v8, "_uid", a3);
  xpc_dictionary_set_uuid(v8, "_user_uuid", &v15.byte0);
  if (a2)
  {
    BytePtr = CFDataGetBytePtr(a2);
    Length = CFDataGetLength(a2);
    xpc_dictionary_set_data(v8, "_secret_new", BytePtr, Length);
  }
  if (a4)
  {
    v11 = CFDataGetBytePtr(a4);
    v12 = CFDataGetLength(a4);
    xpc_dictionary_set_data(v8, "_secret", v11, v12);
  }
  v13 = _service_send_msg(0, v8, 0);
  xpc_release(v8);
  return v13;
}

uint64_t applekeystored_client_identity_delete(const __CFUUID *a1)
{
  xpc_object_t v1;
  void *v2;
  int64_t v3;
  CFUUIDBytes v5;

  v5 = CFUUIDGetUUIDBytes(a1);
  v1 = xpc_dictionary_create(0, 0, 0);
  if (!v1)
    return 3758097084;
  v2 = v1;
  xpc_dictionary_set_uint64(v1, "_request", 0xDuLL);
  xpc_dictionary_set_uuid(v2, "_user_uuid", &v5.byte0);
  v3 = _service_send_msg(0, v2, 0);
  xpc_release(v2);
  return v3;
}

uint64_t applekeystored_client_identity_migrate(const __CFUUID *a1, unsigned int a2, const __CFData *a3)
{
  xpc_object_t v5;
  void *v6;
  const UInt8 *BytePtr;
  size_t Length;
  int64_t v9;
  CFUUIDBytes v11;

  v11 = CFUUIDGetUUIDBytes(a1);
  v5 = xpc_dictionary_create(0, 0, 0);
  if (!v5)
    return 3758097084;
  v6 = v5;
  xpc_dictionary_set_uint64(v5, "_request", 0xEuLL);
  xpc_dictionary_set_uuid(v6, "_user_uuid", &v11.byte0);
  xpc_dictionary_set_uint64(v6, "_uid", a2);
  if (a3)
  {
    BytePtr = CFDataGetBytePtr(a3);
    Length = CFDataGetLength(a3);
    xpc_dictionary_set_data(v6, "_secret", BytePtr, Length);
  }
  v9 = _service_send_msg(0, v6, 0);
  xpc_release(v6);
  return v9;
}

uint64_t applekeystored_client_identity_load(const __CFUUID *a1, const __CFData *a2, unsigned int a3)
{
  xpc_object_t v5;
  void *v6;
  const UInt8 *BytePtr;
  size_t Length;
  int64_t v9;
  CFUUIDBytes v11;

  v11 = CFUUIDGetUUIDBytes(a1);
  v5 = xpc_dictionary_create(0, 0, 0);
  if (!v5)
    return 3758097084;
  v6 = v5;
  xpc_dictionary_set_uint64(v5, "_request", 0xFuLL);
  xpc_dictionary_set_uint64(v6, "_uid", a3);
  xpc_dictionary_set_uuid(v6, "_user_uuid", &v11.byte0);
  if (a2)
  {
    BytePtr = CFDataGetBytePtr(a2);
    Length = CFDataGetLength(a2);
    xpc_dictionary_set_data(v6, "_secret", BytePtr, Length);
  }
  v9 = _service_send_msg(0, v6, 0);
  xpc_release(v6);
  return v9;
}

uint64_t applekeystored_client_identity_change_passcode(unsigned int a1, const __CFData *a2, const __CFData *a3)
{
  xpc_object_t v6;
  void *v7;
  const UInt8 *BytePtr;
  size_t Length;
  const UInt8 *v10;
  size_t v11;
  int64_t v12;

  v6 = xpc_dictionary_create(0, 0, 0);
  if (!v6)
    return 3758097084;
  v7 = v6;
  xpc_dictionary_set_uint64(v6, "_request", 0x10uLL);
  xpc_dictionary_set_uint64(v7, "_uid", a1);
  if (a2)
  {
    BytePtr = CFDataGetBytePtr(a2);
    Length = CFDataGetLength(a2);
    xpc_dictionary_set_data(v7, "_secret", BytePtr, Length);
  }
  if (a3)
  {
    v10 = CFDataGetBytePtr(a3);
    v11 = CFDataGetLength(a3);
    xpc_dictionary_set_data(v7, "_secret_new", v10, v11);
  }
  v12 = _service_send_msg(0, v7, 0);
  xpc_release(v7);
  return v12;
}

void ___service_get_connection_block_invoke()
{
  const char *v0;
  _xpc_connection_s *mach_service;

  if (getenv("USE_APPLEKEYSTORED_TEST"))
  {
    syslog(4, "Using applekeystored-test variant");
    v0 = "com.apple.applekeystored-test";
  }
  else
  {
    v0 = "com.apple.applekeystored";
  }
  mach_service = xpc_connection_create_mach_service(v0, 0, 2uLL);
  _service_get_connection_connection = (uint64_t)mach_service;
  if (mach_service)
  {
    xpc_connection_set_event_handler(mach_service, &__block_literal_global_18);
    xpc_connection_resume((xpc_connection_t)_service_get_connection_connection);
  }
}

void ___service_get_connection_block_invoke_2(uint64_t a1, uint64_t a2)
{
  char *v3;

  if (MEMORY[0x219A18548](a2) == MEMORY[0x24BDACFB8])
  {
    if (a2 == MEMORY[0x24BDACF38])
      syslog(3, "applekeystored not available");
  }
  else
  {
    v3 = (char *)MEMORY[0x219A184E8](a2);
    syslog(3, "applekeystored should never get messages on this connection: %s", v3);
    free(v3);
  }
}

uint64_t platform_get_measurement()
{
  REQUIRE_func(&lib_platform_callbacks != 0, 36, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return 4294967284;
}

uint64_t platform_rng()
{
  REQUIRE_func(&lib_platform_callbacks != 0, 62, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(lib_platform_rng != 0, 63, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return lib_platform_rng();
}

uint64_t platform_read_random(uint64_t a1, unsigned int a2)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 70, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(lib_platform_read_random != 0, 71, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return lib_platform_read_random(a1, a2);
}

uint64_t platform_pka_get_pub_key(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 78, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(0, 79, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return MEMORY[0](a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t platform_pka_ecdh(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 86, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(0, 87, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return MEMORY[0](a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t platform_pka_sign(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 94, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(0, 95, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return MEMORY[0](a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t platform_pka_sika_attest(unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 106, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(0, 107, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return MEMORY[0](a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

uint64_t platform_pka_shared_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 115, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(0, 116, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return MEMORY[0](a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
}

uint64_t platform_ref_key_hw_crypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 123, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(0, 124, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return MEMORY[0](a1, a2, a3, a4, a5);
}

uint64_t platform_ref_key_hw_crypt_clear_cache()
{
  REQUIRE_func(&lib_platform_callbacks != 0, 131, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(0, 132, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return MEMORY[0]();
}

uint64_t platform_get_device_id(uint64_t a1, _QWORD *a2)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 139, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(lib_platform_get_device_id != 0, 140, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return lib_platform_get_device_id(a1, a2);
}

uint64_t platform_get_aon_security(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 147, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(0, 148, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return MEMORY[0](a1);
}

uint64_t platform_get_att_sep_chip_rev(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 155, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(0, 156, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return MEMORY[0](a1);
}

uint64_t platform_get_chip_id(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 163, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(lib_platform_get_chip_id != 0, 164, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return lib_platform_get_chip_id(a1);
}

uint64_t platform_get_ecid(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 171, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(lib_platform_get_ecid != 0, 172, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return lib_platform_get_ecid(a1);
}

uint64_t platform_get_board_id(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 179, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(lib_platform_get_board_id != 0, 180, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return lib_platform_get_board_id(a1);
}

uint64_t platform_get_fuse_bits(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 187, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(0, 188, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return MEMORY[0](a1);
}

uint64_t platform_get_att_board_and_chip_id(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 195, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(0, 196, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  return MEMORY[0](a1);
}

uint64_t get_aks_log_pid()
{
  return 0;
}

uint64_t compress_uuid()
{
  ccsha256_di();
  ccdigest();
  return 0;
}

unint64_t time_seconds_to_abs_interval(unsigned int a1)
{
  mach_timebase_info info;

  info = 0;
  mach_timebase_info(&info);
  return 1000000000 * info.denom * (unint64_t)a1 / info.numer;
}

unint64_t time_absolute_to_nanoseconds(uint64_t a1)
{
  mach_timebase_info info;

  info = 0;
  mach_timebase_info(&info);
  return (unint64_t)info.numer * a1 / info.denom;
}

uint64_t get_usec_time()
{
  mach_timebase_info info;

  info = 0;
  mach_timebase_info(&info);
  return mach_continuous_time() * info.numer / info.denom / 0x3E8;
}

__darwin_time_t get_clock_time()
{
  timeval v1;

  v1.tv_sec = 0;
  *(_QWORD *)&v1.tv_usec = 0;
  gettimeofday(&v1, 0);
  return v1.tv_sec;
}

uint64_t ipc_seconds_to_microsecond_interval(uint64_t a1)
{
  return 1000000 * a1;
}

unint64_t ipc_microseconds_to_seconds(uint64_t a1)
{
  return (a1 + 999999) / 0xF4240uLL;
}

_QWORD *circular_queue_init(unsigned int a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  size_t v7;
  void *v8;

  v2 = a1 + 1;
  v3 = v2 << 31 >> 31;
  if (v3 != v2 || v3 < 0)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s overflow%s\n", "aks", "", "", "", "circular_queue_init", ":", 341, "", 0, "", "");
    return 0;
  }
  else
  {
    v5 = calloc(0x20uLL, 1uLL);
    v6 = v5;
    if (v5)
    {
      v5[1] = 0;
      v7 = (v3 & 0x1FFFFFFFFLL) * a2;
      *(_DWORD *)v5 = a2;
      *((_DWORD *)v5 + 1) = v2;
      v8 = calloc(v7, 1uLL);
      v6[2] = v7;
      v6[3] = v8;
    }
  }
  return v6;
}

uint64_t circular_queue_size(_DWORD *a1)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t result;

  v3 = a1[2];
  v2 = a1[3];
  result = v2 - v3;
  if (v2 < v3)
    return (result + a1[1]);
  return result;
}

uint64_t circular_queue_enqueue(unsigned int *a1, const void *a2)
{
  unsigned int v3;
  unsigned int v4;

  v3 = a1[3];
  v4 = (v3 + 1) % a1[1];
  memcpy((void *)(*((_QWORD *)a1 + 3) + *a1 * v3), a2, *a1);
  a1[3] = v4;
  if (v4 == a1[2])
    a1[2] = (v4 + 1) % a1[1];
  return 0;
}

uint64_t circular_queue_dequeue(unsigned int *a1, void *__dst)
{
  unsigned int v2;
  uint64_t result;

  v2 = a1[2];
  if (v2 == a1[3])
    return 0xFFFFFFFFLL;
  if (__dst)
  {
    memcpy(__dst, (const void *)(*((_QWORD *)a1 + 3) + *a1 * v2), *a1);
    v2 = a1[2];
  }
  memset_s((void *)(*((_QWORD *)a1 + 3) + *a1 * v2), *a1, 0, *a1);
  result = 0;
  a1[2] = (a1[2] + 1) % a1[1];
  return result;
}

uint64_t circular_queue_peek(unsigned int *a1, void *__dst)
{
  unsigned int v2;

  v2 = a1[2];
  if (v2 == a1[3])
    return 0xFFFFFFFFLL;
  memcpy(__dst, (const void *)(*((_QWORD *)a1 + 3) + *a1 * v2), *a1);
  return 0;
}

uint64_t circular_queue_dequeue_all(int *a1, _QWORD *a2, unsigned int *a3)
{
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  char *v10;
  char *v11;
  unsigned int v12;
  unsigned int v13;
  const void *v14;
  size_t v15;
  uint64_t result;
  unsigned int v17;
  unsigned int v18;
  int v19;

  v7 = a1[2];
  v6 = a1[3];
  v8 = v6 - v7;
  if (v6 < v7)
    v8 += a1[1];
  if (!v8)
    return 0;
  v9 = *a1 * v8;
  v10 = (char *)calloc(v9, 1uLL);
  if (!v10)
    return 0xFFFFFFFFLL;
  v11 = v10;
  v12 = a1[2];
  v13 = a1[3];
  if (v13 <= v12)
  {
    if (v12 <= v13)
      goto LABEL_13;
    v17 = a1[1] - v12;
    memcpy(v10, (const void *)(*((_QWORD *)a1 + 3) + *a1 * v12), *a1 * v17);
    if (v8 <= v17)
      goto LABEL_13;
    v10 = &v11[*a1 * v17];
    v14 = (const void *)*((_QWORD *)a1 + 3);
    v15 = *a1 * (v8 - v17);
  }
  else
  {
    v14 = (const void *)(*((_QWORD *)a1 + 3) + *a1 * v12);
    v15 = *a1 * v8;
  }
  memcpy(v10, v14, v15);
LABEL_13:
  v18 = a1[1];
  v19 = *a1;
  a1[2] = (a1[2] + v8) % v18;
  memset_s(*((void **)a1 + 3), v19 * v18, 0, v19 * v18);
  result = 0;
  *a2 = v11;
  *a3 = v9;
  return result;
}

uint64_t circular_queue_clear(uint64_t a1)
{
  rsize_t v1;

  *(_QWORD *)(a1 + 8) = 0;
  v1 = (*(_DWORD *)a1 * *(_DWORD *)(a1 + 4));
  return memset_s(*(void **)(a1 + 24), v1, 0, v1);
}

void circular_queue_free(void *a1)
{
  rsize_t v2;

  *((_QWORD *)a1 + 1) = 0;
  v2 = (*(_DWORD *)a1 * *((_DWORD *)a1 + 1));
  memset_s(*((void **)a1 + 3), v2, 0, v2);
  memset_s(*((void **)a1 + 3), *((_QWORD *)a1 + 2), 0, *((_QWORD *)a1 + 2));
  free(*((void **)a1 + 3));
  memset_s(a1, 0x20uLL, 0, 0x20uLL);
  free(a1);
}

uint64_t class_gen_get(unsigned int a1)
{
  return (a1 >> 5) & 1;
}

BOOL persona_uuid_is_valid(uint8x16_t *a1)
{
  int8x16_t v1;
  int8x16_t v2;
  int8x16_t v3;

  v1 = (int8x16_t)vmovl_high_u8(*a1);
  v2 = (int8x16_t)vmovl_u8(*(uint8x8_t *)a1->i8);
  v3 = (int8x16_t)vmovl_u16((uint16x4_t)vorr_s8(vorr_s8(*(int8x8_t *)v2.i8, *(int8x8_t *)v1.i8), vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v1, v1, 8uLL))));
  return vorr_s8(*(int8x8_t *)v3.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v3, v3, 8uLL)) != 0;
}

BOOL is_non_zero(unsigned __int8 *a1, uint64_t a2)
{
  int v2;
  int v3;

  if (!a2)
    return 0;
  v2 = 0;
  do
  {
    v3 = *a1++;
    v2 |= v3;
    --a2;
  }
  while (a2);
  return v2 != 0;
}

_DWORD *pfk_params_is_valid(_DWORD *result)
{
  if (result)
    return (_DWORD *)(*result != 0);
  return result;
}

uint64_t class_gen_set(char a1, int a2)
{
  return a1 & 0x1F | (32 * a2);
}

uint64_t class_persona_get(unsigned int a1)
{
  return (a1 >> 6) & 1;
}

uint64_t class_persona_unset(int a1)
{
  return a1 & 0xFFFFFFBF;
}

uint64_t class_persona_set(int a1)
{
  return a1 | 0x40u;
}

uint64_t keychain_key(char a1)
{
  char v1;

  v1 = a1 & 0x1F;
  if ((a1 & 0x1Fu) >= 0x14)
    v1 = -1;
  return ((a1 & 0x1Fu) < 0x14) & (0xC3FC0u >> v1);
}

uint64_t class_id_get(char a1)
{
  if ((a1 & 0x1Fu) > 0x13)
    return 0xFFFFFFFFLL;
  else
    return a1 & 0x1F;
}

uint64_t fs_class_key(char a1)
{
  unsigned int v1;

  v1 = a1 & 0x1F;
  if (v1 > 0x13)
    v1 = -1;
  return (v1 < 0x12) & (0x2E03Eu >> v1);
}

uint64_t keystore_type(char a1)
{
  return a1 & 0xF;
}

BOOL store_type_equal(int a1, int a2)
{
  return ((a2 ^ a1) & 0xF) == 0;
}

uint64_t memcmp_c()
{
  return cc_cmp_safe();
}

uint64_t dump_bytes_internal(const char *a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  const char *v4;
  FILE **v5;
  unint64_t v6;
  FILE **v7;
  uint64_t v8;
  unsigned __int8 *v9;
  char *v10;
  uint64_t v11;
  int v12;
  unint64_t v15;
  char __str[16];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  char v24;
  uint64_t v25;

  v3 = a3;
  v4 = a1;
  v25 = *MEMORY[0x24BDAC8D0];
  v24 = 0;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  *(_OWORD *)__str = 0u;
  v17 = 0u;
  v5 = (FILE **)MEMORY[0x24BDAC8E8];
  if (a3 >= 0x41)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s %sdump %s (len = %zd)%s%s\n", "aks", "", "", "", "dump_bytes_internal", ":", 786, "", 0, "", "", a1, a3, "", "");
    v4 = "";
  }
  else if (!a3)
  {
    return memset_s(__str, 0x81uLL, 0, 0x81uLL);
  }
  v6 = 0;
  v15 = v3;
  do
  {
    v7 = v5;
    if (v3 - v6 >= 0x40)
      v8 = 64;
    else
      v8 = v3 - v6;
    if (v8)
    {
      v9 = (unsigned __int8 *)(a2 + v6);
      v10 = __str;
      v11 = v8;
      do
      {
        v12 = *v9++;
        snprintf(v10, 3uLL, "%02x", v12);
        v10 += 2;
        --v11;
      }
      while (v11);
    }
    v5 = v7;
    fprintf(*v7, "%s%s:%s%s%s%s%u:%s%u:%s %s%s%s[%04zu,%04zu): %s%s%s%s\n", "aks", "", "", "", "dump_bytes_internal", ":", 796, "", 0, "", "", v4, "", v6, v8 + v6, "", __str,
      "",
      "");
    v6 += v8;
    v3 = v15;
  }
  while (v6 < v15);
  return memset_s(__str, 0x81uLL, 0, 0x81uLL);
}

_BYTE *bytes_to_str_hint(unsigned __int8 *a1, unint64_t a2)
{
  uint64_t v2;
  char *v4;
  uint64_t v5;
  int v6;

  if (a2 >= 0x10)
    v2 = 16;
  else
    v2 = a2;
  if (v2)
  {
    v4 = bytes_to_str_hint_buf;
    v5 = v2;
    do
    {
      v6 = *a1++;
      snprintf(v4, 3uLL, "%02x", v6);
      v4 += 2;
      --v5;
    }
    while (v5);
  }
  bytes_to_str_hint_buf[2 * v2] = 0;
  return bytes_to_str_hint_buf;
}

uint64_t get_kcv(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  _OWORD __s[2];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  memset(__s, 0, sizeof(__s));
  if (a4 == 3)
  {
    ccsha256_di();
    cchmac();
    v5 = 0;
    *(_WORD *)a3 = __s[0];
    *(_BYTE *)(a3 + 2) = BYTE2(__s[0]);
  }
  else
  {
    v5 = 0xFFFFFFFFLL;
  }
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  return v5;
}

uint64_t print_kcv(const char *a1, uint64_t a2, uint64_t a3)
{
  __int16 v5;
  char v6;

  v6 = 0;
  v5 = 0;
  get_kcv(a2, a3, (uint64_t)&v5, 3);
  return dump_bytes_internal(a1, (uint64_t)&v5, 3uLL);
}

char *byte_swap_val(char *result, unint64_t a2)
{
  unint64_t v2;
  char *v3;
  char v4;

  if (a2 >= 2)
  {
    v2 = a2 >> 1;
    v3 = &result[a2 - 1];
    do
    {
      v4 = *result;
      *result++ = *v3;
      *v3-- = v4;
      --v2;
    }
    while (v2);
  }
  return result;
}

uint64_t ascii_hex_to_bytes(unsigned __int8 *a1, unint64_t a2, _QWORD *a3, unint64_t *a4)
{
  uint64_t v5;
  unsigned __int8 *v6;
  unint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  _BYTE *v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  char v16;
  char v17;
  char v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  char v22;
  char v23;

  v5 = 0xFFFFFFFFLL;
  if ((a2 & 1) == 0)
  {
    v6 = a1;
    if (a1)
    {
      if (a3 && a4)
      {
        v9 = a2 >> 1;
        v10 = calloc(a2 >> 1, 1uLL);
        if (v10)
        {
          if (a2 >= 2)
          {
            if (v9 <= 1)
              v11 = 1;
            else
              v11 = a2 >> 1;
            v12 = v10;
            do
            {
              v13 = *v6;
              v14 = v13 - 48;
              v15 = v13 - 97;
              if ((v13 - 65) >= 6)
                v16 = -1;
              else
                v16 = v13 - 55;
              v17 = v13 - 87;
              if (v15 > 5)
                v17 = v16;
              if (v14 < 0xA)
                v17 = v14;
              v18 = 16 * v17;
              v19 = v6[1];
              v20 = v19 - 48;
              v21 = v19 - 97;
              if ((v19 - 65) >= 6)
                v22 = -1;
              else
                v22 = v19 - 55;
              v23 = v19 - 87;
              if (v21 > 5)
                v23 = v22;
              if (v20 < 0xA)
                v23 = v20;
              *v12++ = v23 | v18;
              v6 += 2;
              --v11;
            }
            while (v11);
          }
          v5 = 0;
          *a3 = v10;
          *a4 = v9;
        }
        else
        {
          return 4294967279;
        }
      }
    }
  }
  return v5;
}

uint64_t err_sks_to_aks(uint64_t result)
{
  if ((_DWORD)result == 0 || result >= 0xFFFFFFDA)
    return dword_217E31350[(int)result + 38];
  return result;
}

uint64_t fv_init_cred_from_secret(_QWORD *a1, uint64_t a2, char a3)
{
  uint64_t result;
  size_t v7;
  void *v8;
  const void *v9;

  memset_s(a1, 0x10uLL, 0, 0x10uLL);
  if ((a3 & 1) != 0)
    return 4294967285;
  if (a2 && *(_QWORD *)a2 && (v7 = *(_QWORD *)(a2 + 8)) != 0)
  {
    v8 = calloc(v7, 1uLL);
    if (v8)
    {
      *a1 = v8;
      v9 = *(const void **)a2;
      a1[1] = *(_QWORD *)(a2 + 8);
      memcpy(v8, v9, *(_QWORD *)(a2 + 8));
      return 0;
    }
    else
    {
      return 4294967279;
    }
  }
  else
  {
    result = 0;
    *a1 = 0;
    a1[1] = 0;
  }
  return result;
}

uint64_t REQUIRE_func(uint64_t result, int a2, const char *a3)
{
  if ((result & 1) == 0)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s failed REQUIRE condition (%s:%d)\n%s\n", "aks", "", "", "", "REQUIRE_func", ":", 1047, "", 0, "", a3, a2, "");
    abort();
  }
  return result;
}

uint64_t firebloom_export_pub_key(uint64_t a1, _QWORD *a2, size_t *a3)
{
  size_t v5;
  void *v6;
  void *v7;
  uint64_t result;

  v5 = ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
  v6 = calloc(v5, 1uLL);
  if (!v6)
    return 4294967279;
  v7 = v6;
  ccec_export_pub();
  result = 0;
  *a2 = v7;
  *a3 = v5;
  return result;
}

unint64_t firebloom_cp_prime_size()
{
  return (unint64_t)(cczp_bitlen() + 7) >> 3;
}

unint64_t firebloom_sign_max_size()
{
  return (((unint64_t)(cczp_bitlen() + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL) + 9;
}

unint64_t firebloom_ec_export_pub_size()
{
  return ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
}

unint64_t firebloom_ec_compact_export_pub_size()
{
  return (unint64_t)(cczp_bitlen() + 7) >> 3;
}

uint64_t firebloom_cbc_one_shot_f()
{
  return cccbc_one_shot();
}

uint64_t firebloom_ecb_one_shot_f()
{
  return ccecb_one_shot();
}

uint64_t firebloom_cbc_update_f()
{
  return cccbc_update();
}

BOOL firebloom_ec_import()
{
  return !ccec_import_pub() && ccn_read_uint() == 0;
}

uint64_t firebloom_ec_export()
{
  ccn_write_uint_padded();
  return 1;
}

uint64_t generate_wrapping_key_curve25519(__int128 *a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  int __s;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _OWORD v14[2];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  memset(v14, 0, sizeof(v14));
  platform_read_random((uint64_t)v14, 0x20u);
  cccurve25519_make_pub();
  v8 = 0u;
  v9 = 0u;
  __s = 0x1000000;
  v4 = a2[1];
  v10 = *a2;
  v11 = v4;
  v5 = a1[1];
  v12 = *a1;
  v13 = v5;
  cccurve25519();
  ccsha256_di();
  ccdigest();
  memset_s(&__s, 0x64uLL, 0, 0x64uLL);
  memset_s(v14, 0x20uLL, 0, 0x20uLL);
  return 0;
}

uint64_t wrap_data(int *a1, uint64_t (*a2)(uint64_t, void *, uint64_t *, uint64_t *, uint64_t), char a3, uint64_t *a4, unsigned int a5, uint64_t a6, unsigned int *a7)
{
  uint64_t v8;
  int v14;
  unsigned int v15;
  _OWORD *v18;
  unsigned int v19;
  uint64_t (*v20)(uint64_t, void *, uint64_t *, uint64_t *, uint64_t);
  uint64_t *v21;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 *v26;
  _QWORD *v27;
  int v29;
  unsigned int v30;
  _OWORD __s[2];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v30 = 0;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  memset(__s, 0, sizeof(__s));
  v8 = 0xFFFFFFFFLL;
  if (!a6 || !a7)
    goto LABEL_40;
  if (!a1)
  {
LABEL_14:
    if (a2)
    {
      if (rfc3394_wrapped_size_legacy(a5, &v30))
      {
        if (*a7 < v30)
          goto LABEL_40;
        v18 = 0;
        v19 = 0;
        v20 = a2;
        v21 = a4;
        goto LABEL_38;
      }
    }
    else
    {
      if ((a3 & 4) != 0)
      {
        if ((a5 & 0xF) != 0 || *a7 < a5)
          goto LABEL_40;
        v30 = a5;
        ccaes_cbc_encrypt_mode();
        firebloom_cbc_one_shot_f();
LABEL_39:
        v8 = 0;
        *a7 = v30;
        goto LABEL_40;
      }
      if (rfc3394_wrapped_size_legacy(a5, &v30))
      {
        if (*a7 < v30)
          goto LABEL_40;
        if ((a3 & 8) != 0)
        {
          ccsha256_di();
          cchkdf();
          v18 = __s;
        }
        else
        {
          v18 = a1 + 2;
        }
        v19 = 32;
        v20 = 0;
        v21 = a4;
LABEL_38:
        if (rfc3394_wrap_legacy((uint64_t)v18, v19, 0xA6A6A6A6A6A6A6A6, v20, v21, a5, (_QWORD *)a6, &v30))goto LABEL_40;
        goto LABEL_39;
      }
    }
    v8 = 4294967285;
    if ((a3 & 8) == 0)
      goto LABEL_42;
    goto LABEL_41;
  }
  v14 = *a1;
  if ((*a1 - 1) >= 2)
  {
    if (v14)
      goto LABEL_40;
    goto LABEL_14;
  }
  if ((a3 & 4) != 0)
    v15 = 64;
  else
    v15 = 72;
  v30 = v15;
  if (!a2 && a5 == 32 && *a7 >= v15)
  {
    if (v14 == 1)
    {
      generate_wrapping_key_curve25519((__int128 *)(a1 + 9), &v32);
    }
    else
    {
      v23 = *(_OWORD *)(a1 + 5);
      v32 = *(_OWORD *)(a1 + 1);
      v33 = v23;
      v24 = *(_OWORD *)(a1 + 13);
      v34 = *(_OWORD *)(a1 + 9);
      v35 = v24;
    }
    if ((a3 & 0x80) == 0)
    {
      v25 = v33;
      *(_OWORD *)a6 = v32;
      *(_OWORD *)(a6 + 16) = v25;
      if ((a3 & 4) != 0)
      {
        ccaes_cbc_encrypt_mode();
        firebloom_cbc_one_shot_f();
        goto LABEL_34;
      }
      v29 = 40;
      if ((a3 & 8) != 0)
      {
        ccsha256_di();
        cchkdf();
        v27 = (_QWORD *)(a6 + 32);
        v26 = __s;
      }
      else
      {
        v26 = &v34;
        v27 = (_QWORD *)(a6 + 32);
      }
      if (!rfc3394_wrap_legacy((uint64_t)v26, 0x20u, 0xA6A6A6A6A6A6A6A6, 0, a4, 0x20u, v27, &v29))
      {
LABEL_34:
        v8 = 0;
        *a7 = v15;
        if ((a3 & 8) == 0)
          goto LABEL_42;
        goto LABEL_41;
      }
    }
  }
LABEL_40:
  if ((a3 & 8) != 0)
LABEL_41:
    memset_s(__s, 0x20uLL, 0, 0x20uLL);
LABEL_42:
  memset_s(&v32, 0x40uLL, 0, 0x40uLL);
  return v8;
}

uint64_t generate_unwrap_shared_key_curve25519(__int128 *a1, uint64_t a2, __int128 *a3)
{
  __int128 v3;
  __int128 v4;
  int __s;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v8 = 0u;
  v7 = 0u;
  v3 = a1[1];
  v9 = *a1;
  v10 = v3;
  v4 = a3[1];
  v11 = *a3;
  __s = 0x1000000;
  v12 = v4;
  cccurve25519();
  ccsha256_di();
  ccdigest();
  memset_s(&__s, 0x64uLL, 0, 0x64uLL);
  return 0;
}

uint64_t unwrap_data(uint64_t a1, uint64_t (*a2)(_QWORD, void *, unint64_t *, unint64_t *, uint64_t), char a3, _QWORD *a4, unsigned int a5, _QWORD *a6, unsigned int *a7)
{
  uint64_t v8;
  _OWORD *v15;
  unsigned int v16;
  uint64_t (*v17)(_QWORD, void *, unint64_t *, unint64_t *, uint64_t);
  _QWORD *v18;
  _OWORD *v19;
  int v21;
  unsigned int v22;
  _OWORD __s[2];
  _OWORD v24[2];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v22 = 0;
  memset(v24, 0, sizeof(v24));
  v8 = 0xFFFFFFFFLL;
  if (a4 && a5)
  {
    if (!a1)
      goto LABEL_6;
    if (*(_DWORD *)a1 != 1)
    {
      if (!*(_DWORD *)a1)
      {
LABEL_6:
        if (a5 <= 0x28)
        {
          if (a2)
          {
            if (rfc3394_unwrapped_size_legacy(a5, &v22) && *a7 >= v22)
            {
              v15 = 0;
              v16 = 0;
              v17 = a2;
              goto LABEL_30;
            }
          }
          else if ((a3 & 4) != 0)
          {
            if ((a5 & 0xF) == 0 && *a7 >= a5)
            {
              v22 = a5;
              ccaes_cbc_decrypt_mode();
              firebloom_cbc_one_shot_f();
LABEL_31:
              v8 = 0;
              *a7 = v22;
              goto LABEL_35;
            }
          }
          else if (rfc3394_unwrapped_size_legacy(a5, &v22) && *a7 >= v22)
          {
            if ((a3 & 8) != 0)
            {
              ccsha256_di();
              cchkdf();
              v15 = v24;
            }
            else
            {
              v15 = (_OWORD *)(a1 + 8);
            }
            v16 = 32;
            v17 = 0;
LABEL_30:
            if (!rfc3394_unwrap_legacy((uint64_t)v15, v16, 0xA6A6A6A6A6A6A6A6, v17, a4, a5, a6, &v22))
              goto LABEL_31;
            goto LABEL_40;
          }
        }
LABEL_38:
        v8 = 4294967285;
        goto LABEL_35;
      }
LABEL_22:
      v8 = 0xFFFFFFFFLL;
      goto LABEL_35;
    }
    v22 = 32;
    if (*a7 < 0x20)
      goto LABEL_38;
    memset(__s, 0, sizeof(__s));
    if ((a3 & 4) != 0)
    {
      if (a5 != 64)
        goto LABEL_38;
      generate_unwrap_shared_key_curve25519((__int128 *)a4, a1 + 4, (__int128 *)(a1 + 36));
      ccaes_cbc_decrypt_mode();
      firebloom_cbc_one_shot_f();
    }
    else
    {
      if (a5 != 72)
        goto LABEL_38;
      generate_unwrap_shared_key_curve25519((__int128 *)a4, a1 + 4, (__int128 *)(a1 + 36));
      if (a3 < 0)
        goto LABEL_22;
      v21 = 32;
      if ((a3 & 8) != 0)
      {
        ccsha256_di();
        cchkdf();
        v18 = a4 + 4;
        v19 = v24;
      }
      else
      {
        v18 = a4 + 4;
        v19 = __s;
      }
      if (rfc3394_unwrap_legacy((uint64_t)v19, 0x20u, 0xA6A6A6A6A6A6A6A6, 0, v18, 0x28u, a6, &v21))
      {
        memset_s(__s, 0x20uLL, 0, 0x20uLL);
LABEL_40:
        v8 = 4294967277;
        goto LABEL_35;
      }
    }
    memset_s(__s, 0x20uLL, 0, 0x20uLL);
    v8 = 0;
    *a7 = 32;
  }
LABEL_35:
  if ((a3 & 8) != 0)
    memset_s(v24, 0x20uLL, 0, 0x20uLL);
  return v8;
}

uint64_t rfc3394_wrap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t *, uint64_t *, uint64_t), uint64_t *a5, unint64_t a6, _QWORD *a7, unint64_t *a8)
{
  size_t v14;
  size_t v15;
  uint64_t v16;
  unint64_t v17;
  BOOL v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  uint64_t *v37;
  unint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  _OWORD __s[4];
  uint64_t v43;

  v39 = a1;
  v40 = a3;
  v43 = *MEMORY[0x24BDAC8D0];
  memset(__s, 0, sizeof(__s));
  ccaes_cbc_encrypt_mode();
  MEMORY[0x24BDAC7A8]();
  v41 = (char *)&v34 - v14;
  bzero((char *)&v34 - v14, v14);
  MEMORY[0x24BDAC7A8]();
  bzero((char *)&v34 - v15, v15);
  v16 = 0xFFFFFFFFLL;
  if (HIDWORD(a6) || (a6 - 40) < 0xFFFFFFE0)
    goto LABEL_30;
  v37 = &v34;
  v38 = a8;
  v36 = a7;
  if (!a4)
  {
    v18 = (a2 & 0xFFFFFFFFFFFFFFF7) == 0x10 || a2 == 32;
    if (!v18 || !a8 || *a8 < a6 + 8)
    {
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      goto LABEL_31;
    }
    v35 = a6 + 8;
    cccbc_init();
    goto LABEL_15;
  }
  if (a8)
  {
    v17 = *v38;
    v35 = a6 + 8;
    if (v17 >= a6 + 8)
    {
LABEL_15:
      v19 = 0;
      v20 = a6 >> 3;
      if (a6 >> 3 <= 1)
        v21 = 1;
      else
        v21 = v20;
      do
      {
        v22 = *a5++;
        *((_QWORD *)&__s[v19++] + 1) = v22;
      }
      while (v21 != v19);
      v23 = 0;
      *(_QWORD *)&__s[0] = v40;
      v24 = 1;
      v39 = v20;
      do
      {
        v40 = v23;
        v25 = 0;
        v26 = (uint64_t *)__s;
        do
        {
          if (a4)
          {
            if ((a4(1, &firebloom_null_iv, v26, v26, 16) & 1) == 0)
              goto LABEL_6;
          }
          else
          {
            cccbc_clear_iv();
            firebloom_cbc_update_f();
          }
          v27 = *v26;
          v26 += 2;
          v28 = v27 ^ bswap64(v24 + v25++);
          *(_QWORD *)&__s[v25 % v20] = v28;
        }
        while (v21 != v25);
        v23 = v40 + 1;
        v24 += v39;
      }
      while (v40 != 5);
      v29 = v36;
      *v36 = *(_QWORD *)&__s[0];
      v30 = v29 + 1;
      v31 = (uint64_t *)__s + 1;
      do
      {
        v32 = *v31;
        v31 += 2;
        *v30++ = v32;
        --v21;
      }
      while (v21);
      v16 = 0;
      *v38 = v35 & 0xFFFFFFF8;
LABEL_30:
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      if (a4)
        return v16;
LABEL_31:
      cc_clear();
      return v16;
    }
  }
LABEL_6:
  memset_s(__s, 0x40uLL, 0, 0x40uLL);
  return 0xFFFFFFFFLL;
}

uint64_t rfc3394_wrap_legacy(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t *, uint64_t *, uint64_t), uint64_t *a5, unsigned int a6, _QWORD *a7, _DWORD *a8)
{
  uint64_t v9;
  unint64_t v11;

  v11 = *a8;
  v9 = rfc3394_wrap(a1, a2, a3, a4, a5, a6, a7, &v11);
  REQUIRE_func(HIDWORD(v11) == 0, 171, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/aeskeywrap.c");
  *a8 = v11;
  return v9;
}

uint64_t rfc3394_unwrap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(_QWORD, void *, unint64_t *, unint64_t *, uint64_t), _QWORD *a5, unint64_t a6, _QWORD *a7, _QWORD *a8)
{
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  size_t v17;
  uint64_t v18;
  unsigned int v19;
  BOOL v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  unint64_t *v28;
  int v29;
  unsigned int v30;
  BOOL v31;
  _QWORD *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t *v40;
  _QWORD *v41;
  unint64_t *v42;
  uint64_t v43;
  unint64_t v44;
  _QWORD *v45;
  char *v46;
  _OWORD __s[4];
  uint64_t v48;

  v45 = a5;
  v43 = a1;
  v48 = *MEMORY[0x24BDAC8D0];
  memset(__s, 0, sizeof(__s));
  v14 = ccaes_cbc_decrypt_mode();
  MEMORY[0x24BDAC7A8](v14);
  v46 = (char *)&v37 - v15;
  bzero((char *)&v37 - v15, v15);
  MEMORY[0x24BDAC7A8](v16);
  bzero((char *)&v37 - v17, v17);
  v18 = 0xFFFFFFFFLL;
  if (HIDWORD(a6))
    goto LABEL_33;
  v39 = a3;
  v19 = a6 >> 3;
  if ((a6 >> 3) - 6 < 0xFFFFFFFC)
    goto LABEL_33;
  v40 = &v37;
  v41 = a8;
  v38 = a7;
  v44 = a6;
  if (!a4)
  {
    v20 = (a2 & 0xFFFFFFFFFFFFFFF7) == 0x10 || a2 == 32;
    if (!v20 || !a8 || *a8 < a6 - 8)
    {
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      goto LABEL_34;
    }
    cccbc_init();
    goto LABEL_15;
  }
  if (a8 && *v41 >= v44 - 8)
  {
LABEL_15:
    *(_QWORD *)&__s[0] = *v45;
    v21 = v19 - 1;
    if (v19 != 1)
    {
      v22 = (_QWORD *)__s + 1;
      v23 = v45 + 1;
      v24 = v19 - 1;
      do
      {
        v25 = *v23++;
        *v22 = v25;
        v22 += 2;
        --v24;
      }
      while (v24);
    }
    v26 = 6 * v19 - 6;
    LODWORD(v43) = 1 - v19;
    v27 = 5;
    v42 = (unint64_t *)&__s[v19 - 2];
    do
    {
      LODWORD(v45) = v27;
      if (v44 >= 0x10)
      {
        v28 = v42;
        v29 = v21;
        v30 = v26;
        do
        {
          *v28 = *(_QWORD *)&__s[v29 % v21] ^ bswap64(v30);
          if (a4)
          {
            if ((a4(0, &firebloom_null_iv, v28, v28, 16) & 1) == 0)
              goto LABEL_6;
          }
          else
          {
            cccbc_clear_iv();
            firebloom_cbc_update_f();
          }
          --v30;
          v28 -= 2;
          v31 = __OFSUB__(v29--, 1);
        }
        while (!((v29 < 0) ^ v31 | (v29 == 0)));
      }
      v27 = (_DWORD)v45 - 1;
      v26 += v43;
    }
    while ((_DWORD)v45);
    if (*(_QWORD *)&__s[0] == v39)
    {
      v32 = v38;
      if ((_DWORD)v21)
      {
        v33 = (uint64_t *)__s + 1;
        v34 = v21;
        do
        {
          v35 = *v33;
          v33 += 2;
          *v32++ = v35;
          --v34;
        }
        while (v34);
      }
      v18 = 0;
      *v41 = (8 * v21);
    }
    else
    {
      v18 = 0xFFFFFFFFLL;
    }
LABEL_33:
    memset_s(__s, 0x40uLL, 0, 0x40uLL);
    if (a4)
      return v18;
LABEL_34:
    cc_clear();
    return v18;
  }
LABEL_6:
  memset_s(__s, 0x40uLL, 0, 0x40uLL);
  return 0xFFFFFFFFLL;
}

uint64_t rfc3394_unwrap_legacy(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(_QWORD, void *, unint64_t *, unint64_t *, uint64_t), _QWORD *a5, unsigned int a6, _QWORD *a7, _DWORD *a8)
{
  uint64_t v9;
  uint64_t v11;

  v11 = *a8;
  v9 = rfc3394_unwrap(a1, a2, a3, a4, a5, a6, a7, &v11);
  REQUIRE_func(HIDWORD(v11) == 0, 261, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/aeskeywrap.c");
  *a8 = v11;
  return v9;
}

uint64_t rfc3394_wrapped_size_legacy(unsigned int a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  int v5;

  v2 = a1 + 15;
  v3 = v2 << 31 >> 31;
  v4 = v3 != v2 || v3 < 0;
  v5 = v4;
  if (!v4)
    *a2 = v3 & 0xFFFFFFF8;
  return v5 ^ 1u;
}

uint64_t rfc3394_wrapped_size(unint64_t a1, unint64_t *a2)
{
  uint64_t v2;
  BOOL v3;
  int v4;

  v2 = a1 >= 0xFFFFFFFFFFFFFFF1;
  v3 = v2 << 63 >> 63 != v2 || v2 << 63 >> 63 == -1;
  v4 = v3;
  if (!v3)
    *a2 = (a1 + 15) & 0xFFFFFFFFFFFFFFF8;
  return v4 ^ 1u;
}

BOOL rfc3394_unwrapped_size_legacy(unsigned int a1, unsigned int *a2)
{
  unsigned int v2;
  _BOOL8 result;

  v2 = a1 - 8;
  result = a1 > 7;
  *a2 = v2;
  return result;
}

BOOL rfc3394_unwrapped_size(unint64_t a1, unint64_t *a2)
{
  unint64_t v2;
  _BOOL8 result;

  v2 = a1 - 8;
  result = a1 > 7;
  *a2 = v2;
  return result;
}

uint64_t lib_platform_rng()
{
  uint64_t v0;

  v0 = ccrng();
  REQUIRE_func(v0 != 0, 22, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform_lib.c");
  REQUIRE_func(0, 23, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform_lib.c");
  return v0;
}

uint64_t lib_platform_read_random(uint64_t a1, unsigned int a2)
{
  unsigned int (*v4)(uint64_t, _QWORD, uint64_t);
  uint64_t v5;
  _BOOL8 v6;

  v4 = *(unsigned int (**)(uint64_t, _QWORD, uint64_t))platform_rng();
  v5 = platform_rng();
  v6 = v4(v5, a2, a1) == 0;
  return REQUIRE_func(v6, 31, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform_lib.c");
}

uint64_t lib_platform_get_device_id(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  __int128 v5;
  uint64_t v6;
  int v7;

  if (!a2)
    return 0xFFFFFFFFLL;
  if (*a2 < 0x1AuLL)
    return 0xFFFFFFFFLL;
  if ((lib_platform_get_device_id_s_device_id_len & 1) == 0)
  {
    v7 = 0;
    v6 = 0;
    if (platform_get_chip_id((uint64_t)&v7) || platform_get_ecid((uint64_t)&v6))
      return 4294967284;
    LODWORD(lib_platform_get_device_id_s_device_id) = v7;
    byte_swap_val((char *)&lib_platform_get_device_id_s_device_id, 4uLL);
    *(_QWORD *)((char *)&lib_platform_get_device_id_s_device_id + 4) = v6;
    byte_swap_val((char *)&lib_platform_get_device_id_s_device_id + 4, 0x10uLL);
    lib_platform_get_device_id_s_device_id_len = 1;
  }
  *a2 = 20;
  result = 0;
  if (a1)
  {
    v5 = lib_platform_get_device_id_s_device_id;
    *(_DWORD *)(a1 + 16) = dword_254F27BBC;
    *(_OWORD *)a1 = v5;
  }
  return result;
}

uint64_t lib_platform_get_chip_id(uint64_t result)
{
  _DWORD *v1;
  uint64_t v2;
  int v3;

  if (result)
  {
    v1 = (_DWORD *)result;
    v2 = MGGetSInt64Answer();
    if (v2)
    {
      v3 = v2;
      result = 0;
      *v1 = v3;
    }
    else
    {
      return 4294967284;
    }
  }
  return result;
}

uint64_t lib_platform_get_ecid(uint64_t result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = (_QWORD *)result;
    v2 = MGGetSInt64Answer();
    if (v2)
    {
      v3 = v2;
      result = 0;
      *v1 = v3;
    }
    else
    {
      return 4294967284;
    }
  }
  return result;
}

uint64_t lib_platform_get_board_id(uint64_t result)
{
  _DWORD *v1;
  uint64_t v2;
  int v3;

  if (result)
  {
    v1 = (_DWORD *)result;
    v2 = MGGetSInt64Answer();
    if (v2)
    {
      v3 = v2;
      result = 0;
      *v1 = v3;
    }
    else
    {
      return 4294967284;
    }
  }
  return result;
}

BOOL der_key_equal(unsigned __int8 *a1, const void *a2)
{
  return der_equal(a1, (uint64_t)&a1[a1[1] + 2], a2);
}

uint64_t der_dict_find_value(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (a1)
  {
    der_dict_iterate();
    if (a2)
    {
      if (a3)
      {
        *a2 = 0;
        *a3 = 0;
      }
    }
  }
  return 0;
}

BOOL _dict_find_value_cb(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL4 v8;

  v8 = der_equal(*(const void **)a5, *(_QWORD *)a5 + *(unsigned __int8 *)(*(_QWORD *)a5 + 1) + 2, a1);
  if (v8)
  {
    *(_BYTE *)(a5 + 24) = 1;
    *(_QWORD *)(a5 + 8) = a3;
    *(_QWORD *)(a5 + 16) = a3 + a4;
  }
  return !v8;
}

uint64_t der_dict_get_number(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4)
    return 0;
  if (result)
  {
    der_dict_iterate();
    return 0;
  }
  return result;
}

uint64_t der_dict_get_data(uint64_t result)
{
  if (result)
  {
    der_dict_iterate();
    return 0;
  }
  return result;
}

double der_utils_decode_implicit_raw_octet_string(__int128 *a1, uint64_t a2, _DWORD *a3, _QWORD *a4)
{
  double result;
  __int128 v8;

  v8 = *a1;
  if (ccder_blob_decode_range())
  {
    *a4 = 0;
    *a3 = 0;
    result = *(double *)&v8;
    *a1 = v8;
  }
  return result;
}

uint64_t der_array_iterate(uint64_t a1, uint64_t a2, unsigned int (*a3)(uint64_t, _QWORD, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;

  *(_QWORD *)&v12 = a1;
  *((_QWORD *)&v12 + 1) = a2;
  v6 = ccder_blob_decode_range();
  if ((_DWORD)v6)
  {
    v11 = 0;
    v7 = v12;
    if (der_utils_decode_tl(&v12, &v10, &v11))
    {
      do
      {
        v8 = v12 + v11;
        if (!a3(v7, v12 + v11 - v7, a4))
          break;
        *(_QWORD *)&v12 = v8;
        v7 = v8;
      }
      while ((der_utils_decode_tl(&v12, &v10, &v11) & 1) != 0);
    }
  }
  return v6;
}

uint64_t der_utils_decode_tl(__int128 *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  __int128 v7;

  v7 = *a1;
  result = ccder_blob_decode_tag();
  if ((_DWORD)result)
  {
    result = ccder_blob_decode_len();
    if ((_DWORD)result)
    {
      *a1 = v7;
      *a2 = 0;
      *a3 = 0;
      return 1;
    }
  }
  return result;
}

uint64_t encode_list_remove_key(_QWORD *a1, unsigned __int8 *a2)
{
  _QWORD **v2;
  uint64_t result;
  uint64_t v4;
  _QWORD *i;
  void *v6;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = (_QWORD **)a1;
  result = (uint64_t)_encode_list_find_key(a1, a2);
  if (result)
  {
    v4 = result;
    for (i = *v2; i != (_QWORD *)result; i = (_QWORD *)*i)
      v2 = (_QWORD **)i;
    *v2 = *(_QWORD **)result;
    v6 = *(void **)(result + 8);
    if (v6)
    {
      memset_s(v6, *(_QWORD *)(v4 + 16), 0, *(_QWORD *)(v4 + 16));
      free(*(void **)(v4 + 8));
    }
    memset_s((void *)v4, 0x18uLL, 0, 0x18uLL);
    free((void *)v4);
    return 0;
  }
  return result;
}

_QWORD *_encode_list_find_key(_QWORD *a1, unsigned __int8 *a2)
{
  _QWORD *v2;
  const void *v5;

  if (!a1)
    return 0;
  v2 = (_QWORD *)*a1;
  if (*a1)
  {
    do
    {
      v5 = (const void *)v2[1];
      if (ccder_blob_decode_sequence_tl() && der_equal(a2, (uint64_t)&a2[a2[1] + 2], v5))
        break;
      v2 = (_QWORD *)*v2;
    }
    while (v2);
  }
  return v2;
}

uint64_t encode_list_get_data(_QWORD *a1, unsigned __int8 *a2, int a3, _QWORD *a4, _QWORD *a5)
{
  _QWORD *key;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v15;

  key = _encode_list_find_key(a1, a2);
  if (!key)
    return 0;
  v9 = 1;
  if (a4)
  {
    if (a5)
    {
      v10 = key[1] + key[2];
      *(_QWORD *)&v15 = key[1];
      *((_QWORD *)&v15 + 1) = v10;
      v9 = ccder_blob_decode_sequence_tl();
      if ((_DWORD)v9)
      {
        if (der_utils_decode_implicit_raw_octet_string_copy(&v15, 12, 0, 0))
        {
          v11 = v15;
          if (ccder_blob_decode_tag())
          {
            if (ccder_blob_decode_len())
            {
              v13 = 0;
              v12 = v15;
              if (a3)
              {
                v13 = (v15 - v11);
                v12 = v11;
              }
              *a4 = v12;
              *a5 = v13;
            }
          }
        }
      }
    }
  }
  return v9;
}

uint64_t der_utils_decode_implicit_raw_octet_string_copy(__int128 *a1, uint64_t a2, uint64_t a3, int a4)
{
  __int128 v8;

  v8 = *a1;
  if ((ccder_blob_decode_range() & 1) == 0 || a3 && a4)
    return 0;
  *a1 = v8;
  return 1;
}

uint64_t encode_list_cstr_get_data(_QWORD *a1, char *__s, void *a3, size_t a4)
{
  unsigned __int8 *v7;
  uint64_t result;
  void *__src;
  uint64_t v10;
  _BYTE v11[2];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[31];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  memset(v18, 0, sizeof(v18));
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v12 = 0u;
  v11[0] = 12;
  v11[1] = strlen(__s);
  v7 = (unsigned __int8 *)der_key_validate((uint64_t)v11);
  result = 0xFFFFFFFFLL;
  if (a3 && v7)
  {
    __memcpy_chk();
    __src = 0;
    v10 = 0;
    if (encode_list_get_data(a1, v7, 0, &__src, &v10))
    {
      if (v10 == a4)
      {
        memcpy(a3, __src, a4);
        return 0;
      }
      else
      {
        return 4294967277;
      }
    }
    else
    {
      return 4294967293;
    }
  }
  return result;
}

uint64_t der_key_validate(uint64_t a1)
{
  if ((ccder_blob_decode_tl() & 1) == 0)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s bad 1%s\n", "aks", "", "", "", "der_key_validate");
    return 0;
  }
  return a1;
}

uint64_t encode_list_get_number(_QWORD *a1, unsigned __int8 *a2, uint64_t *a3)
{
  uint64_t data;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;

  v7 = 0;
  v8 = 0;
  data = encode_list_get_data(a1, a2, 1, &v7, &v8);
  v5 = data;
  if (a3 && (_DWORD)data)
    *a3 = der_get_number();
  return v5;
}

uint64_t encode_list_get_BOOL(_QWORD *a1, unsigned __int8 *a2, _BYTE *a3)
{
  uint64_t data;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;

  v7 = 0;
  v8 = 0;
  data = encode_list_get_data(a1, a2, 1, &v7, &v8);
  v5 = data;
  if (a3 && (_DWORD)data)
    *a3 = der_get_BOOL();
  return v5;
}

uint64_t encode_list_merge_dict(uint64_t a1)
{
  if (a1)
    return der_dict_iterate() - 1;
  else
    return 4294967285;
}

uint64_t _merge_dict_cb(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  unsigned __int8 *v8;
  uint64_t v9;

  v8 = (unsigned __int8 *)der_key_validate(a1);
  if (v8)
  {
    v9 = (uint64_t)v8;
    if (!encode_list_remove_key(a5, v8) && !encode_list_add_der(a5, v9, a3, a3 + a4))
      return 1;
  }
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s fail%s\n", "aks", "", "", "", "_merge_dict_cb", ":", 647, "", 0, "", "");
  return 0;
}

uint64_t encode_list_add_der(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  size_t v6;
  char *v7;
  char *v8;
  int v9;
  char *v10;
  int v11;
  char *v12;
  _QWORD *v14;
  _QWORD *v15;
  char *v16;
  char *v17;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3 && a4)
  {
    if (der_get_sizeof(a3) <= (unint64_t)(a4 - a3))
    {
      v6 = ccder_sizeof();
      v7 = (char *)calloc(v6, 1uLL);
      if (!v7)
        return 4294967279;
      v8 = v7;
      v16 = &v7[v6];
      if (ccder_blob_encode_body())
      {
        v9 = ccder_blob_encode_body();
        v10 = v16;
        if (!v9)
          v10 = 0;
        v17 = v10;
        v11 = ccder_blob_encode_tl();
        v12 = v17;
        if (!v11)
          v12 = 0;
        if (v12 && v12 == v8)
        {
          v14 = calloc(0x18uLL, 1uLL);
          if (v14)
          {
            v15 = v14;
            result = 0;
            v15[1] = v8;
            v15[2] = v6;
            *v15 = *a1;
            *a1 = v15;
            return result;
          }
        }
      }
      memset_s(v8, v6, 0, v6);
      free(v8);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t encode_list_add_key(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return encode_list_add_der(a1, a2, a3, a3 + *(unsigned __int8 *)(a3 + 1) + 2);
}

uint64_t encode_list_add_data(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  size_t v5;
  char *v6;
  char *v7;
  int v8;
  char *v9;
  int v10;
  char *v11;
  BOOL v12;
  _QWORD *v13;
  _QWORD *v14;
  char *v15;
  char *v16;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    ccder_sizeof();
    v5 = ccder_sizeof();
    v6 = (char *)calloc(v5, 1uLL);
    if (v6)
    {
      v7 = v6;
      v15 = &v6[v5];
      if (!ccder_blob_encode_body() || !ccder_blob_encode_tl())
        goto LABEL_19;
      v8 = ccder_blob_encode_body();
      v9 = v15;
      if (!v8)
        v9 = 0;
      v16 = v9;
      v10 = ccder_blob_encode_tl();
      v11 = v16;
      if (!v10)
        v11 = 0;
      v12 = v11 && v11 == v7;
      if (v12 && (v13 = calloc(0x18uLL, 1uLL)) != 0)
      {
        v14 = v13;
        result = 0;
        v14[1] = v7;
        v14[2] = v5;
        *v14 = *a1;
        *a1 = v14;
      }
      else
      {
LABEL_19:
        memset_s(v7, v5, 0, v5);
        free(v7);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

uint64_t encode_list_cstr_add_data(_QWORD *a1, char *__s, uint64_t a3)
{
  uint64_t v5;
  uint64_t result;
  _BYTE v7[2];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[31];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  memset(v14, 0, sizeof(v14));
  v13 = 0u;
  v12 = 0u;
  v11 = 0u;
  v10 = 0u;
  v9 = 0u;
  v8 = 0u;
  v7[0] = 12;
  v7[1] = strlen(__s);
  v5 = der_key_validate((uint64_t)v7);
  result = 4294967285;
  if (a3)
  {
    if (v5)
    {
      __memcpy_chk();
      return encode_list_add_data(a1, v5, a3);
    }
  }
  return result;
}

uint64_t encode_list_add_BOOL(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  size_t v4;
  char *v5;
  char *v6;
  int v7;
  char *v8;
  int v9;
  char *v10;
  BOOL v11;
  _QWORD *v12;
  _QWORD *v13;
  char *v14;
  char *v15;

  result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    ccder_sizeof();
    v4 = ccder_sizeof();
    v5 = (char *)calloc(v4, 1uLL);
    if (v5)
    {
      v6 = v5;
      v14 = &v5[v4];
      if (!ccder_blob_encode_body() || !ccder_blob_encode_tl())
        goto LABEL_18;
      v7 = ccder_blob_encode_body();
      v8 = v14;
      if (!v7)
        v8 = 0;
      v15 = v8;
      v9 = ccder_blob_encode_tl();
      v10 = v15;
      if (!v9)
        v10 = 0;
      v11 = v10 && v10 == v6;
      if (v11 && (v12 = calloc(0x18uLL, 1uLL)) != 0)
      {
        v13 = v12;
        result = 0;
        v13[1] = v6;
        v13[2] = v4;
        *v13 = *a1;
        *a1 = v13;
      }
      else
      {
LABEL_18:
        memset_s(v6, v4, 0, v4);
        free(v6);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

uint64_t encode_list_add_string(_QWORD *a1, uint64_t a2, char *__s)
{
  uint64_t result;
  size_t v5;
  char *v6;
  char *v7;
  int v8;
  char *v9;
  int v10;
  char *v11;
  BOOL v12;
  _QWORD *v13;
  _QWORD *v14;
  char *v15;
  char *v16;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 && __s)
  {
    strlen(__s);
    ccder_sizeof();
    v5 = ccder_sizeof();
    v6 = (char *)calloc(v5, 1uLL);
    if (v6)
    {
      v7 = v6;
      v15 = &v6[v5];
      if (!ccder_blob_encode_body() || !ccder_blob_encode_tl())
        goto LABEL_19;
      v8 = ccder_blob_encode_body();
      v9 = v15;
      if (!v8)
        v9 = 0;
      v16 = v9;
      v10 = ccder_blob_encode_tl();
      v11 = v16;
      if (!v10)
        v11 = 0;
      v12 = v11 && v11 == v7;
      if (v12 && (v13 = calloc(0x18uLL, 1uLL)) != 0)
      {
        v14 = v13;
        result = 0;
        v14[1] = v7;
        v14[2] = v5;
        *v14 = *a1;
        *a1 = v14;
      }
      else
      {
LABEL_19:
        memset_s(v7, v5, 0, v5);
        free(v7);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

uint64_t encode_list_add_list(_QWORD *a1, uint64_t a2, _QWORD *a3)
{
  char *v3;
  uint64_t v4;
  size_t v5;
  char *v7;
  int v8;
  char *v9;
  int v10;
  char *v11;
  BOOL v12;
  _QWORD *v13;
  char *v15;
  void *__s;
  rsize_t __n;
  char *v18;
  char *v19;

  v3 = 0;
  __s = 0;
  __n = 0;
  v4 = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    v5 = 0;
    if (a3)
    {
      if (encode_list_dict(a3, &__s, &__n))
      {
        v3 = 0;
        v5 = 0;
      }
      else
      {
        v5 = ccder_sizeof();
        v7 = (char *)calloc(v5, 1uLL);
        v3 = v7;
        if (v7)
        {
          v15 = &v7[v5];
          if (!ccder_blob_encode_body())
            goto LABEL_23;
          v18 = v3;
          v19 = v15;
          v8 = ccder_blob_encode_body();
          v9 = v19;
          if (!v8)
            v9 = 0;
          v18 = v3;
          v19 = v9;
          v10 = ccder_blob_encode_tl();
          v11 = v19;
          if (!v10)
            v11 = 0;
          v12 = v11 && v11 == v3;
          if (v12 && (v13 = calloc(0x18uLL, 1uLL)) != 0)
          {
            v4 = 0;
            v13[1] = v3;
            v13[2] = v5;
            *v13 = *a1;
            *a1 = v13;
            v3 = 0;
          }
          else
          {
LABEL_23:
            v4 = 0xFFFFFFFFLL;
          }
        }
        else
        {
          v4 = 4294967279;
        }
      }
    }
  }
  else
  {
    v5 = 0;
  }
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  if (v3)
  {
    memset_s(v3, v5, 0, v5);
    free(v3);
  }
  return v4;
}

uint64_t ccder_sizeof_fv_data()
{
  return ccder_sizeof();
}

uint64_t ccder_sizeof_fv_key()
{
  uint64_t v0;

  v0 = ccder_sizeof();
  return ccder_sizeof() + v0;
}

uint64_t der_utils_encode_fv_key(__int128 *a1, uint64_t a2)
{
  uint64_t result;
  __int128 v4;

  v4 = *a1;
  if (a2)
  {
    result = ccder_blob_encode_body_tl();
    if (!(_DWORD)result)
      return result;
    if ((ccder_blob_encode_body_tl() & 1) == 0)
      return 0;
  }
  else if (!ccder_blob_encode_body_tl() || (ccder_blob_encode_tl() & 1) == 0)
  {
    return 0;
  }
  *a1 = v4;
  return 1;
}

uint64_t der_utils_decode_fv_key(__int128 *a1, int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t result;
  int v10;
  __int128 v11;
  int *v12;
  uint64_t v13;
  __int128 v14;

  v6 = *(_QWORD *)a3;
  v5 = *(_QWORD *)(a3 + 8);
  v7 = *(_DWORD *)(a3 + 20);
  v11 = *a1;
  if (a2)
  {
    v14 = *a1;
    v12 = 0;
    v13 = 0;
    if ((ccder_blob_decode_range() & 1) == 0)
      return 0;
    v6 = (uint64_t)v12;
    v8 = v13 - (_DWORD)v12;
    v11 = v14;
  }
  else
  {
    LODWORD(v14) = v5;
    result = der_utils_decode_implicit_raw_octet_string_copy_len(&v11, 4, v6, &v14);
    if (!(_DWORD)result)
      return result;
    v8 = v14;
  }
  v14 = v11;
  v12 = 0;
  v13 = 0;
  if ((ccder_blob_decode_range() & 1) == 0)
    return 0;
  v11 = v14;
  if ((v13 - (_DWORD)v12) > 4)
    return 0;
  v10 = *v12;
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v8;
  *(_DWORD *)(a3 + 16) = v10;
  *(_DWORD *)(a3 + 20) = v7;
  *a1 = v11;
  return 1;
}

uint64_t der_utils_decode_implicit_raw_octet_string_copy_len(__int128 *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  __int128 v8;

  v8 = *a1;
  if ((ccder_blob_decode_range() & 1) == 0)
    return 0;
  if (a3)
  {
    if (a4)
      *a4 = 0;
  }
  *a1 = v8;
  return 1;
}

uint64_t der_utils_encode_fv_data(__int128 *a1, uint64_t a2)
{
  uint64_t result;
  __int128 v4;

  v4 = *a1;
  if (a2)
  {
    if ((ccder_blob_encode_body_tl() & 1) == 0)
      return 0;
  }
  else
  {
    result = ccder_blob_encode_tl();
    if (!(_DWORD)result)
      return result;
  }
  *a1 = v4;
  return 1;
}

uint64_t der_utils_decode_fv_data(__int128 *a1, int a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;

  v6 = *a3;
  v5 = a3[1];
  v9 = *a1;
  if (a2)
  {
    v12 = *a1;
    v10 = 0;
    v11 = 0;
    result = ccder_blob_decode_range();
    if (!(_DWORD)result)
      return result;
    v6 = v10;
    v8 = v11 - v10;
    v9 = v12;
  }
  else
  {
    LODWORD(v12) = v5;
    result = der_utils_decode_implicit_raw_octet_string_copy_len(&v9, 4, v6, &v12);
    if (!(_DWORD)result)
      return result;
    v8 = v12;
  }
  *a3 = v6;
  a3[1] = v8;
  *a1 = v9;
  return 1;
}

uint64_t der_utils_encode_fv_params(__int128 *a1, uint64_t a2)
{
  uint64_t result;
  __int128 v4;

  v4 = *a1;
  if (a2)
  {
    if ((ccder_blob_encode_body_tl() & 1) == 0)
      return 0;
  }
  else
  {
    result = ccder_blob_encode_tl();
    if (!(_DWORD)result)
      return result;
  }
  *a1 = v4;
  return 1;
}

uint64_t der_utils_decode_fv_params(__int128 *a1)
{
  __int128 v3;

  v3 = *a1;
  if ((ccder_blob_decode_range() & 1) == 0)
    return 0;
  *a1 = v3;
  return 1;
}

uint64_t encode_extended_state(unsigned int *a1, int a2, _QWORD *a3, _DWORD *a4)
{
  uint64_t v8;
  uint64_t v10;
  size_t v11;
  void *v12;

  v12 = 0;
  if (encode_list_add_number(&v12, (uint64_t)der_key_state_state, *a1)
    || encode_list_add_number(&v12, (uint64_t)der_key_state_lock_state, a1[1])
    || encode_list_add_number(&v12, (uint64_t)der_key_state_backoff, *((_QWORD *)a1 + 1))
    || encode_list_add_number(&v12, (uint64_t)der_key_state_failed_attempts, a1[4])
    || encode_list_add_number(&v12, (uint64_t)der_key_state_generation_state, a1[5])
    || encode_list_add_number(&v12, (uint64_t)der_key_state_recovery_countdown, *(_QWORD *)((char *)a1 + 26))|| encode_list_add_number(&v12, (uint64_t)der_key_state_more_state, *(_QWORD *)((char *)a1 + 34))|| encode_list_add_number(&v12, (uint64_t)der_key_keybag_handle, *(int *)((char *)a1 + 42))|| encode_list_add_number(&v12, (uint64_t)der_key_config_max_unlock_attempts, *(unsigned int *)((char *)a1 + 46))|| encode_list_add_data(&v12, (uint64_t)der_key_config_user_uuid, (uint64_t)a1 + 50)|| a2&& (encode_list_add_number(&v12, (uint64_t)der_key_state_assertion_set, *((char *)a1 + 66))|| encode_list_add_number(&v12, (uint64_t)der_key_state_grace_period_enabled, *((char *)a1 + 67))|| encode_list_add_number(&v12, (uint64_t)der_key_lock_time, *(_QWORD *)(a1 + 17))|| encode_list_add_number(&v12, (uint64_t)der_key_cx_window, *(_QWORD *)(a1 + 19)))|| (v10 = 0, v11 = 0, encode_list_dict(&v12, &v10, &v11)))
  {
    v8 = 0xFFFFFFFFLL;
  }
  else
  {
    v8 = 0;
    *a3 = v10;
    *a4 = v11;
  }
  encode_list_free(&v12);
  return v8;
}

uint64_t decode_memento_state(uint64_t a1, int a2, _BYTE *__s)
{
  uint64_t result;
  int number;

  result = 0xFFFFFFFFLL;
  if (a2 && a1 && __s)
  {
    memset_s(__s, 0x10uLL, 0, 0x10uLL);
    if (der_dict_iterate())
    {
      *__s = der_get_number();
      *((_DWORD *)__s + 1) = der_get_number();
      *((_DWORD *)__s + 2) = der_get_number();
      number = der_get_number();
      result = 0;
      *((_DWORD *)__s + 3) = number;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t decode_primary_identity_state(uint64_t a1, int a2, void *__s, void *a4, uint64_t a5)
{
  uint64_t result;
  __int128 v10[2];
  __int128 v11;
  uint64_t v12;
  void *v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  result = 0xFFFFFFFFLL;
  if (a2 && a1 && __s && a4)
  {
    memset_s(__s, 0x10uLL, 0, 0x10uLL);
    memset_s(a4, 0x10uLL, 0, 0x10uLL);
    v12 = 0;
    v10[0] = 0u;
    v11 = 0u;
    v14 = 0u;
    v15 = 0u;
    v10[1] = (unint64_t)der_key_group_uuid;
    v13 = der_key_uuid;
    der_dict_iterate();
    if (der_utils_decode_implicit_raw_octet_string_copy(v10, 4, (uint64_t)__s, 16)
      && der_utils_decode_implicit_raw_octet_string_copy((__int128 *)((char *)&v11 + 8), 4, (uint64_t)a4, 16))
    {
      return der_utils_decode_implicit_raw_octet_string_copy(&v15, 4, a5, 16) - 1;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t decode_fv_blob_state(uint64_t a1, uint64_t a2, _DWORD *__s)
{
  uint64_t result;
  int v6;
  int number;
  __int128 v8;
  uint64_t v9;
  void *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  void *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  void *v22;
  __int128 v23;
  __int128 v24;
  void *v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  void *v29;
  __int128 v30;
  __int128 v31;
  void *v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  void *v36;
  __int128 v37;
  __int128 v38;
  void *v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  void *v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  result = 0xFFFFFFFFLL;
  if (a2 && a1 && __s)
  {
    memset_s(__s, 0x58uLL, 0, 0x58uLL);
    v24 = 0u;
    v26 = 0;
    v27 = 0u;
    v28 = 0;
    v30 = 0u;
    v31 = 0u;
    v33 = 0;
    v34 = 0u;
    v35 = 0;
    v37 = 0u;
    v38 = 0u;
    v40 = 0;
    v41 = 0u;
    v42 = 0;
    v44 = 0u;
    v45 = 0u;
    v8 = 0u;
    v9 = 0;
    v11 = 0u;
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    v15 = 0;
    v17 = 0u;
    v18 = 0u;
    v19 = 0u;
    v20 = 0u;
    v21 = 0;
    v23 = 0u;
    v10 = der_key_id;
    *(_QWORD *)&v13 = der_key_flags;
    v16 = der_key_version;
    *(_QWORD *)&v19 = der_key_state_reserved;
    v22 = der_key_state_failed_attempts;
    v25 = der_key_state_failed_attempts_other;
    v29 = der_key_config_max_unlock_attempts;
    v32 = der_key_state_backoff;
    v36 = der_key_state_backoff_other;
    v39 = der_key_config_capabilities;
    v43 = der_key_state_refcount;
    der_dict_iterate();
    *__s = der_get_number();
    if (der_utils_decode_implicit_raw_octet_string_copy((__int128 *)((char *)&v8 + 8), 4, (uint64_t)(__s + 1), 16)&& der_utils_decode_implicit_raw_octet_string_copy(&v12, 4, (uint64_t)(__s + 5), 16)&& (__s[9] = der_get_number(), __s[10] = der_get_number(), __s[11] = der_get_number(), __s[12] = der_get_number(), __s[15] = der_get_number(), __s[13] = der_get_number(), __s[14] = der_get_number(), der_utils_decode_implicit_raw_octet_string_copy_partial((__int128 *)((char *)&v20 + 8))))
    {
      v6 = __s[9];
      if ((v6 & 0x400) != 0)
      {
        *((_QWORD *)__s + 9) = der_get_number();
        v6 = __s[9];
      }
      if ((v6 & 0x800) != 0)
      {
        number = der_get_number();
        result = 0;
        __s[20] = number;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t der_utils_decode_implicit_raw_octet_string_copy_partial(__int128 *a1)
{
  uint64_t v2;
  __int128 v4;

  v4 = *a1;
  v2 = ccder_blob_decode_range();
  if ((v2 & 1) != 0)
    *a1 = v4;
  return v2;
}

uint64_t encode_pfk_params_public(int *a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t v3;
  int v7;
  uint64_t v9;
  size_t v10;
  void *v11;

  v11 = 0;
  v3 = 4294967273;
  if (a2 && a3)
  {
    if (a1 && (v7 = *a1) != 0)
    {
      if ((v7 & 1) != 0)
      {
        encode_list_cstr_add_data(&v11, "persona_uuid", (uint64_t)(a1 + 1));
        v7 = *a1;
      }
      if ((v7 & 2) != 0)
        encode_list_cstr_add_data(&v11, "volume_uuid", (uint64_t)(a1 + 5));
      v9 = 0;
      v10 = 0;
      if (!encode_list_dict(&v11, &v9, &v10))
      {
        v3 = 0;
        *a2 = v9;
        *a3 = v10;
      }
    }
    else
    {
      v3 = 0;
      *a2 = 0;
      *a3 = 0;
    }
  }
  encode_list_free(&v11);
  return v3;
}

uint64_t decode_pfk_params_internal(uint64_t a1, uint64_t a2, char *__s)
{
  uint64_t v3;
  void *v6;

  v6 = 0;
  v3 = 0xFFFFFFFFLL;
  if (a2 && a1 && __s)
  {
    memset_s(__s, 0x24uLL, 0, 0x24uLL);
    if (der_dict_iterate())
    {
      if (!encode_list_cstr_get_data(&v6, "volume_uuid", __s + 20, 0x10uLL))
        *(_DWORD *)__s |= 2u;
      v3 = 0;
      if (!encode_list_cstr_get_data(&v6, "persona_uuid", __s + 4, 0x10uLL))
        *(_DWORD *)__s |= 1u;
    }
    else
    {
      v3 = 0xFFFFFFFFLL;
    }
  }
  encode_list_free(&v6);
  return v3;
}

uint64_t encode_fv_params_internal(uint64_t a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v8;
  size_t v9;
  void *v10;

  v10 = 0;
  v3 = 4294967273;
  if (a2 && a3)
  {
    if (a1)
    {
      if (!encode_list_cstr_add_data(&v10, "options", a1)
        && !encode_list_cstr_add_data(&v10, "kc", a1 + 8))
      {
        v8 = 0;
        v9 = 0;
        if (!encode_list_dict(&v10, &v8, &v9))
        {
          v3 = 0;
          *a2 = v8;
          *a3 = v9;
        }
      }
    }
    else
    {
      v3 = 0;
      *a2 = 0;
      *a3 = 0;
    }
  }
  encode_list_free(&v10);
  return v3;
}

uint64_t decode_fv_params_internal(uint64_t a1, uint64_t a2, char *__s)
{
  uint64_t v3;
  void *v6;

  v6 = 0;
  v3 = 0xFFFFFFFFLL;
  if (a2 && a1 && __s)
  {
    memset_s(__s, 0x10uLL, 0, 0x10uLL);
    if (der_dict_iterate())
    {
      encode_list_cstr_get_data(&v6, "options", __s, 8uLL);
      encode_list_cstr_get_data(&v6, "kc", __s + 8, 4uLL);
      v3 = 0;
    }
    else
    {
      v3 = 0xFFFFFFFFLL;
    }
  }
  encode_list_free(&v6);
  return v3;
}

uint64_t ref_key_op_der_to_enum(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;

  result = 0;
  v4 = *MEMORY[0x24BDAC8D0];
  if (a1 && a2)
  {
    if (der_key_op)
      der_dict_iterate();
    return 0;
  }
  return result;
}

uint64_t der_utils_decode_implicit_raw_octet_string_alloc(__int128 *a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t result;
  __int128 v8;

  v8 = *a1;
  if ((ccder_blob_decode_range() & 1) == 0)
    return 0;
  if (a3 && a4)
  {
    result = (uint64_t)calloc(0, 1uLL);
    if (!result)
      return result;
    *a3 = result;
    *a4 = 0;
  }
  *a1 = v8;
  return 1;
}

uint64_t der_utils_decode_implicit_uint64(__int128 *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  __int128 v6;

  if (a3)
    *a3 = 0;
  v6 = *a1;
  result = ccder_blob_decode_range();
  if ((_DWORD)result)
  {
    if (ccn_read_uint())
    {
      return 0;
    }
    else
    {
      *a1 = v6;
      if (a3)
        *a3 = 0;
      return 1;
    }
  }
  return result;
}

uint64_t _qsort_compare(const void **a1, void **a2)
{
  int v2;
  void *__s2;
  const void *v5;

  v5 = *a1;
  __s2 = *a2;
  if (!ccder_blob_decode_sequence_tl()
    || !ccder_blob_decode_sequence_tl()
    || !ccder_blob_decode_tag()
    || !ccder_blob_decode_len()
    || !v5
    || !ccder_blob_decode_tag()
    || !ccder_blob_decode_len()
    || !__s2)
  {
    return 4294967293;
  }
  v2 = memcmp(v5, __s2, 0);
  if (v2 > 0)
    return 1;
  else
    return ((v2 < 0) << 31 >> 31);
}

uint64_t sizeof_backup_bag()
{
  ccder_sizeof_implicit_uint64();
  ccder_sizeof_raw_octet_string();
  ccder_sizeof_raw_octet_string();
  ccder_sizeof_implicit_uint64();
  return ccder_sizeof();
}

uint64_t encode_backup_bag(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t result;
  uint64_t v6;

  v6 = a2 + a3;
  if (!ccder_blob_encode_implicit_uint64()
    || !ccder_blob_encode_body_tl()
    || !ccder_blob_encode_body_tl()
    || !ccder_blob_encode_body_tl()
    || !ccder_blob_encode_implicit_uint64())
  {
    return 4294967273;
  }
  v3 = ccder_blob_encode_tl();
  result = 4294967273;
  if (v3)
  {
    if (a2 == v6)
      return 0;
    else
      return 4294967273;
  }
  return result;
}

uint64_t decode_backup_bag(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  int v4;
  uint64_t result;
  __int128 v6;

  *(_QWORD *)&v6 = a1;
  *((_QWORD *)&v6 + 1) = a1 + a2;
  if (!ccder_blob_decode_range()
    || !der_utils_decode_implicit_uint64(&v6, 0x8000000000000000, a3)
    || !der_utils_decode_implicit_raw_octet_string_copy(&v6, 0x8000000000000001, (uint64_t)(a3 + 1), 16)
    || !der_utils_decode_implicit_raw_octet_string_copy(&v6, 0x8000000000000002, (uint64_t)(a3 + 3), 40)
    || !der_utils_decode_implicit_raw_octet_string_copy(&v6, 0x8000000000000003, (uint64_t)(a3 + 8), 16))
  {
    return 4294967277;
  }
  v4 = der_utils_decode_implicit_uint64(&v6, 0x8000000000000004, a3 + 10);
  result = 4294967277;
  if (v4)
  {
    if ((_QWORD)v6 == *((_QWORD *)&v6 + 1))
      return 0;
    else
      return 4294967277;
  }
  return result;
}

uint64_t wrap_backup_bag(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v12;
  _OWORD __s[2];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  memset(__s, 0, sizeof(__s));
  v12 = 40;
  *(_QWORD *)a4 = 0;
  uuid_copy((unsigned __int8 *)(a4 + 8), (const unsigned __int8 *)(a1 + 32));
  *(_QWORD *)(a4 + 80) = 1;
  platform_read_random(a4 + 64, 0x10u);
  v8 = ccsha256_di();
  if (firebloom_ccpbkdf2_hmac(v8, a3, a2, 16, a4 + 64, *(_QWORD *)(a4 + 80), 32, __s))
  {
    v10 = 4294967286;
  }
  else
  {
    v9 = rfc3394_wrap_legacy((uint64_t)__s, 0x20u, 0xA6A6A6A6A6A6A6A6, 0, (uint64_t *)a1, 0x20u, (_QWORD *)(a4 + 24), &v12);
    if ((_DWORD)v9)
    {
      v10 = v9;
    }
    else if (v12 == 40)
    {
      v10 = 0;
    }
    else
    {
      v10 = 4294967286;
    }
  }
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  return v10;
}

uint64_t unwrap_backup_bag(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v12;
  _OWORD __s[2];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  memset(__s, 0, sizeof(__s));
  v12 = 32;
  if (*(_QWORD *)a1)
  {
    v10 = 4294967284;
  }
  else
  {
    v8 = ccsha256_di();
    if (firebloom_ccpbkdf2_hmac(v8, a3, a2, 16, a1 + 64, *(_QWORD *)(a1 + 80), 32, __s))
      goto LABEL_9;
    v9 = rfc3394_unwrap_legacy((uint64_t)__s, 0x20u, 0xA6A6A6A6A6A6A6A6, 0, (_QWORD *)(a1 + 24), 0x28u, (_QWORD *)a4, &v12);
    if ((_DWORD)v9)
    {
      v10 = v9;
      goto LABEL_8;
    }
    if (v12 != 32)
    {
LABEL_9:
      v10 = 4294967286;
    }
    else
    {
      cccurve25519_make_pub();
      if (uuid_compare((const unsigned __int8 *)(a1 + 8), (const unsigned __int8 *)(a4 + 32)))
        v10 = 4294967272;
      else
        v10 = 0;
    }
  }
LABEL_8:
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  return v10;
}

uint64_t aks_get_pad_size(int a1)
{
  return -a1 & 3;
}

char *aks_copy_packed_data(_DWORD *a1, const void *a2, int a3)
{
  char *v3;
  int v5;
  size_t v6;
  int __s;

  v3 = (char *)(a1 + 1);
  if (a2)
  {
    *a1 = a3;
    memcpy(a1 + 1, a2, a3);
    v3 += a3;
    v5 = -a3;
    v6 = -a3 & 3;
    if ((v5 & 3) != 0)
    {
      __s = 0;
      memset_s(&__s, 4uLL, 0, 4uLL);
      memcpy(v3, &__s, v6);
      v3 += v6;
    }
  }
  else
  {
    *a1 = 0;
  }
  return v3;
}

char *aks_pack_data(char **a1, unsigned int *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unsigned int v12;
  int v13;
  uint64_t *v14;
  char *result;
  char *v16;
  int v17;
  uint64_t v18;
  const void **v19;
  const void *v20;
  uint64_t *v21;
  const void **v22;

  v21 = &a9;
  v12 = 4;
  if (a3)
  {
    v13 = a3;
    do
    {
      v14 = v21;
      v21 += 2;
      v12 += *((_DWORD *)v14 + 2) + (-*((_DWORD *)v14 + 2) & 3) + 4;
      --v13;
    }
    while (v13);
  }
  result = (char *)calloc(1uLL, v12);
  v16 = result;
  v22 = (const void **)&a9;
  v17 = 0;
  if (a3)
  {
    v18 = 4;
    do
    {
      v19 = v22;
      v20 = *v22;
      v22 += 2;
      result = aks_copy_packed_data(&v16[v18], v20, *((_DWORD *)v19 + 2));
      v18 = result - v16;
      ++v17;
    }
    while (a3 != v17);
  }
  *(_DWORD *)v16 = v17;
  *a1 = v16;
  *a2 = v12;
  return result;
}

uint64_t aks_unpack_data(unsigned int *a1, unint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unsigned int v9;
  char *v11;
  void **v12;
  void *v13;
  char *v14;
  size_t v15;
  unsigned int v16;
  size_t *v17;
  void **v19;

  if (a2 < 4)
    return 0xFFFFFFFFLL;
  v9 = a3;
  if (*a1 >= a3)
  {
    v19 = (void **)&a9;
    if (!a3)
      return 0;
    v11 = (char *)(a1 + 1);
    while (1)
    {
      v12 = v19;
      v13 = *v19;
      v19 += 2;
      v16 = *(_DWORD *)v11;
      v14 = v11 + 4;
      v15 = v16;
      if (v16 > a2)
        break;
      if (v13)
      {
        v17 = (size_t *)v12[1];
        if (*v17 < v15)
          return 0xFFFFFFFFLL;
        memcpy(v13, v14, v15);
        *v17 = v15;
      }
      v11 = &v14[v15];
      if (!--v9)
        return 0;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t aks_fv_new_vek(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  mach_port_t aks_client_connection;
  mach_port_t v15;
  uint64_t v16;
  __int128 v18;
  __int128 v19;
  size_t v20;
  uint64_t input[2];
  _BYTE __s[4096];
  _QWORD v23[2];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = v1;
  v23[0] = *MEMORY[0x24BDAC8D0];
  bzero(__s, 0x1000uLL);
  *(_QWORD *)&v19 = __s;
  *((_QWORD *)&v19 + 1) = v23;
  v20 = 4096;
  v13 = 3758097090;
  if (v7 && v5)
  {
    aks_client_connection = get_aks_client_connection();
    if (!aks_client_connection)
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_fv_new_vek", ":", 179, "", 0, "", "");
      v13 = 3758097084;
      goto LABEL_16;
    }
    v15 = aks_client_connection;
    if (!ccder_blob_encode_body_tl()
      || !der_utils_encode_fv_data(&v19, v9)
      || !der_utils_encode_fv_data(&v19, v11)
      || !der_utils_encode_fv_params(&v19, v12)
      || !ccder_blob_encode_tl())
    {
      goto LABEL_14;
    }
    input[0] = *((_QWORD *)&v19 + 1);
    input[1] = (uint64_t)v23 - *((_QWORD *)&v19 + 1);
    v16 = IOConnectCallMethod(v15, 0x4Au, input, 2u, 0, 0, 0, 0, __s, &v20);
    if ((_DWORD)v16)
    {
      v13 = v16;
      goto LABEL_16;
    }
    *(_QWORD *)&v18 = __s;
    *((_QWORD *)&v18 + 1) = &__s[v20];
    if (!ccder_blob_decode_range() || !der_utils_decode_fv_data(&v18, 0, v5))
      goto LABEL_14;
    if (!v3)
    {
      v13 = 0;
      goto LABEL_16;
    }
    v13 = 0;
    if ((der_utils_decode_fv_key(&v18, 0, v3) & 1) == 0)
LABEL_14:
      v13 = 3758097098;
  }
LABEL_16:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v13;
}

unint64_t _aks_save_file(char *a1, const void *a2, size_t a3)
{
  unint64_t v3;
  int v6;
  int v7;
  ssize_t v8;
  int *v10;
  char *v11;
  int *v12;
  char *v13;

  v3 = (unint64_t)a1;
  if (a1)
  {
    v6 = open_dprotected_np(a1, 1793, 4, 0, 384);
    if (v6 == -1)
    {
      v10 = __error();
      v11 = strerror(*v10);
      syslog(3, "could not create file: %s (%s)\n", (const char *)v3, v11);
      return 0;
    }
    else
    {
      v7 = v6;
      v8 = write(v6, a2, a3);
      v3 = v8 != -1;
      if (v8 == -1)
      {
        v12 = __error();
        v13 = strerror(*v12);
        syslog(3, "failed to write restore bag to disk %s\n", v13);
      }
      close(v7);
    }
  }
  return v3;
}

const char *_aks_load_file(char *a1, _QWORD *a2, size_t *a3)
{
  const char *v3;
  size_t st_size;
  int v7;
  int v8;
  void *v9;
  void *v10;
  int *v12;
  char *v13;
  stat v14;

  v3 = a1;
  memset(&v14, 0, sizeof(v14));
  if (a1)
  {
    if (!stat(a1, &v14))
    {
      st_size = v14.st_size;
      v7 = open(v3, 0);
      if (v7 == -1)
      {
        v12 = __error();
        v13 = strerror(*v12);
        syslog(3, "could not open file: %s (%s)\n", v3, v13);
      }
      else
      {
        v8 = v7;
        v9 = calloc(st_size, 1uLL);
        v3 = (const char *)(v9 != 0);
        if (!v9)
        {
LABEL_7:
          close(v8);
          return v3;
        }
        v10 = v9;
        if (read(v8, v9, st_size) == st_size)
        {
          *a2 = v10;
          *a3 = st_size;
          goto LABEL_7;
        }
        close(v8);
        free(v10);
      }
    }
    return 0;
  }
  return v3;
}

uint64_t aks_delete_xart_leak(unsigned int a1, const void *a2)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x6Cu, input, 1u, a2, 0x10uLL, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_delete_xart_leak", ":", 268, "", 0, "", "");
  return 3758097084;
}

char *_iterate_path(char *result, uint64_t a2, uint64_t a3)
{
  FTS *v5;
  FTSENT *v6;
  FTSENT *v7;
  int fts_info;
  char *v9[3];

  v9[2] = *(char **)MEMORY[0x24BDAC8D0];
  if (result)
  {
    v9[0] = result;
    v9[1] = 0;
    result = (char *)fts_open(v9, 84, 0);
    if (result)
    {
      v5 = (FTS *)result;
      v6 = fts_read((FTS *)result);
      if (v6)
      {
        v7 = v6;
        do
        {
          fts_info = v7->fts_info;
          if (fts_info != 6)
          {
            if (fts_info == 1)
            {
              if (a2)
              {
                if (((*(uint64_t (**)(uint64_t, FTSENT *))(a2 + 16))(a2, v7) & 1) == 0)
                  fts_set(v5, v7, 4);
              }
            }
            else if (a3 && fts_info == 8)
            {
              (*(void (**)(uint64_t, FTSENT *))(a3 + 16))(a3, v7);
            }
          }
          v7 = fts_read(v5);
        }
        while (v7);
      }
      return (char *)fts_close(v5);
    }
  }
  return result;
}

char *aks_dump_path(char *result, int a2)
{
  const char *v3;
  _QWORD v4[4];
  int v5;
  _QWORD v6[4];
  int v7;
  char v8[1024];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (result)
  {
    v3 = result;
    bzero(v8, 0x400uLL);
    result = realpath_DARWIN_EXTSN(v3, v8);
    if (result)
    {
      v6[0] = MEMORY[0x24BDAC760];
      v6[1] = 0x40000000;
      v6[2] = __aks_dump_path_block_invoke;
      v6[3] = &__block_descriptor_tmp_0;
      v7 = a2;
      v4[0] = MEMORY[0x24BDAC760];
      v4[1] = 0x40000000;
      v4[2] = __aks_dump_path_block_invoke_2;
      v4[3] = &__block_descriptor_tmp_126;
      v5 = a2;
      return _iterate_path(v8, (uint64_t)v6, (uint64_t)v4);
    }
  }
  return result;
}

uint64_t __aks_dump_path_block_invoke(uint64_t a1, uint64_t a2)
{
  int path_class;
  int v5;

  path_class = _get_path_class(*(const char **)(a2 + 48));
  v5 = *(_DWORD *)(a1 + 32);
  if (v5 == -1 || path_class == v5)
    printf(" dir: %s %i\n", *(const char **)(a2 + 48), path_class);
  return 1;
}

uint64_t _get_path_class(const char *a1)
{
  int v1;
  int v2;
  uint64_t v3;

  v1 = open_dprotected_np(a1, 0, 0, 1);
  if (v1 == -1)
    return 0xFFFFFFFFLL;
  v2 = v1;
  v3 = fcntl(v1, 63);
  if ((v2 & 0x80000000) == 0)
    close(v2);
  return v3;
}

uint64_t __aks_dump_path_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;

  result = _get_path_class(*(const char **)(a2 + 48));
  v5 = *(_DWORD *)(a1 + 32);
  if (v5 == -1 || (_DWORD)result == v5)
    return printf("file: %s %i\n", *(const char **)(a2 + 48), result);
  return result;
}

uint64_t aks_fs_supports_enhanced_apfs()
{
  io_registry_entry_t v0;
  io_object_t v1;
  CFTypeRef CFProperty;
  _BOOL4 v3;
  unsigned int v4;
  size_t __len;
  char __big[1024];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v0 = IORegistryEntryFromPath(*MEMORY[0x24BDD8B20], "IODeviceTree:/filesystems");
  if (v0)
  {
    v1 = v0;
    CFProperty = IORegistryEntryCreateCFProperty(v0, CFSTR("e-apfs"), (CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
    v3 = CFProperty != 0;
    if (CFProperty)
      CFRelease(CFProperty);
    IOObjectRelease(v1);
  }
  else
  {
    v3 = 0;
  }
  __len = 1023;
  bzero(__big, 0x400uLL);
  if ((_aks_check_apfs_shared_datavolume_bootarg_init & 1) == 0)
  {
    if (!sysctlbyname("kern.bootargs", __big, &__len, 0, 0) && strnstr(__big, "-apfs_shared_datavolume", __len))
      _aks_check_apfs_shared_datavolume_bootarg_value = 1;
    _aks_check_apfs_shared_datavolume_bootarg_init = 1;
  }
  v4 = _aks_check_apfs_shared_datavolume_bootarg_value;
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s ioreg: %d, boot_arg: %d%s\n", "aks", "", "", "", "aks_fs_supports_enhanced_apfs", ":", 437, "", 0, "", v3, _aks_check_apfs_shared_datavolume_bootarg_value, "");
  return v3 | v4;
}

uint64_t aks_fs_status(const char *a1)
{
  char __str[1024];
  char v4[1024];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  bzero(v4, 0x400uLL);
  bzero(__str, 0x400uLL);
  if (realpath_DARWIN_EXTSN(a1, v4))
  {
    snprintf(__str, 0x400uLL, "%s/mobile", v4);
    aks_fs_status_with_map(v4, (uint64_t)&sharedPathMap, 35);
    if ((aks_fs_supports_enhanced_apfs() & 1) == 0)
      aks_fs_status_with_map(__str, (uint64_t)&userPathMap, 72);
  }
  return 0;
}

void aks_fs_status_with_map(const char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  stat v7;
  char __str[1024];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  bzero(__str, 0x400uLL);
  memset(&v7, 0, sizeof(v7));
  if (a3)
  {
    v6 = a2 + 16;
    do
    {
      snprintf(__str, 0x400uLL, "%s%s", a1, *(const char **)(v6 - 16));
      if (stat(__str, &v7))
      {
        printf("stat failed: %s\n");
      }
      else
      {
        _get_path_class(__str);
        printf("%s: mode=%o, u/g=%i:%i class=%i%s\n");
      }
      v6 += 48;
      --a3;
    }
    while (a3);
  }
}

uint64_t aks_user_fs_status(const char *a1)
{
  char v3[1024];
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  bzero(v3, 0x400uLL);
  if (realpath_DARWIN_EXTSN(a1, v3))
    aks_fs_status_with_map(v3, (uint64_t)&userPathMap, 72);
  return 0;
}

const char *aks_show_allowlist()
{
  puts("shared allow list:");
  aks_show_allowlist_with_map("<var>", (uint64_t)&sharedPathMap, 35);
  puts("user allow list:");
  return aks_show_allowlist_with_map("<user>", (uint64_t)&userPathMap, 72);
}

const char *aks_show_allowlist_with_map(const char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  const char *v4;
  const char **v5;
  const char **v6;
  char v7;

  if (a3)
  {
    v3 = a3;
    v4 = result;
    v5 = (const char **)(a2 + 16);
    v6 = (const char **)(a2 + 16);
    do
    {
      v7 = *(_BYTE *)v6;
      v6 += 6;
      if ((v7 & 1) != 0)
        result = (const char *)printf("%s%s\n", v4, *(v5 - 2));
      v5 = v6;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t aks_fv_new_kek(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  mach_port_t aks_client_connection;
  mach_port_t v13;
  uint64_t v14;
  __int128 v16;
  __int128 v17;
  size_t v18;
  uint64_t input[3];
  _BYTE __s[4096];
  uint64_t v21;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = v1;
  v21 = *MEMORY[0x24BDAC8D0];
  bzero(__s, 0x1000uLL);
  *(_QWORD *)&v17 = __s;
  *((_QWORD *)&v17 + 1) = &v21;
  v18 = 4096;
  v11 = 3758097090;
  if (v5 && v3)
  {
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      v13 = aks_client_connection;
      if (!ccder_blob_encode_body_tl()
        || !der_utils_encode_fv_data(&v17, v7)
        || !der_utils_encode_fv_params(&v17, v10)
        || !ccder_blob_encode_tl())
      {
        goto LABEL_10;
      }
      input[0] = v9;
      input[1] = *((_QWORD *)&v17 + 1);
      input[2] = (uint64_t)&v21 - *((_QWORD *)&v17 + 1);
      v14 = IOConnectCallMethod(v13, 0x4Cu, input, 3u, 0, 0, 0, 0, __s, &v18);
      if ((_DWORD)v14)
      {
        v11 = v14;
        goto LABEL_12;
      }
      *(_QWORD *)&v16 = __s;
      *((_QWORD *)&v16 + 1) = &__s[v18];
      if (!ccder_blob_decode_range() || (v11 = 0, (der_utils_decode_fv_data(&v16, 0, v3) & 1) == 0))
LABEL_10:
        v11 = 3758097098;
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_fv_new_kek", ":", 508, "", 0, "", "");
      v11 = 3758097084;
    }
  }
LABEL_12:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v11;
}

uint64_t aks_fv_new_sibling_vek()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  mach_port_t aks_client_connection;
  mach_port_t v12;
  uint64_t v13;
  __int128 v15;
  __int128 v16;
  size_t v17;
  uint64_t input[2];
  _BYTE __s[4096];
  uint64_t v20;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v9 = v0;
  v20 = *MEMORY[0x24BDAC8D0];
  bzero(__s, 0x1000uLL);
  *(_QWORD *)&v16 = __s;
  *((_QWORD *)&v16 + 1) = &v20;
  v17 = 4096;
  v10 = 3758097090;
  if (v6 && v4)
  {
    aks_client_connection = get_aks_client_connection();
    if (!aks_client_connection)
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_fv_new_sibling_vek", ":", 543, "", 0, "", "");
      v10 = 3758097084;
      goto LABEL_15;
    }
    v12 = aks_client_connection;
    if (!ccder_blob_encode_body_tl()
      || !der_utils_encode_fv_data(&v16, v8)
      || !der_utils_encode_fv_params(&v16, v9)
      || !ccder_blob_encode_tl())
    {
      goto LABEL_13;
    }
    input[0] = *((_QWORD *)&v16 + 1);
    input[1] = (uint64_t)&v20 - *((_QWORD *)&v16 + 1);
    v13 = IOConnectCallMethod(v12, 0x63u, input, 2u, 0, 0, 0, 0, __s, &v17);
    if ((_DWORD)v13)
    {
      v10 = v13;
      goto LABEL_15;
    }
    *(_QWORD *)&v15 = __s;
    *((_QWORD *)&v15 + 1) = &__s[v17];
    if (!ccder_blob_decode_range() || !der_utils_decode_fv_data(&v15, 0, v4))
      goto LABEL_13;
    if (!v2)
    {
      v10 = 0;
      goto LABEL_15;
    }
    v10 = 0;
    if ((der_utils_decode_fv_key(&v15, 0, v2) & 1) == 0)
LABEL_13:
      v10 = 3758097098;
  }
LABEL_15:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v10;
}

uint64_t aks_fv_rewrap_kek(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  mach_port_t aks_client_connection;
  mach_port_t v15;
  uint64_t v16;
  __int128 v18;
  __int128 v19;
  size_t v20;
  uint64_t input[2];
  _BYTE __s[4096];
  _QWORD v23[2];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = v1;
  v23[0] = *MEMORY[0x24BDAC8D0];
  bzero(__s, 0x1000uLL);
  *(_QWORD *)&v19 = __s;
  *((_QWORD *)&v19 + 1) = v23;
  v20 = 4096;
  v13 = 3758097090;
  if (v9 && v7 && v5 && v3)
  {
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      v15 = aks_client_connection;
      if (!der_utils_encode_fv_data(&v19, v5)
        || !ccder_blob_encode_body_tl()
        || !der_utils_encode_fv_data(&v19, v9)
        || !der_utils_encode_fv_data(&v19, v11)
        || !der_utils_encode_fv_params(&v19, v12)
        || !ccder_blob_encode_tl())
      {
        goto LABEL_14;
      }
      input[0] = *((_QWORD *)&v19 + 1);
      input[1] = (uint64_t)v23 - *((_QWORD *)&v19 + 1);
      v16 = IOConnectCallMethod(v15, 0x4Du, input, 2u, 0, 0, 0, 0, __s, &v20);
      if ((_DWORD)v16)
      {
        v13 = v16;
        goto LABEL_16;
      }
      *(_QWORD *)&v18 = __s;
      *((_QWORD *)&v18 + 1) = &__s[v20];
      if (!ccder_blob_decode_range() || (v13 = 0, (der_utils_decode_fv_data(&v18, 0, v3) & 1) == 0))
LABEL_14:
        v13 = 3758097098;
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_fv_rewrap_kek", ":", 582, "", 0, "", "");
      v13 = 3758097084;
    }
  }
LABEL_16:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v13;
}

uint64_t aks_fv_set_protection(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  mach_port_t aks_client_connection;
  mach_port_t v16;
  uint64_t v17;
  uint64_t *v19;
  __int128 v20;
  __int128 v21;
  size_t v22;
  uint64_t input[4];
  _BYTE __s[4096];
  _QWORD v25[2];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v19 = v2;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v13 = v1;
  v25[0] = *MEMORY[0x24BDAC8D0];
  v14 = 3758097098;
  bzero(__s, 0x1000uLL);
  *(_QWORD *)&v21 = __s;
  *((_QWORD *)&v21 + 1) = v25;
  v22 = 4096;
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_fv_set_protection", ":", 616, "", 0, "", "");
    v14 = 3758097084;
    goto LABEL_14;
  }
  v16 = aks_client_connection;
  if (der_utils_encode_fv_data(&v21, v4)
    && der_utils_encode_fv_data(&v21, v6)
    && der_utils_encode_fv_data(&v21, v8)
    && der_utils_encode_fv_params(&v21, v13)
    && ccder_blob_encode_tl())
  {
    input[0] = v12;
    input[1] = v10;
    input[2] = *((_QWORD *)&v21 + 1);
    input[3] = (uint64_t)v25 - *((_QWORD *)&v21 + 1);
    v17 = IOConnectCallMethod(v16, 0x54u, input, 4u, 0, 0, 0, 0, __s, &v22);
    if ((_DWORD)v17)
    {
      v14 = v17;
      goto LABEL_14;
    }
    *(_QWORD *)&v20 = __s;
    *((_QWORD *)&v20 + 1) = &__s[v22];
    if (!v22)
      goto LABEL_13;
    if (!ccder_blob_decode_range())
      goto LABEL_14;
    if (!v19)
    {
LABEL_13:
      v14 = 0;
      goto LABEL_14;
    }
    v14 = 0;
    if ((der_utils_decode_fv_data(&v20, 0, v19) & 1) == 0)
      v14 = 3758097098;
  }
LABEL_14:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v14;
}

uint64_t aks_fv_unwrap_vek_with_acm()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  mach_port_t aks_client_connection;
  mach_port_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v19;
  __int128 v20;
  size_t v21;
  uint64_t input[3];
  _BYTE __s[4096];
  _QWORD v24[2];

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v13 = v0;
  v24[0] = *MEMORY[0x24BDAC8D0];
  bzero(__s, 0x1000uLL);
  *(_QWORD *)&v20 = __s;
  *((_QWORD *)&v20 + 1) = v24;
  v21 = 4096;
  if (!v6)
  {
    v17 = 3758097090;
    goto LABEL_15;
  }
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_fv_unwrap_vek_with_acm", ":", 653, "", 0, "", "");
    v17 = 3758097084;
    goto LABEL_15;
  }
  v15 = aks_client_connection;
  if (!der_utils_encode_fv_data(&v20, v4)
    || !der_utils_encode_fv_data(&v20, v6)
    || !der_utils_encode_fv_data(&v20, v8)
    || !der_utils_encode_fv_data(&v20, v10)
    || !der_utils_encode_fv_params(&v20, v13)
    || !ccder_blob_encode_tl())
  {
    goto LABEL_13;
  }
  input[0] = *((_QWORD *)&v20 + 1);
  input[1] = (uint64_t)v24 - *((_QWORD *)&v20 + 1);
  input[2] = v12;
  v16 = IOConnectCallMethod(v15, 0x4Bu, input, 3u, 0, 0, 0, 0, __s, &v21);
  if ((_DWORD)v16)
  {
    v17 = v16;
    goto LABEL_15;
  }
  *(_QWORD *)&v19 = __s;
  *((_QWORD *)&v19 + 1) = &__s[v21];
  if (!ccder_blob_decode_range())
    goto LABEL_13;
  if (!v2)
  {
    v17 = 0;
    goto LABEL_15;
  }
  v17 = 0;
  if ((der_utils_decode_fv_key(&v19, 0, v2) & 1) == 0)
LABEL_13:
    v17 = 3758097098;
LABEL_15:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v17;
}

uint64_t aks_fv_unwrap_vek_with_opts()
{
  return aks_fv_unwrap_vek_with_acm();
}

void aks_gather_stats(const char *a1, char a2)
{
  char *v4;
  char *v5;
  uint64_t i;
  char *v7;
  uint64_t k;
  char *v9;
  uint64_t j;
  _QWORD v11[5];
  char v12[1024];
  statfs v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    bzero(&v13, 0x878uLL);
    bzero(v12, 0x400uLL);
    if (realpath_DARWIN_EXTSN(a1, v12))
    {
      v4 = (char *)malloc(0x818uLL);
      memset_s(v4, 0x818uLL, 0, 0x818uLL);
      v11[0] = MEMORY[0x24BDAC760];
      v11[1] = 0x40000000;
      v11[2] = __aks_gather_stats_block_invoke_2;
      v11[3] = &__block_descriptor_tmp_139;
      v11[4] = v4;
      _iterate_path(v12, (uint64_t)&__block_literal_global_0, (uint64_t)v11);
      if (!statfs(v12, &v13))
      {
        if ((a2 & 1) != 0)
          printf("Free Blocks:%lld blocks of size:%d\n");
        else
          printf("%lld,%d\n");
      }
      v5 = v4 + 340;
      for (i = 1; i != 5; ++i)
      {
        if ((a2 & 1) != 0)
        {
          v9 = &v4[296 * i];
          printf("%s:\n\tNum files:\t%u,\n\tNum hardlinks:\t%u,\n\tNum compressed:\t%u,\n\tTotal Size:\t%lld,\n\tMin File Size:\t%lld,\n\tMax File Size:\t%lld,\n", class_names[i], *(_DWORD *)v9, *((_DWORD *)v9 + 2), *((_DWORD *)v9 + 1), *((_QWORD *)v9 + 2), *((_QWORD *)v9 + 3), *((_QWORD *)v9 + 4));
          printf("\tSize Distribution:");
          printf("%i", *((_DWORD *)v9 + 10));
          for (j = 0; j != 252; j += 4)
          {
            putchar(44);
            printf("%i", *(_DWORD *)&v5[j]);
          }
        }
        else
        {
          v7 = &v4[296 * i];
          printf("%i,%u,%u,%u,%lld,%lld,%lld,", i, *(_DWORD *)v7, *((_DWORD *)v7 + 2), *((_DWORD *)v7 + 1), *((_QWORD *)v7 + 2), *((_QWORD *)v7 + 3), *((_QWORD *)v7 + 4));
          printf("%i", *((_DWORD *)v7 + 10));
          for (k = 0; k != 252; k += 4)
          {
            putchar(44);
            printf("%i", *(_DWORD *)&v5[k]);
          }
        }
        putchar(10);
        v5 += 296;
      }
      free(v4);
    }
  }
}

uint64_t __aks_gather_stats_block_invoke()
{
  return 1;
}

uint64_t __aks_gather_stats_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  int64_t v6;
  uint64_t v7;
  uint64_t v8;
  int64_t *v9;
  int64_t v10;
  uint64_t v11;
  int64_t *v12;
  int64_t v13;
  int64_t v14;
  BOOL v15;
  unint64_t v16;

  result = _get_path_class(*(const char **)(a2 + 48));
  if ((result - 7) >= 0xFFFFFFFA)
  {
    v5 = *(_QWORD *)(a2 + 96);
    v6 = *(_QWORD *)(v5 + 96);
    v7 = *(_QWORD *)(a1 + 32);
    ++*(_DWORD *)(v7 + 296 * result);
    if (*(unsigned __int16 *)(v5 + 6) >= 2u)
      ++*(_DWORD *)(v7 + 296 * result + 8);
    if ((*(_BYTE *)(v5 + 116) & 0x20) != 0)
      ++*(_DWORD *)(v7 + 296 * result + 4);
    v8 = v7 + 296 * result;
    v10 = *(_QWORD *)(v8 + 32);
    v9 = (int64_t *)(v8 + 32);
    *(v9 - 2) += v6;
    if (v6 > v10)
      *v9 = v6;
    v11 = v7 + 296 * result;
    v14 = *(_QWORD *)(v11 + 24);
    v12 = (int64_t *)(v11 + 24);
    v13 = v14;
    if (v14)
      v15 = v6 < v13;
    else
      v15 = 1;
    if (v15)
      *v12 = v6;
    if (v6)
      v16 = v7 + 296 * result + 4 * (63 - __clz(v6));
    else
      v16 = v7 + 296 * result;
    ++*(_DWORD *)(v16 + 40);
  }
  return result;
}

uint64_t aks_kext_set_options(unsigned int a1, uint64_t a2)
{
  mach_port_t aks_client_connection;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  input[0] = 1;
  input[1] = a1;
  input[2] = a2;
  output = 0;
  outputCnt = 1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x56u, input, 3u, 0, 0, &output, &outputCnt, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_kext_set_options", ":", 820, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_kext_get_options(unsigned int a1, uint64_t *a2)
{
  uint64_t v2;
  mach_port_t aks_client_connection;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  v2 = 3758097084;
  if (!a2)
    return 3758097090;
  input[0] = 0;
  input[1] = a1;
  input[2] = 0;
  output = 0;
  outputCnt = 1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v2 = IOConnectCallMethod(aks_client_connection, 0x56u, input, 3u, 0, 0, &output, &outputCnt, 0, 0);
    if (!(_DWORD)v2)
      *a2 = output;
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_kext_get_options", ":", 841, "", 0, "", "");
  }
  return v2;
}

uint64_t aks_internal_state()
{
  mach_port_t aks_client_connection;

  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x10u, 0, 0, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_internal_state", ":", 857, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_run_internal_test(unsigned int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x86u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_run_internal_test", ":", 871, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_stash_escrow()
{
  int v0;
  _DWORD *v1;
  _DWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  int v5;
  int v6;
  const void *v7;
  const void *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  mach_port_t aks_client_connection;
  uint64_t v17;
  void *v18;
  size_t __count;
  uint64_t input[4];
  _BYTE __src[32768];
  uint64_t v23;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v14 = v13;
  v15 = v0;
  v23 = *MEMORY[0x24BDAC8D0];
  bzero(__src, 0x8000uLL);
  __count = 0x8000;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = v15;
    input[1] = v14;
    input[2] = v12;
    input[3] = v10;
    if (!v14 || (v17 = 3758097090, v4) && v2)
    {
      v17 = IOConnectCallMethod(aks_client_connection, 0x36u, input, 4u, v8, v6, 0, 0, __src, &__count);
      if (!(_DWORD)v17 && v14)
      {
        v18 = calloc(__count, 1uLL);
        *v4 = v18;
        if (v18)
        {
          memcpy(v18, __src, __count);
          v17 = 0;
          *v2 = __count;
        }
        else
        {
          v17 = 3758097085;
        }
      }
    }
  }
  else
  {
    v17 = 3758097084;
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_stash_escrow", ":", 890, "", 0, "", "");
  }
  memset_s(__src, 0x8000uLL, 0, 0x8000uLL);
  return v17;
}

uint64_t get_akstest_client_connection()
{
  uint64_t result;

  if (get_aks_client_dispatch_queue_onceToken != -1)
    dispatch_once(&get_aks_client_dispatch_queue_onceToken, &__block_literal_global_168);
  dispatch_sync((dispatch_queue_t)get_aks_client_dispatch_queue_connection_queue, &__block_literal_global_154);
  result = get_akstest_client_connection_connection;
  if (!get_akstest_client_connection_connection)
  {
    syslog(3, "failed to open connection to %s\n", "AppleKeyStoreTest");
    return get_akstest_client_connection_connection;
  }
  return result;
}

void __get_akstest_client_connection_block_invoke()
{
  if (!get_akstest_client_connection_connection)
    get_akstest_client_connection_connection = _copy_aks_client_connection("IOService:/IOResources/AppleKeyStoreTest", "AppleKeyStoreTest");
}

uint64_t akstest_new_key(mach_port_t a1, const void *a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, _DWORD *a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  size_t v19;
  uint32_t outputCnt;
  unsigned int outputStruct[256];
  uint64_t output;
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  input[0] = a4;
  input[1] = a3;
  output = 0;
  outputCnt = 1;
  bzero(outputStruct, 0x400uLL);
  v19 = 1024;
  v11 = IOConnectCallMethod(a1, 0xFu, input, 2u, a2, 0x10uLL, &output, &outputCnt, outputStruct, &v19);
  if ((_DWORD)v11)
    return v11;
  v17 = 3758097084;
  if (outputCnt == 1)
  {
    *a7 = output;
    if (aks_unpack_data(outputStruct, v19, 3u, v12, v13, v14, v15, v16, a5))
      return 3758097084;
    else
      return 0;
  }
  return v17;
}

uint64_t akstest_new_ekwk(mach_port_t a1, const void *a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, _DWORD *a7, uint64_t a8, uint64_t a9, _DWORD *a10, uint64_t a11, uint64_t a12, _DWORD *a13)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  size_t v26;
  uint32_t outputCnt;
  unsigned int outputStruct[256];
  uint64_t output;
  uint64_t v30;
  uint64_t v31;
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  input[0] = a4;
  input[1] = a3;
  output = 0;
  v30 = 0;
  v31 = 0;
  outputCnt = 3;
  bzero(outputStruct, 0x400uLL);
  v26 = 1024;
  v17 = IOConnectCallMethod(a1, 0x13u, input, 2u, a2, 0x10uLL, &output, &outputCnt, outputStruct, &v26);
  if ((_DWORD)v17)
    return v17;
  v23 = 3758097084;
  if (outputCnt == 3)
  {
    v24 = v30;
    *a7 = output;
    *a10 = v24;
    *a13 = v31;
    if (aks_unpack_data(outputStruct, v26, 5u, v18, v19, v20, v21, v22, a5))
      return 3758097084;
    else
      return 0;
  }
  return v23;
}

uint64_t akstest_new_ek(mach_port_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, size_t *a8)
{
  uint64_t v11;
  unsigned int inputStructCnt[3];
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a3;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 2, a4, a5, a6, (uint64_t)a7, (uint64_t)a8, a2);
  v11 = IOConnectCallMethod(a1, 0x14u, input, 1u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, a7, a8);
  free(*(void **)&inputStructCnt[1]);
  return v11;
}

uint64_t akstest_rewrap_ek(mach_port_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, uint64_t a10, uint64_t a11, unsigned int a12, void *outputStruct, size_t *a14, _DWORD *a15)
{
  uint64_t v16;
  uint64_t v17;
  uint32_t outputCnt;
  unsigned int inputStructCnt[3];
  uint64_t output;
  uint64_t input[5];

  input[4] = *MEMORY[0x24BDAC8D0];
  input[0] = a3;
  input[1] = a6;
  input[2] = a9;
  input[3] = a12;
  output = 0;
  outputCnt = 1;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 4, a4, a5, a6, a7, a8, a2);
  v16 = IOConnectCallMethod(a1, 0x15u, input, 4u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], &output, &outputCnt, outputStruct, a14);
  if ((_DWORD)v16)
  {
    v17 = v16;
  }
  else if (outputCnt == 1)
  {
    v17 = 0;
    *a15 = output;
  }
  else
  {
    v17 = 3758097084;
  }
  free(*(void **)&inputStructCnt[1]);
  return v17;
}

uint64_t akstest_unwrap_key(mach_port_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t outputStructCnt;
  unsigned int inputStructCnt[3];
  unsigned int outputStruct[256];
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  input[0] = a3;
  input[1] = a6;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  bzero(outputStruct, 0x400uLL);
  outputStructCnt = 1024;
  aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 2, v10, v11, v12, v13, v14, a2);
  v15 = IOConnectCallMethod(a1, 0x10u, input, 2u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, outputStruct, &outputStructCnt);
  if ((_DWORD)v15)
  {
    v21 = v15;
  }
  else if (aks_unpack_data(outputStruct, outputStructCnt, 2u, v16, v17, v18, v19, v20, a7))
  {
    v21 = 3758097084;
  }
  else
  {
    v21 = 0;
  }
  free(*(void **)&inputStructCnt[1]);
  return v21;
}

uint64_t akstest_unwrap_ek(mach_port_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, unsigned int a9, uint64_t a10)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  size_t v25;
  unsigned int inputStructCnt[3];
  unsigned int outputStruct[256];
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  input[0] = a3;
  input[1] = a6;
  input[2] = a9;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  bzero(outputStruct, 0x400uLL);
  v25 = 1024;
  aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 3, v12, v13, v14, v15, v16, a2);
  v17 = IOConnectCallMethod(a1, 0x17u, input, 3u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, outputStruct, &v25);
  if ((_DWORD)v17)
  {
    v23 = v17;
  }
  else if (aks_unpack_data(outputStruct, v25, 2u, v18, v19, v20, v21, v22, a10))
  {
    v23 = 3758097084;
  }
  else
  {
    v23 = 0;
  }
  free(*(void **)&inputStructCnt[1]);
  return v23;
}

uint64_t akstest_check_class(mach_port_t a1, void *inputStruct, unsigned int a3)
{
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a3;
  return IOConnectCallMethod(a1, 0x11u, input, 1u, inputStruct, 0x10uLL, 0, 0, 0, 0);
}

uint64_t akstest_last_user(mach_port_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unsigned int inputStructCnt[3];
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a2;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 1, a4, a5, a6, a7, a8, a3);
  v9 = IOConnectCallMethod(a1, 0x12u, input, 1u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, 0, 0);
  free(*(void **)&inputStructCnt[1]);
  return v9;
}

uint64_t aks_get_internal_info_for_key(uint64_t a1)
{
  int v1;
  size_t *v2;
  size_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  const void *v6;
  const void *v7;
  mach_port_t aks_client_connection;
  size_t v9;
  uint64_t v10;
  size_t v11;
  void *v12;
  uint64_t v13;
  size_t __count;
  _BYTE __src[32768];
  uint64_t input[2];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = v1;
  bzero(__src, 0x8000uLL);
  __count = 0x8000;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (v7)
      v9 = 18;
    else
      v9 = 0;
    v10 = IOConnectCallMethod(aks_client_connection, 0x5Du, input, 1u, v7, v9, 0, 0, __src, &__count);
    v11 = __count;
    if ((_DWORD)v10)
    {
      v13 = v10;
    }
    else if (__count - 32769 < 0xFFFFFFFFFFFF8000)
    {
      v13 = 3758097090;
    }
    else
    {
      v12 = calloc(__count, 1uLL);
      *v5 = v12;
      v11 = __count;
      if (v12)
      {
        *v3 = __count;
        memcpy(v12, __src, v11);
        v13 = 0;
        v11 = __count;
      }
      else
      {
        v13 = 3758097085;
      }
    }
  }
  else
  {
    v13 = 3758097084;
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_internal_info_for_key", ":", 1246, "", 0, "", "");
    v11 = 0x8000;
  }
  memset_s(__src, v11, 0, v11);
  return v13;
}

uint64_t aks_operation_optional_params(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7, _QWORD *a8)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  size_t v18;
  void *v19;

  v19 = 0;
  if (a1
    && (v14 = a1 + a2, der_get_sizeof(a1) == a2)
    && encode_list_add_der(&v19, (uint64_t)der_key_access_groups, a1, v14)
    || a3
    && der_get_sizeof(a3) == a4
    && encode_list_add_der(&v19, (uint64_t)der_key_external_data, a3, a3 + a4)
    || a5 && encode_list_add_data(&v19, (uint64_t)der_key_acm_handle, a5)
    || (v17 = 0, v18 = 0, encode_list_dict(&v19, &v17, &v18)))
  {
    v15 = 0xFFFFFFFFLL;
  }
  else
  {
    v15 = 0;
    *a7 = v17;
    *a8 = v18;
  }
  encode_list_free(&v19);
  return v15;
}

void *aks_params_create(uint64_t a1)
{
  _QWORD *v2;
  void *v3;

  v2 = calloc(8uLL, 1uLL);
  v3 = v2;
  if (v2)
  {
    *v2 = 0;
    if (a1)
    {
      if (encode_list_merge_dict((uint64_t)v2))
      {
        memset_s(v3, 8uLL, 0, 8uLL);
        free(v3);
        return 0;
      }
    }
  }
  return v3;
}

uint64_t aks_params_set_BOOL(_QWORD *a1, int a2, uint64_t a3)
{
  uint64_t v5;
  unsigned __int8 *der_key;
  uint64_t v7;

  v5 = 3758097090;
  der_key = (unsigned __int8 *)_params_get_der_key(a2, 3);
  if (der_key)
  {
    v7 = (uint64_t)der_key;
    if (!encode_list_remove_key(a1, der_key) && (!a3 || !encode_list_add_BOOL(a1, v7)))
      return 0;
  }
  return v5;
}

void *_params_get_der_key(int a1, int a2)
{
  void **v2;
  void *result;
  void **v4;
  void *v5;
  BOOL v6;

  switch(a1)
  {
    case 1:
      v2 = (void **)&der_key_access_groups;
      goto LABEL_28;
    case 2:
      v2 = (void **)&der_key_external_data;
      goto LABEL_28;
    case 3:
      v2 = (void **)&der_key_acm_handle;
      goto LABEL_28;
    case 4:
      v2 = (void **)&der_key_salt;
      goto LABEL_28;
    case 5:
      v2 = (void **)&der_key_data;
      goto LABEL_28;
    case 6:
      v2 = (void **)&der_key_ecdh_seed;
      goto LABEL_28;
    case 7:
      v2 = (void **)&der_key_ecdh_iv;
      goto LABEL_28;
    case 8:
      v4 = (void **)&der_key_raw_output;
      goto LABEL_30;
    case 9:
      v4 = (void **)&der_key_options;
      goto LABEL_30;
    case 10:
      v2 = (void **)&der_key_shared_info;
      goto LABEL_28;
    case 11:
      v2 = (void **)&der_key_shared_info2;
      goto LABEL_28;
    case 12:
      v2 = (void **)&der_key_transcode_shared_info;
      goto LABEL_28;
    case 13:
      v2 = (void **)&der_key_transcode_shared_info2;
      goto LABEL_28;
    case 14:
      v2 = (void **)&der_key_transcode_ecdh_seed;
      goto LABEL_28;
    case 15:
      v2 = (void **)&der_key_persona_uuid;
      goto LABEL_28;
    case 16:
      v4 = (void **)&der_key_sub_key_type;
      goto LABEL_30;
    case 17:
      v2 = (void **)&der_key_system_key_client_seed;
      goto LABEL_28;
    case 18:
      v4 = (void **)&der_key_system_key_options;
      goto LABEL_30;
    case 19:
      v5 = der_key_system_key_no_img4;
      v6 = a2 == 3;
      goto LABEL_31;
    case 20:
      v4 = (void **)&der_key_remote_session_signing_key_type;
      goto LABEL_30;
    case 21:
      v2 = (void **)&der_key_remote_session_signing_key_certificate;
      goto LABEL_28;
    case 22:
      v4 = (void **)&der_key_gid_ref_key_options;
      goto LABEL_30;
    case 23:
      v4 = (void **)&der_key_pka_flags;
      goto LABEL_30;
    case 24:
      v2 = (void **)&der_key_volume_uuid;
      goto LABEL_28;
    case 25:
      v2 = (void **)&der_key_seed;
LABEL_28:
      v5 = *v2;
      v6 = a2 == 2;
      goto LABEL_31;
    case 26:
      v4 = (void **)&der_key_test_flags;
LABEL_30:
      v5 = *v4;
      v6 = a2 == 1;
LABEL_31:
      if (v6)
        result = v5;
      else
        result = 0;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t aks_params_get_BOOL(_QWORD *a1, int a2, _BYTE *a3)
{
  uint64_t result;
  char v6;

  v6 = 0;
  result = (uint64_t)_params_get_der_key(a2, 3);
  if (result)
  {
    result = encode_list_get_BOOL(a1, (unsigned __int8 *)result, &v6);
    if ((_DWORD)result)
    {
      if (v6)
      {
        result = 1;
        *a3 = 1;
      }
    }
  }
  return result;
}

uint64_t aks_params_set_number(_QWORD *a1, int a2, uint64_t *a3)
{
  uint64_t v5;
  unsigned __int8 *der_key;
  uint64_t v7;

  v5 = 3758097090;
  der_key = (unsigned __int8 *)_params_get_der_key(a2, 1);
  if (der_key)
  {
    v7 = (uint64_t)der_key;
    if (!encode_list_remove_key(a1, der_key)
      && (!a3 || !encode_list_add_number(a1, v7, *a3)))
    {
      return 0;
    }
  }
  return v5;
}

uint64_t aks_params_get_number(_QWORD *a1, int a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v6;

  v6 = 0;
  result = (uint64_t)_params_get_der_key(a2, 1);
  if (result)
  {
    result = encode_list_get_number(a1, (unsigned __int8 *)result, &v6);
    if (a3)
    {
      if ((_DWORD)result)
      {
        *a3 = v6;
        return 1;
      }
    }
  }
  return result;
}

uint64_t aks_params_set_data(_QWORD *a1, int a2, uint64_t a3)
{
  uint64_t v6;
  unsigned __int8 *der_key;
  uint64_t v8;

  v6 = 3758097090;
  der_key = (unsigned __int8 *)_params_get_der_key(a2, 2);
  if (der_key)
  {
    v8 = (uint64_t)der_key;
    if (!encode_list_remove_key(a1, der_key))
    {
      if (a3)
      {
        if (a2 == 1 || a2 == 2)
        {
          ccder_blob_decode_tag();
          return v6;
        }
        if (encode_list_add_data(a1, v8, a3))
          return v6;
      }
      return 0;
    }
  }
  return v6;
}

uint64_t aks_params_get_data(_QWORD *a1, int a2, _QWORD *a3)
{
  unsigned __int8 *der_key;
  int data;
  uint64_t v9;
  uint64_t v10;

  v9 = 0;
  v10 = 0;
  der_key = (unsigned __int8 *)_params_get_der_key(a2, 2);
  if (der_key)
  {
    data = encode_list_get_data(a1, der_key, (a2 - 1) < 2, &v9, &v10);
    if (a3)
    {
      if (data)
        *a3 = v10;
    }
  }
  return v9;
}

uint64_t aks_params_free(void ***a1)
{
  uint64_t result;
  void **v3;

  result = 3758097090;
  if (a1)
  {
    v3 = *a1;
    if (*a1)
    {
      *a1 = 0;
      encode_list_free(v3);
      memset_s(v3, 8uLL, 0, 8uLL);
      free(v3);
      return 0;
    }
  }
  return result;
}

uint64_t aks_encrypt(int a1, int a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, _QWORD *a7, size_t *a8)
{
  _BOOL4 v8;
  uint64_t v11;
  void *v12;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  void *v29[2];
  void *v30;
  void **v31;
  void *v32;

  v8 = 0;
  v31 = 0;
  v32 = 0;
  v29[1] = 0;
  v30 = 0;
  v28 = a6;
  v29[0] = a5;
  v26 = 0;
  v27 = 0;
  v25 = 0;
  if (!a7 || !a8)
  {
    v17 = 3758097090;
    goto LABEL_16;
  }
  v11 = a6;
  v12 = a5;
  v23 = 0;
  v24 = 0;
  if (der_dict_find_value((uint64_t)der_key_external_data, &v23, &v24)
    && (v21 = 0, v22 = 0, der_dict_find_value((uint64_t)der_key_acl, &v21, &v22))
    && (der_dict_find_value((uint64_t)der_key_op_encrypt, 0, 0) & 1) == 0)
  {
    if (encode_list_merge_dict((uint64_t)&v27)
      || encode_list_merge_dict((uint64_t)&v26)
      || encode_list_merge_dict((uint64_t)&v25))
    {
      v8 = 0;
      v17 = 3758097085;
      goto LABEL_16;
    }
    encode_list_add_BOOL(&v25, (uint64_t)der_key_op_encrypt);
    encode_list_remove_key(&v26, (unsigned __int8 *)der_key_acl);
    encode_list_add_list(&v26, (uint64_t)der_key_acl, &v25);
    encode_list_remove_key(&v27, (unsigned __int8 *)der_key_external_data);
    encode_list_add_list(&v27, (uint64_t)der_key_external_data, &v26);
    v8 = encode_list_dict(&v27, v29, (size_t *)&v28) == 0;
    v11 = v28;
    v12 = v29[0];
  }
  else
  {
    v8 = 0;
  }
  v16 = aks_ref_key_create(a1, a2, 0, (uint64_t)v12, v11, &v31);
  if ((_DWORD)v16 || (v16 = aks_ref_key_encrypt((uint64_t *)v31, (uint64_t)v29[0], v28, a3), (_DWORD)v16))
  {
    v17 = v16;
  }
  else if (encode_list_merge_dict((uint64_t)&v32)
         || encode_list_merge_dict((uint64_t)&v32)
         || (v19 = 0, v20 = 0, der_dict_find_value((uint64_t)der_key_external_data, &v19, &v20))
         && encode_list_add_der(&v32, (uint64_t)der_key_auth_data, v19, (uint64_t)v31[2]))
  {
    v17 = 3758097090;
  }
  else if (encode_list_dict(&v32, a7, a8))
  {
    v17 = 3758097090;
  }
  else
  {
    v17 = 0;
  }
LABEL_16:
  encode_list_free(&v27);
  encode_list_free(&v26);
  encode_list_free(&v25);
  if (v8)
    free(v29[0]);
  if (v31)
    aks_ref_key_free((uint64_t *)&v31);
  free(v30);
  encode_list_free(&v32);
  result = 3758097122;
  if ((int)v17 <= -536870175)
  {
    if ((_DWORD)v17 == -536870212)
      return 3758097084;
    if ((_DWORD)v17 != -536870194)
      return v17;
  }
  else if ((_DWORD)v17 != -536870174 && (_DWORD)v17 != -536363000)
  {
    if ((_DWORD)v17 != -536362999)
      return v17;
    return 3758097084;
  }
  return result;
}

uint64_t aks_ref_key_create(int a1, int a2, unsigned int a3, uint64_t a4, uint64_t a5, void ***a6)
{
  uint64_t v11;
  void *v12;
  void **v13;
  void *v14;
  void **v15;
  uint64_t v16;
  char *v17;
  rsize_t v18;
  void *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  rsize_t v24;
  void *v25;
  size_t v26;

  v11 = 3758097090;
  v12 = der_key_op_create;
  v13 = (void **)calloc(8uLL, 1uLL);
  *v13 = 0;
  encode_list_add_key(v13, (uint64_t)der_key_op, (uint64_t)v12);
  v25 = 0;
  v26 = 0;
  v23 = 0;
  v24 = 0;
  if (!a6)
    goto LABEL_14;
  v14 = calloc(0x50uLL, 1uLL);
  v22 = v14;
  if (!v14)
  {
    v11 = 3758604298;
    goto LABEL_14;
  }
  v15 = (void **)v14;
  memset_s(v14, 0x50uLL, 0, 0x50uLL);
  if (a4 && encode_list_merge_dict((uint64_t)v13)
    || encode_list_add_number(v13, (uint64_t)der_key_keybag_class, a2)
    || encode_list_add_number(v13, (uint64_t)der_key_type, a3)
    || encode_list_dict(v13, &v25, &v26))
  {
LABEL_17:
    aks_ref_key_free((uint64_t *)&v22);
    goto LABEL_14;
  }
  v16 = _aks_operation();
  if ((_DWORD)v16)
  {
    v11 = v16;
    goto LABEL_17;
  }
  v17 = (char *)v23;
  v18 = v24;
  *v15 = v23;
  v15[1] = (void *)v18;
  *((_DWORD *)v15 + 10) = a1;
  v15[2] = &v17[v18];
  v20 = 0;
  v21 = 0;
  if (der_dict_find_value((uint64_t)der_key_ref_key, &v20, &v21))
    v15[4] = v20;
  if (der_dict_find_value((uint64_t)der_key_external_data, &v20, &v21))
    v15[3] = v20;
  v11 = 0;
  *a6 = v15;
  v23 = 0;
  v24 = 0;
LABEL_14:
  encode_list_free(v13);
  memset_s(v13, 8uLL, 0, 8uLL);
  free(v13);
  memset_s(v25, v26, 0, v26);
  free(v25);
  memset_s(v23, v24, 0, v24);
  free(v23);
  return v11;
}

uint64_t aks_ref_key_encrypt(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  void *v8;
  void **v9;
  void *__s;
  rsize_t __n;

  v7 = 3758097090;
  v8 = der_key_op_encrypt;
  v9 = (void **)calloc(8uLL, 1uLL);
  *v9 = 0;
  encode_list_add_key(v9, (uint64_t)der_key_op, (uint64_t)v8);
  __s = 0;
  __n = 0;
  if (!_get_merged_params((uint64_t)a1, v9, a2))
  {
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_data);
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_ref_key);
    if (!encode_list_add_data(v9, (uint64_t)der_key_data, a4)
      && !encode_list_add_der(v9, (uint64_t)der_key_ref_key, *a1, a1[2])
      && !encode_list_dict(v9, &__s, &__n))
    {
      v7 = _aks_operation();
    }
  }
  encode_list_free(v9);
  memset_s(v9, 8uLL, 0, 8uLL);
  free(v9);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v7;
}

uint64_t aks_ref_key_free(uint64_t *a1)
{
  uint64_t v1;
  void *v2;
  void *v3;

  v1 = *a1;
  if (!*a1)
    return 3758097090;
  *a1 = 0;
  if (*(_QWORD *)v1)
  {
    memset_s(*(void **)v1, *(_QWORD *)(v1 + 8), 0, *(_QWORD *)(v1 + 8));
    free(*(void **)v1);
  }
  v2 = *(void **)(v1 + 48);
  if (v2)
  {
    memset_s(v2, *(_QWORD *)(v1 + 56), 0, *(_QWORD *)(v1 + 56));
    free(*(void **)(v1 + 48));
  }
  v3 = *(void **)(v1 + 64);
  if (v3)
  {
    memset_s(v3, *(_QWORD *)(v1 + 72), 0, *(_QWORD *)(v1 + 72));
    free(*(void **)(v1 + 64));
  }
  memset_s((void *)v1, 0x50uLL, 0, 0x50uLL);
  free((void *)v1);
  return 0;
}

uint64_t aks_decrypt(int a1, void *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t *v13;

  v5 = 3758097122;
  v13 = 0;
  v6 = 3758097090;
  if (!a2 || !a3 || der_get_sizeof((uint64_t)a2) != a3)
    return v6;
  v6 = aks_ref_key_create_with_blob(a1, a2, a3, (uint64_t *)&v13);
  if (!(_DWORD)v6)
  {
    v6 = aks_ref_key_decrypt(v13, a4, a5, a2, a3);
LABEL_6:
    aks_ref_key_free((uint64_t *)&v13);
    goto LABEL_7;
  }
  if (v13)
    goto LABEL_6;
LABEL_7:
  if ((int)v6 <= -536870175)
  {
    if ((_DWORD)v6 == -536870212)
      return 3758097084;
    if ((_DWORD)v6 != -536870194)
      return v6;
  }
  else if ((_DWORD)v6 != -536870174 && (_DWORD)v6 != -536363000)
  {
    if ((_DWORD)v6 != -536362999)
      return v6;
    return 3758097084;
  }
  return v5;
}

uint64_t aks_ref_key_create_with_blob(int a1, const void *a2, size_t a3, uint64_t *a4)
{
  uint64_t v4;
  void *v9;
  uint64_t v10;
  void *v12;

  v4 = 3758097090;
  if (a2)
  {
    if (a3)
    {
      if (der_get_sizeof((uint64_t)a2) == a3)
      {
        v4 = 3758604298;
        v9 = calloc(0x50uLL, 1uLL);
        v12 = v9;
        if (v9)
        {
          v10 = (uint64_t)v9;
          memset_s(v9, 0x50uLL, 0, 0x50uLL);
          *(_DWORD *)(v10 + 40) = a1;
          if (_set_blob(v10, a2, a3))
          {
            aks_ref_key_free((uint64_t *)&v12);
          }
          else
          {
            v4 = 0;
            *a4 = v10;
          }
        }
      }
    }
  }
  return v4;
}

uint64_t aks_ref_key_decrypt(uint64_t *a1, uint64_t a2, uint64_t a3, void *a4, size_t a5)
{
  uint64_t v9;
  void *v10;
  void **v11;
  uint64_t v12;
  int version;
  void *v15;
  size_t v16;
  void *__s;
  rsize_t __n;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;

  v9 = 3758097090;
  v10 = der_key_op_decrypt;
  v11 = (void **)calloc(8uLL, 1uLL);
  *v11 = 0;
  encode_list_add_key(v11, (uint64_t)der_key_op, (uint64_t)v10);
  __s = 0;
  __n = 0;
  v15 = a4;
  v16 = a5;
  if (a4)
  {
    if (a5)
    {
      v12 = (uint64_t)a4 + a5;
      if (der_get_sizeof((uint64_t)a4) == a5)
      {
        version = aks_ref_key_get_version((uint64_t)a1);
        if (!version)
        {
          v22 = 0;
          v23 = 0;
          v20 = 0;
          v21 = 0;
          v19 = 0;
          if (!der_dict_find_value((uint64_t)der_key_tag, &v19, &v20)
            || !der_dict_find_value((uint64_t)der_key_protected_data, &v21, &v22)
            || encode_list_add_der(&v23, (uint64_t)der_key_data, v21, v12)
            || encode_list_add_der(&v23, (uint64_t)der_key_tag, v19, v12)
            || encode_list_dict(&v23, &v15, &v16))
          {
            encode_list_free(&v23);
            goto LABEL_19;
          }
          encode_list_free(&v23);
        }
        if (!_get_merged_params((uint64_t)a1, v11, a2))
        {
          encode_list_remove_key(v11, (unsigned __int8 *)der_key_data);
          encode_list_remove_key(v11, (unsigned __int8 *)der_key_ref_key);
          if (!encode_list_add_der(v11, (uint64_t)der_key_data, (uint64_t)v15, (uint64_t)v15 + v16)
            && !encode_list_add_der(v11, (uint64_t)der_key_ref_key, *a1, a1[2])
            && !encode_list_dict(v11, &__s, &__n))
          {
            v9 = _aks_operation();
          }
        }
        if (!version)
        {
          memset_s(v15, v16, 0, v16);
          free(v15);
        }
      }
    }
  }
LABEL_19:
  encode_list_free(v11);
  memset_s(v11, 8uLL, 0, 8uLL);
  free(v11);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v9;
}

uint64_t aks_delete(int a1, const void *a2, size_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v11;

  v4 = 3758097122;
  v11 = 0;
  v5 = 3758097090;
  if (!a2 || !a3 || der_get_sizeof((uint64_t)a2) != a3)
    return v5;
  v5 = aks_ref_key_create_with_blob(a1, a2, a3, (uint64_t *)&v11);
  if (!(_DWORD)v5)
  {
    v5 = aks_ref_key_delete(v11, a4);
LABEL_6:
    aks_ref_key_free((uint64_t *)&v11);
    goto LABEL_7;
  }
  if (v11)
    goto LABEL_6;
LABEL_7:
  if ((int)v5 <= -536870175)
  {
    if ((_DWORD)v5 == -536870212)
      return 3758097084;
    if ((_DWORD)v5 != -536870194)
      return v5;
  }
  else if ((_DWORD)v5 != -536870174 && (_DWORD)v5 != -536363000)
  {
    if ((_DWORD)v5 != -536362999)
      return v5;
    return 3758097084;
  }
  return v4;
}

uint64_t aks_ref_key_delete(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  void *v5;
  void **v6;
  void *__s;
  rsize_t __n;

  v4 = 3758097090;
  v5 = der_key_op_delete;
  v6 = (void **)calloc(8uLL, 1uLL);
  *v6 = 0;
  encode_list_add_key(v6, (uint64_t)der_key_op, (uint64_t)v5);
  __s = 0;
  __n = 0;
  if (!_get_merged_params((uint64_t)a1, v6, a2))
  {
    encode_list_remove_key(v6, (unsigned __int8 *)der_key_ref_key);
    if (!encode_list_add_der(v6, (uint64_t)der_key_ref_key, *a1, a1[2])
      && !encode_list_dict(v6, &__s, &__n))
    {
      v4 = _aks_operation();
    }
  }
  encode_list_free(v6);
  memset_s(v6, 8uLL, 0, 8uLL);
  free(v6);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v4;
}

uint64_t _aks_operation()
{
  int v0;
  size_t *v1;
  size_t *v2;
  _QWORD *v3;
  _QWORD *v4;
  size_t v5;
  size_t v6;
  const void *v7;
  const void *v8;
  int v9;
  mach_port_t aks_client_connection;
  mach_port_t v11;
  uint64_t v12;
  void *v13;
  size_t __count;
  uint64_t input;
  _BYTE __src[32768];
  uint64_t v18;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v9 = v0;
  v18 = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (v8)
    {
      v11 = aks_client_connection;
      v12 = 3758097090;
      if (der_get_sizeof((uint64_t)v8) == v6)
      {
        bzero(__src, 0x8000uLL);
        __count = 0x8000;
        input = v9;
        v12 = IOConnectCallMethod(v11, 0x2Bu, &input, 1u, v8, v6, 0, 0, __src, &__count);
        if (!(_DWORD)v12 && v4 && v2)
        {
          v13 = calloc(__count, 1uLL);
          *v4 = v13;
          if (v13)
          {
            memcpy(v13, __src, __count);
            v12 = 0;
            *v2 = __count;
          }
          else
          {
            v12 = 3758097085;
          }
        }
      }
    }
    else
    {
      v12 = 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_aks_operation", ":", 457, "", 0, "", "");
    v12 = 3758097084;
  }
  memset_s(__src, 0x8000uLL, 0, 0x8000uLL);
  return v12;
}

uint64_t _set_blob(uint64_t a1, const void *a2, size_t a3)
{
  void *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;

  v8 = 0;
  v9 = 0;
  if (!der_dict_find_value((uint64_t)der_key_ref_key, &v8, &v9))
    return 3758097090;
  if (*(_QWORD *)a1)
  {
    memset_s(*(void **)a1, *(_QWORD *)(a1 + 8), 0, *(_QWORD *)(a1 + 8));
    free(*(void **)a1);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
  }
  v6 = calloc(a3, 1uLL);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + 8) = a3;
  if (!v6)
    return 3758604298;
  memcpy(v6, a2, a3);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)a1 + *(_QWORD *)(a1 + 8);
  if (der_dict_find_value((uint64_t)der_key_ref_key, &v8, &v9))
    *(_QWORD *)(a1 + 32) = v8;
  if ((der_dict_find_value((uint64_t)der_key_external_data, &v8, &v9) & 1) != 0
    || (result = der_dict_find_value((uint64_t)der_key_auth_data, &v8, &v9), (_DWORD)result))
  {
    result = 0;
    *(_QWORD *)(a1 + 24) = v8;
  }
  return result;
}

uint64_t aks_ref_key_create_and_encrypt(int a1, int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void ***a8, void **a9, rsize_t *a10)
{
  uint64_t v16;
  void *v17;
  void **v18;
  void *v19;
  void **v20;
  uint64_t v21;
  char *v22;
  rsize_t v23;
  void *v25;
  uint64_t v26;
  void *__s;
  rsize_t __n;
  void *v29;
  void *v30;
  rsize_t v31;
  void *v32;
  rsize_t __smax;
  void *v34;
  rsize_t v35;

  v16 = 3758097090;
  v35 = 0;
  __smax = 0;
  v34 = 0;
  v31 = 0;
  v32 = 0;
  v30 = 0;
  v17 = der_key_op_create_with_encrypt;
  v18 = (void **)calloc(8uLL, 1uLL);
  *v18 = 0;
  encode_list_add_key(v18, (uint64_t)der_key_op, (uint64_t)v17);
  __s = 0;
  __n = 0;
  if (!a8)
    goto LABEL_16;
  v19 = calloc(0x50uLL, 1uLL);
  v29 = v19;
  if (!v19)
  {
    v16 = 3758604298;
    goto LABEL_16;
  }
  v20 = (void **)v19;
  memset_s(v19, 0x50uLL, 0, 0x50uLL);
  if (a4 && encode_list_merge_dict((uint64_t)v18)
    || (encode_list_remove_key(v18, (unsigned __int8 *)der_key_data),
        encode_list_remove_key(v18, (unsigned __int8 *)der_key_ref_key),
        encode_list_add_number(v18, (uint64_t)der_key_keybag_class, a2))
    || encode_list_add_number(v18, (uint64_t)der_key_type, a3)
    || encode_list_add_data(v18, (uint64_t)der_key_data, a6)
    || encode_list_dict(v18, &__s, &__n))
  {
LABEL_26:
    aks_ref_key_free((uint64_t *)&v29);
    goto LABEL_16;
  }
  v21 = _aks_operation();
  if ((_DWORD)v21 || (v21 = decode_ref_key_with_result((uint64_t)v34, v35, &v32, &__smax, &v30, &v31), (_DWORD)v21))
  {
    v16 = v21;
    goto LABEL_26;
  }
  v22 = (char *)v32;
  v23 = __smax;
  *v20 = v32;
  v20[1] = (void *)v23;
  *((_DWORD *)v20 + 10) = a1;
  v20[2] = &v22[v23];
  v25 = 0;
  v26 = 0;
  if (der_dict_find_value((uint64_t)der_key_ref_key, &v25, &v26))
    v20[4] = v25;
  if (der_dict_find_value((uint64_t)der_key_external_data, &v25, &v26))
    v20[3] = v25;
  v16 = 0;
  *a8 = v20;
  v32 = 0;
  __smax = 0;
  *a9 = v30;
  *a10 = v31;
  v30 = 0;
  v31 = 0;
LABEL_16:
  encode_list_free(v18);
  memset_s(v18, 8uLL, 0, 8uLL);
  free(v18);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  if (v32)
  {
    memset_s(v32, __smax, 0, __smax);
    free(v32);
  }
  if (v30)
  {
    memset_s(v30, v31, 0, v31);
    free(v30);
  }
  if (v34)
  {
    memset_s(v34, v35, 0, v35);
    free(v34);
  }
  return v16;
}

uint64_t decode_ref_key_with_result(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, void **a5, _QWORD *a6)
{
  uint64_t v10;
  void *__s;
  _DWORD __smax[4];
  unsigned int __n;
  __int128 __n_4;

  *(_QWORD *)&__n_4 = a1;
  *((_QWORD *)&__n_4 + 1) = a1 + a2;
  __n = 0;
  *(_QWORD *)&__smax[1] = 0;
  __smax[0] = 0;
  __s = 0;
  if (a6
    && a1
    && a3
    && a4
    && a5
    && ccder_blob_decode_range()
    && der_utils_decode_implicit_raw_octet_string_alloc(&__n_4, 4, (uint64_t *)&__s, __smax))
  {
    if (der_utils_decode_implicit_raw_octet_string_alloc(&__n_4, 4, (uint64_t *)&__smax[1], &__n))
    {
      v10 = 0;
      *a3 = *(_QWORD *)&__smax[1];
      *a4 = __n;
      *a5 = __s;
      *a6 = __smax[0];
      return v10;
    }
    if (*(_QWORD *)&__smax[1])
    {
      memset_s(*(void **)&__smax[1], __n, 0, __n);
      free(*(void **)&__smax[1]);
    }
  }
  v10 = 3758097084;
  if (__s)
  {
    memset_s(__s, __smax[0], 0, __smax[0]);
    free(__s);
  }
  return v10;
}

uint64_t aks_ref_key_create_and_wrap(int a1, int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void ***a8, void **a9, rsize_t *a10)
{
  uint64_t v16;
  void *v17;
  void **v18;
  void *v19;
  void **v20;
  uint64_t v21;
  char *v22;
  rsize_t v23;
  void *v25;
  uint64_t v26;
  void *__s;
  rsize_t __n;
  void *v29;
  void *v30;
  rsize_t v31;
  void *v32;
  rsize_t __smax;
  void *v34;
  rsize_t v35;

  v16 = 3758097090;
  v35 = 0;
  __smax = 0;
  v34 = 0;
  v31 = 0;
  v32 = 0;
  v30 = 0;
  v17 = der_key_op_create_with_wrap;
  v18 = (void **)calloc(8uLL, 1uLL);
  *v18 = 0;
  encode_list_add_key(v18, (uint64_t)der_key_op, (uint64_t)v17);
  __s = 0;
  __n = 0;
  if (!a8)
    goto LABEL_16;
  v19 = calloc(0x50uLL, 1uLL);
  v29 = v19;
  if (!v19)
  {
    v16 = 3758604298;
    goto LABEL_16;
  }
  v20 = (void **)v19;
  memset_s(v19, 0x50uLL, 0, 0x50uLL);
  if (a4 && encode_list_merge_dict((uint64_t)v18)
    || (encode_list_remove_key(v18, (unsigned __int8 *)der_key_data),
        encode_list_remove_key(v18, (unsigned __int8 *)der_key_ref_key),
        encode_list_add_number(v18, (uint64_t)der_key_keybag_class, a2))
    || encode_list_add_number(v18, (uint64_t)der_key_type, a3)
    || encode_list_add_data(v18, (uint64_t)der_key_data, a6)
    || encode_list_dict(v18, &__s, &__n))
  {
LABEL_26:
    aks_ref_key_free((uint64_t *)&v29);
    goto LABEL_16;
  }
  v21 = _aks_operation();
  if ((_DWORD)v21 || (v21 = decode_ref_key_with_result((uint64_t)v34, v35, &v32, &__smax, &v30, &v31), (_DWORD)v21))
  {
    v16 = v21;
    goto LABEL_26;
  }
  v22 = (char *)v32;
  v23 = __smax;
  *v20 = v32;
  v20[1] = (void *)v23;
  *((_DWORD *)v20 + 10) = a1;
  v20[2] = &v22[v23];
  v25 = 0;
  v26 = 0;
  if (der_dict_find_value((uint64_t)der_key_ref_key, &v25, &v26))
    v20[4] = v25;
  if (der_dict_find_value((uint64_t)der_key_external_data, &v25, &v26))
    v20[3] = v25;
  v16 = 0;
  *a8 = v20;
  v32 = 0;
  __smax = 0;
  *a9 = v30;
  *a10 = v31;
  v30 = 0;
  v31 = 0;
LABEL_16:
  encode_list_free(v18);
  memset_s(v18, 8uLL, 0, 8uLL);
  free(v18);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  if (v32)
  {
    memset_s(v32, __smax, 0, __smax);
    free(v32);
  }
  if (v30)
  {
    memset_s(v30, v31, 0, v31);
    free(v30);
  }
  if (v34)
  {
    memset_s(v34, v35, 0, v35);
    free(v34);
  }
  return v16;
}

uint64_t _get_merged_params(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;

  v3 = 3758604298;
  if (a1
    && (!*(_QWORD *)(a1 + 48) || !encode_list_merge_dict((uint64_t)a2))
    && (!a3 || !encode_list_merge_dict((uint64_t)a2)))
  {
    encode_list_remove_key(a2, (unsigned __int8 *)der_key_external_data);
    return 0;
  }
  return v3;
}

uint64_t aks_ref_key_get_version(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;

  if (!*(_QWORD *)(a1 + 32))
    return 0;
  v2 = 0;
  v3 = 0;
  result = der_dict_find_value((uint64_t)der_key_version, &v2, &v3);
  if ((_DWORD)result)
    return der_get_number();
  return result;
}

uint64_t aks_ref_key_sign(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  void *v8;
  void **v9;
  void *__s;
  rsize_t __n;

  v7 = 3758097090;
  v8 = der_key_op_sign;
  v9 = (void **)calloc(8uLL, 1uLL);
  *v9 = 0;
  encode_list_add_key(v9, (uint64_t)der_key_op, (uint64_t)v8);
  __s = 0;
  __n = 0;
  if (!_get_merged_params((uint64_t)a1, v9, a2))
  {
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_data);
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_ref_key);
    if (!encode_list_add_data(v9, (uint64_t)der_key_data, a4)
      && !encode_list_add_der(v9, (uint64_t)der_key_ref_key, *a1, a1[2])
      && !encode_list_dict(v9, &__s, &__n))
    {
      v7 = _aks_operation();
    }
  }
  encode_list_free(v9);
  memset_s(v9, 8uLL, 0, 8uLL);
  free(v9);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v7;
}

uint64_t aks_ref_key_verify_sig(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7;
  char v10;
  uint64_t v11;
  int type;
  size_t v13;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  __int128 v20;
  uint64_t v21;

  v7 = a7;
  v21 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v20 = a6;
  *((_QWORD *)&v20 + 1) = a6 + a7;
  v19 = 0;
  v18 = 0;
  der_utils_decode_implicit_raw_octet_string(&v20, 4, &v19, &v18);
  if ((v10 & 1) == 0)
  {
    v18 = a6;
    v19 = v7;
  }
  v11 = 3758097090;
  type = aks_ref_key_get_type((uint64_t)a1);
  if ((type - 4) < 2)
  {
    v16 = 0;
    goto LABEL_8;
  }
  if ((type - 7) < 2)
  {
    v16 = 0;
    if (MEMORY[0x219A17EAC]())
    {
LABEL_9:
      MEMORY[0x24BDAC7A8]();
      bzero((char *)&v15 - v13, v13);
      v17 = 0;
      if (aks_ref_key_get_public_key(a1, &v17) && !ccec_import_pub() && !ccec_verify())
      {
        if (!v16)
          return 3758604294;
        return 0;
      }
      return v11;
    }
LABEL_8:
    MEMORY[0x219A17EA0]();
    goto LABEL_9;
  }
  if (type == 3)
  {
    v17 = 0;
    if (aks_ref_key_get_public_key(a1, &v17))
    {
      if (v17 == 32 && v18 && v19 == 64)
      {
        ccsha512_di();
        if (cced25519_verify())
          return 3758604294;
        return 0;
      }
    }
  }
  return v11;
}

uint64_t aks_ref_key_get_type(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;

  if (!*(_QWORD *)(a1 + 32))
    return 0;
  v2 = 0;
  v3 = 0;
  result = der_dict_find_value((uint64_t)der_key_type, &v2, &v3);
  if ((_DWORD)result)
    return der_get_number();
  return result;
}

uint64_t aks_ref_key_get_public_key(_QWORD *a1, _QWORD *a2)
{
  int type;
  uint64_t v5;
  uint64_t v7;
  size_t v8;
  size_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v17 = 0;
  v16 = 0;
  if (!a1[4])
    return 0;
  v14 = 0;
  v15 = 0;
  if (der_dict_find_value((uint64_t)der_key_public_key, &v14, &v15))
  {
    *(_QWORD *)&v13 = v14;
    *((_QWORD *)&v13 + 1) = v14 + v15;
    der_utils_decode_implicit_raw_octet_string(&v13, 4, &v17, &v16);
  }
  type = aks_ref_key_get_type((uint64_t)a1);
  if ((type - 7) < 2)
  {
    v5 = MEMORY[0x219A17EAC]();
    goto LABEL_9;
  }
  if ((type - 4) <= 1)
  {
    v5 = MEMORY[0x219A17EA0]();
LABEL_9:
    if (v5)
    {
      v7 = firebloom_cp_prime_bitlen(v5);
      if (v17 == (unint64_t)(v7 + 7) >> 3)
      {
        if (v16 && !a1[8])
        {
          MEMORY[0x24BDAC7A8]();
          bzero((char *)&v12 - v8, v8);
          ccec_compact_import_pub();
          v9 = (2 * firebloom_cp_prime_size()) | 1;
          v10 = calloc(v9, 1uLL);
          a1[8] = v10;
          a1[9] = v9;
          if (v10)
            ccec_export_pub();
          cc_clear();
        }
        v11 = a1[9];
        v16 = a1[8];
        v17 = v11;
      }
    }
  }
  *a2 = v17;
  return v16;
}

uint64_t aks_ref_key_set_key_class(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7;
  void *v8;
  void **v9;
  uint64_t v10;
  void *v12;
  rsize_t __n;

  v7 = 3758097090;
  v8 = der_key_op_set_key_class;
  v9 = (void **)calloc(8uLL, 1uLL);
  *v9 = 0;
  encode_list_add_key(v9, (uint64_t)der_key_op, (uint64_t)v8);
  v12 = 0;
  __n = 0;
  if (!_get_merged_params((uint64_t)a1, v9, a2))
  {
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_data);
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_ref_key);
    if (!encode_list_add_number(v9, (uint64_t)der_key_keybag_class, a4)
      && !encode_list_add_der(v9, (uint64_t)der_key_ref_key, *a1, a1[2])
      && !encode_list_dict(v9, &v12, &__n))
    {
      v10 = _aks_operation();
      if ((_DWORD)v10)
        v7 = v10;
      else
        v7 = _set_blob((uint64_t)a1, 0, 0);
    }
  }
  encode_list_free(v9);
  memset_s(v9, 8uLL, 0, 8uLL);
  free(v9);
  if (v12)
  {
    memset_s(v12, __n, 0, __n);
    free(v12);
  }
  return v7;
}

uint64_t aks_ref_key_wrap(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  void *v8;
  void **v9;
  void *__s;
  rsize_t __n;

  v7 = 3758097090;
  v8 = der_key_op_wrap;
  v9 = (void **)calloc(8uLL, 1uLL);
  *v9 = 0;
  encode_list_add_key(v9, (uint64_t)der_key_op, (uint64_t)v8);
  __s = 0;
  __n = 0;
  if (!_get_merged_params((uint64_t)a1, v9, a2))
  {
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_data);
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_ref_key);
    if (!encode_list_add_data(v9, (uint64_t)der_key_data, a4)
      && !encode_list_add_der(v9, (uint64_t)der_key_ref_key, *a1, a1[2])
      && !encode_list_dict(v9, &__s, &__n))
    {
      v7 = _aks_operation();
    }
  }
  encode_list_free(v9);
  memset_s(v9, 8uLL, 0, 8uLL);
  free(v9);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v7;
}

uint64_t aks_ref_key_unwrap(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  void *v10;
  void **v11;
  void *__s;
  rsize_t __n;

  v9 = 3758097090;
  v10 = der_key_op_unwrap;
  v11 = (void **)calloc(8uLL, 1uLL);
  *v11 = 0;
  encode_list_add_key(v11, (uint64_t)der_key_op, (uint64_t)v10);
  __s = 0;
  __n = 0;
  if (!_get_merged_params((uint64_t)a1, v11, a2))
  {
    encode_list_remove_key(v11, (unsigned __int8 *)der_key_data);
    encode_list_remove_key(v11, (unsigned __int8 *)der_key_ref_key);
    if (!encode_list_add_der(v11, (uint64_t)der_key_data, a4, a4 + a5)
      && !encode_list_add_der(v11, (uint64_t)der_key_ref_key, *a1, a1[2])
      && !encode_list_dict(v11, &__s, &__n))
    {
      v9 = _aks_operation();
    }
  }
  encode_list_free(v11);
  memset_s(v11, 8uLL, 0, 8uLL);
  free(v11);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v9;
}

uint64_t aks_ref_key_transcrypt(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7;
  void *v8;
  void **v9;
  uint64_t v10;
  void *v12;
  rsize_t __n;

  v7 = 3758097090;
  v8 = der_key_op_transcrypt;
  v9 = (void **)calloc(8uLL, 1uLL);
  *v9 = 0;
  encode_list_add_key(v9, (uint64_t)der_key_op, (uint64_t)v8);
  v12 = 0;
  __n = 0;
  if (!_get_merged_params(a1, v9, a2))
  {
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_dst_keybag_handle);
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_ref_key);
    if (!encode_list_add_number(v9, (uint64_t)der_key_dst_keybag_handle, a4)
      && !encode_list_add_der(v9, (uint64_t)der_key_ref_key, *(_QWORD *)a1, *(_QWORD *)(a1 + 16))
      && !encode_list_dict(v9, &v12, &__n))
    {
      v10 = _aks_operation();
      if ((_DWORD)v10)
      {
        v7 = v10;
      }
      else
      {
        *(_DWORD *)(a1 + 40) = a4;
        v7 = _set_blob(a1, 0, 0);
      }
    }
  }
  encode_list_free(v9);
  memset_s(v9, 8uLL, 0, 8uLL);
  free(v9);
  if (v12)
  {
    memset_s(v12, __n, 0, __n);
    free(v12);
  }
  return v7;
}

uint64_t aks_ref_key_compute_key(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  void *v8;
  void **v9;
  void *__s;
  rsize_t __n;

  v7 = 3758097090;
  v8 = der_key_op_compute_key;
  v9 = (void **)calloc(8uLL, 1uLL);
  *v9 = 0;
  encode_list_add_key(v9, (uint64_t)der_key_op, (uint64_t)v8);
  __s = 0;
  __n = 0;
  if (!_get_merged_params((uint64_t)a1, v9, a2))
  {
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_public_key);
    encode_list_remove_key(v9, (unsigned __int8 *)der_key_ref_key);
    if (!encode_list_add_data(v9, (uint64_t)der_key_public_key, a4)
      && !encode_list_add_der(v9, (uint64_t)der_key_ref_key, *a1, a1[2])
      && !encode_list_dict(v9, &__s, &__n))
    {
      v7 = _aks_operation();
    }
  }
  encode_list_free(v9);
  memset_s(v9, 8uLL, 0, 8uLL);
  free(v9);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v7;
}

uint64_t aks_ref_key_encapsulate(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void **a6, _QWORD *a7, void **a8, _QWORD *a9)
{
  uint64_t v14;
  void *v15;
  void **v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  int v20;
  void *v23;
  unsigned int v24;
  void *__s;
  _DWORD __n[3];
  size_t v27[2];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v14 = 3758097090;
  v15 = der_key_op_kem_encapsulate;
  v16 = (void **)calloc(8uLL, 1uLL);
  *v16 = 0;
  encode_list_add_key(v16, (uint64_t)der_key_op, (uint64_t)v15);
  LODWORD(v17) = 0;
  v18 = 0;
  v27[0] = 0;
  memset(__n, 0, sizeof(__n));
  __s = 0;
  v24 = 0;
  v23 = 0;
  if (a6 && a8)
  {
    if (_get_merged_params((uint64_t)a1, v16, a2))
      goto LABEL_13;
    encode_list_remove_key(v16, (unsigned __int8 *)der_key_ref_key);
    if (encode_list_add_data(v16, (uint64_t)der_key_public_key, a4)
      || encode_list_add_der(v16, (uint64_t)der_key_ref_key, *a1, a1[2])
      || encode_list_dict(v16, &__n[1], v27))
    {
      goto LABEL_13;
    }
    v19 = _aks_operation();
    if ((_DWORD)v19)
    {
      v14 = v19;
      goto LABEL_13;
    }
    v14 = 3758604298;
    v30 = 0u;
    v31 = 0u;
    v29 = 0u;
    v28 = 0u;
    v27[1] = (size_t)der_key_op_compute_key;
    v32 = 0;
    *(_QWORD *)&v30 = der_key_data;
    der_dict_iterate();
    LODWORD(v17) = 0;
    v18 = 0;
    if ((_QWORD)v28)
    {
      if (*((_QWORD *)&v30 + 1))
      {
        if (!der_utils_decode_implicit_raw_octet_string_alloc(&v29, 4, (uint64_t *)&__s, __n))
        {
LABEL_13:
          v18 = 0;
          LODWORD(v17) = 0;
          goto LABEL_14;
        }
        v20 = der_utils_decode_implicit_raw_octet_string_alloc((__int128 *)((char *)&v31 + 8), 4, (uint64_t *)&v23, &v24);
        v17 = v24;
        v18 = v23;
        if (v20)
        {
          v14 = 0;
          *a6 = v23;
          *a7 = v17;
          v23 = 0;
          v24 = 0;
          *a8 = __s;
          *a9 = __n[0];
          __s = 0;
          __n[0] = 0;
          goto LABEL_13;
        }
      }
    }
  }
LABEL_14:
  memset_s(v18, v17, 0, v17);
  free(v23);
  memset_s(__s, __n[0], 0, __n[0]);
  free(__s);
  encode_list_free(v16);
  memset_s(v16, 8uLL, 0, 8uLL);
  free(v16);
  memset_s(*(void **)&__n[1], v27[0], 0, v27[0]);
  free(*(void **)&__n[1]);
  memset_s(0, 0, 0, 0);
  free(0);
  return v14;
}

uint64_t aks_ref_key_decapsulate(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, _QWORD *a7)
{
  uint64_t v12;
  void *v13;
  void **v14;
  void *v16;
  size_t v17;

  v12 = 3758097090;
  v13 = der_key_op_kem_decapsulate;
  v14 = (void **)calloc(8uLL, 1uLL);
  *v14 = 0;
  encode_list_add_key(v14, (uint64_t)der_key_op, (uint64_t)v13);
  v16 = 0;
  v17 = 0;
  if (a6)
  {
    if (!_get_merged_params((uint64_t)a1, v14, a2))
    {
      encode_list_remove_key(v14, (unsigned __int8 *)der_key_ref_key);
      if (!encode_list_add_data(v14, (uint64_t)der_key_data, a4)
        && !encode_list_add_der(v14, (uint64_t)der_key_ref_key, *a1, a1[2])
        && !encode_list_dict(v14, &v16, &v17))
      {
        v12 = _aks_operation();
        if (!(_DWORD)v12)
        {
          *a6 = 0;
          *a7 = 0;
        }
      }
    }
  }
  encode_list_free(v14);
  memset_s(v14, 8uLL, 0, 8uLL);
  free(v14);
  memset_s(v16, v17, 0, v17);
  free(v16);
  return v12;
}

uint64_t aks_ref_key_ecies_encrypt(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _QWORD *a8, _QWORD *a9)
{
  uint64_t v13;
  void *v14;
  void **v15;
  void *__s;
  rsize_t __n;

  v13 = 3758097090;
  v14 = der_key_op_ecies_encrypt;
  v15 = (void **)calloc(8uLL, 1uLL);
  *v15 = 0;
  encode_list_add_key(v15, (uint64_t)der_key_op, (uint64_t)v14);
  __s = 0;
  __n = 0;
  if (!_get_merged_params((uint64_t)a1, v15, a2))
  {
    encode_list_remove_key(v15, (unsigned __int8 *)der_key_public_key);
    encode_list_remove_key(v15, (unsigned __int8 *)der_key_ref_key);
    if (!encode_list_add_data(v15, (uint64_t)der_key_public_key, a4)
      && !encode_list_add_data(v15, (uint64_t)der_key_data, a6)
      && !encode_list_add_der(v15, (uint64_t)der_key_ref_key, *a1, a1[2])
      && !encode_list_dict(v15, &__s, &__n))
    {
      v13 = _aks_operation();
      if (!(_DWORD)v13)
      {
        *a8 = 0;
        *a9 = 0;
      }
    }
  }
  encode_list_free(v15);
  memset_s(v15, 8uLL, 0, 8uLL);
  free(v15);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v13;
}

uint64_t aks_ref_key_ecies_decrypt(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, _QWORD *a7)
{
  uint64_t v12;
  void *v13;
  void **v14;
  void *__s;
  rsize_t __n;

  v12 = 3758097090;
  v13 = der_key_op_ecies_decrypt;
  v14 = (void **)calloc(8uLL, 1uLL);
  *v14 = 0;
  encode_list_add_key(v14, (uint64_t)der_key_op, (uint64_t)v13);
  __s = 0;
  __n = 0;
  if (!_get_merged_params((uint64_t)a1, v14, a2))
  {
    encode_list_remove_key(v14, (unsigned __int8 *)der_key_ref_key);
    if ((!a4 || !encode_list_add_data(v14, (uint64_t)der_key_data, a4))
      && !encode_list_add_der(v14, (uint64_t)der_key_ref_key, *a1, a1[2])
      && !encode_list_dict(v14, &__s, &__n))
    {
      v12 = _aks_operation();
      if (!(_DWORD)v12)
      {
        *a6 = 0;
        *a7 = 0;
      }
    }
  }
  encode_list_free(v14);
  memset_s(v14, 8uLL, 0, 8uLL);
  free(v14);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v12;
}

uint64_t aks_ref_key_ecies_transcode(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _QWORD *a8, _QWORD *a9)
{
  uint64_t v13;
  void *v14;
  void **v15;
  void *__s;
  rsize_t __n;

  v13 = 3758097090;
  v14 = der_key_op_ecies_transcode;
  v15 = (void **)calloc(8uLL, 1uLL);
  *v15 = 0;
  encode_list_add_key(v15, (uint64_t)der_key_op, (uint64_t)v14);
  __s = 0;
  __n = 0;
  if (!_get_merged_params((uint64_t)a1, v15, a2))
  {
    encode_list_remove_key(v15, (unsigned __int8 *)der_key_public_key);
    encode_list_remove_key(v15, (unsigned __int8 *)der_key_ref_key);
    if (!encode_list_add_data(v15, (uint64_t)der_key_public_key, a4)
      && !encode_list_add_data(v15, (uint64_t)der_key_data, a6)
      && !encode_list_add_der(v15, (uint64_t)der_key_ref_key, *a1, a1[2])
      && !encode_list_dict(v15, &__s, &__n))
    {
      v13 = _aks_operation();
      if (!(_DWORD)v13)
      {
        *a8 = 0;
        *a9 = 0;
      }
    }
  }
  encode_list_free(v15);
  memset_s(v15, 8uLL, 0, 8uLL);
  free(v15);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v13;
}

uint64_t aks_ref_key_enable_test_keys(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  void **v5;
  void *__s;
  rsize_t __n;

  v3 = 3758097090;
  v4 = der_key_op_enable_test_keys;
  v5 = (void **)calloc(8uLL, 1uLL);
  *v5 = 0;
  encode_list_add_key(v5, (uint64_t)der_key_op, (uint64_t)v4);
  __s = 0;
  __n = 0;
  if (!encode_list_add_data(v5, (uint64_t)der_key_passcode, a2)
    && !encode_list_dict(v5, &__s, &__n))
  {
    v3 = _aks_operation();
  }
  encode_list_free(v5);
  memset_s(v5, 8uLL, 0, 8uLL);
  free(v5);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v3;
}

uint64_t aks_ref_key_attest(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  void *v12;
  void **v13;
  void *__s;
  rsize_t __n;
  void *v17;

  v11 = 3758097090;
  v12 = der_key_op_attest;
  v13 = (void **)calloc(8uLL, 1uLL);
  *v13 = 0;
  encode_list_add_key(v13, (uint64_t)der_key_op, (uint64_t)v12);
  __s = 0;
  __n = 0;
  v17 = 0;
  if (a5)
  {
    if (a6)
    {
      if (!_get_merged_params((uint64_t)a4, &v17, 0))
      {
        encode_list_remove_key(&v17, (unsigned __int8 *)der_key_ref_key);
        if (!encode_list_add_der(&v17, (uint64_t)der_key_ref_key, *a4, a4[2])
          && !_get_merged_params((uint64_t)a1, v13, a2))
        {
          encode_list_remove_key(v13, (unsigned __int8 *)der_key_ref_key);
          if (!encode_list_add_list(v13, (uint64_t)der_key_data, &v17)
            && !encode_list_add_der(v13, (uint64_t)der_key_ref_key, *a1, a1[2])
            && !encode_list_dict(v13, &__s, &__n))
          {
            v11 = _aks_operation();
          }
        }
      }
    }
  }
  encode_list_free(&v17);
  encode_list_free(v13);
  memset_s(v13, 8uLL, 0, 8uLL);
  free(v13);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v11;
}

uint64_t aks_ref_key_set_params(uint64_t a1, const void *a2, size_t __count)
{
  void *v6;
  uint64_t result;
  void *v8;

  if (a2 && der_get_sizeof((uint64_t)a2) != __count)
    return 3758097090;
  v6 = *(void **)(a1 + 48);
  if (v6)
  {
    memset_s(v6, *(_QWORD *)(a1 + 56), 0, *(_QWORD *)(a1 + 56));
    free(*(void **)(a1 + 48));
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
  }
  result = 0;
  if (a2 && __count)
  {
    v8 = calloc(__count, 1uLL);
    *(_QWORD *)(a1 + 48) = v8;
    *(_QWORD *)(a1 + 56) = __count;
    if (v8)
    {
      memcpy(v8, a2, __count);
      return 0;
    }
    else
    {
      return 3758604298;
    }
  }
  return result;
}

uint64_t aks_ref_key_get_blob(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;

  result = *a1;
  *a2 = a1[1];
  return result;
}

uint64_t aks_ref_key_get_external_data(uint64_t a1, uint64_t *a2)
{
  *a2 = der_get_sizeof(*(_QWORD *)(a1 + 24));
  return *(_QWORD *)(a1 + 24);
}

uint64_t aks_ref_key_get_uuid(uint64_t a1, _QWORD *a2)
{
  int value;
  uint64_t result;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;

  v9 = 0;
  v8 = 0;
  if (!*(_QWORD *)(a1 + 32))
    return 0;
  v6 = 0;
  v7 = 0;
  value = der_dict_find_value((uint64_t)der_key_uuid, &v6, &v7);
  result = 0;
  if (value)
  {
    *(_QWORD *)&v5 = v6;
    *((_QWORD *)&v5 + 1) = v6 + v7;
    der_utils_decode_implicit_raw_octet_string(&v5, 4, &v9, &v8);
    *a2 = v9;
    return v8;
  }
  return result;
}

uint64_t aks_ref_key_get_handle(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t aks_ref_key_get_key_class(uint64_t a1)
{
  return aks_ref_key_get_raw_key_class(a1) & 0x1F;
}

uint64_t aks_ref_key_get_raw_key_class(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;

  if (!*(_QWORD *)(a1 + 32))
    return 0;
  v2 = 0;
  v3 = 0;
  result = der_dict_find_value((uint64_t)der_key_keybag_class, &v2, &v3);
  if ((_DWORD)result)
    return der_get_number();
  return result;
}

uint64_t aks_ref_key_get_options(uint64_t a1)
{
  int value;
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  if (!*(_QWORD *)(a1 + 32))
    return 0;
  v3 = 0;
  v4 = 0;
  value = der_dict_find_value((uint64_t)der_key_options, &v3, &v4);
  result = 0;
  if (value)
    return der_get_number();
  return result;
}

uint64_t aks_ref_key_validate_key(uint64_t *a1)
{
  uint64_t v2;
  void *v3;
  void **v4;
  void *__s;
  rsize_t __n;

  v2 = 3758097090;
  v3 = der_key_op_validate_key;
  v4 = (void **)calloc(8uLL, 1uLL);
  *v4 = 0;
  encode_list_add_key(v4, (uint64_t)der_key_op, (uint64_t)v3);
  __s = 0;
  __n = 0;
  if (!encode_list_add_der(v4, (uint64_t)der_key_ref_key, *a1, a1[2])
    && !encode_list_dict(v4, &__s, &__n))
  {
    v2 = _aks_operation();
  }
  encode_list_free(v4);
  memset_s(v4, 8uLL, 0, 8uLL);
  free(v4);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v2;
}

uint64_t aks_sik_attest(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return _op_attest(a1, (uint64_t)der_key_op_sik_attest, a2, a3, a4, a5);
}

uint64_t _op_attest(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  void **v12;
  void *__s;
  rsize_t __n;

  v11 = 3758097090;
  v12 = (void **)calloc(8uLL, 1uLL);
  *v12 = 0;
  encode_list_add_key(v12, (uint64_t)der_key_op, a2);
  __s = 0;
  __n = 0;
  if (a1)
  {
    if (a5)
    {
      if (a6)
      {
        if (!_get_merged_params((uint64_t)a1, v12, a3))
        {
          encode_list_remove_key(v12, (unsigned __int8 *)der_key_ref_key);
          if (!encode_list_add_der(v12, (uint64_t)der_key_ref_key, *a1, a1[2])
            && !encode_list_dict(v12, &__s, &__n))
          {
            v11 = _aks_operation();
          }
        }
      }
    }
  }
  encode_list_free(v12);
  memset_s(v12, 8uLL, 0, 8uLL);
  free(v12);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v11;
}

uint64_t aks_gid_attest(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return _op_attest(a1, (uint64_t)der_key_op_gid_attest, a2, a3, a4, a5);
}

uint64_t aks_sik_optional_params(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t v9;
  uint64_t v11;
  size_t v12;
  void *v13;

  v11 = 0;
  v12 = 0;
  v13 = 0;
  v9 = 3758097090;
  if ((!a1 || a2 <= 0x20 && !encode_list_add_data(&v13, (uint64_t)der_key_salt, a1))
    && (!a3 || !encode_list_add_data(&v13, (uint64_t)der_key_data, a3)))
  {
    if (encode_list_is_empty(&v13))
    {
      v9 = 0;
    }
    else if (!encode_list_dict(&v13, &v11, &v12))
    {
      v9 = 0;
      *a5 = v11;
      *a6 = v12;
    }
  }
  encode_list_free(&v13);
  return v9;
}

uint64_t aks_sik_collection(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void **v4;
  void *__s;
  rsize_t __n;

  v2 = 3758097090;
  v3 = der_key_op_sik_collection;
  v4 = (void **)calloc(8uLL, 1uLL);
  *v4 = 0;
  encode_list_add_key(v4, (uint64_t)der_key_op, (uint64_t)v3);
  __s = 0;
  __n = 0;
  if ((!a1 || !encode_list_merge_dict((uint64_t)v4)) && !encode_list_dict(v4, &__s, &__n))
    v2 = _aks_operation();
  encode_list_free(v4);
  memset_s(v4, 8uLL, 0, 8uLL);
  free(v4);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v2;
}

uint64_t aks_get_sik_status(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v7;
  void *v8;
  void **v9;
  void *__s;
  rsize_t __n;

  v7 = 3758097090;
  v8 = der_key_op_get_sik_status;
  v9 = (void **)calloc(8uLL, 1uLL);
  *v9 = 0;
  encode_list_add_key(v9, (uint64_t)der_key_op, (uint64_t)v8);
  __s = 0;
  __n = 0;
  if ((!a1 || !encode_list_merge_dict((uint64_t)v9)) && !encode_list_dict(v9, &__s, &__n))
  {
    v7 = _aks_operation();
    if (!(_DWORD)v7)
    {
      *a3 = 0;
      *a4 = 0;
    }
  }
  encode_list_free(v9);
  memset_s(v9, 8uLL, 0, 8uLL);
  free(v9);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v7;
}

uint64_t aks_system_key_collection(unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t v11;
  void *v12;
  void **v13;
  void *__s;
  rsize_t __n;

  v11 = 3758097090;
  v12 = der_key_op_system_key_collect;
  v13 = (void **)calloc(8uLL, 1uLL);
  *v13 = 0;
  encode_list_add_key(v13, (uint64_t)der_key_op, (uint64_t)v12);
  __s = 0;
  __n = 0;
  if ((!a3 || !encode_list_merge_dict((uint64_t)v13))
    && !encode_list_add_number(v13, (uint64_t)der_key_system_key_type, a1)
    && !encode_list_add_number(v13, (uint64_t)der_key_system_key_generation, a2)
    && !encode_list_dict(v13, &__s, &__n))
  {
    v11 = _aks_operation();
    if (!(_DWORD)v11)
    {
      *a5 = 0;
      *a6 = 0;
    }
  }
  encode_list_free(v13);
  memset_s(v13, 8uLL, 0, 8uLL);
  free(v13);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v11;
}

uint64_t aks_system_key_attest(unsigned int a1, unsigned int a2, uint64_t *a3, uint64_t a4, uint64_t a5, _QWORD *a6, _QWORD *a7)
{
  uint64_t v13;
  void *v14;
  void **v15;
  void *__s;
  rsize_t __n;

  v13 = 3758097090;
  v14 = der_key_op_system_key_attest;
  v15 = (void **)calloc(8uLL, 1uLL);
  *v15 = 0;
  encode_list_add_key(v15, (uint64_t)der_key_op, (uint64_t)v14);
  __s = 0;
  __n = 0;
  if (a3)
  {
    if (!_get_merged_params((uint64_t)a3, v15, a4))
    {
      encode_list_remove_key(v15, (unsigned __int8 *)der_key_ref_key);
      if (!encode_list_add_der(v15, (uint64_t)der_key_ref_key, *a3, a3[2])
        && !encode_list_add_number(v15, (uint64_t)der_key_system_key_type, a1)
        && !encode_list_add_number(v15, (uint64_t)der_key_system_key_generation, a2)
        && !encode_list_dict(v15, &__s, &__n))
      {
        v13 = _aks_operation();
        if (!(_DWORD)v13)
        {
          *a6 = 0;
          *a7 = 0;
        }
      }
    }
  }
  encode_list_free(v15);
  memset_s(v15, 8uLL, 0, 8uLL);
  free(v15);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v13;
}

uint64_t aks_system_key_operate(unsigned int a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6;
  void *v7;
  void **v8;
  void *__s;
  rsize_t __n;

  v6 = 3758097090;
  v7 = der_key_op_system_key_operate;
  v8 = (void **)calloc(8uLL, 1uLL);
  *v8 = 0;
  encode_list_add_key(v8, (uint64_t)der_key_op, (uint64_t)v7);
  __s = 0;
  __n = 0;
  if ((!a3 || !encode_list_merge_dict((uint64_t)v8))
    && !encode_list_add_number(v8, (uint64_t)der_key_system_key_type, a1)
    && !encode_list_add_number(v8, (uint64_t)der_key_system_key_operation, a2)
    && !encode_list_dict(v8, &__s, &__n))
  {
    v6 = _aks_operation();
  }
  encode_list_free(v8);
  memset_s(v8, 8uLL, 0, 8uLL);
  free(v8);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v6;
}

uint64_t aks_system_key_get_public(unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t v11;
  void *v12;
  void **v13;
  void *__s;
  rsize_t __n;

  v11 = 3758097090;
  v12 = der_key_op_system_key_get_public;
  v13 = (void **)calloc(8uLL, 1uLL);
  *v13 = 0;
  encode_list_add_key(v13, (uint64_t)der_key_op, (uint64_t)v12);
  __s = 0;
  __n = 0;
  if ((!a3 || !encode_list_merge_dict((uint64_t)v13))
    && !encode_list_add_number(v13, (uint64_t)der_key_system_key_type, a1)
    && !encode_list_add_number(v13, (uint64_t)der_key_system_key_generation, a2)
    && !encode_list_dict(v13, &__s, &__n))
  {
    v11 = _aks_operation();
    if (!(_DWORD)v11)
    {
      *a5 = 0;
      *a6 = 0;
    }
  }
  encode_list_free(v13);
  memset_s(v13, 8uLL, 0, 8uLL);
  free(v13);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v11;
}

uint64_t aks_system_key_sign(unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7, _QWORD *a8)
{
  uint64_t v13;
  void *v14;
  void **v15;
  void *__s;
  rsize_t __n;

  v13 = 3758097090;
  v14 = der_key_op_system_key_sign;
  v15 = (void **)calloc(8uLL, 1uLL);
  *v15 = 0;
  encode_list_add_key(v15, (uint64_t)der_key_op, (uint64_t)v14);
  __s = 0;
  __n = 0;
  if (!a3 || !encode_list_merge_dict((uint64_t)v15))
  {
    encode_list_remove_key(v15, (unsigned __int8 *)der_key_system_key_type);
    encode_list_remove_key(v15, (unsigned __int8 *)der_key_system_key_generation);
    encode_list_remove_key(v15, (unsigned __int8 *)der_key_data);
    if (!encode_list_add_number(v15, (uint64_t)der_key_system_key_type, a1)
      && !encode_list_add_number(v15, (uint64_t)der_key_system_key_generation, a2)
      && !encode_list_add_data(v15, (uint64_t)der_key_data, a5)
      && !encode_list_dict(v15, &__s, &__n))
    {
      v13 = _aks_operation();
      if (!(_DWORD)v13)
      {
        *a7 = 0;
        *a8 = 0;
      }
    }
  }
  encode_list_free(v15);
  memset_s(v15, 8uLL, 0, 8uLL);
  free(v15);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v13;
}

void aks_dealloc(void *a1, rsize_t __n)
{
  memset_s(a1, __n, 0, __n);
  free(a1);
}

uint64_t aks_fv_apfs_get_default_disk(char *a1, size_t a2)
{
  uint64_t v4;
  FILE *v6;
  int *v7;
  char *v8;
  statfs v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v4 = 3758097084;
  bzero(&v9, 0x878uLL);
  if (a1)
  {
    if (statfs("/private/var", &v9))
    {
      v6 = (FILE *)*MEMORY[0x24BDAC8E8];
      v7 = __error();
      v8 = strerror(*v7);
      fprintf(v6, "%s%s:%s%s%s%s%u:%s%u:%s statfs error: %s\n%s\n", "aks", "", "", "", "aks_fv_apfs_get_default_disk", ":", 33, "", 0, "", v8, "");
      return 3758097136;
    }
    else if (*(_DWORD *)v9.f_fstypename ^ 0x73667061 | v9.f_fstypename[4])
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s skipping: not apfs%s\n", "aks", "", "", "", "aks_fv_apfs_get_default_disk", ":", 34, "", 0, "", "");
      return 3758097112;
    }
    else if (strlcpy(a1, v9.f_mntfromname, a2) >= a2)
    {
      return 3758097084;
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t fv_apfs_remove_blob(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  FILE *v4;
  int *v5;
  char *v6;

  result = 3758097090;
  if (a1 && a2)
  {
    result = APFSVolumeRemoveUnlockRecord();
    if ((_DWORD)result)
    {
      v4 = (FILE *)*MEMORY[0x24BDAC8E8];
      v5 = __error();
      v6 = strerror(*v5);
      fprintf(v4, "%s%s:%s%s%s%s%u:%s%u:%s APFSVolumeRemoveUnlockRecord: %s%s\n", "aks", "", "", "", "fv_apfs_remove_blob", ":", 49, "", 0, "", v6, "");
      return 3758097084;
    }
  }
  return result;
}

uint64_t fv_apfs_set_blob(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t result;
  CFDataRef v6;
  CFDataRef v7;
  FILE *v8;
  int *v9;
  char *v10;

  v4 = 3758097084;
  result = 3758097090;
  if (a1 && a2 && a3)
  {
    v6 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], *(const UInt8 **)a3, *(_QWORD *)(a3 + 8), (CFAllocatorRef)*MEMORY[0x24BDBD258]);
    if (v6)
    {
      v7 = v6;
      if (APFSVolumeSetUnlockRecord())
      {
        v8 = (FILE *)*MEMORY[0x24BDAC8E8];
        v9 = __error();
        v10 = strerror(*v9);
        fprintf(v8, "%s%s:%s%s%s%s%u:%s%u:%s APFSVolumeSetUnlockRecord: %s%s\n", "aks", "", "", "", "fv_apfs_set_blob", ":", 65, "", 0, "", v10, "");
      }
      else
      {
        v4 = 0;
      }
      CFRelease(v7);
      return v4;
    }
    else
    {
      return 3758097084;
    }
  }
  return result;
}

uint64_t aks_fv_apfs_get_blob_by_uuid(uint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  BOOL v6;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  const __CFString *ValueAtIndex;
  int UnlockRecord;
  FILE *v14;
  uuid_t uu;
  char buffer[16];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v3 = 3758097084;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v4 = 3758097090;
  *(_OWORD *)buffer = 0u;
  v17 = 0u;
  if (!a1 || !a3)
    return v4;
  if (MEMORY[0x24BDFD2B8])
    v6 = MEMORY[0x24BDFD2D0] == 0;
  else
    v6 = 1;
  if (v6)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s no apfs fwk%s\n", "aks", "", "", "", "aks_fv_apfs_get_blob_by_uuid");
    return 3758097084;
  }
  if (APFSVolumeListUUIDsOfUnlockRecords())
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s APFSVolumeListUUIDsOfUnlockRecords failed%s\n", "aks", "", "", "", "aks_fv_apfs_get_blob_by_uuid");
    return 3758097084;
  }
  Count = CFArrayGetCount(0);
  if (Count)
  {
    v9 = Count;
    v10 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(0, v10);
      memset(uu, 0, sizeof(uu));
      if (!CFStringGetCString(ValueAtIndex, buffer, 128, 0x8000100u))
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s string fail%s\n", "aks", "", "", "", "aks_fv_apfs_get_blob_by_uuid", ":", 100, "", 0, "", "");
        return v3;
      }
      uuid_parse(buffer, uu);
      if (!uuid_compare(uu, a2))
        break;
      if (v9 == ++v10)
        goto LABEL_16;
    }
    UnlockRecord = APFSVolumeGetUnlockRecord();
    if (UnlockRecord)
    {
      v14 = (FILE *)*MEMORY[0x24BDAC8E8];
      strerror(UnlockRecord);
      fprintf(v14, "%s%s:%s%s%s%s%u:%s%u:%s APFSVolumeGetUnlockRecord: %s\n%s\n", "aks", "", "", "", "aks_fv_apfs_get_blob_by_uuid", ":");
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s no kek%s\n", "aks", "", "", "", "aks_fv_apfs_get_blob_by_uuid");
    }
    return 3758097136;
  }
  else
  {
LABEL_16:
    if (*(_QWORD *)(a3 + 8))
      return 0;
    else
      return 3758097136;
  }
}

uint64_t fv_apfs_get_blobs(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  CFIndex Count;
  BOOL v4;
  const __CFString *ValueAtIndex;
  int UnlockRecord;
  FILE *v8;
  uuid_t uu;
  char buffer[16];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = 3758097084;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  Count = 3758097090;
  *(_OWORD *)buffer = 0u;
  v11 = 0u;
  if (!a1 || !a2)
    return Count;
  if (MEMORY[0x24BDFD2B8])
    v4 = MEMORY[0x24BDFD2D0] == 0;
  else
    v4 = 1;
  if (v4)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s no apfs fwk%s\n", "aks", "", "", "", "fv_apfs_get_blobs");
    return 3758097084;
  }
  if (APFSVolumeListUUIDsOfUnlockRecords())
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s APFSVolumeListUUIDsOfUnlockRecords failed%s\n", "aks", "", "", "", "fv_apfs_get_blobs");
    return 3758097084;
  }
  Count = CFArrayGetCount(0);
  if (Count)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(0, 0);
    memset(uu, 0, sizeof(uu));
    if (CFStringGetCString(ValueAtIndex, buffer, 128, 0x8000100u))
    {
      uuid_parse(buffer, uu);
      UnlockRecord = APFSVolumeGetUnlockRecord();
      if (UnlockRecord)
      {
        v8 = (FILE *)*MEMORY[0x24BDAC8E8];
        strerror(UnlockRecord);
        fprintf(v8, "%s%s:%s%s%s%s%u:%s%u:%s APFSVolumeGetUnlockRecord: %s\n%s\n", "aks", "", "", "", "fv_apfs_get_blobs", ":");
      }
      else
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s no kek%s\n", "aks", "", "", "", "fv_apfs_get_blobs");
      }
      return 3758097136;
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s string fail%s\n", "aks", "", "", "", "fv_apfs_get_blobs", ":", 152, "", 0, "", "");
    }
    return v2;
  }
  return Count;
}

uint64_t aks_fv_apfs_get_vek(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  size_t Length;
  void *v5;
  void *v6;
  const UInt8 *BytePtr;

  v3 = 3758097084;
  if (!APFSVolumeGetWVEK())
  {
    Length = CFDataGetLength(0);
    a2[1] = Length;
    v5 = malloc(Length);
    *a2 = v5;
    if (v5)
    {
      v6 = v5;
      BytePtr = CFDataGetBytePtr(0);
      memcpy(v6, BytePtr, a2[1]);
      return 0;
    }
    else
    {
      return 3758097085;
    }
  }
  return v3;
}

size_t aks_fv_apfs_device_parse(const char *a1, char *a2, size_t a3, char **a4)
{
  uint64_t v8;
  const char *v9;
  int v10;

  if (!strncmp(a1, "/dev/", 5uLL))
    v8 = 5;
  else
    v8 = 0;
  v9 = &a1[v8];
  if (!strncmp(&a1[v8], "disk", 4uLL))
  {
    *a4 = a2;
  }
  else
  {
    v10 = strncmp(v9, "rdisk", 5uLL);
    *a4 = a2;
    if (v10)
      v9 = a1;
    else
      ++v9;
  }
  return strlcpy(a2, v9, a3);
}

const char *fv_apfs_is_special_uuid(const unsigned __int8 *a1)
{
  _BYTE v2[37];
  uint64_t v3;

  v3 = *MEMORY[0x24BDAC8D0];
  memset(v2, 0, sizeof(v2));
  uuid_unparse_upper(a1, v2);
  if (!strcmp("EBC6C064-0000-11AA-AA11-00306543ECAC", v2))
    return "personal recovery key";
  if (!strcmp("64C0C6EB-0000-11AA-AA11-00306543ECAC", v2))
    return "icloud recovery key";
  if (!strcmp("C064EBC6-0000-11AA-AA11-00306543ECAC", v2))
    return "institutional recovery key";
  if (!strcmp("EC1C2AD9-B618-4ED6-BD8D-50F361C27507", v2))
    return "icloud user";
  if (!strcmp("2FA31400-BAFF-4DE7-AE2A-C3AA6E1FD340", v2))
    return "institutional user";
  if (!strcmp("2457711A-523C-4604-B75A-F48A571D5036", v2))
    return "mdm boostrap token";
  if (!strcmp("BF6F8EF2-33A3-408A-A6D3-37EAFC077B07", v2))
    return "installer bootstrap user";
  return 0;
}

void *aks_create_escrow_blob(rsize_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  int v6;
  uint64_t v7;
  size_t v8;
  rsize_t v9;
  char *v10;
  void *v11;
  char *v13;
  char *v14;

  if (a5 >> 16)
    v6 = 0;
  else
    v6 = (unsigned __int16)a5;
  if (a3 != 32 || !a2 || !a4 || !v6)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s Bad input %d %zd %d %zd%s\n", "aks", "", "", "", "aks_create_escrow_blob", ":", 26, "", 0);
    goto LABEL_21;
  }
  v7 = ccder_sizeof_raw_octet_string();
  if (__CFADD__(v7, ccder_sizeof_raw_octet_string()))
  {
LABEL_21:
    v11 = 0;
LABEL_22:
    v9 = 0;
    if (!a1)
      return v11;
    goto LABEL_16;
  }
  v8 = ccder_sizeof();
  v9 = v8;
  if (v8 >= 0x3C01)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s Escrow blob is too big %zd/%llu%s\n", "aks", "", "", "", "aks_create_escrow_blob", ":", 31);
    goto LABEL_21;
  }
  v10 = (char *)calloc(v8, 1uLL);
  v11 = v10;
  if (!v10)
    goto LABEL_22;
  v13 = v10;
  v14 = &v10[v9];
  if (!ccder_blob_encode_body_tl()
    || !ccder_blob_encode_body_tl()
    || !ccder_blob_encode_tl()
    || v13 != v14)
  {
    memset_s(v11, v9, 0, v9);
    free(v11);
    goto LABEL_21;
  }
  if (a1)
LABEL_16:
    *a1 = v9;
  return v11;
}

void aks_free_escrow_blob(void **a1, rsize_t __smax)
{
  void *v3;

  if (a1)
  {
    v3 = *a1;
    if (v3)
    {
      if (__smax)
      {
        memset_s(v3, __smax, 0, __smax);
        v3 = *a1;
      }
      memset_s(v3, __smax, 0, __smax);
      free(*a1);
    }
  }
}

uint64_t aks_parse_escrow_blob(uint64_t a1, unint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t v6;
  int v11;
  int v12;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  __int128 v18;

  v6 = 1;
  if (a1 && a2 >= 0x20)
  {
    *(_QWORD *)&v18 = a1;
    *((_QWORD *)&v18 + 1) = a1 + a2;
    if (ccder_blob_decode_range())
    {
      if ((unint64_t)(*((_QWORD *)&v18 + 1) - v18 - 15360) < 0xFFFFFFFFFFFFC420)
      {
        v6 = 3;
      }
      else
      {
        v17 = 0;
        v16 = 0;
        v15 = 0;
        v14 = 0;
        der_utils_decode_implicit_raw_octet_string(&v18, 0x8000000000000000, &v17, &v16);
        if (v11 && (der_utils_decode_implicit_raw_octet_string(&v18, 0x8000000000000001, &v15, &v14), v12))
        {
          v6 = 0;
          *a3 = v16;
          *a4 = v17;
          *a5 = v14;
          *a6 = v15;
        }
        else
        {
          v6 = 0xFFFFFFFFLL;
        }
      }
    }
    else
    {
      v6 = 2;
    }
  }
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s escrow blob parse error %d%s\n", "aks", "", "", "", "aks_parse_escrow_blob", ":", 100, "", 0, "", v6, "");
  return v6;
}

uint64_t aks_get_os_type()
{
  return 1;
}

uint64_t attest_verify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  _BYTE v9[1120];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  bzero(v9, 0x460uLL);
  result = aks_attest_context_init(a3, a4, v9);
  if (!(_DWORD)result)
    return aks_attest_context_verify((uint64_t)v9, a1, a2);
  return result;
}

uint64_t aks_attest_context_init(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result;
  uint64_t v7;
  __int128 v8;

  result = 4294967285;
  if (a1 && a2 && a3)
  {
    bzero(a3, 0x460uLL);
    *((_QWORD *)a3 + 2) = a1;
    *((_QWORD *)a3 + 3) = a1 + a2;
    if (ccder_blob_decode_range())
    {
      if ((ccder_blob_decode_uint64() & 1) != 0)
      {
        v7 = 0;
        *((_QWORD *)a3 + 1) = 0;
      }
      else
      {
        v7 = *((_QWORD *)a3 + 1);
      }
      if (v7 == 3)
      {
        if (ccder_blob_decode_range())
          ccder_blob_decode_uint64();
        return 4294967272;
      }
      if (!v7)
      {
        v8 = *((_OWORD *)a3 + 1);
        if (ccder_blob_decode_range())
        {
          if (ccder_blob_decode_range())
          {
            *((_QWORD *)a3 + 4) = v8;
            *((_QWORD *)a3 + 5) = 0;
            ccder_blob_decode_uint64();
          }
        }
        return 4294967272;
      }
      return 4294967284;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t aks_attest_context_verify(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  size_t v5;
  char *v6;
  uint64_t v7;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x24BDAC8D0];
  result = 4294967285;
  if (a2 && a3)
  {
    if (!a1 || !*(_BYTE *)a1)
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s context not initialized%s\n", "aks", "", "", "", "aks_attest_context_verify", ":", 1093, "", 0, "", "");
      return 4294967282;
    }
    if (a3 == 65)
    {
      MEMORY[0x219A17EA0](4294967285);
    }
    else
    {
      if (a3 != 97)
        return result;
      MEMORY[0x219A17EAC](4294967285);
    }
    MEMORY[0x24BDAC7A8]();
    v6 = (char *)v8 - v5;
    bzero((char *)v8 - v5, v5);
    if (ccec_import_pub())
      return 0xFFFFFFFFLL;
    v7 = *(_QWORD *)(a1 + 8);
    if (v7 == 3)
    {
      result = verify_simple_request((uint64_t)v6, a1);
      if (!(_DWORD)result)
        return 0;
    }
    else
    {
      if (!v7)
      {
        result = verify_certificate_request((uint64_t)v6, a1);
        if ((_DWORD)result)
          return result;
        return 0;
      }
      return 4294967284;
    }
  }
  return result;
}

uint64_t attest_get(uint64_t a1, uint64_t a2, unsigned int a3, _QWORD *a4, size_t *a5)
{
  uint64_t result;
  _BYTE v11[1120];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  bzero(v11, 0x460uLL);
  result = aks_attest_context_init(a1, a2, v11);
  if (!(_DWORD)result)
    return aks_attest_context_get((uint64_t)v11, a3, a4, a5);
  return result;
}

uint64_t aks_attest_context_get(uint64_t a1, unsigned int a2, _QWORD *a3, size_t *a4)
{
  if (a1 && *(_BYTE *)a1)
  {
    if (!*(_BYTE *)(a1 + 1) && (_akslog_filter & 2) != 0)
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s %swarning parsing an unverified attestation%s\n", "aks", "", "", "", "aks_attest_context_get", ":", 866, "", 0, "", "", "");
    return aks_attest_context_get_internal((_QWORD *)a1, a2, a3, a4);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s context not initialized%s\n", "aks", "", "", "", "aks_attest_context_get", ":", 864, "", 0, "", "");
    return 4294967285;
  }
}

uint64_t aks_get_digest_info(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;

  if (ccoid_equal())
  {
    v3 = ccsha384_di();
  }
  else if (ccoid_equal())
  {
    v3 = ccsha256_di();
  }
  else
  {
    if (!ccoid_equal())
      return 4294967272;
    v3 = ccsha512_di();
  }
  v4 = 0;
  *a2 = v3;
  return v4;
}

uint64_t aks_get_pub_key_cp(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  if (ccoid_equal())
  {
    v3 = MEMORY[0x219A17EAC]();
LABEL_5:
    v4 = v3;
    result = 0;
    *a2 = v4;
    return result;
  }
  if (ccoid_equal())
  {
    v3 = MEMORY[0x219A17EA0]();
    goto LABEL_5;
  }
  return 4294967272;
}

uint64_t aks_attest_context_get_internal(_QWORD *a1, unsigned int a2, _QWORD *a3, size_t *a4)
{
  uint64_t result;
  _DWORD *v8;
  int v10;
  uint64_t v11;
  size_t v12;
  const void *v13;
  size_t v14;
  size_t v15;
  void *v16;
  void *__s1;
  size_t __n;

  result = 4294967285;
  if (!a3 || !a4)
    return result;
  if (a2 >= 0x13 || (v8 = &param_id_table[4 * a2], *v8 != a2))
    abort();
  v10 = param_id_table[4 * a2 + 1];
  if (v10 == 2)
  {
    if (a2 == 5)
    {
      *a3 = a1[27];
      v12 = a1[28];
LABEL_21:
      *a4 = v12;
      return 0;
    }
    if (a2 != 3)
    {
      if (a2 != 1)
        return 4294967293;
      v11 = a1[105];
      if (v11)
      {
        *a3 = v11;
        v12 = a1[104];
      }
      else
      {
        *a3 = a1[62];
        v12 = a1[61];
      }
      goto LABEL_21;
    }
    __s1 = 0;
    __n = 0;
    result = _get_param_data((uint64_t)a1, (uint64_t)v8, &__s1, &__n);
    if ((_DWORD)result)
      return result;
    v13 = (const void *)a1[43];
    if (v13)
    {
      v14 = __n;
      v15 = a1[44];
    }
    else
    {
      v13 = (const void *)a1[129];
      if (!v13)
      {
        v16 = __s1;
        v14 = __n;
LABEL_26:
        *a3 = v16;
        *a4 = v14;
        return 0;
      }
      v14 = __n;
      v15 = a1[130];
    }
    if (v14 > v15)
      return 0xFFFFFFFFLL;
    v16 = __s1;
    if (memcmp(__s1, v13, v14))
      return 4294967272;
    goto LABEL_26;
  }
  if (v10 != 1)
    return 4294967286;
  result = _get_param_data((uint64_t)a1, (uint64_t)v8, a3, a4);
  if (!(_DWORD)result)
    return 0;
  return result;
}

uint64_t aks_attest_context_get_uint64(uint64_t a1, unsigned int a2)
{
  if (a1 && *(_BYTE *)a1)
  {
    if (!*(_BYTE *)(a1 + 1) && (_akslog_filter & 2) != 0)
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s %swarning parsing an unverified attestation%s\n", "aks", "", "", "", "aks_attest_context_get_uint64", ":", 898, "", 0, "", "", "");
    return aks_attest_context_get_uint64_internal((_QWORD *)a1, a2);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s context not initialized%s\n", "aks", "", "", "", "aks_attest_context_get_uint64", ":", 896, "", 0, "", "");
    return 4294967285;
  }
}

uint64_t aks_attest_context_get_uint64_internal(_QWORD *a1, unsigned int a2)
{
  uint64_t result;
  uint64_t v3;
  size_t v4;

  v3 = 0;
  v4 = 0;
  result = aks_attest_context_get_internal(a1, a2, &v3, &v4);
  if (!(_DWORD)result)
    return ccder_blob_decode_uint64() - 1;
  return result;
}

uint64_t aks_attest_context_get_header_version(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  if (!a2)
    return 4294967285;
  if (a1 && *(_BYTE *)a1)
  {
    result = 0;
    *a2 = *(_QWORD *)(a1 + 8);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s context not initialized%s\n", "aks", "", "", "", "aks_attest_context_get_header_version", ":", 913, "", 0, "", "");
    return 4294967285;
  }
  return result;
}

uint64_t aks_attest_context_get_blob(_BYTE *a1, int a2, void *__dst)
{
  const void *v3;
  const void *v4;
  void *v5;

  if (!__dst)
    return 4294967285;
  if (a1 && *a1)
  {
    switch(a2)
    {
      case 1:
        v4 = a1 + 88;
        if (*((_QWORD *)a1 + 11))
        {
          v5 = __dst;
          v3 = v4;
LABEL_14:
          memcpy(v5, v3, 0x158uLL);
          return 0;
        }
        return 4294967293;
      case 3:
        if (*((_QWORD *)a1 + 97))
        {
          v3 = a1 + 776;
          goto LABEL_13;
        }
        return 4294967293;
      case 2:
        if (*((_QWORD *)a1 + 54))
        {
          v3 = a1 + 432;
LABEL_13:
          v5 = __dst;
          goto LABEL_14;
        }
        return 4294967293;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s context not initialized%s\n", "aks", "", "", "", "aks_attest_context_get_blob", ":", 928, "", 0, "", "");
  }
  return 4294967285;
}

uint64_t aks_attest_context_get_info(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t result;
  uint64_t v8;

  result = 4294967285;
  if (a6 && a2 && a3 && a4 && a5)
  {
    if (a1 && *(_BYTE *)a1)
    {
      result = 0;
      *a2 = *(_QWORD *)(a1 + 32);
      *a3 = *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32);
      v8 = *(_QWORD *)(a1 + 56);
      *a4 = *(_QWORD *)(a1 + 48);
      *a5 = *(_QWORD *)(a1 + 64);
      *a6 = v8;
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s context not initialized%s\n", "aks", "", "", "", "aks_attest_context_get_info", ":", 959, "", 0, "", "");
      return 4294967285;
    }
  }
  return result;
}

uint64_t verify_certificate_request(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  _BYTE *v9;
  size_t v10;
  _BYTE v11[15];
  char v12;
  unint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if (_verify_ec_attest_blob(a1, (_QWORD *)(a2 + 88))
    || *(_QWORD *)(a2 + 776) && _verify_ec_attest_blob(a1, (_QWORD *)(a2 + 776)))
  {
    return 0xFFFFFFFFLL;
  }
  v16 = 0u;
  v17 = 0u;
  v15 = 0u;
  v13 = 48;
  v14 = 0;
  result = _calculate_digest(*(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 136), (uint64_t (*)(uint64_t, char *, uint64_t))_osk_digest_update, a2, (uint64_t)&v15, &v13);
  if (!(_DWORD)result)
  {
    result = aks_get_pub_key_cp(*(_QWORD *)(a2 + 136), &v14);
    if (!(_DWORD)result)
    {
      MEMORY[0x24BDAC7A8]();
      bzero(&v11[-v5], v5);
      if (ccec_import_pub())
        return 0xFFFFFFFFLL;
      v12 = 0;
      if (ccec_verify() || !v12)
        return 0xFFFFFFFFLL;
      v6 = *(_QWORD *)(a2 + 480);
      if (ccoid_equal())
      {
        *(_QWORD *)&v15 = 0;
        if (aks_attest_context_get_uint64_internal((_QWORD *)a2, 0x11u)
          || (_QWORD)v15 != 1
          || !ccoid_equal()
          || *(_QWORD *)(a2 + 464)
          || *(_QWORD *)(a2 + 472))
        {
          return 0xFFFFFFFFLL;
        }
      }
      else if (ccoid_equal())
      {
        v17 = 0u;
        v18 = 0u;
        v15 = 0u;
        v16 = 0u;
        v14 = 64;
        if (!ccoid_equal())
          return 0xFFFFFFFFLL;
        v7 = *(_QWORD *)(a2 + 456);
        if (!ccoid_equal())
          return 0xFFFFFFFFLL;
        if (!*(_QWORD *)(a2 + 432))
          return 0xFFFFFFFFLL;
        if (*(_QWORD *)(a2 + 488) != 32)
          return 0xFFFFFFFFLL;
        if (!*(_QWORD *)(a2 + 472))
          return 0xFFFFFFFFLL;
        if (*(_QWORD *)(a2 + 464) != 64)
          return 0xFFFFFFFFLL;
        if (_calculate_digest(v7, v6, (uint64_t (*)(uint64_t, char *, uint64_t))_blob_digest_update, a2 + 432, (uint64_t)&v15, (unint64_t *)&v14))return 0xFFFFFFFFLL;
        ccsha512_di();
        if (cced25519_verify())
          return 0xFFFFFFFFLL;
      }
      else
      {
        *(_QWORD *)&v15 = 0;
        result = aks_get_pub_key_cp(v6, (uint64_t *)&v15);
        if ((_DWORD)result)
          return result;
        MEMORY[0x24BDAC7A8]();
        v9 = &v11[-v8];
        bzero(&v11[-v8], v8);
        if (ccec_import_pub() || _verify_ec_attest_blob((uint64_t)v9, (_QWORD *)(a2 + 432)))
          return 0xFFFFFFFFLL;
      }
      if (!*(_QWORD *)(a2 + 776)
        || (v10 = *(_QWORD *)(a2 + 832), v10 == *(_QWORD *)(a2 + 488))
        && !memcmp(*(const void **)(a2 + 840), *(const void **)(a2 + 496), v10))
      {
        if ((*(_DWORD *)(a2 + 424) == 1936941921 || *(_DWORD *)(a2 + 424) == 1633907571)
          && (*(_BYTE *)(a2 + 160) & 0x40) != 0)
        {
          result = 0;
          *(_BYTE *)(a2 + 1) = 1;
          return result;
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t verify_simple_request(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  BOOL v17;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v22 = 0;
  v23 = 0;
  v24 = 0u;
  v25 = 0u;
  v4 = ccsha256_di();
  MEMORY[0x24BDAC7A8]();
  v6 = (char *)&v20 - v5;
  bzero((char *)&v20 - v5, v7);
  ccdigest_init();
  if (_verify_ec_attest_blob(a1, (_QWORD *)(a2 + 776)))
    return 0xFFFFFFFFLL;
  v8 = 0;
  v9 = *(_QWORD *)(a2 + 32);
  v10 = *(_QWORD *)(a2 + 40);
  do
  {
    v20 = v9;
    v21 = v10;
    if (ccder_blob_decode_range())
    {
      ccdigest_update();
      v9 = v20;
      v10 = v21;
    }
    ++v8;
  }
  while (v8 != 32);
  if (v9 != v10)
    return 0xFFFFFFFFLL;
  if (*(_QWORD *)(a2 + 56) != 32)
    return 4294967290;
  (*(void (**)(uint64_t, char *, __int128 *))(v4 + 56))(v4, v6, &v24);
  cc_clear();
  v11 = *(uint64_t **)(a2 + 64);
  v12 = *v11;
  v13 = v11[1];
  v15 = v11[2];
  v14 = v11[3];
  v16 = (_QWORD)v24 == v12 && *((_QWORD *)&v24 + 1) == v13;
  v17 = v16 && (_QWORD)v25 == v15;
  if (!v17 || *((_QWORD *)&v25 + 1) != v14)
    return 4294967290;
  result = 0;
  *(_BYTE *)(a2 + 1) = 1;
  return result;
}

uint64_t aks_attest_context_get_sealed_hash(_BYTE *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t result;
  BOOL v7;
  int v8;
  uint64_t v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  size_t v15;
  size_t v16;
  unint64_t v17;
  __int128 v18;
  size_t v19;
  size_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;

  v15 = 0;
  v16 = 0;
  result = 4294967285;
  if (a2 && a3)
  {
    if (a1 && *a1)
    {
      result = aks_attest_context_get((uint64_t)a1, 7u, &v15, &v16);
      if (!(_DWORD)result)
      {
        v19 = v15;
        v20 = v15 + v16;
        v18 = 0uLL;
        v17 = 0;
        if (ccder_blob_decode_range())
        {
          while (1)
          {
            if (v19)
              v7 = v19 == v20;
            else
              v7 = 1;
            if (v7)
              return 4294967293;
            if (v19 > v20)
            {
              fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s incorrect attestation data%s\n", "aks", "", "", "", "_find_sealed_data_hash", ":", 1163, "", 0, "", "");
              return 4294967272;
            }
            if (!ccder_blob_decode_range())
              return 0xFFFFFFFFLL;
            v24 = 0;
            v23 = v18;
            v21 = 0;
            v22 = 0;
            if (!ccder_blob_decode_range() || ccn_read_uint())
              return 0xFFFFFFFFLL;
            v18 = v23;
            if (v24)
              break;
            v8 = ccder_blob_decode_tl();
            result = 0xFFFFFFFFLL;
            if (!v8 || v17 < 0x56)
              return result;
            v9 = v18;
            if (*(_QWORD *)v18 == *a2 && *(_QWORD *)(v18 + 8) == a2[1])
            {
              result = 0;
              v11 = *(_OWORD *)(v18 + 16);
              *(_OWORD *)a3 = *(_OWORD *)v18;
              *(_OWORD *)(a3 + 16) = v11;
              v12 = *(_OWORD *)(v9 + 32);
              v13 = *(_OWORD *)(v9 + 48);
              v14 = *(_OWORD *)(v9 + 64);
              *(_QWORD *)(a3 + 78) = *(_QWORD *)(v9 + 78);
              *(_OWORD *)(a3 + 48) = v13;
              *(_OWORD *)(a3 + 64) = v14;
              *(_OWORD *)(a3 + 32) = v12;
              return result;
            }
          }
          fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s version mis-match during load%s\n", "aks", "", "", "", "_find_sealed_data_hash", ":", 1170, "", 0, "", "");
        }
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s context not initialized%s\n", "aks", "", "", "", "aks_attest_context_get_sealed_hash", ":", 1196, "", 0, "", "");
      return 4294967285;
    }
  }
  return result;
}

uint64_t aks_validate_certificate(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, _QWORD *a7)
{
  uint64_t result;
  unint64_t v12;
  int v13;
  char *v14;
  __int128 v15;
  _DWORD *exention_prop_by_id;
  void *v17;
  const void *v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD v24[2];
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const void *v28;
  size_t v29;
  _DWORD *v30;
  char *v31;
  uint64_t v32;
  _DWORD *v33;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v28 = 0;
  v29 = 0;
  v26 = 0;
  v27 = 0;
  v25 = 0;
  memset(v24, 0, sizeof(v24));
  v23 = 0;
  result = 4294967285;
  if (!a1 || !a2)
    return result;
  v36 = 0uLL;
  v37 = 0uLL;
  v35 = 0uLL;
  if (CTParseCertificateSet(a1, a1 + a2, &v35, 3, &v23))
    return 4294967286;
  if (v23 != 2)
    return 4294967285;
  v12 = CTGetBAASubCAType(v36, *((uint64_t *)&v36 + 1));
  result = 4294967272;
  if (v12 <= 4 && ((1 << v12) & 0x16) != 0)
  {
    v13 = CTEvaluateBAA(v12, a1, a2, 0, 0, &v28, &v29, &v26, &v27, (uint64_t)v24);
    if (v13)
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s error: CTEvaluateBAA returned %x%s\n", "aks", "", "", "", "aks_validate_certificate", ":", 1738, "", 0, "", v13, "");
      return 4294967274;
    }
    result = 4294967286;
    if (v28)
    {
      if (v29)
      {
        v22 = 0;
        if (!get_oid_property_integer(5u, 1u, v35, *((uint64_t *)&v35 + 1), &v22))
        {
          v14 = (v22 & 0x1F000000) != 0 ? "ssca" : "acss";
          v15 = v35;
          exention_prop_by_id = _get_exention_prop_by_id(6u, 6u);
          v33 = 0;
          v34 = 0;
          v32 = 0;
          if (!exention_prop_by_id[4]
            && !_get_oid_property_value(6u, *((_QWORD *)exention_prop_by_id + 1), v15, *((uint64_t *)&v15 + 1), (unint64_t *)&v33, &v34))
          {
            if (v33)
            {
              v30 = v33;
              v31 = (char *)v33 + v34;
              if ((ccder_blob_decode_tl() & 1) != 0)
              {
                if (v32 == 4 && *(_DWORD *)v14 == *v30)
                {
                  v21 = 0;
                  if (!get_oid_property_integer(6u, 2u, v35, *((uint64_t *)&v35 + 1), &v21))
                  {
                    if (v21 == 1)
                    {
                      v20 = 0;
                      if (!get_oid_property_integer(6u, 8u, v35, *((uint64_t *)&v35 + 1), &v20))
                      {
                        if (v20 == 6)
                        {
                          result = 0;
                          if (a6 && a7)
                          {
                            v17 = calloc(v29, 1uLL);
                            if (v17)
                            {
                              *a6 = v17;
                              v18 = v28;
                              v19 = v29;
                              *a7 = v29;
                              memcpy(v17, v18, v19);
                              return 0;
                            }
                            else
                            {
                              return 4294967279;
                            }
                          }
                          return result;
                        }
                        fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s error: incorrect key type%s\n", "aks", "", "", "", "aks_validate_certificate");
                      }
                    }
                    else
                    {
                      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s error: not attestion only key%s\n", "aks", "", "", "", "aks_validate_certificate");
                    }
                  }
                }
                else
                {
                  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s error: invalid namespace, expected ssca%s\n", "aks", "", "", "", "aks_validate_certificate");
                }
              }
            }
          }
        }
        return 4294967286;
      }
    }
  }
  return result;
}

uint64_t get_oid_property_integer(unsigned int a1, unsigned int a2, unint64_t a3, uint64_t a4, uint64_t *a5)
{
  _DWORD *exention_prop_by_id;
  _DWORD *v10;
  int v12;
  uint64_t result;
  unsigned __int8 *v14;
  uint64_t v15;
  unsigned int v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  char *v19;
  uint64_t v20;

  exention_prop_by_id = _get_exention_prop_by_id(a1, a2);
  v19 = 0;
  v20 = 0;
  if ((exention_prop_by_id[4] - 3) < 0xFFFFFFFE)
    return 0xFFFFFFFFLL;
  v10 = exention_prop_by_id;
  if (_get_oid_property_value(a1, *((_QWORD *)exention_prop_by_id + 1), a3, a4, (unint64_t *)&v19, &v20)|| v19 == 0)
  {
    return 0xFFFFFFFFLL;
  }
  v17 = (unsigned __int8 *)v19;
  v18 = (unsigned __int8 *)&v19[v20];
  v12 = ccder_blob_decode_tl();
  result = 0xFFFFFFFFLL;
  if (v12)
  {
    v14 = v17;
    if (v10[4] == 1)
      v15 = (uint64_t)(char)*v17 >> 7;
    else
      v15 = 0;
    while (v14 != v18)
    {
      v16 = *v14++;
      v15 = v16 | (unint64_t)(v15 << 8);
    }
    result = 0;
    *a5 = v15;
  }
  return result;
}

uint64_t aks_attest_context_dump(uint64_t a1)
{
  FILE **v2;
  uint64_t result;
  unint64_t v4;
  _OWORD v5[4];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  memset(v5, 0, sizeof(v5));
  v4 = 64;
  if (!a1 || !*(_BYTE *)a1)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s context not initialized%s\n", "aks", "", "", "", "aks_attest_context_dump", ":", 1784, "", 0, "", "");
    return 4294967285;
  }
  v2 = (FILE **)MEMORY[0x24BDAC8E8];
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s dumping attestation info:%s\n", "aks", "", "", "", "aks_attest_context_dump", ":", 1786, "", 0, "", "");
  if (*(_QWORD *)(a1 + 88))
  {
    result = _calculate_digest(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 136), (uint64_t (*)(uint64_t, char *, uint64_t))_osk_digest_update, a1, (uint64_t)v5, &v4);
    if ((_DWORD)result)
      return result;
    dump_bytes_internal("osk pub", *(_QWORD *)(a1 + 152), *(_QWORD *)(a1 + 144));
    dump_bytes_internal("request digest", (uint64_t)v5, v4);
    dump_bytes_internal("request sig", *(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 120));
    v4 = 64;
    result = _calculate_digest(*(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 136), (uint64_t (*)(uint64_t, char *, uint64_t))_blob_digest_update, a1 + 88, (uint64_t)v5, &v4);
    if ((_DWORD)result)
      return result;
    dump_bytes_internal("osk digest", (uint64_t)v5, v4);
  }
  else
  {
    fprintf(*v2, "%s%s:%s%s%s%s%u:%s%u:%s \x1B[38;5;112mno osk detected\x1B[0m%s\n",
      "aks",
      "",
      "",
      "",
      "aks_attest_context_dump",
      ":",
      1797,
      "",
      0,
      "",
      "");
  }
  dump_bytes_internal("osk sig", *(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 120));
  if (*(_QWORD *)(a1 + 432))
  {
    v4 = 64;
    dump_bytes_internal("self pub", *(_QWORD *)(a1 + 496), *(_QWORD *)(a1 + 488));
    if (*(_QWORD *)(a1 + 472))
    {
      result = _calculate_digest(*(_QWORD *)(a1 + 456), *(_QWORD *)(a1 + 480), (uint64_t (*)(uint64_t, char *, uint64_t))_blob_digest_update, a1 + 432, (uint64_t)v5, &v4);
      if ((_DWORD)result)
        return result;
      dump_bytes_internal("self digest", (uint64_t)v5, v4);
      dump_bytes_internal("self sig", *(_QWORD *)(a1 + 472), *(_QWORD *)(a1 + 464));
    }
    else
    {
      fprintf(*v2, "%s%s:%s%s%s%s%u:%s%u:%s self has no sig%s\n", "aks", "", "", "", "aks_attest_context_dump");
    }
  }
  else
  {
    fprintf(*v2, "%s%s:%s%s%s%s%u:%s%u:%s \x1B[38;5;112mno self detected\x1B[0m%s\n",
      "aks",
      "",
      "",
      "",
      "aks_attest_context_dump");
  }
  if (*(_QWORD *)(a1 + 776))
  {
    v4 = 64;
    result = _calculate_digest(*(_QWORD *)(a1 + 800), *(_QWORD *)(a1 + 824), (uint64_t (*)(uint64_t, char *, uint64_t))_blob_digest_update, a1 + 776, (uint64_t)v5, &v4);
    if ((_DWORD)result)
      return result;
    dump_bytes_internal("aa digest", (uint64_t)v5, v4);
    dump_bytes_internal("aa sig", *(_QWORD *)(a1 + 816), *(_QWORD *)(a1 + 808));
  }
  return 0;
}

uint64_t _calculate_digest(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, char *, uint64_t), uint64_t a4, uint64_t a5, unint64_t *a6)
{
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  size_t v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25[2];

  v25[1] = *MEMORY[0x24BDAC8D0];
  v24 = 0;
  v25[0] = 0;
  v12 = ccsha384_di();
  result = aks_get_digest_info(a1, v25);
  if (!(_DWORD)result)
  {
    v14 = v25[0];
    if (v14 == ccsha256_di())
    {
      v15 = 32;
    }
    else if (v14 == ccsha384_di())
    {
      v15 = 48;
    }
    else
    {
      if (v14 != ccsha512_di())
        return 4294967272;
      v15 = 64;
    }
    if (*a6 < v15)
      return 0xFFFFFFFFLL;
    v16 = v14;
    if ((ccoid_equal() & 1) == 0)
    {
      result = aks_get_pub_key_cp(a2, &v24);
      if ((_DWORD)result)
        return result;
      v17 = v24;
      v16 = v12;
      if (v17 == MEMORY[0x219A17EA0]())
        v16 = ccsha256_di();
    }
    MEMORY[0x24BDAC7A8]();
    v19 = (char *)&v23 - v18;
    bzero((char *)&v23 - v18, v20);
    ccdigest_init();
    result = a3(v16, v19, a4);
    if (!(_DWORD)result)
    {
      (*(void (**)(uint64_t, char *, uint64_t))(v16 + 56))(v16, v19, a5);
      cc_clear();
      if (v16 == ccsha256_di() && v14 != ccsha256_di())
      {
        v21 = *(_OWORD *)(a5 + 16);
        *(_OWORD *)(a5 + 16) = *(_OWORD *)a5;
        *(_OWORD *)(a5 + 32) = v21;
        *(_QWORD *)a5 = 0;
        *(_QWORD *)(a5 + 8) = 0;
      }
      if (v16 == ccsha384_di() && v14 != ccsha384_di())
      {
        v22 = *(_OWORD *)(a5 + 32);
        *(_OWORD *)a5 = *(_OWORD *)(a5 + 16);
        *(_OWORD *)(a5 + 16) = v22;
        *(_QWORD *)(a5 + 32) = 0;
        *(_QWORD *)(a5 + 40) = 0;
      }
      result = 0;
      *a6 = v15;
    }
  }
  return result;
}

uint64_t _osk_digest_update(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;

  v3 = a3[3];
  if (!v3)
    return 4294967285;
  v4 = a3[4];
  if (!v4)
    return 4294967285;
  v5 = a3[5];
  if (v4 >= v3 || v5 == 0)
    return 4294967285;
  if (v5 >= v3 || v5 <= v4)
    return 4294967285;
  ccdigest_update();
  return 0;
}

uint64_t _blob_digest_update(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t i;

  for (i = 0; i != 256; i += 16)
  {
    if (*(_QWORD *)(a3 + i + 80) && *(_QWORD *)(a3 + i + 88))
      ccdigest_update();
  }
  return 0;
}

uint64_t _parse_attest_blob(__int128 *a1, char a2)
{
  uint64_t v4;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;

  v7 = 0;
  v8 = 0;
  v6 = *a1;
  if (ccder_blob_decode_uint64()
    && ccder_blob_decode_range()
    && ccder_blob_decode_oid())
  {
    if (ccoid_equal())
    {
      if ((a2 & 1) != 0)
        return 0xFFFFFFFFLL;
    }
    else
    {
      if (!ccder_blob_decode_range() || v8 - v7 < 1)
        return 0xFFFFFFFFLL;
      v4 = v7 + 1;
      *((_QWORD *)a1 + 4) = v8 - (v7 + 1);
      *((_QWORD *)a1 + 5) = v4;
    }
    if (ccder_blob_decode_range()
      && ccder_blob_decode_range()
      && ccder_blob_decode_oid()
      && ccder_blob_decode_range()
      && ccder_blob_decode_oid())
    {
      ccder_blob_decode_range();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t _parse_digest_value(_QWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v7;

  if (digest_pos_table[4 * a3] != a3)
    abort();
  v4 = a3;
  if ((digest_pos_table[4 * a3 + 1] & *(_DWORD *)(a2 + 72)) == 0)
    return 1;
  result = ccder_blob_decode_range();
  if ((_DWORD)result)
  {
    result = ccder_blob_decode_tl();
    if ((_DWORD)result)
    {
      v7 = a2 + 16 * v4;
      *(_QWORD *)(v7 + 80) = 0;
      *(_QWORD *)(v7 + 88) = 0;
      return !*a1;
    }
  }
  return result;
}

uint64_t _get_param_data(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v4 = *(_QWORD *)(a1 + 72);
  v5 = *(_QWORD *)(a1 + 80);
  v12 = v4;
  v13 = v5;
  if (v4)
    v6 = v4 == v5;
  else
    v6 = 1;
  if (!v6)
  {
    while (1)
    {
      if (v4 > v5)
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s incorrect attestation data%s\n", "aks", "", "", "", "_get_param_data", ":", 758, "", 0, "", "");
        return 4294967272;
      }
      if (!ccder_blob_decode_tag() || !ccder_blob_decode_len())
        return 0xFFFFFFFFLL;
      if (!*(_QWORD *)(a2 + 8))
        break;
      v4 = v12;
      result = 4294967293;
      if (v12)
      {
        v5 = v13;
        if (v12 != v13)
          continue;
      }
      return result;
    }
    v11 = v12;
    if (ccder_blob_decode_tl())
      v11 = v12;
    if (v11)
    {
      result = 0;
      *a3 = v11;
      *a4 = 0;
      return result;
    }
  }
  return 4294967293;
}

uint64_t _verify_ec_attest_blob(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  unint64_t v6;
  _OWORD v7[3];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  memset(v7, 0, sizeof(v7));
  v6 = 48;
  v3 = a2[6];
  if ((ccoid_equal() & 1) == 0 && !ccoid_equal())
    return 4294967272;
  v4 = a2[3];
  if ((ccoid_equal() & 1) == 0 && !ccoid_equal())
    return 4294967272;
  if (!*a2 || !a2[5] || !a2[4])
    return 4294967272;
  result = _calculate_digest(v4, v3, (uint64_t (*)(uint64_t, char *, uint64_t))_blob_digest_update, (uint64_t)a2, (uint64_t)v7, &v6);
  if (!(_DWORD)result)
  {
    ccec_verify();
    return 0xFFFFFFFFLL;
  }
  return result;
}

_DWORD *_get_exention_prop_by_id(unsigned int a1, unsigned int a2)
{
  _DWORD *result;

  if (*((_DWORD *)&cert_oids_table + 12 * a1) != a1
    || *((_QWORD *)&cert_oids_table + 6 * a1 + 4) <= (unint64_t)a2
    || (result = (_DWORD *)(*((_QWORD *)&cert_oids_table + 6 * a1 + 3) + 32 * a2), *result != a2))
  {
    abort();
  }
  return result;
}

uint64_t _get_oid_property_value(unsigned int a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t *a5, _QWORD *a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;

  if (*((_DWORD *)&cert_oids_table + 12 * a1) != a1)
    abort();
  v11 = *((_QWORD *)&cert_oids_table + 6 * a1 + 1);
  v12 = MEMORY[0x219A17E1C](v11);
  v16 = 0;
  v17 = 0;
  if (CTParseExtensionValue(a3, a4, (const void *)(v11 + 2), v12 - 2, &v16, &v17))
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s extension error %s%s\n", "aks", "", "", "", "_get_oid_property_value", ":", 1619, "", 0, "", "", "");
  }
  else
  {
    v14 = v16;
    v15 = v16 + v17;
    if (ccder_blob_decode_range() && v14 < v15)
    {
      while (ccder_blob_decode_tag() && ccder_blob_decode_len())
      {
        if (!a2)
        {
          if (!v14)
            return 0xFFFFFFFFLL;
          result = 0;
          *a5 = v14;
          *a6 = 0;
          return result;
        }
        if (v14 >= v15)
          return 0xFFFFFFFFLL;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t _data_protection_enabled(const char *a1)
{
  statfs v3;
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  bzero(&v3, 0x878uLL);
  if (!statfs(a1, &v3) && (v3.f_flags & 0x80) != 0)
    return 1;
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "mount point (%s) does not support Data Protection", a1);
  return 0;
}

uint64_t aks_migrate_user_fs(const char *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  int v7;
  char v8[1024];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  bzero(v8, 0x400uLL);
  v4 = 0xFFFFFFFFLL;
  v7 = -1;
  if (realpath_DARWIN_EXTSN(a1, v8))
  {
    if (aks_migrate_fs_required(v8, a2, ".aks_migrate", &v7)
      && ((v5 = aks_migrate_fs_with_map(v8, a2, (uint64_t)&userPathMap, 72), (_DWORD)v5)
       || (v5 = _aks_version_commit(v7, 49), (_DWORD)v5)))
    {
      return v5;
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t aks_migrate_fs_required(const char *a1, char a2, const char *a3, int *a4)
{
  uint64_t result;
  int v9;
  int v10;
  char __str[1024];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  bzero(__str, 0x400uLL);
  if ((a2 & 2) != 0 || (result = _data_protection_enabled(a1), (_DWORD)result))
  {
    snprintf(__str, 0x400uLL, "%s/%s", a1, a3);
    v9 = open_dprotected_np(__str, 514, 4, 0, 420);
    if (v9 != -1)
    {
      v10 = v9;
      if ((a2 & 2) != 0 || !_aks_version_check(v9, 0x31u))
      {
        *a4 = v10;
        return 1;
      }
      close(v10);
    }
    return 0;
  }
  return result;
}

uint64_t aks_migrate_fs_with_map(char *a1, int a2, uint64_t a3, uint64_t a4)
{
  char v6;
  int v8;
  _QWORD v10[4];
  int v11;
  _QWORD v12[7];
  int v13;

  if (!a1)
    return 22;
  v6 = a2;
  v8 = a2 | 1;
  v12[0] = MEMORY[0x24BDAC760];
  v12[1] = 0x40000000;
  v12[2] = ___migrate_user_partition_block_invoke;
  v12[3] = &__block_descriptor_tmp_22;
  v12[4] = strlen(a1);
  v12[5] = a4;
  v12[6] = a3;
  v13 = v8;
  v10[0] = MEMORY[0x24BDAC760];
  v10[1] = 0x40000000;
  v10[2] = ___migrate_user_partition_block_invoke_2;
  v10[3] = &__block_descriptor_tmp_23;
  v11 = v8;
  _iterate_path(a1, (uint64_t)v12, (uint64_t)v10);
  if ((v6 & 1) != 0)
    fwrite("Skipping migration of Applications\n", 0x23uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8E8]);
  return 0;
}

uint64_t aks_migrate_fs(const char *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  int v7;
  char __str[1024];
  char v9[1024];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  bzero(v9, 0x400uLL);
  bzero(__str, 0x400uLL);
  v4 = 0xFFFFFFFFLL;
  v7 = -1;
  if (realpath_DARWIN_EXTSN(a1, v9))
  {
    snprintf(__str, 0x400uLL, "%s/mobile", v9);
    if (aks_migrate_fs_required(v9, a2, "root/.aks_migrate", &v7)
      && ((v5 = aks_migrate_fs_with_map(v9, a2, (uint64_t)&sharedPathMap, 35), (_DWORD)v5)
       || (aks_fs_supports_enhanced_apfs() & 1) == 0
       && (v5 = aks_migrate_fs_with_map(__str, a2, (uint64_t)&userPathMap, 72), (_DWORD)v5)
       || (v5 = _aks_version_commit(v7, 49), (_DWORD)v5)))
    {
      return v5;
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t aks_bootstrap_shared_fs(const char *a1, char a2)
{
  uint64_t result;
  char v5[1024];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 22;
  bzero(v5, 0x400uLL);
  if (!realpath_DARWIN_EXTSN(a1, v5))
    return 0xFFFFFFFFLL;
  result = aks_bootstrap_fs_required(v5, "root/.bootstrapped", a2);
  if (!(_DWORD)result)
    return result;
  if (aks_bootstrap_fs_with_map((uint64_t)v5))
    return 0xFFFFFFFFLL;
  aks_bootstrap_fs_done(v5, "root/.bootstrapped");
  return 0;
}

uint64_t aks_bootstrap_fs_required(const char *a1, const char *a2, char a3)
{
  uint64_t result;
  int v7;
  char __str[1024];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  result = _data_protection_enabled(a1);
  if ((_DWORD)result)
  {
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "%s/%s", a1, a2);
    if ((a3 & 1) != 0)
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "checking path: %s\n", __str);
    v7 = access(__str, 4) | a3 & 2;
    result = v7 != 0;
    if ((a3 & 1) != 0 && !v7)
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s has already been bootstrapped\n", a1);
      return 0;
    }
  }
  return result;
}

uint64_t aks_bootstrap_fs_with_map(uint64_t a1)
{
  uint64_t v1;
  char v2;
  gid_t v3;
  uid_t v4;
  uid_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  unsigned __int16 *v12;
  FILE **v13;
  FILE *v14;
  int *v15;
  unsigned int v16;
  FILE *v17;
  int *v18;
  char *v19;
  const char *v20;
  uid_t pw_uid;
  const char *v22;
  gid_t v23;
  FILE *v24;
  int *v25;
  char *v26;
  FILE *v27;
  int *v28;
  int *v29;
  FILE *v30;
  int *v31;
  char v33;
  gid_t v34;
  stat v35;
  passwd v36;
  passwd *v37;
  char __str[1024];
  char v39[4096];
  uint64_t v40;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v33 = v2;
  v34 = v3;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = (const char *)v1;
  v40 = *MEMORY[0x24BDAC8D0];
  bzero(__str, 0x400uLL);
  v11 = 0;
  if (v7)
  {
    v12 = (unsigned __int16 *)(v9 + 20);
    v13 = (FILE **)MEMORY[0x24BDAC8D8];
    do
    {
      if ((*(_BYTE *)(v12 - 2) & 8) == 0)
      {
        memset(&v35, 0, sizeof(v35));
        snprintf(__str, 0x400uLL, "%s%s", v10, *(const char **)(v12 - 10));
        if (!stat(__str, &v35))
          goto LABEL_19;
        if (mkpath_np(__str, *v12))
        {
          v14 = *v13;
          v15 = __error();
          strerror(*v15);
          fprintf(v14, "failed to create: %s (%s)\n");
        }
        else
        {
          v16 = *v12;
          if (v16 >= 0x200 && chmod(__str, v16))
          {
            v17 = *v13;
            v18 = __error();
            v19 = strerror(*v18);
            fprintf(v17, "failed to change permissions on: %s (%s)\n", __str, v19);
          }
          v20 = *(const char **)(v12 + 2);
          pw_uid = v5;
          if (v20)
          {
            bzero(v39, 0x1000uLL);
            v37 = 0;
            memset(&v36, 0, sizeof(v36));
            if (getpwnam_r(v20, &v36, v39, 0x1000uLL, &v37))
            {
              pw_uid = v5;
              if (*__error())
              {
                v27 = *v13;
                v28 = __error();
                strerror(*v28);
                fprintf(v27, "failed to get uid for user '%s'(%s)\n");
                goto LABEL_25;
              }
            }
            else
            {
              pw_uid = v37->pw_uid;
            }
          }
          v22 = *(const char **)(v12 + 6);
          v23 = v34;
          if (!v22)
            goto LABEL_16;
          bzero(v39, 0x1000uLL);
          memset(&v36, 0, 32);
          v37 = 0;
          if (!getgrnam_r(v22, (group *)&v36, v39, 0x1000uLL, (group **)&v37))
          {
            v23 = v37->pw_uid;
LABEL_16:
            if (chown(__str, pw_uid, v23))
            {
              v24 = *v13;
              v25 = __error();
              v26 = strerror(*v25);
              fprintf(v24, "failed to change ownership on: %s (%s)\n", __str, v26);
            }
            stat(__str, &v35);
LABEL_19:
            if ((v35.st_mode & 0xF000) == 0x4000)
            {
              if ((*(_BYTE *)(v12 - 2) & 1) != 0)
              {
                if (_set_path_class(__str, -1, *((_DWORD *)v12 + 5), v33))
                  v11 = 0xFFFFFFFFLL;
                else
                  v11 = v11;
              }
            }
            else
            {
              fprintf(*v13, "failed %s is not a directory\n");
            }
            goto LABEL_25;
          }
          v29 = __error();
          v23 = v34;
          if (!*v29)
            goto LABEL_16;
          v30 = *v13;
          v31 = __error();
          strerror(*v31);
          fprintf(v30, "failed to get gid for group '%s' (%s)\n");
        }
      }
LABEL_25:
      v12 += 24;
      --v7;
    }
    while (v7);
  }
  return v11;
}

uint64_t aks_bootstrap_fs_done(const char *a1, const char *a2)
{
  int v4;
  FILE *v6;
  int *v7;
  char *v8;
  char __str[1024];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s/%s", a1, a2);
  v4 = open(__str, 513, 420);
  if (v4 != -1)
    return close(v4);
  v6 = (FILE *)*MEMORY[0x24BDAC8D8];
  v7 = __error();
  v8 = strerror(*v7);
  return fprintf(v6, "Could not create marker file: %s (%s)\n", __str, v8);
}

uint64_t aks_bootstrap_user_fs(const char *a1, char a2)
{
  uint64_t result;
  char v5[1024];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 22;
  bzero(v5, 0x400uLL);
  if (!realpath_DARWIN_EXTSN(a1, v5))
    return 0xFFFFFFFFLL;
  result = aks_bootstrap_fs_required(v5, ".bootstrapped", a2);
  if (!(_DWORD)result)
    return result;
  if (aks_bootstrap_fs_with_map((uint64_t)v5))
    return 0xFFFFFFFFLL;
  aks_bootstrap_fs_done(v5, ".bootstrapped");
  return 0;
}

uint64_t aks_bootstrap_fs(const char *a1, char a2)
{
  uint64_t result;
  char __str[1024];
  char v6[1024];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 22;
  bzero(v6, 0x400uLL);
  if (!realpath_DARWIN_EXTSN(a1, v6))
    return 0xFFFFFFFFLL;
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s/mobile", v6);
  result = aks_bootstrap_fs_required(v6, "root/.bootstrapped", a2);
  if (!(_DWORD)result)
    return result;
  if (aks_bootstrap_fs_with_map((uint64_t)v6)
    || (aks_fs_supports_enhanced_apfs() & 1) == 0 && aks_bootstrap_fs_with_map((uint64_t)__str))
  {
    return 0xFFFFFFFFLL;
  }
  aks_bootstrap_fs_done(v6, "root/.bootstrapped");
  return 0;
}

uint64_t aks_setupallowlist_user_fs(const char *a1, int a2)
{
  FILE *v4;
  FILE *v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;
  FILE *v9;
  uint64_t v10;
  uint64_t v11;
  int v13;

  v13 = -1;
  v4 = fopen("/var/logs/AKSSetup.log", "w+");
  v5 = v4;
  v6 = (uint64_t *)MEMORY[0x24BDAC8E8];
  v7 = *MEMORY[0x24BDAC8E8];
  if (v4)
    v7 = (uint64_t)v4;
  __logfd = v7;
  aks_bootstrap_user_fs(a1, a2 | 3);
  if (aks_setupallowlist_fs_required(a1, a2, ".aks_allowlist", &v13))
  {
    aks_setupallowlist_fs_with_map(a1, a2, (uint64_t)&userPathMap, 72);
    v8 = v13;
    v9 = (FILE *)(__logfd ? __logfd : *v6);
    fprintf(v9, "%s has been allow listed with version:%c\n", a1, 52);
    v10 = _aks_version_commit(v8, 52);
    if ((_DWORD)v10)
    {
      v11 = v10;
      if (!v5)
        goto LABEL_10;
      goto LABEL_9;
    }
  }
  v11 = 0;
  if (v5)
LABEL_9:
    fclose(v5);
LABEL_10:
  __logfd = *v6;
  return v11;
}

uint64_t aks_setupallowlist_fs_required(const char *a1, char a2, const char *a3, int *a4)
{
  int v8;
  int v9;
  FILE *v10;
  char __str[1024];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s/%s", a1, a3);
  v8 = open_dprotected_np(__str, 514, 4, 0, 420);
  if (v8 == -1)
    return 0;
  v9 = v8;
  if ((a2 & 2) == 0)
  {
    if (!_aks_version_check(v8, 0x34u))
    {
      if (__logfd)
        v10 = (FILE *)__logfd;
      else
        v10 = (FILE *)*MEMORY[0x24BDAC8E8];
      fprintf(v10, "%s has different allowlist needed=%c\n", a1, 52);
      goto LABEL_8;
    }
    close(v9);
    return 0;
  }
LABEL_8:
  *a4 = v9;
  return 1;
}

void aks_setupallowlist_fs_with_map(const char *a1, int a2, uint64_t a3, uint64_t a4)
{
  _DWORD *v8;
  FILE **v9;
  FILE *v10;
  _QWORD v11[4];
  int v12;
  char __str[1025];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  bzero(__str, 0x401uLL);
  if (a4)
  {
    v8 = (_DWORD *)(a3 + 16);
    v9 = (FILE **)MEMORY[0x24BDAC8E8];
    while (1)
    {
      snprintf(__str, 0x401uLL, "%s%s", a1, *((const char **)v8 - 2));
      if ((*v8 & 2) != 0)
        break;
      if (__logfd)
        v10 = (FILE *)__logfd;
      else
        v10 = *v9;
      if ((*v8 & 4) == 0)
        goto LABEL_12;
      fprintf(v10, "Traversing hierarchy: %s\n", __str);
      v11[0] = MEMORY[0x24BDAC760];
      v11[1] = 0x40000000;
      v11[2] = __setup_allowlist_dirpath_block_invoke;
      v11[3] = &__block_descriptor_tmp_36;
      v12 = a2 | 3;
      _iterate_path(__str, (uint64_t)v11, 0);
LABEL_13:
      v8 += 12;
      if (!--a4)
        return;
    }
    if (__logfd)
      v10 = (FILE *)__logfd;
    else
      v10 = *v9;
LABEL_12:
    fprintf(v10, "SKIPPED: %s\n", __str);
    goto LABEL_13;
  }
}

uint64_t aks_setupallowlist_fs(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  const char *v4;
  FILE *v5;
  FILE *v6;
  uint64_t *v7;
  uint64_t v8;
  std::error_code *v9;
  int v10;
  FILE *v11;
  uint64_t v12;
  uint64_t v13;
  int v15;
  char __str[1024];
  char v17[1024];
  std::__fs::filesystem::path __from;
  std::__fs::filesystem::path __to;
  uint64_t v20;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v4 = (const char *)v1;
  v20 = *MEMORY[0x24BDAC8D0];
  v15 = -1;
  bzero(&__to, 0x400uLL);
  bzero(&__from, 0x400uLL);
  bzero(v17, 0x400uLL);
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s/mobile", v4);
  snprintf(v17, 0x400uLL, "%s/tmp", v4);
  if (_set_path_class(v17, -1, 4, 0))
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Unable to set %s to class D!", v17);
  v5 = fopen("/var/logs/AKSSetup.log", "w+");
  v6 = v5;
  v7 = (uint64_t *)MEMORY[0x24BDAC8E8];
  v8 = *MEMORY[0x24BDAC8E8];
  if (v5)
    v8 = (uint64_t)v5;
  __logfd = v8;
  aks_bootstrap_fs(v4, v3 | 3);
  snprintf((char *)&__from, 0x400uLL, "%s/root/.aks_whitelist", v4);
  snprintf((char *)&__to, 0x400uLL, "%s/root/.aks_allowlist", v4);
  rename(&__from, &__to, v9);
  if (aks_setupallowlist_fs_required(v4, v3, "root/.aks_allowlist", &v15))
  {
    aks_setupallowlist_fs_with_map(v4, v3, (uint64_t)&sharedPathMap, 35);
    if ((aks_fs_supports_enhanced_apfs() & 1) == 0)
      aks_setupallowlist_fs_with_map(__str, v3, (uint64_t)&userPathMap, 72);
    v10 = v15;
    v11 = (FILE *)(__logfd ? __logfd : *v7);
    fprintf(v11, "%s has been allow listed with version:%c\n", v4, 52);
    v12 = _aks_version_commit(v10, 52);
    if ((_DWORD)v12)
    {
      v13 = v12;
      if (!v6)
        goto LABEL_14;
      goto LABEL_13;
    }
  }
  v13 = 0;
  if (v6)
LABEL_13:
    fclose(v6);
LABEL_14:
  __logfd = *v7;
  return v13;
}

uint64_t _set_path_class(const char *a1, int a2, int a3, char a4)
{
  int *v8;
  uint64_t v9;
  FILE *v10;
  char *v11;
  int v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;

  v16 = 0;
  v15 = xmmword_217E32958;
  v14 = 0;
  if (getattrlist(a1, &v15, &v14, 8uLL, 0))
    return *__error();
  if (HIDWORD(v14) == a3 || a2 != -1 && HIDWORD(v14) != a2)
    return 0;
  if (a2 == -1)
  {
    if ((a4 & 1) != 0)
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s set %i\n");
  }
  else if ((a4 & 1) != 0)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s update %i -> %i\n");
  }
  v13 = a3;
  if (!setattrlist(a1, &v15, &v13, 4uLL, 0))
    return 0;
  v8 = __error();
  v9 = *v8;
  v10 = (FILE *)*MEMORY[0x24BDAC8D8];
  v11 = strerror(*v8);
  fprintf(v10, "failed (%s) to update class for %s\n", v11, a1);
  return v9;
}

uint64_t aks_migrate_path(const char *a1, int a2, int a3, int a4)
{
  int v8;
  _QWORD v10[4];
  int v11;
  int v12;
  int v13;
  _QWORD v14[4];
  int v15;
  int v16;
  int v17;
  char v18[1024];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 0xFFFFFFFFLL;
  bzero(v18, 0x400uLL);
  if (!realpath_DARWIN_EXTSN(a1, v18))
    return 0xFFFFFFFFLL;
  v8 = a2 | 0x18;
  v14[0] = MEMORY[0x24BDAC760];
  if ((a2 & 0x1C) != 0)
    v8 = a2;
  v14[1] = 0x40000000;
  v14[2] = __aks_migrate_path_block_invoke;
  v14[3] = &__block_descriptor_tmp_1;
  v15 = v8;
  v16 = a3;
  v17 = a4;
  v10[0] = MEMORY[0x24BDAC760];
  v10[1] = 0x40000000;
  v10[2] = __aks_migrate_path_block_invoke_2;
  v10[3] = &__block_descriptor_tmp_16;
  v11 = a3;
  v12 = v8;
  v13 = a4;
  _iterate_path(v18, (uint64_t)v14, (uint64_t)v10);
  return 0;
}

uint64_t __aks_migrate_path_block_invoke(_DWORD *a1, uint64_t a2)
{
  int v2;
  const char *v3;
  int v4;
  int v5;
  const char *v6;

  v2 = a1[8];
  if ((v2 & 4) != 0)
  {
    v6 = *(const char **)(a2 + 48);
    v4 = a1[9];
    v5 = a1[10];
    v3 = v6;
    goto LABEL_5;
  }
  if ((v2 & 8) != 0)
  {
    v3 = *(const char **)(a2 + 48);
    v4 = -1;
    v5 = 0;
LABEL_5:
    _set_path_class(v3, v4, v5, v2);
  }
  return 1;
}

_DWORD *__aks_migrate_path_block_invoke_2(_DWORD *result, uint64_t a2)
{
  int v3;
  int v4;
  int v5;

  v3 = result[8];
  if (v3)
  {
    v4 = result[9];
    if ((v4 & 0x10) != 0)
    {
      if (result[10])
        v5 = result[10];
      else
        v5 = 3;
      return (_DWORD *)_set_path_class(*(const char **)(a2 + 48), v3, v5, v4);
    }
  }
  return result;
}

BOOL _aks_version_check(int a1, unsigned __int8 a2)
{
  int v3;
  FILE *v5;
  int *v6;
  char *v7;
  unsigned __int8 v8;

  v8 = a2;
  v3 = read(a1, &v8, 1uLL);
  if (v3 == 1)
    return (char)v8 == a2;
  if (v3 == -1)
  {
    v5 = (FILE *)*MEMORY[0x24BDAC8D8];
    v6 = __error();
    v7 = strerror(*v6);
    fprintf(v5, "failed to read version file (%s)\n", v7);
  }
  return 0;
}

BOOL ___migrate_user_partition_block_invoke(uint64_t a1, uint64_t a2)
{
  const char *v3;
  const char *v4;
  size_t v5;
  unint64_t v6;
  BOOL v7;
  uint64_t v8;
  size_t v9;
  _DWORD *v10;

  v3 = *(const char **)(a2 + 48);
  v4 = &v3[*(_QWORD *)(a1 + 32)];
  v5 = strlen(v4);
  v6 = *(_QWORD *)(a1 + 40);
  if (!v6)
  {
LABEL_8:
    _set_path_class(v3, 4, 0, *(_DWORD *)(a1 + 56));
    return 1;
  }
  v7 = 0;
  v8 = 0;
  v9 = v5 + 1;
  v10 = (_DWORD *)(*(_QWORD *)(a1 + 48) + 16);
  while (1)
  {
    if (v9 != *((_QWORD *)v10 - 1) || strncasecmp(v4, *((const char **)v10 - 2), v9))
      goto LABEL_7;
    if ((*v10 & 1) != 0)
      break;
    if ((*v10 & 2) != 0)
    {
      if ((*(_BYTE *)(a1 + 56) & 1) != 0)
        fprintf((FILE *)*MEMORY[0x24BDAC8E8], "SKIPPED: %s\n");
      return v7;
    }
LABEL_7:
    v7 = ++v8 >= v6;
    v10 += 12;
    if (v6 == v8)
      goto LABEL_8;
  }
  if ((*(_BYTE *)(a1 + 56) & 1) != 0)
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "ALLOW LISTED: %s\n");
  return v7;
}

uint64_t ___migrate_user_partition_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return _set_path_class(*(const char **)(a2 + 48), 4, 3, *(_DWORD *)(a1 + 32));
}

uint64_t _aks_version_commit(int a1, char a2)
{
  int *v2;
  uint64_t v3;
  FILE *v4;
  char *v5;
  char __buf;

  __buf = a2;
  if (pwrite(a1, &__buf, 1uLL, 0) != -1)
    return 0;
  v2 = __error();
  v3 = *v2;
  v4 = (FILE *)*MEMORY[0x24BDAC8D8];
  v5 = strerror(*v2);
  fprintf(v4, "failed to read version file (%s)\n", v5);
  return v3;
}

uint64_t __setup_allowlist_dirpath_block_invoke(uint64_t a1, uint64_t a2)
{
  _set_path_class(*(const char **)(a2 + 48), -1, 4, *(_DWORD *)(a1 + 32));
  return 1;
}

uint64_t aks_stash_create_for_bag_and_kek(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  mach_port_t aks_client_connection;
  mach_port_t v15;
  __int128 v17;
  uint64_t input[7];
  _BYTE v19[4096];
  uint64_t v20;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = v1;
  v20 = *MEMORY[0x24BDAC8D0];
  v13 = 3758097098;
  bzero(v19, 0x1000uLL);
  *(_QWORD *)&v17 = v19;
  *((_QWORD *)&v17 + 1) = &v20;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v15 = aks_client_connection;
    if (der_utils_encode_fv_data(&v17, v3) && ccder_blob_encode_tl())
    {
      input[0] = v12;
      input[1] = v11;
      input[2] = v7;
      input[3] = v5;
      input[4] = v9;
      input[5] = *((_QWORD *)&v17 + 1);
      input[6] = (uint64_t)&v20 - *((_QWORD *)&v17 + 1);
      return IOConnectCallMethod(v15, 0x21u, input, 7u, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_stash_create_for_bag_and_kek", ":", 50, "", 0, "", "");
    return 3758097084;
  }
  return v13;
}

uint64_t aks_stash_create(uint64_t a1)
{
  return aks_stash_create_for_bag_and_kek(a1);
}

uint64_t aks_stash_load(int a1)
{
  return _aks_stash_load(a1, 0, 0);
}

uint64_t _aks_stash_load(int a1, unsigned int a2, BOOL *a3)
{
  mach_port_t aks_client_connection;
  uint64_t result;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a2;
    output = 0;
    outputCnt = 1;
    result = IOConnectCallMethod(aks_client_connection, 0x22u, input, 2u, 0, 0, &output, &outputCnt, 0, 0);
    if (!(_DWORD)result)
    {
      result = 0;
      if (a3)
        *a3 = output != 0;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_aks_stash_load", ":", 77, "", 0, "", "");
    return 3758097084;
  }
  return result;
}

uint64_t aks_stash_verify(int a1, _BYTE *a2)
{
  uint64_t result;
  BOOL v4;

  v4 = 0;
  if (!a2)
    return _aks_stash_load(a1, 1u, &v4);
  *a2 = 0;
  result = _aks_stash_load(a1, 1u, &v4);
  if (!(_DWORD)result)
    *a2 = v4;
  return result;
}

uint64_t aks_stash_destroy()
{
  mach_port_t aks_client_connection;

  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x25u, 0, 0, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_stash_destroy", ":", 125, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_stash_commit(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x24u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_stash_commit", ":", 138, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_stash_enable(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x33u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_stash_enable", ":", 154, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_stash_persist(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x35u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_stash_persist", ":", 170, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_prederived_free(void **a1)
{
  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 != 1634431856)
    return 0xFFFFFFFFLL;
  free(a1[1]);
  free(a1);
  return 0;
}

uint64_t aks_prederived_create(int a1, uint64_t a2, unint64_t a3, int a4, void ***a5)
{
  void *v9;
  void *v10;
  int v11;
  uint64_t v12;
  void **v14;

  v14 = 0;
  if (!a2 && a3)
    return 0xFFFFFFFFLL;
  if (_aks_prederived_create_ctx(a4, &v14) || (v9 = calloc(0x20uLL, 1uLL)) == 0)
  {
    v12 = 0xFFFFFFFFLL;
  }
  else
  {
    v10 = v9;
    v11 = _aks_prederive_passcode(v14, a2, a3, (uint64_t)v9);
    v12 = 0xFFFFFFFFLL;
    if (a3 <= 0x7FFFFFFE
      && !v11
      && !_set_prederived_configuration(a1, a2, a3, (uint64_t)v10, (uint64_t)v14))
    {
      v12 = 0;
      if (a5)
      {
        *a5 = v14;
        v14 = 0;
      }
    }
    memset_s(v10, 0x20uLL, 0, 0x20uLL);
    free(v10);
  }
  if (v14)
    aks_prederived_free(v14);
  return v12;
}

uint64_t _aks_prederived_create_ctx(int a1, _QWORD *a2)
{
  uint64_t result;
  _DWORD *v6;
  _DWORD *v7;
  void *v8;
  int v9;
  void *v10;

  if ((a1 - 1) > 2 || a2 == 0)
    return 0xFFFFFFFFLL;
  v6 = calloc(0x20uLL, 1uLL);
  if (!v6)
    return 0xFFFFFFFFLL;
  v7 = v6;
  *((_QWORD *)v6 + 2) = 20;
  v8 = calloc(0x14uLL, 1uLL);
  *((_QWORD *)v7 + 1) = v8;
  if (!v8)
  {
LABEL_19:
    free(v7);
    return 0xFFFFFFFFLL;
  }
  *v7 = 1634431856;
  v7[6] = a1;
  result = CCRandomCopyBytes();
  if ((_DWORD)result)
  {
    v10 = (void *)*((_QWORD *)v7 + 1);
    if (v10)
      free(v10);
    goto LABEL_19;
  }
  if (a1 == 3)
    v9 = 2000;
  else
    v9 = 10000000;
  if (a1 == 2)
    v9 = 1000;
  v7[1] = v9;
  *a2 = v7;
  return result;
}

uint64_t _aks_prederive_passcode(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (*a1 != 1634431856 || !a2 && a3)
    return 0xFFFFFFFFLL;
  result = 0xFFFFFFFFLL;
  if (a4 && (a1[6] - 4) >= 0xFFFFFFFD)
  {
    ccsha256_di();
    if (ccpbkdf2_hmac())
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  return result;
}

uint64_t _set_prederived_configuration(int a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  mach_port_t aks_client_connection;
  mach_port_t v12;
  void *v14;
  rsize_t __n;
  void *__s;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  __n = 0;
  __s = 0;
  v10 = 3758097090;
  v14 = 0;
  if ((a2 || !a3) && a4 && a5)
  {
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      v12 = aks_client_connection;
      if (!encode_list_add_data(&v14, (uint64_t)der_key_config_prederived_salt, *(_QWORD *)(a5 + 8))
        && !encode_list_add_data(&v14, (uint64_t)der_key_config_prederived_passcode, a4)
        && !encode_list_add_number(&v14, (uint64_t)der_key_config_prederived_iterations, *(unsigned int *)(a5 + 4))&& !encode_list_add_number(&v14, (uint64_t)der_key_config_prederived_type, *(unsigned int *)(a5 + 24))&& (a3 < 1 || !encode_list_add_data(&v14, (uint64_t)der_key_passcode, a2))&& !encode_list_is_empty(&v14)&& !encode_list_dict(&v14, &__s, &__n))
      {
        input[0] = a1;
        input[1] = (uint64_t)__s;
        input[2] = __n;
        v10 = IOConnectCallMethod(v12, 0x1Eu, input, 3u, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_set_prederived_configuration", ":", 218, "", 0, "", "");
      v10 = 3758097084;
    }
  }
  encode_list_free(&v14);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v10;
}

uint64_t aks_prederived_is_enabled(uint64_t a1)
{
  int v1;
  uint64_t *v2;
  uint64_t *v3;
  int v4;
  uint64_t result;
  uint64_t v6;
  mach_port_t aks_client_connection;
  mach_port_t v8;
  CFMutableDictionaryRef Mutable;
  uint64_t v10;
  const void *v11;
  void *v12;
  int v13;
  size_t v14[2];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  void *v20;
  __int128 v21;
  __int128 v22;
  uint64_t input;
  _BYTE outputStruct[32768];
  uint64_t v25;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v25 = *MEMORY[0x24BDAC8D0];
  if (!v2)
    return 0;
  v3 = v2;
  v4 = v1;
  result = (uint64_t)calloc(0x20uLL, 1uLL);
  if (!result)
    return result;
  v6 = result;
  *(_DWORD *)result = 1634431856;
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_get_prederived_configuration", ":", 384, "", 0, "", "");
LABEL_16:
    aks_prederived_free((void **)v6);
    return 0;
  }
  v8 = aks_client_connection;
  bzero(outputStruct, 0x8000uLL);
  v14[0] = 0x8000;
  input = v4;
  if (IOConnectCallMethod(v8, 0x1Fu, &input, 1u, 0, 0, 0, 0, outputStruct, v14) || v14[0] > 0x8000)
    goto LABEL_16;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v16 = 0u;
  v18 = 0u;
  v19 = 0;
  v15 = 0u;
  v21 = 0u;
  v22 = 0u;
  v14[1] = (size_t)der_key_config_prederived_salt;
  v17 = (unint64_t)der_key_config_prederived_iterations;
  v20 = der_key_config_prederived_type;
  der_dict_iterate();
  v10 = ccder_decode_tl();
  if (v10)
  {
    v11 = (const void *)v10;
    v12 = calloc(*(_QWORD *)(v6 + 16), 1uLL);
    *(_QWORD *)(v6 + 8) = v12;
    if (!v12)
    {
      v13 = 0;
      if (!Mutable)
        goto LABEL_11;
      goto LABEL_10;
    }
    memcpy(v12, v11, *(_QWORD *)(v6 + 16));
    *(_DWORD *)(v6 + 4) = der_get_number();
    *(_DWORD *)(v6 + 24) = der_get_number();
  }
  v13 = 1;
  if (Mutable)
LABEL_10:
    CFRelease(Mutable);
LABEL_11:
  if (!v13 || !*(_QWORD *)(v6 + 16))
    goto LABEL_16;
  *v3 = v6;
  return 1;
}

uint64_t aks_prederived_unlock_keybag(int a1, uint64_t a2, int a3, _DWORD *a4)
{
  BOOL v4;
  BOOL v5;
  uint64_t v7;
  _OWORD v9[2];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  memset(v9, 0, sizeof(v9));
  if (a3)
    v4 = a2 == 0;
  else
    v4 = 0;
  v5 = v4 || a4 == 0;
  if (v5 || *a4 != 1634431856 || _aks_prederive_passcode(a4, a2, a3, (uint64_t)v9))
    v7 = 0xFFFFFFFFLL;
  else
    v7 = aks_unlock_bag(a1, (uint64_t)v9, 32);
  memset_s(v9, 0x20uLL, 0, 0x20uLL);
  return v7;
}

uint64_t aks_unlock_bag(int a1, uint64_t a2, int a3)
{
  mach_port_t aks_client_connection;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a2;
    input[2] = a3;
    return IOConnectCallMethod(aks_client_connection, 0xCu, input, 3u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unlock_bag", ":", 807, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_prederived_change_secret(int a1, uint64_t a2, int a3, uint64_t a4, int a5, void ***a6)
{
  void **v7;
  int v11;
  void **v12;
  int v13;
  uint64_t v14;
  void **v16;
  _OWORD v17[2];
  _OWORD __s[2];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  memset(__s, 0, sizeof(__s));
  memset(v17, 0, sizeof(v17));
  v16 = 0;
  if (!a6)
    goto LABEL_17;
  v7 = *a6;
  if (!*a6 || *(_DWORD *)v7 != 1634431856 || !a2 && a3)
    goto LABEL_17;
  if (!a4 && a5 || _aks_prederive_passcode(*a6, a2, a3, (uint64_t)__s))
    goto LABEL_17;
  v11 = _aks_prederived_create_ctx(*((_DWORD *)v7 + 6), &v16);
  v12 = v16;
  if (v11 || (v13 = _aks_prederive_passcode(v16, a4, a5, (uint64_t)v17), v12 = v16, v13))
  {
LABEL_15:
    if (v12)
      aks_prederived_free(v12);
LABEL_17:
    v14 = 0xFFFFFFFFLL;
    goto LABEL_13;
  }
  if (_set_prederived_configuration(a1, (uint64_t)__s, 32, (uint64_t)v17, (uint64_t)v16))
  {
    v12 = v16;
    goto LABEL_15;
  }
  aks_prederived_free(v7);
  v14 = 0;
  *a6 = v16;
LABEL_13:
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  memset_s(v17, 0x20uLL, 0, 0x20uLL);
  return v14;
}

uint64_t aks_create_bag(uint64_t a1, int a2, unsigned int a3, _DWORD *a4)
{
  return _create_bag(a1, a2, 0, 0, a3, -1, a4);
}

uint64_t _create_bag(uint64_t a1, int a2, uint64_t a3, int a4, unsigned int a5, int a6, _DWORD *a7)
{
  uint64_t v14;
  mach_port_t aks_client_connection;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[7];

  input[6] = *MEMORY[0x24BDAC8D0];
  v14 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a7)
    {
      input[0] = a5;
      input[1] = a6;
      input[2] = a1;
      input[3] = a2;
      input[4] = a3;
      input[5] = a4;
      output = 0;
      outputCnt = 1;
      v14 = IOConnectCallMethod(aks_client_connection, 2u, input, 6u, 0, 0, &output, &outputCnt, 0, 0);
      if (!(_DWORD)v14)
        *a7 = output;
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_create_bag", ":", 187, "", 0, "", "");
  }
  return v14;
}

uint64_t aks_create_escrow_bag(uint64_t a1, int a2, int a3, _DWORD *a4)
{
  return _create_bag(a1, a2, 0, 0, 2u, a3, a4);
}

uint64_t aks_create_escrow_bag_with_auth(uint64_t a1, int a2, uint64_t a3, int a4, int a5, _DWORD *a6)
{
  return _create_bag(a3, a4, a1, a2, 2u, a5, a6);
}

uint64_t aks_create_sync_bag(uint64_t a1, int a2, int a3, _DWORD *a4)
{
  return _create_bag(a1, a2, 0, 0, 0x8000002u, a3, a4);
}

uint64_t aks_create_sync_bag_with_auth(uint64_t a1, int a2, uint64_t a3, int a4, int a5, _DWORD *a6)
{
  return _create_bag(a3, a4, a1, a2, 0x8000002u, a5, a6);
}

uint64_t aks_invalidate_sync_bags()
{
  mach_port_t aks_client_connection;

  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x42u, 0, 0, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_invalidate_sync_bags", ":", 544, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_unlock_with_sync_bag(const void *a1, int a2, uint64_t a3, int a4, int a5)
{
  uint64_t v10;
  mach_port_t aks_client_connection;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  v10 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a1)
    {
      input[0] = a5;
      input[1] = a3;
      input[2] = a4;
      return IOConnectCallMethod(aks_client_connection, 0x43u, input, 3u, a1, a2, 0, 0, 0, 0);
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unlock_with_sync_bag", ":", 557, "", 0, "", "");
  }
  return v10;
}

uint64_t aks_load_bag(const void *a1, int a2, _DWORD *a3)
{
  uint64_t v6;
  mach_port_t aks_client_connection;
  uint32_t outputCnt;
  uint64_t output[2];

  output[1] = *MEMORY[0x24BDAC8D0];
  v6 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v6 = 3758097090;
    if (a1)
    {
      if (a3)
      {
        output[0] = 0;
        outputCnt = 1;
        v6 = IOConnectCallMethod(aks_client_connection, 6u, 0, 0, a1, a2, output, &outputCnt, 0, 0);
        if (!(_DWORD)v6)
          *a3 = output[0];
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_load_bag", ":", 574, "", 0, "", "");
  }
  return v6;
}

uint64_t aks_invalidate_bag(const void *a1, int a2)
{
  uint64_t v4;
  mach_port_t aks_client_connection;

  v4 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a1)
      return IOConnectCallMethod(aks_client_connection, 0x57u, 0, 0, a1, a2, 0, 0, 0, 0);
    return 3758097090;
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_invalidate_bag", ":", 596, "", 0, "", "");
  }
  return v4;
}

uint64_t aks_unload_bag(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 4u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unload_bag", ":", 612, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_unload_session_bags(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x37u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unload_session_bags", ":", 629, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_save_bag(uint64_t a1)
{
  int v1;
  _DWORD *v2;
  _DWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  int v6;
  mach_port_t aks_client_connection;
  mach_port_t v8;
  uint64_t result;
  void *v10;
  size_t __count;
  uint64_t input;
  _BYTE __src[32768];
  uint64_t v14;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v6 = v1;
  v14 = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v8 = aks_client_connection;
    result = 3758097090;
    if (v5)
    {
      if (v3)
      {
        bzero(__src, 0x8000uLL);
        __count = 0x8000;
        input = v6;
        result = IOConnectCallMethod(v8, 3u, &input, 1u, 0, 0, 0, 0, __src, &__count);
        if (!(_DWORD)result)
        {
          v10 = calloc(__count, 1uLL);
          *v5 = v10;
          if (v10)
          {
            memcpy(v10, __src, __count);
            result = 0;
            *v3 = __count;
          }
          else
          {
            return 3758097085;
          }
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_save_bag", ":", 646, "", 0, "", "");
    return 3758097084;
  }
  return result;
}

uint64_t aks_change_secret_opts(int a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, uint64_t a8, int a9, unsigned __int8 a10, unsigned int a11, unsigned int a12, _DWORD *a13)
{
  mach_port_t aks_client_connection;
  uint64_t result;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[13];

  input[12] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a11;
    input[2] = a10;
    input[3] = a2;
    input[4] = a3;
    input[5] = a4;
    input[6] = a5;
    input[7] = a6;
    input[8] = a7;
    input[9] = a8;
    input[10] = a9;
    input[11] = a12;
    output = 0;
    outputCnt = 1;
    result = IOConnectCallMethod(aks_client_connection, 0xFu, input, 0xCu, 0, 0, &output, &outputCnt, 0, 0);
    if (a13)
    {
      if (!(_DWORD)result)
        *a13 = output;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_change_secret_opts", ":", 678, "", 0, "", "");
    return 3758097084;
  }
  return result;
}

uint64_t aks_change_secret_se(int a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, uint64_t a8, int a9, unsigned __int8 a10, unsigned int a11, _DWORD *a12)
{
  return aks_change_secret_opts(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, 0, a12);
}

uint64_t aks_change_secret(int a1, uint64_t a2, int a3, uint64_t a4, int a5, unsigned int a6, _DWORD *a7)
{
  return aks_change_secret_opts(a1, a2, a3, a4, a5, 0, 0, 0, 0, 0xFFu, a6, 0, a7);
}

uint64_t aks_get_bag_uuid(int a1, _OWORD *a2)
{
  uint64_t v4;
  mach_port_t aks_client_connection;
  size_t v7;
  uint64_t input;
  __int128 outputStruct;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v4 = 3758097084;
  v7 = 16;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      outputStruct = 0uLL;
      input = a1;
      v4 = IOConnectCallMethod(aks_client_connection, 0x17u, &input, 1u, 0, 0, 0, 0, &outputStruct, &v7);
      if (!(_DWORD)v4)
        *a2 = outputStruct;
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_bag_uuid", ":", 729, "", 0, "", "");
  }
  return v4;
}

uint64_t aks_copy_volume_cookie(int a1, _QWORD *a2, size_t *a3)
{
  return aks_copy_volume_cookie_persona(a1, (uint64_t)&UUID_NULL, a2, a3);
}

uint64_t aks_copy_volume_cookie_persona(int a1, uint64_t a2, _QWORD *a3, size_t *a4)
{
  mach_port_t aks_client_connection;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  mach_port_t v15;
  uint64_t v16;
  void *v17;
  unsigned int inputStructCnt[3];
  size_t __count;
  uint64_t input;
  _OWORD __src[2];
  __int16 v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v23 = 0;
  memset(__src, 0, sizeof(__src));
  __count = 34;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v14 = 3758097090;
    if (a3 && a4)
    {
      v15 = aks_client_connection;
      input = a1;
      aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 1, v9, v10, v11, v12, v13, a2);
      if (*(_QWORD *)&inputStructCnt[1])
      {
        v16 = IOConnectCallMethod(v15, 0x44u, &input, 1u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, __src, &__count);
        if ((_DWORD)v16)
        {
          v14 = v16;
        }
        else
        {
          v17 = calloc(__count, 1uLL);
          *a3 = v17;
          v14 = 3758097085;
          if (v17)
          {
            memcpy(v17, __src, __count);
            v14 = 0;
            *a4 = __count;
          }
        }
      }
      else
      {
        v14 = 3758097085;
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_copy_volume_cookie_persona", ":", 760, "", 0, "", "");
    v14 = 3758097084;
  }
  free(*(void **)&inputStructCnt[1]);
  return v14;
}

uint64_t aks_lock_bag(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0xDu, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_lock_bag", ":", 790, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_wrap_key(const void *a1, int a2, int a3, int a4, void *a5, int *a6, _DWORD *a7)
{
  uint64_t v14;
  mach_port_t aks_client_connection;
  uint64_t v16;
  size_t v18;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  v14 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v14 = 3758097090;
    if (a1 && a5 && a6)
    {
      input[0] = a4;
      input[1] = a3;
      output = 0;
      outputCnt = 1;
      v18 = *a6;
      v16 = IOConnectCallMethod(aks_client_connection, 0xAu, input, 2u, a1, a2, &output, &outputCnt, a5, &v18);
      if ((_DWORD)v16)
      {
        return v16;
      }
      else
      {
        *a6 = v18;
        v14 = 0;
        if (a7)
          *a7 = output;
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_wrap_key", ":", 848, "", 0, "", "");
  }
  return v14;
}

uint64_t aks_unwrap_key(const void *a1, int a2, int a3, int a4, void *a5, int *a6)
{
  uint64_t v12;
  mach_port_t aks_client_connection;
  size_t v15;
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  v12 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v12 = 3758097090;
    if (a1)
    {
      if (a5)
      {
        if (a6)
        {
          input[0] = a4;
          input[1] = a3;
          v15 = *a6;
          v12 = IOConnectCallMethod(aks_client_connection, 0xBu, input, 2u, a1, a2, 0, 0, a5, &v15);
          if (!(_DWORD)v12)
            *a6 = v15;
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unwrap_key", ":", 877, "", 0, "", "");
  }
  return v12;
}

uint64_t aks_rewrap_key_for_backup(const void *a1, int a2, int a3, int a4, uint64_t a5, unsigned int a6, void *a7)
{
  uint64_t v14;
  mach_port_t aks_client_connection;
  size_t v17;
  uint64_t input[5];

  input[4] = *MEMORY[0x24BDAC8D0];
  v14 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v14 = 3758097090;
    if (a1 && a7)
    {
      input[0] = a3;
      input[1] = a4;
      input[2] = a5;
      input[3] = a6;
      v17 = 108;
      return IOConnectCallMethod(aks_client_connection, 0x18u, input, 4u, a1, a2, 0, 0, a7, &v17);
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_rewrap_key_for_backup", ":", 901, "", 0, "", "");
  }
  return v14;
}

uint64_t aks_get_system(int a1, _DWORD *a2)
{
  uint64_t v4;
  mach_port_t aks_client_connection;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  v4 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      output = 0;
      input[0] = a1;
      outputCnt = 1;
      v4 = IOConnectCallMethod(aks_client_connection, 0xEu, input, a1 != 0, 0, 0, &output, &outputCnt, 0, 0);
      if (!(_DWORD)v4)
        *a2 = output;
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_system", ":", 922, "", 0, "", "");
  }
  return v4;
}

uint64_t aks_set_system_with_passcode(int a1, int a2, uint64_t a3, int a4)
{
  mach_port_t aks_client_connection;
  uint64_t input[5];

  input[4] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a2;
    input[2] = a3;
    input[3] = a4;
    return IOConnectCallMethod(aks_client_connection, 5u, input, 4u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_set_system_with_passcode", ":", 950, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_set_system(int a1, int a2)
{
  return aks_set_system_with_passcode(a1, a2, 0, 0);
}

uint64_t aks_set_keybag_for_volume(int a1, uint64_t a2, unsigned int a3)
{
  return aks_set_keybag_for_volume_with_cookie_persona(a1, a2, a3);
}

uint64_t aks_set_keybag_for_volume_with_cookie(int a1, uint64_t a2, unsigned int a3)
{
  return aks_set_keybag_for_volume_with_cookie_persona(a1, a2, a3);
}

uint64_t aks_set_keybag_for_volume_with_cookie_persona(int a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6;
  mach_port_t aks_client_connection;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  mach_port_t v13;
  void *v14;
  unsigned int inputStructCnt[3];
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  v6 = 3758097084;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v13 = aks_client_connection;
    input[0] = a1;
    input[1] = a3;
    aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 3, v8, v9, v10, v11, v12, a2);
    if (*(_QWORD *)&inputStructCnt[1])
    {
      v6 = IOConnectCallMethod(v13, 0x41u, input, 2u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, 0, 0);
      v14 = *(void **)&inputStructCnt[1];
    }
    else
    {
      v14 = 0;
      v6 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_set_keybag_for_volume_with_cookie_persona", ":", 987, "", 0, "", "");
    v14 = 0;
  }
  free(v14);
  return v6;
}

uint64_t aks_backup_enable_volume(uint64_t a1)
{
  uint64_t v1;
  size_t *v2;
  size_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  mach_port_t aks_client_connection;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  mach_port_t v18;
  uint64_t v19;
  void *v20;
  size_t __count;
  unsigned int inputStructCnt[3];
  uint64_t input[2];
  _BYTE __src[32768];
  uint64_t v26;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = v1;
  v26 = *MEMORY[0x24BDAC8D0];
  v11 = 3758097085;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  bzero(__src, 0x8000uLL);
  __count = 0x8000;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v18 = aks_client_connection;
    input[0] = v9;
    input[1] = v7;
    aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 1, v13, v14, v15, v16, v17, v10);
    if (*(_QWORD *)&inputStructCnt[1])
    {
      v19 = IOConnectCallMethod(v18, 0x6Eu, input, 2u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, __src, &__count);
      if ((_DWORD)v19)
      {
        v11 = v19;
      }
      else
      {
        v20 = calloc(__count, 1uLL);
        *v5 = v20;
        if (v20)
        {
          memcpy(v20, __src, __count);
          v11 = 0;
          *v3 = __count;
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_backup_enable_volume", ":", 1014, "", 0, "", "");
    v11 = 3758097084;
  }
  free(*(void **)&inputStructCnt[1]);
  return v11;
}

uint64_t aks_backup_disable_volume(uint64_t a1)
{
  uint64_t v2;
  mach_port_t aks_client_connection;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  mach_port_t v9;
  char *v10;
  int v12;
  char *v13;

  v2 = 3758097084;
  v13 = 0;
  v12 = 0;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v9 = aks_client_connection;
    aks_pack_data(&v13, (unsigned int *)&v12, 1, v4, v5, v6, v7, v8, a1);
    if (v13)
    {
      v2 = IOConnectCallMethod(v9, 0x6Fu, 0, 0, v13, v12, 0, 0, 0, 0);
      v10 = v13;
    }
    else
    {
      v10 = 0;
      v2 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_backup_disable_volume", ":", 1044, "", 0, "", "");
    v10 = 0;
  }
  free(v10);
  return v2;
}

uint64_t aks_backup_copy_current_bag_uuid(uint64_t a1, void *a2)
{
  uint64_t v4;
  mach_port_t aks_client_connection;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  mach_port_t v11;
  char *v12;
  size_t v14;
  int v15;
  char *v16;

  v4 = 3758097084;
  v16 = 0;
  v15 = 0;
  v14 = 16;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v11 = aks_client_connection;
    aks_pack_data(&v16, (unsigned int *)&v15, 1, v6, v7, v8, v9, v10, a1);
    if (v16)
    {
      v4 = IOConnectCallMethod(v11, 0x70u, 0, 0, v16, v15, 0, 0, a2, &v14);
      v12 = v16;
    }
    else
    {
      v12 = 0;
      v4 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_backup_copy_current_bag_uuid", ":", 1066, "", 0, "", "");
    v12 = 0;
  }
  free(v12);
  return v4;
}

uint64_t aks_backup_rewrap_key(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unsigned int a6, void *a7)
{
  uint64_t v13;
  mach_port_t aks_client_connection;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  mach_port_t v20;
  void *v21;
  size_t v23;
  unsigned int inputStructCnt[3];
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  v13 = 3758097084;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v20 = aks_client_connection;
    v21 = 0;
    v13 = 3758097090;
    if (a2 && a7)
    {
      input[0] = a4;
      input[1] = a5;
      input[2] = a6;
      aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 2, v15, v16, v17, v18, v19, a1);
      v23 = 108;
      v13 = IOConnectCallMethod(v20, 0x71u, input, 3u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, a7, &v23);
      v21 = *(void **)&inputStructCnt[1];
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_backup_rewrap_key", ":", 1087, "", 0, "", "");
    v21 = 0;
  }
  free(v21);
  return v13;
}

uint64_t aks_backup_rewrap_ek(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, unsigned int a8, void *outputStruct)
{
  uint64_t v15;
  mach_port_t aks_client_connection;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  mach_port_t v22;
  void *v23;
  size_t v25;
  unsigned int inputStructCnt[3];
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  v15 = 3758097084;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v22 = aks_client_connection;
    v23 = 0;
    v15 = 3758097090;
    if (a2 && a4 && outputStruct)
    {
      input[0] = a6;
      input[1] = a7;
      input[2] = a8;
      aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 3, v17, v18, v19, v20, v21, a1);
      v25 = 108;
      v15 = IOConnectCallMethod(v22, 0x71u, input, 3u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, outputStruct, &v25);
      v23 = *(void **)&inputStructCnt[1];
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_backup_rewrap_ek", ":", 1113, "", 0, "", "");
    v23 = 0;
  }
  free(v23);
  return v15;
}

uint64_t aks_backup_unwrap_bag(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  _OWORD v13[5];
  uint64_t v14;
  __int128 __s;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v17 = 0u;
  v18 = 0u;
  __s = 0u;
  v16 = 0u;
  v14 = 0;
  memset(v13, 0, sizeof(v13));
  v8 = decode_backup_bag(a1, a2, v13);
  if ((_DWORD)v8)
  {
    v9 = v8;
  }
  else
  {
    v9 = unwrap_backup_bag((uint64_t)v13, a3, a4, (uint64_t)&__s);
    if (!(_DWORD)v9)
    {
      v10 = v16;
      *a5 = __s;
      a5[1] = v10;
      v11 = v18;
      a5[2] = v17;
      a5[3] = v11;
    }
  }
  memset_s(v13, 0x58uLL, 0, 0x58uLL);
  memset_s(&__s, 0x40uLL, 0, 0x40uLL);
  return err_sks_to_aks(v9);
}

uint64_t aks_backup_copy_bag_uuid(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t v4;
  _OWORD v6[5];
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v7 = 0;
  memset(v6, 0, sizeof(v6));
  v4 = decode_backup_bag(a1, a2, v6);
  if (!(_DWORD)v4)
    uuid_copy(a3, (const unsigned __int8 *)v6 + 8);
  memset_s(v6, 0x58uLL, 0, 0x58uLL);
  return err_sks_to_aks(v4);
}

uint64_t aks_backup_unwrap_key(__int128 *a1, _QWORD *a2, unsigned int a3, _QWORD *a4, _QWORD *a5)
{
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  unsigned int v10;
  int __s;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v6 = a1[1];
  v12 = *a1;
  v13 = v6;
  v7 = a1[3];
  v14 = a1[2];
  v15 = v7;
  v10 = *a5;
  __s = 1;
  v8 = unwrap_data((uint64_t)&__s, 0, 0, a2, a3, a4, &v10);
  *a5 = v10;
  memset_s(&__s, 0x44uLL, 0, 0x44uLL);
  return err_sks_to_aks(v8);
}

uint64_t aks_kc_backup_unwrap_key(uint64_t a1, const void *a2, size_t a3, void *a4, size_t *a5)
{
  uint64_t v10;
  mach_port_t aks_client_connection;
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  v10 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v10 = 3758097090;
    if (a2 && a4)
    {
      input[0] = a1;
      input[1] = 64;
      return IOConnectCallMethod(aks_client_connection, 0x82u, input, 2u, a2, a3, 0, 0, a4, a5);
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_kc_backup_unwrap_key", ":", 1193, "", 0, "", "");
  }
  return v10;
}

uint64_t aks_kc_backup_wrap_key(int a1, const void *a2, size_t a3, void *a4, size_t *a5)
{
  uint64_t v10;
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  v10 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v10 = 3758097090;
    if (a2 && a4)
    {
      input[0] = a1;
      return IOConnectCallMethod(aks_client_connection, 0x81u, input, 1u, a2, a3, 0, 0, a4, a5);
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_kc_backup_wrap_key", ":", 1212, "", 0, "", "");
  }
  return v10;
}

uint64_t aks_kc_backup_get_handle(int a1, _DWORD *a2)
{
  uint64_t v4;
  mach_port_t aks_client_connection;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  v4 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      output = 0;
      input[0] = a1;
      outputCnt = 1;
      v4 = IOConnectCallMethod(aks_client_connection, 0x83u, input, 1u, 0, 0, &output, &outputCnt, 0, 0);
      if (!(_DWORD)v4)
        *a2 = output;
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_kc_backup_get_handle", ":", 1231, "", 0, "", "");
  }
  return v4;
}

uint64_t aks_kc_backup_get_uuid(int a1, unsigned __int8 *a2)
{
  uint64_t v4;
  mach_port_t aks_client_connection;
  uint64_t v6;
  size_t v8;
  unsigned __int8 src[8];
  uint64_t v10;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  v4 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      v10 = 0;
      input[0] = a1;
      v8 = 16;
      *(_QWORD *)src = 0;
      v6 = IOConnectCallMethod(aks_client_connection, 0x84u, input, 1u, 0, 0, 0, 0, src, &v8);
      if ((_DWORD)v6)
      {
        return v6;
      }
      else if (v8 == 16)
      {
        uuid_copy(a2, src);
        return 0;
      }
      else
      {
        return 3758604298;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_kc_backup_get_uuid", ":", 1253, "", 0, "", "");
  }
  return v4;
}

uint64_t aks_kc_backup_open_keybag(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, _OWORD *a6)
{
  int v7;
  int v9;
  int v11;
  FILE **v12;
  FILE *v13;
  uint64_t bag;
  int is_enabled;
  int v16;
  uint64_t v17;

  if (a5)
  {
    v7 = a4;
    v9 = a2;
    *a5 = -1;
    v11 = aks_backup_unwrap_bag((uint64_t)a1, a2, a3, a4, a6);
    v12 = (FILE **)MEMORY[0x24BDAC8E8];
    v13 = (FILE *)*MEMORY[0x24BDAC8E8];
    if (!v11)
    {
      fprintf(v13, "%s%s:%s%s%s%s%u:%s%u:%s Unwrapped DER backup bag%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":", 1302, "", 0, "", "");
      v17 = 0;
      goto LABEL_9;
    }
    fprintf(v13, "%s%s:%s%s%s%s%u:%s%u:%s Failed to unwrap backup bag as DER: 0x%08x%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":", 1290, "", 0, "", v11, "");
    bag = aks_load_bag(a1, v9, a5);
    if ((_DWORD)bag)
    {
      v17 = bag;
      fprintf(*v12, "%s%s:%s%s%s%s%u:%s%u:%s Failed to load in-kernel backup bag: 0x%08x%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":", 1292, "", 0, "", bag, "");
    }
    else
    {
      is_enabled = aks_prederived_is_enabled(*a5);
      v16 = *a5;
      if (is_enabled)
      {
        v17 = aks_prederived_unlock_keybag(v16, a3, v7, 0);
        if (!(_DWORD)v17)
          goto LABEL_9;
        fprintf(*v12, "%s%s:%s%s%s%s%u:%s%u:%s Failed to unlock in-kernel backup bag with prederived secret: 0x%08x%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":");
      }
      else
      {
        v17 = aks_unlock_bag(v16, a3, v7);
        if (!(_DWORD)v17)
          goto LABEL_9;
        fprintf(*v12, "%s%s:%s%s%s%s%u:%s%u:%s Failed to unlock in-kernel backup bag: 0x%08x%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":");
      }
    }
  }
  else
  {
    v17 = 3758097090;
  }
  if (*a5 != -1)
  {
    aks_unload_bag(*a5);
    *a5 = -1;
  }
LABEL_9:
  aks_prederived_free(0);
  return v17;
}

uint64_t aks_keybag_persona_create(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  mach_port_t aks_client_connection;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  mach_port_t v15;
  char *v16;
  int v18;
  char *v19;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  v8 = 3758097084;
  v19 = 0;
  v18 = 0;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v15 = aks_client_connection;
    input[0] = a1;
    input[1] = a2;
    input[2] = a3;
    aks_pack_data(&v19, (unsigned int *)&v18, 1, v10, v11, v12, v13, v14, a4);
    if (v19)
    {
      v8 = IOConnectCallMethod(v15, 0x60u, input, 3u, v19, v18, 0, 0, 0, 0);
      v16 = v19;
    }
    else
    {
      v16 = 0;
      v8 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_keybag_persona_create", ":", 1324, "", 0, "", "");
    v16 = 0;
  }
  free(v16);
  return v8;
}

uint64_t aks_keybag_persona_create_with_flags(int a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v10;
  mach_port_t aks_client_connection;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  mach_port_t v17;
  void *v18;
  unsigned int inputStructCnt[3];
  uint64_t input[5];

  input[4] = *MEMORY[0x24BDAC8D0];
  v10 = 3758097084;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v17 = aks_client_connection;
    input[0] = a1;
    input[1] = a2;
    input[2] = a3;
    input[3] = a5;
    aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 1, v12, v13, v14, v15, v16, a4);
    if (*(_QWORD *)&inputStructCnt[1])
    {
      v10 = IOConnectCallMethod(v17, 0x75u, input, 4u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, 0, 0);
      v18 = *(void **)&inputStructCnt[1];
    }
    else
    {
      v18 = 0;
      v10 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_keybag_persona_create_with_flags", ":", 1346, "", 0, "", "");
    v18 = 0;
  }
  free(v18);
  return v10;
}

uint64_t aks_keybag_persona_list(uint64_t a1)
{
  int v1;
  size_t *v2;
  size_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  int v6;
  uint64_t v7;
  mach_port_t aks_client_connection;
  uint64_t v9;
  void *v10;
  size_t v11;
  size_t __count;
  uint64_t input;
  _BYTE __src[8192];
  uint64_t v16;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v6 = v1;
  v16 = *MEMORY[0x24BDAC8D0];
  bzero(__src, 0x2000uLL);
  __count = 0x2000;
  input = v6;
  v7 = 3758097090;
  if (v5 && v3)
  {
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      v9 = IOConnectCallMethod(aks_client_connection, 0x61u, &input, 1u, 0, 0, 0, 0, __src, &__count);
      if ((_DWORD)v9)
      {
        v7 = v9;
      }
      else
      {
        if (__count)
        {
          v10 = calloc(__count, 1uLL);
          *v5 = v10;
          if (!v10)
          {
            v7 = 3758097085;
            goto LABEL_10;
          }
          memcpy(v10, __src, __count);
          v11 = __count;
        }
        else
        {
          v11 = 0;
          *v5 = 0;
        }
        v7 = 0;
        *v3 = v11;
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_keybag_persona_list", ":", 1372, "", 0, "", "");
      v7 = 3758097084;
    }
  }
LABEL_10:
  memset_s(__src, 0x2000uLL, 0, 0x2000uLL);
  return v7;
}

uint64_t aks_keybag_persona_delete(int a1, uint64_t a2)
{
  uint64_t v4;
  mach_port_t aks_client_connection;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  mach_port_t v11;
  char *v12;
  int v14;
  char *v15;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  v4 = 3758097084;
  v15 = 0;
  v14 = 0;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v11 = aks_client_connection;
    input[0] = a1;
    aks_pack_data(&v15, (unsigned int *)&v14, 1, v6, v7, v8, v9, v10, a2);
    if (v15)
    {
      v4 = IOConnectCallMethod(v11, 0x62u, input, 1u, v15, v14, 0, 0, 0, 0);
      v12 = v15;
    }
    else
    {
      v12 = 0;
      v4 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_keybag_persona_delete", ":", 1394, "", 0, "", "");
    v12 = 0;
  }
  free(v12);
  return v4;
}

uint64_t aks_auth_token_create(int a1, uint64_t a2, int a3, unsigned int a4, void *a5, size_t *a6)
{
  uint64_t v12;
  mach_port_t aks_client_connection;
  uint64_t input[5];

  input[4] = *MEMORY[0x24BDAC8D0];
  v12 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v12 = 3758097090;
    if (a5 && a6)
    {
      input[0] = a1;
      input[1] = a4;
      input[2] = a2;
      input[3] = a3;
      return IOConnectCallMethod(aks_client_connection, 0x26u, input, 4u, 0, 0, 0, 0, a5, a6);
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_auth_token_create", ":", 1415, "", 0, "", "");
  }
  return v12;
}

uint64_t aks_assert_hold(int a1, unsigned int a2, uint64_t a3)
{
  mach_port_t aks_client_connection;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  input[0] = a2;
  input[1] = a3;
  input[2] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x1Au, input, 3u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_assert_hold", ":", 1654, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_assert_drop(int a1, unsigned int a2)
{
  mach_port_t aks_client_connection;
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  input[0] = a2;
  input[1] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x1Bu, input, 2u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_assert_drop", ":", 1672, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_assert_promote(int a1, unsigned int a2)
{
  mach_port_t aks_client_connection;
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a2;
    input[1] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x64u, input, 2u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_assert_promote", ":", 1687, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_oneness_heartbeat(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x91u, input, 1u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_oneness_heartbeat", ":", 1707, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_assert_consume(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x65u, input, 1u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_assert_consume", ":", 1722, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_recover_with_escrow_bag(int a1, uint64_t a2)
{
  mach_port_t aks_client_connection;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  mach_port_t v10;
  uint64_t v11;
  void *v12;
  int v14;
  void *v15;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  v15 = 0;
  v14 = 0;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v10 = aks_client_connection;
    aks_pack_data((char **)&v15, (unsigned int *)&v14, 3, v5, v6, v7, v8, v9, a2);
    input[0] = a1;
    input[1] = (uint64_t)v15;
    input[2] = v14;
    v11 = IOConnectCallMethod(v10, 0x12u, input, 3u, 0, 0, 0, 0, 0, 0);
    v12 = v15;
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_recover_with_escrow_bag", ":", 1739, "", 0, "", "");
    v12 = 0;
    v11 = 3758097084;
  }
  free(v12);
  return v11;
}

uint64_t aks_fdr_hmac_data(uint64_t a1)
{
  uint64_t v1;
  _DWORD *v2;
  _DWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  int v6;
  int v7;
  const void *v8;
  uint64_t v9;
  mach_port_t aks_client_connection;
  uint64_t v11;
  void *v12;
  size_t __count;
  _BYTE __src[32768];
  uint64_t v16;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v8 = (const void *)v1;
  v16 = *MEMORY[0x24BDAC8D0];
  v9 = 3758097090;
  bzero(__src, 0x8000uLL);
  __count = 0x8000;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (v8 && v5 && v3)
    {
      v11 = IOConnectCallMethod(aks_client_connection, 0x29u, 0, 0, v8, v7, 0, 0, __src, &__count);
      if ((_DWORD)v11)
      {
        v9 = v11;
      }
      else
      {
        v12 = calloc(__count, 1uLL);
        *v5 = v12;
        if (v12)
        {
          memcpy(v12, __src, __count);
          v9 = 0;
          *v3 = __count;
        }
        else
        {
          v9 = 3758097085;
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_fdr_hmac_data", ":", 1758, "", 0, "", "");
    v9 = 3758097084;
  }
  memset_s(__src, 0x8000uLL, 0, 0x8000uLL);
  return v9;
}

uint64_t aks_generation(int a1, unsigned int a2, _DWORD *a3)
{
  mach_port_t aks_client_connection;
  uint64_t result;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a2;
    output = 0;
    outputCnt = 1;
    result = IOConnectCallMethod(aks_client_connection, 0x28u, input, 2u, 0, 0, &output, &outputCnt, 0, 0);
    if (a3)
    {
      if (!(_DWORD)result)
        *a3 = output;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_generation", ":", 1781, "", 0, "", "");
    return 3758097084;
  }
  return result;
}

uint64_t _aks_verify_password(int a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  uint64_t v9;
  mach_port_t aks_client_connection;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  mach_port_t v16;
  const char *v17;
  void *v18;
  int v20;
  void *v21;
  uint64_t input[5];

  input[4] = *MEMORY[0x24BDAC8D0];
  v9 = 3758097084;
  v21 = 0;
  v20 = 0;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v16 = aks_client_connection;
    if (a2)
      v17 = a2;
    else
      v17 = "";
    aks_pack_data((char **)&v21, (unsigned int *)&v20, 2, v11, v12, v13, v14, v15, (uint64_t)v17);
    if (v21)
    {
      input[0] = a1;
      input[1] = a6;
      input[2] = (uint64_t)v21;
      input[3] = v20;
      v9 = IOConnectCallMethod(v16, 0x2Au, input, 4u, 0, 0, 0, 0, 0, 0);
      v18 = v21;
    }
    else
    {
      v18 = 0;
      v9 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_aks_verify_password", ":", 1807, "", 0, "", "");
    v18 = 0;
  }
  free(v18);
  return v9;
}

uint64_t aks_verify_password(int a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return _aks_verify_password(a1, a2, a3, a4, a5, 0);
}

uint64_t aks_verify_password_memento(int a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return _aks_verify_password(a1, a2, a3, a4, a5, 1u);
}

uint64_t aks_register_for_notifications()
{
  if (get_aks_client_connection())
    JUMPOUT(0x219A17B70);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_register_for_notifications", ":", 1840, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_create_signing_key(int a1, int a2, _QWORD *a3, size_t *a4)
{
  uint64_t result;
  mach_port_t aks_client_connection;
  void *v8;
  size_t __count;
  uint64_t input[2];
  _OWORD __src[16];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  __count = 256;
  input[0] = a1;
  input[1] = a2;
  result = 3758097090;
  if (a3 && a4)
  {
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      memset(__src, 0, sizeof(__src));
      result = IOConnectCallMethod(aks_client_connection, 0x31u, input, 2u, 0, 0, 0, 0, __src, &__count);
      if (!(_DWORD)result)
      {
        if (__count > 0x100)
        {
          return 3758604298;
        }
        else
        {
          v8 = calloc(__count, 1uLL);
          *a3 = v8;
          if (v8)
          {
            memcpy(v8, __src, __count);
            result = 0;
            *a4 = __count;
          }
          else
          {
            return 3758097085;
          }
        }
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_create_signing_key", ":", 1859, "", 0, "", "");
      return 3758097084;
    }
  }
  return result;
}

uint64_t aks_create_signing_key_with_params(uint64_t a1)
{
  int v1;
  const void *v2;
  size_t v3;
  _QWORD *v4;
  size_t *v5;
  int v6;
  uint64_t result;
  size_t *v8;
  _QWORD *v9;
  size_t v10;
  const void *v11;
  mach_port_t aks_client_connection;
  mach_port_t v13;
  void *v14;
  size_t __count;
  uint64_t input[2];
  _BYTE __src[32768];
  uint64_t v18;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v18 = *MEMORY[0x24BDAC8D0];
  __count = 0x8000;
  input[0] = v1;
  input[1] = v6;
  result = 3758097090;
  if (v4)
  {
    v8 = v5;
    if (v5)
    {
      v9 = v4;
      v10 = v3;
      v11 = v2;
      aks_client_connection = get_aks_client_connection();
      if (aks_client_connection)
      {
        v13 = aks_client_connection;
        bzero(__src, 0x8000uLL);
        result = IOConnectCallMethod(v13, 0x31u, input, 2u, v11, v10, 0, 0, __src, &__count);
        if (!(_DWORD)result)
        {
          if (__count > 0x8000)
          {
            return 3758604298;
          }
          else
          {
            v14 = calloc(__count, 1uLL);
            *v9 = v14;
            if (v14)
            {
              memcpy(v14, __src, __count);
              result = 0;
              *v8 = __count;
            }
            else
            {
              return 3758097085;
            }
          }
        }
      }
      else
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_create_signing_key_with_params", ":", 1881, "", 0, "", "");
        return 3758097084;
      }
    }
  }
  return result;
}

uint64_t aks_obliterate_signing_keys(uint64_t a1)
{
  return remote_session_operate(a1);
}

uint64_t remote_session_operate(uint64_t a1)
{
  int v1;
  size_t *v2;
  size_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint32_t v6;
  uint32_t v7;
  uint64_t v8;
  uint64_t v9;
  mach_port_t aks_client_connection;
  mach_port_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  size_t v15;
  size_t __count;
  uint64_t input[3];
  _BYTE __src[15360];
  uint64_t v20;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v20 = *MEMORY[0x24BDAC8D0];
  __count = 15360;
  input[0] = v1;
  input[1] = v8;
  input[2] = v9;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v11 = aks_client_connection;
    bzero(__src, 0x3C00uLL);
    v12 = IOConnectCallMethod(v11, v7, input, 3u, 0, 0, 0, 0, __src, &__count);
    if ((_DWORD)v12)
    {
      return v12;
    }
    else if (__count > 0x3C00)
    {
      return 3758604298;
    }
    else
    {
      v13 = 0;
      if (v5 && v3)
      {
        if (__count)
        {
          v14 = calloc(__count, 1uLL);
          *v5 = v14;
          if (!v14)
            return 3758097085;
          memcpy(v14, __src, __count);
          v15 = __count;
        }
        else
        {
          v15 = 0;
        }
        v13 = 0;
        *v3 = v15;
      }
    }
  }
  else
  {
    v13 = 3758097084;
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "remote_session_operate", ":", 2017, "", 0, "", "");
  }
  return v13;
}

uint64_t aks_sign_signing_key(int a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, _QWORD *a8, size_t *a9)
{
  uint64_t v9;
  mach_port_t aks_client_connection;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  mach_port_t v18;
  uint64_t v19;
  void *v20;
  unsigned int inputStructCnt[3];
  size_t __count;
  uint64_t input[3];
  _OWORD __src[16];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  memset(__src, 0, sizeof(__src));
  __count = 256;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  input[0] = a1;
  input[1] = a2;
  v9 = 3758097090;
  input[2] = a5;
  if (a8 && a9)
  {
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      v18 = aks_client_connection;
      aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 2, v13, v14, v15, v16, v17, a3);
      if (*(_QWORD *)&inputStructCnt[1])
      {
        v19 = IOConnectCallMethod(v18, 0x32u, input, 3u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, __src, &__count);
        if ((_DWORD)v19)
        {
          v9 = v19;
        }
        else if (__count > 0x100)
        {
          v9 = 3758604298;
        }
        else
        {
          v20 = calloc(__count, 1uLL);
          *a8 = v20;
          v9 = 3758097085;
          if (v20)
          {
            memcpy(v20, __src, __count);
            v9 = 0;
            *a9 = __count;
          }
        }
      }
      else
      {
        v9 = 3758097085;
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_sign_signing_key", ":", 1911, "", 0, "", "");
      v9 = 3758097084;
    }
  }
  free(*(void **)&inputStructCnt[1]);
  return v9;
}

uint64_t aks_remote_session(int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9)
{
  uint64_t v10;
  mach_port_t aks_client_connection;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  mach_port_t v17;
  uint64_t v18;
  uint32_t outputCnt;
  unsigned int inputStructCnt[3];
  uint64_t output;
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  v10 = 3758097084;
  input[0] = a2;
  input[1] = a1;
  output = 0;
  outputCnt = 1;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v17 = aks_client_connection;
    aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 3, v12, v13, v14, v15, v16, a3);
    if (*(_QWORD *)&inputStructCnt[1])
    {
      v18 = IOConnectCallMethod(v17, 0x2Cu, input, 2u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], &output, &outputCnt, 0, 0);
      v10 = v18;
      if (a9 && !(_DWORD)v18)
        *a9 = output;
    }
    else
    {
      v10 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_remote_session", ":", 1938, "", 0, "", "");
  }
  free(*(void **)&inputStructCnt[1]);
  return v10;
}

uint64_t aks_validate_local_key(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  int v8;
  uint64_t v11;
  void *v12;
  rsize_t __smax;
  rsize_t __n;
  uint64_t v16;
  void *v17;
  void *__s;
  __int128 v19;

  v17 = 0;
  __s = 0;
  v4 = 3758097084;
  __n = 0;
  v16 = 0;
  v5 = 3758097090;
  __smax = 0;
  if (!a3 || !a4)
    goto LABEL_12;
  v8 = -536870212;
  *(_QWORD *)&v19 = a3;
  *((_QWORD *)&v19 + 1) = a3 + a4;
  if (!(a3 + a4))
    goto LABEL_19;
  v16 = 0;
  if ((ccder_blob_decode_range() & 1) == 0)
  {
    v8 = -536870198;
LABEL_19:
    syslog(3, "error parsing signing key: %d", v8);
    v5 = 3758097084;
LABEL_12:
    v12 = __s;
    v4 = v5;
    goto LABEL_13;
  }
  der_utils_decode_implicit_uint64(&v19, 0x8000000000000001, &v16);
  if (v16)
  {
    v5 = remote_session_operate(a1);
    if ((_DWORD)v5)
      syslog(3, "error: validating v1 local signing key failed: %d");
    goto LABEL_12;
  }
  v11 = aks_create_signing_key(a1, 11, &__s, &__n);
  if ((_DWORD)v11)
  {
    v5 = v11;
    syslog(3, "error: validating (create) v0 local signing key failed: %d", v11);
    goto LABEL_12;
  }
  v12 = __s;
  if (__s && __n)
  {
    v5 = aks_sign_signing_key(a1, a2, a3, a4, 11, (uint64_t)__s, __n, &v17, &__smax);
    if ((_DWORD)v5)
      syslog(3, "error: validating (sign) v0 local signing key failed: %d");
    goto LABEL_12;
  }
LABEL_13:
  if (v12)
  {
    memset_s(v12, __n, 0, __n);
    free(__s);
  }
  if (v17)
  {
    memset_s(v17, __smax, 0, __smax);
    free(v17);
  }
  return v4;
}

uint64_t aks_remote_session_step(uint64_t a1)
{
  return remote_session_operate(a1);
}

uint64_t aks_remote_peer_setup(uint64_t a1)
{
  return remote_session_operate(a1);
}

uint64_t aks_remote_peer_setup_with_acm(uint64_t a1)
{
  return remote_session_operate(a1);
}

uint64_t aks_remote_peer_confirm(uint64_t a1)
{
  return remote_session_operate(a1);
}

uint64_t aks_remote_session_token(uint64_t a1)
{
  return remote_session_operate(a1);
}

uint64_t aks_drain_backup_keys(uint64_t a1)
{
  int v1;
  _DWORD *v2;
  _DWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  int v6;
  mach_port_t aks_client_connection;
  mach_port_t v8;
  uint64_t result;
  void *v10;
  size_t __count;
  uint64_t input[2];
  _BYTE __src[32768];
  uint64_t v14;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v6 = v1;
  v14 = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v8 = aks_client_connection;
    result = 3758097090;
    if (v5)
    {
      if (v3)
      {
        bzero(__src, 0x8000uLL);
        __count = 0x8000;
        input[0] = v6;
        input[1] = 0;
        result = IOConnectCallMethod(v8, 0x14u, input, 2u, 0, 0, 0, 0, __src, &__count);
        if (!(_DWORD)result)
        {
          if (__count)
          {
            v10 = calloc(__count, 1uLL);
            *v5 = v10;
            if (v10)
            {
              memcpy(v10, __src, __count);
              result = 0;
              *v3 = __count;
            }
            else
            {
              return 3758097085;
            }
          }
          else
          {
            return 3758097136;
          }
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_drain_backup_keys", ":", 2072, "", 0, "", "");
    return 3758097084;
  }
  return result;
}

uint64_t aks_drain_backup_keys_info(uint64_t a1)
{
  int v1;
  size_t *v2;
  size_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  int v6;
  mach_port_t aks_client_connection;
  mach_port_t v8;
  uint64_t result;
  void *v10;
  size_t __count;
  uint64_t input[2];
  _BYTE __src[32768];
  uint64_t v14;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v6 = v1;
  v14 = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v8 = aks_client_connection;
    result = 3758097090;
    if (v5)
    {
      if (v3)
      {
        bzero(__src, 0x8000uLL);
        __count = 0x8000;
        input[0] = v6;
        input[1] = 1;
        result = IOConnectCallMethod(v8, 0x14u, input, 2u, 0, 0, 0, 0, __src, &__count);
        if (!(_DWORD)result)
        {
          if (__count)
          {
            if (__ROR8__(0xEF7BDEF7BDEF7BDFLL * __count, 2) > 0x210842108421084uLL)
            {
              return 3758604298;
            }
            else
            {
              v10 = calloc(__count, 1uLL);
              *v5 = v10;
              if (v10)
              {
                memcpy(v10, __src, __count);
                result = 0;
                *v3 = __count / 0x7C;
              }
              else
              {
                return 3758097085;
              }
            }
          }
          else
          {
            return 3758097136;
          }
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_drain_backup_keys_info", ":", 2100, "", 0, "", "");
    return 3758097084;
  }
  return result;
}

uint64_t aks_clear_backup_bag(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x16u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_clear_backup_bag", ":", 2129, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_set_backup_bag(uint64_t a1)
{
  int v1;
  _DWORD *v2;
  _DWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  mach_port_t aks_client_connection;
  mach_port_t v14;
  _BYTE *outputStruct;
  size_t *p_count;
  uint64_t v17;
  uint64_t result;
  void *v19;
  size_t __count;
  uint64_t input[5];
  _BYTE __src[32768];
  uint64_t v23;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = v1;
  v23 = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_set_backup_bag", ":", 2146, "", 0, "", "");
    return 3758097084;
  }
  v14 = aks_client_connection;
  if (v5)
  {
    if (!v3)
      return 3758097090;
    outputStruct = __src;
    p_count = &__count;
    v17 = 1;
  }
  else
  {
    p_count = 0;
    outputStruct = 0;
    v17 = 0;
  }
  bzero(__src, 0x8000uLL);
  __count = 0x8000;
  input[0] = v12;
  input[1] = v11;
  input[2] = v17;
  input[3] = v9;
  input[4] = v7;
  result = IOConnectCallMethod(v14, 0x15u, input, 5u, 0, 0, 0, 0, outputStruct, p_count);
  if (v5 && !(_DWORD)result)
  {
    v19 = calloc(__count, 1uLL);
    *v5 = v19;
    if (v19)
    {
      memcpy(v19, __src, __count);
      result = 0;
      *v3 = __count;
    }
    else
    {
      return 3758097085;
    }
  }
  return result;
}

uint64_t aks_make_public_backup_bag(int a1, _DWORD *a2)
{
  uint64_t v4;
  mach_port_t aks_client_connection;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  v4 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      output = 0;
      input[0] = a1;
      outputCnt = 1;
      v4 = IOConnectCallMethod(aks_client_connection, 0x52u, input, 1u, 0, 0, &output, &outputCnt, 0, 0);
      if (!(_DWORD)v4)
        *a2 = output;
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_make_public_backup_bag", ":", 2178, "", 0, "", "");
  }
  return v4;
}

uint64_t aks_remote_session_reset(uint64_t a1)
{
  return remote_session_operate(a1);
}

uint64_t aks_remote_session_reset_all()
{
  return remote_session_operate(0);
}

uint64_t aks_reset_session(uint64_t a1)
{
  return remote_session_operate(a1);
}

uint64_t aks_remote_peer_get_state(uint64_t a1)
{
  int v1;
  _DWORD *v2;
  _DWORD *v3;
  size_t v4;
  size_t v5;
  const void *v6;
  const void *v7;
  uint64_t v8;
  mach_port_t aks_client_connection;
  mach_port_t v10;
  uint64_t v11;
  size_t v13[2];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  void *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t input;
  _BYTE outputStruct[4096];
  uint64_t v27;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v27 = *MEMORY[0x24BDAC8D0];
  v8 = 3758097084;
  v13[0] = 4096;
  input = v1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (v3)
    {
      v10 = aks_client_connection;
      bzero(outputStruct, 0x1000uLL);
      memset_s(v3, 0x10uLL, 0, 0x10uLL);
      v11 = IOConnectCallMethod(v10, 0x39u, &input, 1u, v7, v5, 0, 0, outputStruct, v13);
      if ((_DWORD)v11)
      {
        return v11;
      }
      else
      {
        v18 = 0;
        v22 = 0u;
        v14 = 0u;
        v15 = 0u;
        v17 = 0u;
        v20 = 0u;
        v21 = 0u;
        v23 = 0u;
        v24 = 0;
        v13[1] = (size_t)der_key_peer_unlock_token_status;
        v16 = (unint64_t)der_key_peer_unwrapped_escrow_record_status;
        v19 = der_key_peer_wrapped_escrow_record_status;
        *(_QWORD *)&v22 = der_key_peer_flags;
        der_dict_iterate();
        *v3 = der_get_number();
        v3[1] = der_get_number();
        v3[2] = der_get_number();
        v8 = 0;
        v3[3] = der_get_number();
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_remote_peer_get_state", ":", 2255, "", 0, "", "");
  }
  return v8;
}

uint64_t aks_remote_peer_drop(int a1, const void *a2, size_t a3)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x3Au, input, 1u, a2, a3, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_remote_peer_drop", ":", 2292, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_lock_device(int a1, int a2)
{
  mach_port_t aks_client_connection;
  uint32_t v4;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
      v4 = 32;
    else
      v4 = 8;
    return IOConnectCallMethod(aks_client_connection, v4, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_lock_device", ":", 2307, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_lock_cx(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x8Du, input, 1u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_lock_cx", ":", 2327, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_unlock_device(int a1, uint64_t a2, int a3)
{
  mach_port_t aks_client_connection;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  input[1] = a2;
  input[2] = a3;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 9u, input, 3u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unlock_device", ":", 2342, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_obliterate_class_d()
{
  mach_port_t aks_client_connection;

  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x13u, 0, 0, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_obliterate_class_d", ":", 2355, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_migrate_s_key(int a1, unsigned int a2, uint64_t a3, unsigned int a4, const void *a5, int a6)
{
  mach_port_t aks_client_connection;
  uint64_t input[5];

  input[4] = *MEMORY[0x24BDAC8D0];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a2;
    input[2] = a3;
    input[3] = a4;
    return IOConnectCallMethod(aks_client_connection, 0x3Fu, input, 4u, a5, a6, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_migrate_s_key", ":", 2367, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_smartcard_register(int a1, uint64_t a2, uint64_t a3, unsigned int a4, const void *a5, size_t a6, _QWORD *a7, size_t *a8)
{
  mach_port_t aks_client_connection;
  mach_port_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  size_t v17;
  size_t __count;
  _BYTE __src[2048];
  uint64_t input[5];

  input[4] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  input[1] = a4;
  input[2] = a2;
  input[3] = a3;
  __count = 2048;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v13 = aks_client_connection;
    bzero(__src, 0x800uLL);
    v14 = IOConnectCallMethod(v13, 0x3Bu, input, 4u, a5, a6, 0, 0, __src, &__count);
    if ((_DWORD)v14)
    {
      return v14;
    }
    else if (__count > 0x800)
    {
      return 3758604298;
    }
    else
    {
      v15 = 0;
      if (a7 && a8)
      {
        if (__count)
        {
          v16 = calloc(__count, 1uLL);
          *a7 = v16;
          if (!v16)
            return 3758097085;
          memcpy(v16, __src, __count);
          v17 = __count;
        }
        else
        {
          v17 = 0;
        }
        v15 = 0;
        *a8 = v17;
      }
    }
  }
  else
  {
    v15 = 3758097084;
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_smartcard_register", ":", 2388, "", 0, "", "");
  }
  return v15;
}

uint64_t aks_smartcard_unregister(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x3Cu, input, 1u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_smartcard_unregister", ":", 2412, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_smartcard_request_unlock(int a1, const void *a2, size_t a3, _QWORD *a4, size_t *a5)
{
  mach_port_t aks_client_connection;
  mach_port_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  size_t v14;
  size_t __count;
  _BYTE __src[2048];
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  __count = 2048;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v10 = aks_client_connection;
    bzero(__src, 0x800uLL);
    v11 = IOConnectCallMethod(v10, 0x3Du, input, 1u, a2, a3, 0, 0, __src, &__count);
    if ((_DWORD)v11)
    {
      return v11;
    }
    else if (__count > 0x800)
    {
      return 3758604298;
    }
    else
    {
      v12 = 0;
      if (a4 && a5)
      {
        if (__count)
        {
          v13 = calloc(__count, 1uLL);
          *a4 = v13;
          if (!v13)
            return 3758097085;
          memcpy(v13, __src, __count);
          v14 = __count;
        }
        else
        {
          v14 = 0;
        }
        v12 = 0;
        *a5 = v14;
      }
    }
  }
  else
  {
    v12 = 3758097084;
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_smartcard_request_unlock", ":", 2429, "", 0, "", "");
  }
  return v12;
}

uint64_t aks_smartcard_unlock(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, size_t *a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  mach_port_t aks_client_connection;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  size_t v19;
  size_t __count;
  unsigned int inputStructCnt[3];
  _BYTE __src[2048];
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  bzero(__src, 0x800uLL);
  __count = 2048;
  aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 2, v10, v11, v12, v13, v14, a2);
  if (!*(_QWORD *)&inputStructCnt[1])
  {
    v17 = 3758097085;
    goto LABEL_12;
  }
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_smartcard_unlock", ":", 2460, "", 0, "", "");
    v17 = 3758097084;
    goto LABEL_12;
  }
  v16 = IOConnectCallMethod(aks_client_connection, 0x3Eu, input, 1u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, __src, &__count);
  if ((_DWORD)v16)
  {
    v17 = v16;
    goto LABEL_12;
  }
  if (__count > 0x800)
  {
    v17 = 3758604298;
    goto LABEL_12;
  }
  v17 = 0;
  if (a6 && a7)
  {
    if (!__count)
    {
      v19 = 0;
      goto LABEL_11;
    }
    v18 = calloc(__count, 1uLL);
    *a6 = v18;
    v17 = 3758097085;
    if (v18)
    {
      memcpy(v18, __src, __count);
      v19 = __count;
LABEL_11:
      v17 = 0;
      *a7 = v19;
    }
  }
LABEL_12:
  free(*(void **)&inputStructCnt[1]);
  return v17;
}

uint64_t aks_smartcard_get_sc_usk(unint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a3 && a4)
  {
    if (aks_smartcard_get_foo((uint64_t)der_key_sc_enc_sc_usk, 0, a1, a2, a3, a4))
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  return result;
}

uint64_t aks_smartcard_get_foo(uint64_t a1, int a2, unint64_t a3, uint64_t a4, uint64_t *a5, _QWORD *a6)
{
  uint64_t result;
  uint64_t number;
  uint64_t v11;
  uint64_t v12;

  result = 0xFFFFFFFFLL;
  if (a6 && a3 && a4 && a5 && a3 + a4 > a3)
  {
    der_dict_iterate();
    if (a2)
    {
      if (*a6 == 8)
      {
        number = der_get_number();
        result = 0;
        *a5 = number;
        return result;
      }
      return 0xFFFFFFFFLL;
    }
    v11 = ccder_decode_tl();
    if (!v11)
      return 0xFFFFFFFFLL;
    v12 = v11;
    result = 0;
    *a5 = v12;
    *a6 = 0;
  }
  return result;
}

uint64_t aks_smartcard_get_ec_pub(unint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a3 && a4)
  {
    if (aks_smartcard_get_foo((uint64_t)der_key_sc_auth_eph_pub, 0, a1, a2, a3, a4))
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  return result;
}

uint64_t aks_smartcard_get_mode(unint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  v5 = 8;
  if (!a3)
    return 0xFFFFFFFFLL;
  v6 = 0;
  result = aks_smartcard_get_foo((uint64_t)der_key_sc_auth_mode, 1, a1, a2, &v6, &v5);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  *a3 = v6;
  return result;
}

uint64_t aks_smartcard_get_version(unint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  v5 = 8;
  if (!a3)
    return 0xFFFFFFFFLL;
  v6 = 0;
  result = aks_smartcard_get_foo((uint64_t)der_key_sc_auth_version, 1, a1, a2, &v6, &v5);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  *a3 = v6;
  return result;
}

uint64_t aks_se_fail(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x47u, input, 1u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_se_fail", ":", 2589, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_se_set_healthy(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x49u, input, 1u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_se_set_healthy", ":", 2605, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_se_set_secret(int a1, uint64_t a2, uint64_t a3)
{
  return __aks_se_set_secret(a1, a2, a3, 0x45u);
}

uint64_t __aks_se_set_secret(int a1, uint64_t a2, uint64_t a3, uint32_t a4)
{
  mach_port_t aks_client_connection;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  input[1] = a2;
  input[2] = a3;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, a4, input, 3u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "__aks_se_set_secret", ":", 2621, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_se_set_secret_memento(int a1, uint64_t a2, uint64_t a3)
{
  return __aks_se_set_secret(a1, a2, a3, 0x8Cu);
}

uint64_t aks_se_recover(int a1, uint64_t a2, uint64_t a3)
{
  mach_port_t aks_client_connection;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  input[1] = a2;
  input[2] = a3;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x46u, input, 3u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_se_recover", ":", 2649, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_change_secret_epilogue(int a1, uint64_t a2, uint64_t a3)
{
  mach_port_t aks_client_connection;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  input[1] = a2;
  input[2] = a3;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x69u, input, 3u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_change_secret_epilogue", ":", 2665, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_se_get_reset_token_for_memento_secret(uint64_t a1)
{
  int v1;
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  mach_port_t aks_client_connection;
  uint64_t v7;
  unint64_t number;
  uint64_t v9;
  rsize_t __n[2];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  _BYTE __s[4096];
  uint64_t input[4];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  input[3] = *MEMORY[0x24BDAC8D0];
  input[0] = v1;
  input[1] = v4;
  input[2] = v5;
  bzero(__s, 0x1000uLL);
  __n[0] = 4096;
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    v9 = 3758097084;
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_se_get_reset_token_for_memento_secret", ":", 2683, "", 0, "", "");
    goto LABEL_10;
  }
  v7 = IOConnectCallMethod(aks_client_connection, 0x48u, input, 3u, 0, 0, 0, 0, __s, __n);
  if ((_DWORD)v7)
  {
    v9 = v7;
    goto LABEL_10;
  }
  if (__n[0] - 4097 < 0xFFFFFFFFFFFFF000)
  {
    v9 = 3758604298;
    goto LABEL_10;
  }
  v16 = 0;
  v15 = 0u;
  v13 = 0u;
  v12 = 0u;
  __n[1] = (rsize_t)der_key_config_se_reset_token;
  v14 = (unint64_t)der_key_config_se_slot;
  der_dict_iterate();
  if ((_QWORD)v12)
  {
    ccder_decode_tl();
LABEL_9:
    v9 = 0;
    goto LABEL_10;
  }
  if (!*((_QWORD *)&v14 + 1))
    goto LABEL_9;
  number = der_get_number();
  if (number > 0xFF)
    goto LABEL_9;
  v9 = 0;
  *v3 = number;
LABEL_10:
  memset_s(__s, __n[0], 0, __n[0]);
  return v9;
}

uint64_t aks_se_get_reset_token(uint64_t a1)
{
  return aks_se_get_reset_token_for_memento_secret(a1);
}

uint64_t aks_se_set_nonce(int a1, const void *a2, size_t a3)
{
  mach_port_t aks_client_connection;
  size_t v6;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
      v6 = a3;
    else
      v6 = 0;
    return IOConnectCallMethod(aks_client_connection, 0x58u, input, 1u, a2, v6, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_se_set_nonce", ":", 2737, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_se_get_reset_sig(uint64_t a1)
{
  int v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  mach_port_t aks_client_connection;
  uint64_t v12;
  _BYTE *v13;
  int v14;
  void *v15;
  size_t v16;
  size_t __n;
  int __s;
  char v20;
  _BYTE v21[3];
  uint64_t input[2];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = v1;
  bzero(&__s, 0x1000uLL);
  __n = 4096;
  v10 = 3758097090;
  if (v9)
  {
    if (v7)
    {
      v10 = 3758097090;
      if (v5)
      {
        if (v3)
        {
          aks_client_connection = get_aks_client_connection();
          if (aks_client_connection)
          {
            v12 = IOConnectCallMethod(aks_client_connection, 0x5Au, input, 1u, 0, 0, 0, 0, &__s, &__n);
            if ((_DWORD)v12)
            {
              v10 = v12;
            }
            else if (__n - 4097 < 0xFFFFFFFFFFFFF005)
            {
              v10 = 3758604298;
            }
            else
            {
              v13 = calloc(5uLL, 1uLL);
              *v5 = v13;
              if (v13)
              {
                *v3 = 5;
                v14 = __s;
                v13[4] = v20;
                *(_DWORD *)v13 = v14;
                v15 = calloc(__n - 5, 1uLL);
                *v9 = v15;
                v10 = 3758097085;
                if (v15)
                {
                  v16 = __n;
                  *v7 = __n - 5;
                  memcpy(v15, v21, v16);
                  v10 = 0;
                }
              }
              else
              {
                v10 = 3758097085;
              }
            }
          }
          else
          {
            fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_se_get_reset_sig", ":", 2759, "", 0, "", "");
            v10 = 3758097084;
          }
        }
      }
    }
  }
  memset_s(&__s, __n, 0, __n);
  return v10;
}

uint64_t aks_se_get_reset_pubkey(uint64_t a1)
{
  int v1;
  size_t *v2;
  size_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  size_t v6;
  uint64_t v7;
  mach_port_t aks_client_connection;
  uint64_t v9;
  void *v10;
  size_t __count;
  _BYTE __src[4096];
  uint64_t input[2];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = v1;
  v6 = 4096;
  bzero(__src, 0x1000uLL);
  __count = 4096;
  v7 = 3758097090;
  if (v5 && v3)
  {
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      v9 = IOConnectCallMethod(aks_client_connection, 0x59u, input, 1u, 0, 0, 0, 0, __src, &__count);
      v6 = __count;
      if ((_DWORD)v9)
      {
        v7 = v9;
      }
      else if (__count - 4097 < 0xFFFFFFFFFFFFF000)
      {
        v7 = 3758604298;
      }
      else
      {
        v10 = calloc(__count, 1uLL);
        *v5 = v10;
        v6 = __count;
        if (v10)
        {
          *v3 = __count;
          memcpy(v10, __src, v6);
          v7 = 0;
          v6 = __count;
        }
        else
        {
          v7 = 3758097085;
        }
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_se_get_reset_pubkey", ":", 2791, "", 0, "", "");
      v6 = 4096;
      v7 = 3758097084;
    }
  }
  memset_s(__src, v6, 0, v6);
  return v7;
}

uint64_t aks_se_delete_reset_token(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x5Bu, input, 1u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_se_delete_reset_token", ":", 2815, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_se_support_in_rm(unsigned int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x5Eu, input, 1u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_se_support_in_rm", ":", 2832, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_se_support_in_rm_is_set(BOOL *a1)
{
  mach_port_t aks_client_connection;
  uint64_t result;
  uint32_t outputCnt;
  uint64_t output[2];

  output[1] = *MEMORY[0x24BDAC8D0];
  output[0] = 0;
  outputCnt = 1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    result = IOConnectCallMethod(aks_client_connection, 0x6Bu, 0, 0, 0, 0, output, &outputCnt, 0, 0);
    if (a1)
    {
      if (!(_DWORD)result)
        *a1 = output[0] != 0;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_se_support_in_rm_is_set", ":", 2848, "", 0, "", "");
    return 3758097084;
  }
  return result;
}

uint64_t aks_se_stage_stash()
{
  mach_port_t aks_client_connection;

  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x5Fu, 0, 0, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_se_stage_stash", ":", 2865, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_fv_lock_volume_bag()
{
  return aks_fv_set_protection(0);
}

uint64_t aks_fv_unwrap_vek()
{
  return aks_fv_unwrap_vek_with_acm();
}

uint64_t aks_fv_get_blob_state(uint64_t a1)
{
  uint64_t v1;
  _DWORD *v2;
  _DWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  mach_port_t aks_client_connection;
  mach_port_t v9;
  uint64_t v10;
  __int128 v12;
  int v13[2];
  _BYTE __s[4096];
  uint64_t v15;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v6 = v1;
  v15 = *MEMORY[0x24BDAC8D0];
  bzero(__s, 0x1000uLL);
  *(_QWORD *)&v12 = __s;
  *((_QWORD *)&v12 + 1) = &v15;
  *(_QWORD *)v13 = 4096;
  v7 = 3758097090;
  if (v5 && v3)
  {
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      v9 = aks_client_connection;
      if (der_utils_encode_fv_data(&v12, v5) && der_utils_encode_fv_params(&v12, v6))
      {
        v7 = 3758097098;
        if (ccder_blob_encode_tl())
        {
          v10 = IOConnectCallMethod(v9, 0x55u, 0, 0, *((const void **)&v12 + 1), (size_t)&v15 - *((_QWORD *)&v12 + 1), 0, 0, __s, (size_t *)v13);
          if (!(_DWORD)v10)
            v10 = decode_fv_blob_state((uint64_t)__s, *(uint64_t *)v13, v3);
          v7 = v10;
        }
      }
      else
      {
        v7 = 3758097098;
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_fv_get_blob_state", ":", 2900, "", 0, "", "");
      v7 = 3758097084;
    }
  }
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v7;
}

uint64_t aks_fv_get_last_known_gp_state(__int128 *a1)
{
  uint64_t v1;
  __int128 v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  char v7;

  v7 = 0;
  v5 = &v7;
  v6 = 1;
  v3 = 0uLL;
  v4 = 0;
  if (a1)
  {
    v3 = *a1;
    v4 = *((_QWORD *)a1 + 2);
    v1 = *((_QWORD *)&v3 + 1) | 0x10;
  }
  else
  {
    v1 = 16;
  }
  *((_QWORD *)&v3 + 1) = v1;
  return aks_fv_get_blob_state((uint64_t)&v3);
}

uint64_t aks_fv_get_size(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  mach_port_t aks_client_connection;
  mach_port_t v8;
  __int128 v10;
  uint32_t outputCnt;
  _BYTE __s[4096];
  uint64_t output;
  uint64_t input[2];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v4 = v1;
  input[1] = *MEMORY[0x24BDAC8D0];
  v5 = 3758097098;
  output = 0;
  input[0] = v6;
  outputCnt = 1;
  bzero(__s, 0x1000uLL);
  *(_QWORD *)&v10 = __s;
  *((_QWORD *)&v10 + 1) = &output;
  if (v3)
  {
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      v8 = aks_client_connection;
      if (der_utils_encode_fv_params(&v10, v4))
      {
        if (ccder_blob_encode_tl())
        {
          v5 = IOConnectCallMethod(v8, 0x4Eu, input, 1u, *((const void **)&v10 + 1), (size_t)&input[-1] - *((_QWORD *)&v10 + 1), &output, &outputCnt, 0, 0);
          if (!(_DWORD)v5)
            *v3 = output;
        }
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_fv_get_size", ":", 2943, "", 0, "", "");
      v5 = 3758097084;
    }
  }
  else
  {
    v5 = 3758097090;
  }
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v5;
}

uint64_t aks_fv_import(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  mach_port_t aks_client_connection;
  mach_port_t v12;
  uint64_t v13;
  __int128 v15;
  __int128 v16;
  size_t v17;
  _BYTE __s[4096];
  uint64_t input[2];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v8 = v1;
  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = v9;
  bzero(__s, 0x1000uLL);
  *(_QWORD *)&v16 = __s;
  *((_QWORD *)&v16 + 1) = input;
  v17 = 4096;
  v10 = 3758097090;
  if (v7 && v5)
  {
    aks_client_connection = get_aks_client_connection();
    if (!aks_client_connection)
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_fv_import", ":", 2971, "", 0, "", "");
      v10 = 3758097084;
      goto LABEL_14;
    }
    v12 = aks_client_connection;
    if (!ccder_blob_encode_body_tl()
      || !der_utils_encode_fv_data(&v16, v7)
      || !der_utils_encode_fv_params(&v16, v8)
      || !ccder_blob_encode_tl())
    {
      goto LABEL_12;
    }
    v13 = IOConnectCallMethod(v12, 0x4Fu, input, 1u, *((const void **)&v16 + 1), (size_t)input - *((_QWORD *)&v16 + 1), 0, 0, __s, &v17);
    if ((_DWORD)v13)
    {
      v10 = v13;
      goto LABEL_14;
    }
    *(_QWORD *)&v15 = __s;
    *((_QWORD *)&v15 + 1) = &__s[v17];
    if (!ccder_blob_decode_range())
      goto LABEL_12;
    if (!v3)
    {
      v10 = 0;
      goto LABEL_14;
    }
    v10 = 0;
    if ((der_utils_decode_fv_data(&v15, 0, v3) & 1) == 0)
LABEL_12:
      v10 = 3758097098;
  }
LABEL_14:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v10;
}

uint64_t aks_fv_get_verifier_size()
{
  return aks_fv_get_size(0);
}

uint64_t aks_fv_get_access_token_size()
{
  return aks_fv_get_size(0);
}

uint64_t aks_fv_new_verifier()
{
  return aks_fv_new_kek(0);
}

uint64_t aks_fv_rewrap_verifier()
{
  return aks_fv_rewrap_kek(0);
}

uint64_t aks_fv_new_access_token()
{
  _QWORD v1[3];

  v1[0] = 0;
  v1[1] = 2;
  v1[2] = 0;
  return aks_fv_new_vek((uint64_t)v1);
}

uint64_t aks_fv_new_unbound_access_token(char a1)
{
  uint64_t v1;
  _QWORD v3[3];

  v1 = 130;
  if ((a1 & 6) == 0)
    v1 = 2;
  v3[0] = 0;
  v3[1] = v1;
  v3[2] = 0;
  return aks_fv_new_vek((uint64_t)v3);
}

uint64_t aks_fv_bind_access_token()
{
  return aks_fv_set_protection(0);
}

uint64_t aks_fv_is_access_token_unbound(uint64_t a1, BOOL *a2)
{
  uint64_t result;
  _QWORD v4[3];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  memset(v4, 0, sizeof(v4));
  v10 = 0;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  v5 = 0u;
  if (!a2)
    return 3758097090;
  result = aks_fv_get_blob_state((uint64_t)v4);
  if (!(_DWORD)result)
  {
    if ((_DWORD)v5 == 1)
    {
      result = 0;
      *a2 = (DWORD1(v7) & 0x8000000) != 0;
    }
    else
    {
      return 3758604312;
    }
  }
  return result;
}

uint64_t aks_fv_load_access_token_as_system_keychain()
{
  return aks_fv_set_protection(0);
}

uint64_t aks_fv_verify_user_opts()
{
  return aks_fv_unwrap_vek_with_acm();
}

uint64_t aks_fv_grant_ownership(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v13;
  __int128 v14;
  _BYTE v15[4096];
  _BYTE v16[4096];
  uint64_t v17;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = v1;
  v17 = *MEMORY[0x24BDAC8D0];
  v11 = 3758097098;
  bzero(v16, 0x1000uLL);
  bzero(v15, 0x1000uLL);
  *(_QWORD *)&v14 = v16;
  *((_QWORD *)&v14 + 1) = &v17;
  *(_QWORD *)&v13 = v15;
  *((_QWORD *)&v13 + 1) = v16;
  if (der_utils_encode_fv_data(&v14, v9)
    && der_utils_encode_fv_data(&v14, v7)
    && ccder_blob_encode_tl()
    && der_utils_encode_fv_data(&v13, v5)
    && der_utils_encode_fv_data(&v13, v3)
    && ccder_blob_encode_tl())
  {
    return aks_fv_set_protection(v10);
  }
  return v11;
}

uint64_t aks_fv_owners_exist(uint64_t a1)
{
  return aks_fv_set_protection(a1);
}

uint64_t aks_fv_remove_external_kek_group(uint64_t a1)
{
  _QWORD v2[4];

  v2[3] = a1;
  memset(v2, 0, 24);
  return aks_fv_set_protection((uint64_t)v2);
}

uint64_t aks_fv_sidp_status(uint64_t a1)
{
  uint64_t v1;
  _BYTE *v2;
  _BYTE *v3;
  _BYTE *v4;
  _BYTE *v5;
  uint64_t v6;
  uint64_t result;
  _BYTE v8[16384];
  uint64_t v9;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v6 = v1;
  v9 = *MEMORY[0x24BDAC8D0];
  bzero(v8, 0x4000uLL);
  result = aks_fv_set_protection(v6);
  if (!(_DWORD)result)
  {
    if (ccder_decode_sequence_tl() && ccder_decode_tl())
    {
      __memcpy_chk();
      if (v5)
        *v5 = 0;
      if (v3)
        *v3 = 0;
      return 0;
    }
    else
    {
      return 3758097084;
    }
  }
  return result;
}

uint64_t aks_fv_stash_kek()
{
  return aks_fv_set_protection(0);
}

uint64_t aks_fv_stash_kek_with_secret(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = 8;
  if (a1)
    v1 = 12;
  v4 = 0;
  v5 = v1;
  v6 = 0;
  v2 = aks_fv_set_protection((uint64_t)&v4);
  syslog(6, "aks_fv_prot_cmd_stash_kek(%llu) = %d", v5, v2);
  return v2;
}

uint64_t aks_fv_commit_stashed_kek()
{
  uint64_t v0;

  v0 = aks_fv_set_protection(0);
  syslog(6, "aks_fv_prot_cmd_stash_commit = %d", v0);
  return v0;
}

uint64_t aks_fv_destroy_stashed_kek()
{
  uint64_t v0;

  v0 = aks_fv_set_protection(0);
  syslog(6, "aks_fv_prot_cmd_stash_destroy = %d", v0);
  return v0;
}

uint64_t aks_fv_verify_user()
{
  return aks_fv_unwrap_vek_with_acm();
}

uint64_t aks_fv_delete_verifier()
{
  return aks_fv_set_protection(0);
}

uint64_t aks_absinthe_collection(uint64_t a1)
{
  unsigned int v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  const char *v6;
  const char *v7;
  uint64_t v8;
  mach_port_t aks_client_connection;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  mach_port_t v15;
  const char *v16;
  uint64_t v17;
  void *v18;
  unsigned int inputStructCnt[3];
  size_t __count;
  _BYTE __src[32768];
  uint64_t input[2];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  input[1] = *MEMORY[0x24BDAC8D0];
  v8 = 3758097084;
  input[0] = v1;
  bzero(__src, 0x8000uLL);
  __count = 0x8000;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  if (v5)
  {
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      v15 = aks_client_connection;
      if (v7)
        v16 = v7;
      else
        v16 = "";
      aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 2, v10, v11, v12, v13, v14, (uint64_t)v16);
      v17 = IOConnectCallMethod(v15, 0x50u, input, 1u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, __src, &__count);
      if ((_DWORD)v17)
      {
        v8 = v17;
      }
      else
      {
        v18 = calloc(__count, 1uLL);
        *v5 = v18;
        if (v18)
        {
          memcpy(v18, __src, __count);
          v8 = 0;
          *v3 = (int)__count;
        }
        else
        {
          v8 = 3758097085;
        }
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_absinthe_collection", ":", 3220, "", 0, "", "");
    }
  }
  else
  {
    v8 = 3758097090;
  }
  memset_s(__src, 0x8000uLL, 0, 0x8000uLL);
  free(*(void **)&inputStructCnt[1]);
  return v8;
}

uint64_t aks_absinthe_generate(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, size_t *a7)
{
  uint64_t v7;
  mach_port_t aks_client_connection;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  mach_port_t v17;
  size_t v19;
  int v20;
  char *v21;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  v21 = 0;
  input[0] = a1;
  v20 = 0;
  v7 = 3758097090;
  if (a2 && a6 && a7)
  {
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      v17 = aks_client_connection;
      aks_pack_data(&v21, (unsigned int *)&v20, 2, v12, v13, v14, v15, v16, a2);
      v19 = *a7;
      v7 = IOConnectCallMethod(v17, 0x51u, input, 1u, v21, v20, 0, 0, a6, &v19);
      if (!(_DWORD)v7)
        *a7 = (int)v19;
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_absinthe_generate", ":", 3253, "", 0, "", "");
      v7 = 3758097084;
    }
  }
  free(v21);
  return v7;
}

uint64_t aks_drop_auxiliary_auth_by_uid(unsigned int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  input[0] = 0;
  input[1] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x53u, input, 2u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_drop_auxiliary_auth_by_uid", ":", 3280, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_drop_auxiliary_auth_by_handle(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  input[0] = 1;
  input[1] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x53u, input, 2u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_drop_auxiliary_auth_by_handle", ":", 3296, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_lower_iteration_count()
{
  mach_port_t aks_client_connection;

  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x5Cu, 0, 0, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_lower_iteration_count", ":", 3310, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_se_secret_drop(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x6Au, input, 1u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_se_secret_drop", ":", 3326, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_get_current_sep_measurement(uint64_t a1, uint64_t a2)
{
  if (a1 && a2 && !aks_get_internal_info_for_key(0xFFFFFFFFLL))
    der_dict_get_data((uint64_t)der_key_sep_measurement);
  free(0);
  return 3758097084;
}

uint64_t aks_get_internal_info(uint64_t a1)
{
  return aks_get_internal_info_for_key(a1);
}

uint64_t aks_get_seconds_since_passcode_change(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  time_t v4;
  time_t v5;
  uint64_t v7;
  uint64_t v8;
  void *v9;

  v3 = 3758097084;
  v8 = 0;
  v9 = 0;
  v7 = 0;
  if (!aks_get_internal_info_for_key(a1)
    && der_dict_get_number((uint64_t)der_key_passcode_change_time, (uint64_t)v9, (uint64_t)v9 + v8, (uint64_t)&v7))
  {
    if (a2)
    {
      v4 = time(0);
      v3 = 0;
      v5 = v4 - v7;
      if (v4 <= v7)
        v5 = 0;
      *a2 = v5;
    }
    else
    {
      v3 = 0;
    }
  }
  free(v9);
  return v3;
}

uint64_t aks_get_internal_state(uint64_t a1)
{
  int v1;
  char *v2;
  char *v3;
  uint64_t v4;
  mach_port_t aks_client_connection;
  uint64_t v6;
  rsize_t v7;
  rsize_t __n;
  _BYTE __s[4096];
  uint64_t input[2];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  input[1] = *MEMORY[0x24BDAC8D0];
  v4 = 3758097090;
  input[0] = v1;
  bzero(__s, 0x1000uLL);
  __n = 4096;
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_internal_state", ":", 3405, "", 0, "", "");
    v4 = 3758097084;
    goto LABEL_11;
  }
  if (!v3)
  {
LABEL_11:
    v7 = 4096;
    goto LABEL_9;
  }
  v6 = IOConnectCallMethod(aks_client_connection, 0x8Eu, input, 1u, 0, 0, 0, 0, __s, &__n);
  v7 = __n;
  if ((_DWORD)v6)
  {
    v4 = v6;
  }
  else if (__n - 4097 >= 0xFFFFFFFFFFFFF000)
  {
    if (decode_extended_state((uint64_t)__s, __n, v3))
      v4 = 3758097090;
    else
      v4 = 0;
    v7 = __n;
  }
LABEL_9:
  memset_s(__s, v7, 0, v7);
  return v4;
}

uint64_t aks_fairplay_wrap(const void *a1, size_t a2, void *a3, size_t *a4)
{
  uint64_t result;
  mach_port_t aks_client_connection;
  size_t v10;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = 266;
  result = 3758097090;
  if (a3 && a4)
  {
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      v10 = *a4;
      result = IOConnectCallMethod(aks_client_connection, 0x68u, input, 1u, a1, a2, 0, 0, a3, &v10);
      if (!(_DWORD)result)
        *a4 = (int)v10;
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_fairplay_wrap", ":", 3431, "", 0, "", "");
      return 3758097084;
    }
  }
  return result;
}

uint64_t _fairplay_generate_csk_internal(unsigned int a1, const void *a2, size_t a3, void *a4, size_t *a5)
{
  uint64_t result;
  mach_port_t aks_client_connection;
  size_t v11;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = ((unint64_t)a1 << 8) | 1;
  result = 3758097090;
  if (a4 && a5)
  {
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      v11 = *a5;
      result = IOConnectCallMethod(aks_client_connection, 0x68u, input, 1u, a2, a3, 0, 0, a4, &v11);
      if (!(_DWORD)result)
        *a5 = (int)v11;
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_fairplay_generate_csk_internal", ":", 3455, "", 0, "", "");
      return 3758097084;
    }
  }
  return result;
}

uint64_t aks_fairplay_generate_csk(const void *a1, size_t a2, void *a3, size_t *a4)
{
  return _fairplay_generate_csk_internal(0, a1, a2, a3, a4);
}

uint64_t aks_fairplay_generate_csk_v1(const void *a1, size_t a2, void *a3, size_t *a4)
{
  return _fairplay_generate_csk_internal(1u, a1, a2, a3, a4);
}

uint64_t aks_bak_get_beacon_internal(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  size_t v6;
  size_t v7;
  const void *v8;
  const void *v9;
  uint64_t v10;
  mach_port_t aks_client_connection;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  size_t v16;
  uint64_t input[2];
  _BYTE __s[16384];
  __int128 v19;
  _BYTE v20[28];
  uint64_t v21;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = v1;
  v21 = *MEMORY[0x24BDAC8D0];
  v19 = 0u;
  memset(v20, 0, sizeof(v20));
  bzero(__s, 0x4000uLL);
  v16 = 0x4000;
  input[0] = 1;
  input[1] = v10;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v12 = IOConnectCallMethod(aks_client_connection, 0x87u, input, 2u, v9, v7, 0, 0, __s, &v16);
    if ((_DWORD)v12)
    {
      v14 = v12;
    }
    else
    {
      __memcpy_chk();
      *v3 = 44;
      v13 = calloc(0x2CuLL, 1uLL);
      *v5 = v13;
      if (v13)
      {
        __memcpy_chk();
        v14 = 0;
      }
      else
      {
        v14 = 3758097085;
      }
    }
  }
  else
  {
    v14 = 3758097084;
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_bak_get_beacon_internal", ":", 3491, "", 0, "", "");
  }
  memset_s(__s, 0x4000uLL, 0, 0x4000uLL);
  return v14;
}

uint64_t aks_bak_get_beacon(int a1, unsigned int a2)
{
  uint64_t beacon_internal;

  beacon_internal = aks_bak_get_beacon_internal(a1 ^ 1u | ((unint64_t)a2 << 16));
  if ((_DWORD)beacon_internal)
    return beacon_internal;
  else
    return 3758604312;
}

uint64_t aks_bak_get_swizzler_internal(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  mach_port_t aks_client_connection;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  __int128 v14;
  __int128 v15;
  _OWORD *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  size_t v25;
  _BYTE __s[16384];
  _QWORD v27[6];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  int v37;
  uint64_t input[3];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  input[2] = *MEMORY[0x24BDAC8D0];
  input[0] = 2;
  input[1] = v1;
  v37 = 0;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v28 = 0u;
  memset(v27, 0, sizeof(v27));
  bzero(__s, 0x4000uLL);
  v25 = 0x4000;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v11 = IOConnectCallMethod(aks_client_connection, 0x87u, input, 2u, 0, 0, 0, 0, __s, &v25);
    if ((_DWORD)v11)
    {
      v12 = v11;
    }
    else
    {
      v12 = 3758097085;
      __memcpy_chk();
      v13 = calloc(0x28uLL, 1uLL);
      *v9 = v13;
      if (v13)
      {
        *v7 = 40;
        v14 = *(_OWORD *)&v27[1];
        v15 = *(_OWORD *)&v27[3];
        v13[4] = v27[5];
        *(_OWORD *)v13 = v14;
        *((_OWORD *)v13 + 1) = v15;
        v16 = calloc(0x91uLL, 1uLL);
        *v5 = v16;
        if (v16)
        {
          v12 = 0;
          *v3 = 145;
          v17 = v29;
          *v16 = v28;
          v16[1] = v17;
          v18 = v30;
          v19 = v31;
          v20 = v33;
          v16[4] = v32;
          v16[5] = v20;
          v16[2] = v18;
          v16[3] = v19;
          v21 = v34;
          v22 = v35;
          v23 = v36;
          *((_BYTE *)v16 + 144) = v37;
          v16[7] = v22;
          v16[8] = v23;
          v16[6] = v21;
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_bak_get_swizzler_internal", ":", 3551, "", 0, "", "");
    v12 = 3758097084;
  }
  memset_s(__s, 0x4000uLL, 0, 0x4000uLL);
  memset_s(v27, 0xC4uLL, 0, 0xC4uLL);
  return v12;
}

uint64_t aks_bak_get_swizzler()
{
  return aks_bak_get_swizzler_internal(0);
}

uint64_t aks_test_stashed_kek(uint64_t a1)
{
  mach_port_t akstest_client_connection;

  akstest_client_connection = get_akstest_client_connection();
  if (akstest_client_connection)
    return IOConnectCallMethod(akstest_client_connection, 0xCu, 0, 0, *(const void **)a1, *(_QWORD *)(a1 + 8), 0, 0, 0, 0);
  else
    return 3758097084;
}

uint64_t aks_get_dsme_key(uint64_t a1)
{
  uint64_t v1;
  size_t *v2;
  size_t *v3;
  _QWORD *v4;
  mach_port_t aks_client_connection;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  size_t v9;
  size_t __count;
  _BYTE __src[16384];
  uint64_t v13;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v4 = (_QWORD *)v1;
  v13 = *MEMORY[0x24BDAC8D0];
  bzero(__src, 0x4000uLL);
  __count = 0x4000;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v6 = 3758097090;
    if (v4 && v3)
    {
      v7 = IOConnectCallMethod(aks_client_connection, 0x96u, 0, 0, 0, 0, 0, 0, __src, &__count);
      if ((_DWORD)v7)
      {
        v6 = v7;
      }
      else
      {
        v8 = calloc(__count, 1uLL);
        *v4 = v8;
        if (v8)
        {
          v9 = __count;
          *v3 = __count;
          memcpy(v8, __src, v9);
          v6 = 0;
        }
        else
        {
          v6 = 3758097085;
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_dsme_key", ":", 3600, "", 0, "", "");
    v6 = 3758097084;
  }
  memset_s(__src, 0x4000uLL, 0, 0x4000uLL);
  return v6;
}

BOOL aks_bag_in_xart(uint64_t a1, uint64_t a2)
{
  return a2 == 4 || a2 == 32;
}

uint64_t aks_prewarm_sps()
{
  mach_port_t aks_client_connection;

  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x73u, 0, 0, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_prewarm_sps", ":", 3627, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_sealed_hashes_set(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  mach_port_t aks_client_connection;
  mach_port_t v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  char *v10;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x24BDAC8D0];
  v4 = 4294967285;
  if (a3 && a4 <= 0x30)
  {
    v4 = 3758097084;
    aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      v6 = aks_client_connection;
      ccder_sizeof_raw_octet_string();
      ccder_sizeof_uint64();
      ccder_sizeof_raw_octet_string();
      v7 = ccder_sizeof();
      v8 = v7;
      MEMORY[0x24BDAC7A8](v7);
      v10 = (char *)v12 - v9;
      bzero((char *)v12 - v9, v8);
      ccder_encode_raw_octet_string();
      ccder_encode_uint64();
      ccder_encode_raw_octet_string();
      if ((char *)ccder_encode_constructed_tl() == v10)
        return IOConnectCallMethod(v6, 0x72u, 0, 0, v10, v8, 0, 0, 0, 0);
      else
        return 3758097090;
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_sealed_hashes_set", ":", 3644, "", 0, "", "");
    }
  }
  return v4;
}

uint64_t aks_measure_and_seal_cryptex_manifest(const void *a1, size_t a2)
{
  mach_port_t aks_client_connection;

  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x90u, 0, 0, a1, a2, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_measure_and_seal_cryptex_manifest", ":", 3674, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_seal_cryptex_manifest_lock()
{
  mach_port_t aks_client_connection;

  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x95u, 0, 0, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_seal_cryptex_manifest_lock", ":", 3688, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_lkgp_recover(int a1, uint64_t a2, uint64_t a3)
{
  mach_port_t aks_client_connection;
  uint64_t input[4];

  input[3] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  input[1] = a2;
  input[2] = a3;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x85u, input, 3u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_lkgp_recover", ":", 3704, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_memento_efface_blob(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x8Au, input, 1u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_memento_efface_blob", ":", 3720, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_memento_get_state(uint64_t a1)
{
  int v1;
  _BYTE *v2;
  _BYTE *v3;
  mach_port_t aks_client_connection;
  uint64_t v5;
  rsize_t v6;
  uint64_t v7;
  rsize_t __n;
  _BYTE __s[4096];
  uint64_t input[2];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = v1;
  bzero(__s, 0x1000uLL);
  __n = 4096;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v5 = IOConnectCallMethod(aks_client_connection, 0x8Bu, input, 1u, 0, 0, 0, 0, __s, &__n);
    v6 = __n;
    if ((_DWORD)v5)
    {
      v7 = v5;
    }
    else
    {
      v7 = 3758097090;
      if (__n - 4097 >= 0xFFFFFFFFFFFFF000)
      {
        if (decode_memento_state((uint64_t)__s, __n, v3))
          v7 = 3758097090;
        else
          v7 = 0;
        v6 = __n;
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_memento_get_state", ":", 3738, "", 0, "", "");
    v7 = 3758097084;
    v6 = 4096;
  }
  memset_s(__s, v6, 0, v6);
  return v7;
}

uint64_t aks_set_jcop_supports_updated_kud_policy()
{
  mach_port_t aks_client_connection;
  uint64_t input;

  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x89u, &input, 0, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_set_jcop_supports_updated_kud_policy", ":", 3758, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_set_cx_window(uint64_t a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x97u, input, 1u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_set_cx_window", ":", 3774, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_get_cx_window(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  mach_port_t aks_client_connection;
  mach_port_t v4;
  uint64_t result;
  size_t v6;
  _QWORD outputStruct[513];

  v1 = MEMORY[0x24BDAC7A8](a1);
  outputStruct[512] = *MEMORY[0x24BDAC8D0];
  v6 = 4096;
  if (!v1)
    return 4294967285;
  v2 = (_QWORD *)v1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v4 = aks_client_connection;
    bzero(outputStruct, 0x1000uLL);
    result = IOConnectCallMethod(v4, 0x98u, 0, 0, 0, 0, 0, 0, outputStruct, &v6);
    if (!(_DWORD)result)
    {
      if (v6 == 8)
      {
        result = 0;
        *v2 = outputStruct[0];
      }
      else
      {
        return 3758604298;
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_cx_window", ":", 3791, "", 0, "", "");
    return 3758097084;
  }
  return result;
}

uint64_t AKSIdentityCreateFirst(const __CFUUID *a1, const __CFData *a2, CFTypeRef *a3)
{
  return AKSIdentityCreateInternal(a1, a2, -1, 0, a3);
}

uint64_t AKSIdentityCreateInternal(const __CFUUID *a1, const __CFData *a2, int a3, const __CFData *a4, CFTypeRef *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  mach_port_t aks_client_connection;
  uint64_t v15;
  uint32_t outputCnt;
  unsigned int inputStructCnt[3];
  CFUUIDBytes v19;
  uint64_t output;
  uint64_t input[3];

  input[2] = *MEMORY[0x24BDAC8D0];
  v19 = CFUUIDGetUUIDBytes(a1);
  input[0] = a3;
  input[1] = 0;
  output = 0;
  outputCnt = 1;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  if (a2)
  {
    CFDataGetBytePtr(a2);
    CFDataGetLength(a2);
    if (!a4)
      goto LABEL_5;
    goto LABEL_3;
  }
  if (a4)
  {
LABEL_3:
    CFDataGetBytePtr(a4);
    CFDataGetLength(a4);
  }
LABEL_5:
  aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 3, v9, v10, v11, v12, v13, (uint64_t)&v19);
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "AKSIdentityCreateInternal", ":", 109, "", 0, "", "");
    free(*(void **)&inputStructCnt[1]);
    v15 = 3758097084;
    goto LABEL_7;
  }
  v15 = IOConnectCallMethod(aks_client_connection, 0x76u, input, 2u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], &output, &outputCnt, 0, 0);
  free(*(void **)&inputStructCnt[1]);
  if ((_DWORD)v15)
  {
LABEL_7:
    create_error((CFErrorRef)v15, a5);
    return 0;
  }
  return 1;
}

uint64_t AKSIdentityMigrateFirst(const __CFUUID *a1, CFTypeRef *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  mach_port_t aks_client_connection;
  uint64_t v9;
  int v11;
  char *v12;
  CFUUIDBytes v13;

  v13 = CFUUIDGetUUIDBytes(a1);
  v12 = 0;
  v11 = 0;
  aks_pack_data(&v12, (unsigned int *)&v11, 1, v3, v4, v5, v6, v7, (uint64_t)&v13);
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "AKSIdentityMigrateFirst", ":", 147, "", 0, "", "");
    free(v12);
    v9 = 3758097084;
    goto LABEL_3;
  }
  v9 = IOConnectCallMethod(aks_client_connection, 0x7Fu, 0, 0, v12, v11, 0, 0, 0, 0);
  free(v12);
  if ((_DWORD)v9)
  {
LABEL_3:
    create_error((CFErrorRef)v9, a2);
    return 0;
  }
  return 1;
}

uint64_t AKSIdentityCreate(const __CFUUID *a1, const __CFData *a2, int a3, const __CFData *a4, CFTypeRef *a5)
{
  int v5;

  if (a3 >= 10)
    v5 = -a3;
  else
    v5 = -1;
  return AKSIdentityCreateInternal(a1, a2, v5, a4, a5);
}

uint64_t AKSIdentityMigrate(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  create_error((CFErrorRef)0xE00002E6, a4);
  return 0;
}

uint64_t AKSIdentityDelete(const __CFUUID *a1, CFTypeRef *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  mach_port_t aks_client_connection;
  uint64_t v9;
  int v11;
  char *v12;
  CFUUIDBytes v13;

  v13 = CFUUIDGetUUIDBytes(a1);
  v12 = 0;
  v11 = 0;
  aks_pack_data(&v12, (unsigned int *)&v11, 1, v3, v4, v5, v6, v7, (uint64_t)&v13);
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "AKSIdentityDelete", ":", 195, "", 0, "", "");
    free(v12);
    v9 = 3758097084;
    goto LABEL_3;
  }
  v9 = IOConnectCallMethod(aks_client_connection, 0x77u, 0, 0, v12, v11, 0, 0, 0, 0);
  free(v12);
  if ((_DWORD)v9)
  {
LABEL_3:
    create_error((CFErrorRef)v9, a2);
    return 0;
  }
  return 1;
}

uint64_t AKSIdentityChangePasscode(int a1, CFDataRef theData, const __CFData *a3, CFTypeRef *a4)
{
  const UInt8 *BytePtr;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  mach_port_t aks_client_connection;
  uint64_t v14;
  uint64_t v15;
  int v17;
  char *v18;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  v17 = 0;
  v18 = 0;
  input[0] = -a1;
  BytePtr = CFDataGetBytePtr(theData);
  CFDataGetLength(theData);
  CFDataGetBytePtr(a3);
  CFDataGetLength(a3);
  aks_pack_data(&v18, (unsigned int *)&v17, 2, v8, v9, v10, v11, v12, (uint64_t)BytePtr);
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "AKSIdentityChangePasscodeInternal", ":", 220, "", 0, "", "");
    free(v18);
    v15 = 3758097084;
    goto LABEL_3;
  }
  v14 = 1;
  v15 = IOConnectCallMethod(aks_client_connection, 0x7Cu, input, 1u, v18, v17, 0, 0, 0, 0);
  free(v18);
  if ((_DWORD)v15)
  {
LABEL_3:
    create_error((CFErrorRef)v15, a4);
    return 0;
  }
  return v14;
}

uint64_t AKSIdentitySetOption(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  create_error((CFErrorRef)0xE00002E6, a3);
  return 0;
}

uint64_t AKSIdentityGetOption(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  create_error((CFErrorRef)0xE00002E6, a3);
  return 0;
}

uint64_t AKSIdentityLoad(const __CFUUID *a1, int a2, CFTypeRef *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  mach_port_t aks_client_connection;
  uint64_t v11;
  uint64_t v12;
  int v14;
  char *v15;
  CFUUIDBytes v16;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  if (a2 >= 10)
    v4 = -a2;
  else
    v4 = -1;
  v16 = CFUUIDGetUUIDBytes(a1);
  v15 = 0;
  v14 = 0;
  input[0] = v4;
  aks_pack_data(&v15, (unsigned int *)&v14, 1, v5, v6, v7, v8, v9, (uint64_t)&v16);
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "AKSIdentityLoadInternal", ":", 276, "", 0, "", "");
    free(v15);
    v12 = 3758097084;
    goto LABEL_6;
  }
  v11 = 1;
  v12 = IOConnectCallMethod(aks_client_connection, 0x78u, input, 1u, v15, v14, 0, 0, 0, 0);
  free(v15);
  if ((_DWORD)v12)
  {
LABEL_6:
    create_error((CFErrorRef)v12, a3);
    return 0;
  }
  return v11;
}

uint64_t AKSIdentityLogin(const __CFUUID *a1, const __CFData *a2, int a3, CFTypeRef *a4)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;

  result = AKSIdentityLoad(a1, a3, a4);
  if ((_DWORD)result)
  {
    if (a3 >= 10)
      v13 = -a3;
    else
      v13 = -1;
    if ((AKSIdentityUnlockInternal(v13, a2, a4, v8, v9, v10, v11, v12) & 1) != 0)
    {
      return 1;
    }
    else
    {
      AKSIdentityUnload(a3, 0);
      return 0;
    }
  }
  return result;
}

uint64_t AKSIdentityUnlockSession(int a1, const __CFData *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  if (a1 >= 10)
    v8 = -a1;
  else
    v8 = -1;
  return AKSIdentityUnlockInternal(v8, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t AKSIdentityUnload(int a1, CFTypeRef *a2)
{
  int v3;
  mach_port_t aks_client_connection;
  uint64_t v5;
  uint64_t v6;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  if (a1 >= 10)
    v3 = -a1;
  else
    v3 = -1;
  input[0] = v3;
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "AKSIdentityUnloadInternal", ":", 337, "", 0, "", "");
    v6 = 3758097084;
    goto LABEL_6;
  }
  v5 = 1;
  v6 = IOConnectCallMethod(aks_client_connection, 0x79u, input, 1u, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)v6)
  {
LABEL_6:
    create_error((CFErrorRef)v6, a2);
    return 0;
  }
  return v5;
}

BOOL AKSIdentityCopyVolumeCookie(int a1, CFUUIDRef uuid, CFDataRef *a3, CFTypeRef *a4)
{
  int v6;
  __CFError *v7;
  int v8;
  CFUUIDBytes v10;
  size_t v11;
  UInt8 *v12;

  if (a1 >= 10)
    v6 = -a1;
  else
    v6 = -1;
  v11 = 0;
  v12 = 0;
  if (uuid)
  {
    v10 = CFUUIDGetUUIDBytes(uuid);
    v7 = (__CFError *)aks_copy_volume_cookie_persona(v6, (uint64_t)&v10, &v12, &v11);
  }
  else
  {
    v7 = (__CFError *)aks_copy_volume_cookie(v6, &v12, &v11);
  }
  v8 = (int)v7;
  if ((_DWORD)v7)
  {
    create_error(v7, a4);
  }
  else
  {
    *a3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], v12, v11);
    aks_dealloc(v12, v11);
  }
  return v8 == 0;
}

BOOL AKSVolumeMapByUUID(const __CFUUID *a1, int a2, const __CFUUID *a3, const __CFData *a4, CFTypeRef *a5)
{
  __CFError *v9;
  int v10;
  CFUUIDBytes v12;

  v12 = CFUUIDGetUUIDBytes(a1);
  if (a3)
  {
    CFUUIDGetUUIDBytes(a3);
    CFDataGetBytePtr(a4);
    CFDataGetLength(a4);
    v9 = (__CFError *)aks_set_keybag_for_volume_with_cookie_persona(a2, (uint64_t)&v12, 0);
  }
  else
  {
    CFDataGetBytePtr(a4);
    CFDataGetLength(a4);
    v9 = (__CFError *)aks_set_keybag_for_volume_with_cookie(a2, (uint64_t)&v12, 0);
  }
  v10 = (int)v9;
  if ((_DWORD)v9)
    create_error(v9, a5);
  return v10 == 0;
}

BOOL AKSVolumeUnmapByUUID(const __CFUUID *a1, CFTypeRef *a2)
{
  __CFError *v3;
  int v4;
  CFUUIDBytes v6;

  v6 = CFUUIDGetUUIDBytes(a1);
  v3 = (__CFError *)aks_set_keybag_for_volume(-1, (uint64_t)&v6, 0);
  v4 = (int)v3;
  if ((_DWORD)v3)
    create_error(v3, a2);
  return v4 == 0;
}

BOOL AKSVolumeMap(const __CFString *a1, int a2, const __CFUUID *a3, CFTypeRef *a4)
{
  const __CFUUID *v8;
  const __CFData *v9;
  UInt8 *v10;
  const __CFData *v11;
  _BOOL8 v12;
  uint64_t v14;
  CFDataRef theData;
  size_t __size;
  char buffer[1024];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  theData = 0;
  __size = 0;
  bzero(buffer, 0x400uLL);
  if (!CFStringGetCString(a1, buffer, 1024, 0x8000100u))
  {
    create_error((CFErrorRef)0xE00002C2, a4);
    v12 = 0;
    v10 = 0;
    v8 = 0;
    goto LABEL_11;
  }
  v8 = copy_apfs_volume_uuid_for_disk(a1, a4);
  if (!v8)
    goto LABEL_18;
  if (APFSVolumePayloadGet())
  {
    if (AKSIdentityCopyVolumeCookie(a2, a3, &theData, a4))
    {
      v9 = theData;
      CFDataGetBytePtr(theData);
      CFDataGetLength(v9);
      if (!APFSVolumePayloadSet())
      {
        v10 = 0;
LABEL_10:
        v12 = AKSVolumeMapByUUID(v8, a2, a3, v9, a4);
        goto LABEL_11;
      }
      create_error((CFErrorRef)0xE007C00ALL, a4);
    }
LABEL_18:
    v12 = 0;
    v10 = 0;
    goto LABEL_11;
  }
  v10 = (UInt8 *)malloc(__size);
  if (APFSVolumePayloadGet())
  {
    v14 = 3758604298;
  }
  else
  {
    v11 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], v10, __size, (CFAllocatorRef)*MEMORY[0x24BDBD258]);
    theData = v11;
    if (v11)
    {
      v9 = v11;
      goto LABEL_10;
    }
    v14 = 3758097085;
  }
  create_error((CFErrorRef)v14, a4);
  v12 = 0;
LABEL_11:
  free(v10);
  if (theData)
    CFRelease(theData);
  if (v8)
    CFRelease(v8);
  return v12;
}

CFErrorRef create_error(CFErrorRef result, CFTypeRef *a2)
{
  int v3;

  if (a2)
  {
    v3 = (int)result;
    if (*a2)
    {
      CFRelease(*a2);
      *a2 = 0;
    }
    result = CFErrorCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], (CFErrorDomain)*MEMORY[0x24BDBD388], v3, 0);
    *a2 = result;
  }
  return result;
}

CFUUIDRef copy_apfs_volume_uuid_for_disk(const __CFString *a1, CFTypeRef *a2)
{
  uint64_t v4;
  mach_port_t v5;
  const __CFDictionary *v6;
  io_service_t MatchingService;
  io_registry_entry_t v8;
  const __CFAllocator *v9;
  uint64_t v10;
  const __CFString *Value;
  const __CFString *v12;
  CFTypeID v13;
  CFUUIDRef v14;
  CFMutableDictionaryRef properties;
  char buffer[1024];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  bzero(buffer, 0x400uLL);
  properties = 0;
  if (CFStringGetCString(a1, buffer, 1024, 0x8000100u))
  {
    v4 = 3758097090;
    v5 = *MEMORY[0x24BDD8B20];
    v6 = IOBSDNameMatching(*MEMORY[0x24BDD8B20], 0, buffer);
    MatchingService = IOServiceGetMatchingService(v5, v6);
    if (!MatchingService)
      goto LABEL_13;
    v8 = MatchingService;
    if (!IOObjectConformsTo(MatchingService, "AppleAPFSVolume"))
      goto LABEL_13;
    v9 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v10 = IORegistryEntryCreateCFProperties(v8, &properties, (CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
    if ((_DWORD)v10)
    {
      v4 = v10;
      goto LABEL_13;
    }
    Value = (const __CFString *)CFDictionaryGetValue(properties, CFSTR("UUID"));
    if (Value)
    {
      v12 = Value;
      v13 = CFGetTypeID(Value);
      if (v13 == CFStringGetTypeID())
      {
        v14 = CFUUIDCreateFromString(v9, v12);
        v4 = 3758604298;
        if (v14)
          goto LABEL_8;
        goto LABEL_13;
      }
    }
  }
  v4 = 3758604298;
LABEL_13:
  create_error((CFErrorRef)v4, a2);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s Failed to get volume UUID for %s%s\n", "aks", "", "", "", "copy_apfs_volume_uuid_for_disk", ":", 422, "", 0, "", buffer, "");
  v14 = 0;
LABEL_8:
  if (properties)
    CFRelease(properties);
  return v14;
}

const __CFUUID *AKSVolumeUnmap(const __CFString *a1, CFTypeRef *a2)
{
  const __CFUUID *result;
  const __CFUUID *v4;
  _BOOL8 v5;

  result = copy_apfs_volume_uuid_for_disk(a1, a2);
  if (result)
  {
    v4 = result;
    v5 = AKSVolumeUnmapByUUID(result, a2);
    CFRelease(v4);
    return (const __CFUUID *)v5;
  }
  return result;
}

uint64_t AKSIdentityCopyGroupUUIDBytes(int a1, _OWORD *a2, CFTypeRef *a3)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t configuration;
  CFTypeID v8;
  void *value;
  CFDictionaryRef v11;

  v4 = 3758097090;
  value = 0;
  v11 = 0;
  if (a2)
  {
    v6 = a1 >= 10 ? -a1 : 0xFFFFFFFFLL;
    configuration = aks_get_configuration(v6);
    if ((_DWORD)configuration)
    {
      v4 = configuration;
    }
    else if (CFDictionaryGetValueIfPresent(v11, CFSTR("GroupUUID"), (const void **)&value))
    {
      v8 = CFGetTypeID(value);
      if (v8 == CFDataGetTypeID())
      {
        if (CFDataGetLength((CFDataRef)value) == 16)
        {
          v4 = 0;
          *a2 = *(_OWORD *)CFDataGetBytePtr((CFDataRef)value);
        }
        else
        {
          v4 = 3758604298;
          fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s invalid uuid size%s\n", "aks", "", "", "", "AKSIdentityCopyGroupUUIDBytes");
        }
      }
      else
      {
        v4 = 3758604298;
        fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s invalid type%s\n", "aks", "", "", "", "AKSIdentityCopyGroupUUIDBytes");
      }
    }
    else
    {
      v4 = 3758097136;
    }
    if (v11)
    {
      CFRelease(v11);
      v11 = 0;
    }
    if (!(_DWORD)v4)
      return 1;
  }
  create_error((CFErrorRef)v4, a3);
  return 0;
}

uint64_t AKSIdentityCopyGroupUUID(int a1, CFUUIDRef *a2, CFTypeRef *a3)
{
  uint64_t result;
  CFUUIDRef v6;
  uint64_t v7;
  CFUUIDBytes v8;

  v8 = (CFUUIDBytes)0;
  if (!a2)
  {
    v7 = 3758097090;
LABEL_8:
    create_error((CFErrorRef)v7, a3);
    return 0;
  }
  result = AKSIdentityCopyGroupUUIDBytes(a1, &v8, a3);
  if (!(_DWORD)result)
    return result;
  v6 = CFUUIDCreateFromUUIDBytes((CFAllocatorRef)*MEMORY[0x24BDBD240], v8);
  *a2 = v6;
  if (!v6)
  {
    v7 = 3758097085;
    goto LABEL_8;
  }
  return 1;
}

uint64_t AKSIdentityCopyUserUUIDBytes(int a1, _OWORD *a2, CFTypeRef *a3)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t configuration;
  CFTypeID v8;
  void *value;
  CFDictionaryRef v11;

  v4 = 3758097090;
  value = 0;
  v11 = 0;
  if (a2)
  {
    v6 = a1 >= 10 ? -a1 : 0xFFFFFFFFLL;
    configuration = aks_get_configuration(v6);
    if ((_DWORD)configuration)
    {
      v4 = configuration;
    }
    else if (CFDictionaryGetValueIfPresent(v11, CFSTR("UserUUID"), (const void **)&value))
    {
      v8 = CFGetTypeID(value);
      if (v8 == CFDataGetTypeID())
      {
        if (CFDataGetLength((CFDataRef)value) == 16)
        {
          v4 = 0;
          *a2 = *(_OWORD *)CFDataGetBytePtr((CFDataRef)value);
        }
        else
        {
          v4 = 3758604298;
          fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s invalid uuid size%s\n", "aks", "", "", "", "AKSIdentityCopyUserUUIDBytes");
        }
      }
      else
      {
        v4 = 3758604298;
        fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s invalid type%s\n", "aks", "", "", "", "AKSIdentityCopyUserUUIDBytes");
      }
    }
    else
    {
      v4 = 3758097136;
    }
    if (v11)
    {
      CFRelease(v11);
      v11 = 0;
    }
    if (!(_DWORD)v4)
      return 1;
  }
  create_error((CFErrorRef)v4, a3);
  return 0;
}

uint64_t AKSIdentityCopyUserUUID(int a1, CFUUIDRef *a2, CFTypeRef *a3)
{
  uint64_t result;
  CFUUIDRef v6;
  uint64_t v7;
  CFUUIDBytes v8;

  v8 = (CFUUIDBytes)0;
  if (!a2)
  {
    v7 = 3758097090;
LABEL_8:
    create_error((CFErrorRef)v7, a3);
    return 0;
  }
  result = AKSIdentityCopyUserUUIDBytes(a1, &v8, a3);
  if (!(_DWORD)result)
    return result;
  v6 = CFUUIDCreateFromUUIDBytes((CFAllocatorRef)*MEMORY[0x24BDBD240], v8);
  *a2 = v6;
  if (!v6)
  {
    v7 = 3758097085;
    goto LABEL_8;
  }
  return 1;
}

uint64_t AKSIdentityUnlock(CFDataRef theData, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return AKSIdentityUnlockInternal(-3, theData, a2, a4, a5, a6, a7, a8);
}

uint64_t AKSIdentityUnlockInternal(int a1, CFDataRef theData, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const UInt8 *BytePtr;
  mach_port_t aks_client_connection;
  uint64_t v12;
  uint64_t v13;
  int v15;
  char *v16;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  v15 = 0;
  v16 = 0;
  input[0] = a1;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    CFDataGetLength(theData);
  }
  else
  {
    BytePtr = 0;
  }
  aks_pack_data(&v16, (unsigned int *)&v15, 1, a4, a5, a6, a7, a8, (uint64_t)BytePtr);
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "AKSIdentityUnlockInternal", ":", 567, "", 0, "", "");
    free(v16);
    v13 = 3758097084;
    goto LABEL_6;
  }
  v12 = 1;
  v13 = IOConnectCallMethod(aks_client_connection, 0x7Bu, input, 1u, v16, v15, 0, 0, 0, 0);
  free(v16);
  if ((_DWORD)v13)
  {
LABEL_6:
    create_error((CFErrorRef)v13, a3);
    return 0;
  }
  return v12;
}

uint64_t AKSIdentityLock(CFTypeRef *a1)
{
  return AKSIdentityLockInternal(-3, a1);
}

uint64_t AKSIdentityLockInternal(int a1, CFTypeRef *a2)
{
  mach_port_t aks_client_connection;
  uint64_t v4;
  uint64_t v5;
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "AKSIdentityLockInternal", ":", 620, "", 0, "", "");
    v5 = 3758097084;
    goto LABEL_3;
  }
  v4 = 1;
  v5 = IOConnectCallMethod(aks_client_connection, 0x7Au, input, 1u, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)v5)
  {
LABEL_3:
    create_error((CFErrorRef)v5, a2);
    return 0;
  }
  return v4;
}

uint64_t AKSIdentityLockSession(int a1, CFTypeRef *a2)
{
  int v2;

  if (a1 >= 10)
    v2 = -a1;
  else
    v2 = -1;
  return AKSIdentityLockInternal(v2, a2);
}

uint64_t AKSIdentityGetLockState(uint64_t a1, CFTypeRef *a2)
{
  create_error((CFErrorRef)0xE00002E6, a2);
  return 0;
}

BOOL AKSIdentityAddPersona(int a1, const __CFData *a2, CFUUIDRef uuid, CFTypeRef *a4)
{
  int v6;
  const UInt8 *BytePtr;
  uint64_t Length;
  __CFError *v9;
  int v10;
  CFUUIDBytes v12;

  if (a1 >= 10)
    v6 = -a1;
  else
    v6 = -1;
  v12 = CFUUIDGetUUIDBytes(uuid);
  BytePtr = CFDataGetBytePtr(a2);
  Length = CFDataGetLength(a2);
  v9 = (__CFError *)aks_keybag_persona_create(v6, (uint64_t)BytePtr, Length, (uint64_t)&v12);
  v10 = (int)v9;
  if ((_DWORD)v9)
    create_error(v9, a4);
  return v10 == 0;
}

BOOL AKSIdentityDeletePersona(int a1, CFUUIDRef uuid, CFTypeRef *a3)
{
  int v4;
  __CFError *v5;
  int v6;
  CFUUIDBytes v8;

  if (a1 >= 10)
    v4 = -a1;
  else
    v4 = -1;
  v8 = CFUUIDGetUUIDBytes(uuid);
  v5 = (__CFError *)aks_keybag_persona_delete(v4, (uint64_t)&v8);
  v6 = (int)v5;
  if ((_DWORD)v5)
    create_error(v5, a3);
  return v6 == 0;
}

uint64_t AKSIdentityOperation(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  create_error((CFErrorRef)0xE00002E6, a4);
  return 0;
}

uint64_t AKSIdentityRemoteSession(CFTypeRef *a1)
{
  create_error((CFErrorRef)0xE00002E6, a1);
  return 0;
}

uint64_t AKSIdentityRegisterUnlockToken(CFTypeRef *a1)
{
  create_error((CFErrorRef)0xE00002E6, a1);
  return 0;
}

uint64_t AKSIdentityReset(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  create_error((CFErrorRef)0xE00002E6, a3);
  return 0;
}

uint64_t AKSIdentityUnlockWithToken(CFTypeRef *a1)
{
  create_error((CFErrorRef)0xE00002E6, a1);
  return 0;
}

uint64_t AKSIdentityList(uint64_t a1, CFTypeRef *a2)
{
  create_error((CFErrorRef)0xE00002E6, a2);
  return 0;
}

uint64_t AKSBackupEnableForVolume(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  create_error((CFErrorRef)0xE00002E6, a5);
  return 0;
}

uint64_t AKSBackupDisableForVolume(uint64_t a1, CFTypeRef *a2)
{
  create_error((CFErrorRef)0xE00002E6, a2);
  return 0;
}

uint64_t AKSBackupCopyBackupBagUUIDForVolume(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  create_error((CFErrorRef)0xE00002E6, a3);
  return 0;
}

uint64_t AKSBackupCopyBackupBagUUIDForBag(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  create_error((CFErrorRef)0xE00002E6, a3);
  return 0;
}

uint64_t AKSIdentityGetPrimary(CFUUIDRef *a1, CFUUIDRef *a2, CFTypeRef *a3)
{
  mach_port_t aks_client_connection;
  uint64_t v7;
  uint64_t v8;
  const __CFAllocator *v9;
  CFUUIDRef v10;
  CFUUIDRef v11;
  int v13[2];
  uint64_t input;
  _QWORD v15[2];
  CFUUIDBytes v16;
  CFUUIDBytes __s;
  _OWORD outputStruct[16];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  memset(outputStruct, 0, sizeof(outputStruct));
  *(_QWORD *)v13 = 256;
  *(_QWORD *)&__s.byte0 = 0;
  *(_QWORD *)&__s.byte8 = 0;
  *(_QWORD *)&v16.byte0 = 0;
  *(_QWORD *)&v16.byte8 = 0;
  v15[0] = 0;
  v15[1] = 0;
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "AKSIdentityGetPrimary", ":", 779, "", 0, "", "");
    v8 = 3758097084;
    goto LABEL_12;
  }
  v7 = IOConnectCallMethod(aks_client_connection, 0x7Du, &input, 0, 0, 0, 0, 0, outputStruct, (size_t *)v13);
  if ((_DWORD)v7)
  {
    v8 = v7;
    goto LABEL_12;
  }
  v8 = 3758604298;
  if (v13[1])
  {
LABEL_12:
    create_error((CFErrorRef)v8, a3);
    return 0;
  }
  if (decode_primary_identity_state((uint64_t)outputStruct, v13[0], &__s, &v16, (uint64_t)v15))
  {
    v8 = 3758604307;
    goto LABEL_12;
  }
  v8 = 3758097090;
  v9 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v10 = CFUUIDCreateFromUUIDBytes((CFAllocatorRef)*MEMORY[0x24BDBD240], __s);
  *a1 = v10;
  if (!v10)
    goto LABEL_12;
  v11 = CFUUIDCreateFromUUIDBytes(v9, v16);
  *a2 = v11;
  if (!v11)
    goto LABEL_12;
  return 1;
}

BOOL AKSIdentityTransferPrimary(int a1, const __CFData *a2, int a3, const __CFData *a4, CFTypeRef *a5)
{
  int v6;
  int v7;
  __CFError *v8;
  int v9;

  if (a1 >= 10)
    v6 = -a1;
  else
    v6 = -1;
  if (a3 >= 10)
    v7 = -a3;
  else
    v7 = -1;
  v8 = (__CFError *)_transfer_primary_identity(v6, a2, v7, a4);
  v9 = (int)v8;
  if ((_DWORD)v8)
    create_error(v8, a5);
  return v9 == 0;
}

uint64_t _transfer_primary_identity(int a1, CFDataRef theData, int a3, const __CFData *a4)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  const UInt8 *v9;
  CFIndex v10;
  mach_port_t aks_client_connection;
  uint64_t input[4];
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  input[0] = a1;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(theData);
  }
  else
  {
    BytePtr = 0;
    Length = 0;
  }
  v14 = 0u;
  input[1] = (uint64_t)BytePtr;
  input[2] = Length;
  input[3] = a3;
  if (a4)
  {
    v9 = CFDataGetBytePtr(a4);
    v10 = CFDataGetLength(a4);
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  *(_QWORD *)&v14 = v9;
  *((_QWORD *)&v14 + 1) = v10;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x7Eu, input, 6u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_transfer_primary_identity", ":", 809, "", 0, "", "");
  return 3758097084;
}

BOOL AKSIdentitySetPrimary(int a1, const __CFData *a2, CFTypeRef *a3)
{
  __CFError *v4;
  int v5;

  v4 = (__CFError *)_transfer_primary_identity(-1, 0, -a1, a2);
  v5 = (int)v4;
  if ((_DWORD)v4)
    create_error(v4, a3);
  return v5 == 0;
}

uint64_t AKSIdentityStashLoad(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  create_error((CFErrorRef)0xE00002E6, a4);
  return 0;
}

uint64_t AKSIdentityStashCreate(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  create_error((CFErrorRef)0xE00002E6, a3);
  return 0;
}

uint64_t AKSGetLastUser(CFUUIDRef *a1, CFTypeRef *a2)
{
  mach_port_t aks_client_connection;
  uint64_t v5;
  CFUUIDRef v6;
  uint64_t v8;
  size_t v9;
  CFUUIDBytes outputStruct[16];
  uint64_t input[2];

  input[1] = *MEMORY[0x24BDAC8D0];
  input[0] = 2;
  memset(outputStruct, 0, sizeof(outputStruct));
  v9 = 256;
  aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    v8 = 3758097084;
    fprintf((FILE *)*MEMORY[0x24BDAC8E8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "AKSGetLastUser", ":", 901, "", 0, "", "");
    goto LABEL_11;
  }
  v5 = IOConnectCallMethod(aks_client_connection, 0x80u, input, 1u, 0, 0, 0, 0, outputStruct, &v9);
  if ((_DWORD)v5)
  {
    v8 = v5;
    goto LABEL_11;
  }
  if (v9 != 16)
  {
    v8 = 3758604298;
LABEL_11:
    create_error((CFErrorRef)v8, a2);
    return 0;
  }
  v6 = CFUUIDCreateFromUUIDBytes((CFAllocatorRef)*MEMORY[0x24BDBD240], outputStruct[0]);
  *a1 = v6;
  if (!v6)
  {
    v8 = 3758097090;
    goto LABEL_11;
  }
  return 1;
}

uint64_t AKSVolumeBootstrapFS(const __CFString *a1, int a2, CFTypeRef *a3)
{
  uint64_t v6;
  char buffer[1024];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  bzero(buffer, 0x400uLL);
  if (!CFStringGetCString(a1, buffer, 1024, 0x8000100u))
  {
    v6 = 3758604298;
    goto LABEL_6;
  }
  if (a2)
  {
    v6 = aks_bootstrap_user_fs(buffer, 0);
    if (!(_DWORD)v6)
      return 1;
LABEL_6:
    create_error((CFErrorRef)v6, a3);
    return 0;
  }
  v6 = aks_bootstrap_fs(buffer, 0);
  if ((_DWORD)v6)
    goto LABEL_6;
  return 1;
}

uint64_t AKSVolumeAllowlistFS(const __CFString *a1, int a2, CFTypeRef *a3)
{
  uint64_t v6;
  char buffer[1024];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  bzero(buffer, 0x400uLL);
  if (!CFStringGetCString(a1, buffer, 1024, 0x8000100u))
  {
    v6 = 3758604298;
    goto LABEL_6;
  }
  if (a2)
  {
    v6 = aks_setupallowlist_user_fs(buffer, 0);
    if (!(_DWORD)v6)
      return 1;
LABEL_6:
    create_error((CFErrorRef)v6, a3);
    return 0;
  }
  v6 = aks_setupallowlist_fs((uint64_t)buffer);
  if ((_DWORD)v6)
    goto LABEL_6;
  return 1;
}

BOOL AKSIdentityGetSessionInfo(__CFDictionary **a1, CFTypeRef *a2)
{
  return _get_info(4294967293, a1, a2);
}

BOOL _get_info(uint64_t a1, __CFDictionary **a2, CFTypeRef *a3)
{
  __CFDictionary *Mutable;
  __CFError *v7;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v7 = (__CFError *)set_lock_state(a1, Mutable);
  if ((_DWORD)v7)
  {
    if (Mutable)
      CFRelease(Mutable);
    create_error(v7, a3);
  }
  else
  {
    *a2 = Mutable;
  }
  return (_DWORD)v7 == 0;
}

BOOL AKSIdentityGetInfo(int a1, __CFDictionary **a2, CFTypeRef *a3)
{
  uint64_t v3;

  if (a1 >= 10)
    v3 = -a1;
  else
    v3 = 0xFFFFFFFFLL;
  return _get_info(v3, a2, a3);
}

BOOL AKSIdentityGetTimeWindows(int a1, _QWORD *a2, _QWORD *a3, CFTypeRef *a4)
{
  uint64_t v4;

  if (a1 >= 10)
    v4 = -a1;
  else
    v4 = 0xFFFFFFFFLL;
  return get_time_windows(v4, a2, a3, a4);
}

BOOL get_time_windows(uint64_t a1, _QWORD *a2, _QWORD *a3, CFTypeRef *a4)
{
  __CFError *internal_state;
  int v8;
  _BYTE v10[20];

  memset(v10, 0, sizeof(v10));
  internal_state = (__CFError *)aks_get_internal_state(a1);
  v8 = (int)internal_state;
  if ((_DWORD)internal_state)
  {
    create_error(internal_state, a4);
  }
  else
  {
    if (a2)
      *a2 = 0;
    if (a3)
      *a3 = *(_QWORD *)&v10[12];
  }
  return v8 == 0;
}

BOOL AKSIdentityGetSessionTimeWindows(_QWORD *a1, _QWORD *a2, CFTypeRef *a3)
{
  return get_time_windows(4294967293, a1, a2, a3);
}

uint64_t set_lock_state(uint64_t a1, __CFDictionary *a2)
{
  uint64_t v2;
  uint64_t v5;
  char v6;
  const void *v7;
  host_t v8;
  uint64_t v9;
  uint32_t multiuser_flags;
  __int128 v12;
  _OWORD byte7[3];
  UInt8 byte15[8];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = 3758097084;
  *(_WORD *)byte15 = 0;
  v12 = 0u;
  memset(byte7, 0, sizeof(byte7));
  if (!a2 || aks_get_extended_device_state())
    return v2;
  if ((DWORD1(v12) - 5) < 3 || DWORD1(v12) == 0)
    v5 = 0;
  else
    v5 = DWORD1(v12);
  set_info_key(a2, CFSTR("ls"), v5);
  set_info_key(a2, CFSTR("els"), DWORD1(v12));
  set_info_key(a2, CFSTR("state"), v12);
  set_info_key(a2, CFSTR("kms"), *(uint64_t *)((char *)&byte7[1] + 2));
  v6 = BYTE2(byte7[1]);
  if ((BYTE2(byte7[1]) & 1) == 0)
  {
    if ((BYTE2(byte7[1]) & 2) == 0)
      goto LABEL_11;
LABEL_30:
    CFDictionarySetValue(a2, CFSTR("cxd"), (const void *)*MEMORY[0x24BDBD270]);
    if ((BYTE2(byte7[1]) & 0x10) == 0)
      goto LABEL_13;
    goto LABEL_12;
  }
  CFDictionarySetValue(a2, CFSTR("cxx"), (const void *)*MEMORY[0x24BDBD270]);
  v6 = BYTE2(byte7[1]);
  if ((BYTE2(byte7[1]) & 2) != 0)
    goto LABEL_30;
LABEL_11:
  if ((v6 & 0x10) != 0)
LABEL_12:
    CFDictionarySetValue(a2, CFSTR("oneness"), (const void *)*MEMORY[0x24BDBD270]);
LABEL_13:
  if ((v12 & 8) != 0)
    CFDictionarySetValue(a2, CFSTR("th"), (const void *)*MEMORY[0x24BDBD270]);
  set_info_key(a2, CFSTR("boff"), *((uint64_t *)&v12 + 1));
  set_info_key(a2, CFSTR("fa"), LODWORD(byte7[0]));
  set_info_key(a2, CFSTR("countdown"), *(uint64_t *)((char *)byte7 + 10));
  set_info_key(a2, CFSTR("ma"), *(unsigned int *)((char *)&byte7[1] + 14));
  if (LODWORD(byte7[0]) >= *(_DWORD *)((char *)&byte7[1] + 14))
  {
    v7 = (const void *)*MEMORY[0x24BDBD270];
    CFDictionarySetValue(a2, CFSTR("pb"), (const void *)*MEMORY[0x24BDBD270]);
    if ((isEduMode_once & 1) == 0)
    {
      multiuser_flags = 0;
      v8 = MEMORY[0x219A18110]();
      if (!host_get_multiuser_config_flags(v8, &multiuser_flags))
      {
        if ((multiuser_flags & 0x80000000) != 0)
          isEduMode_result = 1;
        isEduMode_once = 1;
      }
    }
    if (isEduMode_result == 1)
      CFDictionarySetValue(a2, CFSTR("sw"), v7);
  }
  if (*(int *)((char *)&byte7[1] + 10) < -9)
    v9 = -*(_DWORD *)((char *)&byte7[1] + 10);
  else
    v9 = 0xFFFFFFFFLL;
  set_info_key(a2, CFSTR("uid"), v9);
  v2 = (uint64_t)CFUUIDCreateWithBytes((CFAllocatorRef)*MEMORY[0x24BDBD240], BYTE2(byte7[2]), BYTE3(byte7[2]), BYTE4(byte7[2]), BYTE5(byte7[2]), BYTE6(byte7[2]), BYTE7(byte7[2]), BYTE8(byte7[2]), BYTE9(byte7[2]), BYTE10(byte7[2]), BYTE11(byte7[2]), BYTE12(byte7[2]), BYTE13(byte7[2]), BYTE14(byte7[2]), HIBYTE(byte7[2]), byte15[0], byte15[1]);
  CFDictionarySetValue(a2, CFSTR("user_uuid"), (const void *)v2);
  if (v2)
  {
    CFRelease((CFTypeRef)v2);
    return 0;
  }
  return v2;
}

_QWORD *initializeBufferWithCopyOfBuffer for DERDictionary(_QWORD *a1, _QWORD *a2)
{
  *a1 = *a2;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t destroy for DERDictionary()
{
  return swift_bridgeObjectRelease();
}

_QWORD *assignWithCopy for DERDictionary(_QWORD *a1, _QWORD *a2)
{
  *a1 = *a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

_QWORD *__swift_memcpy8_8(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *assignWithTake for DERDictionary(_QWORD *a1, _QWORD *a2)
{
  *a1 = *a2;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for DERDictionary(uint64_t *a1, unsigned int a2)
{
  uint64_t v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0x7FFFFFFF && *((_BYTE *)a1 + 8))
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  v3 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF)
    LODWORD(v3) = -1;
  v4 = v3 - 1;
  if (v4 < 0)
    v4 = -1;
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for DERDictionary(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(_QWORD *)result = a2 - 0x7FFFFFFF;
    if (a3 >= 0x7FFFFFFF)
      *(_BYTE *)(result + 8) = 1;
  }
  else
  {
    if (a3 >= 0x7FFFFFFF)
      *(_BYTE *)(result + 8) = 0;
    if (a2)
      *(_QWORD *)result = a2;
  }
  return result;
}

ValueMetadata *type metadata accessor for DERDictionary()
{
  return &type metadata for DERDictionary;
}

uint64_t sub_217E03AFC@<X0>(uint64_t *a1@<X0>, char **a2@<X1>, char **a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int64_t v8;
  unint64_t v9;
  int64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int64_t v17;
  int64_t v18;
  uint64_t *v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  char v23;
  char v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  char isUniquelyReferenced_nonNull_native;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t result;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t *v42;
  char **v43;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int64_t v52;
  unint64_t v53;
  uint64_t v54;
  __int128 v56;
  uint64_t v57;
  _QWORD v58[5];
  _QWORD v59[12];
  _QWORD v60[12];
  _QWORD v61[12];
  _OWORD v62[4];
  __int128 v63;
  __int128 v64;
  __int128 v65;
  _OWORD v66[5];
  _OWORD v67[4];
  __int128 v68;
  __int128 v69;
  __int128 v70;
  _OWORD v71[5];
  _BYTE v72[48];
  _BYTE v73[48];
  _BYTE v74[48];
  __int128 v75;
  uint64_t v76;
  uint64_t v77;
  char v78;
  char *v79;

  v8 = a1[2];
  v9 = a1[3];
  v10 = v9 >> 1;
  if (v8 == v9 >> 1)
  {
LABEL_47:
    *a3 = *a2;
    return swift_bridgeObjectRetain();
  }
  else
  {
    v43 = a3;
    v54 = v4;
    v12 = *a1;
    v11 = a1[1];
    v46 = v11;
    v47 = v11 + 112;
    v48 = v9 & 0xFFFFFFFFFFFFFFFELL;
    v45 = *a1;
    while (1)
    {
      v13 = v9 >> 1;
      if (v8 >= (uint64_t)(v9 >> 1))
      {
LABEL_51:
        __break(1u);
LABEL_52:
        __break(1u);
LABEL_53:
        __break(1u);
LABEL_54:
        __break(1u);
LABEL_55:
        __break(1u);
LABEL_56:
        __break(1u);
LABEL_57:
        __break(1u);
LABEL_58:
        __break(1u);
LABEL_59:
        __break(1u);
LABEL_60:
        __break(1u);
LABEL_61:
        __break(1u);
LABEL_62:
        __break(1u);
LABEL_63:
        __break(1u);
LABEL_64:
        __break(1u);
LABEL_65:
        v21 = (_QWORD *)v9;
        if (!*(_QWORD *)(v13 + 64))
        {
          *a1 = v45;
          a1[1] = v46;
          a1[2] = v5;
          a1[3] = v9;
          __break(1u);
LABEL_67:
          *a1 = v12;
          a1[1] = v11;
          a1[2] = v52;
          a1[3] = v53;
          __break(1u);
        }
        swift_unknownObjectRetain();
        if (v3 == 16 && (_DWORD)v4 == 0)
        {
          *a1 = v45;
          a1[1] = v46;
          a1[2] = v5;
          a1[3] = (uint64_t)v21;
          __break(1u);
        }
LABEL_74:
        __break(1u);
LABEL_75:
        *a1 = v12;
        a1[1] = v11;
        a1[2] = v52;
        a1[3] = v53;
        v37 = sub_217E055EC((uint64_t)"AppleKeyStore/ASN1OctetString.swift", 35, 2, 26);
        sub_217E04C24();
        swift_allocError();
        *v38 = v37;
        j__swift_unknownObjectRetain(v12, v11, v5, v3, v6, 0);
        j__swift_unknownObjectRetain(v12, v11, v5, v3, v6, 0);
        swift_unknownObjectRetain();
        j__swift_unknownObjectRetain(v12, v11, v5, v3, v6, 0);
        swift_unknownObjectRetain();
        swift_willThrow();
        sub_217E04D34(v59, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_217E04C6C);
        goto LABEL_78;
      }
      if (v10 <= v8)
        goto LABEL_52;
      if (v13 < v10)
        goto LABEL_53;
      v13 = v11 + 96 * v8;
      v3 = *(_QWORD *)v13;
      LODWORD(v4) = *(unsigned __int8 *)(v13 + 8);
      v5 = v8 + 1;
      v14 = v9 & 1;
      v9 = v14 | v48;
      if (!*(_BYTE *)(v13 + 24))
        goto LABEL_65;
      v6 = *(_QWORD *)(v13 + 16);
      if (v5 == v10)
      {
        v15 = v10;
      }
      else
      {
        v13 = v47 + 96 * v8;
        v15 = v8 + 1;
        do
        {
          if (v15 >= v10)
          {
LABEL_49:
            __break(1u);
LABEL_50:
            __break(1u);
            goto LABEL_51;
          }
          if (v6 >= *(_QWORD *)v13)
            goto LABEL_15;
          v16 = v15 + 1;
          if (__OFADD__(v15, 1))
            goto LABEL_50;
          ++v15;
          v13 += 96;
        }
        while (v16 != v10);
        v15 = v10;
LABEL_15:
        if (v15 <= v8)
          goto LABEL_54;
        if (v15 < 0)
          goto LABEL_55;
      }
      v13 = v15 - v5;
      if (__OFSUB__(v15, v5))
        goto LABEL_56;
      if ((v13 & 0x8000000000000000) != 0)
        goto LABEL_57;
      v17 = v10 - v5;
      if (__OFSUB__(v10, v5))
        goto LABEL_58;
      if (!v13 || v17 < 0 || (v18 = v10, v17 >= (uint64_t)v13))
      {
        v18 = v15;
        if (__OFADD__(v5, v13))
          goto LABEL_62;
        if (v10 < v15)
          goto LABEL_59;
      }
      if (v18 <= v8)
        goto LABEL_60;
      if (v5 != v15)
      {
        if (v5 >= v15)
          goto LABEL_63;
        v19 = (uint64_t *)(v47 + 96 * v8);
        do
        {
          v20 = *v19;
          v19 += 12;
          if (v6 >= v20)
          {
            __break(1u);
            goto LABEL_49;
          }
          --v13;
        }
        while (v13);
        v13 = *(_QWORD *)(v11 + 96 * v5 + 16);
        if (v13 != v6 + 1)
          goto LABEL_64;
      }
      v52 = v18;
      v53 = v14 | v48;
      swift_unknownObjectRetain();
      if (v3 != 16 || (_DWORD)v4)
        goto LABEL_74;
      v58[0] = v12;
      v58[1] = v11;
      v3 = v14 | (2 * v15);
      v58[2] = v5;
      v58[3] = v3;
      v58[4] = v6;
      v21 = v58;
      sub_217E05C84((uint64_t)v59);
      sub_217E04B9C((uint64_t)v59, (uint64_t)v67);
      if (!(_QWORD)v68)
      {
        *a1 = v12;
        a1[1] = v11;
        a1[2] = v52;
        a1[3] = v53;
        v39 = sub_217E0556C(0xD00000000000002ALL, 0x8000000217E30C50, (uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, 1107);
        sub_217E04C24();
        swift_allocError();
        *v40 = v39;
        j__swift_unknownObjectRetain(v12, v11, v5, v3, v6, 0);
        j__swift_unknownObjectRetain(v12, v11, v5, v3, v6, 0);
        swift_unknownObjectRetain();
        j__swift_unknownObjectRetain(v12, v11, v5, v3, v6, 0);
        swift_unknownObjectRetain();
        swift_willThrow();
        goto LABEL_78;
      }
      v71[1] = v67[2];
      v71[2] = v67[3];
      v71[3] = v68;
      v71[4] = v69;
      v70 = v67[0];
      v71[0] = v67[1];
      if (*(_QWORD *)&v67[0] != 12 || BYTE8(v70))
        goto LABEL_75;
      sub_217E04CC0((uint64_t)v71, (uint64_t)v72);
      sub_217E04CC0((uint64_t)v72, (uint64_t)&v75);
      if (v78 != 1)
        goto LABEL_67;
      v56 = v75;
      v50 = v77;
      v51 = v76;
      j__swift_unknownObjectRetain(v12, v11, v5, v3, v6, 0);
      j__swift_unknownObjectRetain(v12, v11, v5, v3, v6, 0);
      swift_unknownObjectRetain();
      v57 = v3;
      j__swift_unknownObjectRetain(v12, v11, v5, v3, v6, 0);
      swift_unknownObjectRetain();
      sub_217E04CFC((uint64_t)v72, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))j__swift_unknownObjectRetain);
      sub_217E04D34(v59, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_217E04C6C);
      sub_217E05C84((uint64_t)v60);
      sub_217E04B9C((uint64_t)v60, (uint64_t)v62);
      if (!(_QWORD)v63)
        break;
      v66[1] = v62[2];
      v66[2] = v62[3];
      v66[3] = v63;
      v66[4] = v64;
      v65 = v62[0];
      v66[0] = v62[1];
      v79 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
      v22 = v65;
      v23 = BYTE8(v65);
      sub_217E04CC0((uint64_t)v66, (uint64_t)v73);
      sub_217E04CC0((uint64_t)v73, (uint64_t)v74);
      v24 = v74[40];
      sub_217E04D34(v60, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_217E04D88);
      LODWORD(v4) = v54;
      sub_217E0833C(v22, v23, (v24 & 1) == 0, (uint64_t)&v79, (uint64_t)&v65);
      if (v54)
        goto LABEL_79;
      sub_217E04D34(v60, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_217E04C6C);
      sub_217E04D34(v60, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_217E04C6C);
      v25 = v79;
      v49 = *((_QWORD *)v79 + 2);
      sub_217E05C84((uint64_t)v61);
      v26 = v61[8];
      v27 = v12;
      v28 = v11;
      v29 = v5;
      v3 = v5;
      v5 = v11;
      v11 = v12;
      v12 = v57;
      j__swift_unknownObjectRelease(v27, v28, v29, v57, v6, 0);
      sub_217E04D34(v61, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_217E04C6C);
      if (v26)
        goto LABEL_61;
      swift_unknownObjectRelease();
      j__swift_unknownObjectRelease(v11, v5, v3, v57, v6, 0);
      swift_unknownObjectRelease();
      v30 = *a2;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      *a2 = v30;
      v5 = v3;
      if ((isUniquelyReferenced_nonNull_native & 1) == 0)
      {
        v30 = sub_217E0E3D4(0, *((_QWORD *)v30 + 2) + 1, 1, v30);
        *a2 = v30;
      }
      v3 = v51;
      v33 = *((_QWORD *)v30 + 2);
      v32 = *((_QWORD *)v30 + 3);
      if (v33 >= v32 >> 1)
        v30 = sub_217E0E3D4((char *)(v32 > 1), v33 + 1, 1, v30);
      *((_QWORD *)v30 + 2) = v33 + 1;
      v34 = &v30[64 * v33];
      *((_OWORD *)v34 + 2) = v56;
      *((_QWORD *)v34 + 6) = v51;
      *((_QWORD *)v34 + 7) = v50;
      *((_QWORD *)v34 + 8) = v25;
      *((_QWORD *)v34 + 9) = v25 + 32;
      *((_QWORD *)v34 + 10) = 0;
      *((_QWORD *)v34 + 11) = (2 * v49) | 1;
      *a2 = v30;
      v12 = v45;
      v11 = v46;
      j__swift_unknownObjectRelease(v45, v46, v5, v57, v6, 0);
      swift_unknownObjectRelease();
      swift_unknownObjectRelease();
      swift_unknownObjectRelease();
      v9 = v53;
      v8 = v52;
      if (v52 == v10)
      {
        a3 = v43;
        *a1 = v45;
        a1[1] = v46;
        a1[2] = v10;
        a1[3] = v53;
        goto LABEL_47;
      }
    }
    *a1 = v12;
    a1[1] = v11;
    a1[2] = v52;
    a1[3] = v53;
    v41 = sub_217E0556C(0xD00000000000002ALL, 0x8000000217E30C50, (uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, 1026);
    sub_217E04C24();
    swift_allocError();
    *v42 = v41;
    swift_willThrow();
    sub_217E04CFC((uint64_t)v72, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))j__swift_unknownObjectRelease);
LABEL_78:
    swift_unexpectedError();
    __break(1u);
LABEL_79:
    sub_217E04D34(v60, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_217E04C6C);
    *a1 = v12;
    a1[1] = v11;
    a1[2] = v52;
    a1[3] = v53;
    result = swift_unexpectedError();
    __break(1u);
  }
  return result;
}

__n128 sub_217E043A0(uint64_t a1)
{
  uint64_t v1;
  char *v3;
  uint64_t v4;
  int64_t v5;
  __n128 result;
  unint64_t v7;
  unint64_t v8;
  char *v9;
  __int128 v10;
  __int128 v11;

  if (!*(_QWORD *)v1)
    *(_QWORD *)v1 = MEMORY[0x24BEE4AF8];
  v3 = 0;
  v4 = sub_217E205B0(v1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  v5 = *(_QWORD *)(*(_QWORD *)v1 + 16);
  if (v5 < v4)
  {
    __break(1u);
LABEL_11:
    v3 = sub_217E0E3D4(0, *((_QWORD *)v3 + 2) + 1, 1, v3);
    goto LABEL_6;
  }
  sub_217E208C8(v4, v5);
  v3 = *(char **)v1;
  if (!*(_QWORD *)v1)
    return result;
  sub_217E04DD8(a1);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
    goto LABEL_11;
LABEL_6:
  v8 = *((_QWORD *)v3 + 2);
  v7 = *((_QWORD *)v3 + 3);
  if (v8 >= v7 >> 1)
    v3 = sub_217E0E3D4((char *)(v7 > 1), v8 + 1, 1, v3);
  *((_QWORD *)v3 + 2) = v8 + 1;
  v9 = &v3[64 * v8];
  result = *(__n128 *)a1;
  v10 = *(_OWORD *)(a1 + 16);
  v11 = *(_OWORD *)(a1 + 48);
  *((_OWORD *)v9 + 4) = *(_OWORD *)(a1 + 32);
  *((_OWORD *)v9 + 5) = v11;
  *((__n128 *)v9 + 2) = result;
  *((_OWORD *)v9 + 3) = v10;
  *(_QWORD *)v1 = v3;
  return result;
}

uint64_t sub_217E0449C(char **a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _OWORD v12[4];

  if (!a2)
    return swift_bridgeObjectRelease();
  result = swift_bridgeObjectRetain();
  v6 = *(_QWORD *)(a2 + 16);
  if (!v6)
    return swift_bridgeObjectRelease();
  v7 = 0;
  v8 = 32;
  while (v7 < v6)
  {
    v9 = *(_OWORD *)(a2 + v8);
    v10 = *(_OWORD *)(a2 + v8 + 16);
    v11 = *(_OWORD *)(a2 + v8 + 48);
    v12[2] = *(_OWORD *)(a2 + v8 + 32);
    v12[3] = v11;
    v12[0] = v9;
    v12[1] = v10;
    sub_217E04DD8((uint64_t)v12);
    sub_217E04DD8((uint64_t)v12);
    sub_217E08974(0x10uLL, 0, 1, a1, (char *)v12);
    if (v2)
    {
      sub_217E04E0C((uint64_t)v12);
      sub_217E04E0C((uint64_t)v12);
      return swift_bridgeObjectRelease();
    }
    ++v7;
    sub_217E04E0C((uint64_t)v12);
    result = sub_217E04E0C((uint64_t)v12);
    v6 = *(_QWORD *)(a2 + 16);
    v8 += 64;
    if (v7 == v6)
      return swift_bridgeObjectRelease();
  }
  __break(1u);
  return result;
}

uint64_t sub_217E0458C()
{
  uint64_t *v0;
  uint64_t v1;
  _BYTE v3[72];

  v1 = *v0;
  sub_217E2D1E8();
  sub_217E2D200();
  if (v1)
    sub_217E048A8((uint64_t)v3, v1);
  return sub_217E2D218();
}

uint64_t sub_217E045EC(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v3;

  v3 = *v1;
  if (!*v1)
    return sub_217E2D200();
  sub_217E2D200();
  return sub_217E048A8(a1, v3);
}

uint64_t sub_217E04648()
{
  uint64_t *v0;
  uint64_t v1;
  _BYTE v3[72];

  v1 = *v0;
  sub_217E2D1E8();
  sub_217E2D200();
  if (v1)
    sub_217E048A8((uint64_t)v3, v1);
  return sub_217E2D218();
}

BOOL sub_217E046A4(uint64_t *a1, uint64_t *a2)
{
  return sub_217E04AC4(*a1, *a2);
}

unint64_t sub_217E046B4()
{
  unint64_t result;

  result = qword_254F27778;
  if (!qword_254F27778)
  {
    result = MEMORY[0x219A1838C](&unk_217E329DC, &type metadata for DERDictionary);
    atomic_store(result, (unint64_t *)&qword_254F27778);
  }
  return result;
}

uint64_t sub_217E046F8()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v1 = v0[2];
  v2 = v0[3] >> 1;
  result = v2 - v1;
  if (__OFSUB__(v2, v1))
  {
    __break(1u);
    goto LABEL_13;
  }
  v4 = v0[1];
  result = sub_217E2D1F4();
  v5 = __OFSUB__(v2, v1);
  v6 = v2 - v1;
  if (v6)
  {
    if ((v6 < 0) ^ v5 | (v6 == 0))
    {
LABEL_14:
      __break(1u);
      goto LABEL_15;
    }
    v7 = v4 + v1;
    do
    {
      ++v7;
      sub_217E2D200();
      --v6;
    }
    while (v6);
  }
  v8 = v0[6];
  v9 = v0[7] >> 1;
  result = v9 - v8;
  if (__OFSUB__(v9, v8))
  {
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }
  v10 = v0[5];
  result = sub_217E2D1F4();
  v11 = v9 - v8;
  if (v9 == v8)
    return result;
  if (v9 <= v8)
  {
LABEL_15:
    __break(1u);
    return result;
  }
  v12 = v10 + v8;
  do
  {
    ++v12;
    result = sub_217E2D200();
    --v11;
  }
  while (v11);
  return result;
}

uint64_t sub_217E047A8()
{
  sub_217E2D1E8();
  sub_217E046F8();
  return sub_217E2D218();
}

uint64_t sub_217E047E8()
{
  sub_217E2D1E8();
  sub_217E046F8();
  return sub_217E2D218();
}

uint64_t sub_217E04820(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;

  v2 = a1[5];
  v3 = a1[6];
  v4 = a1[7];
  v5 = a2[5];
  v6 = a2[6];
  v7 = a2[7];
  if ((sub_217E085E8(a1[1], a1[2], a1[3], a2[1], a2[2], a2[3]) & 1) != 0)
    return sub_217E085E8(v2, v3, v4, v5, v6, v7);
  else
    return 0;
}

uint64_t sub_217E048A8(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;

  v3 = *(_QWORD *)(a2 + 16);
  result = sub_217E2D1F4();
  if (v3)
  {
    v5 = 0;
    v6 = a2 + 32;
    while (1)
    {
      v7 = (_QWORD *)(v6 + (v5 << 6));
      v8 = v7[2];
      v9 = v7[3] >> 1;
      result = v9 - v8;
      if (__OFSUB__(v9, v8))
        break;
      v10 = v7[1];
      v11 = v7[5];
      v12 = v7[6];
      v13 = v7[7];
      result = sub_217E2D1F4();
      v14 = __OFSUB__(v9, v8);
      v15 = v9 - v8;
      if (v15)
      {
        if ((v15 < 0) ^ v14 | (v15 == 0))
          goto LABEL_18;
        v16 = v10 + v8;
        do
        {
          ++v16;
          sub_217E2D200();
          --v15;
        }
        while (v15);
      }
      v17 = v13 >> 1;
      result = v17 - v12;
      if (__OFSUB__(v17, v12))
        goto LABEL_17;
      result = sub_217E2D1F4();
      v18 = __OFSUB__(v17, v12);
      v19 = v17 - v12;
      if (v19)
      {
        if ((v19 < 0) ^ v18 | (v19 == 0))
          goto LABEL_19;
        v20 = v11 + v12;
        do
        {
          ++v20;
          result = sub_217E2D200();
          --v19;
        }
        while (v19);
      }
      if (++v5 == v3)
        return result;
    }
    __break(1u);
LABEL_17:
    __break(1u);
LABEL_18:
    __break(1u);
LABEL_19:
    __break(1u);
  }
  return result;
}

uint64_t sub_217E04998@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t result;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  __int128 v19;

  if (a4)
  {
    result = swift_bridgeObjectRetain();
    v7 = 0;
    v8 = a4 + 48;
    while (1)
    {
      v9 = *(_QWORD *)(a4 + 16);
      if (v7 == v9)
        break;
      if (v7 >= v9)
      {
        __break(1u);
        return result;
      }
      v10 = v8 + 64;
      ++v7;
      v11 = *(_QWORD *)(v8 - 16);
      v12 = *(_QWORD *)(v8 - 8);
      v14 = *(_QWORD *)v8;
      v13 = *(_QWORD *)(v8 + 8);
      v19 = *(_OWORD *)(v8 + 16);
      v15 = *(_QWORD *)(v8 + 32);
      v16 = *(_QWORD *)(v8 + 40);
      result = sub_217E085E8(v12, *(_QWORD *)v8, v13, a1, a2, a3);
      v8 = v10;
      if ((result & 1) != 0)
      {
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        result = swift_bridgeObjectRelease();
        *(_QWORD *)a5 = v11;
        *(_QWORD *)(a5 + 8) = v12;
        *(_QWORD *)(a5 + 16) = v14;
        *(_QWORD *)(a5 + 24) = v13;
        *(_OWORD *)(a5 + 32) = v19;
        *(_QWORD *)(a5 + 48) = v15;
        *(_QWORD *)(a5 + 56) = v16;
        return result;
      }
    }
  }
  sub_217E04E40();
  swift_allocError();
  *v17 = 2;
  swift_willThrow();
  return swift_bridgeObjectRelease();
}

BOOL sub_217E04AC4(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *i;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;

  result = (a1 | a2) == 0;
  if (a1 && a2)
  {
    v4 = *(_QWORD *)(a1 + 16);
    if (v4 == *(_QWORD *)(a2 + 16))
    {
      if (!v4 || a1 == a2)
        return 1;
      v5 = (uint64_t *)(a2 + 48);
      for (i = (uint64_t *)(a1 + 48); ; i += 8)
      {
        v7 = i[3];
        v8 = i[4];
        v9 = i[5];
        v10 = v5[3];
        v11 = v5[4];
        v12 = v5[5];
        if ((sub_217E085E8(*(i - 1), *i, i[1], *(v5 - 1), *v5, v5[1]) & 1) == 0
          || (sub_217E085E8(v7, v8, v9, v10, v11, v12) & 1) == 0)
        {
          break;
        }
        v5 += 8;
        if (!--v4)
          return 1;
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_217E04B9C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_254F27780);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

uint64_t __swift_instantiateConcreteTypeFromMangledName(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if (result < 0)
  {
    result = MEMORY[0x219A18374]((char *)a1 + (int)result, -(result >> 32), 0, 0);
    *a1 = result;
  }
  return result;
}

unint64_t sub_217E04C24()
{
  unint64_t result;

  result = qword_254F27788;
  if (!qword_254F27788)
  {
    result = MEMORY[0x219A1838C](&unk_217E32C5C, &type metadata for ASN1Error);
    atomic_store(result, (unint64_t *)&qword_254F27788);
  }
  return result;
}

uint64_t sub_217E04C6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8, uint64_t a9)
{
  uint64_t result;

  if (a9)
  {
    j__swift_unknownObjectRelease(a3, a4, a5, a6, a7, a8 & 1);
    return swift_unknownObjectRelease();
  }
  return result;
}

uint64_t sub_217E04CC0(uint64_t a1, uint64_t a2)
{
  __swift_memcpy41_8(a2, a1);
  return a2;
}

uint64_t sub_217E04CFC(uint64_t a1, void (*a2)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))
{
  a2(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
  return a1;
}

_QWORD *sub_217E04D34(_QWORD *a1, void (*a2)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))
{
  a2(*a1, a1[1], a1[2], a1[3], a1[4], a1[5], a1[6], a1[7], a1[8], a1[9], a1[10], a1[11]);
  return a1;
}

uint64_t sub_217E04D88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8, uint64_t a9)
{
  uint64_t result;

  if (a9)
  {
    j__swift_unknownObjectRetain(a3, a4, a5, a6, a7, a8 & 1);
    return swift_unknownObjectRetain();
  }
  return result;
}

uint64_t sub_217E04DD8(uint64_t a1)
{
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  return a1;
}

uint64_t sub_217E04E0C(uint64_t a1)
{
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  return a1;
}

unint64_t sub_217E04E40()
{
  unint64_t result;

  result = qword_254F27790;
  if (!qword_254F27790)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSError, &type metadata for AKSError);
    atomic_store(result, (unint64_t *)&qword_254F27790);
  }
  return result;
}

uint64_t initializeBufferWithCopyOfBuffer for der_key(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *a2;
  *a1 = *a2;
  v3 = v2 + 16;
  swift_retain();
  return v3;
}

uint64_t destroy for DERDictionaryItem()
{
  swift_unknownObjectRelease();
  return swift_unknownObjectRelease();
}

uint64_t initializeWithCopy for DERDictionaryItem(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  return a1;
}

_QWORD *assignWithCopy for DERDictionaryItem(_QWORD *a1, _QWORD *a2)
{
  *a1 = *a2;
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a2[4];
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  a1[5] = a2[5];
  a1[6] = a2[6];
  a1[7] = a2[7];
  return a1;
}

__n128 __swift_memcpy64_8(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

_OWORD *assignWithTake for DERDictionaryItem(_OWORD *a1, _OWORD *a2)
{
  __int128 v4;
  __int128 v5;

  swift_unknownObjectRelease();
  v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  swift_unknownObjectRelease();
  v5 = a2[3];
  a1[2] = a2[2];
  a1[3] = v5;
  return a1;
}

uint64_t getEnumTagSinglePayload for DERDictionaryItem(uint64_t *a1, int a2)
{
  uint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *((_BYTE *)a1 + 64))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for DERDictionaryItem(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 64) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)result = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 64) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for DERDictionaryItem()
{
  return &type metadata for DERDictionaryItem;
}

unint64_t sub_217E050C0()
{
  unint64_t result;

  result = qword_254F27798;
  if (!qword_254F27798)
  {
    result = MEMORY[0x219A1838C](&unk_217E32A94, &type metadata for DERDictionaryItem);
    atomic_store(result, (unint64_t *)&qword_254F27798);
  }
  return result;
}

uint64_t sub_217E05118()
{
  sub_217E2D1E8();
  sub_217E2D1F4();
  return sub_217E2D218();
}

uint64_t sub_217E0515C()
{
  return sub_217E2D1F4();
}

uint64_t sub_217E05188()
{
  sub_217E2D1E8();
  sub_217E2D1F4();
  return sub_217E2D218();
}

BOOL sub_217E051C8(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(*(_QWORD *)a1 + 16) == *(unsigned __int8 *)(*(_QWORD *)a2 + 16);
}

uint64_t sub_217E051E4()
{
  sub_217E2D134();
  swift_bridgeObjectRelease();
  sub_217E2CFCC();
  sub_217E2CFD8();
  swift_bridgeObjectRelease();
  sub_217E2CFD8();
  swift_bridgeObjectRetain();
  sub_217E2CFD8();
  swift_bridgeObjectRelease();
  sub_217E2CFD8();
  sub_217E2D14C();
  sub_217E2CFD8();
  swift_bridgeObjectRelease();
  sub_217E2CFD8();
  sub_217E2D17C();
  sub_217E2CFD8();
  swift_bridgeObjectRelease();
  return 0x6F727245314E5341;
}

uint64_t sub_217E05320()
{
  return sub_217E051E4();
}

BOOL sub_217E05328(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

uint64_t sub_217E0533C()
{
  sub_217E2D1E8();
  sub_217E2D1F4();
  return sub_217E2D218();
}

uint64_t sub_217E05380()
{
  return sub_217E2D1F4();
}

uint64_t sub_217E053A8()
{
  sub_217E2D1E8();
  sub_217E2D1F4();
  return sub_217E2D218();
}

uint64_t sub_217E053E8()
{
  return sub_217E2CFCC();
}

uint64_t sub_217E05418()
{
  swift_bridgeObjectRelease();
  return swift_deallocClassInstance();
}

uint64_t type metadata accessor for ASN1Error.Backing()
{
  return objc_opt_self();
}

ValueMetadata *type metadata accessor for ASN1Error()
{
  return &type metadata for ASN1Error;
}

_BYTE *__swift_memcpy1_1(_BYTE *result, _BYTE *a2)
{
  *result = *a2;
  return result;
}

ValueMetadata *type metadata accessor for ASN1Error.ErrorCode()
{
  return &type metadata for ASN1Error.ErrorCode;
}

unint64_t sub_217E05498()
{
  unint64_t result;

  result = qword_254F277A0;
  if (!qword_254F277A0)
  {
    result = MEMORY[0x219A1838C](&unk_217E32B8C, &type metadata for ASN1Error.ErrorCode);
    atomic_store(result, (unint64_t *)&qword_254F277A0);
  }
  return result;
}

unint64_t sub_217E054E0()
{
  unint64_t result;

  result = qword_254F277A8;
  if (!qword_254F277A8)
  {
    result = MEMORY[0x219A1838C](&unk_217E32BF4, &type metadata for ASN1Error);
    atomic_store(result, (unint64_t *)&qword_254F277A8);
  }
  return result;
}

unint64_t sub_217E05528()
{
  unint64_t result;
  uint64_t v1;

  result = qword_254F277B0;
  if (!qword_254F277B0)
  {
    v1 = type metadata accessor for ASN1Error.Backing();
    result = MEMORY[0x219A1838C](&unk_217E32C9C, v1);
    atomic_store(result, (unint64_t *)&qword_254F277B0);
  }
  return result;
}

uint64_t sub_217E0556C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v12;

  type metadata accessor for ASN1Error.Backing();
  v12 = swift_allocObject();
  *(_BYTE *)(v12 + 16) = 1;
  *(_QWORD *)(v12 + 24) = a1;
  *(_QWORD *)(v12 + 32) = a2;
  *(_QWORD *)(v12 + 40) = a3;
  *(_QWORD *)(v12 + 48) = a4;
  *(_BYTE *)(v12 + 56) = a5;
  *(_QWORD *)(v12 + 64) = a6;
  swift_bridgeObjectRetain();
  return v12;
}

uint64_t sub_217E055EC(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t result;

  type metadata accessor for ASN1Error.Backing();
  result = swift_allocObject();
  *(_BYTE *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0xD000000000000013;
  *(_QWORD *)(result + 32) = 0x8000000217E30D10;
  *(_QWORD *)(result + 40) = a1;
  *(_QWORD *)(result + 48) = a2;
  *(_BYTE *)(result + 56) = a3;
  *(_QWORD *)(result + 64) = a4;
  return result;
}

uint64_t sub_217E05658(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v12;

  type metadata accessor for ASN1Error.Backing();
  v12 = swift_allocObject();
  *(_BYTE *)(v12 + 16) = 2;
  *(_QWORD *)(v12 + 24) = a1;
  *(_QWORD *)(v12 + 32) = a2;
  *(_QWORD *)(v12 + 40) = a3;
  *(_QWORD *)(v12 + 48) = a4;
  *(_BYTE *)(v12 + 56) = a5;
  *(_QWORD *)(v12 + 64) = a6;
  swift_bridgeObjectRetain();
  return v12;
}

uint64_t sub_217E056D8(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t result;

  type metadata accessor for ASN1Error.Backing();
  result = swift_allocObject();
  *(_BYTE *)(result + 16) = 3;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0xE000000000000000;
  *(_QWORD *)(result + 40) = a1;
  *(_QWORD *)(result + 48) = a2;
  *(_BYTE *)(result + 56) = a3;
  *(_QWORD *)(result + 64) = a4;
  return result;
}

uint64_t sub_217E05734(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v12;

  type metadata accessor for ASN1Error.Backing();
  v12 = swift_allocObject();
  *(_BYTE *)(v12 + 16) = 4;
  *(_QWORD *)(v12 + 24) = a1;
  *(_QWORD *)(v12 + 32) = a2;
  *(_QWORD *)(v12 + 40) = a3;
  *(_QWORD *)(v12 + 48) = a4;
  *(_BYTE *)(v12 + 56) = a5;
  *(_QWORD *)(v12 + 64) = a6;
  swift_bridgeObjectRetain();
  return v12;
}

uint64_t _s13AppleKeyStore9ASN1ErrorV9ErrorCodeV11BackingCodeOwet_0(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFA)
    goto LABEL_17;
  if (a2 + 6 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 6) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 6;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 6;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 6;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 7;
  v8 = v6 - 7;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t _s13AppleKeyStore9ASN1ErrorV9ErrorCodeV11BackingCodeOwst_0(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 6 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 6) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFA)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xF9)
    return ((uint64_t (*)(void))((char *)&loc_217E05890 + 4 * byte_217E32B35[v4]))();
  *a1 = a2 + 6;
  return ((uint64_t (*)(void))((char *)sub_217E058C4 + 4 * byte_217E32B30[v4]))();
}

uint64_t sub_217E058C4(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E058CC(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x217E058D4);
  return result;
}

uint64_t sub_217E058E0(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x217E058E8);
  *(_BYTE *)result = a2 + 6;
  return result;
}

uint64_t sub_217E058EC(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E058F4(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E05900(unsigned __int8 *a1)
{
  return *a1;
}

_BYTE *sub_217E0590C(_BYTE *result, char a2)
{
  *result = a2;
  return result;
}

ValueMetadata *type metadata accessor for ASN1Error.ErrorCode.BackingCode()
{
  return &type metadata for ASN1Error.ErrorCode.BackingCode;
}

unint64_t sub_217E05928()
{
  unint64_t result;

  result = qword_254F277B8;
  if (!qword_254F277B8)
  {
    result = MEMORY[0x219A1838C](&unk_217E32DA0, &type metadata for ASN1Error.ErrorCode.BackingCode);
    atomic_store(result, (unint64_t *)&qword_254F277B8);
  }
  return result;
}

uint64_t sub_217E05970(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  char v3;
  uint64_t v4;
  char v5;
  uint64_t (*v6)(uint64_t *);
  __int128 v7;
  __int128 v8;
  uint64_t v10;
  char v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  char v15;
  __int128 v16;
  __int128 v17;

  v3 = *((_BYTE *)a1 + 8);
  v4 = a1[6];
  v5 = *((_BYTE *)a1 + 56);
  v6 = *(uint64_t (**)(uint64_t *))(a3 + 8);
  v10 = *a1;
  v11 = v3;
  v7 = *((_OWORD *)a1 + 2);
  v12 = *((_OWORD *)a1 + 1);
  v13 = v7;
  v14 = v4;
  v15 = v5;
  v8 = *((_OWORD *)a1 + 5);
  v16 = *((_OWORD *)a1 + 4);
  v17 = v8;
  return v6(&v10);
}

uint64_t sub_217E059C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t sub_217E059DC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t sub_217E059E4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  char v5;
  uint64_t v6;
  char v7;
  uint64_t (*v8)(uint64_t *);
  __int128 v9;
  __int128 v10;
  uint64_t v12;
  char v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  char v17;
  __int128 v18;
  __int128 v19;

  v5 = *((_BYTE *)a1 + 8);
  v6 = a1[6];
  v7 = *((_BYTE *)a1 + 56);
  v8 = *(uint64_t (**)(uint64_t *))(a5 + 32);
  v12 = *a1;
  v13 = v5;
  v9 = *((_OWORD *)a1 + 2);
  v14 = *((_OWORD *)a1 + 1);
  v15 = v9;
  v16 = v6;
  v17 = v7;
  v10 = *((_OWORD *)a1 + 5);
  v18 = *((_OWORD *)a1 + 4);
  v19 = v10;
  return v8(&v12);
}

uint64_t sub_217E05A38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 40))();
}

uint64_t destroy for ASN1Node.Content(uint64_t a1)
{
  return j__swift_unknownObjectRelease(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

uint64_t initializeWithCopy for ASN1Node.Content(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *a2;
  v4 = a2[1];
  v5 = a2[2];
  v6 = a2[3];
  v7 = a2[4];
  v8 = *((unsigned __int8 *)a2 + 40);
  j__swift_unknownObjectRetain(*a2, v4, v5, v6, v7, v8);
  *(_QWORD *)a1 = v3;
  *(_QWORD *)(a1 + 8) = v4;
  *(_QWORD *)(a1 + 16) = v5;
  *(_QWORD *)(a1 + 24) = v6;
  *(_QWORD *)(a1 + 32) = v7;
  *(_BYTE *)(a1 + 40) = v8;
  return a1;
}

uint64_t *assignWithCopy for ASN1Node.Content(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v3 = *a2;
  v4 = a2[1];
  v5 = a2[2];
  v6 = a2[3];
  v7 = a2[4];
  v8 = *((unsigned __int8 *)a2 + 40);
  j__swift_unknownObjectRetain(*a2, v4, v5, v6, v7, v8);
  v9 = *a1;
  v10 = a1[1];
  v11 = a1[2];
  v12 = a1[3];
  v13 = a1[4];
  v14 = *((unsigned __int8 *)a1 + 40);
  *a1 = v3;
  a1[1] = v4;
  a1[2] = v5;
  a1[3] = v6;
  a1[4] = v7;
  *((_BYTE *)a1 + 40) = v8;
  j__swift_unknownObjectRelease(v9, v10, v11, v12, v13, v14);
  return a1;
}

__n128 __swift_memcpy41_8(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 25) = *(_OWORD *)(a2 + 25);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t *assignWithTake for ASN1Node.Content(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;

  v3 = *(_QWORD *)(a2 + 32);
  v4 = *(_BYTE *)(a2 + 40);
  v5 = *a1;
  v7 = a1[1];
  v6 = a1[2];
  v8 = a1[3];
  v9 = a1[4];
  v10 = *((unsigned __int8 *)a1 + 40);
  v11 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *((_OWORD *)a1 + 1) = v11;
  a1[4] = v3;
  *((_BYTE *)a1 + 40) = v4;
  j__swift_unknownObjectRelease(v5, v7, v6, v8, v9, v10);
  return a1;
}

uint64_t getEnumTagSinglePayload for ASN1Node.Content(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 41))
    return (*(_DWORD *)a1 + 255);
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 <= 1)
    v4 = -1;
  else
    v4 = v3 ^ 0xFF;
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for ASN1Node.Content(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_BYTE *)(result + 40) = 0;
    *(_QWORD *)result = a2 - 255;
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 41) = 1;
  }
  else
  {
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 41) = 0;
    if (a2)
      *(_BYTE *)(result + 40) = -(char)a2;
  }
  return result;
}

uint64_t sub_217E05C60(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 40);
}

uint64_t sub_217E05C68(uint64_t result, char a2)
{
  *(_BYTE *)(result + 40) = a2 & 1;
  return result;
}

ValueMetadata *type metadata accessor for ASN1Node.Content()
{
  return &type metadata for ASN1Node.Content;
}

void sub_217E05C84(uint64_t a1@<X8>)
{
  uint64_t *v1;
  int64_t v3;
  unint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 *v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  uint64_t v41;
  __int128 v42;
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  _OWORD v48[2];
  _BYTE v49[40];

  v3 = v1[2];
  v4 = v1[3];
  if (v3 == v4 >> 1)
  {
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0uLL;
    v10 = 0uLL;
    v11 = 0uLL;
    v12 = 0uLL;
LABEL_9:
    *(_QWORD *)a1 = v5;
    *(_QWORD *)(a1 + 8) = v6;
    *(_QWORD *)(a1 + 16) = v7;
    *(_QWORD *)(a1 + 24) = v8;
    *(_OWORD *)(a1 + 32) = v9;
    *(_OWORD *)(a1 + 48) = v10;
    *(_OWORD *)(a1 + 64) = v11;
    *(_OWORD *)(a1 + 80) = v12;
    return;
  }
  if (v3 >= (uint64_t)(v4 >> 1))
  {
    __break(1u);
LABEL_11:
    __break(1u);
    goto LABEL_12;
  }
  v13 = *v1;
  v14 = v1[1];
  v15 = (__int128 *)(v14 + 96 * v3);
  v16 = v15[1];
  v44 = *v15;
  v45 = v16;
  v17 = v15[2];
  v18 = v15[3];
  v19 = v15[5];
  v48[0] = v15[4];
  v48[1] = v19;
  v46 = v17;
  v47 = v18;
  v20 = v3 + 1;
  v1[2] = v3 + 1;
  if ((BYTE8(v45) & 1) != 0)
  {
    sub_217E09C38(v13, v14, v20, v4, (uint64_t)&v44);
    v25 = v24;
    if (!__OFSUB__(v23 >> 1, v22))
    {
      v26 = v21;
      v27 = v22;
      v28 = v23;
      *v1 = sub_217E06CCC((v23 >> 1) - v22, v13, v14, v20, v4);
      v1[1] = v29;
      v1[2] = v30;
      v1[3] = v31;
      v5 = v44;
      v6 = BYTE8(v44);
      sub_217E082C8(v25, v26, v27, v28, v45, &v40);
      v7 = v40;
      v8 = v41;
      *((_QWORD *)&v32 + 1) = *((_QWORD *)&v46 + 1);
      v37 = v42;
      v39 = v46;
      *(_QWORD *)&v32 = v43;
      v33 = v32;
      v35 = v47;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      v10 = v33;
      v12 = v35;
      v9 = v37;
      v11 = v39;
      goto LABEL_9;
    }
    goto LABEL_11;
  }
  sub_217E09AF4((uint64_t)v48, (uint64_t)v49, &qword_254F277E8);
  sub_217E09AF4((uint64_t)v49, (uint64_t)&v40, &qword_254F277E8);
  v7 = v40;
  if (v40)
  {
    v8 = v41;
    v5 = v44;
    v6 = BYTE8(v44);
    v36 = v42;
    v38 = v46;
    v34 = v47;
    sub_217E09B38((uint64_t)v49);
    swift_unknownObjectRetain();
    v12 = v34;
    v9 = v36;
    v11 = v38;
    v10 = xmmword_217E32DD0;
    goto LABEL_9;
  }
LABEL_12:
  __break(1u);
}

char *sub_217E05E84(uint64_t a1, uint64_t a2, unsigned __int8 a3, char **a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *result;
  uint64_t v13[5];
  uint64_t v14[12];
  char *v15;

  if (*(_QWORD *)a1 != a2 || *(unsigned __int8 *)(a1 + 8) != a3)
  {
    __break(1u);
LABEL_8:
    __break(1u);
    goto LABEL_9;
  }
  if ((*(_BYTE *)(a1 + 56) & 1) != 0)
  {
LABEL_9:
    __break(1u);
    goto LABEL_10;
  }
  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  v8 = *(_QWORD *)(a1 + 32);
  v9 = *(_QWORD *)(a1 + 40);
  v10 = *(_QWORD *)(a1 + 48);
  v13[0] = v6;
  v13[1] = v7;
  v13[2] = v8;
  v13[3] = v9;
  v13[4] = v10;
  swift_unknownObjectRetain_n();
  sub_217E03AFC(v13, a4, &v15);
  if (!v4)
  {
    sub_217E05C84((uint64_t)v14);
    v11 = v14[8];
    j__swift_unknownObjectRelease(v6, v7, v8, v9, v10, 0);
    sub_217E09B64(v14);
    if (!v11)
    {
      swift_unknownObjectRelease();
      return v15;
    }
    goto LABEL_8;
  }
LABEL_10:
  result = (char *)swift_unexpectedError();
  __break(1u);
  return result;
}

uint64_t sub_217E05F90()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;

  sub_217E2D1F4();
  sub_217E2D1F4();
  sub_217E2D1F4();
  sub_217E2D200();
  v1 = v0[6];
  v2 = v0[7] >> 1;
  result = v2 - v1;
  if (__OFSUB__(v2, v1))
  {
    __break(1u);
    goto LABEL_16;
  }
  v4 = v0[5];
  result = sub_217E2D1F4();
  v5 = __OFSUB__(v2, v1);
  v6 = v2 - v1;
  if (v6)
  {
    if ((v6 < 0) ^ v5 | (v6 == 0))
    {
LABEL_17:
      __break(1u);
      goto LABEL_18;
    }
    v7 = v4 + v1;
    do
    {
      ++v7;
      sub_217E2D200();
      --v6;
    }
    while (v6);
  }
  if (!v0[8])
    return sub_217E2D200();
  v8 = v0[10];
  v9 = v0[11];
  v10 = v0[9];
  sub_217E2D200();
  v11 = v9 >> 1;
  result = (v9 >> 1) - v8;
  if (__OFSUB__(v9 >> 1, v8))
  {
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
  result = sub_217E2D1F4();
  v12 = __OFSUB__(v11, v8);
  v13 = v11 - v8;
  if (!v13)
    return result;
  if ((v13 < 0) ^ v12 | (v13 == 0))
  {
LABEL_18:
    __break(1u);
    return result;
  }
  v14 = v10 + v8;
  do
  {
    ++v14;
    result = sub_217E2D200();
    --v13;
  }
  while (v13);
  return result;
}

uint64_t sub_217E06084()
{
  sub_217E2D1E8();
  sub_217E05F90();
  return sub_217E2D218();
}

uint64_t sub_217E060C4()
{
  sub_217E2D1E8();
  sub_217E05F90();
  return sub_217E2D218();
}

uint64_t sub_217E060FC(_OWORD *a1, _OWORD *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  _OWORD v9[6];
  _OWORD v10[6];

  v2 = a1[3];
  v9[2] = a1[2];
  v9[3] = v2;
  v3 = a1[5];
  v9[4] = a1[4];
  v9[5] = v3;
  v4 = a1[1];
  v9[0] = *a1;
  v9[1] = v4;
  v5 = a2[3];
  v10[2] = a2[2];
  v10[3] = v5;
  v6 = a2[5];
  v10[4] = a2[4];
  v10[5] = v6;
  v7 = a2[1];
  v10[0] = *a2;
  v10[1] = v7;
  return sub_217E092DC((uint64_t)v9, (uint64_t)v10) & 1;
}

uint64_t sub_217E06154()
{
  uint64_t v0;
  uint64_t result;
  _BYTE v2[32];
  _QWORD v3[4];

  v3[0] = 0;
  v3[1] = 0xE000000000000000;
  sub_217E2D134();
  sub_217E2CFD8();
  sub_217E22DCC();
  sub_217E2CFD8();
  swift_bridgeObjectRelease();
  sub_217E2CFD8();
  v3[0] = *(_QWORD *)(v0 + 16);
  sub_217E2D17C();
  sub_217E2CFD8();
  swift_bridgeObjectRelease();
  sub_217E2CFD8();
  sub_217E09AF4(v0 + 64, (uint64_t)v2, &qword_254F277E8);
  result = sub_217E09AF4((uint64_t)v2, (uint64_t)v3, &qword_254F277E8);
  if (v3[0] && __OFSUB__(v3[3] >> 1, v3[2]))
  {
    __break(1u);
  }
  else
  {
    sub_217E2D17C();
    sub_217E2CFD8();
    swift_bridgeObjectRelease();
    sub_217E2CFD8();
    return 0;
  }
  return result;
}

uint64_t sub_217E062E0()
{
  return sub_217E06154();
}

uint64_t sub_217E06320(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char *v4;
  uint64_t v5;
  uint64_t result;
  char **v7;
  uint64_t v8[2];
  uint64_t v9;
  unint64_t v10;
  char *v11;

  v10 = a4;
  v8[0] = a1;
  v8[1] = a2;
  v9 = a3;
  swift_unknownObjectRetain();
  v11 = sub_217E0E1D4(0, 16, 0, MEMORY[0x24BEE4AF8]);
  sub_217E06444(v8, 1, &v11);
  result = v8[0];
  if (v5)
    goto LABEL_6;
  if (!__OFSUB__(v10 >> 1, v9))
  {
    if (v10 >> 1 == v9)
    {
      v4 = v11;
      swift_unknownObjectRelease();
      return (uint64_t)v4;
    }
    v4 = (char *)sub_217E0556C(0xD000000000000021, 0x8000000217E30D50, (uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, 479);
    sub_217E04C24();
    swift_allocError();
    *v7 = v4;
    swift_willThrow();
LABEL_6:
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
    return (uint64_t)v4;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E06444(uint64_t *a1, uint64_t a2, char **a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t result;
  int v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t *v42;
  char *v43;
  unint64_t v44;
  unint64_t v45;
  char v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  int64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char **v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  uint64_t v60;
  unint64_t v61;
  int v62;

  if (a2 > 50)
  {
    v4 = sub_217E0556C(0xD000000000000021, 0x8000000217E30DD0, (uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, 490);
LABEL_9:
    v20 = v4;
    sub_217E04C24();
    swift_allocError();
    *v21 = v20;
    return swift_willThrow();
  }
  v7 = a1;
  v8 = *a1;
  v9 = a1[1];
  v10 = a1[2];
  v11 = a1[3];
  v12 = sub_217E069AC();
  if ((v12 & 0x100) != 0)
  {
    v4 = sub_217E056D8((uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, 496);
    goto LABEL_9;
  }
  v13 = v12;
  if ((~v12 & 0x1F) != 0)
  {
    v58 = sub_217E22F24(v12);
    v62 = v23;
    swift_unknownObjectRetain();
  }
  else
  {
    v56 = a3;
    v14 = v10;
    v15 = v9;
    v16 = sub_217E22F1C(v12);
    swift_unknownObjectRetain();
    sub_217E11EF0();
    if (v3)
      return swift_unknownObjectRelease();
    v62 = v16;
    if (v17 <= 0x1E)
    {
      v18 = sub_217E0556C(0xD00000000000002BLL, 0x8000000217E30DA0, (uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, 510);
      sub_217E04C24();
      swift_allocError();
      *v19 = v18;
      swift_willThrow();
      return swift_unknownObjectRelease();
    }
    v58 = v17;
    v9 = v15;
    v10 = v14;
    a3 = v56;
  }
  sub_217E069F4();
  if (v3)
    return swift_unknownObjectRelease();
  if ((v25 & 1) != 0)
  {
    v38 = sub_217E056D8((uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, 518);
LABEL_27:
    v39 = v38;
    sub_217E04C24();
    swift_allocError();
    *v40 = v39;
    swift_willThrow();
    return swift_unknownObjectRelease();
  }
  if (v24 < 0)
  {
    v38 = sub_217E0556C(0xD000000000000018, 0x8000000217E30D80, (uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, 523);
    goto LABEL_27;
  }
  v55 = *v7;
  v57 = v24;
  v50 = v7[2];
  v51 = v7[1];
  v52 = v7[3];
  v26 = sub_217E06C4C(v24, *v7, v51, v50, v52);
  v53 = v28;
  v54 = v27;
  v48 = v29;
  v49 = v26;
  v59[0] = v26;
  v59[1] = v29;
  v60 = v27;
  v61 = v28;
  *v7 = sub_217E06CCC(v57, v55, v51, v50, v52);
  v7[1] = v30;
  v7[2] = v31;
  v7[3] = v32;
  v33 = v53 >> 1;
  if (__OFSUB__(v53 >> 1, v54))
  {
LABEL_41:
    __break(1u);
LABEL_42:
    __break(1u);
    goto LABEL_43;
  }
  if ((v53 >> 1) - v54 != v57)
  {
    v41 = sub_217E056D8((uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, 530);
    sub_217E04C24();
    swift_allocError();
    *v42 = v41;
    swift_unknownObjectRetain();
    swift_willThrow();
    swift_unknownObjectRelease();
    return swift_unknownObjectRelease();
  }
  if (v33 < v10)
    goto LABEL_42;
  if ((uint64_t)(v11 >> 1) < v10)
  {
LABEL_43:
    __break(1u);
    goto LABEL_44;
  }
  if (v11 >> 1 < v33)
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }
  v52 = v53 & 0xFFFFFFFFFFFFFFFELL | v11 & 1;
  if ((v13 & 0x20) != 0)
  {
    v43 = *a3;
    swift_unknownObjectRetain_n();
    swift_unknownObjectRetain();
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      v43 = sub_217E0E1D4(0, *((_QWORD *)v43 + 2) + 1, 1, v43);
    v45 = *((_QWORD *)v43 + 2);
    v44 = *((_QWORD *)v43 + 3);
    v46 = v62;
    if (v45 >= v44 >> 1)
    {
      v43 = sub_217E0E1D4((char *)(v44 > 1), v45 + 1, 1, v43);
      v46 = v62;
    }
    *((_QWORD *)v43 + 2) = v45 + 1;
    v47 = &v43[96 * v45];
    *((_QWORD *)v47 + 4) = v58;
    v47[40] = v46;
    *((_QWORD *)v47 + 6) = a2;
    v47[56] = 1;
    *((_QWORD *)v47 + 8) = v8;
    *((_QWORD *)v47 + 9) = v9;
    *((_QWORD *)v47 + 10) = v10;
    *((_QWORD *)v47 + 11) = v52;
    *((_OWORD *)v47 + 6) = 0u;
    *((_OWORD *)v47 + 7) = 0u;
    *a3 = v43;
    if (!v57)
    {
      swift_unknownObjectRelease_n();
      return swift_unknownObjectRelease();
    }
    v7 = (uint64_t *)(a2 + 1);
    while (1)
    {
      sub_217E06444(v59, a2 + 1, a3);
      if (__OFSUB__(v61 >> 1, v60))
        break;
      if ((uint64_t)((v61 >> 1) - v60) <= 0)
      {
        swift_unknownObjectRelease_n();
        return swift_unknownObjectRelease();
      }
    }
    __break(1u);
    goto LABEL_41;
  }
  v7 = (uint64_t *)*a3;
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
LABEL_45:
    v7 = (uint64_t *)sub_217E0E1D4(0, v7[2] + 1, 1, (char *)v7);
  v35 = v7[2];
  v34 = v7[3];
  v36 = v62;
  if (v35 >= v34 >> 1)
  {
    v7 = (uint64_t *)sub_217E0E1D4((char *)(v34 > 1), v35 + 1, 1, (char *)v7);
    v36 = v62;
  }
  v7[2] = v35 + 1;
  v37 = &v7[12 * v35];
  v37[4] = v58;
  *((_BYTE *)v37 + 40) = v36;
  v37[6] = a2;
  *((_BYTE *)v37 + 56) = 0;
  v37[8] = v8;
  v37[9] = v9;
  v37[10] = v10;
  v37[11] = v52;
  v37[12] = v49;
  v37[13] = v48;
  v37[14] = v54;
  v37[15] = v53;
  swift_unknownObjectRelease();
  result = swift_unknownObjectRelease();
  *a3 = (char *)v7;
  return result;
}

uint64_t sub_217E069AC()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t result;

  v1 = v0[2];
  v2 = v0[3] >> 1;
  if (v1 == v2)
  {
    v3 = 0;
  }
  else
  {
    if (v1 >= v2)
    {
      __break(1u);
      return result;
    }
    v3 = *(unsigned __int8 *)(v0[1] + v1);
    v0[2] = v1 + 1;
  }
  return v3 | ((v1 == v2) << 8);
}

void sub_217E069F4()
{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  int64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int64_t v8;
  uint64_t v9;
  uint64_t *v10;
  BOOL v11;
  int64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  unint64_t v28;
  uint64_t v29;

  v2 = v0[2];
  v3 = v0[3];
  v4 = v3 >> 1;
  if (v2 == v3 >> 1)
    return;
  if (v2 >= v4)
  {
    __break(1u);
    goto LABEL_18;
  }
  v5 = *v0;
  v6 = v0[1];
  v7 = *(unsigned __int8 *)(v6 + v2);
  v8 = v2 + 1;
  v0[2] = v2 + 1;
  if (v7 == 128)
  {
    v9 = sub_217E05734(0xD000000000000035, 0x8000000217E30E90, (uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, 1149);
    sub_217E04C24();
    swift_allocError();
    *v10 = v9;
    swift_willThrow();
    return;
  }
  if ((v7 & 0x80) != 0)
  {
    v11 = __OFSUB__(v4, v8);
    v12 = v4 - v8;
    if (!v11)
    {
      v13 = v7 & 0x7F;
      if (v12 < (uint64_t)v13)
        return;
      sub_217E06C4C(v7 & 0x7F, v5, v6, v2 + 1, v3);
      v29 = v14;
      v16 = v15;
      v28 = v17;
      *v0 = sub_217E06CCC(v13, v5, v6, v8, v3);
      v0[1] = v18;
      v0[2] = v19;
      v0[3] = v20;
      swift_unknownObjectRetain();
      v21 = swift_unknownObjectRetain();
      sub_217E14A88(v21, v29, v16, v28);
      if (!v1)
      {
        if (v22 <= 0x7F)
        {
          v24 = 0xD00000000000004FLL;
          v23 = 0x8000000217E30E00;
          v25 = 1168;
        }
        else
        {
          if (v13 <= (71 - __clz(v22)) >> 3)
            goto LABEL_15;
          v23 = 0x8000000217E30E50;
          v24 = 0xD000000000000031;
          v25 = 1173;
        }
        v26 = sub_217E05734(v24, v23, (uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, v25);
        sub_217E04C24();
        swift_allocError();
        *v27 = v26;
        swift_willThrow();
      }
LABEL_15:
      swift_unknownObjectRelease();
      return;
    }
LABEL_18:
    __break(1u);
  }
}

uint64_t sub_217E06C4C(uint64_t result, uint64_t a2, uint64_t a3, int64_t a4, unint64_t a5)
{
  int64_t v5;
  uint64_t v6;
  int64_t v7;

  if (result < 0)
  {
    __break(1u);
    goto LABEL_13;
  }
  v5 = a5 >> 1;
  v6 = (a5 >> 1) - a4;
  if (__OFSUB__(a5 >> 1, a4))
  {
LABEL_13:
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  if (!result || v6 < 0 || (v7 = a5 >> 1, v6 >= result))
  {
    v7 = a4 + result;
    if (__OFADD__(a4, result))
      goto LABEL_18;
  }
  if (v7 < a4)
    goto LABEL_14;
  if (v5 < a4)
  {
LABEL_15:
    __break(1u);
    goto LABEL_16;
  }
  if (v5 >= v7)
  {
    if ((v7 & 0x8000000000000000) == 0)
      return a2;
    goto LABEL_17;
  }
LABEL_16:
  __break(1u);
LABEL_17:
  __break(1u);
LABEL_18:
  __break(1u);
  return result;
}

uint64_t sub_217E06CCC(uint64_t result, uint64_t a2, uint64_t a3, int64_t a4, unint64_t a5)
{
  int64_t v5;
  uint64_t v6;
  int64_t v7;

  if (result < 0)
  {
    __break(1u);
    goto LABEL_12;
  }
  v5 = a5 >> 1;
  v6 = (a5 >> 1) - a4;
  if (__OFSUB__(a5 >> 1, a4))
  {
LABEL_12:
    __break(1u);
    goto LABEL_13;
  }
  if (result)
  {
    if ((v6 & 0x8000000000000000) == 0)
    {
      v7 = a5 >> 1;
      if (v6 < result)
      {
LABEL_8:
        if (v7 >= a4)
        {
          if (v5 >= a4)
            return a2;
          goto LABEL_15;
        }
LABEL_14:
        __break(1u);
LABEL_15:
        __break(1u);
        goto LABEL_16;
      }
    }
  }
  v7 = a4 + result;
  if (!__OFADD__(a4, result))
  {
    if (v5 >= v7)
      goto LABEL_8;
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }
LABEL_16:
  __break(1u);
  return result;
}

uint64_t sub_217E06D3C()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  _BYTE v5[72];

  v1 = v0[1];
  v2 = v0[2];
  v3 = v0[3];
  sub_217E2D1E8();
  sub_217E0989C((uint64_t)v5, v1, v2, v3);
  return sub_217E2D218();
}

uint64_t sub_217E06D94(uint64_t a1)
{
  uint64_t v1;

  return sub_217E0989C(a1, *(_QWORD *)(v1 + 8), *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24));
}

uint64_t sub_217E06DA0()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  _BYTE v5[72];

  v1 = v0[1];
  v2 = v0[2];
  v3 = v0[3];
  sub_217E2D1E8();
  sub_217E0989C((uint64_t)v5, v1, v2, v3);
  return sub_217E2D218();
}

uint64_t sub_217E06DF4(uint64_t a1, uint64_t a2)
{
  return sub_217E08F3C(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24));
}

uint64_t sub_217E06E10()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  _BYTE v5[72];

  v1 = v0[1];
  v2 = v0[2];
  v3 = v0[3];
  sub_217E2D1E8();
  sub_217E0989C((uint64_t)v5, v1, v2, v3);
  sub_217E2D1F4();
  return sub_217E2D218();
}

uint64_t sub_217E06E7C(uint64_t a1)
{
  uint64_t v1;

  sub_217E0989C(a1, *(_QWORD *)(v1 + 8), *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24));
  return sub_217E2D1F4();
}

uint64_t sub_217E06EB0()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  _BYTE v5[72];

  v1 = v0[1];
  v2 = v0[2];
  v3 = v0[3];
  sub_217E2D1E8();
  sub_217E0989C((uint64_t)v5, v1, v2, v3);
  sub_217E2D1F4();
  return sub_217E2D218();
}

uint64_t sub_217E06F18(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1[4];
  v3 = a2[4];
  return sub_217E08F3C(a1[1], a1[2], a1[3], a2[1], a2[2], a2[3]) & (v2 == v3);
}

uint64_t sub_217E06F58@<X0>(uint64_t a1@<X8>)
{
  _BYTE v3[96];

  sub_217E05C84((uint64_t)v3);
  return sub_217E09AF4((uint64_t)v3, a1, &qword_254F27780);
}

__n128 sub_217E06F98@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v2;
  __n128 result;
  __int128 v4;

  v2 = *(_QWORD *)(v1 + 32);
  result = *(__n128 *)v1;
  v4 = *(_OWORD *)(v1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v1;
  *(_OWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 32) = v2;
  return result;
}

uint64_t sub_217E06FAC()
{
  return 0;
}

uint64_t sub_217E06FB4()
{
  return 2;
}

uint64_t sub_217E06FBC()
{
  uint64_t v0;
  uint64_t v1;

  v1 = sub_217E094B8(*(_QWORD *)v0, *(_QWORD *)(v0 + 8), *(_QWORD *)(v0 + 16), *(_QWORD *)(v0 + 24));
  swift_unknownObjectRelease();
  return v1;
}

uint64_t sub_217E06FF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_217E07FF0(a1, a2, a3);
}

uint64_t sub_217E0702C()
{
  return sub_217E2CFFC();
}

uint64_t sub_217E0704C(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE v17[48];
  _BYTE v18[8];
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;

  v2 = v1;
  sub_217E2D1F4();
  sub_217E2D1F4();
  sub_217E04CC0((uint64_t)(v2 + 2), (uint64_t)v17);
  sub_217E04CC0((uint64_t)v17, (uint64_t)v18);
  v4 = v19;
  v5 = v20;
  v6 = v21;
  if ((v22 & 1) != 0)
  {
    sub_217E2D1F4();
    v7 = v6 >> 1;
    result = v7 - v5;
    if (__OFSUB__(v7, v5))
    {
LABEL_16:
      __break(1u);
LABEL_17:
      __break(1u);
      goto LABEL_18;
    }
    result = sub_217E2D1F4();
    v9 = __OFSUB__(v7, v5);
    v10 = v7 - v5;
    if (v10)
    {
      if ((v10 < 0) ^ v9 | (v10 == 0))
      {
LABEL_18:
        __break(1u);
        return result;
      }
      v11 = v4 + v5;
      do
      {
        ++v11;
        sub_217E2D200();
        --v10;
      }
      while (v10);
    }
  }
  else
  {
    sub_217E2D1F4();
    sub_217E0989C(a1, v4, v5, v6);
    sub_217E2D1F4();
  }
  v12 = v2[10];
  v13 = v2[11] >> 1;
  result = v13 - v12;
  if (__OFSUB__(v13, v12))
  {
    __break(1u);
    goto LABEL_16;
  }
  v14 = v2[9];
  result = sub_217E2D1F4();
  v15 = v13 - v12;
  if (v13 == v12)
    return result;
  if (v13 <= v12)
    goto LABEL_17;
  v16 = v14 + v12;
  do
  {
    ++v16;
    result = sub_217E2D200();
    --v15;
  }
  while (v15);
  return result;
}

uint64_t sub_217E0716C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[4];
  char v13;

  v2 = v1;
  sub_217E04CC0(v2, (uint64_t)v12);
  v4 = v12[1];
  v5 = v12[2];
  v6 = v12[3];
  if ((v13 & 1) == 0)
  {
    sub_217E2D1F4();
    sub_217E0989C(a1, v4, v5, v6);
    return sub_217E2D1F4();
  }
  sub_217E2D1F4();
  v7 = v6 >> 1;
  result = v7 - v5;
  if (__OFSUB__(v7, v5))
  {
    __break(1u);
    goto LABEL_11;
  }
  result = sub_217E2D1F4();
  v9 = __OFSUB__(v7, v5);
  v10 = v7 - v5;
  if (!v10)
    return result;
  if ((v10 < 0) ^ v9 | (v10 == 0))
  {
LABEL_11:
    __break(1u);
    return result;
  }
  v11 = v4 + v5;
  do
  {
    ++v11;
    result = sub_217E2D200();
    --v10;
  }
  while (v10);
  return result;
}

uint64_t sub_217E0722C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t result;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE v9[72];
  _BYTE v10[8];
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;

  sub_217E2D1E8();
  sub_217E04CC0(v0, (uint64_t)v10);
  v1 = v11;
  v2 = v12;
  v3 = v13;
  if ((v14 & 1) == 0)
  {
    sub_217E2D1F4();
    sub_217E0989C((uint64_t)v9, v1, v2, v3);
    sub_217E2D1F4();
    return sub_217E2D218();
  }
  sub_217E2D1F4();
  v4 = v3 >> 1;
  result = v4 - v2;
  if (__OFSUB__(v4, v2))
  {
    __break(1u);
    goto LABEL_11;
  }
  result = sub_217E2D1F4();
  v6 = __OFSUB__(v4, v2);
  v7 = v4 - v2;
  if (!v7)
    return sub_217E2D218();
  if (!((v7 < 0) ^ v6 | (v7 == 0)))
  {
    v8 = v1 + v2;
    do
    {
      ++v8;
      sub_217E2D200();
      --v7;
    }
    while (v7);
    return sub_217E2D218();
  }
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_217E0730C()
{
  __int128 *v0;
  __int128 v1;
  __int128 v2;
  __int128 v3;
  _BYTE v5[72];
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  v1 = v0[3];
  v8 = v0[2];
  v9 = v1;
  v2 = v0[5];
  v10 = v0[4];
  v11 = v2;
  v3 = v0[1];
  v6 = *v0;
  v7 = v3;
  sub_217E2D1E8();
  sub_217E0704C((uint64_t)v5);
  return sub_217E2D218();
}

uint64_t sub_217E07368(uint64_t a1)
{
  return sub_217E0704C(a1);
}

uint64_t sub_217E073A8()
{
  __int128 *v0;
  __int128 v1;
  __int128 v2;
  __int128 v3;
  _BYTE v5[72];
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  v1 = v0[3];
  v8 = v0[2];
  v9 = v1;
  v2 = v0[5];
  v10 = v0[4];
  v11 = v2;
  v3 = v0[1];
  v6 = *v0;
  v7 = v3;
  sub_217E2D1E8();
  sub_217E0704C((uint64_t)v5);
  return sub_217E2D218();
}

uint64_t sub_217E07400(_OWORD *a1, _OWORD *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  _OWORD v9[6];
  _OWORD v10[6];

  v2 = a1[3];
  v9[2] = a1[2];
  v9[3] = v2;
  v3 = a1[5];
  v9[4] = a1[4];
  v9[5] = v3;
  v4 = a1[1];
  v9[0] = *a1;
  v9[1] = v4;
  v5 = a2[3];
  v10[2] = a2[2];
  v10[3] = v5;
  v6 = a2[5];
  v10[4] = a2[4];
  v10[5] = v6;
  v7 = a2[1];
  v10[0] = *a2;
  v10[1] = v7;
  return sub_217E0938C((uint64_t)v9, (uint64_t)v10) & 1;
}

uint64_t sub_217E07458()
{
  uint64_t v0;
  uint64_t v2;

  sub_217E04CC0(v0, (uint64_t)&v2);
  return sub_217E0722C();
}

uint64_t sub_217E0748C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v4;

  sub_217E04CC0(v1, (uint64_t)&v4);
  return sub_217E0716C(a1);
}

uint64_t sub_217E074C8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  char v4;
  unint64_t v5;
  uint64_t result;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE v10[72];

  v1 = *(_QWORD *)(v0 + 8);
  v2 = *(_QWORD *)(v0 + 16);
  v3 = *(_QWORD *)(v0 + 24);
  v4 = *(_BYTE *)(v0 + 40);
  sub_217E2D1E8();
  if ((v4 & 1) == 0)
  {
    sub_217E2D1F4();
    sub_217E0989C((uint64_t)v10, v1, v2, v3);
    sub_217E2D1F4();
    return sub_217E2D218();
  }
  sub_217E2D1F4();
  v5 = v3 >> 1;
  result = v5 - v2;
  if (__OFSUB__(v5, v2))
  {
    __break(1u);
    goto LABEL_11;
  }
  result = sub_217E2D1F4();
  v7 = __OFSUB__(v5, v2);
  v8 = v5 - v2;
  if (!v8)
    return sub_217E2D218();
  if (!((v8 < 0) ^ v7 | (v8 == 0)))
  {
    v9 = v1 + v2;
    do
    {
      ++v9;
      sub_217E2D200();
      --v8;
    }
    while (v8);
    return sub_217E2D218();
  }
LABEL_11:
  __break(1u);
  return result;
}

uint64_t sub_217E07594(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a1 + 24);
  v7 = *(_QWORD *)(a2 + 8);
  v8 = *(_QWORD *)(a2 + 16);
  v9 = *(_QWORD *)(a2 + 24);
  if ((*(_BYTE *)(a1 + 40) & 1) != 0)
  {
    if ((*(_BYTE *)(a2 + 40) & 1) != 0)
      return sub_217E085E8(v4, v5, v6, v7, v8, v9);
    return 0;
  }
  if ((*(_BYTE *)(a2 + 40) & 1) != 0)
    return 0;
  v11 = *(_QWORD *)(a1 + 32);
  v12 = *(_QWORD *)(a2 + 32);
  return sub_217E08F3C(v4, v5, v6, v7, v8, v9) & (v11 == v12);
}

unint64_t sub_217E07608()
{
  unint64_t result;

  result = qword_254F277C0;
  if (!qword_254F277C0)
  {
    result = MEMORY[0x219A1838C](&unk_217E32E38, &type metadata for ASN1Node.Content);
    atomic_store(result, (unint64_t *)&qword_254F277C0);
  }
  return result;
}

unint64_t sub_217E07650()
{
  unint64_t result;

  result = qword_254F277C8;
  if (!qword_254F277C8)
  {
    result = MEMORY[0x219A1838C](&unk_217E32F08, &type metadata for ASN1NodeCollection.Iterator);
    atomic_store(result, (unint64_t *)&qword_254F277C8);
  }
  return result;
}

unint64_t sub_217E07698()
{
  unint64_t result;

  result = qword_254F277D0;
  if (!qword_254F277D0)
  {
    result = MEMORY[0x219A1838C](&unk_217E32F38, &type metadata for ASN1NodeCollection);
    atomic_store(result, (unint64_t *)&qword_254F277D0);
  }
  return result;
}

unint64_t sub_217E076E0()
{
  unint64_t result;

  result = qword_254F277D8;
  if (!qword_254F277D8)
  {
    result = MEMORY[0x219A1838C](&unk_217E32FA0, &type metadata for DER.ParseResult);
    atomic_store(result, (unint64_t *)&qword_254F277D8);
  }
  return result;
}

unint64_t sub_217E07728()
{
  unint64_t result;

  result = qword_254F277E0;
  if (!qword_254F277E0)
  {
    result = MEMORY[0x219A1838C](&unk_217E33030, &type metadata for DER.ParserNode);
    atomic_store(result, (unint64_t *)&qword_254F277E0);
  }
  return result;
}

uint64_t sub_217E0776C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_217E0833C();
  return sub_217E09BF8(a5);
}

uint64_t sub_217E0779C(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  int64_t v25;
  int64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  int64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;

  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a2 + 32);
  v5 = *(_QWORD *)(a2 + 40);
  v7 = *(_QWORD *)(a2 + 48);
  if ((*(_BYTE *)(a2 + 56) & 1) != 0)
  {
    v35 = *(unsigned __int8 *)(a2 + 56);
    j__swift_unknownObjectRetain(v3, v4, v6, v5, v7, 1);
    sub_217E20404(v3, v4, v6, v5);
    return j__swift_unknownObjectRelease(v3, v4, v6, v5, v7, v35);
  }
  else
  {
    v41 = result;
    v8 = *(_QWORD *)(a2 + 40);
    v9 = v5 >> 1;
    if (v6 != v9)
    {
      v35 = *(unsigned __int8 *)(a2 + 56);
      v58 = v2;
      v32 = v7;
      j__swift_unknownObjectRetain(v3, v4, v6, v8, v7, 0);
      v39 = v8 & 0xFFFFFFFFFFFFFFFELL;
      v37 = v3;
      swift_unknownObjectRetain();
      v36 = v4 + 112;
      v10 = v6;
      v33 = v8;
      v34 = v6;
      v40 = v4;
      v38 = v9;
      while (v10 < (uint64_t)(v8 >> 1))
      {
        if (v9 <= v10)
          goto LABEL_46;
        if (v8 >> 1 < v9)
          goto LABEL_47;
        v11 = v4 + 96 * v10;
        v12 = *(_QWORD *)v11;
        v13 = *(unsigned __int8 *)(v11 + 8);
        v14 = *(unsigned __int8 *)(v11 + 24);
        v15 = v10 + 1;
        v16 = v8 & 1;
        v45 = v16;
        v43 = *(_OWORD *)(v11 + 48);
        v44 = *(_OWORD *)(v11 + 32);
        if (*(_BYTE *)(v11 + 24))
        {
          v17 = *(_QWORD *)(v11 + 16);
          if (v15 == v9)
          {
            v18 = v9;
          }
          else
          {
            v22 = (_QWORD *)(v36 + 96 * v10);
            v18 = v10 + 1;
            do
            {
              if (v18 >= v9)
              {
LABEL_43:
                __break(1u);
LABEL_44:
                __break(1u);
                goto LABEL_45;
              }
              if (v17 >= *v22)
                goto LABEL_19;
              v23 = v18 + 1;
              if (__OFADD__(v18, 1))
                goto LABEL_44;
              ++v18;
              v22 += 12;
            }
            while (v23 != v9);
            v18 = v9;
LABEL_19:
            if (v18 <= v10)
              goto LABEL_48;
            if (v18 < 0)
              goto LABEL_49;
          }
          v24 = v18 - v15;
          if (__OFSUB__(v18, v15))
            goto LABEL_50;
          if (v24 < 0)
            goto LABEL_51;
          v25 = v9 - v15;
          if (__OFSUB__(v9, v15))
            goto LABEL_52;
          if (!v24 || v25 < 0 || (v26 = v9, v25 >= v24))
          {
            v26 = v18;
            if (__OFADD__(v15, v24))
              goto LABEL_55;
            if (v9 < v18)
              goto LABEL_53;
          }
          if (v26 <= v10)
            goto LABEL_54;
          if (v15 != v18)
          {
            if (v15 >= v18)
              goto LABEL_56;
            v27 = (uint64_t *)(v36 + 96 * v10);
            do
            {
              v28 = *v27;
              v27 += 12;
              if (v17 >= v28)
              {
                __break(1u);
                goto LABEL_43;
              }
              --v24;
            }
            while (v24);
            if (*(_QWORD *)(v4 + 96 * v15 + 16) != v17 + 1)
              goto LABEL_57;
          }
          v42 = v26;
          v20 = v13;
          v47 = v16 | (2 * v18);
          v19 = v37;
          swift_unknownObjectRetain();
          v46 = v4;
        }
        else
        {
          v19 = *(_QWORD *)(v11 + 64);
          if (!v19)
            goto LABEL_58;
          v20 = *(unsigned __int8 *)(v11 + 8);
          v21 = *(_QWORD *)(v11 + 80);
          v46 = *(_QWORD *)(v11 + 72);
          v47 = *(_QWORD *)(v11 + 88);
          swift_unknownObjectRetain();
          v17 = 0;
          v42 = v15;
          v15 = v21;
        }
        v29 = v14;
        v30 = v14 ^ 1;
        v48 = v12;
        v49 = v20;
        v50 = v19;
        v51 = v46;
        v52 = v15;
        v53 = v47;
        v54 = v17;
        v55 = v30;
        v56 = v44;
        v57 = v43;
        swift_unknownObjectRetain();
        j__swift_unknownObjectRetain(v19, v46, v15, v47, v17, v30);
        swift_unknownObjectRetain();
        v31 = v58;
        sub_217E0776C(v12, v20, v29, v41, (uint64_t)&v48);
        v58 = v31;
        if (v31)
          goto LABEL_59;
        v8 = v45 | v39;
        j__swift_unknownObjectRelease(v19, v46, v15, v47, v17, v30);
        swift_unknownObjectRelease();
        v10 = v42;
        v9 = v38;
        v4 = v40;
        if (v42 == v38)
        {
          v3 = v37;
          swift_unknownObjectRelease();
          v5 = v33;
          v6 = v34;
          v7 = v32;
          return j__swift_unknownObjectRelease(v3, v4, v6, v5, v7, v35);
        }
      }
LABEL_45:
      __break(1u);
LABEL_46:
      __break(1u);
LABEL_47:
      __break(1u);
LABEL_48:
      __break(1u);
LABEL_49:
      __break(1u);
LABEL_50:
      __break(1u);
LABEL_51:
      __break(1u);
LABEL_52:
      __break(1u);
LABEL_53:
      __break(1u);
LABEL_54:
      __break(1u);
LABEL_55:
      __break(1u);
LABEL_56:
      __break(1u);
LABEL_57:
      __break(1u);
LABEL_58:
      __break(1u);
LABEL_59:
      result = swift_unexpectedError();
      __break(1u);
    }
  }
  return result;
}

uint64_t sub_217E07B84(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;

  if (result < 1)
    goto LABEL_28;
  v6 = a3;
  v7 = *v4;
  v8 = *(_QWORD *)(*v4 + 16);
  v9 = v8 - a3;
  if (__OFSUB__(v8, a3))
    goto LABEL_29;
  v3 = a2;
  v5 = result;
  if (v9 >= result)
    goto LABEL_13;
  v10 = result - v9;
  if (__OFSUB__(result, v9))
  {
    __break(1u);
    goto LABEL_32;
  }
  if (v10 < 0)
  {
LABEL_32:
    __break(1u);
LABEL_33:
    result = (uint64_t)sub_217E0E2EC(0, v8 + 1, 1, (char *)v7);
    v7 = result;
LABEL_8:
    v11 = *(_QWORD *)(v7 + 16);
    do
    {
      v12 = *(_QWORD *)(v7 + 24);
      if (v11 >= v12 >> 1)
      {
        result = (uint64_t)sub_217E0E2EC((char *)(v12 > 1), v11 + 1, 1, (char *)v7);
        v7 = result;
      }
      *(_QWORD *)(v7 + 16) = v11 + 1;
      *(_BYTE *)(v7 + v11++ + 32) = 0;
      --v10;
    }
    while (v10);
    *v4 = v7;
    goto LABEL_13;
  }
  if (v10)
  {
    result = swift_isUniquelyReferenced_nonNull_native();
    if ((result & 1) != 0)
      goto LABEL_8;
    goto LABEL_33;
  }
LABEL_13:
  if (v6 == v3)
    return result;
  result = swift_isUniquelyReferenced_nonNull_native();
  if ((result & 1) == 0)
    goto LABEL_30;
  do
  {
    while (1)
    {
      if (v6 <= v3)
      {
        __break(1u);
LABEL_24:
        __break(1u);
LABEL_25:
        __break(1u);
LABEL_26:
        __break(1u);
        goto LABEL_27;
      }
      v13 = v6 - 1 + v5;
      if (__OFADD__(v6 - 1, v5))
        goto LABEL_24;
      v14 = v6 - 1;
      if (v6 < 1)
        goto LABEL_25;
      v15 = *(_QWORD *)(v7 + 16);
      if (v14 >= v15)
        goto LABEL_26;
      if (v13 < v15)
        break;
LABEL_27:
      __break(1u);
LABEL_28:
      __break(1u);
LABEL_29:
      __break(1u);
LABEL_30:
      result = (uint64_t)sub_217E200A4(v7);
      v7 = result;
    }
    *(_BYTE *)(v7 + 32 + v13) = *(_BYTE *)(v7 + v6-- + 31);
  }
  while (v14 != v3);
  *v4 = v7;
  return result;
}

uint64_t sub_217E07D08()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;
  BOOL v3;
  uint64_t v4;

  v0 = sub_217E2D0EC();
  result = sub_217E2D170();
  v2 = v0 - result;
  if (__OFSUB__(v0, result))
  {
    __break(1u);
  }
  else
  {
    v3 = __OFADD__(v2, 7);
    v4 = v2 + 7;
    if (!v3)
      return v4 / 8;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E07D70(uint64_t result, int64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int64_t v8;
  _BOOL4 v9;
  BOOL v10;
  int64_t *v11;
  uint64_t v12;
  uint64_t v13;
  int64_t *v14;
  uint64_t v15;
  BOOL v16;
  int64_t v17;
  BOOL v18;
  uint64_t v19;
  int64_t v20;
  unint64_t v21;
  int64_t v22;
  uint64_t v23;
  int64_t *v24;
  int64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  BOOL v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;

  v5 = result;
  v6 = 0;
  v7 = 32;
  v8 = result;
  while (1)
  {
    v9 = v8 <= a2;
    if (a3 > 0)
      v9 = v8 >= a2;
    if (v9)
      break;
    v10 = __OFADD__(v8, a3);
    v8 += a3;
    if (v10)
      v8 = (v8 >> 63) ^ 0x8000000000000000;
    v7 += 8;
    v10 = __OFADD__(v6++, 1);
    if (v10)
    {
      __break(1u);
      break;
    }
  }
  if (v6 > 0)
  {
    __swift_instantiateConcreteTypeFromMangledName(&qword_254F277F8);
    v11 = (int64_t *)swift_allocObject();
    result = _swift_stdlib_malloc_size(v11);
    v12 = result - 32;
    if (result < 32)
      v12 = result - 25;
    v13 = v12 >> 3;
    v11[2] = v6;
    v11[3] = 2 * v13;
    v14 = v11 + 4;
    v15 = v13 & 0x7FFFFFFFFFFFFFFFLL;
LABEL_15:
    v15 -= v6;
    while (1)
    {
      v16 = v5 <= a2;
      if (a3 > 0)
        v16 = v5 >= a2;
      if (v16)
        break;
      if (__OFADD__(v5, a3))
        v17 = ((v5 + a3) >> 63) ^ 0x8000000000000000;
      else
        v17 = v5 + a3;
      *v14++ = v5;
      v5 = v17;
      if (!--v6)
        goto LABEL_23;
    }
    __break(1u);
LABEL_57:
    __break(1u);
LABEL_58:
    __break(1u);
    goto LABEL_59;
  }
  v11 = (int64_t *)MEMORY[0x24BEE4AF8];
  v14 = (int64_t *)(MEMORY[0x24BEE4AF8] + 32);
  v15 = *(_QWORD *)(MEMORY[0x24BEE4AF8] + 24) >> 1;
  if (v6)
    goto LABEL_15;
  v17 = result;
LABEL_23:
  v18 = v17 <= a2;
  if (a3 > 0)
    v18 = v17 >= a2;
  if (!v18)
  {
    v19 = (a3 >> 63) ^ 0x7FFFFFFFFFFFFFFFLL;
    do
    {
      v20 = v17 + a3;
      if (__OFADD__(v17, a3))
      {
        v20 = v19;
        if (!v15)
          goto LABEL_32;
        v20 = v19;
      }
      else if (!v15)
      {
LABEL_32:
        v21 = v11[3];
        if ((uint64_t)((v21 >> 1) + 0x4000000000000000) < 0)
          goto LABEL_58;
        v22 = v21 & 0xFFFFFFFFFFFFFFFELL;
        if (v22 <= 1)
          v23 = 1;
        else
          v23 = v22;
        __swift_instantiateConcreteTypeFromMangledName(&qword_254F277F8);
        v24 = (int64_t *)swift_allocObject();
        v25 = _swift_stdlib_malloc_size(v24);
        v26 = v25 - 32;
        if (v25 < 32)
          v26 = v25 - 25;
        v27 = v26 >> 3;
        v24[2] = v23;
        v24[3] = 2 * (v26 >> 3);
        v28 = (unint64_t)(v24 + 4);
        v29 = (unint64_t)v11[3] >> 1;
        if (v11[2])
        {
          if (v24 != v11 || v28 >= (unint64_t)&v11[v29 + 4])
            memmove(v24 + 4, v11 + 4, 8 * v29);
          v11[2] = 0;
        }
        v14 = (int64_t *)(v28 + 8 * v29);
        v15 = (v27 & 0x7FFFFFFFFFFFFFFFLL) - v29;
        result = swift_release();
        v11 = v24;
        v19 = (a3 >> 63) ^ 0x7FFFFFFFFFFFFFFFLL;
      }
      v10 = __OFSUB__(v15--, 1);
      if (v10)
        goto LABEL_57;
      *v14++ = v17;
      v31 = v20 <= a2;
      if (a3 > 0)
        v31 = v20 >= a2;
      v17 = v20;
    }
    while (!v31);
  }
  v32 = v11[3];
  if (v32 < 2)
    return (uint64_t)v11;
  v33 = v32 >> 1;
  v10 = __OFSUB__(v33, v15);
  v34 = v33 - v15;
  if (!v10)
  {
    v11[2] = v34;
    return (uint64_t)v11;
  }
LABEL_59:
  __break(1u);
  return result;
}

uint64_t sub_217E07FF0(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  int64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;
  int64_t v12;
  uint64_t v13;
  int64_t v14;
  _QWORD *v15;
  int64_t v16;
  int64_t v17;
  int64_t v18;
  int64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  int64_t v30;
  uint64_t v31;
  char v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = a3;
  v5 = v3[1];
  v31 = *v3;
  v6 = v3[2];
  v29 = *(_OWORD *)(v3 + 3);
  if (!a2)
    goto LABEL_5;
  if (!a3)
  {
LABEL_43:
    *(_QWORD *)result = v31;
    *(_QWORD *)(result + 8) = v5;
    *(_QWORD *)(result + 16) = v6;
    *(_OWORD *)(result + 24) = v29;
    return v35;
  }
  if ((a3 & 0x8000000000000000) == 0)
  {
    v7 = (unint64_t)v29 >> 1;
    if (v6 == (unint64_t)v29 >> 1)
    {
LABEL_5:
      v35 = 0;
      goto LABEL_43;
    }
    v27 = result;
    if (v6 >= (uint64_t)((unint64_t)v29 >> 1))
    {
LABEL_40:
      __break(1u);
LABEL_41:
      v12 = (unint64_t)v29 >> 1;
      v35 = v4;
LABEL_42:
      swift_unknownObjectRetain();
      v6 = v12;
      result = v27;
      goto LABEL_43;
    }
    v8 = a2;
    v28 = v5 + 112;
    v4 = 1;
    while (v7 > v6)
    {
      v9 = (uint64_t *)(v5 + 96 * v6);
      v10 = *v9;
      v11 = *((_BYTE *)v9 + 8);
      v12 = v6 + 1;
      v33 = *((_OWORD *)v9 + 3);
      v34 = *((_OWORD *)v9 + 2);
      v32 = *((_BYTE *)v9 + 24);
      if (v32)
      {
        v13 = v9[2];
        v14 = (unint64_t)v29 >> 1;
        if (v12 != v7)
        {
          v15 = (_QWORD *)(v28 + 96 * v6);
          v14 = v6 + 1;
          do
          {
            if (v14 >= v7)
            {
LABEL_45:
              __break(1u);
LABEL_46:
              __break(1u);
              goto LABEL_47;
            }
            if (v13 >= *v15)
              goto LABEL_17;
            v16 = v14 + 1;
            if (__OFADD__(v14, 1))
              goto LABEL_46;
            ++v14;
            v15 += 12;
          }
          while (v16 != v7);
          v14 = (unint64_t)v29 >> 1;
LABEL_17:
          if (v14 <= v6)
            goto LABEL_48;
          if (v14 < 0)
            goto LABEL_49;
        }
        v17 = v14 - v12;
        if (__OFSUB__(v14, v12))
          goto LABEL_50;
        if (v17 < 0)
          goto LABEL_51;
        v18 = v7 - v12;
        if (__OFSUB__(v7, v12))
          goto LABEL_52;
        if (!v17 || v18 < 0 || (v19 = (unint64_t)v29 >> 1, v18 >= v17))
        {
          v19 = v14;
          if (__OFADD__(v12, v17))
            goto LABEL_55;
          if (v7 < v14)
            goto LABEL_53;
        }
        if (v19 <= v6)
          goto LABEL_54;
        if (v12 != v14)
        {
          if (v12 >= v14)
            goto LABEL_56;
          v20 = (uint64_t *)(v28 + 96 * v6);
          do
          {
            v21 = *v20;
            v20 += 12;
            if (v13 >= v21)
            {
              __break(1u);
              goto LABEL_45;
            }
            --v17;
          }
          while (v17);
          if (*(_QWORD *)(v5 + 96 * v12 + 16) != v13 + 1)
            goto LABEL_57;
        }
        v22 = v29 & 1 | (2 * v14);
        v23 = swift_unknownObjectRetain();
        v24 = v12;
        v12 = v19;
        v25 = v22;
        v26 = v5;
      }
      else
      {
        result = v9[8];
        if (!result)
          goto LABEL_59;
        v26 = v9[9];
        v30 = v9[10];
        v25 = v9[11];
        v23 = swift_unknownObjectRetain();
        v13 = 0;
        v24 = v30;
      }
      *(_QWORD *)v8 = v10;
      *(_BYTE *)(v8 + 8) = v11;
      *(_QWORD *)(v8 + 16) = v23;
      *(_QWORD *)(v8 + 24) = v26;
      *(_QWORD *)(v8 + 32) = v24;
      *(_QWORD *)(v8 + 40) = v25;
      *(_QWORD *)(v8 + 48) = v13;
      *(_BYTE *)(v8 + 56) = v32 ^ 1;
      *(_OWORD *)(v8 + 64) = v34;
      *(_OWORD *)(v8 + 80) = v33;
      if (v4 == v35)
        goto LABEL_42;
      if (v12 == v7)
        goto LABEL_41;
      ++v4;
      v8 += 96;
      result = swift_unknownObjectRetain();
      v6 = v12;
      if (v12 >= v7)
        goto LABEL_40;
    }
LABEL_47:
    __break(1u);
LABEL_48:
    __break(1u);
LABEL_49:
    __break(1u);
LABEL_50:
    __break(1u);
LABEL_51:
    __break(1u);
LABEL_52:
    __break(1u);
LABEL_53:
    __break(1u);
LABEL_54:
    __break(1u);
LABEL_55:
    __break(1u);
LABEL_56:
    __break(1u);
LABEL_57:
    __break(1u);
  }
  __break(1u);
LABEL_59:
  __break(1u);
  return result;
}

void sub_217E082B4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  sub_217E09C38(a1, a2, a3, a4, a5);
}

uint64_t sub_217E082C8@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, _QWORD *a6@<X8>)
{
  int64_t v6;
  _QWORD *v7;
  uint64_t v8;

  v6 = a4 >> 1;
  if (a4 >> 1 == a3)
  {
LABEL_7:
    *a6 = result;
    a6[1] = a2;
    a6[2] = a3;
    a6[3] = a4;
    a6[4] = a5;
  }
  else
  {
    v7 = (_QWORD *)(a2 + 96 * a3 + 16);
    v8 = a3;
    do
    {
      if (v8 >= v6)
      {
        __break(1u);
LABEL_9:
        __break(1u);
        goto LABEL_10;
      }
      if (*v7 <= a5)
        goto LABEL_9;
      ++v8;
      v7 += 12;
    }
    while (v6 != v8);
    if (*(_QWORD *)(a2 + 96 * a3 + 16) == a5 + 1)
      goto LABEL_7;
LABEL_10:
    __break(1u);
  }
  return result;
}

uint64_t sub_217E0833C(unint64_t a1, char a2, char a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  unint64_t v6;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t result;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;

  sub_217E22B5C(a1, a2, a3);
  v9 = *(char **)a4;
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
    goto LABEL_32;
  while (1)
  {
    v11 = *((_QWORD *)v9 + 2);
    v10 = *((_QWORD *)v9 + 3);
    v12 = v11 + 1;
    if (v11 >= v10 >> 1)
      v9 = sub_217E0E2EC((char *)(v10 > 1), v11 + 1, 1, v9);
    *((_QWORD *)v9 + 2) = v12;
    v9[v11 + 32] = 0;
    *(_QWORD *)a4 = v9;
    result = sub_217E0779C(a4, a5);
    if (v5)
      return result;
    a5 = *(_QWORD *)a4;
    v14 = *(_QWORD *)(*(_QWORD *)a4 + 16);
    v15 = v14 - v12;
    if ((uint64_t)(v14 - v12) <= 127)
      break;
    if (v14 <= v11)
    {
      __break(1u);
    }
    else
    {
      v6 = 71 - __clz(v15);
      v9 = (char *)(v6 >> 3);
      sub_217E07B84(v6 >> 3, v11 + 1, v14);
      a5 = *(_QWORD *)a4;
      result = swift_isUniquelyReferenced_nonNull_native();
      if ((result & 1) != 0)
        goto LABEL_8;
    }
    result = (uint64_t)sub_217E200A4(a5);
    a5 = result;
LABEL_8:
    if (v11 >= *(_QWORD *)(a5 + 16))
    {
      __break(1u);
      goto LABEL_36;
    }
    v16 = a5 + 32;
    *(_BYTE *)(a5 + 32 + v11) = (v6 >> 3) | 0x80;
    *(_QWORD *)a4 = a5;
    if (v11 + 1 < *(_QWORD *)(a5 + 16))
    {
      *(_BYTE *)(v16 + v11 + 1) = v15 >> (8 * (((_BYTE)v9 - 1) & 7u));
      if (v9 == (char *)1)
        goto LABEL_29;
      if (v11 + 2 < *(_QWORD *)(a5 + 16))
      {
        *(_BYTE *)(v16 + v11 + 2) = v15 >> (8 * (((_BYTE)v9 - 2) & 7u));
        if (v9 == (char *)2)
          goto LABEL_29;
        if (v11 + 3 < *(_QWORD *)(a5 + 16))
        {
          *(_BYTE *)(v16 + v11 + 3) = v15 >> (8 * (((_BYTE)v9 - 3) & 7u));
          if (v9 == (char *)3)
            goto LABEL_29;
          if (v11 + 4 < *(_QWORD *)(a5 + 16))
          {
            *(_BYTE *)(v16 + v11 + 4) = v15 >> (8 * (((_BYTE)v9 - 4) & 7u));
            if (v9 == (char *)4)
              goto LABEL_29;
            if (v11 + 5 < *(_QWORD *)(a5 + 16))
            {
              *(_BYTE *)(v16 + v11 + 5) = v15 >> (8 * (((_BYTE)v9 - 5) & 7u));
              if (v9 == (char *)5)
                goto LABEL_29;
              if (v11 + 6 < *(_QWORD *)(a5 + 16))
              {
                *(_BYTE *)(v16 + v11 + 6) = v15 >> (8 * (((_BYTE)v9 - 6) & 7u));
                if (v9 == (char *)6)
                  goto LABEL_29;
                if (v11 + 7 < *(_QWORD *)(a5 + 16))
                {
                  *(_BYTE *)(v16 + v11 + 7) = v15 >> (8 * (((_BYTE)v9 - 7) & 7u));
                  if (v9 == (char *)7)
                    goto LABEL_29;
                  if (v11 + 8 < *(_QWORD *)(a5 + 16))
                  {
                    *(_BYTE *)(v16 + v11 + 8) = v15 >> (v6 & 0x38);
LABEL_29:
                    *(_QWORD *)a4 = a5;
                    return result;
                  }
                }
              }
            }
          }
        }
      }
    }
    __break(1u);
LABEL_32:
    v9 = sub_217E0E2EC(0, *((_QWORD *)v9 + 2) + 1, 1, v9);
  }
  if ((v15 & 0x8000000000000000) != 0)
  {
LABEL_36:
    __break(1u);
    goto LABEL_37;
  }
  result = swift_isUniquelyReferenced_nonNull_native();
  if ((result & 1) != 0)
    goto LABEL_27;
LABEL_37:
  result = (uint64_t)sub_217E200A4(a5);
  a5 = result;
LABEL_27:
  if (v11 < *(_QWORD *)(a5 + 16))
  {
    *(_BYTE *)(a5 + v11 + 32) = v15;
    goto LABEL_29;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E085E8(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  int64_t v6;
  uint64_t v7;
  int64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;

  v6 = a3 >> 1;
  v7 = (a3 >> 1) - a2;
  if (!__OFSUB__(a3 >> 1, a2))
  {
    v8 = a6 >> 1;
    if (__OFSUB__(a6 >> 1, a5))
      goto LABEL_20;
    if (v7 != (a6 >> 1) - a5)
      return 0;
    if (!v7 || result + a2 == a4 + a5 || v6 == a2)
      return 1;
    if (v6 <= a2)
      goto LABEL_22;
    v9 = a2 + 1;
    v10 = *(unsigned __int8 *)(result + a2);
    if (v6 == a2)
      return 1;
    v11 = a5;
    if (v8 == a5)
      return 0;
    while (v11 >= a5 && v11 < v8)
    {
      if (v10 != *(unsigned __int8 *)(a4 + v11))
        return 0;
      if (v6 == v9)
        return 1;
      if (v9 >= v6)
        goto LABEL_21;
      v10 = *(unsigned __int8 *)(result + v9++);
      if (v8 == ++v11)
        return 0;
    }
    __break(1u);
  }
  __break(1u);
LABEL_20:
  __break(1u);
LABEL_21:
  __break(1u);
LABEL_22:
  __break(1u);
  return result;
}

uint64_t sub_217E086BC(unint64_t a1, char a2, char a3, char **a4, uint64_t (*a5)(char **))
{
  uint64_t v5;
  unint64_t v6;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t result;
  unint64_t v14;
  unint64_t v15;
  char *v16;

  sub_217E22B5C(a1, a2, a3);
  v9 = *a4;
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
    goto LABEL_32;
  while (1)
  {
    v11 = *((_QWORD *)v9 + 2);
    v10 = *((_QWORD *)v9 + 3);
    v12 = v11 + 1;
    if (v11 >= v10 >> 1)
      v9 = sub_217E0E2EC((char *)(v10 > 1), v11 + 1, 1, v9);
    *((_QWORD *)v9 + 2) = v12;
    v9[v11 + 32] = 0;
    *a4 = v9;
    result = a5(a4);
    if (v5)
      return result;
    v9 = *a4;
    v14 = *((_QWORD *)*a4 + 2);
    v15 = v14 - v12;
    if ((uint64_t)(v14 - v12) <= 127)
      break;
    if (v14 <= v11)
    {
      __break(1u);
    }
    else
    {
      v6 = 71 - __clz(v15);
      a5 = (uint64_t (*)(char **))(v6 >> 3);
      sub_217E07B84(v6 >> 3, v11 + 1, v14);
      v9 = *a4;
      result = swift_isUniquelyReferenced_nonNull_native();
      if ((result & 1) != 0)
        goto LABEL_8;
    }
    result = (uint64_t)sub_217E200A4((uint64_t)v9);
    v9 = (char *)result;
LABEL_8:
    if (v11 >= *((_QWORD *)v9 + 2))
    {
      __break(1u);
      goto LABEL_36;
    }
    v16 = v9 + 32;
    v9[v11 + 32] = (v6 >> 3) | 0x80;
    *a4 = v9;
    if (v11 + 1 < *((_QWORD *)v9 + 2))
    {
      v16[v11 + 1] = v15 >> (8 * (((_BYTE)a5 - 1) & 7u));
      if (a5 == (uint64_t (*)(char **))1)
        goto LABEL_29;
      if (v11 + 2 < *((_QWORD *)v9 + 2))
      {
        v16[v11 + 2] = v15 >> (8 * (((_BYTE)a5 - 2) & 7u));
        if (a5 == (uint64_t (*)(char **))2)
          goto LABEL_29;
        if (v11 + 3 < *((_QWORD *)v9 + 2))
        {
          v16[v11 + 3] = v15 >> (8 * (((_BYTE)a5 - 3) & 7u));
          if (a5 == (uint64_t (*)(char **))3)
            goto LABEL_29;
          if (v11 + 4 < *((_QWORD *)v9 + 2))
          {
            v16[v11 + 4] = v15 >> (8 * (((_BYTE)a5 - 4) & 7u));
            if (a5 == (uint64_t (*)(char **))4)
              goto LABEL_29;
            if (v11 + 5 < *((_QWORD *)v9 + 2))
            {
              v16[v11 + 5] = v15 >> (8 * (((_BYTE)a5 - 5) & 7u));
              if (a5 == (uint64_t (*)(char **))5)
                goto LABEL_29;
              if (v11 + 6 < *((_QWORD *)v9 + 2))
              {
                v16[v11 + 6] = v15 >> (8 * (((_BYTE)a5 - 6) & 7u));
                if (a5 == (uint64_t (*)(char **))6)
                  goto LABEL_29;
                if (v11 + 7 < *((_QWORD *)v9 + 2))
                {
                  v16[v11 + 7] = v15 >> (8 * (((_BYTE)a5 - 7) & 7u));
                  if (a5 == (uint64_t (*)(char **))7)
                    goto LABEL_29;
                  if (v11 + 8 < *((_QWORD *)v9 + 2))
                  {
                    v16[v11 + 8] = v15 >> (v6 & 0x38);
LABEL_29:
                    *a4 = v9;
                    return result;
                  }
                }
              }
            }
          }
        }
      }
    }
    __break(1u);
LABEL_32:
    v9 = sub_217E0E2EC(0, *((_QWORD *)v9 + 2) + 1, 1, v9);
  }
  if ((v15 & 0x8000000000000000) != 0)
  {
LABEL_36:
    __break(1u);
    goto LABEL_37;
  }
  result = swift_isUniquelyReferenced_nonNull_native();
  if ((result & 1) != 0)
    goto LABEL_27;
LABEL_37:
  result = (uint64_t)sub_217E200A4((uint64_t)v9);
  v9 = (char *)result;
LABEL_27:
  if (v11 < *((_QWORD *)v9 + 2))
  {
    v9[v11 + 32] = v15;
    goto LABEL_29;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E08974(unint64_t a1, char a2, char a3, char **a4, char *a5)
{
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  char *v10;
  uint64_t isUniquelyReferenced_nonNull_native;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t result;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  _OWORD v23[2];

  v7 = v5;
  sub_217E22B5C(a1, a2, a3);
  v10 = *a4;
  isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  if ((isUniquelyReferenced_nonNull_native & 1) == 0)
    goto LABEL_32;
  while (1)
  {
    v13 = *((_QWORD *)v10 + 2);
    v12 = *((_QWORD *)v10 + 3);
    v14 = v13 + 1;
    if (v13 >= v12 >> 1)
    {
      isUniquelyReferenced_nonNull_native = (uint64_t)sub_217E0E2EC((char *)(v12 > 1), v13 + 1, 1, v10);
      v10 = (char *)isUniquelyReferenced_nonNull_native;
    }
    *((_QWORD *)v10 + 2) = v14;
    v10[v13 + 32] = 0;
    *a4 = v10;
    MEMORY[0x24BDAC7A8](isUniquelyReferenced_nonNull_native);
    result = sub_217E086BC(0xCuLL, 0, 0, a4, (uint64_t (*)(char **))sub_217E09BB4);
    if (v7)
      return result;
    v16 = *((_OWORD *)a5 + 3);
    v23[0] = *((_OWORD *)a5 + 2);
    v23[1] = v16;
    v17 = *((_QWORD *)&v23[0] + 1);
    v10 = (char *)*((_QWORD *)&v16 + 1);
    v18 = v16;
    v19 = swift_unknownObjectRetain();
    sub_217E20404(v19, v17, v18, (unint64_t)v10);
    sub_217E09BD0((uint64_t)v23);
    a5 = *a4;
    v20 = *((_QWORD *)*a4 + 2);
    v21 = v20 - v14;
    if ((uint64_t)(v20 - v14) <= 127)
      break;
    if (v20 <= v13)
    {
      __break(1u);
    }
    else
    {
      v6 = 71 - __clz(v21);
      v10 = (char *)(v6 >> 3);
      sub_217E07B84(v6 >> 3, v13 + 1, v20);
      a5 = *a4;
      result = swift_isUniquelyReferenced_nonNull_native();
      if ((result & 1) != 0)
        goto LABEL_8;
    }
    result = (uint64_t)sub_217E200A4((uint64_t)a5);
    a5 = (char *)result;
LABEL_8:
    if (v13 >= *((_QWORD *)a5 + 2))
    {
      __break(1u);
      goto LABEL_36;
    }
    v22 = a5 + 32;
    a5[v13 + 32] = (v6 >> 3) | 0x80;
    *a4 = a5;
    if (v13 + 1 < *((_QWORD *)a5 + 2))
    {
      v22[v13 + 1] = v21 >> (8 * (((_BYTE)v10 - 1) & 7u));
      if (v10 == (char *)1)
        goto LABEL_29;
      if (v13 + 2 < *((_QWORD *)a5 + 2))
      {
        v22[v13 + 2] = v21 >> (8 * (((_BYTE)v10 - 2) & 7u));
        if (v10 == (char *)2)
          goto LABEL_29;
        if (v13 + 3 < *((_QWORD *)a5 + 2))
        {
          v22[v13 + 3] = v21 >> (8 * (((_BYTE)v10 - 3) & 7u));
          if (v10 == (char *)3)
            goto LABEL_29;
          if (v13 + 4 < *((_QWORD *)a5 + 2))
          {
            v22[v13 + 4] = v21 >> (8 * (((_BYTE)v10 - 4) & 7u));
            if (v10 == (char *)4)
              goto LABEL_29;
            if (v13 + 5 < *((_QWORD *)a5 + 2))
            {
              v22[v13 + 5] = v21 >> (8 * (((_BYTE)v10 - 5) & 7u));
              if (v10 == (char *)5)
                goto LABEL_29;
              if (v13 + 6 < *((_QWORD *)a5 + 2))
              {
                v22[v13 + 6] = v21 >> (8 * (((_BYTE)v10 - 6) & 7u));
                if (v10 == (char *)6)
                  goto LABEL_29;
                if (v13 + 7 < *((_QWORD *)a5 + 2))
                {
                  v22[v13 + 7] = v21 >> (8 * (((_BYTE)v10 - 7) & 7u));
                  if (v10 == (char *)7)
                    goto LABEL_29;
                  if (v13 + 8 < *((_QWORD *)a5 + 2))
                  {
                    v22[v13 + 8] = v21 >> (v6 & 0x38);
LABEL_29:
                    *a4 = a5;
                    return result;
                  }
                }
              }
            }
          }
        }
      }
    }
    __break(1u);
LABEL_32:
    isUniquelyReferenced_nonNull_native = (uint64_t)sub_217E0E2EC(0, *((_QWORD *)v10 + 2) + 1, 1, v10);
    v10 = (char *)isUniquelyReferenced_nonNull_native;
  }
  if ((v21 & 0x8000000000000000) != 0)
  {
LABEL_36:
    __break(1u);
    goto LABEL_37;
  }
  result = swift_isUniquelyReferenced_nonNull_native();
  if ((result & 1) != 0)
    goto LABEL_27;
LABEL_37:
  result = (uint64_t)sub_217E200A4((uint64_t)a5);
  a5 = (char *)result;
LABEL_27:
  if (v13 < *((_QWORD *)a5 + 2))
  {
    a5[v13 + 32] = v21;
    goto LABEL_29;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E08C90(unint64_t a1, char a2, char a3, char **a4, char *a5)
{
  uint64_t v5;
  unint64_t v6;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t result;
  unint64_t v14;
  unint64_t v15;
  char *v16;

  sub_217E22B5C(a1, a2, a3);
  v9 = *a4;
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
    goto LABEL_32;
  while (1)
  {
    v11 = *((_QWORD *)v9 + 2);
    v10 = *((_QWORD *)v9 + 3);
    v12 = v11 + 1;
    if (v11 >= v10 >> 1)
      v9 = sub_217E0E2EC((char *)(v10 > 1), v11 + 1, 1, v9);
    *((_QWORD *)v9 + 2) = v12;
    v9[v11 + 32] = 0;
    *a4 = v9;
    result = sub_217E0449C(a4, (uint64_t)a5);
    if (v5)
      return result;
    a5 = *a4;
    v14 = *((_QWORD *)*a4 + 2);
    v15 = v14 - v12;
    if ((uint64_t)(v14 - v12) <= 127)
      break;
    if (v14 <= v11)
    {
      __break(1u);
    }
    else
    {
      v6 = 71 - __clz(v15);
      v9 = (char *)(v6 >> 3);
      sub_217E07B84(v6 >> 3, v11 + 1, v14);
      a5 = *a4;
      result = swift_isUniquelyReferenced_nonNull_native();
      if ((result & 1) != 0)
        goto LABEL_8;
    }
    result = (uint64_t)sub_217E200A4((uint64_t)a5);
    a5 = (char *)result;
LABEL_8:
    if (v11 >= *((_QWORD *)a5 + 2))
    {
      __break(1u);
      goto LABEL_36;
    }
    v16 = a5 + 32;
    a5[v11 + 32] = (v6 >> 3) | 0x80;
    *a4 = a5;
    if (v11 + 1 < *((_QWORD *)a5 + 2))
    {
      v16[v11 + 1] = v15 >> (8 * (((_BYTE)v9 - 1) & 7u));
      if (v9 == (char *)1)
        goto LABEL_29;
      if (v11 + 2 < *((_QWORD *)a5 + 2))
      {
        v16[v11 + 2] = v15 >> (8 * (((_BYTE)v9 - 2) & 7u));
        if (v9 == (char *)2)
          goto LABEL_29;
        if (v11 + 3 < *((_QWORD *)a5 + 2))
        {
          v16[v11 + 3] = v15 >> (8 * (((_BYTE)v9 - 3) & 7u));
          if (v9 == (char *)3)
            goto LABEL_29;
          if (v11 + 4 < *((_QWORD *)a5 + 2))
          {
            v16[v11 + 4] = v15 >> (8 * (((_BYTE)v9 - 4) & 7u));
            if (v9 == (char *)4)
              goto LABEL_29;
            if (v11 + 5 < *((_QWORD *)a5 + 2))
            {
              v16[v11 + 5] = v15 >> (8 * (((_BYTE)v9 - 5) & 7u));
              if (v9 == (char *)5)
                goto LABEL_29;
              if (v11 + 6 < *((_QWORD *)a5 + 2))
              {
                v16[v11 + 6] = v15 >> (8 * (((_BYTE)v9 - 6) & 7u));
                if (v9 == (char *)6)
                  goto LABEL_29;
                if (v11 + 7 < *((_QWORD *)a5 + 2))
                {
                  v16[v11 + 7] = v15 >> (8 * (((_BYTE)v9 - 7) & 7u));
                  if (v9 == (char *)7)
                    goto LABEL_29;
                  if (v11 + 8 < *((_QWORD *)a5 + 2))
                  {
                    v16[v11 + 8] = v15 >> (v6 & 0x38);
LABEL_29:
                    *a4 = a5;
                    return result;
                  }
                }
              }
            }
          }
        }
      }
    }
    __break(1u);
LABEL_32:
    v9 = sub_217E0E2EC(0, *((_QWORD *)v9 + 2) + 1, 1, v9);
  }
  if ((v15 & 0x8000000000000000) != 0)
  {
LABEL_36:
    __break(1u);
    goto LABEL_37;
  }
  result = swift_isUniquelyReferenced_nonNull_native();
  if ((result & 1) != 0)
    goto LABEL_27;
LABEL_37:
  result = (uint64_t)sub_217E200A4((uint64_t)a5);
  a5 = (char *)result;
LABEL_27:
  if (v11 < *((_QWORD *)a5 + 2))
  {
    a5[v11 + 32] = v15;
    goto LABEL_29;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E08F3C(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  int64_t v6;
  uint64_t v7;
  uint64_t v8;
  int64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _BOOL8 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int64_t v44;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62[12];
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;

  v6 = a3 >> 1;
  v7 = (a3 >> 1) - a2;
  if (__OFSUB__(a3 >> 1, a2))
  {
    __break(1u);
LABEL_37:
    __break(1u);
LABEL_38:
    __break(1u);
    goto LABEL_39;
  }
  v8 = a5;
  v9 = a6 >> 1;
  if (__OFSUB__(a6 >> 1, a5))
    goto LABEL_37;
  if (v7 != (a6 >> 1) - a5)
    return 0;
  if (!v7)
    return 1;
  v10 = a4;
  v11 = result + 96 * a2;
  if (v11 == a4 + 96 * a5)
    return 1;
  v44 = a3 >> 1;
  v46 = a6 >> 1;
  if (v6 == a2)
  {
    v42 = result;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v61 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    result = 0;
    v22 = a5;
    v23 = a5;
    goto LABEL_11;
  }
  v23 = a5;
  if (v6 > a2)
  {
LABEL_10:
    v42 = result;
    v25 = result + 96 * a2;
    v19 = *(_BYTE *)(v25 + 24);
    v55 = a2 + 1;
    v18 = *(_QWORD *)(v25 + 32);
    v57 = *(_QWORD *)(v25 + 40);
    v58 = *(unsigned __int8 *)(v11 + 8);
    v54 = *(_QWORD *)(v25 + 88);
    v50 = *(_QWORD *)(v25 + 80);
    v52 = *(_QWORD *)(v25 + 72);
    v26 = *(_QWORD *)(v25 + 48);
    v60 = *(_QWORD *)(v25 + 56);
    v61 = *(_QWORD *)(v25 + 64);
    v27 = *(_QWORD *)(v25 + 16);
    v28 = *(_QWORD *)v11;
    v29 = v23;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    result = v28;
    v14 = v52;
    v12 = v54;
    v13 = v50;
    v20 = v27;
    v17 = v57;
    v21 = v58;
    v23 = v29;
    v16 = v26;
    v15 = v60;
    v22 = v29;
    a2 = v55;
LABEL_11:
    v30 = (unint64_t *)(v10 + 96 * v22 + 88);
    v47 = v22;
    v48 = a2;
    while (1)
    {
      v24 = v18 == 0;
      if (!v18)
        return v24;
      v31 = v19 & 1;
      if (v9 == v23)
        break;
      if (v22 < v8 || v23 >= v9)
        goto LABEL_38;
      if (result != *(v30 - 11)
        || *((unsigned __int8 *)v30 - 80) != v21
        || v20 != *(v30 - 9)
        || (_DWORD)v31 != *((unsigned __int8 *)v30 - 64))
      {
        v40 = v21;
        v41 = v18;
LABEL_32:
        sub_217E09A04(result, v40, v20, v31, v41);
        return 0;
      }
      v51 = v19 & 1;
      v53 = v20;
      v32 = result;
      v33 = v12;
      v34 = v13;
      v59 = v21;
      v49 = v23;
      v56 = v18;
      v35 = *(v30 - 3);
      v37 = *(v30 - 2);
      v36 = *(v30 - 1);
      v38 = *v30;
      if ((sub_217E085E8(v17, v16, v15, *(v30 - 6), *(v30 - 5), *(v30 - 4)) & 1) == 0)
        goto LABEL_31;
      if (v61)
      {
        if (!v35)
          goto LABEL_31;
        v39 = sub_217E085E8(v14, v34, v33, v37, v36, v38);
        sub_217E09A04(v32, v59, v53, v51, v56);
        if ((v39 & 1) == 0)
          return v24;
      }
      else
      {
        if (v35)
        {
LABEL_31:
          result = v32;
          v40 = v59;
          v31 = v51;
          v20 = v53;
          v41 = v56;
          goto LABEL_32;
        }
        sub_217E09A04(v32, v59, v53, v51, v56);
      }
      v12 = 0;
      v13 = 0;
      v14 = 0;
      v61 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      result = 0;
      v30 += 12;
      a2 = v48;
      v23 = v49 + 1;
      v8 = a5;
      v9 = v46;
      v22 = v47;
      if (v48 != v44)
      {
        if (v48 >= v44)
          goto LABEL_40;
        result = v42;
        v10 = a4;
        v11 = v42 + 96 * v48;
        goto LABEL_10;
      }
    }
    v62[0] = result;
    v62[1] = v21;
    v62[2] = v20;
    v62[3] = v19 & 1;
    v62[4] = v18;
    v62[5] = v17;
    v62[6] = v16;
    v62[7] = v15;
    v62[8] = v61;
    v62[9] = v14;
    v62[10] = v13;
    v62[11] = v12;
    v63 = 0u;
    v64 = 0u;
    v65 = 0u;
    v66 = 0u;
    v67 = 0u;
    v68 = 0u;
    sub_217E09A34(v62);
    return 0;
  }
LABEL_39:
  __break(1u);
LABEL_40:
  __break(1u);
  return result;
}

uint64_t sub_217E092DC(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (*(_QWORD *)a1 == *(_QWORD *)a2
    && *(unsigned __int8 *)(a1 + 8) == *(unsigned __int8 *)(a2 + 8)
    && *(_QWORD *)(a1 + 16) == *(_QWORD *)(a2 + 16)
    && ((*(unsigned __int8 *)(a1 + 24) ^ *(unsigned __int8 *)(a2 + 24)) & 1) == 0
    && (sub_217E085E8(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 56)) & 1) != 0)
  {
    v4 = *(_QWORD *)(a2 + 64);
    if (*(_QWORD *)(a1 + 64))
    {
      if (v4
        && (sub_217E085E8(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), *(_QWORD *)(a2 + 72), *(_QWORD *)(a2 + 80), *(_QWORD *)(a2 + 88)) & 1) != 0)
      {
        return 1;
      }
    }
    else if (!v4)
    {
      return 1;
    }
  }
  return 0;
}

uint64_t sub_217E0938C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v10;
  char v11;
  _BYTE v12[48];
  _BYTE v13[48];
  _BYTE v14[8];
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  char v19;
  _BYTE v20[8];
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  char v25;

  if (*(_QWORD *)a1 != *(_QWORD *)a2 || *(unsigned __int8 *)(a1 + 8) != *(unsigned __int8 *)(a2 + 8))
    goto LABEL_8;
  sub_217E04CC0(a1 + 16, (uint64_t)v13);
  sub_217E04CC0(a2 + 16, (uint64_t)v12);
  sub_217E04CC0((uint64_t)v13, (uint64_t)v14);
  v4 = v15;
  v5 = v16;
  v6 = v17;
  if ((v19 & 1) != 0)
  {
    sub_217E04CC0((uint64_t)v12, (uint64_t)v20);
    if ((v25 & 1) != 0 && (sub_217E085E8(v4, v5, v6, v21, v22, v23) & 1) != 0)
    {
LABEL_12:
      v8 = sub_217E085E8(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), *(_QWORD *)(a2 + 72), *(_QWORD *)(a2 + 80), *(_QWORD *)(a2 + 88));
      return v8 & 1;
    }
    goto LABEL_8;
  }
  v7 = v18;
  sub_217E04CC0((uint64_t)v12, (uint64_t)v20);
  if ((v25 & 1) != 0)
  {
LABEL_8:
    v8 = 0;
    return v8 & 1;
  }
  v10 = v24;
  v11 = sub_217E08F3C(v4, v5, v6, v21, v22, v23);
  v8 = 0;
  if ((v11 & 1) != 0 && v7 == v10)
    goto LABEL_12;
  return v8 & 1;
}

uint64_t sub_217E094B8(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  int64_t v6;
  uint64_t result;
  char v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  int64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  BOOL v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  __int128 v50;
  __int128 v51;

  v6 = a4 >> 1;
  result = MEMORY[0x24BEE4AF8];
  if (a4 >> 1 == a3)
  {
    v4 = 0;
    goto LABEL_52;
  }
  v8 = a4;
  v9 = a3;
  v45 = (char *)MEMORY[0x24BEE4AF8];
  v43 = a1;
  result = swift_unknownObjectRetain();
  if (v6 > v9)
  {
    v4 = 0;
    v41 = v8 & 1;
    v42 = a2 + 112;
    v11 = MEMORY[0x24BEE4AF8] + 32;
    v44 = a2;
    do
    {
      if (v6 <= v9)
      {
LABEL_59:
        __break(1u);
LABEL_60:
        __break(1u);
LABEL_61:
        __break(1u);
LABEL_62:
        __break(1u);
LABEL_63:
        __break(1u);
LABEL_64:
        __break(1u);
LABEL_65:
        __break(1u);
LABEL_66:
        __break(1u);
LABEL_67:
        __break(1u);
LABEL_68:
        __break(1u);
LABEL_69:
        __break(1u);
LABEL_70:
        __break(1u);
LABEL_71:
        __break(1u);
LABEL_72:
        __break(1u);
LABEL_73:
        __break(1u);
        return result;
      }
      v12 = (uint64_t *)(a2 + 96 * v9);
      v13 = *v12;
      v14 = *((_BYTE *)v12 + 8);
      v15 = v9 + 1;
      v50 = *((_OWORD *)v12 + 3);
      v51 = *((_OWORD *)v12 + 2);
      v49 = *((_BYTE *)v12 + 24);
      if (v49)
      {
        v16 = v12[2];
        v17 = v6;
        if (v15 != v6)
        {
          v18 = (_QWORD *)(v42 + 96 * v9);
          v17 = v9 + 1;
          do
          {
            if (v17 >= v6)
            {
LABEL_57:
              __break(1u);
LABEL_58:
              __break(1u);
              goto LABEL_59;
            }
            if (v16 >= *v18)
              goto LABEL_14;
            v19 = v17 + 1;
            if (__OFADD__(v17, 1))
              goto LABEL_58;
            ++v17;
            v18 += 12;
          }
          while (v19 != v6);
          v17 = v6;
LABEL_14:
          if (v17 <= v9)
            goto LABEL_61;
          if (v17 < 0)
            goto LABEL_62;
        }
        v20 = v17 - v15;
        if (__OFSUB__(v17, v15))
          goto LABEL_63;
        if (v20 < 0)
          goto LABEL_64;
        v21 = v6 - v15;
        if (__OFSUB__(v6, v15))
          goto LABEL_65;
        v46 = v14;
        v22 = v13;
        if (!v20 || v21 < 0 || (v23 = v6, v21 >= v20))
        {
          v23 = v17;
          if (__OFADD__(v15, v20))
            goto LABEL_69;
          if (v6 < v17)
            goto LABEL_66;
        }
        if (v23 <= v9)
          goto LABEL_67;
        if (v15 != v17)
        {
          if (v15 >= v17)
            goto LABEL_70;
          v24 = (uint64_t *)(v42 + 96 * v9);
          do
          {
            v25 = *v24;
            v24 += 12;
            if (v16 >= v25)
            {
              __break(1u);
              goto LABEL_57;
            }
            --v20;
          }
          while (v20);
          if (*(_QWORD *)(a2 + 96 * v15 + 16) != v16 + 1)
            goto LABEL_71;
        }
        v48 = v41 | (2 * v17);
        v26 = v43;
        result = swift_unknownObjectRetain();
        v9 = v23;
        v47 = a2;
        v13 = v22;
        v14 = v46;
        if (v4)
        {
LABEL_43:
          result = swift_unknownObjectRetain();
          v37 = __OFSUB__(v4--, 1);
          if (v37)
            goto LABEL_60;
          goto LABEL_48;
        }
      }
      else
      {
        v26 = v12[8];
        if (!v26)
          goto LABEL_73;
        v36 = v12[10];
        v47 = v12[9];
        v48 = v12[11];
        result = swift_unknownObjectRetain();
        v16 = 0;
        ++v9;
        v15 = v36;
        a2 = v44;
        if (v4)
          goto LABEL_43;
      }
      v27 = *((_QWORD *)v45 + 3);
      if ((uint64_t)((v27 >> 1) + 0x4000000000000000) < 0)
        goto LABEL_68;
      v28 = v27 & 0xFFFFFFFFFFFFFFFELL;
      if (v28 <= 1)
        v29 = 1;
      else
        v29 = v28;
      __swift_instantiateConcreteTypeFromMangledName(&qword_254F277F0);
      v30 = (char *)swift_allocObject();
      v31 = (uint64_t)(_swift_stdlib_malloc_size(v30) - 32) / 96;
      *((_QWORD *)v30 + 2) = v29;
      *((_QWORD *)v30 + 3) = 2 * v31;
      v32 = v30 + 32;
      v33 = *((_QWORD *)v45 + 3) >> 1;
      v11 = (uint64_t)&v30[96 * v33 + 32];
      v34 = (v31 & 0x7FFFFFFFFFFFFFFFLL) - v33;
      if (*((_QWORD *)v45 + 2))
      {
        v35 = v45 + 32;
        if (v30 != v45 || v32 >= &v35[96 * v33])
          memmove(v32, v35, 96 * v33);
        swift_unknownObjectRetain();
        *((_QWORD *)v45 + 2) = 0;
      }
      else
      {
        swift_unknownObjectRetain();
      }
      result = swift_release();
      v45 = v30;
      a2 = v44;
      v37 = __OFSUB__(v34, 1);
      v4 = v34 - 1;
      if (v37)
        goto LABEL_60;
LABEL_48:
      *(_QWORD *)v11 = v13;
      *(_BYTE *)(v11 + 8) = v14;
      *(_QWORD *)(v11 + 16) = v26;
      *(_QWORD *)(v11 + 24) = v47;
      *(_QWORD *)(v11 + 32) = v15;
      *(_QWORD *)(v11 + 40) = v48;
      *(_QWORD *)(v11 + 48) = v16;
      *(_BYTE *)(v11 + 56) = v49 ^ 1;
      *(_OWORD *)(v11 + 64) = v51;
      *(_OWORD *)(v11 + 80) = v50;
      if (v9 == v6)
        goto LABEL_51;
      v11 += 96;
    }
    while (v9 < v6);
  }
  __break(1u);
LABEL_51:
  swift_unknownObjectRelease();
  result = (uint64_t)v45;
LABEL_52:
  v38 = *(_QWORD *)(result + 24);
  if (v38 >= 2)
  {
    v39 = v38 >> 1;
    v37 = __OFSUB__(v39, v4);
    v40 = v39 - v4;
    if (v37)
      goto LABEL_72;
    *(_QWORD *)(result + 16) = v40;
  }
  return result;
}

uint64_t sub_217E0989C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  int64_t v4;
  uint64_t result;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  unint64_t v24;

  v4 = a4 >> 1;
  result = (a4 >> 1) - a3;
  if (__OFSUB__(a4 >> 1, a3))
  {
LABEL_25:
    __break(1u);
    return result;
  }
  v6 = a3;
  result = sub_217E2D1F4();
  if (v4 != v6)
  {
    v21 = v4;
    while (v6 < v4)
    {
      v7 = (_QWORD *)(a2 + 96 * v6);
      v8 = v7[5];
      v9 = v7[6];
      v10 = v7[10];
      v23 = v7[9];
      v24 = v7[11];
      v12 = v7[7];
      v11 = v7[8];
      sub_217E2D1F4();
      sub_217E2D1F4();
      sub_217E2D1F4();
      sub_217E2D200();
      v13 = v12 >> 1;
      result = (v12 >> 1) - v9;
      if (__OFSUB__(v12 >> 1, v9))
        goto LABEL_21;
      result = sub_217E2D1F4();
      v14 = __OFSUB__(v13, v9);
      v15 = v13 - v9;
      if (v15)
      {
        if ((v15 < 0) ^ v14 | (v15 == 0))
          goto LABEL_23;
        v16 = v8 + v9;
        do
        {
          ++v16;
          sub_217E2D200();
          --v15;
        }
        while (v15);
      }
      if (v11)
      {
        sub_217E2D200();
        v17 = v24 >> 1;
        result = (v24 >> 1) - v10;
        if (__OFSUB__(v24 >> 1, v10))
          goto LABEL_22;
        result = sub_217E2D1F4();
        v18 = __OFSUB__(v17, v10);
        v19 = v17 - v10;
        if (v19)
        {
          if ((v19 < 0) ^ v18 | (v19 == 0))
            goto LABEL_24;
          v20 = v23 + v10;
          do
          {
            ++v20;
            result = sub_217E2D200();
            --v19;
          }
          while (v19);
        }
      }
      else
      {
        result = sub_217E2D200();
      }
      ++v6;
      v4 = v21;
      if (v6 == v21)
        return result;
    }
    __break(1u);
LABEL_21:
    __break(1u);
LABEL_22:
    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }
  return result;
}

uint64_t sub_217E09A04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  if (a5)
  {
    swift_unknownObjectRelease();
    return swift_unknownObjectRelease();
  }
  return result;
}

uint64_t *sub_217E09A34(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;

  v2 = a1[13];
  v7 = a1[12];
  v3 = a1[14];
  v4 = a1[15];
  v5 = a1[16];
  sub_217E09A04(*a1, a1[1], a1[2], a1[3], a1[4]);
  sub_217E09A04(v7, v2, v3, v4, v5);
  return a1;
}

uint64_t sub_217E09AF4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;

  v5 = __swift_instantiateConcreteTypeFromMangledName(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t sub_217E09B38(uint64_t a1)
{
  swift_unknownObjectRetain();
  return a1;
}

uint64_t *sub_217E09B64(uint64_t *a1)
{
  sub_217E04C6C(*a1, a1[1], a1[2], a1[3], a1[4], a1[5], a1[6], a1[7], a1[8]);
  return a1;
}

uint64_t sub_217E09BB4(uint64_t a1)
{
  uint64_t v1;

  return sub_217E12A8C(a1, *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24), *(_QWORD *)(v1 + 32), *(_QWORD *)(v1 + 40));
}

uint64_t sub_217E09BD0(uint64_t a1)
{
  swift_unknownObjectRelease();
  return a1;
}

uint64_t sub_217E09BF8(uint64_t a1)
{
  j__swift_unknownObjectRelease(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(unsigned __int8 *)(a1 + 56));
  swift_unknownObjectRelease();
  return a1;
}

void sub_217E09C38(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  int64_t v5;
  int64_t v6;
  _QWORD *v7;

  v5 = a4 >> 1;
  v6 = a3;
  if (a4 >> 1 != a3)
  {
    v7 = (_QWORD *)(a2 + 96 * a3 + 16);
    v6 = a3;
    while (1)
    {
      if (v6 >= v5)
      {
        __break(1u);
        goto LABEL_13;
      }
      if (*(_QWORD *)(a5 + 16) >= *v7)
        break;
      ++v6;
      v7 += 12;
      if (v5 == v6)
      {
        v6 = a4 >> 1;
        break;
      }
    }
    if (v6 >= a3)
      goto LABEL_8;
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }
LABEL_8:
  if (v5 < a3)
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  if (v5 < v6)
  {
LABEL_15:
    __break(1u);
    goto LABEL_16;
  }
  if (v6 < 0)
LABEL_16:
    __break(1u);
}

uint64_t sub_217E09CBC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v5;
  uint64_t result;
  uint64_t v8;
  int64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 *v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  int64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  int64_t v34;
  char v35;
  BOOL v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  _QWORD v42[3];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  _OWORD v48[2];
  _BYTE v49[32];
  _QWORD v50[5];
  int v51;

  result = sub_217E06320(a1, a2, a3, a4);
  if (!v5)
  {
    v11 = v10;
    v12 = v10 >> 1;
    if (v9 == v10 >> 1)
    {
      __break(1u);
    }
    else if (v9 < (uint64_t)(v10 >> 1))
    {
      v13 = result;
      v14 = v8;
      v15 = (__int128 *)(v8 + 96 * v9);
      v16 = v15[1];
      v44 = *v15;
      v45 = v16;
      v17 = v15[2];
      v18 = v15[3];
      v19 = v15[5];
      v48[0] = v15[4];
      v48[1] = v19;
      v46 = v17;
      v47 = v18;
      v20 = v9 + 1;
      v51 = BYTE8(v45);
      if ((BYTE8(v45) & 1) != 0)
      {
        sub_217E09C38(result, v8, v9 + 1, v10, (uint64_t)&v44);
        v41 = v29;
        result = (v28 >> 1) - v27;
        if (__OFSUB__(v28 >> 1, v27))
        {
LABEL_17:
          __break(1u);
          goto LABEL_18;
        }
        v30 = v26;
        v31 = v27;
        v32 = v28;
        sub_217E06CCC(result, v13, v14, v20, v11);
        v37 = v33;
        v20 = v34;
        sub_217E082C8(v41, v30, v31, v32, v45, v42);
        v21 = v42[0];
        v39 = v42[1];
        v22 = v42[2];
        v38 = v43;
        v40 = v46;
        v24 = *((_QWORD *)&v47 + 1);
        v25 = v47;
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        result = swift_unknownObjectRelease();
        v12 = v37 >> 1;
      }
      else
      {
        sub_217E09AF4((uint64_t)v48, (uint64_t)v49, &qword_254F277E8);
        result = sub_217E09AF4((uint64_t)v49, (uint64_t)v50, &qword_254F277E8);
        v21 = v50[0];
        if (!v50[0])
        {
LABEL_18:
          __break(1u);
          return result;
        }
        v22 = v50[2];
        v39 = v50[1];
        *((_QWORD *)&v23 + 1) = *((_QWORD *)&v46 + 1);
        v40 = v46;
        v24 = *((_QWORD *)&v47 + 1);
        v25 = v47;
        *(_QWORD *)&v23 = v50[3];
        v38 = v23;
        sub_217E09B38((uint64_t)v49);
        swift_unknownObjectRetain();
        result = swift_unknownObjectRelease();
      }
      if (!__OFSUB__(v12, v20))
      {
        if (v12 == v20)
        {
          v35 = BYTE8(v44);
          v36 = (v51 & 1) == 0;
          *(_QWORD *)a5 = v44;
          *(_BYTE *)(a5 + 8) = v35;
          *(_QWORD *)(a5 + 16) = v21;
          *(_QWORD *)(a5 + 24) = v39;
          *(_QWORD *)(a5 + 32) = v22;
          *(_OWORD *)(a5 + 40) = v38;
          *(_BYTE *)(a5 + 56) = v36;
          *(_OWORD *)(a5 + 64) = v40;
          *(_QWORD *)(a5 + 80) = v25;
          *(_QWORD *)(a5 + 88) = v24;
          return result;
        }
        goto LABEL_16;
      }
LABEL_15:
      __break(1u);
LABEL_16:
      __break(1u);
      goto LABEL_17;
    }
    __break(1u);
    goto LABEL_15;
  }
  return result;
}

ValueMetadata *type metadata accessor for DER()
{
  return &type metadata for DER;
}

uint64_t destroy for DER.ParserNode()
{
  swift_unknownObjectRelease();
  return swift_unknownObjectRelease();
}

uint64_t initializeWithCopy for DER.ParserNode(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  v3 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 64) = v3;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  return a1;
}

uint64_t assignWithCopy for DER.ParserNode(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  return a1;
}

__n128 __swift_memcpy96_8(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  __n128 result;
  __int128 v4;
  __int128 v5;

  v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  result = *(__n128 *)(a2 + 32);
  v4 = *(_OWORD *)(a2 + 48);
  v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v5;
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v4;
  return result;
}

uint64_t assignWithTake for DER.ParserNode(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  swift_unknownObjectRelease();
  v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  swift_unknownObjectRelease();
  v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v5;
  return a1;
}

uint64_t getEnumTagSinglePayload for DER.ParserNode(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 96))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 32);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for DER.ParserNode(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 88) = 0;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 96) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 32) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 96) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for DER.ParserNode()
{
  return &type metadata for DER.ParserNode;
}

uint64_t initializeWithCopy for der_key(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  swift_unknownObjectRetain();
  return a1;
}

_QWORD *assignWithCopy for der_key(_QWORD *a1, _QWORD *a2)
{
  *a1 = *a2;
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  return a1;
}

__n128 __swift_memcpy32_8(_OWORD *a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

_OWORD *assignWithTake for der_key(_OWORD *a1, _OWORD *a2)
{
  __int128 v4;

  swift_unknownObjectRelease();
  v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  return a1;
}

uint64_t getEnumTagSinglePayload for der_key(uint64_t *a1, int a2)
{
  uint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *((_BYTE *)a1 + 32))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for der_key(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_QWORD *)result = a2 ^ 0x80000000;
    *(_QWORD *)(result + 8) = 0;
    if (a3 < 0)
      *(_BYTE *)(result + 32) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)result = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 32) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for DER.ParseResult()
{
  return &type metadata for DER.ParseResult;
}

uint64_t destroy for der_key()
{
  return swift_unknownObjectRelease();
}

__n128 __swift_memcpy40_8(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

ValueMetadata *type metadata accessor for ASN1NodeCollection.Iterator()
{
  return &type metadata for ASN1NodeCollection.Iterator;
}

uint64_t initializeWithCopy for ASN1BitString(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  swift_unknownObjectRetain();
  return a1;
}

_QWORD *assignWithCopy for ASN1BitString(_QWORD *a1, _QWORD *a2)
{
  *a1 = *a2;
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a2[4];
  return a1;
}

uint64_t assignWithTake for ASN1BitString(uint64_t a1, uint64_t a2)
{
  __int128 v4;

  swift_unknownObjectRelease();
  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  return a1;
}

uint64_t getEnumTagSinglePayload for ASN1BitString(uint64_t *a1, int a2)
{
  uint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *((_BYTE *)a1 + 40))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for ASN1BitString(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 40) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)result = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 40) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for ASN1NodeCollection()
{
  return &type metadata for ASN1NodeCollection;
}

uint64_t destroy for ASN1Node(uint64_t a1)
{
  j__swift_unknownObjectRelease(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(unsigned __int8 *)(a1 + 56));
  return swift_unknownObjectRelease();
}

uint64_t initializeWithCopy for ASN1Node(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a2 + 32);
  v7 = *(_QWORD *)(a2 + 40);
  v8 = *(_QWORD *)(a2 + 48);
  v9 = *(unsigned __int8 *)(a2 + 56);
  j__swift_unknownObjectRetain(v4, v5, v6, v7, v8, v9);
  *(_QWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 24) = v5;
  *(_QWORD *)(a1 + 32) = v6;
  *(_QWORD *)(a1 + 40) = v7;
  *(_QWORD *)(a1 + 48) = v8;
  *(_BYTE *)(a1 + 56) = v9;
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  swift_unknownObjectRetain();
  return a1;
}

uint64_t assignWithCopy for ASN1Node(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a2 + 32);
  v7 = *(_QWORD *)(a2 + 40);
  v8 = *(_QWORD *)(a2 + 48);
  v9 = *(unsigned __int8 *)(a2 + 56);
  j__swift_unknownObjectRetain(v4, v5, v6, v7, v8, v9);
  v10 = *(_QWORD *)(a1 + 16);
  v11 = *(_QWORD *)(a1 + 24);
  v12 = *(_QWORD *)(a1 + 32);
  v13 = *(_QWORD *)(a1 + 40);
  v14 = *(_QWORD *)(a1 + 48);
  v15 = *(unsigned __int8 *)(a1 + 56);
  *(_QWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 24) = v5;
  *(_QWORD *)(a1 + 32) = v6;
  *(_QWORD *)(a1 + 40) = v7;
  *(_QWORD *)(a1 + 48) = v8;
  *(_BYTE *)(a1 + 56) = v9;
  j__swift_unknownObjectRelease(v10, v11, v12, v13, v14, v15);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  return a1;
}

uint64_t assignWithTake for ASN1Node(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 48);
  v5 = *(_BYTE *)(a2 + 56);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  v8 = *(_QWORD *)(a1 + 32);
  v9 = *(_QWORD *)(a1 + 40);
  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(unsigned __int8 *)(a1 + 56);
  v12 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v12;
  *(_QWORD *)(a1 + 48) = v4;
  *(_BYTE *)(a1 + 56) = v5;
  j__swift_unknownObjectRelease(v6, v7, v8, v9, v10, v11);
  swift_unknownObjectRelease();
  v13 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v13;
  return a1;
}

uint64_t getEnumTagSinglePayload for ASN1Node(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 96))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 64);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for ASN1Node(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 88) = 0;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 96) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 64) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 96) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for ASN1Node()
{
  return &type metadata for ASN1Node;
}

unint64_t sub_217E0A764()
{
  unint64_t result;

  result = qword_254F27800;
  if (!qword_254F27800)
  {
    result = MEMORY[0x219A1838C](&unk_217E330D4, &type metadata for ASN1Node);
    atomic_store(result, (unint64_t *)&qword_254F27800);
  }
  return result;
}

uint64_t sub_217E0A7B0(uint64_t *a1, char a2)
{
  uint64_t v4;
  uint64_t result;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  char v9;
  unint64_t v10;

  v4 = *a1;
  result = swift_isUniquelyReferenced_nonNull_native();
  if ((a2 & 1) != 0)
  {
    if ((result & 1) == 0)
    {
      result = (uint64_t)sub_217E0E2EC(0, *(_QWORD *)(v4 + 16) + 1, 1, (char *)v4);
      v4 = result;
    }
    v7 = *(_QWORD *)(v4 + 16);
    v6 = *(_QWORD *)(v4 + 24);
    v8 = v7 + 1;
    if (v7 >= v6 >> 1)
    {
      result = (uint64_t)sub_217E0E2EC((char *)(v6 > 1), v7 + 1, 1, (char *)v4);
      v4 = result;
    }
    v9 = -1;
  }
  else
  {
    if ((result & 1) == 0)
    {
      result = (uint64_t)sub_217E0E2EC(0, *(_QWORD *)(v4 + 16) + 1, 1, (char *)v4);
      v4 = result;
    }
    v7 = *(_QWORD *)(v4 + 16);
    v10 = *(_QWORD *)(v4 + 24);
    v8 = v7 + 1;
    if (v7 >= v10 >> 1)
    {
      result = (uint64_t)sub_217E0E2EC((char *)(v10 > 1), v7 + 1, 1, (char *)v4);
      v4 = result;
    }
    v9 = 0;
  }
  *(_QWORD *)(v4 + 16) = v8;
  *(_BYTE *)(v4 + v7 + 32) = v9;
  *a1 = v4;
  return result;
}

uint64_t sub_217E0A8C0(uint64_t result, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;

  v3 = result;
  if (*(_QWORD *)result != a2 || *(unsigned __int8 *)(result + 8) != a3)
  {
    v8 = sub_217E055EC((uint64_t)"AppleKeyStore/ASN1Boolean.swift", 31, 2, 22);
LABEL_12:
    v9 = v8;
    sub_217E04C24();
    swift_allocError();
    *v10 = v9;
    swift_willThrow();
    sub_217E09BF8(v3);
    return v7 & 1;
  }
  if (*(_BYTE *)(result + 56) != 1)
    goto LABEL_11;
  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  if (__OFSUB__(v5 >> 1, v4))
  {
    __break(1u);
    goto LABEL_17;
  }
  if ((v5 >> 1) - v4 != 1)
  {
LABEL_11:
    v8 = sub_217E0556C(0xD00000000000001CLL, 0x8000000217E30EF0, (uint64_t)"AppleKeyStore/ASN1Boolean.swift", 31, 2, 26);
    goto LABEL_12;
  }
  if (v4 < (uint64_t)(v5 >> 1))
  {
    v6 = *(_QWORD *)(result + 24);
    if (*(unsigned __int8 *)(v6 + v4) == 255)
    {
      sub_217E09BF8(result);
      v7 = 1;
    }
    else if (*(_BYTE *)(v6 + v4))
    {
      v11 = *(_QWORD *)(result + 16);
      v12 = *(_QWORD *)(result + 48);
      v13 = sub_217E0556C(0xD000000000000019, 0x8000000217E30F10, (uint64_t)"AppleKeyStore/ASN1Boolean.swift", 31, 2, 38);
      sub_217E04C24();
      swift_allocError();
      *v14 = v13;
      swift_unknownObjectRetain();
      swift_willThrow();
      sub_217E09BF8(v3);
      j__swift_unknownObjectRelease(v11, v6, v4, v5, v12, 1);
    }
    else
    {
      sub_217E09BF8(result);
      v7 = 0;
    }
    return v7 & 1;
  }
LABEL_17:
  __break(1u);
  return result;
}

__n128 sub_217E0AAA0@<Q0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v3;
  return result;
}

uint64_t sub_217E0AAAC@<X0>(_OWORD *a1@<X8>)
{
  _OWORD *v1;
  __int128 v2;

  v2 = v1[1];
  *a1 = *v1;
  a1[1] = v2;
  return swift_unknownObjectRetain();
}

uint64_t sub_217E0AABC()
{
  uint64_t v0;

  return sub_217E0AB00(0, *(_QWORD *)(v0 + 8), *(_QWORD *)(v0 + 16), *(_QWORD *)(v0 + 24));
}

uint64_t sub_217E0AACC(uint64_t a1)
{
  uint64_t v1;

  return sub_217E0AB84(a1, *(_QWORD *)(v1 + 8), *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24));
}

uint64_t sub_217E0AAD8(uint64_t a1)
{
  uint64_t v1;

  return sub_217E0AB00(a1, *(_QWORD *)(v1 + 8), *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24));
}

uint64_t sub_217E0AAE4(uint64_t a1, uint64_t a2)
{
  return sub_217E085E8(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24));
}

uint64_t sub_217E0AB00(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v7;
  uint64_t result;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;

  sub_217E2D1E8();
  v7 = a4 >> 1;
  result = (a4 >> 1) - a3;
  if (__OFSUB__(a4 >> 1, a3))
  {
    __break(1u);
  }
  else
  {
    result = sub_217E2D1F4();
    v9 = __OFSUB__(v7, a3);
    v10 = v7 - a3;
    if (!v10)
      return sub_217E2D218();
    if (!((v10 < 0) ^ v9 | (v10 == 0)))
    {
      v11 = a2 + a3;
      do
      {
        ++v11;
        sub_217E2D200();
        --v10;
      }
      while (v10);
      return sub_217E2D218();
    }
  }
  __break(1u);
  return result;
}

uint64_t sub_217E0AB84(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  uint64_t result;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;

  v4 = a4 >> 1;
  result = (a4 >> 1) - a3;
  if (__OFSUB__(a4 >> 1, a3))
  {
    __break(1u);
    goto LABEL_8;
  }
  result = sub_217E2D1F4();
  v8 = __OFSUB__(v4, a3);
  v9 = v4 - a3;
  if (!v9)
    return result;
  if ((v9 < 0) ^ v8 | (v9 == 0))
  {
LABEL_8:
    __break(1u);
    return result;
  }
  v10 = a2 + a3;
  do
  {
    ++v10;
    result = sub_217E2D200();
    --v9;
  }
  while (v9);
  return result;
}

ValueMetadata *type metadata accessor for der_key()
{
  return &type metadata for der_key;
}

unint64_t sub_217E0ABFC()
{
  unint64_t result;

  result = qword_254F27808;
  if (!qword_254F27808)
  {
    result = MEMORY[0x219A1838C](&unk_217E331A4, &type metadata for der_key);
    atomic_store(result, (unint64_t *)&qword_254F27808);
  }
  return result;
}

uint64_t sub_217E0AC40(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t sub_217E0AC48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 24))();
}

uint64_t sub_217E0AC50()
{
  return MEMORY[0x24BEE0D88];
}

uint64_t sub_217E0AC5C()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;

  v1 = v0[2];
  v2 = v0[3] >> 1;
  result = v2 - v1;
  if (__OFSUB__(v2, v1))
  {
    __break(1u);
    goto LABEL_8;
  }
  v4 = v0[1];
  result = sub_217E2D1F4();
  v5 = __OFSUB__(v2, v1);
  v6 = v2 - v1;
  if (!v6)
    return result;
  if ((v6 < 0) ^ v5 | (v6 == 0))
  {
LABEL_8:
    __break(1u);
    return result;
  }
  v7 = v4 + v1;
  do
  {
    ++v7;
    result = sub_217E2D200();
    --v6;
  }
  while (v6);
  return result;
}

uint64_t sub_217E0ACD0@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  v3 = sub_217E0B394(*(_QWORD *)a1, *(_QWORD *)(a1 + 8));
  v5 = v4;
  v7 = v6;
  v9 = v8;
  result = swift_bridgeObjectRelease();
  *a2 = v3;
  a2[1] = v5;
  a2[2] = v7;
  a2[3] = v9;
  return result;
}

uint64_t sub_217E0AD2C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return sub_217E0ADFC(a1, (uint64_t (*)(uint64_t, _QWORD, uint64_t))sub_217E0B320, a2);
}

uint64_t sub_217E0AD38()
{
  uint64_t v0;

  return sub_217E0B6D0(*(_QWORD *)(v0 + 8), *(_QWORD *)(v0 + 16), *(_QWORD *)(v0 + 24));
}

uint64_t sub_217E0AD54(uint64_t a1)
{
  uint64_t v1;

  return sub_217E0AB84(a1, *(_QWORD *)(v1 + 8), *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24));
}

uint64_t sub_217E0AD70()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t result;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;

  v1 = v0[1];
  v2 = v0[2];
  v3 = v0[3];
  sub_217E2D1E8();
  v4 = v3 >> 1;
  result = v4 - v2;
  if (__OFSUB__(v4, v2))
  {
    __break(1u);
  }
  else
  {
    result = sub_217E2D1F4();
    v6 = __OFSUB__(v4, v2);
    v7 = v4 - v2;
    if (!v7)
      return sub_217E2D218();
    if (!((v7 < 0) ^ v6 | (v7 == 0)))
    {
      v8 = v1 + v2;
      do
      {
        ++v8;
        sub_217E2D200();
        --v7;
      }
      while (v7);
      return sub_217E2D218();
    }
  }
  __break(1u);
  return result;
}

uint64_t sub_217E0ADF0@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return sub_217E0ADFC(a1, (uint64_t (*)(uint64_t, _QWORD, uint64_t))sub_217E0B440, a2);
}

uint64_t sub_217E0ADFC@<X0>(uint64_t a1@<X0>, uint64_t (*a2)(uint64_t, _QWORD, uint64_t)@<X3>, uint64_t *a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t result;

  v5 = sub_217E0B288(*(_QWORD *)a1, *(_QWORD *)(a1 + 8));
  swift_bridgeObjectRelease();
  v6 = (2 * *(_QWORD *)(v5 + 16)) | 1;
  result = a2(v5 + 32, 0, v6);
  if ((result & 1) != 0)
  {
    *a3 = v5;
    a3[1] = v5 + 32;
    a3[2] = 0;
    a3[3] = v6;
  }
  else
  {
    __break(1u);
  }
  return result;
}

unint64_t sub_217E0AE7C()
{
  unint64_t result;

  result = qword_254F27810;
  if (!qword_254F27810)
  {
    result = MEMORY[0x219A1838C](&unk_217E3327C, &type metadata for ASN1IA5String);
    atomic_store(result, (unint64_t *)&qword_254F27810);
  }
  return result;
}

uint64_t sub_217E0AEC0()
{
  return MEMORY[0x24BEE0D90];
}

unint64_t sub_217E0AED0()
{
  unint64_t result;

  result = qword_254F27818;
  if (!qword_254F27818)
  {
    result = MEMORY[0x219A1838C](&unk_217E332B4, &type metadata for ASN1IA5String);
    atomic_store(result, (unint64_t *)&qword_254F27818);
  }
  return result;
}

uint64_t sub_217E0AF14()
{
  return MEMORY[0x24BEE0D80];
}

unint64_t sub_217E0AF24()
{
  unint64_t result;

  result = qword_254F27820;
  if (!qword_254F27820)
  {
    result = MEMORY[0x219A1838C](&unk_217E33334, &type metadata for ASN1BMPString);
    atomic_store(result, (unint64_t *)&qword_254F27820);
  }
  return result;
}

unint64_t sub_217E0AF6C()
{
  unint64_t result;

  result = qword_254F27828;
  if (!qword_254F27828)
  {
    result = MEMORY[0x219A1838C](&unk_217E3336C, &type metadata for ASN1BMPString);
    atomic_store(result, (unint64_t *)&qword_254F27828);
  }
  return result;
}

unint64_t sub_217E0AFB4()
{
  unint64_t result;

  result = qword_254F27830;
  if (!qword_254F27830)
  {
    result = MEMORY[0x219A1838C](&unk_217E333EC, &type metadata for ASN1UniversalString);
    atomic_store(result, (unint64_t *)&qword_254F27830);
  }
  return result;
}

unint64_t sub_217E0AFFC()
{
  unint64_t result;

  result = qword_254F27838;
  if (!qword_254F27838)
  {
    result = MEMORY[0x219A1838C](&unk_217E33424, &type metadata for ASN1UniversalString);
    atomic_store(result, (unint64_t *)&qword_254F27838);
  }
  return result;
}

unint64_t sub_217E0B044()
{
  unint64_t result;

  result = qword_254F27840;
  if (!qword_254F27840)
  {
    result = MEMORY[0x219A1838C](&unk_217E334A4, &type metadata for ASN1PrintableString);
    atomic_store(result, (unint64_t *)&qword_254F27840);
  }
  return result;
}

unint64_t sub_217E0B08C()
{
  unint64_t result;

  result = qword_254F27848;
  if (!qword_254F27848)
  {
    result = MEMORY[0x219A1838C](&unk_217E334DC, &type metadata for ASN1PrintableString);
    atomic_store(result, (unint64_t *)&qword_254F27848);
  }
  return result;
}

unint64_t sub_217E0B0D4()
{
  unint64_t result;

  result = qword_254F27850;
  if (!qword_254F27850)
  {
    result = MEMORY[0x219A1838C](&unk_217E3355C, &type metadata for ASN1TeletexString);
    atomic_store(result, (unint64_t *)&qword_254F27850);
  }
  return result;
}

unint64_t sub_217E0B11C()
{
  unint64_t result;

  result = qword_254F27858;
  if (!qword_254F27858)
  {
    result = MEMORY[0x219A1838C](&unk_217E33594, &type metadata for ASN1TeletexString);
    atomic_store(result, (unint64_t *)&qword_254F27858);
  }
  return result;
}

unint64_t sub_217E0B164()
{
  unint64_t result;

  result = qword_254F27860;
  if (!qword_254F27860)
  {
    result = MEMORY[0x219A1838C](&unk_217E33614, &type metadata for ASN1UTF8String);
    atomic_store(result, (unint64_t *)&qword_254F27860);
  }
  return result;
}

unint64_t sub_217E0B1AC()
{
  unint64_t result;

  result = qword_254F27868;
  if (!qword_254F27868)
  {
    result = MEMORY[0x219A1838C]("嫭546", &type metadata for ASN1UTF8String);
    atomic_store(result, (unint64_t *)&qword_254F27868);
  }
  return result;
}

_QWORD *sub_217E0B1F0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  size_t v5;

  if (a2 <= a1)
    v2 = a1;
  else
    v2 = a2;
  if (!v2)
    return (_QWORD *)MEMORY[0x24BEE4AF8];
  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v4 = (_QWORD *)swift_allocObject();
  v5 = _swift_stdlib_malloc_size(v4);
  v4[2] = a1;
  v4[3] = 2 * v5 - 64;
  return v4;
}

uint64_t (*sub_217E0B254(uint64_t (*result)(), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6))()
{
  if (a2 < a5 || (uint64_t)(a6 >> 1) <= a2)
  {
    __break(1u);
  }
  else
  {
    *(_BYTE *)result = *(_BYTE *)(a4 + a2);
    return nullsub_1;
  }
  return result;
}

uint64_t sub_217E0B288(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t result;
  char v5;

  if ((a2 & 0x1000000000000000) != 0)
    goto LABEL_9;
  if ((a2 & 0x2000000000000000) != 0)
    v2 = HIBYTE(a2) & 0xF;
  else
    v2 = a1 & 0xFFFFFFFFFFFFLL;
  if (v2)
  {
    while (1)
    {
      v3 = sub_217E0B1F0(v2, 0);
      result = sub_217E2D140();
      if ((v5 & 1) != 0)
        break;
      if (result == v2)
        return (uint64_t)v3;
      __break(1u);
LABEL_9:
      v2 = sub_217E2CFE4();
      if (!v2)
        return MEMORY[0x24BEE4AF8];
    }
    __break(1u);
  }
  else
  {
    return MEMORY[0x24BEE4AF8];
  }
  return result;
}

uint64_t sub_217E0B320(uint64_t result, uint64_t a2, unint64_t a3)
{
  int64_t v3;
  unsigned int v4;
  BOOL v5;
  unint64_t v6;

  v3 = a3 >> 1;
  if (a3 >> 1 == a2)
    return 1;
  while (a2 < v3)
  {
    v4 = *(unsigned __int8 *)(result + a2);
    v5 = (v4 & 0xFFFFFFDF) - 91 > 0xFFFFFFE5 || v4 - 58 > 0xFFFFFFF5;
    if (!v5)
    {
      v5 = v4 > 0x3F;
      v6 = (1 << v4) & 0xA400FB8100000000;
      if (v5 || v6 == 0)
        return 0;
    }
    if (v3 == ++a2)
      return 1;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E0B394(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t result;
  char v5;

  if ((a2 & 0x1000000000000000) != 0)
    goto LABEL_9;
  if ((a2 & 0x2000000000000000) != 0)
    v2 = HIBYTE(a2) & 0xF;
  else
    v2 = a1 & 0xFFFFFFFFFFFFLL;
  if (v2)
  {
    while (1)
    {
      v3 = sub_217E0B1F0(v2, 0);
      result = sub_217E2D140();
      if ((v5 & 1) != 0)
        break;
      if (result == v2)
        return (uint64_t)v3;
      __break(1u);
LABEL_9:
      v2 = sub_217E2CFE4();
      if (!v2)
        return MEMORY[0x24BEE4AF8];
    }
    __break(1u);
  }
  else
  {
    return MEMORY[0x24BEE4AF8];
  }
  return result;
}

uint64_t sub_217E0B440(uint64_t result, uint64_t a2, unint64_t a3)
{
  int64_t v3;
  uint64_t v4;
  int v5;

  v3 = a3 >> 1;
  if (a3 >> 1 != a2)
  {
    if ((uint64_t)(a3 >> 1) > a2)
    {
      if (*(char *)(result + a2) < 0)
        return 0;
      if (a2 + 1 == v3)
        return 1;
      v4 = result + 1;
      while (a2 + 1 < v3)
      {
        v5 = *(char *)(v4 + a2);
        result = v5 >= 0;
        if ((v5 & 0x80000000) == 0 && v3 - 2 != a2++)
          continue;
        return result;
      }
      __break(1u);
    }
    __break(1u);
    return result;
  }
  return 1;
}

ValueMetadata *type metadata accessor for ASN1UTF8String()
{
  return &type metadata for ASN1UTF8String;
}

ValueMetadata *type metadata accessor for ASN1TeletexString()
{
  return &type metadata for ASN1TeletexString;
}

ValueMetadata *type metadata accessor for ASN1PrintableString()
{
  return &type metadata for ASN1PrintableString;
}

ValueMetadata *type metadata accessor for ASN1UniversalString()
{
  return &type metadata for ASN1UniversalString;
}

ValueMetadata *type metadata accessor for ASN1BMPString()
{
  return &type metadata for ASN1BMPString;
}

ValueMetadata *type metadata accessor for ASN1IA5String()
{
  return &type metadata for ASN1IA5String;
}

unint64_t sub_217E0B524()
{
  unint64_t result;

  result = qword_254F27878;
  if (!qword_254F27878)
  {
    result = MEMORY[0x219A1838C](&unk_217E33770, &type metadata for ASN1IA5String);
    atomic_store(result, (unint64_t *)&qword_254F27878);
  }
  return result;
}

unint64_t sub_217E0B56C()
{
  unint64_t result;

  result = qword_254F27880;
  if (!qword_254F27880)
  {
    result = MEMORY[0x219A1838C](&unk_217E33818, &type metadata for ASN1BMPString);
    atomic_store(result, (unint64_t *)&qword_254F27880);
  }
  return result;
}

unint64_t sub_217E0B5B4()
{
  unint64_t result;

  result = qword_254F27888;
  if (!qword_254F27888)
  {
    result = MEMORY[0x219A1838C](&unk_217E338C0, &type metadata for ASN1UniversalString);
    atomic_store(result, (unint64_t *)&qword_254F27888);
  }
  return result;
}

unint64_t sub_217E0B5FC()
{
  unint64_t result;

  result = qword_254F27890;
  if (!qword_254F27890)
  {
    result = MEMORY[0x219A1838C](&unk_217E33968, &type metadata for ASN1PrintableString);
    atomic_store(result, (unint64_t *)&qword_254F27890);
  }
  return result;
}

unint64_t sub_217E0B644()
{
  unint64_t result;

  result = qword_254F27898;
  if (!qword_254F27898)
  {
    result = MEMORY[0x219A1838C](&unk_217E33A10, &type metadata for ASN1TeletexString);
    atomic_store(result, (unint64_t *)&qword_254F27898);
  }
  return result;
}

unint64_t sub_217E0B68C()
{
  unint64_t result;

  result = qword_254F278A0;
  if (!qword_254F278A0)
  {
    result = MEMORY[0x219A1838C](&unk_217E33AB8, &type metadata for ASN1UTF8String);
    atomic_store(result, (unint64_t *)&qword_254F278A0);
  }
  return result;
}

uint64_t sub_217E0B6D0(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v6;
  uint64_t result;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;

  sub_217E2D1E8();
  v6 = a3 >> 1;
  result = (a3 >> 1) - a2;
  if (__OFSUB__(a3 >> 1, a2))
  {
    __break(1u);
  }
  else
  {
    result = sub_217E2D1F4();
    v8 = __OFSUB__(v6, a2);
    v9 = v6 - a2;
    if (!v9)
      return sub_217E2D218();
    if (!((v9 < 0) ^ v8 | (v9 == 0)))
    {
      v10 = a1 + a2;
      do
      {
        ++v10;
        sub_217E2D200();
        --v9;
      }
      while (v9);
      return sub_217E2D218();
    }
  }
  __break(1u);
  return result;
}

uint64_t sub_217E0B764(char **a1, uint64_t a2, uint64_t a3)
{
  size_t v4;
  uint64_t v5;
  _QWORD v7[2];
  _BYTE v8[16];
  size_t v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v7[0] = a2;
  v7[1] = a3;
  v4 = sub_217E0E5D4((size_t)v7, (unint64_t)v8);
  v5 = (2 * *(_QWORD *)(v4 + 16)) | 1;
  v9 = v4;
  v10 = v4 + 32;
  v11 = 0;
  v12 = v5;
  sub_217E086BC(4uLL, 0, 0, a1, (uint64_t (*)(char **))sub_217E09BB4);
  return swift_release();
}

_DWORD *AKSIdentity.init(_:)@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

uint64_t AKSUUID.init(_:)@<X0>(uint64_t result@<X0>, char a2@<W1>, char a3@<W2>, char a4@<W3>, char a5@<W4>, char a6@<W5>, char a7@<W6>, char a8@<W7>, uint64_t a9@<X8>, int a10, int a11)
{
  *(_BYTE *)a9 = result;
  *(_BYTE *)(a9 + 1) = a2;
  *(_BYTE *)(a9 + 2) = a3;
  *(_BYTE *)(a9 + 3) = a4;
  *(_BYTE *)(a9 + 4) = a5;
  *(_BYTE *)(a9 + 5) = a6;
  *(_BYTE *)(a9 + 6) = a7;
  *(_BYTE *)(a9 + 7) = a8;
  *(_DWORD *)(a9 + 8) = a10;
  *(_DWORD *)(a9 + 12) = a11;
  return result;
}

uint64_t AKSUUID.init(_:)@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t result;
  _BYTE *v4;
  __int128 v5;

  if (*(_QWORD *)(a1 + 16) == 16)
  {
    v5 = *(_OWORD *)(a1 + 32);
    result = swift_bridgeObjectRelease();
    *a2 = v5;
  }
  else
  {
    swift_bridgeObjectRelease();
    sub_217E04E40();
    swift_allocError();
    *v4 = 10;
    return swift_willThrow();
  }
  return result;
}

uint64_t AKSUUID.init(repeating:)@<X0>(uint64_t result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2;

  v2 = 0x101010101010101 * result;
  *a2 = v2;
  a2[1] = v2;
  return result;
}

uint64_t static AKSUUID.== infix(_:_:)(__int128 *a1, __int128 *a2)
{
  size_t v3;
  size_t v4;
  __int128 v6;
  _QWORD v7[2];

  v7[1] = *MEMORY[0x24BDAC8D0];
  v6 = *a1;
  v3 = sub_217E0E5D4((size_t)&v6, (unint64_t)v7);
  v6 = *a2;
  v4 = sub_217E0E5D4((size_t)&v6, (unint64_t)v7);
  LOBYTE(a2) = sub_217E0BA78(v3, v4);
  swift_release();
  swift_release();
  return a2 & 1;
}

size_t AKSUUID.bytes.getter()
{
  __int128 *v0;
  __int128 v2;
  _QWORD v3[2];

  v3[1] = *MEMORY[0x24BDAC8D0];
  v2 = *v0;
  return sub_217E0E5D4((size_t)&v2, (unint64_t)v3);
}

BOOL sub_217E0BA78(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  uint64_t v5;
  _BOOL8 result;
  int v7;
  int v8;
  int v9;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != *(_QWORD *)(a2 + 16))
    return 0;
  if (!v2 || a1 == a2)
    return 1;
  if (*(unsigned __int8 *)(a1 + 32) != *(unsigned __int8 *)(a2 + 32))
    return 0;
  v3 = (unsigned __int8 *)(a1 + 33);
  v4 = (unsigned __int8 *)(a2 + 33);
  v5 = v2 - 1;
  do
  {
    result = v5 == 0;
    if (!v5)
      break;
    v8 = *v3++;
    v7 = v8;
    v9 = *v4++;
    --v5;
  }
  while (v7 == v9);
  return result;
}

BOOL sub_217E0BAE4(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  _BOOL8 result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = a1[2];
  if (v2 != a2[2])
    return 0;
  if (!v2 || a1 == a2)
    return 1;
  if (a1[4] != a2[4])
    return 0;
  v3 = a1 + 5;
  v4 = a2 + 5;
  v5 = v2 - 1;
  do
  {
    result = v5 == 0;
    if (!v5)
      break;
    v8 = *v3++;
    v7 = v8;
    v9 = *v4++;
    --v5;
  }
  while (v7 == v9);
  return result;
}

BOOL sub_217E0BB50()
{
  size_t v0;
  size_t v1;
  BOOL v2;

  v0 = AKSUUID.bytes.getter();
  v1 = AKSUUID.bytes.getter();
  v2 = sub_217E0BA78(v0, v1);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return v2;
}

uint64_t sub_217E0BBC8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned __int8 a3@<W2>, _OWORD *a4@<X8>)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  __int128 v18;
  _BYTE v19[48];
  _QWORD v20[5];
  char v21;

  if (*(_QWORD *)a1 != a2 || *(unsigned __int8 *)(a1 + 8) != a3)
  {
    v13 = sub_217E055EC((uint64_t)"AppleKeyStore/ASN1OctetString.swift", 35, 2, 26);
LABEL_16:
    v16 = v13;
    sub_217E04C24();
    swift_allocError();
    *v17 = v16;
    swift_willThrow();
    return sub_217E09BF8(a1);
  }
  sub_217E04CC0(a1 + 16, (uint64_t)v19);
  result = sub_217E04CC0((uint64_t)v19, (uint64_t)v20);
  if (v21 == 1)
  {
    v7 = v20[0];
    v8 = v20[1];
    v9 = v20[2];
    v10 = v20[3];
    sub_217E04CFC((uint64_t)v19, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))j__swift_unknownObjectRetain);
    if ((v10 & 1) != 0)
    {
      sub_217E2D194();
      swift_unknownObjectRetain_n();
      v14 = swift_dynamicCastClass();
      if (!v14)
      {
        sub_217E04CFC((uint64_t)v19, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))j__swift_unknownObjectRelease);
        v14 = MEMORY[0x24BEE4AF8];
      }
      v15 = *(_QWORD *)(v14 + 16);
      swift_release();
      if (__OFSUB__(v10 >> 1, v9))
      {
        __break(1u);
      }
      else if (v15 == (v10 >> 1) - v9)
      {
        v12 = swift_dynamicCastClass();
        if (!v12)
        {
          sub_217E04CFC((uint64_t)v19, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))j__swift_unknownObjectRelease);
          v12 = MEMORY[0x24BEE4AF8];
        }
        goto LABEL_13;
      }
      sub_217E04CFC((uint64_t)v19, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))j__swift_unknownObjectRelease);
    }
    sub_217E200CC(v7, v8, v9, v10);
    v12 = v11;
LABEL_13:
    sub_217E04CFC((uint64_t)v19, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))j__swift_unknownObjectRelease);
    if (*(_QWORD *)(v12 + 16) == 16)
    {
      v18 = *(_OWORD *)(v12 + 32);
      swift_release();
      result = sub_217E09BF8(a1);
      *a4 = v18;
      return result;
    }
    swift_release();
    v13 = sub_217E05734(0xD000000000000011, 0x8000000217E30FA0, (uint64_t)"AppleKeyStore/libaks_identity.swift", 35, 2, 72);
    goto LABEL_16;
  }
  __break(1u);
  return result;
}

uint64_t AKSIdentity.Config.gracePeriod.getter()
{
  uint64_t v0;

  return *(_QWORD *)v0;
}

uint64_t AKSIdentity.Config.gracePeriod.setter(uint64_t result, char a2)
{
  uint64_t v2;

  *(_QWORD *)v2 = result;
  *(_BYTE *)(v2 + 8) = a2 & 1;
  return result;
}

uint64_t (*AKSIdentity.Config.gracePeriod.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.backOffDelay.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 16);
}

uint64_t AKSIdentity.Config.backOffDelay.setter(uint64_t result, char a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 16) = result;
  *(_BYTE *)(v2 + 24) = a2 & 1;
  return result;
}

uint64_t (*AKSIdentity.Config.backOffDelay.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.maxUnlockAttempts.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 32);
}

uint64_t AKSIdentity.Config.maxUnlockAttempts.setter(uint64_t result, char a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 32) = result;
  *(_BYTE *)(v2 + 40) = a2 & 1;
  return result;
}

uint64_t (*AKSIdentity.Config.maxUnlockAttempts.modify())()
{
  return nullsub_1;
}

void AKSIdentity.Config.options.getter(uint64_t a1@<X8>)
{
  uint64_t v1;
  char v2;

  v2 = *(_BYTE *)(v1 + 56);
  *(_QWORD *)a1 = *(_QWORD *)(v1 + 48);
  *(_BYTE *)(a1 + 8) = v2;
}

uint64_t AKSIdentity.Config.options.setter(uint64_t result)
{
  uint64_t v1;
  char v2;

  v2 = *(_BYTE *)(result + 8);
  *(_QWORD *)(v1 + 48) = *(_QWORD *)result;
  *(_BYTE *)(v1 + 56) = v2;
  return result;
}

uint64_t (*AKSIdentity.Config.options.modify())()
{
  return nullsub_1;
}

__n128 AKSIdentity.Config.userUUID.getter@<Q0>(__n128 *a1@<X8>)
{
  uint64_t v1;
  unsigned __int8 v2;
  __n128 result;

  v2 = *(_BYTE *)(v1 + 73);
  result = *(__n128 *)(v1 + 57);
  *a1 = result;
  a1[1].n128_u8[0] = v2;
  return result;
}

__n128 AKSIdentity.Config.userUUID.setter(__n128 *a1)
{
  uint64_t v1;
  unsigned __int8 v2;
  __n128 result;

  v2 = a1[1].n128_u8[0];
  result = *a1;
  *(__n128 *)(v1 + 57) = *a1;
  *(_BYTE *)(v1 + 73) = v2;
  return result;
}

uint64_t (*AKSIdentity.Config.userUUID.modify())()
{
  return nullsub_1;
}

__n128 AKSIdentity.Config.groupUUID.getter@<Q0>(__n128 *a1@<X8>)
{
  uint64_t v1;
  unsigned __int8 v2;
  __n128 result;

  v2 = *(_BYTE *)(v1 + 90);
  result = *(__n128 *)(v1 + 74);
  *a1 = result;
  a1[1].n128_u8[0] = v2;
  return result;
}

__n128 AKSIdentity.Config.groupUUID.setter(__n128 *a1)
{
  uint64_t v1;
  unsigned __int8 v2;
  __n128 result;

  v2 = a1[1].n128_u8[0];
  result = *a1;
  *(__n128 *)(v1 + 74) = *a1;
  *(_BYTE *)(v1 + 90) = v2;
  return result;
}

uint64_t (*AKSIdentity.Config.groupUUID.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.recoveryIterations.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 96);
}

uint64_t AKSIdentity.Config.recoveryIterations.setter(uint64_t result, char a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 96) = result;
  *(_BYTE *)(v2 + 104) = a2 & 1;
  return result;
}

uint64_t (*AKSIdentity.Config.recoveryIterations.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.recoveryTargetIterations.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 112);
}

uint64_t AKSIdentity.Config.recoveryTargetIterations.setter(uint64_t result, char a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 112) = result;
  *(_BYTE *)(v2 + 120) = a2 & 1;
  return result;
}

uint64_t (*AKSIdentity.Config.recoveryTargetIterations.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.recoveryFlags.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 128);
}

uint64_t AKSIdentity.Config.recoveryFlags.setter(uint64_t result, char a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 128) = result;
  *(_BYTE *)(v2 + 136) = a2 & 1;
  return result;
}

uint64_t (*AKSIdentity.Config.recoveryFlags.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.mementoSupported.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 137);
}

uint64_t AKSIdentity.Config.mementoSupported.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 137) = result;
  return result;
}

uint64_t (*AKSIdentity.Config.mementoSupported.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.mementoBlobExists.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 138);
}

uint64_t AKSIdentity.Config.mementoBlobExists.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 138) = result;
  return result;
}

uint64_t (*AKSIdentity.Config.mementoBlobExists.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.mementoPasscodeGeneration.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 144);
}

uint64_t AKSIdentity.Config.mementoPasscodeGeneration.setter(uint64_t result, char a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 144) = result;
  *(_BYTE *)(v2 + 152) = a2 & 1;
  return result;
}

uint64_t (*AKSIdentity.Config.mementoPasscodeGeneration.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.passcodeGeneration.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 160);
}

uint64_t AKSIdentity.Config.passcodeGeneration.setter(uint64_t result, char a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 160) = result;
  *(_BYTE *)(v2 + 168) = a2 & 1;
  return result;
}

uint64_t (*AKSIdentity.Config.passcodeGeneration.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.escrowPasscodePeriod.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 176);
}

uint64_t AKSIdentity.Config.escrowPasscodePeriod.setter(uint64_t result, char a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 176) = result;
  *(_BYTE *)(v2 + 184) = a2 & 1;
  return result;
}

uint64_t (*AKSIdentity.Config.escrowPasscodePeriod.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.escrowTokenPeriod.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 192);
}

uint64_t AKSIdentity.Config.escrowTokenPeriod.setter(uint64_t result, char a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 192) = result;
  *(_BYTE *)(v2 + 200) = a2 & 1;
  return result;
}

uint64_t (*AKSIdentity.Config.escrowTokenPeriod.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.inactivityRebootEnabled.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 201);
}

uint64_t AKSIdentity.Config.inactivityRebootEnabled.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 201) = result;
  return result;
}

uint64_t (*AKSIdentity.Config.inactivityRebootEnabled.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.onenessAutomaticMode.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 202);
}

uint64_t AKSIdentity.Config.onenessAutomaticMode.setter(uint64_t result)
{
  uint64_t v1;

  *(_BYTE *)(v1 + 202) = result;
  return result;
}

uint64_t (*AKSIdentity.Config.onenessAutomaticMode.modify())()
{
  return nullsub_1;
}

uint64_t AKSIdentity.Config.bindKEKToKB.getter()
{
  return swift_bridgeObjectRetain();
}

uint64_t AKSIdentity.Config.bindKEKToKB.setter(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  result = swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + 208) = a1;
  return result;
}

uint64_t (*AKSIdentity.Config.bindKEKToKB.modify())()
{
  return nullsub_1;
}

void AKSIdentity.Config.init()(uint64_t a1@<X8>)
{
  *(_QWORD *)a1 = 0;
  *(_BYTE *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 24) = 1;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 40) = 1;
  *(_QWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 1;
  *(_QWORD *)(a1 + 57) = 0;
  *(_QWORD *)(a1 + 65) = 0;
  *(_BYTE *)(a1 + 73) = 1;
  *(_QWORD *)(a1 + 74) = 0;
  *(_QWORD *)(a1 + 82) = 0;
  *(_BYTE *)(a1 + 90) = 1;
  *(_QWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 104) = 1;
  *(_QWORD *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 120) = 1;
  *(_QWORD *)(a1 + 128) = 0;
  *(_BYTE *)(a1 + 136) = 1;
  *(_WORD *)(a1 + 137) = 514;
  *(_QWORD *)(a1 + 144) = 0;
  *(_BYTE *)(a1 + 152) = 1;
  *(_QWORD *)(a1 + 160) = 0;
  *(_BYTE *)(a1 + 168) = 1;
  *(_QWORD *)(a1 + 176) = 0;
  *(_BYTE *)(a1 + 184) = 1;
  *(_QWORD *)(a1 + 192) = 0;
  *(_BYTE *)(a1 + 200) = 1;
  *(_WORD *)(a1 + 201) = 514;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 224) = 0;
}

uint64_t AKSIdentity.Config.Options.rawValue.getter()
{
  uint64_t v0;

  return *(_QWORD *)v0;
}

uint64_t AKSIdentity.Config.Options.init(rawValue:)@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  *a2 = result;
  return result;
}

void static AKSIdentity.Config.Options.gracePeriodSet.getter(_QWORD *a1@<X8>)
{
  *a1 = 1;
}

void static AKSIdentity.Config.Options.inactivityRebootEnabled.getter(_QWORD *a1@<X8>)
{
  *a1 = 2;
}

void static AKSIdentity.Config.Options.inactivityRebootSet.getter(_QWORD *a1@<X8>)
{
  *a1 = 4;
}

void static AKSIdentity.Config.Options.onenessAutomaticMode.getter(_QWORD *a1@<X8>)
{
  *a1 = 8;
}

_QWORD *sub_217E0C248@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void sub_217E0C254(_QWORD *a1@<X8>)
{
  *a1 = 0;
}

_QWORD *sub_217E0C25C@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v2;

  *a2 = *v2 | *result;
  return result;
}

_QWORD *sub_217E0C270@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v2;

  *a2 = *v2 & *result;
  return result;
}

_QWORD *sub_217E0C284@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v2;

  *a2 = *v2 ^ *result;
  return result;
}

BOOL sub_217E0C298(_QWORD *a1, uint64_t *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  v3 = *a2;
  v4 = *v2 & *a2;
  if (v4 != *a2)
    *v2 |= v3;
  *a1 = v3;
  return v4 != v3;
}

_QWORD *sub_217E0C2C8@<X0>(_QWORD *result@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v2;
  uint64_t v3;

  v3 = *v2 & *result;
  if (v3)
    *v2 &= ~*result;
  *(_QWORD *)a2 = v3;
  *(_BYTE *)(a2 + 8) = v3 == 0;
  return result;
}

uint64_t *sub_217E0C2F4@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *result;
  v4 = *v2;
  *v2 |= *result;
  v5 = v4 & v3;
  *(_QWORD *)a2 = v5;
  *(_BYTE *)(a2 + 8) = v5 == 0;
  return result;
}

_QWORD *sub_217E0C318(_QWORD *result)
{
  _QWORD *v1;

  *v1 |= *result;
  return result;
}

_QWORD *sub_217E0C32C(_QWORD *result)
{
  _QWORD *v1;

  *v1 &= *result;
  return result;
}

_QWORD *sub_217E0C340(_QWORD *result)
{
  _QWORD *v1;

  *v1 ^= *result;
  return result;
}

_QWORD *sub_217E0C354@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v2;

  *a2 = *v2 & ~*result;
  return result;
}

BOOL sub_217E0C368(_QWORD *a1)
{
  _QWORD *v1;

  return (*v1 & ~*a1) == 0;
}

BOOL sub_217E0C37C(_QWORD *a1)
{
  _QWORD *v1;

  return (*v1 & *a1) == 0;
}

BOOL sub_217E0C390(_QWORD *a1)
{
  _QWORD *v1;

  return (*a1 & ~*v1) == 0;
}

BOOL sub_217E0C3A4()
{
  _QWORD *v0;

  return *v0 == 0;
}

uint64_t sub_217E0C3B4()
{
  return sub_217E2D11C();
}

_QWORD *sub_217E0C3CC(_QWORD *result)
{
  _QWORD *v1;

  *v1 &= ~*result;
  return result;
}

_QWORD *sub_217E0C3E0@<X0>(_QWORD *result@<X0>, uint64_t a2@<X8>)
{
  *(_QWORD *)a2 = *result;
  *(_BYTE *)(a2 + 8) = 0;
  return result;
}

void sub_217E0C3F0(_QWORD *a1@<X8>)
{
  _QWORD *v1;

  *a1 = *v1;
}

BOOL sub_217E0C3FC(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

uint64_t AKSIdentity.getConfiguration()@<X0>(uint64_t a1@<X8>)
{
  int *v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t inited;
  uint64_t v7;
  uint64_t result;
  char *v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _OWORD v18[14];
  uint64_t v19;
  char *v20;
  uint64_t v21;
  _BYTE v22[96];

  v4 = *v1;
  v5 = sub_217E2D008();
  *(_QWORD *)(v5 + 16) = 0x8000;
  bzero((void *)(v5 + 32), 0x8000uLL);
  v21 = v5;
  __swift_instantiateConcreteTypeFromMangledName(&qword_254F278A8);
  inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_217E33B50;
  *(_QWORD *)(inited + 32) = v4;
  v20 = 0;
  v7 = sub_217E2272C(0x1Fu, inited, 0, &v20, &v21);
  result = swift_bridgeObjectRelease();
  if (v2)
  {
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  else if ((_DWORD)v7)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    sub_217E04E40();
    swift_allocError();
    sub_217E14ED8(v7, v9);
    return swift_willThrow();
  }
  else
  {
    v10 = v21;
    if (v21)
    {
      swift_bridgeObjectRelease();
      sub_217E09CBC(v10, v10 + 32, 0, (2 * *(_QWORD *)(v10 + 16)) | 1, (uint64_t)v22);
      swift_bridgeObjectRelease();
      result = sub_217E0CAA0((uint64_t)v22, 17, 0, (uint64_t)v18);
      v11 = v18[13];
      *(_OWORD *)(a1 + 192) = v18[12];
      *(_OWORD *)(a1 + 208) = v11;
      *(_QWORD *)(a1 + 224) = v19;
      v12 = v18[9];
      *(_OWORD *)(a1 + 128) = v18[8];
      *(_OWORD *)(a1 + 144) = v12;
      v13 = v18[11];
      *(_OWORD *)(a1 + 160) = v18[10];
      *(_OWORD *)(a1 + 176) = v13;
      v14 = v18[5];
      *(_OWORD *)(a1 + 64) = v18[4];
      *(_OWORD *)(a1 + 80) = v14;
      v15 = v18[7];
      *(_OWORD *)(a1 + 96) = v18[6];
      *(_OWORD *)(a1 + 112) = v15;
      v16 = v18[1];
      *(_OWORD *)a1 = v18[0];
      *(_OWORD *)(a1 + 16) = v16;
      v17 = v18[3];
      *(_OWORD *)(a1 + 32) = v18[2];
      *(_OWORD *)(a1 + 48) = v17;
    }
    else
    {
      __break(1u);
    }
  }
  return result;
}

uint64_t AKSIdentity.setConfiguration(_:_:)(uint64_t a1, uint64_t a2)
{
  int *v2;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  int v21;
  char v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  __int16 v38;
  char v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  char v45;
  uint64_t v46;
  __int16 v47;
  __int128 v48;
  unsigned int v49;
  _OWORD v50[14];
  uint64_t v51;
  char *v52;
  _OWORD v53[2];
  __int128 v54;
  _BYTE v55[48];
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  uint64_t v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  _BYTE v68[48];
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;
  uint64_t v78;

  v4 = *(_OWORD *)(a2 + 208);
  v62 = *(_OWORD *)(a2 + 192);
  v63 = v4;
  v64 = *(_QWORD *)(a2 + 224);
  v5 = *(_OWORD *)(a2 + 144);
  v58 = *(_OWORD *)(a2 + 128);
  v59 = v5;
  v6 = *(_OWORD *)(a2 + 176);
  v60 = *(_OWORD *)(a2 + 160);
  v61 = v6;
  v7 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)&v55[16] = *(_OWORD *)(a2 + 64);
  *(_OWORD *)&v55[32] = v7;
  v8 = *(_OWORD *)(a2 + 112);
  v56 = *(_OWORD *)(a2 + 96);
  v57 = v8;
  v9 = *(_OWORD *)(a2 + 16);
  v53[0] = *(_OWORD *)a2;
  v53[1] = v9;
  v10 = *(_OWORD *)(a2 + 48);
  v54 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)v55 = v10;
  v21 = *v2;
  v48 = v63;
  v47 = *(_WORD *)((char *)&v62 + 9);
  v46 = v62;
  v45 = BYTE8(v62);
  v44 = v61;
  v43 = BYTE8(v61);
  v42 = v60;
  v41 = BYTE8(v60);
  v40 = v59;
  v38 = *(_WORD *)((char *)&v58 + 9);
  v39 = BYTE8(v59);
  v37 = v58;
  v36 = BYTE8(v58);
  v35 = v57;
  v34 = BYTE8(v57);
  v33 = v56;
  v32 = BYTE8(v56);
  v30 = *(_QWORD *)&v55[34];
  v31 = *(_QWORD *)&v55[26];
  v29 = v55[42];
  v27 = *(_QWORD *)&v55[17];
  v28 = *(_QWORD *)&v55[9];
  v26 = v55[25];
  v25 = v10;
  v24 = BYTE8(v10);
  v23 = v54;
  v22 = BYTE8(v54);
  v11 = v9;
  v12 = BYTE8(v9);
  v13 = *(_QWORD *)&v53[0];
  v14 = BYTE8(v53[0]);
  sub_217E0E684((uint64_t)v53);
  v52 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)&v65 = v13;
  BYTE8(v65) = v14;
  *(_QWORD *)&v66 = v11;
  BYTE8(v66) = v12;
  *(_QWORD *)&v67 = v23;
  BYTE8(v67) = v22;
  *(_QWORD *)v68 = v25;
  v68[8] = v24;
  *(_QWORD *)&v68[9] = v28;
  *(_QWORD *)&v68[17] = v27;
  v68[25] = v26;
  *(_QWORD *)&v68[26] = v31;
  *(_QWORD *)&v68[34] = v30;
  v68[42] = v29;
  *(_QWORD *)&v69 = v33;
  BYTE8(v69) = v32;
  *(_QWORD *)&v70 = v35;
  BYTE8(v70) = v34;
  *(_QWORD *)&v71 = v37;
  BYTE8(v71) = v36;
  *(_WORD *)((char *)&v71 + 9) = v38;
  *(_QWORD *)&v72 = v40;
  BYTE8(v72) = v39;
  *(_QWORD *)&v73 = v42;
  BYTE8(v73) = v41;
  *(_QWORD *)&v74 = v44;
  BYTE8(v74) = v43;
  *(_QWORD *)&v75 = v46;
  BYTE8(v75) = v45;
  *(_WORD *)((char *)&v75 + 9) = v47;
  v76 = v48;
  v77 = a1;
  v50[12] = v75;
  v50[13] = v48;
  v51 = a1;
  v50[8] = v71;
  v50[9] = v72;
  v50[10] = v73;
  v50[11] = v74;
  v50[4] = *(_OWORD *)&v68[16];
  v50[5] = *(_OWORD *)&v68[32];
  v50[6] = v69;
  v50[7] = v70;
  v50[0] = v65;
  v50[1] = v66;
  v50[2] = v67;
  v50[3] = *(_OWORD *)v68;
  v15 = v78;
  sub_217E0E6C8(&v52);
  sub_217E0F948((uint64_t)&v65);
  if (v15)
  {
    swift_bridgeObjectRelease();
    sub_217E04E40();
    swift_allocError();
    *v16 = 23;
    swift_willThrow();
    return MEMORY[0x219A18338](v15);
  }
  else
  {
    v18 = sub_217E2D008();
    *(_QWORD *)(v18 + 16) = 0x8000;
    bzero((void *)(v18 + 32), 0x8000uLL);
    *(_QWORD *)&v50[0] = v18;
    v49 = -1;
    sub_217E0C9D4((uint64_t)(v52 + 32), *((_QWORD *)v52 + 2), v21, &v49, (uint64_t *)v50);
    swift_bridgeObjectRelease();
    v19 = v49;
    if (v49)
    {
      sub_217E04E40();
      swift_allocError();
      sub_217E14ED8(v19, v20);
      swift_willThrow();
    }
    return swift_bridgeObjectRelease();
  }
}

uint64_t sub_217E0C9D4(uint64_t a1, uint64_t a2, int a3, _DWORD *a4, uint64_t *a5)
{
  uint64_t v5;
  uint64_t result;
  int v12;
  char *v13;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F278A8);
  result = swift_initStackObject();
  *(_OWORD *)(result + 16) = xmmword_217E33B60;
  *(_QWORD *)(result + 32) = a3;
  *(_QWORD *)(result + 40) = a1;
  if (a2 < 0)
  {
    __break(1u);
  }
  else
  {
    *(_QWORD *)(result + 48) = a2;
    v13 = 0;
    v12 = sub_217E2272C(0x1Eu, result, 0, &v13, a5);
    swift_bridgeObjectRelease();
    result = swift_setDeallocating();
    if (!v5)
      *a4 = v12;
  }
  return result;
}

uint64_t sub_217E0CAA0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned __int8 a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  char *v7;
  uint64_t result;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  __int128 v62;
  uint64_t v63;
  char v64;
  _BYTE v65[7];
  uint64_t v66;
  char v67;
  _BYTE v68[7];
  uint64_t v69;
  char v70;
  uint64_t v71;
  uint64_t v72;
  char v73;
  uint64_t v74;
  uint64_t v75;
  char v76;
  int v77;
  char v78;
  uint64_t v79;
  char v80;
  _BYTE v81[7];
  uint64_t v82;
  char v83;
  _BYTE v84[7];
  uint64_t v85;
  char v86;
  char v87;
  char v88;
  int v89;
  char v90;
  uint64_t v91;
  char v92;
  _BYTE v93[7];
  uint64_t v94;
  char v95;
  _BYTE v96[7];
  uint64_t v97;
  char v98;
  _BYTE v99[7];
  uint64_t v100;
  char v101;
  __int16 v102;
  int v103;
  char v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  char v109;
  char v110;
  _BYTE v111[7];
  char v112;
  _BYTE v113[7];
  char v114;
  _BYTE v115[7];
  char v116;
  int v117;
  char v118;
  char v119;
  _BYTE v120[7];
  char v121;
  _BYTE v122[7];
  char v123;
  int v124;
  char v125;
  char v126;
  char v127;
  char v128;
  _BYTE v129[7];
  char v130;
  _BYTE v131[7];
  char v132;
  _BYTE v133[7];
  char v134;
  _BYTE v135[32];
  __int128 v136;
  __int128 v137;
  _BYTE v138[96];
  _BYTE v139[32];
  __int128 v140;
  __int128 v141;
  _BYTE v142[96];
  _BYTE v143[32];
  __int128 v144;
  __int128 v145;
  _BYTE v146[96];
  _BYTE v147[32];
  __int128 v148;
  __int128 v149;
  _BYTE v150[96];
  _BYTE v151[32];
  __int128 v152;
  __int128 v153;
  _BYTE v154[96];
  _BYTE v155[32];
  __int128 v156;
  __int128 v157;
  _BYTE v158[96];
  _BYTE v159[32];
  __int128 v160;
  __int128 v161;
  _BYTE v162[96];
  _BYTE v163[32];
  __int128 v164;
  __int128 v165;
  _BYTE v166[96];
  _BYTE v167[32];
  __int128 v168;
  __int128 v169;
  _BYTE v170[96];
  _BYTE v171[32];
  __int128 v172;
  __int128 v173;
  _BYTE v174[96];
  _BYTE v175[32];
  __int128 v176;
  __int128 v177;
  _BYTE v178[96];
  _BYTE v179[32];
  __int128 v180;
  __int128 v181;
  _BYTE v182[96];
  _BYTE v183[32];
  __int128 v184;
  __int128 v185;
  _BYTE v186[96];
  _BYTE v187[32];
  __int128 v188;
  __int128 v189;
  _BYTE v190[96];
  _BYTE v191[32];
  __int128 v192;
  __int128 v193;
  _BYTE v194[96];
  _OWORD v195[2];
  _OWORD v196[2];
  _OWORD v197[2];
  _OWORD v198[2];
  _OWORD v199[2];
  _OWORD v200[2];
  _OWORD v201[2];
  _OWORD v202[2];
  _OWORD v203[2];
  _OWORD v204[2];
  _OWORD v205[2];
  _OWORD v206[2];
  _OWORD v207[2];
  _OWORD v208[2];
  _OWORD v209[3];
  uint64_t v210;

  v134 = 1;
  v132 = 1;
  v130 = 1;
  v128 = 1;
  v127 = 1;
  v126 = 1;
  v123 = 1;
  v121 = 1;
  v119 = 1;
  v116 = 1;
  v114 = 1;
  v112 = 1;
  v110 = 1;
  *(_QWORD *)&v62 = MEMORY[0x24BEE4AF8];
  v7 = sub_217E05E84(a1, a2, a3, (char **)&v62);
  if (v4)
  {
    swift_bridgeObjectRelease();
    sub_217E09BF8(a1);
    *(_QWORD *)&v62 = 0;
    BYTE8(v62) = v134;
    *(_DWORD *)((char *)&v62 + 9) = *(_DWORD *)v133;
    HIDWORD(v62) = *(_DWORD *)&v133[3];
    v63 = 0;
    v64 = v132;
    *(_DWORD *)v65 = *(_DWORD *)v131;
    *(_DWORD *)&v65[3] = *(_DWORD *)&v131[3];
    v66 = 0;
    v67 = v130;
    *(_DWORD *)v68 = *(_DWORD *)v129;
    *(_DWORD *)&v68[3] = *(_DWORD *)&v129[3];
    v69 = 0;
    v70 = v128;
    v71 = 0;
    v72 = 0;
    v73 = v127;
    v74 = 0;
    v75 = 0;
    v76 = v126;
    v78 = v125;
    v77 = v124;
    v79 = 0;
    v80 = v123;
    *(_DWORD *)&v81[3] = *(_DWORD *)&v122[3];
    *(_DWORD *)v81 = *(_DWORD *)v122;
    v82 = 0;
    v83 = v121;
    *(_DWORD *)&v84[3] = *(_DWORD *)&v120[3];
    *(_DWORD *)v84 = *(_DWORD *)v120;
    v85 = 0;
    v86 = v119;
    v87 = 2;
    v88 = 2;
    v90 = v118;
    v89 = v117;
    v91 = 0;
    v92 = v116;
    *(_DWORD *)&v93[3] = *(_DWORD *)&v115[3];
    *(_DWORD *)v93 = *(_DWORD *)v115;
    v94 = 0;
    v95 = v114;
    *(_DWORD *)&v96[3] = *(_DWORD *)&v113[3];
    *(_DWORD *)v96 = *(_DWORD *)v113;
    v97 = 0;
    v98 = v112;
    *(_DWORD *)&v99[3] = *(_DWORD *)&v111[3];
    *(_DWORD *)v99 = *(_DWORD *)v111;
    v100 = 0;
    v101 = v110;
    v102 = 514;
    v104 = v109;
    v103 = v108;
    v105 = 0;
    v106 = 0;
    v107 = 0;
    return sub_217E0F948((uint64_t)&v62);
  }
  else
  {
    v9 = (uint64_t)v7;
    swift_bridgeObjectRelease();
    if (qword_254F275E0 != -1)
      swift_once();
    sub_217E04998(qword_254F2C0F0, qword_254F2C0F8, qword_254F2C100, v9, (uint64_t)v135);
    v209[0] = v136;
    v209[1] = v137;
    v10 = v136;
    v11 = v137;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v135);
    sub_217E09CBC(v10, *((uint64_t *)&v10 + 1), v11, *((unint64_t *)&v11 + 1), (uint64_t)v138);
    v210 = sub_217E1532C((uint64_t)v138, 2, 0);
    sub_217E09BD0((uint64_t)v209);
    v134 = 0;
    if (qword_254F275E8 != -1)
      swift_once();
    sub_217E04998(qword_254F2C110, qword_254F2C118, qword_254F2C120, v9, (uint64_t)v139);
    v60 = a4;
    v208[0] = v140;
    v208[1] = v141;
    v12 = v140;
    v13 = v141;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v139);
    sub_217E09CBC(v12, *((uint64_t *)&v12 + 1), v13, *((unint64_t *)&v13 + 1), (uint64_t)v142);
    v61 = sub_217E1532C((uint64_t)v142, 2, 0);
    sub_217E09BD0((uint64_t)v208);
    v132 = 0;
    if (qword_254F275F0 != -1)
      swift_once();
    sub_217E04998(qword_254F2C130, xmmword_254F2C138, *((unint64_t *)&xmmword_254F2C138 + 1), v9, (uint64_t)v143);
    v207[0] = v144;
    v207[1] = v145;
    v14 = v144;
    v15 = v145;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v143);
    sub_217E09CBC(v14, *((uint64_t *)&v14 + 1), v15, *((unint64_t *)&v15 + 1), (uint64_t)v146);
    v59 = sub_217E1532C((uint64_t)v146, 2, 0);
    sub_217E09BD0((uint64_t)v207);
    v130 = 0;
    if (qword_254F27608 != -1)
      swift_once();
    sub_217E04998(qword_254F2C190, *(uint64_t *)algn_254F2C198, qword_254F2C1A0, v9, (uint64_t)v147);
    v206[0] = v148;
    v206[1] = v149;
    v16 = v148;
    v17 = v149;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v147);
    sub_217E09CBC(v16, *((uint64_t *)&v16 + 1), v17, *((unint64_t *)&v17 + 1), (uint64_t)v150);
    v58 = sub_217E150D4((uint64_t)v150, 2, 0);
    sub_217E09BD0((uint64_t)v206);
    v128 = 0;
    if (qword_254F27690 != -1)
      swift_once();
    sub_217E04998(qword_254F2C3B0, xmmword_254F2C3B8, *((unint64_t *)&xmmword_254F2C3B8 + 1), v9, (uint64_t)v151);
    v205[0] = v152;
    v205[1] = v153;
    v18 = v152;
    v19 = v153;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v151);
    sub_217E09CBC(v18, *((uint64_t *)&v18 + 1), v19, *((unint64_t *)&v19 + 1), (uint64_t)v154);
    sub_217E0BBC8((uint64_t)v154, 4, 0, &v62);
    sub_217E09BD0((uint64_t)v205);
    v56 = *((_QWORD *)&v62 + 1);
    v57 = v62;
    v127 = 0;
    if (qword_254F276C8 != -1)
      swift_once();
    sub_217E04998(qword_254F2C490, unk_254F2C498, qword_254F2C4A0, v9, (uint64_t)v155);
    v204[0] = v156;
    v204[1] = v157;
    v20 = v156;
    v21 = v157;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v155);
    sub_217E09CBC(v20, *((uint64_t *)&v20 + 1), v21, *((unint64_t *)&v21 + 1), (uint64_t)v158);
    sub_217E0BBC8((uint64_t)v158, 4, 0, &v62);
    sub_217E09BD0((uint64_t)v204);
    v54 = *((_QWORD *)&v62 + 1);
    v55 = v62;
    v126 = 0;
    if (qword_254F276D8 != -1)
      swift_once();
    sub_217E04998(qword_254F2C4D0, *(uint64_t *)algn_254F2C4D8, qword_254F2C4E0, v9, (uint64_t)v159);
    v203[0] = v160;
    v203[1] = v161;
    v22 = v160;
    v23 = v161;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v159);
    sub_217E09CBC(v22, *((uint64_t *)&v22 + 1), v23, *((unint64_t *)&v23 + 1), (uint64_t)v162);
    v53 = sub_217E1532C((uint64_t)v162, 2, 0);
    sub_217E09BD0((uint64_t)v203);
    v123 = 0;
    if (qword_254F276E8 != -1)
      swift_once();
    sub_217E04998(qword_254F2C510, unk_254F2C518, qword_254F2C520, v9, (uint64_t)v163);
    v202[0] = v164;
    v202[1] = v165;
    v24 = v164;
    v25 = v165;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v163);
    sub_217E09CBC(v24, *((uint64_t *)&v24 + 1), v25, *((unint64_t *)&v25 + 1), (uint64_t)v166);
    v52 = sub_217E1532C((uint64_t)v166, 2, 0);
    sub_217E09BD0((uint64_t)v202);
    v121 = 0;
    if (qword_254F276E0 != -1)
      swift_once();
    sub_217E04998(qword_254F2C4F0, *(uint64_t *)algn_254F2C4F8, qword_254F2C500, v9, (uint64_t)v167);
    v201[0] = v168;
    v201[1] = v169;
    v26 = v168;
    v27 = v169;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v167);
    sub_217E09CBC(v26, *((uint64_t *)&v26 + 1), v27, *((unint64_t *)&v27 + 1), (uint64_t)v170);
    v37 = sub_217E1532C((uint64_t)v170, 2, 0);
    sub_217E09BD0((uint64_t)v201);
    v119 = 0;
    if (qword_254F27728 != -1)
      swift_once();
    sub_217E04998(qword_254F2C610, *(uint64_t *)algn_254F2C618, qword_254F2C620, v9, (uint64_t)v171);
    v200[0] = v172;
    v200[1] = v173;
    v28 = v172;
    v29 = v173;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v171);
    sub_217E09CBC(v28, *((uint64_t *)&v28 + 1), v29, *((unint64_t *)&v29 + 1), (uint64_t)v174);
    v38 = sub_217E0A8C0((uint64_t)v174, 1, 0);
    sub_217E09BD0((uint64_t)v200);
    v39 = v38 & 1;
    if (qword_254F27730 != -1)
      swift_once();
    sub_217E04998(qword_254F2C630, unk_254F2C638, qword_254F2C640, v9, (uint64_t)v175);
    v199[0] = v176;
    v199[1] = v177;
    v30 = v176;
    v31 = v177;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v175);
    sub_217E09CBC(v30, *((uint64_t *)&v30 + 1), v31, *((unint64_t *)&v31 + 1), (uint64_t)v178);
    v40 = sub_217E0A8C0((uint64_t)v178, 1, 0);
    sub_217E09BD0((uint64_t)v199);
    if (qword_254F27740 != -1)
      swift_once();
    sub_217E04998(qword_254F2C670, *(uint64_t *)algn_254F2C678, qword_254F2C680, v9, (uint64_t)v179);
    v198[0] = v180;
    v198[1] = v181;
    v32 = v180;
    v33 = v181;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v179);
    sub_217E09CBC(v32, *((uint64_t *)&v32 + 1), v33, *((unint64_t *)&v33 + 1), (uint64_t)v182);
    sub_217E1532C((uint64_t)v182, 2, 0);
    sub_217E09BD0((uint64_t)v198);
    v116 = 0;
    if (qword_254F27738 != -1)
      swift_once();
    sub_217E04998(qword_254F2C650, unk_254F2C658, qword_254F2C660, v9, (uint64_t)v183);
    v197[0] = v184;
    v197[1] = v185;
    v34 = v184;
    v35 = v185;
    v51 = *((_QWORD *)&v184 + 1);
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v183);
    sub_217E09CBC(v34, v51, v35, *((unint64_t *)&v35 + 1), (uint64_t)v186);
    v41 = sub_217E1532C((uint64_t)v186, 2, 0);
    sub_217E09BD0((uint64_t)v197);
    v114 = 0;
    if (qword_254F275F8 != -1)
      swift_once();
    sub_217E04998(qword_254F2C150, xmmword_254F2C158, *((unint64_t *)&xmmword_254F2C158 + 1), v9, (uint64_t)v187);
    v196[0] = v188;
    v196[1] = v189;
    v36 = v188;
    v46 = v189;
    v48 = *((_QWORD *)&v188 + 1);
    v44 = *((_QWORD *)&v189 + 1);
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v187);
    sub_217E09CBC(v36, v48, v46, v44, (uint64_t)v190);
    v42 = sub_217E1532C((uint64_t)v190, 2, 0);
    sub_217E09BD0((uint64_t)v196);
    v112 = 0;
    if (qword_254F27600 != -1)
      swift_once();
    sub_217E04998(qword_254F2C170, xmmword_254F2C178, *((unint64_t *)&xmmword_254F2C178 + 1), v9, (uint64_t)v191);
    v195[0] = v192;
    v195[1] = v193;
    v47 = v193;
    v49 = *((_QWORD *)&v192 + 1);
    v43 = v192;
    v45 = *((_QWORD *)&v193 + 1);
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v191);
    sub_217E09CBC(v43, v49, v47, v45, (uint64_t)v194);
    v50 = sub_217E1532C((uint64_t)v194, 2, 0);
    sub_217E09BD0((uint64_t)v195);
    swift_bridgeObjectRelease();
    result = sub_217E09BF8(a1);
    *(_QWORD *)v60 = v210;
    *(_BYTE *)(v60 + 8) = 0;
    *(_QWORD *)(v60 + 16) = v61;
    *(_BYTE *)(v60 + 24) = 0;
    *(_QWORD *)(v60 + 32) = v59;
    *(_BYTE *)(v60 + 40) = 0;
    *(_QWORD *)(v60 + 48) = v58;
    *(_BYTE *)(v60 + 56) = 0;
    *(_QWORD *)(v60 + 57) = v57;
    *(_QWORD *)(v60 + 65) = v56;
    *(_BYTE *)(v60 + 73) = 0;
    *(_QWORD *)(v60 + 74) = v55;
    *(_QWORD *)(v60 + 82) = v54;
    *(_BYTE *)(v60 + 90) = 0;
    *(_QWORD *)(v60 + 96) = v53;
    *(_BYTE *)(v60 + 104) = 0;
    *(_QWORD *)(v60 + 112) = v52;
    *(_BYTE *)(v60 + 120) = 0;
    *(_QWORD *)(v60 + 128) = v37;
    *(_BYTE *)(v60 + 136) = 0;
    *(_BYTE *)(v60 + 137) = v39;
    *(_BYTE *)(v60 + 138) = v40 & 1;
    *(_QWORD *)(v60 + 144) = *((_QWORD *)&v26 + 1);
    *(_BYTE *)(v60 + 152) = 0;
    *(_QWORD *)(v60 + 160) = v41;
    *(_BYTE *)(v60 + 168) = 0;
    *(_QWORD *)(v60 + 176) = v42;
    *(_BYTE *)(v60 + 184) = 0;
    *(_QWORD *)(v60 + 192) = v50;
    *(_BYTE *)(v60 + 200) = 0;
    *(_BYTE *)(v60 + 201) = (v58 & 2) != 0;
    *(_BYTE *)(v60 + 202) = (v58 & 8) != 0;
    *(_QWORD *)(v60 + 208) = 0;
    *(_QWORD *)(v60 + 216) = 0;
    *(_QWORD *)(v60 + 224) = 0;
  }
  return result;
}

char *sub_217E0E1C8(char *a1, int64_t a2, char a3, char *a4)
{
  return sub_217E0E4E0(a1, a2, a3, a4, &qword_254F277F8);
}

char *sub_217E0E1D4(char *result, int64_t a2, char a3, char *a4)
{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  size_t v11;
  char *v12;
  char *v13;

  v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    v6 = *((_QWORD *)a4 + 3);
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = *((_QWORD *)a4 + 2);
  if (v7 <= v8)
    v9 = *((_QWORD *)a4 + 2);
  else
    v9 = v7;
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&qword_254F278D8);
    v10 = (char *)swift_allocObject();
    v11 = _swift_stdlib_malloc_size(v10);
    *((_QWORD *)v10 + 2) = v8;
    *((_QWORD *)v10 + 3) = 2 * ((uint64_t)(v11 - 32) / 96);
  }
  else
  {
    v10 = (char *)MEMORY[0x24BEE4AF8];
  }
  v12 = v10 + 32;
  v13 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v10 != a4 || v12 >= &v13[96 * v8])
      memmove(v12, v13, 96 * v8);
    *((_QWORD *)a4 + 2) = 0;
  }
  else
  {
    swift_arrayInitWithCopy();
  }
  swift_bridgeObjectRelease();
  return v10;
}

char *sub_217E0E2EC(char *result, int64_t a2, char a3, char *a4)
{
  char v5;
  unint64_t v6;
  int64_t v7;
  int64_t v8;
  int64_t v9;
  char *v10;
  size_t v11;
  char *v12;
  char *v13;

  v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    v6 = *((_QWORD *)a4 + 3);
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = *((_QWORD *)a4 + 2);
  if (v7 <= v8)
    v9 = *((_QWORD *)a4 + 2);
  else
    v9 = v7;
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
    v10 = (char *)swift_allocObject();
    v11 = _swift_stdlib_malloc_size(v10);
    *((_QWORD *)v10 + 2) = v8;
    *((_QWORD *)v10 + 3) = 2 * v11 - 64;
  }
  else
  {
    v10 = (char *)MEMORY[0x24BEE4AF8];
  }
  v12 = v10 + 32;
  v13 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v10 != a4 || v12 >= &v13[v8])
      memmove(v12, v13, v8);
    *((_QWORD *)a4 + 2) = 0;
  }
  else
  {
    memcpy(v12, v13, v8);
  }
  swift_bridgeObjectRelease();
  return v10;
}

char *sub_217E0E3D4(char *result, int64_t a2, char a3, char *a4)
{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;

  v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    v6 = *((_QWORD *)a4 + 3);
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = *((_QWORD *)a4 + 2);
  if (v7 <= v8)
    v9 = *((_QWORD *)a4 + 2);
  else
    v9 = v7;
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&qword_254F278D0);
    v10 = (char *)swift_allocObject();
    v11 = _swift_stdlib_malloc_size(v10);
    v12 = v11 - 32;
    if (v11 < 32)
      v12 = v11 + 31;
    *((_QWORD *)v10 + 2) = v8;
    *((_QWORD *)v10 + 3) = 2 * (v12 >> 6);
  }
  else
  {
    v10 = (char *)MEMORY[0x24BEE4AF8];
  }
  v13 = v10 + 32;
  v14 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v10 != a4 || v13 >= &v14[64 * v8])
      memmove(v13, v14, v8 << 6);
    *((_QWORD *)a4 + 2) = 0;
  }
  else
  {
    swift_arrayInitWithCopy();
  }
  swift_bridgeObjectRelease();
  return v10;
}

char *sub_217E0E4D4(char *a1, int64_t a2, char a3, char *a4)
{
  return sub_217E0E4E0(a1, a2, a3, a4, &qword_254F278A8);
}

char *sub_217E0E4E0(char *result, int64_t a2, char a3, char *a4, uint64_t *a5)
{
  char v6;
  unint64_t v7;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  int64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;

  v6 = (char)result;
  if ((a3 & 1) != 0)
  {
    v7 = *((_QWORD *)a4 + 3);
    v8 = v7 >> 1;
    if ((uint64_t)(v7 >> 1) < a2)
    {
      if (v8 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v7 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v8 = a2;
    }
  }
  else
  {
    v8 = a2;
  }
  v9 = *((_QWORD *)a4 + 2);
  if (v8 <= v9)
    v10 = *((_QWORD *)a4 + 2);
  else
    v10 = v8;
  if (v10)
  {
    __swift_instantiateConcreteTypeFromMangledName(a5);
    v11 = (char *)swift_allocObject();
    v12 = _swift_stdlib_malloc_size(v11);
    v13 = v12 - 32;
    if (v12 < 32)
      v13 = v12 - 25;
    *((_QWORD *)v11 + 2) = v9;
    *((_QWORD *)v11 + 3) = 2 * (v13 >> 3);
  }
  else
  {
    v11 = (char *)MEMORY[0x24BEE4AF8];
  }
  v14 = v11 + 32;
  v15 = a4 + 32;
  if ((v6 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[8 * v9])
      memmove(v14, v15, 8 * v9);
    *((_QWORD *)a4 + 2) = 0;
  }
  else
  {
    memcpy(v14, v15, 8 * v9);
  }
  swift_bridgeObjectRelease();
  return v11;
}

size_t sub_217E0E5D4(size_t result, unint64_t a2)
{
  const void *v3;
  int64_t v4;
  _QWORD *v5;

  if (!result)
    return MEMORY[0x24BEE4AF8];
  v3 = (const void *)result;
  v4 = a2 - result;
  if (a2 == result)
    return MEMORY[0x24BEE4AF8];
  if (v4 < 1)
  {
    v5 = (_QWORD *)MEMORY[0x24BEE4AF8];
    if (!a2)
      goto LABEL_13;
  }
  else
  {
    __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
    v5 = (_QWORD *)swift_allocObject();
    result = _swift_stdlib_malloc_size(v5);
    v5[2] = v4;
    v5[3] = 2 * result - 64;
    if (!a2)
      goto LABEL_13;
  }
  if ((unint64_t)v3 < a2)
  {
    if ((v4 & 0x8000000000000000) == 0)
    {
      memmove(v5 + 4, v3, v4);
      return (size_t)v5;
    }
    __break(1u);
  }
LABEL_13:
  __break(1u);
  return result;
}

uint64_t sub_217E0E684(uint64_t a1)
{
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

char *sub_217E0E6C8(char **a1)
{
  uint64_t v1;
  char *v2;
  char *v3;
  char v4;
  unint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  int64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  int64_t v27;
  uint64_t v28;
  int64_t v29;
  uint64_t v30;
  int64_t v31;
  uint64_t v32;
  int64_t v33;
  uint64_t v34;
  int64_t v35;
  uint64_t v36;
  int64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t *v45;
  char *result;
  char *v47;
  char *v48;
  unint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  int64_t v54;
  unint64_t v55;
  unint64_t v56;
  char *v57;
  unint64_t v58;
  unint64_t v59;
  char *v60;
  uint64_t v61;
  int64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  unint64_t v66;
  char *v67;
  char *v68;
  uint64_t v69;
  int64_t v70;
  unint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  unint64_t v75;
  char *v76;
  char *v77;
  unint64_t v78;
  uint64_t v79;
  int64_t v80;
  unint64_t v81;
  unint64_t v82;
  char *v83;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int64_t v90;
  char *v91;
  unint64_t v92;
  unint64_t v93;
  char *v94;
  char *v95;
  uint64_t v96;
  int64_t v97;
  uint64_t v98;
  unint64_t v99;
  char *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  char *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  _BYTE *v124;
  uint64_t v125;
  uint64_t *v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  int64_t v132;
  unint64_t v133;
  unint64_t v134;
  char *v135;
  char *v136;
  uint64_t v137;
  char *v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  char *v142;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  int v147;
  uint64_t v148;
  uint64_t v149;
  int v150;
  char v151;
  char v152;
  unint64_t v153;
  unint64_t v154;
  uint64_t v155;
  char *v156;
  char *v157;
  __int128 v158;
  uint64_t v159;
  uint64_t v160;
  char *v161;
  uint64_t v162;
  uint64_t v163;
  __int128 v164;
  uint64_t v165;
  uint64_t v166;
  char *v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  char *v171;

  v3 = v2;
  v4 = *(_BYTE *)(v1 + 8);
  v156 = *(char **)(v1 + 16);
  LOBYTE(v5) = *(_BYTE *)(v1 + 24);
  v153 = *(_QWORD *)(v1 + 32);
  LODWORD(v157) = *(unsigned __int8 *)(v1 + 40);
  v148 = *(_QWORD *)(v1 + 65);
  v149 = *(_QWORD *)(v1 + 57);
  v151 = *(_BYTE *)(v1 + 73);
  LODWORD(v154) = *(unsigned __int8 *)(v1 + 184);
  v152 = *(_BYTE *)(v1 + 200);
  v150 = *(unsigned __int8 *)(v1 + 201);
  v147 = *(unsigned __int8 *)(v1 + 202);
  v144 = *(_QWORD *)(v1 + 216);
  v145 = *(_QWORD *)(v1 + 224);
  v146 = *(_QWORD *)(v1 + 208);
  v171 = 0;
  if (qword_254F275E0 == -1)
  {
    if ((v4 & 1) != 0)
    {
LABEL_3:
      v6 = 0;
      goto LABEL_4;
    }
  }
  else
  {
    swift_once();
    if ((v4 & 1) != 0)
      goto LABEL_3;
  }
  v7 = qword_254F2C0E8;
  v9 = qword_254F2C0F0;
  v10 = qword_254F2C0F8;
  v18 = (char *)qword_254F2C100;
  result = sub_217E1400C();
  v6 = v2;
  if (v2)
    return result;
  v8 = result;
  v130 = v127;
  v140 = v129;
  v141 = v128;
  v171 = (char *)MEMORY[0x24BEE4AF8];
  swift_unknownObjectRetain();
  v131 = sub_217E205B0((uint64_t)&v171, v9, v10, (unint64_t)v18);
  v132 = *((_QWORD *)v171 + 2);
  if (v132 >= v131)
  {
    v3 = 0;
    sub_217E208C8(v131, v132);
    v6 = v171;
    if (!v171)
    {
      swift_unknownObjectRelease();
      swift_unknownObjectRelease();
      goto LABEL_4;
    }
    v139 = v130;
    v142 = 0;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      goto LABEL_141;
    goto LABEL_154;
  }
LABEL_150:
  __break(1u);
LABEL_151:
  swift_once();
  while (1)
  {
    v18 = (char *)qword_254F2C3A8;
    v19 = qword_254F2C3B0;
    v7 = *((_QWORD *)&xmmword_254F2C3B8 + 1);
    v17 = xmmword_254F2C3B8;
    if (v171)
    {
      v32 = sub_217E205B0((uint64_t)&v171, qword_254F2C3B0, xmmword_254F2C3B8, *((unint64_t *)&xmmword_254F2C3B8 + 1));
      v33 = *((_QWORD *)v171 + 2);
      if (v33 < v32)
      {
        __break(1u);
        while (1)
        {
          __break(1u);
LABEL_157:
          v6 = sub_217E0E3D4(0, *((_QWORD *)v6 + 2) + 1, 1, v6);
LABEL_16:
          v24 = *((_QWORD *)v6 + 2);
          v23 = *((_QWORD *)v6 + 3);
          v5 = v24 + 1;
          if (v24 >= v23 >> 1)
            v6 = sub_217E0E3D4((char *)(v23 > 1), v24 + 1, 1, v6);
          *((_QWORD *)v6 + 2) = v5;
          v25 = &v6[64 * v24];
          *((_QWORD *)v25 + 4) = v7;
          *((_QWORD *)v25 + 5) = v8;
          *((_QWORD *)v25 + 6) = v9;
          *((_QWORD *)v25 + 7) = v10;
          *((_QWORD *)v25 + 8) = v17;
          *((_QWORD *)v25 + 9) = v156;
          *((_QWORD *)v25 + 10) = v19;
          *((_QWORD *)v25 + 11) = v141;
          swift_unknownObjectRelease();
          swift_unknownObjectRelease();
          v171 = v6;
LABEL_20:
          v3 = v142;
LABEL_21:
          v10 = (uint64_t)v3;
          if (qword_254F275F0 != -1)
            swift_once();
          v17 = qword_254F2C128;
          v7 = qword_254F2C130;
          v9 = *((_QWORD *)&xmmword_254F2C138 + 1);
          v8 = (char *)xmmword_254F2C138;
          if (v171)
          {
            v26 = sub_217E205B0((uint64_t)&v171, qword_254F2C130, xmmword_254F2C138, *((unint64_t *)&xmmword_254F2C138 + 1));
            v27 = *((_QWORD *)v171 + 2);
            if (v27 < v26)
            {
              __break(1u);
              goto LABEL_148;
            }
            v6 = (char *)&v171;
            sub_217E208C8(v26, v27);
          }
          if ((v157 & 1) != 0)
            break;
          v47 = sub_217E1400C();
          v6 = (char *)v10;
          if (v10)
            return (char *)swift_bridgeObjectRelease();
          v19 = (uint64_t)v47;
          v51 = v48;
          v5 = v49;
          v157 = v50;
          v52 = v171;
          if (!v171)
            v52 = (char *)MEMORY[0x24BEE4AF8];
          v171 = v52;
          swift_unknownObjectRetain();
          v53 = sub_217E205B0((uint64_t)&v171, v7, (uint64_t)v8, v9);
          v54 = *((_QWORD *)v171 + 2);
          if (v54 >= v53)
          {
            v10 = 0;
            sub_217E208C8(v53, v54);
            v6 = v171;
            if (!v171)
            {
              swift_unknownObjectRelease();
              swift_unknownObjectRelease();
              break;
            }
            v153 = v5;
            v156 = v51;
            swift_unknownObjectRetain();
            swift_unknownObjectRetain();
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
              goto LABEL_65;
            goto LABEL_160;
          }
        }
        while (2)
        {
          if (qword_254F275F8 != -1)
LABEL_146:
            swift_once();
          v19 = qword_254F2C148;
          v17 = qword_254F2C150;
          v8 = (char *)*((_QWORD *)&xmmword_254F2C158 + 1);
          v7 = xmmword_254F2C158;
          if (v171)
          {
            v28 = sub_217E205B0((uint64_t)&v171, qword_254F2C150, xmmword_254F2C158, *((unint64_t *)&xmmword_254F2C158 + 1));
            v29 = *((_QWORD *)v171 + 2);
            if (v29 < v28)
            {
              __break(1u);
              goto LABEL_150;
            }
            v6 = (char *)&v171;
            sub_217E208C8(v28, v29);
          }
          if ((v154 & 1) != 0)
          {
            while (1)
            {
LABEL_32:
              if (qword_254F27600 == -1)
                goto LABEL_33;
LABEL_148:
              swift_once();
LABEL_33:
              v18 = (char *)qword_254F2C168;
              v19 = qword_254F2C170;
              v7 = *((_QWORD *)&xmmword_254F2C178 + 1);
              v17 = xmmword_254F2C178;
              if (v171)
              {
                v30 = sub_217E205B0((uint64_t)&v171, qword_254F2C170, xmmword_254F2C178, *((unint64_t *)&xmmword_254F2C178 + 1));
                v31 = *((_QWORD *)v171 + 2);
                if (v31 < v30)
                {
                  __break(1u);
                  while (1)
                  {
                    __break(1u);
LABEL_154:
                    v6 = sub_217E0E3D4(0, *((_QWORD *)v6 + 2) + 1, 1, v6);
LABEL_141:
                    v134 = *((_QWORD *)v6 + 2);
                    v133 = *((_QWORD *)v6 + 3);
                    if (v134 >= v133 >> 1)
                      v6 = sub_217E0E3D4((char *)(v133 > 1), v134 + 1, 1, v6);
                    *((_QWORD *)v6 + 2) = v134 + 1;
                    v135 = &v6[64 * v134];
                    *((_QWORD *)v135 + 4) = v7;
                    *((_QWORD *)v135 + 5) = v9;
                    *((_QWORD *)v135 + 6) = v10;
                    *((_QWORD *)v135 + 7) = v18;
                    *((_QWORD *)v135 + 8) = v8;
                    *((_QWORD *)v135 + 9) = v139;
                    *((_QWORD *)v135 + 10) = v141;
                    *((_QWORD *)v135 + 11) = v140;
                    swift_unknownObjectRelease();
                    swift_unknownObjectRelease();
                    v171 = v6;
                    v3 = v142;
LABEL_4:
                    if (qword_254F275E8 != -1)
                      swift_once();
                    v7 = qword_254F2C108;
                    v8 = (char *)qword_254F2C110;
                    v9 = qword_254F2C118;
                    v10 = qword_254F2C120;
                    if (v6)
                    {
                      v11 = sub_217E205B0((uint64_t)&v171, qword_254F2C110, qword_254F2C118, qword_254F2C120);
                      v12 = *((_QWORD *)v171 + 2);
                      if (v12 < v11)
                      {
                        __break(1u);
                        goto LABEL_146;
                      }
                      v6 = (char *)&v171;
                      sub_217E208C8(v11, v12);
                    }
                    if ((v5 & 1) != 0)
                      goto LABEL_21;
                    v13 = sub_217E1400C();
                    v6 = v3;
                    if (v3)
                      return (char *)swift_bridgeObjectRelease();
                    v17 = (uint64_t)v13;
                    v18 = v14;
                    v19 = v15;
                    v5 = v16;
                    v20 = v171;
                    if (!v171)
                      v20 = (char *)MEMORY[0x24BEE4AF8];
                    v171 = v20;
                    swift_unknownObjectRetain();
                    v21 = sub_217E205B0((uint64_t)&v171, (uint64_t)v8, v9, v10);
                    v142 = 0;
                    v22 = *((_QWORD *)v171 + 2);
                    if (v22 >= v21)
                    {
                      sub_217E208C8(v21, v22);
                      v6 = v171;
                      if (v171)
                      {
                        v141 = v5;
                        v156 = v18;
                        swift_unknownObjectRetain();
                        swift_unknownObjectRetain();
                        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
                          goto LABEL_157;
                        goto LABEL_16;
                      }
                      swift_unknownObjectRelease();
                      swift_unknownObjectRelease();
                      goto LABEL_20;
                    }
                  }
                }
                v6 = (char *)&v171;
                sub_217E208C8(v30, v31);
              }
              if ((v152 & 1) != 0)
                goto LABEL_37;
              v8 = sub_217E1400C();
              v6 = (char *)v10;
              if (v10)
                return (char *)swift_bridgeObjectRelease();
              v68 = v65;
              v9 = v66;
              v157 = v67;
              if (!v171)
                v171 = (char *)MEMORY[0x24BEE4AF8];
              swift_unknownObjectRetain();
              v69 = sub_217E205B0((uint64_t)&v171, v19, v17, v7);
              v70 = *((_QWORD *)v171 + 2);
              if (v70 >= v69)
              {
                v10 = 0;
                sub_217E208C8(v69, v70);
                v6 = v171;
                if (!v171)
                {
                  swift_unknownObjectRelease();
                  swift_unknownObjectRelease();
                  goto LABEL_37;
                }
                v154 = v9;
                v156 = v68;
                swift_unknownObjectRetain();
                swift_unknownObjectRetain();
                if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
                  goto LABEL_165;
                goto LABEL_83;
              }
LABEL_162:
              __break(1u);
LABEL_163:
              v6 = sub_217E0E3D4(0, *((_QWORD *)v6 + 2) + 1, 1, v6);
LABEL_74:
              v9 = *((_QWORD *)v6 + 2);
              v63 = *((_QWORD *)v6 + 3);
              v5 = v9 + 1;
              if (v9 >= v63 >> 1)
                v6 = sub_217E0E3D4((char *)(v63 > 1), v9 + 1, 1, v6);
              *((_QWORD *)v6 + 2) = v5;
              v64 = &v6[64 * v9];
              *((_QWORD *)v64 + 4) = v19;
              *((_QWORD *)v64 + 5) = v17;
              *((_QWORD *)v64 + 6) = v7;
              *((_QWORD *)v64 + 7) = v8;
              *((_QWORD *)v64 + 8) = v18;
              *((_QWORD *)v64 + 9) = v156;
              *((_QWORD *)v64 + 10) = v154;
              *((_QWORD *)v64 + 11) = v157;
              swift_unknownObjectRelease();
              swift_unknownObjectRelease();
              v171 = v6;
            }
          }
          v18 = sub_217E1400C();
          v6 = (char *)v10;
          if (v10)
            return (char *)swift_bridgeObjectRelease();
          v5 = v58;
          v9 = v59;
          v157 = v60;
          if (!v171)
            v171 = (char *)MEMORY[0x24BEE4AF8];
          swift_unknownObjectRetain();
          v61 = sub_217E205B0((uint64_t)&v171, v17, v7, (unint64_t)v8);
          v62 = *((_QWORD *)v171 + 2);
          if (v62 < v61)
          {
LABEL_159:
            __break(1u);
LABEL_160:
            v6 = sub_217E0E3D4(0, *((_QWORD *)v6 + 2) + 1, 1, v6);
LABEL_65:
            v56 = *((_QWORD *)v6 + 2);
            v55 = *((_QWORD *)v6 + 3);
            v5 = v56 + 1;
            if (v56 >= v55 >> 1)
              v6 = sub_217E0E3D4((char *)(v55 > 1), v56 + 1, 1, v6);
            *((_QWORD *)v6 + 2) = v5;
            v57 = &v6[64 * v56];
            *((_QWORD *)v57 + 4) = v17;
            *((_QWORD *)v57 + 5) = v7;
            *((_QWORD *)v57 + 6) = v8;
            *((_QWORD *)v57 + 7) = v9;
            *((_QWORD *)v57 + 8) = v19;
            *((_QWORD *)v57 + 9) = v156;
            *((_QWORD *)v57 + 10) = v153;
            *((_QWORD *)v57 + 11) = v157;
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
            v171 = v6;
            continue;
          }
          break;
        }
        v10 = 0;
        sub_217E208C8(v61, v62);
        v6 = v171;
        if (!v171)
        {
          swift_unknownObjectRelease();
          swift_unknownObjectRelease();
          goto LABEL_32;
        }
        v154 = v9;
        v156 = (char *)v5;
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
          goto LABEL_74;
        goto LABEL_163;
      }
      v6 = (char *)&v171;
      sub_217E208C8(v32, v33);
    }
    if ((v151 & 1) != 0)
      goto LABEL_42;
    v73 = (char *)MEMORY[0x24BEE4AF8];
    v161 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
    sub_217E0B764(&v161, v149, v148);
    v6 = (char *)v10;
    v8 = v161;
    if (v10)
    {
      swift_bridgeObjectRelease();
      return (char *)swift_bridgeObjectRelease();
    }
    v9 = *((_QWORD *)v161 + 2);
    v95 = v171;
    if (!v171)
      v95 = v73;
    v171 = v95;
    swift_unknownObjectRetain();
    v96 = sub_217E205B0((uint64_t)&v171, v19, v17, v7);
    v97 = *((_QWORD *)v171 + 2);
    if (v97 >= v96)
      break;
    __break(1u);
LABEL_165:
    v6 = sub_217E0E3D4(0, *((_QWORD *)v6 + 2) + 1, 1, v6);
LABEL_83:
    v9 = *((_QWORD *)v6 + 2);
    v71 = *((_QWORD *)v6 + 3);
    if (v9 >= v71 >> 1)
      v6 = sub_217E0E3D4((char *)(v71 > 1), v9 + 1, 1, v6);
    *((_QWORD *)v6 + 2) = v9 + 1;
    v72 = &v6[64 * v9];
    *((_QWORD *)v72 + 4) = v18;
    *((_QWORD *)v72 + 5) = v19;
    *((_QWORD *)v72 + 6) = v17;
    *((_QWORD *)v72 + 7) = v7;
    *((_QWORD *)v72 + 8) = v8;
    *((_QWORD *)v72 + 9) = v156;
    *((_QWORD *)v72 + 10) = v154;
    *((_QWORD *)v72 + 11) = v157;
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    v171 = v6;
LABEL_37:
    if (qword_254F27690 != -1)
      goto LABEL_151;
  }
  v10 = 0;
  sub_217E208C8(v96, v97);
  v6 = v171;
  if (v171)
  {
    v157 = v8 + 32;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      v6 = sub_217E0E3D4(0, *((_QWORD *)v6 + 2) + 1, 1, v6);
    v98 = (2 * v9) | 1;
    v9 = *((_QWORD *)v6 + 2);
    v99 = *((_QWORD *)v6 + 3);
    if (v9 >= v99 >> 1)
    {
      v136 = v6;
      v137 = v98;
      v138 = sub_217E0E3D4((char *)(v99 > 1), v9 + 1, 1, v136);
      v98 = v137;
      v6 = v138;
    }
    *((_QWORD *)v6 + 2) = v9 + 1;
    v100 = &v6[64 * v9];
    *((_QWORD *)v100 + 4) = v18;
    *((_QWORD *)v100 + 5) = v19;
    *((_QWORD *)v100 + 6) = v17;
    *((_QWORD *)v100 + 7) = v7;
    *((_QWORD *)v100 + 8) = v8;
    *((_QWORD *)v100 + 9) = v157;
    *((_QWORD *)v100 + 10) = 0;
    *((_QWORD *)v100 + 11) = v98;
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    v171 = v6;
  }
  else
  {
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
  }
LABEL_42:
  if (qword_254F27748 != -1)
    swift_once();
  v18 = (char *)qword_254F2C688;
  v19 = qword_254F2C690;
  v7 = *((_QWORD *)&xmmword_254F2C698 + 1);
  v17 = xmmword_254F2C698;
  if (!v171)
    goto LABEL_47;
  v34 = sub_217E205B0((uint64_t)&v171, qword_254F2C690, xmmword_254F2C698, *((unint64_t *)&xmmword_254F2C698 + 1));
  v35 = *((_QWORD *)v171 + 2);
  if (v35 < v34)
  {
    __break(1u);
    goto LABEL_159;
  }
  v6 = (char *)&v171;
  sub_217E208C8(v34, v35);
LABEL_47:
  if (v150 != 2)
  {
    v8 = sub_217E13F74();
    if (v10)
      return (char *)swift_bridgeObjectRelease();
    v77 = v74;
    v78 = v75;
    v157 = v76;
    if (!v171)
      v171 = (char *)MEMORY[0x24BEE4AF8];
    swift_unknownObjectRetain();
    v79 = sub_217E205B0((uint64_t)&v171, v19, v17, v7);
    v80 = *((_QWORD *)v171 + 2);
    if (v80 < v79)
    {
      __break(1u);
LABEL_167:
      swift_once();
LABEL_123:
      v104 = qword_254F2BDB0;
      v159 = qword_254F2BDA8;
      v106 = qword_254F2BDB8;
      v105 = unk_254F2BDC0;
      swift_bridgeObjectRetain();
      v107 = v19;
      v108 = sub_217E204F8();
      v110 = v109;
      v112 = v111;
      v114 = v113;
      swift_bridgeObjectRelease();
      v115 = v107;
      if (!v107)
      {
        v116 = v105;
        v162 = v159;
        v117 = &v162;
        goto LABEL_134;
      }
LABEL_129:
      sub_217E04E40();
      v123 = swift_allocError();
      *v124 = 22;
      swift_willThrow();
      MEMORY[0x219A18338](v115);
      swift_bridgeObjectRelease();
      v125 = sub_217E0556C(0xD000000000000018, 0x8000000217E30F30, (uint64_t)"AppleKeyStore/libaks_identity.swift", 35, 2, 293);
      sub_217E04C24();
      swift_allocError();
      *v126 = v125;
      swift_willThrow();
      return (char *)MEMORY[0x219A18338](v123);
    }
    v10 = 0;
    sub_217E208C8(v79, v80);
    v6 = v171;
    if (v171)
    {
      v154 = v78;
      v156 = v77;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
        goto LABEL_95;
      goto LABEL_169;
    }
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
  }
  while (1)
  {
    if (qword_254F27750 != -1)
      swift_once();
    v18 = (char *)qword_254F2C6A8;
    v19 = qword_254F2C6B0;
    v7 = *((_QWORD *)&xmmword_254F2C6B8 + 1);
    v17 = xmmword_254F2C6B8;
    if (v171)
    {
      v36 = sub_217E205B0((uint64_t)&v171, qword_254F2C6B0, xmmword_254F2C6B8, *((unint64_t *)&xmmword_254F2C6B8 + 1));
      v37 = *((_QWORD *)v171 + 2);
      if (v37 < v36)
      {
        __break(1u);
        goto LABEL_162;
      }
      sub_217E208C8(v36, v37);
    }
    if (v147 == 2)
      goto LABEL_54;
    v8 = sub_217E13F74();
    v6 = (char *)v10;
    if (v10)
      return (char *)swift_bridgeObjectRelease();
    v87 = v84;
    v88 = v85;
    v157 = v86;
    if (!v171)
      v171 = (char *)MEMORY[0x24BEE4AF8];
    swift_unknownObjectRetain();
    v89 = sub_217E205B0((uint64_t)&v171, v19, v17, v7);
    v90 = *((_QWORD *)v171 + 2);
    if (v90 >= v89)
      break;
    __break(1u);
LABEL_169:
    v6 = sub_217E0E3D4(0, *((_QWORD *)v6 + 2) + 1, 1, v6);
LABEL_95:
    v82 = *((_QWORD *)v6 + 2);
    v81 = *((_QWORD *)v6 + 3);
    if (v82 >= v81 >> 1)
      v6 = sub_217E0E3D4((char *)(v81 > 1), v82 + 1, 1, v6);
    *((_QWORD *)v6 + 2) = v82 + 1;
    v83 = &v6[64 * v82];
    *((_QWORD *)v83 + 4) = v18;
    *((_QWORD *)v83 + 5) = v19;
    *((_QWORD *)v83 + 6) = v17;
    *((_QWORD *)v83 + 7) = v7;
    *((_QWORD *)v83 + 8) = v8;
    *((_QWORD *)v83 + 9) = v156;
    *((_QWORD *)v83 + 10) = v154;
    *((_QWORD *)v83 + 11) = v157;
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    v171 = v6;
  }
  v10 = 0;
  sub_217E208C8(v89, v90);
  v91 = v171;
  if (v171)
  {
    v155 = v88;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      v91 = sub_217E0E3D4(0, *((_QWORD *)v91 + 2) + 1, 1, v91);
    v93 = *((_QWORD *)v91 + 2);
    v92 = *((_QWORD *)v91 + 3);
    if (v93 >= v92 >> 1)
      v91 = sub_217E0E3D4((char *)(v92 > 1), v93 + 1, 1, v91);
    *((_QWORD *)v91 + 2) = v93 + 1;
    v94 = &v91[64 * v93];
    *((_QWORD *)v94 + 4) = v18;
    *((_QWORD *)v94 + 5) = v19;
    *((_QWORD *)v94 + 6) = v17;
    *((_QWORD *)v94 + 7) = v7;
    *((_QWORD *)v94 + 8) = v8;
    *((_QWORD *)v94 + 9) = v87;
    *((_QWORD *)v94 + 10) = v155;
    *((_QWORD *)v94 + 11) = v157;
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    v171 = v91;
  }
  else
  {
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
  }
LABEL_54:
  v19 = v10;
  if (v146)
  {
    if (qword_254F276D0 != -1)
      swift_once();
    v158 = xmmword_254F2C4A8;
    v38 = qword_254F2C4B8;
    v39 = unk_254F2C4C0;
    swift_bridgeObjectRetain();
    v43 = sub_217E204F8();
    if (v10)
    {
      swift_bridgeObjectRelease();
      MEMORY[0x219A18338](v10);
      swift_bridgeObjectRelease();
      v44 = sub_217E0556C(0xD000000000000019, 0x8000000217E30F80, (uint64_t)"AppleKeyStore/libaks_identity.swift", 35, 2, 281);
      sub_217E04C24();
      swift_allocError();
      *v45 = v44;
      return (char *)swift_willThrow();
    }
    v101 = v40;
    v102 = v41;
    v103 = v42;
    swift_bridgeObjectRelease();
    v164 = v158;
    v165 = v38;
    v166 = v39;
    v167 = v43;
    v168 = v101;
    v169 = v102;
    v170 = v103;
    swift_unknownObjectRetain();
    sub_217E043A0((uint64_t)&v164);
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    v19 = 0;
  }
  if (v145)
  {
    if (qword_254F27510 == -1)
      goto LABEL_123;
    goto LABEL_167;
  }
  if (v144)
  {
    if (qword_254F27520 != -1)
      swift_once();
    v104 = qword_254F2BDF0;
    v160 = qword_254F2BDE8;
    v106 = qword_254F2BDF8;
    v118 = unk_254F2BE00;
    swift_bridgeObjectRetain();
    v119 = v19;
    v108 = sub_217E204F8();
    v110 = v120;
    v112 = v121;
    v114 = v122;
    swift_bridgeObjectRelease();
    v115 = v119;
    if (v119)
      goto LABEL_129;
    v116 = v118;
    v163 = v160;
    v117 = &v163;
LABEL_134:
    v117[1] = v104;
    v117[2] = v106;
    v117[3] = v116;
    v117[4] = (uint64_t)v108;
    v117[5] = v110;
    v117[6] = v112;
    v117[7] = v114;
    swift_unknownObjectRetain();
    sub_217E043A0((uint64_t)v117);
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
  }
  sub_217E08C90(0x11uLL, 0, 1, a1, v171);
  return (char *)swift_bridgeObjectRelease();
}

uint64_t sub_217E0F948(uint64_t a1)
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return a1;
}

unint64_t sub_217E0F990()
{
  unint64_t result;

  result = qword_254F278B0;
  if (!qword_254F278B0)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSIdentity.Config.Options, &type metadata for AKSIdentity.Config.Options);
    atomic_store(result, (unint64_t *)&qword_254F278B0);
  }
  return result;
}

unint64_t sub_217E0F9D8()
{
  unint64_t result;

  result = qword_254F278B8;
  if (!qword_254F278B8)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSIdentity.Config.Options, &type metadata for AKSIdentity.Config.Options);
    atomic_store(result, (unint64_t *)&qword_254F278B8);
  }
  return result;
}

unint64_t sub_217E0FA20()
{
  unint64_t result;

  result = qword_254F278C0;
  if (!qword_254F278C0)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSIdentity.Config.Options, &type metadata for AKSIdentity.Config.Options);
    atomic_store(result, (unint64_t *)&qword_254F278C0);
  }
  return result;
}

unint64_t sub_217E0FA68()
{
  unint64_t result;

  result = qword_254F278C8;
  if (!qword_254F278C8)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSIdentity.Config.Options, &type metadata for AKSIdentity.Config.Options);
    atomic_store(result, (unint64_t *)&qword_254F278C8);
  }
  return result;
}

ValueMetadata *type metadata accessor for AKSIdentity()
{
  return &type metadata for AKSIdentity;
}

__n128 __swift_memcpy16_1(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for AKSUUID(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 16))
    return (*(_DWORD *)a1 + 1);
  else
    return 0;
}

uint64_t storeEnumTagSinglePayload for AKSUUID(uint64_t result, int a2, int a3)
{
  char v3;

  if (a2)
  {
    *(_QWORD *)result = (a2 - 1);
    *(_QWORD *)(result + 8) = 0;
    if (!a3)
      return result;
    v3 = 1;
  }
  else
  {
    if (!a3)
      return result;
    v3 = 0;
  }
  *(_BYTE *)(result + 16) = v3;
  return result;
}

ValueMetadata *type metadata accessor for AKSUUID()
{
  return &type metadata for AKSUUID;
}

uint64_t destroy for AKSIdentity.Config()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for AKSIdentity.Config(uint64_t a1, uint64_t a2)
{
  __int128 v3;
  uint64_t v4;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 57);
  *(_BYTE *)(a1 + 73) = *(_BYTE *)(a2 + 73);
  *(_OWORD *)(a1 + 57) = v3;
  *(_OWORD *)(a1 + 74) = *(_OWORD *)(a2 + 74);
  *(_BYTE *)(a1 + 90) = *(_BYTE *)(a2 + 90);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_BYTE *)(a1 + 104) = *(_BYTE *)(a2 + 104);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  *(_BYTE *)(a1 + 120) = *(_BYTE *)(a2 + 120);
  *(_BYTE *)(a1 + 136) = *(_BYTE *)(a2 + 136);
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
  *(_WORD *)(a1 + 137) = *(_WORD *)(a2 + 137);
  *(_BYTE *)(a1 + 152) = *(_BYTE *)(a2 + 152);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  *(_BYTE *)(a1 + 168) = *(_BYTE *)(a2 + 168);
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
  *(_BYTE *)(a1 + 184) = *(_BYTE *)(a2 + 184);
  *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
  *(_BYTE *)(a1 + 200) = *(_BYTE *)(a2 + 200);
  *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
  *(_BYTE *)(a1 + 201) = *(_BYTE *)(a2 + 201);
  *(_BYTE *)(a1 + 202) = *(_BYTE *)(a2 + 202);
  v4 = *(_QWORD *)(a2 + 216);
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
  *(_QWORD *)(a1 + 216) = v4;
  *(_QWORD *)(a1 + 224) = *(_QWORD *)(a2 + 224);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for AKSIdentity.Config(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v4 = *a2;
  *(_BYTE *)(a1 + 8) = *((_BYTE *)a2 + 8);
  *(_QWORD *)a1 = v4;
  v5 = a2[2];
  *(_BYTE *)(a1 + 24) = *((_BYTE *)a2 + 24);
  *(_QWORD *)(a1 + 16) = v5;
  v6 = a2[4];
  *(_BYTE *)(a1 + 40) = *((_BYTE *)a2 + 40);
  *(_QWORD *)(a1 + 32) = v6;
  v7 = a2[6];
  *(_BYTE *)(a1 + 56) = *((_BYTE *)a2 + 56);
  *(_QWORD *)(a1 + 48) = v7;
  v8 = *(_OWORD *)((char *)a2 + 57);
  *(_BYTE *)(a1 + 73) = *((_BYTE *)a2 + 73);
  *(_OWORD *)(a1 + 57) = v8;
  v9 = *(_OWORD *)((char *)a2 + 74);
  *(_BYTE *)(a1 + 90) = *((_BYTE *)a2 + 90);
  *(_OWORD *)(a1 + 74) = v9;
  v10 = a2[12];
  *(_BYTE *)(a1 + 104) = *((_BYTE *)a2 + 104);
  *(_QWORD *)(a1 + 96) = v10;
  v11 = a2[14];
  *(_BYTE *)(a1 + 120) = *((_BYTE *)a2 + 120);
  *(_QWORD *)(a1 + 112) = v11;
  v12 = a2[16];
  *(_BYTE *)(a1 + 136) = *((_BYTE *)a2 + 136);
  *(_QWORD *)(a1 + 128) = v12;
  *(_BYTE *)(a1 + 137) = *((_BYTE *)a2 + 137);
  *(_BYTE *)(a1 + 138) = *((_BYTE *)a2 + 138);
  v13 = a2[18];
  *(_BYTE *)(a1 + 152) = *((_BYTE *)a2 + 152);
  *(_QWORD *)(a1 + 144) = v13;
  v14 = a2[20];
  *(_BYTE *)(a1 + 168) = *((_BYTE *)a2 + 168);
  *(_QWORD *)(a1 + 160) = v14;
  v15 = a2[22];
  *(_BYTE *)(a1 + 184) = *((_BYTE *)a2 + 184);
  *(_QWORD *)(a1 + 176) = v15;
  v16 = a2[24];
  *(_BYTE *)(a1 + 200) = *((_BYTE *)a2 + 200);
  *(_QWORD *)(a1 + 192) = v16;
  *(_BYTE *)(a1 + 201) = *((_BYTE *)a2 + 201);
  *(_BYTE *)(a1 + 202) = *((_BYTE *)a2 + 202);
  *(_QWORD *)(a1 + 208) = a2[26];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 216) = a2[27];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 224) = a2[28];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy232_8(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __n128 result;
  __int128 v11;
  __int128 v12;

  v2 = *a2;
  v3 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)a1 = v2;
  v4 = a2[3];
  v5 = a2[4];
  v6 = a2[6];
  *(_OWORD *)(a1 + 80) = a2[5];
  *(_OWORD *)(a1 + 96) = v6;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)(a1 + 64) = v5;
  v7 = a2[7];
  v8 = a2[8];
  v9 = a2[10];
  *(_OWORD *)(a1 + 144) = a2[9];
  *(_OWORD *)(a1 + 160) = v9;
  *(_OWORD *)(a1 + 112) = v7;
  *(_OWORD *)(a1 + 128) = v8;
  result = (__n128)a2[11];
  v11 = a2[12];
  v12 = a2[13];
  *(_QWORD *)(a1 + 224) = *((_QWORD *)a2 + 28);
  *(_OWORD *)(a1 + 192) = v11;
  *(_OWORD *)(a1 + 208) = v12;
  *(__n128 *)(a1 + 176) = result;
  return result;
}

uint64_t assignWithTake for AKSIdentity.Config(uint64_t a1, uint64_t a2)
{
  __int128 v4;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_BYTE *)(a1 + 40) = *(_BYTE *)(a2 + 40);
  *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  v4 = *(_OWORD *)(a2 + 57);
  *(_BYTE *)(a1 + 73) = *(_BYTE *)(a2 + 73);
  *(_OWORD *)(a1 + 57) = v4;
  *(_OWORD *)(a1 + 74) = *(_OWORD *)(a2 + 74);
  *(_BYTE *)(a1 + 90) = *(_BYTE *)(a2 + 90);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_BYTE *)(a1 + 104) = *(_BYTE *)(a2 + 104);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  *(_BYTE *)(a1 + 120) = *(_BYTE *)(a2 + 120);
  *(_BYTE *)(a1 + 136) = *(_BYTE *)(a2 + 136);
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
  *(_WORD *)(a1 + 137) = *(_WORD *)(a2 + 137);
  *(_BYTE *)(a1 + 152) = *(_BYTE *)(a2 + 152);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  *(_BYTE *)(a1 + 168) = *(_BYTE *)(a2 + 168);
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
  *(_BYTE *)(a1 + 184) = *(_BYTE *)(a2 + 184);
  *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
  *(_BYTE *)(a1 + 200) = *(_BYTE *)(a2 + 200);
  *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
  *(_BYTE *)(a1 + 201) = *(_BYTE *)(a2 + 201);
  *(_BYTE *)(a1 + 202) = *(_BYTE *)(a2 + 202);
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 208);
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 224) = *(_QWORD *)(a2 + 224);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for AKSIdentity.Config(uint64_t a1, unsigned int a2)
{
  unint64_t v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0x7FFFFFFF && *(_BYTE *)(a1 + 232))
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  v3 = *(_QWORD *)(a1 + 208);
  if (v3 >= 0xFFFFFFFF)
    LODWORD(v3) = -1;
  v4 = v3 - 1;
  if (v4 < 0)
    v4 = -1;
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for AKSIdentity.Config(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_QWORD *)result = a2 - 0x7FFFFFFF;
    if (a3 >= 0x7FFFFFFF)
      *(_BYTE *)(result + 232) = 1;
  }
  else
  {
    if (a3 >= 0x7FFFFFFF)
      *(_BYTE *)(result + 232) = 0;
    if (a2)
      *(_QWORD *)(result + 208) = a2;
  }
  return result;
}

ValueMetadata *type metadata accessor for AKSIdentity.Config()
{
  return &type metadata for AKSIdentity.Config;
}

ValueMetadata *type metadata accessor for AKSIdentity.Config.Options()
{
  return &type metadata for AKSIdentity.Config.Options;
}

BOOL static AKSError.== infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

uint64_t AKSError.hash(into:)()
{
  return sub_217E2D1F4();
}

uint64_t AKSError.hashValue.getter()
{
  sub_217E2D1E8();
  sub_217E2D1F4();
  return sub_217E2D218();
}

unint64_t sub_217E100F8()
{
  unint64_t result;

  result = qword_254F278E0;
  if (!qword_254F278E0)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSError, &type metadata for AKSError);
    atomic_store(result, (unint64_t *)&qword_254F278E0);
  }
  return result;
}

uint64_t getEnumTagSinglePayload for AKSError(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xDA)
    goto LABEL_17;
  if (a2 + 38 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 38) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 38;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 38;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 38;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0x27;
  v8 = v6 - 39;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for AKSError(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 38 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 38) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xDA)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xD9)
    return ((uint64_t (*)(void))((char *)&loc_217E10218 + 4 * byte_217E33E41[v4]))();
  *a1 = a2 + 38;
  return ((uint64_t (*)(void))((char *)sub_217E1024C + 4 * asc_217E33E3C[v4]))();
}

uint64_t sub_217E1024C(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E10254(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x217E1025CLL);
  return result;
}

uint64_t sub_217E10268(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x217E10270);
  *(_BYTE *)result = a2 + 38;
  return result;
}

uint64_t sub_217E10274(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E1027C(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AKSError()
{
  return &type metadata for AKSError;
}

uint64_t sub_217E10298()
{
  return sub_217E10444(&qword_254F278E8, &qword_254F278F0);
}

uint64_t __swift_instantiateConcreteTypeFromMangledNameAbstract(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if (result < 0)
  {
    result = MEMORY[0x219A18380](255, (char *)a1 + (int)result, -(result >> 32), 0, 0);
    *a1 = result;
  }
  return result;
}

uint64_t sub_217E10300()
{
  return sub_217E10444(&qword_254F278F8, &qword_254F27900);
}

uint64_t sub_217E10324()
{
  return sub_217E10444(&qword_254F27908, &qword_254F27910);
}

uint64_t sub_217E10348()
{
  return sub_217E10444(&qword_254F27918, &qword_254F27920);
}

uint64_t sub_217E1036C()
{
  return sub_217E10444(&qword_254F27928, &qword_254F27930);
}

uint64_t sub_217E10390()
{
  return sub_217E10444(&qword_254F27938, &qword_254F27940);
}

uint64_t sub_217E103B4()
{
  return sub_217E10444(&qword_254F27948, &qword_254F27950);
}

uint64_t sub_217E103D8()
{
  return sub_217E10444(&qword_254F27958, &qword_254F27960);
}

uint64_t sub_217E103FC()
{
  return sub_217E10444(&qword_254F27968, &qword_254F27970);
}

uint64_t sub_217E10420()
{
  return sub_217E10444(&qword_254F27978, qword_254F27980);
}

uint64_t sub_217E10444(unint64_t *a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v4;

  result = *a1;
  if (!result)
  {
    v4 = __swift_instantiateConcreteTypeFromMangledNameAbstract(a2);
    result = MEMORY[0x219A1838C](&unk_217E34640, v4);
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_217E10484(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t sub_217E1048C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 40))();
}

uint64_t sub_217E104A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 48))();
}

uint64_t sub_217E104BC()
{
  return swift_allocateGenericValueMetadata();
}

uint64_t sub_217E104C4()
{
  uint64_t result;
  unint64_t v1;

  result = swift_checkMetadataState();
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

uint64_t *sub_217E10530(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v8;

  v3 = a1;
  v4 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  v5 = *(_DWORD *)(v4 + 80);
  if (v5 <= 7 && *(_QWORD *)(v4 + 64) <= 0x18uLL && (*(_DWORD *)(v4 + 80) & 0x100000) == 0)
  {
    (*(void (**)(uint64_t *))(v4 + 16))(a1);
  }
  else
  {
    v8 = *a2;
    *v3 = *a2;
    v3 = (uint64_t *)(v8 + ((v5 + 16) & ~v5));
    swift_retain();
  }
  return v3;
}

uint64_t sub_217E105A0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a2 + 16) - 8) + 8))();
}

uint64_t sub_217E105B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a3 + 16) - 8) + 16))();
  return a1;
}

uint64_t sub_217E105E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a3 + 16) - 8) + 24))();
  return a1;
}

uint64_t sub_217E10610(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a3 + 16) - 8) + 32))();
  return a1;
}

uint64_t sub_217E10640(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a3 + 16) - 8) + 40))();
  return a1;
}

uint64_t sub_217E10670(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  char v8;
  int v9;
  unsigned int v10;
  int v11;

  if (!a2)
    return 0;
  v4 = *(_QWORD *)(*(_QWORD *)(a3 + 16) - 8);
  v5 = *(_DWORD *)(v4 + 84);
  v6 = a2 - v5;
  if (a2 <= v5)
    goto LABEL_18;
  v7 = *(_QWORD *)(v4 + 64);
  v8 = 8 * v7;
  if (v7 <= 3)
  {
    v10 = ((v6 + ~(-1 << v8)) >> v8) + 1;
    if (HIWORD(v10))
    {
      v9 = *(_DWORD *)(a1 + v7);
      if (!v9)
        goto LABEL_18;
      goto LABEL_11;
    }
    if (v10 > 0xFF)
    {
      v9 = *(unsigned __int16 *)(a1 + v7);
      if (!*(_WORD *)(a1 + v7))
        goto LABEL_18;
      goto LABEL_11;
    }
    if (v10 < 2)
    {
LABEL_18:
      if (v5)
        return (*(uint64_t (**)(void))(v4 + 48))();
      return 0;
    }
  }
  v9 = *(unsigned __int8 *)(a1 + v7);
  if (!*(_BYTE *)(a1 + v7))
    goto LABEL_18;
LABEL_11:
  v11 = (v9 - 1) << v8;
  if (v7 > 3)
    v11 = 0;
  if (!(_DWORD)v7)
    return v5 + v11 + 1;
  if (v7 > 3)
    LODWORD(v7) = 4;
  return ((uint64_t (*)(void))((char *)&loc_217E10720 + 4 * byte_217E33FB0[(v7 - 1)]))();
}

void sub_217E10770(_WORD *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6;
  unsigned int v7;
  size_t v8;
  BOOL v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;

  v6 = *(_QWORD *)(*(_QWORD *)(a4 + 16) - 8);
  v7 = *(_DWORD *)(v6 + 84);
  v8 = *(_QWORD *)(v6 + 64);
  v9 = a3 >= v7;
  v10 = a3 - v7;
  if (v10 != 0 && v9)
  {
    if (v8 <= 3)
    {
      v13 = ((v10 + ~(-1 << (8 * v8))) >> (8 * v8)) + 1;
      if (HIWORD(v13))
      {
        v11 = 4u;
      }
      else if (v13 >= 0x100)
      {
        v11 = 2;
      }
      else
      {
        v11 = v13 > 1;
      }
    }
    else
    {
      v11 = 1u;
    }
  }
  else
  {
    v11 = 0;
  }
  if (v7 < a2)
  {
    v12 = ~v7 + a2;
    if (v8 < 4)
    {
      if ((_DWORD)v8)
      {
        v14 = v12 & ~(-1 << (8 * v8));
        bzero(a1, v8);
        if ((_DWORD)v8 == 3)
        {
          *a1 = v14;
          *((_BYTE *)a1 + 2) = BYTE2(v14);
        }
        else if ((_DWORD)v8 == 2)
        {
          *a1 = v14;
        }
        else
        {
          *(_BYTE *)a1 = v14;
        }
      }
    }
    else
    {
      bzero(a1, *(_QWORD *)(v6 + 64));
      *(_DWORD *)a1 = v12;
    }
    __asm { BR              X10 }
  }
  __asm { BR              X11 }
}

uint64_t type metadata accessor for IntegerBytesCollection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for IntegerBytesCollection);
}

void sub_217E1092C()
{
  JUMPOUT(0x219A1838CLL);
}

uint64_t sub_217E1093C()
{
  return MEMORY[0x24BEE1780];
}

uint64_t sub_217E10948()
{
  return MEMORY[0x24BEE17C0];
}

uint64_t sub_217E10954()
{
  return sub_217E2CF78();
}

uint64_t sub_217E10968()
{
  return sub_217E2CFC0() & 1;
}

uint64_t sub_217E10998()
{
  sub_217E2D1E8();
  sub_217E2CF78();
  return sub_217E2D218();
}

uint64_t sub_217E109EC()
{
  sub_217E2D1E8();
  sub_217E10954();
  return sub_217E2D218();
}

uint64_t sub_217E10A2C()
{
  return sub_217E10968();
}

uint64_t sub_217E10A38(uint64_t result)
{
  if (__OFSUB__(result, 1))
  {
    __break(1u);
  }
  else if ((unint64_t)(result - 0x1000000000000001) >> 61 == 7)
  {
    sub_217E11E78();
    return sub_217E2D104();
  }
  __break(1u);
  return result;
}

uint64_t sub_217E10ABC()
{
  return sub_217E07D08();
}

uint64_t sub_217E10AC8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  void (*v26)(char *, uint64_t);
  char *v27;
  void (*v28)(char *, char *, uint64_t);
  char *v29;
  char v30;
  uint64_t result;
  char v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char v36;
  unsigned int v37;
  unsigned __int8 v38;
  char *v39;
  char *v40;
  char v41;
  char *v42;
  unsigned __int8 v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  char *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t AssociatedTypeWitness;
  char *v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  uint64_t AssociatedConformanceWitness;
  char *v60;
  unsigned __int8 v61;

  v3 = *(_QWORD *)(a2 + 16);
  v54 = *(_QWORD *)(a2 + 24);
  v55 = (char *)a1;
  v49 = *(_QWORD *)(*(_QWORD *)(v54 + 8) + 24);
  v50 = v3;
  swift_getAssociatedTypeWitness();
  v56 = *(_QWORD *)(swift_getAssociatedConformanceWitness() + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  MEMORY[0x24BDAC7A8](AssociatedTypeWitness);
  v53 = (char *)&v46 - v4;
  v5 = *(_QWORD *)(v3 - 8);
  MEMORY[0x24BDAC7A8](v6);
  v8 = (char *)&v46 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = swift_checkMetadataState();
  v58 = *(_QWORD *)(v9 - 8);
  MEMORY[0x24BDAC7A8](v9);
  v47 = (char *)&v46 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x24BDAC7A8](v11);
  v51 = (char *)&v46 - v12;
  MEMORY[0x24BDAC7A8](v13);
  v60 = (char *)&v46 - v14;
  MEMORY[0x24BDAC7A8](v15);
  v57 = (char *)&v46 - v16;
  MEMORY[0x24BDAC7A8](v17);
  v19 = (char *)&v46 - v18;
  v48 = (char *)&v46 - v18;
  v21 = MEMORY[0x24BDAC7A8](v20);
  v23 = (char *)&v46 - v22;
  (*(void (**)(char *, uint64_t, uint64_t, double))(v5 + 16))(v8, v2, v3, v21);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
  sub_217E2D0BC();
  sub_217E10A38((uint64_t)v55);
  sub_217E2D0D4();
  v24 = v3;
  v25 = (char *)AssociatedTypeWitness;
  (*(void (**)(char *, uint64_t))(v5 + 8))(v8, v24);
  v26 = *(void (**)(char *, uint64_t))(v58 + 8);
  v26(v19, v9);
  swift_getAssociatedConformanceWitness();
  sub_217E2D1AC();
  sub_217E2D188();
  v27 = v57;
  v55 = v23;
  sub_217E2D0C8();
  v26(v19, v9);
  v28 = *(void (**)(char *, char *, uint64_t))(v58 + 16);
  v28(v60, v27, v9);
  if ((sub_217E2D0F8() & 1) == 0
    || (sub_217E2D1AC(),
        v29 = v48,
        sub_217E2D188(),
        swift_getAssociatedConformanceWitness(),
        v30 = sub_217E2CFA8(),
        result = ((uint64_t (*)(char *, uint64_t))v26)(v29, v9),
        (v30 & 1) != 0))
  {
    if (sub_217E2D0EC() < 8)
      goto LABEL_15;
    v28(v51, v60, v9);
    v61 = -1;
    v32 = sub_217E2D0F8();
    v33 = sub_217E2D0EC();
    if ((v32 & 1) != 0)
    {
      if (v33 <= 8)
      {
        sub_217E2D1AC();
        v34 = v48;
        sub_217E2D188();
        swift_getAssociatedConformanceWitness();
        v35 = v51;
        v36 = sub_217E2CF90();
        v26(v34, v9);
        v37 = v61;
        v25 = v47;
        (*(void (**)(char *, char *, uint64_t))(v58 + 32))(v47, v35, v9);
        if ((v36 & 1) == 0)
        {
LABEL_14:
          v26(v25, v9);
          goto LABEL_15;
        }
        v38 = sub_217E2D0E0();
        v26(v25, v9);
        if (v37 < v38)
        {
LABEL_13:
          __break(1u);
          goto LABEL_14;
        }
LABEL_15:
        v44 = v60;
        v45 = sub_217E2D0E0();
        v26(v44, v9);
        v26(v57, v9);
        v26(v55, v9);
        return v45;
      }
    }
    else if (v33 < 9)
    {
      v42 = v51;
      v43 = sub_217E2D0E0();
      v26(v42, v9);
      if (v61 < v43)
        goto LABEL_13;
      goto LABEL_15;
    }
    sub_217E11E34();
    v39 = v48;
    sub_217E2D0BC();
    swift_getAssociatedConformanceWitness();
    v40 = v51;
    v41 = sub_217E2CF9C();
    v26(v39, v9);
    v26(v40, v9);
    if ((v41 & 1) != 0)
      goto LABEL_13;
    goto LABEL_15;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E110F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  v4 = type metadata accessor for IntegerBytesCollection.Index(255, *(_QWORD *)(a3 + 16), *(_QWORD *)(a3 + 24), a4);
  MEMORY[0x219A1838C](&unk_217E34328, v4);
  return sub_217E2D020();
}

uint64_t sub_217E1116C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  v4 = type metadata accessor for IntegerBytesCollection.Index(255, *(_QWORD *)(a3 + 16), *(_QWORD *)(a3 + 24), a4);
  MEMORY[0x219A1838C](&unk_217E34328, v4);
  return sub_217E2D038();
}

uint64_t sub_217E111D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_217E11534(a1, a2, a3, MEMORY[0x24BEE1880]);
}

_QWORD *sub_217E111E0(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return sub_217E115C4(a1, a2, a3, MEMORY[0x24BEE1880]);
}

uint64_t sub_217E111F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  MEMORY[0x219A1838C](&unk_217E34640, a4);
  return sub_217E2D014();
}

uint64_t sub_217E11258@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result;

  result = sub_217E10ABC();
  *a1 = result;
  return result;
}

uint64_t sub_217E1127C@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result;

  result = sub_217E06FAC();
  *a1 = result;
  return result;
}

void (*sub_217E112A8(_QWORD *a1, uint64_t *a2, uint64_t a3))(_QWORD *a1)
{
  _BYTE *v6;
  uint64_t (*v7)();
  char v8;

  v6 = malloc(0x30uLL);
  *a1 = v6;
  v7 = sub_217E11338((uint64_t)v6, *a2, a3);
  v6[40] = v8;
  *((_QWORD *)v6 + 4) = v7;
  return sub_217E1130C;
}

void sub_217E1130C(_QWORD *a1)
{
  void *v1;

  v1 = (void *)*a1;
  (*(void (**)(_QWORD))(*a1 + 32))(*a1);
  free(v1);
}

uint64_t (*sub_217E11338(uint64_t a1, uint64_t a2, uint64_t a3))()
{
  sub_217E10AC8(a2, a3);
  return nullsub_1;
}

uint64_t sub_217E11364(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  MEMORY[0x219A1838C](&unk_217E34640, a1);
  v3 = type metadata accessor for IntegerBytesCollection.Index(255, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), v2);
  MEMORY[0x219A1838C](&unk_217E34328, v3);
  return sub_217E2D02C();
}

void sub_217E113D4(uint64_t a1@<X8>)
{
  *(_QWORD *)a1 = 0;
  *(_WORD *)(a1 + 8) = 256;
}

uint64_t sub_217E113E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  MEMORY[0x219A1838C](&unk_217E34640, a3);
  v5 = type metadata accessor for IntegerBytesCollection.Index(255, *(_QWORD *)(a3 + 16), *(_QWORD *)(a3 + 24), v4);
  MEMORY[0x219A1838C](&unk_217E34328, v5);
  return sub_217E2D020();
}

uint64_t sub_217E11464(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  MEMORY[0x219A1838C](&unk_217E34640, a3);
  v5 = type metadata accessor for IntegerBytesCollection.Index(255, *(_QWORD *)(a3 + 16), *(_QWORD *)(a3 + 24), v4);
  MEMORY[0x219A1838C](&unk_217E34328, v5);
  return sub_217E2D038();
}

uint64_t sub_217E114DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_217E11AFC(a1, a2, a3, a4, (uint64_t (*)(_QWORD, uint64_t, uint64_t))MEMORY[0x24BEE1B68], (uint64_t (*)(char *, char *, uint64_t, uint64_t))MEMORY[0x24BEE07E0]);
}

uint64_t sub_217E11500(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_217E11AFC(a1, a2, a3, a4, MEMORY[0x24BEE08B8], (uint64_t (*)(char *, char *, uint64_t, uint64_t))MEMORY[0x24BEE07F0]);
}

uint64_t sub_217E11528(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_217E11534(a1, a2, a3, MEMORY[0x24BEE1878]);
}

uint64_t sub_217E11534(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = MEMORY[0x219A1838C](&unk_217E34640);
  v8 = type metadata accessor for IntegerBytesCollection.Index(255, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v7);
  v9 = MEMORY[0x219A1838C](&unk_217E34328, v8);
  return a4(a1, a2, v6, v9);
}

_QWORD *sub_217E115B8(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return sub_217E115C4(a1, a2, a3, MEMORY[0x24BEE1878]);
}

_QWORD *sub_217E115C4(_QWORD *a1, uint64_t a2, uint64_t a3, _QWORD *(*a4)(uint64_t *__return_ptr, _QWORD *, uint64_t, uint64_t, uint64_t))
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *result;
  uint64_t v12;

  v7 = MEMORY[0x219A1838C](&unk_217E34640);
  v9 = type metadata accessor for IntegerBytesCollection.Index(255, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v8);
  v10 = MEMORY[0x219A1838C](&unk_217E34328, v9);
  result = a4(&v12, a1, a2, v7, v10);
  *a1 = v12;
  return result;
}

uint64_t sub_217E1164C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;

  v5 = *(_QWORD *)(a1 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 16))(a2, v2, a1);
  v6 = sub_217E10ABC();
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(v2, a1);
  MEMORY[0x219A1838C](&unk_217E34498, a1);
  result = sub_217E2D164();
  *(_QWORD *)(a2 + *(int *)(result + 36)) = v6;
  return result;
}

uint64_t sub_217E116D8(uint64_t a1)
{
  MEMORY[0x219A1838C](&unk_217E34498, a1);
  return sub_217E2D044();
}

uint64_t sub_217E1170C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v3 = MEMORY[0x219A1838C](&unk_217E34498, a1);
  v4 = sub_217E11CA8(v1, a1, v3);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 - 8) + 8))(v1, a1);
  return v4;
}

uint64_t sub_217E1176C()
{
  return sub_217E2D1F4();
}

uint64_t sub_217E11790()
{
  sub_217E2D1E8();
  sub_217E2D1F4();
  return sub_217E2D218();
}

uint64_t sub_217E117D8()
{
  return sub_217E11790();
}

uint64_t sub_217E117E0()
{
  return sub_217E1176C();
}

uint64_t sub_217E117E8()
{
  sub_217E2D1E8();
  sub_217E1176C();
  return sub_217E2D218();
}

uint64_t sub_217E11824(uint64_t a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x219A1838C](&unk_217E34328, a3);
  return sub_217E2D0A4();
}

BOOL sub_217E11870(uint64_t a1, uint64_t a2)
{
  return a2 < a1;
}

BOOL sub_217E1187C(uint64_t a1, uint64_t a2)
{
  return a1 < a2;
}

BOOL sub_217E11888(uint64_t a1, uint64_t a2)
{
  return a1 >= a2;
}

BOOL sub_217E11894(uint64_t a1, uint64_t a2)
{
  return a2 >= a1;
}

BOOL sub_217E118A0(uint64_t *a1, uint64_t *a2)
{
  return sub_217E11870(*a1, *a2);
}

BOOL sub_217E118AC(uint64_t *a1, uint64_t *a2)
{
  return sub_217E11888(*a1, *a2);
}

BOOL sub_217E118B8(uint64_t *a1, uint64_t *a2)
{
  return sub_217E11894(*a1, *a2);
}

BOOL sub_217E118C4(uint64_t *a1, uint64_t *a2)
{
  return sub_217E1187C(*a1, *a2);
}

uint64_t sub_217E118D4(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  uint64_t result;

  v2 = __OFSUB__(a2, a1);
  result = a2 - a1;
  if (v2)
    __break(1u);
  return result;
}

uint64_t sub_217E118E4@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v2;
  uint64_t result;

  result = sub_217E118D4(*a1, *v2);
  *a2 = result;
  return result;
}

uint64_t sub_217E11910()
{
  return sub_217E2D0B0();
}

void sub_217E1192C()
{
  JUMPOUT(0x219A1838CLL);
}

void sub_217E1193C()
{
  JUMPOUT(0x219A1838CLL);
}

void sub_217E1194C()
{
  JUMPOUT(0x219A1838CLL);
}

uint64_t sub_217E1195C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_217E11A4C(a1, a2, a3, MEMORY[0x24BEE1BD8]);
}

unint64_t sub_217E11968()
{
  unint64_t result;

  result = qword_254F27A08;
  if (!qword_254F27A08)
  {
    result = MEMORY[0x219A1838C](MEMORY[0x24BEE1790], MEMORY[0x24BEE1768]);
    atomic_store(result, (unint64_t *)&qword_254F27A08);
  }
  return result;
}

void sub_217E119AC()
{
  JUMPOUT(0x219A1838CLL);
}

void sub_217E119BC()
{
  JUMPOUT(0x219A1838CLL);
}

uint64_t sub_217E119CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_217E11A4C(a1, a2, a3, MEMORY[0x24BEE1BA8]);
}

uint64_t sub_217E119D8(uint64_t a1)
{
  uint64_t v3;

  v3 = MEMORY[0x219A1838C](&unk_217E34578);
  return MEMORY[0x219A1838C](MEMORY[0x24BEE4218], a1, &v3);
}

void sub_217E11A20()
{
  JUMPOUT(0x219A1838CLL);
}

void sub_217E11A30()
{
  JUMPOUT(0x219A1838CLL);
}

uint64_t sub_217E11A40(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_217E11A4C(a1, a2, a3, MEMORY[0x24BEE1BD0]);
}

uint64_t sub_217E11A4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v7[2];

  v7[0] = MEMORY[0x219A1838C](&unk_217E34328, *(_QWORD *)(a1 + 16));
  v7[1] = sub_217E11968();
  return MEMORY[0x219A1838C](a4, a1, v7);
}

uint64_t sub_217E11AA8(uint64_t a1)
{
  uint64_t v3;

  v3 = MEMORY[0x219A1838C](&unk_217E34640);
  return MEMORY[0x219A1838C](MEMORY[0x24BEE4230], a1, &v3);
}

uint64_t type metadata accessor for IntegerBytesCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for IntegerBytesCollection.Index);
}

uint64_t sub_217E11AFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(_QWORD, uint64_t, uint64_t), uint64_t (*a6)(char *, char *, uint64_t, uint64_t))
{
  uint64_t AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  char v19;
  char v20;
  uint64_t result;
  uint64_t v22;
  uint64_t (*v23)(char *, char *, uint64_t, uint64_t);

  v23 = a6;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
  v11 = a5(0, AssociatedTypeWitness, AssociatedConformanceWitness);
  v12 = *(_QWORD *)(v11 - 8);
  MEMORY[0x24BDAC7A8](v11);
  v14 = (char *)&v22 - v13;
  v15 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x24BDAC7A8](v16);
  v18 = (char *)&v22 - v17;
  v19 = sub_217E2CFB4();
  (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v18, a1, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v14, a2, v11);
  if ((v19 & 1) == 0)
  {
    (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v11);
    result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v18, AssociatedTypeWitness);
    goto LABEL_5;
  }
  v20 = v23(v18, &v14[*(int *)(v11 + 36)], AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v11);
  result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v18, AssociatedTypeWitness);
  if ((v20 & 1) == 0)
LABEL_5:
    __break(1u);
  return result;
}

uint64_t sub_217E11CAC(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char v11;
  void (*v12)(char *, uint64_t, uint64_t);
  char v13;
  void (*v14)(char *, uint64_t);
  uint64_t result;
  void (*v16)(char *, uint64_t);
  uint64_t v17;

  swift_getAssociatedTypeWitness();
  swift_getAssociatedConformanceWitness();
  v4 = sub_217E2D068();
  v5 = *(_QWORD *)(v4 - 8);
  MEMORY[0x24BDAC7A8](v4);
  v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x24BDAC7A8](v8);
  v10 = (char *)&v17 - v9;
  v11 = sub_217E2CFB4();
  v12 = *(void (**)(char *, uint64_t, uint64_t))(v5 + 16);
  v12(v10, a1, v4);
  v12(v7, a2, v4);
  if ((v11 & 1) == 0)
  {
    v16 = *(void (**)(char *, uint64_t))(v5 + 8);
    v16(v7, v4);
    result = ((uint64_t (*)(char *, uint64_t))v16)(v10, v4);
    goto LABEL_5;
  }
  v13 = sub_217E2CFB4();
  v14 = *(void (**)(char *, uint64_t))(v5 + 8);
  v14(v7, v4);
  result = ((uint64_t (*)(char *, uint64_t))v14)(v10, v4);
  if ((v13 & 1) == 0)
LABEL_5:
    __break(1u);
  return result;
}

unint64_t sub_217E11E34()
{
  unint64_t result;

  result = qword_254F27A10;
  if (!qword_254F27A10)
  {
    result = MEMORY[0x219A1838C](MEMORY[0x24BEE4298], MEMORY[0x24BEE4260]);
    atomic_store(result, (unint64_t *)&qword_254F27A10);
  }
  return result;
}

unint64_t sub_217E11E78()
{
  unint64_t result;

  result = qword_254F27A18[0];
  if (!qword_254F27A18[0])
  {
    result = MEMORY[0x219A1838C](MEMORY[0x24BEE17B0], MEMORY[0x24BEE1768]);
    atomic_store(result, qword_254F27A18);
  }
  return result;
}

uint64_t __swift_instantiateGenericMetadata(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD v6[3];

  v6[0] = a2;
  v6[1] = a3;
  v6[2] = a4;
  return MEMORY[0x219A1835C](a1, v6, a5);
}

void sub_217E11EF0()
{
  _QWORD *v0;
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;

  v1 = v0[2];
  v2 = v0[3];
  v3 = v2 >> 1;
  if (v1 == v2 >> 1)
    goto LABEL_2;
  if (v1 >= (uint64_t)(v2 >> 1))
  {
LABEL_20:
    __break(1u);
    goto LABEL_21;
  }
  v7 = v0[1];
  v8 = *(char *)(v7 + v1);
  v9 = v0[2];
  if (v8 < 0)
  {
    v9 = v1 + 1;
    if (v1 + 1 == v3)
    {
LABEL_2:
      v4 = 0x8000000217E30FC0;
      v5 = 0xD000000000000026;
      v6 = 275;
LABEL_17:
      v14 = sub_217E0556C(v5, v4, (uint64_t)"AppleKeyStore/ObjectIdentifier.swift", 36, 2, v6);
      sub_217E04C24();
      swift_allocError();
      *v15 = v14;
      swift_willThrow();
      return;
    }
    while (v9 < v3)
    {
      if ((*(char *)(v7 + v9) & 0x80000000) == 0)
        goto LABEL_5;
      v13 = v9 + 1;
      if (__OFADD__(v9, 1))
        goto LABEL_19;
      ++v9;
      if (v13 == v3)
        goto LABEL_2;
    }
    __break(1u);
LABEL_19:
    __break(1u);
    goto LABEL_20;
  }
LABEL_5:
  v10 = v9 + 1;
  if (v9 + 1 < v1)
  {
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }
  if (v9 >= -1)
  {
    if (v8 != -128 && v1 != v10)
    {
      v11 = v0[3] & 1 | (2 * v10);
      v0[2] = v10;
      v12 = swift_unknownObjectRetain();
      sub_217E12528(v12, v7, v1, v11);
      return;
    }
    v5 = 0xD00000000000002DLL;
    v4 = 0x8000000217E31020;
    v6 = 283;
    goto LABEL_17;
  }
LABEL_22:
  __break(1u);
}

uint64_t sub_217E12060(unint64_t a1)
{
  char **v1;
  unint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t result;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char v14;
  unint64_t v15;

  if (a1)
  {
    v3 = __clz(a1);
    v4 = *v1;
    if (v3 - 57 >= 7)
    {
      v5 = (((37 * (70 - v3)) >> 8)
          + (((70 - v3 - ((unsigned __int16)(37 * (70 - v3)) >> 8)) & 0xFE) >> 1)) >> 2;
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
        v4 = sub_217E0E2EC(0, *((_QWORD *)v4 + 2) + 1, 1, v4);
      v6 = 7 * v5 - 7;
      v7 = v5;
      while (v7 <= v5)
      {
        v9 = *((_QWORD *)v4 + 2);
        v8 = *((_QWORD *)v4 + 3);
        if (v9 >= v8 >> 1)
          v4 = sub_217E0E2EC((char *)(v8 > 1), v9 + 1, 1, v4);
        --v7;
        *((_QWORD *)v4 + 2) = v9 + 1;
        v4[v9 + 32] = (a1 >> v6) | 0x80;
        v6 -= 7;
        if (v7 == 1)
          goto LABEL_17;
      }
      __break(1u);
LABEL_17:
      *v1 = v4;
    }
    v14 = a1 & 0x7F;
    result = swift_isUniquelyReferenced_nonNull_native();
    if ((result & 1) == 0)
    {
      result = (uint64_t)sub_217E0E2EC(0, *((_QWORD *)v4 + 2) + 1, 1, v4);
      v4 = (char *)result;
    }
    v12 = *((_QWORD *)v4 + 2);
    v15 = *((_QWORD *)v4 + 3);
    v13 = v12 + 1;
    if (v12 >= v15 >> 1)
    {
      result = (uint64_t)sub_217E0E2EC((char *)(v15 > 1), v12 + 1, 1, v4);
      v4 = (char *)result;
    }
  }
  else
  {
    v4 = *v1;
    result = swift_isUniquelyReferenced_nonNull_native();
    if ((result & 1) == 0)
    {
      result = (uint64_t)sub_217E0E2EC(0, *((_QWORD *)v4 + 2) + 1, 1, v4);
      v4 = (char *)result;
    }
    v12 = *((_QWORD *)v4 + 2);
    v11 = *((_QWORD *)v4 + 3);
    v13 = v12 + 1;
    if (v12 >= v11 >> 1)
    {
      result = (uint64_t)sub_217E0E2EC((char *)(v11 > 1), v12 + 1, 1, v4);
      v4 = (char *)result;
    }
    v14 = 0;
  }
  *((_QWORD *)v4 + 2) = v13;
  v4[v12 + 32] = v14;
  *v1 = v4;
  return result;
}

uint64_t sub_217E12250(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  sub_217E2D1E8();
  v2 = *(_QWORD *)(a1 + 16);
  sub_217E2D1F4();
  if (v2)
  {
    v3 = a1 + 32;
    do
    {
      v3 += 8;
      sub_217E2D1F4();
      --v2;
    }
    while (v2);
  }
  return sub_217E2D218();
}

uint64_t sub_217E122BC()
{
  uint64_t *v0;

  return sub_217E12250(*v0);
}

uint64_t sub_217E122C4()
{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  v1 = *v0;
  v2 = *(_QWORD *)(*v0 + 16);
  result = sub_217E2D1F4();
  if (v2)
  {
    v4 = v1 + 32;
    do
    {
      v4 += 8;
      result = sub_217E2D1F4();
      --v2;
    }
    while (v2);
  }
  return result;
}

uint64_t sub_217E12314()
{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *v0;
  sub_217E2D1E8();
  v2 = *(_QWORD *)(v1 + 16);
  sub_217E2D1F4();
  if (v2)
  {
    v3 = v1 + 32;
    do
    {
      v3 += 8;
      sub_217E2D1F4();
      --v2;
    }
    while (v2);
  }
  return sub_217E2D218();
}

BOOL sub_217E1237C(_QWORD **a1, _QWORD **a2)
{
  return sub_217E0BAE4(*a1, *a2);
}

uint64_t sub_217E12388@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  *a2 = result;
  return result;
}

uint64_t sub_217E12390(uint64_t a1)
{
  int64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
  {
    v11 = MEMORY[0x24BEE4AF8];
    swift_bridgeObjectRetain();
    sub_217E126CC(0, v1, 0);
    v2 = 0;
    do
    {
      v3 = sub_217E2D17C();
      v5 = v4;
      v7 = *(_QWORD *)(v11 + 16);
      v6 = *(_QWORD *)(v11 + 24);
      if (v7 >= v6 >> 1)
        sub_217E126CC((char *)(v6 > 1), v7 + 1, 1);
      ++v2;
      *(_QWORD *)(v11 + 16) = v7 + 1;
      v8 = v11 + 16 * v7;
      *(_QWORD *)(v8 + 32) = v3;
      *(_QWORD *)(v8 + 40) = v5;
    }
    while (v1 != v2);
    swift_bridgeObjectRelease();
  }
  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27AA8);
  sub_217E126E8();
  v9 = sub_217E2CF84();
  swift_bridgeObjectRelease();
  return v9;
}

uint64_t sub_217E124D8()
{
  uint64_t *v0;

  return sub_217E12390(*v0);
}

unint64_t sub_217E124E4()
{
  unint64_t result;

  result = qword_254F27AA0;
  if (!qword_254F27AA0)
  {
    result = MEMORY[0x219A1838C](&unk_217E34728, &type metadata for ASN1ObjectIdentifier);
    atomic_store(result, (unint64_t *)&qword_254F27AA0);
  }
  return result;
}

void sub_217E12528(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  int64_t v4;
  uint64_t v5;
  int64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;

  v4 = a4 >> 1;
  v5 = (a4 >> 1) - a3;
  if (__OFSUB__(a4 >> 1, a3))
  {
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }
  v7 = 7 * v5;
  if ((unsigned __int128)(v5 * (__int128)7) >> 64 != (7 * v5) >> 63)
  {
LABEL_25:
    __break(1u);
    goto LABEL_26;
  }
  if (!__OFADD__(v7, 7))
  {
    if (v7 + 7 > 71)
    {
      v8 = sub_217E0556C(0xD000000000000021, 0x8000000217E31050, (uint64_t)"AppleKeyStore/ObjectIdentifier.swift", 36, 2, 298);
      sub_217E04C24();
      swift_allocError();
      *v9 = v8;
      swift_willThrow();
      swift_unknownObjectRelease();
      return;
    }
    v11 = sub_217E14DC4(0, v7, 7);
    v12 = *(_QWORD *)(v11 + 16);
    if (!v12)
    {
LABEL_22:
      swift_bridgeObjectRelease();
      swift_unknownObjectRelease();
      return;
    }
    v13 = 0;
    v14 = 0;
    if (a3 <= v4)
      v15 = v4;
    else
      v15 = a3;
    v16 = v15 - a3;
    while (v16 > v12 - 1)
    {
      v18 = *(_QWORD *)(v11 + 8 * v14 + 32);
      if (v18 - 65 <= 0xFFFFFFFFFFFFFF7ELL)
      {
        v17 = 0;
      }
      else
      {
        v19 = *(_BYTE *)(a2 + a3 + v14) & 0x7F;
        if ((v18 & 0x8000000000000000) != 0)
        {
          v21 = v19 >> -(char)v18;
          if (v18 <= 0xFFFFFFFFFFFFFFC0)
            v17 = 0;
          else
            v17 = v21;
        }
        else
        {
          v20 = v19 << v18;
          if (v18 >= 0x40)
            v17 = 0;
          else
            v17 = v20;
        }
      }
      ++v14;
      v13 |= v17;
      if (v12 == v14)
        goto LABEL_22;
    }
    __break(1u);
    goto LABEL_24;
  }
LABEL_26:
  __break(1u);
}

char *sub_217E126CC(char *a1, int64_t a2, char a3)
{
  char **v3;
  char *result;

  result = sub_217E12734(a1, a2, a3, *v3);
  *v3 = result;
  return result;
}

unint64_t sub_217E126E8()
{
  unint64_t result;
  uint64_t v1;

  result = qword_254F27AB0;
  if (!qword_254F27AB0)
  {
    v1 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_254F27AA8);
    result = MEMORY[0x219A1838C](MEMORY[0x24BEE12B0], v1);
    atomic_store(result, (unint64_t *)&qword_254F27AB0);
  }
  return result;
}

char *sub_217E12734(char *result, int64_t a2, char a3, char *a4)
{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;

  v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    v6 = *((_QWORD *)a4 + 3);
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = *((_QWORD *)a4 + 2);
  if (v7 <= v8)
    v9 = *((_QWORD *)a4 + 2);
  else
    v9 = v7;
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&qword_254F27AB8);
    v10 = (char *)swift_allocObject();
    v11 = _swift_stdlib_malloc_size(v10);
    v12 = v11 - 32;
    if (v11 < 32)
      v12 = v11 - 17;
    *((_QWORD *)v10 + 2) = v8;
    *((_QWORD *)v10 + 3) = 2 * (v12 >> 4);
  }
  else
  {
    v10 = (char *)MEMORY[0x24BEE4AF8];
  }
  v13 = v10 + 32;
  v14 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v10 != a4 || v13 >= &v14[16 * v8])
      memmove(v13, v14, 16 * v8);
    *((_QWORD *)a4 + 2) = 0;
  }
  else
  {
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

ValueMetadata *type metadata accessor for ASN1ObjectIdentifier()
{
  return &type metadata for ASN1ObjectIdentifier;
}

uint64_t sub_217E12844()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;

  v1 = v0[2];
  v2 = v0[3] >> 1;
  result = v2 - v1;
  if (__OFSUB__(v2, v1))
  {
    __break(1u);
  }
  else
  {
    v4 = v0[1];
    result = sub_217E2D1F4();
    v5 = __OFSUB__(v2, v1);
    v6 = v2 - v1;
    if (!v6)
      return sub_217E2D1F4();
    if (!((v6 < 0) ^ v5 | (v6 == 0)))
    {
      v7 = v4 + v1;
      do
      {
        ++v7;
        sub_217E2D200();
        --v6;
      }
      while (v6);
      return sub_217E2D1F4();
    }
  }
  __break(1u);
  return result;
}

uint64_t sub_217E128BC()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;

  sub_217E2D1E8();
  v1 = v0[2];
  v2 = v0[3] >> 1;
  result = v2 - v1;
  if (__OFSUB__(v2, v1))
  {
    __break(1u);
  }
  else
  {
    v4 = v0[1];
    result = sub_217E2D1F4();
    v5 = __OFSUB__(v2, v1);
    v6 = v2 - v1;
    if (!v6)
    {
LABEL_6:
      sub_217E2D1F4();
      return sub_217E2D218();
    }
    if (!((v6 < 0) ^ v5 | (v6 == 0)))
    {
      v7 = v4 + v1;
      do
      {
        ++v7;
        sub_217E2D200();
        --v6;
      }
      while (v6);
      goto LABEL_6;
    }
  }
  __break(1u);
  return result;
}

uint64_t sub_217E12960()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t result;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;

  v1 = v0[1];
  v2 = v0[2];
  v3 = v0[3];
  sub_217E2D1E8();
  v4 = v3 >> 1;
  result = v4 - v2;
  if (__OFSUB__(v4, v2))
  {
    __break(1u);
  }
  else
  {
    result = sub_217E2D1F4();
    v6 = __OFSUB__(v4, v2);
    v7 = v4 - v2;
    if (!v7)
    {
LABEL_6:
      sub_217E2D1F4();
      return sub_217E2D218();
    }
    if (!((v7 < 0) ^ v6 | (v7 == 0)))
    {
      v8 = v1 + v2;
      do
      {
        ++v8;
        sub_217E2D200();
        --v7;
      }
      while (v7);
      goto LABEL_6;
    }
  }
  __break(1u);
  return result;
}

uint64_t sub_217E129F4(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1[4];
  v3 = a2[4];
  return sub_217E085E8(a1[1], a1[2], a1[3], a2[1], a2[2], a2[3]) & (v2 == v3);
}

unint64_t sub_217E12A38()
{
  unint64_t result;

  result = qword_254F27AC0;
  if (!qword_254F27AC0)
  {
    result = MEMORY[0x219A1838C](&unk_217E347E8, &type metadata for ASN1BitString);
    atomic_store(result, (unint64_t *)&qword_254F27AC0);
  }
  return result;
}

ValueMetadata *type metadata accessor for ASN1BitString()
{
  return &type metadata for ASN1BitString;
}

uint64_t sub_217E12A8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  swift_unknownObjectRetain();
  sub_217E20404(a2, a3, a4, a5);
  return swift_unknownObjectRelease();
}

uint64_t sub_217E12AF8()
{
  uint64_t v0;

  return sub_217E0B6D0(*(_QWORD *)(v0 + 8), *(_QWORD *)(v0 + 16), *(_QWORD *)(v0 + 24));
}

unint64_t sub_217E12B08()
{
  unint64_t result;

  result = qword_254F27AC8;
  if (!qword_254F27AC8)
  {
    result = MEMORY[0x219A1838C]("\uD7AD54&", &type metadata for ASN1OctetString);
    atomic_store(result, (unint64_t *)&qword_254F27AC8);
  }
  return result;
}

ValueMetadata *type metadata accessor for ASN1OctetString()
{
  return &type metadata for ASN1OctetString;
}

double sub_217E12B5C(uint64_t a1)
{
  return sub_217E12C20(a1, 111, &qword_254F2BD08, &qword_254F2BD10, &qword_254F2BD18);
}

double sub_217E12B74(uint64_t a1)
{
  return sub_217E13B7C(a1, 25442, &qword_254F2BD28, &qword_254F2BD30, &qword_254F2BD38);
}

double sub_217E12B8C(uint64_t a1)
{
  return sub_217E12C20(a1, 100, (uint64_t *)&xmmword_254F2BD48, (_QWORD *)&xmmword_254F2BD48 + 1, &qword_254F2BD58);
}

double sub_217E12BA4(uint64_t a1)
{
  return sub_217E13B7C(a1, 25697, &qword_254F2BD68, &qword_254F2BD70, &qword_254F2BD78);
}

double sub_217E12BBC(uint64_t a1)
{
  return sub_217E13B7C(a1, 25701, &qword_254F2BD88, &qword_254F2BD90, &qword_254F2BD98);
}

double sub_217E12BD4(uint64_t a1)
{
  return sub_217E13E08(a1, 1751999329, &qword_254F2BDA8, &qword_254F2BDB0, &qword_254F2BDB8);
}

double sub_217E12BF0(uint64_t a1)
{
  return sub_217E13B7C(a1, 26465, &qword_254F2BDC8, &qword_254F2BDD0, &qword_254F2BDD8);
}

double sub_217E12C08(uint64_t a1)
{
  return sub_217E12C20(a1, 112, &qword_254F2BDE8, &qword_254F2BDF0, &qword_254F2BDF8);
}

double sub_217E12C20(uint64_t a1, char a2, uint64_t *a3, _QWORD *a4, _OWORD *a5)
{
  uint64_t v9;
  size_t v10;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v9 = swift_allocObject();
  v10 = _swift_stdlib_malloc_size((const void *)v9);
  *(_BYTE *)(v9 + 32) = a2;
  *(_QWORD *)(v9 + 16) = 1;
  *(_QWORD *)(v9 + 24) = 2 * v10 - 64;
  *a3 = v9;
  *a4 = v9 + 32;
  result = 0.0;
  *a5 = xmmword_217E34960;
  return result;
}

double sub_217E12CA4(uint64_t a1)
{
  return sub_217E13E08(a1, 1953259891, &qword_254F2BE08, &qword_254F2BE10, &qword_254F2BE18);
}

double sub_217E12CC0()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 30064;
  *(_BYTE *)(v0 + 34) = 98;
  *(_QWORD *)&xmmword_254F2BE28 = v0;
  *((_QWORD *)&xmmword_254F2BE28 + 1) = v0 + 32;
  result = 0.0;
  xmmword_254F2BE38 = xmmword_217E34970;
  return result;
}

double sub_217E12D34(uint64_t a1)
{
  return sub_217E13B7C(a1, 29803, &qword_254F2BE48, &qword_254F2BE50, &qword_254F2BE58);
}

double sub_217E12D4C(uint64_t a1)
{
  return sub_217E13B7C(a1, 30315, &qword_254F2BE68, &qword_254F2BE70, algn_254F2BE78);
}

double sub_217E12D64()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 26987;
  *(_BYTE *)(v0 + 34) = 100;
  qword_254F2BE88 = v0;
  qword_254F2BE90 = v0 + 32;
  result = 0.0;
  xmmword_254F2BE98 = xmmword_217E34970;
  return result;
}

double sub_217E12DD8(uint64_t a1)
{
  return sub_217E13B7C(a1, 27506, &qword_254F2BEA8, &qword_254F2BEB0, &qword_254F2BEB8);
}

double sub_217E12DF0(uint64_t a1)
{
  return sub_217E13B7C(a1, 25967, &qword_254F2BEC8, &qword_254F2BED0, &qword_254F2BED8);
}

double sub_217E12E08(uint64_t a1)
{
  return sub_217E13E08(a1, 1702323055, &qword_254F2BEE8, &qword_254F2BEF0, &qword_254F2BEF8);
}

double sub_217E12E24(uint64_t a1)
{
  return sub_217E13B7C(a1, 25711, &qword_254F2BF08, &qword_254F2BF10, &qword_254F2BF18);
}

double sub_217E12E3C(uint64_t a1)
{
  return sub_217E13E08(a1, 1818584175, &qword_254F2BF28, &qword_254F2BF30, &qword_254F2BF38);
}

double sub_217E12E58(uint64_t a1)
{
  return sub_217E13B7C(a1, 25455, &qword_254F2BF48, &qword_254F2BF50, &qword_254F2BF58);
}

double sub_217E12E70(uint64_t a1)
{
  return sub_217E13E08(a1, 1852273519, &qword_254F2BF68, &qword_254F2BF70, &qword_254F2BF78);
}

double sub_217E12E8C(uint64_t a1)
{
  return sub_217E13E08(a1, 1667986287, &qword_254F2BF88, &qword_254F2BF90, &qword_254F2BF98);
}

double sub_217E12EA8(uint64_t a1)
{
  return sub_217E13B7C(a1, 30575, &qword_254F2BFA8, &qword_254F2BFB0, &qword_254F2BFB8);
}

double sub_217E12EC0()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 30063;
  *(_BYTE *)(v0 + 34) = 119;
  qword_254F2BFC8 = v0;
  unk_254F2BFD0 = v0 + 32;
  result = 0.0;
  xmmword_254F2BFD8 = xmmword_217E34970;
  return result;
}

double sub_217E12F34()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 25455;
  *(_BYTE *)(v0 + 34) = 107;
  qword_254F2BFE8 = v0;
  qword_254F2BFF0 = v0 + 32;
  result = 0.0;
  xmmword_254F2BFF8 = xmmword_217E34970;
  return result;
}

double sub_217E12FA8(uint64_t a1)
{
  return sub_217E13B7C(a1, 24943, &qword_254F2C008, &qword_254F2C010, &qword_254F2C018);
}

double sub_217E12FC0(uint64_t a1)
{
  return sub_217E13E08(a1, 1802990191, &qword_254F2C028, &qword_254F2C030, &qword_254F2C038);
}

double sub_217E12FDC()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 30319;
  *(_BYTE *)(v0 + 34) = 107;
  qword_254F2C048 = v0;
  unk_254F2C050 = v0 + 32;
  result = 0.0;
  xmmword_254F2C058 = xmmword_217E34970;
  return result;
}

double sub_217E13050(uint64_t a1)
{
  return sub_217E13E08(a1, 1701012847, &qword_254F2C068, &qword_254F2C070, &qword_254F2C078);
}

double sub_217E1306C(uint64_t a1)
{
  return sub_217E13E08(a1, 1684235631, &qword_254F2C088, &qword_254F2C090, &qword_254F2C098);
}

double sub_217E13088(uint64_t a1)
{
  return sub_217E13E08(a1, 1952671087, &qword_254F2C0A8, &qword_254F2C0B0, &qword_254F2C0B8);
}

double sub_217E130A4()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 25188;
  *(_BYTE *)(v0 + 34) = 104;
  qword_254F2C0C8 = v0;
  unk_254F2C0D0 = v0 + 32;
  result = 0.0;
  xmmword_254F2C0D8 = xmmword_217E34970;
  return result;
}

double sub_217E13118(uint64_t a1)
{
  return sub_217E13B7C(a1, 28775, &qword_254F2C0E8, &qword_254F2C0F0, &qword_254F2C0F8);
}

double sub_217E13130(uint64_t a1)
{
  return sub_217E13B7C(a1, 25698, &qword_254F2C108, &qword_254F2C110, &qword_254F2C118);
}

double sub_217E13148()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 30061;
  *(_BYTE *)(v0 + 34) = 97;
  qword_254F2C128 = v0;
  qword_254F2C130 = v0 + 32;
  result = 0.0;
  xmmword_254F2C138 = xmmword_217E34970;
  return result;
}

double sub_217E131BC()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 28773;
  *(_BYTE *)(v0 + 34) = 112;
  qword_254F2C148 = v0;
  qword_254F2C150 = v0 + 32;
  result = 0.0;
  xmmword_254F2C158 = xmmword_217E34970;
  return result;
}

double sub_217E13230()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 29797;
  *(_BYTE *)(v0 + 34) = 112;
  qword_254F2C168 = v0;
  qword_254F2C170 = v0 + 32;
  result = 0.0;
  xmmword_254F2C178 = xmmword_217E34970;
  return result;
}

double sub_217E132A4(uint64_t a1)
{
  return sub_217E13B7C(a1, 26211, &qword_254F2C188, &qword_254F2C190, algn_254F2C198);
}

double sub_217E132BC(uint64_t a1)
{
  return sub_217E13E08(a1, 1634431855, &qword_254F2C1A8, &qword_254F2C1B0, &qword_254F2C1B8);
}

double sub_217E132D8()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 5;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_DWORD *)(v0 + 32) = 1667986287;
  *(_BYTE *)(v0 + 36) = 50;
  qword_254F2C1C8 = v0;
  unk_254F2C1D0 = v0 + 32;
  result = 0.0;
  xmmword_254F2C1D8 = xmmword_217E34980;
  return result;
}

double sub_217E13350()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 5;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_DWORD *)(v0 + 32) = 1735095151;
  *(_BYTE *)(v0 + 36) = 112;
  qword_254F2C1E8 = v0;
  unk_254F2C1F0 = v0 + 32;
  result = 0.0;
  xmmword_254F2C1F8 = xmmword_217E34980;
  return result;
}

double sub_217E133C8(uint64_t a1)
{
  return sub_217E13E08(a1, 1869312879, &qword_254F2C208, &qword_254F2C210, &qword_254F2C218);
}

double sub_217E133E4(uint64_t a1)
{
  return sub_217E13E08(a1, 1936421743, &qword_254F2C228, &qword_254F2C230, &qword_254F2C238);
}

double sub_217E13400()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 27507;
  *(_BYTE *)(v0 + 34) = 116;
  qword_254F2C248 = v0;
  unk_254F2C250 = v0 + 32;
  result = 0.0;
  xmmword_254F2C258 = xmmword_217E34970;
  return result;
}

double sub_217E13474(uint64_t a1)
{
  return sub_217E13E08(a1, 1953198707, &qword_254F2C268, &qword_254F2C270, &qword_254F2C278);
}

double sub_217E13490(uint64_t a1)
{
  return sub_217E13E08(a1, 1634431091, &qword_254F2C288, &qword_254F2C290, &qword_254F2C298);
}

double sub_217E134AC(uint64_t a1)
{
  return sub_217E13E08(a1, 1935895411, &qword_254F2C2A8, &qword_254F2C2B0, &qword_254F2C2B8);
}

double sub_217E134C8()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 27507;
  *(_BYTE *)(v0 + 34) = 103;
  qword_254F2C2C8 = v0;
  unk_254F2C2D0 = v0 + 32;
  result = 0.0;
  xmmword_254F2C2D8 = xmmword_217E34970;
  return result;
}

double sub_217E1353C()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 27507;
  *(_BYTE *)(v0 + 34) = 111;
  qword_254F2C2E8 = v0;
  unk_254F2C2F0 = v0 + 32;
  result = 0.0;
  xmmword_254F2C2F8 = xmmword_217E34970;
  return result;
}

double sub_217E135B0(uint64_t a1)
{
  return sub_217E13E08(a1, 1936681843, &qword_254F2C308, &qword_254F2C310, &qword_254F2C318);
}

double sub_217E135CC(uint64_t a1)
{
  return sub_217E13E08(a1, 1869312615, &qword_254F2C328, &qword_254F2C330, &qword_254F2C338);
}

double sub_217E135E8(uint64_t a1)
{
  return sub_217E13E08(a1, 1768844147, &qword_254F2C348, &qword_254F2C350, &qword_254F2C358);
}

double sub_217E13604(uint64_t a1)
{
  return sub_217E13E08(a1, 1953198962, &qword_254F2C368, &qword_254F2C370, &qword_254F2C378);
}

double sub_217E13620(uint64_t a1)
{
  return sub_217E13E08(a1, 1952674674, &qword_254F2C388, &qword_254F2C390, &qword_254F2C398);
}

double sub_217E1363C()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 5;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_DWORD *)(v0 + 32) = 1769305461;
  *(_BYTE *)(v0 + 36) = 100;
  qword_254F2C3A8 = v0;
  qword_254F2C3B0 = v0 + 32;
  result = 0.0;
  xmmword_254F2C3B8 = xmmword_217E34980;
  return result;
}

double sub_217E136B4()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 5;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_DWORD *)(v0 + 32) = 1751409509;
  *(_BYTE *)(v0 + 36) = 105;
  qword_254F2C3C8 = v0;
  unk_254F2C3D0 = v0 + 32;
  result = 0.0;
  xmmword_254F2C3D8 = xmmword_217E34980;
  return result;
}

double sub_217E1372C()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 5;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_DWORD *)(v0 + 32) = 1751409509;
  *(_BYTE *)(v0 + 36) = 115;
  qword_254F2C3E8 = v0;
  unk_254F2C3F0 = v0 + 32;
  result = 0.0;
  xmmword_254F2C3F8 = xmmword_217E34980;
  return result;
}

double sub_217E137A4(uint64_t a1)
{
  return sub_217E13E08(a1, 1853059696, &qword_254F2C408, &qword_254F2C410, &qword_254F2C418);
}

double sub_217E137C0(uint64_t a1)
{
  return sub_217E13B7C(a1, 28530, &qword_254F2C428, &qword_254F2C430, &qword_254F2C438);
}

double sub_217E137D8()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 27506;
  *(_BYTE *)(v0 + 34) = 111;
  qword_254F2C448 = v0;
  qword_254F2C450 = v0 + 32;
  result = 0.0;
  xmmword_254F2C458 = xmmword_217E34970;
  return result;
}

double sub_217E1384C(uint64_t a1)
{
  return sub_217E13B7C(a1, 26228, &qword_254F2C468, &qword_254F2C470, &qword_254F2C478);
}

double sub_217E13864()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 5;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_DWORD *)(v0 + 32) = 1769305447;
  *(_BYTE *)(v0 + 36) = 100;
  qword_254F2C488 = v0;
  qword_254F2C490 = v0 + 32;
  result = 0.0;
  unk_254F2C498 = xmmword_217E34980;
  return result;
}

double sub_217E138DC(uint64_t a1)
{
  return sub_217E13B7C(a1, 27490, (uint64_t *)&xmmword_254F2C4A8, (_QWORD *)&xmmword_254F2C4A8 + 1, &qword_254F2C4B8);
}

double sub_217E138F4(uint64_t a1)
{
  return sub_217E13B7C(a1, 26994, &qword_254F2C4C8, &qword_254F2C4D0, algn_254F2C4D8);
}

double sub_217E1390C(uint64_t a1)
{
  return sub_217E13B7C(a1, 26226, &qword_254F2C4E8, &qword_254F2C4F0, algn_254F2C4F8);
}

double sub_217E13924()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 29810;
  *(_BYTE *)(v0 + 34) = 105;
  qword_254F2C508 = v0;
  qword_254F2C510 = v0 + 32;
  result = 0.0;
  unk_254F2C518 = xmmword_217E34970;
  return result;
}

double sub_217E13998(uint64_t a1)
{
  return sub_217E13B7C(a1, 26995, &qword_254F2C528, &qword_254F2C530, &qword_254F2C538);
}

double sub_217E139B0()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 26995;
  *(_BYTE *)(v0 + 34) = 50;
  qword_254F2C548 = v0;
  unk_254F2C550 = v0 + 32;
  result = 0.0;
  xmmword_254F2C558 = xmmword_217E34970;
  return result;
}

double sub_217E13A24()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 29556;
  *(_BYTE *)(v0 + 34) = 105;
  qword_254F2C568 = v0;
  unk_254F2C570 = v0 + 32;
  result = 0.0;
  xmmword_254F2C578 = xmmword_217E34970;
  return result;
}

double sub_217E13A98(uint64_t a1)
{
  return sub_217E13E08(a1, 845771636, &qword_254F2C588, &qword_254F2C590, &qword_254F2C598);
}

double sub_217E13AB4()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 6;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_DWORD *)(v0 + 32) = 1684235636;
  *(_WORD *)(v0 + 36) = 29544;
  qword_254F2C5A8 = v0;
  unk_254F2C5B0 = v0 + 32;
  result = 0.0;
  xmmword_254F2C5B8 = xmmword_217E34990;
  return result;
}

double sub_217E13B2C(uint64_t a1)
{
  return sub_217E13E08(a1, 2004312943, &qword_254F2C5C8, &qword_254F2C5D0, &qword_254F2C5D8);
}

double sub_217E13B48(uint64_t a1)
{
  return sub_217E13E08(a1, 1684632950, &qword_254F2C5E8, &qword_254F2C5F0, &qword_254F2C5F8);
}

double sub_217E13B64(uint64_t a1)
{
  return sub_217E13B7C(a1, 29549, &qword_254F2C608, &qword_254F2C610, algn_254F2C618);
}

double sub_217E13B7C(uint64_t a1, __int16 a2, uint64_t *a3, _QWORD *a4, _OWORD *a5)
{
  uint64_t v9;
  size_t v10;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v9 = swift_allocObject();
  v10 = _swift_stdlib_malloc_size((const void *)v9);
  *(_WORD *)(v9 + 32) = a2;
  *(_QWORD *)(v9 + 16) = 2;
  *(_QWORD *)(v9 + 24) = 2 * v10 - 64;
  *a3 = v9;
  *a4 = v9 + 32;
  result = 0.0;
  *a5 = xmmword_217E349A0;
  return result;
}

double sub_217E13C00()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 25197;
  *(_BYTE *)(v0 + 34) = 101;
  qword_254F2C628 = v0;
  qword_254F2C630 = v0 + 32;
  result = 0.0;
  unk_254F2C638 = xmmword_217E34970;
  return result;
}

double sub_217E13C74()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 28771;
  *(_BYTE *)(v0 + 34) = 103;
  qword_254F2C648 = v0;
  qword_254F2C650 = v0 + 32;
  result = 0.0;
  unk_254F2C658 = xmmword_217E34970;
  return result;
}

double sub_217E13CE8(uint64_t a1)
{
  return sub_217E13E08(a1, 1735421283, &qword_254F2C668, &qword_254F2C670, algn_254F2C678);
}

double sub_217E13D04()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 29289;
  *(_BYTE *)(v0 + 34) = 101;
  qword_254F2C688 = v0;
  unk_254F2C690 = v0 + 32;
  result = 0.0;
  xmmword_254F2C698 = xmmword_217E34970;
  return result;
}

double sub_217E13D78()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 24943;
  *(_BYTE *)(v0 + 34) = 109;
  qword_254F2C6A8 = v0;
  unk_254F2C6B0 = v0 + 32;
  result = 0.0;
  xmmword_254F2C6B8 = xmmword_217E34970;
  return result;
}

double sub_217E13DEC(uint64_t a1)
{
  return sub_217E13E08(a1, 1684366707, &qword_254F2C6C8, &qword_254F2C6D0, &qword_254F2C6D8);
}

double sub_217E13E08(uint64_t a1, int a2, uint64_t *a3, _QWORD *a4, _OWORD *a5)
{
  uint64_t v9;
  size_t v10;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v9 = swift_allocObject();
  v10 = _swift_stdlib_malloc_size((const void *)v9);
  *(_DWORD *)(v9 + 32) = a2;
  *(_QWORD *)(v9 + 16) = 4;
  *(_QWORD *)(v9 + 24) = 2 * v10 - 64;
  *a3 = v9;
  *a4 = v9 + 32;
  result = 0.0;
  *a5 = xmmword_217E349B0;
  return result;
}

double sub_217E13E8C()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 27503;
  *(_BYTE *)(v0 + 34) = 101;
  qword_254F2C6E8 = v0;
  unk_254F2C6F0 = v0 + 32;
  result = 0.0;
  xmmword_254F2C6F8 = xmmword_217E34970;
  return result;
}

double sub_217E13F00()
{
  uint64_t v0;
  size_t v1;
  double result;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
  v0 = swift_allocObject();
  v1 = _swift_stdlib_malloc_size((const void *)v0);
  *(_QWORD *)(v0 + 16) = 3;
  *(_QWORD *)(v0 + 24) = 2 * v1 - 64;
  *(_WORD *)(v0 + 32) = 27503;
  *(_BYTE *)(v0 + 34) = 100;
  qword_254F2C708 = v0;
  unk_254F2C710 = v0 + 32;
  result = 0.0;
  xmmword_254F2C718 = xmmword_217E34970;
  return result;
}

char *sub_217E13F74()
{
  uint64_t v0;
  char *result;
  char *v2;

  v2 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  sub_217E086BC(1uLL, 0, 0, &v2, (uint64_t (*)(char **))sub_217E22264);
  result = v2;
  if (v0)
    return (char *)swift_bridgeObjectRelease();
  return result;
}

char *sub_217E1400C()
{
  uint64_t v0;
  char *result;
  char *v2;

  v2 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  sub_217E086BC(2uLL, 0, 0, &v2, (uint64_t (*)(char **))sub_217E22240);
  result = v2;
  if (v0)
    return (char *)swift_bridgeObjectRelease();
  return result;
}

char *sub_217E140AC(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4;
  char *v7;

  v7 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  sub_217E086BC(0xCuLL, 0, 0, &v7, (uint64_t (*)(char **))sub_217E09BB4);
  if (v4)
  {
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
  }
  else
  {
    a4 = v7;
    swift_unknownObjectRelease();
  }
  return a4;
}

char *sub_217E14180(char *a1)
{
  uint64_t v1;
  char *v2;
  char *v5;

  v5 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  swift_bridgeObjectRetain();
  sub_217E08C90(0x11uLL, 0, 1, &v5, a1);
  swift_bridgeObjectRelease();
  if (v1)
    swift_bridgeObjectRelease();
  else
    v2 = v5;
  swift_bridgeObjectRelease();
  return v2;
}

uint64_t sub_217E14240(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9[12];
  _OWORD v10[4];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _OWORD v14[5];
  _BYTE v15[48];
  uint64_t v16;
  char v17;

  sub_217E05C84((uint64_t)v9);
  sub_217E04B9C((uint64_t)v9, (uint64_t)v10);
  if (!(_QWORD)v11)
  {
    v6 = sub_217E0556C(0xD00000000000002ALL, 0x8000000217E30C50, (uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, 1107);
    sub_217E04C24();
    swift_allocError();
    *v7 = v6;
    swift_willThrow();
    return v6;
  }
  v14[1] = v10[2];
  v14[2] = v10[3];
  v14[3] = v11;
  v14[4] = v12;
  v13 = v10[0];
  v14[0] = v10[1];
  if (*(_QWORD *)&v10[0] != a2 || BYTE8(v13) != a3)
  {
    v6 = sub_217E055EC((uint64_t)"AppleKeyStore/ASN1OctetString.swift", 35, 2, 26);
    sub_217E04C24();
    swift_allocError();
    *v8 = v6;
    swift_willThrow();
    sub_217E09B64(v9);
    return v6;
  }
  sub_217E04CC0((uint64_t)v14, (uint64_t)v15);
  result = sub_217E04CC0((uint64_t)v15, (uint64_t)&v16);
  if ((v17 & 1) != 0)
  {
    v6 = v16;
    sub_217E2220C((uint64_t)v15);
    sub_217E09B64(v9);
    return v6;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E143D8(uint64_t result, unint64_t a2, unint64_t a3, uint64_t (*a4)(_BYTE *, uint64_t))
{
  uint64_t (*v4)(_BYTE *, uint64_t);
  char **v5;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  int64_t v10;
  uint64_t v11;
  int64_t v12;
  int64_t v13;
  char *isUniquelyReferenced_nonNull_native;
  int64_t v16;
  int64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t (*v25)(_BYTE *, _QWORD);
  char *v26;
  char v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  int64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  unint64_t v36;
  uint64_t (*v37)(_BYTE *, _QWORD);
  char *v38;
  char *v39;
  unint64_t v40;
  int64_t v41;
  int64_t v42;
  int64_t v43;
  uint64_t v44;
  uint64_t v45;
  _BYTE v46[32];
  int64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;

  v8 = (71 - __clz(a3)) >> 3;
  if (v8 < result)
  {
    __break(1u);
    goto LABEL_17;
  }
  if (v8 < a2)
  {
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }
  v10 = result;
  v11 = result - a2;
  v6 = *v5;
  v12 = *((_QWORD *)*v5 + 2);
  v13 = v12 + result - a2;
  if (__OFADD__(v12, result - a2))
  {
LABEL_18:
    __break(1u);
LABEL_19:
    __break(1u);
    goto LABEL_20;
  }
  v4 = a4;
  isUniquelyReferenced_nonNull_native = (char *)swift_isUniquelyReferenced_nonNull_native();
  if (!(_DWORD)isUniquelyReferenced_nonNull_native || (v16 = *((_QWORD *)v6 + 3) >> 1, v16 < v13))
  {
    if (v12 <= v13)
      v17 = v13;
    else
      v17 = v12;
    v6 = sub_217E0E2EC(isUniquelyReferenced_nonNull_native, v17, 1, v6);
    v16 = *((_QWORD *)v6 + 3) >> 1;
  }
  v18 = *((_QWORD *)v6 + 2);
  v19 = v16 - v18;
  result = (uint64_t)sub_217E20180(&v47, &v6[v18 + 32], v16 - v18, v10, a2, a3);
  if (result < v11)
    goto LABEL_19;
  if (result >= 1)
  {
    v20 = *((_QWORD *)v6 + 2);
    v21 = __OFADD__(v20, result);
    v22 = v20 + result;
    if (v21)
    {
      __break(1u);
LABEL_41:
      v33 = v7 - v10 + 1;
      goto LABEL_42;
    }
    *((_QWORD *)v6 + 2) = v22;
  }
  if (result != v19)
  {
LABEL_15:
    *v5 = v6;
    return result;
  }
LABEL_20:
  v23 = v50;
  if (__OFSUB__(v50, v48))
    goto LABEL_45;
  if (v50 == v48)
    goto LABEL_15;
  v7 = *((_QWORD *)v6 + 2);
  v24 = v49;
  v43 = v47;
  v45 = v48;
  v25 = (uint64_t (*)(_BYTE *, _QWORD))v4(v46, v50);
  v27 = *v26;
  result = v25(v46, 0);
  v28 = v23 - 1;
  if (v23 < 1)
    goto LABEL_47;
  v29 = v24;
  v42 = (71 - __clz(v24)) >> 3;
  if (v42 < v23)
    goto LABEL_47;
  v30 = v45;
LABEL_26:
  while (1)
  {
    v31 = *((_QWORD *)v6 + 3);
    v32 = v31 >> 1;
    v33 = v7 + 1;
    if ((uint64_t)(v31 >> 1) < v7 + 1)
      break;
    v34 = v7 - v32;
    if (v7 < v32)
      goto LABEL_28;
LABEL_25:
    *((_QWORD *)v6 + 2) = v7;
  }
  v39 = v6;
  v40 = v29;
  result = (uint64_t)sub_217E0E2EC((char *)(v31 > 1), v7 + 1, 1, v39);
  v29 = v40;
  v30 = v45;
  v6 = (char *)result;
  v32 = *(_QWORD *)(result + 24) >> 1;
  v34 = v7 - v32;
  if (v7 >= v32)
    goto LABEL_25;
LABEL_28:
  v6[v7 + 32] = v27;
  if (__OFSUB__(v28, v30))
    goto LABEL_46;
  v41 = v32;
  if (v28 == v30)
  {
LABEL_42:
    *((_QWORD *)v6 + 2) = v33;
    goto LABEL_15;
  }
  v10 = 0;
  v44 = v34 + 1;
  v35 = v6 + 33;
  while (1)
  {
    v36 = v29;
    v37 = (uint64_t (*)(_BYTE *, _QWORD))((uint64_t (*)(_BYTE *, uint64_t, int64_t))v4)(v46, v28 + v10, v43);
    v27 = *v38;
    result = v37(v46, 0);
    if (v28 > v42 || v28 + v10 < 1)
      break;
    v29 = v36;
    if (v44 == v10)
    {
      v28 = v28 + v10 - 1;
      v7 = v41;
      v30 = v45;
      *((_QWORD *)v6 + 2) = v41;
      goto LABEL_26;
    }
    v35[v7] = v27;
    if (__OFSUB__(v28 + v10 - 1, v45))
      goto LABEL_44;
    --v10;
    ++v35;
    if (!(v28 - v45 + v10))
      goto LABEL_41;
  }
  __break(1u);
LABEL_44:
  __break(1u);
LABEL_45:
  __break(1u);
LABEL_46:
  __break(1u);
LABEL_47:
  __break(1u);
  return result;
}

uint64_t sub_217E146D4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t *v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  char v12;

  result = sub_217E09CBC(a1, a2, a3, a4, (uint64_t)&v9);
  if (v4)
    goto LABEL_7;
  if (v9 != 4 || v10 != 0)
  {
    v5 = sub_217E055EC((uint64_t)"AppleKeyStore/ASN1OctetString.swift", 35, 2, 26);
    sub_217E04C24();
    swift_allocError();
    *v8 = v5;
    swift_willThrow();
    sub_217E09BF8((uint64_t)&v9);
LABEL_7:
    swift_unknownObjectRelease();
    return v5;
  }
  if (v12 == 1)
  {
    v5 = v11;
    swift_unknownObjectRetain();
    sub_217E09BF8((uint64_t)&v9);
    swift_unknownObjectRelease();
    return v5;
  }
  __break(1u);
  return result;
}

char *sub_217E147CC(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v3;
  char *v7;
  _BYTE v8[96];

  sub_217E09CBC(a1, a1 + 32, 0, (2 * *(_QWORD *)(a1 + 16)) | 1, (uint64_t)v8);
  swift_bridgeObjectRelease();
  if (!v3)
  {
    v7 = (char *)MEMORY[0x24BEE4AF8];
    a3 = sub_217E05E84((uint64_t)v8, a2, a3, &v7);
    sub_217E09BF8((uint64_t)v8);
    swift_bridgeObjectRelease();
  }
  return a3;
}

uint64_t sub_217E14874(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  char v13;

  sub_217E09CBC(a1, a1 + 32, 0, (2 * *(_QWORD *)(a1 + 16)) | 1, (uint64_t)&v10);
  result = swift_bridgeObjectRelease();
  if (v3)
    return v4;
  if (v10 != a2 || v11 != a3)
  {
    v8 = sub_217E055EC((uint64_t)"AppleKeyStore/ASN1OctetString.swift", 35, 2, 26);
    sub_217E04C24();
    swift_allocError();
    *v9 = v8;
    swift_willThrow();
    sub_217E09BF8((uint64_t)&v10);
    return v4;
  }
  if (v13 == 1)
  {
    v4 = v12;
    swift_unknownObjectRetain();
    sub_217E09BF8((uint64_t)&v10);
    return v4;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E14984(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t result;
  uint64_t *v10;
  uint64_t v11;
  unsigned __int8 v12;
  uint64_t v13;
  char v14;

  result = sub_217E09CBC(a1, a2, a3, a4, (uint64_t)&v11);
  if (v6)
    goto LABEL_7;
  if (v11 != a5 || v12 != a6)
  {
    a6 = sub_217E055EC((uint64_t)"AppleKeyStore/ASN1OctetString.swift", 35, 2, 26);
    sub_217E04C24();
    swift_allocError();
    *v10 = a6;
    swift_willThrow();
    sub_217E09BF8((uint64_t)&v11);
LABEL_7:
    swift_unknownObjectRelease();
    return a6;
  }
  if (v14 == 1)
  {
    a6 = v13;
    swift_unknownObjectRetain();
    sub_217E09BF8((uint64_t)&v11);
    swift_unknownObjectRelease();
    return a6;
  }
  __break(1u);
  return result;
}

void sub_217E14A88(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  sub_217E14A9C(a1, a2, a3, a4);
}

void sub_217E14A9C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  int64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;

  v4 = a4 >> 1;
  v5 = (a4 >> 1) - a3;
  if (!__OFSUB__(a4 >> 1, a3))
  {
    if (v5 > 8)
    {
      v6 = sub_217E0556C(0xD00000000000001ALL, 0x8000000217E31210, (uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, 1191);
      sub_217E04C24();
      swift_allocError();
      *v7 = v6;
      swift_willThrow();
      swift_unknownObjectRelease();
      return;
    }
    if ((unint64_t)(v5 - 0x1000000000000000) >> 61 != 7)
      goto LABEL_24;
    v10 = sub_217E14DC4(0, 8 * v5, 8);
    v11 = *(_QWORD *)(v10 + 16);
    if (!v11)
    {
LABEL_21:
      swift_bridgeObjectRelease();
      swift_unknownObjectRelease();
      return;
    }
    v12 = 0;
    v13 = 0;
    if (a3 <= v4)
      v14 = v4;
    else
      v14 = a3;
    v15 = v14 - a3;
    while (v15 > v11 - 1)
    {
      v17 = *(_QWORD *)(v10 + 8 * v12 + 32);
      if (v17 - 65 < 0xFFFFFFFFFFFFFF7FLL)
      {
        v16 = 0;
      }
      else
      {
        v18 = *(unsigned __int8 *)(a2 + a3 + v12);
        if ((v17 & 0x8000000000000000) != 0)
        {
          v20 = v18 >> -(char)v17;
          if (v17 <= 0xFFFFFFFFFFFFFFC0)
            v16 = 0;
          else
            v16 = v20;
        }
        else
        {
          v19 = v18 << v17;
          if (v17 >= 0x40)
            v16 = 0;
          else
            v16 = v19;
        }
      }
      ++v12;
      v13 |= v16;
      if (v11 == v12)
        goto LABEL_21;
    }
    __break(1u);
  }
  __break(1u);
LABEL_24:
  __break(1u);
}

void sub_217E14C30(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  int64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  unint64_t v17;
  unsigned int v18;
  BOOL v19;
  unsigned int v20;

  v4 = a4 >> 1;
  v5 = (a4 >> 1) - a3;
  if (!__OFSUB__(a4 >> 1, a3))
  {
    if (v5 > 4)
    {
      v6 = sub_217E0556C(0xD00000000000001ALL, 0x8000000217E31210, (uint64_t)"AppleKeyStore/ASN1.swift", 24, 2, 1191);
      sub_217E04C24();
      swift_allocError();
      *v7 = v6;
      swift_willThrow();
      swift_unknownObjectRelease();
      return;
    }
    if ((unint64_t)(v5 - 0x1000000000000000) >> 61 != 7)
      goto LABEL_24;
    v10 = sub_217E14DC4(0, 8 * v5, 8);
    v11 = *(_QWORD *)(v10 + 16);
    if (!v11)
    {
LABEL_21:
      swift_bridgeObjectRelease();
      swift_unknownObjectRelease();
      return;
    }
    v12 = 0;
    v13 = 0;
    if (a3 <= v4)
      v14 = v4;
    else
      v14 = a3;
    v15 = v14 - a3;
    while (v15 > v11 - 1)
    {
      v17 = *(_QWORD *)(v10 + 8 * v12 + 32);
      if (v17 - 33 < 0xFFFFFFFFFFFFFFBFLL)
      {
        v16 = 0;
      }
      else
      {
        v18 = *(unsigned __int8 *)(a2 + a3 + v12);
        if ((v17 & 0x8000000000000000) != 0)
        {
          v20 = v18 >> -(char)v17;
          if (v17 <= 0xFFFFFFFFFFFFFFE0)
            v16 = 0;
          else
            v16 = v20;
        }
        else
        {
          v19 = v17 >= 0x20;
          v16 = v18 << v17;
          if (v19)
            v16 = 0;
        }
      }
      ++v12;
      v13 |= v16;
      if (v11 == v12)
        goto LABEL_21;
    }
    __break(1u);
  }
  __break(1u);
LABEL_24:
  __break(1u);
}

uint64_t sub_217E14DC4(uint64_t a1, int64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t i;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  result = sub_217E07D70(a1, a2, a3);
  v4 = result;
  v5 = *(_QWORD *)(result + 16);
  if (v5 < 2)
    return v4;
  v6 = 0;
  v7 = v5 >> 1;
  for (i = v5 + 3; ; --i)
  {
    if (v6 == i - 4)
      goto LABEL_5;
    v9 = *(_QWORD *)(v4 + 16);
    if (v6 >= v9)
      break;
    if (i - 4 >= v9)
      goto LABEL_12;
    v10 = *(_QWORD *)(v4 + 8 * v6 + 32);
    v11 = *(_QWORD *)(v4 + 8 * i);
    result = swift_isUniquelyReferenced_nonNull_native();
    if ((result & 1) == 0)
    {
      result = (uint64_t)sub_217E20090(v4);
      v4 = result;
    }
    *(_QWORD *)(v4 + 8 * v6 + 32) = v11;
    *(_QWORD *)(v4 + 8 * i) = v10;
LABEL_5:
    if (v7 == ++v6)
      return v4;
  }
  __break(1u);
LABEL_12:
  __break(1u);
  return result;
}

uint64_t sub_217E14E84@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
  {
    v4 = 0;
    v5 = (uint64_t *)(a1 + 32);
    do
    {
      v7 = *v5++;
      v6 = v7;
      if ((v7 & ~v4) == 0)
        v6 = 0;
      v4 |= v6;
      --v3;
    }
    while (v3);
  }
  else
  {
    v4 = 0;
  }
  result = swift_bridgeObjectRelease();
  *a2 = v4;
  return result;
}

uint64_t sub_217E14ED8@<X0>(uint64_t result@<X0>, char *a2@<X8>)
{
  char v2;

  switch(result)
  {
    case 0xE007C006:
      *a2 = 5;
      break;
    case 0xE007C007:
      *a2 = 6;
      break;
    case 0xE007C008:
      *a2 = 7;
      break;
    case 0xE007C009:
      *a2 = 8;
      break;
    case 0xE007C00A:
      *a2 = 9;
      break;
    case 0xE007C00B:
    case 0xE007C00C:
    case 0xE007C00F:
    case 0xE007C010:
    case 0xE007C011:
    case 0xE007C012:
    case 0xE007C01B:
    case 0xE007C01C:
    case 0xE007C01D:
    case 0xE007C020:
LABEL_28:
      v2 = 38;
LABEL_29:
      *a2 = v2;
      break;
    case 0xE007C00D:
      *a2 = 12;
      break;
    case 0xE007C00E:
      *a2 = 3;
      break;
    case 0xE007C013:
      *a2 = 18;
      break;
    case 0xE007C014:
      *a2 = 19;
      break;
    case 0xE007C015:
      *a2 = 20;
      break;
    case 0xE007C016:
      *a2 = 21;
      break;
    case 0xE007C017:
      *a2 = 22;
      break;
    case 0xE007C018:
      *a2 = 23;
      break;
    case 0xE007C019:
      *a2 = 24;
      break;
    case 0xE007C01A:
      *a2 = 31;
      break;
    case 0xE007C01E:
      *a2 = 29;
      break;
    case 0xE007C01F:
      *a2 = 30;
      break;
    case 0xE007C021:
      *a2 = 32;
      break;
    case 0xE007C022:
      *a2 = 33;
      break;
    case 0xE007C023:
      *a2 = 34;
      break;
    case 0xE007C024:
      *a2 = 35;
      break;
    case 0xE007C025:
      *a2 = 36;
      break;
    case 0xE007C026:
      *a2 = 37;
      break;
    default:
      v2 = 1;
      switch(result)
      {
        case 0xE00002BC:
          *a2 = 0;
          break;
        case 0xE00002BD:
          *a2 = 16;
          break;
        case 0xE00002C1:
          *a2 = 28;
          break;
        case 0xE00002CA:
          *a2 = 25;
          break;
        case 0xE00002CE:
          *a2 = 4;
          break;
        case 0xE00002D5:
          *a2 = 26;
          break;
        case 0xE00002D6:
          *a2 = 17;
          break;
        case 0xE00002D8:
          *a2 = 13;
          break;
        case 0xE00002DB:
          *a2 = 27;
          break;
        case 0xE00002E2:
          goto LABEL_29;
        case 0xE00002E6:
          *a2 = 11;
          break;
        case 0xE00002F0:
          *a2 = 2;
          break;
        default:
          goto LABEL_28;
      }
      break;
  }
  return result;
}

uint64_t sub_217E150D4(uint64_t result, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v3;
  unint64_t v4;
  int64_t v5;
  int64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  uint64_t v19;
  unint64_t v20;

  v3 = result;
  if (*(_QWORD *)result != a2 || *(unsigned __int8 *)(result + 8) != a3)
  {
    v4 = sub_217E055EC((uint64_t)"AppleKeyStore/ASN1Integer.swift", 31, 2, 46);
    sub_217E04C24();
    swift_allocError();
    *v12 = v4;
    swift_willThrow();
    sub_217E09BF8(v3);
    return v4;
  }
  if (*(_BYTE *)(result + 56) == 1)
  {
    v5 = *(_QWORD *)(result + 32);
    v4 = *(_QWORD *)(result + 40);
    v6 = v4 >> 1;
    if (__OFSUB__(v4 >> 1, v5))
    {
      __break(1u);
    }
    else
    {
      v8 = *(_QWORD *)(result + 16);
      v7 = *(_QWORD *)(result + 24);
      v9 = *(_QWORD *)(result + 48);
      if ((uint64_t)((v4 >> 1) - v5) < 1)
      {
        v13 = 0x8000000217E31190;
        v14 = 0xD00000000000001FLL;
        v15 = 55;
LABEL_13:
        v16 = sub_217E05658(v14, v13, (uint64_t)"AppleKeyStore/ASN1Integer.swift", 31, 2, v15);
        sub_217E04C24();
        swift_allocError();
        *v17 = v16;
        swift_unknownObjectRetain();
        swift_willThrow();
        sub_217E09BF8(v3);
        j__swift_unknownObjectRelease(v8, v7, v5, v4, v9, 1);
        return v4;
      }
      if (v5 == v6)
      {
LABEL_20:
        v11 = *(_QWORD *)(result + 32);
        goto LABEL_21;
      }
      if (v5 < v6)
      {
        v10 = *(unsigned __int8 *)(v7 + v5);
        v11 = v5 + 1;
        if (v5 + 1 == v6)
        {
          if (!*(_BYTE *)(v7 + v5))
          {
            v11 = v4 >> 1;
LABEL_21:
            v19 = swift_unknownObjectRetain();
            sub_217E14A9C(v19, v7, v11, v4);
            v4 = v20;
            sub_217E09BF8(v3);
            return v4;
          }
LABEL_19:
          if ((v10 & 0x80) == 0)
            goto LABEL_20;
          goto LABEL_23;
        }
        if (v5 + 1 < v6)
        {
          v18 = *(char *)(v7 + v11);
          if (*(_BYTE *)(v7 + v5))
          {
            if (v10 != 255)
              goto LABEL_19;
            if ((v18 & 0x80000000) == 0)
            {
LABEL_23:
              v14 = 0xD000000000000021;
              v13 = 0x8000000217E311B0;
              v15 = 77;
              goto LABEL_13;
            }
          }
          else if (v18 < 0)
          {
            goto LABEL_21;
          }
          v14 = 0xD00000000000002ELL;
          v13 = 0x8000000217E311E0;
          v15 = 67;
          goto LABEL_13;
        }
        goto LABEL_28;
      }
    }
    __break(1u);
LABEL_28:
    __break(1u);
  }
  __break(1u);
  return result;
}

uint64_t sub_217E1532C(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  return sub_217E15340(a1, a2, a3);
}

uint64_t sub_217E15340(uint64_t result, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;

  v4 = result;
  if (*(_QWORD *)result != a2 || *(unsigned __int8 *)(result + 8) != a3)
  {
    v13 = sub_217E055EC((uint64_t)"AppleKeyStore/ASN1Integer.swift", 31, 2, 46);
    sub_217E04C24();
    swift_allocError();
    *v14 = v13;
    swift_willThrow();
    sub_217E09BF8(v4);
    return v3;
  }
  if (*(_BYTE *)(result + 56) == 1)
  {
    v6 = *(_QWORD *)(result + 32);
    v5 = *(_QWORD *)(result + 40);
    v7 = v5 >> 1;
    if (__OFSUB__(v5 >> 1, v6))
    {
      __break(1u);
    }
    else
    {
      v9 = *(_QWORD *)(result + 16);
      v8 = *(_QWORD *)(result + 24);
      v10 = *(_QWORD *)(result + 48);
      if ((uint64_t)((v5 >> 1) - v6) < 1)
      {
        v15 = 0x8000000217E31190;
        v16 = 0xD00000000000001FLL;
        v17 = 55;
LABEL_16:
        v3 = sub_217E05658(v16, v15, (uint64_t)"AppleKeyStore/ASN1Integer.swift", 31, 2, v17);
        sub_217E04C24();
        swift_allocError();
        *v18 = v3;
        swift_unknownObjectRetain();
        swift_willThrow();
        sub_217E09BF8(v4);
        j__swift_unknownObjectRelease(v9, v8, v6, v5, v10, 1);
        return v3;
      }
      if (v6 == v7)
        goto LABEL_13;
      if (v6 < v7)
      {
        if (v6 + 1 == v7)
          goto LABEL_13;
        if (v6 + 1 < v7)
        {
          v11 = *(char *)(v8 + v6 + 1);
          if (*(_BYTE *)(v8 + v6))
          {
            if (*(unsigned __int8 *)(v8 + v6) != 255 || (v11 & 0x80000000) == 0)
              goto LABEL_13;
            goto LABEL_19;
          }
          if ((v11 & 0x80000000) == 0)
          {
LABEL_19:
            v16 = 0xD00000000000002ELL;
            v15 = 0x8000000217E311E0;
            v17 = 67;
            goto LABEL_16;
          }
LABEL_13:
          j__swift_unknownObjectRetain(*(_QWORD *)(result + 16), *(_QWORD *)(result + 24), *(_QWORD *)(result + 32), *(_QWORD *)(result + 40), *(_QWORD *)(result + 48), 1);
          sub_217E209DC(v9, v8, v6, v5);
          v3 = v12;
          j__swift_unknownObjectRelease(v9, v8, v6, v5, v10, 1);
          sub_217E09BF8(v4);
          return v3;
        }
        goto LABEL_22;
      }
    }
    __break(1u);
LABEL_22:
    __break(1u);
  }
  __break(1u);
  return result;
}

uint64_t sub_217E15588(uint64_t result, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v3;
  unint64_t v4;
  int64_t v5;
  int64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  uint64_t v19;
  unint64_t v20;

  v3 = result;
  if (*(_QWORD *)result != a2 || *(unsigned __int8 *)(result + 8) != a3)
  {
    v4 = sub_217E055EC((uint64_t)"AppleKeyStore/ASN1Integer.swift", 31, 2, 46);
    sub_217E04C24();
    swift_allocError();
    *v12 = v4;
    swift_willThrow();
    sub_217E09BF8(v3);
    return v4;
  }
  if (*(_BYTE *)(result + 56) == 1)
  {
    v5 = *(_QWORD *)(result + 32);
    v4 = *(_QWORD *)(result + 40);
    v6 = v4 >> 1;
    if (__OFSUB__(v4 >> 1, v5))
    {
      __break(1u);
    }
    else
    {
      v8 = *(_QWORD *)(result + 16);
      v7 = *(_QWORD *)(result + 24);
      v9 = *(_QWORD *)(result + 48);
      if ((uint64_t)((v4 >> 1) - v5) < 1)
      {
        v13 = 0x8000000217E31190;
        v14 = 0xD00000000000001FLL;
        v15 = 55;
LABEL_13:
        v16 = sub_217E05658(v14, v13, (uint64_t)"AppleKeyStore/ASN1Integer.swift", 31, 2, v15);
        sub_217E04C24();
        swift_allocError();
        *v17 = v16;
        swift_unknownObjectRetain();
        swift_willThrow();
        sub_217E09BF8(v3);
        j__swift_unknownObjectRelease(v8, v7, v5, v4, v9, 1);
        return v4;
      }
      if (v5 == v6)
      {
LABEL_20:
        v11 = *(_QWORD *)(result + 32);
        goto LABEL_21;
      }
      if (v5 < v6)
      {
        v10 = *(unsigned __int8 *)(v7 + v5);
        v11 = v5 + 1;
        if (v5 + 1 == v6)
        {
          if (!*(_BYTE *)(v7 + v5))
          {
            v11 = v4 >> 1;
LABEL_21:
            v19 = swift_unknownObjectRetain();
            sub_217E14C30(v19, v7, v11, v4);
            v4 = v20;
            sub_217E09BF8(v3);
            return v4;
          }
LABEL_19:
          if ((v10 & 0x80) == 0)
            goto LABEL_20;
          goto LABEL_23;
        }
        if (v5 + 1 < v6)
        {
          v18 = *(char *)(v7 + v11);
          if (*(_BYTE *)(v7 + v5))
          {
            if (v10 != 255)
              goto LABEL_19;
            if ((v18 & 0x80000000) == 0)
            {
LABEL_23:
              v14 = 0xD000000000000021;
              v13 = 0x8000000217E311B0;
              v15 = 77;
              goto LABEL_13;
            }
          }
          else if (v18 < 0)
          {
            goto LABEL_21;
          }
          v14 = 0xD00000000000002ELL;
          v13 = 0x8000000217E311E0;
          v15 = 67;
          goto LABEL_13;
        }
        goto LABEL_28;
      }
    }
    __break(1u);
LABEL_28:
    __break(1u);
  }
  __break(1u);
  return result;
}

uint64_t sub_217E157E0(uint64_t *a1, unint64_t a2, uint64_t (*a3)(_BYTE *, uint64_t))
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;

  if (a2)
  {
    v5 = sub_217E158A0(a2);
    return sub_217E143D8(v5, v6, v7, a3);
  }
  else
  {
    v9 = *a1;
    result = swift_isUniquelyReferenced_nonNull_native();
    if ((result & 1) == 0)
    {
      result = (uint64_t)sub_217E0E2EC(0, *(_QWORD *)(v9 + 16) + 1, 1, (char *)v9);
      v9 = result;
    }
    v11 = *(_QWORD *)(v9 + 16);
    v10 = *(_QWORD *)(v9 + 24);
    if (v11 >= v10 >> 1)
    {
      result = (uint64_t)sub_217E0E2EC((char *)(v10 > 1), v11 + 1, 1, (char *)v9);
      v9 = result;
    }
    *(_QWORD *)(v9 + 16) = v11 + 1;
    *(_BYTE *)(v9 + v11 + 32) = 0;
    *a1 = v9;
  }
  return result;
}

unint64_t sub_217E158A0(unint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t result;
  uint64_t v6;
  uint64_t v7;
  char v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  BOOL v12;
  unint64_t v13;
  char v14;
  unint64_t v15;

  if (!a1)
    return 0;
  v2 = 71 - __clz(a1);
  v3 = v2 >> 3;
  result = sub_217E2037C(v2 >> 3, v2 >> 3, 0, a1, v2);
  if (result != 255 && result != 0)
    return v3;
  if (v3 >= 1)
    v6 = 1;
  else
    v6 = v3;
  v7 = 8 * v3;
  v8 = 16 - 8 * v3;
  v9 = v3;
  while (1)
  {
    if (v9 < 2)
      return v6;
    v15 = v9;
    v10 = v7 - 8;
    if (v7 - 8 < 0)
      v11 = a1 << ((v8 - 8) & 0x38);
    else
      v11 = a1 >> (v10 & 0x38);
    if (result != v11)
      return v15;
    v9 = v15 - 1;
    if (v15 - 1 > v3)
      break;
    v12 = v7 < 16;
    v13 = a1 >> ((v7 + 48) & 0x38);
    if (v12)
      v13 = a1 << (v8 & 0x38);
    v14 = result ^ v13;
    v8 += 8;
    v7 = v10;
    if (v14 < 0)
      return v15;
  }
  __break(1u);
  return result;
}

BOOL static AKSRefKeyParam.== infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

uint64_t AKSRefKeyParam.hash(into:)()
{
  return sub_217E2D1F4();
}

uint64_t AKSRefKeyParam.hashValue.getter()
{
  sub_217E2D1E8();
  sub_217E2D1F4();
  return sub_217E2D218();
}

AppleKeyStore::AKSSystemKeyType_optional __swiftcall AKSSystemKeyType.init(rawValue:)(Swift::Int64 rawValue)
{
  char *v1;
  char v2;

  v2 = rawValue - 1;
  if ((unint64_t)(rawValue - 1) >= 0xE)
    v2 = 14;
  *v1 = v2;
  return (AppleKeyStore::AKSSystemKeyType_optional)rawValue;
}

AppleKeyStore::AKSSystemKeyType_optional sub_217E15A44(Swift::Int64 *a1)
{
  return AKSSystemKeyType.init(rawValue:)(*a1);
}

AppleKeyStore::AKSSystemKeyGeneration_optional __swiftcall AKSSystemKeyGeneration.init(rawValue:)(Swift::Int64 rawValue)
{
  _BYTE *v1;
  unsigned int v2;

  v2 = 0x2010003u >> (8 * rawValue);
  if ((unint64_t)rawValue >= 4)
    LOBYTE(v2) = 3;
  *v1 = v2;
  return (AppleKeyStore::AKSSystemKeyGeneration_optional)rawValue;
}

uint64_t AKSSystemKeyGeneration.rawValue.getter()
{
  unsigned __int8 *v0;

  return *v0 + 1;
}

uint64_t sub_217E15A7C()
{
  return sub_217E2D20C();
}

AppleKeyStore::AKSSystemKeyGeneration_optional sub_217E15AA8(Swift::Int64 *a1)
{
  return AKSSystemKeyGeneration.init(rawValue:)(*a1);
}

void sub_217E15AB0(_QWORD *a1@<X8>)
{
  unsigned __int8 *v1;

  *a1 = *v1 + 1;
}

uint64_t sub_217E15AC0()
{
  sub_217E2D1E8();
  sub_217E2D20C();
  return sub_217E2D218();
}

uint64_t sub_217E15B04()
{
  sub_217E2D1E8();
  sub_217E2D20C();
  return sub_217E2D218();
}

uint64_t AKSHandle.rawValue.getter()
{
  unsigned int *v0;

  return *v0;
}

uint64_t AKSHandle.init(rawValue:)@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = result;
  return result;
}

void static AKSHandle.systemKeychain.getter(_DWORD *a1@<X8>)
{
  *a1 = -6;
}

void static AKSHandle.uuidOnly.getter(_DWORD *a1@<X8>)
{
  *a1 = -5;
}

void static AKSHandle.macosRoot.getter(_DWORD *a1@<X8>)
{
  *a1 = -4;
}

void static AKSHandle.session.getter(_DWORD *a1@<X8>)
{
  *a1 = -3;
}

void static AKSHandle.backup.getter(_DWORD *a1@<X8>)
{
  *a1 = -2;
}

void static AKSHandle.bad.getter(_DWORD *a1@<X8>)
{
  *a1 = -1;
}

void static AKSHandle.device.getter(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

_DWORD *sub_217E15BA4@<X0>(_DWORD *result@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = *result;
  *(_BYTE *)(a2 + 4) = 0;
  return result;
}

void sub_217E15BB4(_DWORD *a1@<X8>)
{
  _DWORD *v1;

  *a1 = *v1;
}

AppleKeyStore::AKSKeyClass_optional __swiftcall AKSKeyClass.init(rawValue:)(Swift::Int64 rawValue)
{
  char *v1;
  char v2;
  char v3;

  v2 = 0;
  v3 = 2;
  switch(rawValue)
  {
    case 0:
      goto LABEL_3;
    case 1:
      v2 = 1;
LABEL_3:
      v3 = v2;
      goto LABEL_4;
    case 2:
LABEL_4:
      *v1 = v3;
      break;
    case 3:
      *v1 = 3;
      break;
    case 4:
      *v1 = 4;
      break;
    case 5:
      *v1 = 5;
      break;
    case 6:
      *v1 = 6;
      break;
    case 7:
      *v1 = 7;
      break;
    case 8:
      *v1 = 8;
      break;
    case 9:
      *v1 = 9;
      break;
    case 10:
      *v1 = 10;
      break;
    case 11:
      *v1 = 11;
      break;
    case 12:
      *v1 = 12;
      break;
    case 13:
      *v1 = 13;
      break;
    case 14:
      *v1 = 14;
      break;
    case 15:
      *v1 = 15;
      break;
    case 16:
      *v1 = 16;
      break;
    case 17:
      *v1 = 17;
      break;
    case 18:
      *v1 = 18;
      break;
    case 19:
      *v1 = 19;
      break;
    default:
      *v1 = 20;
      break;
  }
  return (AppleKeyStore::AKSKeyClass_optional)rawValue;
}

uint64_t AKSKeyClass.rawValue.getter()
{
  unsigned __int8 *v0;

  return *v0;
}

uint64_t sub_217E15CD8()
{
  sub_217E2D1E8();
  sub_217E2D20C();
  return sub_217E2D218();
}

uint64_t sub_217E15D1C()
{
  return sub_217E2D20C();
}

uint64_t sub_217E15D44()
{
  sub_217E2D1E8();
  sub_217E2D20C();
  return sub_217E2D218();
}

AppleKeyStore::AKSKeyClass_optional sub_217E15D84(Swift::Int64 *a1)
{
  return AKSKeyClass.init(rawValue:)(*a1);
}

void sub_217E15D8C(_QWORD *a1@<X8>)
{
  unsigned __int8 *v1;

  *a1 = *v1;
}

AppleKeyStore::AKSRefKeyType_optional __swiftcall AKSRefKeyType.init(rawValue:)(Swift::Int64 rawValue)
{
  char *v1;
  char v2;
  char v3;

  v2 = 1;
  switch(rawValue)
  {
    case 0:
      v2 = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      *v1 = v2;
      break;
    case 2:
      *v1 = 2;
      break;
    case 3:
      *v1 = 3;
      break;
    case 4:
      *v1 = 4;
      break;
    case 5:
      *v1 = 5;
      break;
    case 6:
      *v1 = 6;
      break;
    case 7:
      *v1 = 7;
      break;
    case 8:
      *v1 = 8;
      break;
    case 9:
      *v1 = 9;
      break;
    case 10:
      *v1 = 10;
      break;
    default:
      if (rawValue == 0xFFFFFFFFLL)
        v3 = 11;
      else
        v3 = 12;
      *v1 = v3;
      break;
  }
  return (AppleKeyStore::AKSRefKeyType_optional)rawValue;
}

uint64_t AKSRefKeyType.rawValue.getter()
{
  char *v0;

  return qword_217E35258[*v0];
}

BOOL sub_217E15E64(char *a1, char *a2)
{
  return qword_217E35258[*a1] == qword_217E35258[*a2];
}

uint64_t sub_217E15E88()
{
  sub_217E2D1E8();
  sub_217E2D20C();
  return sub_217E2D218();
}

uint64_t sub_217E15ED4()
{
  return sub_217E2D20C();
}

uint64_t sub_217E15F08()
{
  sub_217E2D1E8();
  sub_217E2D20C();
  return sub_217E2D218();
}

AppleKeyStore::AKSRefKeyType_optional sub_217E15F50(Swift::Int64 *a1)
{
  return AKSRefKeyType.init(rawValue:)(*a1);
}

void sub_217E15F58(_QWORD *a1@<X8>)
{
  char *v1;

  *a1 = qword_217E35258[*v1];
}

uint64_t AKSRefKeyOptions.rawValue.getter()
{
  uint64_t v0;

  return *(_QWORD *)v0;
}

uint64_t AKSRefKeyOptions.init(rawValue:)@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  *a2 = result;
  return result;
}

void static AKSRefKeyOptions.none.getter(_QWORD *a1@<X8>)
{
  *a1 = 0;
}

void static AKSRefKeyOptions.osBound.getter(_QWORD *a1@<X8>)
{
  *a1 = 1;
}

void static AKSRefKeyOptions.intermediate.getter(_QWORD *a1@<X8>)
{
  *a1 = 2;
}

void static AKSRefKeyOptions.satori.getter(_QWORD *a1@<X8>)
{
  *a1 = 4;
}

void static AKSRefKeyOptions.userclient.getter(_QWORD *a1@<X8>)
{
  *a1 = 8;
}

void static AKSRefKeyOptions.ecCompactable.getter(_QWORD *a1@<X8>)
{
  *a1 = 16;
}

void static AKSRefKeyOptions.nonce.getter(_QWORD *a1@<X8>)
{
  *a1 = 32;
}

void static AKSRefKeyOptions.anonymous.getter(_QWORD *a1@<X8>)
{
  *a1 = 64;
}

void static AKSRefKeyOptions.trng.getter(_QWORD *a1@<X8>)
{
  *a1 = 128;
}

void static AKSRefKeyOptions.sealedHashesBound.getter(_QWORD *a1@<X8>)
{
  *a1 = 256;
}

void static AKSRefKeyOptions.completeSeed.getter(_QWORD *a1@<X8>)
{
  *a1 = 0x200000000000000;
}

void static AKSRefKeyOptions.sealData.getter(_QWORD *a1@<X8>)
{
  *a1 = 0x400000000000000;
}

void static AKSRefKeyOptions.forceEffective.getter(_QWORD *a1@<X8>)
{
  *a1 = 0x800000000000000;
}

void static AKSRefKeyOptions.pkaSkipPubGen.getter(_QWORD *a1@<X8>)
{
  *a1 = 0x1000000000000000;
}

void static AKSRefKeyOptions.pkaUpdatedSeed.getter(_QWORD *a1@<X8>)
{
  *a1 = 0x2000000000000000;
}

void static AKSRefKeyOptions.systemKey.getter(_QWORD *a1@<X8>)
{
  *a1 = 0x4000000000000000;
}

void static AKSRefKeyOptions.uidProtection.getter(_QWORD *a1@<X8>)
{
  *a1 = 0x8000000000000000;
}

uint64_t sub_217E16048@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  return sub_217E14E84(a1, a2);
}

uint64_t AKSRefKeyParams.__allocating_init()()
{
  uint64_t result;

  result = swift_allocObject();
  *(_QWORD *)(result + 16) = 0;
  return result;
}

uint64_t AKSRefKeyParams.init()()
{
  uint64_t v0;
  uint64_t result;

  result = v0;
  *(_QWORD *)(v0 + 16) = 0;
  return result;
}

void sub_217E1608C(char *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[8];
  char v14;

  v14 = *a1;
  sub_217E20B60((uint64_t)&v14);
  if (!v1)
  {
    v6 = v2;
    v7 = v3;
    v8 = v4;
    v9 = v5;
    swift_unknownObjectRetain();
    v13[0] = v6;
    v13[1] = v7;
    v13[2] = v8;
    v13[3] = v9;
    v13[4] = sub_217E1400C();
    v13[5] = v10;
    v13[6] = v11;
    v13[7] = v12;
    swift_unknownObjectRetain();
    sub_217E043A0((uint64_t)v13);
    swift_unknownObjectRelease();
    swift_unknownObjectRelease_n();
  }
}

BOOL sub_217E16198(char *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  char v15;
  _BYTE v16[32];
  __int128 v17;
  __int128 v18;
  _BYTE v19[96];
  _OWORD v20[2];

  v15 = *a1;
  sub_217E20B60((uint64_t)&v15);
  if (!v2)
  {
    v7 = v3;
    v8 = v4;
    v9 = v5;
    v10 = *(_QWORD *)(v1 + 16);
    swift_bridgeObjectRetain();
    swift_unknownObjectRetain();
    sub_217E04998(v7, v8, v9, v10, (uint64_t)v16);
    swift_bridgeObjectRelease();
    v20[0] = v17;
    v20[1] = v18;
    v11 = v17;
    v12 = v18;
    sub_217E09B38((uint64_t)v20);
    sub_217E09CBC(v11, *((uint64_t *)&v11 + 1), v12, *((unint64_t *)&v12 + 1), (uint64_t)v19);
    v13 = sub_217E15340((uint64_t)v19, 2, 0);
    sub_217E09BD0((uint64_t)v20);
    swift_unknownObjectRelease();
    sub_217E04E0C((uint64_t)v16);
    return v13 != 0;
  }
  return v6;
}

void sub_217E16338(char *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[8];
  char v14;

  v14 = *a1;
  sub_217E20B60((uint64_t)&v14);
  if (!v1)
  {
    v6 = v2;
    v7 = v3;
    v8 = v4;
    v9 = v5;
    swift_unknownObjectRetain();
    v13[0] = v6;
    v13[1] = v7;
    v13[2] = v8;
    v13[3] = v9;
    v13[4] = sub_217E1400C();
    v13[5] = v10;
    v13[6] = v11;
    v13[7] = v12;
    swift_unknownObjectRetain();
    sub_217E043A0((uint64_t)v13);
    swift_unknownObjectRelease();
    swift_unknownObjectRelease_n();
  }
}

uint64_t sub_217E16440(char *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  char v15;
  _BYTE v16[32];
  __int128 v17;
  __int128 v18;
  _BYTE v19[96];
  _OWORD v20[2];

  v15 = *a1;
  sub_217E20B60((uint64_t)&v15);
  if (!v2)
  {
    v7 = v4;
    v8 = v5;
    v9 = v6;
    v10 = *(_QWORD *)(v1 + 16);
    swift_bridgeObjectRetain();
    swift_unknownObjectRetain();
    sub_217E04998(v7, v8, v9, v10, (uint64_t)v16);
    swift_bridgeObjectRelease();
    v20[0] = v17;
    v20[1] = v18;
    v13 = *((_QWORD *)&v17 + 1);
    v12 = v17;
    v14 = v18;
    sub_217E09B38((uint64_t)v20);
    sub_217E09CBC(v12, v13, v14, *((unint64_t *)&v14 + 1), (uint64_t)v19);
    v3 = sub_217E15340((uint64_t)v19, 2, 0);
    sub_217E09BD0((uint64_t)v20);
    swift_unknownObjectRelease();
    sub_217E04E0C((uint64_t)v16);
  }
  return v3;
}

void sub_217E165D4(_BYTE *a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  char v29;
  uint64_t v30;
  _BYTE *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned __int8 v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  uint64_t v50;
  unint64_t v51;
  char v52;
  uint64_t v53;
  _BYTE v54[48];
  _QWORD v55[8];
  _BYTE v56[56];
  char *v57;

  v4 = *a1;
  LOBYTE(v57) = *a1;
  sub_217E20B60((uint64_t)&v57);
  if (!v2)
  {
    v9 = v5;
    v10 = v7;
    v11 = v8;
    v37 = v6;
    if (v4)
    {
      if (v4 != 1)
      {
        swift_unknownObjectRetain();
        swift_bridgeObjectRetain();
        v15 = sub_217E204F8();
        v17 = v16;
        v19 = v18;
        v21 = v20;
        swift_bridgeObjectRelease();
        v23 = v17;
        v24 = v19;
        v41 = 0;
        v35 = 0;
        v36 = 0;
        v33 = 0;
        v34 = 0;
        v32 = 0;
        v25 = 0;
        v26 = 0;
LABEL_11:
        v55[0] = v9;
        v55[1] = v37;
        v55[2] = v10;
        v55[3] = v11;
        v55[4] = v15;
        v55[5] = v23;
        v55[6] = v24;
        v55[7] = v21;
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        sub_217E043A0((uint64_t)v55);
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease_n();
        sub_217E04C6C(v26, 0, v25, v32, v33, v34, v35, v36, v41);
        return;
      }
      v12 = 17;
    }
    else
    {
      v12 = 16;
    }
    v13 = (2 * *(_QWORD *)(a2 + 16)) | 1;
    swift_unknownObjectRetain();
    v14 = swift_bridgeObjectRetain();
    sub_217E09CBC(v14, a2 + 32, 0, v13, (uint64_t)&v42);
    v39 = v42;
    v40 = v43;
    v38 = v44;
    v32 = v45;
    v33 = v46;
    v34 = v47;
    v35 = v48;
    v36 = v49;
    v41 = v50;
    swift_bridgeObjectRelease();
    v22 = swift_bridgeObjectRetain();
    sub_217E09CBC(v22, a2 + 32, 0, v13, (uint64_t)&v51);
    v57 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
    v27 = v51;
    v28 = v52;
    sub_217E04CC0((uint64_t)&v53, (uint64_t)v54);
    sub_217E04CC0((uint64_t)v54, (uint64_t)v56);
    v29 = v56[40];
    sub_217E21234((uint64_t)&v51);
    sub_217E0833C(v27, v28, (v29 & 1) == 0, (uint64_t)&v57, (uint64_t)&v51);
    sub_217E09BF8((uint64_t)&v51);
    v15 = v57;
    v30 = *((_QWORD *)v57 + 2);
    sub_217E09BF8((uint64_t)&v51);
    swift_bridgeObjectRelease();
    if (v39 == v12 && !(_DWORD)v40)
    {
      v24 = 0;
      v23 = v15 + 32;
      v21 = (2 * v30) | 1;
      v25 = v38;
      v26 = v12;
      goto LABEL_11;
    }
    sub_217E04E40();
    swift_allocError();
    *v31 = 10;
    swift_willThrow();
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
    sub_217E04C6C(v39, v40, v38, v32, v33, v34, v35, v36, v41);
  }
}

uint64_t sub_217E16A44(_BYTE *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  _BYTE v26[32];
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char v35;
  _OWORD v36[2];

  LOBYTE(v25) = *a1;
  sub_217E20B60((uint64_t)&v25);
  if (v2)
    return v3;
  v7 = v4;
  v8 = v5;
  v9 = v6;
  v10 = *(_QWORD *)(v1 + 16);
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  sub_217E04998(v7, v8, v9, v10, (uint64_t)v26);
  swift_bridgeObjectRelease();
  v25 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  v36[0] = v27;
  v36[1] = v28;
  v13 = *((_QWORD *)&v27 + 1);
  v12 = v27;
  v14 = v28;
  sub_217E09B38((uint64_t)v36);
  sub_217E20404(v12, v13, v14, *((unint64_t *)&v14 + 1));
  sub_217E09BD0((uint64_t)v36);
  v15 = (uint64_t)v25;
  v16 = (uint64_t)(v25 + 32);
  v17 = (2 * *((_QWORD *)v25 + 2)) | 1;
  v18 = swift_bridgeObjectRetain();
  sub_217E09CBC(v18, v16, 0, v17, (uint64_t)&v29);
  swift_bridgeObjectRelease();
  if (v29 != 4 || v30)
  {
    v19 = 0;
    v20 = (2 * *(_QWORD *)(v15 + 16)) | 1;
LABEL_11:
    sub_217E2D194();
    swift_unknownObjectRetain_n();
    v22 = swift_dynamicCastClass();
    if (!v22)
    {
      swift_unknownObjectRelease();
      v22 = MEMORY[0x24BEE4AF8];
    }
    v23 = *(_QWORD *)(v22 + 16);
    swift_release();
    if (__OFSUB__(v20 >> 1, v19))
    {
      __break(1u);
    }
    else if (v23 == (v20 >> 1) - v19)
    {
      v24 = swift_dynamicCastClass();
      if (v24)
      {
        v3 = v24;
      }
      else
      {
        swift_unknownObjectRelease();
        v3 = MEMORY[0x24BEE4AF8];
      }
      goto LABEL_18;
    }
    swift_unknownObjectRelease();
LABEL_10:
    sub_217E200CC(v15, v16, v19, v20);
    v3 = v21;
LABEL_18:
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    sub_217E09BF8((uint64_t)&v29);
    sub_217E04E0C((uint64_t)v26);
    return v3;
  }
  result = swift_bridgeObjectRelease();
  if (v35 == 1)
  {
    v19 = v33;
    v20 = v34;
    v15 = v31;
    v16 = v32;
    swift_unknownObjectRetain();
    if ((v20 & 1) == 0)
      goto LABEL_10;
    goto LABEL_11;
  }
  __break(1u);
  return result;
}

char *sub_217E16D1C()
{
  uint64_t v0;
  uint64_t v1;
  char *v2;
  char *v3;
  _BYTE *v4;
  char *v6;

  v6 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  v2 = *(char **)(v0 + 16);
  swift_bridgeObjectRetain();
  sub_217E08C90(0x11uLL, 0, 1, &v6, v2);
  swift_bridgeObjectRelease();
  v3 = v6;
  if (v1)
  {
    swift_bridgeObjectRelease();
    sub_217E04E40();
    swift_allocError();
    *v4 = 22;
    swift_willThrow();
    MEMORY[0x219A18338](v1);
  }
  return v3;
}

uint64_t AKSRefKeyParams.deinit()
{
  uint64_t v0;

  swift_bridgeObjectRelease();
  return v0;
}

uint64_t AKSRefKeyParams.__deallocating_deinit()
{
  swift_bridgeObjectRelease();
  return swift_deallocClassInstance();
}

uint64_t sub_217E16E24(int *a1, char *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t inited;
  uint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = *a1;
  v5 = MEMORY[0x24BEE4AF8];
  v14 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  swift_bridgeObjectRetain();
  sub_217E08C90(0x11uLL, 0, 1, &v14, a2);
  swift_bridgeObjectRelease();
  if (v2)
  {
    swift_bridgeObjectRelease();
    sub_217E04E40();
    swift_allocError();
    *v6 = 25;
    swift_willThrow();
    return MEMORY[0x219A18338](v2);
  }
  else
  {
    v8 = sub_217E2D008();
    *(_QWORD *)(v8 + 16) = 0x8000;
    bzero((void *)(v8 + 32), 0x8000uLL);
    v13 = v8;
    __swift_instantiateConcreteTypeFromMangledName(&qword_254F278A8);
    inited = swift_initStackObject();
    *(_OWORD *)(inited + 16) = xmmword_217E33B50;
    *(_QWORD *)(inited + 32) = v4;
    v12 = 0;
    v10 = sub_217E2272C(0x2Bu, inited, (uint64_t)v14, &v12, &v13);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    result = v13;
    if ((_DWORD)v10)
    {
      swift_bridgeObjectRelease();
      sub_217E04E40();
      swift_allocError();
      sub_217E14ED8(v10, v11);
      return swift_willThrow();
    }
    else if (!v13)
    {
      return v5;
    }
  }
  return result;
}

uint64_t sub_217E1700C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t result;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD v31[5];
  uint64_t v32;
  char v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char v39;
  uint64_t v40[13];
  uint64_t v41;

  v5 = a1 + 32;
  v6 = (2 * *(_QWORD *)(a1 + 16)) | 1;
  v7 = swift_bridgeObjectRetain();
  sub_217E09CBC(v7, v5, 0, v6, (uint64_t)&v32);
  v8 = v1;
  swift_bridgeObjectRelease();
  if (v1)
  {
    sub_217E04E40();
    swift_allocError();
    *v9 = 25;
    swift_willThrow();
    MEMORY[0x219A18338](v1);
    return v8;
  }
  if (v32 == 16 && v33 == 0)
  {
    if ((v39 & 1) != 0)
    {
      __break(1u);
      swift_unknownObjectRelease();
      result = swift_unexpectedError();
      __break(1u);
      return result;
    }
    v3 = v34;
    v4 = v35;
    v2 = v36;
    v11 = v37;
    v12 = v38;
    v31[0] = v34;
    v31[1] = v35;
    v31[2] = v36;
    v31[3] = v37;
    v31[4] = v38;
    j__swift_unknownObjectRetain(v34, v35, v36, v37, v38, 0);
    swift_unknownObjectRetain();
    v30 = sub_217E14240((uint64_t)v31, 4, 0);
    v41 = v13;
    v6 = v14;
    v27 = v15;
    v28 = sub_217E14240((uint64_t)v31, 4, 0);
    v29 = v16;
    v26 = v17;
    v19 = v18;
    sub_217E05C84((uint64_t)v40);
    v20 = v40[8];
    j__swift_unknownObjectRelease(v3, v4, v2, v11, v12, 0);
    sub_217E09B64(v40);
    if (!v20)
    {
      swift_unknownObjectRelease();
      v4 = v6;
      if ((v6 & 1) == 0)
      {
        v6 = v30;
        swift_unknownObjectRetain();
        v3 = v19;
        v2 = v41;
        goto LABEL_12;
      }
      sub_217E2D194();
      v6 = v30;
      swift_unknownObjectRetain_n();
      v22 = swift_dynamicCastClass();
      v3 = v19;
      v2 = v41;
      if (!v22)
      {
        swift_unknownObjectRelease();
        v22 = MEMORY[0x24BEE4AF8];
      }
      v23 = *(_QWORD *)(v22 + 16);
      swift_release();
      if (!__OFSUB__(v4 >> 1, v2))
      {
        if (v23 != (v4 >> 1) - v2)
          goto LABEL_33;
        v8 = swift_dynamicCastClass();
        if (!v8)
        {
          swift_unknownObjectRelease();
          v8 = MEMORY[0x24BEE4AF8];
        }
        goto LABEL_19;
      }
      goto LABEL_31;
    }
  }
  else
  {
    __break(1u);
  }
  __break(1u);
LABEL_31:
  __break(1u);
  do
  {
    __break(1u);
LABEL_33:
    swift_unknownObjectRelease();
LABEL_12:
    sub_217E200CC(v6, v27, v2, v4);
    v8 = v21;
LABEL_19:
    swift_unknownObjectRelease();
    if ((v3 & 1) == 0)
    {
      swift_unknownObjectRetain();
LABEL_21:
      sub_217E200CC(v28, v26, v29, v3);
      goto LABEL_28;
    }
    sub_217E2D194();
    swift_unknownObjectRetain_n();
    v24 = swift_dynamicCastClass();
    if (!v24)
    {
      swift_unknownObjectRelease();
      v24 = MEMORY[0x24BEE4AF8];
    }
    v2 = *(_QWORD *)(v24 + 16);
    swift_release();
  }
  while (__OFSUB__(v3 >> 1, v29));
  if (v2 != (v3 >> 1) - v29)
  {
    swift_unknownObjectRelease();
    goto LABEL_21;
  }
  if (!swift_dynamicCastClass())
    swift_unknownObjectRelease();
LABEL_28:
  swift_unknownObjectRelease();
  swift_unknownObjectRelease_n();
  sub_217E09BF8((uint64_t)&v32);
  return v8;
}

char *sub_217E1738C(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  __int128 v15;
  unint64_t v16;
  int64_t v17;
  uint64_t v18;
  int64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int64_t v27;
  int64_t v28;
  char *isUniquelyReferenced_nonNull_native;
  int64_t v30;
  uint64_t v31;
  BOOL v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char *v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  unint64_t v41;
  int64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  _BYTE *v65;
  char *v66;
  uint64_t v67;
  char *v68;
  uint64_t v69;
  int64_t v70;
  unint64_t v71;
  unint64_t v72;
  char *v73;
  char *v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  __int128 v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  __int128 v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  __int128 v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  __int128 v96;
  uint64_t v97;
  __int128 v98;
  uint64_t v99;
  char *v100;

  if (!a5 || (v5 = *(_QWORD *)(a5 + 16)) == 0 || (swift_bridgeObjectRetain(), (v6 = *(_QWORD *)(v5 + 16)) == 0))
  {
    v8 = 0;
LABEL_79:
    if (qword_254F274E8 != -1)
      goto LABEL_112;
    goto LABEL_80;
  }
  v7 = 0;
  v8 = 0;
  v79 = v5 + 32;
  v80 = v5;
  while (1)
  {
    if (v7 >= v6)
      goto LABEL_103;
    v10 = (uint64_t *)(v79 + (v7 << 6));
    v11 = *v10;
    v12 = v10[1];
    v14 = v10[2];
    v13 = v10[3];
    v86 = *((_OWORD *)v10 + 2);
    v15 = *((_OWORD *)v10 + 3);
    if (!v8)
      v8 = (char *)MEMORY[0x24BEE4AF8];
    v100 = v8;
    v16 = *((_QWORD *)v8 + 2);
    v87 = v14;
    v88 = v12;
    v83 = v7;
    v84 = v11;
    v82 = v15;
    v81 = v13;
    if (!v16)
    {
LABEL_34:
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      v19 = v16;
      v27 = v16;
      goto LABEL_35;
    }
    v17 = v13 >> 1;
    v18 = (v13 >> 1) - v14;
    if (__OFSUB__(v13 >> 1, v14))
      goto LABEL_109;
    v19 = 0;
    v95 = v12 + v14;
    while (1)
    {
      v20 = &v8[64 * v19 + 32];
      v21 = *((_QWORD *)v20 + 2);
      v22 = *((_QWORD *)v20 + 3) >> 1;
      if (__OFSUB__(v22, v21))
        goto LABEL_100;
      if (v22 - v21 != v18)
        goto LABEL_12;
      if (!v18)
        break;
      v23 = *((_QWORD *)v20 + 1);
      if (v23 + v21 == v95 || v21 == v22)
        break;
      if (v21 >= v22)
        goto LABEL_108;
      v24 = v21 + 1;
      v25 = *(unsigned __int8 *)(v23 + v21);
      if (v21 == v22)
        break;
      v26 = v14;
      if (v17 != v14)
      {
        while (v26 >= v14 && v26 < v17)
        {
          if (v25 != *(unsigned __int8 *)(v12 + v26))
            goto LABEL_12;
          if (v22 == v24)
            goto LABEL_28;
          if (v24 >= v22)
            goto LABEL_93;
          v25 = *(unsigned __int8 *)(v23 + v24++);
          if (v17 == ++v26)
            goto LABEL_12;
        }
        __break(1u);
LABEL_93:
        __break(1u);
LABEL_94:
        __break(1u);
LABEL_95:
        __break(1u);
LABEL_96:
        __break(1u);
LABEL_97:
        __break(1u);
LABEL_98:
        __break(1u);
LABEL_99:
        __break(1u);
LABEL_100:
        __break(1u);
LABEL_101:
        __break(1u);
LABEL_102:
        __break(1u);
LABEL_103:
        __break(1u);
LABEL_104:
        __break(1u);
LABEL_105:
        __break(1u);
        goto LABEL_106;
      }
LABEL_12:
      if (++v19 == v16)
        goto LABEL_34;
    }
LABEL_28:
    v27 = v19 + 1;
    if (__OFADD__(v19, 1))
      goto LABEL_110;
    v85 = (v13 >> 1) - v14;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    if (v27 != v16)
    {
      v37 = v85;
      while (1)
      {
        if (v27 >= v16)
          goto LABEL_95;
        v38 = v8 + 32;
        v39 = &v8[64 * v27 + 32];
        v40 = *((_QWORD *)v39 + 2);
        v41 = *((_QWORD *)v39 + 3);
        v42 = v41 >> 1;
        if (__OFSUB__(v41 >> 1, v40))
          goto LABEL_96;
        v43 = *((_QWORD *)v39 + 1);
        if ((v41 >> 1) - v40 != v37)
          goto LABEL_68;
        if (v37 && v43 + v40 != v95 && v40 != v42)
        {
          if (v40 >= v42)
            goto LABEL_107;
          v44 = v40 + 1;
          v45 = *(unsigned __int8 *)(v43 + v40);
          if (v40 != v42)
            break;
        }
LABEL_75:
        v32 = __OFADD__(v27++, 1);
        if (v32)
          goto LABEL_97;
        v16 = *((_QWORD *)v8 + 2);
        if (v27 == v16)
          goto LABEL_31;
      }
      v46 = v14;
      if (v17 != v14)
      {
        while (v46 >= v14 && v46 < v17)
        {
          if (v45 != *(unsigned __int8 *)(v12 + v46))
            goto LABEL_68;
          if (v42 == v44)
            goto LABEL_75;
          if (v44 >= v42)
            goto LABEL_98;
          v45 = *(unsigned __int8 *)(v43 + v44++);
          if (v17 == ++v46)
            goto LABEL_68;
        }
        goto LABEL_94;
      }
LABEL_68:
      if (v19 != v27)
      {
        if (v19 >= v16)
          goto LABEL_101;
        v47 = &v38[64 * v19];
        v48 = *((_QWORD *)v47 + 2);
        v49 = *((_QWORD *)v47 + 3);
        v96 = *((_OWORD *)v47 + 2);
        v89 = *((_QWORD *)v47 + 7);
        v90 = *((_QWORD *)v47 + 6);
        v50 = *(_QWORD *)v39;
        v51 = &v38[64 * v27];
        v98 = *((_OWORD *)v51 + 2);
        v93 = *((_QWORD *)v51 + 7);
        v94 = *((_QWORD *)v51 + 6);
        v92 = *(_OWORD *)v47;
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        v91 = v49;
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          v8 = sub_217E200B8((uint64_t)v8);
        v52 = v8;
        v8 += 32;
        v53 = &v8[64 * v19];
        *(_QWORD *)v53 = v50;
        *((_QWORD *)v53 + 1) = v43;
        *((_QWORD *)v53 + 2) = v40;
        *((_QWORD *)v53 + 3) = v41;
        *((_OWORD *)v53 + 2) = v98;
        *((_QWORD *)v53 + 6) = v94;
        *((_QWORD *)v53 + 7) = v93;
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        if ((unint64_t)v27 >= *((_QWORD *)v52 + 2))
          goto LABEL_102;
        v54 = &v8[64 * v27];
        *(_OWORD *)v54 = v92;
        *((_QWORD *)v54 + 2) = v48;
        *((_QWORD *)v54 + 3) = v91;
        *((_OWORD *)v54 + 2) = v96;
        *((_QWORD *)v54 + 6) = v90;
        *((_QWORD *)v54 + 7) = v89;
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        v8 = v52;
        v14 = v87;
        v12 = v88;
        v37 = v85;
      }
      v32 = __OFADD__(v19++, 1);
      if (v32)
        goto LABEL_99;
      goto LABEL_75;
    }
    v27 = v16;
LABEL_31:
    if (v27 < v19)
      goto LABEL_105;
    if (v19 < 0)
      break;
LABEL_35:
    v28 = v19 - v27;
    if (__OFADD__(v27, v19 - v27))
      goto LABEL_104;
    isUniquelyReferenced_nonNull_native = (char *)swift_isUniquelyReferenced_nonNull_native();
    if (!(_DWORD)isUniquelyReferenced_nonNull_native || v19 > *((_QWORD *)v8 + 3) >> 1)
    {
      if (v27 <= v19)
        v30 = v19;
      else
        v30 = v27;
      v8 = sub_217E0E3D4(isUniquelyReferenced_nonNull_native, v30, 1, v8);
    }
    swift_arrayDestroy();
    if (v27 != v19)
    {
      memmove(&v8[64 * v19 + 32], &v8[64 * v27 + 32], (*((_QWORD *)v8 + 2) - v27) << 6);
      v31 = *((_QWORD *)v8 + 2);
      v32 = __OFADD__(v31, v28);
      v33 = v31 + v28;
      if (v32)
        goto LABEL_111;
      *((_QWORD *)v8 + 2) = v33;
LABEL_47:
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      v9 = v80;
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
        v8 = sub_217E0E3D4(0, *((_QWORD *)v8 + 2) + 1, 1, v8);
      v35 = *((_QWORD *)v8 + 2);
      v34 = *((_QWORD *)v8 + 3);
      if (v35 >= v34 >> 1)
        v8 = sub_217E0E3D4((char *)(v34 > 1), v35 + 1, 1, v8);
      *((_QWORD *)v8 + 2) = v35 + 1;
      v36 = &v8[64 * v35];
      *((_QWORD *)v36 + 4) = v84;
      *((_QWORD *)v36 + 5) = v88;
      *((_QWORD *)v36 + 6) = v87;
      *((_QWORD *)v36 + 7) = v81;
      *((_OWORD *)v36 + 4) = v86;
      *((_OWORD *)v36 + 5) = v82;
      swift_unknownObjectRelease();
      swift_unknownObjectRelease();
      v100 = v8;
      goto LABEL_5;
    }
    v100 = v8;
    if (v8)
      goto LABEL_47;
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    v9 = v80;
LABEL_5:
    v7 = v83 + 1;
    v6 = *(_QWORD *)(v9 + 16);
    if (v83 + 1 == v6)
      goto LABEL_79;
  }
LABEL_106:
  __break(1u);
LABEL_107:
  __break(1u);
LABEL_108:
  __break(1u);
LABEL_109:
  __break(1u);
LABEL_110:
  __break(1u);
LABEL_111:
  __break(1u);
LABEL_112:
  swift_once();
LABEL_80:
  v55 = qword_254F2BD08;
  v56 = qword_254F2BD10;
  v57 = qword_254F2BD18;
  v58 = unk_254F2BD20;
  v59 = swift_unknownObjectRetain();
  v60 = sub_217E140AC(v59, a2, a3, a4);
  v64 = v78;
  if (!v78)
  {
    v66 = v60;
    v67 = v61;
    v97 = v63;
    v99 = v62;
    v68 = (char *)MEMORY[0x24BEE4AF8];
    if (v8)
      v68 = v8;
    v100 = v68;
    swift_unknownObjectRetain();
    v69 = sub_217E205B0((uint64_t)&v100, v56, v57, v58);
    v70 = *((_QWORD *)v100 + 2);
    if (v70 < v69)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v69, v70);
      v64 = v100;
      if (!v100)
      {
LABEL_90:
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        swift_bridgeObjectRelease();
        return v64;
      }
      v95 = v67;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_87:
        v72 = *((_QWORD *)v64 + 2);
        v71 = *((_QWORD *)v64 + 3);
        if (v72 >= v71 >> 1)
          v64 = sub_217E0E3D4((char *)(v71 > 1), v72 + 1, 1, v64);
        *((_QWORD *)v64 + 2) = v72 + 1;
        v73 = &v64[64 * v72];
        *((_QWORD *)v73 + 4) = v55;
        *((_QWORD *)v73 + 5) = v56;
        *((_QWORD *)v73 + 6) = v57;
        *((_QWORD *)v73 + 7) = v58;
        *((_QWORD *)v73 + 8) = v66;
        *((_QWORD *)v73 + 9) = v95;
        *((_QWORD *)v73 + 10) = v99;
        *((_QWORD *)v73 + 11) = v97;
        goto LABEL_90;
      }
    }
    v64 = sub_217E0E3D4(0, *((_QWORD *)v64 + 2) + 1, 1, v64);
    goto LABEL_87;
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_217E04E40();
  swift_allocError();
  *v65 = 25;
  swift_willThrow();
  MEMORY[0x219A18338]();
  return v64;
}

uint64_t AKSRefKey.__allocating_init(handle:key_class:key_type:params:)(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;

  v8 = swift_allocObject();
  AKSRefKey.init(handle:key_class:key_type:params:)(a1, a2, a3, a4);
  return v8;
}

uint64_t AKSRefKey.init(handle:key_class:key_type:params:)(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;
  int v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  int64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  int v55;
  char *v56;

  v6 = v4;
  v8 = *a1;
  *(_OWORD *)(v4 + 24) = xmmword_217E32980;
  *(_DWORD *)(v4 + 16) = v8;
  if (qword_254F27578 != -1)
    swift_once();
  v9 = sub_217E1738C(qword_254F2BF48, qword_254F2BF50, qword_254F2BF58, unk_254F2BF60, a4);
  v10 = v5;
  if (v5)
  {
    swift_release();
    swift_release();
    return v6;
  }
  v11 = v9;
  v56 = v9;
  if (qword_254F274F0 != -1)
    swift_once();
  v12 = qword_254F2BD28;
  v13 = qword_254F2BD30;
  v15 = qword_254F2BD38;
  v14 = qword_254F2BD40;
  v17 = 0;
  v16 = sub_217E1400C();
  v47 = v19;
  v49 = v18;
  v51 = v20;
  v53 = v16;
  if (!v11)
    v56 = (char *)MEMORY[0x24BEE4AF8];
  swift_unknownObjectRetain();
  v21 = sub_217E205B0((uint64_t)&v56, v13, v15, v14);
  v22 = *((_QWORD *)v56 + 2);
  if (v22 < v21)
  {
    __break(1u);
LABEL_33:
    swift_once();
    goto LABEL_18;
  }
  sub_217E208C8(v21, v22);
  v10 = v56;
  if (v56)
  {
    v46 = 0;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      v10 = sub_217E0E3D4(0, *((_QWORD *)v10 + 2) + 1, 1, v10);
    v24 = *((_QWORD *)v10 + 2);
    v23 = *((_QWORD *)v10 + 3);
    if (v24 >= v23 >> 1)
      v10 = sub_217E0E3D4((char *)(v23 > 1), v24 + 1, 1, v10);
    *((_QWORD *)v10 + 2) = v24 + 1;
    v25 = &v10[64 * v24];
    *((_QWORD *)v25 + 4) = v12;
    *((_QWORD *)v25 + 5) = v13;
    *((_QWORD *)v25 + 6) = v15;
    *((_QWORD *)v25 + 7) = v14;
    *((_QWORD *)v25 + 8) = v53;
    *((_QWORD *)v25 + 9) = v51;
    *((_QWORD *)v25 + 10) = v49;
    *((_QWORD *)v25 + 11) = v47;
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    v56 = v10;
    v17 = v5;
  }
  else
  {
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
  }
  if (qword_254F27538 != -1)
    goto LABEL_33;
LABEL_18:
  v26 = qword_254F2BE48;
  v27 = qword_254F2BE50;
  v29 = qword_254F2BE58;
  v28 = qword_254F2BE60;
  v30 = sub_217E1400C();
  v48 = v33;
  v50 = v32;
  v52 = v34;
  v54 = v30;
  v35 = (char *)MEMORY[0x24BEE4AF8];
  if (v10)
    v35 = v10;
  v56 = v35;
  swift_unknownObjectRetain();
  v36 = sub_217E205B0((uint64_t)&v56, v27, v29, v28);
  v37 = *((_QWORD *)v56 + 2);
  if (v37 < v36)
  {
    __break(1u);
    goto LABEL_35;
  }
  v38 = 0;
  sub_217E208C8(v36, v37);
  v17 = v56;
  if (v56)
  {
    v46 = 0;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
    {
LABEL_25:
      v40 = *((_QWORD *)v17 + 2);
      v39 = *((_QWORD *)v17 + 3);
      if (v40 >= v39 >> 1)
        v17 = sub_217E0E3D4((char *)(v39 > 1), v40 + 1, 1, v17);
      *((_QWORD *)v17 + 2) = v40 + 1;
      v41 = &v17[64 * v40];
      *((_QWORD *)v41 + 4) = v26;
      *((_QWORD *)v41 + 5) = v27;
      *((_QWORD *)v41 + 6) = v29;
      *((_QWORD *)v41 + 7) = v28;
      *((_QWORD *)v41 + 8) = v54;
      *((_QWORD *)v41 + 9) = v52;
      *((_QWORD *)v41 + 10) = v50;
      *((_QWORD *)v41 + 11) = v48;
      swift_unknownObjectRelease();
      swift_unknownObjectRelease();
      v38 = v46;
      goto LABEL_29;
    }
LABEL_35:
    v17 = sub_217E0E3D4(0, *((_QWORD *)v17 + 2) + 1, 1, v17);
    goto LABEL_25;
  }
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
LABEL_29:
  v55 = *(_DWORD *)(v6 + 16);
  v42 = sub_217E16E24(&v55, v17);
  if (v38)
  {
    swift_release();
    swift_release();
    swift_bridgeObjectRelease();
  }
  else
  {
    v43 = v42;
    swift_bridgeObjectRelease();
    v44 = sub_217E147CC(v43, 17, 0);
    swift_release();
    v45 = *(_QWORD *)(v6 + 24);
    *(_QWORD *)(v6 + 24) = v44;
    sub_217E21274(v45);
  }
  return v6;
}

uint64_t AKSRefKey.__allocating_init(handle:blob:)(int *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  int v6;
  char *v7;
  _BYTE *v8;

  v5 = swift_allocObject();
  v6 = *a1;
  *(_OWORD *)(v5 + 24) = xmmword_217E32980;
  *(_DWORD *)(v5 + 16) = v6;
  v7 = sub_217E147CC(a2, 17, 0);
  if (v2)
  {
    swift_release();
    sub_217E04E40();
    swift_allocError();
    *v8 = 25;
    swift_willThrow();
    MEMORY[0x219A18338](v2);
  }
  else
  {
    *(_QWORD *)(v5 + 24) = v7;
    sub_217E21274(1);
  }
  return v5;
}

uint64_t AKSRefKey.init(handle:blob:)(int *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  char *v5;
  _BYTE *v6;
  uint64_t v7;

  v4 = *a1;
  *(_OWORD *)(v2 + 24) = xmmword_217E32980;
  *(_DWORD *)(v2 + 16) = v4;
  v5 = sub_217E147CC(a2, 17, 0);
  if (v3)
  {
    swift_release();
    sub_217E04E40();
    swift_allocError();
    *v6 = 25;
    swift_willThrow();
    MEMORY[0x219A18338](v3);
  }
  else
  {
    v7 = *(_QWORD *)(v2 + 24);
    *(_QWORD *)(v2 + 24) = v5;
    sub_217E21274(v7);
  }
  return v2;
}

double AKSRefKey.__allocating_init(handle:)(int *a1)
{
  uint64_t v2;
  int v3;
  double result;

  v2 = swift_allocObject();
  v3 = *a1;
  *(_QWORD *)&result = 1;
  *(_OWORD *)(v2 + 24) = xmmword_217E32980;
  *(_DWORD *)(v2 + 16) = v3;
  return result;
}

uint64_t AKSRefKey.init(handle:)(int *a1)
{
  uint64_t v1;
  int v2;

  v2 = *a1;
  *(_OWORD *)(v1 + 24) = xmmword_217E32980;
  *(_DWORD *)(v1 + 16) = v2;
  return v1;
}

uint64_t sub_217E18268(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v4;
  unint64_t v5;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  int64_t v34;
  char *v35;
  unint64_t v36;
  unint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _BYTE *v49;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  __int128 v61;
  char *v62;
  int v63;
  __int128 v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;

  v7 = *a1;
  if (qword_254F27560 != -1)
    swift_once();
  v8 = sub_217E1738C(qword_254F2BEE8, qword_254F2BEF0, qword_254F2BEF8, unk_254F2BF00, a4);
  if (!v5)
  {
    v9 = (unint64_t)v8;
    v62 = v4;
    v71 = v8;
    if (qword_254F274F0 != -1)
      swift_once();
    v10 = qword_254F2BD28;
    v11 = qword_254F2BD30;
    v12 = qword_254F2BD38;
    v13 = qword_254F2BD40;
    v14 = 0;
    v15 = sub_217E1400C();
    v56 = v17;
    v57 = v16;
    v59 = v18;
    if (!v9)
      v71 = (char *)MEMORY[0x24BEE4AF8];
    swift_unknownObjectRetain();
    v19 = sub_217E205B0((uint64_t)&v71, v11, v12, v13);
    v20 = *((_QWORD *)v71 + 2);
    if (v20 < v19)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v19, v20);
      v4 = v71;
      if (v71)
      {
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          v4 = sub_217E0E3D4(0, *((_QWORD *)v4 + 2) + 1, 1, v4);
        v9 = *((_QWORD *)v4 + 2);
        v21 = *((_QWORD *)v4 + 3);
        if (v9 >= v21 >> 1)
          v4 = sub_217E0E3D4((char *)(v21 > 1), v9 + 1, 1, v4);
        *((_QWORD *)v4 + 2) = v9 + 1;
        v22 = &v4[64 * v9];
        *((_QWORD *)v22 + 4) = v10;
        *((_QWORD *)v22 + 5) = v11;
        *((_QWORD *)v22 + 6) = v12;
        *((_QWORD *)v22 + 7) = v13;
        *((_QWORD *)v22 + 8) = v15;
        *((_QWORD *)v22 + 9) = v59;
        *((_QWORD *)v22 + 10) = v57;
        *((_QWORD *)v22 + 11) = v56;
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        v71 = v4;
        v14 = v5;
      }
      else
      {
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
      }
      if (qword_254F27538 == -1)
      {
LABEL_17:
        v23 = qword_254F2BE48;
        v24 = qword_254F2BE50;
        v25 = qword_254F2BE58;
        v26 = qword_254F2BE60;
        v27 = sub_217E1400C();
        v29 = v28;
        v58 = v31;
        v60 = v30;
        v32 = (char *)MEMORY[0x24BEE4AF8];
        if (v4)
          v32 = v4;
        v71 = v32;
        swift_unknownObjectRetain();
        v33 = sub_217E205B0((uint64_t)&v71, v24, v25, v26);
        v34 = *((_QWORD *)v71 + 2);
        if (v34 < v33)
        {
          __break(1u);
        }
        else
        {
          v9 = 0;
          sub_217E208C8(v33, v34);
          v35 = v71;
          if (v71)
          {
            swift_unknownObjectRetain();
            swift_unknownObjectRetain();
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
              v35 = sub_217E0E3D4(0, *((_QWORD *)v35 + 2) + 1, 1, v35);
            v37 = *((_QWORD *)v35 + 2);
            v36 = *((_QWORD *)v35 + 3);
            if (v37 >= v36 >> 1)
              v35 = sub_217E0E3D4((char *)(v36 > 1), v37 + 1, 1, v35);
            *((_QWORD *)v35 + 2) = v37 + 1;
            v38 = &v35[64 * v37];
            *((_QWORD *)v38 + 4) = v23;
            *((_QWORD *)v38 + 5) = v24;
            *((_QWORD *)v38 + 6) = v25;
            *((_QWORD *)v38 + 7) = v26;
            *((_QWORD *)v38 + 8) = v27;
            *((_QWORD *)v38 + 9) = v60;
            *((_QWORD *)v38 + 10) = v58;
            *((_QWORD *)v38 + 11) = v29;
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
            v71 = v35;
            v9 = v14;
          }
          else
          {
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
          }
          if (qword_254F274F8 == -1)
            goto LABEL_28;
        }
        swift_once();
LABEL_28:
        v61 = xmmword_254F2BD48;
        v39 = qword_254F2BD58;
        v40 = qword_254F2BD60;
        swift_bridgeObjectRetain();
        v41 = v9;
        v42 = sub_217E204F8();
        v44 = v43;
        v46 = v45;
        v48 = v47;
        v7 = v41;
        swift_bridgeObjectRelease();
        if (v41)
        {
          sub_217E04E40();
          swift_allocError();
          *v49 = 22;
          swift_willThrow();
          MEMORY[0x219A18338](v41);
          swift_bridgeObjectRelease();
        }
        else
        {
          v64 = v61;
          v65 = v39;
          v66 = v40;
          v67 = v42;
          v68 = v44;
          v69 = v46;
          v70 = v48;
          swift_unknownObjectRetain();
          sub_217E043A0((uint64_t)&v64);
          swift_unknownObjectRelease();
          swift_unknownObjectRelease();
          v63 = *((_DWORD *)v62 + 4);
          v51 = sub_217E16E24(&v63, v71);
          swift_bridgeObjectRelease();
          v7 = sub_217E1700C(v51);
          v53 = v52;
          swift_bridgeObjectRelease();
          v54 = sub_217E147CC(v53, 17, 0);
          v55 = *((_QWORD *)v62 + 3);
          *((_QWORD *)v62 + 3) = v54;
          sub_217E21274(v55);
        }
        return v7;
      }
    }
    swift_once();
    goto LABEL_17;
  }
  return v7;
}

uint64_t sub_217E187DC(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v4;
  unint64_t v5;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  int64_t v34;
  char *v35;
  unint64_t v36;
  unint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _BYTE *v49;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  __int128 v61;
  char *v62;
  int v63;
  __int128 v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;

  v7 = *a1;
  if (qword_254F27718 != -1)
    swift_once();
  v8 = sub_217E1738C(qword_254F2C5C8, qword_254F2C5D0, qword_254F2C5D8, unk_254F2C5E0, a4);
  if (!v5)
  {
    v9 = (unint64_t)v8;
    v62 = v4;
    v71 = v8;
    if (qword_254F274F0 != -1)
      swift_once();
    v10 = qword_254F2BD28;
    v11 = qword_254F2BD30;
    v12 = qword_254F2BD38;
    v13 = qword_254F2BD40;
    v14 = 0;
    v15 = sub_217E1400C();
    v56 = v17;
    v57 = v16;
    v59 = v18;
    if (!v9)
      v71 = (char *)MEMORY[0x24BEE4AF8];
    swift_unknownObjectRetain();
    v19 = sub_217E205B0((uint64_t)&v71, v11, v12, v13);
    v20 = *((_QWORD *)v71 + 2);
    if (v20 < v19)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v19, v20);
      v4 = v71;
      if (v71)
      {
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          v4 = sub_217E0E3D4(0, *((_QWORD *)v4 + 2) + 1, 1, v4);
        v9 = *((_QWORD *)v4 + 2);
        v21 = *((_QWORD *)v4 + 3);
        if (v9 >= v21 >> 1)
          v4 = sub_217E0E3D4((char *)(v21 > 1), v9 + 1, 1, v4);
        *((_QWORD *)v4 + 2) = v9 + 1;
        v22 = &v4[64 * v9];
        *((_QWORD *)v22 + 4) = v10;
        *((_QWORD *)v22 + 5) = v11;
        *((_QWORD *)v22 + 6) = v12;
        *((_QWORD *)v22 + 7) = v13;
        *((_QWORD *)v22 + 8) = v15;
        *((_QWORD *)v22 + 9) = v59;
        *((_QWORD *)v22 + 10) = v57;
        *((_QWORD *)v22 + 11) = v56;
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        v71 = v4;
        v14 = v5;
      }
      else
      {
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
      }
      if (qword_254F27538 == -1)
      {
LABEL_17:
        v23 = qword_254F2BE48;
        v24 = qword_254F2BE50;
        v25 = qword_254F2BE58;
        v26 = qword_254F2BE60;
        v27 = sub_217E1400C();
        v29 = v28;
        v58 = v31;
        v60 = v30;
        v32 = (char *)MEMORY[0x24BEE4AF8];
        if (v4)
          v32 = v4;
        v71 = v32;
        swift_unknownObjectRetain();
        v33 = sub_217E205B0((uint64_t)&v71, v24, v25, v26);
        v34 = *((_QWORD *)v71 + 2);
        if (v34 < v33)
        {
          __break(1u);
        }
        else
        {
          v9 = 0;
          sub_217E208C8(v33, v34);
          v35 = v71;
          if (v71)
          {
            swift_unknownObjectRetain();
            swift_unknownObjectRetain();
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
              v35 = sub_217E0E3D4(0, *((_QWORD *)v35 + 2) + 1, 1, v35);
            v37 = *((_QWORD *)v35 + 2);
            v36 = *((_QWORD *)v35 + 3);
            if (v37 >= v36 >> 1)
              v35 = sub_217E0E3D4((char *)(v36 > 1), v37 + 1, 1, v35);
            *((_QWORD *)v35 + 2) = v37 + 1;
            v38 = &v35[64 * v37];
            *((_QWORD *)v38 + 4) = v23;
            *((_QWORD *)v38 + 5) = v24;
            *((_QWORD *)v38 + 6) = v25;
            *((_QWORD *)v38 + 7) = v26;
            *((_QWORD *)v38 + 8) = v27;
            *((_QWORD *)v38 + 9) = v60;
            *((_QWORD *)v38 + 10) = v58;
            *((_QWORD *)v38 + 11) = v29;
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
            v71 = v35;
            v9 = v14;
          }
          else
          {
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
          }
          if (qword_254F274F8 == -1)
            goto LABEL_28;
        }
        swift_once();
LABEL_28:
        v61 = xmmword_254F2BD48;
        v39 = qword_254F2BD58;
        v40 = qword_254F2BD60;
        swift_bridgeObjectRetain();
        v41 = v9;
        v42 = sub_217E204F8();
        v44 = v43;
        v46 = v45;
        v48 = v47;
        v7 = v41;
        swift_bridgeObjectRelease();
        if (v41)
        {
          sub_217E04E40();
          swift_allocError();
          *v49 = 22;
          swift_willThrow();
          MEMORY[0x219A18338](v41);
          swift_bridgeObjectRelease();
        }
        else
        {
          v64 = v61;
          v65 = v39;
          v66 = v40;
          v67 = v42;
          v68 = v44;
          v69 = v46;
          v70 = v48;
          swift_unknownObjectRetain();
          sub_217E043A0((uint64_t)&v64);
          swift_unknownObjectRelease();
          swift_unknownObjectRelease();
          v63 = *((_DWORD *)v62 + 4);
          v51 = sub_217E16E24(&v63, v71);
          swift_bridgeObjectRelease();
          v7 = sub_217E1700C(v51);
          v53 = v52;
          swift_bridgeObjectRelease();
          v54 = sub_217E147CC(v53, 17, 0);
          v55 = *((_QWORD *)v62 + 3);
          *((_QWORD *)v62 + 3) = v54;
          sub_217E21274(v55);
        }
        return v7;
      }
    }
    swift_once();
    goto LABEL_17;
  }
  return v7;
}

uint64_t sub_217E18D50(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int64_t v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t result;
  char *v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  int64_t v50;
  unint64_t v51;
  unint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  __int128 v58;
  uint64_t v59;
  int v60;
  __int128 v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;

  if (qword_254F27580 != -1)
    swift_once();
  v6 = sub_217E1738C(qword_254F2BF68, qword_254F2BF70, qword_254F2BF78, unk_254F2BF80, a2);
  if (v3)
    return a1;
  v7 = v6;
  v59 = v2;
  v68 = v6;
  if (qword_254F276B0 != -1)
    swift_once();
  v9 = qword_254F2C428;
  v8 = qword_254F2C430;
  v10 = qword_254F2C438;
  v11 = unk_254F2C440;
  v12 = sub_217E1400C();
  v14 = v13;
  v55 = v16;
  v57 = v15;
  if (!v7)
    v68 = (char *)MEMORY[0x24BEE4AF8];
  swift_unknownObjectRetain();
  v17 = v8;
  v18 = sub_217E205B0((uint64_t)&v68, v8, v10, v11);
  v19 = *((_QWORD *)v68 + 2);
  if (v19 < v18)
  {
    __break(1u);
LABEL_33:
    swift_once();
    goto LABEL_17;
  }
  sub_217E208C8(v18, v19);
  v20 = v68;
  if (v68)
  {
    v54 = v14;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      v20 = sub_217E0E3D4(0, *((_QWORD *)v20 + 2) + 1, 1, v20);
    v22 = *((_QWORD *)v20 + 2);
    v21 = *((_QWORD *)v20 + 3);
    if (v22 >= v21 >> 1)
      v20 = sub_217E0E3D4((char *)(v21 > 1), v22 + 1, 1, v20);
    *((_QWORD *)v20 + 2) = v22 + 1;
    v23 = &v20[64 * v22];
    *((_QWORD *)v23 + 4) = v9;
    *((_QWORD *)v23 + 5) = v17;
    *((_QWORD *)v23 + 6) = v10;
    *((_QWORD *)v23 + 7) = v11;
    *((_QWORD *)v23 + 8) = v12;
    *((_QWORD *)v23 + 9) = v54;
    *((_QWORD *)v23 + 10) = v57;
    *((_QWORD *)v23 + 11) = v55;
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    v68 = v20;
  }
  else
  {
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
  }
  if (qword_254F274F8 != -1)
    goto LABEL_33;
LABEL_17:
  v58 = xmmword_254F2BD48;
  v24 = qword_254F2BD58;
  v25 = qword_254F2BD60;
  swift_bridgeObjectRetain();
  v26 = sub_217E204F8();
  v28 = v27;
  v30 = v29;
  v32 = v31;
  swift_bridgeObjectRelease();
  v61 = v58;
  v62 = v24;
  v63 = v25;
  v64 = v26;
  v65 = v28;
  v66 = v30;
  v67 = v32;
  swift_unknownObjectRetain();
  v33 = (char *)&v68;
  sub_217E043A0((uint64_t)&v61);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  result = *(_QWORD *)(v59 + 24);
  if (result != 1)
  {
    v35 = (char *)swift_bridgeObjectRetain();
    v36 = sub_217E14180(v35);
    v38 = v37;
    v40 = v39;
    v42 = v41;
    v43 = qword_254F27550;
    swift_unknownObjectRetain();
    if (v43 != -1)
      swift_once();
    v45 = qword_254F2BEA8;
    v44 = qword_254F2BEB0;
    v47 = qword_254F2BEB8;
    v46 = qword_254F2BEC0;
    v48 = v68;
    if (!v68)
      v48 = (char *)MEMORY[0x24BEE4AF8];
    v68 = v48;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v56 = v46;
    v49 = sub_217E205B0((uint64_t)&v68, v44, v47, v46);
    v50 = *((_QWORD *)v68 + 2);
    if (v50 < v49)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v49, v50);
      v33 = v68;
      if (!v68)
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
LABEL_31:
        v60 = *(_DWORD *)(v59 + 16);
        a1 = sub_217E16E24(&v60, v33);
        swift_bridgeObjectRelease();
        return a1;
      }
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_27:
        v52 = *((_QWORD *)v33 + 2);
        v51 = *((_QWORD *)v33 + 3);
        if (v52 >= v51 >> 1)
          v33 = sub_217E0E3D4((char *)(v51 > 1), v52 + 1, 1, v33);
        *((_QWORD *)v33 + 2) = v52 + 1;
        v53 = &v33[64 * v52];
        *((_QWORD *)v53 + 4) = v45;
        *((_QWORD *)v53 + 5) = v44;
        *((_QWORD *)v53 + 6) = v47;
        *((_QWORD *)v53 + 7) = v56;
        *((_QWORD *)v53 + 8) = v36;
        *((_QWORD *)v53 + 9) = v38;
        *((_QWORD *)v53 + 10) = v40;
        *((_QWORD *)v53 + 11) = v42;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        goto LABEL_31;
      }
    }
    v33 = sub_217E0E3D4(0, *((_QWORD *)v33 + 2) + 1, 1, v33);
    goto LABEL_27;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E19244(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t result;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  int64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  int v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;

  v4 = v2;
  if (qword_254F27558 != -1)
    swift_once();
  v6 = sub_217E1738C(qword_254F2BEC8, qword_254F2BED0, qword_254F2BED8, unk_254F2BEE0, a2);
  if (v3)
    return v4;
  v47 = v6;
  if (qword_254F274F8 != -1)
    swift_once();
  v37 = xmmword_254F2BD48;
  v7 = qword_254F2BD58;
  v8 = qword_254F2BD60;
  swift_bridgeObjectRetain();
  v9 = sub_217E204F8();
  v11 = v10;
  v13 = v12;
  v15 = v14;
  swift_bridgeObjectRelease();
  v40 = v37;
  v41 = v7;
  v42 = v8;
  v43 = v9;
  v44 = v11;
  v45 = v13;
  v46 = v15;
  swift_unknownObjectRetain();
  v16 = (char *)&v47;
  sub_217E043A0((uint64_t)&v40);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  result = *(_QWORD *)(v4 + 24);
  if (result != 1)
  {
    v18 = (char *)swift_bridgeObjectRetain();
    v19 = sub_217E14180(v18);
    v21 = v20;
    v36 = v23;
    v38 = v22;
    v24 = qword_254F27550;
    swift_unknownObjectRetain();
    if (v24 != -1)
      swift_once();
    v25 = qword_254F2BEA8;
    v26 = qword_254F2BEB0;
    v27 = qword_254F2BEB8;
    v28 = qword_254F2BEC0;
    v29 = v47;
    if (!v47)
      v29 = (char *)MEMORY[0x24BEE4AF8];
    v47 = v29;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v30 = sub_217E205B0((uint64_t)&v47, v26, v27, v28);
    v31 = *((_QWORD *)v47 + 2);
    if (v31 < v30)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v30, v31);
      v16 = v47;
      if (!v47)
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
LABEL_20:
        v39 = *(_DWORD *)(v4 + 16);
        v4 = sub_217E16E24(&v39, v16);
        swift_bridgeObjectRelease();
        return v4;
      }
      v35 = v21;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_16:
        v33 = *((_QWORD *)v16 + 2);
        v32 = *((_QWORD *)v16 + 3);
        if (v33 >= v32 >> 1)
          v16 = sub_217E0E3D4((char *)(v32 > 1), v33 + 1, 1, v16);
        *((_QWORD *)v16 + 2) = v33 + 1;
        v34 = &v16[64 * v33];
        *((_QWORD *)v34 + 4) = v25;
        *((_QWORD *)v34 + 5) = v26;
        *((_QWORD *)v34 + 6) = v27;
        *((_QWORD *)v34 + 7) = v28;
        *((_QWORD *)v34 + 8) = v19;
        *((_QWORD *)v34 + 9) = v35;
        *((_QWORD *)v34 + 10) = v38;
        *((_QWORD *)v34 + 11) = v36;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        goto LABEL_20;
      }
    }
    v16 = sub_217E0E3D4(0, *((_QWORD *)v16 + 2) + 1, 1, v16);
    goto LABEL_16;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E195B4(uint64_t a1, uint64_t a2)
{
  char *v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  unint64_t v9;
  char v10;
  char v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  uint64_t v40;
  int64_t v41;
  unint64_t v42;
  unint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t result;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  int v64;
  unint64_t v65;
  char v66;
  uint64_t v67;
  _BYTE v68[48];
  _BYTE v69[56];
  char *v70;

  v5 = a1 + 32;
  v6 = (2 * *(_QWORD *)(a1 + 16)) | 1;
  v7 = swift_bridgeObjectRetain();
  sub_217E09CBC(v7, v5, 0, v6, (uint64_t)&v65);
  if (v3)
  {
    swift_bridgeObjectRelease();
    sub_217E04E40();
    swift_allocError();
    *v8 = 10;
    swift_willThrow();
    MEMORY[0x219A18338](v3);
    return v6;
  }
  v70 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  v9 = v65;
  v10 = v66;
  sub_217E04CC0((uint64_t)&v67, (uint64_t)v68);
  sub_217E04CC0((uint64_t)v68, (uint64_t)v69);
  v11 = v69[40];
  sub_217E21234((uint64_t)&v65);
  sub_217E0833C(v9, v10, (v11 & 1) == 0, (uint64_t)&v70, (uint64_t)&v65);
  sub_217E09BF8((uint64_t)&v65);
  v12 = v70;
  v6 = *((_QWORD *)v70 + 2);
  sub_217E09BF8((uint64_t)&v65);
  swift_bridgeObjectRelease();
  v13 = qword_254F27568;
  swift_unknownObjectRetain();
  if (v13 != -1)
    swift_once();
  v14 = 0;
  v15 = sub_217E1738C(qword_254F2BF08, qword_254F2BF10, qword_254F2BF18, unk_254F2BF20, a2);
  v63 = v2;
  v70 = v15;
  if (qword_254F274F8 != -1)
    swift_once();
  v16 = xmmword_254F2BD48;
  v17 = qword_254F2BD58;
  v18 = qword_254F2BD60;
  if (!v15)
    v70 = (char *)MEMORY[0x24BEE4AF8];
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  v19 = sub_217E205B0((uint64_t)&v70, *((uint64_t *)&v16 + 1), v17, v18);
  v20 = *((_QWORD *)v70 + 2);
  if (v20 < v19)
  {
    __break(1u);
LABEL_44:
    v2 = sub_217E0E3D4(0, *((_QWORD *)v2 + 2) + 1, 1, v2);
    goto LABEL_12;
  }
  sub_217E208C8(v19, v20);
  v2 = v70;
  if (!v70)
  {
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    goto LABEL_16;
  }
  v62 = 0;
  v14 = 1;
  v60 = v12 + 32;
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
    goto LABEL_44;
LABEL_12:
  v21 = v14 | (2 * v6);
  v23 = *((_QWORD *)v2 + 2);
  v22 = *((_QWORD *)v2 + 3);
  v6 = v23 + 1;
  if (v23 >= v22 >> 1)
    v2 = sub_217E0E3D4((char *)(v22 > 1), v23 + 1, 1, v2);
  *((_QWORD *)v2 + 2) = v6;
  v24 = &v2[64 * v23];
  *((_OWORD *)v24 + 2) = v16;
  *((_QWORD *)v24 + 6) = v17;
  *((_QWORD *)v24 + 7) = v18;
  *((_QWORD *)v24 + 8) = v12;
  *((_QWORD *)v24 + 9) = v60;
  *((_QWORD *)v24 + 10) = 0;
  *((_QWORD *)v24 + 11) = v21;
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  v70 = v2;
  v14 = v62;
LABEL_16:
  if (*((_QWORD *)v63 + 3) != 1)
  {
    v25 = (char *)swift_bridgeObjectRetain();
    v26 = sub_217E14180(v25);
    v30 = v14;
    if (v14)
    {
      sub_217E04E40();
      swift_allocError();
      *v31 = 22;
      swift_willThrow();
      MEMORY[0x219A18338](v14);
      swift_bridgeObjectRelease();
LABEL_32:
      swift_bridgeObjectRelease();
      return v6;
    }
    v32 = v26;
    v33 = v27;
    v34 = v29;
    v59 = v28;
    v35 = qword_254F27550;
    swift_unknownObjectRetain();
    if (v35 != -1)
      swift_once();
    v37 = qword_254F2BEA8;
    v36 = qword_254F2BEB0;
    v6 = qword_254F2BEB8;
    v38 = qword_254F2BEC0;
    v39 = (char *)MEMORY[0x24BEE4AF8];
    if (v2)
      v39 = v2;
    v70 = v39;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v61 = v6;
    v40 = sub_217E205B0((uint64_t)&v70, v36, v6, v38);
    v41 = *((_QWORD *)v70 + 2);
    if (v41 < v40)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v40, v41);
      v6 = (uint64_t)v70;
      if (!v70)
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        v6 = (uint64_t)v70;
        goto LABEL_30;
      }
      v58 = v30;
      v30 = v33;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_26:
        v43 = *(_QWORD *)(v6 + 16);
        v42 = *(_QWORD *)(v6 + 24);
        if (v43 >= v42 >> 1)
          v6 = (uint64_t)sub_217E0E3D4((char *)(v42 > 1), v43 + 1, 1, (char *)v6);
        *(_QWORD *)(v6 + 16) = v43 + 1;
        v44 = (_QWORD *)(v6 + (v43 << 6));
        v44[4] = v37;
        v44[5] = v36;
        v44[6] = v61;
        v44[7] = v38;
        v44[8] = v32;
        v44[9] = v30;
        v44[10] = v59;
        v44[11] = v34;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        v70 = (char *)v6;
        v30 = v58;
LABEL_30:
        v64 = *((_DWORD *)v63 + 4);
        v45 = sub_217E16E24(&v64, (char *)v6);
        if (v30)
        {
          swift_bridgeObjectRelease();
          goto LABEL_32;
        }
        v47 = v45;
        swift_bridgeObjectRelease();
        v48 = sub_217E14874(v47, 4, 0);
        v50 = v49;
        v52 = v51;
        v54 = v53;
        if ((v53 & 1) != 0)
        {
          sub_217E2D194();
          swift_unknownObjectRetain_n();
          v56 = swift_dynamicCastClass();
          if (!v56)
          {
            swift_unknownObjectRelease();
            v56 = MEMORY[0x24BEE4AF8];
          }
          v57 = *(_QWORD *)(v56 + 16);
          swift_release();
          if (__OFSUB__(v54 >> 1, v52))
          {
            __break(1u);
          }
          else if (v57 == (v54 >> 1) - v52)
          {
            v6 = swift_dynamicCastClass();
            swift_bridgeObjectRelease();
            if (!v6)
            {
              swift_unknownObjectRelease();
              v6 = MEMORY[0x24BEE4AF8];
            }
            goto LABEL_42;
          }
          swift_unknownObjectRelease();
        }
        sub_217E200CC(v48, v50, v52, v54);
        v6 = v55;
        swift_bridgeObjectRelease();
LABEL_42:
        swift_unknownObjectRelease();
        return v6;
      }
    }
    v6 = (uint64_t)sub_217E0E3D4(0, *(_QWORD *)(v6 + 16) + 1, 1, (char *)v6);
    goto LABEL_26;
  }
  __break(1u);
  sub_217E09BF8(1);
  result = swift_unexpectedError();
  __break(1u);
  return result;
}

char *sub_217E19C7C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char *result;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  char *v32;

  v3 = v1;
  if (qword_254F27570 != -1)
    swift_once();
  result = sub_217E1738C(qword_254F2BF28, qword_254F2BF30, qword_254F2BF38, unk_254F2BF40, a1);
  if (!v2)
  {
    v6 = result;
    v32 = result;
    result = *(char **)(v3 + 24);
    if (result == (char *)1)
    {
      __break(1u);
      return result;
    }
    v8 = 0;
    v7 = (char *)swift_bridgeObjectRetain();
    v9 = sub_217E14180(v7);
    v11 = v10;
    v13 = v12;
    v30 = v14;
    v15 = qword_254F27550;
    swift_unknownObjectRetain();
    if (v15 != -1)
      swift_once();
    v16 = qword_254F2BEA8;
    v17 = qword_254F2BEB0;
    v18 = qword_254F2BEB8;
    v19 = qword_254F2BEC0;
    if (!v6)
      v32 = (char *)MEMORY[0x24BEE4AF8];
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v20 = sub_217E205B0((uint64_t)&v32, v17, v18, v19);
    v21 = *((_QWORD *)v32 + 2);
    if (v21 < v20)
    {
      __break(1u);
    }
    else
    {
      v22 = 0;
      sub_217E208C8(v20, v21);
      v8 = v32;
      if (!v32)
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
LABEL_16:
        v31 = *(_DWORD *)(v3 + 16);
        sub_217E16E24(&v31, v8);
        if (!v22)
          swift_bridgeObjectRelease();
        return (char *)swift_bridgeObjectRelease();
      }
      v28 = v17;
      v29 = 0;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_12:
        v24 = *((_QWORD *)v8 + 2);
        v23 = *((_QWORD *)v8 + 3);
        v25 = v18;
        if (v24 >= v23 >> 1)
        {
          v27 = sub_217E0E3D4((char *)(v23 > 1), v24 + 1, 1, v8);
          v25 = v18;
          v8 = v27;
        }
        *((_QWORD *)v8 + 2) = v24 + 1;
        v26 = &v8[64 * v24];
        *((_QWORD *)v26 + 4) = v16;
        *((_QWORD *)v26 + 5) = v28;
        *((_QWORD *)v26 + 6) = v25;
        *((_QWORD *)v26 + 7) = v19;
        *((_QWORD *)v26 + 8) = v9;
        *((_QWORD *)v26 + 9) = v30;
        *((_QWORD *)v26 + 10) = v11;
        *((_QWORD *)v26 + 11) = v13;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        v22 = v29;
        goto LABEL_16;
      }
    }
    v8 = sub_217E0E3D4(0, *((_QWORD *)v8 + 2) + 1, 1, v8);
    goto LABEL_12;
  }
  return result;
}

char *sub_217E19F2C(uint64_t a1, uint64_t a2)
{
  char *v2;
  uint64_t v3;
  char *result;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t v38;
  int64_t v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  int v51;
  char *v52;

  if (qword_254F27588 != -1)
    swift_once();
  result = sub_217E1738C(qword_254F2BF88, qword_254F2BF90, qword_254F2BF98, unk_254F2BFA0, a2);
  if (!v3)
  {
    v6 = result;
    v50 = v2;
    v52 = result;
    if (qword_254F274F0 != -1)
      swift_once();
    v7 = qword_254F2BD28;
    v8 = qword_254F2BD30;
    v9 = qword_254F2BD38;
    v10 = qword_254F2BD40;
    v11 = 0;
    v12 = sub_217E1400C();
    v14 = v13;
    v48 = v16;
    v49 = v15;
    if (!v6)
      v52 = (char *)MEMORY[0x24BEE4AF8];
    swift_unknownObjectRetain();
    v17 = sub_217E205B0((uint64_t)&v52, v8, v9, v10);
    v18 = *((_QWORD *)v52 + 2);
    if (v18 < v17)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v17, v18);
      v2 = v52;
      if (!v52)
      {
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        goto LABEL_15;
      }
      v47 = 0;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_11:
        v20 = *((_QWORD *)v2 + 2);
        v19 = *((_QWORD *)v2 + 3);
        if (v20 >= v19 >> 1)
          v2 = sub_217E0E3D4((char *)(v19 > 1), v20 + 1, 1, v2);
        *((_QWORD *)v2 + 2) = v20 + 1;
        v21 = &v2[64 * v20];
        *((_QWORD *)v21 + 4) = v7;
        *((_QWORD *)v21 + 5) = v8;
        *((_QWORD *)v21 + 6) = v9;
        *((_QWORD *)v21 + 7) = v10;
        *((_QWORD *)v21 + 8) = v12;
        *((_QWORD *)v21 + 9) = v14;
        *((_QWORD *)v21 + 10) = v49;
        *((_QWORD *)v21 + 11) = v48;
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        v52 = v2;
        v11 = v47;
LABEL_15:
        v22 = v50;
        result = (char *)*((_QWORD *)v50 + 3);
        if (result == (char *)1)
        {
          __break(1u);
          return result;
        }
        v23 = (char *)swift_bridgeObjectRetain();
        v24 = sub_217E14180(v23);
        if (v11)
        {
          sub_217E04E40();
          swift_allocError();
          *v28 = 22;
          swift_willThrow();
          MEMORY[0x219A18338](v11);
          return (char *)swift_bridgeObjectRelease();
        }
        v29 = v24;
        v30 = v26;
        v31 = v27;
        v46 = v25;
        v32 = qword_254F27550;
        swift_unknownObjectRetain();
        if (v32 != -1)
          swift_once();
        v34 = qword_254F2BEA8;
        v33 = qword_254F2BEB0;
        v35 = qword_254F2BEB8;
        v36 = qword_254F2BEC0;
        v37 = (char *)MEMORY[0x24BEE4AF8];
        if (v2)
          v37 = v2;
        v52 = v37;
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        v38 = sub_217E205B0((uint64_t)&v52, v33, v35, v36);
        v39 = *((_QWORD *)v52 + 2);
        if (v39 < v38)
        {
          __break(1u);
        }
        else
        {
          sub_217E208C8(v38, v39);
          v11 = v52;
          if (!v52)
          {
            swift_unknownObjectRelease_n();
            swift_unknownObjectRelease();
LABEL_30:
            v51 = *((_DWORD *)v22 + 4);
            v43 = sub_217E16E24(&v51, v11);
            swift_bridgeObjectRelease();
            v44 = sub_217E147CC(v43, 17, 0);
            v45 = *((_QWORD *)v22 + 3);
            *((_QWORD *)v22 + 3) = v44;
            return (char *)sub_217E21274(v45);
          }
          swift_unknownObjectRetain();
          swift_unknownObjectRetain();
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
          {
LABEL_26:
            v41 = *((_QWORD *)v11 + 2);
            v40 = *((_QWORD *)v11 + 3);
            if (v41 >= v40 >> 1)
              v11 = sub_217E0E3D4((char *)(v40 > 1), v41 + 1, 1, v11);
            *((_QWORD *)v11 + 2) = v41 + 1;
            v42 = &v11[64 * v41];
            *((_QWORD *)v42 + 4) = v34;
            *((_QWORD *)v42 + 5) = v33;
            *((_QWORD *)v42 + 6) = v35;
            *((_QWORD *)v42 + 7) = v36;
            *((_QWORD *)v42 + 8) = v29;
            *((_QWORD *)v42 + 9) = v46;
            *((_QWORD *)v42 + 10) = v30;
            *((_QWORD *)v42 + 11) = v31;
            swift_unknownObjectRelease_n();
            swift_unknownObjectRelease();
            v22 = v50;
            goto LABEL_30;
          }
        }
        v11 = sub_217E0E3D4(0, *((_QWORD *)v11 + 2) + 1, 1, v11);
        goto LABEL_26;
      }
    }
    v2 = sub_217E0E3D4(0, *((_QWORD *)v2 + 2) + 1, 1, v2);
    goto LABEL_11;
  }
  return result;
}

uint64_t sub_217E1A3C0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t result;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  int64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  int v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;

  v4 = v2;
  if (qword_254F27590 != -1)
    swift_once();
  v6 = sub_217E1738C(qword_254F2BFA8, qword_254F2BFB0, qword_254F2BFB8, unk_254F2BFC0, a2);
  if (v3)
    return v4;
  v47 = v6;
  if (qword_254F274F8 != -1)
    swift_once();
  v37 = xmmword_254F2BD48;
  v7 = qword_254F2BD58;
  v8 = qword_254F2BD60;
  swift_bridgeObjectRetain();
  v9 = sub_217E204F8();
  v11 = v10;
  v13 = v12;
  v15 = v14;
  swift_bridgeObjectRelease();
  v40 = v37;
  v41 = v7;
  v42 = v8;
  v43 = v9;
  v44 = v11;
  v45 = v13;
  v46 = v15;
  swift_unknownObjectRetain();
  v16 = (char *)&v47;
  sub_217E043A0((uint64_t)&v40);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  result = *(_QWORD *)(v4 + 24);
  if (result != 1)
  {
    v18 = (char *)swift_bridgeObjectRetain();
    v19 = sub_217E14180(v18);
    v21 = v20;
    v36 = v23;
    v38 = v22;
    v24 = qword_254F27550;
    swift_unknownObjectRetain();
    if (v24 != -1)
      swift_once();
    v25 = qword_254F2BEA8;
    v26 = qword_254F2BEB0;
    v27 = qword_254F2BEB8;
    v28 = qword_254F2BEC0;
    v29 = v47;
    if (!v47)
      v29 = (char *)MEMORY[0x24BEE4AF8];
    v47 = v29;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v30 = sub_217E205B0((uint64_t)&v47, v26, v27, v28);
    v31 = *((_QWORD *)v47 + 2);
    if (v31 < v30)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v30, v31);
      v16 = v47;
      if (!v47)
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
LABEL_20:
        v39 = *(_DWORD *)(v4 + 16);
        v4 = sub_217E16E24(&v39, v16);
        swift_bridgeObjectRelease();
        return v4;
      }
      v35 = v21;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_16:
        v33 = *((_QWORD *)v16 + 2);
        v32 = *((_QWORD *)v16 + 3);
        if (v33 >= v32 >> 1)
          v16 = sub_217E0E3D4((char *)(v32 > 1), v33 + 1, 1, v16);
        *((_QWORD *)v16 + 2) = v33 + 1;
        v34 = &v16[64 * v33];
        *((_QWORD *)v34 + 4) = v25;
        *((_QWORD *)v34 + 5) = v26;
        *((_QWORD *)v34 + 6) = v27;
        *((_QWORD *)v34 + 7) = v28;
        *((_QWORD *)v34 + 8) = v19;
        *((_QWORD *)v34 + 9) = v35;
        *((_QWORD *)v34 + 10) = v38;
        *((_QWORD *)v34 + 11) = v36;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        goto LABEL_20;
      }
    }
    v16 = sub_217E0E3D4(0, *((_QWORD *)v16 + 2) + 1, 1, v16);
    goto LABEL_16;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E1A730(uint64_t a1, uint64_t a2)
{
  char *v2;
  uint64_t v3;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  unint64_t v9;
  char v10;
  char v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int64_t v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  int64_t v37;
  char *v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  char *v42;
  char *v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  _BYTE *v47;
  uint64_t result;
  char *v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  uint64_t v57;
  int64_t v58;
  unint64_t v59;
  unint64_t v60;
  char *v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  char *v70;
  int v71;
  unint64_t v72;
  char v73;
  uint64_t v74;
  _BYTE v75[48];
  _BYTE v76[56];
  char *v77;

  v5 = a1 + 32;
  v6 = (2 * *(_QWORD *)(a1 + 16)) | 1;
  v7 = swift_bridgeObjectRetain();
  sub_217E09CBC(v7, v5, 0, v6, (uint64_t)&v72);
  swift_bridgeObjectRelease();
  if (v3)
  {
    sub_217E04E40();
    swift_allocError();
    *v8 = 10;
    swift_willThrow();
    MEMORY[0x219A18338](v3);
    return a2;
  }
  v77 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  v9 = v72;
  v10 = v73;
  sub_217E04CC0((uint64_t)&v74, (uint64_t)v75);
  sub_217E04CC0((uint64_t)v75, (uint64_t)v76);
  v11 = v76[40];
  sub_217E21234((uint64_t)&v72);
  sub_217E0833C(v9, v10, (v11 & 1) == 0, (uint64_t)&v77, (uint64_t)&v72);
  sub_217E09BF8((uint64_t)&v72);
  v12 = v77;
  v13 = *((_QWORD *)v77 + 2);
  sub_217E09BF8((uint64_t)&v72);
  v14 = qword_254F27598;
  swift_unknownObjectRetain();
  if (v14 != -1)
    swift_once();
  v15 = sub_217E1738C(qword_254F2BFC8, unk_254F2BFD0, xmmword_254F2BFD8, *((char **)&xmmword_254F2BFD8 + 1), a2);
  v69 = v13;
  v70 = v2;
  v77 = v15;
  if (qword_254F276B0 != -1)
    swift_once();
  v16 = qword_254F2C428;
  v17 = qword_254F2C430;
  v18 = qword_254F2C438;
  v19 = unk_254F2C440;
  v20 = 0;
  v21 = sub_217E1400C();
  v63 = v23;
  v65 = v22;
  v67 = v24;
  v68 = v19;
  if (!v15)
    v77 = (char *)MEMORY[0x24BEE4AF8];
  swift_unknownObjectRetain();
  v25 = v17;
  v26 = v17;
  v27 = v18;
  v28 = sub_217E205B0((uint64_t)&v77, v26, v18, v68);
  v29 = *((_QWORD *)v77 + 2);
  if (v29 < v28)
  {
    __break(1u);
    goto LABEL_44;
  }
  sub_217E208C8(v28, v29);
  v2 = v77;
  if (!v77)
  {
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    goto LABEL_16;
  }
  v62 = 0;
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
    goto LABEL_46;
  while (1)
  {
    v31 = *((_QWORD *)v2 + 2);
    v30 = *((_QWORD *)v2 + 3);
    if (v31 >= v30 >> 1)
      v2 = sub_217E0E3D4((char *)(v30 > 1), v31 + 1, 1, v2);
    *((_QWORD *)v2 + 2) = v31 + 1;
    v32 = &v2[64 * v31];
    *((_QWORD *)v32 + 4) = v16;
    *((_QWORD *)v32 + 5) = v25;
    *((_QWORD *)v32 + 6) = v27;
    *((_QWORD *)v32 + 7) = v68;
    *((_QWORD *)v32 + 8) = v21;
    *((_QWORD *)v32 + 9) = v67;
    *((_QWORD *)v32 + 10) = v65;
    *((_QWORD *)v32 + 11) = v63;
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    v77 = v2;
    v20 = v62;
LABEL_16:
    if (qword_254F274F8 != -1)
LABEL_44:
      swift_once();
    v33 = *((_QWORD *)&xmmword_254F2BD48 + 1);
    v16 = xmmword_254F2BD48;
    v21 = (char *)qword_254F2BD58;
    v25 = qword_254F2BD60;
    v34 = v77;
    if (!v77)
      v34 = (char *)MEMORY[0x24BEE4AF8];
    v77 = v34;
    swift_bridgeObjectRetain();
    swift_unknownObjectRetain();
    v35 = v20;
    v36 = sub_217E205B0((uint64_t)&v77, v33, (uint64_t)v21, v25);
    v37 = *((_QWORD *)v77 + 2);
    if (v37 >= v36)
      break;
    __break(1u);
LABEL_46:
    v2 = sub_217E0E3D4(0, *((_QWORD *)v2 + 2) + 1, 1, v2);
  }
  sub_217E208C8(v36, v37);
  v38 = v77;
  if (v77)
  {
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      v38 = sub_217E0E3D4(0, *((_QWORD *)v38 + 2) + 1, 1, v38);
    v40 = *((_QWORD *)v38 + 2);
    v39 = *((_QWORD *)v38 + 3);
    if (v40 >= v39 >> 1)
      v38 = sub_217E0E3D4((char *)(v39 > 1), v40 + 1, 1, v38);
    *((_QWORD *)v38 + 2) = v40 + 1;
    v41 = &v38[64 * v40];
    *((_QWORD *)v41 + 4) = v16;
    *((_QWORD *)v41 + 5) = v33;
    *((_QWORD *)v41 + 6) = v21;
    *((_QWORD *)v41 + 7) = v25;
    *((_QWORD *)v41 + 8) = v12;
    *((_QWORD *)v41 + 9) = v12 + 32;
    *((_QWORD *)v41 + 10) = 0;
    *((_QWORD *)v41 + 11) = (2 * v69) | 1;
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    v77 = v38;
    v20 = v35;
  }
  else
  {
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
  }
  if (*((_QWORD *)v70 + 3) != 1)
  {
    v42 = (char *)swift_bridgeObjectRetain();
    v43 = sub_217E14180(v42);
    if (v20)
    {
      sub_217E04E40();
      swift_allocError();
      *v47 = 22;
      swift_willThrow();
      MEMORY[0x219A18338](v20);
      a2 = (uint64_t)v77;
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      return a2;
    }
    v49 = v43;
    v50 = v44;
    v64 = v46;
    v66 = v45;
    v51 = qword_254F27550;
    swift_unknownObjectRetain();
    if (v51 != -1)
      swift_once();
    v53 = qword_254F2BEA8;
    v52 = qword_254F2BEB0;
    v54 = qword_254F2BEB8;
    v55 = qword_254F2BEC0;
    v56 = (char *)MEMORY[0x24BEE4AF8];
    if (v38)
      v56 = v38;
    v77 = v56;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v57 = sub_217E205B0((uint64_t)&v77, v52, v54, v55);
    v58 = *((_QWORD *)v77 + 2);
    if (v58 < v57)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v57, v58);
      v20 = v77;
      if (!v77)
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        v20 = v77;
LABEL_42:
        v71 = *((_DWORD *)v70 + 4);
        a2 = sub_217E16E24(&v71, v20);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        return a2;
      }
      v62 = v50;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_38:
        v60 = *((_QWORD *)v20 + 2);
        v59 = *((_QWORD *)v20 + 3);
        if (v60 >= v59 >> 1)
          v20 = sub_217E0E3D4((char *)(v59 > 1), v60 + 1, 1, v20);
        *((_QWORD *)v20 + 2) = v60 + 1;
        v61 = &v20[64 * v60];
        *((_QWORD *)v61 + 4) = v53;
        *((_QWORD *)v61 + 5) = v52;
        *((_QWORD *)v61 + 6) = v54;
        *((_QWORD *)v61 + 7) = v55;
        *((_QWORD *)v61 + 8) = v49;
        *((_QWORD *)v61 + 9) = v62;
        *((_QWORD *)v61 + 10) = v66;
        *((_QWORD *)v61 + 11) = v64;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        goto LABEL_42;
      }
    }
    v20 = sub_217E0E3D4(0, *((_QWORD *)v20 + 2) + 1, 1, v20);
    goto LABEL_38;
  }
  __break(1u);
  sub_217E09BF8(1);
  result = swift_unexpectedError();
  __break(1u);
  return result;
}

char *sub_217E1AE70(int *a1, uint64_t a2)
{
  char *v2;
  uint64_t v3;
  int v5;
  char *result;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t v38;
  int64_t v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  char *v51;
  int v52;
  char *v53;

  v5 = *a1;
  if (qword_254F275B0 != -1)
    swift_once();
  result = sub_217E1738C(qword_254F2C028, qword_254F2C030, qword_254F2C038, unk_254F2C040, a2);
  if (!v3)
  {
    v7 = result;
    v50 = v5;
    v51 = v2;
    v53 = result;
    if (qword_254F275D8 != -1)
      swift_once();
    v8 = qword_254F2C0C8;
    v9 = unk_254F2C0D0;
    v10 = xmmword_254F2C0D8;
    v11 = 0;
    v12 = sub_217E1400C();
    v14 = v13;
    v48 = v16;
    v49 = v15;
    if (!v7)
      v53 = (char *)MEMORY[0x24BEE4AF8];
    swift_unknownObjectRetain();
    v17 = sub_217E205B0((uint64_t)&v53, v9, v10, *((unint64_t *)&v10 + 1));
    v18 = *((_QWORD *)v53 + 2);
    if (v18 < v17)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v17, v18);
      v2 = v53;
      if (!v53)
      {
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        goto LABEL_15;
      }
      v47 = 0;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_11:
        v20 = *((_QWORD *)v2 + 2);
        v19 = *((_QWORD *)v2 + 3);
        if (v20 >= v19 >> 1)
          v2 = sub_217E0E3D4((char *)(v19 > 1), v20 + 1, 1, v2);
        *((_QWORD *)v2 + 2) = v20 + 1;
        v21 = &v2[64 * v20];
        *((_QWORD *)v21 + 4) = v8;
        *((_QWORD *)v21 + 5) = v9;
        *((_OWORD *)v21 + 3) = v10;
        *((_QWORD *)v21 + 8) = v12;
        *((_QWORD *)v21 + 9) = v14;
        *((_QWORD *)v21 + 10) = v49;
        *((_QWORD *)v21 + 11) = v48;
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        v53 = v2;
        v11 = v47;
LABEL_15:
        v22 = v51;
        result = (char *)*((_QWORD *)v51 + 3);
        if (result == (char *)1)
        {
          __break(1u);
          return result;
        }
        v23 = (char *)swift_bridgeObjectRetain();
        v24 = sub_217E14180(v23);
        if (v11)
        {
          sub_217E04E40();
          swift_allocError();
          *v28 = 22;
          swift_willThrow();
          MEMORY[0x219A18338](v11);
          return (char *)swift_bridgeObjectRelease();
        }
        v29 = v24;
        v30 = v26;
        v31 = v27;
        v46 = v25;
        v32 = qword_254F27550;
        swift_unknownObjectRetain();
        if (v32 != -1)
          swift_once();
        v34 = qword_254F2BEA8;
        v33 = qword_254F2BEB0;
        v35 = qword_254F2BEB8;
        v36 = qword_254F2BEC0;
        v37 = (char *)MEMORY[0x24BEE4AF8];
        if (v2)
          v37 = v2;
        v53 = v37;
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        v38 = sub_217E205B0((uint64_t)&v53, v33, v35, v36);
        v39 = *((_QWORD *)v53 + 2);
        if (v39 < v38)
        {
          __break(1u);
        }
        else
        {
          sub_217E208C8(v38, v39);
          v11 = v53;
          if (!v53)
          {
            swift_unknownObjectRelease_n();
            swift_unknownObjectRelease();
LABEL_30:
            v52 = *((_DWORD *)v22 + 4);
            v43 = sub_217E16E24(&v52, v11);
            swift_bridgeObjectRelease();
            *((_DWORD *)v22 + 4) = v50;
            v44 = sub_217E147CC(v43, 17, 0);
            v45 = *((_QWORD *)v22 + 3);
            *((_QWORD *)v22 + 3) = v44;
            return (char *)sub_217E21274(v45);
          }
          swift_unknownObjectRetain();
          swift_unknownObjectRetain();
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
          {
LABEL_26:
            v41 = *((_QWORD *)v11 + 2);
            v40 = *((_QWORD *)v11 + 3);
            if (v41 >= v40 >> 1)
              v11 = sub_217E0E3D4((char *)(v40 > 1), v41 + 1, 1, v11);
            *((_QWORD *)v11 + 2) = v41 + 1;
            v42 = &v11[64 * v41];
            *((_QWORD *)v42 + 4) = v34;
            *((_QWORD *)v42 + 5) = v33;
            *((_QWORD *)v42 + 6) = v35;
            *((_QWORD *)v42 + 7) = v36;
            *((_QWORD *)v42 + 8) = v29;
            *((_QWORD *)v42 + 9) = v46;
            *((_QWORD *)v42 + 10) = v30;
            *((_QWORD *)v42 + 11) = v31;
            swift_unknownObjectRelease_n();
            swift_unknownObjectRelease();
            v22 = v51;
            goto LABEL_30;
          }
        }
        v11 = sub_217E0E3D4(0, *((_QWORD *)v11 + 2) + 1, 1, v11);
        goto LABEL_26;
      }
    }
    v2 = sub_217E0E3D4(0, *((_QWORD *)v2 + 2) + 1, 1, v2);
    goto LABEL_11;
  }
  return result;
}

uint64_t sub_217E1B310(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int64_t v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  __int128 v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t result;
  char *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  int64_t v49;
  unint64_t v50;
  unint64_t v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  __int128 v57;
  uint64_t v58;
  int v59;
  _OWORD v60[2];
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;

  if (qword_254F275A0 != -1)
    swift_once();
  v6 = sub_217E1738C(qword_254F2BFE8, qword_254F2BFF0, xmmword_254F2BFF8, *((char **)&xmmword_254F2BFF8 + 1), a2);
  if (v3)
    return a1;
  v7 = v6;
  v58 = v2;
  v65 = v6;
  if (qword_254F276B0 != -1)
    swift_once();
  v9 = qword_254F2C428;
  v8 = qword_254F2C430;
  v10 = qword_254F2C438;
  v11 = unk_254F2C440;
  v12 = sub_217E1400C();
  v14 = v13;
  v54 = v16;
  v56 = v15;
  if (!v7)
    v65 = (char *)MEMORY[0x24BEE4AF8];
  swift_unknownObjectRetain();
  v17 = v8;
  v18 = sub_217E205B0((uint64_t)&v65, v8, v10, v11);
  v19 = *((_QWORD *)v65 + 2);
  if (v19 < v18)
  {
    __break(1u);
LABEL_33:
    swift_once();
    goto LABEL_17;
  }
  sub_217E208C8(v18, v19);
  v20 = v65;
  if (v65)
  {
    v53 = v14;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      v20 = sub_217E0E3D4(0, *((_QWORD *)v20 + 2) + 1, 1, v20);
    v22 = *((_QWORD *)v20 + 2);
    v21 = *((_QWORD *)v20 + 3);
    if (v22 >= v21 >> 1)
      v20 = sub_217E0E3D4((char *)(v21 > 1), v22 + 1, 1, v20);
    *((_QWORD *)v20 + 2) = v22 + 1;
    v23 = &v20[64 * v22];
    *((_QWORD *)v23 + 4) = v9;
    *((_QWORD *)v23 + 5) = v17;
    *((_QWORD *)v23 + 6) = v10;
    *((_QWORD *)v23 + 7) = v11;
    *((_QWORD *)v23 + 8) = v12;
    *((_QWORD *)v23 + 9) = v53;
    *((_QWORD *)v23 + 10) = v56;
    *((_QWORD *)v23 + 11) = v54;
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    v65 = v20;
  }
  else
  {
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
  }
  if (qword_254F27530 != -1)
    goto LABEL_33;
LABEL_17:
  v57 = xmmword_254F2BE28;
  v24 = xmmword_254F2BE38;
  swift_bridgeObjectRetain();
  v25 = sub_217E204F8();
  v27 = v26;
  v29 = v28;
  v31 = v30;
  swift_bridgeObjectRelease();
  v60[0] = v57;
  v60[1] = v24;
  v61 = v25;
  v62 = v27;
  v63 = v29;
  v64 = v31;
  swift_unknownObjectRetain();
  v32 = (char *)&v65;
  sub_217E043A0((uint64_t)v60);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  result = *(_QWORD *)(v58 + 24);
  if (result != 1)
  {
    v34 = (char *)swift_bridgeObjectRetain();
    v35 = sub_217E14180(v34);
    v37 = v36;
    v39 = v38;
    v41 = v40;
    v42 = qword_254F27550;
    swift_unknownObjectRetain();
    if (v42 != -1)
      swift_once();
    v44 = qword_254F2BEA8;
    v43 = qword_254F2BEB0;
    v46 = qword_254F2BEB8;
    v45 = qword_254F2BEC0;
    v47 = v65;
    if (!v65)
      v47 = (char *)MEMORY[0x24BEE4AF8];
    v65 = v47;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v55 = v45;
    v48 = sub_217E205B0((uint64_t)&v65, v43, v46, v45);
    v49 = *((_QWORD *)v65 + 2);
    if (v49 < v48)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v48, v49);
      v32 = v65;
      if (!v65)
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
LABEL_31:
        v59 = *(_DWORD *)(v58 + 16);
        a1 = sub_217E16E24(&v59, v32);
        swift_bridgeObjectRelease();
        return a1;
      }
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_27:
        v51 = *((_QWORD *)v32 + 2);
        v50 = *((_QWORD *)v32 + 3);
        if (v51 >= v50 >> 1)
          v32 = sub_217E0E3D4((char *)(v50 > 1), v51 + 1, 1, v32);
        *((_QWORD *)v32 + 2) = v51 + 1;
        v52 = &v32[64 * v51];
        *((_QWORD *)v52 + 4) = v44;
        *((_QWORD *)v52 + 5) = v43;
        *((_QWORD *)v52 + 6) = v46;
        *((_QWORD *)v52 + 7) = v55;
        *((_QWORD *)v52 + 8) = v35;
        *((_QWORD *)v52 + 9) = v37;
        *((_QWORD *)v52 + 10) = v39;
        *((_QWORD *)v52 + 11) = v41;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        goto LABEL_31;
      }
    }
    v32 = sub_217E0E3D4(0, *((_QWORD *)v32 + 2) + 1, 1, v32);
    goto LABEL_27;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E1B804(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  char *v6;
  __int128 v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t result;
  char *v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  int64_t v42;
  unint64_t v43;
  unint64_t v44;
  char *v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  int v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _OWORD v57[2];
  char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;

  if (qword_254F275C0 != -1)
    swift_once();
  v6 = sub_217E1738C(qword_254F2C068, qword_254F2C070, qword_254F2C078, unk_254F2C080, a3);
  if (v4)
    return a3;
  v46 = v3;
  v62 = v6;
  if (qword_254F27530 != -1)
    swift_once();
  v47 = xmmword_254F2BE28;
  v7 = xmmword_254F2BE38;
  swift_bridgeObjectRetain();
  v8 = sub_217E204F8();
  v10 = v9;
  v12 = v11;
  v14 = v13;
  v15 = 0;
  swift_bridgeObjectRelease();
  v57[0] = v47;
  v57[1] = v7;
  v58 = v8;
  v59 = v10;
  v60 = v12;
  v61 = v14;
  swift_unknownObjectRetain();
  sub_217E043A0((uint64_t)v57);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  if (qword_254F274F8 != -1)
    swift_once();
  v48 = xmmword_254F2BD48;
  v16 = qword_254F2BD58;
  v17 = qword_254F2BD60;
  swift_bridgeObjectRetain();
  v18 = sub_217E204F8();
  v20 = v19;
  v22 = v21;
  v24 = v23;
  swift_bridgeObjectRelease();
  v50 = v48;
  v51 = v16;
  v52 = v17;
  v53 = v18;
  v54 = v20;
  v55 = v22;
  v56 = v24;
  swift_unknownObjectRetain();
  sub_217E043A0((uint64_t)&v50);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  v25 = v46;
  result = *(_QWORD *)(v46 + 24);
  if (result != 1)
  {
    v27 = (char *)swift_bridgeObjectRetain();
    v28 = sub_217E14180(v27);
    v30 = v29;
    v32 = v31;
    v34 = v33;
    v35 = qword_254F27550;
    swift_unknownObjectRetain();
    if (v35 != -1)
      swift_once();
    v36 = qword_254F2BEA8;
    v37 = qword_254F2BEB0;
    v39 = qword_254F2BEB8;
    v38 = qword_254F2BEC0;
    v40 = v62;
    if (!v62)
      v40 = (char *)MEMORY[0x24BEE4AF8];
    v62 = v40;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v41 = sub_217E205B0((uint64_t)&v62, v37, v39, v38);
    v42 = *((_QWORD *)v62 + 2);
    if (v42 < v41)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v41, v42);
      v15 = v62;
      if (!v62)
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
LABEL_22:
        v49 = *(_DWORD *)(v25 + 16);
        a3 = sub_217E16E24(&v49, v15);
        swift_bridgeObjectRelease();
        return a3;
      }
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_18:
        v44 = *((_QWORD *)v15 + 2);
        v43 = *((_QWORD *)v15 + 3);
        if (v44 >= v43 >> 1)
          v15 = sub_217E0E3D4((char *)(v43 > 1), v44 + 1, 1, v15);
        *((_QWORD *)v15 + 2) = v44 + 1;
        v45 = &v15[64 * v44];
        *((_QWORD *)v45 + 4) = v36;
        *((_QWORD *)v45 + 5) = v37;
        *((_QWORD *)v45 + 6) = v39;
        *((_QWORD *)v45 + 7) = v38;
        *((_QWORD *)v45 + 8) = v28;
        *((_QWORD *)v45 + 9) = v30;
        *((_QWORD *)v45 + 10) = v32;
        *((_QWORD *)v45 + 11) = v34;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        v25 = v46;
        goto LABEL_22;
      }
    }
    v15 = sub_217E0E3D4(0, *((_QWORD *)v15 + 2) + 1, 1, v15);
    goto LABEL_18;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E1BC44(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t result;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  int64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  int v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;

  v4 = v2;
  if (qword_254F275C8 != -1)
    swift_once();
  v6 = sub_217E1738C(qword_254F2C088, qword_254F2C090, qword_254F2C098, unk_254F2C0A0, a2);
  if (v3)
    return v4;
  v47 = v6;
  if (qword_254F274F8 != -1)
    swift_once();
  v37 = xmmword_254F2BD48;
  v7 = qword_254F2BD58;
  v8 = qword_254F2BD60;
  swift_bridgeObjectRetain();
  v9 = sub_217E204F8();
  v11 = v10;
  v13 = v12;
  v15 = v14;
  swift_bridgeObjectRelease();
  v40 = v37;
  v41 = v7;
  v42 = v8;
  v43 = v9;
  v44 = v11;
  v45 = v13;
  v46 = v15;
  swift_unknownObjectRetain();
  v16 = (char *)&v47;
  sub_217E043A0((uint64_t)&v40);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  result = *(_QWORD *)(v4 + 24);
  if (result != 1)
  {
    v18 = (char *)swift_bridgeObjectRetain();
    v19 = sub_217E14180(v18);
    v21 = v20;
    v36 = v23;
    v38 = v22;
    v24 = qword_254F27550;
    swift_unknownObjectRetain();
    if (v24 != -1)
      swift_once();
    v25 = qword_254F2BEA8;
    v26 = qword_254F2BEB0;
    v27 = qword_254F2BEB8;
    v28 = qword_254F2BEC0;
    v29 = v47;
    if (!v47)
      v29 = (char *)MEMORY[0x24BEE4AF8];
    v47 = v29;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v30 = sub_217E205B0((uint64_t)&v47, v26, v27, v28);
    v31 = *((_QWORD *)v47 + 2);
    if (v31 < v30)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v30, v31);
      v16 = v47;
      if (!v47)
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
LABEL_20:
        v39 = *(_DWORD *)(v4 + 16);
        v4 = sub_217E16E24(&v39, v16);
        swift_bridgeObjectRelease();
        return v4;
      }
      v35 = v21;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_16:
        v33 = *((_QWORD *)v16 + 2);
        v32 = *((_QWORD *)v16 + 3);
        if (v33 >= v32 >> 1)
          v16 = sub_217E0E3D4((char *)(v32 > 1), v33 + 1, 1, v16);
        *((_QWORD *)v16 + 2) = v33 + 1;
        v34 = &v16[64 * v33];
        *((_QWORD *)v34 + 4) = v25;
        *((_QWORD *)v34 + 5) = v26;
        *((_QWORD *)v34 + 6) = v27;
        *((_QWORD *)v34 + 7) = v28;
        *((_QWORD *)v34 + 8) = v19;
        *((_QWORD *)v34 + 9) = v35;
        *((_QWORD *)v34 + 10) = v38;
        *((_QWORD *)v34 + 11) = v36;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        goto LABEL_20;
      }
    }
    v16 = sub_217E0E3D4(0, *((_QWORD *)v16 + 2) + 1, 1, v16);
    goto LABEL_16;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E1BFB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  char *v6;
  __int128 v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t result;
  char *v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  int64_t v42;
  unint64_t v43;
  unint64_t v44;
  char *v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  int v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _OWORD v57[2];
  char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;

  if (qword_254F275D0 != -1)
    swift_once();
  v6 = sub_217E1738C(qword_254F2C0A8, qword_254F2C0B0, qword_254F2C0B8, unk_254F2C0C0, a3);
  if (v4)
    return a3;
  v46 = v3;
  v62 = v6;
  if (qword_254F27530 != -1)
    swift_once();
  v47 = xmmword_254F2BE28;
  v7 = xmmword_254F2BE38;
  swift_bridgeObjectRetain();
  v8 = sub_217E204F8();
  v10 = v9;
  v12 = v11;
  v14 = v13;
  v15 = 0;
  swift_bridgeObjectRelease();
  v57[0] = v47;
  v57[1] = v7;
  v58 = v8;
  v59 = v10;
  v60 = v12;
  v61 = v14;
  swift_unknownObjectRetain();
  sub_217E043A0((uint64_t)v57);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  if (qword_254F274F8 != -1)
    swift_once();
  v48 = xmmword_254F2BD48;
  v16 = qword_254F2BD58;
  v17 = qword_254F2BD60;
  swift_bridgeObjectRetain();
  v18 = sub_217E204F8();
  v20 = v19;
  v22 = v21;
  v24 = v23;
  swift_bridgeObjectRelease();
  v50 = v48;
  v51 = v16;
  v52 = v17;
  v53 = v18;
  v54 = v20;
  v55 = v22;
  v56 = v24;
  swift_unknownObjectRetain();
  sub_217E043A0((uint64_t)&v50);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  v25 = v46;
  result = *(_QWORD *)(v46 + 24);
  if (result != 1)
  {
    v27 = (char *)swift_bridgeObjectRetain();
    v28 = sub_217E14180(v27);
    v30 = v29;
    v32 = v31;
    v34 = v33;
    v35 = qword_254F27550;
    swift_unknownObjectRetain();
    if (v35 != -1)
      swift_once();
    v36 = qword_254F2BEA8;
    v37 = qword_254F2BEB0;
    v39 = qword_254F2BEB8;
    v38 = qword_254F2BEC0;
    v40 = v62;
    if (!v62)
      v40 = (char *)MEMORY[0x24BEE4AF8];
    v62 = v40;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v41 = sub_217E205B0((uint64_t)&v62, v37, v39, v38);
    v42 = *((_QWORD *)v62 + 2);
    if (v42 < v41)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v41, v42);
      v15 = v62;
      if (!v62)
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
LABEL_22:
        v49 = *(_DWORD *)(v25 + 16);
        a3 = sub_217E16E24(&v49, v15);
        swift_bridgeObjectRelease();
        return a3;
      }
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_18:
        v44 = *((_QWORD *)v15 + 2);
        v43 = *((_QWORD *)v15 + 3);
        if (v44 >= v43 >> 1)
          v15 = sub_217E0E3D4((char *)(v43 > 1), v44 + 1, 1, v15);
        *((_QWORD *)v15 + 2) = v44 + 1;
        v45 = &v15[64 * v44];
        *((_QWORD *)v45 + 4) = v36;
        *((_QWORD *)v45 + 5) = v37;
        *((_QWORD *)v45 + 6) = v39;
        *((_QWORD *)v45 + 7) = v38;
        *((_QWORD *)v45 + 8) = v28;
        *((_QWORD *)v45 + 9) = v30;
        *((_QWORD *)v45 + 10) = v32;
        *((_QWORD *)v45 + 11) = v34;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        v25 = v46;
        goto LABEL_22;
      }
    }
    v15 = sub_217E0E3D4(0, *((_QWORD *)v15 + 2) + 1, 1, v15);
    goto LABEL_18;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E1C3F4@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  __int128 v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  char *v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  __int128 v66;
  unint64_t v67;
  int v68;
  uint64_t v69;
  _BYTE v70[32];
  __int128 v71;
  __int128 v72;
  _BYTE v73[32];
  __int128 v74;
  __int128 v75;
  _OWORD v76[2];
  _OWORD v77[2];
  _OWORD v78[2];
  unint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t *v83;

  v4 = v2;
  if (qword_254F27760 != -1)
    swift_once();
  result = (uint64_t)sub_217E1738C(qword_254F2C6E8, unk_254F2C6F0, xmmword_254F2C6F8, *((char **)&xmmword_254F2C6F8 + 1), a1);
  if (v3)
    return result;
  v83 = a2;
  v69 = result;
  if (qword_254F27530 != -1)
    swift_once();
  v66 = xmmword_254F2BE28;
  v8 = xmmword_254F2BE38;
  swift_bridgeObjectRetain();
  v9 = (unint64_t)sub_217E204F8();
  v11 = v10;
  v13 = v12;
  v15 = v14;
  v16 = 0;
  swift_bridgeObjectRelease();
  v78[0] = v66;
  v78[1] = v8;
  v79 = v9;
  v80 = v11;
  v17 = v66;
  v81 = v13;
  v82 = v15;
  swift_unknownObjectRetain();
  sub_217E043A0((uint64_t)v78);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  if (*(_QWORD *)(v4 + 24) == 1)
  {
    __break(1u);
    goto LABEL_47;
  }
  v19 = 0;
  v18 = (char *)swift_bridgeObjectRetain();
  v20 = sub_217E14180(v18);
  v22 = v21;
  v24 = v23;
  v26 = v25;
  v27 = qword_254F27550;
  swift_unknownObjectRetain();
  if (v27 != -1)
    swift_once();
  v29 = qword_254F2BEA8;
  v28 = qword_254F2BEB0;
  v30 = qword_254F2BEB8;
  v31 = qword_254F2BEC0;
  v32 = v69;
  if (!v69)
    v32 = MEMORY[0x24BEE4AF8];
  v69 = v32;
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  v65 = v30;
  v33 = sub_217E205B0((uint64_t)&v69, v28, v30, v31);
  v34 = *(_QWORD *)(v69 + 16);
  if (v34 < v33)
  {
    __break(1u);
LABEL_45:
    v19 = sub_217E0E3D4(0, *((_QWORD *)v19 + 2) + 1, 1, v19);
    goto LABEL_16;
  }
  v35 = 0;
  sub_217E208C8(v33, v34);
  v19 = (char *)v69;
  if (!v69)
  {
    swift_unknownObjectRelease_n();
    swift_unknownObjectRelease();
    goto LABEL_20;
  }
  v63 = 0;
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
    goto LABEL_45;
LABEL_16:
  v37 = *((_QWORD *)v19 + 2);
  v36 = *((_QWORD *)v19 + 3);
  if (v37 >= v36 >> 1)
    v19 = sub_217E0E3D4((char *)(v36 > 1), v37 + 1, 1, v19);
  *((_QWORD *)v19 + 2) = v37 + 1;
  v38 = &v19[64 * v37];
  *((_QWORD *)v38 + 4) = v29;
  *((_QWORD *)v38 + 5) = v28;
  *((_QWORD *)v38 + 6) = v65;
  *((_QWORD *)v38 + 7) = v31;
  *((_QWORD *)v38 + 8) = v20;
  *((_QWORD *)v38 + 9) = v22;
  *((_QWORD *)v38 + 10) = v24;
  *((_QWORD *)v38 + 11) = v26;
  swift_unknownObjectRelease_n();
  swift_unknownObjectRelease();
  v69 = (uint64_t)v19;
  v35 = v63;
LABEL_20:
  v68 = *(_DWORD *)(v4 + 16);
  v39 = sub_217E16E24(&v68, v19);
  result = swift_bridgeObjectRelease();
  if (!v35)
  {
    v40 = sub_217E147CC(v39, 17, 0);
    if (qword_254F274F8 != -1)
      swift_once();
    sub_217E04998(*((uint64_t *)&xmmword_254F2BD48 + 1), qword_254F2BD58, qword_254F2BD60, (uint64_t)v40, (uint64_t)v70);
    v77[0] = v71;
    v77[1] = v72;
    v41 = *((_QWORD *)&v71 + 1);
    v42 = v72;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v70);
    if (qword_254F275A0 != -1)
      swift_once();
    sub_217E04998(qword_254F2BFF0, xmmword_254F2BFF8, *((unint64_t *)&xmmword_254F2BFF8 + 1), (uint64_t)v40, (uint64_t)v73);
    swift_bridgeObjectRelease();
    v76[0] = v74;
    v76[1] = v75;
    v43 = *((_QWORD *)&v74 + 1);
    v67 = *((_QWORD *)&v75 + 1);
    v44 = v75;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v73);
    v45 = swift_unknownObjectRetain();
    v46 = sub_217E146D4(v45, v41, v42, *((unint64_t *)&v42 + 1));
    v15 = v47;
    v16 = v48;
    v9 = v49;
    v50 = swift_unknownObjectRetain();
    v17 = sub_217E146D4(v50, v43, v44, v67);
    v11 = v51;
    v64 = v52;
    *(_QWORD *)&v66 = v53;
    if ((v9 & 1) == 0)
    {
      swift_unknownObjectRetain();
LABEL_27:
      sub_217E200CC(v46, v15, v16, v9);
      v55 = v54;
      goto LABEL_34;
    }
    sub_217E2D194();
    swift_unknownObjectRetain_n();
    v4 = v46;
    v56 = swift_dynamicCastClass();
    if (!v56)
    {
      swift_unknownObjectRelease();
      v56 = MEMORY[0x24BEE4AF8];
    }
    v57 = *(_QWORD *)(v56 + 16);
    swift_release();
    if (!__OFSUB__(v9 >> 1, v16))
    {
      if (v57 == (v9 >> 1) - v16)
      {
        v55 = swift_dynamicCastClass();
        if (!v55)
        {
          swift_unknownObjectRelease();
          v55 = MEMORY[0x24BEE4AF8];
        }
LABEL_34:
        swift_unknownObjectRelease();
        if ((v11 & 1) != 0)
        {
          sub_217E2D194();
          swift_unknownObjectRetain_n();
          v61 = swift_dynamicCastClass();
          if (!v61)
          {
            swift_unknownObjectRelease();
            v61 = MEMORY[0x24BEE4AF8];
          }
          v62 = *(_QWORD *)(v61 + 16);
          swift_release();
          if (__OFSUB__(v11 >> 1, (_QWORD)v66))
          {
            __break(1u);
          }
          else if (v62 == (v11 >> 1) - (_QWORD)v66)
          {
            v59 = swift_dynamicCastClass();
            v60 = v83;
            if (!v59)
            {
              swift_unknownObjectRelease();
              v59 = MEMORY[0x24BEE4AF8];
            }
            goto LABEL_43;
          }
          swift_unknownObjectRelease();
        }
        else
        {
          swift_unknownObjectRetain();
        }
        sub_217E200CC(v17, v64, v66, v11);
        v59 = v58;
        v60 = v83;
LABEL_43:
        swift_unknownObjectRelease();
        sub_217E09BD0((uint64_t)v77);
        sub_217E09BD0((uint64_t)v76);
        swift_unknownObjectRelease();
        result = swift_unknownObjectRelease();
        *v60 = v55;
        v60[1] = v59;
        return result;
      }
      goto LABEL_48;
    }
LABEL_47:
    __break(1u);
LABEL_48:
    v46 = v4;
    swift_unknownObjectRelease();
    goto LABEL_27;
  }
  return result;
}

uint64_t sub_217E1CB6C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t result;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  int64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  int v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;

  v4 = v2;
  if (qword_254F27768 != -1)
    swift_once();
  v6 = sub_217E1738C(qword_254F2C708, unk_254F2C710, xmmword_254F2C718, *((char **)&xmmword_254F2C718 + 1), a2);
  if (v3)
    return v4;
  v47 = v6;
  if (qword_254F274F8 != -1)
    swift_once();
  v37 = xmmword_254F2BD48;
  v7 = qword_254F2BD58;
  v8 = qword_254F2BD60;
  swift_bridgeObjectRetain();
  v9 = sub_217E204F8();
  v11 = v10;
  v13 = v12;
  v15 = v14;
  swift_bridgeObjectRelease();
  v40 = v37;
  v41 = v7;
  v42 = v8;
  v43 = v9;
  v44 = v11;
  v45 = v13;
  v46 = v15;
  swift_unknownObjectRetain();
  v16 = (char *)&v47;
  sub_217E043A0((uint64_t)&v40);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  result = *(_QWORD *)(v4 + 24);
  if (result != 1)
  {
    v18 = (char *)swift_bridgeObjectRetain();
    v19 = sub_217E14180(v18);
    v21 = v20;
    v36 = v23;
    v38 = v22;
    v24 = qword_254F27550;
    swift_unknownObjectRetain();
    if (v24 != -1)
      swift_once();
    v25 = qword_254F2BEA8;
    v26 = qword_254F2BEB0;
    v27 = qword_254F2BEB8;
    v28 = qword_254F2BEC0;
    v29 = v47;
    if (!v47)
      v29 = (char *)MEMORY[0x24BEE4AF8];
    v47 = v29;
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v30 = sub_217E205B0((uint64_t)&v47, v26, v27, v28);
    v31 = *((_QWORD *)v47 + 2);
    if (v31 < v30)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v30, v31);
      v16 = v47;
      if (!v47)
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
LABEL_20:
        v39 = *(_DWORD *)(v4 + 16);
        v4 = sub_217E16E24(&v39, v16);
        swift_bridgeObjectRelease();
        return v4;
      }
      v35 = v21;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_16:
        v33 = *((_QWORD *)v16 + 2);
        v32 = *((_QWORD *)v16 + 3);
        if (v33 >= v32 >> 1)
          v16 = sub_217E0E3D4((char *)(v32 > 1), v33 + 1, 1, v16);
        *((_QWORD *)v16 + 2) = v33 + 1;
        v34 = &v16[64 * v33];
        *((_QWORD *)v34 + 4) = v25;
        *((_QWORD *)v34 + 5) = v26;
        *((_QWORD *)v34 + 6) = v27;
        *((_QWORD *)v34 + 7) = v28;
        *((_QWORD *)v34 + 8) = v19;
        *((_QWORD *)v34 + 9) = v35;
        *((_QWORD *)v34 + 10) = v38;
        *((_QWORD *)v34 + 11) = v36;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        goto LABEL_20;
      }
    }
    v16 = sub_217E0E3D4(0, *((_QWORD *)v16 + 2) + 1, 1, v16);
    goto LABEL_16;
  }
  __break(1u);
  return result;
}

uint64_t sub_217E1CEDC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  unint64_t v22;
  uint64_t v23;
  int64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  _BYTE *v30;
  uint64_t result;
  unint64_t v32;
  char *v33;
  char v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  int64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _BYTE *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  int64_t v62;
  unint64_t v63;
  unint64_t v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  char *v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  char *v75;
  char *v76;
  unint64_t v77;
  unsigned __int8 v78;
  uint64_t v79;
  _BYTE v80[48];
  _BYTE v81[56];
  char *v82;

  if (qword_254F275A8 != -1)
    swift_once();
  v6 = sub_217E1738C(qword_254F2C008, qword_254F2C010, qword_254F2C018, unk_254F2C020, a2);
  if (v3)
    return a1;
  v7 = v6;
  v82 = v6;
  v8 = (char *)MEMORY[0x24BEE4AF8];
  v76 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  v9 = *(_QWORD *)(a1 + 24);
  if (v9 == 1)
  {
    __break(1u);
    goto LABEL_52;
  }
  v11 = 0;
  v10 = (char *)swift_bridgeObjectRetain();
  v12 = sub_217E14180(v10);
  v14 = v13;
  v16 = v15;
  v72 = v17;
  v68 = v2;
  v18 = qword_254F27550;
  swift_unknownObjectRetain();
  if (v18 != -1)
    swift_once();
  v20 = qword_254F2BEA8;
  v19 = qword_254F2BEB0;
  v21 = (char *)qword_254F2BEB8;
  v22 = qword_254F2BEC0;
  v75 = v8;
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  v70 = v21;
  v23 = sub_217E205B0((uint64_t)&v75, v19, (uint64_t)v21, v22);
  v24 = *((_QWORD *)v75 + 2);
  if (v24 < v23)
  {
    __break(1u);
LABEL_46:
    v21 = sub_217E0E3D4(0, *((_QWORD *)v21 + 2) + 1, 1, v21);
    goto LABEL_10;
  }
  sub_217E208C8(v23, v24);
  v21 = v75;
  if (!v75)
  {
    swift_unknownObjectRelease_n();
    swift_unknownObjectRelease();
    goto LABEL_14;
  }
  v69 = 0;
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
    goto LABEL_46;
LABEL_10:
  v26 = *((_QWORD *)v21 + 2);
  v25 = *((_QWORD *)v21 + 3);
  if (v26 >= v25 >> 1)
    v21 = sub_217E0E3D4((char *)(v25 > 1), v26 + 1, 1, v21);
  *((_QWORD *)v21 + 2) = v26 + 1;
  v27 = &v21[64 * v26];
  *((_QWORD *)v27 + 4) = v20;
  *((_QWORD *)v27 + 5) = v19;
  *((_QWORD *)v27 + 6) = v70;
  *((_QWORD *)v27 + 7) = v22;
  *((_QWORD *)v27 + 8) = v12;
  *((_QWORD *)v27 + 9) = v72;
  *((_QWORD *)v27 + 10) = v14;
  *((_QWORD *)v27 + 11) = v16;
  swift_unknownObjectRelease_n();
  swift_unknownObjectRelease();
  v75 = v21;
  v11 = v69;
LABEL_14:
  v28 = v11;
  sub_217E08C90(0x11uLL, 0, 1, &v76, v21);
  v29 = v11;
  swift_bridgeObjectRelease();
  a1 = (uint64_t)v76;
  if (v28)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    sub_217E04E40();
    swift_allocError();
    *v30 = 22;
    swift_willThrow();
    swift_unknownObjectRelease();
    MEMORY[0x219A18338](v29);
    return a1;
  }
  sub_217E09CBC((uint64_t)v76, (uint64_t)(v76 + 32), 0, (2 * *((_QWORD *)v76 + 2)) | 1, (uint64_t)&v77);
  swift_bridgeObjectRelease();
  v74 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  v32 = v77;
  v33 = (char *)v78;
  sub_217E04CC0((uint64_t)&v79, (uint64_t)v80);
  sub_217E04CC0((uint64_t)v80, (uint64_t)v81);
  v34 = v81[40];
  sub_217E21234((uint64_t)&v77);
  sub_217E0833C(v32, (char)v33, (v34 & 1) == 0, (uint64_t)&v74, (uint64_t)&v77);
  a1 = 0;
  sub_217E09BF8((uint64_t)&v77);
  v35 = v74;
  v36 = *((_QWORD *)v74 + 2);
  sub_217E09BF8((uint64_t)&v77);
  v37 = qword_254F274F8;
  swift_unknownObjectRetain();
  if (v37 != -1)
    swift_once();
  v38 = xmmword_254F2BD48;
  v39 = qword_254F2BD58;
  v40 = qword_254F2BD60;
  if (!v7)
    v82 = (char *)MEMORY[0x24BEE4AF8];
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  v41 = sub_217E205B0((uint64_t)&v82, *((uint64_t *)&v38 + 1), v39, v40);
  v42 = *((_QWORD *)v82 + 2);
  if (v42 < v41)
  {
    __break(1u);
LABEL_48:
    v33 = sub_217E0E3D4(0, *((_QWORD *)v33 + 2) + 1, 1, v33);
    goto LABEL_25;
  }
  sub_217E208C8(v41, v42);
  v33 = v82;
  if (!v82)
  {
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    goto LABEL_29;
  }
  v72 = 0;
  a1 = 1;
  v70 = v35 + 32;
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
    goto LABEL_48;
LABEL_25:
  v43 = a1 | (2 * v36);
  v45 = *((_QWORD *)v33 + 2);
  v44 = *((_QWORD *)v33 + 3);
  if (v45 >= v44 >> 1)
    v33 = sub_217E0E3D4((char *)(v44 > 1), v45 + 1, 1, v33);
  *((_QWORD *)v33 + 2) = v45 + 1;
  v46 = &v33[64 * v45];
  *((_OWORD *)v46 + 2) = v38;
  *((_QWORD *)v46 + 6) = v39;
  *((_QWORD *)v46 + 7) = v40;
  *((_QWORD *)v46 + 8) = v35;
  *((_QWORD *)v46 + 9) = v70;
  *((_QWORD *)v46 + 10) = 0;
  *((_QWORD *)v46 + 11) = v43;
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  v82 = v33;
  a1 = v72;
LABEL_29:
  v9 = *(_QWORD *)(v68 + 24);
  if (v9 != 1)
  {
    v47 = (char *)swift_bridgeObjectRetain();
    v48 = sub_217E14180(v47);
    if (a1)
    {
      sub_217E04E40();
      swift_allocError();
      *v52 = 22;
      swift_willThrow();
      MEMORY[0x219A18338](a1);
      swift_unknownObjectRelease();
      swift_bridgeObjectRelease();
LABEL_43:
      swift_bridgeObjectRelease();
      return a1;
    }
    v53 = v48;
    v54 = v49;
    v55 = v50;
    v73 = v51;
    v57 = qword_254F2BEA8;
    v56 = qword_254F2BEB0;
    v59 = (char *)qword_254F2BEB8;
    v58 = qword_254F2BEC0;
    v60 = (char *)MEMORY[0x24BEE4AF8];
    if (v33)
      v60 = v33;
    v82 = v60;
    swift_unknownObjectRetain_n();
    swift_unknownObjectRetain();
    v71 = v59;
    v61 = sub_217E205B0((uint64_t)&v82, v56, (uint64_t)v59, v58);
    v62 = *((_QWORD *)v82 + 2);
    if (v62 < v61)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v61, v62);
      v59 = v82;
      if (!v82)
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        v59 = v82;
LABEL_41:
        LODWORD(v74) = *(_DWORD *)(v68 + 16);
        v66 = sub_217E16E24((int *)&v74, v59);
        if (!a1)
        {
          a1 = v66;
          swift_unknownObjectRelease();
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          return a1;
        }
        swift_unknownObjectRelease();
        swift_bridgeObjectRelease();
        goto LABEL_43;
      }
      v67 = a1;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_37:
        v64 = *((_QWORD *)v59 + 2);
        v63 = *((_QWORD *)v59 + 3);
        if (v64 >= v63 >> 1)
          v59 = sub_217E0E3D4((char *)(v63 > 1), v64 + 1, 1, v59);
        *((_QWORD *)v59 + 2) = v64 + 1;
        v65 = &v59[64 * v64];
        *((_QWORD *)v65 + 4) = v57;
        *((_QWORD *)v65 + 5) = v56;
        *((_QWORD *)v65 + 6) = v71;
        *((_QWORD *)v65 + 7) = v58;
        *((_QWORD *)v65 + 8) = v53;
        *((_QWORD *)v65 + 9) = v54;
        *((_QWORD *)v65 + 10) = v55;
        *((_QWORD *)v65 + 11) = v73;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        v82 = v59;
        a1 = v67;
        goto LABEL_41;
      }
    }
    v59 = sub_217E0E3D4(0, *((_QWORD *)v59 + 2) + 1, 1, v59);
    goto LABEL_37;
  }
LABEL_52:
  __break(1u);
  sub_217E09BF8(v9);
  result = swift_unexpectedError();
  __break(1u);
  return result;
}

char *sub_217E1D690()
{
  uint64_t v0;
  uint64_t v1;
  char *result;
  char *v3;
  char *v4;
  _BYTE *v5;
  char *v6;

  result = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  v6 = result;
  v3 = *(char **)(v0 + 24);
  if (v3 == (char *)1)
  {
    __break(1u);
  }
  else
  {
    sub_217E21284((uint64_t)v3);
    sub_217E08C90(0x11uLL, 0, 1, &v6, v3);
    sub_217E21274((uint64_t)v3);
    v4 = v6;
    if (v1)
    {
      swift_bridgeObjectRelease();
      sub_217E04E40();
      swift_allocError();
      *v5 = 22;
      swift_willThrow();
      MEMORY[0x219A18338](v1);
    }
    return v4;
  }
  return result;
}

char *sub_217E1D764()
{
  uint64_t v0;
  uint64_t v1;
  char *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  char *v10;
  _BYTE v11[32];
  __int128 v12;
  __int128 v13;
  _BYTE v14[96];
  _OWORD v15[2];

  v2 = *(char **)(v0 + 24);
  if (v2 == (char *)1)
  {
    sub_217E04E40();
    swift_allocError();
    *v3 = 10;
    swift_willThrow();
  }
  else
  {
    v4 = v1;
    v5 = qword_254F27550;
    swift_bridgeObjectRetain();
    if (v5 != -1)
      swift_once();
    sub_217E04998(qword_254F2BEB0, qword_254F2BEB8, qword_254F2BEC0, (uint64_t)v2, (uint64_t)v11);
    sub_217E21274((uint64_t)v2);
    if (!v4)
    {
      v15[0] = v12;
      v15[1] = v13;
      v7 = *((_QWORD *)&v12 + 1);
      v6 = v12;
      v8 = v13;
      swift_unknownObjectRetain();
      sub_217E04E0C((uint64_t)v11);
      sub_217E09B38((uint64_t)v15);
      sub_217E09B38((uint64_t)v15);
      sub_217E09CBC(v6, v7, v8, *((unint64_t *)&v8 + 1), (uint64_t)v14);
      v10 = (char *)MEMORY[0x24BEE4AF8];
      v2 = sub_217E05E84((uint64_t)v14, 17, 0, &v10);
      sub_217E09BF8((uint64_t)v14);
      swift_bridgeObjectRelease();
      sub_217E09BD0((uint64_t)v15);
      sub_217E09BD0((uint64_t)v15);
      sub_217E09BD0((uint64_t)v15);
    }
  }
  return v2;
}

char sub_217E1D94C@<W0>(_BYTE *a1@<X8>)
{
  uint64_t v1;
  char *v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  Swift::Int64 v7;
  char v9;
  _BYTE v10[32];
  __int128 v11;
  __int128 v12;
  _BYTE v13[96];
  _OWORD v14[2];

  v3 = sub_217E1D764();
  if (!v1)
  {
    v4 = (uint64_t)v3;
    if (qword_254F27538 != -1)
      swift_once();
    sub_217E04998(qword_254F2BE50, qword_254F2BE58, qword_254F2BE60, v4, (uint64_t)v10);
    swift_bridgeObjectRelease();
    v14[0] = v11;
    v14[1] = v12;
    v5 = v11;
    v6 = v12;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v10);
    sub_217E09B38((uint64_t)v14);
    sub_217E09CBC(v5, *((uint64_t *)&v5 + 1), v6, *((unint64_t *)&v6 + 1), (uint64_t)v13);
    v7 = sub_217E15340((uint64_t)v13, 2, 0);
    sub_217E09BD0((uint64_t)v14);
    LOBYTE(v3) = AKSRefKeyType.init(rawValue:)(v7);
    if (v9 == 12)
    {
      __break(1u);
    }
    else
    {
      LOBYTE(v3) = sub_217E09BD0((uint64_t)v14);
      *a1 = v9;
    }
  }
  return (char)v3;
}

uint64_t sub_217E1DAE8()
{
  uint64_t v0;
  uint64_t v1;
  char *v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE v19[32];
  __int128 v20;
  __int128 v21;
  _OWORD v22[2];

  v2 = sub_217E1D764();
  if (!v0)
  {
    v3 = (uint64_t)v2;
    if (qword_254F27530 != -1)
      swift_once();
    sub_217E04998(*((uint64_t *)&xmmword_254F2BE28 + 1), xmmword_254F2BE38, *((unint64_t *)&xmmword_254F2BE38 + 1), v3, (uint64_t)v19);
    swift_bridgeObjectRelease();
    v22[0] = v20;
    v22[1] = v21;
    v4 = *((_QWORD *)&v20 + 1);
    v5 = v21;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v19);
    v6 = swift_unknownObjectRetain();
    v7 = sub_217E14984(v6, v4, v5, *((unint64_t *)&v5 + 1), 4, 0);
    v12 = v7;
    v13 = v8;
    v14 = v9;
    v15 = v10;
    if ((v10 & 1) != 0)
    {
      sub_217E2D194();
      swift_unknownObjectRetain_n();
      v17 = swift_dynamicCastClass();
      if (!v17)
      {
        swift_unknownObjectRelease();
        v17 = MEMORY[0x24BEE4AF8];
      }
      v18 = *(_QWORD *)(v17 + 16);
      swift_release();
      if (__OFSUB__(v15 >> 1, v14))
      {
        __break(1u);
      }
      else if (v18 == (v15 >> 1) - v14)
      {
        v1 = swift_dynamicCastClass();
        if (!v1)
        {
          swift_unknownObjectRelease();
          v1 = MEMORY[0x24BEE4AF8];
        }
        goto LABEL_14;
      }
      swift_unknownObjectRelease();
    }
    sub_217E200CC(v12, v13, v14, v15);
    v1 = v16;
LABEL_14:
    swift_unknownObjectRelease();
    sub_217E09BD0((uint64_t)v22);
  }
  return v1;
}

char *sub_217E1DCE4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *result;
  char *v19;
  _BYTE v20[32];
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  _QWORD v25[8];

  if (qword_254F27508 != -1)
    swift_once();
  v2 = *(_QWORD *)(v0 + 24);
  if (v2 == 1)
  {
    sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
LABEL_14:
    __break(1u);
LABEL_15:
    result = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
    goto LABEL_16;
  }
  v4 = qword_254F2BD98;
  v3 = unk_254F2BDA0;
  v5 = qword_254F2BD90;
  sub_217E21284(*(_QWORD *)(v0 + 24));
  sub_217E04998(v5, v4, v3, v2, (uint64_t)v20);
  if (!v1)
  {
    sub_217E21274(v2);
    v10 = v21;
    v11 = v22;
    v12 = v23;
    v13 = v24;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v20);
    v25[0] = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
    if (v10)
    {
      sub_217E20404(v10, v11, v12, v13);
      swift_unknownObjectRelease();
      return (char *)v25[0];
    }
    goto LABEL_14;
  }
  sub_217E21274(v2);
  MEMORY[0x219A18338](v1);
  if (qword_254F27500 != -1)
    swift_once();
  v6 = *(_QWORD *)(v0 + 24);
  if (v6 == 1)
    goto LABEL_15;
  v7 = qword_254F2BD78;
  v8 = unk_254F2BD80;
  v9 = qword_254F2BD70;
  swift_bridgeObjectRetain();
  sub_217E04998(v9, v7, v8, v6, (uint64_t)v25);
  sub_217E21274(v6);
  v14 = v25[4];
  v15 = v25[5];
  v16 = v25[6];
  v17 = v25[7];
  swift_unknownObjectRetain();
  sub_217E04E0C((uint64_t)v25);
  result = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  v19 = result;
  if (v14)
  {
    sub_217E20404(v14, v15, v16, v17);
    swift_unknownObjectRelease();
    return v19;
  }
LABEL_16:
  __break(1u);
  return result;
}

uint64_t sub_217E1DF24()
{
  uint64_t v0;
  uint64_t v1;
  char *v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE v19[32];
  __int128 v20;
  __int128 v21;
  _OWORD v22[2];

  v2 = sub_217E1D764();
  if (!v0)
  {
    v3 = (uint64_t)v2;
    if (qword_254F27548 != -1)
      swift_once();
    sub_217E04998(qword_254F2BE90, xmmword_254F2BE98, *((unint64_t *)&xmmword_254F2BE98 + 1), v3, (uint64_t)v19);
    swift_bridgeObjectRelease();
    v22[0] = v20;
    v22[1] = v21;
    v4 = *((_QWORD *)&v20 + 1);
    v5 = v21;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v19);
    v6 = swift_unknownObjectRetain();
    v7 = sub_217E146D4(v6, v4, v5, *((unint64_t *)&v5 + 1));
    v12 = v7;
    v13 = v8;
    v14 = v9;
    v15 = v10;
    if ((v10 & 1) != 0)
    {
      sub_217E2D194();
      swift_unknownObjectRetain_n();
      v17 = swift_dynamicCastClass();
      if (!v17)
      {
        swift_unknownObjectRelease();
        v17 = MEMORY[0x24BEE4AF8];
      }
      v18 = *(_QWORD *)(v17 + 16);
      swift_release();
      if (__OFSUB__(v15 >> 1, v14))
      {
        __break(1u);
      }
      else if (v18 == (v15 >> 1) - v14)
      {
        v1 = swift_dynamicCastClass();
        if (!v1)
        {
          swift_unknownObjectRelease();
          v1 = MEMORY[0x24BEE4AF8];
        }
        goto LABEL_14;
      }
      swift_unknownObjectRelease();
    }
    sub_217E200CC(v12, v13, v14, v15);
    v1 = v16;
LABEL_14:
    swift_unknownObjectRelease();
    sub_217E09BD0((uint64_t)v22);
  }
  return v1;
}

uint64_t sub_217E1E118()
{
  uint64_t v0;
  uint64_t v1;
  char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  _BYTE v8[32];
  __int128 v9;
  __int128 v10;
  _BYTE v11[96];
  _OWORD v12[2];

  v2 = sub_217E1D764();
  if (!v1)
  {
    v3 = (uint64_t)v2;
    if (qword_254F27540 != -1)
      swift_once();
    sub_217E04998(qword_254F2BE70, *(uint64_t *)algn_254F2BE78, qword_254F2BE80, v3, (uint64_t)v8);
    swift_bridgeObjectRelease();
    v12[0] = v9;
    v12[1] = v10;
    v5 = *((_QWORD *)&v9 + 1);
    v4 = v9;
    v6 = v10;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v8);
    sub_217E09B38((uint64_t)v12);
    sub_217E09CBC(v4, v5, v6, *((unint64_t *)&v6 + 1), (uint64_t)v11);
    v0 = sub_217E15588((uint64_t)v11, 2, 0);
    sub_217E09BD0((uint64_t)v12);
    sub_217E09BD0((uint64_t)v12);
  }
  return v0;
}

void sub_217E1E288(_DWORD *a1@<X8>)
{
  uint64_t v1;

  *a1 = *(_DWORD *)(v1 + 16);
}

char sub_217E1E294@<W0>(_BYTE *a1@<X8>)
{
  uint64_t v1;
  char *v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  Swift::Int64 v7;
  char v9;
  _BYTE v10[32];
  __int128 v11;
  __int128 v12;
  _BYTE v13[96];
  _OWORD v14[2];

  v3 = sub_217E1D764();
  if (!v1)
  {
    v4 = (uint64_t)v3;
    if (qword_254F274F0 != -1)
      swift_once();
    sub_217E04998(qword_254F2BD30, qword_254F2BD38, qword_254F2BD40, v4, (uint64_t)v10);
    swift_bridgeObjectRelease();
    v14[0] = v11;
    v14[1] = v12;
    v5 = v11;
    v6 = v12;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v10);
    sub_217E09B38((uint64_t)v14);
    sub_217E09CBC(v5, *((uint64_t *)&v5 + 1), v6, *((unint64_t *)&v6 + 1), (uint64_t)v13);
    v7 = sub_217E15340((uint64_t)v13, 2, 0);
    sub_217E09BD0((uint64_t)v14);
    LOBYTE(v3) = AKSKeyClass.init(rawValue:)(v7);
    if (v9 == 20)
    {
      __break(1u);
    }
    else
    {
      LOBYTE(v3) = sub_217E09BD0((uint64_t)v14);
      *a1 = v9;
    }
  }
  return (char)v3;
}

uint64_t sub_217E1E430@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  _BYTE v8[32];
  __int128 v9;
  __int128 v10;
  _BYTE v11[96];
  _OWORD v12[2];

  result = (uint64_t)sub_217E1D764();
  if (!v1)
  {
    v4 = result;
    if (qword_254F276B8 != -1)
      swift_once();
    sub_217E04998(qword_254F2C450, xmmword_254F2C458, *((unint64_t *)&xmmword_254F2C458 + 1), v4, (uint64_t)v8);
    swift_bridgeObjectRelease();
    v12[0] = v9;
    v12[1] = v10;
    v5 = v9;
    v6 = v10;
    swift_unknownObjectRetain();
    sub_217E04E0C((uint64_t)v8);
    sub_217E09B38((uint64_t)v12);
    sub_217E09CBC(v5, *((uint64_t *)&v5 + 1), v6, *((unint64_t *)&v6 + 1), (uint64_t)v11);
    v7 = sub_217E150D4((uint64_t)v11, 2, 0);
    sub_217E09BD0((uint64_t)v12);
    result = sub_217E09BD0((uint64_t)v12);
    *a1 = v7;
  }
  return result;
}

char *sub_217E1E5A4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  char *result;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  char *v30;

  v2 = v0;
  if (qword_254F275B8 != -1)
    swift_once();
  result = sub_217E1738C(qword_254F2C048, unk_254F2C050, xmmword_254F2C058, *((char **)&xmmword_254F2C058 + 1), 0);
  if (!v1)
  {
    v4 = result;
    v30 = result;
    result = *(char **)(v0 + 24);
    if (result == (char *)1)
    {
      __break(1u);
      return result;
    }
    v6 = 0;
    v5 = (char *)swift_bridgeObjectRetain();
    v7 = sub_217E14180(v5);
    v9 = v8;
    v11 = v10;
    v28 = v12;
    v13 = qword_254F27550;
    swift_unknownObjectRetain();
    if (v13 != -1)
      swift_once();
    v14 = qword_254F2BEA8;
    v15 = qword_254F2BEB0;
    v16 = qword_254F2BEB8;
    v17 = qword_254F2BEC0;
    if (!v4)
      v30 = (char *)MEMORY[0x24BEE4AF8];
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v18 = sub_217E205B0((uint64_t)&v30, v15, v16, v17);
    v19 = *((_QWORD *)v30 + 2);
    if (v19 < v18)
    {
      __break(1u);
    }
    else
    {
      v20 = 0;
      sub_217E208C8(v18, v19);
      v6 = v30;
      if (!v30)
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
LABEL_16:
        v29 = *(_DWORD *)(v2 + 16);
        sub_217E16E24(&v29, v6);
        if (!v20)
          swift_bridgeObjectRelease();
        return (char *)swift_bridgeObjectRelease();
      }
      v26 = v15;
      v27 = 0;
      swift_unknownObjectRetain();
      swift_unknownObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      {
LABEL_12:
        v22 = *((_QWORD *)v6 + 2);
        v21 = *((_QWORD *)v6 + 3);
        v23 = v16;
        if (v22 >= v21 >> 1)
        {
          v25 = sub_217E0E3D4((char *)(v21 > 1), v22 + 1, 1, v6);
          v23 = v16;
          v6 = v25;
        }
        *((_QWORD *)v6 + 2) = v22 + 1;
        v24 = &v6[64 * v22];
        *((_QWORD *)v24 + 4) = v14;
        *((_QWORD *)v24 + 5) = v26;
        *((_QWORD *)v24 + 6) = v23;
        *((_QWORD *)v24 + 7) = v17;
        *((_QWORD *)v24 + 8) = v7;
        *((_QWORD *)v24 + 9) = v28;
        *((_QWORD *)v24 + 10) = v9;
        *((_QWORD *)v24 + 11) = v11;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        v20 = v27;
        goto LABEL_16;
      }
    }
    v6 = sub_217E0E3D4(0, *((_QWORD *)v6 + 2) + 1, 1, v6);
    goto LABEL_12;
  }
  return result;
}

uint64_t AKSRefKey.deinit()
{
  uint64_t v0;

  sub_217E21274(*(_QWORD *)(v0 + 24));
  swift_bridgeObjectRelease();
  return v0;
}

uint64_t AKSRefKey.__deallocating_deinit()
{
  uint64_t v0;

  sub_217E21274(*(_QWORD *)(v0 + 24));
  swift_bridgeObjectRelease();
  return swift_deallocClassInstance();
}

uint64_t AKSRefKeyCreateAndEncrypt(handle:key_class:key_type:data:params:)(int *a1, char *a2, char *a3, uint64_t a4, uint64_t a5)
{
  return sub_217E1E8D8(a1, a2, a3, a4, a5, (void (*)(char *, char *, uint64_t, uint64_t))sub_217E18268);
}

uint64_t AKSRefKeyCreateAndWrap(handle:key_class:key_type:data:params:)(int *a1, char *a2, char *a3, uint64_t a4, uint64_t a5)
{
  return sub_217E1E8D8(a1, a2, a3, a4, a5, (void (*)(char *, char *, uint64_t, uint64_t))sub_217E187DC);
}

uint64_t sub_217E1E8D8(int *a1, char *a2, char *a3, uint64_t a4, uint64_t a5, void (*a6)(char *, char *, uint64_t, uint64_t))
{
  uint64_t v6;
  int v10;
  char v11;
  char v12;
  uint64_t v13;
  char v15;
  char v16;

  v10 = *a1;
  v11 = *a2;
  v12 = *a3;
  type metadata accessor for AKSRefKey();
  v13 = swift_allocObject();
  *(_OWORD *)(v13 + 24) = xmmword_217E32980;
  *(_DWORD *)(v13 + 16) = v10;
  v16 = v11;
  v15 = v12;
  a6(&v16, &v15, a4, a5);
  if (v6)
    swift_release();
  return v13;
}

uint64_t AKSSystemKeyCollection(type:generation:params:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  int64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  char *v41;

  v4 = v3;
  if (qword_254F27618 != -1)
    swift_once();
  v6 = sub_217E1738C(qword_254F2C1C8, unk_254F2C1D0, xmmword_254F2C1D8, *((char **)&xmmword_254F2C1D8 + 1), a3);
  if (!v3)
  {
    v7 = v6;
    v41 = v6;
    if (qword_254F27638 != -1)
      swift_once();
    v8 = qword_254F2C248;
    v9 = unk_254F2C250;
    v10 = xmmword_254F2C258;
    v11 = sub_217E1400C();
    v35 = v13;
    v36 = v12;
    v38 = v14;
    if (!v7)
      v41 = (char *)MEMORY[0x24BEE4AF8];
    swift_unknownObjectRetain();
    v15 = sub_217E205B0((uint64_t)&v41, v9, v10, *((unint64_t *)&v10 + 1));
    v16 = *((_QWORD *)v41 + 2);
    if (v16 < v15)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v15, v16);
      v7 = v41;
      if (v41)
      {
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          v7 = sub_217E0E3D4(0, *((_QWORD *)v7 + 2) + 1, 1, v7);
        v18 = *((_QWORD *)v7 + 2);
        v17 = *((_QWORD *)v7 + 3);
        if (v18 >= v17 >> 1)
          v7 = sub_217E0E3D4((char *)(v17 > 1), v18 + 1, 1, v7);
        *((_QWORD *)v7 + 2) = v18 + 1;
        v19 = &v7[64 * v18];
        *((_QWORD *)v19 + 4) = v8;
        *((_QWORD *)v19 + 5) = v9;
        *((_OWORD *)v19 + 3) = v10;
        *((_QWORD *)v19 + 8) = v11;
        *((_QWORD *)v19 + 9) = v38;
        *((_QWORD *)v19 + 10) = v36;
        *((_QWORD *)v19 + 11) = v35;
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        v41 = v7;
      }
      else
      {
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
      }
      if (qword_254F27658 == -1)
      {
LABEL_17:
        v20 = qword_254F2C2C8;
        v21 = unk_254F2C2D0;
        v22 = xmmword_254F2C2D8;
        v24 = sub_217E1400C();
        v26 = v25;
        v37 = v28;
        v39 = v27;
        v29 = (char *)MEMORY[0x24BEE4AF8];
        if (v7)
          v29 = v7;
        v41 = v29;
        swift_unknownObjectRetain();
        v30 = sub_217E205B0((uint64_t)&v41, v21, v22, *((unint64_t *)&v22 + 1));
        v31 = *((_QWORD *)v41 + 2);
        if (v31 < v30)
        {
          __break(1u);
        }
        else
        {
          sub_217E208C8(v30, v31);
          v7 = v41;
          if (!v41)
          {
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
LABEL_28:
            v40 = -1;
            v4 = sub_217E16E24(&v40, v7);
            swift_bridgeObjectRelease();
            return v4;
          }
          swift_unknownObjectRetain();
          swift_unknownObjectRetain();
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
          {
LABEL_24:
            v33 = *((_QWORD *)v7 + 2);
            v32 = *((_QWORD *)v7 + 3);
            if (v33 >= v32 >> 1)
              v7 = sub_217E0E3D4((char *)(v32 > 1), v33 + 1, 1, v7);
            *((_QWORD *)v7 + 2) = v33 + 1;
            v34 = &v7[64 * v33];
            *((_QWORD *)v34 + 4) = v20;
            *((_QWORD *)v34 + 5) = v21;
            *((_OWORD *)v34 + 3) = v22;
            *((_QWORD *)v34 + 8) = v24;
            *((_QWORD *)v34 + 9) = v39;
            *((_QWORD *)v34 + 10) = v26;
            *((_QWORD *)v34 + 11) = v37;
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
            goto LABEL_28;
          }
        }
        v7 = sub_217E0E3D4(0, *((_QWORD *)v7 + 2) + 1, 1, v7);
        goto LABEL_24;
      }
    }
    swift_once();
    goto LABEL_17;
  }
  return v4;
}

uint64_t AKSSystemKeyAttest(type:generation:ref_key:params:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  int64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  __int128 v33;
  char *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  int64_t v43;
  unint64_t v44;
  unint64_t v45;
  char *v46;
  uint64_t v47;
  __int128 v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _BYTE *v53;
  char *v54;
  char *v55;
  uint64_t v56;
  int64_t v57;
  char *v58;
  unint64_t v59;
  unint64_t v60;
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  int v71;
  char *v72;

  result = *(_QWORD *)(a3 + 24);
  if (result != 1)
  {
    v8 = (char *)swift_bridgeObjectRetain();
    v9 = sub_217E14180(v8);
    if (v4)
    {
      sub_217E04E40();
      swift_allocError();
      *v13 = 25;
      swift_willThrow();
      MEMORY[0x219A18338](v4);
      return v5;
    }
    v14 = v9;
    v15 = v10;
    v16 = v11;
    v17 = v12;
    v18 = qword_254F27610;
    swift_unknownObjectRetain();
    if (v18 != -1)
      swift_once();
    v19 = sub_217E1738C(qword_254F2C1A8, qword_254F2C1B0, qword_254F2C1B8, unk_254F2C1C0, a4);
    v20 = 0;
    v21 = v19;
    v69 = v14;
    v72 = v19;
    if (qword_254F27550 != -1)
      swift_once();
    v23 = qword_254F2BEA8;
    v22 = qword_254F2BEB0;
    v24 = qword_254F2BEB8;
    v25 = qword_254F2BEC0;
    if (!v21)
      v72 = (char *)MEMORY[0x24BEE4AF8];
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v26 = sub_217E205B0((uint64_t)&v72, v22, v24, v25);
    v27 = *((_QWORD *)v72 + 2);
    if (v27 < v26)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v26, v27);
      v20 = v72;
      v64 = 0;
      if (v72)
      {
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          v20 = sub_217E0E3D4(0, *((_QWORD *)v20 + 2) + 1, 1, v20);
        v29 = *((_QWORD *)v20 + 2);
        v28 = *((_QWORD *)v20 + 3);
        v30 = v22;
        if (v29 >= v28 >> 1)
        {
          v63 = sub_217E0E3D4((char *)(v28 > 1), v29 + 1, 1, v20);
          v30 = v22;
          v20 = v63;
        }
        *((_QWORD *)v20 + 2) = v29 + 1;
        v31 = &v20[64 * v29];
        *((_QWORD *)v31 + 4) = v23;
        *((_QWORD *)v31 + 5) = v30;
        *((_QWORD *)v31 + 6) = v24;
        *((_QWORD *)v31 + 7) = v25;
        *((_QWORD *)v31 + 8) = v69;
        *((_QWORD *)v31 + 9) = v15;
        *((_QWORD *)v31 + 10) = v16;
        *((_QWORD *)v31 + 11) = v17;
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
        v72 = v20;
      }
      else
      {
        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease();
      }
      if (qword_254F27638 == -1)
      {
LABEL_19:
        v5 = qword_254F2C248;
        v32 = unk_254F2C250;
        v33 = xmmword_254F2C258;
        v34 = sub_217E1400C();
        v38 = v64;
        if (v64)
        {
LABEL_32:
          sub_217E04E40();
          swift_allocError();
          *v53 = 22;
          swift_willThrow();
          MEMORY[0x219A18338](v38);
LABEL_33:
          swift_unknownObjectRelease();
          swift_bridgeObjectRelease();
          return v5;
        }
        v39 = v34;
        v40 = v35;
        v65 = v37;
        v67 = v36;
        v41 = (char *)MEMORY[0x24BEE4AF8];
        if (v20)
          v41 = v20;
        v72 = v41;
        swift_unknownObjectRetain();
        v42 = sub_217E205B0((uint64_t)&v72, v32, v33, *((unint64_t *)&v33 + 1));
        v43 = *((_QWORD *)v72 + 2);
        if (v43 < v42)
        {
          __break(1u);
        }
        else
        {
          sub_217E208C8(v42, v43);
          v20 = v72;
          v69 = 0;
          if (v72)
          {
            v64 = v40;
            swift_unknownObjectRetain();
            swift_unknownObjectRetain();
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
              v20 = sub_217E0E3D4(0, *((_QWORD *)v20 + 2) + 1, 1, v20);
            v45 = *((_QWORD *)v20 + 2);
            v44 = *((_QWORD *)v20 + 3);
            if (v45 >= v44 >> 1)
              v20 = sub_217E0E3D4((char *)(v44 > 1), v45 + 1, 1, v20);
            *((_QWORD *)v20 + 2) = v45 + 1;
            v46 = &v20[64 * v45];
            *((_QWORD *)v46 + 4) = v5;
            *((_QWORD *)v46 + 5) = v32;
            *((_OWORD *)v46 + 3) = v33;
            *((_QWORD *)v46 + 8) = v39;
            *((_QWORD *)v46 + 9) = v64;
            *((_QWORD *)v46 + 10) = v67;
            *((_QWORD *)v46 + 11) = v65;
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
            v72 = v20;
          }
          else
          {
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
          }
          if (qword_254F27658 == -1)
          {
LABEL_31:
            v5 = qword_254F2C2C8;
            v47 = unk_254F2C2D0;
            v48 = xmmword_254F2C2D8;
            v49 = sub_217E1400C();
            v38 = v69;
            if (v69)
              goto LABEL_32;
            v54 = v49;
            v66 = v52;
            v68 = v51;
            v70 = v50;
            v55 = (char *)MEMORY[0x24BEE4AF8];
            if (v20)
              v55 = v20;
            v72 = v55;
            swift_unknownObjectRetain();
            v56 = sub_217E205B0((uint64_t)&v72, v47, v48, *((unint64_t *)&v48 + 1));
            v57 = *((_QWORD *)v72 + 2);
            if (v57 < v56)
            {
              __break(1u);
            }
            else
            {
              v58 = 0;
              sub_217E208C8(v56, v57);
              v38 = v72;
              if (!v72)
              {
                swift_unknownObjectRelease();
                swift_unknownObjectRelease();
                goto LABEL_44;
              }
              v64 = 0;
              swift_unknownObjectRetain();
              swift_unknownObjectRetain();
              if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
              {
LABEL_40:
                v60 = *((_QWORD *)v38 + 2);
                v59 = *((_QWORD *)v38 + 3);
                if (v60 >= v59 >> 1)
                  v38 = sub_217E0E3D4((char *)(v59 > 1), v60 + 1, 1, v38);
                *((_QWORD *)v38 + 2) = v60 + 1;
                v61 = &v38[64 * v60];
                *((_QWORD *)v61 + 4) = v5;
                *((_QWORD *)v61 + 5) = v47;
                *((_OWORD *)v61 + 3) = v48;
                *((_QWORD *)v61 + 8) = v54;
                *((_QWORD *)v61 + 9) = v70;
                *((_QWORD *)v61 + 10) = v68;
                *((_QWORD *)v61 + 11) = v66;
                swift_unknownObjectRelease();
                swift_unknownObjectRelease();
                v58 = v64;
LABEL_44:
                v71 = -1;
                v62 = sub_217E16E24(&v71, v38);
                if (!v58)
                {
                  v5 = v62;
                  swift_unknownObjectRelease();
                  swift_bridgeObjectRelease();
                  return v5;
                }
                goto LABEL_33;
              }
            }
            v38 = sub_217E0E3D4(0, *((_QWORD *)v38 + 2) + 1, 1, v38);
            goto LABEL_40;
          }
        }
        swift_once();
        goto LABEL_31;
      }
    }
    swift_once();
    goto LABEL_19;
  }
  __break(1u);
  return result;
}

char *AKSSystemKeyOperate(type:operation:params:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  char *result;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  int64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  char *v41;

  if (qword_254F27628 != -1)
    swift_once();
  result = sub_217E1738C(qword_254F2C208, qword_254F2C210, qword_254F2C218, unk_254F2C220, a3);
  if (!v3)
  {
    v6 = result;
    v41 = result;
    if (qword_254F27638 != -1)
      swift_once();
    v7 = qword_254F2C248;
    v8 = unk_254F2C250;
    v9 = xmmword_254F2C258;
    v10 = 0;
    v11 = sub_217E1400C();
    v35 = v13;
    v36 = v12;
    v38 = v14;
    if (!v6)
      v41 = (char *)MEMORY[0x24BEE4AF8];
    swift_unknownObjectRetain();
    v15 = sub_217E205B0((uint64_t)&v41, v8, v9, *((unint64_t *)&v9 + 1));
    v16 = *((_QWORD *)v41 + 2);
    if (v16 < v15)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v15, v16);
      v10 = v41;
      if (v41)
      {
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          v10 = sub_217E0E3D4(0, *((_QWORD *)v10 + 2) + 1, 1, v10);
        v18 = *((_QWORD *)v10 + 2);
        v17 = *((_QWORD *)v10 + 3);
        if (v18 >= v17 >> 1)
          v10 = sub_217E0E3D4((char *)(v17 > 1), v18 + 1, 1, v10);
        *((_QWORD *)v10 + 2) = v18 + 1;
        v19 = &v10[64 * v18];
        *((_QWORD *)v19 + 4) = v7;
        *((_QWORD *)v19 + 5) = v8;
        *((_OWORD *)v19 + 3) = v9;
        *((_QWORD *)v19 + 8) = v11;
        *((_QWORD *)v19 + 9) = v38;
        *((_QWORD *)v19 + 10) = v36;
        *((_QWORD *)v19 + 11) = v35;
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        v41 = v10;
      }
      else
      {
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
      }
      if (qword_254F27660 == -1)
      {
LABEL_17:
        v20 = qword_254F2C2E8;
        v21 = unk_254F2C2F0;
        v22 = xmmword_254F2C2F8;
        v23 = sub_217E1400C();
        v25 = v24;
        v37 = v27;
        v39 = v26;
        v28 = (char *)MEMORY[0x24BEE4AF8];
        if (v10)
          v28 = v10;
        v41 = v28;
        swift_unknownObjectRetain();
        v29 = sub_217E205B0((uint64_t)&v41, v21, v22, *((unint64_t *)&v22 + 1));
        v30 = *((_QWORD *)v41 + 2);
        if (v30 < v29)
        {
          __break(1u);
        }
        else
        {
          v31 = 0;
          sub_217E208C8(v29, v30);
          v10 = v41;
          if (!v41)
          {
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
LABEL_28:
            v40 = -1;
            sub_217E16E24(&v40, v10);
            if (!v31)
              swift_bridgeObjectRelease();
            return (char *)swift_bridgeObjectRelease();
          }
          v35 = 0;
          swift_unknownObjectRetain();
          swift_unknownObjectRetain();
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
          {
LABEL_24:
            v33 = *((_QWORD *)v10 + 2);
            v32 = *((_QWORD *)v10 + 3);
            if (v33 >= v32 >> 1)
              v10 = sub_217E0E3D4((char *)(v32 > 1), v33 + 1, 1, v10);
            *((_QWORD *)v10 + 2) = v33 + 1;
            v34 = &v10[64 * v33];
            *((_QWORD *)v34 + 4) = v20;
            *((_QWORD *)v34 + 5) = v21;
            *((_OWORD *)v34 + 3) = v22;
            *((_QWORD *)v34 + 8) = v23;
            *((_QWORD *)v34 + 9) = v39;
            *((_QWORD *)v34 + 10) = v25;
            *((_QWORD *)v34 + 11) = v37;
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
            v31 = v35;
            goto LABEL_28;
          }
        }
        v10 = sub_217E0E3D4(0, *((_QWORD *)v10 + 2) + 1, 1, v10);
        goto LABEL_24;
      }
    }
    swift_once();
    goto LABEL_17;
  }
  return result;
}

uint64_t AKSSystemKeyGetPublicKey(type:generation:params:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  int64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  char *v41;

  v4 = v3;
  if (qword_254F27620 != -1)
    swift_once();
  v6 = sub_217E1738C(qword_254F2C1E8, unk_254F2C1F0, xmmword_254F2C1F8, *((char **)&xmmword_254F2C1F8 + 1), a3);
  if (!v3)
  {
    v7 = v6;
    v41 = v6;
    if (qword_254F27638 != -1)
      swift_once();
    v8 = qword_254F2C248;
    v9 = unk_254F2C250;
    v10 = xmmword_254F2C258;
    v11 = sub_217E1400C();
    v35 = v13;
    v36 = v12;
    v38 = v14;
    if (!v7)
      v41 = (char *)MEMORY[0x24BEE4AF8];
    swift_unknownObjectRetain();
    v15 = sub_217E205B0((uint64_t)&v41, v9, v10, *((unint64_t *)&v10 + 1));
    v16 = *((_QWORD *)v41 + 2);
    if (v16 < v15)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v15, v16);
      v7 = v41;
      if (v41)
      {
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          v7 = sub_217E0E3D4(0, *((_QWORD *)v7 + 2) + 1, 1, v7);
        v18 = *((_QWORD *)v7 + 2);
        v17 = *((_QWORD *)v7 + 3);
        if (v18 >= v17 >> 1)
          v7 = sub_217E0E3D4((char *)(v17 > 1), v18 + 1, 1, v7);
        *((_QWORD *)v7 + 2) = v18 + 1;
        v19 = &v7[64 * v18];
        *((_QWORD *)v19 + 4) = v8;
        *((_QWORD *)v19 + 5) = v9;
        *((_OWORD *)v19 + 3) = v10;
        *((_QWORD *)v19 + 8) = v11;
        *((_QWORD *)v19 + 9) = v38;
        *((_QWORD *)v19 + 10) = v36;
        *((_QWORD *)v19 + 11) = v35;
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        v41 = v7;
      }
      else
      {
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
      }
      if (qword_254F27658 == -1)
      {
LABEL_17:
        v20 = qword_254F2C2C8;
        v21 = unk_254F2C2D0;
        v22 = xmmword_254F2C2D8;
        v24 = sub_217E1400C();
        v26 = v25;
        v37 = v28;
        v39 = v27;
        v29 = (char *)MEMORY[0x24BEE4AF8];
        if (v7)
          v29 = v7;
        v41 = v29;
        swift_unknownObjectRetain();
        v30 = sub_217E205B0((uint64_t)&v41, v21, v22, *((unint64_t *)&v22 + 1));
        v31 = *((_QWORD *)v41 + 2);
        if (v31 < v30)
        {
          __break(1u);
        }
        else
        {
          sub_217E208C8(v30, v31);
          v7 = v41;
          if (!v41)
          {
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
LABEL_28:
            v40 = -1;
            v4 = sub_217E16E24(&v40, v7);
            swift_bridgeObjectRelease();
            return v4;
          }
          swift_unknownObjectRetain();
          swift_unknownObjectRetain();
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
          {
LABEL_24:
            v33 = *((_QWORD *)v7 + 2);
            v32 = *((_QWORD *)v7 + 3);
            if (v33 >= v32 >> 1)
              v7 = sub_217E0E3D4((char *)(v32 > 1), v33 + 1, 1, v7);
            *((_QWORD *)v7 + 2) = v33 + 1;
            v34 = &v7[64 * v33];
            *((_QWORD *)v34 + 4) = v20;
            *((_QWORD *)v34 + 5) = v21;
            *((_OWORD *)v34 + 3) = v22;
            *((_QWORD *)v34 + 8) = v24;
            *((_QWORD *)v34 + 9) = v39;
            *((_QWORD *)v34 + 10) = v26;
            *((_QWORD *)v34 + 11) = v37;
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
            goto LABEL_28;
          }
        }
        v7 = sub_217E0E3D4(0, *((_QWORD *)v7 + 2) + 1, 1, v7);
        goto LABEL_24;
      }
    }
    swift_once();
    goto LABEL_17;
  }
  return v4;
}

uint64_t AKSSystemKeySign(type:generation:digest:params:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  int64_t v31;
  char *v32;
  unint64_t v33;
  unint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  __int128 v51;
  int v52;
  __int128 v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;

  if (qword_254F27630 != -1)
    swift_once();
  v6 = sub_217E1738C(qword_254F2C228, qword_254F2C230, qword_254F2C238, unk_254F2C240, a4);
  if (!v4)
  {
    v7 = v6;
    v60 = v6;
    if (qword_254F27638 != -1)
      swift_once();
    v8 = qword_254F2C248;
    v9 = unk_254F2C250;
    v10 = xmmword_254F2C258;
    v11 = sub_217E1400C();
    v46 = v13;
    v48 = v12;
    v49 = v14;
    if (!v7)
      v60 = (char *)MEMORY[0x24BEE4AF8];
    swift_unknownObjectRetain();
    v15 = sub_217E205B0((uint64_t)&v60, v9, v10, *((unint64_t *)&v10 + 1));
    v16 = *((_QWORD *)v60 + 2);
    if (v16 < v15)
    {
      __break(1u);
    }
    else
    {
      sub_217E208C8(v15, v16);
      v7 = v60;
      if (v60)
      {
        swift_unknownObjectRetain();
        swift_unknownObjectRetain();
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          v7 = sub_217E0E3D4(0, *((_QWORD *)v7 + 2) + 1, 1, v7);
        v18 = *((_QWORD *)v7 + 2);
        v17 = *((_QWORD *)v7 + 3);
        if (v18 >= v17 >> 1)
          v7 = sub_217E0E3D4((char *)(v17 > 1), v18 + 1, 1, v7);
        *((_QWORD *)v7 + 2) = v18 + 1;
        v19 = &v7[64 * v18];
        *((_QWORD *)v19 + 4) = v8;
        *((_QWORD *)v19 + 5) = v9;
        *((_OWORD *)v19 + 3) = v10;
        *((_QWORD *)v19 + 8) = v11;
        *((_QWORD *)v19 + 9) = v49;
        *((_QWORD *)v19 + 10) = v48;
        *((_QWORD *)v19 + 11) = v46;
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        v60 = v7;
      }
      else
      {
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
      }
      if (qword_254F27658 == -1)
      {
LABEL_17:
        v20 = qword_254F2C2C8;
        v21 = unk_254F2C2D0;
        v22 = xmmword_254F2C2D8;
        v23 = sub_217E1400C();
        v25 = v24;
        v27 = v26;
        v50 = v28;
        v29 = (char *)MEMORY[0x24BEE4AF8];
        if (v7)
          v29 = v7;
        v60 = v29;
        swift_unknownObjectRetain();
        v30 = sub_217E205B0((uint64_t)&v60, v21, v22, *((unint64_t *)&v22 + 1));
        v31 = *((_QWORD *)v60 + 2);
        if (v31 < v30)
        {
          __break(1u);
        }
        else
        {
          sub_217E208C8(v30, v31);
          v32 = v60;
          if (v60)
          {
            v47 = v25;
            swift_unknownObjectRetain();
            swift_unknownObjectRetain();
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
              v32 = sub_217E0E3D4(0, *((_QWORD *)v32 + 2) + 1, 1, v32);
            v34 = *((_QWORD *)v32 + 2);
            v33 = *((_QWORD *)v32 + 3);
            if (v34 >= v33 >> 1)
              v32 = sub_217E0E3D4((char *)(v33 > 1), v34 + 1, 1, v32);
            *((_QWORD *)v32 + 2) = v34 + 1;
            v35 = &v32[64 * v34];
            *((_QWORD *)v35 + 4) = v20;
            *((_QWORD *)v35 + 5) = v21;
            *((_OWORD *)v35 + 3) = v22;
            *((_QWORD *)v35 + 8) = v23;
            *((_QWORD *)v35 + 9) = v47;
            *((_QWORD *)v35 + 10) = v27;
            *((_QWORD *)v35 + 11) = v50;
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
            v60 = v32;
          }
          else
          {
            swift_unknownObjectRelease();
            swift_unknownObjectRelease();
          }
          if (qword_254F274F8 == -1)
            goto LABEL_28;
        }
        swift_once();
LABEL_28:
        v51 = xmmword_254F2BD48;
        v36 = qword_254F2BD58;
        v37 = qword_254F2BD60;
        swift_bridgeObjectRetain();
        v38 = sub_217E204F8();
        v40 = v39;
        v42 = v41;
        v44 = v43;
        swift_bridgeObjectRelease();
        v53 = v51;
        v54 = v36;
        v55 = v37;
        v56 = v38;
        v57 = v40;
        v58 = v42;
        v59 = v44;
        swift_unknownObjectRetain();
        sub_217E043A0((uint64_t)&v53);
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        v52 = -1;
        a4 = sub_217E16E24(&v52, v60);
        swift_bridgeObjectRelease();
        return a4;
      }
    }
    swift_once();
    goto LABEL_17;
  }
  return a4;
}

char *sub_217E20090(uint64_t a1)
{
  return sub_217E0E1C8(0, *(_QWORD *)(a1 + 16), 0, (char *)a1);
}

char *sub_217E200A4(uint64_t a1)
{
  return sub_217E0E2EC(0, *(_QWORD *)(a1 + 16), 0, (char *)a1);
}

char *sub_217E200B8(uint64_t a1)
{
  return sub_217E0E3D4(0, *(_QWORD *)(a1 + 16), 0, (char *)a1);
}

void sub_217E200CC(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  int64_t v5;
  _QWORD *v8;
  size_t v9;

  v4 = a4 >> 1;
  v5 = (a4 >> 1) - a3;
  if (__OFSUB__(a4 >> 1, a3))
  {
LABEL_9:
    __break(1u);
    return;
  }
  if (v5)
  {
    if (v5 <= 0)
    {
      v8 = (_QWORD *)MEMORY[0x24BEE4AF8];
      if (v4 != a3)
        goto LABEL_5;
    }
    else
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_254F27870);
      v8 = (_QWORD *)swift_allocObject();
      v9 = _swift_stdlib_malloc_size(v8);
      v8[2] = v5;
      v8[3] = 2 * v9 - 64;
      if (v4 != a3)
      {
LABEL_5:
        memcpy(v8 + 4, (const void *)(a2 + a3), v5);
        return;
      }
    }
    __break(1u);
    goto LABEL_9;
  }
}

int64_t *sub_217E20180(int64_t *result, _BYTE *a2, int64_t a3, int64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  int64_t v8;
  char v9;
  uint64_t v10;
  unint64_t v11;

  if (a2)
  {
    if (!a3)
      goto LABEL_7;
    if (a3 < 0)
      goto LABEL_36;
    if (__OFSUB__(a4, a5))
    {
LABEL_37:
      __break(1u);
      return result;
    }
    if (a4 != a5)
    {
      if (a4 <= a5)
        goto LABEL_33;
      v7 = 0;
      v8 = (71 - __clz(a6)) >> 3;
      v9 = 8 - 8 * a4;
      v10 = 8 * a4 - 8;
      while (1)
      {
        if ((unint64_t)(a4 - 0x1000000000000001 + v7) >> 61 != 7)
        {
          __break(1u);
LABEL_33:
          __break(1u);
LABEL_34:
          __break(1u);
LABEL_35:
          __break(1u);
LABEL_36:
          __break(1u);
          goto LABEL_37;
        }
        if (v10 < -64)
        {
LABEL_13:
          LOBYTE(v11) = 0;
          if (v8 < a4)
            goto LABEL_34;
          goto LABEL_22;
        }
        if (v10 > 64)
          break;
        if (v10 < 0)
        {
          if ((unint64_t)v10 <= 0xFFFFFFFFFFFFFFC0)
            goto LABEL_13;
          v11 = a6 << (v9 & 0x38);
        }
        else
        {
          if ((unint64_t)v10 >= 0x40)
            break;
          v11 = a6 >> (v10 & 0x38);
        }
        if (v8 < a4)
          goto LABEL_34;
LABEL_22:
        if (a4 + v7 < 1)
          goto LABEL_34;
        *a2 = v11;
        if (!(a3 - 1 + v7))
        {
          v6 = a4 + v7 - 1;
          goto LABEL_8;
        }
        if (__OFSUB__(a4 + v7 - 1, a5))
          goto LABEL_35;
        if (!(a4 - a5 - 1 + v7))
        {
          v6 = a5;
          a3 = a4 - a5;
          goto LABEL_8;
        }
        ++a2;
        --v7;
        v9 += 8;
        v10 -= 8;
        if (a4 + v7 <= a5)
          goto LABEL_33;
      }
      LOBYTE(v11) = 0;
      if (v8 < a4)
        goto LABEL_34;
      goto LABEL_22;
    }
  }
  a3 = 0;
LABEL_7:
  v6 = a4;
LABEL_8:
  *result = a4;
  result[1] = a5;
  result[2] = a6;
  result[3] = v6;
  return (int64_t *)a3;
}

uint64_t (*sub_217E202E0@<X0>(_BYTE *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, _BYTE *a6@<X8>))()
{
  int64_t v6;
  char v7;
  unint64_t v8;
  uint64_t v10;

  if (a3 < a2 || a4 >= a2)
  {
    __break(1u);
    goto LABEL_13;
  }
  v6 = (unint64_t)(a2 - 0x1000000000000001) >> 61;
  if (v6 != 7)
  {
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }
  a6 = a1;
  v7 = 8 * a2;
  v6 = 8 * a2 - 8;
  if (v6 < -64)
  {
    LOBYTE(v8) = 0;
    goto LABEL_11;
  }
  if (v6 > 64)
  {
LABEL_7:
    LOBYTE(v8) = 0;
    goto LABEL_11;
  }
  if ((v6 & 0x8000000000000000) == 0)
  {
    if ((unint64_t)v6 < 0x40)
    {
      v8 = a5 >> (v6 & 0x38);
      goto LABEL_11;
    }
    goto LABEL_7;
  }
LABEL_14:
  v10 = a5 << ((8 - v7) & 0x38);
  if ((unint64_t)v6 <= 0xFFFFFFFFFFFFFFC0)
    LOBYTE(v8) = 0;
  else
    LOBYTE(v8) = v10;
LABEL_11:
  *a6 = v8;
  return nullsub_1;
}

unint64_t sub_217E2037C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, int64_t a5@<X8>)
{
  char v5;
  uint64_t v7;

  if (a2 < a1 || a3 >= a1)
  {
    __break(1u);
    goto LABEL_12;
  }
  a5 = (unint64_t)(a1 - 0x1000000000000001) >> 61;
  if (a5 != 7)
  {
LABEL_12:
    __break(1u);
LABEL_13:
    v7 = a4 << ((8 - v5) & 0x38);
    if ((unint64_t)a5 <= 0xFFFFFFFFFFFFFFC0)
      return 0;
    else
      return v7;
  }
  v5 = 8 * a1;
  a5 = 8 * a1 - 8;
  if (a5 < -64)
    return 0;
  if (a5 > 64)
    return 0;
  if (a5 < 0)
    goto LABEL_13;
  if ((unint64_t)a5 >= 0x40)
    return 0;
  return a4 >> (a5 & 0x38);
}

void sub_217E20404(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char **v4;
  unint64_t v5;
  int64_t v6;
  char *v7;
  int64_t v8;
  int64_t v9;
  char *isUniquelyReferenced_nonNull_native;
  int64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;

  v5 = a4 >> 1;
  v6 = (a4 >> 1) - a3;
  if (__OFSUB__(a4 >> 1, a3))
  {
    __break(1u);
    goto LABEL_18;
  }
  v7 = *v4;
  v8 = *((_QWORD *)*v4 + 2);
  v9 = v8 + v6;
  if (__OFADD__(v8, v6))
  {
LABEL_18:
    __break(1u);
LABEL_19:
    __break(1u);
    goto LABEL_20;
  }
  isUniquelyReferenced_nonNull_native = (char *)swift_isUniquelyReferenced_nonNull_native();
  if (!(_DWORD)isUniquelyReferenced_nonNull_native || v9 > *((_QWORD *)v7 + 3) >> 1)
    goto LABEL_8;
  if (v5 == a3)
  {
    while (v6 > 0)
    {
      __break(1u);
LABEL_8:
      if (v8 <= v9)
        v13 = v8 + v6;
      else
        v13 = v8;
      isUniquelyReferenced_nonNull_native = sub_217E0E2EC(isUniquelyReferenced_nonNull_native, v13, 1, v7);
      v7 = isUniquelyReferenced_nonNull_native;
      if (v5 != a3)
        goto LABEL_12;
    }
    goto LABEL_16;
  }
LABEL_12:
  v14 = *((_QWORD *)v7 + 2);
  if ((*((_QWORD *)v7 + 3) >> 1) - v14 < v6)
    goto LABEL_19;
  memcpy(&v7[v14 + 32], (const void *)(a2 + a3), v6);
  if (v6 <= 0)
  {
LABEL_16:
    *v4 = v7;
    return;
  }
  v15 = *((_QWORD *)v7 + 2);
  v16 = __OFADD__(v15, v6);
  v17 = v15 + v6;
  if (!v16)
  {
    *((_QWORD *)v7 + 2) = v17;
    goto LABEL_16;
  }
LABEL_20:
  __break(1u);
}

char *sub_217E204F8()
{
  uint64_t v0;
  char *result;
  char *v2;

  v2 = sub_217E0E2EC(0, 1024, 0, MEMORY[0x24BEE4AF8]);
  sub_217E086BC(4uLL, 0, 0, &v2, (uint64_t (*)(char **))sub_217E2228C);
  result = v2;
  if (v0)
    return (char *)swift_bridgeObjectRelease();
  return result;
}

uint64_t sub_217E205B0(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char *v4;
  unint64_t v5;
  unint64_t v6;
  int64_t v8;
  uint64_t v9;
  unint64_t v11;
  uint64_t i;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unint64_t v20;
  char *v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  _QWORD *v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v30 = (_QWORD *)result;
  v4 = *(char **)result;
  v5 = *(_QWORD *)(*(_QWORD *)result + 16);
  if (!v5)
    return 0;
  v6 = a4;
  v8 = a4 >> 1;
  v9 = (a4 >> 1) - a3;
  if (__OFSUB__(a4 >> 1, a3))
  {
LABEL_47:
    __break(1u);
LABEL_48:
    __break(1u);
LABEL_49:
    __break(1u);
    return result;
  }
  v11 = 0;
  for (i = 152; ; i += 64)
  {
    v13 = &v4[64 * v11 + 32];
    v14 = *((_QWORD *)v13 + 2);
    v15 = *((_QWORD *)v13 + 3) >> 1;
    if (__OFSUB__(v15, v14))
      goto LABEL_42;
    if (v15 - v14 != v9)
      goto LABEL_4;
    if (!v9)
      break;
    v16 = *((_QWORD *)v13 + 1);
    if (v16 + v14 == a2 + a3 || v14 == v15)
      break;
    if (v14 >= v15)
      goto LABEL_48;
    v17 = v14 + 1;
    v18 = *(unsigned __int8 *)(v16 + v14);
    if (v14 == v15)
      break;
    v19 = a3;
    if (v8 != a3)
    {
      while (v19 >= a3 && v19 < v8)
      {
        if (v18 != *(unsigned __int8 *)(a2 + v19))
          goto LABEL_4;
        if (v15 == v17)
          goto LABEL_20;
        if (v17 >= v15)
          goto LABEL_39;
        v18 = *(unsigned __int8 *)(v16 + v17++);
        if (v8 == ++v19)
          goto LABEL_4;
      }
      __break(1u);
LABEL_39:
      __break(1u);
      goto LABEL_40;
    }
LABEL_4:
    if (++v11 == v5)
      return *(_QWORD *)(*(_QWORD *)result + 16);
  }
LABEL_20:
  v20 = v11 + 1;
  if (__OFADD__(v11, 1))
    goto LABEL_49;
  if (v20 != v5)
  {
    while (v20 < v5)
    {
      v22 = &v4[i];
      result = sub_217E085E8(*(_QWORD *)&v4[i - 48], *(_QWORD *)&v4[i - 40], *(_QWORD *)&v4[i - 32], a2, a3, v6);
      if ((result & 1) == 0)
      {
        if (v20 != v11)
        {
          if ((v11 & 0x8000000000000000) != 0)
            goto LABEL_43;
          v23 = *((_QWORD *)v4 + 2);
          if (v11 >= v23)
            goto LABEL_44;
          if (v20 >= v23)
            goto LABEL_45;
          v24 = &v4[64 * v11 + 32];
          v35 = *((_OWORD *)v24 + 2);
          v31 = *((_OWORD *)v24 + 3);
          v32 = *((_OWORD *)v24 + 1);
          v37 = *(_OWORD *)(v22 - 56);
          v25 = *((_QWORD *)v22 - 5);
          v38 = *((_QWORD *)v22 - 4);
          v36 = *(_OWORD *)&v4[i - 24];
          v26 = *(_QWORD *)&v4[i];
          v34 = *(_QWORD *)&v4[i - 8];
          v33 = *(_OWORD *)v24;
          swift_unknownObjectRetain();
          swift_unknownObjectRetain();
          swift_unknownObjectRetain();
          swift_unknownObjectRetain();
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
            v4 = sub_217E200B8((uint64_t)v4);
          v27 = &v4[64 * v11];
          *((_OWORD *)v27 + 2) = v37;
          *((_QWORD *)v27 + 6) = v25;
          *((_QWORD *)v27 + 7) = v38;
          *((_OWORD *)v27 + 4) = v36;
          *((_QWORD *)v27 + 10) = v34;
          *((_QWORD *)v27 + 11) = v26;
          swift_unknownObjectRelease();
          result = swift_unknownObjectRelease();
          if (v20 >= *((_QWORD *)v4 + 2))
            goto LABEL_46;
          v28 = &v4[i];
          *(_OWORD *)(v28 - 56) = v33;
          *(_OWORD *)(v28 - 40) = v32;
          *(_OWORD *)(v28 - 24) = v35;
          *(_OWORD *)(v28 - 8) = v31;
          swift_unknownObjectRelease();
          result = swift_unknownObjectRelease();
          v6 = a4;
          *v30 = v4;
        }
        if (__OFADD__(v11++, 1))
          goto LABEL_41;
      }
      ++v20;
      v5 = *((_QWORD *)v4 + 2);
      i += 64;
      if (v20 == v5)
        return v11;
    }
LABEL_40:
    __break(1u);
LABEL_41:
    __break(1u);
LABEL_42:
    __break(1u);
LABEL_43:
    __break(1u);
LABEL_44:
    __break(1u);
LABEL_45:
    __break(1u);
LABEL_46:
    __break(1u);
    goto LABEL_47;
  }
  return v11;
}

uint64_t sub_217E208C8(uint64_t result, int64_t a2)
{
  char **v2;
  char *v4;
  int64_t v5;
  uint64_t v6;
  int64_t v7;
  uint64_t v8;
  int64_t v9;
  char *isUniquelyReferenced_nonNull_native;
  int64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;

  if (result < 0)
  {
    __break(1u);
    goto LABEL_21;
  }
  v4 = *v2;
  v5 = *((_QWORD *)*v2 + 2);
  if (v5 < a2)
  {
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }
  v6 = result;
  v7 = a2 - result;
  if (__OFSUB__(a2, result))
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }
  v8 = result - a2;
  if (__OFSUB__(0, v7))
  {
LABEL_23:
    __break(1u);
    goto LABEL_24;
  }
  v9 = v5 - v7;
  if (__OFADD__(v5, v8))
  {
LABEL_24:
    __break(1u);
LABEL_25:
    __break(1u);
    goto LABEL_26;
  }
  isUniquelyReferenced_nonNull_native = (char *)swift_isUniquelyReferenced_nonNull_native();
  if (!(_DWORD)isUniquelyReferenced_nonNull_native || v9 > *((_QWORD *)v4 + 3) >> 1)
  {
    if (v5 <= v9)
      v11 = v5 + v8;
    else
      v11 = v5;
    v4 = sub_217E0E3D4(isUniquelyReferenced_nonNull_native, v11, 1, v4);
  }
  result = swift_arrayDestroy();
  if (!v7)
    goto LABEL_19;
  v12 = *((_QWORD *)v4 + 2);
  v13 = __OFSUB__(v12, a2);
  v14 = v12 - a2;
  if (v13)
    goto LABEL_25;
  v15 = &v4[64 * a2 + 32];
  if (v6 != a2 || &v4[64 * v6 + 32] >= &v15[64 * v14])
    result = (uint64_t)memmove(&v4[64 * v6 + 32], v15, v14 << 6);
  v16 = *((_QWORD *)v4 + 2);
  v13 = __OFADD__(v16, v8);
  v17 = v16 - v7;
  if (!v13)
  {
    *((_QWORD *)v4 + 2) = v17;
LABEL_19:
    *v2 = v4;
    return result;
  }
LABEL_26:
  __break(1u);
  return result;
}

void sub_217E209DC(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v8;

  v8 = swift_unknownObjectRetain();
  sub_217E14A9C(v8, a2, a3, a4);
  if (!v4 && a4 >> 1 != a3 && (uint64_t)(a4 >> 1) <= a3)
    __break(1u);
}

void sub_217E20B60(uint64_t a1)
{
  __asm { BR              X10 }
}

uint64_t sub_217E20B8C(uint64_t a1, char a2)
{
  _BYTE *v2;

  if (a2 == 1)
  {
    if (qword_254F27518 != -1)
      swift_once();
    return qword_254F2BDC8;
  }
  else
  {
    sub_217E04E40();
    swift_allocError();
    *v2 = 10;
    return swift_willThrow();
  }
}

uint64_t sub_217E21234(uint64_t a1)
{
  j__swift_unknownObjectRetain(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(unsigned __int8 *)(a1 + 56));
  swift_unknownObjectRetain();
  return a1;
}

uint64_t sub_217E21274(uint64_t result)
{
  if (result != 1)
    return swift_bridgeObjectRelease();
  return result;
}

uint64_t sub_217E21284(uint64_t result)
{
  if (result != 1)
    return swift_bridgeObjectRetain();
  return result;
}

uint64_t type metadata accessor for AKSRefKey()
{
  return objc_opt_self();
}

unint64_t sub_217E212B8()
{
  unint64_t result;

  result = qword_254F27AD0;
  if (!qword_254F27AD0)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSRefKeyParam, &type metadata for AKSRefKeyParam);
    atomic_store(result, (unint64_t *)&qword_254F27AD0);
  }
  return result;
}

unint64_t sub_217E21300()
{
  unint64_t result;

  result = qword_254F27AD8;
  if (!qword_254F27AD8)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSSystemKeyType, &type metadata for AKSSystemKeyType);
    atomic_store(result, (unint64_t *)&qword_254F27AD8);
  }
  return result;
}

unint64_t sub_217E21348()
{
  unint64_t result;

  result = qword_254F27AE0;
  if (!qword_254F27AE0)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSSystemKeyGeneration, &type metadata for AKSSystemKeyGeneration);
    atomic_store(result, (unint64_t *)&qword_254F27AE0);
  }
  return result;
}

unint64_t sub_217E21390()
{
  unint64_t result;

  result = qword_254F27AE8;
  if (!qword_254F27AE8)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSSystemKeyOperation, &type metadata for AKSSystemKeyOperation);
    atomic_store(result, (unint64_t *)&qword_254F27AE8);
  }
  return result;
}

unint64_t sub_217E213D8()
{
  unint64_t result;

  result = qword_254F27AF0;
  if (!qword_254F27AF0)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSKeyClass, &type metadata for AKSKeyClass);
    atomic_store(result, (unint64_t *)&qword_254F27AF0);
  }
  return result;
}

unint64_t sub_217E21420()
{
  unint64_t result;

  result = qword_254F27AF8;
  if (!qword_254F27AF8)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSRefKeyType, &type metadata for AKSRefKeyType);
    atomic_store(result, (unint64_t *)&qword_254F27AF8);
  }
  return result;
}

unint64_t sub_217E21468()
{
  unint64_t result;

  result = qword_254F27B00;
  if (!qword_254F27B00)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSRefKeyOptions, &type metadata for AKSRefKeyOptions);
    atomic_store(result, (unint64_t *)&qword_254F27B00);
  }
  return result;
}

unint64_t sub_217E214B0()
{
  unint64_t result;

  result = qword_254F27B08;
  if (!qword_254F27B08)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSRefKeyOptions, &type metadata for AKSRefKeyOptions);
    atomic_store(result, (unint64_t *)&qword_254F27B08);
  }
  return result;
}

unint64_t sub_217E214F8()
{
  unint64_t result;

  result = qword_254F27B10;
  if (!qword_254F27B10)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSRefKeyOptions, &type metadata for AKSRefKeyOptions);
    atomic_store(result, (unint64_t *)&qword_254F27B10);
  }
  return result;
}

unint64_t sub_217E21540()
{
  unint64_t result;

  result = qword_254F27B18;
  if (!qword_254F27B18)
  {
    result = MEMORY[0x219A1838C](&protocol conformance descriptor for AKSRefKeyOptions, &type metadata for AKSRefKeyOptions);
    atomic_store(result, (unint64_t *)&qword_254F27B18);
  }
  return result;
}

uint64_t getEnumTagSinglePayload for AKSRefKeyParam(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xE7)
    goto LABEL_17;
  if (a2 + 25 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 25) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 25;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 25;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 25;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0x1A;
  v8 = v6 - 26;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for AKSRefKeyParam(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 25 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 25) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xE7)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xE6)
    return ((uint64_t (*)(void))((char *)&loc_217E21660 + 4 * byte_217E34A54[v4]))();
  *a1 = a2 + 25;
  return ((uint64_t (*)(void))((char *)sub_217E21694 + 4 * byte_217E34A4F[v4]))();
}

uint64_t sub_217E21694(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E2169C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x217E216A4);
  return result;
}

uint64_t sub_217E216B0(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x217E216B8);
  *(_BYTE *)result = a2 + 25;
  return result;
}

uint64_t sub_217E216BC(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E216C4(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AKSRefKeyParam()
{
  return &type metadata for AKSRefKeyParam;
}

uint64_t getEnumTagSinglePayload for AKSSystemKeyType(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xF3)
    goto LABEL_17;
  if (a2 + 13 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 13) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 13;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 13;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 13;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0xE;
  v8 = v6 - 14;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for AKSSystemKeyType(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 13 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 13) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xF3)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xF2)
    return ((uint64_t (*)(void))((char *)&loc_217E217BC + 4 * byte_217E34A5E[v4]))();
  *a1 = a2 + 13;
  return ((uint64_t (*)(void))((char *)sub_217E217F0 + 4 * byte_217E34A59[v4]))();
}

uint64_t sub_217E217F0(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E217F8(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x217E21800);
  return result;
}

uint64_t sub_217E2180C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x217E21814);
  *(_BYTE *)result = a2 + 13;
  return result;
}

uint64_t sub_217E21818(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E21820(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AKSSystemKeyType()
{
  return &type metadata for AKSSystemKeyType;
}

ValueMetadata *type metadata accessor for AKSSystemKeyGeneration()
{
  return &type metadata for AKSSystemKeyGeneration;
}

uint64_t _s13AppleKeyStore22AKSSystemKeyGenerationOwet_0(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFE)
    goto LABEL_17;
  if (a2 + 2 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 2) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 2;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 2;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 2;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 3;
  v8 = v6 - 3;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t _s13AppleKeyStore22AKSSystemKeyGenerationOwst_0(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 2 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 2) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFE)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFD)
    return ((uint64_t (*)(void))((char *)&loc_217E21930 + 4 * byte_217E34A68[v4]))();
  *a1 = a2 + 2;
  return ((uint64_t (*)(void))((char *)sub_217E21964 + 4 * byte_217E34A63[v4]))();
}

uint64_t sub_217E21964(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E2196C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x217E21974);
  return result;
}

uint64_t sub_217E21980(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x217E21988);
  *(_BYTE *)result = a2 + 2;
  return result;
}

uint64_t sub_217E2198C(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E21994(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AKSSystemKeyOperation()
{
  return &type metadata for AKSSystemKeyOperation;
}

ValueMetadata *type metadata accessor for AKSHandle()
{
  return &type metadata for AKSHandle;
}

uint64_t getEnumTagSinglePayload for AKSKeyClass(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xED)
    goto LABEL_17;
  if (a2 + 19 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 19) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 19;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 19;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 19;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0x14;
  v8 = v6 - 20;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for AKSKeyClass(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 19 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 19) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xED)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xEC)
    return ((uint64_t (*)(void))((char *)&loc_217E21A9C + 4 * byte_217E34A72[v4]))();
  *a1 = a2 + 19;
  return ((uint64_t (*)(void))((char *)sub_217E21AD0 + 4 * byte_217E34A6D[v4]))();
}

uint64_t sub_217E21AD0(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E21AD8(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x217E21AE0);
  return result;
}

uint64_t sub_217E21AEC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x217E21AF4);
  *(_BYTE *)result = a2 + 19;
  return result;
}

uint64_t sub_217E21AF8(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E21B00(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AKSKeyClass()
{
  return &type metadata for AKSKeyClass;
}

uint64_t getEnumTagSinglePayload for AKSRefKeyType(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xF5)
    goto LABEL_17;
  if (a2 + 11 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 11) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 11;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 11;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 11;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0xC;
  v8 = v6 - 12;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for AKSRefKeyType(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 11 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 11) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xF5)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xF4)
    return ((uint64_t (*)(void))((char *)&loc_217E21BF8 + 4 * byte_217E34A7C[v4]))();
  *a1 = a2 + 11;
  return ((uint64_t (*)(void))((char *)sub_217E21C2C + 4 * byte_217E34A77[v4]))();
}

uint64_t sub_217E21C2C(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E21C34(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x217E21C3CLL);
  return result;
}

uint64_t sub_217E21C48(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x217E21C50);
  *(_BYTE *)result = a2 + 11;
  return result;
}

uint64_t sub_217E21C54(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E21C5C(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for AKSRefKeyType()
{
  return &type metadata for AKSRefKeyType;
}

ValueMetadata *type metadata accessor for AKSRefKeyOptions()
{
  return &type metadata for AKSRefKeyOptions;
}

uint64_t type metadata accessor for AKSRefKeyParams()
{
  return objc_opt_self();
}

uint64_t method lookup function for AKSRefKeyParams()
{
  return swift_lookUpClassMethod();
}

uint64_t dispatch thunk of AKSRefKeyParams.__allocating_init()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 112))();
}

uint64_t dispatch thunk of AKSRefKeyParams.set_BOOL(key:value:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 120))();
}

uint64_t dispatch thunk of AKSRefKeyParams.get_BOOL(key:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 128))() & 1;
}

uint64_t dispatch thunk of AKSRefKeyParams.set_number(key:value:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 136))();
}

uint64_t dispatch thunk of AKSRefKeyParams.get_number(key:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 144))();
}

uint64_t dispatch thunk of AKSRefKeyParams.set_data(key:value:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 152))();
}

uint64_t dispatch thunk of AKSRefKeyParams.get_data(key:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 160))();
}

uint64_t dispatch thunk of AKSRefKeyParams.serialize()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 168))();
}

uint64_t destroy for AKSRefKeyKemOutput()
{
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

_QWORD *_s13AppleKeyStore18AKSRefKeyKemOutputVwCP_0(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

_QWORD *assignWithCopy for AKSRefKeyKemOutput(_QWORD *a1, _QWORD *a2)
{
  *a1 = *a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[1] = a2[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy16_8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

_OWORD *assignWithTake for AKSRefKeyKemOutput(_OWORD *a1, _OWORD *a2)
{
  swift_bridgeObjectRelease();
  *a1 = *a2;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for AKSRefKeyKemOutput(uint64_t *a1, int a2)
{
  uint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *((_BYTE *)a1 + 16))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for AKSRefKeyKemOutput(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)result = a2 ^ 0x80000000;
    *(_QWORD *)(result + 8) = 0;
    if (a3 < 0)
      *(_BYTE *)(result + 16) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)result = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 16) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for AKSRefKeyKemOutput()
{
  return &type metadata for AKSRefKeyKemOutput;
}

uint64_t method lookup function for AKSRefKey()
{
  return swift_lookUpClassMethod();
}

uint64_t dispatch thunk of AKSRefKey.__allocating_init(handle:key_class:key_type:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 176))();
}

uint64_t dispatch thunk of AKSRefKey.__allocating_init(handle:blob:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 184))();
}

uint64_t dispatch thunk of AKSRefKey.__allocating_init(handle:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 192))();
}

uint64_t dispatch thunk of AKSRefKey.sign(digest:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 224))();
}

uint64_t dispatch thunk of AKSRefKey.encrypt(data:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 232))();
}

uint64_t dispatch thunk of AKSRefKey.decrypt(data:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 240))();
}

uint64_t dispatch thunk of AKSRefKey.delete(params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 248))();
}

uint64_t dispatch thunk of AKSRefKey.set_key_class(key_class:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 256))();
}

uint64_t dispatch thunk of AKSRefKey.wrap(key:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 264))();
}

uint64_t dispatch thunk of AKSRefKey.unwrap(key:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 272))();
}

uint64_t dispatch thunk of AKSRefKey.transcrypt(dst_handle:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 280))();
}

uint64_t dispatch thunk of AKSRefKey.compute_key(public_key:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 288))();
}

uint64_t dispatch thunk of AKSRefKey.ecies_encrypt(public_key:data:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 296))();
}

uint64_t dispatch thunk of AKSRefKey.ecies_decrypt(data:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 304))();
}

uint64_t dispatch thunk of AKSRefKey.ecies_transcode(public_key:data:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 312))();
}

uint64_t dispatch thunk of AKSRefKey.encapsulate(public_key:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 320))();
}

uint64_t dispatch thunk of AKSRefKey.decapsulate(cipher_text:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 328))();
}

uint64_t dispatch thunk of AKSRefKey.attest(ref_key:params:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 336))();
}

uint64_t dispatch thunk of AKSRefKey.serialize()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 344))();
}

uint64_t dispatch thunk of AKSRefKey.type()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 368))();
}

uint64_t dispatch thunk of AKSRefKey.public_key()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 376))();
}

uint64_t dispatch thunk of AKSRefKey.external_data()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 384))();
}

uint64_t dispatch thunk of AKSRefKey.uuid()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 392))();
}

uint64_t dispatch thunk of AKSRefKey.version()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 400))();
}

uint64_t dispatch thunk of AKSRefKey.keybag_handle()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 408))();
}

uint64_t dispatch thunk of AKSRefKey.key_class()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 416))();
}

uint64_t dispatch thunk of AKSRefKey.options()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 424))();
}

uint64_t dispatch thunk of AKSRefKey.validate()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 432))();
}

uint64_t sub_217E2220C(uint64_t a1)
{
  j__swift_unknownObjectRetain(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
  return a1;
}

uint64_t sub_217E22240(uint64_t *a1)
{
  uint64_t v1;

  return sub_217E157E0(a1, **(_QWORD **)(v1 + 16), (uint64_t (*)(_BYTE *, uint64_t))sub_217E202E0);
}

uint64_t sub_217E22264(uint64_t *a1)
{
  uint64_t v1;

  return sub_217E0A7B0(a1, *(_BYTE *)(v1 + 16));
}

uint64_t sub_217E2228C(uint64_t a1)
{
  return sub_217E09BB4(a1);
}

unint64_t sub_217E222B4()
{
  unint64_t result;
  uint64_t v1;

  result = qword_254F27B20;
  if (!qword_254F27B20)
  {
    v1 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_254F27B28);
    result = MEMORY[0x219A1838C](MEMORY[0x24BEE2188], v1);
    atomic_store(result, (unint64_t *)&qword_254F27B20);
  }
  return result;
}

uint64_t sub_217E22300()
{
  swift_unknownObjectRetain();
  sub_217E2D110();
  sub_217E2CFD8();
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  sub_217E2CFD8();
  return 0x28796E41314E5341;
}

ValueMetadata *type metadata accessor for ASN1Any()
{
  return &type metadata for ASN1Any;
}

unint64_t sub_217E223AC()
{
  unint64_t result;

  result = qword_254F27B30;
  if (!qword_254F27B30)
  {
    result = MEMORY[0x219A1838C](&unk_217E353CC, &type metadata for ASN1Any);
    atomic_store(result, (unint64_t *)&qword_254F27B30);
  }
  return result;
}

uint64_t sub_217E223F0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  _QWORD v7[2];

  v0 = sub_217E2D074();
  v1 = *(_QWORD *)(v0 - 8);
  MEMORY[0x24BDAC7A8](v0);
  v3 = (char *)v7 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  v4 = sub_217E2D08C();
  MEMORY[0x24BDAC7A8](v4);
  v5 = sub_217E2CF6C();
  MEMORY[0x24BDAC7A8](v5);
  sub_217E22A8C();
  sub_217E2CF60();
  v7[1] = MEMORY[0x24BEE4AF8];
  sub_217E22AC8();
  __swift_instantiateConcreteTypeFromMangledName(&qword_254F27B50);
  sub_217E22B10();
  sub_217E2D128();
  (*(void (**)(char *, _QWORD, uint64_t))(v1 + 104))(v3, *MEMORY[0x24BEE5758], v0);
  result = sub_217E2D098();
  qword_254F2C728 = result;
  return result;
}

void sub_217E22580()
{
  mach_port_t v0;
  io_service_t MatchingService;
  const __CFDictionary *v2;
  int v3;
  _BYTE *v4;
  _BYTE *v5;
  io_connect_t connect;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (!dword_254F27B38)
  {
    connect = 0;
    v0 = *MEMORY[0x24BDD8B18];
    MatchingService = IORegistryEntryFromPath(*MEMORY[0x24BDD8B18], "IOService:/IOResources/AppleKeyStore");
    if (!MatchingService)
    {
      v2 = IOServiceMatching("AppleKeyStore");
      MatchingService = IOServiceGetMatchingService(v0, v2);
      if (!MatchingService)
      {
        sub_217E04E40();
        swift_allocError();
        *v5 = 21;
        swift_willThrow();
        return;
      }
    }
    if (!IOServiceOpen(MatchingService, *MEMORY[0x24BDAEC58], 0, &connect))
    {
      v3 = connect;
      if (!IOConnectCallMethod(connect, 0, 0, 0, 0, 0, 0, 0, 0, 0))
      {
        dword_254F27B38 = v3;
        goto LABEL_8;
      }
      IOServiceClose(v3);
    }
    sub_217E04E40();
    swift_allocError();
    *v4 = 21;
    swift_willThrow();
LABEL_8:
    IOObjectRelease(MatchingService);
  }
}

uint64_t sub_217E226FC()
{
  return swift_deallocClassInstance();
}

uint64_t type metadata accessor for AKSUserClient()
{
  return objc_opt_self();
}

uint64_t sub_217E2272C(uint32_t a1, uint64_t a2, uint64_t a3, char **a4, uint64_t *a5)
{
  size_t v5;
  uint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v12;
  unint64_t v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  id v17;
  unint64_t v18;
  const uint64_t *v19;
  const void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void *v26;
  const uint64_t *v27;
  size_t inputStructCnt;
  uint64_t *v29;
  size_t v32;
  uint32_t outputCnt;
  uint64_t v34;

  v9 = v6;
  v34 = *MEMORY[0x24BDAC8D0];
  v12 = *a4;
  if (*a4)
  {
    v13 = *((_QWORD *)v12 + 2);
    if (HIDWORD(v13))
    {
      __break(1u);
      goto LABEL_42;
    }
    v8 = *a4;
  }
  else
  {
    LODWORD(v13) = 0;
    v8 = (char *)MEMORY[0x24BEE4AF8];
  }
  outputCnt = v13;
  v14 = *a5;
  v29 = a5;
  if (*a5)
  {
    v15 = *(_QWORD *)(v14 + 16);
    v7 = (char *)*a5;
  }
  else
  {
    v15 = 0;
    v7 = (char *)MEMORY[0x24BEE4AF8];
  }
  v32 = v15;
  v16 = qword_254F27770;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  if (v16 != -1)
    swift_once();
  v17 = (id)qword_254F2C728;
  sub_217E2D080();
  if (!v9)
  {

    v5 = dword_254F27B38;
    if (!a2)
    {
      LODWORD(v18) = 0;
      if (a3)
        goto LABEL_15;
      goto LABEL_17;
    }
    v18 = *(_QWORD *)(a2 + 16);
    if (!HIDWORD(v18))
    {
      if (a3)
      {
LABEL_15:
        inputStructCnt = *(_QWORD *)(a3 + 16);
        goto LABEL_18;
      }
LABEL_17:
      inputStructCnt = 0;
LABEL_18:
      if (a2)
        v19 = (const uint64_t *)(a2 + 32);
      else
        v19 = 0;
      v20 = (const void *)(a3 + 32);
      if (!a3)
        v20 = 0;
      v26 = v20;
      v27 = v19;
      swift_bridgeObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
        v8 = sub_217E0E4D4(0, *((_QWORD *)v8 + 2), 0, v8);
      swift_bridgeObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
        v7 = sub_217E0E2EC(0, *((_QWORD *)v7 + 2), 0, v7);
      a2 = IOConnectCallMethod(v5, a1, v27, v18, v26, inputStructCnt, (uint64_t *)v8 + 4, &outputCnt, v7 + 32, &v32);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if (v12)
      {
        swift_bridgeObjectRelease();
        *a4 = v8;
        if (v14)
          goto LABEL_29;
      }
      else
      {
        swift_bridgeObjectRelease();
        if (v14)
        {
LABEL_29:
          v8 = v7 + 32;
          v5 = v32;
          if ((v32 & 0x8000000000000000) == 0)
          {
            if (*((_QWORD *)v7 + 2) >= v32)
            {
              sub_217E2D194();
              swift_bridgeObjectRetain();
              swift_unknownObjectRetain_n();
              v21 = swift_dynamicCastClass();
              if (!v21)
              {
                swift_bridgeObjectRelease();
                v21 = MEMORY[0x24BEE4AF8];
              }
              v22 = *(_QWORD *)(v21 + 16);
              swift_release();
              if (v22 == v5)
              {
                v23 = swift_dynamicCastClass();
                if (!v23)
                {
                  swift_bridgeObjectRelease();
                  v24 = MEMORY[0x24BEE4AF8];
                  goto LABEL_39;
                }
LABEL_35:
                v24 = v23;
LABEL_39:
                swift_bridgeObjectRelease();
                swift_bridgeObjectRelease_n();
                *v29 = v24;
                return a2;
              }
LABEL_45:
              swift_bridgeObjectRelease();
              sub_217E200CC((uint64_t)v7, (uint64_t)v8, 0, (2 * v5) | 1);
              goto LABEL_35;
            }
LABEL_44:
            __break(1u);
            goto LABEL_45;
          }
LABEL_43:
          __break(1u);
          goto LABEL_44;
        }
      }
      swift_bridgeObjectRelease();
      return a2;
    }
LABEL_42:
    __break(1u);
    goto LABEL_43;
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();

  return a2;
}

unint64_t sub_217E22A8C()
{
  unint64_t result;

  result = qword_254F27B40;
  if (!qword_254F27B40)
  {
    objc_opt_self();
    result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_254F27B40);
  }
  return result;
}

unint64_t sub_217E22AC8()
{
  unint64_t result;
  uint64_t v1;

  result = qword_254F27B48;
  if (!qword_254F27B48)
  {
    v1 = sub_217E2D08C();
    result = MEMORY[0x219A1838C](MEMORY[0x24BEE5940], v1);
    atomic_store(result, (unint64_t *)&qword_254F27B48);
  }
  return result;
}

unint64_t sub_217E22B10()
{
  unint64_t result;
  uint64_t v1;

  result = qword_254F27B58;
  if (!qword_254F27B58)
  {
    v1 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_254F27B50);
    result = MEMORY[0x219A1838C](MEMORY[0x24BEE12C8], v1);
    atomic_store(result, (unint64_t *)&qword_254F27B58);
  }
  return result;
}

uint64_t sub_217E22B5C(unint64_t a1, char a2, char a3)
{
  char **v3;
  char v5;
  char v6;
  uint64_t v7;
  uint64_t result;
  unint64_t v9;
  unint64_t v10;
  char v11;
  char *v12;
  char v13;
  unint64_t v14;
  unint64_t v15;

  v5 = a2 << 6;
  if (a1 > 0x1E)
  {
    if ((a3 & 1) != 0)
      v11 = 63;
    else
      v11 = 31;
    v12 = *v3;
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      v12 = sub_217E0E2EC(0, *((_QWORD *)v12 + 2) + 1, 1, v12);
    v13 = v5 | v11;
    v15 = *((_QWORD *)v12 + 2);
    v14 = *((_QWORD *)v12 + 3);
    if (v15 >= v14 >> 1)
      v12 = sub_217E0E2EC((char *)(v14 > 1), v15 + 1, 1, v12);
    *((_QWORD *)v12 + 2) = v15 + 1;
    v12[v15 + 32] = v13;
    *v3 = v12;
    return sub_217E12060(a1);
  }
  else
  {
    if ((a3 & 1) != 0)
      v6 = v5 | a1 | 0x20;
    else
      v6 = v5 | a1;
    v7 = (uint64_t)*v3;
    result = swift_isUniquelyReferenced_nonNull_native();
    if ((result & 1) == 0)
    {
      result = (uint64_t)sub_217E0E2EC(0, *(_QWORD *)(v7 + 16) + 1, 1, (char *)v7);
      v7 = result;
    }
    v10 = *(_QWORD *)(v7 + 16);
    v9 = *(_QWORD *)(v7 + 24);
    if (v10 >= v9 >> 1)
    {
      result = (uint64_t)sub_217E0E2EC((char *)(v9 > 1), v10 + 1, 1, (char *)v7);
      v7 = result;
    }
    *(_QWORD *)(v7 + 16) = v10 + 1;
    *(_BYTE *)(v7 + v10 + 32) = v6;
    *v3 = (char *)v7;
  }
  return result;
}

uint64_t sub_217E22CB0()
{
  sub_217E2D1E8();
  sub_217E2D1F4();
  sub_217E2D1F4();
  return sub_217E2D218();
}

uint64_t sub_217E22D0C()
{
  sub_217E2D1F4();
  return sub_217E2D1F4();
}

uint64_t sub_217E22D48()
{
  sub_217E2D1E8();
  sub_217E2D1F4();
  sub_217E2D1F4();
  return sub_217E2D218();
}

BOOL sub_217E22DA0(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)a1 == *(_QWORD *)a2 && *(unsigned __int8 *)(a1 + 8) == *(unsigned __int8 *)(a2 + 8);
}

uint64_t sub_217E22DCC()
{
  sub_217E2D134();
  sub_217E2CFD8();
  sub_217E2D17C();
  sub_217E2CFD8();
  swift_bridgeObjectRelease();
  sub_217E2CFD8();
  sub_217E2D158();
  sub_217E2CFD8();
  return 0;
}

uint64_t sub_217E22EC8()
{
  return sub_217E22DCC();
}

unint64_t sub_217E22ED8()
{
  unint64_t result;

  result = qword_254F27B60;
  if (!qword_254F27B60)
  {
    result = MEMORY[0x219A1838C](&unk_217E354A4, &type metadata for ASN1Identifier);
    atomic_store(result, (unint64_t *)&qword_254F27B60);
  }
  return result;
}

uint64_t sub_217E22F1C(unsigned __int8 a1)
{
  return a1 >> 6;
}

uint64_t sub_217E22F24(char a1)
{
  uint64_t result;

  result = a1 & 0x1F;
  if ((_DWORD)result == 31)
    __break(1u);
  return result;
}

uint64_t getEnumTagSinglePayload for ASN1Identifier.TagClass(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFD)
    goto LABEL_17;
  if (a2 + 3 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 3) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 3;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 3;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 3;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 4;
  v8 = v6 - 4;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for ASN1Identifier.TagClass(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 3 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 3) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFD)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFC)
    return ((uint64_t (*)(void))((char *)&loc_217E2301C + 4 * byte_217E35475[v4]))();
  *a1 = a2 + 3;
  return ((uint64_t (*)(void))((char *)sub_217E23050 + 4 * asc_217E35470[v4]))();
}

uint64_t sub_217E23050(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E23058(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x217E23060);
  return result;
}

uint64_t sub_217E2306C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x217E23074);
  *(_BYTE *)result = a2 + 3;
  return result;
}

uint64_t sub_217E23078(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_217E23080(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for ASN1Identifier.TagClass()
{
  return &type metadata for ASN1Identifier.TagClass;
}

uint64_t __swift_memcpy9_8(uint64_t result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *(_BYTE *)(result + 8) = *((_BYTE *)a2 + 8);
  *(_QWORD *)result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for ASN1Identifier(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  BOOL v4;
  int v5;

  if (!a2)
    return 0;
  if (a2 >= 0xFD && *(_BYTE *)(a1 + 9))
    return (*(_DWORD *)a1 + 253);
  v3 = *(unsigned __int8 *)(a1 + 8);
  v4 = v3 >= 4;
  v5 = v3 - 4;
  if (!v4)
    v5 = -1;
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for ASN1Identifier(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFC)
  {
    *(_BYTE *)(result + 8) = 0;
    *(_QWORD *)result = a2 - 253;
    if (a3 >= 0xFD)
      *(_BYTE *)(result + 9) = 1;
  }
  else
  {
    if (a3 >= 0xFD)
      *(_BYTE *)(result + 9) = 0;
    if (a2)
      *(_BYTE *)(result + 8) = a2 + 3;
  }
  return result;
}

ValueMetadata *type metadata accessor for ASN1Identifier()
{
  return &type metadata for ASN1Identifier;
}

unint64_t sub_217E2314C()
{
  unint64_t result;

  result = qword_254F27B68;
  if (!qword_254F27B68)
  {
    result = MEMORY[0x219A1838C](&unk_217E35574, &type metadata for ASN1Identifier.TagClass);
    atomic_store(result, (unint64_t *)&qword_254F27B68);
  }
  return result;
}

uint64_t X509PolicySetFlagsForCommonNames(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  unint64_t v4[3];

  v4[2] = *MEMORY[0x24BDAC8D0];
  v4[0] = 0xAAAAAAAAAAAAAAAALL;
  v4[1] = 0xAAAAAAAAAAAAAAAALL;
  result = X509CertificateSubjectNameGetCommonName((unint64_t *)(a1 + 104), v4);
  if (!(_DWORD)result)
  {
    result = compare_octet_string((uint64_t)&iPhoneCAName, (uint64_t)v4);
    if ((_DWORD)result)
    {
      result = compare_octet_string((uint64_t)&CodeSigningCAName, (uint64_t)v4);
      if ((_DWORD)result)
      {
        result = compare_octet_string_partial((uint64_t)&MFi4AccessoryCAName, (uint64_t)v4);
        if ((_DWORD)result)
        {
          result = compare_octet_string_partial((uint64_t)&MFi4AttestationCAName, (uint64_t)v4);
          if ((_DWORD)result)
          {
            result = compare_octet_string_partial((uint64_t)&MFi4ProvisioningCAName, (uint64_t)v4);
            if ((_DWORD)result)
              return result;
            v3 = 0x1000000000;
          }
          else
          {
            v3 = 0x800000000;
          }
        }
        else
        {
          v3 = 0x400000000;
        }
      }
      else
      {
        v3 = 8;
      }
    }
    else
    {
      v3 = 3840;
    }
    *(_QWORD *)(a1 + 240) |= v3;
  }
  return result;
}

double X509PolicySetFlagsForMFI(uint64_t a1)
{
  double result;
  time_t v3;
  tm v4;
  time_t v5;
  unint64_t v6[3];

  v6[2] = *MEMORY[0x24BDAC8D0];
  v6[0] = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = 0xAAAAAAAAAAAAAAAALL;
  if (!X509CertificateSubjectNameGetCommonName((unint64_t *)(a1 + 104), v6))
  {
    if (compare_octet_string_partial((uint64_t)&MFICommonNamePrefix, (uint64_t)v6))
      goto LABEL_3;
    v5 = 0;
    if (!X509CertificateGetNotBefore(a1, &v5))
    {
      memset(&v4, 0, sizeof(v4));
      strptime("2006-05-31", "%F", &v4);
      v3 = timegm(&v4);
      result = difftime(v3, v5);
      if (result < 0.0)
      {
        *(_QWORD *)(a1 + 240) |= 0x8000000uLL;
LABEL_3:
        if (!compare_octet_string_partial((uint64_t)&MFi4ProvisioningHostNamePrefix, (uint64_t)v6))
          *(_QWORD *)(a1 + 240) |= 0x1000000000uLL;
      }
    }
  }
  return result;
}

uint64_t X509PolicySetFlagsForRoots(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!result)
    return result;
  v3 = result;
  if (*(_BYTE *)(result + 16))
  {
    result = compare_octet_string(a2 + 88, (uint64_t)&AppleRootCASPKI);
    if (!(_DWORD)result
      || (result = compare_octet_string(a2 + 88, (uint64_t)&AppleRootG2SPKI), !(_DWORD)result)
      || (result = compare_octet_string(a2 + 88, (uint64_t)&AppleRootG3SPKI), !(_DWORD)result))
    {
      v5 = *(_QWORD *)(a2 + 240) | 0x58E30653FFF8;
      goto LABEL_11;
    }
  }
  v4 = *(_QWORD *)(v3 + 8);
  if ((v4 & 0x1000000) != 0)
  {
    result = compare_octet_string(a2 + 88, (uint64_t)&UcrtRootSpki);
    if (!(_DWORD)result)
    {
      v5 = *(_QWORD *)(a2 + 240) | 0x1000000;
      goto LABEL_11;
    }
LABEL_13:
    if (*(_BYTE *)(v3 + 17))
      result = X509PolicySetFlagsForTestAnchor((_QWORD *)v3, a2);
    goto LABEL_15;
  }
  if ((v4 & 0x1C00000000) == 0)
    goto LABEL_15;
  result = compare_octet_string(a2 + 88, (uint64_t)&MFi4RootSpki);
  if ((_DWORD)result)
    goto LABEL_13;
  v5 = *(_QWORD *)(a2 + 240) | 0x1C00000000;
LABEL_11:
  *(_QWORD *)(a2 + 240) = v5;
LABEL_15:
  if (*(_BYTE *)(v3 + 16))
  {
    if (*(_BYTE *)(v3 + 17))
    {
      result = compare_octet_string(a2 + 88, (uint64_t)&TestAppleRootCASPKI);
      if (!(_DWORD)result
        || (result = compare_octet_string(a2 + 88, (uint64_t)&TestAppleRootG2SPKI), !(_DWORD)result)
        || (result = compare_octet_string(a2 + 88, (uint64_t)&TestAppleRootG3SPKI), !(_DWORD)result))
      {
        *(_QWORD *)(a2 + 240) |= 0x58E30653FFF8uLL;
      }
    }
    if (*(_BYTE *)(v3 + 16) && *(_BYTE *)(v3 + 17))
    {
      result = compare_octet_string(a2 + 88, (uint64_t)&TestAppleRootECCSPKI);
      if (!(_DWORD)result)
        *(_QWORD *)(a2 + 240) |= 0x6400000uLL;
    }
  }
  return result;
}

uint64_t X509PolicySetFlagsForTestAnchor(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  _QWORD v5[2];
  unint64_t v6[3];

  v6[2] = *MEMORY[0x24BDAC8D0];
  v6[0] = 0;
  v6[1] = 0;
  v5[0] = 0;
  v5[1] = 0;
  result = X509CertificateParseSPKI((unint64_t *)(a2 + 88), v6, 0, v5);
  if (!(_DWORD)result)
  {
    result = compare_octet_string(a1[4], (uint64_t)v6);
    if (!(_DWORD)result)
    {
      result = compare_octet_string(a1[3], (uint64_t)v5);
      if (!(_DWORD)result)
        *(_QWORD *)(a2 + 240) |= a1[1];
    }
  }
  return result;
}

uint64_t X509PolicyCheckForBlockedKeys(uint64_t a1)
{
  uint64_t result;

  result = compare_octet_string(a1 + 88, (uint64_t)&BlockedYonkersSPKI);
  if (!(_DWORD)result)
    *(_QWORD *)(a1 + 240) &= 0xFFFFFFFFFFF3FFFFLL;
  return result;
}

int *find_digest(uint64_t a1)
{
  unint64_t v2;
  int *result;

  v2 = 0;
  while (1)
  {
    result = (int *)compare_octet_string_raw((uint64_t)&digests[v2 / 4 + 2], *(const void **)a1, *(_QWORD *)(a1 + 8));
    if (!(_DWORD)result)
      break;
    v2 += 32;
    if (v2 == 160)
      return 0;
  }
  if (v2 <= ~(unint64_t)digests)
    return &digests[v2 / 4];
  __break(0x5513u);
  return result;
}

int *find_digest_by_type(int *result)
{
  unint64_t v1;

  v1 = 0;
  while (digests[v1 / 4] != (_DWORD)result)
  {
    v1 += 32;
    if (v1 == 160)
      return 0;
  }
  if (v1 <= ~(unint64_t)digests)
    return &digests[v1 / 4];
  __break(0x5513u);
  return result;
}

uint64_t find_digestOID_for_signingOID(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  void *v6;

  if (!compare_octet_string_raw(a1, &sha1WithRSA_oid, 9uLL)
    || !compare_octet_string_raw(a1, &sha1WithECDSA_oid, 7uLL))
  {
    v6 = &CTOidSha1;
    v4 = 5;
    goto LABEL_11;
  }
  v4 = 9;
  if (!compare_octet_string_raw(a1, &sha256WithRSA_oid, 9uLL))
  {
    v6 = &CTOidSha256;
    goto LABEL_11;
  }
  if (!compare_octet_string_raw(a1, &sha256WithECDSA_oid, 8uLL))
  {
    v6 = &CTOidSha256;
LABEL_18:
    v4 = 9;
    goto LABEL_11;
  }
  v4 = 9;
  if (!compare_octet_string_raw(a1, &sha384WithRSA_oid, 9uLL))
  {
    v6 = &CTOidSha384;
    goto LABEL_11;
  }
  if (!compare_octet_string_raw(a1, &sha384WithECDSA_oid, 8uLL))
  {
    v6 = &CTOidSha384;
    goto LABEL_18;
  }
  v4 = 9;
  if (compare_octet_string_raw(a1, &sha512WithRSA_oid, 9uLL))
  {
    if (compare_octet_string_raw(a1, &sha512WithECDSA_oid, 8uLL))
      return 0;
    v6 = &CTOidSha512;
    goto LABEL_18;
  }
  v6 = &CTOidSha512;
LABEL_11:
  *a2 = v6;
  a2[1] = v4;
  return 1;
}

unint64_t validateSignatureRSA(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  unint64_t result;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  __int128 v18;
  unint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char v23;
  char v24;
  unint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t vars0;

  result = 0;
  v27 = *MEMORY[0x24BDAC8D0];
  v23 = 0;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            result = compare_octet_string((uint64_t)&rsaEncryption, (uint64_t)(a5 + 7));
            if (!(_DWORD)result
              || (result = validateOIDs((uint64_t)&rsaAlgs, (uint64_t)(a5 + 3), (uint64_t)(a5 + 7)), (_DWORD)result))
            {
              v21 = 0xAAAAAAAAAAAAAAAALL;
              v22 = 0xAAAAAAAAAAAAAAAALL;
              v10 = a5[9];
              v9 = a5[10];
              if (__CFADD__(v10, v9))
                goto LABEL_31;
              if (v10 > v10 + v9)
                goto LABEL_32;
              v21 = a5[9];
              v22 = v10 + v9;
              if (!v9 || (result = ccder_blob_check_null(), (_DWORD)result))
              {
                if (!__CFADD__(a1, a2))
                {
                  if (a1 + a2 >= a1)
                  {
                    result = ccder_decode_rsa_pub_n();
                    if (!result)
                      return result;
                    v11 = result;
                    if (result >> 58)
                    {
LABEL_33:
                      __break(0x550Cu);
                      return result;
                    }
                    v12 = result << 6;
                    if (result << 6 < 0x400)
                      return 0;
                    v25 = 0xAAAAAAAAAAAAAAAALL;
                    v26 = -21846;
                    v24 = 6;
                    if (&vars0 != (uint64_t *)82)
                    {
                      v13 = a5[4];
                      LOBYTE(v25) = v13;
                      if ((unint64_t)&v24 <= 0xFFFFFFFFFFFFFFFDLL)
                      {
                        if (v13 <= 9)
                        {
                          v14 = __memcpy_chk();
                          if (v12 > 0x1068)
                            return 0;
                          result = MEMORY[0x24BDAC7A8](v14);
                          v16 = (unint64_t *)((char *)&v20 - v15);
                          v17 = 0;
                          *(_QWORD *)&v18 = 0xAAAAAAAAAAAAAAAALL;
                          *((_QWORD *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
                          do
                          {
                            v19 = &v16[v17 / 8];
                            *(_OWORD *)v19 = v18;
                            *((_OWORD *)v19 + 1) = v18;
                            v17 += 32;
                          }
                          while (v15 != v17);
                          if (v15 >= 1)
                          {
                            *v16 = v11;
                            if (ccrsa_import_pub())
                              return 0;
                            if (!ccrsa_verify_pkcs1v15_allowshortsigs())
                              return v23 != 0;
                            result = 0;
                            v23 = 0;
                            return result;
                          }
                        }
                        goto LABEL_32;
                      }
                    }
                    goto LABEL_31;
                  }
LABEL_32:
                  __break(0x5519u);
                  goto LABEL_33;
                }
LABEL_31:
                __break(0x5513u);
                goto LABEL_32;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL validateOIDs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  BOOL v7;

  v6 = 0;
  v7 = 1;
  do
  {
    if (!compare_octet_string(a1, a2) && !compare_octet_string(a1 + 16, a3))
      break;
    v7 = v6 < 3;
    a1 += 32;
    ++v6;
  }
  while (v6 != 4);
  return v7;
}

_UNKNOWN **oidForPubKeyLength()
{
  uint64_t v0;
  int is_supported;
  _UNKNOWN **v2;
  _UNKNOWN **v3;
  _UNKNOWN **v4;

  v0 = ccec_x963_import_pub_size();
  is_supported = ccec_keysize_is_supported();
  v2 = &CTOidSECP256r1;
  v3 = &CTOidSECP521r1;
  v4 = &CTOidSECP384r1;
  if (v0 != 384)
    v4 = 0;
  if (v0 != 521)
    v3 = v4;
  if (v0 != 256)
    v2 = v3;
  if (is_supported)
    return v2;
  else
    return 0;
}

uint64_t validateSignatureEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t *v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = 0;
  v18 = *MEMORY[0x24BDAC8D0];
  HIBYTE(v17) = 0;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            if (!compare_octet_string((uint64_t)&ecPublicKey, a5 + 56)
              || (result = validateOIDs((uint64_t)&ecAlgs, a5 + 24, a5 + 56), (_DWORD)result))
            {
              result = ccec_cp_for_oid((int **)(a5 + 72));
              if (result)
              {
                v8 = *(_QWORD *)result;
                if (*(_QWORD *)result >> 61 || !is_mul_ok(8 * v8, 3uLL))
                {
                  __break(0x550Cu);
                }
                else
                {
                  v9 = 24 * v8;
                  v10 = __CFADD__(v9, 16);
                  v11 = v9 + 16;
                  if (!v10 && v11 < 0xFFFFFFFFFFFFFFF0)
                  {
                    result = MEMORY[0x24BDAC7A8](result);
                    v14 = (uint64_t *)((char *)&v17 - v12);
                    v15 = 0;
                    do
                    {
                      v16 = &v14[v15 / 8];
                      *v16 = 0xAAAAAAAAAAAAAAAALL;
                      v16[1] = 0xAAAAAAAAAAAAAAAALL;
                      v15 += 16;
                    }
                    while (v12 != v15);
                    if (v13 >= 0x10)
                    {
                      *v14 = result;
                      if (v12 >= 1)
                      {
                        if (!ccec_import_pub())
                        {
                          result = ccec_x963_import_pub_size();
                          if (result == 256 && *(_QWORD *)(a5 + 96) == 64)
                          {
                            if (*(_QWORD *)(a5 + 88) < 0xFFFFFFFFFFFFFFE0)
                            {
                              if (!ccec_verify_composite())
                                return HIBYTE(v17) != 0;
                              goto LABEL_24;
                            }
LABEL_31:
                            __break(0x5513u);
                            return result;
                          }
                          if (ccec_verify())
LABEL_24:
                            HIBYTE(v17) = 0;
                        }
                        return HIBYTE(v17) != 0;
                      }
LABEL_30:
                      __break(0x5519u);
                      goto LABEL_31;
                    }
LABEL_29:
                    __break(1u);
                    goto LABEL_30;
                  }
                }
                __break(0x5500u);
                goto LABEL_29;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t ccec_cp_for_oid(int **a1)
{
  int *v1;
  int *v3;
  int v5;
  int v6;

  if (!a1)
    return 0;
  v1 = a1[1];
  if (v1 != (int *)7)
  {
    if (v1 == (int *)10 && *(_QWORD *)*a1 == 0x33DCE48862A0806 && *((_WORD *)*a1 + 4) == 1793)
      JUMPOUT(0x219A17EA0);
    return 0;
  }
  v3 = *a1;
  if (**a1 == -2127887098 && *(int *)((char *)*a1 + 3) == 570426497)
    JUMPOUT(0x219A17EACLL);
  v5 = *v3;
  v6 = *(int *)((char *)v3 + 3);
  if (v5 != -2127887098 || v6 != 587203713)
    return 0;
  return ccec_cp_521();
}

void compressECPublicKey(uint64_t a1, int **a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x24BDAC8D0];
  v6 = (_QWORD *)ccec_cp_for_oid(a2);
  if (!v6)
    return;
  v7 = v6;
  v8 = *v6;
  if (*v6 >> 61 || !is_mul_ok(8 * v8, 3uLL))
  {
    __break(0x550Cu);
    goto LABEL_18;
  }
  v9 = 24 * v8;
  v10 = __CFADD__(v9, 16);
  v11 = v9 + 16;
  if (v10 || v11 >= 0xFFFFFFFFFFFFFFF0)
LABEL_18:
    __break(0x5500u);
  MEMORY[0x24BDAC7A8](v6);
  v14 = (_QWORD *)((char *)v17 - v12);
  v15 = 0;
  do
  {
    v16 = &v14[v15 / 8];
    *v16 = 0xAAAAAAAAAAAAAAAALL;
    v16[1] = 0xAAAAAAAAAAAAAAAALL;
    v15 += 16;
  }
  while (v12 != v15);
  if (v13 < 0x10)
    goto LABEL_20;
  *v14 = v7;
  if (v12 < 1)
  {
LABEL_19:
    __break(0x5519u);
LABEL_20:
    __break(1u);
    return;
  }
  if (!ccec_import_pub() && ccec_compressed_x962_export_pub_size() == a4)
  {
    if (!a3 || a4)
    {
      ccec_compressed_x962_export_pub();
      return;
    }
    goto LABEL_19;
  }
}

void decompressECPublicKey(uint64_t a1, int **a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x24BDAC8D0];
  v6 = (uint64_t *)ccec_cp_for_oid(a2);
  if (v6)
  {
    v7 = *v6;
    if (!((unint64_t)*v6 >> 61) && is_mul_ok(8 * v7, 3uLL))
    {
      v8 = 24 * v7;
      v9 = __CFADD__(v8, 16);
      v10 = v8 + 16;
      if (!v9 && v10 < 0xFFFFFFFFFFFFFFF0)
      {
        MEMORY[0x24BDAC7A8](v6);
        v14 = (_QWORD *)((char *)v17 - v12);
        v15 = 0;
        do
        {
          v16 = &v14[v15 / 8];
          *v16 = 0xAAAAAAAAAAAAAAAALL;
          v16[1] = 0xAAAAAAAAAAAAAAAALL;
          v15 += 16;
        }
        while (v12 != v15);
        if (v13 < 0x10)
          goto LABEL_20;
        *v14 = v11;
        if (v12 < 1)
        {
LABEL_19:
          __break(0x5519u);
LABEL_20:
          __break(1u);
          return;
        }
        if (ccec_compressed_x962_import_pub())
          return;
        if ((unint64_t)cczp_bitlen() < 0xFFFFFFFFFFFFFFF9)
        {
          if (!a3 || a4)
          {
            ccec_export_pub();
            return;
          }
          goto LABEL_19;
        }
      }
      __break(0x5500u);
    }
    __break(0x550Cu);
  }
}

uint64_t CMSParseContentInfoSignedDataWithOptions(char *a1, uint64_t a2, unint64_t *a3, char a4)
{
  int v4;
  int v7;
  uint64_t result;
  uint64_t v9;
  _QWORD *v10;
  char *v11;
  int v12;
  char *v13;
  char *v15;
  int v16;
  char *v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  size_t v26;
  __int16 v27;
  char *v28;
  char *v29;
  unint64_t v30[3];
  __int16 v31;
  char *v32;
  unint64_t v33;
  size_t v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  char *v37;
  char *v38;
  unint64_t v39;
  unsigned __int8 v40;
  unint64_t v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v28 = (char *)0xAAAAAAAAAAAAAAAALL;
  v29 = (char *)0xAAAAAAAAAAAAAAAALL;
  if (__CFADD__(a1, a2))
    goto LABEL_114;
  if (&a1[a2] < a1)
    goto LABEL_112;
  v4 = 65537;
  v28 = a1;
  v29 = &a1[a2];
  v27 = 0;
  v26 = 0xAAAAAAAAAAAAAAAALL;
  v7 = ccder_blob_decode_ber_tl((uint64_t)&v28, 0x2000000000000010, (_BYTE *)&v27 + 1, &v26);
  result = 65537;
  if (v7)
  {
    v24 = (char *)0xAAAAAAAAAAAAAAAALL;
    v25 = (char *)0xAAAAAAAAAAAAAAAALL;
    if (__CFADD__(v28, v26))
      goto LABEL_114;
    if (v28 > &v28[v26] || &v28[v26] > v29)
      goto LABEL_112;
    v24 = v28;
    v25 = &v28[v26];
    if (ccder_blob_decode_tl())
    {
      if (v25 < v24 || v26 > v25 - v24)
        goto LABEL_112;
      if (compare_octet_string_raw((uint64_t)&pkcs7_signedData_oid, v24, v26))
        return 65539;
      if (__CFADD__(v24, v26))
        goto LABEL_114;
      if (v24 > &v24[v26] || &v24[v26] > v25)
        goto LABEL_112;
      v24 += v26;
      if (!ccder_blob_decode_ber_tl((uint64_t)&v24, 0xA000000000000000, &v27, &v26))
        return 65540;
      v22 = (char *)0xAAAAAAAAAAAAAAAALL;
      v23 = (char *)0xAAAAAAAAAAAAAAAALL;
      if (__CFADD__(v24, v26))
        goto LABEL_114;
      if (v24 > &v24[v26] || &v24[v26] > v25)
        goto LABEL_112;
      v22 = v24;
      v23 = &v24[v26];
      v31 = 0;
      memset(v30, 170, sizeof(v30));
      if ((ccder_blob_decode_ber_tl((uint64_t)&v22, 0x2000000000000010, (_BYTE *)&v31 + 1, v30) & 1) == 0)
        return 131073;
      if (__CFADD__(v22, v30[0]))
        goto LABEL_114;
      v9 = 131080;
      if (&v22[v30[0]] != v23)
        return 131082;
      v10 = a3 + 11;
      if (!ccder_blob_decode_uint64())
        return 131074;
      result = 131092;
      if (*v10 <= 4uLL && ((1 << *v10) & 0x1A) != 0)
      {
        if (!ccder_blob_eat_ber_inner((unint64_t *)&v22, 0x2000000000000011, 0, 125))
          return 131075;
        v35 = 0;
        v34 = 0;
        if ((ccder_blob_decode_ber_tl((uint64_t)&v22, 0x2000000000000010, &v35, &v34) & 1) == 0)
          return 131076;
        v32 = (char *)0xAAAAAAAAAAAAAAAALL;
        v33 = 0xAAAAAAAAAAAAAAAALL;
        if (__CFADD__(v22, v34))
          goto LABEL_114;
        if (v22 > &v22[v34] || &v22[v34] > v23)
          goto LABEL_112;
        v32 = v22;
        v33 = (unint64_t)&v22[v34];
        if (!ccder_blob_decode_tl())
          return 131077;
        if (v33 < (unint64_t)v32 || v34 > v33 - (unint64_t)v32)
          goto LABEL_112;
        if (compare_octet_string_raw((uint64_t)&pkcs7_data_oid, v32, v34))
          return 131078;
        if (__CFADD__(v32, v34))
          goto LABEL_114;
        v11 = &v32[v34];
        if (v32 > &v32[v34] || (unint64_t)v11 > v33)
          goto LABEL_112;
        v32 += v34;
        v12 = v35;
        if (v11 != (char *)v33 || v35)
        {
          v40 = 0;
          v38 = (char *)v33;
          v39 = 0;
          v37 = v11;
          if (ccder_blob_decode_ber_tl((uint64_t)&v37, 0xA000000000000000, &v40, &v39))
          {
            if (!v12)
            {
              if (__CFADD__(v37, v39))
                goto LABEL_114;
              if (&v37[v39] != (char *)v33)
                return v9;
            }
            if (v37 > v38)
              goto LABEL_112;
            v32 = v37;
            v33 = (unint64_t)v38;
            v36 = 0;
            v16 = v40;
            if (v40 && !ccder_blob_decode_ber_tl((uint64_t)&v32, 0x2000000000000004, &v36, &v39))
              return 131079;
            v41 = 0;
            if (!ccder_blob_decode_tl())
              return 131090;
            v17 = v32;
            v18 = v33;
            if (v33 < (unint64_t)v32)
              goto LABEL_112;
            v19 = v41;
            if (v41 > v33 - (unint64_t)v32)
              goto LABEL_112;
            a3[9] = (unint64_t)v32;
            a3[10] = v19;
            if (__CFADD__(v17, v19))
            {
LABEL_114:
              __break(0x5513u);
              return 0;
            }
            v20 = &v17[v19];
            if ((unint64_t)v20 > v18 || v17 > v20)
              goto LABEL_112;
            v32 = v20;
            if ((ccder_blob_decode_eoc((unint64_t *)&v32, v36) & 1) == 0)
              return 131089;
          }
          else
          {
            if (!v12)
              return v9;
            v16 = v40;
          }
          if ((ccder_blob_decode_eoc((unint64_t *)&v32, v16 != 0) & 1) == 0)
            return 131088;
          v11 = v32;
        }
        if (v11 > v23 || v22 > v11)
          goto LABEL_112;
        v22 = v11;
        if ((ccder_blob_decode_eoc((unint64_t *)&v22, v12 != 0) & 1) == 0)
          return 131081;
        v37 = (char *)0xAAAAAAAAAAAAAAAALL;
        v38 = (char *)0xAAAAAAAAAAAAAAAALL;
        if (v22 > v23)
          goto LABEL_112;
        v37 = v22;
        v38 = v23;
        if ((ccder_blob_decode_ber_tl((uint64_t)&v37, 0xA000000000000000, &v31, v30) & 1) == 0)
        {
          v13 = v22;
          v15 = v23;
          goto LABEL_86;
        }
        v32 = (char *)0xAAAAAAAAAAAAAAAALL;
        v33 = 0xAAAAAAAAAAAAAAAALL;
        if (!__CFADD__(v37, v30[0]))
        {
          if (v37 > &v37[v30[0]] || &v37[v30[0]] > v38)
            goto LABEL_112;
          v32 = v37;
          v33 = (unint64_t)&v37[v30[0]];
          if (!CMSParseImplicitCertificateSet((unint64_t *)&v32, a3[1], *a3, a3 + 3, a3 + 2))
            return 131085;
          if (!ccder_blob_decode_eoc((unint64_t *)&v32, v31))
            return 131086;
          v13 = v32;
          if (v32 - v37 >= 0 ? v32 >= v37 : v32 < v37)
          {
            if (v37 > v32)
              goto LABEL_112;
            v15 = v38;
            if (v32 > v38)
              goto LABEL_112;
            v22 = v32;
            v23 = v38;
LABEL_86:
            if (v13 <= v15)
            {
              v37 = v13;
              v38 = v15;
              if (ccder_blob_eat_ber_inner((unint64_t *)&v37, 0xA000000000000001, 0, 125))
              {
                if (v37 > v38)
                  goto LABEL_112;
                v22 = v37;
                v23 = v38;
              }
              if (!ccder_blob_eat_ber_inner((unint64_t *)&v22, 0x2000000000000011, &v30[1], 125))
                return 131083;
              if (v30[2] >= v30[1])
              {
                v21 = &v22[-v30[1]];
                if ((unint64_t)&v22[-v30[1]] <= v30[2] - v30[1])
                {
                  a3[5] = v30[1];
                  a3[6] = (unint64_t)v21;
                  if ((ccder_blob_decode_eoc((unint64_t *)&v22, HIBYTE(v31)) & 1) == 0)
                    return 131084;
                  if (!ccder_blob_decode_eoc((unint64_t *)&v22, v27))
                    return 65541;
                  if (v22 <= v25 && v24 <= v22)
                  {
                    v24 = v22;
                    if (ccder_blob_decode_eoc((unint64_t *)&v24, HIBYTE(v27)))
                    {
                      if ((a4 & 1) == 0 && v24 != v29)
                        return 65543;
                      return 0;
                    }
                    return (v4 + 5);
                  }
                }
              }
            }
LABEL_112:
            __break(0x5519u);
            return (v4 + 5);
          }
        }
        goto LABEL_114;
      }
    }
    else
    {
      return 65538;
    }
  }
  return result;
}

uint64_t ccder_blob_decode_ber_tl(uint64_t a1, uint64_t a2, _BYTE *a3, unint64_t *a4)
{
  int v8;
  uint64_t result;

  v8 = ccder_blob_decode_tag();
  result = 0;
  if (v8)
  {
    if (a2 == 0xAAAAAAAAAAAAAAAALL)
      return ccder_blob_decode_ber_len(a1, a3, a4);
  }
  return result;
}

uint64_t ccder_blob_decode_eoc(unint64_t *a1, int a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5;

  if (!a2)
    return 1;
  result = ccder_blob_decode_tl();
  if (!(_DWORD)result)
    return result;
  v4 = *a1;
  if (*a1 >= 0x5555555555555556)
  {
    __break(0x5513u);
LABEL_12:
    __break(0x5519u);
    return result;
  }
  v5 = v4 - 0x5555555555555556;
  if (v4 > v4 - 0x5555555555555556 || v5 > a1[1])
    goto LABEL_12;
  *a1 = v5;
  return 1;
}

uint64_t CMSParseContentInfoSignedData(char *a1, uint64_t a2, unint64_t *a3)
{
  return CMSParseContentInfoSignedDataWithOptions(a1, a2, a3, 0);
}

uint64_t CMSParseSignerInfos(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, __int128 *))
{
  uint64_t v3;
  unint64_t v4;
  unsigned int v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int *digest;
  int *v14;
  unsigned int v15;
  uint64_t result;
  unint64_t v17;
  unsigned int v18;
  uint64_t v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  int v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  int *v33;
  unsigned int v34;
  unint64_t v35;
  _OWORD *v36;
  unint64_t v37;
  BOOL v38;
  unint64_t v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  unsigned int v48;
  int v49;
  uint64_t v50;
  _OWORD *v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  unsigned __int8 v60;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unsigned __int8 v71;
  unint64_t v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  unint64_t v84;
  unint64_t v85;
  uint64_t v86;

  v86 = *MEMORY[0x24BDAC8D0];
  v84 = 0xAAAAAAAAAAAAAAAALL;
  v85 = 0xAAAAAAAAAAAAAAAALL;
  v4 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 48);
  if (__CFADD__(v4, v3))
    goto LABEL_93;
  if (v4 > v4 + v3)
    goto LABEL_92;
  v84 = *(_QWORD *)(a1 + 40);
  v85 = v4 + v3;
  v72 = 0xAAAAAAAAAAAAAAAALL;
  if (v4 >= v4 + v3)
  {
    v48 = 0;
    result = 0;
    if (v3)
      return (v48 << 8) | 0x30008;
    return result;
  }
  v6 = 0;
  v60 = 0;
  v7 = 256;
  while (1)
  {
    v71 = 0;
    v82 = 0u;
    v83 = 0u;
    v73 = 0u;
    v74 = 0u;
    v75 = 0u;
    v76 = 0u;
    v77 = 0u;
    v78 = 0u;
    v79 = 0u;
    v80 = 0u;
    v81 = 0u;
    DWORD2(v83) = 327681;
    LOBYTE(v82) = v6 + 1;
    if ((ccder_blob_decode_ber_tl((uint64_t)&v84, 0x2000000000000010, &v71, &v72) & 1) == 0)
    {
      v49 = 196609;
      return v7 | v49;
    }
    v69 = 0xAAAAAAAAAAAAAAAALL;
    v70 = 0xAAAAAAAAAAAAAAAALL;
    if (__CFADD__(v84, v72))
      goto LABEL_93;
    if (v84 > v84 + v72 || v84 + v72 > v85)
      goto LABEL_92;
    v69 = v84;
    v70 = v84 + v72;
    if ((ccder_blob_decode_uint64() & 1) == 0)
    {
      v49 = 196610;
      return v7 | v49;
    }
    v9 = v69;
    v8 = v70;
    v67 = 0xAAAAAAAAAAAAAAAALL;
    v68 = 0xAAAAAAAAAAAAAAAALL;
    if (v69 > v70)
      goto LABEL_92;
    v67 = v69;
    v68 = v70;
    v65 = v69;
    v66 = v70;
    if (!ccder_blob_decode_tl())
      break;
    v10 = v69;
LABEL_19:
    if (__CFADD__(v72, v10 - v9))
      goto LABEL_94;
    if (v72 + v10 - v9 > v8 - v9)
      goto LABEL_92;
    *((_QWORD *)&v73 + 1) = v9;
    *(_QWORD *)&v74 = v72 + v10 - v9;
    if (__CFADD__(v10, v72))
      goto LABEL_93;
    if (v10 > v10 + v72 || v10 + v72 > v70)
      goto LABEL_92;
    v69 = v10 + v72;
    if (!ccder_blob_decode_AlgorithmIdentifierNULL(&v69, (unint64_t *)&v74 + 1))
    {
      v49 = 196612;
      return v7 | v49;
    }
    v63 = 0xAAAAAAAAAAAAAAAALL;
    v64 = 0xAAAAAAAAAAAAAAAALL;
    if (v69 > v70)
      goto LABEL_92;
    v63 = v69;
    v64 = v70;
    if (ccder_blob_decode_tl())
    {
      if (v64 < v63 || v72 > v64 - v63)
        goto LABEL_92;
      *((_QWORD *)&v75 + 1) = v63;
      *(_QWORD *)&v76 = v72;
      if (__CFADD__(v63, v72))
        goto LABEL_93;
      if (v63 > v63 + v72 || v63 + v72 > v64)
        goto LABEL_92;
      v69 = v63 + v72;
      v70 = v64;
    }
    else
    {
      *((_QWORD *)&v75 + 1) = 0;
      *(_QWORD *)&v76 = 0;
    }
    if ((ccder_blob_decode_AlgorithmIdentifierNULL(&v69, (unint64_t *)&v76 + 1) & 1) == 0)
    {
      v49 = 196613;
      return v7 | v49;
    }
    if ((ccder_blob_decode_tl() & 1) == 0)
    {
      v49 = 196614;
      return v7 | v49;
    }
    if (v70 < v69 || v72 > v70 - v69)
      goto LABEL_92;
    *((_QWORD *)&v78 + 1) = v69;
    *(_QWORD *)&v79 = v72;
    if (__CFADD__(v69, v72))
      goto LABEL_93;
    v12 = v69 + v72;
    if (v69 > v69 + v72 || v12 > v70)
      goto LABEL_92;
    v69 += v72;
    v63 = v12;
    v64 = v70;
    if (ccder_blob_eat_ber_inner(&v63, 0xA000000000000001, 0, 125))
    {
      if (v63 > v64)
        goto LABEL_92;
      v69 = v63;
      v70 = v64;
    }
    if ((ccder_blob_decode_eoc(&v69, v71) & 1) == 0)
    {
      v49 = 196615;
      return v7 | v49;
    }
    digest = find_digest((uint64_t)&v74 + 8);
    if (digest)
    {
      v14 = digest;
      v15 = *(_DWORD *)(a1 + 96);
      if (!v15 || *digest <= v15)
      {
        result = a3(a2, a1, &v73);
        if ((_DWORD)result != 327710)
        {
          if ((_DWORD)result)
            return result;
          v17 = *(_QWORD *)(a1 + 64);
          if (v17 <= v60)
          {
            if (v17)
            {
              v29 = v60 - 1;
              v30 = *(_QWORD *)(a1 + 56);
              v31 = 176 * v29;
              if (__CFADD__(v30, v31))
                goto LABEL_93;
              v32 = v30 + 176 * v29;
              if (v32 >= v30 + 176 * v17 || v32 < v30)
                goto LABEL_92;
              v33 = find_digest(v30 + 176 * v29 + 24);
              if (v33)
              {
                if (*v14 > *v33)
                {
                  v34 = *(_DWORD *)(a1 + 96);
                  if (!v34 || *v14 <= v34)
                  {
                    v35 = *(_QWORD *)(a1 + 56);
                    if (__CFADD__(v35, v31))
                      goto LABEL_93;
                    v36 = (_OWORD *)(v35 + 176 * v29);
                    v37 = v35 + 176 * *(_QWORD *)(a1 + 64);
                    v38 = v37 >= (unint64_t)v36;
                    v39 = v37 - (_QWORD)v36;
                    if (!v38 || v35 > (unint64_t)v36 || v39 < 0xB0)
                      goto LABEL_92;
                    v40 = v73;
                    v41 = v75;
                    v36[1] = v74;
                    v36[2] = v41;
                    *v36 = v40;
                    v42 = v76;
                    v43 = v77;
                    v44 = v79;
                    v36[5] = v78;
                    v36[6] = v44;
                    v36[3] = v42;
                    v36[4] = v43;
                    v45 = v80;
                    v46 = v81;
                    v47 = v83;
                    v36[9] = v82;
                    v36[10] = v47;
                    v36[7] = v45;
                    v36[8] = v46;
                  }
                }
              }
            }
          }
          else
          {
            v18 = *(_DWORD *)(a1 + 96);
            if (!v18 || *v14 <= v18)
            {
              v19 = *(_QWORD *)(a1 + 56);
              if (__CFADD__(v19, 176 * (char)v60))
                goto LABEL_93;
              v20 = (_OWORD *)(v19 + 176 * v60);
              if (176 * v17 - 176 * v60 < 0xB0)
                goto LABEL_92;
              v21 = v73;
              v22 = v75;
              v20[1] = v74;
              v20[2] = v22;
              *v20 = v21;
              v23 = v76;
              v24 = v77;
              v25 = v79;
              v20[5] = v78;
              v20[6] = v25;
              v20[3] = v23;
              v20[4] = v24;
              v26 = v80;
              v27 = v81;
              v28 = v83;
              v20[9] = v82;
              v20[10] = v28;
              v20[7] = v26;
              v20[8] = v27;
              if (v60 == 0xFF)
              {
                __break(0x5507u);
                return result;
              }
              ++v60;
            }
          }
        }
      }
    }
    if (v69 > v85 || v84 > v69)
      goto LABEL_92;
    v84 = v69;
    v48 = v6 + 1;
    if (v6 <= 6)
    {
      v7 += 256;
      ++v6;
      if (v69 < v85)
        continue;
    }
    if (v69 == v85)
    {
      if (v60)
        return 0;
      v50 = *(_QWORD *)(a1 + 64);
      if (!v50)
        return 0;
      if ((unint64_t)(176 * v50) >= 0xB0)
      {
        result = 0;
        v51 = *(_OWORD **)(a1 + 56);
        v52 = v73;
        v53 = v75;
        v51[1] = v74;
        v51[2] = v53;
        *v51 = v52;
        v54 = v76;
        v55 = v77;
        v56 = v79;
        v51[5] = v78;
        v51[6] = v56;
        v51[3] = v54;
        v51[4] = v55;
        v57 = v80;
        v58 = v81;
        v59 = v83;
        v51[9] = v82;
        v51[10] = v59;
        v51[7] = v57;
        v51[8] = v58;
        return result;
      }
LABEL_92:
      __break(0x5519u);
LABEL_93:
      __break(0x5513u);
LABEL_94:
      __break(0x5500u);
    }
    return (v48 << 8) | 0x30008;
  }
  if ((ccder_blob_decode_tl() & 1) != 0)
  {
    v10 = v67;
    v11 = v68;
LABEL_17:
    if (v10 > v11)
      goto LABEL_92;
    v69 = v10;
    v70 = v11;
    goto LABEL_19;
  }
  if (ccder_blob_decode_tl())
  {
    v10 = v65;
    v11 = v66;
    goto LABEL_17;
  }
  v49 = 196611;
  return v7 | v49;
}

uint64_t CMSBuildPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t CertificateUsingKeyIdentifier;
  uint64_t v13;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v20 = 0xAAAAAAAAAAAAAAAALL;
  v21 = 0xAAAAAAAAAAAAAAAALL;
  v3 = *(_QWORD *)(a3 + 8);
  v4 = *(_QWORD *)(a3 + 16);
  if (__CFADD__(v3, v4))
LABEL_49:
    __break(0x5513u);
  v5 = v3 + v4;
  if (v3 > v5)
    goto LABEL_48;
  v20 = *(_QWORD *)(a3 + 8);
  v21 = v5;
  v19 = 0xAAAAAAAAAAAAAAAALL;
  if (*(_QWORD *)a3 != 3)
  {
    if (*(_QWORD *)a3 != 1)
      return 524289;
    v8 = 524293;
    if (!ccder_blob_decode_tl())
      return 524290;
    if (!ccder_blob_decode_tl())
      return 524291;
    if (v21 >= v20 && v19 <= v21 - v20)
    {
      v15 = v20;
      v16 = v19;
      if (__CFADD__(v20, v19))
        goto LABEL_49;
      if (v20 <= v20 + v19 && v20 + v19 <= v21)
      {
        v20 += v19;
        if (!ccder_blob_decode_tl())
          return 524292;
        if (v21 >= v20 && v19 <= v21 - v20)
        {
          v17 = v20;
          v18 = v19;
          if (__CFADD__(v20, v19))
            goto LABEL_49;
          if (v20 <= v20 + v19 && v20 + v19 <= v21)
          {
            v20 += v19;
            v9 = *(_QWORD **)(a2 + 24);
            if (!v9)
              return v8;
            while (compare_octet_string((uint64_t)&v15, (uint64_t)(v9 + 15))
                 || compare_octet_string((uint64_t)&v17, (uint64_t)(v9 + 17)))
            {
              v9 = (_QWORD *)v9[34];
              if (!v9)
                return v8;
            }
            goto LABEL_36;
          }
        }
      }
    }
    goto LABEL_48;
  }
  if (*(_QWORD *)(a2 + 88) == 1)
    return 524298;
  v15 = v3;
  v16 = v5;
  if (ccder_blob_decode_tl())
  {
    v11 = v20;
    v10 = v21;
    goto LABEL_29;
  }
  v8 = 524294;
  if (!ccder_blob_decode_tl() || !ccder_blob_decode_tl())
    return v8;
  v11 = v15;
  v10 = v16;
  if (v15 > v16)
  {
LABEL_48:
    __break(0x5519u);
    goto LABEL_49;
  }
  v20 = v15;
  v21 = v16;
LABEL_29:
  if (v10 < v11 || v19 > v10 - v11)
    goto LABEL_48;
  v17 = v11;
  v18 = v19;
  if (__CFADD__(v11, v19))
    goto LABEL_49;
  if (v11 > v11 + v19 || v11 + v19 > v10)
    goto LABEL_48;
  v20 = v11 + v19;
  CertificateUsingKeyIdentifier = X509ChainGetCertificateUsingKeyIdentifier((uint64_t *)(a2 + 24), (uint64_t)&v17);
  if (!CertificateUsingKeyIdentifier)
    return 524295;
  v9 = (_QWORD *)CertificateUsingKeyIdentifier;
LABEL_36:
  if (v20 != v21)
    return 524543;
  v13 = X509ChainBuildPath(v9, (uint64_t *)(a2 + 24), (_QWORD *)(a3 + 152));
  v8 = v13;
  if (*(_DWORD *)(a3 + 168) == 327681)
    *(_DWORD *)(a3 + 168) = v13;
  return v8;
}

uint64_t validateSignerInfo(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  __int128 *v6;
  int *digest;
  unint64_t *v8;
  unint64_t *v9;
  _OWORD *v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t result;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28[2];
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  _OWORD v34[4];
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v6 = (__int128 *)(a3 + 24);
  digest = find_digest(a3 + 24);
  if (!digest)
    return 327682;
  v8 = (unint64_t *)(*((uint64_t (**)(void))digest + 3))();
  v9 = v8;
  memset(v34, 0, sizeof(v34));
  v10 = (_OWORD *)a2[13];
  v11 = a2[14];
  if (v10)
    v12 = v11 == 0;
  else
    v12 = 1;
  if (v12)
  {
    if (a2[9] && a2[10])
    {
      v10 = v34;
      v13 = ccdigest();
      v11 = *v9;
      if (*v9 >= 0x41)
        goto LABEL_55;
      goto LABEL_16;
    }
    if (!v10)
      goto LABEL_31;
  }
  if (*v8 != v11)
  {
LABEL_31:
    *(_DWORD *)(a3 + 168) = 327710;
    return 327710;
  }
  if (v11 > 0x40)
    goto LABEL_55;
  v13 = __memcpy_chk();
LABEL_16:
  *(_QWORD *)(a3 + 128) = v10;
  *(_QWORD *)(a3 + 136) = v11;
  v15 = (_QWORD *)(a3 + 128);
  v16 = *(_QWORD *)(a3 + 48);
  if (!v16)
  {
    result = CMSBuildPath(v13, (uint64_t)a2, a3);
    switch((int)result)
    {
      case 524293:
      case 524295:
        *(_DWORD *)(a3 + 168) = result;
        return 0;
      case 524294:
        goto LABEL_52;
      case 524296:
        if (*(_DWORD *)(a3 + 168) != 458753)
          goto LABEL_43;
        v20 = 524296;
LABEL_42:
        *(_DWORD *)(a3 + 168) = v20;
LABEL_43:
        v21 = *v9;
        if (*v9 > 0x40)
          goto LABEL_55;
        v28[0] = (uint64_t)v34;
        v28[1] = v21;
        result = X509CertificateCheckSignatureDigest(29, *(_QWORD *)(a3 + 152), v28, v6, (__int128 *)(a3 + 88));
        if (!(_DWORD)result || (_DWORD)result == 655648 || (_DWORD)result == 655632)
        {
          v22 = *(_DWORD *)(a3 + 168);
          if (!v22 || v22 == 458753 || v22 == 327681)
            *(_DWORD *)(a3 + 168) = result;
          result = 0;
        }
        break;
      case 524297:
        v20 = 524297;
        goto LABEL_42;
      default:
        if ((_DWORD)result)
          goto LABEL_52;
        goto LABEL_43;
    }
    goto LABEL_52;
  }
  v25 = a1;
  v32 = 0xAAAAAAAAAAAAAAAALL;
  v33 = 0xAAAAAAAAAAAAAAAALL;
  v17 = *(_QWORD *)(a3 + 40);
  if (__CFADD__(v17, v16))
LABEL_56:
    __break(0x5513u);
  v18 = v17 + v16;
  if (v17 > v18)
    goto LABEL_55;
  v32 = *(_QWORD *)(a3 + 40);
  v33 = v18;
  v31 = 0xAAAAAAAAAAAAAAAALL;
  if (v17 >= v18)
  {
    result = 262156;
    goto LABEL_52;
  }
  v27 = 0x2000000000000010;
  v24 = 262146;
  v26 = 262147;
  v23 = 458754;
  if (!ccder_blob_decode_tl())
  {
    result = 262145;
    goto LABEL_52;
  }
  if (__CFADD__(v32, v31))
    goto LABEL_56;
  v30 = 0xAAAAAAAAAAAAAAAALL;
  v29 = 0xAAAAAAAAAAAAAAAALL;
  if (v32 > v32 + v31 || v32 + v31 > v33)
  {
LABEL_55:
    __break(0x5519u);
    goto LABEL_56;
  }
  v29 = v32;
  v30 = v32 + v31;
  if (ccder_blob_decode_tl())
  {
    if (__CFADD__(v29, v31))
      goto LABEL_56;
    if (v29 <= v29 + v31 && v29 + v31 <= v30)
    {
      v29 += v31;
      result = 262150;
      goto LABEL_52;
    }
    goto LABEL_55;
  }
  result = v24;
LABEL_52:
  if ((_OWORD *)*v15 == v34)
  {
    *v15 = 0;
    *(_QWORD *)(a3 + 136) = 0;
  }
  return result;
}

uint64_t validateSignerInfoAndChain(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  int v7;

  v5 = validateSignerInfo((uint64_t)a1, a2, a3);
  if (!(_DWORD)v5)
  {
    v7 = X509ChainCheckPath(29, (uint64_t *)(a3 + 152), *a1);
    if (v7)
    {
      if (!*(_DWORD *)(a3 + 168))
        *(_DWORD *)(a3 + 168) = v7;
    }
  }
  return v5;
}

uint64_t CMSVerifySignedDataWithLeaf(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, _QWORD *a7)
{
  uint64_t v8;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x24BDAC8D0];
  v8 = 0;
  v9[0] = 0;
  return CMSVerify(a1, a2, a3, a4, a5, a6, a7, &v8, v9);
}

uint64_t CMSVerify(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, _QWORD *a7, _QWORD *a8, _QWORD *a9)
{
  uint64_t result;
  uint64_t v18;
  _OWORD v19[9];
  __int128 v20;
  __int128 v21;
  unint64_t v22[2];
  __int128 v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD *v27;
  _OWORD v28[3];
  uint64_t v29;
  _QWORD v30[2];
  _BYTE __b[1216];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v29 = 0;
  v30[0] = 0;
  memset(v28, 0, sizeof(v28));
  v26 = 0;
  v25 = 0;
  v23 = 0u;
  v24 = (char *)&v23 + 8;
  v30[1] = 0;
  memset(__b, 170, sizeof(__b));
  v22[0] = 4;
  v22[1] = (unint64_t)__b;
  v20 = 0u;
  v21 = 0u;
  memset(v19, 0, sizeof(v19));
  v27 = v19;
  *(_QWORD *)&v28[0] = 1;
  DWORD2(v21) = 327681;
  if (a2 < 0)
    goto LABEL_19;
  result = CMSParseContentInfoSignedDataWithOptions(a1, a2, v22, 0);
  if ((_DWORD)result)
    return result;
  if (!a4)
    goto LABEL_7;
  result = 131091;
  if (*(_OWORD *)((char *)v28 + 8) != 0)
    return result;
  if (a4 < 0)
LABEL_19:
    __break(0x5519u);
  *((_QWORD *)&v28[0] + 1) = a3;
  *(_QWORD *)&v28[1] = a4;
LABEL_7:
  v30[0] = a5;
  DWORD2(v21) = 458753;
  result = CMSParseSignerInfos((uint64_t)v22, (uint64_t)v30, (uint64_t (*)(uint64_t, uint64_t, __int128 *))validateSignerInfoAndChain);
  if (!(_DWORD)result)
  {
    result = DWORD2(v21);
    if (!DWORD2(v21))
    {
      if (a6 && a7)
        result = X509CertificateParseKey(*((uint64_t *)&v20 + 1), a6, a7);
      if (!a4)
      {
        if (a8)
        {
          if (a9)
          {
            v18 = *(_QWORD *)&v28[1];
            if (*(_QWORD *)&v28[1])
            {
              if (*((_QWORD *)&v28[0] + 1))
              {
                *a8 = *((_QWORD *)&v28[0] + 1);
                *a9 = v18;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t CMSVerifySignedData(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v7 = 0;
  v9[0] = 0;
  v8 = 0;
  return CMSVerify(a1, a2, a3, a4, a5, &v6, &v7, &v8, v9);
}

uint64_t CMSVerifyAndReturnSignedData(char *a1, uint64_t a2, _QWORD *a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v6;
  _QWORD v7[2];

  v7[1] = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v7[0] = 0;
  return CMSVerify(a1, a2, 0, 0, a5, &v6, v7, a3, a4);
}

uint64_t ccder_blob_decode_ber_len(uint64_t result, _BYTE *a2, unint64_t *a3)
{
  unsigned __int8 *v3;
  unint64_t v4;
  unsigned __int8 *v5;
  unint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unint64_t v10;
  uint64_t v11;

  *a2 = 0;
  v3 = *(unsigned __int8 **)result;
  if (!*(_QWORD *)result)
    return 0;
  v4 = *(_QWORD *)(result + 8);
  if ((unint64_t)v3 >= v4)
    return 0;
  if (v3 == (unsigned __int8 *)-1)
    goto LABEL_42;
  v5 = v3 + 1;
  if (v3 >= v3 + 1 || (unint64_t)v5 > v4)
  {
LABEL_41:
    __break(0x5519u);
LABEL_42:
    __break(0x5513u);
    return result;
  }
  *(_QWORD *)result = v5;
  v7 = *v3;
  if ((char)*v3 < 0)
  {
    switch(*v3)
    {
      case 0x80u:
        v7 = v4 - (_QWORD)v5;
        *a2 = 1;
        break;
      case 0x81u:
        if ((uint64_t)(v4 - (_QWORD)v5) < 1)
          return 0;
        if (v3 == (unsigned __int8 *)-2)
          goto LABEL_42;
        v8 = v3 + 2;
        if (v5 > v8 || (unint64_t)v8 > v4)
          goto LABEL_41;
        *(_QWORD *)result = v8;
        v7 = *v5;
        v5 = v8;
        break;
      case 0x82u:
        if ((uint64_t)(v4 - (_QWORD)v5) < 2)
          return 0;
        if ((unint64_t)v5 >= v4)
          goto LABEL_41;
        if (v3 == (unsigned __int8 *)-2)
          goto LABEL_42;
        if (v3 + 2 < v5 || (unint64_t)(v3 + 2) >= v4)
          goto LABEL_41;
        if ((unint64_t)v5 > 0xFFFFFFFFFFFFFFFDLL)
          goto LABEL_42;
        v9 = v3 + 3;
        if (v5 > v3 + 3 || (unint64_t)v9 > v4)
          goto LABEL_41;
        v10 = (unint64_t)v3[1] << 8;
        v11 = v3[2];
        goto LABEL_40;
      case 0x83u:
        if ((uint64_t)(v4 - (_QWORD)v5) < 3)
          return 0;
        if ((unint64_t)v5 >= v4)
          goto LABEL_41;
        if (v3 == (unsigned __int8 *)-2)
          goto LABEL_42;
        if (v3 + 2 < v5 || (unint64_t)(v3 + 2) >= v4)
          goto LABEL_41;
        if ((unint64_t)v5 > 0xFFFFFFFFFFFFFFFDLL)
          goto LABEL_42;
        if (v3 + 3 < v5 || (unint64_t)(v3 + 3) >= v4)
          goto LABEL_41;
        if ((unint64_t)v5 > 0xFFFFFFFFFFFFFFFCLL)
          goto LABEL_42;
        v9 = v3 + 4;
        if (v5 > v3 + 4 || (unint64_t)v9 > v4)
          goto LABEL_41;
        v10 = ((unint64_t)v3[1] << 16) | ((unint64_t)v3[2] << 8);
        v11 = v3[3];
LABEL_40:
        v7 = v10 | v11;
        *(_QWORD *)result = v9;
        v5 = v9;
        break;
      default:
        return 0;
    }
  }
  if (v4 - (unint64_t)v5 < v7)
    return 0;
  *a3 = v7;
  return 1;
}

uint64_t CMSParseImplicitCertificateSet(unint64_t *a1, unint64_t a2, unint64_t a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  BOOL v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t **v19;
  unint64_t **v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v25;
  unint64_t **v27;
  unint64_t v28;
  char v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v31 = 0xAAAAAAAAAAAAAAAALL;
  v32 = 0xAAAAAAAAAAAAAAAALL;
  *a4 = 0;
  a4[1] = 0;
  v30 = 0xAAAAAAAAAAAAAAAALL;
  v5 = *a1;
  v6 = a1[1];
  if (*a1 > v6)
  {
LABEL_43:
    __break(0x5519u);
LABEL_44:
    __break(0x5513u);
  }
  v30 = *a1;
  v31 = v6;
  v7 = v5 >= v6 || a3 == 0;
  if (v7)
  {
    v12 = 0;
LABEL_8:
    if (a5)
      *a5 = v12;
    return 1;
  }
  else
  {
    v12 = 0;
    v13 = 304 * a3;
    v14 = a2 + 304 * a3;
    v25 = ~a2;
    v27 = (unint64_t **)(a4 + 1);
    v23 = (unint64_t *)(a2 + 272);
    v15 = a2;
    while (1)
    {
      v29 = 0;
      if (!ccder_blob_decode_tag())
        return 0;
      if (!v32)
        goto LABEL_8;
      if (!ccder_blob_decode_ber_len((uint64_t)&v30, &v29, &v28) || v29 || v32 != 0x2000000000000010)
        return 0;
      if ((unsigned __int128)((uint64_t)v12 * (__int128)304) >> 64 != (uint64_t)(304 * v12) >> 63 || 304 * v12 > v25)
        goto LABEL_44;
      if (v15 > v14)
        goto LABEL_43;
      if (v15 < a2)
        goto LABEL_43;
      v16 = v13 >= 0x130;
      v13 -= 304;
      if (!v16)
        goto LABEL_43;
      *(_OWORD *)(v15 + 272) = 0u;
      *(_OWORD *)(v15 + 288) = 0u;
      *(_OWORD *)(v15 + 240) = 0u;
      *(_OWORD *)(v15 + 256) = 0u;
      *(_OWORD *)(v15 + 208) = 0u;
      *(_OWORD *)(v15 + 224) = 0u;
      *(_OWORD *)(v15 + 176) = 0u;
      *(_OWORD *)(v15 + 192) = 0u;
      *(_OWORD *)(v15 + 144) = 0u;
      *(_OWORD *)(v15 + 160) = 0u;
      *(_OWORD *)(v15 + 112) = 0u;
      *(_OWORD *)(v15 + 128) = 0u;
      *(_OWORD *)(v15 + 80) = 0u;
      *(_OWORD *)(v15 + 96) = 0u;
      *(_OWORD *)(v15 + 48) = 0u;
      *(_OWORD *)(v15 + 64) = 0u;
      *(_OWORD *)(v15 + 16) = 0u;
      *(_OWORD *)(v15 + 32) = 0u;
      *(_OWORD *)v15 = 0u;
      if (v12)
      {
        if (v15 + 304 > v14)
          goto LABEL_43;
        *(_QWORD *)(v15 + 272) = 0;
        v17 = *v27;
        *(_QWORD *)(v15 + 280) = *v27;
        if (v15)
        {
          if (v15 >= v14)
            goto LABEL_43;
        }
        *v17 = v15;
        *v27 = (unint64_t *)(v15 + 272);
      }
      else
      {
        if (v15 + 304 > v14)
          goto LABEL_43;
        v18 = *a4;
        *v23 = *a4;
        v19 = (unint64_t **)(v18 + 280);
        v7 = v18 == 0;
        v20 = v27;
        if (!v7)
          v20 = v19;
        *v20 = v23;
        if (v15)
        {
          if (v15 >= v14)
            goto LABEL_43;
        }
        *a4 = v15;
        *(_QWORD *)(a2 + 280) = a4;
      }
      if (X509CertificateParseImplicit(v15, &v30, 0, 0))
        return 0;
      if (v6 < v5)
        goto LABEL_43;
      v21 = v30;
      v22 = v30 - v5;
      if (v30 - v5 > v6 - v5)
        goto LABEL_43;
      if (v15 + 304 > v14)
        goto LABEL_43;
      *(_QWORD *)v15 = v5;
      *(_QWORD *)(v15 + 8) = v22;
      v6 = v31;
      if (v21 > v31)
        goto LABEL_43;
      *a1 = v21;
      a1[1] = v6;
      ++v12;
      if (v21 < v6)
      {
        v15 += 304;
        v5 = v21;
        if (v12 < a3)
          continue;
      }
      goto LABEL_8;
    }
  }
}

uint64_t ccder_blob_eat_ber_inner(unint64_t *a1, uint64_t a2, unint64_t *a3, int a4)
{
  int v8;
  uint64_t result;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v15 = 0;
  v14 = 0xAAAAAAAAAAAAAAAALL;
  v8 = ccder_blob_decode_tag();
  result = 0;
  if (v8 && v14 == a2)
  {
    v13 = 0xAAAAAAAAAAAAAAAALL;
    result = ccder_blob_decode_ber_len((uint64_t)a1, &v15, &v13);
    if ((result & 1) == 0)
      return 0;
    if (a3)
    {
      v10 = a1[1];
      if (*a1 > v10)
        goto LABEL_18;
      *a3 = *a1;
      a3[1] = v10;
    }
    if (v15)
    {
      if (a4 >= 1)
      {
        result = ccder_blob_eat_ber_inner(a1, 0, 0, (char)(a4 - 1));
        if (!(_DWORD)result)
          return result;
        return (ccder_blob_decode_eoc(a1, 1) & 1) != 0;
      }
      return 0;
    }
    v11 = *a1;
    if (__CFADD__(*a1, v13))
    {
LABEL_19:
      __break(0x5513u);
      return result;
    }
    v12 = v11 + v13;
    if (v11 <= v11 + v13 && v12 <= a1[1])
    {
      *a1 = v12;
      return 1;
    }
LABEL_18:
    __break(0x5519u);
    goto LABEL_19;
  }
  return result;
}

uint64_t compare_octet_string(uint64_t a1, uint64_t a2)
{
  size_t v2;
  size_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return memcmp(*(const void **)a1, *(const void **)a2, v2);
  if (v2 > v3)
    return 0xFFFFFFFFLL;
  return 1;
}

uint64_t compare_octet_string_raw(uint64_t a1, const void *a2, size_t a3)
{
  size_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (v3 == a3)
    return memcmp(*(const void **)a1, a2, a3);
  if (v3 > a3)
    return 0xFFFFFFFFLL;
  return 1;
}

uint64_t compare_octet_string_partial(uint64_t a1, uint64_t a2)
{
  size_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2 <= *(_QWORD *)(a2 + 8))
    return memcmp(*(const void **)a2, *(const void **)a1, v2);
  else
    return 0xFFFFFFFFLL;
}

uint64_t ccder_blob_decode_AlgorithmIdentifierNULL(unint64_t *a1, unint64_t *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    if (*a1 > a1[1])
      goto LABEL_20;
    v5 = *a1;
    v6 = *a1;
    result = ccder_blob_decode_tl();
    if (!(_DWORD)result)
      return result;
    if (a2)
    {
      if (v6 < v5)
        goto LABEL_20;
      *a2 = v5;
      a2[1] = 0;
    }
    if (v5 == v6)
    {
      if (v5 <= a1[1] && *a1 <= v5)
      {
        *a1 = v5;
        return 1;
      }
    }
    else if (v5 <= v6)
    {
      result = ccder_blob_decode_tl();
      if (!(_DWORD)result)
        return result;
      if (v5 != v6)
        return 0;
      if (v5 <= a1[1] && *a1 <= v5)
      {
        *a1 = v5;
        return 1;
      }
    }
LABEL_20:
    __break(0x5519u);
  }
  return result;
}

uint64_t ccder_blob_decode_Time(_QWORD *a1)
{
  if (*a1 > a1[1])
    goto LABEL_6;
  if ((ccder_blob_decode_tl() & 1) != 0)
    return 0;
  if (*a1 > a1[1])
LABEL_6:
    __break(0x5519u);
  ccder_blob_decode_tl();
  return 0;
}

uint64_t ccder_blob_decode_GeneralName(unint64_t *a1, int *a2, unint64_t *a3)
{
  uint64_t result;
  unint64_t v7;
  int v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;

  result = 0;
  if (a2 && a3)
  {
    *a3 = 0;
    a3[1] = 0;
    if (*a1 > a1[1])
      goto LABEL_42;
    v10 = *a1;
    if (ccder_blob_decode_tl())
    {
      *a2 = 0;
LABEL_6:
      v7 = v10;
LABEL_16:
      if (v7 <= a1[1] && *a1 <= v7)
      {
        *a1 = v7;
        return 1;
      }
LABEL_42:
      __break(0x5519u);
    }
    if (*a1 > a1[1])
      goto LABEL_42;
    v11 = *a1;
    v16 = a1[1];
    if (ccder_blob_decode_tl())
    {
      v7 = v11;
      if (v16 < v11)
        goto LABEL_42;
      *a3 = v11;
      a3[1] = 0;
      v8 = 1;
LABEL_15:
      *a2 = v8;
      goto LABEL_16;
    }
    if (*a1 > a1[1])
      goto LABEL_42;
    v12 = *a1;
    v17 = a1[1];
    if (ccder_blob_decode_tl())
    {
      v7 = v12;
      if (v17 < v12)
        goto LABEL_42;
      *a3 = v12;
      a3[1] = 0;
      v8 = 2;
      goto LABEL_15;
    }
    if (*a1 > a1[1])
      goto LABEL_42;
    v10 = *a1;
    if (ccder_blob_decode_tl())
    {
      v9 = 3;
LABEL_23:
      *a2 = v9;
      goto LABEL_6;
    }
    if (*a1 > a1[1])
      goto LABEL_42;
    v13 = *a1;
    v18 = a1[1];
    if (ccder_blob_decode_tl())
    {
      v7 = v13;
      if (v18 < v13)
        goto LABEL_42;
      *a3 = v13;
      a3[1] = 0;
      v8 = 4;
      goto LABEL_15;
    }
    if (*a1 > a1[1])
      goto LABEL_42;
    v10 = *a1;
    if (ccder_blob_decode_tl())
    {
      v9 = 5;
      goto LABEL_23;
    }
    if (*a1 > a1[1])
      goto LABEL_42;
    v14 = *a1;
    v19 = a1[1];
    if (ccder_blob_decode_tl())
    {
      v7 = v14;
      if (v19 < v14)
        goto LABEL_42;
      *a3 = v14;
      a3[1] = 0;
      v8 = 6;
      goto LABEL_15;
    }
    if (*a1 > a1[1])
      goto LABEL_42;
    v15 = *a1;
    v20 = a1[1];
    if (ccder_blob_decode_tl())
    {
      v7 = v15;
      if (v20 < v15)
        goto LABEL_42;
      *a3 = v15;
      a3[1] = 0;
      v8 = 7;
      goto LABEL_15;
    }
    if (*a1 > a1[1])
      goto LABEL_42;
    v10 = *a1;
    result = ccder_blob_decode_tl();
    if ((_DWORD)result)
    {
      v9 = 8;
      goto LABEL_23;
    }
  }
  return result;
}

uint64_t ccder_blob_check_null()
{
  return ccder_blob_decode_tl();
}

uint64_t CTParseCertificateSet(unint64_t a1, unint64_t a2, _OWORD *a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  _OWORD *v10;
  unint64_t v11;
  __int128 v12;
  uint64_t result;
  unint64_t v15;
  unint64_t v16;
  _OWORD v17[19];
  uint64_t v18;

  v6 = 0;
  v18 = *MEMORY[0x24BDAC8D0];
  if (a1 < a2 && a4)
  {
    v8 = 0;
    v9 = a4 - 1;
    v10 = a3;
    v11 = (unint64_t)&a3[a4];
    while (1)
    {
      *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v17[17] = v12;
      v17[18] = v12;
      v17[15] = v12;
      v17[16] = v12;
      v17[13] = v12;
      v17[14] = v12;
      v17[11] = v12;
      v17[12] = v12;
      v17[9] = v12;
      v17[10] = v12;
      v17[7] = v12;
      v17[8] = v12;
      v17[5] = v12;
      v17[6] = v12;
      v17[3] = v12;
      v17[4] = v12;
      v17[1] = v12;
      v17[2] = v12;
      v17[0] = v12;
      v15 = a1;
      v16 = a2;
      result = X509CertificateParse((unint64_t *)v17, &v15);
      if ((_DWORD)result)
        break;
      a1 = v15;
      a2 = v16;
      if (v15 > v16 || (unint64_t)v10 >= v11 || v10 < a3)
        __break(0x5519u);
      *v10 = v17[0];
      v6 = v8 + 1;
      if (a1 < a2)
      {
        ++v10;
        if (v9 != v8++)
          continue;
      }
      goto LABEL_11;
    }
  }
  else
  {
LABEL_11:
    result = 0;
    if (a5)
      *a5 = v6;
  }
  return result;
}

uint64_t CTParseExtensionValue(unint64_t a1, uint64_t a2, const void *a3, size_t a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t result;
  uint64_t v9;
  unint64_t v10[2];
  _OWORD v11[15];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  memset(v11, 0, sizeof(v11));
  if (__CFADD__(a1, a2))
  {
    __break(0x5513u);
LABEL_11:
    __break(0x5519u);
  }
  if (a1 + a2 < a1)
    goto LABEL_11;
  v10[0] = a1;
  v10[1] = a1 + a2;
  result = X509CertificateParseWithExtension((unint64_t *)v11, v10, a3, a4);
  if (!(_DWORD)result)
  {
    result = 720914;
    if (*((_QWORD *)&v12 + 1))
    {
      v9 = v13;
      if ((_QWORD)v13)
      {
        result = 0;
        if (a5)
        {
          if (a6)
          {
            result = 0;
            *a5 = *((_QWORD *)&v12 + 1);
            *a6 = v9;
          }
        }
      }
    }
  }
  return result;
}

uint64_t CTParseKey(unint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t result;
  unint64_t v7[2];
  _OWORD v8[19];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  memset(v8, 0, sizeof(v8));
  if (__CFADD__(a1, a2))
  {
    __break(0x5513u);
LABEL_7:
    __break(0x5519u);
  }
  if (a1 + a2 < a1)
    goto LABEL_7;
  v7[0] = a1;
  v7[1] = a1 + a2;
  result = X509CertificateParse((unint64_t *)v8, v7);
  if (!(_DWORD)result)
    return X509CertificateParseKey((uint64_t)v8, a3, a4);
  return result;
}

uint64_t CTEvaluateSavageCertsWithUID(unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, _QWORD *a5, _QWORD *a6, _BYTE *a7, uint64_t a8, BOOL *a9)
{
  return CTEvaluateCertifiedChip(a1, a2, a3, a4, a5, a6, a7, a8, 0, 0, a9, (uint64_t)&X509PolicySavage, 2);
}

uint64_t CTEvaluateCertifiedChip(unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, _QWORD *a5, _QWORD *a6, _BYTE *a7, uint64_t a8, const void *a9, size_t a10, BOOL *a11, uint64_t a12, uint64_t a13)
{
  uint64_t result;
  uint64_t *v22;
  uint64_t v23;
  __int128 *v24;
  unint64_t v25;
  int v26;
  unint64_t v27[2];
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33[4];
  _QWORD __b[154];

  __b[152] = *MEMORY[0x24BDAC8D0];
  result = (uint64_t)memset(__b, 170, 0x4C0uLL);
  memset(v33, 170, sizeof(v33));
  v31 = 0xAAAAAAAAAAAAAAAALL;
  v32 = 0;
  v30 = 0xAAAAAAAAAAAAAAAALL;
  if (__CFADD__(a1, a2))
    goto LABEL_34;
  if (a1 + a2 < a1)
    goto LABEL_35;
  v30 = a1;
  v31 = a1 + a2;
  result = (uint64_t)X509ChainParseCertificateSet(&v30, (unint64_t)__b, 4, &v33[2], &v32);
  if ((_DWORD)result)
    return result;
  result = 327690;
  if (v30 != v31)
    return result;
  if (v32 != 2)
    return 327692;
  X509ChainResetChain(v33, &v33[2]);
  __b[74] = v33[0];
  v22 = v33[0] ? (uint64_t *)(v33[0] + 296) : &v33[1];
  *v22 = (uint64_t)&__b[74];
  if ((_QWORD *)((char *)&__b[38] + 1) != 0 && (unint64_t)__b >= 0xFFFFFFFFFFFFFECFLL)
LABEL_34:
    __break(0x5513u);
  v33[0] = (uint64_t)&__b[38];
  __b[75] = v33;
  __b[36] = 0;
  __b[37] = v33[1];
  *(_QWORD *)v33[1] = __b;
  v33[1] = (uint64_t)&__b[36];
  result = X509ChainCheckPathWithOptions(12, v33, a12, 0);
  if ((_DWORD)result)
    return result;
  v23 = **(_QWORD **)(v33[1] + 8);
  v28 = 0xAAAAAAAAAAAAAAAALL;
  v29 = 0xAAAAAAAAAAAAAAAALL;
  if ((a4 & 0x8000000000000000) != 0)
    goto LABEL_35;
  v28 = a3;
  v29 = a4;
  v24 = (__int128 *)oidForPubKeyLength();
  result = X509CertificateCheckSignatureWithPublicKey(&v28, (uint64_t)&ecPublicKey, v24, v23 + 16, (__int128 *)(v23 + 40), (__int128 *)(v23 + 56));
  if ((_DWORD)result)
    return result;
  if (a9 && a10)
  {
    if ((a10 & 0x8000000000000000) != 0)
      goto LABEL_35;
    if (compare_octet_string_raw(v23 + 248, a9, a10))
      return 590085;
  }
  v25 = v33[0];
  LODWORD(result) = X509CertificateParseKey(v33[0], a5, a6);
  v26 = result;
  if ((_DWORD)result)
    result = result;
  else
    result = 327691;
  if (!v25 || v26)
    return result;
  if (a11)
    *a11 = (*(_QWORD *)(v25 + 240) & a13) != 0;
  if (!a7 || !a8)
    return 0;
  v27[0] = 0;
  v27[1] = 0;
  if (v25 >= v25 + 304)
    goto LABEL_35;
  result = X509CertificateSubjectNameGetCommonName((unint64_t *)(v25 + 104), v27);
  if ((_DWORD)result)
    return result;
  if (a8 < 0)
  {
LABEL_35:
    __break(0x5519u);
    return result;
  }
  result = CTCopyUID((uint64_t)v27, a7, a8);
  if (!(_DWORD)result)
    return 0;
  return result;
}

uint64_t CTEvaluateSavageCerts(unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, _QWORD *a5, _QWORD *a6, BOOL *a7)
{
  return CTEvaluateCertifiedChip(a1, a2, a3, a4, a5, a6, 0, 0, 0, 0, a7, (uint64_t)&X509PolicySavage, 2);
}

uint64_t CTEvaluateYonkersCerts(unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, _QWORD *a5, _QWORD *a6, _BYTE *a7, uint64_t a8, BOOL *a9)
{
  return CTEvaluateCertifiedChip(a1, a2, a3, a4, a5, a6, a7, a8, 0, 0, a9, (uint64_t)&X509PolicyYonkers, 0x80000);
}

uint64_t CTEvaluateSensorCerts(unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, const void *a5, size_t a6, _QWORD *a7, _QWORD *a8, _BYTE *a9, uint64_t a10, BOOL *a11)
{
  return CTEvaluateCertifiedChip(a1, a2, a3, a4, a7, a8, a9, a10, a5, a6, a11, (uint64_t)&X509PolicySensor, 0x10000000000);
}

unint64_t CTCopyDeviceIdentifiers(unint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int v5;
  uint64_t v6;
  int v7;
  char v8;
  _QWORD v9[2];
  unint64_t v10;
  uint64_t v11;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x24BDAC8D0];
  v3 = 327696;
  if (!result || !a2)
    return v3;
  v11 = 0;
  v12[0] = 0;
  v10 = 0;
  if (__CFADD__(result, a2))
  {
    __break(0x5513u);
  }
  else if (result + a2 >= result)
  {
    v9[0] = result;
    v9[1] = result + a2;
    v5 = CTConvertDashTerminatedHexstringTo64BitInteger((uint64_t)v9, v12);
    v6 = 327697;
    if (!v5 && !HIDWORD(v12[0]))
    {
      if (CTConvertDashTerminatedHexstringTo64BitInteger((uint64_t)v9, &v11))
      {
        return 327698;
      }
      else
      {
        v7 = CTConvertDashTerminatedHexstringTo64BitInteger((uint64_t)v9, &v10);
        v6 = 327699;
        if (!v7)
        {
          v8 = v10;
          if (v10 <= 0xFF)
          {
            v6 = 0;
            if (a3)
            {
              *(_DWORD *)a3 = v12[0];
              *(_QWORD *)(a3 + 8) = v11;
              *(_BYTE *)(a3 + 16) = (v8 & 8) != 0;
              *(_BYTE *)(a3 + 17) = (v8 & 4) != 0;
              *(_BYTE *)(a3 + 18) = v8 & 3;
              *(_QWORD *)(a3 + 24) = 0;
              *(_QWORD *)(a3 + 32) = 0;
            }
          }
        }
      }
    }
    return v6;
  }
  __break(0x5519u);
  return result;
}

uint64_t CTConvertDashTerminatedHexstringTo64BitInteger(uint64_t result, _QWORD *a2)
{
  unsigned __int8 *v2;
  unint64_t v3;
  _QWORD *v4;
  unsigned __int8 *v5;
  unint64_t v6;
  unsigned __int8 *v7;
  char v8;
  unsigned __int8 *v9;
  uint64_t v10;
  signed int v11;
  char v12;
  uint64_t v13;
  char v14;
  unsigned int v15;
  unint64_t v16;
  unsigned __int8 *v17;
  BOOL v18;
  unsigned __int8 *v19;
  unsigned __int8 *v21;
  unsigned int v22;
  unint64_t v23;

  v2 = *(unsigned __int8 **)result;
  v3 = *(_QWORD *)(result + 8);
  if (*(_QWORD *)result > v3)
    goto LABEL_50;
  v4 = (_QWORD *)result;
  v5 = *(unsigned __int8 **)result;
  if (*(_QWORD *)result < v3)
  {
    v6 = v3 - (_QWORD)v2;
    v5 = *(unsigned __int8 **)result;
    while (*v5 != 45)
    {
      v7 = v5 + 1;
      if ((unint64_t)(v5 + 1) > v3 || v5 > v7)
        goto LABEL_50;
      *(_QWORD *)result = v7;
      ++v5;
      if (!--v6)
      {
        v5 = (unsigned __int8 *)v3;
        break;
      }
    }
  }
  if ((unint64_t)v5 > v3 || v2 > v5)
    goto LABEL_50;
  result = 327708;
  if (v5 == (unsigned __int8 *)v3)
    return result;
  v8 = (_BYTE)v5 - (_BYTE)v2;
  if (v5 - v2 > 16)
    return result;
  if (v5 == (unsigned __int8 *)-1)
    goto LABEL_51;
  v9 = v5 + 1;
  if ((unint64_t)(v5 + 1) > v3 || v5 > v9)
  {
LABEL_50:
    __break(0x5519u);
LABEL_51:
    __break(0x5513u);
LABEL_52:
    __break(0x5500u);
    return result;
  }
  v10 = 0;
  *v4 = v9;
  if (v2 >= v5 || (v11 = v8 + 1 + (((v8 + 1) & 0x8000u) >> 15), v11 << 23 >> 24 < 1))
  {
LABEL_46:
    result = 0;
    if (a2)
      *a2 = v10;
  }
  else
  {
    v12 = 0;
    v10 = 0;
    v13 = v11 >> 1;
    v14 = 8 * v13 - 8;
    while (1)
    {
      if ((v8 & 1) == 0 || (v12 & 1) != 0)
      {
        v16 = *v2;
        if (v16 > ~(unint64_t)asciiNibbleToByte)
          goto LABEL_51;
        v17 = &asciiNibbleToByte[v16];
        v18 = v17 < byte_217E36652 && v17 >= asciiNibbleToByte;
        if (!v18)
          goto LABEL_50;
        if (v2 == (unsigned __int8 *)-1)
          goto LABEL_51;
        if (v2 + 1 > v5 || v2 > v2 + 1)
          goto LABEL_50;
        v15 = *v17;
        ++v2;
      }
      else
      {
        v15 = 0;
      }
      if (v2 >= v5)
        return 327703;
      v19 = &asciiNibbleToByte[*v2];
      if (v19 >= byte_217E36652 || v19 < asciiNibbleToByte)
        goto LABEL_50;
      v21 = v2 + 1;
      if (v2 + 1 > v5 || v2 > v21)
        goto LABEL_50;
      if (v15 > 0xF)
        return 327703;
      v22 = *v19;
      if (v22 > 0xF)
        return 327703;
      v23 = (unint64_t)(v22 | (16 * v15)) << (v14 & 0xF8);
      v18 = __CFADD__(v10, v23);
      v10 += v23;
      if (v18)
        goto LABEL_52;
      if (v21 < v5)
      {
        v14 -= 8;
        v12 = 1;
        v2 = v21;
        if (v13-- > 1)
          continue;
      }
      goto LABEL_46;
    }
  }
  return result;
}

uint64_t CTEvaluateCertsForPolicy(unint64_t a1, uint64_t a2, char a3, int a4, _QWORD *a5, _QWORD *a6, uint64_t a7, uint64_t a8, _QWORD *a9, _QWORD *a10, __int128 *a11)
{
  uint64_t result;
  uint64_t v20;
  uint64_t *v21;
  _BYTE *v22;
  BOOL v23;
  __int128 v24;
  char v25;
  uint64_t v26;
  _UNKNOWN **v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  __int128 v31;
  _BYTE v32[32];
  uint64_t v33;
  _QWORD v34[2];
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38[4];
  _BYTE v39[272];
  uint64_t v40;
  _QWORD v41[117];

  v41[116] = *MEMORY[0x24BDAC8D0];
  memset(v38, 170, sizeof(v38));
  bzero(v39, 0x4C0uLL);
  if (__CFADD__(a1, a2))
  {
    __break(0x5513u);
LABEL_42:
    __break(0x5519u);
  }
  if (a1 + a2 < a1)
    goto LABEL_42;
  v36 = a1 + a2;
  v37 = 0xAAAAAAAAAAAAAAAALL;
  v35 = a1;
  result = (uint64_t)X509ChainParseCertificateSet(&v35, (unint64_t)v39, 4, &v38[2], &v37);
  if ((_DWORD)result)
    return result;
  if (v35 != v36)
    return 327690;
  if ((a4 & 1) == 0 && !v40)
  {
    X509ChainResetChain(v38, &v38[2]);
    v20 = v38[0];
    v21 = (uint64_t *)(v38[0] + 296);
    if (!v38[0])
      v21 = &v38[1];
    *v21 = (uint64_t)v41;
    v38[0] = (uint64_t)v39;
    v41[0] = v20;
    v41[1] = v38;
LABEL_20:
    v34[0] = a7;
    v34[1] = a8;
    if (a7)
      v23 = a8 == 0;
    else
      v23 = 1;
    *(_QWORD *)&v24 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)v32 = v24;
    *(_OWORD *)&v32[16] = v24;
    v31 = *a11;
    v32[0] = *((_BYTE *)a11 + 16);
    if (v23)
      v25 = a3;
    else
      v25 = 1;
    v32[1] = v25;
    *(_WORD *)&v32[2] = *((_WORD *)a11 + 9);
    if (v23)
    {
      *(_OWORD *)&v32[8] = *(__int128 *)((char *)a11 + 24);
      v27 = (_UNKNOWN **)*((_QWORD *)a11 + 5);
    }
    else
    {
      v26 = *((_QWORD *)a11 + 4);
      *(_QWORD *)&v32[8] = v34;
      *(_QWORD *)&v32[16] = v26;
      v27 = oidForPubKeyLength();
    }
    v28 = *((_QWORD *)a11 + 6);
    *(_QWORD *)&v32[24] = v27;
    v33 = v28;
    result = X509ChainCheckPathWithOptions(12, v38, (uint64_t)&v31, 0);
    if (!(_DWORD)result)
    {
      v29 = (_QWORD *)v38[0];
      if (!a5 || !a6 || !v38[0] || (result = X509CertificateParseKey(v38[0], a5, a6), !(_DWORD)result))
      {
        if (a10 && v29)
        {
          v30 = v29[32];
          *a10 = v29[31];
          a10[1] = v30;
        }
        result = 0;
        if (a9)
        {
          if (v29)
          {
            result = 0;
            *a9 = v29[30];
          }
        }
      }
    }
    return result;
  }
  if (v39[265])
  {
    if (v38[2])
    {
      v22 = (_BYTE *)v38[2];
      while (v22[265])
      {
        v22 = (_BYTE *)*((_QWORD *)v22 + 34);
        if (!v22)
        {
          v22 = (_BYTE *)v38[2];
          break;
        }
      }
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v22 = v39;
  }
  result = X509ChainBuildPathPartial(v22, &v38[2], v38, a4 ^ 1u);
  if (!(_DWORD)result)
    goto LABEL_20;
  return result;
}

uint64_t CTEvaluateSatori(unint64_t a1, uint64_t a2, char a3, _QWORD *a4, _QWORD *a5)
{
  return CTEvaluateCertsForPolicy(a1, a2, a3, 1, a4, a5, 0, 0, 0, 0, X509PolicySatori);
}

uint64_t CTEvaluateBAASystem(unint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  return CTEvaluateCertsForPolicy(a1, a2, 0, 1, a3, a4, 0, 0, 0, 0, X509PolicyBAASystem);
}

unint64_t CTEvaluateBAASystemWithId(unint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, uint64_t a5)
{
  unint64_t result;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v8 = 0;
  v9 = 0;
  v7 = 0;
  result = CTEvaluateCertsForPolicy(a1, a2, 0, 1, a3, a4, 0, 0, &v7, &v8, X509PolicyBAASystem);
  if (!(_DWORD)result)
    return CTFillBAAIdentity(v7, v8, v9, a5);
  return result;
}

unint64_t CTFillBAAIdentity(int a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t result;

  if ((a1 & 0x800000) != 0 && a4)
  {
    result = CTCopyDeviceIdentifiers(a2, a3, a4);
    if ((_DWORD)result)
      return result;
  }
  else if (!a4)
  {
    return 0;
  }
  result = 0;
  if (a1 < 0 && a3)
  {
    if (a2)
    {
      *(_QWORD *)(a4 + 32) = 0;
      *(_OWORD *)a4 = 0u;
      *(_OWORD *)(a4 + 16) = 0u;
      result = 0;
      *(_QWORD *)(a4 + 24) = a2;
      *(_QWORD *)(a4 + 32) = a3;
      return result;
    }
    return 0;
  }
  return result;
}

unint64_t CTEvaluateBAASystemTestRoot(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6, uint64_t a7)
{
  unint64_t result;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = 0;
  v11 = 0;
  v9 = 0;
  result = CTEvaluateCertsForPolicy(a1, a2, 1, 1, a5, a6, a3, a4, &v9, &v10, X509PolicyBAASystem);
  if (!(_DWORD)result)
    return CTFillBAAIdentity(v9, v10, v11, a7);
  return result;
}

unint64_t CTEvaluateBAAUser(unint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, uint64_t a5)
{
  unint64_t result;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v8 = 0;
  v9 = 0;
  v7 = 0;
  result = CTEvaluateCertsForPolicy(a1, a2, 0, 1, a3, a4, 0, 0, &v7, &v8, X509PolicyBAAUser);
  if (!(_DWORD)result)
    return CTFillBAAIdentity(v7, v8, v9, a5);
  return result;
}

unint64_t CTEvaluateBAAUserTestRoot(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6, uint64_t a7)
{
  unint64_t result;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = 0;
  v11 = 0;
  v9 = 0;
  result = CTEvaluateCertsForPolicy(a1, a2, 1, 1, a5, a6, a3, a4, &v9, &v10, X509PolicyBAAUser);
  if (!(_DWORD)result)
    return CTFillBAAIdentity(v9, v10, v11, a7);
  return result;
}

unint64_t CTEvaluateBAASepApp(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6, uint64_t a7)
{
  unint64_t result;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = 0;
  v11 = 0;
  v9 = 0;
  result = CTEvaluateCertsForPolicy(a1, a2, 1, 1, a5, a6, a3, a4, &v9, &v10, X509PolicyBAASepApp);
  if (!(_DWORD)result)
    return CTFillBAAIdentity(v9, v10, v11, a7);
  return result;
}

uint64_t CTEvaluateBAA(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, _QWORD *a7, _QWORD *a8, _QWORD *a9, uint64_t a10)
{
  uint64_t result;

  switch(a1)
  {
    case 1:
      result = CTEvaluateBAASystemTestRoot(a2, a3, a4, a5, a6, a7, a10);
      break;
    case 2:
      result = CTEvaluateBAAUserTestRoot(a2, a3, a4, a5, a6, a7, a10);
      break;
    case 3:
      result = CTEvaluateBAAAccessory(a2, a3, a4, a5, a6, a7, a8, a9);
      break;
    case 4:
      result = CTEvaluateBAASepApp(a2, a3, a4, a5, a6, a7, a10);
      break;
    default:
      result = 327712;
      break;
  }
  return result;
}

uint64_t CTEvaluateBAAAccessory(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6, _QWORD *a7, _QWORD *a8)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v12 = 0;
  v13 = 0;
  result = CTEvaluateCertsForPolicy(a1, a2, 0, 1, a5, a6, a3, a4, 0, &v12, X509PolicyMFi4Attestation);
  if (!(_DWORD)result && a7)
  {
    if (a8)
    {
      v11 = v13;
      *a7 = v12;
      *a8 = v11;
    }
  }
  return result;
}

uint64_t CTGetBAARootType(unint64_t a1, uint64_t a2)
{
  unint64_t v3[2];
  _OWORD v4[19];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  memset(v4, 0, sizeof(v4));
  if (__CFADD__(a1, a2))
  {
    __break(0x5513u);
LABEL_14:
    __break(0x5519u);
  }
  if (a1 + a2 < a1)
    goto LABEL_14;
  v3[0] = a1;
  v3[1] = a1 + a2;
  if (X509CertificateParse((unint64_t *)v4, v3))
    return 0;
  if (!compare_octet_string((uint64_t)&v4[5] + 8, (uint64_t)&BASystemRootSPKI))
    return 1;
  if (!compare_octet_string((uint64_t)&v4[5] + 8, (uint64_t)&BAUserRootSPKI))
    return 2;
  if (compare_octet_string((uint64_t)&v4[5] + 8, (uint64_t)&MFi4RootSpki))
    return 4 * (compare_octet_string((uint64_t)&v4[5] + 8, (uint64_t)&BASepAppRootSPKI) == 0);
  return 3;
}

uint64_t CTGetBAASubCAType(unint64_t a1, uint64_t a2)
{
  unint64_t v3[2];
  _OWORD v4[19];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  memset(v4, 0, sizeof(v4));
  if (__CFADD__(a1, a2))
  {
    __break(0x5513u);
LABEL_14:
    __break(0x5519u);
  }
  if (a1 + a2 < a1)
    goto LABEL_14;
  v3[0] = a1;
  v3[1] = a1 + a2;
  if (X509CertificateParse((unint64_t *)v4, v3))
    return 0;
  if (!compare_octet_string((uint64_t)&v4[10] + 8, (uint64_t)&BASystemRootSKID))
    return 1;
  if (!compare_octet_string((uint64_t)&v4[10] + 8, (uint64_t)&BAUserRootSKID))
    return 2;
  if (compare_octet_string((uint64_t)&v4[10] + 8, (uint64_t)&MFi4RootSKID))
    return 4 * (compare_octet_string((uint64_t)&v4[10] + 8, (uint64_t)&BASepAppRootSKID) == 0);
  return 3;
}

uint64_t CTEvaluateDAK(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6, uint64_t a7)
{
  unint64_t v7;
  uint64_t result;
  __int128 v12;
  unint64_t v13;
  _BYTE *v14;
  int v15;
  unint64_t v16[2];
  uint64_t v17;
  _QWORD v18[2];
  uint64_t v19;
  unint64_t v20;
  _QWORD v21[2];
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _OWORD v27[19];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v7 = a1 + a2;
  if (a1 + a2 < a1)
    goto LABEL_31;
  result = CTEvaluateBAAUserTestRoot(a1, a2, a3, a4, a5, a6, a7);
  if ((_DWORD)result)
    return result;
  *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v27[17] = v12;
  v27[18] = v12;
  v27[15] = v12;
  v27[16] = v12;
  v27[13] = v12;
  v27[14] = v12;
  v27[11] = v12;
  v27[12] = v12;
  v27[9] = v12;
  v27[10] = v12;
  v27[7] = v12;
  v27[8] = v12;
  v27[5] = v12;
  v27[6] = v12;
  v27[3] = v12;
  v27[4] = v12;
  v27[1] = v12;
  v27[2] = v12;
  v27[0] = v12;
  v18[0] = 0xAAAAAAAAAAAAAAAALL;
  v18[1] = 0xAAAAAAAAAAAAAAAALL;
  v17 = 0;
  if (__CFADD__(a1, a2))
    goto LABEL_32;
  v16[0] = a1;
  v16[1] = v7;
  result = (uint64_t)X509ChainParseCertificateSet(v16, (unint64_t)v27, 1, v18, &v17);
  if (!(_DWORD)result)
  {
    if (!v18[0])
      return 327691;
    v25 = 0;
    v26 = 0;
    result = CTParseExtensionValue(*(_QWORD *)v18[0], *(_QWORD *)(v18[0] + 8), &CTOidAppleFDRIdentity, 9uLL, &v25, &v26);
    if (!(_DWORD)result)
    {
      v23 = 0xAAAAAAAAAAAAAAAALL;
      v24 = 0xAAAAAAAAAAAAAAAALL;
      if (!__CFADD__(v25, v26))
      {
        if (v25 > v25 + v26)
          goto LABEL_31;
        v23 = v25;
        v24 = v25 + v26;
        v22 = v26;
        result = ccder_blob_decode_tl();
        if (!(_DWORD)result)
          return 720929;
        if (v24 < v23)
          goto LABEL_31;
        v13 = v22;
        if (v22 > v24 - v23)
          goto LABEL_31;
        v25 = v23;
        v26 = v22;
        if (!__CFADD__(v23, v22))
        {
          v14 = (_BYTE *)v23;
          if (v23 < v23 + v22)
          {
            do
            {
              if ((unint64_t)v14 < v23)
                goto LABEL_31;
              if (*v14 == 45)
                goto LABEL_19;
              ++v14;
              --v13;
            }
            while (v13);
            v14 = (_BYTE *)(v23 + v22);
          }
LABEL_19:
          if (v14 != (_BYTE *)-1)
          {
            if ((unint64_t)(v14 + 1) >= v23 + v22)
              return 327711;
            if (v23 <= (unint64_t)(v14 + 1))
            {
              v21[0] = v14 + 1;
              v21[1] = v23 + v22;
              v19 = 0;
              v20 = 0;
              v15 = CTConvertDashTerminatedHexstringTo64BitInteger((uint64_t)v21, &v20);
              result = 327697;
              if (!v15 && !HIDWORD(v20))
              {
                if (CTConvertDashTerminatedHexstringTo64BitInteger((uint64_t)v21, &v19))
                {
                  return 327698;
                }
                else
                {
                  result = 0;
                  if (a7)
                  {
                    *(_DWORD *)a7 = v20;
                    *(_QWORD *)(a7 + 8) = v19;
                  }
                }
              }
              return result;
            }
LABEL_31:
            __break(0x5519u);
          }
        }
      }
LABEL_32:
      __break(0x5513u);
    }
  }
  return result;
}

uint64_t CTEvaluateAcrt(unint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  return CTEvaluateCertsForPolicy(a1, a2, 0, 0, a3, a4, 0, 0, 0, 0, X509PolicyACRT);
}

uint64_t CTEvaluateUcrt(unint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  return CTEvaluateCertsForPolicy(a1, a2, 0, 1, a3, a4, 0, 0, 0, 0, X509PolicyUcrt);
}

uint64_t CTEvaluateUcrtTestRoot(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6)
{
  return CTEvaluateCertsForPolicy(a1, a2, 1, 1, a5, a6, a3, a4, 0, 0, X509PolicyUcrt);
}

uint64_t CTParseFlagsForAccessoryCerts(uint64_t result)
{
  uint64_t v1;
  unsigned __int8 *v2;
  uint64_t v3;

  v1 = result;
  if (!result || (result = *(_QWORD *)(result + 240)) == 0)
  {
    v3 = v1 + 136;
    v2 = *(unsigned __int8 **)(v1 + 136);
    if (*(_QWORD *)(v3 + 8) != 15 || v2 == 0)
      return 0;
    if ((unint64_t)v2 < 0xFFFFFFFFFFFFFFFELL)
    {
      if (v2[2] != 170)
        return 0;
      if ((unint64_t)v2 <= 0xFFFFFFFFFFFFFFF9)
      {
        if (v2[6] != 170)
          return 0;
        if ((unint64_t)v2 <= 0xFFFFFFFFFFFFFFF7)
        {
          if (v2[8] == 170)
          {
            if ((unint64_t)v2 <= 0xFFFFFFFFFFFFFFF4)
            {
              if (v2[11] == 170)
                return 0x8000000;
              return 0;
            }
            goto LABEL_17;
          }
          return 0;
        }
      }
    }
LABEL_17:
    __break(0x5513u);
  }
  return result;
}

uint64_t CTParseAccessoryCerts(char *a1, uint64_t a2, _QWORD *a3, _QWORD *a4, char **a5, unint64_t *a6, uint64_t *a7)
{
  char *v14;
  uint64_t result;
  _BYTE *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  char v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  BOOL v34;
  uint64_t v35;
  unint64_t v36[4];
  unint64_t v37;
  unint64_t v38[2];
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  _BYTE v46[1216];
  _QWORD v47[2];

  v47[0] = *MEMORY[0x24BDAC8D0];
  bzero(v46, 0x4C0uLL);
  v45 = 0;
  v44 = 0u;
  v43 = 0u;
  v42 = 0u;
  v41 = 0u;
  v40 = 0u;
  v39 = 0u;
  v38[0] = 4;
  v38[1] = (unint64_t)v46;
  v14 = &a1[a2];
  v37 = 0;
  result = CMSParseContentInfoSignedDataWithOptions(a1, a2, v38, 1);
  if ((_DWORD)result)
  {
    memset(v36, 170, sizeof(v36));
    if (__CFADD__(a1, a2))
      goto LABEL_65;
    v36[0] = (unint64_t)a1;
    v36[1] = (unint64_t)&a1[a2];
    result = (uint64_t)X509ChainParseCertificateSet(v36, (unint64_t)v46, 4, &v36[2], &v37);
    if ((_DWORD)result)
      return result;
    if (v36[0] != v36[1])
      return 327690;
  }
  else
  {
    v37 = v39;
  }
  if (!v46[265])
  {
    if (v37 < 2)
    {
      v20 = 0;
      v17 = 0;
      v16 = v46;
      goto LABEL_19;
    }
    v18 = v37 - 1;
    if (__OFSUB__(v37, 1))
    {
LABEL_67:
      __break(0x5515u);
      return result;
    }
    v17 = 0;
    v16 = v46;
    v20 = 1;
    v19 = 1;
    goto LABEL_20;
  }
  v16 = v46;
  if (!v37)
  {
    v20 = 0;
    v17 = 0;
    goto LABEL_19;
  }
  if (v37 > 5)
  {
LABEL_66:
    __break(0x5512u);
    goto LABEL_67;
  }
  v17 = 304 * v37 - 304;
  if (__CFADD__(v46, v17))
  {
LABEL_65:
    __break(0x5513u);
    goto LABEL_66;
  }
  v16 = &v46[v17];
  v18 = v37 - 2;
  if (v37 < 2)
  {
    v20 = 0;
LABEL_19:
    v18 = -1;
    v19 = -1;
    goto LABEL_20;
  }
  v19 = 0;
  v20 = 1;
LABEL_20:
  if (a5 && a6)
  {
    v21 = v20 ^ 1;
    if (v18 < 0)
      v21 = 1;
    if ((v21 & 1) != 0)
    {
      v27 = 0;
      v26 = 0;
LABEL_47:
      *a5 = v27;
      *a6 = v26;
      goto LABEL_48;
    }
    v22 = (unint64_t *)&v46[304 * (int)v19];
    if (v22 >= v47 || v22 < (unint64_t *)v46)
      goto LABEL_63;
    v23 = 304 * (int)v19;
    if (v23 > 0x4BF)
      goto LABEL_64;
    v24 = v23 | 8;
    if ((v23 | 8) > 0x4C0)
      goto LABEL_64;
    v25 = *v22;
    if (v19 <= v18)
    {
      v26 = 0;
      while (1)
      {
        if (&v46[v24 - 8] >= (_BYTE *)v47 || &v46[v24 - 8] < v46)
          goto LABEL_63;
        if (v24 > 0x4C0)
          goto LABEL_64;
        v29 = *(_QWORD *)&v46[v24];
        v30 = __CFADD__(v26, v29);
        v26 += v29;
        if (v30)
          break;
        v31 = v19 + 1;
        if (__OFADD__(v19, 1))
          break;
        v24 += 304;
        ++v19;
        if (v31 > v18)
          goto LABEL_41;
      }
      __break(0x5500u);
      goto LABEL_63;
    }
    v26 = 0;
LABEL_41:
    v32 = v25 - (_QWORD)a1;
    v33 = v25 >= (unint64_t)a1;
    v34 = v25 < (unint64_t)a1;
    if (v32 < 0)
      v33 = v34;
    if (v33)
    {
      v27 = &a1[v32];
      if (v14 < v27 || v27 < a1 || v26 > v14 - v27)
        goto LABEL_63;
      goto LABEL_47;
    }
    goto LABEL_65;
  }
LABEL_48:
  if (a7 && v16)
  {
    if (v16 >= (_BYTE *)v47 || v16 < v46)
      goto LABEL_63;
    *a7 = CTParseFlagsForAccessoryCerts((uint64_t)v16);
  }
  result = 0;
  if (a3 && a4 && v16)
  {
    if (v46 <= v16 && v16 + 304 <= (_BYTE *)v47)
    {
      if (v17 <= 0x4BF && (v17 | 8) <= 0x4C0)
      {
        result = 0;
        v35 = *((_QWORD *)v16 + 1);
        *a3 = *(_QWORD *)v16;
        *a4 = v35;
        return result;
      }
LABEL_64:
      __break(1u);
    }
LABEL_63:
    __break(0x5519u);
    goto LABEL_64;
  }
  return result;
}

uint64_t CTEvaluateAccessoryCert(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, _QWORD *a8, _QWORD *a9, _QWORD *a10, _QWORD *a11)
{
  uint64_t result;
  uint64_t v20;
  uint64_t **v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  BOOL v25;
  unint64_t v26;
  char v27;
  char v28;
  char v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  __int16 v34;
  char v35;
  char v36;
  int v37;
  unint64_t *v38;
  unint64_t *v39;
  unint64_t *v40;
  uint64_t v41;
  unint64_t v42[2];
  unint64_t v43[4];
  unint64_t v44;
  unint64_t v45;
  unint64_t v46[4];
  unint64_t *v47;
  uint64_t *v48;
  _BYTE v49[272];
  uint64_t v50;
  unint64_t v51[34];
  _QWORD v52[4];
  unint64_t v53[11];
  unint64_t v54[19];
  uint64_t v55;
  _QWORD v56[44];

  v56[42] = *MEMORY[0x24BDAC8D0];
  bzero(v51, 0x390uLL);
  v47 = 0;
  v48 = 0;
  memset(v46, 170, sizeof(v46));
  if (__CFADD__(a1, a2))
    goto LABEL_56;
  if (a1 + a2 < a1)
    goto LABEL_57;
  v46[0] = a1;
  v46[1] = a1 + a2;
  result = X509CertificateParse(v51, v46);
  if ((_DWORD)result)
    return result;
  v20 = (uint64_t)v47;
  v21 = &v48;
  if (v47)
    v21 = (uint64_t **)(v47 + 35);
  *v21 = v52;
  v47 = v51;
  v52[0] = v20;
  v52[1] = &v47;
  v44 = 0xAAAAAAAAAAAAAAAALL;
  v45 = 0xAAAAAAAAAAAAAAAALL;
  if (__CFADD__(a5, a6))
    goto LABEL_56;
  if (a5 + a6 < a5)
    goto LABEL_57;
  v44 = a5;
  v45 = a5 + a6;
  if ((unint64_t *)((char *)v53 + 1) != 0 && (unint64_t)v51 >= 0xFFFFFFFFFFFFFECFLL)
    goto LABEL_56;
  result = X509CertificateParse(v53, &v44);
  if ((_DWORD)result)
    return result;
  v56[0] = 0;
  v56[1] = v48;
  *v48 = (uint64_t)v53;
  v48 = v56;
  bzero(v49, 0x390uLL);
  if (!a3 || !a4)
  {
LABEL_22:
    result = X509ChainBuildPath(v51, (uint64_t *)&v47, &v46[2]);
    if ((_DWORD)result)
      return result;
    v26 = 0;
    v27 = 0;
    v28 = 28;
    result = 327700;
    if (a7 <= 0x1FFFFFFF)
    {
      if (a7 <= 0x7FFFFFF)
      {
        if (a7)
        {
          v29 = 0;
          if (a7 != 4)
            return result;
        }
        else
        {
          v27 = 0;
          v26 = 0;
          v29 = 1;
        }
        goto LABEL_44;
      }
      if (a7 == 0x8000000)
      {
        v26 = 0;
        v29 = 0;
        v28 = 29;
        v27 = 1;
        goto LABEL_44;
      }
      if (a7 != 0x10000000)
        return result;
    }
    else
    {
      if (a7 > 0x3FFFFFFFFLL)
      {
        if (a7 == 0x400000000 || a7 == 0x800000000)
        {
          v29 = 0;
        }
        else
        {
          v29 = 0;
          if (a7 != 0x1000000000)
            return result;
        }
        goto LABEL_44;
      }
      if (a7 != 0x20000000)
      {
        if (a7 != 0x40000000)
          return result;
        v27 = 0;
        v29 = 0;
        v26 = 3;
        goto LABEL_44;
      }
      v27 = 1;
    }
    v29 = v27;
    v26 = 2;
    v27 = 0;
LABEL_44:
    if (!v55)
      v55 = a7;
    memset(v43, 170, sizeof(v43));
    v42[0] = 0xAAAAAAAAAAAAAAAALL;
    v42[1] = 0xAAAAAAAAAAAAAAAALL;
    X509CertificateParseSPKI(v54, &v43[2], v42, v43);
    v32 = v26;
    v33 = a7;
    v37 = -1431655766;
    v38 = v43;
    v34 = 0;
    v35 = v29;
    v36 = v27;
    v39 = &v43[2];
    v40 = v42;
    v41 = 0;
    result = X509ChainCheckPath(v28, (uint64_t *)&v46[2], (uint64_t)&v32);
    if (!(_DWORD)result)
    {
      v30 = v46[2];
      if (!a8 || !a9 || !v46[2] || (result = X509CertificateParseKey(v46[2], a8, a9), !(_DWORD)result))
      {
        result = 0;
        if (a10 && a11)
        {
          if (v30)
          {
            result = 0;
            v31 = *(_QWORD *)(v30 + 256);
            *a10 = *(_QWORD *)(v30 + 248);
            *a11 = v31;
          }
        }
      }
    }
    return result;
  }
  if (__CFADD__(a3, a4))
  {
LABEL_56:
    __break(0x5513u);
LABEL_57:
    __break(0x5519u);
  }
  if (a3 + a4 < a3)
    goto LABEL_57;
  v32 = a3;
  v33 = a3 + a4;
  if (a3 + a4 <= a3)
    goto LABEL_22;
  v22 = 0;
  v23 = &v50;
  while (1)
  {
    result = X509CertificateParse((unint64_t *)v23 - 34, &v32);
    if ((_DWORD)result)
      return result;
    v24 = v48;
    *v23 = 0;
    v23[1] = (uint64_t)v24;
    *v24 = (uint64_t)(v23 - 34);
    v48 = v23;
    v25 = v32 >= v33 || v22++ > 1;
    v23 += 38;
    if (v25)
      goto LABEL_22;
  }
}

uint64_t CTEvaluatePragueSignatureCMS(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, _QWORD *a6, _QWORD *a7)
{
  __int128 v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v9 = 0xAAAAAAAA0000AA01;
  v8 = xmmword_217E36710;
  BYTE1(v9) = a5;
  v10 = 0u;
  v11 = 0u;
  return CMSVerifySignedDataWithLeaf(a1, a2, a3, a4, (uint64_t)&v8, a6, a7);
}

uint64_t CTEvaluateKDLSignatureCMS(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, _QWORD *a6, _QWORD *a7)
{
  __int128 v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v9 = 0xAAAAAAAA0000AA01;
  v8 = xmmword_217E36720;
  BYTE1(v9) = a5;
  v10 = 0u;
  v11 = 0u;
  return CMSVerifySignedDataWithLeaf(a1, a2, a3, a4, (uint64_t)&v8, a6, a7);
}

uint64_t CTVerifyAppleMarkerExtension(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;
  unint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  unint64_t v11;
  char v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  unsigned __int8 *v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;

  result = 327700;
  v4 = a1[31];
  v5 = a1[32];
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
    return 327707;
  v7 = a1[30];
  if ((v7 & 0x100000000) == 0)
  {
    if ((v7 & 0x200000000) == 0)
      return result;
    if (!__CFADD__(v4, v5))
    {
      v11 = v4 + v5;
      if (v4 + v5 != -1)
      {
        if (v5 > 0x13)
          return 327704;
        v16 = (unsigned __int8 *)(v11 - 1);
        if (v11 - 1 >= v4)
        {
          v10 = 0;
          v17 = 0;
          while ((unint64_t)v16 < v11)
          {
            v18 = *v16;
            if ((v18 - 58) < 0xFFFFFFF6)
              return 327705;
            if (v17 == 20)
              break;
            if ((v17 & 0x1FFFFFFFFFFFFFFFLL) == 0x14)
              goto LABEL_39;
            v19 = (v18 - 48);
            v20 = powersOfTen[v17];
            if (!is_mul_ok(v19, v20))
              goto LABEL_40;
            v21 = v19 * v20;
            v15 = __CFADD__(v10, v21);
            v10 += v21;
            if (v15)
              goto LABEL_38;
            ++v17;
            if ((unint64_t)--v16 < v4)
              goto LABEL_23;
          }
LABEL_37:
          __break(0x5519u);
LABEL_38:
          __break(0x5500u);
LABEL_39:
          __break(1u);
LABEL_40:
          __break(0x550Cu);
          goto LABEL_41;
        }
        goto LABEL_13;
      }
    }
LABEL_41:
    __break(0x5513u);
    return result;
  }
  if (__CFADD__(v4, v5))
    goto LABEL_41;
  v8 = v4 + v5;
  if (v4 + v5 == -1)
    goto LABEL_41;
  v9 = (_BYTE *)(v8 - 1);
  if (v8 - 1 >= v4)
  {
    v12 = 0;
    v13 = 0;
    v10 = 0;
    while ((unint64_t)v9 < v8)
    {
      v14 = (unint64_t)(*v9 & 0x7F) << v12;
      v15 = __CFADD__(v10, v14);
      v10 += v14;
      if (v15)
        goto LABEL_38;
      if (v13 <= 7)
      {
        ++v13;
        --v9;
        v12 += 7;
        if ((unint64_t)v9 >= v4)
          continue;
      }
      goto LABEL_23;
    }
    goto LABEL_37;
  }
LABEL_13:
  v10 = 0;
LABEL_23:
  if (v10 == a2)
    return 0;
  else
    return 589829;
}

uint64_t CTVerifyHostname(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  _QWORD v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v3 = 327702;
  if (*(_QWORD *)(a1 + 232) && *(_QWORD *)(a1 + 224))
  {
    v7[1] = a3;
    v8 = 0xAAAAAAAAAAAAAA00;
    v7[0] = a2;
    v4 = X509CertificateParseGeneralNamesContent(a1, (uint64_t (*)(_QWORD, int *, uint64_t))CTCompareGeneralNameToHostname, (uint64_t)v7);
    if ((_BYTE)v8)
      v5 = 0;
    else
      v5 = 327706;
    if (v4)
      return v4;
    else
      return v5;
  }
  return v3;
}

uint64_t CTCompareGeneralNameToHostname(uint64_t result, _QWORD *a2, unint64_t a3)
{
  char *v4;
  size_t v5;
  size_t v6;
  char *v7;
  char *v8;
  BOOL v9;
  int v11;
  size_t v12;
  unint64_t v13;
  _BYTE *v14;
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  char *v20;
  size_t v22;
  size_t v23;

  if ((_DWORD)result != 2)
    return 1;
  v4 = *(char **)a3;
  v5 = *(_QWORD *)(a3 + 8);
  v6 = ~*(_QWORD *)a3;
  if (v5 > v6)
    goto LABEL_50;
  v7 = &v4[v5];
  if (&v4[v5] == (char *)-1)
    goto LABEL_50;
  v8 = v7 - 1;
  if (v7)
    v9 = v8 >= v4;
  else
    v9 = 0;
  if (!v9 || a3 + 24 < a3)
    goto LABEL_49;
  v11 = *v8;
  result = compare_octet_string((uint64_t)a2, a3);
  if (!(_DWORD)result)
    goto LABEL_48;
  if (v11 != 46)
    goto LABEL_15;
  v12 = v5 - 1;
  if (v5)
  {
    if (v12 <= v5)
    {
      result = compare_octet_string_raw((uint64_t)a2, v4, v12);
      if ((_DWORD)result)
      {
LABEL_15:
        v13 = a2[1];
        if (v13 < 3)
          return 1;
        v14 = (_BYTE *)*a2;
        if (*(_BYTE *)*a2 != 42)
          return 1;
        if (v14 != (_BYTE *)-1)
        {
          v15 = v14 + 1;
          if (v14[1] == 46)
          {
            v16 = -2;
            if ((unint64_t)v14 < 0xFFFFFFFFFFFFFFFELL)
              v16 = (uint64_t)v14;
            v17 = -v16;
            v18 = 2;
            result = 1;
            while (v17 != v18)
            {
              if (&v14[v18] < v14)
                goto LABEL_49;
              if (v14[v18] == 46)
              {
                if (v13 == v18)
                  return 1;
                v19 = 0;
                if (v5)
                {
                  while (1)
                  {
                    v20 = &v4[v19];
                    if (&v4[v19] >= v7 || v20 < v4)
                      goto LABEL_49;
                    if (*v20 == 46)
                      break;
                    if (v5 == ++v19)
                    {
                      v19 = v5;
                      break;
                    }
                  }
                }
                v22 = v13 - 1;
                v9 = v5 >= v19;
                v23 = v5 - v19;
                if (!v9)
                  goto LABEL_51;
                if (v22 == v23)
                {
                  if (v19 > v6)
                    goto LABEL_50;
                  result = memcmp(v15, &v4[v19], v13 - 1);
                  if (!(_DWORD)result)
                    goto LABEL_48;
                }
                if (v11 != 46)
                  return 1;
                if (!v23)
                  goto LABEL_51;
                if (v22 != v23 - 1)
                  return 1;
                if (v19 <= v6)
                {
                  if (!memcmp(v15, &v4[v19], v22))
                    goto LABEL_48;
                  return 1;
                }
                goto LABEL_50;
              }
              if (v13 == ++v18)
                return result;
            }
            goto LABEL_50;
          }
          return 1;
        }
LABEL_50:
        __break(0x5513u);
        goto LABEL_51;
      }
LABEL_48:
      result = 0;
      *(_BYTE *)(a3 + 16) = 1;
      return result;
    }
LABEL_49:
    __break(0x5519u);
    goto LABEL_50;
  }
LABEL_51:
  __break(0x5515u);
  return result;
}

uint64_t CTEvaluateAppleSSLWithOptionalTemporalCheck(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, char a7)
{
  uint64_t result;
  __int128 v13;
  unint64_t v14[2];
  _QWORD v15[3];
  _OWORD v16[19];
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  unint64_t v20;
  __int128 *v21;
  __int128 *v22;
  __int128 *v23;
  _UNKNOWN **v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v20 = 0xAAAAAAAA00AAAA01;
  v21 = &null_octet;
  v19 = xmmword_217E36730;
  BYTE1(v20) = a6;
  BYTE2(v20) = a7;
  v22 = &null_octet;
  v23 = &null_octet;
  v24 = &CTOctetServerAuthEKU;
  v17 = 0;
  v18 = 0;
  result = CTEvaluateCertsForPolicy(a1, a2, a6, 1, &v17, &v18, 0, 0, 0, 0, &v19);
  if (!(_DWORD)result)
  {
    *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v16[17] = v13;
    v16[18] = v13;
    v16[15] = v13;
    v16[16] = v13;
    v16[13] = v13;
    v16[14] = v13;
    v16[11] = v13;
    v16[12] = v13;
    v16[9] = v13;
    v16[10] = v13;
    v16[7] = v13;
    v16[8] = v13;
    v16[6] = v13;
    v16[4] = v13;
    v16[5] = v13;
    v16[2] = v13;
    v16[3] = v13;
    v16[0] = v13;
    v16[1] = v13;
    memset(v15, 170, sizeof(v15));
    if (__CFADD__(a1, a2))
    {
      __break(0x5513u);
    }
    else
    {
      v14[0] = a1;
      v14[1] = a1 + a2;
      result = (uint64_t)X509ChainParseCertificateSet(v14, (unint64_t)v16, 1, &v15[1], v15);
      if (!(_DWORD)result)
      {
        result = CTVerifyAppleMarkerExtension(v16, a5);
        if (!(_DWORD)result)
          return CTVerifyHostname((uint64_t)v16, a3, a4);
      }
    }
  }
  return result;
}

uint64_t CTEvaluateAppleSSL(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  return CTEvaluateAppleSSLWithOptionalTemporalCheck(a1, a2, a3, a4, a5, a6, 1);
}

uint64_t CTCopyUID(uint64_t result, _BYTE *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  _BYTE *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v14;
  unsigned int v15;
  unsigned int v16;

  v5 = *(_QWORD *)result;
  v4 = *(_QWORD *)(result + 8);
  if (__CFADD__(*(_QWORD *)result, v4))
    goto LABEL_31;
  v6 = v5 + v4;
  v7 = *(unsigned __int8 **)result;
  if (v5 < v6)
  {
    while ((unint64_t)v7 >= v5)
    {
      v3 = *v7;
      if (v3 != 45 && (unint64_t)++v7 < v6)
        continue;
      goto LABEL_6;
    }
    goto LABEL_34;
  }
LABEL_6:
  if (v7 == (unsigned __int8 *)-1)
    goto LABEL_31;
  v8 = v7 + 1;
  v3 = 327693;
  result = 327693;
  if ((unint64_t)(v7 + 1) >= v6)
    return result;
  if (a3 < 0 || v5 > (unint64_t)v8)
  {
LABEL_34:
    __break(0x5519u);
    return result;
  }
  if (__CFADD__(v8, v6 - (_QWORD)v8))
    goto LABEL_31;
  if (v6 - (_QWORD)v8 != 2 * a3)
    return (v3 + 1);
  if (__CFADD__(a2, a3) || v7 == (unsigned __int8 *)-2)
  {
LABEL_31:
    __break(0x5513u);
    return (v3 + 1);
  }
  v9 = v7 + 2;
  v10 = a2;
  while (1)
  {
    result = 0;
    if ((unint64_t)v9 >= v6 || v10 >= &a2[a3])
      return result;
    v11 = v9 - 1;
    if ((unint64_t)(v9 - 1) >= v6 || v11 < v8)
      goto LABEL_34;
    v12 = &asciiNibbleToByte[*v11];
    result = (uint64_t)byte_217E36652;
    if (v12 >= byte_217E36652 || v12 < asciiNibbleToByte)
      goto LABEL_34;
    if (v11 < v7)
      goto LABEL_34;
    v14 = &asciiNibbleToByte[*v9];
    result = (uint64_t)byte_217E36652;
    if (v14 >= byte_217E36652 || v14 < asciiNibbleToByte)
      goto LABEL_34;
    v15 = *v12;
    result = 327695;
    if (v15 > 0xF)
      return result;
    v16 = *v14;
    if (v16 > 0xF)
      return result;
    if (v10 < a2)
      goto LABEL_34;
    *v10++ = v16 | (16 * v15);
    v9 += 2;
    if (!v9)
      goto LABEL_31;
  }
}

uint64_t X509CertificateParseImplicit(uint64_t a1, unint64_t *a2, const void *a3, size_t a4)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  BOOL v39;
  int v40;
  int v41;
  unint64_t v43;
  unint64_t v51;
  unint64_t v52;
  unsigned __int8 v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  char v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  _OWORD v70[10];
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  v68 = 0;
  v69 = 0;
  v66 = 0xAAAAAAAAAAAAAAAALL;
  v67 = 0xAAAAAAAAAAAAAAAALL;
  v4 = *a2;
  v5 = a2[1];
  if (*a2 > v5)
    goto LABEL_186;
  v10 = 720915;
  v66 = *a2;
  v67 = v5;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  result = ccder_blob_decode_tl();
  if (!(_DWORD)result)
    return v10;
  v12 = v69;
  v13 = v66;
  v14 = v69 + v66 - v4;
  if (__CFADD__(v69, v66 - v4))
    goto LABEL_188;
  if (v14 > v5 - v4)
    goto LABEL_186;
  *(_QWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 24) = v14;
  v64 = 0xAAAAAAAAAAAAAAAALL;
  v65 = 0xAAAAAAAAAAAAAAAALL;
  if (__CFADD__(v13, v12))
    goto LABEL_187;
  v15 = v13 + v12;
  if (v13 > v15 || v15 > v67)
    goto LABEL_186;
  v64 = v13;
  v65 = v15;
  v62 = v13;
  v63 = v15;
  if (ccder_blob_decode_tl())
  {
    if (__CFADD__(v62, v68))
      goto LABEL_187;
    v16 = 720916;
    if (ccder_blob_decode_uint64() && v62 == v62 + v68)
    {
      if (v62 + v68 > v63)
        goto LABEL_186;
      v64 = v62 + v68;
      v65 = v63;
      goto LABEL_14;
    }
    return v16;
  }
LABEL_14:
  if (!ccder_blob_decode_tl())
    return 720917;
  v18 = v64;
  v17 = v65;
  if (v65 < v64)
    goto LABEL_186;
  v19 = v68;
  if (v68 > v65 - v64)
    goto LABEL_186;
  *(_QWORD *)(a1 + 136) = v64;
  *(_QWORD *)(a1 + 144) = v19;
  if (__CFADD__(v18, v19))
    goto LABEL_187;
  v20 = v18 + v19;
  if (v18 > v20 || v20 > v17)
    goto LABEL_186;
  v64 = v20;
  if (!ccder_blob_decode_AlgorithmIdentifierNULL(&v64, (unint64_t *)(a1 + 152)))
    return 720918;
  if (!ccder_blob_decode_tl())
    return 720919;
  v22 = v64;
  v21 = v65;
  if (v65 < v64)
    goto LABEL_186;
  v23 = v68;
  if (v68 > v65 - v64)
    goto LABEL_186;
  *(_QWORD *)(a1 + 120) = v64;
  *(_QWORD *)(a1 + 128) = v23;
  if (__CFADD__(v22, v23))
    goto LABEL_187;
  v24 = v22 + v23;
  if (v22 > v24 || v24 > v21)
    goto LABEL_186;
  v64 = v24;
  if (!ccder_blob_decode_tl())
    return 720920;
  v26 = v64;
  v25 = v65;
  if (v65 < v64)
    goto LABEL_186;
  v27 = v68;
  if (v68 > v65 - v64)
    goto LABEL_186;
  *(_QWORD *)(a1 + 72) = v64;
  *(_QWORD *)(a1 + 80) = v27;
  if (__CFADD__(v26, v27))
    goto LABEL_187;
  v28 = v26 + v27;
  if (v26 > v28 || v28 > v25)
    goto LABEL_186;
  v64 = v28;
  if (!ccder_blob_decode_tl())
    return 720921;
  v29 = v64;
  v30 = v65;
  if (v65 < v64)
    goto LABEL_186;
  v31 = v68;
  if (v68 > v65 - v64)
    goto LABEL_186;
  *(_QWORD *)(a1 + 104) = v64;
  *(_QWORD *)(a1 + 112) = v31;
  if (__CFADD__(v29, v31))
    goto LABEL_187;
  v32 = v29 + v31;
  if (v29 > v29 + v31 || v32 > v30)
    goto LABEL_186;
  v64 = v29 + v31;
  result = ccder_blob_decode_tl();
  if (!(_DWORD)result)
    return 720922;
  v33 = v64;
  v34 = v68;
  v35 = v64 - v32 + v68;
  if (!__CFADD__(v64 - v32, v68))
  {
    if (v35 > v30 - v32)
      goto LABEL_186;
    *(_QWORD *)(a1 + 88) = v32;
    *(_QWORD *)(a1 + 96) = v35;
    if (__CFADD__(v33, v34))
      goto LABEL_187;
    v36 = v33 + v34;
    if (v33 > v36 || v36 > v65)
      goto LABEL_186;
    v63 = v65;
    v64 = v36;
    v62 = v36;
    if ((ccder_blob_decode_tl() & 1) != 0)
      return 720923;
    if (v64 > v65)
      goto LABEL_186;
    v62 = v64;
    v63 = v65;
    if ((ccder_blob_decode_tl() & 1) != 0)
      return 720924;
    if (v64 > v65)
      goto LABEL_186;
    v62 = v64;
    v63 = v65;
    if (ccder_blob_decode_tl())
    {
      v60 = 0xAAAAAAAAAAAAAAAALL;
      v61 = 0xAAAAAAAAAAAAAAAALL;
      if (__CFADD__(v62, v68))
        goto LABEL_187;
      if (v62 > v62 + v68 || v62 + v68 > v63)
        goto LABEL_186;
      v60 = v62;
      v61 = v62 + v68;
      if (!ccder_blob_decode_tl() || !v68)
        return 720925;
      v37 = v60;
      if (__CFADD__(v60, v68))
LABEL_187:
        __break(0x5513u);
      v38 = v60 + v68;
      if (v60 > v60 + v68 || v38 > v61)
        goto LABEL_186;
      v61 = v60 + v68;
      *(_BYTE *)(a1 + 266) = 0;
      memset(&v70[2], 0, 128);
      if (a3)
        v39 = a4 == 0;
      else
        v39 = 1;
      v40 = !v39;
      memset(v70, 0, 32);
      if (v37 < v38)
      {
        v53 = 0;
        v41 = 0;
        do
        {
          v58 = 0xAAAAAAAAAAAAAAAALL;
          v59 = 0xAAAAAAAAAAAAAAAALL;
          v57 = 0;
          v56 = 0;
          if ((ccder_blob_decode_tl() & 1) == 0)
            return 720926;
          v54 = 0xAAAAAAAAAAAAAAAALL;
          v55 = 0xAAAAAAAAAAAAAAAALL;
          if (__CFADD__(v60, v56))
            goto LABEL_187;
          if (v60 > v60 + v56 || v60 + v56 > v61)
            goto LABEL_186;
          v54 = v60;
          v55 = v60 + v56;
          if (!ccder_blob_decode_tl())
            return 720927;
          if (v55 < v54 || v68 > v55 - v54)
            goto LABEL_186;
          v58 = v54;
          v59 = v68;
          if (__CFADD__(v54, v68))
            goto LABEL_187;
          if (v54 > v54 + v68 || v54 + v68 > v55)
            goto LABEL_186;
          v54 += v68;
          if (!der_get_BOOLean(&v54, 1, &v57))
            return 720928;
          if (!ccder_blob_decode_tl())
            return 720929;
          if (__CFADD__(v54, v68))
            goto LABEL_187;
          if (v55 != v54 + v68)
            return 720929;
          if (v40 && !compare_octet_string_raw((uint64_t)&v58, a3, a4))
          {
            if (v55 < v54)
              goto LABEL_186;
            v43 = v68;
            if (v68 > v55 - v54)
              goto LABEL_186;
            *(_QWORD *)(a1 + 248) = v54;
            *(_QWORD *)(a1 + 256) = v43;
          }
          if (v59 == 3)
          {
            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 15)
            {
              v16 = 720930;
              if ((v41 & 1) != 0 || (X509ExtensionParseKeyUsage() & 1) == 0)
                return v16;
              v41 |= 1u;
              goto LABEL_155;
            }
            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 19)
            {
              v16 = 720931;
              if ((v41 & 2) != 0
                || (X509ExtensionParseBasicConstraints(&v54, (_QWORD *)(a1 + 200), (_BYTE *)(a1 + 265)) & 1) == 0)
              {
                return v16;
              }
              v41 |= 2u;
              goto LABEL_155;
            }
            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 35)
            {
              v16 = 720932;
              if ((v41 & 4) != 0
                || (X509ExtensionParseAuthorityKeyIdentifier(&v54, (unint64_t *)(a1 + 168), (_QWORD *)(a1 + 176)) & 1) == 0)
              {
                return v16;
              }
              v41 |= 4u;
              goto LABEL_155;
            }
            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 14)
            {
              v16 = 720933;
              if ((v41 & 8) != 0
                || (X509ExtensionParseSubjectKeyIdentifier(&v54, (unint64_t *)(a1 + 184), (_QWORD *)(a1 + 192)) & 1) == 0)
              {
                return v16;
              }
              v41 |= 8u;
              goto LABEL_155;
            }
            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 37)
            {
              v16 = 720934;
              if ((v41 & 0x10) != 0
                || (X509ExtensionParseExtendedKeyUsage(&v54, (unint64_t *)(a1 + 208), (_QWORD *)(a1 + 216)) & 1) == 0)
              {
                return v16;
              }
              v41 |= 0x10u;
              goto LABEL_155;
            }
            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 17)
            {
              v16 = 720935;
              if ((v41 & 0x20) != 0
                || (X509ExtensionParseSubjectAltName(&v54, (unint64_t *)(a1 + 224), (_QWORD *)(a1 + 232)) & 1) == 0)
              {
                return v16;
              }
              v41 |= 0x20u;
              goto LABEL_155;
            }
          }
          else if (v59 >= 8 && *(_DWORD *)v58 == -2042067414 && *(_DWORD *)(v58 + 3) == 1684273030)
          {
            v16 = 720936;
            if (!X509CertificateVerifyOnlyOneAppleExtension((uint64_t)&v58, (uint64_t)v70, v53))
              return v16;
            result = X509ExtensionParseAppleExtension((uint64_t)&v54, v58, v59, (uint64_t *)(a1 + 240), (unint64_t *)(a1 + 248), v40);
            if (!(_DWORD)result)
              return v16;
            if (v53 == 0xFF)
              goto LABEL_189;
            ++v53;
            goto LABEL_155;
          }
          if (__CFADD__(v54, v68))
            goto LABEL_187;
          if (v54 > v54 + v68 || v54 + v68 > v55)
            goto LABEL_186;
          v54 += v68;
          if (v57)
            *(_BYTE *)(a1 + 266) = 1;
LABEL_155:
          if (v54 != v55)
            return 720926;
          if (__CFADD__(v60, v56))
            goto LABEL_187;
          v37 = v60 + v56;
          if (v60 > v60 + v56)
            goto LABEL_186;
          v38 = v61;
          if (v37 > v61)
            goto LABEL_186;
          v60 += v56;
        }
        while (v37 < v61);
      }
      if (v37 != v38)
        return 720925;
      if (v37 > v65 || v64 > v37)
        goto LABEL_186;
      v64 = v37;
    }
    if (*(_QWORD *)(a1 + 32) < 3uLL)
    {
      v16 = 720915;
      if (v64 != v65)
        return v16;
LABEL_170:
      if (__CFADD__(v66, v69))
        goto LABEL_187;
      if (v66 > v66 + v69 || v66 + v69 > v67)
        goto LABEL_186;
      v66 += v69;
      if (!ccder_blob_decode_AlgorithmIdentifierNULL(&v66, (unint64_t *)(a1 + 40)))
        return 720937;
      *(_QWORD *)&v70[0] = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v70[0] + 1) = 0xAAAAAAAAAAAAAAAALL;
      v60 = 0;
      result = ccder_blob_decode_bitstring();
      if (!(_DWORD)result)
        return 720938;
      if (v60 < 0xFFFFFFFFFFFFFFF9)
      {
        if (*((_QWORD *)&v70[0] + 1) >= *(_QWORD *)&v70[0])
        {
          v51 = (v60 + 7) >> 3;
          if (v51 <= *((_QWORD *)&v70[0] + 1) - *(_QWORD *)&v70[0])
          {
            *(_QWORD *)(a1 + 56) = *(_QWORD *)&v70[0];
            *(_QWORD *)(a1 + 64) = v51;
            v52 = v67;
            if (v66 <= v67)
            {
              v16 = 0;
              *a2 = v66;
              a2[1] = v52;
              return v16;
            }
          }
        }
        goto LABEL_186;
      }
      goto LABEL_188;
    }
    if (v65 <= a2[1] && *a2 <= v65)
    {
      *a2 = v65;
      goto LABEL_170;
    }
LABEL_186:
    __break(0x5519u);
    goto LABEL_187;
  }
LABEL_188:
  __break(0x5500u);
LABEL_189:
  __break(0x5507u);
  return result;
}

uint64_t der_get_BOOLean(_QWORD *a1, int a2, _BYTE *a3)
{
  if (*a1 > a1[1])
    __break(0x5519u);
  if ((ccder_blob_decode_tl() & 1) != 0 || !a2)
    return 0;
  if (a3)
    *a3 = 0;
  return 1;
}

uint64_t X509ExtensionParseKeyUsage()
{
  uint64_t result;

  result = ccder_blob_decode_bitstring();
  if ((_DWORD)result)
    return 0;
  return result;
}

uint64_t X509ExtensionParseBasicConstraints(_QWORD *a1, _QWORD *a2, _BYTE *a3)
{
  uint64_t result;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    result = der_get_BOOLean(a1, 1, a3);
    if ((_DWORD)result)
    {
      if (ccder_blob_decode_uint64())
      {
        if (!*a3)
          return 0;
        *a2 = 0xAAAAAAAAAAAAAAAALL;
        *a2 = 0xAAAAAAAAAAAAAAABLL;
      }
      return 1;
    }
  }
  return result;
}

uint64_t X509ExtensionParseAuthorityKeyIdentifier(unint64_t *a1, unint64_t *a2, _QWORD *a3)
{
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    v7 = *a1;
    if (*a1 >= 0x5555555555555556)
      goto LABEL_15;
    if (v7 - 0x5555555555555556 != a1[1])
      return 0;
    if (v7 > v7 - 0x5555555555555556)
      goto LABEL_16;
    v10 = *a1;
    v11 = v7 - 0x5555555555555556;
    result = ccder_blob_decode_tl();
    if ((_DWORD)result)
    {
      if (v11 < v10 || v11 - v10 < 0xAAAAAAAAAAAAAAAALL)
        goto LABEL_16;
      *a2 = v10;
      *a3 = 0xAAAAAAAAAAAAAAAALL;
    }
    v8 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
LABEL_15:
      __break(0x5513u);
    }
    else
    {
      v9 = v8 - 0x5555555555555556;
      if (v8 <= v8 - 0x5555555555555556 && v9 <= a1[1])
      {
        *a1 = v9;
        return 1;
      }
    }
LABEL_16:
    __break(0x5519u);
  }
  return result;
}

uint64_t X509ExtensionParseSubjectKeyIdentifier(unint64_t *a1, unint64_t *a2, _QWORD *a3)
{
  uint64_t result;
  unint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v11;
  unint64_t v12;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    v7 = a1[1];
    v8 = v7 >= *a1;
    v9 = v7 - *a1;
    if (!v8 || v9 < 0xAAAAAAAAAAAAAAAALL)
      goto LABEL_13;
    *a2 = *a1;
    *a3 = 0xAAAAAAAAAAAAAAAALL;
    v11 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
      __break(0x5513u);
      return result;
    }
    v12 = v11 - 0x5555555555555556;
    if (v11 > v11 - 0x5555555555555556 || v12 > a1[1])
LABEL_13:
      __break(0x5519u);
    *a1 = v12;
  }
  return result;
}

uint64_t X509ExtensionParseExtendedKeyUsage(unint64_t *a1, unint64_t *a2, _QWORD *a3)
{
  int v6;
  uint64_t result;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  v6 = ccder_blob_decode_tl();
  result = 0;
  if (v6)
  {
    if (*a1 > a1[1])
      goto LABEL_11;
    v10 = *a1;
    v11 = a1[1];
    result = ccder_blob_decode_tl();
    if (!(_DWORD)result)
      return result;
    if (v11 < v10 || v11 - v10 < 0xAAAAAAAAAAAAAAAALL)
      goto LABEL_11;
    *a2 = v10;
    *a3 = 0xAAAAAAAAAAAAAAAALL;
    v8 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
      __break(0x5513u);
      return result;
    }
    v9 = v8 - 0x5555555555555556;
    if (v8 > v8 - 0x5555555555555556 || v9 > a1[1])
LABEL_11:
      __break(0x5519u);
    *a1 = v9;
  }
  return result;
}

uint64_t X509ExtensionParseSubjectAltName(unint64_t *a1, unint64_t *a2, _QWORD *a3)
{
  uint64_t result;
  unint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v11;
  unint64_t v12;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result == 1)
  {
    v7 = a1[1];
    v8 = v7 >= *a1;
    v9 = v7 - *a1;
    if (!v8 || v9 < 0xAAAAAAAAAAAAAAAALL)
      goto LABEL_13;
    *a2 = *a1;
    *a3 = 0xAAAAAAAAAAAAAAAALL;
    v11 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
      __break(0x5513u);
      return result;
    }
    v12 = v11 - 0x5555555555555556;
    if (v11 > v11 - 0x5555555555555556 || v12 > a1[1])
LABEL_13:
      __break(0x5519u);
    *a1 = v12;
  }
  return result;
}

uint64_t X509CertificateVerifyOnlyOneAppleExtension(uint64_t result, uint64_t a2, unsigned int a3)
{
  _QWORD *v5;
  unsigned __int8 v6;
  unint64_t v7;
  uint64_t v9;
  _QWORD *v10;

  if (a3 > 9)
    return 0;
  v5 = (_QWORD *)result;
  v6 = 0;
  v7 = ~a2;
  while (v7 >= 16 * (char)v6)
  {
    result = compare_octet_string((uint64_t)v5, a2 + 16 * v6);
    if (!(_DWORD)result)
      return result;
    if (a3 <= v6++)
    {
      v9 = v5[1];
      v10 = (_QWORD *)(a2 + 16 * a3);
      *v10 = *v5;
      v10[1] = v9;
      return 1;
    }
  }
  __break(0x5513u);
  return result;
}

uint64_t X509ExtensionParseAppleExtension(uint64_t result, unint64_t a2, unint64_t a3, uint64_t *a4, unint64_t *a5, int a6)
{
  uint64_t v24;
  int v44;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  if (a6)
    a5 = 0;
  if (a3 == 11)
  {
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x10901066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x400000000000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x10301066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x200;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x10601066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x800;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x11801066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x2000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x12401066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x100000000000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x11901066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x4000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x21901066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x8000;
      goto LABEL_261;
    }
LABEL_157:
    v44 = 0;
LABEL_158:
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_BYTE *)(a2 + 8) == 27)
      return X509ExtensionParseServerAuthMarker(result, a2, a3, a4, a5);
    if (!v44)
      goto LABEL_232;
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 832)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x400000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3586)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v54 = *a4;
      v55 = 37748736;
    }
    else
    {
      if (*(_QWORD *)a2 != 0x66463F78648862ALL || *(_WORD *)(a2 + 8) != 4354)
      {
        if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 327)
          return (uint64_t)X509ExtensionParseMFI4Properties((unint64_t *)result, a4, a5);
        if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3841)
        {
          v52 = *(_QWORD *)result;
          v51 = *(_QWORD *)(result + 8);
          if (a5)
          {
            if (v52 > v51)
              goto LABEL_265;
            *a5 = v52;
            a5[1] = v51 - v52;
          }
          *a4 |= 0x80000000uLL;
LABEL_233:
          if (v52 <= v51)
          {
            *(_QWORD *)result = v51;
            return 1;
          }
LABEL_265:
          __break(0x5519u);
          return result;
        }
        goto LABEL_232;
      }
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v54 = *a4;
      v55 = 0x8004000000;
    }
LABEL_201:
    v24 = v54 | v55;
    goto LABEL_261;
  }
  if (a3 == 10)
  {
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 5122)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x100000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 258)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v54 = *a4;
      v55 = 0x58600003F0D0;
      goto LABEL_201;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 1538)
      goto LABEL_203;
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 4610)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0xF00;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3073)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x10;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 1793)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x20000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3329)
    {
LABEL_203:
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x20;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 2305)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x40;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 513)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x80;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 1025)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x10000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 769)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x100;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 1537)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x400;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 6145)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x1000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 9217)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x80000000000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 8193)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x2000000000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 8705)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x4000000000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 315)
      return X509ExtensionParseMFISWAuth((unint64_t *)result, a4, a5);
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3074)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x300000000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 304)
      return X509ExtensionParseGenericSSLMarker();
    v44 = 1;
    goto LABEL_158;
  }
  if (a3 != 9)
  {
    if (a3 < 0xA)
      goto LABEL_232;
    goto LABEL_157;
  }
  if (*(_QWORD *)a2 == 0xB6463F78648862ALL && *(_BYTE *)(a2 + 8) == 1)
    return X509ExtensionParseComponentAuth((unint64_t *)result, a4, a5);
  if (*(_QWORD *)a2 != 0x66463F78648862ALL || *(_BYTE *)(a2 + 8) != 49)
  {
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_BYTE *)(a2 + 8) == 44)
      return X509ExtensionParseCertifiedChipIntermediate((unint64_t *)result, a4, a5);
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_BYTE *)(a2 + 8) == 36)
      return X509ExtensionParseMFIAuthv3Leaf((unint64_t *)result);
    if (*(_QWORD *)a2 != 0x66463F78648862ALL || *(_BYTE *)(a2 + 8) != 22)
    {
      if (*(_QWORD *)a2 == 0xC6463F78648862ALL && *(_BYTE *)(a2 + 8) == 19)
      {
        result = ccder_blob_check_null();
        if (!(_DWORD)result)
          return result;
        v24 = *a4 | 0x8000000000;
        goto LABEL_261;
      }
      if (*(_QWORD *)a2 != 0xA6463F78648862ALL || *(_BYTE *)(a2 + 8) != 1)
      {
        if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_BYTE *)(a2 + 8) == 29)
        {
          result = ccder_blob_check_null();
          if (!(_DWORD)result)
            return result;
          v24 = *a4 | 0x2000000;
        }
        else
        {
          if (*(_QWORD *)a2 != 0xC6463F78648862ALL || *(_BYTE *)(a2 + 8) != 14)
          {
            if (*(_QWORD *)a2 == 0x86463F78648862ALL && *(_BYTE *)(a2 + 8) == 3)
              return X509ExtensionParseDeviceAttestationIdentity((unint64_t *)result, a4, a5);
            goto LABEL_232;
          }
          result = ccder_blob_check_null();
          if (!(_DWORD)result)
            return result;
          v24 = *a4 | 0x4000000;
        }
LABEL_261:
        *a4 = v24;
        return 1;
      }
      *a4 |= 0x1000000uLL;
LABEL_232:
      v52 = *(_QWORD *)result;
      v51 = *(_QWORD *)(result + 8);
      goto LABEL_233;
    }
    result = ccder_blob_check_null();
    if (!(_DWORD)result)
      return result;
    v54 = *a4;
    v55 = 1048584;
    goto LABEL_201;
  }
  v56 = 0;
  result = der_get_BOOLean((_QWORD *)result, 0, &v56);
  if ((_DWORD)result)
  {
    v53 = 0x10000080002;
    if (!v56)
      v53 = 0x20000040001;
    *a4 |= v53;
  }
  return result;
}

uint64_t X509CertificateParseWithExtension(unint64_t *a1, unint64_t *a2, const void *a3, size_t a4)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t result;
  unint64_t v13;

  v8 = 720939;
  v9 = *a2;
  v10 = a2[1];
  if (!ccder_blob_decode_tl())
    return v8;
  v11 = *a2;
  result = X509CertificateParseImplicit((uint64_t)a1, a2, a3, a4);
  v8 = result;
  if ((_DWORD)result)
    return v8;
  if (v11 >= 0x5555555555555556)
  {
    __break(0x5513u);
LABEL_11:
    __break(0x5500u);
    goto LABEL_12;
  }
  v8 = 720939;
  if (*a2 != v11 - 0x5555555555555556)
    return v8;
  v13 = v11 - v9 - 0x5555555555555556;
  if (v11 - v9 >= 0x5555555555555556)
    goto LABEL_11;
  if (v10 >= v9 && v13 <= v10 - v9)
  {
    *a1 = v9;
    a1[1] = v13;
    X509PolicyCheckForBlockedKeys((uint64_t)a1);
    return 0;
  }
LABEL_12:
  __break(0x5519u);
  return result;
}

uint64_t X509CertificateParse(unint64_t *a1, unint64_t *a2)
{
  return X509CertificateParseWithExtension(a1, a2, 0, 0);
}

uint64_t X509CertificateParseSPKI(unint64_t *a1, unint64_t *a2, unint64_t *a3, _QWORD *a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v10;
  unint64_t v11;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;

  v4 = *a1;
  v5 = a1[1];
  if (__CFADD__(*a1, v5))
    goto LABEL_31;
  v6 = v4 + v5;
  if (v4 > v6)
    goto LABEL_30;
  v10 = 655361;
  v14 = *a1;
  v15 = v6;
  if (!ccder_blob_decode_tl())
    return v10;
  if (!ccder_blob_decode_tl())
    return 655363;
  if (v14 >= 0x5555555555555556)
LABEL_31:
    __break(0x5513u);
  if (v14 > v14 - 0x5555555555555556 || v14 - 0x5555555555555556 > v15)
    goto LABEL_30;
  v13 = v14 - 0x5555555555555556;
  if (!ccder_blob_decode_tl())
    return 655362;
  if (a2)
  {
    if (v13 >= v14)
    {
      *a2 = v14;
      a2[1] = 0xAAAAAAAAAAAAAAAALL;
      goto LABEL_12;
    }
LABEL_30:
    __break(0x5519u);
    goto LABEL_31;
  }
LABEL_12:
  v11 = v14 - 0x5555555555555556;
  if (v14 > v14 - 0x5555555555555556 || v11 > v13)
    goto LABEL_30;
  if (v11 == v13)
  {
    if (a3)
    {
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else if (a3)
  {
    *a3 = v11;
    a3[1] = v13 - v11;
  }
  if (v13 > v15 || v14 > v13)
    goto LABEL_30;
  if (!ccder_blob_decode_bitstring())
    return 655364;
  *a4 = 0;
  a4[1] = 0;
  if (v13 == v15)
    return 0;
  else
    return 655365;
}

uint64_t X509CertificateParseKey(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  result = 327691;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      v8 = 0;
      v9 = 0;
      result = X509CertificateParseSPKI((unint64_t *)(a1 + 88), 0, 0, &v8);
      if (!(_DWORD)result)
      {
        if (a2)
        {
          if (a3)
          {
            v7 = v9;
            *a2 = v8;
            *a3 = v7;
          }
        }
      }
    }
  }
  return result;
}

uint64_t X509CertificateCheckSignatureDigest(char a1, uint64_t a2, uint64_t *a3, __int128 *a4, __int128 *a5)
{
  uint64_t v9;
  uint64_t result;
  unsigned int (*v11)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *);
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[3];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v28 = 0uLL;
  v27 = 0uLL;
  v25 = 0;
  v26 = 0;
  v24 = 0;
  v23 = 0u;
  v22 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v9 = X509CertificateParseSPKI((unint64_t *)(a2 + 88), (unint64_t *)&v28, (unint64_t *)&v27, &v25);
  if ((_DWORD)v9)
    return v9;
  v9 = 655632;
  if (compare_octet_string((uint64_t)&v28, (uint64_t)&rsaEncryption))
  {
    if (compare_octet_string((uint64_t)&v28, (uint64_t)&ecPublicKey))
      return 655617;
    v11 = (unsigned int (*)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))validateSignatureEC;
  }
  else
  {
    v11 = (unsigned int (*)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))validateSignatureRSA;
  }
  memset(v14, 0, sizeof(v14));
  v19 = *a5;
  v15 = *a4;
  v17 = v28;
  v18 = v27;
  if (((a1 & 1) == 0 || compare_octet_string_raw((uint64_t)a4, &CTOidSha1, 5uLL))
    && ((a1 & 4) == 0 || compare_octet_string_raw((uint64_t)a4, &CTOidSha256, 9uLL))
    && ((a1 & 8) == 0 || compare_octet_string_raw((uint64_t)a4, &CTOidSha384, 9uLL))
    && ((a1 & 0x10) == 0 || compare_octet_string_raw((uint64_t)a4, &CTOidSha512, 9uLL)))
  {
    return v9;
  }
  result = v25;
  if (v26 || !v25)
  {
    v12 = *a3;
    v13 = a3[1];
    if (v13 || !v12)
    {
      if (v11(v25, v26, v12, v13, v14))
        return 0;
      else
        return 655648;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t X509CertificateCheckSignature(char a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  __int128 v8;
  uint64_t result;
  __int128 v10;
  uint64_t v11[2];
  _OWORD v12[4];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[2] = v8;
  v12[3] = v8;
  v12[0] = v8;
  v12[1] = v8;
  v11[0] = (uint64_t)v12;
  v11[1] = 64;
  v10 = 0uLL;
  result = X509MatchSignatureAlgorithm(a3, a4, (uint64_t)v11, &v10);
  if (!(_DWORD)result)
    return X509CertificateCheckSignatureDigest(a1, a2, v11, &v10, a5);
  return result;
}

uint64_t X509MatchSignatureAlgorithm(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t result;

  result = compare_octet_string_raw(a2, &sha1WithRSA_oid, 9uLL);
  if (!(_DWORD)result)
    goto LABEL_8;
  result = compare_octet_string_raw(a2, &sha256WithRSA_oid, 9uLL);
  if (!(_DWORD)result)
  {
LABEL_10:
    *a4 = &CTOidSha256;
    a4[1] = 9;
    if (*(_QWORD *)(a3 + 8) < 0x20uLL)
      goto LABEL_15;
    *(_QWORD *)(a3 + 8) = 32;
    ccsha256_di();
    goto LABEL_14;
  }
  result = compare_octet_string_raw(a2, &sha384WithRSA_oid, 9uLL);
  if (!(_DWORD)result)
    goto LABEL_12;
  result = compare_octet_string_raw(a2, &sha1WithECDSA_oid, 7uLL);
  if (!(_DWORD)result)
  {
LABEL_8:
    *a4 = &CTOidSha1;
    a4[1] = 5;
    if (*(_QWORD *)(a3 + 8) < 0x14uLL)
      goto LABEL_15;
    *(_QWORD *)(a3 + 8) = 20;
    ccsha1_di();
LABEL_14:
    ccdigest();
    return 0;
  }
  result = compare_octet_string_raw(a2, &sha256WithECDSA_oid, 8uLL);
  if (!(_DWORD)result)
    goto LABEL_10;
  result = compare_octet_string_raw(a2, &sha384WithECDSA_oid, 8uLL);
  if ((_DWORD)result)
    return 656640;
LABEL_12:
  *a4 = &CTOidSha384;
  a4[1] = 9;
  if (*(_QWORD *)(a3 + 8) >= 0x30uLL)
  {
    *(_QWORD *)(a3 + 8) = 48;
    ccsha384_di();
    goto LABEL_14;
  }
LABEL_15:
  __break(0x5519u);
  return result;
}

uint64_t X509CertificateCheckSignatureWithPublicKey(uint64_t *a1, uint64_t a2, __int128 *a3, uint64_t a4, __int128 *a5, __int128 *a6)
{
  __int128 v11;
  uint64_t matched;
  unsigned int (*v13)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *);
  __int128 v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  __int128 v29;
  _OWORD *v30;
  uint64_t v31;
  _OWORD v32[4];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v32[2] = v11;
  v32[3] = v11;
  v32[0] = v11;
  v32[1] = v11;
  v30 = v32;
  v31 = 64;
  v29 = 0uLL;
  matched = X509MatchSignatureAlgorithm(a4, (uint64_t)a5, (uint64_t)&v30, &v29);
  if ((_DWORD)matched)
    return matched;
  matched = 655617;
  if (compare_octet_string(a2, (uint64_t)&rsaEncryption))
  {
    if (compare_octet_string(a2, (uint64_t)&ecPublicKey))
      return matched;
    v13 = (unsigned int (*)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))validateSignatureEC;
  }
  else
  {
    v13 = (unsigned int (*)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))validateSignatureRSA;
  }
  v28 = 0;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v22 = 0u;
  v20 = 0u;
  v18 = 0u;
  v21 = *a5;
  v17 = 0;
  v23 = *a6;
  v19 = v29;
  if (a3)
    v14 = *a3;
  else
    v14 = null_octet;
  v22 = v14;
  result = *a1;
  v16 = a1[1];
  if ((v16 || !result) && (!v30 || v31))
  {
    if (v13(result, v16, (uint64_t)v30, v31, &v17))
      return 0;
    else
      return 655648;
  }
  __break(0x5519u);
  return result;
}

uint64_t X509CertificateParseGeneralNamesContent(uint64_t a1, uint64_t (*a2)(_QWORD, int *, uint64_t), uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  int v9[5];
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 224);
  v4 = *(_QWORD *)(a1 + 232);
  if (__CFADD__(v3, v4))
  {
    __break(0x5513u);
LABEL_11:
    __break(0x5519u);
  }
  v5 = v3 + v4;
  if (v3 > v5)
    goto LABEL_11;
  v10 = *(_QWORD *)(a1 + 224);
  v11 = v5;
  while (1)
  {
    if (v10 >= v11)
      return 0;
    memset(v9, 170, sizeof(v9));
    if ((ccder_blob_decode_GeneralName(&v10, v9, (unint64_t *)&v9[1]) & 1) == 0)
      break;
    if ((a2(v9[0], &v9[1], a3) & 1) == 0)
      return 0;
  }
  return 720912;
}

uint64_t X509CertificateSubjectNameGetCommonName(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v6;
  unint64_t v7;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;

  v2 = *a1;
  v3 = a1[1];
  v20 = v3;
  if (__CFADD__(*a1, v3))
    goto LABEL_59;
  v4 = v2 + v3;
  if (v2 > v4)
  {
LABEL_58:
    __break(0x5519u);
    goto LABEL_59;
  }
  v6 = 720901;
  v18 = *a1;
  v19 = v4;
  *a2 = 0;
  a2[1] = 0;
  if (v2 < v4)
  {
    while (1)
    {
      if (!ccder_blob_decode_tl() || !v20)
        return 720898;
      v2 = v18;
      if (__CFADD__(v18, v20))
        break;
      v7 = v18 + v20;
      if (v18 > v18 + v20 || v7 > v19)
        goto LABEL_58;
      v16 = v18;
      v17 = v18 + v20;
      while (v2 < v7)
      {
        if (!ccder_blob_decode_tl())
          return 720899;
        if (__CFADD__(v16, v20))
          goto LABEL_59;
        if (v16 > v16 + v20 || v16 + v20 > v17)
          goto LABEL_58;
        v15 = v16 + v20;
        if (!ccder_blob_decode_tl())
          return 720900;
        v2 = v16 + v20;
        if (v16 > v15)
          goto LABEL_58;
        if (__CFADD__(v16, v20))
          goto LABEL_59;
        if (v16 > v16 + v20)
          goto LABEL_58;
        v14 = v16 + v20;
        if (v20 == 3 && *(_WORD *)v16 == 1109 && *(_BYTE *)(v16 + 2) == 3)
        {
          v12 = v16 + v20;
          v13 = v16 + v20;
          if ((ccder_blob_decode_tl() & 1) == 0)
          {
            if (v14 > v15)
              goto LABEL_58;
            v12 = v16 + v20;
            v13 = v16 + v20;
            if ((ccder_blob_decode_tl() & 1) == 0)
            {
              if (v14 > v15)
                goto LABEL_58;
              v12 = v16 + v20;
              v13 = v16 + v20;
              if (!ccder_blob_decode_tl())
                return v6;
            }
          }
          if (__CFADD__(v12, v20))
            goto LABEL_59;
          v2 = v12 + v20;
          if (v15 != v12 + v20)
            return 720902;
          if (v13 < v12 || v20 > v13 - v12)
            goto LABEL_58;
          *a2 = v12;
          a2[1] = v20;
        }
        v7 = v18 + v20;
        if (v2 > v17 || v16 > v2)
          goto LABEL_58;
        v16 = v2;
      }
      if (v2 != v7)
        return 720903;
      v4 = v19;
      if (v2 > v19 || v18 > v2)
        goto LABEL_58;
      v18 = v2;
      if (v2 >= v19)
        goto LABEL_46;
    }
LABEL_59:
    __break(0x5513u);
  }
LABEL_46:
  if (v2 != v4)
    return 720904;
  if (a2[1] && *a2)
    return 0;
  *a2 = 0;
  a2[1] = 0;
  return 720905;
}

BOOL X509CertificateValidAtTime(uint64_t a1, time_t a2)
{
  _BOOL8 result;
  time_t v5;
  time_t v6[2];

  result = 0;
  v6[1] = *MEMORY[0x24BDAC8D0];
  v5 = 0;
  v6[0] = 0;
  if (a1 && a2 != -1)
    return !X509CertificateGetNotBefore(a1, v6)
        && !X509CertificateGetNotAfter(a1, &v5)
        && difftime(a2, v6[0]) >= 0.0
        && difftime(a2, v5) <= 0.0;
  return result;
}

uint64_t X509CertificateGetNotBefore(uint64_t a1, time_t *a2)
{
  uint64_t result;
  const char *v4[3];

  v4[2] = *(const char **)MEMORY[0x24BDAC8D0];
  v4[0] = (const char *)0xAAAAAAAAAAAAAAAALL;
  v4[1] = (const char *)0xAAAAAAAAAAAAAAAALL;
  result = X509CertificateParseValidity(a1);
  if (!(_DWORD)result)
    return X509TimeConvert(v4, a2);
  return result;
}

uint64_t X509CertificateGetNotAfter(uint64_t a1, time_t *a2)
{
  uint64_t result;
  const char *v4[3];

  v4[2] = *(const char **)MEMORY[0x24BDAC8D0];
  v4[0] = (const char *)0xAAAAAAAAAAAAAAAALL;
  v4[1] = (const char *)0xAAAAAAAAAAAAAAAALL;
  result = X509CertificateParseValidity(a1);
  if (!(_DWORD)result)
    return X509TimeConvert(v4, a2);
  return result;
}

BOOL X509CertificateIsValid(uint64_t a1)
{
  time_t v2;

  v2 = time(0);
  return X509CertificateValidAtTime(a1, v2);
}

uint64_t X509CertificateParseValidity(uint64_t result)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  unint64_t v5;
  _QWORD v6[3];

  v6[2] = *MEMORY[0x24BDAC8D0];
  v1 = 720906;
  if (!result)
    return v1;
  v2 = *(_QWORD *)(result + 72);
  v3 = *(_QWORD *)(result + 80);
  if (!v2 || v3 == 0)
    return v1;
  if (__CFADD__(v2, v3))
  {
    __break(0x5513u);
  }
  else
  {
    v5 = v2 + v3;
    if (v2 <= v5)
    {
      v6[0] = *(_QWORD *)(result + 72);
      v6[1] = v5;
      if (!ccder_blob_decode_Time(v6))
        return 720907;
      if (ccder_blob_decode_Time(v6))
        return 0;
      return 720908;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t X509TimeConvert(const char **a1, time_t *a2)
{
  uint64_t v2;
  const char *v4;
  __int128 v6;
  const char *v7;
  uint64_t result;
  const char *v9;
  time_t v10;
  tm v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = 720909;
  if (!a1)
    return v2;
  v4 = a1[1];
  if (((unint64_t)v4 | 2) != 0xF)
    return v2;
  v11.tm_zone = (char *)0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v11.tm_mon = v6;
  *(_OWORD *)&v11.tm_isdst = v6;
  *(_OWORD *)&v11.tm_sec = v6;
  v7 = *a1;
  if (v4 == (const char *)13)
  {
    result = (uint64_t)strptime(v7, "%y%m%d%H%M%SZ", &v11);
    if (result && v11.tm_year >= 150)
      v11.tm_year -= 100;
  }
  else
  {
    result = (uint64_t)strptime(v7, "%Y%m%d%H%M%SZ", &v11);
  }
  v9 = a1[1];
  if (!__CFADD__(*a1, v9))
  {
    if ((const char *)result != &v9[(_QWORD)*a1])
      return 720910;
    v10 = timegm(&v11);
    if (v10 == -1)
      return 720911;
    v2 = 0;
    if (a2)
      *a2 = v10;
    return v2;
  }
  __break(0x5513u);
  return result;
}

BOOL X509ExtensionParseComponentAuth(unint64_t *a1, _QWORD *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;

  v3 = a1[1];
  if (*a1 > v3)
    goto LABEL_19;
  v12 = *a1;
  v13 = a1[1];
  v11 = v3 - *a1;
  if ((ccder_blob_decode_tl() & 1) != 0)
    goto LABEL_5;
  if (*a1 > a1[1])
    goto LABEL_19;
  v12 = *a1;
  v13 = a1[1];
  if (ccder_blob_decode_tl())
  {
LABEL_5:
    v8 = v12;
    v7 = v13;
    if (v12 > v13)
      goto LABEL_19;
    *a1 = v12;
    a1[1] = v13;
    v9 = v11;
  }
  else
  {
    v8 = *a1;
    v7 = a1[1];
    v9 = v7 - *a1;
  }
  if (__CFADD__(v8, v9))
    goto LABEL_20;
  if (v7 == v8 + v9)
  {
    if (!v9)
      goto LABEL_16;
    if (!a3)
    {
LABEL_15:
      *a2 |= 0x40000000uLL;
LABEL_16:
      if (v8 <= v7)
      {
        *a1 = v7;
        return v7 == v8 + v9;
      }
      goto LABEL_19;
    }
    if (v8 <= v7 && v9 <= v7 - v8)
    {
      *a3 = v8;
      a3[1] = v9;
      goto LABEL_15;
    }
LABEL_19:
    __break(0x5519u);
LABEL_20:
    __break(0x5513u);
  }
  return v7 == v8 + v9;
}

uint64_t X509ExtensionParseCertifiedChipIntermediate(unint64_t *a1, _QWORD *a2, unint64_t *a3)
{
  uint64_t result;
  unint64_t v7;
  unint64_t v8;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    v7 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
      __break(0x5513u);
      goto LABEL_12;
    }
    v8 = v7 - 0x5555555555555556;
    if (a1[1] != v7 - 0x5555555555555556)
      return 0;
    *a2 |= 0x30000000000uLL;
    if (a3)
    {
      if (v7 > v8)
        goto LABEL_12;
      *a3 = v7;
      a3[1] = 0xAAAAAAAAAAAAAAAALL;
    }
    if (v7 <= v8)
    {
      *a1 = v8;
      return 1;
    }
LABEL_12:
    __break(0x5519u);
  }
  return result;
}

uint64_t X509ExtensionParseMFIAuthv3Leaf(unint64_t *a1)
{
  uint64_t result;
  unint64_t v3;
  unint64_t v4;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    v3 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
      __break(0x5513u);
    }
    else
    {
      v4 = a1[1];
      if (v4 != v3 - 0x5555555555555556)
        return 0;
      if (v3 <= v4)
      {
        *a1 = v4;
        return 1;
      }
    }
    __break(0x5519u);
  }
  return result;
}

uint64_t X509ExtensionParseMFISWAuth(unint64_t *a1, _QWORD *a2, unint64_t *a3)
{
  uint64_t result;
  unint64_t v7;
  unint64_t v8;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    v7 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
      __break(0x5513u);
    }
    else
    {
      v8 = a1[1];
      if (v8 != v7 - 0x5555555555555556)
        return 0;
      if (a3)
      {
        if (v8 < v7 || v8 - v7 < 0xAAAAAAAAAAAAAAAALL)
          goto LABEL_13;
        *a3 = v7;
        a3[1] = 0xAAAAAAAAAAAAAAAALL;
      }
      *a2 |= 0x30000000uLL;
      if (v7 <= v8)
      {
        *a1 = v8;
        return 1;
      }
    }
LABEL_13:
    __break(0x5519u);
  }
  return result;
}

uint64_t X509ExtensionParseGenericSSLMarker()
{
  ccder_blob_decode_tl();
  return 0;
}

uint64_t X509ExtensionParseServerAuthMarker(uint64_t a1, unint64_t a2, uint64_t a3, _QWORD *a4, unint64_t *a5)
{
  uint64_t result;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  BOOL v13;
  _BOOL4 v14;
  int v15;

  result = ccder_blob_check_null();
  if ((_DWORD)result)
  {
    if (a2 > 0xFFFFFFFFFFFFFFF6)
      goto LABEL_26;
    if (__CFADD__(a2, a3))
      goto LABEL_26;
    v10 = a2 + a3;
    if (a2 + a3 == -1)
      goto LABEL_26;
    v11 = a2 + 9;
    v12 = (char *)(a2 + 9);
    while (1)
    {
      v13 = (unint64_t)v12 < v10 && (unint64_t)v12 >= a2;
      v14 = v13;
      if ((unint64_t)v12 >= v10 - 1)
        break;
      if (!v14)
        goto LABEL_25;
      v15 = *v12++;
      if ((v15 & 0x80000000) == 0)
        return 0;
    }
    if (!v14)
    {
LABEL_25:
      __break(0x5519u);
LABEL_26:
      __break(0x5513u);
      return result;
    }
    if ((*v12 & 0x80000000) == 0)
    {
      if (!a5)
      {
LABEL_22:
        *a4 |= 0x100000000uLL;
        return 1;
      }
      if (v11 >= a2 && v11 <= v10)
      {
        *a5 = v11;
        a5[1] = a3 - 9;
        goto LABEL_22;
      }
      goto LABEL_25;
    }
    return 0;
  }
  return result;
}

uint64_t X509ExtensionParseDeviceAttestationIdentity(unint64_t *a1, _QWORD *a2, unint64_t *a3)
{
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    v7 = *a1;
    if (*a1 >= 0x5555555555555556)
      goto LABEL_17;
    if (a1[1] != v7 - 0x5555555555555556)
      return 0;
    if (v7 > v7 - 0x5555555555555556)
      goto LABEL_18;
    v10 = *a1;
    v11 = v7 - 0x5555555555555556;
    result = ccder_blob_decode_tl();
    if ((_DWORD)result)
    {
      result = ccder_blob_decode_tl();
      if ((_DWORD)result)
      {
        if (a3)
        {
          if (v11 < v10 || v11 - v10 < 0xAAAAAAAAAAAAAAAALL)
            goto LABEL_18;
          *a3 = v10;
          a3[1] = 0xAAAAAAAAAAAAAAAALL;
        }
        *a2 |= 0x240000800000uLL;
        v8 = *a1;
        if (*a1 < 0x5555555555555556)
        {
          v9 = v8 - 0x5555555555555556;
          if (v8 <= v8 - 0x5555555555555556 && v9 <= a1[1])
          {
            *a1 = v9;
            return 1;
          }
LABEL_18:
          __break(0x5519u);
          return result;
        }
LABEL_17:
        __break(0x5513u);
        goto LABEL_18;
      }
    }
  }
  return result;
}

unint64_t *X509ExtensionParseMFI4Properties(unint64_t *result, _QWORD *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v4 = *result;
  v3 = result[1];
  v5 = v3 - *result;
  if (v5 != 32)
    return (unint64_t *)(v5 == 32);
  if (a3)
  {
    if (v4 > v3)
    {
LABEL_12:
      __break(0x5519u);
      goto LABEL_13;
    }
    *a3 = v4;
    a3[1] = 32;
  }
  *a2 |= 0xC00000000uLL;
  if (v4 < 0xFFFFFFFFFFFFFFE0)
  {
    v6 = v4 + 32;
    if (v4 + 32 <= v3 && v4 <= v6)
    {
      *result = v6;
      return (unint64_t *)(v5 == 32);
    }
    goto LABEL_12;
  }
LABEL_13:
  __break(0x5513u);
  return result;
}

unint64_t *X509ChainParseCertificateSet(unint64_t *result, unint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v5;
  BOOL v6;
  unint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v21;

  v5 = 0;
  *a4 = 0;
  a4[1] = 0;
  v6 = *result >= result[1] || a3 == 0;
  if (v6)
  {
LABEL_6:
    if (a5)
    {
      result = 0;
      *a5 = v5;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v9 = result;
    v10 = 0;
    v11 = a2 + 304 * a3;
    v12 = ~a2;
    v13 = a4 + 1;
    v14 = (_QWORD *)(a2 + 272);
    v15 = a3 - 1;
    v21 = a2 + 272;
    while ((unsigned __int128)(v10 * (__int128)304) >> 64 == (304 * v10) >> 63 && 304 * v10 <= v12)
    {
      v16 = v14 - 34;
      if (v14 != (_QWORD *)272 && ((unint64_t)v16 >= v11 || (unint64_t)v16 < a2))
      {
LABEL_30:
        __break(0x5519u);
        break;
      }
      result = (unint64_t *)X509CertificateParse(v14 - 34, v9);
      if ((_DWORD)result)
        return result;
      if (v10)
      {
        if ((unint64_t)v16 < a2)
          goto LABEL_30;
        if ((unint64_t)(v14 + 4) > v11)
          goto LABEL_30;
        v17 = (_QWORD *)*v13;
        *v14 = 0;
        v14[1] = v17;
        if (v14 != (_QWORD *)272 && (unint64_t)v16 >= v11)
          goto LABEL_30;
        *v17 = v16;
        *v13 = (unint64_t)v14;
      }
      else
      {
        v18 = *a4;
        *(_QWORD *)(a2 + 272) = *a4;
        if (v18)
          v19 = (unint64_t *)(v18 + 280);
        else
          v19 = v13;
        *v19 = v21;
        *a4 = v16;
        *(_QWORD *)(a2 + 280) = a4;
      }
      v5 = v10 + 1;
      if (*v9 < v9[1])
      {
        v14 += 38;
        v6 = v15 == v10++;
        if (!v6)
          continue;
      }
      goto LABEL_6;
    }
    __break(0x5513u);
  }
  return result;
}

uint64_t X509ChainGetCertificateUsingKeyIdentifier(uint64_t *a1, uint64_t a2)
{
  uint64_t i;

  for (i = *a1; i; i = *(_QWORD *)(i + 272))
  {
    if (*(_QWORD *)(i + 192) && !compare_octet_string(a2, i + 184))
      break;
  }
  return i;
}

_QWORD *X509ChainResetChain(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;

  *result = 0;
  result[1] = result;
  v2 = (_QWORD *)*a2;
  if (*a2)
  {
    do
    {
      v2[36] = 0;
      v2[37] = 0;
      v2 = (_QWORD *)v2[34];
    }
    while (v2);
  }
  return result;
}

uint64_t X509ChainBuildPathPartial(_QWORD *a1, uint64_t *a2, _QWORD *a3, int a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t CertificateUsingKeyIdentifier;
  _QWORD *v12;
  _QWORD *v13;
  int v14;
  uint64_t BAARootUsingKeyIdentifier;
  unsigned int v16;

  if (!a1)
    return 327691;
  v7 = a1;
  *a3 = a1;
  a3[1] = a1 + 36;
  a1[36] = 0;
  a1[37] = a3;
  v8 = (uint64_t)(a1 + 15);
  result = compare_octet_string((uint64_t)(a1 + 15), (uint64_t)(a1 + 13));
  if ((_DWORD)result)
  {
    while (1)
    {
      v10 = (uint64_t)(v7 + 21);
      if (!v7[22]
        || (CertificateUsingKeyIdentifier = X509ChainGetCertificateUsingKeyIdentifier(a2, (uint64_t)(v7 + 21))) == 0
        || (v7 = (_QWORD *)CertificateUsingKeyIdentifier,
            compare_octet_string(CertificateUsingKeyIdentifier + 104, v8)))
      {
        v7 = (_QWORD *)*a2;
        if (!*a2)
        {
LABEL_16:
          if (X509ChainGetAppleRootUsingKeyIdentifier(v10, 1))
            return 0;
          BAARootUsingKeyIdentifier = X509ChainGetBAARootUsingKeyIdentifier(v10);
          if (a4)
            v16 = 0;
          else
            v16 = 524296;
          if (BAARootUsingKeyIdentifier)
            return 0;
          else
            return v16;
        }
        while (compare_octet_string(v8, (uint64_t)(v7 + 13)))
        {
          v7 = (_QWORD *)v7[34];
          if (!v7)
            goto LABEL_16;
        }
      }
      v12 = (_QWORD *)*a3;
      if (*a3)
        break;
LABEL_13:
      v13 = (_QWORD *)a3[1];
      v7[36] = 0;
      v7[37] = v13;
      *v13 = v7;
      a3[1] = v7 + 36;
      v8 = (uint64_t)(v7 + 15);
      v14 = compare_octet_string((uint64_t)(v7 + 15), (uint64_t)(v7 + 13));
      result = 0;
      if (!v14)
        return result;
    }
    while (v12 != v7)
    {
      v12 = (_QWORD *)v12[36];
      if (!v12)
        goto LABEL_13;
    }
    return 524297;
  }
  return result;
}

uint64_t X509ChainGetAppleRootUsingKeyIdentifier(uint64_t result, int a2)
{
  _BYTE *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *i;
  uint64_t v7;

  v2 = &numAppleRoots;
  if (!a2)
    v2 = &numAppleProdRoots;
  v3 = *v2;
  if (*v2)
  {
    v4 = result;
    for (i = (uint64_t *)&AppleRoots; i < (uint64_t *)&BlockedYonkersSPKI && i >= (uint64_t *)&AppleRoots; ++i)
    {
      v7 = *i;
      result = compare_octet_string(v4, *i + 184);
      if (!(_DWORD)result)
        return v7;
      if (!--v3)
        return 0;
    }
    __break(0x5519u);
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t X509ChainGetBAARootUsingKeyIdentifier(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *i;
  uint64_t v5;

  v1 = numBAARoots;
  if (numBAARoots)
  {
    v2 = result;
    for (i = (uint64_t *)&BAARoots; i < (uint64_t *)&rsaEncryption && i >= (uint64_t *)&BAARoots; ++i)
    {
      v5 = *i;
      result = compare_octet_string(v2, *i + 184);
      if (!(_DWORD)result)
        return v5;
      if (!--v1)
        return 0;
    }
    __break(0x5519u);
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t X509ChainBuildPath(_QWORD *a1, uint64_t *a2, _QWORD *a3)
{
  return X509ChainBuildPathPartial(a1, a2, a3, 0);
}

uint64_t X509ChainCheckPathWithOptions(char a1, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  unint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char v16;
  unint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t AppleRootUsingKeyIdentifier;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t *v31;
  uint64_t *v32;
  char v33;
  unint64_t v34[2];
  unint64_t v35[5];

  v6 = a2;
  v35[4] = *MEMORY[0x24BDAC8D0];
  v8 = *a2;
  if (a3)
  {
    v9 = *(_QWORD *)(a3 + 48);
    if (v9)
    {
      if (*(_QWORD *)(v9 + 8))
      {
        if (compare_octet_string(v9, v8 + 208))
          return 327701;
        v8 = *v6;
      }
    }
  }
  if (v8)
  {
    v31 = v6;
    v32 = a4;
    v11 = 0;
    v12 = 0;
    v33 = 0;
    v13 = -1;
    while (1)
    {
      v14 = *(_QWORD *)(v8 + 288);
      v15 = v14 + 304;
      if (v14)
      {
LABEL_10:
        v16 = 0;
        goto LABEL_11;
      }
      if (!compare_octet_string(v8 + 120, v8 + 104))
      {
        v16 = 0;
        v15 = v8 + 304;
        v14 = v8;
        goto LABEL_11;
      }
      if (!a3)
        return v12 | 0x9000Du;
      if (*(_BYTE *)(a3 + 16))
      {
        AppleRootUsingKeyIdentifier = X509ChainGetAppleRootUsingKeyIdentifier(v8 + 168, *(unsigned __int8 *)(a3 + 17));
      }
      else
      {
        if (!*(_QWORD *)(a3 + 24))
          goto LABEL_58;
        AppleRootUsingKeyIdentifier = X509ChainGetBAARootUsingKeyIdentifier(v8 + 168);
      }
      v14 = AppleRootUsingKeyIdentifier;
      v33 |= AppleRootUsingKeyIdentifier != 0;
      v15 = AppleRootUsingKeyIdentifier + 304;
      if (AppleRootUsingKeyIdentifier)
        goto LABEL_10;
LABEL_58:
      if (!*(_BYTE *)(a3 + 19))
        return v12 | 0x9000Du;
      v14 = 0;
      v16 = 1;
LABEL_11:
      if (v11 && *(_QWORD *)(v8 + 32) >= 2uLL)
      {
        if (!*(_BYTE *)(v8 + 265))
        {
          v30 = 589825;
          return v12 | v30;
        }
        if ((*(_BYTE *)(v8 + 264) & 4) == 0)
        {
          v30 = 589826;
          return v12 | v30;
        }
      }
      v17 = *(_QWORD *)(v8 + 200);
      if (v17)
        v18 = v17 >= v11;
      else
        v18 = 1;
      if (!v18)
      {
        v30 = 589827;
        return v12 | v30;
      }
      if (*(_BYTE *)(v8 + 266))
      {
        v30 = 589831;
        return v12 | v30;
      }
      if (compare_octet_string(v8 + 40, v8 + 152))
      {
        v30 = 589828;
        return v12 | v30;
      }
      if ((v16 & 1) == 0 && *(_QWORD *)(v8 + 168) && *(_QWORD *)(v8 + 176))
      {
        if (v14 >= v15)
          goto LABEL_100;
        if (compare_octet_string(v8 + 168, v14 + 184))
          return v12 | 0x9000Au;
      }
      if (a3 && v11 && (*(_QWORD *)(v8 + 240) & *(_QWORD *)(a3 + 8)) == 0)
        X509PolicySetFlagsForCommonNames(v8);
      if (v14 == v8 && !*(_QWORD *)(v8 + 240))
      {
        X509PolicySetFlagsForRoots(a3, v8);
        if (a3)
        {
LABEL_34:
          if (*(_BYTE *)(a3 + 18) && !X509CertificateIsValid(v8))
            return v12 | 0x90009u;
          v19 = *(_QWORD *)(a3 + 8);
          if (!v11 && (*(_QWORD *)(v8 + 240) & v19) == 0)
          {
            X509PolicySetFlagsForMFI(v8);
            v19 = *(_QWORD *)(a3 + 8);
          }
          v13 &= *(_QWORD *)(v8 + 240);
          if (v19 && (v19 & v13) == 0)
          {
            v30 = 589829;
            return v12 | v30;
          }
          goto LABEL_49;
        }
      }
      else if (a3)
      {
        goto LABEL_34;
      }
      v13 &= *(_QWORD *)(v8 + 240);
LABEL_49:
      a1 |= v14 == v8;
      if ((v16 & 1) == 0)
      {
        if (v14 >= v15)
          goto LABEL_100;
        result = X509CertificateCheckSignature(a1, v14, v8 + 16, v8 + 40, (__int128 *)(v8 + 56));
        if ((_DWORD)result)
          return result;
      }
      v21 = v11 + 1;
      if (v11 == -1)
        goto LABEL_99;
      v8 = *(_QWORD *)(v8 + 288);
      v12 += 256;
      ++v11;
      if (!v8)
      {
        v6 = v31;
        a4 = v32;
        LOBYTE(v8) = v33;
        if (a3)
          goto LABEL_61;
        goto LABEL_87;
      }
    }
  }
  v21 = 0;
  v13 = -1;
  if (!a3)
    goto LABEL_87;
LABEL_61:
  if (*(_QWORD *)a3)
  {
    v22 = v21;
    if ((v8 & 1) != 0)
    {
      v22 = v21 + 1;
      if (v21 == -1)
      {
LABEL_99:
        __break(0x5500u);
LABEL_100:
        __break(0x5519u);
      }
    }
    if (*(_QWORD *)a3 != v22)
      return ((_DWORD)v22 << 8) | 0x90006u;
  }
  v23 = *(_QWORD *)(a3 + 24);
  if (!v23 || !*(_QWORD *)(v23 + 8))
  {
    if (!*(_BYTE *)(a3 + 16))
      goto LABEL_87;
    v24 = (_DWORD)v21 << 8;
    v25 = **(_QWORD **)(v6[1] + 8);
LABEL_75:
    v27 = 184;
    if ((v8 & 1) != 0)
      v27 = 168;
    v28 = X509ChainGetAppleRootUsingKeyIdentifier(v25 + v27, *(unsigned __int8 *)(a3 + 17));
    if (!v28)
      return v24 | 0x9000Bu;
    v29 = v28;
    if ((v8 & 1) == 0 && !compare_octet_string(v25 + 88, v28 + 88)
      || !X509CertificateCheckSignature(29, v29, v25 + 16, v25 + 40, (__int128 *)(v25 + 56)))
    {
      goto LABEL_87;
    }
    v26 = 589836;
    return v24 | v26;
  }
  v24 = (_DWORD)v21 << 8;
  v25 = **(_QWORD **)(v6[1] + 8);
  if (*(_BYTE *)(a3 + 16))
    goto LABEL_75;
  memset(v35, 170, 32);
  v34[0] = 0xAAAAAAAAAAAAAAAALL;
  v34[1] = 0xAAAAAAAAAAAAAAAALL;
  if (X509CertificateParseSPKI((unint64_t *)(v25 + 88), &v35[2], v34, v35))
  {
LABEL_72:
    v26 = 589832;
    return v24 | v26;
  }
  if (compare_octet_string((uint64_t)&v35[2], *(_QWORD *)(a3 + 32))
    || compare_octet_string((uint64_t)v35, *(_QWORD *)(a3 + 24)))
  {
    if (X509CertificateCheckSignatureWithPublicKey(*(uint64_t **)(a3 + 24), *(_QWORD *)(a3 + 32), *(__int128 **)(a3 + 40), v25 + 16, (__int128 *)(v25 + 40), (__int128 *)(v25 + 56)))goto LABEL_72;
  }
  else if (!compare_octet_string(*(_QWORD *)(a3 + 32), (uint64_t)&ecPublicKey))
  {
    compare_octet_string((uint64_t)v34, *(_QWORD *)(a3 + 40));
  }
LABEL_87:
  result = 0;
  if (a4)
    *a4 = v13;
  return result;
}

uint64_t X509ChainCheckPath(char a1, uint64_t *a2, uint64_t a3)
{
  return X509ChainCheckPathWithOptions(a1, a2, a3, 0);
}

uint64_t sub_217E2CF60()
{
  return MEMORY[0x24BEE54C8]();
}

uint64_t sub_217E2CF6C()
{
  return MEMORY[0x24BEE5500]();
}

uint64_t sub_217E2CF78()
{
  return MEMORY[0x24BEE0618]();
}

uint64_t sub_217E2CF84()
{
  return MEMORY[0x24BEE07D0]();
}

uint64_t sub_217E2CF90()
{
  return MEMORY[0x24BEE07D8]();
}

uint64_t sub_217E2CF9C()
{
  return MEMORY[0x24BEE07E0]();
}

uint64_t sub_217E2CFA8()
{
  return MEMORY[0x24BEE07E8]();
}

uint64_t sub_217E2CFB4()
{
  return MEMORY[0x24BEE07F0]();
}

uint64_t sub_217E2CFC0()
{
  return MEMORY[0x24BEE0980]();
}

uint64_t sub_217E2CFCC()
{
  return MEMORY[0x24BEE09F0]();
}

uint64_t sub_217E2CFD8()
{
  return MEMORY[0x24BEE0BC0]();
}

uint64_t sub_217E2CFE4()
{
  return MEMORY[0x24BEE0C10]();
}

uint64_t sub_217E2CFF0()
{
  return MEMORY[0x24BEE0E50]();
}

uint64_t sub_217E2CFFC()
{
  return MEMORY[0x24BEE0E70]();
}

uint64_t sub_217E2D008()
{
  return MEMORY[0x24BEE1190]();
}

uint64_t sub_217E2D014()
{
  return MEMORY[0x24BEE1870]();
}

uint64_t sub_217E2D020()
{
  return MEMORY[0x24BEE1888]();
}

uint64_t sub_217E2D02C()
{
  return MEMORY[0x24BEE1890]();
}

uint64_t sub_217E2D038()
{
  return MEMORY[0x24BEE1898]();
}

uint64_t sub_217E2D044()
{
  return MEMORY[0x24BEE1950]();
}

uint64_t sub_217E2D050()
{
  return MEMORY[0x24BEE19B8]();
}

uint64_t sub_217E2D05C()
{
  return MEMORY[0x24BEE1A18]();
}

uint64_t sub_217E2D068()
{
  return MEMORY[0x24BEE1B68]();
}

uint64_t sub_217E2D074()
{
  return MEMORY[0x24BEE5760]();
}

uint64_t sub_217E2D080()
{
  return MEMORY[0x24BEE5780]();
}

uint64_t sub_217E2D08C()
{
  return MEMORY[0x24BEE5930]();
}

uint64_t sub_217E2D098()
{
  return MEMORY[0x24BEE5948]();
}

uint64_t sub_217E2D0A4()
{
  return MEMORY[0x24BEE1F80]();
}

uint64_t sub_217E2D0B0()
{
  return MEMORY[0x24BEE1F88]();
}

uint64_t sub_217E2D0BC()
{
  return MEMORY[0x24BEE1FD0]();
}

uint64_t sub_217E2D0C8()
{
  return MEMORY[0x24BEE1FD8]();
}

uint64_t sub_217E2D0D4()
{
  return MEMORY[0x24BEE2020]();
}

uint64_t sub_217E2D0E0()
{
  return MEMORY[0x24BEE2068]();
}

uint64_t sub_217E2D0EC()
{
  return MEMORY[0x24BEE2070]();
}

uint64_t sub_217E2D0F8()
{
  return MEMORY[0x24BEE2078]();
}

uint64_t sub_217E2D104()
{
  return MEMORY[0x24BEE20A0]();
}

uint64_t sub_217E2D110()
{
  return MEMORY[0x24BEE2118]();
}

uint64_t sub_217E2D11C()
{
  return MEMORY[0x24BEE22B0]();
}

uint64_t sub_217E2D128()
{
  return MEMORY[0x24BEE22C0]();
}

uint64_t sub_217E2D134()
{
  return MEMORY[0x24BEE2510]();
}

uint64_t sub_217E2D140()
{
  return MEMORY[0x24BEE2518]();
}

uint64_t sub_217E2D14C()
{
  return MEMORY[0x24BEE25B8]();
}

uint64_t sub_217E2D158()
{
  return MEMORY[0x24BEE2BE0]();
}

uint64_t sub_217E2D164()
{
  return MEMORY[0x24BEE2C00]();
}

uint64_t sub_217E2D170()
{
  return MEMORY[0x24BEE2D48]();
}

uint64_t sub_217E2D17C()
{
  return MEMORY[0x24BEE3568]();
}

uint64_t sub_217E2D188()
{
  return MEMORY[0x24BEE39E0]();
}

uint64_t sub_217E2D194()
{
  return MEMORY[0x24BEE3B98]();
}

uint64_t sub_217E2D1A0()
{
  return MEMORY[0x24BEE3D90]();
}

uint64_t sub_217E2D1AC()
{
  return MEMORY[0x24BEE3DD8]();
}

uint64_t sub_217E2D1B8()
{
  return MEMORY[0x24BEE3EF8]();
}

uint64_t sub_217E2D1C4()
{
  return MEMORY[0x24BEE3F00]();
}

uint64_t sub_217E2D1D0()
{
  return MEMORY[0x24BEE3F08]();
}

uint64_t sub_217E2D1DC()
{
  return MEMORY[0x24BEE3F10]();
}

uint64_t sub_217E2D1E8()
{
  return MEMORY[0x24BEE42E0]();
}

uint64_t sub_217E2D1F4()
{
  return MEMORY[0x24BEE42F8]();
}

uint64_t sub_217E2D200()
{
  return MEMORY[0x24BEE4300]();
}

uint64_t sub_217E2D20C()
{
  return MEMORY[0x24BEE4318]();
}

uint64_t sub_217E2D218()
{
  return MEMORY[0x24BEE4328]();
}

uint64_t APFSVolumeGetUnlockRecord()
{
  return MEMORY[0x24BDFD2B8]();
}

uint64_t APFSVolumeGetWVEK()
{
  return MEMORY[0x24BDFD2C8]();
}

uint64_t APFSVolumeListUUIDsOfUnlockRecords()
{
  return MEMORY[0x24BDFD2D0]();
}

uint64_t APFSVolumePayloadGet()
{
  return MEMORY[0x24BDFD2E0]();
}

uint64_t APFSVolumePayloadSet()
{
  return MEMORY[0x24BDFD2E8]();
}

uint64_t APFSVolumeRemoveUnlockRecord()
{
  return MEMORY[0x24BDFD2F0]();
}

uint64_t APFSVolumeSetUnlockRecord()
{
  return MEMORY[0x24BDFD308]();
}

uint64_t CCRandomCopyBytes()
{
  return MEMORY[0x24BDAC2C8]();
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x24BDBB7C8](theArray, value);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x24BDBB820](theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x24BDBB860](theArray, idx);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x24BDBBA18]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x24BDBBA20](BOOLean);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x24BDBBC98](allocator, bytes, length);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x24BDBBCC0](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x24BDBBCE0](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x24BDBBCF8](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x24BDBBD08]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBDB0](theDict, key, value);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF0](allocator, capacity, keyCallBacks, valueCallBacks);
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x24BDBBE30](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x24BDBBE38](theDict, key, value);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBE60](theDict, key, value);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x24BDBBE88](allocator, domain, code, userInfo);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x24BDBBEF8](cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x24BDBC0A0](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x24BDBC118]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x24BDBC130](number, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x24BDBC600](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x24BDBC698]();
}

CFUUIDRef CFUUIDCreateFromString(CFAllocatorRef alloc, CFStringRef uuidStr)
{
  return (CFUUIDRef)MEMORY[0x24BDBC8D8](alloc, uuidStr);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x24BDBC8E0](alloc, *(_QWORD *)&bytes.byte0, *(_QWORD *)&bytes.byte8);
}

CFUUIDRef CFUUIDCreateWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)MEMORY[0x24BDBC8F0](alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1;
  uint64_t v2;
  CFUUIDBytes result;

  v1 = MEMORY[0x24BDBC908](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

CFMutableDictionaryRef IOBSDNameMatching(mach_port_t mainPort, uint32_t options, const char *bsdName)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDD7EB0](*(_QWORD *)&mainPort, *(_QWORD *)&options, bsdName);
}

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  return MEMORY[0x24BDD7EF8](*(_QWORD *)&connection, *(_QWORD *)&selector, input, *(_QWORD *)&inputCnt, inputStruct, inputStructCnt, output, outputCnt);
}

kern_return_t IOConnectSetNotificationPort(io_connect_t connect, uint32_t type, mach_port_t port, uintptr_t reference)
{
  return MEMORY[0x24BDD7F40](*(_QWORD *)&connect, *(_QWORD *)&type, *(_QWORD *)&port, reference);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return (IONotificationPortRef)MEMORY[0x24BDD8690](*(_QWORD *)&mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
  MEMORY[0x24BDD8698](notify);
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
  MEMORY[0x24BDD86B0](notify, queue);
}

BOOLean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
{
  return MEMORY[0x24BDD86B8](*(_QWORD *)&object, className);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x24BDD86F8](*(_QWORD *)&object);
}

kern_return_t IORegistryEntryCreateCFProperties(io_registry_entry_t entry, CFMutableDictionaryRef *properties, CFAllocatorRef allocator, IOOptionBits options)
{
  return MEMORY[0x24BDD88A8](*(_QWORD *)&entry, properties, allocator, *(_QWORD *)&options);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x24BDD88B0](*(_QWORD *)&entry, key, allocator, *(_QWORD *)&options);
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  return MEMORY[0x24BDD88C0](*(_QWORD *)&mainPort, path);
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return MEMORY[0x24BDD8958](notifyPort, *(_QWORD *)&service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return MEMORY[0x24BDD8970](*(_QWORD *)&connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x24BDD8988](*(_QWORD *)&mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDD89A8](name);
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  return MEMORY[0x24BDD89B8](*(_QWORD *)&service, *(_QWORD *)&owningTask, *(_QWORD *)&type, connect);
}

uint64_t MGGetSInt64Answer()
{
  return MEMORY[0x24BED84A0]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x24BDAC720](aBlock);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x24BDAC738](aBlock);
}

int *__error(void)
{
  return (int *)MEMORY[0x24BDAC7D0]();
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x24BDAC848]();
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

void abort(void)
{
  MEMORY[0x24BDAD008]();
}

int access(const char *a1, int a2)
{
  return MEMORY[0x24BDAD038](a1, *(_QWORD *)&a2);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return (void *)MEMORY[0x24BDAD328](__count, __size);
}

uint64_t cc_clear()
{
  return MEMORY[0x24BDAD348]();
}

uint64_t cc_cmp_safe()
{
  return MEMORY[0x24BDAD350]();
}

uint64_t ccaes_cbc_decrypt_mode()
{
  return MEMORY[0x24BDAD358]();
}

uint64_t ccaes_cbc_encrypt_mode()
{
  return MEMORY[0x24BDAD360]();
}

uint64_t cccbc_clear_iv()
{
  return MEMORY[0x24BDAD398]();
}

uint64_t cccbc_init()
{
  return MEMORY[0x24BDAD3A0]();
}

uint64_t cccbc_one_shot()
{
  return MEMORY[0x24BDAD3A8]();
}

uint64_t cccbc_update()
{
  return MEMORY[0x24BDAD3B8]();
}

uint64_t cccurve25519()
{
  return MEMORY[0x24BDAD3E0]();
}

uint64_t cccurve25519_make_pub()
{
  return MEMORY[0x24BDAD3F0]();
}

uint64_t ccder_blob_decode_bitstring()
{
  return MEMORY[0x24BDAD400]();
}

uint64_t ccder_blob_decode_len()
{
  return MEMORY[0x24BDAD408]();
}

uint64_t ccder_blob_decode_oid()
{
  return MEMORY[0x24BDAD410]();
}

uint64_t ccder_blob_decode_range()
{
  return MEMORY[0x24BDAD418]();
}

uint64_t ccder_blob_decode_sequence_tl()
{
  return MEMORY[0x24BDAD420]();
}

uint64_t ccder_blob_decode_tag()
{
  return MEMORY[0x24BDAD428]();
}

uint64_t ccder_blob_decode_tl()
{
  return MEMORY[0x24BDAD430]();
}

uint64_t ccder_blob_decode_uint64()
{
  return MEMORY[0x24BDAD438]();
}

uint64_t ccder_blob_encode_body()
{
  return MEMORY[0x24BDAD440]();
}

uint64_t ccder_blob_encode_body_tl()
{
  return MEMORY[0x24BDAD448]();
}

uint64_t ccder_blob_encode_implicit_raw_octet_string()
{
  return MEMORY[0x24BDAD450]();
}

uint64_t ccder_blob_encode_implicit_uint64()
{
  return MEMORY[0x24BDAD458]();
}

uint64_t ccder_blob_encode_tl()
{
  return MEMORY[0x24BDAD460]();
}

uint64_t ccder_decode_rsa_pub_n()
{
  return MEMORY[0x24BDAD478]();
}

uint64_t ccder_decode_sequence_tl()
{
  return MEMORY[0x24BDAD480]();
}

uint64_t ccder_decode_tl()
{
  return MEMORY[0x24BDAD490]();
}

uint64_t ccder_encode_constructed_tl()
{
  return MEMORY[0x24BDAD4B0]();
}

uint64_t ccder_encode_raw_octet_string()
{
  return MEMORY[0x24BDAD4C8]();
}

uint64_t ccder_encode_uint64()
{
  return MEMORY[0x24BDAD4D8]();
}

uint64_t ccder_sizeof()
{
  return MEMORY[0x24BDAD4E0]();
}

uint64_t ccder_sizeof_implicit_uint64()
{
  return MEMORY[0x24BDAD4F0]();
}

uint64_t ccder_sizeof_len()
{
  return MEMORY[0x24BDAD500]();
}

uint64_t ccder_sizeof_oid()
{
  return MEMORY[0x24BDAD508]();
}

uint64_t ccder_sizeof_raw_octet_string()
{
  return MEMORY[0x24BDAD510]();
}

uint64_t ccder_sizeof_tag()
{
  return MEMORY[0x24BDAD518]();
}

uint64_t ccder_sizeof_uint64()
{
  return MEMORY[0x24BDAD520]();
}

uint64_t ccdigest()
{
  return MEMORY[0x24BDAD538]();
}

uint64_t ccdigest_init()
{
  return MEMORY[0x24BDAD540]();
}

uint64_t ccdigest_update()
{
  return MEMORY[0x24BDAD548]();
}

uint64_t ccec_compact_import_pub()
{
  return MEMORY[0x24BDAD560]();
}

uint64_t ccec_compressed_x962_export_pub()
{
  return MEMORY[0x24BDAD568]();
}

uint64_t ccec_compressed_x962_export_pub_size()
{
  return MEMORY[0x24BDAD570]();
}

uint64_t ccec_compressed_x962_import_pub()
{
  return MEMORY[0x24BDAD578]();
}

uint64_t ccec_cp_256()
{
  return MEMORY[0x24BDAD590]();
}

uint64_t ccec_cp_384()
{
  return MEMORY[0x24BDAD598]();
}

uint64_t ccec_cp_521()
{
  return MEMORY[0x24BDAD5A0]();
}

uint64_t ccec_export_pub()
{
  return MEMORY[0x24BDAD5B0]();
}

uint64_t ccec_import_pub()
{
  return MEMORY[0x24BDAD5D0]();
}

uint64_t ccec_keysize_is_supported()
{
  return MEMORY[0x24BDAD5D8]();
}

uint64_t ccec_verify()
{
  return MEMORY[0x24BDAD5F0]();
}

uint64_t ccec_verify_composite()
{
  return MEMORY[0x24BDAD5F8]();
}

uint64_t ccec_x963_import_pub_size()
{
  return MEMORY[0x24BDAD618]();
}

uint64_t ccecb_one_shot()
{
  return MEMORY[0x24BDAD620]();
}

uint64_t cced25519_verify()
{
  return MEMORY[0x24BDAD638]();
}

uint64_t cchkdf()
{
  return MEMORY[0x24BDAD690]();
}

uint64_t cchmac()
{
  return MEMORY[0x24BDAD6A8]();
}

uint64_t ccn_read_uint()
{
  return MEMORY[0x24BDAD720]();
}

uint64_t ccn_write_uint_padded()
{
  return MEMORY[0x24BDAD730]();
}

uint64_t ccoid_equal()
{
  return MEMORY[0x24BDAD738]();
}

uint64_t ccpbkdf2_hmac()
{
  return MEMORY[0x24BDAD750]();
}

uint64_t ccrng()
{
  return MEMORY[0x24BDAD758]();
}

uint64_t ccrsa_import_pub()
{
  return MEMORY[0x24BDAD7D0]();
}

uint64_t ccrsa_verify_pkcs1v15_allowshortsigs()
{
  return MEMORY[0x24BDAD7F8]();
}

uint64_t ccsha1_di()
{
  return MEMORY[0x24BDAD818]();
}

uint64_t ccsha256_di()
{
  return MEMORY[0x24BDAD828]();
}

uint64_t ccsha384_di()
{
  return MEMORY[0x24BDAD838]();
}

uint64_t ccsha512_di()
{
  return MEMORY[0x24BDAD840]();
}

uint64_t cczp_bitlen()
{
  return MEMORY[0x24BDAD928]();
}

int chmod(const char *a1, mode_t a2)
{
  return MEMORY[0x24BDAD990](a1, a2);
}

int chown(const char *a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x24BDAD998](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int close(int a1)
{
  return MEMORY[0x24BDAD9D8](*(_QWORD *)&a1);
}

double difftime(time_t a1, time_t a2)
{
  double result;

  MEMORY[0x24BDADC30](a1, a2);
  return result;
}

void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCE0](queue, block);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED0](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED8](label, attr, target);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x24BDADF10](object);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADFE8](queue, block);
}

int fclose(FILE *a1)
{
  return MEMORY[0x24BDAE2E0](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x24BDAE2E8](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x24BDAE410](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAE428](a1, a2);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

int fts_close(FTS *a1)
{
  return MEMORY[0x24BDAE550](a1);
}

FTS *__cdecl fts_open(char *const *a1, int a2, int (__cdecl *a3)(const FTSENT **, const FTSENT **))
{
  return (FTS *)MEMORY[0x24BDAE558](a1, *(_QWORD *)&a2, a3);
}

FTSENT *__cdecl fts_read(FTS *a1)
{
  return (FTSENT *)MEMORY[0x24BDAE568](a1);
}

int fts_set(FTS *a1, FTSENT *a2, int a3)
{
  return MEMORY[0x24BDAE570](a1, a2, *(_QWORD *)&a3);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE590](__ptr, __size, __nitems, __stream);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x24BDAE5A8](a1, a2, a3, a4, *(_QWORD *)&a5);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x24BDAE5F0](a1);
}

int getgrnam_r(const char *a1, group *a2, char *a3, size_t a4, group **a5)
{
  return MEMORY[0x24BDAE630](a1, a2, a3, a4, a5);
}

int getpwnam_r(const char *a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return MEMORY[0x24BDAE718](a1, a2, a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x24BDAE780](a1, a2);
}

kern_return_t host_get_multiuser_config_flags(host_t host, uint32_t *multiuser_flags)
{
  return MEMORY[0x24BDAE7F0](*(_QWORD *)&host, multiuser_flags);
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x24BDAEB48]();
}

mach_port_t mach_host_self(void)
{
  return MEMORY[0x24BDAEB68]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x24BDAEC68](info);
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x24BDAED08](__size);
}

size_t malloc_size(const void *ptr)
{
  return MEMORY[0x24BDAED60](ptr);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return MEMORY[0x24BDAEEC8](__s, __smax, *(_QWORD *)&__c, __n);
}

int mkpath_np(const char *path, mode_t omode)
{
  return MEMORY[0x24BDAEF60](path, omode);
}

uint64_t objc_opt_self()
{
  return MEMORY[0x24BEDD168]();
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x24BDAF228](a1, *(_QWORD *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x24BDAF230](a1, *(_QWORD *)&a2, *(_QWORD *)&a3, *(_QWORD *)&a4);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

int printf(const char *a1, ...)
{
  return MEMORY[0x24BDAF6A8](a1);
}

int putchar(int a1)
{
  return MEMORY[0x24BDAF9F0](*(_QWORD *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x24BDAF9F8](a1);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x24BDAFA00](*(_QWORD *)&__fd, __buf, __nbyte, a4);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x24BDAFA18](__base, __nel, __width, __compar);
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x24BDAFA80](*(_QWORD *)&a1, a2, a3);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x24BDAFAC0](a1, a2);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  MEMORY[0x24BDAFB80](__from, __to, __ec);
}

int setattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x24BDAFD00](a1, a2, a3, a4, *(_QWORD *)&a5);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x24BDAFEA8](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x24BDAFEB0](a1, a2);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x24BDAFF18](*(_QWORD *)&__errnum);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x24BDAFF38](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x24BDAFF50](a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x24BDAFF68](__s1, __s2, __n);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return (char *)MEMORY[0x24BDAFF88](__big, __little, __len);
}

char *__cdecl strptime(const char *a1, const char *a2, tm *a3)
{
  return (char *)MEMORY[0x24BDAFF98](a1, a2, a3);
}

uint64_t swift_allocError()
{
  return MEMORY[0x24BEE4B68]();
}

uint64_t swift_allocObject()
{
  return MEMORY[0x24BEE4B70]();
}

uint64_t swift_allocateGenericValueMetadata()
{
  return MEMORY[0x24BEE4B80]();
}

uint64_t swift_arrayDestroy()
{
  return MEMORY[0x24BEE4B98]();
}

uint64_t swift_arrayInitWithCopy()
{
  return MEMORY[0x24BEE4BA0]();
}

uint64_t swift_bridgeObjectRelease()
{
  return MEMORY[0x24BEE4BC0]();
}

uint64_t swift_bridgeObjectRelease_n()
{
  return MEMORY[0x24BEE4BC8]();
}

uint64_t swift_bridgeObjectRetain()
{
  return MEMORY[0x24BEE4BD0]();
}

uint64_t swift_checkMetadataState()
{
  return MEMORY[0x24BEE4BE0]();
}

uint64_t swift_deallocClassInstance()
{
  return MEMORY[0x24BEE4C00]();
}

uint64_t swift_dynamicCastClass()
{
  return MEMORY[0x24BEE4C40]();
}

uint64_t swift_errorRelease()
{
  return MEMORY[0x24BEE4CA0]();
}

uint64_t swift_getAssociatedConformanceWitness()
{
  return MEMORY[0x24BEE4CD0]();
}

uint64_t swift_getAssociatedTypeWitness()
{
  return MEMORY[0x24BEE4CD8]();
}

uint64_t swift_getGenericMetadata()
{
  return MEMORY[0x24BEE4D80]();
}

uint64_t swift_getObjCClassMetadata()
{
  return MEMORY[0x24BEE4DB0]();
}

uint64_t swift_getTypeByMangledNameInContext2()
{
  return MEMORY[0x24BEE4E10]();
}

uint64_t swift_getTypeByMangledNameInContextInMetadataState2()
{
  return MEMORY[0x24BEE4E18]();
}

uint64_t swift_getWitnessTable()
{
  return MEMORY[0x24BEE4E20]();
}

uint64_t swift_initStackObject()
{
  return MEMORY[0x24BEE4E48]();
}

uint64_t swift_initStructMetadata()
{
  return MEMORY[0x24BEE4E58]();
}

uint64_t swift_isUniquelyReferenced_nonNull_native()
{
  return MEMORY[0x24BEE4E98]();
}

uint64_t swift_lookUpClassMethod()
{
  return MEMORY[0x24BEE4EA8]();
}

uint64_t swift_once()
{
  return MEMORY[0x24BEE4EC8]();
}

uint64_t swift_release()
{
  return MEMORY[0x24BEE4EF8]();
}

uint64_t swift_retain()
{
  return MEMORY[0x24BEE4F08]();
}

uint64_t swift_setDeallocating()
{
  return MEMORY[0x24BEE4F30]();
}

uint64_t swift_unexpectedError()
{
  return MEMORY[0x24BEE4F68]();
}

uint64_t swift_unknownObjectRelease()
{
  return MEMORY[0x24BEE4F70]();
}

uint64_t swift_unknownObjectRelease_n()
{
  return MEMORY[0x24BEE4F78]();
}

uint64_t swift_unknownObjectRetain()
{
  return MEMORY[0x24BEE4F80]();
}

uint64_t swift_unknownObjectRetain_n()
{
  return MEMORY[0x24BEE4F88]();
}

uint64_t swift_willThrow()
{
  return MEMORY[0x24BEE5050]();
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x24BDB0100](a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
  MEMORY[0x24BDB0128](*(_QWORD *)&a1, a2);
}

time_t time(time_t *a1)
{
  return MEMORY[0x24BDB0240](a1);
}

time_t timegm(tm *const a1)
{
  return MEMORY[0x24BDB0248](a1);
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return MEMORY[0x24BDB0308](uu1, uu2);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
  MEMORY[0x24BDB0310](dst, src);
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  return MEMORY[0x24BDB0330](in, uu);
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
  MEMORY[0x24BDB0338](uu, out);
}

void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
{
  MEMORY[0x24BDB0348](uu, out);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x24BDB0558](*(_QWORD *)&__fd, __buf, __nbyte);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x24BDB0740](name, targetq, flags);
}

void xpc_connection_resume(xpc_connection_t connection)
{
  MEMORY[0x24BDB0798](connection);
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x24BDB07B8](connection, message);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
  MEMORY[0x24BDB07C8](connection, handler);
}

char *__cdecl xpc_copy_description(xpc_object_t object)
{
  return (char *)MEMORY[0x24BDB0820](object);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x24BDB08C0](keys, values, count);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x24BDB0908](xdict, key);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x24BDB0938](xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
  MEMORY[0x24BDB0978](xdict, key, value);
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
  MEMORY[0x24BDB0988](xdict, key, bytes, length);
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
  MEMORY[0x24BDB09D0](xdict, key, value);
}

void xpc_dictionary_set_uuid(xpc_object_t xdict, const char *key, const unsigned __int8 *uuid)
{
  MEMORY[0x24BDB09D8](xdict, key, uuid);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x24BDB0A70](object);
}

