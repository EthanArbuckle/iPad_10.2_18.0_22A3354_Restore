uint64_t TSWPCoreTextTypesetter::pPrevCharIndex(TSWPCoreTextTypesetter *this, uint64_t a2)
{
  if (a2)
    return objc_msgSend((id)objc_msgSend(*(id *)(*((_QWORD *)this + 29) + 56), "string"), "rangeOfComposedCharacterSequenceAtIndex:", a2 - 1);
  else
    return 0;
}

uint64_t TSWPCoreTextTypesetter::pCanBreakLineInRange(TSWPCoreTextTypesetter *this, unint64_t a2, unint64_t a3)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  const __CFCharacterSet *v9;
  __CFCharacterSet *Mutable;
  const __CFCharacterSet *Predefined;
  id v13;
  const __CFString *v14;
  __CFStringTokenizer *v15;
  __CFStringTokenizer *v16;
  CFRange CurrentTokenRange;
  CFRange v18;
  CFRange v19;
  CFRange v20;
  CFRange v21;
  CFRange v22;
  CFRange v23;
  CFRange v24;
  CFRange v25;

  v6 = a3 - a2;
  if (a3 <= a2 || *((_QWORD *)this + 7) < a3)
  {
    v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPCoreTextTypesetter::pCanBreakLineInRange(TSWPCharIndex, TSWPCharIndex)");
    objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 1904, CFSTR("Bad localMaxCharIndex"));
  }
  v9 = (const __CFCharacterSet *)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet;
  if (!TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet)
  {
    Mutable = CFCharacterSetCreateMutable(0);
    TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet = (uint64_t)Mutable;
    Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespaceAndNewline);
    CFCharacterSetUnion(Mutable, Predefined);
    v18.location = 8232;
    v18.length = 1;
    CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v18);
    v19.location = 65532;
    v19.length = 1;
    CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v19);
    v20.location = 45;
    v20.length = 1;
    CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v20);
    v21.location = 160;
    v21.length = 1;
    CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v21);
    v22.location = 8239;
    v22.length = 1;
    CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v22);
    v23.location = 8199;
    v23.length = 1;
    CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v23);
    v24.location = 65279;
    v24.length = 1;
    CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet, v24);
    v9 = (const __CFCharacterSet *)TSWPCoreTextTypesetter::pCanBreakLineInRange(unsigned long,unsigned long)::sBreakPointCharacterSet;
  }
  if (CFCharacterSetIsCharacterMember(v9, *(_WORD *)(*((_QWORD *)this + 10) + 2 * a3 - 2)))
    return 1;
  v13 = (id)*((_QWORD *)this + 27);
  if (!v13)
  {
    v13 = objc_alloc_init(MEMORY[0x24BDD1698]);
    v14 = CFStringCreateWithCharactersNoCopy(0, *((const UniChar **)this + 10), *((_QWORD *)this + 7), (CFAllocatorRef)*MEMORY[0x24BDBD258]);
    v25.length = *((_QWORD *)this + 7);
    v25.location = 0;
    v15 = CFStringTokenizerCreate(0, v14, v25, 3uLL, 0);
    v16 = v15;
    while (CFStringTokenizerAdvanceToNextToken(v15))
    {
      CurrentTokenRange = CFStringTokenizerGetCurrentTokenRange(v16);
      objc_msgSend(v13, "addIndex:", CurrentTokenRange.location + CurrentTokenRange.length);
      v15 = v16;
    }
    CFRelease(v16);
    CFRelease(v14);
    *((_QWORD *)this + 27) = v13;
  }
  return objc_msgSend(v13, "containsIndexesInRange:", a2, v6 + 1);
}

BOOL TSWPCoreTextTypesetter::pRoomForHyphen(TSWPCoreTextTypesetter *this, CFRange a2, double a3, int a4, TSWPLineFragment *a5)
{
  CFIndex length;
  CFIndex location;
  unsigned int FontRunIndexForLocalCharIndex;
  const __CTFont *v12;
  unsigned int v13;
  CFIndex v14;
  const __CTTypesetter *v15;
  const __CTLine *Line;
  const __CTLine *v17;
  double TypographicBounds;
  const __CTLine *TruncatedLine;
  const __CTLine *v20;
  double v21;
  void *v22;
  uint64_t v23;
  CGSize advances;
  CGGlyph glyphs[2];
  UniChar characters[2];
  CFRange v28;

  length = a2.length;
  location = a2.location;
  FontRunIndexForLocalCharIndex = TSWPCoreTextTypesetter::pFindFontRunIndexForLocalCharIndex(this, a2.location + a2.length);
  TSWPLineFragment::setHyphenInfo(a5, *(CFTypeRef *)(*((_QWORD *)this + 15) + 104 * FontRunIndexForLocalCharIndex + 32), a4);
  v12 = *(const __CTFont **)(*((_QWORD *)this + 15) + 104 * FontRunIndexForLocalCharIndex + 24);
  if ((a4 - 0x10000) >> 20)
  {
    v14 = 1;
    LOWORD(v13) = a4;
  }
  else
  {
    v13 = ((a4 + 67043328) >> 10) - 10240;
    characters[1] = a4 & 0x3FF | 0xDC00;
    v14 = 2;
  }
  characters[0] = v13;
  CTFontGetGlyphsForCharacters(v12, characters, glyphs, v14);
  CTFontGetAdvancesForGlyphs(v12, kCTFontOrientationDefault, glyphs, &advances, 1);
  v15 = (const __CTTypesetter *)TSWPCoreTextTypesetter::pCTTypesetter(this);
  v28.location = location;
  v28.length = length;
  Line = CTTypesetterCreateLine(v15, v28);
  if (Line)
  {
    v17 = Line;
    TypographicBounds = CTLineGetTypographicBounds(Line, 0, 0, 0);
    TruncatedLine = CTLineCreateTruncatedLine(v17, a3 - advances.width, kCTLineTruncationEnd, 0);
    if (TruncatedLine)
    {
      v20 = TruncatedLine;
      v21 = CTLineGetTypographicBounds(TruncatedLine, 0, 0, 0);
      CFRelease(v20);
    }
    else
    {
      v21 = NAN;
    }
    CFRelease(v17);
  }
  else
  {
    v22 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v23 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPCoreTextTypesetter::pRoomForHyphen(CFRange, UTF32Char, CGFloat, TSWPLineFragment *)");
    objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3725, CFSTR("CTTypesetterCreateLine returned nil"));
    TypographicBounds = 0.0;
    v21 = NAN;
  }
  return v21 == TypographicBounds;
}

uint64_t TSWPCoreTextTypesetter::pHyphenateLocalRange(id *this, CFRange *a2, const TSWPLayoutState *a3, double a4, TSWPLineFragment *a5)
{
  CFIndex location;
  CFIndex v11;
  uint64_t v12;
  int64_t v13;
  unint64_t v14;
  BOOL v15;
  unint64_t v16;
  unsigned int v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  CFIndex v21;
  CFIndex v22;
  CFRange v23;
  BOOL v25;
  void *v27;
  uint64_t v28;
  CFIndex v29;
  CFIndex v30;
  const __CTTypesetter *v31;
  const __CTLine *Line;
  const __CTLine *v33;
  void *v34;
  uint64_t v35;
  TSWPLineFragment *v36;
  uint64_t v37;
  unsigned int v38;
  CFRange v39;

  if (*((double *)a3 + 52) >= a4)
    return 0xFFFFFFFFLL;
  location = a2->location;
  v11 = a2->length + a2->location;
  v12 = objc_msgSend(this[8], "wordAtCharIndex:includePreviousWord:", v11, 1);
  if (v12 == 0x7FFFFFFFFFFFFFFFLL)
    return 0xFFFFFFFFLL;
  v14 = v13;
  v15 = v13 < *((_QWORD *)a3 + 54) || v11 <= location;
  if (v15)
    return 0xFFFFFFFFLL;
  v16 = v12;
  v36 = a5;
  v17 = 0;
  v37 = v12 + v13;
  while (1)
  {
    v38 = 0;
    v18 = *((_QWORD *)a3 + 53);
    if (!v18)
    {
      v19 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v20 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPHyphenationResult TSWPCoreTextTypesetter::pHyphenateLocalRange(CFRange &, const TSWPLayoutState *, CGFloat, TSWPLineFragment *)");
      objc_msgSend(v19, "handleFailureInFunction:file:lineNumber:description:", v20, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3629, CFSTR("invalid nil value for '%s'"), "state->hyphenationLocale");
      v18 = *((_QWORD *)a3 + 53);
    }
    v21 = objc_msgSend(this[8], "hyphenationLocationBeforeIndex:inRange:locale:hyphenChar:", v11, v16, v14, v18, &v38);
    v22 = v21;
    if ((uint64_t)(*((_QWORD *)a3 + 55) + v16) <= v21 && v21 <= v37 - *((_QWORD *)a3 + 56))
    {
      v23.location = a2->location;
      if (v11 <= v21 || v21 <= v23.location)
        return 0xFFFFFFFFLL;
      if (v21 != -1)
      {
        if (v21 < v16 || v21 - v16 >= v14)
        {
          v27 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v28 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPHyphenationResult TSWPCoreTextTypesetter::pHyphenateLocalRange(CFRange &, const TSWPLayoutState *, CGFloat, TSWPLineFragment *)");
          objc_msgSend(v27, "handleFailureInFunction:file:lineNumber:description:", v28, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3650, CFSTR("Bad hyphenation result"));
          return 0xFFFFFFFFLL;
        }
        v23.length = v21 - v23.location;
        if (TSWPCoreTextTypesetter::pRoomForHyphen((TSWPCoreTextTypesetter *)this, v23, a4, v38, v36))
          break;
      }
    }
    v25 = v22 <= location || v17++ >= 0x13;
    v11 = v22;
    if (v25)
      return 0xFFFFFFFFLL;
  }
  v29 = a2->location;
  v30 = v16 - a2->location;
  if (v30 >= 1)
  {
    v31 = (const __CTTypesetter *)TSWPCoreTextTypesetter::pCTTypesetter((TSWPCoreTextTypesetter *)this);
    v39.location = v29;
    v39.length = v30;
    Line = CTTypesetterCreateLine(v31, v39);
    if (Line)
    {
      v33 = Line;
      if (a4 - CTLineGetTypographicBounds(Line, 0, 0, 0) < *((double *)a3 + 52))
      {
        a2->length = v16 - a2->location;
        CFRelease(v33);
        return 0xFFFFFFFFLL;
      }
      CFRelease(v33);
    }
  }
  v15 = v22 <= a2->location;
  a2->length = v22 - a2->location;
  if (v15)
  {
    v34 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v35 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPHyphenationResult TSWPCoreTextTypesetter::pHyphenateLocalRange(CFRange &, const TSWPLayoutState *, CGFloat, TSWPLineFragment *)");
    objc_msgSend(v34, "handleFailureInFunction:file:lineNumber:description:", v35, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3690, CFSTR("Bad hyphenation result range"));
  }
  return 1;
}

uint64_t TSWPCoreTextTypesetter::skipLine(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  __int16 v6;

  v4 = *a2 + *(_QWORD *)(*(_QWORD *)(a3 + 200) + 8);
  if (v4)
    v5 = v4 - 1;
  else
    v5 = 0;
  *(_QWORD *)(a3 + 216) = v5;
  if (v4)
    v6 = objc_msgSend(*(id *)(a1 + 16), "characterAtIndex:");
  else
    v6 = 0;
  *(_WORD *)(a3 + 208) = v6;
  return v4;
}

void TSWPCoreTextTypesetter::truncateLineFragment(uint64_t a1, uint64_t a2, TSWPLineFragment *this, char a4, int a5)
{
  CFTypeRef *i;
  CFTypeRef *v11;
  uint64_t j;
  uint64_t v13;
  uint64_t k;
  uint64_t v15;
  uint64_t m;
  uint64_t v17;
  int v18;
  uint64_t n;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  double v26;
  uint64_t v28;
  CGFloat ascent;

  *((_DWORD *)this + 6) = *((_DWORD *)this + 6) & 0xFF7FFFFD | 0x800000;
  v11 = (CFTypeRef *)*((_QWORD *)this + 24);
  for (i = (CFTypeRef *)*((_QWORD *)this + 25);
        i != v11;
        std::allocator<TSWPLineRef>::destroy[abi:ne180100]((uint64_t)this + 208, i))
  {
    i -= 6;
  }
  *((_QWORD *)this + 25) = v11;
  v13 = *((_QWORD *)this + 34);
  for (j = *((_QWORD *)this + 35);
        j != v13;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 288, j))
  {
    j -= 80;
  }
  *((_QWORD *)this + 35) = v13;
  v15 = *((_QWORD *)this + 37);
  for (k = *((_QWORD *)this + 38);
        k != v15;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 312, k))
  {
    k -= 80;
  }
  *((_QWORD *)this + 38) = v15;
  v17 = *((_QWORD *)this + 40);
  for (m = *((_QWORD *)this + 41);
        m != v17;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 336, m))
  {
    m -= 80;
  }
  v18 = a4 & 0xC;
  *((_QWORD *)this + 41) = v17;
  v20 = *((_QWORD *)this + 43);
  for (n = *((_QWORD *)this + 44);
        n != v20;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 360, n))
  {
    n -= 80;
  }
  *((_QWORD *)this + 44) = v20;
  TSWPCoreTextTypesetter::createLineRefsForLineFragment(a1, this, a2, v18 != 0, a5);
  v21 = *((_QWORD *)this + 24);
  if (0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)this + 25) - v21) >> 4) >= 2)
  {
    v22 = 2;
    v23 = 1;
    do
    {
      v24 = v21 + 48 * v23;
      v25 = *(double *)(v24 + 8);
      v28 = 0;
      ascent = 0.0;
      v26 = v25 + CTLineGetTypographicBounds(*(CTLineRef *)v24, &ascent, (CGFloat *)&v28, 0);
      if (*((double *)this + 27) >= v26)
        v26 = *((double *)this + 27);
      *((double *)this + 27) = v26;
      v23 = v22;
      v21 = *((_QWORD *)this + 24);
    }
    while (0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)this + 25) - v21) >> 4) > v22++);
  }
}

double TSWPCoreTextTypesetter::pMaxRubyHeightAboveLineFragment(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v3;
  double v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  CGFloat ascent;

  v3 = 0.0;
  if (*(_QWORD *)(a3 + 232) != *(_QWORD *)(a3 + 224))
  {
    v5 = TSWPLayoutChore::calculateBaselineOffsetWithHeightInfo((double *)(a3 + 112), a2);
    v6 = *(_QWORD *)(a3 + 224);
    if (*(_QWORD *)(a3 + 232) != v6)
    {
      v7 = v5;
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = v6 + 48 * v8;
        ascent = 0.0;
        CTLineGetTypographicBounds(*(CTLineRef *)v10, &ascent, 0, 0);
        if (v3 <= -(v7 + *(double *)(v10 + 16) - ascent))
          v3 = -(v7 + *(double *)(v10 + 16) - ascent);
        v8 = v9;
        v6 = *(_QWORD *)(a3 + 224);
      }
      while (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a3 + 232) - v6) >> 4) > v9++);
    }
  }
  return v3;
}

BOOL TSWPCoreTextTypesetter::pSetUpEmphasisMarkAdornments(id *this, const TSWPLayoutState *a2, TSWPAdornments *a3, CTRunRef *a4, TSWPLineFragment *a5, NSString *a6, unsigned __int16 *a7, CGSize *a8)
{
  uint64_t v15;
  double v16;
  double v17;
  CFDictionaryRef Attributes;
  CFIndex GlyphCount;
  TSWPParagraphTypesetter *v20;
  _QWORD *TateChuYokoLineRefsForCharIndex;
  _BOOL4 v22;
  double v23;
  CTFontRef v24;
  CTFontRef v25;
  CGColor *v26;
  const void *v27;
  int v28;
  int v29;
  int v30;
  void *v31;
  uint64_t v32;
  _BOOL8 GlyphsForCharacters;
  CGFloat Ascent;
  CGFloat Descent;
  CGFloat width;
  CFIndex buffer[2];
  CFRange v40;

  buffer[1] = *MEMORY[0x24BDAC8D0];
  v15 = objc_msgSend(this[8], "characterStyleAtCharIndex:effectiveRange:", CTRunGetStringRange(*a4).location, 0);
  objc_msgSend((id)TSWPResolvePropertyForStyles(v15, *((_QWORD *)a2 + 12), 17, 0), "doubleValue");
  v17 = v16;
  Attributes = CTRunGetAttributes(*a4);
  GlyphCount = CTRunGetGlyphCount(*a4);
  if (!-[__CFDictionary objectForKeyedSubscript:](Attributes, "objectForKeyedSubscript:", *MEMORY[0x24BDC4F28]))
    goto LABEL_8;
  v40.location = 0;
  v40.length = 1;
  CTRunGetStringIndices(*a4, v40, buffer);
  if (*((unsigned __int16 *)this[10] + buffer[0]) == (unsigned __int16)kTateChuYokoDummySpaceCharacter
    && GlyphCount == 1
    && (v20 = (TSWPParagraphTypesetter *)this[29]) != 0)
  {
    TateChuYokoLineRefsForCharIndex = TSWPParagraphTypesetter::findTateChuYokoLineRefsForCharIndex(v20, buffer[0]);
    v22 = TateChuYokoLineRefsForCharIndex != 0;
    if (v15 && TateChuYokoLineRefsForCharIndex)
    {
      objc_msgSend((id)TSWPResolvePropertyForStyles(0, *((_QWORD *)a2 + 12), 17, 0), "doubleValue");
      v17 = v23;
LABEL_8:
      v22 = 1;
    }
  }
  else
  {
    v22 = 0;
  }
  v24 = CTFontCreateWithName(CFSTR("HiraMinProN-W3"), v17 * (float)((float)(unint64_t)objc_msgSend(*((id *)a2 + 13), "scaleTextPercent") / 100.0) / 3.0, 0);
  if (v24)
  {
    v25 = v24;
    if (v22)
    {
      v26 = (CGColor *)-[__CFDictionary objectForKeyedSubscript:](Attributes, "objectForKeyedSubscript:", *MEMORY[0x24BDC4EE0]);
      CFRetain(v25);
      v27 = (const void *)*((_QWORD *)a3 + 3);
      if (v27)
        CFRelease(v27);
      *((_QWORD *)a3 + 3) = v25;
      CGColorRetain(v26);
      CGColorRelease(*((CGColorRef *)a3 + 2));
      *((_QWORD *)a3 + 2) = v26;
      v28 = -[NSString characterAtIndex:](a6, "characterAtIndex:", 0);
      LOWORD(buffer[0]) = v28;
      v29 = TSWPGetAdornmentLocation(this[12], *((unsigned __int8 *)this + 30), 4);
      v30 = TSWPCJKLanguageForInputLanguageString(this[12]);
      if (v28 == 65093)
      {
        if (v29 == 2 || v30 == 1)
        {
          v28 = 8226;
          LOWORD(buffer[0]) = 8226;
        }
        else
        {
          v28 = 65093;
        }
      }
      *((_BYTE *)a3 + 192) = (v28 == 65093) & (*((_DWORD *)a5 + 6) >> 13);
      GlyphsForCharacters = CTFontGetGlyphsForCharacters(v25, (const UniChar *)buffer, a7, 1);
      if (GlyphsForCharacters)
      {
        CTFontGetAdvancesForGlyphs(*((CTFontRef *)a3 + 3), kCTFontOrientationDefault, a7, a8, 1);
        Ascent = CTFontGetAscent(v25);
        Descent = CTFontGetDescent(v25);
        width = a8->width;
        *((CGFloat *)a3 + 19) = Ascent;
        *((CGFloat *)a3 + 20) = Descent;
        *((CGFloat *)a3 + 21) = width;
        *((_DWORD *)a3 + 1) = v29;
      }
    }
    else
    {
      GlyphsForCharacters = 0;
    }
    CFRelease(v25);
  }
  else
  {
    v31 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v32 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPCoreTextTypesetter::pSetUpEmphasisMarkAdornments(const TSWPLayoutState *, TSWPAdornments &, const CTRunRef &, TSWPLineFragment *, NSString *, CGGlyph &, CGSize &) const");
    objc_msgSend(v31, "handleFailureInFunction:file:lineNumber:description:", v32, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 4153, CFSTR("Emphasis marks, no font."));
    return 0;
  }
  return GlyphsForCharacters;
}

_QWORD *TSWPCoreTextTypesetter::pFindTateRun(TSWPCoreTextTypesetter *this, uint64_t a2, uint64_t a3)
{
  TSWPParagraphTypesetter *v3;

  if (*(unsigned __int16 *)(*((_QWORD *)this + 10) + 2 * a2) == (unsigned __int16)kTateChuYokoDummySpaceCharacter
    && a3 == 1
    && (v3 = (TSWPParagraphTypesetter *)*((_QWORD *)this + 29)) != 0)
  {
    return TSWPParagraphTypesetter::findTateChuYokoLineRefsForCharIndex(v3, a2);
  }
  else
  {
    return 0;
  }
}

unint64_t addAdornmentLine(uint64_t *a1, TSWPAdornmentLine *a2)
{
  unint64_t v4;
  BOOL v5;

  v4 = a1[1];
  if (v4 == *a1 || (v5 = TSWPAdornmentLine::merge((TSWPAdornmentLine *)(v4 - 80), a2), v4 = a1[1], !v5))
  {
    if (v4 >= a1[2])
    {
      v4 = std::vector<TSWPAdornmentLine>::__push_back_slow_path<TSWPAdornmentLine const&>(a1, (uint64_t)a2);
    }
    else
    {
      std::allocator<TSWPAdornmentLine>::construct[abi:ne180100]<TSWPAdornmentLine,TSWPAdornmentLine const&>((uint64_t)(a1 + 2), v4, (uint64_t)a2);
      v4 += 80;
      a1[1] = v4;
    }
    a1[1] = v4;
  }
  return v4 - 80;
}

void sub_217B5C214(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void TSWPAdornmentLine::~TSWPAdornmentLine(TSWPAdornmentLine *this)
{
  CGColorRelease(this->var2);

}

void TSWPCoreTextTypesetter::pAddHighlightAdornmentToLineFragment(TSWPCoreTextTypesetter *this, TSWPLineFragment *a2, double a3, CGFloat a4, TSKAnnotationAuthor *a5)
{
  TSKAnnotationAuthorTextHighlightColorProvider *v8;
  TSKAnnotationAuthorTextHighlightColorProvider *v9;
  TSWPAdornmentLine v10;

  v8 = -[TSKAnnotationAuthorTextHighlightColorProvider initWithAnnotationAuthor:]([TSKAnnotationAuthorTextHighlightColorProvider alloc], "initWithAnnotationAuthor:", a5);
  v10.var0.x = a4;
  v10.var0.y = 0.0;
  v10.var1 = a3;
  v10.var7 = 0.0;
  v10.var8 = 0;
  memset(&v10.var2, 0, 28);
  v10.var9 = v8;
  CGColorRetain(0);
  v9 = v8;
  addAdornmentLine((uint64_t *)a2 + 43, &v10);

  CGColorRelease(v10.var2);
}

void sub_217B5C2F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TSWPAdornmentLine::~TSWPAdornmentLine((TSWPAdornmentLine *)&a9);
  _Unwind_Resume(a1);
}

void TSWPCoreTextTypesetter::pAddEmphasisMarkGlyph(uint64_t a1, TSWPAdornments *a2, uint64_t a3, CTRunRef run, CFRange range, uint64_t a6, const __CTFont *a7, CGFloat a8, double a9, double a10, double a11, double a12, unint64_t charIndex, char a14, unsigned __int16 a15)
{
  CFIndex length;
  CFIndex location;
  BOOL v26;
  CGSize v27;
  double width;
  double v29;
  double v30;
  double v31;
  double v32;
  CTFontOrientation v34;
  CGPoint v35;
  CGRect v36;
  CFRange v37;
  CGRect BoundingRectsForGlyphs;

  length = range.length;
  location = range.location;
  if (range.length
    || (IsWordBoundaryCharacter(a6) & 1) == 0
    && (objc_msgSend((id)objc_msgSend(MEMORY[0x24BDD14A8], "punctuationCharacterSet"), "characterIsMember:", a6) & 1) == 0)
  {
    if (*((_DWORD *)a2 + 1) != 1
      || ((v36.origin = (CGPoint)*MEMORY[0x24BEB3BF0], *(_QWORD *)&v36.origin.x == *MEMORY[0x24BEB3BF0])
        ? (v26 = *(_QWORD *)&v36.origin.y == *(_QWORD *)(MEMORY[0x24BEB3BF0] + 8))
        : (v26 = 0),
          !v26
       || !objc_msgSend(*(id *)(a1 + 64), "smartFieldAtCharIndex:attributeKind:effectiveRange:", charIndex, 7, &v36)
       || charIndex < *(_QWORD *)&v36.origin.x
       || charIndex - *(_QWORD *)&v36.origin.x >= *(_QWORD *)&v36.origin.y))
    {
      v27 = *(CGSize *)(MEMORY[0x24BDBF090] + 16);
      v36.origin = (CGPoint)*MEMORY[0x24BDBF090];
      v36.size = v27;
      if (length)
      {
        width = *(double *)(length + 32);
        v29 = *(double *)(a3 + 8);
        v30 = v29 + CTLineGetOffsetForStringIndex(*(CTLineRef *)a3, charIndex, 0);
        v31 = 0.5;
        v32 = width * 0.5 + v30;
      }
      else
      {
        LOWORD(v35.x) = 0;
        v37.location = location;
        v37.length = 1;
        CTRunGetGlyphs(run, v37, (CGGlyph *)&v35);
        if (a14)
          v34 = kCTFontOrientationVertical;
        else
          v34 = kCTFontOrientationDefault;
        BoundingRectsForGlyphs = CTFontGetBoundingRectsForGlyphs(a7, v34, (const CGGlyph *)&v35, 0, 1);
        if (!a14)
        {
          v35.x = a8 + (a10 - a12) * 0.5;
          v35.y = 0.0;
          v36.origin.x = a8;
          width = a10;
          goto LABEL_22;
        }
        width = BoundingRectsForGlyphs.size.width;
        v30 = -a9;
        v31 = 0.5;
        v32 = -a9 - BoundingRectsForGlyphs.size.width * 0.5;
      }
      v35.x = v32 - a12 * v31;
      v35.y = 0.0;
      v36.origin.x = v30;
LABEL_22:
      v36.origin.y = 0.0;
      v36.size.width = width;
      v36.size.height = 1.0;
      TSWPAdornments::add(a2, objc_msgSend(*(id *)(a1 + 64), "charIndexMappedToStorage:", charIndex, *(_QWORD *)&v35.x, *(_QWORD *)&v35.y, *(_QWORD *)&v36.origin.x, 0, *(_QWORD *)&width, 0x3FF0000000000000), &v35, &a15, &v36);
    }
  }
}

void TSWPCoreTextTypesetter::pAddInvisibleBreakToLineFragment(id *this, const TSWPLayoutState *a2, TSWPLineFragment *a3, int a4, double a5, char a6)
{
  uint64_t v12;
  uint64_t v13;
  double v14;
  int v15;
  double v16;
  uint64_t v17;
  int v18;
  int v19;
  double v20;
  void *v21;
  uint64_t v22;
  double v23;
  int v24;
  double v25;
  __int128 *v26;
  double v27;
  double v28;
  double v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  CGColor *v33;
  id v34;
  __CTFont *v35;
  __int128 v36;
  unint64_t v37;
  uint64_t v38;
  _QWORD v39[2];
  CGColorRef color;
  CFTypeRef cf;
  void *v42[2];
  void *v43[2];
  __int128 v44;
  void *v45[2];
  void *v46[2];
  __int128 v47;
  void *__p[2];
  __int128 v49;
  __int128 v50;
  __int128 v51;
  char v52;
  CGPoint v53;

  v12 = objc_msgSend(this[8], "charRangeMappedFromStorage:", *(_QWORD *)a3, *((_QWORD *)a3 + 1));
  v14 = *(double *)(*((_QWORD *)a3 + 24) + 8);
  v15 = a4 - 4;
  v16 = 2.0;
  v17 = 7;
  switch(v15)
  {
    case 0:
      goto LABEL_15;
    case 1:
      v18 = objc_msgSend(this[8], "hasColumnStyleForParagraphBreakAtCharIndex:", v13 + v12 - 1);
      if (v18)
        v16 = 1.0;
      else
        v16 = 2.0;
      if (v18)
        v17 = 5;
      else
        v17 = 6;
      goto LABEL_15;
    case 6:
    case 7:
    case 9:
      v19 = objc_msgSend(this[8], "hasColumnStyleForParagraphBreakAtCharIndex:", v13 + v12 - 1);
      if (v19)
        v16 = 1.0;
      else
        v16 = 0.0;
      if (v19)
        v17 = 5;
      else
        v17 = 3;
      goto LABEL_15;
    case 8:
      v16 = 1.0;
      v17 = 4;
LABEL_15:
      v20 = v14 + a5;
      if (TSWPParagraphEnumerator::paragraphTextRange((TSWPParagraphEnumerator *)((char *)a2 + 24)) != *((_QWORD *)a3 + 2))
      {
        v21 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v22 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPCoreTextTypesetter::pAddInvisibleBreakToLineFragment(const TSWPLayoutState *, TSWPLineFragment *, unichar, CGFloat, BOOL) const");
        objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3419, CFSTR("line fragment isn't from the current paragraph"));
      }
      v23 = *((double *)&gInvisibles + 5 * v17 + 1);
      v24 = *((_DWORD *)a3 + 6);
      if (fabs(v20) == INFINITY)
      {
        if ((v24 & 0x1000) == 0)
        {
          v20 = *((double *)a3 + 27) + 0.0;
          goto LABEL_29;
        }
        v25 = 0.0;
        goto LABEL_28;
      }
      if ((v24 & 0x1000) != 0)
      {
        v25 = 0.0;
        if (v20 >= 0.0)
          v25 = v20;
LABEL_28:
        v20 = v25 - v23;
        goto LABEL_29;
      }
      if ((a6 & 1) == 0 && *((double *)a3 + 8) < v20)
        v20 = *((double *)a3 + 8);
LABEL_29:
      v26 = (__int128 *)MEMORY[0x24BDBEFB0];
      v53 = (CGPoint)*MEMORY[0x24BDBEFB0];
      if (!*((_BYTE *)&gInvisibles + 40 * v17 + 2))
      {
        v28 = (7.0 - v23) * 0.5 + v20;
        goto LABEL_44;
      }
      if ((v24 & 0x1000) != 0)
      {
        v28 = fmin(v20, 0.0);
        v53.x = v28;
        v29 = v23 + v20 - (v23 + v28);
        v20 = v23 + v28;
      }
      else
      {
        v27 = *((double *)a3 + 8) - v23;
        if (v27 >= v20)
          v28 = v27;
        else
          v28 = v20;
        v29 = v28 - v20;
        if (v28 - v20 < 0.0)
          goto LABEL_44;
      }
      if (v29 > 0.0)
      {
        if (v16 <= 0.0)
        {
          v30 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v31 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPCoreTextTypesetter::pAddInvisibleBreakToLineFragment(const TSWPLayoutState *, TSWPLineFragment *, unichar, CGFloat, BOOL) const");
          objc_msgSend(v30, "handleFailureInFunction:file:lineNumber:description:", v31, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3477, CFSTR("break line has no thickness"));
        }
        if (!TSWPCoreTextTypesetter::pAddInvisibleBreakToLineFragment(TSWPLayoutState const*,TSWPLineFragment *,unsigned short,double,BOOL)const::invisiblesColor)
          TSWPCoreTextTypesetter::pAddInvisibleBreakToLineFragment(TSWPLayoutState const*,TSWPLineFragment *,unsigned short,double,BOOL)const::invisiblesColor = (uint64_t)CGColorRetain((CGColorRef)objc_msgSend((id)objc_msgSend(MEMORY[0x24BEB3C40], "colorWithRed:green:blue:alpha:", 0.180392161, 0.533333361, 0.921568632, 1.0), "CGColor"));
        v32 = operator new();
        v33 = (CGColor *)TSWPCoreTextTypesetter::pAddInvisibleBreakToLineFragment(TSWPLayoutState const*,TSWPLineFragment *,unsigned short,double,BOOL)const::invisiblesColor;
        *(double *)v32 = v20;
        *(_QWORD *)(v32 + 8) = 0x7FF8000000000000;
        *(double *)(v32 + 16) = v29;
        *(_QWORD *)(v32 + 24) = v33;
        *(double *)(v32 + 32) = v16;
        *(_QWORD *)(v32 + 40) = 1;
        *(_DWORD *)(v32 + 48) = 0;
        *(_QWORD *)(v32 + 56) = 0;
        *(_BYTE *)(v32 + 64) = 0;
        *(_QWORD *)(v32 + 72) = 0;
        CGColorRetain(v33);
        v34 = *(id *)(v32 + 72);
        *((_QWORD *)a3 + 58) = v32;
      }
LABEL_44:
      v53.x = v28 - v14;
      v35 = +[TSWPRenderer invisiblesFont](TSWPRenderer, "invisiblesFont");
      v39[0] = 0x100000002;
      v39[1] = 0;
      color = 0;
      cf = v35;
      *(_OWORD *)v42 = 0u;
      *(_OWORD *)v43 = 0u;
      v44 = 0u;
      *(_OWORD *)v45 = 0u;
      *(_OWORD *)v46 = 0u;
      v47 = 0u;
      *(_OWORD *)__p = 0u;
      v49 = 0u;
      v36 = *v26;
      v50 = 0u;
      v51 = v36;
      v52 = 0;
      CGColorRetain(0);
      if (v35)
        CFRetain(v35);
      TSWPAdornments::add((TSWPAdornments *)v39, &v53, (const unsigned __int16 *)&gInvisibles + 20 * v17 + 16);
      v37 = *((_QWORD *)a3 + 56);
      if (v37 >= *((_QWORD *)a3 + 57))
      {
        v38 = std::vector<TSWPAdornments>::__push_back_slow_path<TSWPAdornments const&>((uint64_t *)a3 + 55, (const TSWPAdornments *)v39);
      }
      else
      {
        TSWPAdornments::TSWPAdornments(*((TSWPAdornments **)a3 + 56), (const TSWPAdornments *)v39);
        v38 = v37 + 200;
        *((_QWORD *)a3 + 56) = v37 + 200;
      }
      *((_QWORD *)a3 + 56) = v38;
      TSWPLineFragment::adjustBreakLine(a3);
      CGColorRelease(color);
      if (cf)
        CFRelease(cf);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (v46[1])
      {
        *(void **)&v47 = v46[1];
        operator delete(v46[1]);
      }
      if (v45[0])
      {
        v45[1] = v45[0];
        operator delete(v45[0]);
      }
      if (v43[1])
      {
        *(void **)&v44 = v43[1];
        operator delete(v43[1]);
      }
      if (v42[0])
      {
        v42[1] = v42[0];
        operator delete(v42[0]);
      }
      return;
    default:
      return;
  }
}

void sub_217B5C9D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  va_list va;

  va_start(va, a2);
  *(_QWORD *)(v2 + 448) = v3;
  TSWPAdornments::~TSWPAdornments((CGColorRef *)va);
  _Unwind_Resume(a1);
}

uint64_t TSWPCoreTextTypesetter::pComposedCharacterAtIndex(id *this, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unsigned __int16 *v6;
  uint64_t result;
  int v8;

  v4 = objc_msgSend(this[8], "length");
  if (v4 <= a2)
    return 0;
  v5 = v4;
  v6 = (unsigned __int16 *)this[10];
  result = v6[a2];
  if (a2 + 1 < v5)
  {
    v8 = v6[a2 + 1];
    if ((result & 0xFC00) == 0xD800 && (v8 & 0xFC00) == 56320)
      return (v8 + ((_DWORD)result << 10) - 56613888);
  }
  return result;
}

void TSWPAdornments::add(TSWPAdornments *this, uint64_t a2, const CGPoint *a3, const unsigned __int16 *a4, const CGRect *a5)
{
  char *v10;
  unint64_t v11;
  char *v12;
  _QWORD *v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  CGPoint *v24;
  CGPoint *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  CGPoint *v32;
  char *v33;
  CGPoint *v34;
  CGPoint *v35;
  unint64_t v36;
  char *v37;
  _WORD *v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  char *v47;
  __int16 v48;
  unint64_t v49;
  unint64_t v50;
  CGSize v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  CGSize *v59;
  char *v60;
  CGSize size;
  char *v62;
  char *v63;
  CGSize v64;

  v10 = (char *)this + 48;
  v11 = *((_QWORD *)this + 6);
  v12 = (char *)*((_QWORD *)this + 5);
  if ((unint64_t)v12 >= v11)
  {
    v14 = (char *)*((_QWORD *)this + 4);
    v15 = (v12 - v14) >> 3;
    if ((unint64_t)(v15 + 1) >> 61)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v16 = v11 - (_QWORD)v14;
    v17 = (uint64_t)(v11 - (_QWORD)v14) >> 2;
    if (v17 <= v15 + 1)
      v17 = v15 + 1;
    if (v16 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v17;
    if (v18)
    {
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>((uint64_t)v10, v18);
      v14 = (char *)*((_QWORD *)this + 4);
      v12 = (char *)*((_QWORD *)this + 5);
    }
    else
    {
      v19 = 0;
    }
    v20 = &v19[8 * v15];
    v21 = &v19[8 * v18];
    *(_QWORD *)v20 = a2;
    v13 = v20 + 8;
    while (v12 != v14)
    {
      v22 = *((_QWORD *)v12 - 1);
      v12 -= 8;
      *((_QWORD *)v20 - 1) = v22;
      v20 -= 8;
    }
    *((_QWORD *)this + 4) = v20;
    *((_QWORD *)this + 5) = v13;
    *((_QWORD *)this + 6) = v21;
    if (v14)
      operator delete(v14);
  }
  else
  {
    *(_QWORD *)v12 = a2;
    v13 = v12 + 8;
  }
  v23 = *((_QWORD *)this + 15);
  *((_QWORD *)this + 5) = v13;
  v24 = (CGPoint *)*((_QWORD *)this + 14);
  if ((unint64_t)v24 >= v23)
  {
    v26 = *((_QWORD *)this + 13);
    v27 = ((uint64_t)v24 - v26) >> 4;
    v28 = v27 + 1;
    if ((unint64_t)(v27 + 1) >> 60)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v29 = v23 - v26;
    if (v29 >> 3 > v28)
      v28 = v29 >> 3;
    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF0)
      v30 = 0xFFFFFFFFFFFFFFFLL;
    else
      v30 = v28;
    if (v30)
      v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint>>((uint64_t)this + 120, v30);
    else
      v31 = 0;
    v32 = (CGPoint *)&v31[16 * v27];
    v33 = &v31[16 * v30];
    *v32 = *a3;
    v25 = v32 + 1;
    v35 = (CGPoint *)*((_QWORD *)this + 13);
    v34 = (CGPoint *)*((_QWORD *)this + 14);
    if (v34 != v35)
    {
      do
      {
        v32[-1] = v34[-1];
        --v32;
        --v34;
      }
      while (v34 != v35);
      v34 = (CGPoint *)*((_QWORD *)this + 13);
    }
    *((_QWORD *)this + 13) = v32;
    *((_QWORD *)this + 14) = v25;
    *((_QWORD *)this + 15) = v33;
    if (v34)
      operator delete(v34);
  }
  else
  {
    *v24 = *a3;
    v25 = v24 + 1;
  }
  v36 = *((_QWORD *)this + 9);
  *((_QWORD *)this + 14) = v25;
  v37 = (char *)*((_QWORD *)this + 8);
  if ((unint64_t)v37 >= v36)
  {
    v39 = (char *)*((_QWORD *)this + 7);
    v40 = v37 - v39;
    if (v37 - v39 <= -3)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v41 = v40 >> 1;
    v42 = v36 - (_QWORD)v39;
    if (v42 <= (v40 >> 1) + 1)
      v43 = v41 + 1;
    else
      v43 = v42;
    if (v42 >= 0x7FFFFFFFFFFFFFFELL)
      v44 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v44 = v43;
    if (v44)
    {
      v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>((uint64_t)this + 72, v44);
      v39 = (char *)*((_QWORD *)this + 7);
      v37 = (char *)*((_QWORD *)this + 8);
    }
    else
    {
      v45 = 0;
    }
    v46 = &v45[2 * v41];
    v47 = &v45[2 * v44];
    *(_WORD *)v46 = *a4;
    v38 = v46 + 2;
    while (v37 != v39)
    {
      v48 = *((_WORD *)v37 - 1);
      v37 -= 2;
      *((_WORD *)v46 - 1) = v48;
      v46 -= 2;
    }
    *((_QWORD *)this + 7) = v46;
    *((_QWORD *)this + 8) = v38;
    *((_QWORD *)this + 9) = v47;
    if (v39)
      operator delete(v39);
  }
  else
  {
    *(_WORD *)v37 = *a4;
    v38 = v37 + 2;
  }
  v49 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 8) = v38;
  v50 = *((_QWORD *)this + 11);
  if (v50 >= v49)
  {
    v53 = *((_QWORD *)this + 10);
    v54 = (uint64_t)(v50 - v53) >> 5;
    v55 = v54 + 1;
    if ((unint64_t)(v54 + 1) >> 59)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v56 = v49 - v53;
    if (v56 >> 4 > v55)
      v55 = v56 >> 4;
    if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFE0)
      v57 = 0x7FFFFFFFFFFFFFFLL;
    else
      v57 = v55;
    if (v57)
      v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>((uint64_t)this + 96, v57);
    else
      v58 = 0;
    v59 = (CGSize *)&v58[32 * v54];
    v60 = &v58[32 * v57];
    size = a5->size;
    *v59 = (CGSize)a5->origin;
    v59[1] = size;
    v52 = (char *)&v59[2];
    v63 = (char *)*((_QWORD *)this + 10);
    v62 = (char *)*((_QWORD *)this + 11);
    if (v62 != v63)
    {
      do
      {
        v64 = (CGSize)*((_OWORD *)v62 - 1);
        v59[-2] = *((CGSize *)v62 - 2);
        v59[-1] = v64;
        v59 -= 2;
        v62 -= 32;
      }
      while (v62 != v63);
      v62 = (char *)*((_QWORD *)this + 10);
    }
    *((_QWORD *)this + 10) = v59;
    *((_QWORD *)this + 11) = v52;
    *((_QWORD *)this + 12) = v60;
    if (v62)
      operator delete(v62);
  }
  else
  {
    v51 = a5->size;
    *(CGPoint *)v50 = a5->origin;
    *(CGSize *)(v50 + 16) = v51;
    v52 = (char *)(v50 + 32);
  }
  *((_QWORD *)this + 11) = v52;
}

void TSWPCoreTextTypesetter::pFilterEmphasisMarksForRuby(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CGFloat v18;
  double v19;
  CGFloat v20;
  CGFloat v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  _BYTE *v27;
  _QWORD *v28;
  _BYTE *v29;
  uint64_t v30;
  uint64_t v31;
  _BYTE *v32;
  int64_t v33;
  uint64_t v34;
  _BYTE *v35;
  _QWORD *v36;
  _BYTE *v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE *v40;
  int64_t v41;
  uint64_t v42;
  _BYTE *v43;
  _QWORD *v44;
  _BYTE *v45;
  uint64_t v46;
  uint64_t v47;
  _BYTE *v48;
  int64_t v49;
  uint64_t v50;
  _BYTE *v51;
  _QWORD *v52;
  _BYTE *v53;
  uint64_t v54;
  uint64_t v55;
  _BYTE *v56;
  int64_t v57;
  unsigned int v58;
  _QWORD *v59;
  CGRect v60;
  CGRect v61;

  v4 = a3[55];
  v3 = a3[56];
  if (v3 != v4)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = v4 + 200 * v6;
      v9 = *(_QWORD *)(v8 + 80);
      v10 = *(_QWORD *)(v8 + 88);
      v11 = (_QWORD *)(v8 + 80);
      v12 = v10 - v9;
      if (v12)
      {
        v58 = v7;
        v13 = v12 >> 5;
        v59 = v11;
        do
        {
          v14 = v13 - 1;
          v15 = a3[28];
          if (a3[29] != v15)
          {
            v16 = 0;
            v17 = *v11 + 32 * v14;
            v18 = *(double *)(v17 + 8);
            v19 = *(double *)v17 + *(double *)(a3[24] + 8);
            v21 = *(double *)(v17 + 16);
            v20 = *(double *)(v17 + 24);
            v22 = 1;
            while (1)
            {
              v23 = v15 + 48 * v16;
              v61.size.width = CTLineGetTypographicBounds(*(CTLineRef *)v23, 0, 0, 0);
              v61.origin.x = *(CGFloat *)(v23 + 8);
              v61.origin.y = 0.0;
              v61.size.height = 1.0;
              v60.origin.x = v19;
              v60.origin.y = v18;
              v60.size.width = v21;
              v60.size.height = v20;
              if (CGRectIntersectsRect(v60, v61))
                break;
              v16 = v22;
              v15 = a3[28];
              if (0xAAAAAAAAAAAAAAABLL * ((a3[29] - v15) >> 4) <= v22++)
                goto LABEL_26;
            }
            v25 = a3[55];
            v26 = v25 + 200 * v6;
            v29 = *(_BYTE **)(v26 + 40);
            v28 = (_QWORD *)(v26 + 40);
            v27 = v29;
            v30 = *(v28 - 1);
            if (v14 < (uint64_t)&v29[-v30] >> 3)
            {
              v31 = v30 + 8 * v14;
              v32 = (_BYTE *)(v30 + 8 * v13);
              v33 = v27 - v32;
              if (v27 != v32)
                memmove((void *)(v30 + 8 * v14), v32, v27 - v32);
              *v28 = v31 + v33;
            }
            v34 = v25 + 200 * v6;
            v37 = *(_BYTE **)(v34 + 64);
            v36 = (_QWORD *)(v34 + 64);
            v35 = v37;
            v38 = *(v36 - 1);
            if (v14 < (uint64_t)&v37[-v38] >> 1)
            {
              v39 = v38 + 2 * v14;
              v40 = (_BYTE *)(v38 + 2 * v13);
              v41 = v35 - v40;
              if (v35 != v40)
                memmove((void *)(v38 + 2 * v14), v40, v35 - v40);
              *v36 = v39 + v41;
            }
            v42 = v25 + 200 * v6;
            v45 = *(_BYTE **)(v42 + 88);
            v44 = (_QWORD *)(v42 + 88);
            v43 = v45;
            v46 = *(v44 - 1);
            if (v14 < (uint64_t)&v45[-v46] >> 5)
            {
              v47 = v46 + 32 * v14;
              v48 = (_BYTE *)(v46 + 32 * v13);
              v49 = v43 - v48;
              if (v43 != v48)
                memmove((void *)(v46 + 32 * v14), v48, v43 - v48);
              *v44 = v47 + v49;
            }
            v50 = v25 + 200 * v6;
            v53 = *(_BYTE **)(v50 + 112);
            v52 = (_QWORD *)(v50 + 112);
            v51 = v53;
            v54 = *(v52 - 1);
            v11 = v59;
            if (v14 < (uint64_t)&v53[-v54] >> 4)
            {
              v55 = v54 + 16 * v14;
              v56 = (_BYTE *)(v54 + 16 * v13);
              v57 = v51 - v56;
              if (v51 != v56)
                memmove((void *)(v54 + 16 * v14), v56, v51 - v56);
              *v52 = v55 + v57;
            }
          }
LABEL_26:
          --v13;
        }
        while (v14);
        v4 = a3[55];
        v3 = a3[56];
        v7 = v58;
      }
      v6 = ++v7;
    }
    while (0x8F5C28F5C28F5C29 * ((v3 - v4) >> 3) > v7);
  }
}

void TSWPCoreTextTypesetter::pAddHiddenDeletionForLineFragment(TSWPCoreTextTypesetter *this, TSWPLineFragment *a2, TSUColor *a3, const TSWPLineRef *a4, double a5)
{
  __CTFont *v9;
  __int128 v10;
  CGColor *v11;
  double v12;
  double v13;
  BOOL v14;
  unint64_t v15;
  uint64_t v16;
  CGPoint v17;
  CGRect v18;
  _QWORD v19[2];
  CGColorRef color;
  CFTypeRef cf;
  void *v22[2];
  void *v23[2];
  __int128 v24;
  void *v25[2];
  void *v26[2];
  __int128 v27;
  void *__p[2];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  char v32;
  CGRect BoundingRectsForGlyphs;

  v9 = +[TSWPRenderer invisiblesFont](TSWPRenderer, "invisiblesFont");
  v19[0] = 0x100000006;
  v19[1] = 0;
  color = 0;
  cf = v9;
  *(_OWORD *)v22 = 0u;
  *(_OWORD *)v23 = 0u;
  v24 = 0u;
  *(_OWORD *)v25 = 0u;
  *(_OWORD *)v26 = 0u;
  v27 = 0u;
  *(_OWORD *)__p = 0u;
  v29 = 0u;
  v10 = *MEMORY[0x24BDBEFB0];
  v30 = 0u;
  v31 = v10;
  v32 = 0;
  CGColorRetain(0);
  if (v9)
    CFRetain(v9);
  if (a3)
  {
    v11 = (CGColor *)-[TSUColor CGColor](a3, "CGColor");
    CGColorRetain(v11);
    CGColorRelease(color);
    color = v11;
  }
  BoundingRectsForGlyphs = CTFontGetBoundingRectsForGlyphs(v9, kCTFontOrientationDefault, (const CGGlyph *)&algn_253DE0CA0[16], 0, 1);
  v18 = BoundingRectsForGlyphs;
  v12 = a5 + *(double *)&qword_253DE0C98 * -0.5;
  if ((*((_BYTE *)a2 + 25) & 0x10) != 0)
  {
    v13 = -*((double *)a4 + 1);
    v14 = v12 < v13;
  }
  else
  {
    v13 = *((double *)a2 + 8) - *((double *)a4 + 1) - *(double *)&qword_253DE0C98;
    v14 = v13 < v12;
  }
  if (v14)
    v12 = v13;
  v17.x = v12;
  v17.y = BoundingRectsForGlyphs.size.height * -0.5;
  TSWPAdornments::add((TSWPAdornments *)v19, 0, &v17, (const unsigned __int16 *)&algn_253DE0CA0[16], &v18);
  if ((void *)v27 != v26[1])
  {
    v15 = *((_QWORD *)a2 + 56);
    if (v15 >= *((_QWORD *)a2 + 57))
    {
      v16 = std::vector<TSWPAdornments>::__push_back_slow_path<TSWPAdornments const&>((uint64_t *)a2 + 55, (const TSWPAdornments *)v19);
    }
    else
    {
      TSWPAdornments::TSWPAdornments(*((TSWPAdornments **)a2 + 56), (const TSWPAdornments *)v19);
      v16 = v15 + 200;
      *((_QWORD *)a2 + 56) = v15 + 200;
    }
    *((_QWORD *)a2 + 56) = v16;
  }
  CGColorRelease(color);
  if (cf)
    CFRelease(cf);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v26[1])
  {
    *(void **)&v27 = v26[1];
    operator delete(v26[1]);
  }
  if (v25[0])
  {
    v25[1] = v25[0];
    operator delete(v25[0]);
  }
  if (v23[1])
  {
    *(void **)&v24 = v23[1];
    operator delete(v23[1]);
  }
  if (v22[0])
  {
    v22[1] = v22[0];
    operator delete(v22[0]);
  }
}

void sub_217B5D260(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CGColorRef a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,void *__p)
{
  uint64_t v32;
  uint64_t v33;

  *(_QWORD *)(v32 + 448) = v33;
  TSWPAdornments::~TSWPAdornments(&a16);
  _Unwind_Resume(a1);
}

void TSWPCoreTextTypesetter::pAddHiddenDeletionForLineFragment(id *this, TSWPLineFragment *a2, TSUColor *a3, uint64_t a4)
{
  CFIndex v6;
  uint64_t v7;
  const void *v8;
  double OffsetForStringIndex;
  TSWPCoreTextTypesetter *v10;
  const void *v11;
  __int128 v12;
  __int128 v13;
  int v14;

  v6 = objc_msgSend(this[8], "charIndexMappedFromStorage:", a4);
  v7 = *((_QWORD *)a2 + 24);
  v8 = *(const void **)v7;
  v11 = v8;
  v12 = *(_OWORD *)(v7 + 8);
  v13 = *(_OWORD *)(v7 + 24);
  v14 = *(_DWORD *)(v7 + 40);
  if (v8)
    CFRetain(v8);
  OffsetForStringIndex = CTLineGetOffsetForStringIndex((CTLineRef)v8, v6, 0);
  TSWPCoreTextTypesetter::pAddHiddenDeletionForLineFragment(v10, a2, a3, (const TSWPLineRef *)&v11, OffsetForStringIndex);
  if (v8)
    CFRelease(v8);
}

void sub_217B5D370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TSWPLineRef::~TSWPLineRef(&a9);
  _Unwind_Resume(a1);
}

double TSWPMeasureTextualAttachment(TSWPTypesetterAttachmentMap *a1)
{
  uint64_t v3;
  uint64_t v4;

  v3 = 0;
  v4 = 0;
  if (-[TSWPTypesetterAttachmentMap lineRef](a1, "lineRef"))
    return CTLineGetTypographicBounds(-[TSWPTypesetterAttachmentMap lineRef](a1, "lineRef"), (CGFloat *)&v3, (CGFloat *)&v4, 0);
  else
    return 0.0;
}

CFTypeRef std::vector<TSWPLineRef>::__construct_one_at_end[abi:ne180100]<TSWPLineRef const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  CFTypeRef result;

  v3 = *(_QWORD *)(a1 + 8);
  result = *(CFTypeRef *)a2;
  *(_QWORD *)v3 = *(_QWORD *)a2;
  *(_OWORD *)(v3 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(v3 + 24) = *(_OWORD *)(a2 + 24);
  *(_DWORD *)(v3 + 40) = *(_DWORD *)(a2 + 40);
  if (result)
    result = CFRetain(result);
  *(_QWORD *)(a1 + 8) = v3 + 48;
  return result;
}

void sub_217B5D438(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>,std::reverse_iterator<TSWPLineRef*>,std::reverse_iterator<TSWPLineRef*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  const void *v10;
  const void *v11;
  uint64_t v12;
  _QWORD v14[3];
  char v15;
  __int128 v16;
  __int128 v17;

  v7 = a7;
  *(_QWORD *)&v17 = a6;
  *((_QWORD *)&v17 + 1) = a7;
  v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  v14[2] = &v17;
  v15 = 0;
  if (a3 == a5)
  {
    v12 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v11 = *(const void **)(v9 - 48);
      v9 -= 48;
      v10 = v11;
      *(_QWORD *)(v7 - 48) = v11;
      *(_OWORD *)(v7 - 40) = *(_OWORD *)(v9 + 8);
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(v9 + 24);
      *(_DWORD *)(v7 - 8) = *(_DWORD *)(v9 + 40);
      if (v11)
        CFRetain(v10);
      v7 = *((_QWORD *)&v17 + 1) - 48;
      *((_QWORD *)&v17 + 1) -= 48;
    }
    while (v9 != a5);
    v12 = v17;
  }
  v15 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v14);
  return v12;
}

void sub_217B5D4FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>>::operator()[abi:ne180100](uint64_t *a1)
{
  CFTypeRef *v1;
  CFTypeRef *v2;
  uint64_t v3;

  v1 = *(CFTypeRef **)(a1[2] + 8);
  v2 = *(CFTypeRef **)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<TSWPLineRef>::destroy[abi:ne180100](v3, v1);
      v1 += 6;
    }
    while (v1 != v2);
  }
}

void std::__split_buffer<TSWPLineRef>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 48;
    std::allocator<TSWPLineRef>::destroy[abi:ne180100](v4, (CFTypeRef *)(i - 48));
  }
}

uint64_t std::vector<TSWPAdornmentLine>::__push_back_slow_path<TSWPAdornmentLine const&>(uint64_t *a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  void *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t *v14;

  v3 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  v4 = v3 + 1;
  if (v3 + 1 > 0x333333333333333)
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  if (0x999999999999999ALL * ((a1[2] - *a1) >> 4) > v4)
    v4 = 0x999999999999999ALL * ((a1[2] - *a1) >> 4);
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 4) >= 0x199999999999999)
    v6 = 0x333333333333333;
  else
    v6 = v4;
  v14 = a1 + 2;
  if (v6)
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPAdornmentLine>>((uint64_t)(a1 + 2), v6);
  else
    v7 = 0;
  v10 = v7;
  v11 = &v7[80 * v3];
  v13 = &v7[80 * v6];
  std::allocator<TSWPAdornmentLine>::construct[abi:ne180100]<TSWPAdornmentLine,TSWPAdornmentLine const&>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  v12 = v11 + 80;
  std::vector<TSWPAdornmentLine>::__swap_out_circular_buffer(a1, &v10);
  v8 = a1[1];
  std::__split_buffer<TSWPAdornmentLine>::~__split_buffer(&v10);
  return v8;
}

void sub_217B5D6D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSWPAdornmentLine>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

id std::allocator<TSWPAdornmentLine>::construct[abi:ne180100]<TSWPAdornmentLine,TSWPAdornmentLine const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CGColor *v4;

  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a3 + 16);
  v4 = *(CGColor **)(a3 + 24);
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a3 + 40);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a3 + 48);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a3 + 56);
  *(_BYTE *)(a2 + 64) = *(_BYTE *)(a3 + 64);
  *(_QWORD *)(a2 + 72) = *(_QWORD *)(a3 + 72);
  CGColorRetain(v4);
  return *(id *)(a2 + 72);
}

uint64_t std::vector<TSWPAdornmentLine>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPAdornmentLine>,std::reverse_iterator<TSWPAdornmentLine*>,std::reverse_iterator<TSWPAdornmentLine*>,std::reverse_iterator<TSWPAdornmentLine*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPAdornmentLine>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x333333333333334)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(80 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPAdornmentLine>,std::reverse_iterator<TSWPAdornmentLine*>,std::reverse_iterator<TSWPAdornmentLine*>,std::reverse_iterator<TSWPAdornmentLine*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  __int128 v15;
  __int128 v16;

  v7 = a7;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  v14 = 0;
  if (a3 == a5)
  {
    v11 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v9 -= 80;
      std::allocator<TSWPAdornmentLine>::construct[abi:ne180100]<TSWPAdornmentLine,TSWPAdornmentLine const&>(a1, v7 - 80, v9);
      v7 = *((_QWORD *)&v16 + 1) - 80;
      *((_QWORD *)&v16 + 1) -= 80;
    }
    while (v9 != a5);
    v11 = v16;
  }
  v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentLine>,std::reverse_iterator<TSWPAdornmentLine*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

void sub_217B5D8BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentLine>,std::reverse_iterator<TSWPAdornmentLine*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentLine>,std::reverse_iterator<TSWPAdornmentLine*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentLine>,std::reverse_iterator<TSWPAdornmentLine*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentLine>,std::reverse_iterator<TSWPAdornmentLine*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100](v3, v1);
      v1 += 80;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<TSWPAdornmentLine>::~__split_buffer(void **a1)
{
  std::__split_buffer<TSWPAdornmentLine>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<TSWPAdornmentLine>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 80;
    std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100](v4, i - 80);
  }
}

uint64_t std::vector<TSWPAdornments>::__push_back_slow_path<TSWPAdornments const&>(uint64_t *a1, const TSWPAdornments *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v13;
  TSWPAdornments *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0x8F5C28F5C28F5C29 * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0x147AE147AE147AELL)
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x8F5C28F5C28F5C29 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0xA3D70A3D70A3D7)
    v9 = 0x147AE147AE147AELL;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPAdornments>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (TSWPAdornments *)&v10[200 * v4];
  v16 = &v10[200 * v9];
  TSWPAdornments::TSWPAdornments(v14, a2);
  v15 = (char *)v14 + 200;
  std::vector<TSWPAdornments>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<TSWPAdornments>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_217B5DAD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSWPAdornments>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<unsigned short>::__init_with_size[abi:ne180100]<unsigned short *,unsigned short *>(_QWORD *result, const void *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<unsigned short>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_217B5DB40(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<CGRect>::__init_with_size[abi:ne180100]<CGRect*,CGRect*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<boost::polygon::segment_data<double>>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_217B5DBB8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<TSWPAttachmentPosition>::__init_with_size[abi:ne180100]<TSWPAttachmentPosition*,TSWPAttachmentPosition*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CGPoint>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_217B5DC30(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPAdornments>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x147AE147AE147AFLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(200 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPAdornments>,std::reverse_iterator<TSWPAdornments*>,std::reverse_iterator<TSWPAdornments*>,std::reverse_iterator<TSWPAdornments*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  TSWPAdornments *v12;

  v10 = 0;
  v11 = a7 - 200;
  while (a3 + v10 != a5)
  {
    v12 = (TSWPAdornments *)(v11 + v10);
    v10 -= 200;
    TSWPAdornments::TSWPAdornments(v12, (const TSWPAdornments *)(v10 + a3));
  }
  return a6;
}

void ___ZL19TSWPPlaceholderFontv_block_invoke()
{
  if (!TSWPPlaceholderFont(void)::placeholderFont)
    TSWPPlaceholderFont(void)::placeholderFont = (uint64_t)CTFontCreateUIFontForLanguage(kCTFontUIFontSystem, 1.0, 0);
}

uint64_t ___ZL17iOSIsGreaterThan7v_block_invoke()
{
  uint64_t result;

  result = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x24BDF69C8], "currentDevice"), "systemVersion"), "compare:options:", CFSTR("7.0.2"), 64);
  iOSIsGreaterThan7(void)::result = result == 1;
  return result;
}

_QWORD *std::shared_ptr<TSWPParagraphTypesetter>::shared_ptr[abi:ne180100]<TSWPParagraphTypesetter,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_24D82E720;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_217B5DE00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<TSWPParagraphTypesetter>::reset[abi:ne180100]((TSWPParagraphTypesetter **)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<TSWPParagraphTypesetter *,std::shared_ptr<TSWPParagraphTypesetter>::__shared_ptr_default_delete<TSWPParagraphTypesetter,TSWPParagraphTypesetter>,std::allocator<TSWPParagraphTypesetter>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x219A153B8);
}

TSWPParagraphTypesetter *std::unique_ptr<TSWPParagraphTypesetter>::reset[abi:ne180100](TSWPParagraphTypesetter **a1, TSWPParagraphTypesetter *a2)
{
  TSWPParagraphTypesetter *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    TSWPParagraphTypesetter::~TSWPParagraphTypesetter(result);
    JUMPOUT(0x219A153B8);
  }
  return result;
}

uint64_t std::vector<TSWPUIAttachmentData>::__push_back_slow_path<TSWPUIAttachmentData const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t *v15;

  v3 = (a1[1] - *a1) >> 5;
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 59)
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  v6 = a1[2] - *a1;
  if (v6 >> 4 > v4)
    v4 = v6 >> 4;
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFE0)
    v7 = 0x7FFFFFFFFFFFFFFLL;
  else
    v7 = v4;
  v15 = a1 + 2;
  if (v7)
    v8 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>((uint64_t)(a1 + 2), v7);
  else
    v8 = 0;
  v11 = v8;
  v12 = &v8[32 * v3];
  v14 = &v8[32 * v7];
  std::allocator<TSWPUIAttachmentData>::construct[abi:ne180100]<TSWPUIAttachmentData,TSWPUIAttachmentData const&>((uint64_t)(a1 + 2), (uint64_t)v12, a2);
  v13 = v12 + 32;
  std::vector<TSWPUIAttachmentData>::__swap_out_circular_buffer(a1, &v11);
  v9 = a1[1];
  std::__split_buffer<TSWPUIAttachmentData>::~__split_buffer((uint64_t)&v11);
  return v9;
}

void sub_217B5DF54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSWPUIAttachmentData>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

id std::allocator<TSWPUIAttachmentData>::construct[abi:ne180100]<TSWPUIAttachmentData,TSWPUIAttachmentData const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;
  void *v5;
  uint64_t v6;

  v3 = *(void **)a3;
  *(_QWORD *)a2 = *(_QWORD *)a3;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a3 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a3 + 24);
  if (!v3)
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPUIAttachmentData::TSWPUIAttachmentData(const TSWPUIAttachmentData &)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.h"), 65, CFSTR("invalid nil value for '%s'"), "_attachment");
    v3 = *(void **)a2;
  }
  return v3;
}

uint64_t std::vector<TSWPUIAttachmentData>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<TSWPUIAttachmentData*>,std::reverse_iterator<TSWPUIAttachmentData*>,std::reverse_iterator<TSWPUIAttachmentData*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<TSWPUIAttachmentData*>,std::reverse_iterator<TSWPUIAttachmentData*>,std::reverse_iterator<TSWPUIAttachmentData*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  __int128 v15;
  __int128 v16;

  v7 = a7;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  v14 = 0;
  if (a3 == a5)
  {
    v11 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v9 -= 32;
      std::allocator<TSWPUIAttachmentData>::construct[abi:ne180100]<TSWPUIAttachmentData,TSWPUIAttachmentData const&>(a1, v7 - 32, v9);
      v7 = *((_QWORD *)&v16 + 1) - 32;
      *((_QWORD *)&v16 + 1) -= 32;
    }
    while (v9 != a5);
    v11 = v16;
  }
  v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<TSWPUIAttachmentData*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

void sub_217B5E13C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<TSWPUIAttachmentData*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<TSWPUIAttachmentData*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<TSWPUIAttachmentData*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<TSWPUIAttachmentData*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v8[8];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[8];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v2 = v1[1];
  v14 = v3;
  v15 = v2;
  v16 = v3;
  v17 = v2;
  v4 = *a1;
  v5 = (uint64_t *)a1[1];
  v7 = *v5;
  v6 = v5[1];
  v9 = v7;
  v10 = v6;
  v11 = v7;
  v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<std::reverse_iterator<TSWPUIAttachmentData*>>,std::reverse_iterator<std::reverse_iterator<TSWPUIAttachmentData*>>>(v4, (uint64_t)v13, (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<TSWPUIAttachmentData>,std::reverse_iterator<std::reverse_iterator<TSWPUIAttachmentData*>>,std::reverse_iterator<std::reverse_iterator<TSWPUIAttachmentData*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id *i;

  for (i = *(id **)(a2 + 32); i != *(id **)(a3 + 32); *(_QWORD *)(a2 + 32) = i)
  {

    i = (id *)(*(_QWORD *)(a2 + 32) + 32);
  }
}

uint64_t std::__split_buffer<TSWPUIAttachmentData>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<TSWPUIAttachmentData>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<TSWPUIAttachmentData>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  void *v5;

  while (1)
  {
    v4 = *(_QWORD *)(a1 + 16);
    if (v4 == a2)
      break;
    v5 = *(void **)(v4 - 32);
    *(_QWORD *)(a1 + 16) = v4 - 32;

  }
}

BOOL isUpwardFacingCJKCharacterInVerticalMode(UChar32 a1)
{
  unsigned int IntPropertyValue;
  _BOOL8 result;
  unsigned int v4;
  UBlockCode Code;

  IntPropertyValue = u_getIntPropertyValue(a1, UCHAR_SCRIPT);
  result = 1;
  if (IntPropertyValue > 0x36 || ((1 << IntPropertyValue) & 0x40020008560020) == 0)
  {
    v4 = IntPropertyValue - 73;
    if (v4 > 0x3A || ((1 << v4) & 0x400400100000003) == 0)
    {
      Code = ublock_getCode(a1);
      result = 0;
      switch(Code)
      {
        case UBLOCK_ARROWS:
        case UBLOCK_ENCLOSED_ALPHANUMERICS:
        case UBLOCK_BOX_DRAWING:
        case UBLOCK_BLOCK_ELEMENTS:
        case UBLOCK_GEOMETRIC_SHAPES:
        case UBLOCK_MISCELLANEOUS_SYMBOLS:
        case UBLOCK_DINGBATS:
        case UBLOCK_CJK_RADICALS_SUPPLEMENT:
        case UBLOCK_CJK_SYMBOLS_AND_PUNCTUATION:
        case UBLOCK_HIRAGANA:
        case UBLOCK_KATAKANA:
        case UBLOCK_BOPOMOFO:
        case UBLOCK_HANGUL_COMPATIBILITY_JAMO:
        case UBLOCK_BOPOMOFO_EXTENDED:
        case UBLOCK_ENCLOSED_CJK_LETTERS_AND_MONTHS:
        case UBLOCK_CJK_COMPATIBILITY:
        case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A:
        case UBLOCK_CJK_UNIFIED_IDEOGRAPHS:
        case UBLOCK_YI_SYLLABLES:
        case UBLOCK_YI_RADICALS:
        case UBLOCK_HANGUL_SYLLABLES:
        case UBLOCK_LOW_SURROGATES:
        case UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS:
        case UBLOCK_CJK_COMPATIBILITY_FORMS:
        case UBLOCK_HALFWIDTH_AND_FULLWIDTH_FORMS:
        case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B:
        case UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT:
        case UBLOCK_SUPPLEMENTAL_ARROWS_A:
        case UBLOCK_SUPPLEMENTAL_ARROWS_B:
        case UBLOCK_KATAKANA_PHONETIC_EXTENSIONS:
        case UBLOCK_MISCELLANEOUS_SYMBOLS_AND_ARROWS:
        case UBLOCK_TAI_XUAN_JING_SYMBOLS:
          goto LABEL_7;
        case UBLOCK_MATHEMATICAL_OPERATORS:
        case UBLOCK_MISCELLANEOUS_TECHNICAL:
        case UBLOCK_CONTROL_PICTURES:
        case UBLOCK_OPTICAL_CHARACTER_RECOGNITION:
        case UBLOCK_BRAILLE_PATTERNS:
        case UBLOCK_KANGXI_RADICALS:
        case UBLOCK_IDEOGRAPHIC_DESCRIPTION_CHARACTERS:
        case UBLOCK_KANBUN:
        case UBLOCK_HIGH_SURROGATES:
        case UBLOCK_HIGH_PRIVATE_USE_SURROGATES:
        case UBLOCK_PRIVATE_USE_AREA:
        case UBLOCK_ALPHABETIC_PRESENTATION_FORMS:
        case UBLOCK_ARABIC_PRESENTATION_FORMS_A:
        case UBLOCK_COMBINING_HALF_MARKS:
        case UBLOCK_SMALL_FORM_VARIANTS:
        case UBLOCK_ARABIC_PRESENTATION_FORMS_B:
        case UBLOCK_SPECIALS:
        case UBLOCK_OLD_ITALIC:
        case UBLOCK_GOTHIC:
        case UBLOCK_DESERET:
        case UBLOCK_BYZANTINE_MUSICAL_SYMBOLS:
        case UBLOCK_MUSICAL_SYMBOLS:
        case UBLOCK_MATHEMATICAL_ALPHANUMERIC_SYMBOLS:
        case UBLOCK_TAGS:
        case UBLOCK_CYRILLIC_SUPPLEMENT:
        case UBLOCK_TAGALOG:
        case UBLOCK_HANUNOO:
        case UBLOCK_BUHID:
        case UBLOCK_TAGBANWA:
        case UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A:
        case UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B:
        case UBLOCK_SUPPLEMENTAL_MATHEMATICAL_OPERATORS:
        case UBLOCK_VARIATION_SELECTORS:
        case UBLOCK_SUPPLEMENTARY_PRIVATE_USE_AREA_A:
        case UBLOCK_SUPPLEMENTARY_PRIVATE_USE_AREA_B:
        case UBLOCK_LIMBU:
        case UBLOCK_TAI_LE:
        case UBLOCK_KHMER_SYMBOLS:
        case UBLOCK_PHONETIC_EXTENSIONS:
        case UBLOCK_YIJING_HEXAGRAM_SYMBOLS:
        case UBLOCK_LINEAR_B_SYLLABARY:
        case UBLOCK_LINEAR_B_IDEOGRAMS:
        case UBLOCK_AEGEAN_NUMBERS:
        case UBLOCK_UGARITIC:
        case UBLOCK_SHAVIAN:
        case UBLOCK_OSMANYA:
        case UBLOCK_CYPRIOT_SYLLABARY:
          return result;
        default:
          if ((Code - 145) <= 0x1A && ((1 << (Code + 111)) & 0x6000201) != 0 || Code == UBLOCK_MONGOLIAN)
LABEL_7:
            result = a1 != 12540 && a1 != 65392;
          break;
      }
    }
  }
  return result;
}

uint64_t TSWPIsPotentialTateChuYokoCharacter(uint64_t a1)
{
  if (TSWPIsPotentialTateChuYokoCharacter::s_predicate != -1)
    dispatch_once(&TSWPIsPotentialTateChuYokoCharacter::s_predicate, &__block_literal_global_78);
  return objc_msgSend((id)TSWPIsPotentialTateChuYokoCharacter::_tateChuYokoCharacterSet, "longCharacterIsMember:", a1);
}

uint64_t TSWPNormalWidthCharacterForCharacter(uint64_t result)
{
  if ((result - 65296) < 0xA)
    goto LABEL_2;
  if ((int)result > 65504)
  {
    if ((_DWORD)result == 65505)
    {
      LOWORD(result) = 163;
    }
    else if ((_DWORD)result == 65509)
    {
      LOWORD(result) = 165;
    }
  }
  else
  {
    if ((_DWORD)result == 65284)
    {
LABEL_2:
      LOWORD(result) = result + 288;
      return (unsigned __int16)result;
    }
    if ((_DWORD)result == 65504)
      LOWORD(result) = 162;
  }
  return (unsigned __int16)result;
}

uint64_t TSWPFullWidthCharacterForCharacter(uint64_t result)
{
  if ((result - 48) < 0xA)
    goto LABEL_2;
  if ((int)result > 162)
  {
    if ((_DWORD)result == 163)
    {
      LOWORD(result) = -31;
    }
    else if ((_DWORD)result == 165)
    {
      LOWORD(result) = -27;
    }
  }
  else
  {
    if ((_DWORD)result == 36)
    {
LABEL_2:
      LOWORD(result) = result - 288;
      return (unsigned __int16)result;
    }
    if ((_DWORD)result == 162)
      LOWORD(result) = -32;
  }
  return (unsigned __int16)result;
}

void TSWPFillVerticalFacingRangesFromBuffer(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  _BOOL4 v11;
  unint64_t v12;
  int v14;
  BOOL v15;
  int v16;
  int v17;
  _QWORD *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  __int128 v31;
  uint64_t v32;
  char *v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  __int128 v42;
  _QWORD *v43;

  if (a2)
  {
    v6 = 0;
    v7 = 0;
    v43 = a3 + 2;
    do
    {
      v8 = *(unsigned __int16 *)(a1 + 2 * v6);
      v9 = v8 & 0xFC00;
      v11 = v9 == 55296 || v9 == 56320;
      v12 = v7 + 1;
      if (v12 >= a2 || !v11)
      {
        ++v7;
      }
      else
      {
        v14 = *(unsigned __int16 *)(a1 + 2 * v12);
        v15 = v9 == 55296;
        if (v9 == 55296)
          v16 = *(unsigned __int16 *)(a1 + 2 * v6);
        else
          v16 = v14;
        if (!v15)
          v14 = *(unsigned __int16 *)(a1 + 2 * v6);
        v8 = (v14 + (v16 << 10) - 56613888);
        v7 += 2;
      }
      if (isUpwardFacingCJKCharacterInVerticalMode(v8))
        v17 = 1;
      else
        v17 = TSWPIsPotentialTateChuYokoCharacter(v8);
      v18 = v43;
      v19 = (char *)*a3;
      v20 = (char *)a3[1];
      v21 = (uint64_t)&v20[-*a3] / 24;
      if (v20 == (char *)*a3)
      {
        if ((unint64_t)v20 >= *v43)
        {
          v22 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v43 - (_QWORD)v19) >> 3);
          v23 = 2 * v22;
          if (2 * v22 <= v21 + 1)
            v23 = v21 + 1;
          if (v22 >= 0x555555555555555)
            v24 = 0xAAAAAAAAAAAAAAALL;
          else
            v24 = v23;
          v25 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)v43, v24);
          v27 = &v25[24 * v21];
          *(_QWORD *)v27 = 0;
          *((_QWORD *)v27 + 1) = 0;
          v27[16] = v17;
          v29 = (char *)*a3;
          v28 = (char *)a3[1];
          v30 = v27;
          if (v28 != (char *)*a3)
          {
            do
            {
              v31 = *(_OWORD *)(v28 - 24);
              *((_QWORD *)v30 - 1) = *((_QWORD *)v28 - 1);
              *(_OWORD *)(v30 - 24) = v31;
              v30 -= 24;
              v28 -= 24;
            }
            while (v28 != v29);
            v28 = (char *)*a3;
          }
          v20 = v27 + 24;
          *a3 = v30;
          a3[1] = v27 + 24;
          a3[2] = &v25[24 * v26];
          if (v28)
            operator delete(v28);
          v18 = v43;
        }
        else
        {
          *(_QWORD *)v20 = 0;
          *((_QWORD *)v20 + 1) = 0;
          v20[16] = v17;
          v20 += 24;
        }
        a3[1] = v20;
        v19 = (char *)*a3;
        v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v20[-*a3] >> 3);
      }
      if (v19[24 * v21 - 8] == v17)
      {
        *(_QWORD *)&v19[24 * v21 - 16] = v7 - *(_QWORD *)&v19[24 * v21 - 24];
      }
      else
      {
        v32 = v7 - v6;
        if ((unint64_t)v20 >= *v18)
        {
          if ((unint64_t)(v21 + 1) > 0xAAAAAAAAAAAAAAALL)
            abort();
          v34 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v18 - (_QWORD)v19) >> 3);
          v35 = 2 * v34;
          if (2 * v34 <= v21 + 1)
            v35 = v21 + 1;
          if (v34 >= 0x555555555555555)
            v36 = 0xAAAAAAAAAAAAAAALL;
          else
            v36 = v35;
          if (v36)
            v37 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)v18, v36);
          else
            v37 = 0;
          v38 = &v37[24 * v21];
          *(_QWORD *)v38 = v6;
          *((_QWORD *)v38 + 1) = v32;
          v38[16] = v17;
          v40 = (char *)*a3;
          v39 = (char *)a3[1];
          v41 = v38;
          if (v39 != (char *)*a3)
          {
            do
            {
              v42 = *(_OWORD *)(v39 - 24);
              *((_QWORD *)v41 - 1) = *((_QWORD *)v39 - 1);
              *(_OWORD *)(v41 - 24) = v42;
              v41 -= 24;
              v39 -= 24;
            }
            while (v39 != v40);
            v39 = (char *)*a3;
          }
          v33 = v38 + 24;
          *a3 = v41;
          a3[1] = v38 + 24;
          a3[2] = &v37[24 * v36];
          if (v39)
            operator delete(v39);
        }
        else
        {
          *(_QWORD *)v20 = v6;
          *((_QWORD *)v20 + 1) = v32;
          v33 = v20 + 24;
          v20[16] = v17;
        }
        a3[1] = v33;
      }
      v6 = v7;
    }
    while (v7 < a2);
  }
}

uint64_t TSWPScriptForCharacter(UChar32 a1)
{
  UBlockCode Code;
  uint64_t result;

  Code = ublock_getCode(a1);
  result = 0;
  if (Code <= UBLOCK_CJK_SYMBOLS_AND_PUNCTUATION)
  {
    switch(Code)
    {
      case UBLOCK_BASIC_LATIN:
      case UBLOCK_LATIN_1_SUPPLEMENT:
      case UBLOCK_LATIN_EXTENDED_A:
      case UBLOCK_LATIN_EXTENDED_B:
        return 2;
      case UBLOCK_IPA_EXTENSIONS:
      case UBLOCK_SPACING_MODIFIER_LETTERS:
      case UBLOCK_COMBINING_DIACRITICAL_MARKS:
      case UBLOCK_GREEK:
      case UBLOCK_ARMENIAN:
        return result;
      case UBLOCK_CYRILLIC:
        return 9;
      case UBLOCK_HEBREW:
        return 8;
      case UBLOCK_ARABIC:
        return 7;
      default:
        if (Code == UBLOCK_HANGUL_JAMO)
          return 10;
        if (Code != UBLOCK_LATIN_EXTENDED_ADDITIONAL)
          return result;
        break;
    }
    return 2;
  }
  if (Code <= UBLOCK_MATHEMATICAL_ALPHANUMERIC_SYMBOLS)
  {
    switch(Code)
    {
      case UBLOCK_HIRAGANA:
        result = 3;
        break;
      case UBLOCK_KATAKANA:
        return 4;
      case UBLOCK_BOPOMOFO:
      case UBLOCK_BOPOMOFO_EXTENDED:
        result = 5;
        break;
      case UBLOCK_HANGUL_COMPATIBILITY_JAMO:
      case UBLOCK_HANGUL_SYLLABLES:
        return 10;
      case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A:
      case UBLOCK_CJK_UNIFIED_IDEOGRAPHS:
        return 6;
      default:
        return result;
    }
    return result;
  }
  if ((Code - 148) < 2)
    return 2;
  if (Code == UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B)
    return 6;
  if (Code == UBLOCK_KATAKANA_PHONETIC_EXTENSIONS)
    return 4;
  return result;
}

uint64_t TSWPBackgroundInit()
{
  void *v0;
  uint64_t v1;

  if (objc_msgSend(MEMORY[0x24BDD17F0], "isMainThread"))
  {
    v0 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v1 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPBackgroundInit()");
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v1, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 442, CFSTR("TSWPBackgroundInit should be called on a background thread"));
  }
  return -[TSWPLoadableFonts backgroundLoadAll](+[TSWPLoadableFonts sharedInstance](TSWPLoadableFonts, "sharedInstance"), "backgroundLoadAll");
}

BOOL TSWPFontNameIsValid(uint64_t a1)
{
  _BOOL8 v1;
  const __CTFont *v2;
  const __CTFont *v3;
  CFStringRef v4;
  CFStringRef v5;

  v1 = a1;
  if (a1)
  {
    v2 = (const __CTFont *)TSWPCreateFontWithNameAttributesAndWeight(a1, 0, 12.0, *MEMORY[0x24BDF7888]);
    if (v2)
    {
      v3 = v2;
      v4 = CTFontCopyPostScriptName(v2);
      if (v4)
      {
        v5 = v4;
        v1 = CFEqual((CFTypeRef)v1, v4) != 0;
        CFRelease(v3);
        v3 = (const __CTFont *)v5;
      }
      else
      {
        v1 = 0;
      }
      CFRelease(v3);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t TSWPCreateFontWithName(uint64_t a1, double a2)
{
  return TSWPCreateFontWithNameAttributesAndWeight(a1, 0, a2, *MEMORY[0x24BDF7888]);
}

uint64_t TSWPPageBreakString()
{
  return objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%C"), 5);
}

uint64_t TSWPLineBreakString()
{
  return objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%C"), 8232);
}

const __CTFont *TSWPCreateFontWithFamilyName(uint64_t a1, int a2, int a3, CGFloat a4)
{
  int v5;
  CTFontSymbolicTraits v6;
  const __CTFontDescriptor *v7;
  const __CTFont *v8;
  CTFontRef CopyWithSymbolicTraits;
  CTFontRef v10;
  uint64_t v12;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x24BDAC8D0];
  if (a2)
    v5 = 2;
  else
    v5 = 0;
  v6 = v5 | a3;
  v12 = *MEMORY[0x24BDC4D08];
  v13[0] = a1;
  v7 = CTFontDescriptorCreateWithAttributes((CFDictionaryRef)objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v13, &v12, 1));
  v8 = CTFontCreateWithFontDescriptor(v7, a4, 0);
  CFRelease(v7);
  if ((CTFontGetSymbolicTraits(v8) & 3) != v6)
  {
    if (v8)
    {
      CopyWithSymbolicTraits = CTFontCreateCopyWithSymbolicTraits(v8, a4, 0, v6, 3u);
      if (CopyWithSymbolicTraits)
      {
        v10 = CopyWithSymbolicTraits;
        CFRelease(v8);
        return v10;
      }
    }
  }
  return v8;
}

uint64_t TSWPCreateUIFontWithName(uint64_t result, double a2)
{
  uint64_t v3;

  if (result)
  {
    v3 = result;
    -[TSWPLoadableFonts loadFontWithName:](+[TSWPLoadableFonts sharedInstance](TSWPLoadableFonts, "sharedInstance"), "loadFontWithName:", result);
    return objc_msgSend(MEMORY[0x24BDF6A70], "fontWithName:size:", v3, a2);
  }
  return result;
}

const __CTFont *TSWPFontCopyGraphicsFont()
{
  const __CTFont *result;

  CTFontGetTypeID();
  result = (const __CTFont *)TSUCFTypeCast();
  if (result)
    return CTFontCopyGraphicsFont(result, 0);
  return result;
}

const __CTFont *TSWPUIFontForCTFont(const __CTFont *result)
{
  const __CTFont *v1;
  double Size;

  if (result)
  {
    v1 = result;
    Size = CTFontGetSize(result);
    result = (const __CTFont *)objc_msgSend(MEMORY[0x24BDF6A70], "fontWithName:size:", (id)CTFontCopyPostScriptName(v1), Size);
    if (!result)
      return (const __CTFont *)objc_msgSend(MEMORY[0x24BDF6A70], "systemFontOfSize:", Size);
  }
  return result;
}

__CFString *TSWPFontPostScriptNameForFamilyName(void *a1)
{
  const __CTFontDescriptor *v2;
  const __CTFont *v3;
  const __CTFont *v4;
  CFStringRef v5;
  CFStringRef v6;
  __CFString *v7;
  __CFString *v8;
  uint64_t v10;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x24BDAC8D0];
  v10 = *MEMORY[0x24BDC4D08];
  v11[0] = a1;
  v2 = CTFontDescriptorCreateWithAttributes((CFDictionaryRef)objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v11, &v10, 1));
  v3 = CTFontCreateWithFontDescriptor(v2, 0.0, 0);
  if (!v3)
  {
    v8 = 0;
    if (!v2)
      return v8;
    goto LABEL_12;
  }
  v4 = v3;
  v5 = CTFontCopyFamilyName(v3);
  if (v5)
  {
    v6 = v5;
    if (objc_msgSend(a1, "isEqualToString:", v5)
      && (v7 = (__CFString *)CTFontCopyPostScriptName(v4)) != 0)
    {
      v8 = v7;
    }
    else
    {
      v8 = 0;
    }
    CFRelease(v6);
  }
  else
  {
    v8 = 0;
  }
  CFRelease(v4);
  if (v2)
LABEL_12:
    CFRelease(v2);
  return v8;
}

const __CFString *TSWPFontNameWithFamilyName(uint64_t a1, int a2, int a3)
{
  const __CFString *v3;
  const __CTFont *v4;
  const __CTFont *v5;

  v3 = (const __CFString *)a1;
  v4 = TSWPCreateFontWithFamilyName(a1, a2, a3, 12.0);
  if (v4)
  {
    v5 = v4;
    v3 = (id)CTFontCopyFullName(v4);
    CFRelease(v5);
  }
  return v3;
}

CFTypeRef TSWPFontFamilyNameForFontName(uint64_t a1)
{
  const __CTFontDescriptor *v1;
  const __CTFontDescriptor *v2;
  CFTypeRef v3;
  void *v4;
  uint64_t v5;
  uint64_t v7;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSWPFontFamilyNameForFontName(NSString *)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 716, CFSTR("invalid nil value for '%s'"), "fontName");
    return 0;
  }
  v7 = *MEMORY[0x24BDC4D70];
  v8[0] = a1;
  v1 = CTFontDescriptorCreateWithAttributes((CFDictionaryRef)objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v8, &v7, 1));
  if (!v1)
    return 0;
  v2 = v1;
  v3 = (id)CTFontDescriptorCopyAttribute(v1, (CFStringRef)*MEMORY[0x24BDC4D08]);
  CFRelease(v2);
  return v3;
}

BOOL TSWPFontHasTraits(const __CTFont *a1, int a2)
{
  const __CTFont *v3;

  CTFontGetTypeID();
  v3 = (const __CTFont *)TSUCFTypeCast();
  if (v3)
    LODWORD(v3) = CTFontGetSymbolicTraits(v3);
  return (a2 & ~(_DWORD)v3) == 0;
}

BOOL TSWPFontIsBold(const __CTFont *a1)
{
  return TSWPFontHasTraits(a1, 2);
}

BOOL TSWPFontIsItalic(const __CTFont *a1)
{
  return TSWPFontHasTraits(a1, 1);
}

BOOL TSWPFontIsSymbolic(const __CTFont *a1)
{
  return TSWPFontHasTraits(a1, -1073741824);
}

uint64_t TSWPFontGetAttributes(uint64_t a1, uint64_t *a2, BOOL *a3, _BYTE *a4, CGFloat *a5)
{
  uint64_t result;
  const __CTFont *v10;

  CTFontGetTypeID();
  result = TSUCFTypeCast();
  if (result)
  {
    v10 = (const __CTFont *)result;
    if (a5)
      *a5 = CTFontGetSize((CTFontRef)result);
    result = CTFontGetSymbolicTraits(v10);
    *a3 = (result & 2) != 0;
    *a4 = result & 1;
    if (a2)
    {
      result = (id)CTFontCopyFullName(v10);
LABEL_10:
      *a2 = result;
    }
  }
  else
  {
    if (a5)
      *a5 = 0.0;
    *a4 = 0;
    *a3 = 0;
    if (a2)
    {
      result = 0;
      goto LABEL_10;
    }
  }
  return result;
}

void TSWPFontGetLineHeight()
{
  const __CTFont *v0;
  const __CTFont *v1;

  CTFontGetTypeID();
  v0 = (const __CTFont *)TSUCFTypeCast();
  if (v0)
  {
    v1 = v0;
    CTFontGetAscent(v0);
    CTFontGetDescent(v1);
    CTFontGetLeading(v1);
  }
}

uint64_t TSWPFontFamilyNames()
{
  uint64_t result;
  const __CTFontCollection *v1;
  const __CTFontCollection *v2;
  CFArrayRef MatchingFontDescriptors;
  CFArrayRef v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const __CFString *v8;
  uint64_t v9;
  CFTypeRef v10;
  const void *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x24BDAC8D0];
  result = TSWPFontFamilyNames::fontNames;
  if (!TSWPFontFamilyNames::fontNames)
  {
    -[TSWPLoadableFonts loadAll](+[TSWPLoadableFonts sharedInstance](TSWPLoadableFonts, "sharedInstance"), "loadAll");
    TSWPFontFamilyNames::fontNames = (uint64_t)objc_alloc_init(MEMORY[0x24BDBCEB8]);
    v17 = *MEMORY[0x24BDC4C40];
    v18[0] = MEMORY[0x24BDBD1C8];
    v1 = CTFontCollectionCreateFromAvailableFonts((CFDictionaryRef)objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v18, &v17, 1));
    if (v1)
    {
      v2 = v1;
      MatchingFontDescriptors = CTFontCollectionCreateMatchingFontDescriptors(v1);
      if (MatchingFontDescriptors)
      {
        v4 = MatchingFontDescriptors;
        v14 = 0u;
        v15 = 0u;
        v12 = 0u;
        v13 = 0u;
        v5 = -[__CFArray countByEnumeratingWithState:objects:count:](MatchingFontDescriptors, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
        if (v5)
        {
          v6 = v5;
          v7 = *(_QWORD *)v13;
          v8 = (const __CFString *)*MEMORY[0x24BDC4D08];
          do
          {
            v9 = 0;
            do
            {
              if (*(_QWORD *)v13 != v7)
                objc_enumerationMutation(v4);
              v10 = CTFontDescriptorCopyAttribute(*(CTFontDescriptorRef *)(*((_QWORD *)&v12 + 1) + 8 * v9), v8);
              if (v10)
              {
                v11 = v10;
                objc_msgSend((id)TSWPFontFamilyNames::fontNames, "addObject:", v10);
                CFRelease(v11);
              }
              ++v9;
            }
            while (v6 != v9);
            v6 = -[__CFArray countByEnumeratingWithState:objects:count:](v4, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
          }
          while (v6);
        }
        CFRelease(v4);
      }
      CFRelease(v2);
    }
    objc_msgSend((id)TSWPFontFamilyNames::fontNames, "sortUsingSelector:", sel_compare_);
    return TSWPFontFamilyNames::fontNames;
  }
  return result;
}

unint64_t TSWPMostCompatibleStringEncodingForFont()
{
  const __CTFont *v0;

  CTFontGetTypeID();
  v0 = (const __CTFont *)TSUCFTypeCast();
  if (v0)
    LODWORD(v0) = CTFontGetStringEncoding(v0);
  return CFStringConvertEncodingToNSStringEncoding((CFStringEncoding)v0);
}

const __CTFont *TSWPCreateSubstituteFontForString(uint64_t a1, __CFString *a2)
{
  CFIndex v3;
  const __CTFont *result;
  CFRange v5;

  v3 = -[__CFString length](a2, "length");
  CTFontGetTypeID();
  result = (const __CTFont *)TSUCFTypeCast();
  if (result)
  {
    v5.location = 0;
    v5.length = v3;
    return CTFontCreateForString(result, a2, v5);
  }
  return result;
}

uint64_t TSWPGlyphForChar(uint64_t a1, UniChar a2)
{
  const __CTFont *v2;
  _BOOL4 GlyphsForCharacters;
  CGGlyph v4;
  CGGlyph glyphs;
  UniChar characters;

  characters = a2;
  glyphs = 0;
  CTFontGetTypeID();
  v2 = (const __CTFont *)TSUCFTypeCast();
  GlyphsForCharacters = CTFontGetGlyphsForCharacters(v2, &characters, &glyphs, 1);
  v4 = glyphs;
  if (!GlyphsForCharacters)
    return (CGGlyph)-1;
  return v4;
}

CGFloat TSWPAdvancementForGlyph(uint64_t a1, CGGlyph a2)
{
  const __CTFont *v2;
  CGGlyph glyphs;
  CGSize advances;

  glyphs = a2;
  CTFontGetTypeID();
  v2 = (const __CTFont *)TSUCFTypeCast();
  CTFontGetAdvancesForGlyphs(v2, kCTFontOrientationDefault, &glyphs, &advances, 1);
  return advances.width;
}

void *TSWPPropertyMapByResolvingFontSizeDeltaInPropertyMapAgainstStyle(void *a1, void *a2)
{
  float v4;
  float v5;
  float v6;
  float v7;
  void *v9;
  double v10;
  void *v11;
  uint64_t v12;

  objc_msgSend(a1, "floatValueForProperty:", 52);
  v5 = v4;
  if (v4 == INFINITY)
    return 0;
  objc_msgSend(a2, "floatValueForProperty:", 17);
  if (v6 == INFINITY)
  {
    v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSSPropertyMap *TSWPPropertyMapByResolvingFontSizeDeltaInPropertyMapAgainstStyle(TSSPropertyMap *, TSSStyle *)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 896, CFSTR("Did not get fontSize property from style: %@"), a2);
    return 0;
  }
  v7 = v5 + v6;
  if (v7 < 9.0 || v7 > 288.0)
    return 0;
  v9 = (void *)objc_msgSend(a1, "propertyMapByRemovingValuesForProperties:", +[TSSPropertySet propertySetWithProperty:](TSSPropertySet, "propertySetWithProperty:", 52));
  *(float *)&v10 = v7;
  objc_msgSend(v9, "setFloatValue:forProperty:", 17, v10);
  return v9;
}

uint64_t TSWPParagraphBreakingCharacterSet()
{
  if (TSWPParagraphBreakingCharacterSet::sTSWPParagraphBreakingCharacterSetOnceToken != -1)
    dispatch_once(&TSWPParagraphBreakingCharacterSet::sTSWPParagraphBreakingCharacterSetOnceToken, &__block_literal_global_21_0);
  return TSWPParagraphBreakingCharacterSet::sParagraphBreakingCharacterSet;
}

uint64_t TSWPFullNameForCharacter(unsigned __int16 a1, int a2)
{
  void *v3;
  const __CFString *v4;

  if (a1 <= 0x2006u)
  {
    if (a1 <= 0x9Fu)
    {
      switch(a1)
      {
        case 4u:
          v3 = (void *)TSWPBundle();
          if (a2)
            v4 = CFSTR("Section Breaks");
          else
            v4 = CFSTR("Section Break");
          return objc_msgSend(v3, "localizedStringForKey:value:table:", v4, &stru_24D82FEB0, CFSTR("TSText"));
        case 5u:
          v3 = (void *)TSWPBundle();
          if (a2)
            v4 = CFSTR("Page Breaks");
          else
            v4 = CFSTR("Page Break");
          return objc_msgSend(v3, "localizedStringForKey:value:table:", v4, &stru_24D82FEB0, CFSTR("TSText"));
        case 6u:
        case 7u:
        case 8u:
          return 0;
        case 9u:
          v3 = (void *)TSWPBundle();
          if (a2)
            v4 = CFSTR("Tabs");
          else
            v4 = CFSTR("Tab");
          return objc_msgSend(v3, "localizedStringForKey:value:table:", v4, &stru_24D82FEB0, CFSTR("TSText"));
        case 0xAu:
        case 0xBu:
        case 0xDu:
          goto LABEL_21;
        case 0xCu:
          v3 = (void *)TSWPBundle();
          if (a2)
            v4 = CFSTR("Column Breaks");
          else
            v4 = CFSTR("Column Break");
          return objc_msgSend(v3, "localizedStringForKey:value:table:", v4, &stru_24D82FEB0, CFSTR("TSText"));
        default:
          if (a1 != 32)
            return 0;
          goto LABEL_13;
      }
    }
    if (a1 - 0x2000 < 7)
      goto LABEL_13;
    if (a1 == 160)
    {
LABEL_29:
      v3 = (void *)TSWPBundle();
      if (a2)
        v4 = CFSTR("Non Breaking Spaces");
      else
        v4 = CFSTR("Non Breaking Space");
      return objc_msgSend(v3, "localizedStringForKey:value:table:", v4, &stru_24D82FEB0, CFSTR("TSText"));
    }
    return 0;
  }
  if (a1 <= 0x2028u)
  {
    if (a1 - 8200 >= 4)
    {
      if (a1 == 8199)
        goto LABEL_29;
      if (a1 == 8232)
      {
        v3 = (void *)TSWPBundle();
        if (a2)
          v4 = CFSTR("Line Breaks");
        else
          v4 = CFSTR("Line Break");
        return objc_msgSend(v3, "localizedStringForKey:value:table:", v4, &stru_24D82FEB0, CFSTR("TSText"));
      }
      return 0;
    }
    goto LABEL_13;
  }
  if (a1 >= 0x3000u)
  {
    if (a1 != 12288)
    {
      if (a1 == 65532)
      {
        v3 = (void *)TSWPBundle();
        if (a2)
          v4 = CFSTR("Attachments");
        else
          v4 = CFSTR("Attachment");
        return objc_msgSend(v3, "localizedStringForKey:value:table:", v4, &stru_24D82FEB0, CFSTR("TSText"));
      }
      if (a1 == 65279)
        goto LABEL_29;
      return 0;
    }
    goto LABEL_13;
  }
  if (a1 != 8233)
  {
    if (a1 == 8239)
      goto LABEL_29;
    if (a1 != 8287)
      return 0;
LABEL_13:
    v3 = (void *)TSWPBundle();
    if (a2)
      v4 = CFSTR("Spaces");
    else
      v4 = CFSTR("Space");
    return objc_msgSend(v3, "localizedStringForKey:value:table:", v4, &stru_24D82FEB0, CFSTR("TSText"));
  }
LABEL_21:
  v3 = (void *)TSWPBundle();
  if (a2)
    v4 = CFSTR("Paragraph Breaks");
  else
    v4 = CFSTR("Paragraph Break");
  return objc_msgSend(v3, "localizedStringForKey:value:table:", v4, &stru_24D82FEB0, CFSTR("TSText"));
}

BOOL isDeletableWithoutCombining(UChar32 a1)
{
  UBlockCode Code;

  Code = ublock_getCode(a1);
  return Code == UBLOCK_ARABIC_SUPPLEMENT || (Code - 11) < 2;
}

uint64_t IsWhitespaceCharacter(uint64_t theChar)
{
  uint64_t result;

  if (IsWhitespaceCharacter::sIsWhitespaceCharacterDispatchOnceToken != -1)
    dispatch_once(&IsWhitespaceCharacter::sIsWhitespaceCharacterDispatchOnceToken, &__block_literal_global_62);
  if (CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)IsWhitespaceCharacter::sWhitespaceCharacterSet, theChar))
    return 1;
  LODWORD(result) = IsParagraphBreakingCharacter(theChar);
  if ((_DWORD)theChar == 8232)
    return 1;
  else
    return result;
}

BOOL IsSpecialCharacter(int a1)
{
  return a1 == 65532 || a1 == 14;
}

BOOL IsBreakingSpaceCharacter(UTF32Char theChar)
{
  const __CFCharacterSet *v2;

  v2 = (const __CFCharacterSet *)IsBreakingSpaceCharacter::sBreakingSpaceCharacterSet;
  if (!IsBreakingSpaceCharacter::sBreakingSpaceCharacterSet)
  {
    v2 = (const __CFCharacterSet *)(id)objc_msgSend(MEMORY[0x24BDD14A8], "breakingSpaceCharacterSet");
    IsBreakingSpaceCharacter::sBreakingSpaceCharacterSet = (uint64_t)v2;
  }
  return CFCharacterSetIsLongCharacterMember(v2, theChar) != 0;
}

uint64_t IsWordBoundaryCharacter(uint64_t a1)
{
  char v2;

  if ((int)a1 <= 8211)
  {
    if (!(_DWORD)a1 || (_DWORD)a1 == 14)
      return 1;
  }
  else if ((_DWORD)a1 == 8212 || (_DWORD)a1 == 8232 || (_DWORD)a1 == 65532)
  {
    return 1;
  }
  v2 = IsParagraphBreakingCharacter(a1);
  if ((_DWORD)a1 != 8232 && (v2 & 1) == 0)
    return objc_msgSend((id)objc_msgSend(MEMORY[0x24BDD14A8], "spaceCharacterSet"), "longCharacterIsMember:", a1);
  return 1;
}

BOOL KinsokuIllegalEndChar(UTF32Char theChar)
{
  if (KinsokuIllegalEndChar::sKinsokuIllegalEndCharDispatchOnceToken != -1)
    dispatch_once(&KinsokuIllegalEndChar::sKinsokuIllegalEndCharDispatchOnceToken, &__block_literal_global_64);
  return CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)KinsokuIllegalEndChar::sSet, theChar) != 0;
}

void ___Z21KinsokuIllegalEndCharj_block_invoke()
{
  const __CFAllocator *v0;
  __CFCharacterSet *Mutable;
  const __CFString *v2;
  const __CFString *v3;
  _OWORD v4[4];
  int v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v4[0] = xmmword_217C2B3B8;
  v4[1] = unk_217C2B3C8;
  v4[2] = xmmword_217C2B3D8;
  v4[3] = unk_217C2B3E8;
  v5 = 10551138;
  v0 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240]);
  v2 = CFStringCreateWithCharacters(v0, (const UniChar *)v4, 34);
  if (v2)
  {
    v3 = v2;
    CFCharacterSetAddCharactersInString(Mutable, v2);
    CFRelease(v3);
  }
  KinsokuIllegalEndChar::sSet = (uint64_t)Mutable;
}

BOOL KinsokuIllegalStartChar(UTF32Char theChar)
{
  if (KinsokuIllegalStartChar::sKinsokuIllegalStartCharDispatchOnceToken != -1)
    dispatch_once(&KinsokuIllegalStartChar::sKinsokuIllegalStartCharDispatchOnceToken, &__block_literal_global_65);
  return CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)KinsokuIllegalStartChar::sSet, theChar) != 0;
}

void ___Z23KinsokuIllegalStartCharj_block_invoke()
{
  const __CFAllocator *v0;
  __CFCharacterSet *Mutable;
  const __CFString *v2;
  const __CFString *v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  unint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v16 = xmmword_217C2B4BC;
  v17 = unk_217C2B4CC;
  v18 = xmmword_217C2B4DC;
  v19 = 0xFF64FF61FE52FE51;
  v12 = xmmword_217C2B47C;
  v13 = unk_217C2B48C;
  v14 = xmmword_217C2B49C;
  v15 = unk_217C2B4AC;
  v8 = xmmword_217C2B43C;
  v9 = unk_217C2B44C;
  v10 = xmmword_217C2B45C;
  v11 = unk_217C2B46C;
  v4 = xmmword_217C2B3FC;
  v5 = unk_217C2B40C;
  v6 = xmmword_217C2B41C;
  v7 = unk_217C2B42C;
  v0 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240]);
  v2 = CFStringCreateWithCharacters(v0, (const UniChar *)&v4, 124);
  if (v2)
  {
    v3 = v2;
    CFCharacterSetAddCharactersInString(Mutable, v2);
    CFRelease(v3);
    CFCharacterSetUnion(Mutable, (CFCharacterSetRef)objc_msgSend(MEMORY[0x24BDD14A8], "whitespaceCharacterSet", v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,
                           v19,
                           v20));
  }
  KinsokuIllegalStartChar::sSet = (uint64_t)Mutable;
}

BOOL KinsokuWesternChar(UTF32Char theChar)
{
  if (KinsokuWesternChar::sKinsokuWesternCharDispatchOnceToken != -1)
    dispatch_once(&KinsokuWesternChar::sKinsokuWesternCharDispatchOnceToken, &__block_literal_global_66_1);
  return CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)KinsokuWesternChar::sSet, theChar) != 0;
}

void ___Z18KinsokuWesternCharj_block_invoke()
{
  const __CFAllocator *v0;
  __CFCharacterSet *Mutable;
  const __CFString *v2;
  const __CFString *v3;
  UniChar __dst[767];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  memcpy(__dst, asc_217C2B4F4, sizeof(__dst));
  v0 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240]);
  v2 = CFStringCreateWithCharacters(v0, __dst, 767);
  if (v2)
  {
    v3 = v2;
    CFCharacterSetAddCharactersInString(Mutable, v2);
    CFRelease(v3);
  }
  KinsokuWesternChar::sSet = (uint64_t)Mutable;
}

BOOL KinsokuAllowSplit(uint64_t theChar, uint64_t a2)
{
  UTF32Char v3;
  int v4;
  _BOOL8 result;
  int v6;
  BOOL v7;

  v3 = theChar;
  if ((int)theChar > 12338)
  {
    if ((theChar - 12339) >= 2)
    {
      v6 = 65073;
      if ((_DWORD)theChar != 65073)
        goto LABEL_20;
    }
    else
    {
      v6 = 12341;
    }
    v7 = (_DWORD)a2 == v6;
    return !v7;
  }
  if ((theChar - 8208) <= 0x16)
  {
    v4 = 1 << (theChar - 16);
    if ((v4 & 0x3D) != 0)
    {
LABEL_4:
      if ((a2 - 8208) > 5)
        return (_DWORD)a2 != 45;
      result = 0;
      if ((_DWORD)a2 == 8209)
        return (_DWORD)a2 != 45;
      return result;
    }
    if ((v4 & 0x600000) != 0)
    {
      v7 = (_DWORD)a2 == (_DWORD)theChar;
      return !v7;
    }
  }
  if ((_DWORD)theChar == 45)
    goto LABEL_4;
  if ((_DWORD)theChar == 47)
  {
    v7 = (_DWORD)a2 == 47;
    return !v7;
  }
LABEL_20:
  if (IsWhitespaceCharacter(theChar) && (IsWhitespaceCharacter(a2) & 1) != 0)
    return 0;
  if (KinsokuWesternChar(v3))
    return !KinsokuWesternChar(a2);
  return 1;
}

double OikomiSquishAmountForCharacter(int a1)
{
  double result;
  char v2;

  result = 0.0;
  if (a1 > 10628)
  {
    if (((a1 - 12289) > 0x1E || ((1 << (a1 - 1)) & 0x51F9FF81) == 0) && (a1 - 10629) >= 2)
    {
      if (a1 != 12539)
        return result;
      return 0.5;
    }
    return 0.25;
  }
  if (a1 > 122)
  {
    if ((a1 - 8216) <= 5 && ((1 << (a1 - 24)) & 0x33) != 0
      || (a1 - 125) <= 0x3E && ((1 << (a1 - 125)) & 0x4000400000000001) != 0
      || a1 == 123)
    {
      return 0.25;
    }
  }
  else
  {
    v2 = a1 - 32;
    if ((a1 - 32) > 0x3D)
      return result;
    if (((1 << v2) & 0x2800000000001300) != 0)
      return 0.25;
    if (((1 << v2) & 0xC000000) != 0)
      return 0.5;
    if (a1 == 32)
      return 0.0833333333;
  }
  return result;
}

BOOL BursageEligibleChar(UTF32Char theChar)
{
  if (BursageEligibleChar::sBursageEligibleCharDispatchOnceToken != -1)
    dispatch_once(&BursageEligibleChar::sBursageEligibleCharDispatchOnceToken, &__block_literal_global_67);
  return CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)BursageEligibleChar::sSet, theChar) != 0;
}

void ___Z19BursageEligibleCharj_block_invoke()
{
  const __CFAllocator *v0;
  __CFCharacterSet *Mutable;
  const __CFString *v2;
  const __CFString *v3;
  UniChar v4[20];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)v4 = xmmword_217C2BAF2;
  *(_OWORD *)&v4[7] = *(__int128 *)((char *)&xmmword_217C2BAF2 + 14);
  v0 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240]);
  v2 = CFStringCreateWithCharacters(v0, v4, 15);
  if (v2)
  {
    v3 = v2;
    CFCharacterSetAddCharactersInString(Mutable, v2);
    CFRelease(v3);
  }
  BursageEligibleChar::sSet = (uint64_t)Mutable;
}

uint64_t TSWPPreviousCharFromTextSource(uint64_t a1, void *a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int16 v8;
  void *v10;
  uint64_t v11;

  if (!a2)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPCharIndex TSWPPreviousCharFromTextSource(TSWPCharIndex, id<TSWPTextSource>)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 1366, CFSTR("invalid nil value for '%s'"), "source");
  }
  v6 = objc_msgSend(a2, "charIndexMappedFromStorage:", a1);
  if (v6)
  {
    a1 = objc_msgSend(a2, "charIndexMappedToStorage:", v6 - 1);
    v7 = objc_msgSend(a2, "charIndexMappedFromStorage:", a1);
    v8 = objc_msgSend(a2, "characterAtIndex:", v7);
    if (v7 && (v8 & 0xFC00) == 0xDC00)
      return objc_msgSend(a2, "charIndexMappedToStorage:", v7 - 1);
  }
  else
  {
    v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPCharIndex TSWPPreviousCharFromTextSource(TSWPCharIndex, id<TSWPTextSource>)");
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 1368, CFSTR("charIndex should not be at the start of the text source"));
  }
  return a1;
}

uint64_t TSWPNextCharFromTextSource(uint64_t a1, void *a2)
{
  void *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (!a2)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPCharIndex TSWPNextCharFromTextSource(TSWPCharIndex, id<TSWPTextSource>)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 1388, CFSTR("invalid nil value for '%s'"), "source");
  }
  v6 = objc_msgSend(a2, "charIndexMappedFromStorage:", a1);
  if (v6 >= objc_msgSend(a2, "length") - 1)
    return objc_msgSend(a2, "charIndexMappedToStorage:", v6 + 1);
  while (v6 < objc_msgSend(a2, "length"))
  {
    if ((objc_msgSend(a2, "characterAtIndex:", v6) & 0xFC00) == 0xD800)
      v7 = 2;
    else
      v7 = 1;
    v6 += v7;
    v8 = objc_msgSend(a2, "charIndexMappedToStorage:", v6);
    if (v8 != a1)
      return v8;
  }
  return a1;
}

unint64_t TSWPRangeByExtendingRangeToWhitespaceForTextSource(unint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v3;
  unint64_t v4;
  void *v7;
  uint64_t v8;
  unint64_t v9;
  void *v10;
  unint64_t v11;

  v3 = a1;
  v4 = a1 + a2;
  if (a1 != *MEMORY[0x24BEB3BF0] || a2 != *(_QWORD *)(MEMORY[0x24BEB3BF0] + 8))
  {
    if (!a3)
    {
      v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSRange TSWPRangeByExtendingRangeToWhitespaceForTextSource(NSRange, id<TSWPTextSource>)");
      objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPUtilities.mm"), 1447, CFSTR("invalid nil value for '%s'"), "textSource");
    }
    v9 = objc_msgSend(a3, "length");
    v10 = (void *)objc_msgSend(a3, "string");
    do
    {
      v11 = v3;
      if (!v3)
        break;
      --v3;
    }
    while (!IsWhitespaceCharacter(objc_msgSend(v10, "characterAtIndex:", v11 - 1)));
    if (v4 < v9)
    {
      while ((IsWhitespaceCharacter(objc_msgSend(v10, "characterAtIndex:", v4)) & 1) == 0)
      {
        if (++v4 >= v9)
        {
          v4 = v9;
          break;
        }
      }
    }
    v3 = v11;
  }
  if (v3 >= v4)
    return v4;
  else
    return v3;
}

const __CFString *TSWPTextPackageStringForPreset()
{
  return CFSTR("text");
}

uint64_t TSWPResolveColorForStyles(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[3];

  v2 = 0;
  v7[2] = *MEMORY[0x24BDAC8D0];
  v7[0] = a1;
  v7[1] = a2;
  while (1)
  {
    v3 = (void *)v7[v2];
    if (v3)
    {
      v4 = objc_msgSend(v3, "boxedValueForProperty:", 18);
      if (v4)
      {
        v5 = v4;
        if (v4 != objc_msgSend(MEMORY[0x24BDBCEF8], "null"))
          break;
      }
    }
    if (++v2 == 2)
      return 0;
  }
  return v5;
}

const __CTFont *TSWPCreateFontWithNameAndTraits(uint64_t a1, int a2, int a3, void *a4, double a5)
{
  return TSWPCreateFontWithNameAttributesTraitsAndWeight(a1, a2, a3, 0, a4, 0, a5, *MEMORY[0x24BDF7888]);
}

BOOL TSWPFontGetGlyphsForUnichars(uint64_t a1, const UniChar *a2, CGGlyph *a3, CFIndex a4)
{
  const __CTFont *v7;

  CTFontGetTypeID();
  v7 = (const __CTFont *)TSUCFTypeCast();
  return CTFontGetGlyphsForCharacters(v7, a2, a3, a4);
}

double TSWPAttachmentVAlignmentCorrection(int a1, uint64_t a2, void *a3, unint64_t a4)
{
  double v4;
  const __CTFont *FontForStyle;
  const __CTFont *v7;
  double Ascent;
  double v9;
  double v10;

  v4 = 0.0;
  if (a2)
  {
    FontForStyle = TSWPFastCreateFontForStyle(a2, a3, a4);
    if (FontForStyle)
    {
      v7 = FontForStyle;
      switch(a1)
      {
        case 1:
          Ascent = CTFontGetAscent(FontForStyle);
          v4 = Ascent - CTFontGetCapHeight(v7);
          break;
        case 2:
          v9 = CTFontGetAscent(FontForStyle);
          v4 = -(CTFontGetCapHeight(v7) - v9 * 1.5);
          break;
        case 3:
          v4 = CTFontGetAscent(FontForStyle);
          break;
        case 4:
          v10 = CTFontGetAscent(FontForStyle);
          v4 = v10 + CTFontGetDescent(v7);
          break;
        default:
          break;
      }
      CFRelease(v7);
    }
  }
  return v4;
}

double GetWavyLineHalfAmplitude(double a1)
{
  return fmax(a1, 1.75);
}

double GetWavyLineThickness(double a1)
{
  return fmin(a1, 1.0);
}

double GetWavyLineRate(void)
{
  return 0.174999997;
}

double TSWPUnderlineAdornmentMetricsForFont(const __CTFont *a1, const __CTFont *a2, int a3, int a4, void *a5, int a6, double a7, double a8, double a9, double a10, double a11)
{
  double v22;
  double UnderlineThickness;
  double v24;
  int v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double UnderlinePosition;
  double v31;
  double v33;

  v33 = 0.0;
  v22 = pAdjustedLineHeight(a1, &v33);
  UnderlineThickness = CTFontGetUnderlineThickness(a1);
  if (UnderlineThickness == 0.0)
    v24 = v22 * 0.0440277313;
  else
    v24 = UnderlineThickness;
  v25 = TSWPCJKLanguageForInputLanguageString(a5);
  if (a11 == 0.0)
    a11 = v24;
  v26 = fmax(a11, 1.0);
  if (a6 == 1)
  {
    v27 = -a8;
    if (a4)
      v27 = -(a9 + a10 - (-a8 - a11) - ((a8 + a9) * 0.5 + a10));
    v28 = -0.0;
    if (a3 == 2)
      v28 = a11;
    v29 = v28 + v27;
    if (a3 && !a4 && v25 != 6)
      v29 = v29 - v26;
  }
  else
  {
    if (a4)
    {
      a9 = -(a9 + a10 - (a11 + a9) - ((a8 + a9) * 0.5 + a10));
    }
    else
    {
      if (!a3 || v25 == 6)
      {
        UnderlinePosition = CTFontGetUnderlinePosition(a1);
        if (a1 != a2 && UnderlinePosition == 0.0)
          UnderlinePosition = CTFontGetUnderlinePosition(a2);
        a9 = -UnderlinePosition;
      }
      if (a9 < 1.0)
        a9 = floor(v33) * 5.3636991 * 0.0880554625;
    }
    v31 = fmax(fmax(a11, 1.75) - a11, 0.0) + a9;
    if ((a4 & 1) != 0)
      v31 = a9;
    v29 = a9 - a11;
    if (a3 != 2)
      v29 = a9;
    if (a3 == 3)
      v29 = v31;
  }
  return v29 + a7;
}

double pAdjustedLineHeight(const __CTFont *a1, double *a2)
{
  id v4;

  v4 = +[TSWPFontHeightCache sharedCache](TSWPFontHeightCache, "sharedCache");
  if (v4)
    objc_msgSend(v4, "fontHeightInfoForFont:", a1);
  *a2 = 0.0 + 0.0;
  return fmin(rint(0.0 + 0.0) * 5.3636991, fmax(0.0, 0.0) + 0.0 + 0.0 + 0.0 + 0.0 + 0.0);
}

uint64_t TSWPCJKLanguageForInputLanguageString(void *a1)
{
  void *v1;
  void *v2;
  uint64_t result;
  uint64_t v4;
  void *v5;

  v1 = (void *)objc_msgSend(a1, "lowercaseString");
  if (TSWPCJKLanguageForInputLanguageString::onceToken != -1)
    dispatch_once(&TSWPCJKLanguageForInputLanguageString::onceToken, &__block_literal_global_91);
  v2 = (void *)objc_msgSend((id)TSWPCJKLanguageForInputLanguageString::sMappings, "objectForKeyedSubscript:", v1);
  if (!v2 || (result = objc_msgSend(v2, "intValue"), (_DWORD)result == 6))
  {
    if ((unint64_t)objc_msgSend(v1, "length") >= 2
      && (v4 = objc_msgSend(v1, "substringWithRange:", 0, 2),
          (v5 = (void *)objc_msgSend((id)TSWPCJKLanguageForInputLanguageString::sMappings, "objectForKeyedSubscript:", v4)) != 0))
    {
      return objc_msgSend(v5, "intValue");
    }
    else
    {
      return 6;
    }
  }
  return result;
}

double TSWPPositionForVerticalCenterFromPositionForBaseline(double a1, double a2, double a3, double a4)
{
  return -(a3 + a4 - a1 - ((a2 + a3) * 0.5 + a4));
}

void TSWPStrikethroughAdornmentMetricsForFont(const __CTFont *a1, double a2, double a3, double a4, double a5)
{
  double v6;

  pAdjustedLineHeight(a1, &v6);
  CTFontGetXHeight(a1);
}

double TSWPRound(double a1)
{
  double v1;
  double v2;
  BOOL v3;
  BOOL v4;

  v1 = fabs(a1);
  v2 = v1 - floor(v1);
  v3 = a1 >= 0.0 || v2 > 0.5;
  if (v3 && (a1 >= 0.0 ? (v4 = v2 < 0.5) : (v4 = 1), v4))
    return floor(a1);
  else
    return ceil(a1);
}

double TSWPIntegralPoint(CGPoint a1)
{
  double v1;
  double v2;
  BOOL v3;
  BOOL v4;

  v1 = fabs(a1.x);
  v2 = v1 - floor(v1);
  v3 = a1.x >= 0.0 || v2 > 0.5;
  if (v3 && (a1.x >= 0.0 ? (v4 = v2 < 0.5) : (v4 = 1), v4))
    return floor(a1.x);
  else
    return ceil(a1.x);
}

double TSWPIntegralRect(CGRect a1)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  CGFloat MaxX;
  double v6;
  double v7;
  CGPoint v10;
  CGPoint v11;
  CGRect v12;

  height = a1.size.height;
  width = a1.size.width;
  y = a1.origin.y;
  x = a1.origin.x;
  MaxX = CGRectGetMaxX(a1);
  v12.origin.x = x;
  v12.origin.y = y;
  v12.size.width = width;
  v12.size.height = height;
  v10.y = CGRectGetMaxY(v12);
  v10.x = MaxX;
  v6 = TSWPIntegralPoint(v10);
  v11.x = x;
  v11.y = y;
  v7 = TSWPIntegralPoint(v11);
  if (v7 >= v6)
    return v6;
  else
    return v7;
}

CGFloat TSWPRectWithPoints(CGPoint a1, CGPoint a2)
{
  if (a1.x >= a2.x)
    return a2.x;
  else
    return a1.x;
}

BOOL TSWPInsertionPointInRangeWithOptions(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5;
  unint64_t v6;
  BOOL v7;

  v5 = !(a5 & 1) + a3;
  v7 = a1 >= v5;
  v6 = a1 - v5;
  v7 = !v7 || v6 >= a4 + (a5 & 1) + ((a5 >> 1) & 1) - 1;
  return !v7;
}

uint64_t TSWPListLanguageForInputLanguageString(void *a1)
{
  void *v1;
  void *v2;
  uint64_t result;
  uint64_t v4;
  void *v5;

  v1 = (void *)objc_msgSend(a1, "lowercaseString");
  if (TSWPListLanguageForInputLanguageString::onceToken != -1)
    dispatch_once(&TSWPListLanguageForInputLanguageString::onceToken, &__block_literal_global_113);
  v2 = (void *)objc_msgSend((id)TSWPListLanguageForInputLanguageString::sMappings, "objectForKeyedSubscript:", v1);
  if (!v2 || (result = objc_msgSend(v2, "intValue"), (_DWORD)result == 6))
  {
    if ((unint64_t)objc_msgSend(v1, "length") >= 2
      && (v4 = objc_msgSend(v1, "substringWithRange:", 0, 2),
          (v5 = (void *)objc_msgSend((id)TSWPListLanguageForInputLanguageString::sMappings, "objectForKeyedSubscript:", v4)) != 0))
    {
      return objc_msgSend(v5, "intValue");
    }
    else
    {
      return 6;
    }
  }
  return result;
}

id TSWPLocaleForCJKLanguage(int a1, void *a2)
{
  const __CFString *v2;
  id result;

  v2 = CFSTR("zh_CN");
  switch(a1)
  {
    case 0:
      goto LABEL_8;
    case 1:
      if (objc_msgSend((id)objc_msgSend(a2, "objectForKey:", *MEMORY[0x24BDBCAE8]), "isEqualToString:", CFSTR("TW")))v2 = CFSTR("zh_TW");
      else
        v2 = CFSTR("zh_HK");
      goto LABEL_8;
    case 2:
      v2 = CFSTR("ja_JP");
      goto LABEL_8;
    case 3:
      v2 = CFSTR("ko_KR");
LABEL_8:
      result = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDBCEA0]), "initWithLocaleIdentifier:", v2);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

void ApplyVerticalFormsToAttributedString(__CFAttributedString *a1, UniChar *a2)
{
  CFIndex Length;
  const __CFString *String;
  const unsigned __int16 *CharactersPtr;
  CFIndex v7;
  const __CFString *v8;
  const __CTFont *AttributeAndLongestEffectiveRange;
  CFStringRef v10;
  CFRange *v11;
  CFRange *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  __int128 v21;
  CFRange *v22;
  uint64_t v23;
  unint64_t v24;
  const __CFString *v25;
  const void *v26;
  const void *v27;
  unsigned int v28;
  CFRange *v29;
  const void *v30;
  UniChar *v32;
  CFRange v33;
  CFRange longestEffectiveRange;
  void *__p;
  CFRange *v36;
  CFRange *v37;
  CFRange v38;
  CFRange v39;

  Length = CFAttributedStringGetLength(a1);
  if (!a2)
  {
    String = CFAttributedStringGetString(a1);
    CharactersPtr = CFStringGetCharactersPtr(String);
    if (!CharactersPtr)
    {
      a2 = (UniChar *)operator new[]();
      v38.location = 0;
      v38.length = Length;
      CFStringGetCharacters(String, v38, a2);
      v32 = a2;
      goto LABEL_5;
    }
    a2 = (UniChar *)CharactersPtr;
  }
  v32 = 0;
LABEL_5:
  __p = 0;
  v36 = 0;
  v37 = 0;
  TSWPFillVerticalFacingRangesFromBuffer((uint64_t)a2, Length, &__p);
  v7 = CFAttributedStringGetLength(a1);
  longestEffectiveRange.location = 0;
  longestEffectiveRange.length = 0;
  v8 = (const __CFString *)*MEMORY[0x24BDC4C28];
  while (longestEffectiveRange.length + longestEffectiveRange.location < v7)
  {
    v39.location = 0;
    v39.length = v7;
    AttributeAndLongestEffectiveRange = (const __CTFont *)CFAttributedStringGetAttributeAndLongestEffectiveRange(a1, longestEffectiveRange.length+ longestEffectiveRange.location, v8, v39, &longestEffectiveRange);
    if (!AttributeAndLongestEffectiveRange)
      break;
    v10 = CTFontCopyPostScriptName(AttributeAndLongestEffectiveRange);
    if (CFEqual(v10, CFSTR("AppleColorEmoji")))
    {
      v33 = longestEffectiveRange;
      v11 = v36;
      if (v36 >= v37)
      {
        v13 = 0xAAAAAAAAAAAAAAABLL * (((char *)v36 - (_BYTE *)__p) >> 3);
        v14 = v13 + 1;
        if (v13 + 1 > 0xAAAAAAAAAAAAAAALL)
          abort();
        if (0x5555555555555556 * (((char *)v37 - (_BYTE *)__p) >> 3) > v14)
          v14 = 0x5555555555555556 * (((char *)v37 - (_BYTE *)__p) >> 3);
        if (0xAAAAAAAAAAAAAAABLL * (((char *)v37 - (_BYTE *)__p) >> 3) >= 0x555555555555555)
          v15 = 0xAAAAAAAAAAAAAAALL;
        else
          v15 = v14;
        if (v15)
          v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)&v37, v15);
        else
          v16 = 0;
        v17 = &v16[24 * v13];
        *(CFRange *)v17 = v33;
        v17[16] = 1;
        *(_DWORD *)(v17 + 17) = 0;
        *((_DWORD *)v17 + 5) = 0;
        v19 = (char *)__p;
        v18 = (char *)v36;
        v20 = v17;
        if (v36 != __p)
        {
          do
          {
            v21 = *(_OWORD *)(v18 - 24);
            *((_QWORD *)v20 - 1) = *((_QWORD *)v18 - 1);
            *(_OWORD *)(v20 - 24) = v21;
            v20 -= 24;
            v18 -= 24;
          }
          while (v18 != v19);
          v18 = (char *)__p;
        }
        v12 = (CFRange *)(v17 + 24);
        __p = v20;
        v36 = (CFRange *)(v17 + 24);
        v37 = (CFRange *)&v16[24 * v15];
        if (v18)
          operator delete(v18);
      }
      else
      {
        *v36 = longestEffectiveRange;
        LOBYTE(v11[1].location) = 1;
        *(_DWORD *)((char *)&v11[1].location + 1) = 0;
        HIDWORD(v11[1].location) = 0;
        v12 = (CFRange *)((char *)v11 + 24);
      }
      v36 = v12;
    }
    CFRelease(v10);
  }
  v22 = v36;
  if (v36 != __p)
  {
    v23 = 0;
    v24 = 0xAAAAAAAAAAAAAAABLL * (((char *)v36 - (_BYTE *)__p) >> 3);
    v25 = (const __CFString *)*MEMORY[0x24BDC5008];
    v26 = (const void *)*MEMORY[0x24BDBD270];
    v27 = (const void *)*MEMORY[0x24BDBD268];
    v28 = 1;
    do
    {
      v29 = (CFRange *)((char *)__p + 24 * v23);
      if (LOBYTE(v29[1].location))
        v30 = v26;
      else
        v30 = v27;
      CFAttributedStringSetAttribute(a1, *v29, v25, v30);
      v23 = v28;
    }
    while (v24 > v28++);
    v22 = (CFRange *)__p;
  }
  if (v22)
  {
    v36 = v22;
    operator delete(v22);
  }
  if (v32)
    MEMORY[0x219A15394](v32, 0x1000C80BDFB0063);
}

void sub_217B61290(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t TSWPCTFontSupportsNativeSmallCaps(const __CTFont *a1)
{
  CFArrayRef v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  _BYTE v35[128];
  _BYTE v36[128];
  _BYTE v37[128];
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v1 = CTFontCopyFeatures(a1);
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v2 = -[__CFArray countByEnumeratingWithState:objects:count:](v1, "countByEnumeratingWithState:objects:count:", &v31, v37, 16);
  if (v2)
  {
    v3 = v2;
    v4 = *(_QWORD *)v32;
    v5 = *MEMORY[0x24BDC4D28];
    v22 = *MEMORY[0x24BDC4D30];
    v6 = *MEMORY[0x24BDC4D18];
    while (2)
    {
      for (i = 0; i != v3; ++i)
      {
        if (*(_QWORD *)v32 != v4)
          objc_enumerationMutation(v1);
        v8 = *(void **)(*((_QWORD *)&v31 + 1) + 8 * i);
        v9 = (void *)objc_msgSend(v8, "objectForKey:", v5);
        if (objc_msgSend(v9, "integerValue") == 3)
        {
          v10 = (void *)objc_msgSend(v8, "objectForKey:", v22);
          v27 = 0u;
          v28 = 0u;
          v29 = 0u;
          v30 = 0u;
          v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v27, v36, 16);
          if (v11)
          {
            v12 = v11;
            v13 = *(_QWORD *)v28;
LABEL_9:
            v14 = 0;
            while (1)
            {
              if (*(_QWORD *)v28 != v13)
                objc_enumerationMutation(v10);
              if (objc_msgSend((id)objc_msgSend(*(id *)(*((_QWORD *)&v27 + 1) + 8 * v14), "objectForKey:", v6), "integerValue") == 3)break;
              if (v12 == ++v14)
              {
                v12 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v27, v36, 16);
                if (v12)
                  goto LABEL_9;
                goto LABEL_25;
              }
            }
LABEL_28:
            v20 = 1;
            goto LABEL_30;
          }
        }
        else if (objc_msgSend(v9, "integerValue") == 37)
        {
          v15 = (void *)objc_msgSend(v8, "objectForKey:", v22);
          v23 = 0u;
          v24 = 0u;
          v25 = 0u;
          v26 = 0u;
          v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v23, v35, 16);
          if (v16)
          {
            v17 = v16;
            v18 = *(_QWORD *)v24;
LABEL_19:
            v19 = 0;
            while (1)
            {
              if (*(_QWORD *)v24 != v18)
                objc_enumerationMutation(v15);
              if (objc_msgSend((id)objc_msgSend(*(id *)(*((_QWORD *)&v23 + 1) + 8 * v19), "objectForKey:", v6), "integerValue") == 1)goto LABEL_28;
              if (v17 == ++v19)
              {
                v17 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v23, v35, 16);
                if (v17)
                  goto LABEL_19;
                break;
              }
            }
          }
        }
LABEL_25:
        ;
      }
      v3 = -[__CFArray countByEnumeratingWithState:objects:count:](v1, "countByEnumeratingWithState:objects:count:", &v31, v37, 16);
      v20 = 0;
      if (v3)
        continue;
      break;
    }
  }
  else
  {
    v20 = 0;
  }
LABEL_30:

  return v20;
}

uint64_t TSWPGetAdornmentLocation(void *a1, int a2, int a3)
{
  int v5;
  uint64_t v6;
  int *i;

  v5 = TSWPCJKLanguageForInputLanguageString(a1);
  v6 = 0;
  for (i = &dword_217C2BB1C; v5 != *(i - 3) || (((0x33333uLL >> v6) & 1) == 0) == a2 || *(i - 1) != a3; i += 4)
  {
    if (++v6 == 20)
      return 0;
  }
  return *i;
}

BOOL TSWPPrimaryInputMethodIsRTL()
{
  return objc_msgSend(MEMORY[0x24BDBCEA0], "characterDirectionForLanguage:", TSWPGetPrimaryInputLanguage()) == 2;
}

const __CFString *TSWPGetPrimaryInputLanguage()
{
  void *v0;

  v0 = (void *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x24BDF6D10], "tswp_currentFirstResponder"), "textInputMode"), "primaryLanguage");
  if (!objc_msgSend(v0, "length"))
    v0 = (void *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x24BDBCF50], "standardUserDefaults"), "arrayForKey:", CFSTR("AppleLanguages")), "firstObject");
  if (objc_msgSend(v0, "length"))
    return (const __CFString *)v0;
  else
    return CFSTR("en");
}

uint64_t TSWPGetListNumberTypeForString(uint64_t a1)
{
  void *v2;

  if (TSWPGetListNumberTypeForString::onceToken != -1)
    dispatch_once(&TSWPGetListNumberTypeForString::onceToken, &__block_literal_global_142);
  v2 = (void *)objc_msgSend((id)TSWPGetListNumberTypeForString::listNames, "objectForKey:", a1);
  if (v2)
    return objc_msgSend(v2, "integerValue");
  else
    return 62;
}

uint64_t TSWPStringFromTSWPListNumberType(unsigned int a1)
{
  if (onceTokenTSWPListNumberType != -1)
    dispatch_once(&onceTokenTSWPListNumberType, &__block_literal_global_174);
  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPListNumberType", (void *)s_TSWPListNumberTypeStrings, 0);
}

uint64_t TSWPGetCharacterFormattingOptions(void *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = 0;
  if (!TSUHasCJKLanguage())
    a1 = 0;
  while (1)
  {
    v3 = sCharacterFormattingRulesData[v2];
    if (a1)
    {
      if (!v3)
        goto LABEL_8;
    }
    else if (!v3)
    {
      return LODWORD(sCharacterFormattingRulesData[v2 + 1]);
    }
    if (objc_msgSend(a1, "hasPrefix:"))
      return LODWORD(sCharacterFormattingRulesData[v2 + 1]);
LABEL_8:
    v2 += 2;
    if (v2 == 8)
      return 0;
  }
}

double TSWPRectDifference(double a1, double a2, double a3, double a4, double a5)
{
  return a1 - a5;
}

uint64_t TSWPStringFromEnumWithTableAndIndex(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  void *v7;
  void *v8;
  uint64_t v9;
  _QWORD v11[3];

  v11[2] = *MEMORY[0x24BDAC8D0];
  v7 = (void *)objc_msgSend(a3, "objectForKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInteger:", a1));
  if (!v7)
  {
    v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a2, 4);
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("[Unknown %@ (%ld)]"), v8, a1);

    v11[0] = v9;
    v11[1] = v9;
    v7 = (void *)objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v11, 2);
  }
  return objc_msgSend(v7, "objectAtIndexedSubscript:", a4);
}

uint64_t TSWPStringFromTSWPListLabelType(unsigned int a1)
{
  if (onceTokenTSWPListLabelType != -1)
    dispatch_once(&onceTokenTSWPListLabelType, &__block_literal_global_147);
  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPListLabelType", (void *)s_TSWPListLabelTypeStrings, 0);
}

uint64_t TSWPDisplayStringFromTSWPListLabelType(unsigned int a1)
{
  if (onceTokenTSWPListLabelType != -1)
    dispatch_once(&onceTokenTSWPListLabelType, &__block_literal_global_149);
  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPListLabelType", (void *)s_TSWPListLabelTypeStrings, 1);
}

uint64_t TSWPDisplayStringFromTSWPListNumberType(unsigned int a1)
{
  if (onceTokenTSWPListNumberType != -1)
    dispatch_once(&onceTokenTSWPListNumberType, &__block_literal_global_176);
  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPListNumberType", (void *)s_TSWPListNumberTypeStrings, 1);
}

uint64_t TSWPStringFromTSWPCapitalization(unsigned int a1)
{
  if (onceTokenTSWPCapitalization != -1)
    dispatch_once(&onceTokenTSWPCapitalization, &__block_literal_global_620);
  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPCapitalization", (void *)s_TSWPCapitalizationStrings, 0);
}

uint64_t TSWPDisplayStringFromTSWPCapitalization(unsigned int a1)
{
  if (onceTokenTSWPCapitalization != -1)
    dispatch_once(&onceTokenTSWPCapitalization, &__block_literal_global_622);
  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPCapitalization", (void *)s_TSWPCapitalizationStrings, 1);
}

uint64_t TSWPStringFromTSWPWritingDirection(int a1)
{
  if (onceTokenTSWPWritingDirection != -1)
    dispatch_once(&onceTokenTSWPWritingDirection, &__block_literal_global_648);
  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPWritingDirection", (void *)s_TSWPWritingDirectionStrings, 0);
}

uint64_t TSWPDisplayStringFromTSWPWritingDirection(int a1)
{
  if (onceTokenTSWPWritingDirection != -1)
    dispatch_once(&onceTokenTSWPWritingDirection, &__block_literal_global_650);
  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPWritingDirection", (void *)s_TSWPWritingDirectionStrings, 1);
}

uint64_t TSWPStringFromTSWPTOCScope(unsigned int a1)
{
  if (onceTokenTSWPTOCScope != -1)
    dispatch_once(&onceTokenTSWPTOCScope, &__block_literal_global_673);
  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPTOCScope", (void *)s_TSWPTOCScopeStrings, 0);
}

uint64_t TSWPDisplayStringFromTSWPTOCScope(unsigned int a1)
{
  if (onceTokenTSWPTOCScope != -1)
    dispatch_once(&onceTokenTSWPTOCScope, &__block_literal_global_675);
  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPTOCScope", (void *)s_TSWPTOCScopeStrings, 1);
}

uint64_t TSWPStringFromTSWPVerticalAlignment(unsigned int a1)
{
  if (onceTokenTSWPVerticalAlignment != -1)
    dispatch_once(&onceTokenTSWPVerticalAlignment, &__block_literal_global_695);
  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPVerticalAlignment", (void *)s_TSWPVerticalAlignmentStrings, 0);
}

uint64_t TSWPDisplayStringFromTSWPVerticalAlignment(unsigned int a1)
{
  if (onceTokenTSWPVerticalAlignment != -1)
    dispatch_once(&onceTokenTSWPVerticalAlignment, &__block_literal_global_697);
  return TSWPStringFromEnumWithTableAndIndex(a1, (uint64_t)"TSWPVerticalAlignment", (void *)s_TSWPVerticalAlignmentStrings, 1);
}

void TSWPStorageTransaction::~TSWPStorageTransaction(TSWPStorageTransaction *this)
{
  TSWPStorageTransaction *v2;

  std::vector<TSWPStorageTransactionObject>::__clear[abi:nn180100]((TSWPStorageTransactionObject **)this);
  v2 = this;
  std::vector<TSWPStorageTransactionObject>::__destroy_vector::operator()[abi:nn180100]((void ***)&v2);
}

{
  TSWPStorageTransaction *v2;

  std::vector<TSWPStorageTransactionObject>::__clear[abi:nn180100]((TSWPStorageTransactionObject **)this);
  v2 = this;
  std::vector<TSWPStorageTransactionObject>::__destroy_vector::operator()[abi:nn180100]((void ***)&v2);
}

void TSWPStorageTransaction::TSWPStorageTransaction(TSWPStorageTransaction *this)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(int64x2_t *)((char *)this + 24) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
}

{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(int64x2_t *)((char *)this + 24) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
}

void TSWPStorageTransaction::TSWPStorageTransaction(TSWPStorageTransaction *this, const TSWPStorageTransaction *a2)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  std::vector<TSWPStorageTransactionObject>::__init_with_size[abi:nn180100]<TSWPStorageTransactionObject*,TSWPStorageTransactionObject*>((TSWPStorageTransactionObject *)this, *(TSWPStorageTransactionObject **)a2, *((TSWPStorageTransactionObject **)a2 + 1), (uint64_t)(*((_QWORD *)a2 + 1) - *(_QWORD *)a2) >> 5);
  *(int64x2_t *)((char *)this + 24) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
}

{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  std::vector<TSWPStorageTransactionObject>::__init_with_size[abi:nn180100]<TSWPStorageTransactionObject*,TSWPStorageTransactionObject*>((TSWPStorageTransactionObject *)this, *(TSWPStorageTransactionObject **)a2, *((TSWPStorageTransactionObject **)a2 + 1), (uint64_t)(*((_QWORD *)a2 + 1) - *(_QWORD *)a2) >> 5);
  *(int64x2_t *)((char *)this + 24) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
}

int64x2_t TSWPStorageTransaction::compress(TSWPStorageTransaction *this)
{
  int64x2_t result;

  std::vector<TSWPStorageTransactionObject>::resize((uint64_t *)this, (uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 5);
  result = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
  *(int64x2_t *)((char *)this + 24) = result;
  return result;
}

void std::vector<TSWPStorageTransactionObject>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  TSWPStorageTransactionObject *v6;
  BOOL v7;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      if (v3 != v5)
      {
        v6 = (TSWPStorageTransactionObject *)(v3 - 32);
        do
        {
          if (*(_WORD *)v6)
            TSWPStorageTransactionObject::adjustRetainCount(v6, 0);
          v7 = v6 == (TSWPStorageTransactionObject *)v5;
          v6 = (TSWPStorageTransactionObject *)((char *)v6 - 32);
        }
        while (!v7);
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<TSWPStorageTransactionObject>::__append(a1, a2 - v4);
  }
}

uint64_t TSWPStorageTransaction::operator==(unsigned __int16 **a1, uint64_t a2)
{
  unsigned __int16 *v2;
  unsigned __int16 *v3;
  unsigned __int16 *v4;
  uint64_t result;

  v2 = *a1;
  v3 = a1[1];
  v4 = *(unsigned __int16 **)a2;
  if ((char *)v3 - (char *)*a1 != *(_QWORD *)(a2 + 8) - *(_QWORD *)a2)
    return 0;
  if (v2 == v3)
    return 1;
  do
  {
    result = TSWPStorageTransactionObject::operator==(v2, v4);
    if (!(_DWORD)result)
      break;
    v2 += 16;
    v4 += 16;
  }
  while (v2 != v3);
  return result;
}

uint64_t TSWPStorageTransaction::compressTransaction(_QWORD *a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  int v9;

  if (a2 == 5)
  {
    v5 = a1[4];
    if (v5 != 0x7FFFFFFFFFFFFFFFLL)
    {
      v6 = *a1 + 32 * v5;
      result = 1;
      *(_DWORD *)(v6 + 4) |= 1 << a3;
      return result;
    }
  }
  if (a3)
    return 0;
  v8 = a1[1];
  if (v8 == *a1 || *(unsigned __int16 *)(v8 - 32) != a2 || *(_DWORD *)(v8 - 28))
    return 0;
  if (a2 == 2)
  {
    v9 = *(_DWORD *)(v8 - 20);
    if (v9 + *(_DWORD *)(v8 - 24) == a4)
      goto LABEL_19;
    return 0;
  }
  if (a2 == 7)
  {
    v9 = *(_DWORD *)(v8 - 20);
    if (v9 + *(_DWORD *)(v8 - 24) == a4 && *(_QWORD *)(v8 - 16) == *(_QWORD *)(a5 + 8))
      goto LABEL_19;
    return 0;
  }
  if (a2 != 3 || a1[3] != a4 || *(_QWORD *)(v8 - 16) != *(_QWORD *)(a5 + 8))
    return 0;
  v9 = *(_DWORD *)(v8 - 20);
LABEL_19:
  *(_DWORD *)(v8 - 20) = v9 + 1;
  return 1;
}

void TSWPStorageTransaction::appendToTransaction(uint64_t *a1, int a2, int a3, unint64_t a4, uint64_t a5, NSString *a6, unint64_t a7, unint64_t a8, uint64_t a9)
{
  int v16;
  int v17;
  objc_object *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  const __CFString *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;

  v30 = 0;
  v29 = 0;
  v31 = 0;
  v16 = (unsigned __int16)a2;
  LOWORD(v28) = a2;
  v17 = a2 - 1;
  if (a2 != 1)
    LODWORD(v29) = a3;
  if ((TSWPStorageTransaction::compressTransaction(a1, a2, a3, a4, a5) & 1) == 0)
  {
    v18 = 0;
    switch(v17)
    {
      case 0:
        TSWPStorageTransactionObject::setTextTransaction((TSWPStorageTransactionObject *)&v28, a7, a6, a8);
        a1[4] = (a1[1] - *a1) >> 5;
        goto LABEL_30;
      case 1:
        goto LABEL_19;
      case 2:
        if (a3 <= 9)
        {
          if (!a3)
          {
            TSWPStorageTransactionObject::setCharIndexTransaction((TSWPStorageTransactionObject *)&v28, *(_QWORD *)a5, 1uLL, *(objc_object **)(a5 + 8));
            goto LABEL_30;
          }
          if (a3 == 1)
            goto LABEL_29;
          goto LABEL_39;
        }
        if (a3 == 10)
          goto LABEL_29;
        if (a3 != 11 && a3 != 18)
        {
LABEL_39:
          TSWPStorageTransactionObject::setAttributeIndexTransaction((TSWPStorageTransactionObject *)&v28, a4, *(_QWORD *)a5, *(objc_object **)(a5 + 8));
          goto LABEL_30;
        }
LABEL_26:
        TSWPStorageTransactionObject::setParagraphDataTransaction(&v28, a4, *(_QWORD *)a5, *(_DWORD *)(a5 + 8));
LABEL_30:
        v26 = a1[1];
        if (v26 >= a1[2])
        {
          v27 = std::vector<TSWPStorageTransactionObject>::__push_back_slow_path<TSWPStorageTransactionObject const&>(a1, (const TSWPStorageTransactionObject *)&v28);
        }
        else
        {
          std::vector<TSWPStorageTransactionObject>::__construct_one_at_end[abi:nn180100]<TSWPStorageTransactionObject const&>((uint64_t)a1, (const TSWPStorageTransactionObject *)&v28);
          v27 = v26 + 32;
        }
        a1[1] = v27;
        v16 = (unsigned __int16)v28;
        break;
      case 3:
      case 4:
        LOWORD(v28) = 4;
        TSWPStorageTransactionObject::setCharDeltaTransaction(&v28, *(_QWORD *)a5, a4, a9);
        goto LABEL_30;
      case 5:
        TSWPStorageTransactionObject::setReplaceCharIndexTransaction((uint64_t)&v28, a4, *(_QWORD *)a5);
        goto LABEL_30;
      case 6:
        if (a3 <= 0x12 && ((1 << a3) & 0x40C02) != 0)
        {
          v24 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v25 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransaction::appendToTransaction(TSWPUndoKind, TSWPAttributeArrayKind, TSWPAttributeIndex, const TSWPAttributeRecord &, NSString *, TSWPCharIndex, NSUInteger, NSInteger)");
          objc_msgSend(v24, "handleFailureInFunction:file:lineNumber:description:", v25, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 202, CFSTR("Bad undo kind: kUndoKindReplaceObject."));
        }
        v18 = *(objc_object **)(a5 + 8);
LABEL_19:
        TSWPStorageTransactionObject::setInsertAttributeTransaction((TSWPStorageTransactionObject *)&v28, a4, 1uLL, v18);
        goto LABEL_30;
      case 7:
        if (a3 > 10)
        {
          if (a3 == 18 || a3 == 11)
            goto LABEL_26;
        }
        else if (a3 == 1 || a3 == 10)
        {
LABEL_29:
          TSWPStorageTransactionObject::setParagraphDataTransaction((uint64_t)&v28, a4, *(_QWORD *)a5, *(_WORD *)(a5 + 8), *(_WORD *)(a5 + 10));
          goto LABEL_30;
        }
        v19 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v20 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransaction::appendToTransaction(TSWPUndoKind, TSWPAttributeArrayKind, TSWPAttributeIndex, const TSWPAttributeRecord &, NSString *, TSWPCharIndex, NSUInteger, NSInteger)");
        v21 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm");
        v22 = CFSTR("Bad undo kind: kUndoKindReplaceParagraphData.");
        v23 = 218;
LABEL_7:
        objc_msgSend(v19, "handleFailureInFunction:file:lineNumber:description:", v20, v21, v23, v22);
        goto LABEL_30;
      default:
        v19 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v20 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransaction::appendToTransaction(TSWPUndoKind, TSWPAttributeArrayKind, TSWPAttributeIndex, const TSWPAttributeRecord &, NSString *, TSWPCharIndex, NSUInteger, NSInteger)");
        v21 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm");
        v22 = CFSTR("Bad undo kind for append to transaction.");
        v23 = 224;
        goto LABEL_7;
    }
  }
  a1[3] = a4;
  if (v16)
    TSWPStorageTransactionObject::adjustRetainCount((TSWPStorageTransactionObject *)&v28, 0);
}

void sub_217B62ECC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 a11)
{
  if (a11)
    TSWPStorageTransactionObject::adjustRetainCount((TSWPStorageTransactionObject *)&a11, 0);
  _Unwind_Resume(exception_object);
}

void TSWPStorageTransactionObject::TSWPStorageTransactionObject(TSWPStorageTransactionObject *this)
{
  *(_WORD *)this = 0;
  *(_QWORD *)((char *)this + 12) = 0;
  *(_QWORD *)((char *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
}

{
  *(_WORD *)this = 0;
  *(_QWORD *)((char *)this + 12) = 0;
  *(_QWORD *)((char *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
}

NSString *TSWPStorageTransactionObject::setTextTransaction(TSWPStorageTransactionObject *this, unint64_t a2, NSString *a3, unint64_t a4)
{
  NSString *result;
  void *v8;
  uint64_t v9;
  uint64_t v10;

  if (HIDWORD(a2))
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setTextTransaction(TSWPCharIndex, NSString *, NSUInteger)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1103, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a2) = -1;
  }
  *((_DWORD *)this + 2) = a2;
  result = a3;
  *((_QWORD *)this + 2) = result;
  if (HIDWORD(a4))
  {
    a4 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setTextTransaction(TSWPCharIndex, NSString *, NSUInteger)");
    result = (NSString *)objc_msgSend((id)a4, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1105, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a4) = -1;
  }
  *((_DWORD *)this + 3) = a4;
  return result;
}

objc_object *TSWPStorageTransactionObject::setInsertAttributeTransaction(TSWPStorageTransactionObject *this, unint64_t a2, unint64_t a3, objc_object *a4)
{
  objc_object *result;
  void *v8;
  uint64_t v9;
  uint64_t v10;

  if (HIDWORD(a2))
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setInsertAttributeTransaction(TSWPAttributeIndex, TSWPAttributeCount, id)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1136, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a2) = -1;
  }
  *((_DWORD *)this + 2) = a2;
  if (HIDWORD(a3))
  {
    a3 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setInsertAttributeTransaction(TSWPAttributeIndex, TSWPAttributeCount, id)");
    objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1137, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a3) = -1;
  }
  *((_DWORD *)this + 3) = a3;
  result = a4;
  *((_QWORD *)this + 2) = result;
  return result;
}

objc_object *TSWPStorageTransactionObject::setCharIndexTransaction(TSWPStorageTransactionObject *this, unint64_t a2, unint64_t a3, objc_object *a4)
{
  objc_object *result;
  void *v8;
  uint64_t v9;
  uint64_t v10;

  if (HIDWORD(a2))
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCharIndexTransaction(TSWPCharIndex, TSWPAttributeCount, id)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1111, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a2) = -1;
  }
  *((_DWORD *)this + 2) = a2;
  if (HIDWORD(a3))
  {
    a3 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCharIndexTransaction(TSWPCharIndex, TSWPAttributeCount, id)");
    objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1112, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a3) = -1;
  }
  *((_DWORD *)this + 3) = a3;
  result = a4;
  *((_QWORD *)this + 2) = result;
  return result;
}

uint64_t TSWPStorageTransactionObject::setParagraphDataTransaction(uint64_t this, unint64_t a2, unint64_t a3, __int16 a4, __int16 a5)
{
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;

  v8 = this;
  if (HIDWORD(a2))
  {
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setParagraphDataTransaction(TSWPAttributeIndex, TSWPCharIndex, UInt16, UInt16)");
    this = objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1154, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a2) = -1;
  }
  *(_DWORD *)(v8 + 8) = a2;
  *(_WORD *)(v8 + 12) = a4;
  *(_WORD *)(v8 + 14) = a5;
  if (HIDWORD(a3))
  {
    a3 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setParagraphDataTransaction(TSWPAttributeIndex, TSWPCharIndex, UInt16, UInt16)");
    this = objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1157, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a3) = -1;
  }
  *(_DWORD *)(v8 + 16) = a3;
  return this;
}

_DWORD *TSWPStorageTransactionObject::setParagraphDataTransaction(_DWORD *this, unint64_t a2, unint64_t a3, int a4)
{
  _DWORD *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = this;
  if (HIDWORD(a2))
  {
    v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setParagraphDataTransaction(TSWPAttributeIndex, TSWPCharIndex, UInt32)");
    this = (_DWORD *)objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1164, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a2) = -1;
  }
  v6[2] = a2;
  v6[3] = a4;
  if (HIDWORD(a3))
  {
    a3 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setParagraphDataTransaction(TSWPAttributeIndex, TSWPCharIndex, UInt32)");
    this = (_DWORD *)objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1166, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a3) = -1;
  }
  v6[4] = a3;
  return this;
}

objc_object *TSWPStorageTransactionObject::setAttributeIndexTransaction(TSWPStorageTransactionObject *this, unint64_t a2, unint64_t a3, objc_object *a4)
{
  objc_object *result;
  void *v8;
  uint64_t v9;
  uint64_t v10;

  if (HIDWORD(a2))
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setAttributeIndexTransaction(TSWPAttributeIndex, TSWPCharIndex, id)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1128, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a2) = -1;
  }
  *((_DWORD *)this + 2) = a2;
  if (HIDWORD(a3))
  {
    a3 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setAttributeIndexTransaction(TSWPAttributeIndex, TSWPCharIndex, id)");
    objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1129, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a3) = -1;
  }
  *((_DWORD *)this + 3) = a3;
  result = a4;
  *((_QWORD *)this + 2) = result;
  return result;
}

_DWORD *TSWPStorageTransactionObject::setCharDeltaTransaction(_DWORD *this, unint64_t a2, unint64_t a3, uint64_t a4)
{
  _DWORD *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = this;
  if (HIDWORD(a2))
  {
    v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCharDeltaTransaction(TSWPCharIndex, TSWPAttributeIndex, NSInteger)");
    this = (_DWORD *)objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1145, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a2) = -1;
  }
  v6[2] = a2;
  if (HIDWORD(a3))
  {
    a3 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCharDeltaTransaction(TSWPCharIndex, TSWPAttributeIndex, NSInteger)");
    this = (_DWORD *)objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1146, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a3) = -1;
  }
  v6[3] = a3;
  if (a4 >= 0x80000000)
  {
    a4 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCharDeltaTransaction(TSWPCharIndex, TSWPAttributeIndex, NSInteger)");
    this = (_DWORD *)objc_msgSend((id)a4, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1147, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a4) = 0x7FFFFFFF;
  }
  else if (a4 <= (uint64_t)0xFFFFFFFF7FFFFFFFLL)
  {
    a4 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCharDeltaTransaction(TSWPCharIndex, TSWPAttributeIndex, NSInteger)");
    this = (_DWORD *)objc_msgSend((id)a4, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1147, CFSTR("Out-of-bounds type assignment was clamped to min"));
    LODWORD(a4) = 0x80000000;
  }
  v6[4] = a4;
  return this;
}

uint64_t TSWPStorageTransactionObject::setReplaceCharIndexTransaction(uint64_t this, unint64_t a2, unint64_t a3)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = this;
  if (HIDWORD(a2))
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setReplaceCharIndexTransaction(TSWPAttributeIndex, TSWPCharIndex)");
    this = objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1119, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a2) = -1;
  }
  *(_DWORD *)(v4 + 8) = a2;
  if (HIDWORD(a3))
  {
    a3 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setReplaceCharIndexTransaction(TSWPAttributeIndex, TSWPCharIndex)");
    this = objc_msgSend((id)a3, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1120, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a3) = -1;
  }
  *(_DWORD *)(v4 + 12) = a3;
  *(_QWORD *)(v4 + 16) = 0;
  return this;
}

void TSWPStorageTransactionObject::~TSWPStorageTransactionObject(TSWPStorageTransactionObject *this)
{
  if (*(_WORD *)this)
    TSWPStorageTransactionObject::adjustRetainCount(this, 0);
}

{
  if (*(_WORD *)this)
    TSWPStorageTransactionObject::adjustRetainCount(this, 0);
}

void TSWPStorageTransaction::appendToTransaction(uint64_t *a1, int a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  TSWPStorageTransaction::appendToTransaction(a1, a2, a3, a4, a5, 0, 0x7FFFFFFFFFFFFFFFuLL, 0, a6);
}

void TSWPStorageTransaction::appendToTransaction(uint64_t *a1, int a2, NSString *a3, unint64_t a4, unint64_t a5)
{
  _QWORD v5[2];

  v5[0] = 0;
  v5[1] = 0;
  TSWPStorageTransaction::appendToTransaction(a1, a2, 0, 0x7FFFFFFFFFFFFFFFuLL, (uint64_t)v5, a3, a4, a5, 0);
}

void TSWPStorageTransaction::appendToTransaction(uint64_t *a1, __int16 a2, int a3, void *a4)
{
  unint64_t v5;
  uint64_t v6;
  _WORD v7[2];
  int v8;
  int v9;
  int v10;
  id v11;

  v8 = 0;
  v10 = 0;
  v7[0] = a2;
  v9 = a3;
  v11 = a4;
  v5 = a1[1];
  if (v5 >= a1[2])
  {
    v6 = std::vector<TSWPStorageTransactionObject>::__push_back_slow_path<TSWPStorageTransactionObject const&>(a1, (const TSWPStorageTransactionObject *)v7);
  }
  else
  {
    std::vector<TSWPStorageTransactionObject>::__construct_one_at_end[abi:nn180100]<TSWPStorageTransactionObject const&>((uint64_t)a1, (const TSWPStorageTransactionObject *)v7);
    v6 = v5 + 32;
  }
  a1[1] = v6;
  a1[3] = 0x7FFFFFFFFFFFFFFFLL;
  if (v7[0])
    TSWPStorageTransactionObject::adjustRetainCount((TSWPStorageTransactionObject *)v7, 0);
}

void sub_217B63950(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int16 a9)
{
  if (a9)
    TSWPStorageTransactionObject::adjustRetainCount((TSWPStorageTransactionObject *)&a9, 0);
  _Unwind_Resume(exception_object);
}

id TSWPStorageTransactionObject::setDOLCTransaction(uint64_t a1, int a2, void *a3)
{
  id result;

  *(_DWORD *)(a1 + 8) = a2;
  result = a3;
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

void TSWPStorageTransaction::appendToTransaction(uint64_t *a1, __int16 a2, int a3, unint64_t a4, NSDate *a5)
{
  unint64_t v6;
  uint64_t v7;
  _WORD v8[2];
  int v9;
  uint64_t v10;
  uint64_t v11;

  v10 = 0;
  v11 = 0;
  v8[0] = a2;
  v9 = a3;
  TSWPStorageTransactionObject::setCTDateTransaction((TSWPStorageTransactionObject *)v8, a4, a5);
  v6 = a1[1];
  if (v6 >= a1[2])
  {
    v7 = std::vector<TSWPStorageTransactionObject>::__push_back_slow_path<TSWPStorageTransactionObject const&>(a1, (const TSWPStorageTransactionObject *)v8);
  }
  else
  {
    std::vector<TSWPStorageTransactionObject>::__construct_one_at_end[abi:nn180100]<TSWPStorageTransactionObject const&>((uint64_t)a1, (const TSWPStorageTransactionObject *)v8);
    v7 = v6 + 32;
  }
  a1[1] = v7;
  a1[3] = 0x7FFFFFFFFFFFFFFFLL;
  if (v8[0])
    TSWPStorageTransactionObject::adjustRetainCount((TSWPStorageTransactionObject *)v8, 0);
}

void sub_217B63A24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int16 a9)
{
  if (a9)
    TSWPStorageTransactionObject::adjustRetainCount((TSWPStorageTransactionObject *)&a9, 0);
  _Unwind_Resume(exception_object);
}

NSDate *TSWPStorageTransactionObject::setCTDateTransaction(TSWPStorageTransactionObject *this, unint64_t a2, NSDate *a3)
{
  NSDate *result;
  void *v6;
  uint64_t v7;

  if (HIDWORD(a2))
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::setCTDateTransaction(TSWPAttributeIndex, NSDate *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1179, CFSTR("Out-of-bounds type assignment was clamped to max"));
    LODWORD(a2) = -1;
  }
  *((_DWORD *)this + 2) = a2;
  result = a3;
  *((_QWORD *)this + 2) = result;
  return result;
}

TSWPStorageTransaction *TSWPStorageTransaction::swap(TSWPStorageTransaction *this, TSWPStorageTransaction *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)this;
  *(_QWORD *)this = *(_QWORD *)a2;
  *(_QWORD *)a2 = v2;
  v3 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
  *((_QWORD *)a2 + 1) = v3;
  v4 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
  *((_QWORD *)a2 + 2) = v4;
  return this;
}

uint64_t TSWPStorageTransaction::compressCoalescedTransaction(TSWPStorageTransaction *this, TSWPStorageTransaction *a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  BOOL v6;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  BOOL v13;
  uint64_t v14;

  v2 = *((_QWORD *)this + 1);
  if (v2 != *(_QWORD *)this && *(_WORD *)(v2 - 32) == 1)
  {
    v3 = *(_QWORD *)a2;
    if (*((_QWORD *)a2 + 1) - *(_QWORD *)a2 == 32 && *(_WORD *)v3 == 1)
    {
      v4 = *(_DWORD *)(v2 - 20);
      v5 = *(_QWORD *)(v2 - 16);
      if (v4)
        v6 = v5 == 0;
      else
        v6 = 0;
      if (v6)
      {
        v12 = *(_DWORD *)(v3 + 12);
        if (v12)
          v13 = *(_QWORD *)(v3 + 16) == 0;
        else
          v13 = 0;
        if (!v13 || *(_DWORD *)(v2 - 24) + v4 != *(_DWORD *)(v3 + 8))
          return 0;
        *(_DWORD *)(v2 - 20) = v12 + v4;
        return 1;
      }
      if (v4)
        return 0;
      if (!v5 || *(_DWORD *)(v3 + 12) != 0)
        return 0;
      result = *(_QWORD *)(v3 + 16);
      if (!result)
        return result;
      v9 = *(unsigned int *)(v3 + 8);
      v10 = *(unsigned int *)(v2 - 24);
      if (v10 - objc_msgSend((id)result, "length") == v9)
      {
        v11 = objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithFormat:", CFSTR("%@%@"), *(_QWORD *)(v3 + 16), *(_QWORD *)(v2 - 16));

        *(_QWORD *)(v2 - 16) = v11;
        *(_DWORD *)(v2 - 24) = *(_DWORD *)(v3 + 8);
        return 1;
      }
      if (*(_DWORD *)(v3 + 8) == *(_DWORD *)(v2 - 24))
      {
        v14 = objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithFormat:", CFSTR("%@%@"), *(_QWORD *)(v2 - 16), *(_QWORD *)(v3 + 16));

        *(_QWORD *)(v2 - 16) = v14;
        return 1;
      }
    }
  }
  return 0;
}

void TSWPStorageTransaction::coalesceWithTransaction(TSWPStorageTransaction *this, TSWPStorageTransaction *a2)
{
  const TSWPStorageTransactionObject *v4;
  unint64_t v5;

  if ((TSWPStorageTransaction::compressCoalescedTransaction(this, a2) & 1) == 0)
  {
    v4 = *(const TSWPStorageTransactionObject **)a2;
    if (*(_QWORD *)a2 != *((_QWORD *)a2 + 1))
    {
      v5 = *((_QWORD *)this + 1);
      do
      {
        if (v5 >= *((_QWORD *)this + 2))
        {
          v5 = std::vector<TSWPStorageTransactionObject>::__push_back_slow_path<TSWPStorageTransactionObject const&>((uint64_t *)this, v4);
        }
        else
        {
          std::vector<TSWPStorageTransactionObject>::__construct_one_at_end[abi:nn180100]<TSWPStorageTransactionObject const&>((uint64_t)this, v4);
          v5 += 32;
        }
        *((_QWORD *)this + 1) = v5;
        v4 = (const TSWPStorageTransactionObject *)((char *)v4 + 32);
      }
      while (v4 != *((const TSWPStorageTransactionObject **)a2 + 1));
    }
  }
  std::vector<TSWPStorageTransactionObject>::__clear[abi:nn180100]((TSWPStorageTransactionObject **)a2);
}

void TSWPStorageTransactionObject::TSWPStorageTransactionObject(TSWPStorageTransactionObject *this, const TSWPStorageTransactionObject *a2)
{
  int v2;

  v2 = *(unsigned __int16 *)a2;
  *(_WORD *)this = v2;
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  if (v2)
    TSWPStorageTransactionObject::assignFrom(this, a2);
}

{
  int v2;

  v2 = *(unsigned __int16 *)a2;
  *(_WORD *)this = v2;
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  if (v2)
    TSWPStorageTransactionObject::assignFrom(this, a2);
}

void TSWPStorageTransactionObject::assignFrom(TSWPStorageTransactionObject *this, const TSWPStorageTransactionObject *a2)
{
  id v4;
  __int128 v5;
  void *v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  id v10;

  switch(*(_WORD *)this)
  {
    case 0:
    case 6:
      goto LABEL_3;
    case 1:
    case 2:
    case 7:
    case 9:
      goto LABEL_2;
    case 3:
      v8 = *((_DWORD *)this + 1);
      if (v8 <= 0x12 && ((1 << v8) & 0x40C02) != 0)
        goto LABEL_8;
LABEL_2:
      v4 = *((id *)a2 + 2);

LABEL_3:
      v5 = *(_OWORD *)((char *)a2 + 8);
      goto LABEL_4;
    case 4:
    case 5:
    case 8:
LABEL_8:
      v9 = *((_QWORD *)a2 + 1);
      *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
      *((_QWORD *)this + 1) = v9;
      return;
    case 0xA:
      v10 = *((id *)a2 + 2);

      v5 = *(_OWORD *)((char *)a2 + 8);
      *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
LABEL_4:
      *(_OWORD *)((char *)this + 8) = v5;
      break;
    default:
      v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::assignFrom(const TSWPStorageTransactionObject &)");
      objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1028, CFSTR("Bad undo kind for assign from."));
      break;
  }
}

TSWPStorageTransactionObject *TSWPStorageTransactionObject::operator=(TSWPStorageTransactionObject *this, TSWPStorageTransactionObject *a2)
{
  int v4;

  if (*(_WORD *)this)
    TSWPStorageTransactionObject::adjustRetainCount(this, 0);
  v4 = *(unsigned __int16 *)a2;
  *(_WORD *)this = v4;
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  if (v4)
    TSWPStorageTransactionObject::assignFrom(this, a2);
  return this;
}

void TSWPStorageTransactionObject::adjustRetainCount(TSWPStorageTransactionObject *this, int a2)
{
  unsigned int v2;
  int v3;
  void *v4;
  id v5;
  void *v6;
  uint64_t v7;
  unsigned int v8;

  v2 = *(unsigned __int16 *)this;
  if (v2 > 0xA)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPStorageTransactionObject::adjustRetainCount(BOOL)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStorageTransaction.mm"), 1082, CFSTR("Bad undo kind for adjust retain count."));
  }
  else
  {
    v3 = 1 << v2;
    if ((v3 & 0x175) == 0)
    {
      if ((v3 & 0x682) != 0 || (v8 = *((_DWORD *)this + 1), v8 > 0x12) || ((1 << v8) & 0x40C02) == 0)
      {
        v4 = (void *)*((_QWORD *)this + 2);
        if (v4)
        {
          if (a2)
            v5 = v4;
          else

        }
      }
    }
  }
}

uint64_t TSWPStorageTransactionObject::operator==(unsigned __int16 *a1, unsigned __int16 *a2)
{
  int v2;
  int v3;
  int v4;
  void *v5;
  void *v6;
  uint64_t v7;
  BOOL v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (*a1 != *a2)
    return 0;
  v2 = *((_DWORD *)a1 + 1);
  if (v2 != *((_DWORD *)a2 + 1))
    return 0;
  switch(*a1)
  {
    case 0u:
      if (*((_DWORD *)a1 + 2) != *((_DWORD *)a2 + 2) || *((_DWORD *)a1 + 3) != *((_DWORD *)a2 + 3))
        return 0;
      v8 = *((_QWORD *)a1 + 2) == *((_QWORD *)a2 + 2);
      goto LABEL_34;
    case 1u:
    case 2u:
    case 7u:
      goto LABEL_4;
    case 3u:
      if (v2 <= 9)
      {
        if (v2 == 1)
          goto LABEL_38;
        goto LABEL_4;
      }
      if (v2 == 10)
        goto LABEL_38;
      if (v2 != 11 && v2 != 18)
      {
LABEL_4:
        if (*((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2))
        {
          v3 = *((_DWORD *)a1 + 3);
          v4 = *((_DWORD *)a2 + 3);
LABEL_7:
          if (v3 == v4)
          {
            v5 = (void *)*((_QWORD *)a1 + 2);
            v6 = (void *)*((_QWORD *)a2 + 2);
            if (v5 == v6 || v5 && v6 && (objc_msgSend(v5, "isEqual:") & 1) != 0)
              return 1;
          }
        }
        return 0;
      }
LABEL_29:
      if (*((_DWORD *)a1 + 2) != *((_DWORD *)a2 + 2))
        return 0;
      v11 = *((_DWORD *)a1 + 3);
      v12 = *((_DWORD *)a2 + 3);
LABEL_31:
      if (v11 != v12)
        return 0;
      v9 = *((_DWORD *)a1 + 4);
      v10 = *((_DWORD *)a2 + 4);
LABEL_33:
      v8 = v9 == v10;
LABEL_34:
      v7 = v8;
      break;
    case 4u:
    case 5u:
      goto LABEL_29;
    case 6u:
      if (*((_DWORD *)a1 + 2) != *((_DWORD *)a2 + 2))
        return 0;
      v9 = *((_DWORD *)a1 + 3);
      v10 = *((_DWORD *)a2 + 3);
      goto LABEL_33;
    case 8u:
      v7 = 0;
      if (v2 <= 10)
      {
        if (v2 != 1 && v2 != 10)
          return v7;
LABEL_38:
        if (*((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2) && a1[6] == a2[6])
        {
          v11 = a1[7];
          v12 = a2[7];
          goto LABEL_31;
        }
        return 0;
      }
      if (v2 != 11 && v2 != 18)
        return v7;
      goto LABEL_29;
    case 9u:
    case 0xAu:
      v3 = *((_DWORD *)a1 + 2);
      v4 = *((_DWORD *)a2 + 2);
      goto LABEL_7;
    default:
      return 0;
  }
  return v7;
}

void std::vector<TSWPStorageTransactionObject>::__clear[abi:nn180100](TSWPStorageTransactionObject **a1)
{
  TSWPStorageTransactionObject *v2;
  TSWPStorageTransactionObject *v3;
  TSWPStorageTransactionObject *v4;
  BOOL v5;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = (TSWPStorageTransactionObject *)((char *)v2 - 32);
    do
    {
      if (*(_WORD *)v4)
        TSWPStorageTransactionObject::adjustRetainCount(v4, 0);
      v5 = v4 == v3;
      v4 = (TSWPStorageTransactionObject *)((char *)v4 - 32);
    }
    while (!v5);
  }
  a1[1] = v3;
}

void std::vector<TSWPStorageTransactionObject>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<TSWPStorageTransactionObject>::__clear[abi:nn180100]((TSWPStorageTransactionObject **)v2);
    operator delete(**a1);
  }
}

TSWPStorageTransactionObject *std::vector<TSWPStorageTransactionObject>::__init_with_size[abi:nn180100]<TSWPStorageTransactionObject*,TSWPStorageTransactionObject*>(TSWPStorageTransactionObject *result, TSWPStorageTransactionObject *a2, TSWPStorageTransactionObject *a3, unint64_t a4)
{
  TSWPStorageTransactionObject *v6;

  if (a4)
  {
    v6 = result;
    std::vector<TSDBrushVertexData>::__vallocate[abi:nn180100](result, a4);
    result = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<TSWPStorageTransactionObject>,TSWPStorageTransactionObject*,TSWPStorageTransactionObject*,TSWPStorageTransactionObject*>((int)v6 + 16, a2, a3, *((TSWPStorageTransactionObject **)v6 + 1));
    *((_QWORD *)v6 + 1) = result;
  }
  return result;
}

void sub_217B642E8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

TSWPStorageTransactionObject *std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<TSWPStorageTransactionObject>,TSWPStorageTransactionObject*,TSWPStorageTransactionObject*,TSWPStorageTransactionObject*>(int a1, TSWPStorageTransactionObject *a2, TSWPStorageTransactionObject *a3, TSWPStorageTransactionObject *this)
{
  TSWPStorageTransactionObject *v6;
  int v7;

  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      v7 = *(unsigned __int16 *)v6;
      *(_WORD *)this = v7;
      *((_DWORD *)this + 1) = *((_DWORD *)v6 + 1);
      *((_QWORD *)this + 1) = 0;
      *((_QWORD *)this + 2) = 0;
      if (v7)
        TSWPStorageTransactionObject::assignFrom(this, v6);
      v6 = (TSWPStorageTransactionObject *)((char *)v6 + 32);
      this = (TSWPStorageTransactionObject *)((char *)this + 32);
    }
    while (v6 != a3);
  }
  return this;
}

uint64_t std::vector<TSWPStorageTransactionObject>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  _QWORD v17[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      v14 = v7 + 32 * a2;
      do
      {
        *(_WORD *)v7 = 0;
        *(_QWORD *)(v7 + 12) = 0;
        *(_QWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v7 + 20) = 0;
        v7 += 32;
      }
      while (v7 != v14);
      v7 = v14;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      abort();
    v10 = v8 >> 5;
    v11 = v5 - *a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v17[4] = result;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Edge::CGPointVector>>(result, v12);
    else
      v13 = 0;
    v15 = &v13[32 * v10];
    v17[0] = v13;
    v17[1] = v15;
    v17[3] = &v13[32 * v12];
    v16 = &v15[32 * a2];
    do
    {
      *(_WORD *)v15 = 0;
      *(_QWORD *)(v15 + 12) = 0;
      *(_QWORD *)(v15 + 4) = 0;
      *((_DWORD *)v15 + 5) = 0;
      v15 += 32;
    }
    while (v15 != v16);
    v17[2] = v16;
    std::vector<TSWPStorageTransactionObject>::__swap_out_circular_buffer(a1, v17);
    return std::__split_buffer<TSWPStorageTransactionObject>::~__split_buffer((uint64_t)v17);
  }
  return result;
}

void sub_217B64468(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSWPStorageTransactionObject>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPStorageTransactionObject>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<TSWPStorageTransactionObject>,std::reverse_iterator<TSWPStorageTransactionObject*>,std::reverse_iterator<TSWPStorageTransactionObject*>,std::reverse_iterator<TSWPStorageTransactionObject*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<TSWPStorageTransactionObject>,std::reverse_iterator<TSWPStorageTransactionObject*>,std::reverse_iterator<TSWPStorageTransactionObject*>,std::reverse_iterator<TSWPStorageTransactionObject*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  int v12;
  uint64_t v13;

  if (a3 != a5)
  {
    v11 = 0;
    do
    {
      v12 = *(unsigned __int16 *)(a3 + v11 - 32);
      *(_WORD *)(a7 + v11 - 32) = v12;
      v13 = a7 + v11 - 32;
      *(_DWORD *)(v13 + 4) = *(_DWORD *)(a3 + v11 - 28);
      *(_QWORD *)(v13 + 8) = 0;
      *(_QWORD *)(v13 + 16) = 0;
      if (v12)
        TSWPStorageTransactionObject::assignFrom((TSWPStorageTransactionObject *)v13, (const TSWPStorageTransactionObject *)(a3 + v11 - 32));
      v11 -= 32;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

uint64_t std::__split_buffer<TSWPStorageTransactionObject>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<TSWPStorageTransactionObject>::__destruct_at_end[abi:nn180100](a1, *(TSWPStorageTransactionObject **)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

TSWPStorageTransactionObject *std::__split_buffer<TSWPStorageTransactionObject>::__destruct_at_end[abi:nn180100](uint64_t a1, TSWPStorageTransactionObject *a2)
{
  TSWPStorageTransactionObject *result;
  int v5;

  result = *(TSWPStorageTransactionObject **)(a1 + 16);
  while (result != a2)
  {
    v5 = *((unsigned __int16 *)result - 16);
    result = (TSWPStorageTransactionObject *)((char *)result - 32);
    *(_QWORD *)(a1 + 16) = result;
    if (v5)
    {
      TSWPStorageTransactionObject::adjustRetainCount(result, 0);
      result = *(TSWPStorageTransactionObject **)(a1 + 16);
    }
  }
  return result;
}

void std::vector<TSWPStorageTransactionObject>::__construct_one_at_end[abi:nn180100]<TSWPStorageTransactionObject const&>(uint64_t a1, const TSWPStorageTransactionObject *a2)
{
  uint64_t v3;
  int v4;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(unsigned __int16 *)a2;
  *(_WORD *)v3 = v4;
  *(_DWORD *)(v3 + 4) = *((_DWORD *)a2 + 1);
  *(_QWORD *)(v3 + 8) = 0;
  *(_QWORD *)(v3 + 16) = 0;
  if (v4)
    TSWPStorageTransactionObject::assignFrom((TSWPStorageTransactionObject *)v3, a2);
  *(_QWORD *)(a1 + 8) = v3 + 32;
}

void sub_217B6463C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPStorageTransactionObject>::__push_back_slow_path<TSWPStorageTransactionObject const&>(uint64_t *a1, const TSWPStorageTransactionObject *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  int v13;
  uint64_t v14;
  _QWORD v16[2];
  char *v17;
  char *v18;
  uint64_t v19;

  v2 = *a1;
  v3 = (a1[1] - *a1) >> 5;
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 59)
    abort();
  v8 = a1[2];
  v7 = (uint64_t)(a1 + 2);
  v9 = v8 - v2;
  if (v9 >> 4 > v4)
    v4 = v9 >> 4;
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0)
    v10 = 0x7FFFFFFFFFFFFFFLL;
  else
    v10 = v4;
  v19 = v7;
  if (v10)
    v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Edge::CGPointVector>>(v7, v10);
  else
    v11 = 0;
  v12 = &v11[32 * v3];
  v16[0] = v11;
  v16[1] = v12;
  v17 = v12;
  v18 = &v11[32 * v10];
  v13 = *(unsigned __int16 *)a2;
  *(_WORD *)v12 = v13;
  *((_DWORD *)v12 + 1) = *((_DWORD *)a2 + 1);
  *((_QWORD *)v12 + 1) = 0;
  *((_QWORD *)v12 + 2) = 0;
  if (v13)
  {
    TSWPStorageTransactionObject::assignFrom((TSWPStorageTransactionObject *)v12, a2);
    v12 = v17;
  }
  v17 = v12 + 32;
  std::vector<TSWPStorageTransactionObject>::__swap_out_circular_buffer(a1, v16);
  v14 = a1[1];
  std::__split_buffer<TSWPStorageTransactionObject>::~__split_buffer((uint64_t)v16);
  return v14;
}

void sub_217B64724(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSWPStorageTransactionObject>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

const char *TSWPSmartFieldAttributeArray::className(TSWPSmartFieldAttributeArray *this)
{
  return "TSWPSmartFieldAttributeArray";
}

_QWORD *TSWPSmartFieldAttributeArray::adoptStylesheetWithMapper(_QWORD *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;

  v3 = result[2];
  if (v3)
  {
    v6 = result;
    v7 = 0;
    v8 = 8;
    do
    {
      result = *(_QWORD **)(v6[4] + v8);
      if (result)
      {
        result = (_QWORD *)objc_msgSend(result, "adoptStylesheet:withMapper:", a2, a3);
        v3 = v6[2];
      }
      ++v7;
      v8 += 16;
    }
    while (v7 < v3);
  }
  return result;
}

void TSWPSmartFieldAttributeArray::applyObjectToCharRange(TSWPAttributeArray *this, objc_object *a2, _NSRange a3, TSKAddedToDocumentContext *a4, TSWPStorageTransaction *a5)
{
  NSUInteger length;
  NSUInteger location;
  unint64_t var2;
  unint64_t v12;
  NSUInteger v13;
  objc_object *v14;
  _NSRange v15;

  length = a3.length;
  location = a3.location;
  if (this->var1 == 12 && a3.location == TSWPAttributeArray::characterCount(this) && !length)
  {
    var2 = this->var2;
    v13 = location;
    v14 = a2;
    TSWPAttributeArray::insertAttribute(this, (const TSWPAttributeRecord *)&v13, var2, a4, a5);
    v12 = this->var2;
    v13 = location + 1;
    v14 = 0;
    TSWPAttributeArray::insertAttribute(this, (const TSWPAttributeRecord *)&v13, v12, a4, a5);
  }
  else
  {
    v15.location = location;
    v15.length = length;
    TSWPStyleAttributeArray::applyObjectToCharRange(this, a2, v15, a4, a5);
  }
}

void TSWPSmartFieldAttributeArray::willReplaceCharactersInRangeWithString(TSWPAttributeArray *this, _NSRange a2, uint64_t a3, uint64_t a4, uint64_t a5, TSWPStorageTransaction *a6)
{
  NSUInteger length;
  NSUInteger location;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSUInteger v18;
  NSUInteger v19;
  TSWPAttributeRecord **p_var4;
  BOOL v21;
  NSUInteger v22;
  NSRange v23;
  BOOL v24;
  void *v25;
  uint64_t v26;
  TSWPAttributeRecord *v27;
  _QWORD v28[2];
  NSRange v29;
  _NSRange v30;
  _NSRange v31;
  NSRange v32;

  length = a2.length;
  location = a2.location;
  LOBYTE(this[1].var0) = 1;
  if (this->var1 == 7
    && !TSWPStyleAttributeArray::deleteAttributesInRangeWithString((uint64_t)this, a2, a3, a4, a5, a6))
  {
    return;
  }
  if (!length || !a4)
  {
    v31.location = location;
    v31.length = length;
    TSWPStyleAttributeArray::willReplaceCharactersInRangeWithString(this, v31, a3, a4, a5, a6);
    return;
  }
  v30.location = location;
  v30.length = length;
  v13 = TSWPAttributeArray::calculateAttributeRangeForCharacterRange(this, v30);
  if (!v14)
    return;
  v15 = v13;
  v16 = v14;
  if (v13 >= this->var2)
  {
    p_var4 = &this->var4;
    v19 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    v17 = TSWPAttributeArray::rangeForAttributeIndex(this, v13);
    v19 = v17;
    p_var4 = &this->var4;
    if (*((_QWORD *)this->var4 + 2 * v15 + 1))
      v21 = v17 == 0x7FFFFFFFFFFFFFFFLL;
    else
      v21 = 1;
    if (!v21)
    {
      v22 = v18;
      v29.location = location;
      v29.length = length;
      v32.location = v19;
      v32.length = v22;
      v23 = NSIntersectionRange(v29, v32);
      v24 = v23.location == *MEMORY[0x24BEB3BF0] && v23.length == *(_QWORD *)(MEMORY[0x24BEB3BF0] + 8);
      if (!v24 && (location > v19 || location + length < v19 + v22))
      {
        v25 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v26 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "virtual void TSWPSmartFieldAttributeArray::willReplaceCharactersInRangeWithString(NSRange, NSString *, NSUInteger, markerArray &, TSWPStorageTransaction *)");
        objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPSmartFieldAttributeArray.mm"), 126, CFSTR("There should be no smart fields that overlap selections."));
      }
    }
  }
  if (v19 != location)
    goto LABEL_31;
  v27 = *p_var4;
  if (!*((_QWORD *)*p_var4 + 2 * v15 + 1))
  {
    ++v15;
    goto LABEL_26;
  }
  if (v15)
  {
    if (*((_QWORD *)v27 + 2 * v15 - 1))
    {
      v28[0] = location;
      v28[1] = 0;
      TSWPAttributeArray::insertAttribute(this, (const TSWPAttributeRecord *)v28, v15++, 0, a6);
    }
    goto LABEL_31;
  }
  if (!*((_QWORD *)v27 + 1))
  {
    v15 = 1;
LABEL_26:
    if (!--v16)
      return;
    goto LABEL_31;
  }
  TSWPAttributeArray::replaceObjectForAttributeIndex(this, 0, 0, 0, a6);
  if (--v16)
  {
    v15 = 1;
LABEL_31:
    LOBYTE(this[1].var0) = 0;
    (*((void (**)(TSWPAttributeArray *, unint64_t, uint64_t, TSWPStorageTransaction *))this->var0 + 7))(this, v15, v16, a6);
    (*((void (**)(TSWPAttributeArray *, unint64_t, TSWPStorageTransaction *))this->var0 + 29))(this, v15, a6);
    return;
  }
  if (this->var2 >= 2 && !*((_QWORD *)*p_var4 + 3))
    (*((void (**)(TSWPAttributeArray *, uint64_t, TSWPStorageTransaction *))this->var0 + 29))(this, 1, a6);
}

void TSWPSmartFieldAttributeArray::didReplaceCharactersInRangeWithString(TSWPAttributeArray *this, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, TSWPStorageTransaction *a7, uint64_t a8)
{
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t var2;
  uint64_t v20;
  unint64_t v21;
  unsigned int v22;
  unint64_t v23;
  uint64_t v24;

  if (a3
    || !a5
    || ((v22 = (*((uint64_t (**)(TSWPAttributeArray *, uint64_t))this->var0 + 35))(this, a8),
         !LOBYTE(this[1].var0))
      ? (v15 = 4)
      : (v15 = 5),
        (v16 = TSWPAttributeArray::calculateAttributeIndexForCharacterIndex(this, a2), v16 >= this->var2)
      ? (v17 = objc_msgSend(this->var5, "length") - a5)
      : (v17 = TSWPAttributeArray::charIndexForAttributeIndex(this, v16)),
        v17 != a2))
  {
    TSWPStyleAttributeArray::didReplaceCharactersInRangeWithString(this, a2, a3, a4, a5, a6, a7);
    return;
  }
  if (v16)
    v18 = *((_QWORD *)this->var4 + 2 * v16 - 1);
  else
    v18 = 0;
  var2 = this->var2;
  if (v16 >= var2)
  {
    v20 = 0;
    if (!v18)
      goto LABEL_22;
  }
  else
  {
    v20 = *((_QWORD *)this->var4 + 2 * v16 + 1);
    if (!v18)
      goto LABEL_22;
  }
  if (!v20)
  {
    if ((v22 | 2) != 2)
      goto LABEL_28;
    if (v16 != var2)
      goto LABEL_27;
    goto LABEL_26;
  }
LABEL_22:
  if (v18 && v20)
  {
    if (v22 == 2)
    {
LABEL_27:
      ++v16;
      LODWORD(v15) = 4;
      goto LABEL_28;
    }
    if (v22)
      goto LABEL_28;
LABEL_26:
    v23 = a2;
    v24 = 0;
    TSWPAttributeArray::insertAttribute(this, (const TSWPAttributeRecord *)&v23, v16, 0, a7);
    goto LABEL_27;
  }
  if (!v18 && v20)
  {
    if (v22 < 2)
    {
      if (!v16)
      {
        v23 = a2;
        v24 = 0;
        TSWPAttributeArray::insertAttribute(this, (const TSWPAttributeRecord *)&v23, 0, 0, a7);
        v15 = 4;
        v16 = 1;
      }
      goto LABEL_31;
    }
    if (v22 == 2)
      goto LABEL_27;
  }
LABEL_28:
  if (v16)
    v15 = v15;
  else
    v15 = 4;
LABEL_31:
  if (v16 <= 1)
    v21 = 1;
  else
    v21 = v16;
  TSWPAttributeArray::adjustCharIndexStartingAtAttributeIndex((uint64_t)this, v15, v21, a5);
}

uint64_t TSWPSmartFieldAttributeArray::styleInsertionBehaviorForReplacingSelection(uint64_t a1, uint64_t a2)
{
  return a2;
}

TSWPAttributeArray *TSWPSmartFieldAttributeArray::didInsertAttribute(TSWPAttributeArray *this, id *a2, TSKAddedToDocumentContext *a3, TSWPStorageTransaction *a4)
{
  if (!-[TSKAddedToDocumentContext changeTrackingSubstorage](a3, "changeTrackingSubstorage"))
    objc_msgSend(a2[1], "setParentStorage:", this->var5);
  return TSWPAttributeArray::didInsertAttribute(this, (const TSWPAttributeRecord *)a2, a3, a4);
}

TSWPAttributeArray *TSWPSmartFieldAttributeArray::willDeleteAttribute(TSWPAttributeArray *this, const TSWPAttributeRecord *a2, TSWPStorageTransaction *a3)
{
  TSWPAttributeArray *result;
  void *v6;

  result = TSWPAttributeArray::willDeleteAttribute(this, a2, a3);
  v6 = (void *)*((_QWORD *)a2 + 1);
  if (v6)
  {
    result = (TSWPAttributeArray *)objc_msgSend(v6, "parentStorage");
    if (result == this->var5)
      return (TSWPAttributeArray *)objc_msgSend(v6, "setParentStorage:", 0);
  }
  return result;
}

uint64_t TSWPSmartFieldAttributeArray::shouldDeleteAttributeBeforeReplace(TSWPSmartFieldAttributeArray *this)
{
  objc_opt_class();
  return objc_msgSend((id)TSUDynamicCast(), "allowsEditing");
}

void TSWPSmartFieldAttributeArray::~TSWPSmartFieldAttributeArray(TSWPAttributeArray *this)
{
  TSWPStyleAttributeArray::~TSWPStyleAttributeArray(this);
  JUMPOUT(0x219A153B8);
}

void TSWPAttachmentAttributeArray::~TSWPAttachmentAttributeArray(TSWPAttributeArray *this)
{
  uint64_t v2;
  unsigned int v3;

  this->var0 = (void **)&off_24D82EC68;
  if (this->var2)
  {
    v2 = 0;
    v3 = 1;
    do
    {
      if ((id)objc_msgSend(*((id *)this->var4 + 2 * v2 + 1), "parentStorage") == this->var5)
        objc_msgSend(*((id *)this->var4 + 2 * v2 + 1), "setParentStorage:", 0);
      (*((void (**)(TSWPAttributeArray *, char *))this->var0 + 24))(this, (char *)this->var4 + 16 * v2);
      v2 = v3;
    }
    while (this->var2 > v3++);
  }
  TSWPAttributeArray::~TSWPAttributeArray(this);
}

{
  TSWPAttachmentAttributeArray::~TSWPAttachmentAttributeArray(this);
  JUMPOUT(0x219A153B8);
}

void sub_217B64F48(_Unwind_Exception *a1)
{
  TSWPAttributeArray *v1;

  TSWPAttributeArray::~TSWPAttributeArray(v1);
  _Unwind_Resume(a1);
}

const char *TSWPAttachmentAttributeArray::className(TSWPAttachmentAttributeArray *this)
{
  return "TSWPAttachmentAttributeArray";
}

void TSWPAttachmentAttributeArray::deleteAttributes(TSWPAttributeArray *this, unint64_t a2, unint64_t a3, TSWPStorageTransaction *a4)
{
  id v8;
  unint64_t v9;
  void *v10;
  id v11;
  char *v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  id *v22;
  id *v23;
  id v24;
  char *v25;
  char *v26;
  char *v27;

  if (objc_msgSend(this->var5, "isDOLCSuppressed"))
  {
    TSWPAttributeArray::deleteAttributes(this, a2, a3, a4);
  }
  else if (a3 == 1)
  {
    v24 = (id)*((_QWORD *)this->var4 + 2 * a2 + 1);
    v8 = v24;
    TSWPAttributeArray::deleteAttributes(this, a2, 1uLL, a4);
    (*((void (**)(TSWPAttributeArray *, id, TSWPStorageTransaction *))this->var0 + 33))(this, v24, a4);

  }
  else
  {
    v25 = 0;
    v26 = 0;
    v27 = 0;
    std::vector<objc_object *>::reserve((void **)&v25, a3);
    if (a3 + a2 > a2)
    {
      v9 = a2;
      do
      {
        v10 = (void *)*((_QWORD *)this->var4 + 2 * v9 + 1);
        if (v10)
        {
          v11 = v10;
          v12 = v26;
          if (v26 >= v27)
          {
            v14 = (v26 - v25) >> 3;
            if ((unint64_t)(v14 + 1) >> 61)
              abort();
            v15 = (v27 - v25) >> 2;
            if (v15 <= v14 + 1)
              v15 = v14 + 1;
            if ((unint64_t)(v27 - v25) >= 0x7FFFFFFFFFFFFFF8)
              v16 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v16 = v15;
            if (v16)
              v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>((uint64_t)&v27, v16);
            else
              v17 = 0;
            v18 = &v17[8 * v14];
            *(_QWORD *)v18 = v10;
            v13 = v18 + 8;
            v20 = v25;
            v19 = v26;
            if (v26 != v25)
            {
              do
              {
                v21 = *((_QWORD *)v19 - 1);
                v19 -= 8;
                *((_QWORD *)v18 - 1) = v21;
                v18 -= 8;
              }
              while (v19 != v20);
              v19 = v25;
            }
            v25 = v18;
            v26 = v13;
            v27 = &v17[8 * v16];
            if (v19)
              operator delete(v19);
          }
          else
          {
            *(_QWORD *)v26 = v10;
            v13 = v12 + 8;
          }
          v26 = v13;
        }
        ++v9;
      }
      while (v9 != a3 + a2);
    }
    TSWPAttributeArray::deleteAttributes(this, a2, a3, a4);
    v22 = (id *)v25;
    v23 = (id *)v26;
    if (v25 != v26)
    {
      do
      {
        (*((void (**)(TSWPAttributeArray *, id, TSWPStorageTransaction *))this->var0 + 33))(this, *v22, a4);

      }
      while (v22 != v23);
      v22 = (id *)v25;
    }
    if (v22)
    {
      v26 = (char *)v22;
      operator delete(v22);
    }
  }
}

void sub_217B651E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *TSWPAttachmentAttributeArray::adoptStylesheetWithMapper(_QWORD *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;

  v3 = result[2];
  if (v3)
  {
    v6 = result;
    v7 = 0;
    v8 = 8;
    do
    {
      result = *(_QWORD **)(v6[4] + v8);
      if (result)
      {
        result = (_QWORD *)objc_msgSend(result, "adoptStylesheet:withMapper:", a2, a3);
        v3 = v6[2];
      }
      ++v7;
      v8 += 16;
    }
    while (v7 < v3);
  }
  return result;
}

_QWORD *TSWPAttachmentAttributeArray::willBeAddedToDocumentRoot(_QWORD *this, TSKDocumentRoot *a2, TSKAddedToDocumentContext *a3)
{
  unint64_t v3;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;

  v3 = this[2];
  if (v3)
  {
    v6 = this;
    v7 = 0;
    v8 = 8;
    do
    {
      this = *(_QWORD **)(v6[4] + v8);
      if (this)
      {
        this = (_QWORD *)objc_msgSend(this, "willBeAddedToDocumentRoot:context:", a2, a3);
        v3 = v6[2];
      }
      ++v7;
      v8 += 16;
    }
    while (v7 < v3);
  }
  return this;
}

_QWORD *TSWPAttachmentAttributeArray::wasAddedToDocumentRoot(_QWORD *this, TSKDocumentRoot *a2, TSKAddedToDocumentContext *a3)
{
  unint64_t v3;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;

  v3 = this[2];
  if (v3)
  {
    v6 = this;
    v7 = 0;
    v8 = 8;
    do
    {
      this = *(_QWORD **)(v6[4] + v8);
      if (this)
      {
        this = (_QWORD *)objc_msgSend(this, "wasAddedToDocumentRoot:context:", a2, a3);
        v3 = v6[2];
      }
      ++v7;
      v8 += 16;
    }
    while (v7 < v3);
  }
  return this;
}

_QWORD *TSWPAttachmentAttributeArray::willBeRemovedFromDocumentRoot(_QWORD *this, TSKDocumentRoot *a2)
{
  unint64_t v2;
  _QWORD *v4;
  unint64_t v5;
  uint64_t v6;

  v2 = this[2];
  if (v2)
  {
    v4 = this;
    v5 = 0;
    v6 = 8;
    do
    {
      this = *(_QWORD **)(v4[4] + v6);
      if (this)
      {
        this = (_QWORD *)objc_msgSend(this, "willBeRemovedFromDocumentRoot:", a2);
        v2 = v4[2];
      }
      ++v5;
      v6 += 16;
    }
    while (v5 < v2);
  }
  return this;
}

_QWORD *TSWPAttachmentAttributeArray::wasRemovedFromDocumentRoot(_QWORD *this, TSKDocumentRoot *a2)
{
  unint64_t v2;
  _QWORD *v4;
  unint64_t v5;
  uint64_t v6;

  v2 = this[2];
  if (v2)
  {
    v4 = this;
    v5 = 0;
    v6 = 8;
    do
    {
      this = *(_QWORD **)(v4[4] + v6);
      if (this)
      {
        this = (_QWORD *)objc_msgSend(this, "wasRemovedFromDocumentRoot:", a2);
        v2 = v4[2];
      }
      ++v5;
      v6 += 16;
    }
    while (v5 < v2);
  }
  return this;
}

uint64_t TSWPAttachmentAttributeArray::allowsNilObjects(TSWPAttachmentAttributeArray *this)
{
  return 0;
}

void sub_217B6682C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TSWPParagraphEnumerator *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a17);
  _Unwind_Resume(a1);
}

uint64_t pSetupIndentAnimation(CABasicAnimation *a1, CALayer *a2, double a3)
{
  CALayer *v6;
  double v7;
  double v8;
  double v9;
  double v10;

  v6 = -[CALayer presentationLayer](a2, "presentationLayer");
  if (!v6)
    v6 = a2;
  -[CALayer position](v6, "position");
  v8 = v7;
  v10 = v9 + a3;
  -[CABasicAnimation setFromValue:](a1, "setFromValue:", objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGPoint:"));
  -[CABasicAnimation setToValue:](a1, "setToValue:", objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGPoint:", v10, v8));
  return -[CALayer addAnimation:forKey:](a2, "addAnimation:forKey:", a1, CFSTR("position"));
}

void sub_217B6DFD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_217B6EA00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42,uint64_t a43,void *a44,uint64_t a45)
{
  _Unwind_Resume(exception_object);
}

void sub_217B710D8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217B7111C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217B711C8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217B71450(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217B71518(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::GetBytes(void *this, const char *a2, unsigned __int8 *a3)
{
  return objc_msgSend(this, "readBytes:count:", a2, a3);
}

uint64_t `anonymous namespace'::SkipForward(void *this, const char *a2)
{
  return objc_msgSend(this, "skipForwardBy:", a2);
}

void TSWPDropCapCTState::TSWPDropCapCTState(TSWPDropCapCTState *this, const TSWPDropCapCTState *a2)
{
  __int128 v4;

  *(_QWORD *)this = *(id *)a2;
  v4 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)this + 24) = v4;
}

{
  __int128 v4;

  *(_QWORD *)this = *(id *)a2;
  v4 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)this + 24) = v4;
}

uint64_t TSWPDropCapCTState::textProperties(id *this)
{
  return objc_msgSend((id)objc_msgSend(*this, "characterStyleOverridePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties"));
}

TSWPCharacterStyle *TSWPDropCapCTState::modifiedCharacterStyle(TSWPDropCapCTState *this, TSSStylesheet *a2, TSWPCharacterStyle *a3)
{
  if ((*((_BYTE *)this + 8) & 1) == 0)
    return a3;
  if (a3)
    return (TSWPCharacterStyle *)-[TSSStylesheet variationOfStyle:propertyMap:](a2, "variationOfStyle:propertyMap:", a3, objc_msgSend((id)objc_msgSend(*(id *)this, "characterStyleOverridePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties")));
  return -[TSSStyle initWithContext:name:overridePropertyMap:isVariation:]([TSWPCharacterStyle alloc], "initWithContext:name:overridePropertyMap:isVariation:", -[TSPObject context](a2, "context"), 0, objc_msgSend((id)objc_msgSend(*(id *)this, "characterStyleOverridePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties")), 0);
}

uint64_t TSWPDropCapCTState::reset(uint64_t this)
{
  *(_QWORD *)(this + 16) = 0x3FF0000000000000;
  return this;
}

void TSWPDropCapCTState::prepareForRelayout(void **a1, void *a2, void *a3)
{
  id v4[5];

  if (*a1 != a2)
  {
    TSWPDropCapCTState::TSWPDropCapCTState((uint64_t)v4, a2, a3);
    TSWPDropCapCTState::operator=((uint64_t)a1, (uint64_t)v4);

  }
}

void sub_217B71E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

double TSWPDropCapLayoutState::clearIterationState(TSWPDropCapLayoutState *this)
{
  double result;

  *((_DWORD *)this + 26) = 0;
  result = 0.0;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_QWORD *)this + 20) = 0;
  return result;
}

void TSWPDropCapLayoutState::TSWPDropCapLayoutState(TSWPDropCapLayoutState *this, const TSWPDropCapLayoutState *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  *((_QWORD *)this + 1) = *((id *)a2 + 1);
  v5 = *((_OWORD *)a2 + 1);
  v4 = *((_OWORD *)a2 + 2);
  *((_QWORD *)this + 31) = 0;
  *((_OWORD *)this + 1) = v5;
  *((_OWORD *)this + 2) = v4;
  *((_QWORD *)this + 32) = 0;
  *(_QWORD *)this = *(id *)a2;
  *((_OWORD *)this + 3) = *((_OWORD *)a2 + 3);
  v6 = *((_OWORD *)a2 + 4);
  v7 = *((_OWORD *)a2 + 5);
  v8 = *((_OWORD *)a2 + 7);
  *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
  *((_OWORD *)this + 7) = v8;
  *((_OWORD *)this + 4) = v6;
  *((_OWORD *)this + 5) = v7;
  v9 = *((_OWORD *)a2 + 8);
  v10 = *((_OWORD *)a2 + 9);
  v11 = *((_OWORD *)a2 + 11);
  *((_OWORD *)this + 10) = *((_OWORD *)a2 + 10);
  *((_OWORD *)this + 11) = v11;
  *((_OWORD *)this + 8) = v9;
  *((_OWORD *)this + 9) = v10;
  v12 = *((_OWORD *)a2 + 12);
  v13 = *((_OWORD *)a2 + 13);
  v14 = *((_OWORD *)a2 + 14);
  *((_QWORD *)this + 30) = *((_QWORD *)a2 + 30);
  *((_OWORD *)this + 13) = v13;
  *((_OWORD *)this + 14) = v14;
  *((_OWORD *)this + 12) = v12;
  std::shared_ptr<EQKit::StemStretch::Glyph>::operator=[abi:nn180100]((_QWORD *)this + 31, (uint64_t *)a2 + 31);
}

void sub_217B71F00(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<EQKit::StemStretch::Glyph>::~shared_ptr[abi:nn180100](v2);

  *(_QWORD *)(v1 + 8) = 0;
  _Unwind_Resume(a1);
}

void TSWPDropCapLayoutState::updateWithEndOfParagraph(TSWPDropCapLayoutState *this, double a2, int a3)
{
  char v3;
  uint64_t v4;

  if (a3)
    v3 = 5;
  else
    v3 = 1;
  *((_BYTE *)this + 240) = v3 | *((_BYTE *)this + 240) & 0xFA;
  v4 = *((_QWORD *)this + 31);
  if (v4 && *((_QWORD *)this + 7) && (!*((_BYTE *)this + 80) || (a3 & 1) == 0))
    fmax(a2, ceil(CGRectGetMaxY(*(CGRect *)(v4 + 48))));
}

uint64_t TSWPDropCapLayoutState::shouldReduceRequirementsToKeepInCurrentColumn(TSWPDropCapLayoutState *this)
{
  return *((unsigned __int8 *)this + 96) >> 7;
}

uint64_t TSWPDropCapLayoutState::updateWithEndOfColumn(uint64_t this)
{
  *(_BYTE *)(this + 240) |= 2u;
  return this;
}

uint64_t TSWPDropCapLayoutState::prepareForLayoutIteration(uint64_t this)
{
  ++*(_DWORD *)(this + 104);
  *(_QWORD *)(this + 184) = 0;
  *(_QWORD *)(this + 224) = 0;
  *(_QWORD *)(this + 168) = 0;
  *(_QWORD *)(this + 200) = 0;
  *(_QWORD *)(this + 208) = 0;
  *(_BYTE *)(this + 240) &= 0xE7u;
  return this;
}

uint64_t TSWPDropCapLayoutState::clearLayoutState(uint64_t this)
{
  *(_QWORD *)(this + 184) = 0;
  *(_QWORD *)(this + 224) = 0;
  *(_QWORD *)(this + 168) = 0;
  *(_QWORD *)(this + 200) = 0;
  *(_QWORD *)(this + 208) = 0;
  *(_BYTE *)(this + 240) &= 0xE7u;
  return this;
}

double TSWPDropCapLayoutState::reduceRequirements(TSWPDropCapLayoutState *this)
{
  uint64_t v1;
  double result;

  v1 = *((_QWORD *)this + 6);
  if (v1 != 0x7FFFFFFFFFFFFFFFLL)
  {
    TSWPDropCapLayoutState::updateSpacing(this, v1 + 1);
    *((_QWORD *)this + 3) = 0x3FF0000000000000;
    *((_QWORD *)this + 23) = 0;
    *((_QWORD *)this + 28) = 0;
    result = 0.0;
    *(_OWORD *)((char *)this + 200) = 0u;
    *((_BYTE *)this + 240) &= 0xE0u;
    *((_DWORD *)this + 26) = 0;
    *((_OWORD *)this + 7) = 0u;
    *((_OWORD *)this + 8) = 0u;
    *((_OWORD *)this + 9) = 0u;
    *((_OWORD *)this + 10) = 0u;
  }
  return result;
}

void TSWPDropCapLayoutState::prepareForRelayout(void **a1, void *a2)
{
  TSWPDropCapCTState::prepareForRelayout(a1 + 1, *a1, a2);
}

uint64_t TSWPDropCapLayoutState::dropCapHeightWithGuess(uint64_t this, double a2)
{
  if (*(_DWORD *)(this + 104) == 1)
    a2 = *(double *)(this + 128);
  *(double *)(this + 120) = a2;
  return this;
}

uint64_t TSWPDropCapLayoutState::lineCapHeightWithGuess(uint64_t this, double a2)
{
  if (*(_DWORD *)(this + 104) == 1)
    a2 = *(double *)(this + 160);
  *(double *)(this + 152) = a2;
  return this;
}

BOOL TSWPDropCapLayoutState::canFinalize(TSWPDropCapLayoutState *this)
{
  _BOOL8 result;

  if (!*((_QWORD *)this + 7) || (*((_BYTE *)this + 240) & 1) == 0)
    return 0;
  result = TSWPDropCapLayoutState::isSatifyingRequirements(this);
  if ((_DWORD)result)
    return *((_QWORD *)this + 29) != 0x7FFFFFFFFFFFFFFFLL;
  return result;
}

double TSWPDropCapLayoutState::adjustedAttachmentPosition(TSWPDropCapLayoutState *this, CGPoint a2, TSDLayout *a3, unint64_t a4)
{
  CGFloat y;
  double x;
  double v8;
  double v9;
  CGFloat v10;
  CGFloat v11;
  uint64_t v12;
  CGFloat v13;
  CGFloat v14;
  double v15;
  double v16;
  double v17;
  CGFloat v18;
  double MinY;
  double MidY;
  BOOL v22;
  double v24;
  double v25;
  double MinX;
  double MaxX;
  CGRect v28;
  CGRect v29;
  CGRect v30;
  CGRect v31;
  CGRect v32;

  y = a2.y;
  x = a2.x;
  if (*((_QWORD *)this + 7)
    && (*((_BYTE *)this + 96) & 0x20) != 0
    && *((_QWORD *)this + 5) + *((_QWORD *)this + 4) <= a4
    && *((_QWORD *)this + 31)
    && ceil(TSWPDropCapLayoutState::dropCapBottom(this)) > a2.y)
  {
    -[TSDAbstractLayout frame](a3, "frame");
    v10 = v8;
    v11 = v9;
    v12 = *((_QWORD *)this + 31);
    v13 = *(double *)(v12 + 56);
    v14 = *(double *)(v12 + 72);
    v15 = *(double *)(v12 + 64) + 18.0;
    if ((*(_DWORD *)(v12 + 24) & 0x1000) != 0)
      v16 = *(double *)(v12 + 48);
    else
      v16 = *(double *)(v12 + 48) + -18.0;
    v17 = x;
    v18 = y;
    MaxX = CGRectGetMaxX(*(CGRect *)(&v8 - 2));
    v28.origin.x = v16;
    v28.origin.y = v13;
    v28.size.width = v15;
    v28.size.height = v14;
    MinX = CGRectGetMinX(v28);
    v29.origin.x = v16;
    v29.origin.y = v13;
    v29.size.width = v15;
    v29.size.height = v14;
    v25 = CGRectGetMaxX(v29);
    v30.origin.x = x;
    v30.origin.y = y;
    v30.size.width = v10;
    v30.size.height = v11;
    v24 = CGRectGetMinX(v30);
    v31.origin.x = x;
    v31.origin.y = y;
    v31.size.width = v10;
    v31.size.height = v11;
    MinY = CGRectGetMinY(v31);
    v32.origin.x = v16;
    v32.origin.y = v13;
    v32.size.width = v15;
    v32.size.height = v14;
    MidY = CGRectGetMidY(v32);
    v22 = MaxX > MinX && v25 > v24 && MinY > MidY;
    if (v22 && (*((_BYTE *)this + 240) & 0x10) == 0)
    {
      *((_BYTE *)this + 240) |= 0x10u;
      *((CGFloat *)this + 17) = TSWPDropCapLayoutState::dropCapBottom(this);
    }
  }
  return x;
}

void sub_217B7268C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  if (a12)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

void sub_217B727E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  if (a13)
    operator delete(a13);
  if (a16)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

void sub_217B73524(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31)
{
  if (__p)
    operator delete(__p);
  if (a27)
    operator delete(a27);
  if (a30)
    operator delete(a30);
  _Unwind_Resume(exception_object);
}

void sub_217B73DA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CGColorRef color, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  CGColorRelease(color);

  _Unwind_Resume(a1);
}

void TSWPRangeVector::TSWPRangeVector(TSWPRangeVector *this, const _NSRange *a2)
{
  _NSRange *v4;
  uint64_t v5;
  _NSRange *v6;
  _NSRange *v7;
  _NSRange *end;
  _NSRange *begin;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  v4 = (_NSRange *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)&this->__end_cap_, 1uLL);
  v6 = &v4[v5];
  *v4 = *a2;
  v7 = v4 + 1;
  begin = this->__begin_;
  end = this->__end_;
  if (end != this->__begin_)
  {
    do
    {
      v4[-1] = end[-1];
      --v4;
      --end;
    }
    while (end != begin);
    end = this->__begin_;
  }
  this->__begin_ = v4;
  this->__end_ = v7;
  this->__end_cap_.__value_ = v6;
  if (end)
    operator delete(end);
  this->__end_ = v7;
}

void sub_217B74058(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<TSWPAdornmentLine>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<TSWPAdornmentLine>::__base_destruct_at_end[abi:nn180100]((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }
}

void std::vector<TSWPAdornmentLine>::__base_destruct_at_end[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 8); i != a2; i -= 80)
  {
    CGColorRelease(*(CGColorRef *)(i - 56));

  }
  *(_QWORD *)(a1 + 8) = a2;
}

void sub_217B741A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TSWPChangeEnumerator::~TSWPChangeEnumerator((TSWPChangeEnumerator *)&a9);
  _Unwind_Resume(a1);
}

void sub_217B74440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  void *v11;

  TSWPChangeEnumerator::~TSWPChangeEnumerator((TSWPChangeEnumerator *)&a9);
  v11 = *(void **)v9;
  if (*(_QWORD *)v9)
  {
    *(_QWORD *)(v9 + 8) = v11;
    operator delete(v11);
  }
  _Unwind_Resume(a1);
}

void sub_217B744E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_217B745C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TSWPChangeEnumerator::~TSWPChangeEnumerator((TSWPChangeEnumerator *)&a9);
  _Unwind_Resume(a1);
}

void sub_217B74694(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  uint64_t v12;
  void *v14;

  v14 = *(void **)(v12 - 56);
  if (v14)
  {
    *(_QWORD *)(v12 - 48) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_217B750AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  TSWPChangeEnumerator::~TSWPChangeEnumerator((TSWPChangeEnumerator *)&a37);
  _Unwind_Resume(a1);
}

void sub_217B7522C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TSWPChangeEnumerator::~TSWPChangeEnumerator((TSWPChangeEnumerator *)&a9);
  _Unwind_Resume(a1);
}

void sub_217B75380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TSWPChangeEnumerator::~TSWPChangeEnumerator((TSWPChangeEnumerator *)&a9);
  _Unwind_Resume(a1);
}

uint64_t TSTCellDictionarySetCellAtCellID(uint64_t a1, int a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;

  if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellDictionarySetCellAtCellID(TSTCellDictionary *, TSTCellID, TSTCell *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellDictionary.m"), 100, CFSTR("can't insert an invalid cell ID"));
  }
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  objc_msgSend(*(id *)(a1 + 8), "setObject:forKey:", a3, (a2 << 16) | (unint64_t)BYTE2(a2));
  return pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 16));
}

id TSTCellDictionaryCellAtCellID(uint64_t a1, int a2)
{
  void *v4;
  uint64_t v5;
  id v6;

  if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTCell *TSTCellDictionaryCellAtCellID(TSTCellDictionary *, TSTCellID)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellDictionary.m"), 88, CFSTR("can't look up an invalid cell ID"));
  }
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 16));
  v6 = (id)objc_msgSend(*(id *)(a1 + 8), "objectForKey:", (a2 << 16) | (unint64_t)BYTE2(a2));
  pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 16));
  return v6;
}

void sub_217B772F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_217B773C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;

  _Unwind_Resume(a1);
}

void sub_217B77420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::__deallocate_node(a1, *(id **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::__deallocate_node(uint64_t a1, id *a2)
{
  id *v2;
  id *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (id *)*v2;

      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t **std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::find<SFUtility::ObjcSharedPtr<TSTTableDataObject>>(_QWORD *a1, id *a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t ***v10;
  uint64_t **i;
  unint64_t v12;

  v4 = objc_msgSend(*a2, "hash");
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  for (i = *v10; i; i = (uint64_t **)*i)
  {
    v12 = (unint64_t)i[1];
    if (v12 == v6)
    {
      if ((objc_msgSend(i[2], "isEqual:", *a2) & 1) != 0)
        return i;
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(_QWORD *)&v5)
          v12 %= *(_QWORD *)&v5;
      }
      else
      {
        v12 &= *(_QWORD *)&v5 - 1;
      }
      if (v12 != v9)
        return 0;
    }
  }
  return i;
}

void *std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::__emplace_unique_key_args<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::pair<SFUtility::ObjcSharedPtr<TSTTableDataObject> const,unsigned int>>(uint64_t a1, id *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  void **v12;
  void *i;
  unint64_t v14;
  _QWORD *v15;
  void *v16;
  id v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t v26;

  v7 = objc_msgSend(*a2, "hash");
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      for (i = *v12; i; i = *(void **)i)
      {
        v14 = *((_QWORD *)i + 1);
        if (v14 == v8)
        {
          if ((objc_msgSend(*((id *)i + 2), "isEqual:", *a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9)
              v14 %= v9;
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3)
            break;
        }
      }
    }
  }
  v15 = (_QWORD *)(a1 + 16);
  i = operator new(0x20uLL);
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v8;
  v16 = *(void **)a3;
  *((_QWORD *)i + 2) = *(_QWORD *)a3;
  v17 = v16;
  *((_DWORD *)i + 6) = *(_DWORD *)(a3 + 8);
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v9 || (float)(v19 * (float)v9) < v18)
  {
    v20 = 1;
    if (v9 >= 3)
      v20 = (v9 & (v9 - 1)) != 0;
    v21 = v20 | (2 * v9);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::__unordered_map_hasher<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::hash<EQKit::StemStretch::Key>,std::equal_to<EQKit::StemStretch::Key>,true>,std::__unordered_map_equal<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::equal_to<EQKit::StemStretch::Key>,std::hash<EQKit::StemStretch::Key>,true>,std::allocator<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>>>::__rehash<true>(a1, v23);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v24 = *(_QWORD *)a1;
  v25 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v25)
  {
    *(_QWORD *)i = *v25;
LABEL_38:
    *v25 = i;
    goto LABEL_39;
  }
  *(_QWORD *)i = *v15;
  *v15 = i;
  *(_QWORD *)(v24 + 8 * v3) = v15;
  if (*(_QWORD *)i)
  {
    v26 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v26 >= v9)
        v26 %= v9;
    }
    else
    {
      v26 &= v9 - 1;
    }
    v25 = (_QWORD *)(*(_QWORD *)a1 + 8 * v26);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_217B77800(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,void *>>>::operator()[abi:nn180100](v2, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,void *>>>::operator()[abi:nn180100](uint64_t a1, id *a2)
{
  if (*(_BYTE *)(a1 + 8))
  {

  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

uint64_t *std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::__erase_unique<SFUtility::ObjcSharedPtr<TSTTableDataObject>>(_QWORD *a1, id *a2)
{
  uint64_t *result;

  result = (uint64_t *)std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::find<SFUtility::ObjcSharedPtr<TSTTableDataObject>>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  id *v3;
  void *__p;
  char v6;

  v2 = *a2;
  std::__hash_table<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::__unordered_map_hasher<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::hash<EQKit::StemStretch::Key>,std::equal_to<EQKit::StemStretch::Key>,true>,std::__unordered_map_equal<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::equal_to<EQKit::StemStretch::Key>,std::hash<EQKit::StemStretch::Key>,true>,std::allocator<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>>>::remove(a1, a2, (uint64_t)&__p);
  v3 = (id *)__p;
  __p = 0;
  if (v3)
  {
    if (v6)

    operator delete(v3);
  }
  return v2;
}

void std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,std::__unordered_map_hasher<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectHasher,TSTTableDataObjectEqual,true>,std::__unordered_map_equal<SFUtility::ObjcSharedPtr<TSTTableDataObject>,std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>,TSTTableDataObjectEqual,TSTTableDataObjectHasher,true>,std::allocator<std::__hash_value_type<SFUtility::ObjcSharedPtr<TSTTableDataObject>,unsigned int>>>::__deallocate_node(a1, *(id **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void sub_217B78180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  uint64_t v36;

  _Block_object_dispose(&a36, 8);
  _Block_object_dispose((const void *)(v36 - 200), 8);
  _Block_object_dispose((const void *)(v36 - 168), 8);
  _Block_object_dispose((const void *)(v36 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_217B78924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__25(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__25(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_217B78A48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSTCellStorageHeaderFlagsForStorage(uint64_t result)
{
  if (result)
    return *(unsigned __int16 *)(result + 4);
  return result;
}

unsigned __int8 *TSTCellStorageFormatFlagsForStorage(unsigned __int8 *result)
{
  if (result)
  {
    if (*result < 2u)
      return 0;
    else
      return (unsigned __int8 *)*((unsigned __int16 *)result + 5);
  }
  return result;
}

uint64_t p_TSTCellStorageExtraSizeForHeaderFlags(int a1)
{
  unsigned __int16 v1;

  if (a1)
  {
    v1 = (2 * a1) & 4;
    if ((a1 & 0x80) != 0)
      v1 += 4;
    if ((a1 & 0x400) != 0)
      v1 += 4;
    if ((a1 & 0x800) != 0)
      v1 += 4;
    if ((a1 & 4) != 0)
      v1 += 4;
    if ((a1 & 8) != 0)
      v1 += 4;
    if ((a1 & 0x100) != 0)
      v1 += 4;
    if ((a1 & 0x200) != 0)
      v1 += 4;
    if ((a1 & 0x1000) != 0)
      v1 += 4;
    if ((a1 & 0x10) != 0)
      v1 += 4;
    if ((a1 & 0x20) != 0)
      v1 += 8;
    if ((a1 & 0x40) != 0)
      v1 += 8;
  }
  else
  {
    return 0;
  }
  return v1;
}

uint64_t p_TSTV1CellStorageSizeForHeaderFlags(int a1)
{
  if (a1)
    return (unsigned __int16)(p_TSTCellStorageExtraSizeForHeaderFlags(a1) + 8);
  else
    return 8;
}

uint64_t TSTCellStorageSizeForHeaderFlags(int a1, int a2)
{
  unsigned __int16 v2;
  char v3;
  __int16 v4;
  __int16 v5;
  unsigned __int16 v6;

  v2 = 12;
  if (a2 | a1)
  {
    v3 = a2;
    v4 = p_TSTCellStorageExtraSizeForHeaderFlags(a1);
    if ((v3 & 1) != 0)
      v5 = 16;
    else
      v5 = 12;
    v6 = v4 + v5;
    if ((v3 & 8) != 0)
      v6 += 4;
    if ((v3 & 2) != 0)
      v6 += 4;
    if ((v3 & 4) != 0)
      v6 += 4;
    if ((v3 & 0x20) != 0)
      v6 += 4;
    if ((v3 & 0x10) != 0)
      v6 += 4;
    if ((v3 & 0x40) != 0)
      v6 += 4;
    if (v3 < 0)
      return (unsigned __int16)(v6 + 4);
    else
      return v6;
  }
  return v2;
}

uint64_t TSTCellStorageHeaderFlagsForCell(uint64_t a1)
{
  unsigned int v1;
  int v2;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 56))
      v1 = (2 * (*(_QWORD *)(a1 + 40) != 0)) | 0x80;
    else
      v1 = 2 * (*(_QWORD *)(a1 + 40) != 0);
    if ((*(_DWORD *)(a1 + 104) - 1) < 0xFFFFFFFE)
      v1 |= 4u;
    if (*(_QWORD *)(a1 + 72) || *(_DWORD *)(a1 + 64))
      v1 |= 0x200u;
    if (*(_QWORD *)(a1 + 88) || *(_DWORD *)(a1 + 80))
      v1 |= 0x1000u;
    v2 = BYTE1(*(_DWORD *)(a1 + 8));
    if (v2 == 3)
      v1 |= 0x10u;
  }
  else
  {
    v2 = 0;
    v1 = 0;
  }
  if ((v2 & 0xFFFFFFFB) == 2 || v2 == 7)
    v1 |= 0x20u;
  if (v2 == 5)
    return v1 | 0x40;
  else
    return v1;
}

uint64_t TSTCellStorageFormatFlagsForCell(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  int v12;

  if (!a1)
    return 0;
  v2 = (void *)a1[19];
  if (v2)
  {
    objc_msgSend(v2, "getFormatStruct");
    v3 = (v12 - 1) < 0xFFFFFFFE;
  }
  else
  {
    v3 = 0;
  }
  v4 = (void *)a1[21];
  if (v4)
  {
    objc_msgSend(v4, "getFormatStruct");
    if ((v12 - 1) >= 0xFFFFFFFE)
      v3 = v3;
    else
      v3 = v3 | 8;
  }
  v5 = (void *)a1[25];
  if (v5)
  {
    objc_msgSend(v5, "getFormatStruct");
    if ((v12 - 1) >= 0xFFFFFFFE)
      v3 = v3;
    else
      v3 = v3 | 2;
  }
  v6 = (void *)a1[23];
  if (v6)
  {
    objc_msgSend(v6, "getFormatStruct");
    if ((v12 - 1) >= 0xFFFFFFFE)
      v3 = v3;
    else
      v3 = v3 | 4;
  }
  v7 = (void *)a1[27];
  if (v7)
  {
    objc_msgSend(v7, "getFormatStruct");
    if ((v12 - 1) >= 0xFFFFFFFE)
      v3 = v3;
    else
      v3 = v3 | 0x10;
  }
  v8 = (void *)a1[29];
  if (v8)
  {
    objc_msgSend(v8, "getFormatStruct");
    if ((v12 - 1) >= 0xFFFFFFFE)
      v3 = v3;
    else
      v3 = v3 | 0x20;
  }
  v9 = (void *)a1[31];
  if (v9)
  {
    objc_msgSend(v9, "getFormatStruct");
    if ((v12 - 1) >= 0xFFFFFFFE)
      v3 = v3;
    else
      v3 = v3 | 0x40;
  }
  v10 = (void *)a1[33];
  if (v10)
  {
    objc_msgSend(v10, "getFormatStruct");
    if ((v12 - 1) >= 0xFFFFFFFE)
      return v3;
    else
      return v3 | 0x80;
  }
  return v3;
}

unsigned __int8 *TSTCellStorageVersionAssert(unsigned __int8 *result)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;

  if (*result >= 4u)
  {
    v1 = result;
    v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellStorageVersionAssert(TSTCellStorage *)");
    return (unsigned __int8 *)objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 250, CFSTR("Can't parse cell storage header version %d!"), *v1);
  }
  return result;
}

uint64_t TSTCellToCellStorage(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 v4;
  unint64_t v5;
  unsigned __int8 v6;
  unsigned __int16 v7;
  uint64_t v8;
  __int16 v9;
  int v10;
  unsigned int v11;
  int v12;
  void *v13;
  unsigned __int8 *v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  _DWORD *v18;
  int v19;
  int v20;
  unsigned __int8 *v21;
  int v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  unint64_t v27;
  int v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t result;
  int v34;
  void *v35;
  uint64_t v36;
  unsigned __int8 *v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  unsigned __int8 *v46;
  int v47;
  void *v48;
  uint64_t v49;
  unsigned __int8 *v50;
  uint64_t v52;
  void *v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;

  *a2 = 3;
  if (a1)
    v4 = *(_BYTE *)(a1 + 9);
  else
    v4 = 0;
  a2[2] = v4;
  v5 = *(_QWORD *)(a2 + 4) & 0xFFFFFFFFFFFF0000 | TSTCellStorageHeaderFlagsForCell(a1);
  *(_QWORD *)(a2 + 4) = v5;
  if (a1)
  {
    *(_QWORD *)(a2 + 4) = v5 & 0xFFFFFFFF0000FFFFLL | ((unint64_t)*(unsigned __int16 *)(a1 + 10) << 16);
    v6 = *(_BYTE *)(a1 + 272);
  }
  else
  {
    v6 = 0;
    *(_QWORD *)(a2 + 4) = v5 & 0xFFFFFFFF0000FFFFLL;
  }
  a2[3] = v6;
  v7 = TSTCellStorageFormatFlagsForCell((_QWORD *)a1);
  v8 = *(_QWORD *)(a2 + 4);
  *(_QWORD *)(a2 + 4) = v8 & 0xFFFFFFFFFFFFLL | ((unint64_t)v7 << 48);
  if (!a1)
  {
    *(_QWORD *)(a2 + 4) = v8 | ((unint64_t)v7 << 48);
    v12 = (unsigned __int16)v8;
    v10 = v7;
    if ((v8 & 2) != 0)
    {
      *((_DWORD *)a2 + 3) = 0;
      v15 = v8 & 0xFFFD;
      if ((v8 & 0x80) == 0)
      {
        v11 = 4;
        if ((v8 & 4) == 0)
          goto LABEL_47;
LABEL_38:
        v16 = &a2[v11 + 12];
        if (!a1)
        {
          v20 = 0;
          LOWORD(v12) = v15;
          goto LABEL_52;
        }
        LOWORD(v12) = v15;
LABEL_51:
        v20 = *(_DWORD *)(a1 + 100);
LABEL_52:
        *(_DWORD *)v16 = v20;
        v11 += 4;
        v12 &= 0xFFFBu;
        if ((v12 & 0x200) == 0)
        {
LABEL_57:
          if ((v12 & 0x1000) == 0)
          {
            if ((v12 & 0x10) != 0)
              goto LABEL_121;
            goto LABEL_59;
          }
          v37 = &a2[v11 + 12];
          if (a1)
            goto LABEL_87;
          v38 = 0;
LABEL_120:
          *(_DWORD *)v37 = v38;
          v11 += 4;
          v12 &= 0xEFFFu;
          if ((v12 & 0x10) != 0)
          {
LABEL_121:
            v46 = &a2[v11 + 12];
            if (!a1)
              goto LABEL_126;
            goto LABEL_122;
          }
LABEL_59:
          if ((v12 & 0x20) != 0)
            goto LABEL_128;
          goto LABEL_60;
        }
LABEL_53:
        v21 = &a2[v11 + 12];
        if (!a1)
        {
          v22 = 0;
          goto LABEL_56;
        }
LABEL_54:
        v22 = *(_DWORD *)(a1 + 64);
LABEL_56:
        *(_DWORD *)v21 = v22;
        v11 += 4;
        v12 &= 0xFDFFu;
        goto LABEL_57;
      }
      v19 = 0;
      v18 = a2 + 16;
      v17 = 4;
      LOWORD(v12) = v12 & 0xFFFD;
    }
    else
    {
      if ((v8 & 0x80) == 0)
      {
        v11 = 0;
        if ((v8 & 4) == 0)
        {
          if ((v8 & 0x200) == 0)
          {
            if ((v8 & 0x1000) == 0)
            {
              if ((v8 & 0x10) == 0)
              {
                if ((v8 & 0x20) == 0)
                {
                  if ((v8 & 0x40) != 0)
                  {
                    v13 = 0;
                    v14 = a2 + 12;
                    goto LABEL_162;
                  }
                  goto LABEL_61;
                }
                v50 = a2 + 12;
                goto LABEL_151;
              }
              v46 = a2 + 12;
              goto LABEL_126;
            }
            v38 = 0;
            v37 = a2 + 12;
            goto LABEL_120;
          }
          v22 = 0;
          v21 = a2 + 12;
          goto LABEL_56;
        }
        v20 = 0;
        v16 = a2 + 12;
        goto LABEL_52;
      }
      v17 = 0;
      v19 = 0;
      v18 = a2 + 12;
    }
LABEL_46:
    *v18 = v19;
    v11 = v17 + 4;
    v15 = v12 & 0xFF7F;
    if ((v12 & 4) == 0)
    {
LABEL_47:
      v12 = v15;
      if ((v15 & 0x200) == 0)
        goto LABEL_57;
      goto LABEL_53;
    }
    goto LABEL_38;
  }
  *(_QWORD *)(a2 + 4) = v8 | ((unint64_t)v7 << 48) | ((unint64_t)*(unsigned __int16 *)(a1 + 96) << 32);
  v9 = v8;
  v10 = v7;
  if ((v8 & 2) == 0)
  {
    if ((v8 & 0x80) == 0)
    {
      v11 = 0;
      if ((v8 & 4) == 0)
      {
        if ((v8 & 0x200) == 0)
        {
          if ((v8 & 0x1000) == 0)
          {
            if ((v8 & 0x10) == 0)
            {
              if ((v8 & 0x20) == 0)
              {
                if ((v8 & 0x40) == 0)
                {
                  if (!(_WORD)v8)
                    goto LABEL_63;
LABEL_62:
                  v23 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                  v24 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellToCellStorage(TSTCell *, TSTCellStorage *)");
                  objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v24, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 392, CFSTR("Failed to process all storage elements!"));
                  goto LABEL_63;
                }
                v14 = a2 + 12;
LABEL_155:
                if (*(_BYTE *)(a1 + 9))
                {
                  if (*(_BYTE *)(a1 + 9) == 5)
                  {
                    v13 = *(void **)(a1 + 16);
LABEL_161:
                    LOWORD(v12) = v9;
LABEL_162:
                    objc_msgSend(v13, "timeIntervalSinceReferenceDate");
                    *(_QWORD *)v14 = v59;
                    v11 += 8;
                    if ((v12 & 0xFFBF) != 0)
                      goto LABEL_62;
                    goto LABEL_63;
                  }
                  v57 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                  v58 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSDate *TSTCellDateValue(TSTCell *)");
                  objc_msgSend(v57, "handleFailureInFunction:file:lineNumber:description:", v58, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1021, CFSTR("can't get date value from a non-date cell: %p"), a1);
                }
                v13 = 0;
                goto LABEL_161;
              }
              v50 = a2 + 12;
              goto LABEL_130;
            }
            v46 = a2 + 12;
            goto LABEL_123;
          }
          v37 = a2 + 12;
          LOWORD(v12) = v9;
          goto LABEL_87;
        }
        v21 = a2 + 12;
        LOWORD(v12) = v9;
        goto LABEL_54;
      }
      v16 = a2 + 12;
      LOWORD(v12) = v9;
      goto LABEL_51;
    }
    v17 = 0;
    v18 = a2 + 12;
    LOWORD(v12) = v9;
    goto LABEL_42;
  }
  *((_DWORD *)a2 + 3) = *(_DWORD *)(a1 + 32);
  LOWORD(v12) = v8 & 0xFFFD;
  if ((v8 & 0x80) != 0)
  {
    v18 = a2 + 16;
    v17 = 4;
LABEL_42:
    v19 = *(_DWORD *)(a1 + 48);
    goto LABEL_46;
  }
  if ((v8 & 4) != 0)
  {
    v16 = a2 + 16;
    v11 = 4;
    goto LABEL_51;
  }
  if ((v8 & 0x200) != 0)
  {
    v21 = a2 + 16;
    v11 = 4;
    goto LABEL_54;
  }
  if ((v8 & 0x1000) != 0)
  {
    v37 = a2 + 16;
    v11 = 4;
LABEL_87:
    v38 = *(_DWORD *)(a1 + 80);
    goto LABEL_120;
  }
  if ((v8 & 0x10) != 0)
  {
    v46 = a2 + 16;
    v11 = 4;
LABEL_122:
    v9 = v12;
LABEL_123:
    if (*(unsigned __int8 *)(a1 + 9) << 8 == 768)
    {
      v47 = *(_DWORD *)(a1 + 16);
      goto LABEL_127;
    }
    LOWORD(v12) = v9;
LABEL_126:
    v48 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v49 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStringID(TSTCell *)");
    objc_msgSend(v48, "handleFailureInFunction:file:lineNumber:description:", v49, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 948, CFSTR("can't get string ID from non-string cell: %p"), a1);
    v47 = 0;
    v9 = v12;
LABEL_127:
    *(_DWORD *)v46 = v47;
    v11 += 4;
    v12 = v9 & 0xFFEF;
    if ((v9 & 0x20) != 0)
    {
LABEL_128:
      v50 = &a2[v11 + 12];
      if (a1)
      {
LABEL_129:
        v9 = v12;
LABEL_130:
        if ((*(_DWORD *)(a1 + 8) & 0xFB00) == 0x200 || BYTE1(*(_DWORD *)(a1 + 8)) == 7)
        {
          v52 = *(_QWORD *)(a1 + 16);
        }
        else
        {
          v52 = 0;
          if (BYTE1(*(_DWORD *)(a1 + 8)))
          {
            v53 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v54 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v53, "handleFailureInFunction:file:lineNumber:description:", v54, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a1);
          }
        }
LABEL_152:
        *(_QWORD *)v50 = v52;
        v11 += 8;
        v12 = v9 & 0xFFDF;
        if ((v9 & 0x40) != 0)
        {
LABEL_153:
          v14 = &a2[v11 + 12];
          if (!a1)
          {
            v13 = 0;
            goto LABEL_162;
          }
          goto LABEL_154;
        }
LABEL_61:
        if (!v12)
          goto LABEL_63;
        goto LABEL_62;
      }
LABEL_151:
      v55 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v56 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
      objc_msgSend(v55, "handleFailureInFunction:file:lineNumber:description:", v56, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 889, CFSTR("invalid nil value for '%s'"), "cell");
      v52 = 0;
      v9 = v12;
      goto LABEL_152;
    }
LABEL_60:
    if ((v12 & 0x40) != 0)
      goto LABEL_153;
    goto LABEL_61;
  }
  if ((v8 & 0x20) != 0)
  {
    v50 = a2 + 16;
    v11 = 4;
    goto LABEL_129;
  }
  if ((v8 & 0x40) != 0)
  {
    v14 = a2 + 16;
    v11 = 4;
LABEL_154:
    v9 = v12;
    goto LABEL_155;
  }
  v11 = 4;
  if ((v8 & 0xFFFD) != 0)
    goto LABEL_62;
LABEL_63:
  if ((v7 & 1) != 0)
  {
    if (a1)
      v34 = *(_DWORD *)(a1 + 144);
    else
      v34 = 0;
    *(_DWORD *)&a2[v11 + 12] = v34;
    v11 += 4;
    v10 &= 0xFFFEu;
    if ((v10 & 8) == 0)
    {
LABEL_65:
      if ((v10 & 2) == 0)
        goto LABEL_66;
      goto LABEL_94;
    }
  }
  else if ((v10 & 8) == 0)
  {
    goto LABEL_65;
  }
  if (a1)
    v39 = *(_DWORD *)(a1 + 160);
  else
    v39 = 0;
  *(_DWORD *)&a2[v11 + 12] = v39;
  v11 += 4;
  v10 &= ~8u;
  if ((v10 & 2) == 0)
  {
LABEL_66:
    if ((v10 & 4) == 0)
      goto LABEL_67;
    goto LABEL_98;
  }
LABEL_94:
  if (a1)
    v40 = *(_DWORD *)(a1 + 192);
  else
    v40 = 0;
  *(_DWORD *)&a2[v11 + 12] = v40;
  v11 += 4;
  v10 &= 0xFFFDu;
  if ((v10 & 4) == 0)
  {
LABEL_67:
    if ((v10 & 0x10) == 0)
      goto LABEL_68;
    goto LABEL_102;
  }
LABEL_98:
  if (a1)
    v41 = *(_DWORD *)(a1 + 176);
  else
    v41 = 0;
  *(_DWORD *)&a2[v11 + 12] = v41;
  v11 += 4;
  v10 &= 0xFFFBu;
  if ((v10 & 0x10) == 0)
  {
LABEL_68:
    if ((v10 & 0x20) == 0)
      goto LABEL_69;
    goto LABEL_106;
  }
LABEL_102:
  if (a1)
    v42 = *(_DWORD *)(a1 + 208);
  else
    v42 = 0;
  *(_DWORD *)&a2[v11 + 12] = v42;
  v11 += 4;
  v10 &= 0xFFEFu;
  if ((v10 & 0x20) == 0)
  {
LABEL_69:
    if ((v10 & 0x40) == 0)
      goto LABEL_70;
    goto LABEL_110;
  }
LABEL_106:
  if (a1)
    v43 = *(_DWORD *)(a1 + 224);
  else
    v43 = 0;
  *(_DWORD *)&a2[v11 + 12] = v43;
  v11 += 4;
  v10 &= 0xFFDFu;
  if ((v10 & 0x40) == 0)
  {
LABEL_70:
    if ((v10 & 0x80) == 0)
      goto LABEL_71;
    goto LABEL_114;
  }
LABEL_110:
  if (a1)
    v44 = *(_DWORD *)(a1 + 240);
  else
    v44 = 0;
  *(_DWORD *)&a2[v11 + 12] = v44;
  LOWORD(v11) = v11 + 4;
  v10 &= 0xFFBFu;
  if ((v10 & 0x80) == 0)
  {
LABEL_71:
    if (!v10)
      goto LABEL_73;
    goto LABEL_72;
  }
LABEL_114:
  if (a1)
    v45 = *(_DWORD *)(a1 + 256);
  else
    v45 = 0;
  *(_DWORD *)&a2[(unsigned __int16)v11 + 12] = v45;
  LOWORD(v11) = v11 + 4;
  if ((v10 & 0xFF7F) != 0)
  {
LABEL_72:
    v25 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v26 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellToCellStorage(TSTCell *, TSTCellStorage *)");
    objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 467, CFSTR("Failed to process all format storage elements!"));
  }
LABEL_73:
  v27 = *(_QWORD *)(a2 + 4);
  v28 = (unsigned __int16)v27;
  v29 = *a2;
  if (v29 <= 1)
    v30 = 0;
  else
    v30 = HIWORD(v27);
  v31 = (unsigned __int16)v11 + 12;
  if (v31 != TSTCellStorageSizeForHeaderFlags((unsigned __int16)*(_QWORD *)(a2 + 4), v30))
  {
    NSLog((NSString *)CFSTR("hate"));
    v27 = *(_QWORD *)(a2 + 4);
    v29 = *a2;
    v28 = (unsigned __int16)v27;
  }
  if (v29 <= 1)
    v32 = 0;
  else
    v32 = HIWORD(v27);
  result = TSTCellStorageSizeForHeaderFlags(v28, v32);
  if (v31 != result)
  {
    v35 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v36 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellToCellStorage(TSTCell *, TSTCellStorage *)");
    return objc_msgSend(v35, "handleFailureInFunction:file:lineNumber:description:", v36, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 474, CFSTR("Size miscalculation!"));
  }
  return result;
}

uint64_t TSTV1CellStorageToCell(unsigned __int8 *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  unsigned __int8 v6;
  int v7;
  unsigned int v8;
  int v9;
  void *v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  double *v18;
  int v19;
  double v20;
  int v21;
  double v22;
  double v23;
  int v24;
  void *v25;
  uint64_t v26;
  int v27;
  void *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  void *v32;
  int v33;
  void *v34;
  void *v35;
  uint64_t v36;

  if (*a1 >= 2u)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTV1CellStorageToCell(TSTV1CellStorage *, TSTCell *)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 482, CFSTR("wrong version of the storage used here"));
  }
  v6 = a1[2];
  TSTCellClearValue(a2);
  *(_BYTE *)(a2 + 9) = v6;
  *(_WORD *)(a2 + 10) = *((_WORD *)a1 + 3);
  *(_BYTE *)(a2 + 272) = a1[3];
  v7 = *((_DWORD *)a1 + 1);
  if ((v7 & 2) != 0)
  {
    *(_DWORD *)(a2 + 32) = *((_DWORD *)a1 + 2);
    v9 = v7 & 0xFFFC;
    v8 = 4;
    if ((v7 & 0x80) == 0)
      goto LABEL_8;
    goto LABEL_7;
  }
  v8 = 0;
  v9 = *((_DWORD *)a1 + 1) & 0xFFFE;
  if ((v7 & 0x80) != 0)
  {
LABEL_7:
    *(_DWORD *)(a2 + 48) = *(_DWORD *)&a1[v8 + 8];
    v8 += 4;
    v9 &= 0xFF7Eu;
  }
LABEL_8:
  if ((v9 & 4) != 0)
  {
    *(_DWORD *)(a2 + 100) = *(_DWORD *)&a1[v8 + 8];
    v8 += 4;
    v9 &= ~4u;
    if ((v9 & 0x200) == 0)
    {
LABEL_10:
      if ((v9 & 0x1000) == 0)
        goto LABEL_11;
      goto LABEL_20;
    }
  }
  else if ((v9 & 0x200) == 0)
  {
    goto LABEL_10;
  }
  *(_DWORD *)(a2 + 64) = *(_DWORD *)&a1[v8 + 8];
  v8 += 4;
  v9 &= 0xFDFFu;
  if ((v9 & 0x1000) == 0)
  {
LABEL_11:
    if ((v9 & 0x10) == 0)
      goto LABEL_12;
    goto LABEL_21;
  }
LABEL_20:
  *(_DWORD *)(a2 + 80) = *(_DWORD *)&a1[v8 + 8];
  v8 += 4;
  v9 &= 0xEFFFu;
  if ((v9 & 0x10) == 0)
  {
LABEL_12:
    if ((v9 & 0x20) == 0)
      goto LABEL_13;
    goto LABEL_28;
  }
LABEL_21:
  if (*(unsigned __int8 *)(a2 + 9) << 8 == 768)
  {
    *(_DWORD *)(a2 + 16) = *(_DWORD *)&a1[v8 + 8];
  }
  else
  {
    v16 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v17 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetStringID(TSTCell *, TSTTableDataListKey)");
    objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 958, CFSTR("can't set string ID on non-string cell: %p"), a2);
  }
  v8 += 4;
  v9 &= 0xFFEFu;
  if ((v9 & 0x20) == 0)
  {
LABEL_13:
    if ((v9 & 0x40) == 0)
      goto LABEL_14;
    goto LABEL_47;
  }
LABEL_28:
  v18 = (double *)&a1[v8 + 8];
  v19 = a1[2];
  if (v19 == 7)
  {
    v23 = *v18;
    v24 = *(_DWORD *)(a2 + 8);
    if ((v24 & 0xFF00) == 0)
    {
      TSTCellClearValue(a2);
      *(_BYTE *)(a2 + 9) = 7;
      v24 = *(_DWORD *)(a2 + 8);
    }
    if ((v24 & 0xFF00) != 0x700)
    {
      v25 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v26 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetDurationValue(TSTCell *, NSTimeInterval)");
      objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1080, CFSTR("can't set duration value on a non-duration cell: %p"), a2);
      goto LABEL_46;
    }
    goto LABEL_43;
  }
  if (v19 != 6)
  {
    v23 = *v18;
    v27 = *(_DWORD *)(a2 + 8);
    if ((v27 & 0xFF00) == 0)
    {
      TSTCellClearValue(a2);
      *(_BYTE *)(a2 + 9) = 2;
      v27 = *(_DWORD *)(a2 + 8);
    }
    if ((v27 & 0xFF00) != 0x200)
    {
      v30 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v31 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
      objc_msgSend(v30, "handleFailureInFunction:file:lineNumber:description:", v31, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 912, CFSTR("can't set value to non-value cell: %p"), a2);
      goto LABEL_46;
    }
LABEL_43:
    *(double *)(a2 + 16) = v23;
    goto LABEL_46;
  }
  v20 = *v18;
  v21 = *(_DWORD *)(a2 + 8);
  if ((v21 & 0xFF00) == 0)
  {
    TSTCellClearValue(a2);
    *(_BYTE *)(a2 + 9) = 6;
    v21 = *(_DWORD *)(a2 + 8);
  }
  if ((v21 & 0xFF00) == 0x600)
  {
    v22 = 0.0;
    if (v20 != 0.0)
      v22 = 1.0;
    *(double *)(a2 + 16) = v22;
  }
  else
  {
    v28 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v29 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetBoolValue(TSTCell *, BOOL)");
    objc_msgSend(v28, "handleFailureInFunction:file:lineNumber:description:", v29, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 939, CFSTR("can't set BOOL value to non-BOOL cell: %p"), a2);
  }
LABEL_46:
  v8 += 8;
  v9 &= 0xFFDFu;
  if ((v9 & 0x40) == 0)
  {
LABEL_14:
    if (!v9)
      goto LABEL_16;
    goto LABEL_15;
  }
LABEL_47:
  v32 = (void *)objc_msgSend(MEMORY[0x24BDBCE60], "dateWithTimeIntervalSinceReferenceDate:", *(double *)&a1[v8 + 8]);
  v33 = *(_DWORD *)(a2 + 8);
  if ((v33 & 0xFF00) == 0)
  {
    TSTCellClearValue(a2);
    *(_BYTE *)(a2 + 9) = 5;
    v33 = *(_DWORD *)(a2 + 8);
  }
  if ((v33 & 0xFF00) == 0x500)
  {
    v34 = *(void **)(a2 + 16);
    if (v34 != v32)
    {

      *(_QWORD *)(a2 + 16) = v32;
    }
  }
  else
  {
    v35 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v36 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetDateValue(TSTCell *, NSDate *)");
    objc_msgSend(v35, "handleFailureInFunction:file:lineNumber:description:", v36, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1038, CFSTR("can't set date value on a non-date cell: %p"), a2);
  }
  v8 += 8;
  if ((v9 & 0xFFBF) != 0)
  {
LABEL_15:
    v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTV1CellStorageToCell(TSTV1CellStorage *, TSTCell *)");
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 602, CFSTR("Failed to process all storage elements!"));
  }
LABEL_16:
  result = *((unsigned __int16 *)a1 + 2);
  if (*((_WORD *)a1 + 2))
  {
    result = p_TSTCellStorageExtraSizeForHeaderFlags(result);
    v13 = (unsigned __int16)(result + 8);
  }
  else
  {
    v13 = 8;
  }
  if (v8 + 8 != v13)
  {
    v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTV1CellStorageToCell(TSTV1CellStorage *, TSTCell *)");
    return objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 605, CFSTR("Size miscalculation!"));
  }
  return result;
}

void TSTCellStorageToCell(unsigned __int8 *a1, uint64_t a2)
{
  unsigned __int8 v4;
  unint64_t v5;
  int v6;
  unsigned int v7;
  void *v8;
  uint64_t v9;
  double *v10;
  int v11;
  double v12;
  int v13;
  double v14;
  double v15;
  int v16;
  void *v17;
  uint64_t v18;
  int v19;
  void *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  unint64_t v24;
  void *v25;
  uint64_t v26;
  unint64_t v27;
  int v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  int v32;
  void *v33;
  int v34;
  void *v35;
  void *v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;

  TSTCellStorageVersionAssert(a1);
  TSTCellClear(a2);
  if (!a1)
    return;
  if (*a1 <= 1u)
  {
    TSTV1CellStorageToCell(a1, a2);
    return;
  }
  v4 = a1[2];
  TSTCellClearValue(a2);
  *(_BYTE *)(a2 + 9) = v4;
  *(_WORD *)(a2 + 10) = *((_WORD *)a1 + 3);
  *(_BYTE *)(a2 + 272) = a1[3];
  *(_WORD *)(a2 + 96) = *((_DWORD *)a1 + 2);
  v5 = *(_QWORD *)(a1 + 4);
  v6 = (unsigned __int16)v5;
  if ((v5 & 2) != 0)
  {
    *(_DWORD *)(a2 + 32) = *((_DWORD *)a1 + 3);
    v6 = v5 & 0xFFFD;
    v7 = 4;
    if ((v5 & 0x80) == 0)
      goto LABEL_9;
    goto LABEL_8;
  }
  v7 = 0;
  if ((v5 & 0x80) != 0)
  {
LABEL_8:
    *(_DWORD *)(a2 + 48) = *(_DWORD *)&a1[v7 + 12];
    v7 += 4;
    v6 &= 0xFF7Fu;
  }
LABEL_9:
  if ((v6 & 4) != 0)
  {
    *(_DWORD *)(a2 + 100) = *(_DWORD *)&a1[v7 + 12];
    v7 += 4;
    v6 &= 0xFFFBu;
    if ((v6 & 0x200) == 0)
    {
LABEL_11:
      if ((v6 & 0x1000) == 0)
        goto LABEL_12;
      goto LABEL_17;
    }
  }
  else if ((v6 & 0x200) == 0)
  {
    goto LABEL_11;
  }
  *(_DWORD *)(a2 + 64) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  v6 &= 0xFDFFu;
  if ((v6 & 0x1000) == 0)
  {
LABEL_12:
    if ((v6 & 0x10) == 0)
      goto LABEL_13;
    goto LABEL_18;
  }
LABEL_17:
  *(_DWORD *)(a2 + 80) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  v6 &= 0xEFFFu;
  if ((v6 & 0x10) == 0)
  {
LABEL_13:
    if ((v6 & 0x20) == 0)
      goto LABEL_41;
LABEL_22:
    v10 = (double *)&a1[v7 + 12];
    v11 = a1[2];
    if (v11 == 7)
    {
      v15 = *v10;
      v16 = *(_DWORD *)(a2 + 8);
      if ((v16 & 0xFF00) == 0)
      {
        TSTCellClearValue(a2);
        *(_BYTE *)(a2 + 9) = 7;
        v16 = *(_DWORD *)(a2 + 8);
      }
      if ((v16 & 0xFF00) != 0x700)
      {
        v17 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v18 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetDurationValue(TSTCell *, NSTimeInterval)");
        objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1080, CFSTR("can't set duration value on a non-duration cell: %p"), a2);
LABEL_40:
        v7 += 8;
        v6 &= 0xFFDFu;
        goto LABEL_41;
      }
    }
    else
    {
      if (v11 == 6)
      {
        v12 = *v10;
        v13 = *(_DWORD *)(a2 + 8);
        if ((v13 & 0xFF00) == 0)
        {
          TSTCellClearValue(a2);
          *(_BYTE *)(a2 + 9) = 6;
          v13 = *(_DWORD *)(a2 + 8);
        }
        if ((v13 & 0xFF00) == 0x600)
        {
          v14 = 0.0;
          if (v12 != 0.0)
            v14 = 1.0;
          *(double *)(a2 + 16) = v14;
        }
        else
        {
          v20 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v21 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetBoolValue(TSTCell *, BOOL)");
          objc_msgSend(v20, "handleFailureInFunction:file:lineNumber:description:", v21, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 939, CFSTR("can't set BOOL value to non-BOOL cell: %p"), a2);
        }
        goto LABEL_40;
      }
      v15 = *v10;
      v19 = *(_DWORD *)(a2 + 8);
      if ((v19 & 0xFF00) == 0)
      {
        TSTCellClearValue(a2);
        *(_BYTE *)(a2 + 9) = 2;
        v19 = *(_DWORD *)(a2 + 8);
      }
      if ((v19 & 0xFF00) != 0x200)
      {
        v22 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v23 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
        objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 912, CFSTR("can't set value to non-value cell: %p"), a2);
        goto LABEL_40;
      }
    }
    *(double *)(a2 + 16) = v15;
    goto LABEL_40;
  }
LABEL_18:
  if (*(unsigned __int8 *)(a2 + 9) << 8 == 768)
  {
    *(_DWORD *)(a2 + 16) = *(_DWORD *)&a1[v7 + 12];
  }
  else
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetStringID(TSTCell *, TSTTableDataListKey)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 958, CFSTR("can't set string ID on non-string cell: %p"), a2);
  }
  v7 += 4;
  v6 &= 0xFFEFu;
  if ((v6 & 0x20) != 0)
    goto LABEL_22;
LABEL_41:
  v24 = HIWORD(v5);
  if ((v6 & 0x40) != 0)
  {
    v33 = (void *)objc_msgSend(MEMORY[0x24BDBCE60], "dateWithTimeIntervalSinceReferenceDate:", *(double *)&a1[v7 + 12]);
    v34 = *(_DWORD *)(a2 + 8);
    if ((v34 & 0xFF00) == 0)
    {
      TSTCellClearValue(a2);
      *(_BYTE *)(a2 + 9) = 5;
      v34 = *(_DWORD *)(a2 + 8);
    }
    if ((v34 & 0xFF00) == 0x500)
    {
      v35 = *(void **)(a2 + 16);
      if (v35 != v33)
      {

        *(_QWORD *)(a2 + 16) = v33;
      }
    }
    else
    {
      v38 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v39 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetDateValue(TSTCell *, NSDate *)");
      objc_msgSend(v38, "handleFailureInFunction:file:lineNumber:description:", v39, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1038, CFSTR("can't set date value on a non-date cell: %p"), a2);
    }
    v7 += 8;
    v6 &= 0xFFBFu;
    if ((v5 & 0x1000000000000) == 0)
    {
LABEL_43:
      if ((v5 & 0x8000000000000) == 0)
        goto LABEL_44;
      goto LABEL_72;
    }
  }
  else if ((v5 & 0x1000000000000) == 0)
  {
    goto LABEL_43;
  }
  *(_DWORD *)(a2 + 144) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  LODWORD(v24) = HIWORD(v5) & 0xFFFE;
  if ((v5 & 0x8000000000000) == 0)
  {
LABEL_44:
    if ((v24 & 2) == 0)
      goto LABEL_45;
    goto LABEL_73;
  }
LABEL_72:
  *(_DWORD *)(a2 + 160) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  LODWORD(v24) = v24 & 0xFFFFFFF7;
  if ((v24 & 2) == 0)
  {
LABEL_45:
    if ((v24 & 4) == 0)
      goto LABEL_46;
    goto LABEL_74;
  }
LABEL_73:
  *(_DWORD *)(a2 + 192) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  LODWORD(v24) = v24 & 0xFFFD;
  if ((v24 & 4) == 0)
  {
LABEL_46:
    if ((v24 & 0x10) == 0)
      goto LABEL_47;
    goto LABEL_75;
  }
LABEL_74:
  *(_DWORD *)(a2 + 176) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  LODWORD(v24) = v24 & 0xFFFB;
  if ((v24 & 0x10) == 0)
  {
LABEL_47:
    if ((v24 & 0x20) == 0)
      goto LABEL_48;
    goto LABEL_76;
  }
LABEL_75:
  *(_DWORD *)(a2 + 208) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  LODWORD(v24) = v24 & 0xFFEF;
  if ((v24 & 0x20) == 0)
  {
LABEL_48:
    if ((v24 & 0x40) == 0)
      goto LABEL_49;
LABEL_77:
    *(_DWORD *)(a2 + 240) = *(_DWORD *)&a1[v7 + 12];
    LOWORD(v7) = v7 + 4;
    LODWORD(v24) = v24 & 0xFFBF;
    if ((v24 & 0x80) == 0)
      goto LABEL_51;
    goto LABEL_50;
  }
LABEL_76:
  *(_DWORD *)(a2 + 224) = *(_DWORD *)&a1[v7 + 12];
  v7 += 4;
  LODWORD(v24) = v24 & 0xFFDF;
  if ((v24 & 0x40) != 0)
    goto LABEL_77;
LABEL_49:
  if ((v24 & 0x80) != 0)
  {
LABEL_50:
    *(_DWORD *)(a2 + 256) = *(_DWORD *)&a1[(unsigned __int16)v7 + 12];
    LOWORD(v7) = v7 + 4;
    LODWORD(v24) = v24 & 0xFF7F;
  }
LABEL_51:
  if (v24 | v6)
  {
    v25 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v26 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellStorageToCell(TSTCellStorage *, TSTCell *)");
    objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 831, CFSTR("Failed to process all storage elements!"));
  }
  v27 = *(_QWORD *)(a1 + 4);
  v28 = (unsigned __int16)v27;
  v29 = *a1;
  if (v29 <= 1)
    v30 = 0;
  else
    v30 = HIWORD(v27);
  v31 = (unsigned __int16)v7 + 12;
  if (v31 != TSTCellStorageSizeForHeaderFlags((unsigned __int16)*(_QWORD *)(a1 + 4), v30))
  {
    NSLog((NSString *)CFSTR("hate"));
    v27 = *(_QWORD *)(a1 + 4);
    v29 = *a1;
    v28 = (unsigned __int16)v27;
  }
  if (v29 <= 1)
    v32 = 0;
  else
    v32 = HIWORD(v27);
  if (v31 != TSTCellStorageSizeForHeaderFlags(v28, v32))
  {
    v36 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v37 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellStorageToCell(TSTCellStorage *, TSTCell *)");
    objc_msgSend(v36, "handleFailureInFunction:file:lineNumber:description:", v37, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 838, CFSTR("Size miscalculation!"));
  }
}

uint64_t TSTCellStorageGetElement(uint64_t a1, uint64_t a2)
{
  int v3;
  unsigned int v4;
  void *v6;
  uint64_t v7;

  v3 = *(_DWORD *)(a1 + 4);
  if ((v3 & 2) != 0)
  {
    if ((_DWORD)a2 == 2)
      return a1 + 12;
    v4 = 4;
    if ((v3 & 0x80) == 0)
    {
LABEL_3:
      if ((v3 & 0x400) == 0)
        goto LABEL_4;
      goto LABEL_18;
    }
  }
  else
  {
    v4 = 0;
    if ((v3 & 0x80) == 0)
      goto LABEL_3;
  }
  if ((_DWORD)a2 == 128)
    return a1 + v4 + 12;
  v4 += 4;
  if ((v3 & 0x400) == 0)
  {
LABEL_4:
    if ((v3 & 0x800) == 0)
      goto LABEL_5;
    goto LABEL_20;
  }
LABEL_18:
  if ((_DWORD)a2 == 1024)
    return a1 + v4 + 12;
  v4 += 4;
  if ((v3 & 0x800) == 0)
  {
LABEL_5:
    if ((v3 & 4) == 0)
      goto LABEL_6;
    goto LABEL_22;
  }
LABEL_20:
  if ((_DWORD)a2 == 2048)
    return a1 + v4 + 12;
  v4 += 4;
  if ((v3 & 4) == 0)
  {
LABEL_6:
    if ((v3 & 8) == 0)
      goto LABEL_7;
    goto LABEL_24;
  }
LABEL_22:
  if ((_DWORD)a2 == 4)
    return a1 + v4 + 12;
  v4 += 4;
  if ((v3 & 8) == 0)
  {
LABEL_7:
    if ((v3 & 0x100) == 0)
      goto LABEL_8;
    goto LABEL_26;
  }
LABEL_24:
  if ((_DWORD)a2 == 8)
    return a1 + v4 + 12;
  v4 += 4;
  if ((v3 & 0x100) == 0)
  {
LABEL_8:
    if ((v3 & 0x200) == 0)
      goto LABEL_9;
    goto LABEL_28;
  }
LABEL_26:
  if ((_DWORD)a2 == 256)
    return a1 + v4 + 12;
  v4 += 4;
  if ((v3 & 0x200) == 0)
  {
LABEL_9:
    if ((v3 & 0x1000) == 0)
      goto LABEL_10;
LABEL_30:
    if ((_DWORD)a2 == 4096)
      return a1 + v4 + 12;
    v4 += 4;
    if ((v3 & 0x10) == 0)
      goto LABEL_11;
    goto LABEL_32;
  }
LABEL_28:
  if ((_DWORD)a2 == 512)
    return a1 + v4 + 12;
  v4 += 4;
  if ((v3 & 0x1000) != 0)
    goto LABEL_30;
LABEL_10:
  if ((v3 & 0x10) == 0)
  {
LABEL_11:
    if ((v3 & 0x20) == 0)
      goto LABEL_36;
LABEL_34:
    if ((_DWORD)a2 != 32)
    {
      v4 += 8;
      goto LABEL_36;
    }
    return a1 + v4 + 12;
  }
LABEL_32:
  if ((_DWORD)a2 == 16)
    return a1 + v4 + 12;
  v4 += 4;
  if ((v3 & 0x20) != 0)
    goto LABEL_34;
LABEL_36:
  if ((_DWORD)a2 == 64 && (v3 & 0x40) != 0)
    return a1 + v4 + 12;
  v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTCellStorageDataElement *TSTCellStorageGetElement(TSTCellStorage *, TSTCellStorageHeaderFlags)");
  objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 942, CFSTR("Can't get offset for unknown element 0x%02x!"), a2);
  return 0;
}

uint64_t TSTCellStorageGetElementForFormat(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  void *v8;
  uint64_t v9;

  v4 = HIWORD(*(_QWORD *)(a1 + 4));
  v5 = p_TSTCellStorageExtraSizeForHeaderFlags((unsigned __int16)*(_QWORD *)(a1 + 4));
  if ((v4 & 1) != 0)
  {
    if ((_DWORD)a2 == 1)
    {
      v6 = a1 + v5;
      return v6 + 12;
    }
    LOWORD(v5) = v5 + 4;
  }
  if ((v4 & 8) != 0)
  {
    if ((_DWORD)a2 == 8)
      goto LABEL_25;
    LOWORD(v5) = v5 + 4;
  }
  if ((v4 & 2) != 0)
  {
    if ((_DWORD)a2 == 2)
      goto LABEL_25;
    LOWORD(v5) = v5 + 4;
  }
  if ((v4 & 4) != 0)
  {
    if ((_DWORD)a2 == 4)
      goto LABEL_25;
    LOWORD(v5) = v5 + 4;
  }
  if ((v4 & 0x10) != 0)
  {
    if ((_DWORD)a2 == 16)
      goto LABEL_25;
    LOWORD(v5) = v5 + 4;
  }
  if ((v4 & 0x20) != 0)
  {
    if ((_DWORD)a2 == 32)
      goto LABEL_25;
    LOWORD(v5) = v5 + 4;
  }
  if ((v4 & 0x40) != 0)
  {
    if ((_DWORD)a2 != 64)
    {
      LOWORD(v5) = v5 + 4;
      goto LABEL_23;
    }
LABEL_25:
    v6 = a1 + (unsigned __int16)v5;
    return v6 + 12;
  }
LABEL_23:
  if ((_DWORD)a2 == 128 && (v4 & 0x80) != 0)
    goto LABEL_25;
  v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTCellStorageDataElement *TSTCellStorageGetElementForFormat(TSTCellStorage *, TSTCellStorageFormatFlags)");
  objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.mm"), 1021, CFSTR("Can't get offset for unknown element 0x%02x!"), a2);
  return 0;
}

uint64_t TSTBundle()
{
  if (TSTBundle::onceToken != -1)
    dispatch_once(&TSTBundle::onceToken, &__block_literal_global_79);
  return TSTBundle::bundle;
}

unint64_t TSTCellRangeUnionCellRange(unint64_t a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  __int16 v8;
  __int16 v9;
  unsigned int v10;
  unsigned int v11;

  if ((_WORD)a1 == 0xFFFF || (a1 & 0xFF0000) == 0xFF0000 || (v2 = HIWORD(a1)) == 0 || (a1 & 0xFFFF00000000) == 0)
  {
    v3 = a2 >> 16;
    v7 = a2 & 0xFF000000;
    v4 = HIDWORD(a2);
    LOWORD(a1) = a2;
    v2 = HIWORD(a2);
  }
  else if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000 || !HIWORD(a2) || (a2 & 0xFFFF00000000) == 0)
  {
    v3 = a1 >> 16;
    v7 = a1 & 0xFF000000;
    v4 = HIDWORD(a1);
  }
  else if ((unsigned __int16)a1 <= (unsigned __int16)a2
         && (unsigned __int16)(a1 + HIWORD(a1) - 1) >= (unsigned __int16)a2
         && (v3 = a1 >> 16, BYTE2(a2) >= BYTE2(a1))
         && (v4 = HIDWORD(a1), v5 = (BYTE4(a1) + BYTE2(a1) - 1), v5 >= BYTE2(a2))
         && v5 >= (BYTE4(a2) + BYTE2(a2) - 1)
         && (unsigned __int16)(a1 + HIWORD(a1) - 1) >= (unsigned __int16)(a2 + HIWORD(a2) - 1))
  {
    v7 = a1 & 0xFF000000;
  }
  else if ((unsigned __int16)a2 <= (unsigned __int16)a1
         && (unsigned __int16)(a2 + HIWORD(a2) - 1) >= (unsigned __int16)a1
         && (v3 = a2 >> 16, BYTE2(a1) >= BYTE2(a2))
         && (v4 = HIDWORD(a2), v6 = (BYTE4(a2) + BYTE2(a2) - 1), v6 >= BYTE2(a1))
         && v6 >= (BYTE4(a1) + BYTE2(a1) - 1)
         && (unsigned __int16)(a2 + HIWORD(a2) - 1) >= (unsigned __int16)(a1 + HIWORD(a1) - 1))
  {
    v7 = a2 & 0xFF000000;
    LOWORD(a1) = a2;
    v2 = HIWORD(a2);
  }
  else
  {
    v7 = 0;
    if (BYTE2(a1) >= BYTE2(a2))
      LOWORD(v3) = BYTE2(a2);
    else
      LOWORD(v3) = BYTE2(a1);
    v8 = a1;
    if ((unsigned __int16)a1 >= (unsigned __int16)a2)
      v8 = a2;
    v9 = a1 + HIWORD(a1);
    LOWORD(a1) = v8;
    v10 = (BYTE4(a1) + BYTE2(a1) - 1);
    if (v10 <= (BYTE4(a2) + BYTE2(a2) - 1))
      LOWORD(v10) = (BYTE4(a2) + BYTE2(a2) - 1);
    v11 = (unsigned __int16)(v9 - 1);
    if (v11 <= (unsigned __int16)(a2 + HIWORD(a2) - 1))
      LOWORD(v11) = a2 + HIWORD(a2) - 1;
    LOWORD(v2) = v11 - v8 + 1;
    LOWORD(v4) = v10 - v3 + 1;
    v2 = (unsigned __int16)v2;
  }
  return ((unint64_t)(unsigned __int16)v4 << 32) | (v2 << 48) | v7 & 0xFF000000 | ((unint64_t)v3 << 16) | (unsigned __int16)a1;
}

uint64_t TSTTableRepGetCellIDForCanvasPointIgnoringFreezeHeaders(void *a1, char a2, CGFloat a3, double a4)
{
  TSTLayout *v7;
  uint64_t Space;
  uint64_t GridPointHitByCanvasPoint;
  int v10;

  v7 = (TSTLayout *)objc_msgSend(a1, "tableLayout");
  if ((a2 & 1) == 0)
    return TSTLayoutGetCellIDHitByCanvasPoint(v7, a3, a4);
  Space = TSTLayoutGetSpace(v7);
  GridPointHitByCanvasPoint = TSTLayoutSpaceGetGridPointHitByCanvasPoint(Space, 0, a3, a4);
  v10 = GridPointHitByCanvasPoint << 16;
  if ((_DWORD)GridPointHitByCanvasPoint == -1)
    v10 = 16711680;
  return v10 | WORD2(GridPointHitByCanvasPoint);
}

uint64_t TSTTableRepGetCellIDForCanvasPoint(void *a1, CGFloat a2, double a3)
{
  return TSTLayoutGetCellIDHitByCanvasPoint((TSTLayout *)objc_msgSend(a1, "tableLayout"), a2, a3);
}

uint64_t TSTTableRepGetClosestCellIDForCanvasPoint(void *a1)
{
  return TSTLayoutGetCellIDNearbyCanvasPoint((TSTLayout *)objc_msgSend(a1, "tableLayout"));
}

void TSTTableRepSetupUserSpaceToDeviceSpaceTransform(TSTTableRep *a1, CGFloat a2, double a3)
{
  double v5;
  double v6;
  TSDLayout *v7;
  uint64_t Space;
  CGAffineTransform v9;
  CGAffineTransform t2;
  CGAffineTransform t1;
  CGAffineTransform v12;
  CGAffineTransform v13;
  CGAffineTransform v14;
  CGAffineTransform v15;

  a1->mCurrentScreenScale = a3;
  memset(&v15, 0, sizeof(v15));
  CGAffineTransformMakeScale(&v15, a3, a3);
  -[TSTTableRep layerFrameInScaledCanvas](a1, "layerFrameInScaledCanvas");
  v13 = v15;
  CGAffineTransformTranslate(&v14, &v13, -v5, -v6);
  v15 = v14;
  v12 = v14;
  CGAffineTransformScale(&v14, &v12, a2, a2);
  v15 = v14;
  v7 = -[TSDRep layout](a1, "layout");
  if (v7)
    -[TSDAbstractLayout transformInRoot](v7, "transformInRoot");
  else
    memset(&t1, 0, sizeof(t1));
  t2 = v15;
  CGAffineTransformConcat(&v14, &t1, &t2);
  v15 = v14;
  Space = TSTLayoutGetSpace(-[TSTTableRep tableLayout](a1, "tableLayout"));
  v9 = v15;
  TSTLayoutSpaceSetUserSpaceToDeviceSpaceTransform(Space, (__int128 *)&v9);
}

void TSTTableRepGetStrokeFrameForRange(void *a1, unint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  TSTLayoutSpace *Space;

  if (BYTE2(a2) == 255)
    v2 = -1;
  else
    v2 = BYTE2(a2);
  v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2))
    v3 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v4 = 0xFFFFFFFFLL;
  else
    v4 = (unsigned __int16)a2;
  v5 = v2 | ((unint64_t)v4 << 32);
  v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v6 = 0xFFFFFFFF00000000;
  v7 = v3 | v6;
  Space = (TSTLayoutSpace *)TSTLayoutGetSpace((void *)objc_msgSend(a1, "tableLayout"));
  TSTLayoutSpaceGetStrokeFrameForGridRange(Space, v5, v7);
}

uint64_t TSTTableRepDrawTableName(TSTTableRep *a1, CGContext *a2, TSTAnimation *a3)
{
  TSTLayout *v6;
  double x;
  double y;
  double width;
  double height;
  uint64_t result;
  NSString *v12;
  TSTLayoutSpace *Space;
  TSDStroke *v14;
  TSTMasterLayout *v15;
  CGFloat v16;
  CGFloat v17;
  CGFloat v18;
  CGFloat v19;
  CGFloat MaxX;
  double v21;
  double v22;
  double v23;
  double v24;
  unint64_t Range;
  unsigned int VisibleRow;
  int VisibleColumn;
  double v28;
  double v29;
  double v30;
  double v31;
  CGPoint v32;
  CGPoint v33;
  double v34;
  CGPoint v35;
  CGFloat v36;
  CGFloat v37;
  CGRect v38;
  CGRect v39;
  CGRect v40;
  CGRect v41;

  v6 = -[TSTTableRep tableLayout](a1, "tableLayout");
  v38.origin.x = TSTLayoutGetFrameForTableName(v6);
  x = v38.origin.x;
  y = v38.origin.y;
  width = v38.size.width;
  height = v38.size.height;
  result = CGRectIsEmpty(v38);
  if ((result & 1) == 0)
  {
    result = TSTLayoutIsPartitionAlongLeft(v6);
    if ((_DWORD)result)
    {
      v12 = -[TSTTableModel tableName](-[TSTTableRep tableModel](a1, "tableModel"), "tableName");
      if (!a1->mRecursivelyDrawingInContext
        && !-[TSTLayout inPrintPreviewMode](v6, "inPrintPreviewMode")
        && (!-[TSTAnimation enabled](a3, "enabled") || !-[TSTAnimation drawTableName](a3, "drawTableName")))
      {
        -[TSDRep setupForDrawingInLayer:context:](a1, "setupForDrawingInLayer:context:", a1->mOverlayTableName, a2);
      }
      if (-[TSTEditingState editingMode](-[TSTTableRep editingState](a1, "editingState"), "editingMode") != 7)
        objc_msgSend(-[TSTMasterLayout tableNameTextEngine](-[TSTTableRep masterLayout](a1, "masterLayout"), "tableNameTextEngine"), "drawText:inContext:minSize:maxSize:anchor:flags:viewScale:", v12, a2, 4096, width, height, width, height, x, y, 1.0);
      result = TSTLayoutTableNameBorderEnabled(v6);
      if ((_DWORD)result)
      {
        Space = (TSTLayoutSpace *)TSTLayoutGetSpace(v6);
        -[TSTLayoutSpace lockForRead](Space, "lockForRead");
        v14 = -[TSTTableModel tableNameBorderStroke](-[TSTTableInfo tableModel](-[TSTTableRep tableInfo](a1, "tableInfo"), "tableModel"), "tableNameBorderStroke");
        v15 = -[TSTLayout masterLayout](v6, "masterLayout");
        v39.origin.x = TSTLayoutGetFrameForTableNameBorder(v6);
        v16 = v39.origin.x;
        v17 = v39.origin.y;
        v18 = v39.size.width;
        v19 = v39.size.height;
        MaxX = CGRectGetMaxX(v39);
        v36 = v16;
        v37 = v17;
        v35.x = MaxX;
        v35.y = v17;
        -[TSDStroke width](v14, "width");
        v34 = v21;
        v22 = TSTLayoutSpaceStrokeWidthForDrawing(v21, v21);
        TSTLayoutSpaceAlignStrokeCoordinates(Space, &v36, &v35, &v34);
        TSTLayoutSpaceDrawSingleStroke(v14, a2, v36, v37, v35.x, v35.y, v34, v22, v23, v24, v16, v17, v18, v19);
        Range = TSTLayoutSpaceGetRange((uint64_t)Space);
        VisibleRow = TSTMasterLayoutNextVisibleRow(v15, (unsigned __int16)Range);
        VisibleColumn = TSTMasterLayoutNextVisibleColumn(v15, BYTE2(Range));
        LODWORD(v15) = TSTMasterLayoutPreviousVisibleColumn(v15, (BYTE4(Range) + BYTE2(Range) - 1));
        v40.origin.x = TSTLayoutSpaceGetAlignedStrokeFrameForCellRange(Space, VisibleRow | (VisibleColumn << 16) | 0x1000100000000);
        v36 = v16;
        v37 = v37 - v34 * 0.5;
        v33.x = v16;
        v33.y = CGRectGetMinY(v40);
        TSTLayoutSpaceAlignStrokeCoordinates(Space, &v36, &v33, &v34);
        TSTLayoutSpaceDrawSingleStroke(v14, a2, v36, v37, v33.x, v33.y, v34, v22, v28, v29, v16, v17, v18, v19);
        v41.origin.x = TSTLayoutSpaceGetAlignedStrokeFrameForCellRange(Space, VisibleRow | ((_DWORD)v15 << 16) | 0x1000100000000);
        v35.x = MaxX;
        v35.y = v35.y - v34 * 0.5;
        v32.x = MaxX;
        v32.y = CGRectGetMinY(v41);
        TSTLayoutSpaceAlignStrokeCoordinates(Space, &v35.x, &v32, &v34);
        TSTLayoutSpaceDrawSingleStroke(v14, a2, v35.x, v35.y, v32.x, v32.y, v34, v22, v30, v31, v16, v17, v18, v19);
        return -[TSTLayoutSpace unlock](Space, "unlock");
      }
    }
  }
  return result;
}

void TSTTableRepDrawFrozenHeaderRegion(TSTTableRep *a1, TSTLayoutSpace *a2, CALayer *a3, CGContext *a4)
{
  TSTLayoutSpace *v8;
  uint64_t GridRange;
  unsigned int v10;
  unsigned int v11;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CGAffineTransform v16;
  CGRect ClipBoundingBox;
  CGRect v18;

  v8 = a2;
  if (a2)
  {
    -[TSTLayoutSpace lockForRead](a2, "lockForRead");
    GridRange = TSTLayoutSpaceGetGridRange((uint64_t)a2);
    if ((_DWORD)GridRange != -1
      && v10 != -1
      && GridRange <= v10
      && HIDWORD(GridRange) != -1
      && v11 != -1
      && HIDWORD(GridRange) <= v11)
    {
      -[TSDRep setupForDrawingInLayer:context:](a1, "setupForDrawingInLayer:context:", a3, a4);
      ClipBoundingBox = CGContextGetClipBoundingBox(a4);
      x = ClipBoundingBox.origin.x;
      y = ClipBoundingBox.origin.y;
      width = ClipBoundingBox.size.width;
      height = ClipBoundingBox.size.height;
      if (a1)
        -[TSTTableRep transformFromCanvas](a1, "transformFromCanvas");
      else
        memset(&v16, 0, sizeof(v16));
      CGContextConcatCTM(a4, &v16);
      v18.origin.x = x;
      v18.origin.y = y;
      v18.size.width = width;
      v18.size.height = height;
      TSTTableRepDrawSpaceInContext(a1, a2, v18, a4);
    }
    -[TSTLayoutSpace unlock](a2, "unlock", *(_OWORD *)&v16.a, *(_OWORD *)&v16.c, *(_OWORD *)&v16.tx);

  }
}

void TSTTableRepDrawSpaceInContext(TSTTableRep *a1, TSTLayoutSpace *a2, CGRect a3, CGContext *a4)
{
  double height;
  double width;
  double y;
  double x;
  unint64_t v11;
  uint64_t i;
  unint64_t NearestRangeForLayoutRect;
  $CA3468F20078D5D2DB35E78E73CA60DA v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;

  height = a3.size.height;
  width = a3.size.width;
  y = a3.origin.y;
  x = a3.origin.x;
  if (!-[TSTAnimation enabled](-[TSTTableRep currentAnimation](a1, "currentAnimation"), "enabled"))
  {
    v11 = 1;
    goto LABEL_5;
  }
  v11 = -[TSTAnimation cellRangeCount](-[TSTTableRep currentAnimation](a1, "currentAnimation"), "cellRangeCount");
  if (v11)
  {
LABEL_5:
    for (i = 0; v11 != i; ++i)
    {
      NearestRangeForLayoutRect = TSTLayoutSpaceGetNearestRangeForLayoutRect(a2, x, y, width, height);
      if (!-[TSTAnimation enabled](-[TSTTableRep currentAnimation](a1, "currentAnimation"), "enabled"))
      {
LABEL_32:
        if (a1->mIsZoomToEditOperationInProgress)
          NearestRangeForLayoutRect = TSTCellRangeUnionCellRange(NearestRangeForLayoutRect, *(_QWORD *)&a1->mZoomToEditVisibleCellRange);
        TSTTableRepDrawSpaceRangeInContext(a1, a2, NearestRangeForLayoutRect, a4);
        continue;
      }
      v14 = -[TSTAnimation cellRangeAtIndex:](-[TSTTableRep currentAnimation](a1, "currentAnimation"), "cellRangeAtIndex:", i);
      v15 = 0;
      if ((_WORD)NearestRangeForLayoutRect == 0xFFFF)
        goto LABEL_30;
      v16 = 0xFFFFLL;
      v17 = 16711680;
      v18 = 0;
      if ((NearestRangeForLayoutRect & 0xFF0000) == 0xFF0000)
        goto LABEL_31;
      v15 = 0;
      if (!HIWORD(NearestRangeForLayoutRect))
        goto LABEL_30;
      v16 = 0xFFFFLL;
      v17 = 16711680;
      v18 = 0;
      if ((NearestRangeForLayoutRect & 0xFFFF00000000) == 0)
        goto LABEL_31;
      v15 = 0;
      if (v14.var0.var0 == 0xFFFF)
        goto LABEL_30;
      v16 = 0xFFFFLL;
      v17 = 16711680;
      v18 = 0;
      if ((*(_QWORD *)&v14 & 0xFF0000) == 0xFF0000)
        goto LABEL_31;
      v15 = 0;
      if (!HIWORD(*(unint64_t *)&v14))
      {
LABEL_30:
        v16 = 0xFFFFLL;
        v17 = 16711680;
        v18 = 0;
      }
      else
      {
        v16 = 0xFFFFLL;
        v17 = 16711680;
        v18 = 0;
        if ((*(_QWORD *)&v14 & 0xFFFF00000000) != 0)
        {
          v16 = 0;
          v19 = BYTE2(NearestRangeForLayoutRect) <= v14.var0.var1
              ? v14.var0.var1
              : BYTE2(NearestRangeForLayoutRect);
          v20 = (unsigned __int16)NearestRangeForLayoutRect <= v14.var0.var0
              ? v14.var0.var0
              : (unsigned __int16)NearestRangeForLayoutRect;
          v21 = (BYTE4(NearestRangeForLayoutRect) + BYTE2(NearestRangeForLayoutRect) - 1) >= (LOBYTE(v14.var1.var0) + v14.var0.var1 - 1)
              ? (LOBYTE(v14.var1.var0) + v14.var0.var1 - 1)
              : (BYTE4(NearestRangeForLayoutRect) + BYTE2(NearestRangeForLayoutRect) - 1);
          v22 = (unsigned __int16)(NearestRangeForLayoutRect + HIWORD(NearestRangeForLayoutRect) - 1) >= (unsigned __int16)(v14.var0.var0 + v14.var1.var1 - 1)
              ? (unsigned __int16)(v14.var0.var0 + v14.var1.var1 - 1)
              : (unsigned __int16)(NearestRangeForLayoutRect + HIWORD(NearestRangeForLayoutRect) - 1);
          v17 = 0;
          v15 = 0;
          v18 = 0;
          if (v20 <= v22 && v19 <= v21)
          {
            v18 = ((unint64_t)(v22 - v20) << 48) + 0x1000000000000;
            v15 = (unint64_t)(unsigned __int16)(v21 - v19 + 1) << 32;
            v17 = v19 << 16;
            v16 = v20;
          }
        }
      }
LABEL_31:
      NearestRangeForLayoutRect = v17 | v18 | v16 | v15;
      if (!TSTMasterLayoutIsEntireCellRangeHidden(-[TSTTableRep masterLayout](a1, "masterLayout"), NearestRangeForLayoutRect))goto LABEL_32;
    }
  }
}

uint64_t TSTTableRepDrawRangeInContext(void *a1, unint64_t a2, uint64_t a3)
{
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  _QWORD v16[8];

  if (BYTE2(a2) == 255)
    v6 = -1;
  else
    v6 = BYTE2(a2);
  v7 = (unsigned __int16)a2;
  if (WORD2(a2))
    v8 = WORD2(a2) + v6 - 1;
  else
    v8 = 0xFFFFFFFFLL;
  v9 = (void *)objc_msgSend(a1, "tableLayout");
  if (v7 == 0xFFFF)
    v10 = 0xFFFFFFFFLL;
  else
    v10 = v7;
  v11 = v6 | ((unint64_t)v10 << 32);
  v12 = ((a2 >> 16) & 0xFFFF00000000) + (v10 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v12 = 0xFFFFFFFF00000000;
  v13 = v8 | v12;
  v14 = (void *)objc_msgSend(v9, "spaceBundle");
  v16[0] = MEMORY[0x24BDAC760];
  v16[1] = 3221225472;
  v16[2] = __TSTTableRepDrawRangeInContext_block_invoke;
  v16[3] = &unk_24D82EFA0;
  v16[6] = v11;
  v16[7] = v13;
  v16[4] = a1;
  v16[5] = a3;
  return objc_msgSend(v14, "performActionOnEachLayoutSpace:", v16);
}

void TSTTableRepDrawSpaceRangeInContext(TSTTableRep *a1, TSTLayoutSpace *a2, unint64_t a3, CGContext *a4)
{
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t GridRange;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  CGFloat v16;
  unsigned int v17;
  unsigned __int16 *v18;
  unint64_t Range;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t EntireHeaderColumnsCellRange;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t EntireHeaderRowsCellRange;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t EntireFooterRowsCellRange;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v49;
  unsigned int v50;
  BOOL v51;
  BOOL v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  CGContext *v61;
  TSTAnimation *v62;
  void *v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  BOOL v71;
  BOOL v72;
  BOOL v73;
  unint64_t v74;
  _BOOL4 v75;
  CGPath *v76;
  unsigned int v77;
  unsigned int v78;
  uint64_t v79;
  unsigned int v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unsigned int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  _BOOL4 v89;
  unint64_t v90;
  unint64_t v91;
  BOOL v92;
  TSTLayout *v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  _BOOL4 v97;
  unint64_t v98;
  TSTCell *v99;
  uint64_t v100;
  uint64_t v101;
  BOOL v102;
  char v103;
  BOOL v105;
  unsigned int VisibleRow;
  uint64_t RowFill;
  int v108;
  unsigned int v109;
  uint64_t v110;
  unint64_t v111;
  unsigned int v112;
  uint64_t v114;
  void *CellFill;
  unint64_t v116;
  _BOOL4 v117;
  $2F2D2FE54C0B9D2AA4EBD8788136C7D0 v118;
  uint64_t v119;
  $2F2D2FE54C0B9D2AA4EBD8788136C7D0 v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  unint64_t v124;
  int v125;
  int v126;
  _BOOL8 v127;
  TSDFill *CellFillAndIsDefault;
  BOOL v129;
  TSDFill *v130;
  _BOOL4 v131;
  unsigned __int16 v132;
  BOOL v133;
  char v134;
  unint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  BOOL v139;
  char v140;
  uint64_t v141;
  BOOL v142;
  unint64_t v143;
  uint64_t v144;
  int v145;
  unsigned int v146;
  int v147;
  unsigned int v148;
  unsigned int v149;
  uint64_t v150;
  unsigned int v151;
  unsigned int v152;
  unsigned int v153;
  unint64_t v154;
  unint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  double AlignedFrameForGridRange;
  double v161;
  double v162;
  double v163;
  double v164;
  double v165;
  double v166;
  double v167;
  void *v168;
  uint64_t v169;
  unsigned int v170;
  unsigned int v171;
  uint64_t v172;
  unsigned int v173;
  const __CFString *v174;
  unsigned int v175;
  unsigned int v176;
  uint64_t v177;
  unsigned int v178;
  const __CFString *v179;
  uint64_t v180;
  TSTLayoutSpace *v181;
  int v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t i;
  void *v187;
  uint64_t v188;
  TSDFill *v189;
  _BOOL4 v190;
  uint64_t v191;
  uint64_t v192;
  unint64_t v193;
  unint64_t v194;
  const CGPath *path;
  uint64_t v196;
  TSTAnimation *v197;
  unint64_t v198;
  unint64_t v199;
  char v200;
  void *v201;
  int v202;
  unint64_t v203;
  int v204;
  unint64_t v205;
  _BOOL4 v206;
  unint64_t v207;
  id v208;
  TSTTableRep *v209;
  int v210;
  unint64_t v211;
  unint64_t v212;
  char v213;
  uint64_t v214;
  TSDFill *v215;
  unsigned int v216;
  TSTLayout *v217;
  unint64_t v218;
  TSTCell *v219;
  unsigned __int16 v220;
  uint64_t v221;
  uint64_t v223;
  unint64_t v224;
  uint64_t ColumnFill;
  _BOOL4 v226;
  TSTTableModel *v227;
  int v229;
  unint64_t v230;
  TSTCell *v231;
  TSTMasterLayout *v232;
  __int128 v233;
  __int128 v234;
  __int128 v235;
  __int128 v236;
  _QWORD v237[8];
  _QWORD v238[18];
  CGRect v239;

  v6 = BYTE2(a3);
  if (BYTE2(a3) == 255)
    v7 = -1;
  else
    v7 = BYTE2(a3);
  v238[16] = *MEMORY[0x24BDAC8D0];
  v8 = (unsigned __int16)a3;
  if (WORD2(a3))
    v9 = WORD2(a3) + v7 - 1;
  else
    v9 = -1;
  if ((unsigned __int16)a3 == 0xFFFF)
    v10 = -1;
  else
    v10 = (unsigned __int16)a3;
  v11 = v10 + ((unint64_t)((HIDWORD(a3) << 16) - 0x100000000) >> 32);
  GridRange = TSTLayoutSpaceGetGridRange((uint64_t)a2);
  if (HIWORD(a3))
    v15 = v11;
  else
    v15 = -1;
  if (v6 != 255
    && v9 != -1
    && v7 <= v9
    && v8 != 0xFFFF
    && v15 != -1
    && v10 <= v15
    && (_DWORD)GridRange != -1
    && v13 != -1
    && GridRange <= v13
    && HIDWORD(GridRange) != -1
    && v14 != -1
    && HIDWORD(GridRange) <= v14)
  {
    if (v7 <= GridRange)
      v7 = GridRange;
    if (v9 >= v13)
      v9 = v13;
    if (v7 <= v9)
    {
      if (v15 >= v14)
        v17 = v14;
      else
        v17 = v15;
      if (v10 <= HIDWORD(GridRange))
        v10 = HIDWORD(GridRange);
      if (v10 <= v17 && v7 != -1 && v10 != -1)
      {
        TSTTableRepPrepareToDrawLayoutSpace(a1, a2, a4);
        v18 = -[TSTTableRep masterLayout](a1, "masterLayout");
        -[TSTTableRep tableModel](a1, "tableModel");
        v196 = objc_msgSend(MEMORY[0x24BDBCEB8], "array");
        v209 = a1;
        v197 = -[TSTTableRep currentAnimation](a1, "currentAnimation");
        Range = TSTMasterLayoutGetRange((uint64_t)v18);
        v20 = BYTE2(Range);
        if (BYTE2(Range) == 255)
          v20 = -1;
        v21 = WORD2(Range) + v20 - 1;
        if (!WORD2(Range))
          v21 = 0xFFFFFFFFLL;
        if ((unsigned __int16)Range == 0xFFFF)
          v22 = 0xFFFFFFFFLL;
        else
          v22 = (unsigned __int16)Range;
        v23 = v20 | ((unint64_t)v22 << 32);
        v24 = ((Range >> 16) & 0xFFFF00000000) + (v22 << 32) - 0x100000000;
        if (((Range >> 16) & 0xFFFF00000000) == 0)
          v24 = 0xFFFFFFFF00000000;
        v237[0] = v23;
        v237[1] = v21 | v24;
        EntireHeaderColumnsCellRange = TSTMasterLayoutGetEntireHeaderColumnsCellRange(v18);
        v26 = BYTE2(EntireHeaderColumnsCellRange);
        if (BYTE2(EntireHeaderColumnsCellRange) == 255)
          v26 = -1;
        v27 = WORD2(EntireHeaderColumnsCellRange) + v26 - 1;
        if (!WORD2(EntireHeaderColumnsCellRange))
          v27 = 0xFFFFFFFFLL;
        if ((unsigned __int16)EntireHeaderColumnsCellRange == 0xFFFF)
          v28 = 0xFFFFFFFFLL;
        else
          v28 = (unsigned __int16)EntireHeaderColumnsCellRange;
        v29 = v26 | ((unint64_t)v28 << 32);
        v30 = ((EntireHeaderColumnsCellRange >> 16) & 0xFFFF00000000) + (v28 << 32) - 0x100000000;
        if (((EntireHeaderColumnsCellRange >> 16) & 0xFFFF00000000) == 0)
          v30 = 0xFFFFFFFF00000000;
        v237[2] = v29;
        v237[3] = v27 | v30;
        EntireHeaderRowsCellRange = TSTMasterLayoutGetEntireHeaderRowsCellRange(v18);
        v32 = BYTE2(EntireHeaderRowsCellRange);
        if (BYTE2(EntireHeaderRowsCellRange) == 255)
          v32 = -1;
        v33 = WORD2(EntireHeaderRowsCellRange) + v32 - 1;
        if (!WORD2(EntireHeaderRowsCellRange))
          v33 = 0xFFFFFFFFLL;
        if ((unsigned __int16)EntireHeaderRowsCellRange == 0xFFFF)
          v34 = 0xFFFFFFFFLL;
        else
          v34 = (unsigned __int16)EntireHeaderRowsCellRange;
        v35 = v32 | ((unint64_t)v34 << 32);
        v36 = ((EntireHeaderRowsCellRange >> 16) & 0xFFFF00000000) + (v34 << 32) - 0x100000000;
        if (((EntireHeaderRowsCellRange >> 16) & 0xFFFF00000000) == 0)
          v36 = 0xFFFFFFFF00000000;
        v237[4] = v35;
        v237[5] = v33 | v36;
        EntireFooterRowsCellRange = TSTMasterLayoutGetEntireFooterRowsCellRange(v18);
        v38 = 0;
        v39 = BYTE2(EntireFooterRowsCellRange);
        if (BYTE2(EntireFooterRowsCellRange) == 255)
          v39 = -1;
        v40 = WORD2(EntireFooterRowsCellRange) + v39 - 1;
        if (!WORD2(EntireFooterRowsCellRange))
          v40 = 0xFFFFFFFFLL;
        if ((unsigned __int16)EntireFooterRowsCellRange == 0xFFFF)
          v41 = 0xFFFFFFFFLL;
        else
          v41 = (unsigned __int16)EntireFooterRowsCellRange;
        v42 = v39 | ((unint64_t)v41 << 32);
        v43 = ((EntireFooterRowsCellRange >> 16) & 0xFFFF00000000) + (v41 << 32) - 0x100000000;
        if (((EntireFooterRowsCellRange >> 16) & 0xFFFF00000000) == 0)
          v43 = 0xFFFFFFFF00000000;
        v237[6] = v42;
        v237[7] = v40 | v43;
        do
        {
          v44 = &v237[v38];
          LODWORD(v45) = v237[v38];
          LODWORD(v46) = v237[v38 + 1];
          if ((_DWORD)v45 == -1 || (_DWORD)v46 == -1 || v45 > v46)
            goto LABEL_104;
          v49 = *((_DWORD *)v44 + 1);
          v50 = *((_DWORD *)v44 + 3);
          v51 = v49 == -1 || v50 == -1;
          v52 = v51 || v49 > v50;
          if (v52
            || (v7 <= v45 ? (v45 = v45) : (v45 = v7),
                v9 >= v46 ? (v46 = v46) : (v46 = v9),
                v45 > v46
             || (v17 >= v50 ? (v53 = v50) : (v53 = v17),
                 v10 <= v49 ? (v54 = v49) : (v54 = v10),
                 v54 > v53)))
          {
LABEL_104:
            v55 = -1;
            v56 = -1;
          }
          else
          {
            v56 = v46 | (v53 << 32);
            v55 = v45 | (v54 << 32);
          }
          v237[v38] = v55;
          v44[1] = v56;
          v38 += 2;
        }
        while (v38 != 8);
        v57 = 0;
        v58 = -1;
        v59 = 0xFFFFFFFFLL;
        LODWORD(v60) = -1;
        v61 = a4;
        v63 = (void *)v196;
        v62 = v197;
        do
        {
          v65 = v237[v57];
          v64 = v237[v57 + 1];
          if ((_DWORD)v60 == -1
            || (_DWORD)v58 == -1
            || v60 > v58
            || (_DWORD)v59 == -1
            || HIDWORD(v58) == -1
            || v59 > HIDWORD(v58))
          {
            v58 = v237[v57 + 1];
            v60 = v237[v57];
          }
          else if ((_DWORD)v65 == -1
                 || (_DWORD)v64 == -1
                 || v65 > v64
                 || (v66 = HIDWORD(v65), HIDWORD(v65) == -1)
                 || (v67 = HIDWORD(v64), HIDWORD(v64) == -1)
                 || HIDWORD(v65) > HIDWORD(v64))
          {
            LODWORD(v64) = v58;
            LODWORD(v65) = v60;
            v60 = v60 | (unint64_t)(v59 << 32);
          }
          else
          {
            if (v60 >= v65)
              v65 = v65;
            else
              v65 = v60;
            if (v59 >= v66)
              v68 = v66;
            else
              v68 = v59;
            if (v58 <= v64)
              v64 = v64;
            else
              v64 = v58;
            if (HIDWORD(v58) <= v67)
              v69 = v67;
            else
              v69 = HIDWORD(v58);
            v58 = v64 | (v69 << 32);
            v60 = v65 | (v68 << 32);
          }
          v71 = (_DWORD)v65 == -1 || (_DWORD)v64 == -1 || v65 > v64;
          if (v71
            || (HIDWORD(v60) <= HIDWORD(v58) ? (v72 = HIDWORD(v58) == -1) : (v72 = 1),
                !v72 ? (v73 = HIDWORD(v60) == -1) : (v73 = 1),
                v73))
          {
            v58 = -1;
            v60 = -1;
          }
          v59 = HIDWORD(v60);
          v57 += 2;
        }
        while (v57 != 8);
        if ((_DWORD)v60 == -1)
          goto LABEL_474;
        if ((_DWORD)v58 == -1)
          goto LABEL_474;
        if (v60 > v58)
          goto LABEL_474;
        if (HIDWORD(v60) == -1)
          goto LABEL_474;
        v74 = HIDWORD(v58);
        if (HIDWORD(v58) == -1 || HIDWORD(v60) > HIDWORD(v58))
          goto LABEL_474;
        v193 = v60;
        v194 = v58;
        v75 = -[TSTAnimation enabled](v197, "enabled");
        if (v75)
        {
          v76 = -[TSDBezierPath CGPath](TSTLayoutSpaceGetAlignedStrokeFramePathForGridRange(a2, v193, v194, 0, 0, 0.0), "CGPath");
          path = CGPathRetain(v76);
        }
        else
        {
          path = 0;
        }
        if (-[TSTAnimation drawTableName](v197, "drawTableName"))
          TSTTableRepDrawTableName(a1, a4, v197);
        if ((!-[TSTAnimation enabled](v197, "enabled")
           || -[TSTAnimation drawTableBackground](v197, "drawTableBackground"))
          && TSTTableGetBackgroundFill())
        {
          CGContextSaveGState(a4);
          if (v75)
          {
            CGContextAddPath(a4, path);
            CGContextClip(a4);
          }
          CGContextSetBlendMode(a4, kCGBlendModeClear);
          v239.origin.x = TSTLayoutSpaceGetFrame((uint64_t)a2);
          CGContextFillRect(a4, v239);
          CGContextRestoreGState(a4);
        }
        v190 = v75;
        if ((_DWORD)v193)
          v77 = v193 - 1;
        else
          v77 = 0;
        if ((_DWORD)v59)
          v78 = v59 - 1;
        else
          v78 = 0;
        v79 = TSTLayoutSpaceGetGridRange((uint64_t)a2);
        LODWORD(v82) = v194 + 1;
        v83 = -1;
        v84 = -1;
        if ((_DWORD)v194 != -2 && v77 <= v82)
        {
          v85 = v74 + 1;
          if ((_DWORD)v74 != -2
            && v78 <= v85
            && (_DWORD)v79 != -1
            && v80 != -1
            && v79 <= v80
            && HIDWORD(v79) != -1
            && v81 != -1
            && HIDWORD(v79) <= v81)
          {
            if (v77 <= v79)
              v86 = v79;
            else
              v86 = v77;
            if (v82 >= v80)
              v82 = v80;
            else
              v82 = v82;
            if (v86 <= v82
              && (v85 >= v81 ? (v87 = v81) : (v87 = v85),
                  v78 <= HIDWORD(v79) ? (v88 = HIDWORD(v79)) : (v88 = v78),
                  v88 <= v87))
            {
              v84 = v82 | (v87 << 32);
              v83 = v86 | (v88 << 32);
            }
            else
            {
              v83 = -1;
            }
          }
        }
        v191 = v84;
        v192 = v83;
        v89 = v190;
        if (-[TSTAnimation enabled](v197, "enabled") && !-[TSTAnimation drawCellBackground](v197, "drawCellBackground"))
        {
LABEL_231:
          if (!-[TSTAnimation enabled](v62, "enabled") || -[TSTAnimation drawCellContent](v62, "drawCellContent"))
          {
            CGContextSaveGState(v61);
            if (v89)
            {
              CGContextAddPath(v61, path);
              CGContextClip(v61);
            }
            TSTTableRepDrawCellContent(a1, a2, v193, v194, v61);
            CGContextRestoreGState(v61);
          }
          if (-[TSTAnimation enabled](v62, "enabled") && !-[TSTAnimation drawStrokes](v62, "drawStrokes"))
          {
            if (!-[TSTAnimation enabled](v62, "enabled"))
            {
LABEL_455:
              if ((!-[TSTAnimation enabled](v62, "enabled") || -[TSTAnimation drawCellContent](v62, "drawCellContent"))
                && objc_msgSend(v63, "count"))
              {
                CGContextSaveGState(v61);
                if (v89)
                {
                  CGContextAddPath(v61, path);
                  CGContextClip(v61);
                }
                v233 = 0u;
                v234 = 0u;
                v235 = 0u;
                v236 = 0u;
                v183 = objc_msgSend(v63, "countByEnumeratingWithState:objects:count:", &v233, v238, 16);
                if (v183)
                {
                  v184 = v183;
                  v185 = *(_QWORD *)v234;
                  do
                  {
                    for (i = 0; i != v184; ++i)
                    {
                      if (*(_QWORD *)v234 != v185)
                        objc_enumerationMutation(v63);
                      objc_msgSend(*(id *)(*((_QWORD *)&v233 + 1) + 8 * i), "drawInContext:", v61);
                    }
                    v184 = objc_msgSend(v63, "countByEnumeratingWithState:objects:count:", &v233, v238, 16);
                  }
                  while (v184);
                }
                CGContextRestoreGState(v61);
              }
              if ((!-[TSTAnimation enabled](v62, "enabled")
                 || -[TSTAnimation drawTableBackground](v62, "drawTableBackground"))
                && TSTTableGetBackgroundFill())
              {
                v187 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                v188 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableRepDrawGridRange(TSTTableRep *, TSTLayoutSpace *, TSTGridRange, TSTAnimation *, CGContextRef)");
                objc_msgSend(v187, "handleFailureInFunction:file:lineNumber:description:", v188, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRep.mm"), 5999, CFSTR("background fill is not supported yet"));
              }
              if (path)
                CGPathRelease(path);
LABEL_474:
              if (a2 && a4)
                CGContextRestoreGState(a4);
              goto LABEL_30;
            }
            CGContextSaveGState(v61);
            if (v89)
            {
              CGContextAddPath(v61, path);
              CGContextClip(v61);
            }
            v100 = v192;
            if ((_DWORD)v192 == -1)
            {
              v101 = v191;
            }
            else
            {
              v101 = v191;
              if ((_DWORD)v191 != -1
                && v192 <= v191
                && HIDWORD(v192) != -1
                && HIDWORD(v191) != -1
                && HIDWORD(v192) <= HIDWORD(v191))
              {
                v101 = (v191 & 0xFFFFFFFF00000000 | (v191 + 1)) + 0x100000000;
              }
            }
            v181 = a2;
            v182 = 1;
          }
          else
          {
            CGContextSaveGState(v61);
            if (v89)
            {
              CGContextAddPath(v61, path);
              CGContextClip(v61);
            }
            v100 = v192;
            if ((_DWORD)v192 == -1)
            {
              v101 = v191;
            }
            else
            {
              v101 = v191;
              if ((_DWORD)v191 != -1
                && v192 <= v191
                && HIDWORD(v192) != -1
                && HIDWORD(v191) != -1
                && HIDWORD(v192) <= HIDWORD(v191))
              {
                v101 = (v191 & 0xFFFFFFFF00000000 | (v191 + 1)) + 0x100000000;
              }
            }
            v181 = a2;
            v182 = 0;
          }
          TSTLayoutSpaceDrawStrokes(v181, v100, v101, v182, v61);
          CGContextRestoreGState(v61);
          goto LABEL_455;
        }
        CGContextSaveGState(a4);
        if (v190)
        {
          CGContextAddPath(a4, path);
          CGContextClip(a4);
        }
        v91 = v191;
        v90 = v192;
        if (v197)
        {
          if (!-[TSTAnimation enabled](v197, "enabled")
            || (v92 = -[TSTAnimation expandBackgroundFill](v197, "expandBackgroundFill"), v91 = v191, v90 = v192, !v92))
          {
            v90 = v193;
            v91 = v194;
          }
        }
        v199 = v90;
        v211 = HIDWORD(v90);
        v198 = HIDWORD(v91);
        v93 = -[TSTTableRep tableLayout](a1, "tableLayout");
        v232 = -[TSTTableRep masterLayout](a1, "masterLayout");
        v217 = v93;
        v227 = -[TSTTableInfo tableModel](-[TSTLayout tableInfo](v93, "tableInfo"), "tableModel");
        v94 = 0;
        if ((_DWORD)v199 != -1 && (_DWORD)v91 != -1 && v199 <= v91)
        {
          v94 = 0;
          if ((_DWORD)v211 != -1 && HIDWORD(v91) != -1 && v211 <= HIDWORD(v91))
            v94 = ((v91 - (v199 & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (v91 - v199 + 1))
                + 0x100000000;
        }
        if ((_DWORD)v199 == -1)
          v95 = 16711680;
        else
          v95 = (unint64_t)v199 << 16;
        v96 = (v94 >> 16) & 0xFFFF0000;
        v206 = -[TSTMasterLayout useBandedFill](v232, "useBandedFill");
        v219 = objc_alloc_init(TSTCell);
        v231 = objc_alloc_init(TSTCell);
        v221 = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
        if (-[TSTMasterLayout isDynamicallySwappingColumns](v232, "isDynamicallySwappingColumns")
          || (v97 = -[TSTMasterLayout isDynamicallySwappingRows](v232, "isDynamicallySwappingRows"),
              v98 = ((unint64_t)(v96 | v94) << 32) | WORD2(v199) | v95,
              v97))
        {
          v98 = -[TSTTableModel range](v227, "range");
        }
        v208 = TSTTableMergeRangesForCellRange((uint64_t)v227, v98);
        v214 = objc_msgSend(v208, "count");
        if (!-[TSDCanvas isCanvasInteractive](-[TSDRep canvas](a1, "canvas"), "isCanvasInteractive"))
          CGContextBeginTransparencyLayer(a4, 0);
        v99 = v219;
        if (v211 > HIDWORD(v91))
        {
LABEL_226:
          v61 = a4;
          if (!CGRectIsEmpty(a1->mSearchSelectionBounds))
          {
            CGContextSetFillColorWithColor(a4, (CGColorRef)objc_msgSend((id)objc_msgSend(MEMORY[0x24BEB3C40], "orangeColor"), "CGColor"));
            CGContextFillRect(a4, a1->mSearchSelectionBounds);
          }
          v63 = (void *)v196;
          v62 = v197;
          v89 = v190;
          if (!-[TSDCanvas isCanvasInteractive](-[TSDRep canvas](a1, "canvas"), "isCanvasInteractive"))
            CGContextEndTransparencyLayer(a4);

          CGContextRestoreGState(a4);
          goto LABEL_231;
        }
        if ((_BYTE)v94)
          v102 = (((unint64_t)(v96 | v94) << 32) | WORD2(v199) | v95) >> 48 == 0;
        else
          v102 = 1;
        v103 = v102;
        v213 = v103;
        v210 = v211 + (v96 >> 16) - 1;
        v207 = v95 >> 16;
        v204 = v94 + WORD1(v95) + 255;
        v105 = WORD2(v199) == 0xFFFFLL || v95 == 16711680;
        v200 = v105;
        LOWORD(VisibleRow) = v211;
        v202 = v91;
        while (1)
        {
          v216 = (unsigned __int16)VisibleRow;
          RowFill = TSTTableGetRowFill((uint64_t *)v227, (unsigned __int16)VisibleRow);
          if (v199 <= v91)
            break;
LABEL_261:
          VisibleRow = TSTMasterLayoutNextVisibleRow(v232, (unsigned __int16)(VisibleRow + 1));
          if (VisibleRow > v198)
            goto LABEL_226;
        }
        v215 = (TSDFill *)RowFill;
        v108 = (_DWORD)v199 << 16;
        v109 = v199;
        v220 = VisibleRow;
        while (1)
        {
          v110 = v108 & 0xFF0000 | v216;
          v238[0] = 0;
          v229 = v108;
          if (!v214)
            break;
          v218 = v218 & 0xFFFFFFFF00000000 | v110;
          -[TSTMasterLayout modelCellIDForLayoutCellID:](v232, "modelCellIDForLayoutCellID:");
          v111 = objc_msgSend(v208, "mergedRangeForCellID:");
          v112 = 0;
          if ((_WORD)v111 == 0xFFFF || (v111 & 0xFF0000) == 0xFF0000)
            goto LABEL_273;
          if (!HIWORD(v111) || (v111 & 0xFFFF00000000) == 0)
            break;
          v203 = v203 & 0xFFFFFFFF00000000 | v111;
          v118 = ($2F2D2FE54C0B9D2AA4EBD8788136C7D0)-[TSTMasterLayout layoutCellIDForModelCellID:](v232, "layoutCellIDForModelCellID:");
          VisibleRow = HIWORD(*(unsigned int *)&v118);
          v112 = HIBYTE(*(unsigned int *)&v118);
LABEL_274:
          v230 = v230 & 0xFFFFFFFF00000000 | v110;
          v114 = -[TSTMasterLayout tableAreaForCellID:](v232, "tableAreaForCellID:");
          -[TSTTableModel defaultCell:forTableArea:](v227, "defaultCell:forTableArea:", v231, v114);
          CellFill = (void *)TSTCellGetCellFill(v231);
          ColumnFill = TSTTableGetColumnFill((uint64_t *)v227, VisibleRow);
          v116 = -[TSTLayout editingSpillingTextRange](v217, "editingSpillingTextRange");
          v117 = 0;
          if ((_WORD)v116 != 0xFFFF && (v116 & 0xFF0000) != 0xFF0000)
          {
            v117 = 0;
            if (HIWORD(v116))
            {
              if ((v116 & 0xFFFF00000000) != 0)
              {
                if (v118.var0 >= (unsigned __int16)v116)
                {
                  v117 = 0;
                  if ((unsigned __int16)(v116 + HIWORD(v116) - 1) >= v118.var0
                    && BYTE2(v116) <= VisibleRow)
                  {
                    v117 = (BYTE4(v116) + BYTE2(v116) - 1) >= VisibleRow;
                  }
                }
                else
                {
                  v117 = 0;
                }
              }
            }
          }
          v226 = v117;
          v223 = v108 & 0xFF0000 | v216;
          v119 = VisibleRow << 16;
          if (!-[TSTMasterLayout isDynamicallyChangingContent](v232, "isDynamicallyChangingContent"))
            goto LABEL_292;
          if (v226)
          {
            v120 = ($2F2D2FE54C0B9D2AA4EBD8788136C7D0)-[TSTEditingState editingCellID](-[TSTTableRep editingState](a1, "editingState"), "editingCellID");
            v121 = v120;
            if (v120.var0 == 0xFFFF || (*(_DWORD *)&v120 & 0xFF0000) == 0xFF0000)
            {
              v201 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
              v122 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableRepDrawBackgroundFill(TSTTableRep *, TSTLayoutSpace *, TSTGridRange, CGContextRef)");
              objc_msgSend(v201, "handleFailureInFunction:file:lineNumber:description:", v122, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRep.mm"), 5129, CFSTR("Valid editing spilling text range but no editing cell ID"));
            }
          }
          else
          {
            v121 = v119 | (v112 << 24) | v118.var0;
          }
          v212 = v121 | v212 & 0xFFFFFFFF00000000;
          if (!-[TSTLayoutDynamicContentProtocol cell:forCellID:](-[TSTMasterLayout dynamicContentDelegate](v232, "dynamicContentDelegate"), "cell:forCellID:", v238))
          {
            a1 = v209;
LABEL_292:
            v124 = v119 | ((unint64_t)v112 << 24);
            v224 = v124 | v118.var0 | v224 & 0xFFFFFFFF00000000;
            v99 = v219;
            v125 = TSTCellAtCellIDSuppressingFormula((uint64_t)v227, v124 | v118.var0, v219, 1);
            v123 = (uint64_t)v231;
            if (!v125)
              goto LABEL_294;
            goto LABEL_293;
          }
          v123 = v238[0];
          a1 = v209;
          v99 = v219;
LABEL_293:
          TSTCellCopyJustStyleAndStrokes(v123, (uint64_t)v99);
LABEL_294:
          if (a1->mContainedTextEditingRep)
          {
            v126 = v119 | v118.var0;
            if (v126 == (-[TSTEditingState editingCellID](-[TSTTableRep editingState](a1, "editingState"), "editingCellID") & 0xFFFFFF))
            {
              v127 = 1;
              goto LABEL_299;
            }
          }
          else
          {
            v126 = v119 | v118.var0;
          }
          v127 = ((-[TSTMasterLayout dynamicSuppressingConditionalStylesCellID](-[TSTTableRep masterLayout](a1, "masterLayout"), "dynamicSuppressingConditionalStylesCellID") ^ v126) & 0xFFFFFF) == 0;
LABEL_299:
          LOWORD(VisibleRow) = v220;
          LOBYTE(v233) = 0;
          CellFillAndIsDefault = (TSDFill *)TSTCellGetCellFillAndIsDefault(v99, CellFill, v127, (char *)&v233);
          if ((_DWORD)v114)
            v129 = 1;
          else
            v129 = v233 == 0;
          if (v129)
            v130 = CellFillAndIsDefault;
          else
            v130 = v215;
          if (!v129 && !v215)
          {
            v131 = v206;
            if (ColumnFill)
            {
              v131 = 0;
              v130 = (TSDFill *)ColumnFill;
            }
            else
            {
              v130 = CellFillAndIsDefault;
            }
            if (v131)
            {
              v132 = (_DWORD)v223 == (v119 | v118.var0) ? v220 : v118.var0;
              v130 = CellFillAndIsDefault;
              if (-[TSTMasterLayout shouldRowUseBandedFill:](v232, "shouldRowUseBandedFill:", v132))
                v130 = -[TSTMasterLayout bandedFillObject](v232, "bandedFillObject");
            }
          }
          if (v130)
            v133 = v130 == (TSDFill *)v221;
          else
            v133 = 1;
          v134 = v213;
          if (v133)
            v134 = 1;
          if ((v134 & 1) != 0
            || (unsigned __int16)v211 > v220
            || (unsigned __int16)v210 < v220
            || v207 > v109
            || v204 < v109)
          {
            goto LABEL_437;
          }
          v135 = TSTMasterLayoutMergeRangeAtCellID(-[TSTTableRep masterLayout](a1, "masterLayout"), v223);
          v205 = v205 & 0xFFFFFFFF00000000 | v223;
          if (v226)
          {
            v136 = -[TSTLayout editingSpillingTextRange](v217, "editingSpillingTextRange");
            if ((_WORD)v136 == 0xFFFF)
              goto LABEL_337;
            v137 = 0xFFFFLL;
            v138 = 16711680;
            if ((v136 & 0xFF0000) != 0xFF0000)
            {
              v139 = (v136 & 0xFFFF00000000) == 0 || HIWORD(v136) == 0;
              v140 = v200;
              if (v139)
                v140 = 1;
              if ((v140 & 1) != 0)
              {
LABEL_337:
                v137 = 0xFFFFLL;
                v138 = 16711680;
              }
              else
              {
                v137 = 0;
                v170 = v204;
                v171 = BYTE2(v136);
                if (BYTE2(v136) <= v207)
                  v171 = v207;
                if ((unsigned __int16)v136 <= (unsigned __int16)v211)
                  v172 = (unsigned __int16)v211;
                else
                  v172 = (unsigned __int16)v136;
                if ((BYTE4(v136) + BYTE2(v136) - 1) < v204)
                  v170 = (BYTE4(v136) + BYTE2(v136) - 1);
                v173 = (unsigned __int16)(v136 + HIWORD(v136) - 1);
                if (v173 >= (unsigned __int16)v210)
                  v173 = (unsigned __int16)v210;
                if (v172 > v173)
                {
                  v138 = 0;
                }
                else
                {
                  v138 = 0;
                  if (v171 <= v170)
                  {
                    v138 = v171 << 16;
                    v137 = v172;
                  }
                }
              }
            }
            v141 = *(_QWORD *)&v138 & 0xFF0000 | v137;
            v142 = v141 == v223;
            if (v141 == v223)
              v143 = v136;
            else
              v143 = v223 | 0x1000100000000;
LABEL_341:
            if (!v142)
              v130 = (TSDFill *)v221;
            goto LABEL_352;
          }
          v143 = v135;
          if ((_WORD)v135 != 0xFFFF && (v135 & 0xFF0000) != 0xFF0000 && HIWORD(v135) && (v135 & 0xFFFF00000000) != 0)
          {
            if ((v200 & 1) != 0)
            {
              v144 = 0xFFFFLL;
              v145 = 16711680;
            }
            else
            {
              v144 = 0;
              v175 = v204;
              v176 = BYTE2(v135);
              if (BYTE2(v135) <= v207)
                v176 = v207;
              if ((unsigned __int16)v135 <= (unsigned __int16)v211)
                v177 = (unsigned __int16)v211;
              else
                v177 = (unsigned __int16)v135;
              if ((BYTE4(v135) + BYTE2(v135) - 1) < v204)
                v175 = (BYTE4(v135) + BYTE2(v135) - 1);
              v178 = (unsigned __int16)(v135 + HIWORD(v135) - 1);
              if (v178 >= (unsigned __int16)v210)
                v178 = (unsigned __int16)v210;
              if (v177 > v178)
              {
                v145 = 0;
              }
              else
              {
                v145 = 0;
                if (v176 <= v175)
                {
                  v145 = v176 << 16;
                  v144 = v177;
                }
              }
            }
            v142 = (*(_QWORD *)&v145 & 0xFF0000 | v144) == v223;
            goto LABEL_341;
          }
          v143 = v223 | 0x1000100000000;
LABEL_352:
          if (BYTE2(v143) == 255)
            v146 = -1;
          else
            v146 = BYTE2(v143);
          v147 = (unsigned __int16)v143;
          if (WORD2(v143))
            v148 = WORD2(v143) + v146 - 1;
          else
            v148 = -1;
          if ((unsigned __int16)v143 == 0xFFFF)
            v149 = -1;
          else
            v149 = (unsigned __int16)v143;
          v150 = TSTLayoutSpaceGetGridRange((uint64_t)a2);
          if (HIWORD(v143))
            v153 = v149 + ((unint64_t)((HIDWORD(v143) << 16) - 0x100000000) >> 32);
          else
            v153 = -1;
          v154 = -1;
          if (BYTE2(v143) == 255 || v148 == -1)
          {
            v155 = -1;
          }
          else
          {
            v155 = -1;
            if (v146 <= v148
              && v147 != 0xFFFF
              && v153 != -1
              && v149 <= v153
              && (_DWORD)v150 != -1
              && v151 != -1
              && v150 <= v151
              && HIDWORD(v150) != -1
              && v152 != -1
              && HIDWORD(v150) <= v152)
            {
              v156 = v146 <= v150 ? v150 : v146;
              v157 = v148 >= v151 ? v151 : v148;
              if (v156 <= v157)
              {
                v158 = v153 >= v152 ? v152 : v153;
                v159 = v149 <= HIDWORD(v150) ? HIDWORD(v150) : v149;
                if (v159 <= v158)
                {
                  v155 = v157 | (v158 << 32);
                  v154 = v156 | (v159 << 32);
                }
              }
            }
          }
          AlignedFrameForGridRange = TSTLayoutSpaceGetAlignedFrameForGridRange(a2, v154, v155);
          if (v130 == (TSDFill *)v221)
          {
            a1 = v209;
            v99 = v219;
            LOWORD(VisibleRow) = v220;
            LODWORD(v91) = v202;
          }
          else
          {
            v164 = AlignedFrameForGridRange;
            v165 = v161;
            v166 = v162;
            v167 = v163;
            objc_opt_class();
            v99 = v219;
            LOWORD(VisibleRow) = v220;
            LODWORD(v91) = v202;
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              a1 = v209;
              if (!-[TSDFill isClear](v130, "isClear"))
                -[TSDFill paintRect:inContext:](v130, "paintRect:inContext:", a4, v164, v165, v166, v167);
            }
            else
            {
              v168 = (void *)MEMORY[0x24BDD17C8];
              if ((HIDWORD(v154) & v154) == 0xFFFFFFFF)
              {
                v174 = CFSTR("{invalid, invalid}");
              }
              else
              {
                if ((_DWORD)v154 == -1)
                {
                  v169 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{invalid, %u}"), HIDWORD(v154), v189);
                }
                else if (HIDWORD(v154) == -1)
                {
                  v169 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, invalid}"), v154, v189);
                }
                else
                {
                  v169 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, %u}"), v154, HIDWORD(v154));
                }
                v174 = (const __CFString *)v169;
              }
              if ((HIDWORD(v155) & v155) == 0xFFFFFFFF)
              {
                v179 = CFSTR("{invalid, invalid}");
              }
              else if ((_DWORD)v155 == -1)
              {
                v179 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{invalid, %u}"), HIDWORD(v155), v189);
              }
              else if (HIDWORD(v155) == -1)
              {
                v179 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, invalid}"), v155, v189);
              }
              else
              {
                v179 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, %u}"), v155, HIDWORD(v155));
              }
              v180 = objc_msgSend(v168, "stringWithFormat:", CFSTR("{%@->%@}"), v174, v179);
              v189 = v130;
              NSLog((NSString *)CFSTR("WARNING: invalid cell fill %@ %@"), v180);
              a1 = v209;
            }
          }
LABEL_437:
          TSTCellClear((uint64_t)v99);
          TSTCellClear((uint64_t)v231);
          ++v109;
          v108 = v229 + 0x10000;
          if (v109 > v91)
            goto LABEL_261;
        }
        v112 = 0;
LABEL_273:
        v118.var0 = VisibleRow;
        LOBYTE(VisibleRow) = v109;
        goto LABEL_274;
      }
    }
  }
LABEL_30:
  -[TSDCanvas viewScale](-[TSDRep canvas](a1, "canvas"), "viewScale");
  TSTTableRepSetupUserSpaceToDeviceSpaceTransform(a1, v16, a1->mCurrentScreenScale);
}

double TSTTableRepGetImageFrameForRange(double *a1, unint64_t a2, int a3)
{
  TSTLayout *v6;
  double AlignedStrokeFrameForRange;
  double v8;
  CGFloat v9;
  double v10;
  CGFloat v11;
  double v12;
  CGFloat v13;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double v18;
  double v19;
  CGFloat v20;
  CGFloat v21;
  CGFloat v22;
  double v23;
  double v24;
  CGAffineTransform v26;
  CGAffineTransform v27;
  CGRect v28;
  CGRect v29;
  CGRect v30;
  CGRect v31;
  CGRect v32;
  CGRect v33;

  v6 = (TSTLayout *)objc_msgSend(a1, "tableLayout");
  AlignedStrokeFrameForRange = TSTLayoutGetAlignedStrokeFrameForRange(v6, a2);
  v9 = v8;
  v11 = v10;
  v13 = v12;
  if (a3)
  {
    v28.origin.x = TSTLayoutGetAlignedStrokeFrameForTableNameBorder(v6);
    x = v28.origin.x;
    y = v28.origin.y;
    width = v28.size.width;
    height = v28.size.height;
    if (!CGRectIsEmpty(v28))
    {
      v29.origin.x = x;
      v29.origin.y = y;
      v29.size.width = width;
      v29.size.height = height;
      v33.origin.x = AlignedStrokeFrameForRange;
      v33.origin.y = v9;
      v33.size.width = v11;
      v33.size.height = v13;
      v30 = CGRectUnion(v29, v33);
      AlignedStrokeFrameForRange = v30.origin.x;
      v9 = v30.origin.y;
      v11 = v30.size.width;
      v13 = v30.size.height;
    }
  }
  memset(&v27, 0, sizeof(v27));
  TSTLayoutGetTransformToDevice(v6, &v27);
  v26 = v27;
  v31.origin.x = AlignedStrokeFrameForRange;
  v31.origin.y = v9;
  v31.size.width = v11;
  v31.size.height = v13;
  v32 = CGRectApplyAffineTransform(v31, &v26);
  v18 = a1[55];
  v19 = TSDMultiplyRectScalar(v32.origin.x, v32.origin.y, v32.size.width, v32.size.height, 1.0 / v18);
  v23 = TSDRoundedRectForScale(v19, v20, v21, v22, v18);
  TSDCeilSize(v24);
  return v23;
}

double TSTTableRepGetDrawnFrameInsideImageFrameForRange(double *a1, unint64_t a2)
{
  TSTLayout *v4;
  double AlignedStrokeFrameForRange;
  double v6;
  CGFloat v7;
  double v8;
  CGFloat v9;
  double v10;
  CGFloat v11;
  double v12;
  double v13;
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  CGAffineTransform v18;
  CGAffineTransform v19;
  CGRect v20;
  CGRect v21;

  v4 = (TSTLayout *)objc_msgSend(a1, "tableLayout");
  AlignedStrokeFrameForRange = TSTLayoutGetAlignedStrokeFrameForRange(v4, a2);
  v7 = v6;
  v9 = v8;
  v11 = v10;
  memset(&v19, 0, sizeof(v19));
  TSTLayoutGetTransformToDevice(v4, &v19);
  v18 = v19;
  v20.origin.x = AlignedStrokeFrameForRange;
  v20.origin.y = v7;
  v20.size.width = v9;
  v20.size.height = v11;
  v21 = CGRectApplyAffineTransform(v20, &v18);
  v12 = a1[55];
  v13 = TSDMultiplyRectScalar(v21.origin.x, v21.origin.y, v21.size.width, v21.size.height, 1.0 / v12);
  TSDRoundedRectForScale(v13, v14, v15, v16, v12);
  return *MEMORY[0x24BDBEFB0];
}

uint64_t TSTTableRepGetImageForRange(TSTTableRep *a1, unint64_t a2)
{
  id v4;
  id v5;
  double ImageFrameForRange;
  double v7;
  CGFloat v8;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  double DrawnFrameInsideImageFrameForRange;
  double v14;
  CGFloat v15;
  double v16;
  CGFloat v17;
  double v18;
  CGFloat v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  CGFloat v25;
  double v26;
  double v27;
  double v28;
  CGFloat v29;
  double v30;
  CGFloat v31;
  double v32;
  CGFloat v33;
  CGContext *v34;
  CGFloat v35;
  double v36;
  CGFloat v37;
  double v38;
  double v39;
  TSDLayout *v40;
  CGImage *Image;
  uint64_t v42;
  double v43;
  CGFloat v44;
  double v45;
  CGAffineTransform v47;
  CGAffineTransform transform;
  CGRect v49;

  v4 = +[TSTAnimation newAnimationWithLayout:andCellRange:](TSTAnimation, "newAnimationWithLayout:andCellRange:", -[TSTTableRep tableLayout](a1, "tableLayout"), a2);
  v5 = v4;
  ImageFrameForRange = TSTTableRepGetImageFrameForRange((double *)a1, a2, 0);
  v8 = v7;
  v10 = v9;
  v12 = v11;
  DrawnFrameInsideImageFrameForRange = TSTTableRepGetDrawnFrameInsideImageFrameForRange((double *)a1, a2);
  v15 = v14;
  v17 = v16;
  v19 = v18;
  -[TSDCanvas contentsScale](-[TSDRep canvas](a1, "canvas"), "contentsScale");
  v21 = TSDMultiplyRectScalar(ImageFrameForRange, v8, v10, v12, v20);
  v23 = v22;
  v25 = v24;
  -[TSDCanvas contentsScale](-[TSDRep canvas](a1, "canvas", v21), "contentsScale");
  v27 = TSDMultiplyRectScalar(DrawnFrameInsideImageFrameForRange, v15, v17, v19, v26);
  v29 = v28;
  v31 = v30;
  v33 = v32;
  v34 = TSDBitmapContextCreate(3, v23);
  CGContextTranslateCTM(v34, 0.0, v25);
  CGContextScaleCTM(v34, 1.0, -1.0);
  v49.origin.x = v27;
  v49.origin.y = v29;
  v49.size.width = v31;
  v49.size.height = v33;
  CGContextClipToRect(v34, v49);
  -[TSDCanvas contentsScale](-[TSDRep canvas](a1, "canvas"), "contentsScale");
  CGContextScaleCTM(v34, v35, v35);
  -[TSDCanvas viewScale](-[TSDRep canvas](a1, "canvas"), "viewScale");
  v37 = v36;
  CGContextTranslateCTM(v34, -ImageFrameForRange, -v8);
  -[TSTTableRep layerFrameInScaledCanvas](a1, "layerFrameInScaledCanvas");
  CGContextTranslateCTM(v34, -v38, -v39);
  CGContextScaleCTM(v34, v37, v37);
  v40 = -[TSDRep layout](a1, "layout");
  if (v40)
    -[TSDAbstractLayout transformInRoot](v40, "transformInRoot");
  else
    memset(&transform, 0, sizeof(transform));
  CGContextConcatCTM(v34, &transform);
  if (a1)
    -[TSTTableRep transformFromCanvas](a1, "transformFromCanvas");
  else
    memset(&v47, 0, sizeof(v47));
  CGContextConcatCTM(v34, &v47);
  -[TSTTableRep pushAnimation:](a1, "pushAnimation:", v4);
  TSTTableRepDrawRangeInContext(a1, a2, (uint64_t)v34);
  -[TSTTableRep popAnimation](a1, "popAnimation");
  Image = CGBitmapContextCreateImage(v34);
  v42 = objc_msgSend(MEMORY[0x24BEB3C90], "imageWithCGImage:", Image);
  CGImageRelease(Image);
  CGContextRelease(v34);
  -[TSDCanvas viewScale](-[TSDRep canvas](a1, "canvas"), "viewScale");
  v44 = v43;
  -[TSDCanvas contentsScale](-[TSDRep canvas](a1, "canvas"), "contentsScale");
  TSTTableRepSetupUserSpaceToDeviceSpaceTransform(a1, v44, v45);
  return v42;
}

uint64_t TSTTableRepPrepareToDrawLayoutSpace(TSTTableRep *a1, TSTLayoutSpace *a2, CGContextRef c)
{
  void *v6;
  uint64_t v7;
  double b;
  __int128 v9;
  uint64_t v10;
  uint64_t result;
  CGAffineTransform v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  CGAffineTransform transform;

  if (a2)
  {
    CGContextSaveGState(c);
    -[TSTLayoutSpace transformToCanvas](a2, "transformToCanvas");
  }
  else
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableRepPrepareToDrawLayoutSpace(TSTTableRep *, TSTLayoutSpace *, CGContextRef)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRep.mm"), 4786, CFSTR("invalid nil value for '%s'"), "space");
    CGContextSaveGState(c);
    memset(&transform, 0, sizeof(transform));
  }
  CGContextConcatCTM(c, &transform);
  if (-[TSDCanvas isDrawingIntoPDF](-[TSDRep canvas](a1, "canvas"), "isDrawingIntoPDF"))
    goto LABEL_14;
  v9 = 0uLL;
  v14 = 0u;
  v15 = 0u;
  v13 = 0u;
  if (a2)
  {
    -[TSTLayoutSpace transformToDevice](a2, "transformToDevice");
    v9 = 0uLL;
  }
  *(_OWORD *)&v12.c = v9;
  *(_OWORD *)&v12.tx = v9;
  *(_OWORD *)&v12.a = v9;
  CGContextGetCTM(&v12, c);
  b = *(double *)&v13;
  if (*(double *)&v13 < 0.0)
    goto LABEL_14;
  if (*((double *)&v14 + 1) >= 0.0
    && *((double *)&v15 + 1) + *((double *)&v13 + 1) + *((double *)&v14 + 1) * 0.0 == *((double *)&v15 + 1)
                                                                                    + *((double *)&v14 + 1) * 0.0
                                                                                    + *((double *)&v13 + 1) * 0.0
    && (b = *(double *)&v15 + *(double *)&v14 * 0.0 + *(double *)&v13 * 0.0,
        *(double *)&v15 + *(double *)&v14 + *(double *)&v13 * 0.0 == b)
    && (b = v12.b, v12.b == 0.0)
    && (b = v12.c, v12.c == 0.0))
  {
    v10 = 1;
  }
  else
  {
LABEL_14:
    v10 = 0;
  }
  -[TSTLayoutSpace setDrawPreventAntialias:](a2, "setDrawPreventAntialias:", v10, b);
  -[TSTLayoutSpace setDrawBlackAndWhite:](a2, "setDrawBlackAndWhite:", 0);
  result = -[TSTAnimation enabled](-[TSTTableRep currentAnimation](a1, "currentAnimation"), "enabled");
  if ((_DWORD)result)
  {
    result = -[TSTAnimation drawsBlackAndWhite](-[TSTTableRep currentAnimation](a1, "currentAnimation"), "drawsBlackAndWhite");
    if ((_DWORD)result)
      return -[TSTLayoutSpace setDrawBlackAndWhite:](a2, "setDrawBlackAndWhite:", 1);
  }
  return result;
}

uint64_t TSTTableRepDrawCellContent(void *a1, TSTLayoutSpace *a2, unint64_t a3, unint64_t a4, CGContext *a5)
{
  unint64_t v5;
  void *v9;
  uint64_t result;
  BOOL v11;
  BOOL v12;
  _BOOL4 v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  _BOOL4 v18;
  _BOOL4 v19;
  int v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  char v24;
  unsigned __int8 v25;
  unint64_t v26;
  int v27;
  uint64_t v28;
  char v29;
  unint64_t v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t GridRange;
  unsigned int v36;
  unsigned int v37;
  unint64_t v38;
  unsigned int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  BOOL v43;
  unsigned int v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unsigned int v48;
  TSTLayoutCellIterator *v49;
  _BOOL4 v51;
  BOOL v52;
  int v53;
  void *v54;
  int v55;
  unsigned int v56;
  uint64_t v57;
  BOOL v58;
  BOOL v59;
  unint64_t v61;
  unint64_t v62;
  int v63;
  void *v64;
  unint64_t v65;
  void *v66;
  uint64_t v67;
  id v68;
  void *v69;
  int v70;
  unsigned int v71;
  _BOOL4 v72;
  unint64_t v73;
  _BOOL8 v74;
  unint64_t v75;
  _BOOL4 v76;
  _BOOL4 v77;
  _BOOL4 v78;
  BOOL v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  double AlignedContentFrameForGridRange;
  double v89;
  CGFloat v90;
  double v91;
  unint64_t v92;
  unsigned int v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int v96;
  uint64_t v97;
  unsigned int v98;
  unsigned int v99;
  uint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  unsigned int v105;
  uint64_t v106;
  unsigned int v107;
  unsigned int v108;
  uint64_t v109;
  unint64_t v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t v117;
  double v118;
  double v119;
  double width;
  double v121;
  double v122;
  unint64_t v123;
  unint64_t v124;
  double v125;
  double v126;
  double v127;
  double v128;
  double v129;
  double v130;
  void *v131;
  uint64_t v132;
  uint64_t v133;
  void *v134;
  uint64_t v135;
  void *v136;
  void *v137;
  void *v138;
  void *v139;
  void *v140;
  uint64_t v141;
  double v142;
  double v143;
  double v144;
  double v145;
  double v146;
  double v147;
  double v148;
  double v149;
  double v150;
  double v151;
  double v152;
  double v153;
  double v154;
  double v155;
  double v156;
  double v157;
  double v158;
  double v159;
  double v160;
  double v161;
  double v162;
  double v163;
  double x;
  CGFloat y;
  TSTCell *v166;
  int v167;
  unsigned int v168;
  void *v169;
  void *v170;
  __int128 v171;
  uint64_t v172;
  uint64_t v173;
  CGFloat v174;
  unsigned int TableNumberOfHeaderColumns;
  unint64_t v176;
  _BOOL4 v177;
  unsigned int v178;
  __int16 v179;
  double v180;
  double v181;
  unsigned int v182;
  unsigned __int8 v183;
  unsigned int v184;
  double v185;
  double v186;
  char v187;
  uint64_t v188;
  _BOOL4 v189;
  _BOOL4 v190;
  char v191;
  char v192;
  char *v193;
  unint64_t v194;
  BOOL v195;
  int v197;
  unint64_t v198;
  unsigned int v199;
  unsigned int v200;
  unsigned int v201;
  BOOL v202;
  int v203;
  unint64_t *v204;
  TSTMasterLayout *v205;
  TSDStroke *v206;
  unsigned int v207;
  _DWORD *v208;
  double v209;
  BOOL v210;
  unint64_t v211;
  unint64_t v212;
  uint64_t d_low;
  uint64_t c_low;
  BOOL v220;
  BOOL v221;
  unint64_t v222;
  unint64_t v223;
  uint64_t v224;
  unint64_t v225;
  unint64_t v226;
  unint64_t v227;
  unint64_t v228;
  double v229;
  double v230;
  double v231;
  char v232;
  _BOOL4 v233;
  CGFloat v234;
  CGFloat v235;
  CGFloat v236;
  CGFloat v237;
  CGFloat height;
  double v239;
  TSTTextEngineDelegate *v240;
  TSTTextEngineDelegate *v241;
  void *v242;
  uint64_t c_high;
  uint64_t d_high;
  unsigned __int16 v245;
  uint64_t v246;
  __int16 v247;
  unint64_t v248;
  uint64_t v249;
  uint64_t v250;
  unint64_t v251;
  __int16 v252;
  unsigned int v253;
  uint64_t v254;
  unsigned int v255;
  unsigned int v256;
  uint64_t v257;
  unsigned int v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  BOOL v263;
  uint64_t v264;
  unint64_t v265;
  __int16 v266;
  unsigned int v267;
  unsigned __int8 v268;
  unint64_t v269;
  unsigned int v270;
  double v271;
  _BOOL4 v272;
  _BOOL4 v273;
  unint64_t v274;
  unint64_t v275;
  unint64_t v276;
  unint64_t v277;
  unint64_t v278;
  unint64_t v279;
  unint64_t v280;
  int v281;
  int v282;
  unint64_t v283;
  unsigned __int16 v284;
  int v285;
  int v286;
  unint64_t v287;
  unsigned __int16 v288;
  double v289;
  int v290;
  unsigned int v291;
  double v292;
  double ContentFrameForGridRange;
  uint64_t v294;
  CGFloat v295;
  void *v296;
  _BOOL4 v297;
  unint64_t v298;
  unint64_t v299;
  _BOOL4 v300;
  uint64_t v301;
  unint64_t v302;
  unint64_t v303;
  int v304;
  unsigned int v305;
  unsigned __int8 v306;
  unsigned int v307;
  void *v308;
  void *v309;
  double v310;
  void *v311;
  _BOOL4 v312;
  double v313;
  int v315;
  void *v316;
  int v317;
  uint64_t v318;
  double v319;
  unsigned __int16 *v320;
  double v321;
  unsigned int v322;
  double v323;
  unsigned int v324;
  double v325;
  unsigned int v326;
  double v327;
  _BOOL4 v328;
  int v329;
  void *v330;
  double v331;
  CGFloat rect;
  char recta;
  unsigned __int16 rectb;
  void *v335;
  int v337;
  int v338;
  double v339;
  void *v340;
  uint64_t v341;
  unint64_t v342;
  _BOOL4 v343;
  TSTCell *v344;
  void *context;
  unint64_t v346;
  TSTLayoutCellIterator *v347;
  TSTCell *v348;
  _QWORD v349[3];
  unint64_t v350;
  CGAffineTransform v351;
  CGAffineTransform v352;
  CGAffineTransform v353;
  CGAffineTransform v354;
  CGAffineTransform transform;
  CGAffineTransform v356;
  unsigned int v357;
  unsigned int v358;
  BOOL v359;
  id v360;
  CGAffineTransform v361;
  CGAffineTransform v362;
  uint64_t v363;
  CGRect v364;
  CGRect v365;
  CGRect v366;
  CGRect v367;
  CGRect v368;
  CGRect v369;
  CGRect v370;
  CGRect v371;
  CGRect v372;
  CGRect v373;

  v363 = *MEMORY[0x24BDAC8D0];
  v311 = (void *)objc_msgSend(a1, "tableLayout");
  v9 = (void *)objc_msgSend(v311, "masterLayout");
  if (!objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicRepResize")
    || (result = TSTTableNumberOfPopulatedCells(objc_msgSend(a1, "tableModel")), result <= 0x19))
  {
    result = objc_msgSend(a1, "isDrawingInFlippedContext");
    v291 = result;
    v11 = (_DWORD)a3 == -1 || (_DWORD)a4 == -1;
    v12 = v11 || a3 > a4;
    v13 = v12;
    v304 = v13;
    v14 = 0;
    if (v12)
    {
      v15 = HIDWORD(a3);
    }
    else
    {
      v15 = HIDWORD(a3);
      if (HIDWORD(a3) != -1 && HIDWORD(a4) != -1 && HIDWORD(a3) <= HIDWORD(a4))
        v14 = ((a4 - (a3 & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (a4 - a3 + 1)) + 0x100000000;
    }
    v284 = v15;
    if (v15 <= HIDWORD(a4))
    {
      if ((_DWORD)a3 == -1)
        v16 = 16711680;
      else
        v16 = (unint64_t)a3 << 16;
      v301 = (a4 - a3 + 1) | 0x100000000;
      v302 = v16;
      v18 = (~a3 & 0xFFFF00000000) != 0 && v16 != 16711680;
      v312 = v18;
      v19 = v14 != 0;
      if (((v14 >> 16) & 0xFFFF0000) == 0)
        v19 = 0;
      v300 = v19;
      v283 = v16 >> 16;
      v282 = v14 + WORD1(v16) + 255;
      v281 = v15 + (((v14 >> 16) & 0xFFFF0000) >> 16) - 1;
      LODWORD(result) = v15;
      v335 = a1;
      v316 = v9;
      v303 = HIDWORD(a4);
      do
      {
        v317 = result;
        v20 = v304;
        if ((_DWORD)result == -1)
          v20 = 1;
        v11 = v20 == 0;
        v21 = v301;
        if (!v11)
          v21 = 0;
        v22 = (unsigned __int16)result | (((v21 >> 16) & 0x10000 | v21) << 32) | v302;
        v23 = (unsigned __int16)result | v302;
        if (v23 >= 0x10000)
        {
          v356.a = 0.0;
          v299 = v299 & 0xFFFFFFFF00000000 | v23;
          v24 = objc_msgSend(v9, "cell:forCellID:", &v356);
          v356.a = 0.0;
          if ((v24 & 1) == 0)
          {
            v280 = v280 & 0xFFFFFFFF00000000 | v23;
            v279 = v279 & 0xFFFFFFFF00000000 | TSTLayoutCellLeftOfCell(v311, v280, 0);
            v22 = TSTCellRangeUnionCellID(v22, v279);
          }
        }
        v25 = BYTE2(v22);
        v26 = HIDWORD(v22);
        v27 = (BYTE4(v22) + BYTE2(v22) - 1);
        if (v27 != TSTMasterLayoutGetTableNumberOfColumns((uint64_t)v9) - 1)
        {
          v28 = (unsigned __int16)v22 | (v27 << 16);
          v356.a = 0.0;
          v298 = v298 & 0xFFFFFFFF00000000 | v28;
          v29 = objc_msgSend(v9, "cell:forCellID:", &v356);
          v356.a = 0.0;
          if ((v29 & 1) == 0)
          {
            v278 = v278 & 0xFFFFFFFF00000000 | v28;
            v277 = v277 & 0xFFFFFFFF00000000 | TSTLayoutCellRightOfCell(v311, v28, 0);
            v22 = TSTCellRangeUnionCellID(v22, v277);
            v26 = HIDWORD(v22);
            v25 = BYTE2(v22);
          }
        }
        v30 = v5;
        if (v25 == 255)
          v31 = -1;
        else
          v31 = v25;
        if ((_WORD)v26)
          v32 = (unsigned __int16)v26 + v31 - 1;
        else
          v32 = -1;
        if ((unsigned __int16)v22 == 0xFFFF)
          v33 = -1;
        else
          v33 = (unsigned __int16)v22;
        v34 = v33 + (((v26 << 16) - 0x100000000) >> 32);
        GridRange = TSTLayoutSpaceGetGridRange((uint64_t)a2);
        v38 = 0;
        if (HIWORD(v22))
          v39 = v34;
        else
          v39 = -1;
        v40 = -1;
        v41 = -1;
        v42 = -1;
        if (v25 == 255)
        {
          v44 = -1;
          v9 = v316;
        }
        else
        {
          v43 = v32 == -1 || v31 > v32;
          v44 = -1;
          v9 = v316;
          if (!v43)
          {
            v38 = 0;
            v41 = -1;
            v42 = -1;
            if ((unsigned __int16)v22 == 0xFFFF || v39 == -1)
              goto LABEL_83;
            v44 = -1;
            if (v33 > v39)
              goto LABEL_85;
            v38 = 0;
            v41 = -1;
            v42 = -1;
            if ((_DWORD)GridRange == -1 || v36 == -1)
              goto LABEL_83;
            v44 = -1;
            if (GridRange > v36)
              goto LABEL_85;
            v38 = 0;
            v41 = -1;
            v42 = -1;
            if (HIDWORD(GridRange) == -1 || v37 == -1)
            {
LABEL_83:
              v44 = -1;
            }
            else
            {
              v44 = -1;
              if (HIDWORD(GridRange) <= v37)
              {
                if (v31 <= GridRange)
                  v44 = GridRange;
                else
                  v44 = v31;
                if (v32 >= v36)
                  v42 = v36;
                else
                  v42 = v32;
                if (v44 > v42)
                  goto LABEL_82;
                if (v39 >= v37)
                  v39 = v37;
                v41 = v33 <= HIDWORD(GridRange) ? HIDWORD(GridRange) : v33;
                if (v41 <= v39)
                {
                  v38 = 0;
                  v40 = v44;
                  if (v44 != -1 && v42 != -1)
                  {
                    v263 = v41 == -1 || v39 == -1;
                    if (v263 || v41 > v39)
                      v38 = 0;
                    else
                      v38 = ((v42 - v44 + 1) | ((unint64_t)(v39 - v41) << 32)) + 0x100000000;
                  }
                }
                else
                {
LABEL_82:
                  v38 = 0;
                  v41 = -1;
                  v42 = -1;
                  v44 = -1;
                }
              }
            }
          }
        }
LABEL_85:
        v305 = v44;
        v306 = v40;
        v307 = v42;
        if (v40 == -1)
          v45 = 16711680;
        else
          v45 = (unint64_t)v40 << 16;
        v46 = (v38 >> 16) & 0xFFFF0000;
        v47 = v45 & 0xFFFFFFFFFFFF0000 | ((unint64_t)(v46 | v38) << 32) | (unsigned __int16)v41;
        v48 = v41;
        v49 = -[TSTLayoutCellIterator initWithLayout:range:flags:]([TSTLayoutCellIterator alloc], "initWithLayout:range:flags:", v311, v47, 1);
        v315 = objc_msgSend(v9, "isDynamicallyHidingRowsCols");
        v347 = v49;
        if (TSTLayoutCellIteratorGetNextCell((uint64_t)v49, v349))
        {
          v51 = (unsigned __int16)v48 != 0xFFFFLL && v45 != 16711680;
          v297 = v51;
          if ((_BYTE)v38)
            v52 = HIWORD(v47) == 0;
          else
            v52 = 1;
          v53 = !v52;
          v290 = v53;
          v287 = v45 >> 16;
          v288 = v48;
          v285 = v48 + (v46 >> 16) - 1;
          v286 = v38 + WORD1(v45) + 255;
          v341 = 0xFFFFFFLL;
          v54 = v335;
          v5 = v30;
          v55 = v315;
          while (1)
          {
            v56 = v350;
            v348 = (TSTCell *)v349[1];
            v57 = HIBYTE(v349[0]);
            if ((_WORD)v350 == 0xFFFF)
              goto LABEL_114;
            v58 = (v350 & 0xFF0000) == 0xFF0000 || HIWORD(v350) == 0;
            v59 = v58 || (v350 & 0xFFFF00000000) == 0;
            if (v59 || (WORD2(v349[0]) | ((unint64_t)BYTE6(v349[0]) << 16)) == (v350 & 0xFFFFFF))
              goto LABEL_114;
            v61 = v350 >> 16;
            if (v312 && v300)
            {
              v95 = 0;
              v96 = BYTE2(v350);
              if (BYTE2(v350) <= v283)
                v96 = v283;
              if ((unsigned __int16)v350 <= v284)
                v97 = v284;
              else
                v97 = (unsigned __int16)v350;
              if ((BYTE4(v350) + BYTE2(v350) - 1) >= v282)
                v98 = v282;
              else
                v98 = (BYTE4(v350) + BYTE2(v350) - 1);
              if ((unsigned __int16)(v350 + HIWORD(v350) - 1) >= (unsigned __int16)v281)
                v99 = (unsigned __int16)v281;
              else
                v99 = (unsigned __int16)(v350 + HIWORD(v350) - 1);
              v100 = 0;
              v101 = 0;
              v102 = 0;
              if (v97 <= v99 && v96 <= v98)
              {
                v102 = ((unint64_t)(v99 - v97) << 48) + 0x1000000000000;
                v101 = (unint64_t)(unsigned __int16)(v98 - v96 + 1) << 32;
                v100 = v96 << 16;
                v95 = v97;
              }
            }
            else
            {
              v101 = 0;
              v102 = 0;
              v95 = 0xFFFFLL;
              v100 = 16711680;
            }
            v103 = v100 | v102 | v95 | v101;
            if ((_WORD)v103 == 0xFFFF
              || (v103 & 0xFF0000) == 0xFF0000
              || !HIWORD(v103)
              || (v103 & 0xFFFF00000000) == 0
              || v317 != (unsigned __int16)v103)
            {
              goto LABEL_114;
            }
            if (v297 && v290)
            {
              v104 = 0;
              v105 = BYTE2(v350);
              if (BYTE2(v350) <= v287)
                v105 = v287;
              if ((unsigned __int16)v350 <= v288)
                v106 = v288;
              else
                v106 = (unsigned __int16)v350;
              if ((BYTE4(v350) + BYTE2(v350) - 1) >= v286)
                v107 = v286;
              else
                v107 = (BYTE4(v350) + BYTE2(v350) - 1);
              if ((unsigned __int16)(v350 + HIWORD(v350) - 1) >= (unsigned __int16)v285)
                v108 = (unsigned __int16)v285;
              else
                v108 = (unsigned __int16)(v350 + HIWORD(v350) - 1);
              v109 = 0;
              v110 = 0;
              v111 = 0;
              if (v106 <= v108 && v105 <= v107)
              {
                v111 = ((unint64_t)(v108 - v106) << 48) + 0x1000000000000;
                v110 = (unint64_t)(unsigned __int16)(v107 - v105 + 1) << 32;
                v109 = v105 << 16;
                v104 = v106;
              }
            }
            else
            {
              v110 = 0;
              v111 = 0;
              v104 = 0xFFFFLL;
              v109 = 16711680;
            }
            v113 = v109 | v111 | v104 | v110;
            if ((_WORD)v113 == 0xFFFF
              || (v113 & 0xFF0000) == 0xFF0000
              || !HIWORD(v113)
              || (v113 & 0xFFFF00000000) == 0
              || BYTE6(v349[0]) != BYTE2(v113))
            {
LABEL_114:
              LOBYTE(v61) = BYTE6(v349[0]);
              LOWORD(v56) = WORD2(v349[0]);
            }
            else
            {
              v57 = BYTE3(v350);
              v269 = v269 & 0xFFFFFFFF00000000 | v350;
              if ((objc_msgSend(v9, "cell:forCellID:", &v348) & 1) == 0)
              {
                v348 = objc_alloc_init(TSTCell);
                v114 = objc_msgSend(v54, "tableModel");
                v265 = v56 | v265 & 0xFFFFFFFF00000000;
                TSTCellAtCellID(v114, v56, v348);
              }
            }
            if (!v348)
              goto LABEL_169;
            v62 = (v57 << 24) | ((unint64_t)v61 << 16) | (unsigned __int16)v56;
            v5 = v62 | v5 & 0xFFFFFFFF00000000;
            v63 = objc_msgSend(v9, "modelCellIDForLayoutCellID:", v5);
            v64 = (void *)objc_msgSend(v9, "cellIDToWPColumnCache");
            HIDWORD(v65) = v63;
            LODWORD(v65) = v63;
            v66 = (void *)objc_msgSend(v64, "objectForKey:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", (v65 >> 16) & 0xFFFF00FF));
            if (v66)
            {
              if (!v55)
                goto LABEL_125;
            }
            else
            {
              if (v348 && *((unsigned __int8 *)&v348->mPrivate + 1) << 8 == 2304)
                v67 = -[TSTRichTextPayload storage](v348->mPrivate.mRichTextPayload, "storage");
              else
                v67 = NSStringFromNativeTSTCell((uint64_t)v348);
              v66 = (void *)v67;
              if (!v55)
              {
LABEL_125:
                v68 = v66;
                v344 = v348;
                v337 = HIDWORD(v349[0]);
                v340 = (void *)objc_msgSend(v54, "tableLayout");
                v69 = (void *)objc_msgSend(v54, "tableModel");
                v70 = objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "isDynamicallyResizingCellID:", v62);
                v360 = 0;
                v71 = objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "modelCellIDForLayoutCellID:", v62);
                context = (void *)MEMORY[0x219A15874]();
                objc_opt_class();
                v346 = v5;
                if ((objc_opt_isKindOfClass() & 1) != 0
                  || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0) && objc_msgSend(v66, "length"))
                {
                  v72 = 1;
                  goto LABEL_131;
                }
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  v72 = objc_msgSend(v66, "length") != 0;
LABEL_131:
                  v343 = v72;
                }
                else
                {
                  v343 = 0;
                }
                v73 = v62 | 0x1000100000000;
                if ((objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "isDynamicallyHidingContentOfCellID:", v62) & 1) == 0
                  && (objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "isDynamicallyHidingRowsColsCellID:", v62) & 1) == 0)
                {
                  if (!objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "isDynamicallyHidingTextOfCellID:", v62))goto LABEL_139;
                  v74 = (_BOOL8)v344;
                  if (v344 && (v344->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType - 263) <= 4)
                  {
                    TSTCellClearValue((uint64_t)v344);
                    v74 = (_BOOL8)v344;
                  }
                  if (TSTTableBadgeIsDrawingControlCell(v74))
                  {
LABEL_139:
                    v75 = TSTMasterLayoutMergeRangeAtCellID((void *)objc_msgSend(v54, "masterLayout"), v62);
                    v76 = (~(_DWORD)v75 & 0xFF0000) != 0 && (_WORD)v75 != 0xFFFF;
                    v328 = v76;
                    if (v76)
                    {
                      v77 = (v75 & 0xFFFF00000000) != 0;
                      v78 = HIWORD(v75) != 0;
                      v79 = v78 && v77;
                      if (v78 && v77)
                        v80 = v75;
                      else
                        v80 = v62 | 0x1000100000000;
                      v81 = objc_msgSend(v54, "canvas");
                      if (!v343)
                      {
                        v73 = v80;
                        v54 = v335;
                        v9 = v316;
                        v55 = v315;
                        goto LABEL_450;
                      }
                      v309 = (void *)v81;
                      if (v79)
                      {
                        v73 = v75;
                        if (BYTE2(v75) == 255)
                          v82 = -1;
                        else
                          v82 = BYTE2(v75);
                        v83 = WORD2(v75) + v82 - 1;
                        if (!WORD2(v75))
                          v83 = 0xFFFFFFFFLL;
                        if ((unsigned __int16)v75 == 0xFFFF)
                          v84 = 0xFFFFFFFFLL;
                        else
                          v84 = (unsigned __int16)v75;
                        v85 = v82 | ((unint64_t)v84 << 32);
                        v86 = ((v75 >> 16) & 0xFFFF00000000) + (v84 << 32) - 0x100000000;
                        if (((v75 >> 16) & 0xFFFF00000000) == 0)
                          v86 = 0xFFFFFFFF00000000;
                        v87 = v83 | v86;
                        AlignedContentFrameForGridRange = TSTLayoutSpaceGetAlignedContentFrameForGridRange(a2, v85, v83 | v86);
                        v90 = v89;
                        ContentFrameForGridRange = TSTLayoutSpaceGetContentFrameForGridRange(a2, v85, v87);
                        v310 = v91;
                        if (objc_msgSend((id)objc_msgSend(v335, "masterLayout"), "isDynamicallyChangingRowCount"))
                        {
                          v92 = objc_msgSend((id)objc_msgSend(v335, "tableModel"), "bodyRowRange");
                          if (HIWORD(v92)
                            && (v92 & 0xFFFF00000000) != 0
                            && (unsigned __int16)v92 <= (unsigned __int16)v75
                            && (unsigned __int16)(v92 + HIWORD(v92) - 1) >= (unsigned __int16)v75
                            && BYTE2(v92) <= BYTE2(v75)
                            && (v93 = (BYTE4(v92) + BYTE2(v92) - 1), v93 >= BYTE2(v75))
                            && v93 >= (BYTE4(v75) + BYTE2(v75) - 1))
                          {
                            v245 = v75 + HIWORD(v75) - 1;
                            v94 = v87;
                            v54 = v335;
                            if ((unsigned __int16)(v92 + HIWORD(v92) - 1) >= v245)
                            {
                              rectb = v245;
                              v246 = objc_msgSend((id)objc_msgSend(v335, "tableModel", v87), "bodyRowRange");
                              v247 = objc_msgSend((id)objc_msgSend(v335, "masterLayout"), "dynamicRowAdjustment");
                              v248 = 0;
                              if ((_WORD)v246 == 0xFFFF)
                              {
                                v249 = 0xFFFFLL;
                                v250 = 16711680;
                                v251 = 0;
                                v54 = v335;
                              }
                              else
                              {
                                v249 = 0xFFFFLL;
                                v250 = 16711680;
                                v251 = 0;
                                v54 = v335;
                                if ((v246 & 0xFF0000) != 0xFF0000)
                                {
                                  v248 = 0;
                                  if ((v246 & 0xFFFF00000000) != 0)
                                  {
                                    v252 = v247 + HIWORD(v246);
                                    v249 = 0xFFFFLL;
                                    v250 = 16711680;
                                    v251 = 0;
                                    if (v247 + HIWORD(v246))
                                    {
                                      v249 = 0;
                                      v253 = BYTE2(v75);
                                      if (BYTE2(v75) <= BYTE2(v246))
                                        v253 = BYTE2(v246);
                                      if ((unsigned __int16)v75 <= (unsigned __int16)v246)
                                        v254 = (unsigned __int16)v246;
                                      else
                                        v254 = (unsigned __int16)v75;
                                      if ((BYTE4(v75) + BYTE2(v75) - 1) >= (BYTE4(v246) + BYTE2(v246) - 1))
                                        v255 = (BYTE4(v246) + BYTE2(v246) - 1);
                                      else
                                        v255 = (BYTE4(v75) + BYTE2(v75) - 1);
                                      if (rectb >= (unsigned __int16)(v246 + v252 - 1))
                                        v256 = (unsigned __int16)(v246 + v252 - 1);
                                      else
                                        v256 = rectb;
                                      v250 = 0;
                                      v248 = 0;
                                      v251 = 0;
                                      if (v254 <= v256 && v253 <= v255)
                                      {
                                        v251 = ((unint64_t)(v256 - v254) << 48) + 0x1000000000000;
                                        v248 = (unint64_t)(unsigned __int16)(v255 - v253 + 1) << 32;
                                        v250 = v253 << 16;
                                        v249 = v254;
                                      }
                                    }
                                  }
                                  else
                                  {
                                    v249 = 0xFFFFLL;
                                    v250 = 16711680;
                                    v251 = 0;
                                  }
                                }
                              }
                              v257 = v250 | v251 | v249 | v248;
                              if (BYTE2(v257) == 255)
                                v258 = -1;
                              else
                                v258 = BYTE2(v257);
                              v259 = WORD2(v257) + v258 - 1;
                              if (!WORD2(v257))
                                v259 = 0xFFFFFFFFLL;
                              if ((unsigned __int16)v257 == 0xFFFF)
                                v257 = 0xFFFFFFFFLL;
                              else
                                v257 = (unsigned __int16)v257;
                              v85 = v258 | ((unint64_t)v257 << 32);
                              v260 = (v251 >> 16) & 0xFFFF00000000;
                              v261 = v260 + (v257 << 32) - 0x100000000;
                              if (!v260)
                                v261 = 0xFFFFFFFF00000000;
                              v94 = v259 | v261;
                            }
                          }
                          else
                          {
                            v94 = v87;
                            v54 = v335;
                          }
                        }
                        else
                        {
                          v54 = v335;
                          v94 = v87;
                        }
                        v123 = TSTLayoutSpaceIntersectionGridRange(a2, v85, v94);
                        v319 = TSTLayoutSpaceGetAlignedContentFrameForGridRange(a2, v123, v124);
                        v295 = v125;
                        width = v126;
                        rect = v127;
                        v55 = v315;
LABEL_232:
                        v359 = 0;
                        v358 = 0;
                        v357 = 1;
                        v129 = 0.0;
                        v128 = 0.0;
                        v130 = 0.0;
                        v313 = 0.0;
                        CGContextSaveGState(a5);
                        v318 = v71;
                        TSTCellTextProperties((uint64_t)v344, v69, v71, &v359, &v358, &v357, (uint64_t *)&v360);
                        v131 = (void *)objc_msgSend((id)objc_msgSend(v54, "layout"), "parent");
                        if ((objc_opt_respondsToSelector() & 1) != 0)
                          v132 = objc_msgSend(v131, "pageNumber");
                        else
                          v132 = 0x7FFFFFFFFFFFFFFFLL;
                        if ((objc_opt_respondsToSelector() & 1) != 0)
                          v133 = objc_msgSend(v131, "pageCount");
                        else
                          v133 = 0x7FFFFFFFFFFFFFFFLL;
                        if (objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "isDynamicallyChangingFontColorOfCellID:", v318))
                        {
                          objc_opt_class();
                          v134 = v66;
                          if (TSUDynamicCast())
                          {
                            if (v344 && *((unsigned __int8 *)&v344->mPrivate + 1) << 8 == 2304)
                              v135 = -[TSTRichTextPayload storage](v344->mPrivate.mRichTextPayload, "storage");
                            else
                              v135 = NSStringFromNativeTSTCell((uint64_t)v344);
                            v134 = (void *)v135;
                          }
                          v138 = (void *)objc_msgSend(v54, "masterLayout");
                          LODWORD(v264) = 0;
                          v137 = (void *)objc_msgSend(v138, "validateCellForDrawing:cell:contents:wrap:verticalAlignment:padding:layoutCacheFlags:pageNumber:pageCount:", v318, v344, v134, v359, v357, v360, v264, v132, v133);
                        }
                        else
                        {
                          if (v70)
                          {
                            v136 = (void *)objc_msgSend(v54, "masterLayout");
                            LODWORD(v264) = 15;
                            v137 = (void *)objc_msgSend(v136, "validateCellForDrawing:cell:contents:wrap:verticalAlignment:padding:layoutCacheFlags:pageNumber:pageCount:", v318, v344, v66, v359, v357, v360, v264, v132, v133);
                          }
                          else
                          {
                            objc_opt_class();
                            v137 = (void *)TSUDynamicCast();
                          }
                          v134 = v66;
                        }
                        v330 = v66;
                        if (!v137)
                        {
                          v139 = (void *)objc_msgSend(v54, "masterLayout");
                          LODWORD(v264) = 15;
                          v137 = (void *)objc_msgSend(v139, "validateCellForDrawing:cell:contents:wrap:verticalAlignment:padding:layoutCacheFlags:pageNumber:pageCount:", v318, v344, v134, v359, v357, v360, v264, v132, v133);
                          if (!v137)
                          {
                            v140 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                            v141 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTCellRange TSTTableRepDrawIndividualCellContent(TSTTableRep *, TSTLayoutSpace *, TSTGridRange, TSTCell *, TSTCellID, id, TSTCellIteratorData, TSTCellRange, BOOL, NSMutableArray *, CGContextRef)");
                            objc_msgSend(v140, "handleFailureInFunction:file:lineNumber:description:", v141, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRep.mm"), 5533, CFSTR("No TSWPColumn layout rock found."));
                            v137 = 0;
                          }
                        }
                        v308 = v137;
                        objc_msgSend(v137, "typographicBoundsForCell");
                        v145 = v144;
                        v147 = v146;
                        if (v360)
                        {
                          v321 = v144;
                          v323 = width;
                          v148 = v142;
                          v149 = v143;
                          objc_msgSend(v360, "topInset");
                          v325 = v147;
                          v151 = v150;
                          objc_msgSend(v360, "leftInset");
                          v153 = v152;
                          objc_msgSend(v360, "bottomInset");
                          v155 = v154;
                          objc_msgSend(v360, "rightInset");
                          v156 = AlignedContentFrameForGridRange;
                          v157 = v90;
                          v159 = v158;
                          v160 = v153;
                          v161 = v155;
                          v128 = TSTMasterLayoutApplyMinimumHorizontalInset(v160);
                          v162 = v159;
                          v90 = v157;
                          AlignedContentFrameForGridRange = v156;
                          v130 = TSTMasterLayoutApplyMinimumHorizontalInset(v162);
                          v313 = v161;
                          v163 = -v161;
                          v292 = v148 - v128;
                          v289 = v149 - v151;
                          width = v323;
                          v145 = v321 - (-v130 - v128);
                          v129 = v151;
                          v147 = v325 - (v163 - v151);
                        }
                        else
                        {
                          v289 = v143;
                          v292 = v142;
                        }
                        memset(&v356, 0, sizeof(v356));
                        CGAffineTransformMakeTranslation(&v356, AlignedContentFrameForGridRange, v90);
                        if (v328 && HIWORD(v75) && (v75 & 0xFFFF00000000) != 0)
                        {
                          v361 = v356;
                          CGAffineTransformInvert(&v362, &v361);
                          v364.origin.x = v319;
                          v364.origin.y = v295;
                          v364.size.width = width;
                          v364.size.height = rect;
                          v365 = CGRectApplyAffineTransform(v364, &v362);
                          x = v365.origin.x;
                          y = v365.origin.y;
                          width = v365.size.width;
                          rect = v365.size.height;
                          v9 = v316;
                          v166 = v344;
                          goto LABEL_427;
                        }
                        v166 = v344;
                        if (v344)
                          v167 = *(_DWORD *)&v344->mPrivate >> 8;
                        else
                          LOBYTE(v167) = 0;
                        x = *MEMORY[0x24BDBEFB0];
                        y = *(double *)(MEMORY[0x24BDBEFB0] + 8);
                        if (v328 && HIWORD(v75) && (v75 & 0xFFFF00000000) != 0
                          || v167 != 9 && v167 != 3)
                        {
                          v9 = v316;
                          goto LABEL_427;
                        }
                        v9 = v316;
                        if (!v359 && v145 > v310)
                        {
                          v168 = v358;
                          v169 = (void *)objc_msgSend(v54, "tableLayout");
                          v170 = v169;
                          *(_QWORD *)&v171 = 0xFFFFFFLL;
                          *((_QWORD *)&v171 + 1) = 0xFFFFFFLL;
                          *(_OWORD *)&v361.a = v171;
                          if (BYTE2(v337) == 255)
                            v172 = 0xFFFFFFFFLL;
                          else
                            v172 = BYTE2(v337);
                          v324 = (unsigned __int16)v337;
                          if ((unsigned __int16)v337 == 0xFFFF)
                            v173 = 0xFFFFFFFFLL;
                          else
                            v173 = (unsigned __int16)v337;
                          *(_QWORD *)&v174 = v172 | (v173 << 32);
                          v362.a = v174;
                          v362.b = v174;
                          v362.c = v174;
                          v362.d = v174;
                          TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns((unsigned __int16 *)objc_msgSend(v169, "masterLayout"));
                          v296 = v170;
                          v176 = objc_msgSend(v170, "editingSpillingTextRange");
                          v177 = 0;
                          v276 = v176;
                          if ((_WORD)v176 != 0xFFFF && (v176 & 0xFF0000) != 0xFF0000)
                          {
                            v177 = 0;
                            if (HIWORD(v176))
                            {
                              if ((v176 & 0xFFFF00000000) != 0)
                                v177 = (unsigned __int16)v337 >= (unsigned __int16)v176
                                    && (unsigned __int16)(v176 + HIWORD(v176) - 1) >= (unsigned __int16)v337;
                            }
                          }
                          v326 = v168;
                          if ((objc_msgSend(v296, "layoutDirectionIsLeftToRight") & 1) != 0)
                          {
                            if (v168 <= 4 && ((1 << v168) & 0x15) != 0)
                              goto LABEL_287;
LABEL_296:
                            v178 = v168;
                            goto LABEL_297;
                          }
                          if ((v168 & 0xFFFFFFFB) == 0)
                            goto LABEL_298;
                          if (v168 == 1)
                          {
                            v178 = 0;
                          }
                          else
                          {
                            if (v168 != 2 && v168 != 4)
                              goto LABEL_296;
LABEL_287:
                            v178 = v168;
                          }
                          if (v307 != BYTE2(v337))
                          {
                            LOWORD(v361.a) = v337;
                            BYTE2(v361.a) = BYTE2(v337) + 1;
                            HIWORD(v361.a) = 1;
                            v179 = v307 - BYTE2(v337);
                            if (v307 <= BYTE2(v337))
                              v179 = 0;
                            WORD2(v361.a) = v179;
                          }
LABEL_297:
                          if (v178 - 1 > 1)
                          {
                            v180 = v147;
                            v181 = ContentFrameForGridRange;
                            v267 = 0;
                            v186 = 0.0;
LABEL_312:
                            v268 = -1;
                          }
                          else
                          {
LABEL_298:
                            v180 = v147;
                            v181 = ContentFrameForGridRange;
                            LOWORD(v361.b) = v337;
                            HIWORD(v361.b) = 1;
                            if (TableNumberOfHeaderColumns <= BYTE2(v337))
                              v182 = v305 + TableNumberOfHeaderColumns;
                            else
                              v182 = v305;
                            if (TableNumberOfHeaderColumns <= BYTE2(v337))
                              v183 = v305 + TableNumberOfHeaderColumns;
                            else
                              v183 = v306;
                            v184 = BYTE2(v337) - v182;
                            if (BYTE2(v337) <= v182)
                              v184 = 0;
                            v267 = v184;
                            v268 = v183;
                            BYTE2(v361.b) = v183;
                            WORD2(v361.b) = v184;
                            TSTLayoutSpaceGetFrameForGridRange(a2, *(unint64_t *)&v174, *(uint64_t *)&v174);
                            if (v168 == 2)
                              v186 = v185 * 0.5;
                            else
                              v186 = 0.0;
                            if (BYTE2(v337) == v305)
                            {
                              LODWORD(v361.b) = 0xFFFFFF;
                              goto LABEL_312;
                            }
                          }
                          v187 = 0;
                          v188 = 0;
                          recta = 0;
                          v294 = v337 & 0xFF000000 | (BYTE2(v337) << 16) | (unsigned __int16)v337;
                          v270 = v337 & 0xFF000000 | (BYTE2(v337) << 16) | (unsigned __int16)v337;
                          v189 = BYTE2(v337) < BYTE2(v276) && v177;
                          v273 = v189;
                          v266 = ~BYTE2(v337) + BYTE2(v276);
                          v190 = BYTE2(v337) > (BYTE4(v276) + BYTE2(v276) - 1) && v177;
                          v272 = v190;
                          v322 = (unsigned __int16)v337 + 1;
                          v191 = 1;
                          while (2)
                          {
                            v192 = v191;
                            v193 = (char *)(&v361.a + v188);
                            v194 = *(_QWORD *)v193;
                            if (*(_WORD *)v193 != 0xFFFF)
                            {
                              v195 = (v194 & 0xFF0000) == 0xFF0000 || HIWORD(v194) == 0;
                              if (!v195 && (v194 & 0xFFFF00000000) != 0)
                              {
                                v338 = BYTE2(v194);
                                if ((v187 & 1) != 0)
                                {
                                  v274 = v274 & 0xFFFFFFFF00000000 | v294;
                                  v197 = TSTLayoutCellLeftOfCell(v296, v274, 1);
                                  v198 = v341;
                                  if (v272)
                                  {
                                    v198 = v341;
                                    if (BYTE2(v197) < (BYTE4(v276) + BYTE2(v276) - 1))
                                    {
                                      v198 = v276;
                                      v197 = v276;
                                    }
                                  }
                                  if ((_WORD)v197 != 0xFFFF
                                    && (*(_QWORD *)&v197 & 0xFF0000) != 0xFF0000
                                    && (_WORD)v198 != 0xFFFF
                                    && (v198 & 0xFF0000) != 0xFF0000
                                    && HIWORD(v198)
                                    && (v198 & 0xFFFF00000000) != 0)
                                  {
                                    v199 = HIDWORD(v198) + WORD1(v198);
                                    v200 = -v199 | 0xFFFFFF00;
                                    v201 = v267 + v268;
                                    BYTE2(v361.b) = v199;
                                    v267 = v201 + v200;
                                    v268 = v199;
                                    WORD2(v361.b) = v201 + v200;
                                    v338 = v193[2];
                                  }
                                }
                                else
                                {
                                  v197 = TSTLayoutCellRightOfCell(v296, v294, 1);
                                  v275 = v275 & 0xFFFFFFFF00000000 | v294;
                                  if (v273 && BYTE2(v276) < BYTE2(v197))
                                    WORD2(v361.a) = v266;
                                }
                                v202 = (~v197 & 0xFF0000) != 0 && (_WORD)v197 != 0xFFFF;
                                v203 = v338;
                                if ((v192 & 1) == 0)
                                  v203 = v338 + *((unsigned __int16 *)&v361.a + 4 * v188 + 2) - 1;
                                recta |= v202;
                                v329 = BYTE2(v197);
                                v320 = (unsigned __int16 *)(((unint64_t)&v361 + 8 * v188) | 4);
                                v204 = (unint64_t *)((char *)&v362 + 16 * v188);
                                if ((v192 & 1) == 0)
                                  goto LABEL_353;
LABEL_351:
                                if (v203 < *v320 + v338)
                                {
                                  while ((recta & (v329 == v203)) == 0)
                                  {
                                    v205 = (TSTMasterLayout *)objc_msgSend(v335, "masterLayout");
                                    v206 = +[TSDStroke emptyStroke](TSDStroke, "emptyStroke");
                                    if ((v192 & 1) != 0)
                                      v207 = v203;
                                    else
                                      v207 = v203 + 1;
                                    TSTMasterLayoutSetStrokeForGridColumn(v205, v206, v207, 0, v324, v322);
                                    TSTMasterLayoutSetStrokeForGridColumn((TSTMasterLayout *)objc_msgSend(v335, "masterLayout"), (TSDStroke *)+[TSDStroke emptyStroke](TSDStroke, "emptyStroke"), v207, 1, v324, v322);
                                    if (*((_DWORD *)v204 + 2) >= v203)
                                      v208 = v204;
                                    else
                                      v208 = v204 + 1;
                                    *v208 = v203;
                                    TSTLayoutSpaceGetContentFrameForGridRange(a2, *v204, v204[1]);
                                    if (v326 == 2)
                                      v210 = v145 * 0.5 > v209 - v186;
                                    else
                                      v210 = v145 > v209;
                                    v66 = v330;
                                    if (!v210)
                                      goto LABEL_329;
                                    if ((v192 & 1) != 0)
                                      ++v203;
                                    else
                                      --v203;
                                    if ((v192 & 1) != 0)
                                      goto LABEL_351;
LABEL_353:
                                    if (v203 < v338)
                                    {
LABEL_372:
                                      v212 = *(_QWORD *)&v362.a;
                                      v211 = *(_QWORD *)&v362.b;
                                      LODWORD(c_low) = LODWORD(v362.c);
                                      LODWORD(d_low) = LODWORD(v362.d);
                                      if (LODWORD(v362.a) == -1
                                        || LODWORD(v362.b) == -1
                                        || LODWORD(v362.a) > LODWORD(v362.b)
                                        || HIDWORD(v362.a) == -1
                                        || HIDWORD(v362.b) == -1
                                        || HIDWORD(v362.a) > HIDWORD(v362.b))
                                      {
                                        v211 = *(_QWORD *)&v362.d;
                                        v212 = *(_QWORD *)&v362.c;
                                        v9 = v316;
                                        v55 = v315;
                                        v147 = v180;
                                      }
                                      else
                                      {
                                        v9 = v316;
                                        v147 = v180;
                                        if (LODWORD(v362.c) == -1)
                                        {
                                          LODWORD(d_low) = LODWORD(v362.b);
                                          LODWORD(c_low) = LODWORD(v362.a);
                                          v55 = v315;
                                        }
                                        else
                                        {
                                          v55 = v315;
                                          if (LODWORD(v362.d) == -1
                                            || LODWORD(v362.c) > LODWORD(v362.d)
                                            || HIDWORD(v362.c) == -1
                                            || HIDWORD(v362.d) == -1
                                            || HIDWORD(v362.c) > HIDWORD(v362.d))
                                          {
                                            LODWORD(d_low) = LODWORD(v362.b);
                                            LODWORD(c_low) = LODWORD(v362.a);
                                          }
                                          else
                                          {
                                            if (LODWORD(v362.a) >= LODWORD(v362.c))
                                              c_low = LODWORD(v362.c);
                                            else
                                              c_low = LODWORD(v362.a);
                                            if (HIDWORD(v362.a) >= HIDWORD(v362.c))
                                              c_high = HIDWORD(v362.c);
                                            else
                                              c_high = HIDWORD(v362.a);
                                            if (LODWORD(v362.b) <= LODWORD(v362.d))
                                              d_low = LODWORD(v362.d);
                                            else
                                              d_low = LODWORD(v362.b);
                                            if (HIDWORD(v362.b) <= HIDWORD(v362.d))
                                              d_high = HIDWORD(v362.d);
                                            else
                                              d_high = HIDWORD(v362.b);
                                            v211 = d_low | (d_high << 32);
                                            v212 = c_low | (c_high << 32);
                                          }
                                        }
                                      }
                                      if ((_DWORD)c_low == -1
                                        || (_DWORD)d_low == -1
                                        || c_low > d_low
                                        || (HIDWORD(v212) <= HIDWORD(v211) ? (v220 = HIDWORD(v211) == -1) : (v220 = 1),
                                            !v220 ? (v221 = HIDWORD(v212) == -1) : (v221 = 1),
                                            v221))
                                      {
                                        v211 = -1;
                                        v212 = -1;
                                      }
                                      v222 = 0;
                                      if ((_DWORD)v212 != -1
                                        && (_DWORD)v211 != -1
                                        && v212 <= v211)
                                      {
                                        v222 = 0;
                                        if (HIDWORD(v212) != -1
                                          && HIDWORD(v211) != -1
                                          && HIDWORD(v212) <= HIDWORD(v211))
                                        {
                                          v222 = ((v211 - (v212 & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (v211 - v212 + 1))
                                               + 0x100000000;
                                        }
                                      }
                                      v223 = (unint64_t)v212 << 16;
                                      if ((_DWORD)v212 == -1)
                                        v223 = 16711680;
                                      v224 = 0x100000000;
                                      v225 = 0x1000000000000;
                                      if (WORD2(v212) != 0xFFFFLL && v223 != 16711680)
                                      {
                                        if ((_BYTE)v222)
                                        {
                                          v226 = (v222 >> 16) & 0xFFFF0000 | v222;
                                          v227 = v223 & 0xFFFFFFFFFFFF0000 | WORD2(v212) | (v226 << 32);
                                          if (HIWORD(v227))
                                          {
                                            v228 = v226 << 32;
                                            v225 = (v226 << 32) & 0xFFFF000000000000;
                                            TSTMasterLayoutSetStrokesValidForRange((TSTMasterLayout *)objc_msgSend(v335, "masterLayout"), v223 & 0xFFFF000000FF0000 | WORD2(v212) | (v226 << 32) & 0xFFFF000000FFFFFFLL | ((v226 << 32) + 0x100000000) & 0x1FF00000000);
                                            v224 = v228 & 0xFF00000000;
                                            v270 = v227;
                                          }
                                        }
                                      }
                                      v229 = TSTLayoutSpaceGetContentFrameForGridRange(a2, v212, v211);
                                      width = v230;
                                      rect = v231;
                                      if (v326 == 1)
                                        goto LABEL_422;
                                      if (v326 != 2)
                                      {
                                        v232 = objc_msgSend(v296, "layoutDirectionIsLeftToRight", v229);
                                        if (v326 != 4 || (v232 & 1) != 0)
                                          goto LABEL_425;
LABEL_422:
                                        if (width <= v310)
                                          goto LABEL_425;
                                        x = v310 - width;
LABEL_424:
                                        y = 0.0;
                                        goto LABEL_426;
                                      }
                                      if (v230 > v310)
                                      {
                                        x = v229 - v181;
                                        goto LABEL_424;
                                      }
LABEL_425:
                                      x = *MEMORY[0x24BDBEFB0];
                                      y = *(double *)(MEMORY[0x24BDBEFB0] + 8);
LABEL_426:
                                      v166 = v344;
                                      v73 = v224 | v225 | v270;
                                      v54 = v335;
                                      goto LABEL_427;
                                    }
                                  }
                                  recta = 1;
                                }
                              }
                            }
LABEL_329:
                            v191 = 0;
                            v187 = 1;
                            v188 = 1;
                            if ((v192 & 1) == 0)
                              goto LABEL_372;
                            continue;
                          }
                        }
LABEL_427:
                        v233 = 0;
                        if ((_WORD)v73 != 0xFFFF && (v73 & 0xFF0000) != 0xFF0000)
                        {
                          v233 = 0;
                          if (HIWORD(v73))
                          {
                            if ((v73 & 0xFFFF00000000) != 0)
                            {
                              v233 = 0;
                              if (v166)
                              {
                                if ((v73 & 0xFFFFFFFF00000000) == 0x1000100000000)
                                  v233 = *((unsigned __int8 *)&v166->mPrivate + 1) << 8 == 2304
                                      && -[TSWPStorage listStyleCount](-[TSTRichTextPayload storage](v166->mPrivate.mRichTextPayload, "storage"), "listStyleCount") != 0;
                              }
                            }
                          }
                        }
                        if (objc_msgSend((id)objc_msgSend(v54, "info"), "isInlineWithText"))
                        {
                          objc_msgSend(v340, "parent");
                          objc_opt_class();
                          if ((objc_opt_isKindOfClass() & 1) == 0)
                          {
                            v327 = v147;
                            v331 = v130;
                            v339 = v129;
                            memset(&transform, 0, sizeof(transform));
                            v271 = v128;
                            v234 = width;
                            if (v340)
                              objc_msgSend(v340, "transformInParent");
                            else
                              memset(&v354, 0, sizeof(v354));
                            CGAffineTransformInvert(&transform, &v354);
                            objc_msgSend((id)objc_msgSend(v340, "parent"), "frame");
                            v353 = transform;
                            v367 = CGRectApplyAffineTransform(v366, &v353);
                            v235 = v367.origin.x;
                            v236 = v367.origin.y;
                            v237 = v367.size.width;
                            height = v367.size.height;
                            v351 = v356;
                            CGAffineTransformInvert(&v352, &v351);
                            v368.origin.x = v235;
                            v368.origin.y = v236;
                            v368.size.width = v237;
                            v368.size.height = height;
                            v369 = CGRectApplyAffineTransform(v368, &v352);
                            v373.origin.y = v369.origin.y;
                            v373.size.height = v369.size.height;
                            v369.origin.x = x;
                            v369.origin.y = y;
                            v369.size.width = v234;
                            v369.size.height = rect;
                            v373.origin.x = x;
                            v373.size.width = v234;
                            v370 = CGRectIntersection(v369, v373);
                            x = v370.origin.x;
                            y = v370.origin.y;
                            width = v370.size.width;
                            rect = v370.size.height;
                            v129 = v339;
                            v128 = v271;
                            v130 = v331;
                            v147 = v327;
                          }
                        }
                        transform = v356;
                        CGContextConcatCTM(a5, &transform);
                        v371.origin.x = x;
                        v371.origin.y = y;
                        v371.size.width = width;
                        v371.size.height = rect;
                        CGContextClipToRect(a5, v371);
                        if (!v359 && ((TSTCellFormatUsesAccountingStyle(v344) | v233) & 1) == 0)
                        {
                          if (v358 == 2)
                          {
                            v239 = v310 * 0.5 - v145 * 0.5 - v292;
LABEL_448:
                            CGContextTranslateCTM(a5, v239, 0.0);
                          }
                          else if (v358 == 1)
                          {
                            v372.origin.x = v292;
                            v372.origin.y = v289;
                            v372.size.width = v145;
                            v372.size.height = v147;
                            v239 = v310 - CGRectGetMaxX(v372);
                            goto LABEL_448;
                          }
                        }
                        v240 = [TSTTextEngineDelegate alloc];
                        v241 = -[TSTTextEngineDelegate initWithPadding:verticalAlignment:](v240, "initWithPadding:verticalAlignment:", v357, v129, v128, v313, v130);
                        v242 = (void *)objc_msgSend((id)objc_msgSend(v54, "masterLayout"), "newTextEngineForCell:atCellID:", v344, v318);
                        objc_msgSend(v242, "setDelegate:", v241);
                        objc_msgSend(v309, "viewScale");
                        objc_msgSend(v242, "drawColumn:inContext:isFlipped:viewScale:", v308, a5, v291);
                        objc_msgSend(v242, "setDelegate:", 0);

                        CGContextRestoreGState(a5);
LABEL_450:
                        objc_autoreleasePoolPop(context);
                        if (!v343)
                          v73 = v341;
LABEL_168:

                        v341 = v73;
                        v5 = v346;
                        goto LABEL_169;
                      }
                      v54 = v335;
                      v55 = v315;
                    }
                    else
                    {
                      v112 = objc_msgSend(v54, "canvas");
                      if (!v343)
                      {
                        v9 = v316;
                        goto LABEL_450;
                      }
                      v309 = (void *)v112;
                    }
                    if (BYTE2(v62) == 255)
                      v115 = 0xFFFFFFFFLL;
                    else
                      v115 = BYTE2(v62);
                    if ((unsigned __int16)v62 == 0xFFFF)
                      v116 = 0xFFFFFFFFLL;
                    else
                      v116 = (unsigned __int16)v62;
                    v117 = v115 | (v116 << 32);
                    AlignedContentFrameForGridRange = TSTLayoutSpaceGetAlignedContentFrameForGridRange(a2, v117, v117);
                    v90 = v118;
                    width = v119;
                    rect = v121;
                    ContentFrameForGridRange = TSTLayoutSpaceGetContentFrameForGridRange(a2, v117, v117);
                    v295 = v90;
                    v310 = v122;
                    v319 = AlignedContentFrameForGridRange;
                    goto LABEL_232;
                  }
                }
                objc_autoreleasePoolPop(context);
                goto LABEL_168;
              }
            }
            v342 = v62 | v342 & 0xFFFFFFFF00000000;
            if ((objc_msgSend(v9, "isDynamicallyHidingRowsColsCellID:") & 1) == 0)
              goto LABEL_125;
LABEL_169:
            if (!TSTLayoutCellIteratorGetNextCell((uint64_t)v347, v349))
              goto LABEL_508;
          }
        }
        v5 = v30;
LABEL_508:

        result = TSTMasterLayoutNextVisibleRow(v9, (unsigned __int16)(v317 + 1));
      }
      while (result <= v303);
    }
  }
  return result;
}

unint64_t TSTCellRangeUnionCellID(unint64_t a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  __int16 v7;
  unsigned int v8;
  __int16 v9;
  unsigned __int8 v10;
  __int16 v11;
  __int16 v12;

  LOWORD(v2) = 1;
  v3 = a2 >> 16;
  v4 = a2 >> 24;
  LOWORD(v5) = 1;
  if ((_WORD)a1 == 0xFFFF || (a1 & 0xFF0000) == 0xFF0000 || !HIWORD(a1) || (a1 & 0xFFFF00000000) == 0)
  {
    LOWORD(a1) = a2;
  }
  else if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000)
  {
    v3 = a1 >> 16;
    v4 = a1 >> 24;
    v2 = HIDWORD(a1);
    v5 = HIWORD(a1);
  }
  else if ((unsigned __int16)a1 <= (unsigned __int16)a2
         && (unsigned __int16)(a1 + HIWORD(a1) - 1) >= (unsigned __int16)a2
         && BYTE2(a1) <= BYTE2(a2)
         && (v2 = HIDWORD(a1), (BYTE4(a1) + BYTE2(a1) - 1) >= BYTE2(a2)))
  {
    v3 = a1 >> 16;
    v4 = a1 >> 24;
    LODWORD(v5) = HIWORD(HIDWORD(a1));
  }
  else
  {
    LODWORD(v4) = 0;
    v6 = a1 >> 16;
    if (BYTE2(a2) <= BYTE2(a1))
      LOBYTE(v6) = BYTE2(a2);
    if ((unsigned __int16)a2 <= (unsigned __int16)a1)
      v7 = a2;
    else
      v7 = a1;
    v8 = HIDWORD(a1) + WORD1(a1);
    v9 = a1 + HIWORD(a1);
    LOWORD(a1) = v7;
    v10 = v8 - 1;
    if (BYTE2(a2) < v10)
      LOBYTE(v3) = v10;
    v11 = v9 - 1;
    if ((unsigned __int16)a2 >= (unsigned __int16)(v9 - 1))
      v11 = a2;
    v12 = v11 - v7 + 1;
    LOWORD(v2) = v3 - v6 + 1;
    LOWORD(v5) = v12;
    LOBYTE(v3) = v6;
  }
  return ((_DWORD)v4 << 24) | ((unint64_t)((unsigned __int16)v2 | ((unsigned __int16)v5 << 16)) << 32) | ((unint64_t)v3 << 16) | (unsigned __int16)a1;
}

{
  unint64_t v2;
  unint64_t v3;
  int v4;
  int v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned __int8 v10;
  int v11;

  v2 = a2 >> 16;
  v3 = a2 >> 24;
  v4 = 0x10000;
  v5 = 1;
  if ((_WORD)a1 == 0xFFFF || (a1 & 0xFF0000) == 0xFF0000 || !HIWORD(a1) || (a1 & 0xFFFF00000000) == 0)
  {
    LOWORD(a1) = a2;
  }
  else if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000)
  {
    v2 = a1 >> 16;
    v3 = a1 >> 24;
  }
  else if ((unsigned __int16)a1 <= (unsigned __int16)a2
         && (unsigned __int16)(a1 + HIWORD(a1) - 1) >= (unsigned __int16)a2
         && BYTE2(a1) <= BYTE2(a2)
         && (BYTE4(a1) + BYTE2(a1) - 1) >= BYTE2(a2))
  {
    v2 = a1 >> 16;
    v3 = a1 >> 24;
    v4 = 0x10000;
    v5 = 1;
  }
  else
  {
    LODWORD(v3) = 0;
    v6 = a1 >> 16;
    if (BYTE2(a2) <= BYTE2(a1))
      LOBYTE(v6) = BYTE2(a2);
    if ((unsigned __int16)a2 <= (unsigned __int16)a1)
      v7 = a2;
    else
      v7 = a1;
    v8 = HIDWORD(a1) + WORD1(a1);
    v9 = a1 + HIWORD(a1);
    LOWORD(a1) = v7;
    v10 = v8 - 1;
    if (BYTE2(a2) < v10)
      LOBYTE(v2) = v10;
    v11 = v9 - 1;
    if ((unsigned __int16)a2 >= (unsigned __int16)(v9 - 1))
      v11 = a2;
    v4 = ((v11 - v7) << 16) + 0x10000;
    v5 = (unsigned __int16)(v2 - v6 + 1);
    LOBYTE(v2) = v6;
  }
  return ((_DWORD)v3 << 24) | ((unint64_t)(v4 | v5) << 32) | ((unint64_t)v2 << 16) | (unsigned __int16)a1;
}

void sub_217B833CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__26(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__26(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t **std::__tree<TSTMergeRangeElem,TSTMergeRangeElemCompare,std::allocator<TSTMergeRangeElem>>::__emplace_unique_key_args<TSTMergeRangeElem,TSTMergeRangeElem const&>(uint64_t **a1, uint64_t a2, _OWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unsigned int v7;
  uint64_t **v8;
  unsigned int v9;
  uint64_t *v10;
  __int128 v11;
  __int128 v12;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *(_DWORD *)(a2 + 56);
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 22);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x60uLL);
    v11 = a3[1];
    *((_OWORD *)v10 + 2) = *a3;
    *((_OWORD *)v10 + 3) = v11;
    v12 = a3[3];
    *((_OWORD *)v10 + 4) = a3[2];
    *((_OWORD *)v10 + 5) = v12;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t TSTTableRBTreeLeftRotate(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD *)(a2 + 16);
  v3 = *(_QWORD *)(v2 + 8);
  *(_QWORD *)(a2 + 16) = v3;
  if ((_UNKNOWN *)v3 != &TSTTableRBTreeNil)
    *(_QWORD *)(v3 + 24) = a2;
  *(_QWORD *)(v2 + 24) = *(_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  v5 = v2;
  if ((_UNKNOWN *)v4 != &TSTTableRBTreeNil)
  {
    v6 = 16;
    if (*(_QWORD *)(v4 + 8) == a2)
      v6 = 8;
    *(_QWORD *)(v4 + v6) = v2;
    v5 = a1;
  }
  *(_QWORD *)(v2 + 8) = a2;
  *(_QWORD *)(a2 + 24) = v2;
  return v5;
}

uint64_t TSTTableRBTreeRightRotate(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(v2 + 16);
  *(_QWORD *)(a2 + 8) = v3;
  if ((_UNKNOWN *)v3 != &TSTTableRBTreeNil)
    *(_QWORD *)(v3 + 24) = a2;
  *(_QWORD *)(v2 + 24) = *(_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  v5 = v2;
  if ((_UNKNOWN *)v4 != &TSTTableRBTreeNil)
  {
    v6 = 16;
    if (*(_QWORD *)(v4 + 8) == a2)
      v6 = 8;
    *(_QWORD *)(v4 + v6) = v2;
    v5 = a1;
  }
  *(_QWORD *)(v2 + 16) = a2;
  *(_QWORD *)(a2 + 24) = v2;
  return v5;
}

TSTTableRBTreeNode_s *TSTTableRBTreeInsertFixup(TSTTableRBTreeNode_s *result, TSTTableRBTreeNode_s *a2)
{
  TSTTableRBTreeNode_s *var4;
  char var5;
  char *p_var5;
  TSTTableRBTreeNode_s *v5;
  TSTTableRBTreeNode_s *var2;
  TSTTableRBTreeNode_s *v7;
  TSTTableRBTreeNode_s *var3;
  TSTTableRBTreeNode_s *v9;
  TSTTableRBTreeNode_s *v10;
  TSTTableRBTreeNode_s *v11;
  TSTTableRBTreeNode_s *v12;
  TSTTableRBTreeNode_s *v13;
  uint64_t v14;
  TSTTableRBTreeNode_s *v15;
  TSTTableRBTreeNode_s *v16;
  uint64_t v17;
  uint64_t v18;
  TSTTableRBTreeNode_s *v19;
  TSTTableRBTreeNode_s *v20;
  TSTTableRBTreeNode_s *v21;
  uint64_t v22;
  TSTTableRBTreeNode_s *v23;
  uint64_t v24;

  var4 = a2->var4;
  p_var5 = &var4->var5;
  var5 = var4->var5;
  if (var5 == 1)
  {
    do
    {
      v5 = var4->var4;
      var2 = v5->var2;
      if (var4 == var2)
      {
        var2 = v5->var3;
        if (var2->var5 != 1)
        {
          var3 = var4->var3;
          if (a2 == var3)
          {
            v19 = a2->var2;
            var4->var3 = v19;
            if (v19 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
            {
              v19->var4 = var4;
              v5 = var4->var4;
            }
            a2->var4 = v5;
            v20 = var4->var4;
            v21 = a2;
            if (v20 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
            {
              if (v20->var2 == var4)
                v22 = 8;
              else
                v22 = 16;
              *(_QWORD *)((char *)&v20->var0 + v22) = a2;
              v21 = result;
            }
            a2->var2 = var4;
            var4->var4 = a2;
            v5 = a2->var4;
            v9 = v5->var2;
            var3 = v9->var3;
            v10 = a2;
            result = v21;
          }
          else
          {
            v9 = var4;
            v10 = var4;
            var4 = a2;
          }
          v10->var5 = 0;
          v5->var5 = var5;
          v5->var2 = var3;
          if (var3 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
            var3->var4 = v5;
          v9->var4 = v5->var4;
          v23 = v5->var4;
          v17 = (uint64_t)v9;
          if (v23 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
          {
            if (v23->var2 == v5)
              v24 = 8;
            else
              v24 = 16;
            *(_QWORD *)((char *)&v23->var0 + v24) = v9;
            v17 = (uint64_t)result;
          }
          v9->var3 = v5;
          goto LABEL_42;
        }
      }
      else if (var2->var5 != 1)
      {
        if (a2 == var4->var2)
        {
          v11 = a2->var3;
          var4->var2 = v11;
          if (v11 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
          {
            v11->var4 = var4;
            v5 = var4->var4;
          }
          a2->var4 = v5;
          v12 = var4->var4;
          v13 = a2;
          if (v12 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
          {
            if (v12->var2 == var4)
              v14 = 8;
            else
              v14 = 16;
            *(_QWORD *)((char *)&v12->var0 + v14) = a2;
            v13 = result;
          }
          a2->var3 = var4;
          var4->var4 = a2;
          v5 = a2->var4;
          v7 = a2;
          result = v13;
        }
        else
        {
          v7 = var4;
          var4 = a2;
        }
        v7->var5 = 0;
        v5->var5 = var5;
        v9 = v5->var3;
        v15 = v9->var2;
        v5->var3 = v15;
        if (v15 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
          v15->var4 = v5;
        v9->var4 = v5->var4;
        v16 = v5->var4;
        v17 = (uint64_t)v9;
        if (v16 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
        {
          if (v16->var2 == v5)
            v18 = 8;
          else
            v18 = 16;
          *(_QWORD *)((char *)&v16->var0 + v18) = v9;
          v17 = (uint64_t)result;
        }
        v9->var2 = v5;
LABEL_42:
        v5->var4 = v9;
        result = (TSTTableRBTreeNode_s *)v17;
        goto LABEL_43;
      }
      *p_var5 = 0;
      var2->var5 = 0;
      var4 = v5;
      v5->var5 = var5;
LABEL_43:
      a2 = var4;
      var4 = var4->var4;
      p_var5 = &var4->var5;
    }
    while (var4->var5 == 1);
  }
  result->var5 = 0;
  return result;
}

TSTTableRBTreeNode_s *TSTTableRBTreeInsert(TSTTableRBTreeNode_s *a1, TSTTableRBTreeNode_s *a2)
{
  TSTTableRBTreeNode_s *v2;
  TSTTableRBTreeNode_s *v3;
  uint64_t v4;

  if (a1)
  {
    if (a1 == (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
    {
      a2->var4 = (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil;
      a1 = a2;
    }
    else
    {
      v2 = a1;
      do
      {
        v3 = v2;
        if (a2->var0 >= v2->var0)
          v4 = 16;
        else
          v4 = 8;
        v2 = *(TSTTableRBTreeNode_s **)((char *)&v3->var0 + v4);
      }
      while (v2 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil);
      a2->var4 = v3;
      if (a2->var0 >= v3->var0)
        v3->var3 = a2;
      else
        v3->var2 = a2;
    }
    a2->var2 = (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil;
    a2->var3 = (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil;
    a2->var5 = 1;
    return TSTTableRBTreeInsertFixup(a1, a2);
  }
  else
  {
    a2->var5 = 0;
    return a2;
  }
}

_WORD *TSTTableRBTreeNewNode(__int16 a1, __int16 a2)
{
  _WORD *result;

  result = malloc_type_malloc(0x28uLL, 0x1020040D3174BDAuLL);
  *result = a1;
  result[1] = a2;
  *((_QWORD *)result + 1) = &TSTTableRBTreeNil;
  *((_QWORD *)result + 2) = &TSTTableRBTreeNil;
  *((_QWORD *)result + 3) = &TSTTableRBTreeNil;
  *((_BYTE *)result + 32) = 1;
  return result;
}

void TSTTableRBTreeFree(void **a1)
{
  if (a1)
  {
    if (a1[1] != &TSTTableRBTreeNil)
      TSTTableRBTreeFree();
    if (a1[2] != &TSTTableRBTreeNil)
      TSTTableRBTreeFree();
    free(a1);
  }
}

TSTTableRBTreeNode_s *TSTTableRBTreeMaximum(TSTTableRBTreeNode_s *a1)
{
  TSTTableRBTreeNode_s *v1;

  do
  {
    v1 = a1;
    a1 = a1->var3;
  }
  while (a1 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil);
  return v1;
}

TSTTableRBTreeNode_s *TSTTableRBTreeMinimum(TSTTableRBTreeNode_s *a1)
{
  TSTTableRBTreeNode_s *v1;

  do
  {
    v1 = a1;
    a1 = a1->var2;
  }
  while (a1 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil);
  return v1;
}

TSTTableRBTreeNode_s **TSTTableRBTreePredecessor(TSTTableRBTreeNode_s *a1)
{
  TSTTableRBTreeNode_s *var2;
  TSTTableRBTreeNode_s **result;
  TSTTableRBTreeNode_s *v3;
  BOOL v4;

  var2 = a1->var2;
  if (var2 == (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
  {
    v3 = a1;
    while (1)
    {
      result = (TSTTableRBTreeNode_s **)v3->var4;
      if (result == (TSTTableRBTreeNode_s **)&TSTTableRBTreeNil)
        break;
      v4 = v3 == result[1];
      v3 = v3->var4;
      if (!v4)
        return result;
    }
    return (TSTTableRBTreeNode_s **)&TSTTableRBTreeNil;
  }
  else
  {
    do
    {
      result = (TSTTableRBTreeNode_s **)var2;
      var2 = var2->var3;
    }
    while (var2 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil);
  }
  return result;
}

TSTTableRBTreeNode_s **TSTTableRBTreeSuccessor(TSTTableRBTreeNode_s *a1)
{
  TSTTableRBTreeNode_s *var3;
  TSTTableRBTreeNode_s **result;
  TSTTableRBTreeNode_s *v3;
  BOOL v4;

  var3 = a1->var3;
  if (var3 == (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
  {
    v3 = a1;
    while (1)
    {
      result = (TSTTableRBTreeNode_s **)v3->var4;
      if (result == (TSTTableRBTreeNode_s **)&TSTTableRBTreeNil)
        break;
      v4 = v3 == result[2];
      v3 = v3->var4;
      if (!v4)
        return result;
    }
    return (TSTTableRBTreeNode_s **)&TSTTableRBTreeNil;
  }
  else
  {
    do
    {
      result = (TSTTableRBTreeNode_s **)var3;
      var3 = var3->var2;
    }
    while (var3 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil);
  }
  return result;
}

unsigned __int16 *TSTTableRBFirstNodeGreaterThanOrEqualTo(unsigned __int16 *result, unsigned int a2)
{
  unsigned int v2;
  unsigned __int16 *v3;
  unsigned __int16 *v4;
  BOOL v5;

  if (!result)
    return (unsigned __int16 *)&TSTTableRBTreeNil;
  if (result == (unsigned __int16 *)&TSTTableRBTreeNil)
    return 0;
  do
  {
    v2 = *result;
    if (v2 == a2)
      break;
    if (v2 >= a2)
    {
      v3 = (unsigned __int16 *)*((_QWORD *)result + 1);
      if (v3 == (unsigned __int16 *)&TSTTableRBTreeNil)
        return result;
    }
    else
    {
      v3 = (unsigned __int16 *)*((_QWORD *)result + 2);
      if (v3 == (unsigned __int16 *)&TSTTableRBTreeNil)
      {
        v4 = result;
        while (1)
        {
          result = (unsigned __int16 *)*((_QWORD *)v4 + 3);
          if (result == (unsigned __int16 *)&TSTTableRBTreeNil)
            break;
          v5 = v4 == *((unsigned __int16 **)result + 2);
          v4 = (unsigned __int16 *)*((_QWORD *)v4 + 3);
          if (!v5)
            return result;
        }
        return (unsigned __int16 *)&TSTTableRBTreeNil;
      }
    }
    result = v3;
  }
  while (v3);
  return result;
}

unsigned __int16 *TSTTableRBFirstNodeLessThanOrEqualTo(unsigned __int16 *a1, unsigned int a2)
{
  unsigned __int16 *result;
  unsigned int v4;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  BOOL v7;

  result = (unsigned __int16 *)&TSTTableRBTreeNil;
  if (a1 && a1 != (unsigned __int16 *)&TSTTableRBTreeNil)
  {
    result = a1;
    while (1)
    {
      v4 = *result;
      if (v4 == a2)
        break;
      if (v4 >= a2)
      {
        v5 = (unsigned __int16 *)*((_QWORD *)result + 1);
        if (v5 == (unsigned __int16 *)&TSTTableRBTreeNil)
        {
          v6 = result;
          while (1)
          {
            result = (unsigned __int16 *)*((_QWORD *)v6 + 3);
            if (result == (unsigned __int16 *)&TSTTableRBTreeNil)
              break;
            v7 = v6 == *((unsigned __int16 **)result + 1);
            v6 = (unsigned __int16 *)*((_QWORD *)v6 + 3);
            if (!v7)
              return result;
          }
          return (unsigned __int16 *)&TSTTableRBTreeNil;
        }
      }
      else
      {
        v5 = (unsigned __int16 *)*((_QWORD *)result + 2);
        if (v5 == (unsigned __int16 *)&TSTTableRBTreeNil)
          return result;
      }
      result = v5;
      if (!v5)
        return (unsigned __int16 *)&TSTTableRBTreeNil;
    }
  }
  return result;
}

uint64_t TSTTableRBTreeStripIDForCellIndex(unsigned __int16 *a1, unsigned int a2, unsigned __int16 *a3)
{
  unsigned __int16 *v4;

  v4 = TSTTableRBFirstNodeLessThanOrEqualTo(a1, a2);
  if (v4 == (unsigned __int16 *)&TSTTableRBTreeNil)
    return 0;
  if (a3)
    *a3 = *v4;
  return v4[1];
}

TSTTableRBTreeNode_s *TSTTableRBTreeDeleteFixup(TSTTableRBTreeNode_s *a1, TSTTableRBTreeNode_s *a2)
{
  TSTTableRBTreeNode_s *var4;
  TSTTableRBTreeNode_s *var2;
  TSTTableRBTreeNode_s *var3;
  TSTTableRBTreeNode_s *v5;
  TSTTableRBTreeNode_s *v6;
  uint64_t v7;
  TSTTableRBTreeNode_s *v8;
  TSTTableRBTreeNode_s *v9;
  TSTTableRBTreeNode_s *v10;
  TSTTableRBTreeNode_s *v11;
  TSTTableRBTreeNode_s *v12;
  uint64_t v13;
  TSTTableRBTreeNode_s *v14;
  TSTTableRBTreeNode_s *v15;
  TSTTableRBTreeNode_s *v16;
  TSTTableRBTreeNode_s *v17;
  TSTTableRBTreeNode_s *v18;
  uint64_t v19;
  TSTTableRBTreeNode_s *v20;
  uint64_t v21;
  TSTTableRBTreeNode_s *v22;
  TSTTableRBTreeNode_s *v23;
  TSTTableRBTreeNode_s *v24;
  uint64_t v25;
  TSTTableRBTreeNode_s *v26;
  uint64_t v27;

  if (a2 == a1)
    goto LABEL_61;
  while (1)
  {
    if (a2->var5)
    {
      var4 = a2;
      a2 = a1;
      goto LABEL_62;
    }
    var4 = a2->var4;
    var2 = var4->var2;
    if (a2 != var2)
    {
      if (var2->var5 == 1)
      {
        var2->var5 = 0;
        var4->var5 = 1;
        var3 = var2->var3;
        var4->var2 = var3;
        if (var3 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
          var3->var4 = var4;
        var2->var4 = var4->var4;
        v5 = var4->var4;
        v6 = var2;
        if (v5 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
        {
          if (v5->var2 == var4)
            v7 = 8;
          else
            v7 = 16;
          *(_QWORD *)((char *)&v5->var0 + v7) = var2;
          v6 = a1;
        }
        var2->var3 = var4;
        var4->var4 = var2;
        var4 = a2->var4;
        var2 = var4->var2;
        a1 = v6;
      }
      v9 = var2->var2;
      v8 = var2->var3;
      if (v8->var5)
      {
        if (!v9->var5)
        {
          v8->var5 = 0;
          var2->var5 = 1;
          v16 = v8->var2;
          var2->var3 = v16;
          if (v16 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
            v16->var4 = var2;
          v8->var4 = var2->var4;
          v17 = var2->var4;
          v18 = v8;
          if (v17 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
          {
            v19 = 16;
            if (v17->var2 == var2)
              v19 = 8;
            *(_QWORD *)((char *)&v17->var0 + v19) = v8;
            v18 = a1;
          }
          v8->var2 = var2;
          var2->var4 = v8;
          var4 = a2->var4;
          var2 = var4->var2;
          v9 = var2->var2;
          v8 = var2->var3;
          a1 = v18;
        }
LABEL_38:
        var2->var5 = var4->var5;
        var4->var5 = 0;
        v9->var5 = 0;
        var4->var2 = v8;
        if (v8 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
          v8->var4 = var4;
        var2->var4 = var4->var4;
        v20 = var4->var4;
        a2 = var2;
        if (v20 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
        {
          v21 = 16;
          if (v20->var2 == var4)
            v21 = 8;
          *(_QWORD *)((char *)&v20->var0 + v21) = var2;
          a2 = a1;
        }
        var2->var3 = var4;
        goto LABEL_60;
      }
      if (v9->var5)
        goto LABEL_38;
      goto LABEL_27;
    }
    var2 = var4->var3;
    if (var2->var5 == 1)
    {
      var2->var5 = 0;
      var4->var5 = 1;
      v10 = var2->var2;
      var4->var3 = v10;
      if (v10 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
        v10->var4 = var4;
      var2->var4 = var4->var4;
      v11 = var4->var4;
      v12 = var2;
      if (v11 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
      {
        if (v11->var2 == var4)
          v13 = 8;
        else
          v13 = 16;
        *(_QWORD *)((char *)&v11->var0 + v13) = var2;
        v12 = a1;
      }
      var2->var2 = var4;
      var4->var4 = var2;
      var4 = a2->var4;
      var2 = var4->var3;
      a1 = v12;
    }
    v14 = var2->var2;
    v15 = var2->var3;
    if (v14->var5)
      break;
    if (v15->var5)
      goto LABEL_53;
LABEL_27:
    var2->var5 = 1;
    a2 = var4;
    if (var4 == a1)
      goto LABEL_62;
  }
  if (!v15->var5)
  {
    v14->var5 = 0;
    var2->var5 = 1;
    v22 = v14->var3;
    var2->var2 = v22;
    if (v22 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
      v22->var4 = var2;
    v14->var4 = var2->var4;
    v23 = var2->var4;
    v24 = v14;
    if (v23 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
    {
      v25 = 16;
      if (v23->var2 == var2)
        v25 = 8;
      *(_QWORD *)((char *)&v23->var0 + v25) = v14;
      v24 = a1;
    }
    v14->var3 = var2;
    var2->var4 = v14;
    var4 = a2->var4;
    var2 = var4->var3;
    v14 = var2->var2;
    v15 = var2->var3;
    a1 = v24;
  }
LABEL_53:
  var2->var5 = var4->var5;
  var4->var5 = 0;
  v15->var5 = 0;
  var4->var3 = v14;
  if (v14 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
    v14->var4 = var4;
  var2->var4 = var4->var4;
  v26 = var4->var4;
  a2 = var2;
  if (v26 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
  {
    v27 = 16;
    if (v26->var2 == var4)
      v27 = 8;
    *(_QWORD *)((char *)&v26->var0 + v27) = var2;
    a2 = a1;
  }
  var2->var2 = var4;
LABEL_60:
  var4->var4 = var2;
LABEL_61:
  var4 = a2;
LABEL_62:
  var4->var5 = 0;
  return a2;
}

TSTTableRBTreeNode_s *TSTTableRBTreeDelete(TSTTableRBTreeNode_s *a1, _QWORD *a2)
{
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  TSTTableRBTreeNode_s *v6;
  uint64_t v7;

  v2 = a2[1];
  v3 = a2;
  if ((_UNKNOWN *)v2 == &TSTTableRBTreeNil)
    goto LABEL_4;
  v4 = a2[2];
  if ((_UNKNOWN *)v4 != &TSTTableRBTreeNil)
  {
    do
    {
      v3 = (_BYTE *)v4;
      v4 = *(_QWORD *)(v4 + 8);
    }
    while ((_UNKNOWN *)v4 != &TSTTableRBTreeNil);
LABEL_4:
    v2 = *((_QWORD *)v3 + 2);
    goto LABEL_6;
  }
  v3 = a2;
LABEL_6:
  *(_QWORD *)(v2 + 24) = *((_QWORD *)v3 + 3);
  v5 = *((_QWORD *)v3 + 3);
  v6 = (TSTTableRBTreeNode_s *)v2;
  if ((_UNKNOWN *)v5 != &TSTTableRBTreeNil)
  {
    v7 = 16;
    if (v3 == *(_BYTE **)(v5 + 8))
      v7 = 8;
    *(_QWORD *)(v5 + v7) = v2;
    v6 = a1;
  }
  if (v3 != (_BYTE *)a2)
    *(_DWORD *)a2 = *(_DWORD *)v3;
  if (!v3[32])
    v6 = TSTTableRBTreeDeleteFixup(v6, (TSTTableRBTreeNode_s *)v2);
  free(v3);
  return v6;
}

uint64_t TSTTableRBTreeShiftCellIndices(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int16 *v7;
  unsigned int v8;
  void *v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  unsigned __int16 **v14;

  v7 = (unsigned __int16 *)result;
  if ((int)a3 >= 0)
    v8 = a3;
  else
    v8 = -(int)a3;
  while (1)
  {
    if (v8 >= 0xFFFF)
    {
      v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableRBTreeShiftCellIndices(TSTTableRBTreeNode *, UInt16, int, BOOL)");
      result = objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRBTree.mm"), 443, CFSTR("shiftAmount out of range"));
    }
    if (v7 == (unsigned __int16 *)&TSTTableRBTreeNil)
      break;
    v11 = *v7;
    if (v11 == (_DWORD)a2)
      v12 = a4;
    else
      v12 = 0;
    if (v11 <= a2 && v12 == 0)
    {
      v14 = (unsigned __int16 **)(v7 + 8);
    }
    else
    {
      *v7 = v11 + a3;
      result = TSTTableRBTreeShiftCellIndices(*((_QWORD *)v7 + 2), a2, a3, a4);
      v14 = (unsigned __int16 **)(v7 + 4);
    }
    v7 = *v14;
  }
  return result;
}

unsigned __int16 *TSTTableRBTreeFind(unsigned __int16 *a1, unsigned int a2)
{
  unsigned __int16 *result;
  unsigned int v4;
  uint64_t v5;

  result = (unsigned __int16 *)&TSTTableRBTreeNil;
  if (a1 && a1 != (unsigned __int16 *)&TSTTableRBTreeNil)
  {
    while (1)
    {
      v4 = *a1;
      if (v4 == a2)
        break;
      if (v4 <= a2)
        v5 = 8;
      else
        v5 = 4;
      a1 = *(unsigned __int16 **)&a1[v5];
      if (a1 == (unsigned __int16 *)&TSTTableRBTreeNil)
        return result;
    }
    return a1;
  }
  return result;
}

uint64_t TSTTableRBTreeShiftNodesAfter(uint64_t result, uint64_t a2, uint64_t a3)
{
  unsigned __int16 *v5;
  unsigned int v6;
  void *v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t *v10;

  v5 = (unsigned __int16 *)result;
  if ((int)a3 >= 0)
    v6 = a3;
  else
    v6 = -(int)a3;
  if (v6 >= 0xFFFF)
  {
    v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableRBTreeShiftNodesAfter(TSTTableRBTreeNode *, UInt16, int)");
    result = objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRBTree.mm"), 486, CFSTR("shiftAmount out of range"));
  }
  if (v5 != (unsigned __int16 *)&TSTTableRBTreeNil)
  {
    v9 = *v5;
    if (v9 <= a2)
    {
      v10 = (uint64_t *)(v5 + 8);
    }
    else
    {
      *v5 = v9 + a3;
      TSTTableRBTreeShiftCellIndices(*((_QWORD *)v5 + 2), a2, a3, 0);
      v10 = (uint64_t *)(v5 + 4);
    }
    return TSTTableRBTreeShiftCellIndices(*v10, a2, a3, 0);
  }
  return result;
}

uint64_t TSTTableRBTreeShiftNodesAtOrAfter(uint64_t result, uint64_t a2, uint64_t a3)
{
  unsigned __int16 *v5;
  unsigned int v6;
  void *v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t *v10;

  v5 = (unsigned __int16 *)result;
  if ((int)a3 >= 0)
    v6 = a3;
  else
    v6 = -(int)a3;
  if (v6 >= 0xFFFF)
  {
    v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableRBTreeShiftNodesAtOrAfter(TSTTableRBTreeNode *, UInt16, int)");
    result = objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRBTree.mm"), 509, CFSTR("shiftAmount out of range"));
  }
  if (v5 != (unsigned __int16 *)&TSTTableRBTreeNil)
  {
    v9 = *v5;
    if (v9 >= a2)
    {
      *v5 = v9 + a3;
      TSTTableRBTreeShiftCellIndices(*((_QWORD *)v5 + 2), a2, a3, 1);
      v10 = (uint64_t *)(v5 + 4);
    }
    else
    {
      v10 = (uint64_t *)(v5 + 8);
    }
    return TSTTableRBTreeShiftCellIndices(*v10, a2, a3, 1);
  }
  return result;
}

TSTTableRBTreeNode_s *TSTTableRBTreeDeleteKey(TSTTableRBTreeNode_s *result, unsigned int a2)
{
  TSTTableRBTreeNode_s *v2;
  unsigned int var0;
  uint64_t v4;

  if (result && result != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
  {
    v2 = result;
    while (1)
    {
      var0 = v2->var0;
      if (var0 == a2)
        break;
      if (var0 <= a2)
        v4 = 16;
      else
        v4 = 8;
      v2 = *(TSTTableRBTreeNode_s **)((char *)&v2->var0 + v4);
      if (v2 == (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
        return result;
    }
    if (v2 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
      return TSTTableRBTreeDelete(result, v2);
  }
  return result;
}

uint64_t p_validateNode(unsigned int a1, unsigned __int16 a2, void *a3)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;

  v4 = a1;
  if (objc_msgSend(a3, "containsIndex:", a1))
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_validateNode(UInt16, UInt16, void *)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableRBTree.mm"), 540, CFSTR("Duplicate keys in rbtree!"));
  }
  return objc_msgSend(a3, "addIndex:", v4);
}

void TSTTableRBTreeValidate(uint64_t a1)
{
  id v2;

  v2 = objc_alloc_init(MEMORY[0x24BDD1698]);
  TSTTableRBTreeApply(a1, (uint64_t (*)(_QWORD, _QWORD, uint64_t))p_validateNode, (uint64_t)v2);

}

uint64_t TSTTableRBTreeApply(uint64_t result, uint64_t (*a2)(_QWORD, _QWORD, uint64_t), uint64_t a3)
{
  uint64_t (*v4)(_QWORD, _QWORD, uint64_t);
  unsigned __int16 *v5;
  void *v6;
  void *v7;

  if (result)
  {
    v4 = a2;
    v5 = (unsigned __int16 *)result;
    v6 = *(void **)(result + 8);
    if (v6 != &TSTTableRBTreeNil)
    {
      TSTTableRBTreeApply(v6, a2, a3);
      v4 = a2;
    }
    v7 = (void *)*((_QWORD *)v5 + 2);
    if (v7 != &TSTTableRBTreeNil)
    {
      TSTTableRBTreeApply(v7, v4, a3);
      v4 = a2;
    }
    return v4(*v5, v5[1], a3);
  }
  return result;
}

void TSTTableRBTreeDump(unsigned __int16 *a1)
{
  if (a1)
  {
    if (*((_UNKNOWN **)a1 + 1) != &TSTTableRBTreeNil)
      TSTTableRBTreeDump();
    if (*((_UNKNOWN **)a1 + 2) != &TSTTableRBTreeNil)
      TSTTableRBTreeDump();
    NSLog((NSString *)CFSTR("node %p: key:%d, value: %d"), a1, *a1, a1[1]);
  }
}

uint64_t TSTTableSelectionCellCount(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 16), "cellCount");
}

uint64_t TSTTableSelectionSetCellRegion(uint64_t a1, void *a2)
{
  uint64_t result;

  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 12) = objc_msgSend(a2, "upperLeftCellID");
  result = objc_msgSend(a2, "upperLeftCellID");
  *(_DWORD *)(a1 + 32) = result;
  return result;
}

uint64_t TSTTableSelectionSetCellRange(uint64_t a1, unint64_t a2)
{
  uint64_t result;

  result = objc_msgSend(*(id *)(a1 + 16), "equalsCellRange:", a2);
  if ((result & 1) == 0)
  {

    *(_QWORD *)(a1 + 16) = 0;
    result = (uint64_t)+[TSTCellRegion regionFromRange:](TSTCellRegion, "regionFromRange:", a2);
    *(_QWORD *)(a1 + 16) = result;
    *(_DWORD *)(a1 + 12) = a2;
    *(_DWORD *)(a1 + 32) = (a2 + ((a2 >> 16) & 0xFF0000) + 16711680) & 0xFF0000 | (unsigned __int16)(a2 + HIWORD(a2) - 1);
  }
  return result;
}

void TSTTableSelectionAddCellRange(uint64_t a1)
{
  id v1;

  v1 = *(id *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 16) = +[TSTCellRegion region:addingRange:](TSTCellRegion, "region:addingRange:");

}

void TSTTableSelectionSubtractCellRange(uint64_t a1)
{
  id v1;

  v1 = *(id *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 16) = +[TSTCellRegion region:subtractingRange:](TSTCellRegion, "region:subtractingRange:");

}

uint64_t TSTTableSelectionContainsCell(uint64_t a1, unsigned int a2)
{
  return objc_msgSend(*(id *)(a1 + 16), "containsCellID:", a2);
}

void sub_217B87B1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__27(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__27(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_217B87F70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t p_TSTCellRangeSplitForAdding(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned __int16 v19;
  uint64_t v20;
  unsigned __int16 v21;
  unint64_t v22;
  int v23;
  unint64_t v24;
  unsigned int v25;
  unint64_t v26;
  unsigned __int16 v27;
  unint64_t v28;
  unsigned int v29;
  unint64_t v30;
  unsigned __int16 v31;
  unsigned __int16 v32;
  int v33;
  BOOL v34;
  BOOL v35;
  int v36;
  unint64_t v37;
  _BOOL4 v38;
  _BOOL4 v39;
  unint64_t v40;
  unint64_t v41;
  unsigned int v42;
  _BOOL4 v43;
  _BOOL4 v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  __int16 v49;
  unint64_t v50;
  __int16 v51;
  __int16 v52;
  unint64_t v53;
  unsigned __int16 v54;
  unint64_t v55;
  __int16 v56;
  unint64_t v57;
  unint64_t v58;
  unsigned __int16 v59;
  unsigned int v60;
  unsigned __int16 v61;
  unint64_t v62;
  unsigned __int16 v63;

  v5 = 0;
  *a3 = 0xFFFFFFLL;
  v6 = *(_QWORD *)a1;
  v7 = *(_QWORD *)a2;
  v8 = 16711680;
  v9 = 0xFFFFLL;
  if ((unsigned __int16)v6 == 0xFFFFLL)
    goto LABEL_27;
  v10 = 0;
  if ((v6 & 0xFF0000) == 0xFF0000)
    goto LABEL_28;
  v5 = 0;
  if (HIWORD(v6))
    v11 = (v6 & 0xFFFF00000000) == 0;
  else
    v11 = 1;
  if (v11)
  {
    v10 = 0;
    v8 = 16711680;
    v9 = 0xFFFFLL;
    goto LABEL_28;
  }
  v8 = 16711680;
  v9 = 0xFFFFLL;
  if ((_WORD)v7 == 0xFFFF)
    goto LABEL_27;
  v10 = 0;
  if ((v7 & 0xFF0000) == 0xFF0000)
    goto LABEL_28;
  v5 = 0;
  v8 = 16711680;
  v9 = 0xFFFFLL;
  if (!HIWORD(v7))
  {
LABEL_27:
    v10 = 0;
    goto LABEL_28;
  }
  v10 = 0;
  if ((v7 & 0xFFFF00000000) != 0)
  {
    v9 = 0;
    if (BYTE2(v6) <= BYTE2(v7))
      v12 = BYTE2(v7);
    else
      v12 = BYTE2(v6);
    if ((unsigned __int16)v6 <= (unsigned __int16)v7)
      v13 = (unsigned __int16)v7;
    else
      v13 = (unsigned __int16)v6;
    if ((BYTE4(v6) + BYTE2(v6) - 1) >= (BYTE4(v7) + BYTE2(v7) - 1))
      v14 = (BYTE4(v7) + BYTE2(v7) - 1);
    else
      v14 = (BYTE4(v6) + BYTE2(v6) - 1);
    v15 = (unsigned __int16)(v6 + HIWORD(v6) - 1);
    if (v15 >= (unsigned __int16)(v7 + HIWORD(v7) - 1))
      v15 = (unsigned __int16)(v7 + HIWORD(v7) - 1);
    v8 = 0;
    v5 = 0;
    v10 = 0;
    if (v13 <= v15 && v12 <= v14)
    {
      v10 = ((unint64_t)(v15 - v13) << 48) + 0x1000000000000;
      v5 = (unint64_t)(unsigned __int16)(v14 - v12 + 1) << 32;
      v8 = v12 << 16;
      v9 = v13;
    }
  }
LABEL_28:
  v16 = 0;
  v17 = v8 | v10 | v9 | v5;
  if ((_WORD)v17 != 0xFFFF && (v17 & 0xFF0000) != 0xFF0000)
  {
    v16 = 0;
    if (HIWORD(v17))
    {
      if ((v17 & 0xFFFF00000000) != 0)
      {
        v18 = HIWORD(v7);
        v19 = v17 - v7;
        v20 = 0xFFFFFFLL;
        if ((unsigned __int16)v17 > (unsigned __int16)v7)
          v20 = v7;
        if ((unsigned __int16)v17 < (unsigned __int16)v7)
          v19 = 0;
        v63 = v19;
        v21 = v17 + HIWORD(v10) - 1;
        if ((unsigned __int16)(v7 + HIWORD(v7) - 1) <= v21)
        {
          v23 = (unsigned __int16)v17 > (unsigned __int16)v7;
          v24 = v7 >> 16;
          v61 = -1;
          v62 = 0;
          LODWORD(v22) = 255;
        }
        else
        {
          v22 = v7 >> 16;
          v61 = v17 + HIWORD(v10);
          v62 = (_DWORD)v7 + HIWORD(v7) - (v17 + HIWORD(v10));
          if ((unsigned __int16)v17 <= (unsigned __int16)v7)
            v23 = 1;
          else
            v23 = 2;
          v24 = v7 >> 16;
        }
        v25 = (BYTE4(v7) + BYTE2(v7) - 1);
        if (BYTE2(v17) <= BYTE2(v7))
        {
          v28 = 0;
          v27 = 0;
          v59 = -1;
          LOWORD(v26) = 255;
        }
        else
        {
          v26 = v7 >> 16;
          v27 = BYTE2(v17) - v24;
          ++v23;
          v28 = HIWORD(v7);
          v59 = v7;
        }
        v29 = (BYTE4(v17) + BYTE2(v17) - 1);
        if (v29 >= v25)
        {
          v18 = 0;
          v31 = 0;
          LOBYTE(v30) = 0;
          v32 = -1;
          v60 = 255;
        }
        else
        {
          v30 = v7 >> 24;
          v60 = v29 + 1;
          v31 = (BYTE4(v7) + BYTE2(v7) - 1) - (BYTE4(v17) + BYTE2(v17) - 1);
          ++v23;
          v32 = v7;
        }
        if (v23 == 3)
        {
          if ((unsigned __int16)v17 > (unsigned __int16)v7)
          {
            if ((unsigned __int16)(v7 + HIWORD(v7) - 1) > v21)
            {
              if (BYTE2(v17) > BYTE2(v7))
                *(_BYTE *)(a1 + 2) = BYTE4(v17) + BYTE2(v6);
              *(_WORD *)(a1 + 4) = WORD2(v6) - WORD2(v17);
              return 1;
            }
            *(_WORD *)a1 = v6 + HIWORD(v10);
          }
          *(_WORD *)(a1 + 6) = HIWORD(v6) - HIWORD(v10);
          return 1;
        }
        v33 = (BYTE4(v6) + BYTE2(v6) - 1);
        if (v23 != 2)
        {
          if (v23 == 1)
          {
            v34 = (unsigned __int16)(v7 + HIWORD(v7) - 1) > v21
               || (unsigned __int16)v17 > (unsigned __int16)v7;
            if (v34 && BYTE2(v6) == BYTE2(v7) && v33 == v25
              || (BYTE2(v17) <= BYTE2(v7) ? (v35 = v29 >= v25) : (v35 = 0),
                  v35 ? (v36 = 0) : (v36 = 1),
                  (unsigned __int16)(v6 + HIWORD(v6) - 1) == (unsigned __int16)(v7 + HIWORD(v7) - 1)
               && v36
               && (unsigned __int16)v6 == (unsigned __int16)v7))
            {
              v37 = TSTCellRangeUnionCellRange(v6, v7);
              *(_QWORD *)a1 = 0xFFFFFFLL;
              *(_QWORD *)a2 = v37;
            }
            else
            {
              v45 = (v18 << 48) | ((unint64_t)v31 << 32) | ((unint64_t)v30 << 24) | ((unint64_t)v60 << 16) | v32;
              if (BYTE2(v17) <= BYTE2(v7))
                v46 = v45;
              else
                v46 = (v28 << 48) | ((unint64_t)v27 << 32) | ((unint64_t)(unsigned __int16)v26 << 16) | v59;
              if ((unsigned __int16)(v7 + HIWORD(v7) - 1) > v21)
                v46 = (v62 << 48) | ((unint64_t)v22 << 16) | v61;
              v47 = v20 & 0xFFFFFFFFFFFFLL | ((unint64_t)v63 << 48);
              if ((unsigned __int16)v17 <= (unsigned __int16)v7)
                v47 = v46;
              *(_QWORD *)a2 = v47;
            }
          }
          return 1;
        }
        v38 = (unsigned __int16)(v7 + HIWORD(v7) - 1) <= v21;
        v39 = (unsigned __int16)v17 <= (unsigned __int16)v7;
        if ((unsigned __int16)v17 > (unsigned __int16)v7 && !v38)
        {
          *(_QWORD *)a2 = v20 & 0xFFFFFFFFFFFFLL | ((unint64_t)v63 << 48);
          v40 = v62;
LABEL_76:
          v41 = (v40 << 48) | ((unint64_t)v22 << 16) | v61;
LABEL_81:
          *a3 = v41;
          return 1;
        }
        v42 = BYTE2(v17);
        v43 = v29 >= v25;
        v34 = v42 > BYTE2(v7);
        v44 = v42 <= BYTE2(v7);
        if (v34 && !v43)
        {
          *(_QWORD *)a2 = (v28 << 48) | ((unint64_t)v27 << 32) | ((unint64_t)(unsigned __int16)v26 << 16) | v59;
          v41 = (v18 << 48) | ((unint64_t)v31 << 32) | ((unint64_t)v30 << 24) | ((unint64_t)v60 << 16) | v32;
          goto LABEL_81;
        }
        if (v39 || v43)
        {
          if (v38 || v43)
          {
            if (v44 || v38)
            {
              if (v39 || v44)
                return 1;
              if ((unsigned __int16)(v6 + HIWORD(v6) - 1) == (unsigned __int16)(v7 + HIWORD(v7) - 1))
              {
                *(_QWORD *)a2 = v6;
                *(_BYTE *)(a2 + 2) = v24;
                v49 = WORD2(v6) + BYTE2(v6) - v24;
LABEL_102:
                *(_WORD *)(a2 + 4) = v49;
                v50 = v20 & 0xFFFFFFFFFFFFLL | ((unint64_t)v63 << 48);
LABEL_114:
                *a3 = v50;
                *(_QWORD *)a1 = 0xFFFFFFLL;
                return 1;
              }
              if (v33 == v25)
              {
                *(_QWORD *)a2 = v6;
                *(_WORD *)a2 = v7;
                v56 = v6 - v7 + HIWORD(v6);
                goto LABEL_122;
              }
              *(_QWORD *)a2 = v20 & 0xFFFFFFFFFFFFLL | ((unint64_t)v63 << 48);
              v55 = v10 & 0xFFFF000000000000 | ((unint64_t)v27 << 32) | ((unint64_t)(unsigned __int16)v26 << 16);
LABEL_116:
              v41 = v55 | (unsigned __int16)v6;
              goto LABEL_81;
            }
            if ((unsigned __int16)v6 == (unsigned __int16)v7)
            {
              *(_QWORD *)a2 = v6;
              *(_BYTE *)(a2 + 2) = v24;
              v51 = WORD2(v6) + BYTE2(v6) - v24;
              goto LABEL_109;
            }
            if (v33 == v25)
            {
              *(_QWORD *)a2 = v6;
              v56 = v62 + HIWORD(v6);
LABEL_122:
              *(_WORD *)(a2 + 6) = v56;
              v53 = (v28 << 48) | ((unint64_t)v27 << 32) | ((unint64_t)(unsigned __int16)v26 << 16);
              v54 = v59;
              goto LABEL_110;
            }
            v57 = v62;
            v58 = ((unint64_t)v27 << 32) | ((unint64_t)(v28 - v62) << 48) | ((unint64_t)(unsigned __int16)v26 << 16) | v59;
LABEL_124:
            *(_QWORD *)a2 = v58;
            v40 = v57;
            goto LABEL_76;
          }
          if ((unsigned __int16)v6 == (unsigned __int16)v7)
          {
            *(_QWORD *)a2 = v6;
            v51 = v31 + WORD2(v6);
LABEL_109:
            *(_WORD *)(a2 + 4) = v51;
            v53 = (v62 << 48) | ((unint64_t)v22 << 16);
            v54 = v61;
LABEL_110:
            v50 = v53 & 0xFFFFFFFFFFFF0000 | v54;
            goto LABEL_114;
          }
          if (BYTE2(v6) != BYTE2(v7))
          {
            v57 = v62;
            v58 = ((unint64_t)v31 << 32) | ((unint64_t)(v18 - v62) << 48) | ((unint64_t)v30 << 24) | ((unint64_t)v60 << 16) | v32;
            goto LABEL_124;
          }
          *(_QWORD *)a2 = v6;
          v52 = v62 + HIWORD(v6);
        }
        else
        {
          if ((unsigned __int16)(v6 + HIWORD(v6) - 1) == (unsigned __int16)(v7 + HIWORD(v7) - 1))
          {
            *(_QWORD *)a2 = v6;
            v49 = v31 + WORD2(v6);
            goto LABEL_102;
          }
          if (BYTE2(v6) != BYTE2(v7))
          {
            *(_QWORD *)a2 = v20 & 0xFFFFFFFFFFFFLL | ((unint64_t)v63 << 48);
            v55 = v10 & 0xFFFF000000000000 | ((unint64_t)v31 << 32) | ((unint64_t)v30 << 24) | ((unint64_t)v60 << 16);
            goto LABEL_116;
          }
          *(_QWORD *)a2 = v6;
          *(_WORD *)a2 = v7;
          v52 = v6 - v7 + HIWORD(v6);
        }
        *(_WORD *)(a2 + 6) = v52;
        v50 = (v18 << 48) | ((unint64_t)v31 << 32) | ((unint64_t)v30 << 24) | ((unint64_t)v60 << 16) | v32;
        goto LABEL_114;
      }
    }
  }
  return v16;
}

void sub_217B88B3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_217B8939C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_217B894BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_217B89650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_217B897A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_217B89D04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_217B89F04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_217B8A5F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_217B8A910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_217B8C03C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 72), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__17(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void sub_217B8D050(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x219A153B8](v1, 0x10A0C40ADE6F494);
  _Unwind_Resume(a1);
}

uint64_t TSTTableDataListAddObject(TSTTableDataList *a1, TSTTableDataObject *a2)
{
  TSTTableDataObjectKeyDict *mIDs;
  uint64_t v5;
  uint64_t mNextID;
  TSTTableDataObjectKeyDict *v7;

  mIDs = a1->mIDs;
  if (mIDs && (v5 = -[TSTTableDataObjectKeyDict keyForObject:](mIDs, "keyForObject:", a2), (_DWORD)v5))
  {
    mNextID = v5;
    TSTTableDataListAddReferenceForKey((id *)&a1->super.super.isa, v5);
  }
  else
  {
    -[TSPObject willModify](a1, "willModify");
    mNextID = a1->mNextID;
    a1->mNextID = mNextID + 1;
    -[TSTIntegerKeyDict setObject:forKey:](a1->mData, "setObject:forKey:", a2, mNextID);
    v7 = a1->mIDs;
    if (v7)
      -[TSTTableDataObjectKeyDict setKey:forObject:](v7, "setKey:forObject:", mNextID, a2);
  }
  return mNextID;
}

uint64_t TSTTableDataListAddReferenceForKey(id *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  void *v6;
  uint64_t v7;

  objc_msgSend(a1, "willModify");
  result = objc_msgSend(a1[7], "objectForKey:", a2);
  v5 = result;
  if (!result)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataListAddReferenceForKey(TSTTableDataList *, TSTTableDataListKey)");
    result = objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1089, CFSTR("No object with key %u!"), a2);
  }
  ++*(_DWORD *)(v5 + 8);
  return result;
}

void *TSTTableDataListPrintCFDictionary(const __CFDictionary *a1)
{
  CFIndex Count;
  const void **v3;
  void *v4;
  void **v5;
  void *v6;

  Count = CFDictionaryGetCount(a1);
  v3 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
  CFDictionaryGetKeysAndValues(a1, v3, 0);
  v4 = (void *)objc_msgSend(MEMORY[0x24BDD17C8], "string");
  if (Count >= 1)
  {
    v5 = (void **)v3;
    do
    {
      v6 = *v5++;
      objc_msgSend(v4, "stringByAppendingString:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@ : %ld\n"), objc_msgSend(v6, "description"), CFDictionaryGetValue(a1, v6)));
      --Count;
    }
    while (Count);
  }
  free(v3);
  return v4;
}

uint64_t TSTTableDataListAddString(TSTTableDataList *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  TSTTableDataObject *v6;
  uint64_t v7;

  if (a1->mListType != 1)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddString(TSTTableDataList *, NSString *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 810, CFSTR("Can only store strings in this list!"));
  }
  v6 = -[TSTTableDataString initObjectWithString:]([TSTTableDataString alloc], "initObjectWithString:", a2);
  v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddConditionalStyleSet(TSTTableDataList *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  TSTTableDataObject *v6;
  uint64_t v7;

  if (a1->mListType != 9)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddConditionalStyleSet(TSTTableDataList *, TSTConditionalStyleSet *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 818, CFSTR("Can only store conditional styles in this list!"));
  }
  v6 = -[TSTTableDataConditionalStyleSet initObjectWithConditionalStyleSet:]([TSTTableDataConditionalStyleSet alloc], "initObjectWithConditionalStyleSet:", a2);
  v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddCellFormat(TSTTableDataList *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  TSTTableDataFormat *v6;
  __int128 v7;
  TSTTableDataObject *v8;
  uint64_t v9;
  _OWORD v11[2];
  uint64_t v12;

  if (*(_DWORD *)a2 == 266)
    *(_QWORD *)(a2 + 16) = 0;
  if (a1->mListType != 2)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddCellFormat(TSTTableDataList *, TSUFormatStruct, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 830, CFSTR("Can only store formats in this list!"));
  }
  v6 = [TSTTableDataFormat alloc];
  v7 = *(_OWORD *)(a2 + 16);
  v11[0] = *(_OWORD *)a2;
  v11[1] = v7;
  v12 = *(_QWORD *)(a2 + 32);
  v8 = -[TSTTableDataFormat initObjectWithFormat:](v6, "initObjectWithFormat:", v11);
  v9 = TSTTableDataListAddObject(a1, v8);

  return v9;
}

uint64_t TSTTableDataListAddStyle(TSTTableDataList *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  TSTTableDataObject *v6;
  uint64_t v7;

  if (a1->mListType != 4)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddStyle(TSTTableDataList *, TSSStyle *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 850, CFSTR("Can only store styles in this list!"));
  }
  v6 = -[TSTTableDataStyle initObjectWithStyle:]([TSTTableDataStyle alloc], "initObjectWithStyle:", a2);
  v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddFormulaError(TSTTableDataList *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  TSTTableDataObject *v6;
  uint64_t v7;

  if (a1->mListType != 5)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddFormulaError(TSTTableDataList *, TSWPStorage *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 859, CFSTR("Can only store formula errors in this list!"));
  }
  v6 = -[TSTTableDataFormulaError initObjectWithFormulaError:]([TSTTableDataFormulaError alloc], "initObjectWithFormulaError:", a2);
  v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddRichTextPayload(TSTTableDataList *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  TSTTableDataObject *v6;
  uint64_t v7;

  if (a1->mListType != 8)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddRichTextPayload(TSTTableDataList *, TSTRichTextPayload *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 868, CFSTR("Can only store text objects in this list!"));
  }
  v6 = -[TSTTableDataRichTextPayload initObjectWithRichTextPayload:]([TSTTableDataRichTextPayload alloc], "initObjectWithRichTextPayload:", a2);
  v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddCommentStorage(TSTTableDataList *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  TSTTableDataObject *v6;
  uint64_t v7;

  if (a1->mListType != 10)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddCommentStorage(TSTTableDataList *, TSDCommentStorage *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 877, CFSTR("Can only store cell comment objects in this list!"));
  }
  v6 = -[TSTTableDataCommentStorage initObjectWithCommentStorage:]([TSTTableDataCommentStorage alloc], "initObjectWithCommentStorage:", a2);
  v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddCustomFormat(TSTTableDataList *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  TSTTableDataObject *v6;
  uint64_t v7;

  if (a1->mListType != 6)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddCustomFormat(TSTTableDataList *, TSUCustomFormat *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 886, CFSTR("Can only store custom formats in this list!"));
  }
  v6 = -[TSTTableDataCustomFormat initObjectWithCustomFormat:]([TSTTableDataCustomFormat alloc], "initObjectWithCustomFormat:", a2);
  v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListAddMultipleChoiceListFormat(TSTTableDataList *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  TSTTableDataObject *v6;
  uint64_t v7;

  if (a1->mListType != 7)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListAddMultipleChoiceListFormat(TSTTableDataList *, TSTPopUpMenuModel *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 895, CFSTR("Can only store pop up menu model in this list!"));
  }
  v6 = -[TSTTableDataMultipleChoiceList initObjectWithPopUpMenuModel:]([TSTTableDataMultipleChoiceList alloc], "initObjectWithPopUpMenuModel:", a2);
  v7 = TSTTableDataListAddObject(a1, v6);

  return v7;
}

uint64_t TSTTableDataListGetStringForKey(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t result;

  if (*(_DWORD *)(a1 + 48) != 1)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTTableDataListGetStringForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 904, CFSTR("Can only store strings in this list!"));
  }
  result = objc_msgSend(*(id *)(a1 + 56), "objectForKey:", a2);
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

__n128 TSTTableDataListGetCellFormatForKey@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  __n128 result;
  __int128 v10;

  if (*(_DWORD *)(a1 + 48) != 2)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSUFormatStruct TSTTableDataListGetCellFormatForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 919, CFSTR("Can only store formats in this list!"));
  }
  *(_QWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)a3 = -1;
  v8 = objc_msgSend(*(id *)(a1 + 56), "objectForKey:", a2);
  if (v8)
  {
    result = *(__n128 *)(v8 + 16);
    v10 = *(_OWORD *)(v8 + 32);
    *(__n128 *)a3 = result;
    *(_OWORD *)(a3 + 16) = v10;
    *(_QWORD *)(a3 + 32) = *(_QWORD *)(v8 + 48);
  }
  return result;
}

uint64_t TSTTableDataListGetStyleForKey(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t result;

  if (*(_DWORD *)(a1 + 48) != 4)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSSStyle *TSTTableDataListGetStyleForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 951, CFSTR("Can only store styles in this list!"));
  }
  result = objc_msgSend(*(id *)(a1 + 56), "objectForKey:", a2);
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t TSTTableDataListGetConditionalStyleSetForKey(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t result;

  if (*(_DWORD *)(a1 + 48) != 9)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTConditionalStyleSet *TSTTableDataListGetConditionalStyleSetForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 966, CFSTR("Can only store conditional styles in this list!"));
  }
  result = objc_msgSend(*(id *)(a1 + 56), "objectForKey:", a2);
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t TSTTableDataListGetFormulaErrorForKey(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t result;

  if (*(_DWORD *)(a1 + 48) != 5)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPStorage *TSTTableDataListGetFormulaErrorForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 983, CFSTR("Can only store formulaErrors in this list!"));
  }
  result = objc_msgSend(*(id *)(a1 + 56), "objectForKey:", a2);
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t TSTTableDataListGetRichTextPayloadForKey(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t result;

  if (*(_DWORD *)(a1 + 48) != 8)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTRichTextPayload *TSTTableDataListGetRichTextPayloadForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 998, CFSTR("Can only store text storages in this list!"));
  }
  result = objc_msgSend(*(id *)(a1 + 56), "objectForKey:", a2);
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t TSTTableDataListGetCommentStorageForKey(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t result;

  if (*(_DWORD *)(a1 + 48) != 10)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSDCommentStorage *TSTTableDataListGetCommentStorageForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1013, CFSTR("Can only store cell comment storage objects in this list!"));
  }
  result = objc_msgSend(*(id *)(a1 + 56), "objectForKey:", a2);
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t TSTTableDataListGetCustomFormatForKey(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t result;

  if (*(_DWORD *)(a1 + 48) != 6)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSUCustomFormat *TSTTableDataListGetCustomFormatForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1028, CFSTR("Can only store custom formats in this list!"));
  }
  result = objc_msgSend(*(id *)(a1 + 56), "objectForKey:", a2);
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t TSTTableDataListGetMultipleChoiceListFormatForKey(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t result;

  if (*(_DWORD *)(a1 + 48) != 7)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTPopUpMenuModel *TSTTableDataListGetMultipleChoiceListFormatForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1044, CFSTR("Can only store pop up menu model in this list!"));
  }
  result = objc_msgSend(*(id *)(a1 + 56), "objectForKey:", a2);
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t TSTTableDataListGetCount(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 56), "count");
}

uint64_t TSTTableDataListRefCountForKey(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = objc_msgSend(*(id *)(a1 + 56), "objectForKey:", a2);
  if (result)
    return *(unsigned int *)(result + 8);
  return result;
}

void TSTTableDataListRemoveReferenceForKey(uint64_t a1, uint64_t a2)
{
  id v4;
  void *v5;
  int v6;
  void *v7;
  void *v8;
  uint64_t v9;
  id v10;

  objc_msgSend((id)a1, "willModify");
  v4 = (id)objc_msgSend(*(id *)(a1 + 56), "objectForKey:", a2);
  if (v4)
  {
    v5 = v4;
    v6 = *((_DWORD *)v4 + 2) - 1;
    *((_DWORD *)v4 + 2) = v6;
    if (!v6)
    {
      v10 = v4;
      objc_msgSend(*(id *)(a1 + 56), "removeObjectForKey:", a2);
      v5 = v10;
      v7 = *(void **)(a1 + 64);
      if (v7)
      {
        objc_msgSend(v7, "removeKeyForObject:", v10);
        v5 = v10;
      }
    }

  }
  else
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataListRemoveReferenceForKey(TSTTableDataList *, TSTTableDataListKey)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1099, CFSTR("No object with key %u!"), a2);
  }
}

uint64_t TSTTableDataListTransform(id *a1, uint64_t a2, uint64_t a3)
{
  objc_msgSend(a1, "willModify");
  return objc_msgSend(a1[7], "transformWithFunction:withState:", a2, a3);
}

uint64_t TSTTableDataListHasher()
{
  return 1;
}

uint64_t TSTTableDataListGetKeyForCustomFormat(TSTTableDataList *a1, TSUCustomFormat *a2)
{
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  id v8;
  TSTTableDataObjectKeyDict *mIDs;
  uint64_t v10;

  if (!a1->mIDs)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListGetKeyForCustomFormat(TSTTableDataList *, TSUCustomFormat *)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1136, CFSTR("Can't do a reverse lookup on a list that doesn't support it!"));
  }
  if (a1->mListType != 6)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataListGetKeyForCustomFormat(TSTTableDataList *, TSUCustomFormat *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataList.mm"), 1137, CFSTR("Can only have custom formats in this list!"));
  }
  v8 = -[TSTTableDataCustomFormat initObjectWithCustomFormat:]([TSTTableDataCustomFormat alloc], "initObjectWithCustomFormat:", a2);
  mIDs = a1->mIDs;
  if (mIDs)
    v10 = -[TSTTableDataObjectKeyDict keyForObject:](mIDs, "keyForObject:", v8);
  else
    v10 = 0;

  return v10;
}

uint64_t TSTTableDumpTile(_QWORD *a1)
{
  void *v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  _BYTE v11[128];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  NSLog((NSString *)CFSTR("%@"), objc_msgSend(a1, "description"));
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  v2 = (void *)a1[7];
  result = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v7, v11, 16);
  if (result)
  {
    v4 = result;
    v5 = *(_QWORD *)v8;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v8 != v5)
          objc_enumerationMutation(v2);
        TSTTableDumpTileRowInfo(*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8 * v6++));
      }
      while (v4 != v6);
      result = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v7, v11, 16);
      v4 = result;
    }
    while (result);
  }
  return result;
}

uint64_t TSTTableTileListRows(uint64_t a1)
{
  void *v1;
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  _BYTE v10[128];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v6 = 0u;
  v7 = 0u;
  v8 = 0u;
  v9 = 0u;
  v1 = *(void **)(a1 + 56);
  result = objc_msgSend(v1, "countByEnumeratingWithState:objects:count:", &v6, v10, 16);
  if (result)
  {
    v3 = result;
    v4 = *(_QWORD *)v7;
    do
    {
      v5 = 0;
      do
      {
        if (*(_QWORD *)v7 != v4)
          objc_enumerationMutation(v1);
        NSLog((NSString *)CFSTR("%@"), *(_QWORD *)(*((_QWORD *)&v6 + 1) + 8 * v5++));
      }
      while (v3 != v5);
      result = objc_msgSend(v1, "countByEnumeratingWithState:objects:count:", &v6, v10, 16);
      v3 = result;
    }
    while (result);
  }
  return result;
}

uint64_t TSTTableTileValidate(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  unsigned __int16 v3;
  int v4;
  unsigned int v5;
  unsigned __int8 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  int v21;
  id obj;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  obj = *(id *)(a1 + 56);
  result = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
  if (result)
  {
    v2 = result;
    v3 = 0;
    v4 = 0;
    LOWORD(v5) = 0;
    v6 = 0;
    v7 = *(_QWORD *)v24;
    do
    {
      v21 = v4;
      v8 = 0;
      do
      {
        if (*(_QWORD *)v24 != v7)
          objc_enumerationMutation(obj);
        v9 = *(_QWORD *)(*((_QWORD *)&v23 + 1) + 8 * v8);
        if (*(unsigned __int16 *)(v9 + 536) <= (unsigned __int16)v5)
          v5 = (unsigned __int16)v5;
        else
          v5 = *(unsigned __int16 *)(v9 + 536);
        if (!*(_BYTE *)(v9 + 541))
          TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(_QWORD *)(*((_QWORD *)&v23 + 1) + 8 * v8));
        v10 = *(unsigned __int8 *)(v9 + 540);
        if (v10 > v6 && v10 != 255)
          v6 = *(_BYTE *)(v9 + 540);
        TSTTableTileRowInfoValidate(v9);
        v3 += *(_WORD *)(v9 + 538);
        ++v8;
      }
      while (v2 != v8);
      v4 = v21 + v2;
      result = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
      v2 = result;
    }
    while (result);
  }
  else
  {
    v3 = 0;
    LOWORD(v4) = 0;
    v5 = 0;
    v6 = 0;
  }
  if (v5 != *(unsigned __int16 *)(a1 + 50))
  {
    v12 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v13 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableTileValidate(TSTTableTile *)");
    result = objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 903, CFSTR("max row in tile %@ does not match maximum row index in row infos stored in tile: %hu != %hu"), a1, *(unsigned __int16 *)(a1 + 50), v5);
  }
  if (*(unsigned __int8 *)(a1 + 48) != v6)
  {
    v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableTileValidate(TSTTableTile *)");
    result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 907, CFSTR("max row in tile %@ does not match maximum row index in row infos stored in tile: %hu != %hu"), a1, *(unsigned __int8 *)(a1 + 48), v6);
  }
  if (*(unsigned __int16 *)(a1 + 64) != (unsigned __int16)v4)
  {
    v16 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v17 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableTileValidate(TSTTableTile *)");
    result = objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 911, CFSTR("number of rows in tile %@ does not match number of row infos stored in tile: %hu != %hu"), a1, *(unsigned __int16 *)(a1 + 64), (unsigned __int16)v4);
  }
  if (*(unsigned __int16 *)(a1 + 52) != v3)
  {
    v18 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v19 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableTileValidate(TSTTableTile *)");
    return objc_msgSend(v18, "handleFailureInFunction:file:lineNumber:description:", v19, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 915, CFSTR("number of cells in tile %@ not consistent with row cell count: %hu != %hu"), a1, *(unsigned __int16 *)(a1 + 52), v3);
  }
  return result;
}

TSTTableTileRowInfo *TSTTableTileRowInfoForTileRowIndex(TSTTableTile *a1, uint64_t a2, int a3)
{
  NSMutableArray *mRowInfos;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  TSTTableTileRowInfo *result;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  mRowInfos = a1->mRowInfos;
  v7 = -[NSMutableArray countByEnumeratingWithState:objects:count:](mRowInfos, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v7)
  {
    v8 = v7;
    v9 = *(_QWORD *)v13;
LABEL_3:
    v10 = 0;
    while (1)
    {
      if (*(_QWORD *)v13 != v9)
        objc_enumerationMutation(mRowInfos);
      result = *(TSTTableTileRowInfo **)(*((_QWORD *)&v12 + 1) + 8 * v10);
      if (result->mTileRowIndex == (_DWORD)a2)
        break;
      if (v8 == ++v10)
      {
        v8 = -[NSMutableArray countByEnumeratingWithState:objects:count:](mRowInfos, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
        if (v8)
          goto LABEL_3;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    if (a3)
    {
      -[TSPObject willModify](a1, "willModify");
      return p_AddRowInfoWithRowIndex(a1, a2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

TSTTableTileRowInfo *p_AddRowInfoWithRowIndex(TSTTableTile *a1, uint64_t a2)
{
  unsigned int v2;
  TSTTableTileRowInfo *v4;

  v2 = a2;
  v4 = -[TSTTableTileRowInfo initWithOwner:tileRowIndex:]([TSTTableTileRowInfo alloc], "initWithOwner:tileRowIndex:", a1, a2);
  p_InsertRowInfoWithRowIndex(a1, v4, v2);

  return v4;
}

const void *TSTTableTileRowInfoForRowArrayIndex(uint64_t a1, CFIndex idx)
{
  return CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), idx);
}

UInt8 *TSTTableTileGetCellStorageRef(TSTTableTile *a1, unsigned int a2, uint64_t a3)
{
  TSTTableTileRowInfo *v4;

  if (a1->mNumCells && (v4 = TSTTableTileRowInfoForTileRowIndex(a1, a3, 0)) != 0)
    return TSTTableTileRowInfoCellStorageRefAtTileColumnIndex((uint64_t)v4, a2);
  else
    return 0;
}

void TSTTableTileSetCell(TSTTableTile *a1, unsigned int a2, uint64_t a3, _QWORD *a4)
{
  TSTTableTileRowInfo *v8;
  void *v9;
  uint64_t v10;
  unsigned int mCellCount;
  unsigned int v12;
  __int16 v13;
  NSMutableArray *mRowInfos;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  uint64_t v19;
  unsigned int v20;
  TSTTableTileRowInfo *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _BYTE v26[128];
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  -[TSPObject willModify](a1, "willModify");
  v8 = TSTTableTileRowInfoForTileRowIndex(a1, a3, 0);
  if (!v8)
  {
    v8 = p_AddRowInfoWithRowIndex(a1, a3);
    if (!v8)
    {
      v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableTileSetCell(TSTTableTile *, TSUColumnIndex, TSURowIndex, TSTCell *)");
      objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 374, CFSTR("Couldn't find row info for row index %hu"), a3);
    }
  }
  mCellCount = v8->mCellCount;
  TSTTableTileRowInfoSetCell(v8, a2, a4);
  v12 = v8->mCellCount;
  if (v12 <= mCellCount)
  {
    if (v12 >= mCellCount)
      goto LABEL_9;
    v13 = -1;
  }
  else
  {
    v13 = 1;
  }
  a1->mNumCells += v13;
LABEL_9:
  if (a1->mMaxColumn <= a2)
  {
    if (a4)
    {
      a1->mMaxColumn = a2;
    }
    else
    {
      v21 = v8;
      a1->mMaxColumn = 0;
      v22 = 0u;
      v23 = 0u;
      v24 = 0u;
      v25 = 0u;
      mRowInfos = a1->mRowInfos;
      v15 = -[NSMutableArray countByEnumeratingWithState:objects:count:](mRowInfos, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
      if (v15)
      {
        v16 = v15;
        v17 = *(_QWORD *)v23;
        do
        {
          for (i = 0; i != v16; ++i)
          {
            if (*(_QWORD *)v23 != v17)
              objc_enumerationMutation(mRowInfos);
            v19 = *(_QWORD *)(*((_QWORD *)&v22 + 1) + 8 * i);
            if (*(_WORD *)(v19 + 538))
            {
              if (!*(_BYTE *)(v19 + 541))
                TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(_QWORD *)(*((_QWORD *)&v22 + 1) + 8 * i));
              v20 = *(unsigned __int8 *)(v19 + 540);
              if (v20 != 255 && v20 > a1->mMaxColumn)
                a1->mMaxColumn = v20;
            }
          }
          v16 = -[NSMutableArray countByEnumeratingWithState:objects:count:](mRowInfos, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
        }
        while (v16);
      }
      v8 = v21;
    }
  }
  if (!v8->mCellCount)
    p_RemoveRowInfo(a1, v8);
}

void p_RemoveRowInfo(TSTTableTile *a1, TSTTableTileRowInfo *a2)
{
  unsigned int mTileRowIndex;
  unsigned int mMaxTileColumnIndex;
  TSTTableTileRowInfo *v6;
  NSMutableArray *mRowInfos;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  unsigned int v12;
  NSMutableArray *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t j;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[128];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  mTileRowIndex = a2->mTileRowIndex;
  if (!a2->mMaxTileColumnIndexValid)
    TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)a2);
  mMaxTileColumnIndex = a2->mMaxTileColumnIndex;
  v6 = a2;
  -[NSMutableArray removeObject:](a1->mRowInfos, "removeObject:", a2);
  --a1->mNumRows;
  a1->mNumCells -= a2->mCellCount;

  if (mTileRowIndex >= a1->mMaxRow)
  {
    v20 = mMaxTileColumnIndex;
    a1->mMaxRow = 0;
    v21 = 0u;
    v22 = 0u;
    v23 = 0u;
    v24 = 0u;
    mRowInfos = a1->mRowInfos;
    v8 = -[NSMutableArray countByEnumeratingWithState:objects:count:](mRowInfos, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
    if (v8)
    {
      v9 = v8;
      v10 = *(_QWORD *)v22;
      do
      {
        for (i = 0; i != v9; ++i)
        {
          if (*(_QWORD *)v22 != v10)
            objc_enumerationMutation(mRowInfos);
          v12 = *(unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)&v21 + 1) + 8 * i) + 536);
          if (v12 > a1->mMaxRow)
            a1->mMaxRow = v12;
        }
        v9 = -[NSMutableArray countByEnumeratingWithState:objects:count:](mRowInfos, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
      }
      while (v9);
    }
    mMaxTileColumnIndex = v20;
  }
  if (mMaxTileColumnIndex != 255 && mMaxTileColumnIndex >= a1->mMaxColumn)
  {
    a1->mMaxColumn = 0;
    v21 = 0u;
    v22 = 0u;
    v23 = 0u;
    v24 = 0u;
    v13 = a1->mRowInfos;
    v14 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v13, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
    if (v14)
    {
      v15 = v14;
      v16 = *(_QWORD *)v22;
      do
      {
        for (j = 0; j != v15; ++j)
        {
          if (*(_QWORD *)v22 != v16)
            objc_enumerationMutation(v13);
          v18 = *(_QWORD *)(*((_QWORD *)&v21 + 1) + 8 * j);
          if (*(_WORD *)(v18 + 538))
          {
            if (!*(_BYTE *)(v18 + 541))
              TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(_QWORD *)(*((_QWORD *)&v21 + 1) + 8 * j));
            v19 = *(unsigned __int8 *)(v18 + 540);
            if (v19 != 255 && v19 > a1->mMaxColumn)
              a1->mMaxColumn = v19;
          }
        }
        v15 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v13, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
      }
      while (v15);
    }
  }
}

void TSTTableTileRemoveCell(TSTTableTile *a1, unsigned int a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  TSTTableTileRowInfo *v10;
  TSTTableTileRowInfo *v11;
  unsigned int mCellCount;
  unsigned int v13;
  __int16 v14;
  NSMutableArray *mRowInfos;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t i;
  uint64_t v20;
  unsigned int v21;
  TSTTableTileRowInfo *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if (a1->mMaxColumn < a2)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableTileRemoveCell(TSTTableTile *, TSUColumnIndex, TSURowIndex)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 408, CFSTR("column index too large"));
  }
  if (a1->mMaxRow < a3)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableTileRemoveCell(TSTTableTile *, TSUColumnIndex, TSURowIndex)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 412, CFSTR("row index too large"));
  }
  v10 = TSTTableTileRowInfoForTileRowIndex(a1, a3, 0);
  if (v10)
  {
    v11 = v10;
    -[TSPObject willModify](a1, "willModify");
    mCellCount = v11->mCellCount;
    TSTTableTileRowInfoSetCell(v11, a2, 0);
    v13 = v11->mCellCount;
    if (v13 <= mCellCount)
    {
      if (v13 >= mCellCount)
      {
LABEL_11:
        if (a1->mMaxColumn <= a2)
        {
          v22 = v11;
          a1->mMaxColumn = 0;
          v23 = 0u;
          v24 = 0u;
          v25 = 0u;
          v26 = 0u;
          mRowInfos = a1->mRowInfos;
          v16 = -[NSMutableArray countByEnumeratingWithState:objects:count:](mRowInfos, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
          if (v16)
          {
            v17 = v16;
            v18 = *(_QWORD *)v24;
            do
            {
              for (i = 0; i != v17; ++i)
              {
                if (*(_QWORD *)v24 != v18)
                  objc_enumerationMutation(mRowInfos);
                v20 = *(_QWORD *)(*((_QWORD *)&v23 + 1) + 8 * i);
                if (*(_WORD *)(v20 + 538))
                {
                  if (!*(_BYTE *)(v20 + 541))
                    TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(_QWORD *)(*((_QWORD *)&v23 + 1) + 8 * i));
                  v21 = *(unsigned __int8 *)(v20 + 540);
                  if (v21 != 255 && v21 > a1->mMaxColumn)
                    a1->mMaxColumn = v21;
                }
              }
              v17 = -[NSMutableArray countByEnumeratingWithState:objects:count:](mRowInfos, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
            }
            while (v17);
          }
          v11 = v22;
        }
        if (!v11->mCellCount)
          p_RemoveRowInfo(a1, v11);
        return;
      }
      v14 = -1;
    }
    else
    {
      v14 = 1;
    }
    a1->mNumCells += v14;
    goto LABEL_11;
  }
}

uint64_t TSTTableTileInsertColumns(uint64_t a1, char a2, unsigned int a3, char a4)
{
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t i;
  _BYTE *v13;
  unsigned int v14;
  id obj;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  _BYTE v22[128];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  objc_msgSend((id)a1, "willModify");
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  obj = *(id *)(a1 + 56);
  v8 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
  if (v8)
  {
    v9 = v8;
    v10 = 0;
    v11 = *(_QWORD *)v19;
    do
    {
      for (i = 0; i != v9; ++i)
      {
        if (*(_QWORD *)v19 != v11)
          objc_enumerationMutation(obj);
        v13 = *(_BYTE **)(*((_QWORD *)&v18 + 1) + 8 * i);
        TSTTableTileRowInfoInsertColumns(v13, a2, a3, a4);
        if (!v13[541])
          TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)v13);
        v14 = v13[540];
        if (v14 > v10 && v14 != 255)
          v10 = v13[540];
      }
      v9 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
    }
    while (v9);
  }
  else
  {
    v10 = 0;
  }
  *(_BYTE *)(a1 + 48) = v10;
  return 0;
}

uint64_t TSTTableTileRemoveColumns(uint64_t a1, int a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t i;
  TSTTableTileRowInfo *v11;
  int mCellCount;
  int v13;
  unsigned int mMaxTileColumnIndex;
  id obj;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  _BYTE v22[128];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  objc_msgSend((id)a1, "willModify");
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  obj = *(id *)(a1 + 56);
  v6 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
  if (v6)
  {
    v7 = v6;
    v8 = 0;
    v9 = *(_QWORD *)v19;
    do
    {
      for (i = 0; i != v7; ++i)
      {
        if (*(_QWORD *)v19 != v9)
          objc_enumerationMutation(obj);
        v11 = *(TSTTableTileRowInfo **)(*((_QWORD *)&v18 + 1) + 8 * i);
        mCellCount = v11->mCellCount;
        TSTTableTileRowInfoRemoveColumns(v11, a2, a3);
        v13 = v11->mCellCount - mCellCount;
        if (v13)
          *(_WORD *)(a1 + 52) += v13;
        if (!v11->mMaxTileColumnIndexValid)
          TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)v11);
        mMaxTileColumnIndex = v11->mMaxTileColumnIndex;
        if (mMaxTileColumnIndex > v8 && mMaxTileColumnIndex != 255)
          v8 = v11->mMaxTileColumnIndex;
      }
      v7 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
    }
    while (v7);
  }
  else
  {
    v8 = 0;
  }
  *(_BYTE *)(a1 + 48) = v8;
  return 0;
}

void TSTTableTileMoveColumns(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  unsigned int v8;
  void *v10;
  unsigned __int16 *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 v14;
  uint64_t v15;
  uint64_t i;
  TSTTableTileRowInfo *v17;
  unsigned int mMaxTileColumnIndex;
  uint64_t v20;
  id obj;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _BYTE v26[128];
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  objc_msgSend((id)a1, "willModify");
  if (*(_WORD *)(a1 + 64))
  {
    v8 = *(unsigned __int8 *)(a1 + 48);
    if (v8 >= a2 || v8 >= a3)
    {
      v10 = malloc_type_malloc(0x57FFA8uLL, 0x40D695ABuLL);
      v11 = (unsigned __int16 *)malloc_type_malloc(0x1FFFEuLL, 0x1000040BDFB0063uLL);
      v22 = 0u;
      v23 = 0u;
      v24 = 0u;
      v25 = 0u;
      v20 = a1;
      obj = *(id *)(a1 + 56);
      v12 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
      if (v12)
      {
        v13 = v12;
        v14 = 0;
        v15 = *(_QWORD *)v23;
        do
        {
          for (i = 0; i != v13; ++i)
          {
            if (*(_QWORD *)v23 != v15)
              objc_enumerationMutation(obj);
            v17 = *(TSTTableTileRowInfo **)(*((_QWORD *)&v22 + 1) + 8 * i);
            TSTTableTileRowInfoMoveColumns(v17, a2, a3, a4, v10, v11);
            if (!v17->mMaxTileColumnIndexValid)
              TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)v17);
            mMaxTileColumnIndex = v17->mMaxTileColumnIndex;
            if (mMaxTileColumnIndex > v14 && mMaxTileColumnIndex != 255)
              v14 = v17->mMaxTileColumnIndex;
          }
          v13 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
        }
        while (v13);
      }
      else
      {
        v14 = 0;
      }
      free(v10);
      free(v11);
      *(_BYTE *)(v20 + 48) = v14;
    }
  }
}

uint64_t TSTTableTileInsertRows(uint64_t a1, unsigned int a2, __int16 a3, int a4)
{
  void *v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  __int16 v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _BYTE v31[128];
  _BYTE v32[128];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  objc_msgSend((id)a1, "willModify");
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v7 = *(void **)(a1 + 56);
  result = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v23, v31, 16);
  if (result)
  {
    v9 = result;
    v10 = *(_QWORD *)v24;
    do
    {
      v11 = 0;
      do
      {
        if (*(_QWORD *)v24 != v10)
          objc_enumerationMutation(v7);
        v12 = *(_QWORD *)(*((_QWORD *)&v23 + 1) + 8 * v11);
        v13 = *(unsigned __int16 *)(v12 + 536);
        if (v13 == a2)
          v14 = a4;
        else
          v14 = 1;
        if (v13 >= a2 && v14 != 0)
        {
          v16 = v13 + a3;
          objc_msgSend(*(id *)(*((_QWORD *)&v23 + 1) + 8 * v11), "willModify");
          *(_WORD *)(v12 + 536) = v16;
        }
        ++v11;
      }
      while (v9 != v11);
      result = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v23, v31, 16);
      v9 = result;
    }
    while (result);
  }
  if (*(_WORD *)(a1 + 64))
  {
    *(_WORD *)(a1 + 50) = 0;
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v17 = *(void **)(a1 + 56);
    result = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v27, v32, 16);
    if (result)
    {
      v18 = result;
      v19 = *(_QWORD *)v28;
      do
      {
        v20 = 0;
        do
        {
          if (*(_QWORD *)v28 != v19)
            objc_enumerationMutation(v17);
          v21 = *(unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)&v27 + 1) + 8 * v20) + 536);
          if (v21 > *(unsigned __int16 *)(a1 + 50))
            *(_WORD *)(a1 + 50) = v21;
          ++v20;
        }
        while (v18 != v20);
        result = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v27, v32, 16);
        v18 = result;
      }
      while (result);
    }
  }
  return result;
}

void TSTTableTileRemoveRows(uint64_t a1, unsigned int a2, int a3)
{
  unsigned __int16 v6;
  __int16 v7;
  unsigned __int16 v8;
  unsigned int v9;
  unsigned __int16 *ValueAtIndex;
  unsigned int v11;
  unsigned __int16 *v12;
  unsigned __int16 v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  unsigned int v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t j;
  uint64_t v25;
  unsigned int v26;
  __int16 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _BYTE v32[128];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  objc_msgSend((id)a1, "willModify");
  if (*(_WORD *)(a1 + 64))
  {
    v6 = 0;
    v7 = 0;
    v8 = *(_WORD *)(a1 + 64) - 1;
    v27 = a3;
    v9 = a3 + a2;
    do
    {
      ValueAtIndex = (unsigned __int16 *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), (unsigned __int16)(v8 - v6));
      v11 = ValueAtIndex[268];
      if (v11 >= a2)
      {
        v12 = ValueAtIndex;
        if (v9 <= v11)
        {
          v13 = v11 - v27;
          objc_msgSend(ValueAtIndex, "willModify");
          v12[268] = v13;
        }
        else
        {
          ++v7;
          *(_WORD *)(a1 + 52) -= ValueAtIndex[269];
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 56), (unsigned __int16)(v8 - v6));
        }
      }
      ++v6;
    }
    while (v6 <= v8);
    *(_WORD *)(a1 + 64) -= v7;
    if (*(_WORD *)(a1 + 64))
    {
      *(_WORD *)(a1 + 50) = 0;
      v28 = 0u;
      v29 = 0u;
      v30 = 0u;
      v31 = 0u;
      v14 = *(void **)(a1 + 56);
      v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v28, v32, 16);
      if (v15)
      {
        v16 = v15;
        v17 = *(_QWORD *)v29;
        do
        {
          for (i = 0; i != v16; ++i)
          {
            if (*(_QWORD *)v29 != v17)
              objc_enumerationMutation(v14);
            v19 = *(unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)&v28 + 1) + 8 * i) + 536);
            if (v19 > *(unsigned __int16 *)(a1 + 50))
              *(_WORD *)(a1 + 50) = v19;
          }
          v16 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v28, v32, 16);
        }
        while (v16);
      }
      *(_BYTE *)(a1 + 48) = 0;
      v28 = 0u;
      v29 = 0u;
      v30 = 0u;
      v31 = 0u;
      v20 = *(void **)(a1 + 56);
      v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v28, v32, 16);
      if (v21)
      {
        v22 = v21;
        v23 = *(_QWORD *)v29;
        do
        {
          for (j = 0; j != v22; ++j)
          {
            if (*(_QWORD *)v29 != v23)
              objc_enumerationMutation(v20);
            v25 = *(_QWORD *)(*((_QWORD *)&v28 + 1) + 8 * j);
            if (*(_WORD *)(v25 + 538))
            {
              if (!*(_BYTE *)(v25 + 541))
                TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(_QWORD *)(*((_QWORD *)&v28 + 1) + 8 * j));
              v26 = *(unsigned __int8 *)(v25 + 540);
              if (v26 != 255 && v26 > *(unsigned __int8 *)(a1 + 48))
                *(_BYTE *)(a1 + 48) = v26;
            }
          }
          v22 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v28, v32, 16);
        }
        while (v22);
      }
    }
    else
    {
      *(_WORD *)(a1 + 50) = 0;
      *(_BYTE *)(a1 + 48) = 0;
    }
  }
}

void TSTTableTileYankRows(uint64_t a1, unsigned int a2, int a3, void *a4)
{
  unsigned __int16 v7;
  __int16 v8;
  unsigned __int16 v9;
  _WORD *ValueAtIndex;
  unsigned int v11;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  unsigned int v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t j;
  uint64_t v24;
  unsigned int v25;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _BYTE v31[128];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  objc_msgSend((id)a1, "willModify");
  if (*(_WORD *)(a1 + 64))
  {
    v7 = 0;
    v8 = 0;
    v9 = *(_WORD *)(a1 + 64) - 1;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), (unsigned __int16)(v9 - v7));
      v11 = (unsigned __int16)ValueAtIndex[268];
      if (v11 >= a2 && a3 + a2 > v11)
      {
        ++v8;
        *(_WORD *)(a1 + 52) -= ValueAtIndex[269];
        objc_msgSend(a4, "insertObject:atIndex:", ValueAtIndex, 0);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 56), (unsigned __int16)(v9 - v7));
      }
      ++v7;
    }
    while (v7 <= v9);
    *(_WORD *)(a1 + 64) -= v8;
    if (*(_WORD *)(a1 + 64))
    {
      *(_WORD *)(a1 + 50) = 0;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0u;
      v13 = *(void **)(a1 + 56);
      v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
      if (v14)
      {
        v15 = v14;
        v16 = *(_QWORD *)v28;
        do
        {
          for (i = 0; i != v15; ++i)
          {
            if (*(_QWORD *)v28 != v16)
              objc_enumerationMutation(v13);
            v18 = *(unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)&v27 + 1) + 8 * i) + 536);
            if (v18 > *(unsigned __int16 *)(a1 + 50))
              *(_WORD *)(a1 + 50) = v18;
          }
          v15 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
        }
        while (v15);
      }
      *(_BYTE *)(a1 + 48) = 0;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0u;
      v19 = *(void **)(a1 + 56);
      v20 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
      if (v20)
      {
        v21 = v20;
        v22 = *(_QWORD *)v28;
        do
        {
          for (j = 0; j != v21; ++j)
          {
            if (*(_QWORD *)v28 != v22)
              objc_enumerationMutation(v19);
            v24 = *(_QWORD *)(*((_QWORD *)&v27 + 1) + 8 * j);
            if (*(_WORD *)(v24 + 538))
            {
              if (!*(_BYTE *)(v24 + 541))
                TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(_QWORD *)(*((_QWORD *)&v27 + 1) + 8 * j));
              v25 = *(unsigned __int8 *)(v24 + 540);
              if (v25 != 255 && v25 > *(unsigned __int8 *)(a1 + 48))
                *(_BYTE *)(a1 + 48) = v25;
            }
          }
          v21 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
        }
        while (v21);
      }
    }
    else
    {
      *(_WORD *)(a1 + 50) = 0;
      *(_BYTE *)(a1 + 48) = 0;
    }
  }
}

unsigned __int8 *TSTTableTileYankRow(uint64_t a1, unsigned int a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  unsigned __int16 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t j;
  unsigned int v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t k;
  uint64_t v23;
  unsigned int v24;
  unsigned __int8 *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  _BYTE v35[128];
  _BYTE v36[128];
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  objc_msgSend((id)a1, "willModify");
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v4 = *(void **)(a1 + 56);
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v27, v35, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v28;
    while (2)
    {
      for (i = 0; i != v6; ++i)
      {
        if (*(_QWORD *)v28 != v7)
          objc_enumerationMutation(v4);
        v9 = *(unsigned __int16 **)(*((_QWORD *)&v27 + 1) + 8 * i);
        if (v9[268] == a2)
        {
          *(_WORD *)(a1 + 52) -= v9[269];
          v10 = v9;
          objc_msgSend(*(id *)(a1 + 56), "removeObject:", v9);
          --*(_WORD *)(a1 + 64);
          if (v10)
          {
            if (*(unsigned __int16 *)(a1 + 50) <= a2)
            {
              v11 = v10;
              *(_WORD *)(a1 + 50) = 0;
              v31 = 0u;
              v32 = 0u;
              v33 = 0u;
              v34 = 0u;
              v12 = *(void **)(a1 + 56);
              v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v31, v36, 16);
              if (v13)
              {
                v14 = v13;
                v15 = *(_QWORD *)v32;
                do
                {
                  for (j = 0; j != v14; ++j)
                  {
                    if (*(_QWORD *)v32 != v15)
                      objc_enumerationMutation(v12);
                    v17 = *(unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)&v31 + 1) + 8 * j) + 536);
                    if (v17 > *(unsigned __int16 *)(a1 + 50))
                      *(_WORD *)(a1 + 50) = v17;
                  }
                  v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v31, v36, 16);
                }
                while (v14);
              }
              v10 = v11;
            }
            if (!v10[541])
              TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)v10);
            if (v10[540] >= *(unsigned __int8 *)(a1 + 48))
            {
              v26 = v10;
              *(_BYTE *)(a1 + 48) = 0;
              v31 = 0u;
              v32 = 0u;
              v33 = 0u;
              v34 = 0u;
              v18 = *(void **)(a1 + 56);
              v19 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v31, v36, 16);
              if (v19)
              {
                v20 = v19;
                v21 = *(_QWORD *)v32;
                do
                {
                  for (k = 0; k != v20; ++k)
                  {
                    if (*(_QWORD *)v32 != v21)
                      objc_enumerationMutation(v18);
                    v23 = *(_QWORD *)(*((_QWORD *)&v31 + 1) + 8 * k);
                    if (*(_WORD *)(v23 + 538))
                    {
                      if (!*(_BYTE *)(v23 + 541))
                        TSTTableTileRowInfoRecalculateMaxTileColumnIndex(*(_QWORD *)(*((_QWORD *)&v31 + 1) + 8 * k));
                      v24 = *(unsigned __int8 *)(v23 + 540);
                      if (v24 != 255 && v24 > *(unsigned __int8 *)(a1 + 48))
                        *(_BYTE *)(a1 + 48) = v24;
                    }
                  }
                  v20 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v31, v36, 16);
                }
                while (v20);
              }
              v10 = v26;
            }
          }
          return v10;
        }
      }
      v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v27, v35, 16);
      if (v6)
        continue;
      break;
    }
  }
  v10 = 0;
  return v10;
}

uint64_t TSTTableTileSpliceRow(TSTTableTile *a1, unsigned int a2, TSTTableTileRowInfo *a3)
{
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;

  if (!a3)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableTileSpliceRow(TSTTableTile *, TSURowIndex, TSTTableTileRowInfo *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 703, CFSTR("Can't splice in a nil row!"));
  }
  if ((TSTTableTile *)-[TSPContainedObject owner](a3, "owner") != a1)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableTileSpliceRow(TSTTableTile *, TSURowIndex, TSTTableTileRowInfo *)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 704, CFSTR("Tile doesn't own that row!"));
  }
  -[TSPObject willModify](a1, "willModify");
  return p_InsertRowInfoWithRowIndex(a1, a3, a2);
}

uint64_t p_InsertRowInfoWithRowIndex(TSTTableTile *a1, TSTTableTileRowInfo *a2, unsigned int a3)
{
  void *v5;
  uint64_t v6;
  NSMutableArray *mRowInfos;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  unsigned int mMaxTileColumnIndex;
  unsigned int mMaxColumn;
  uint64_t v20;
  uint64_t v21;
  TSTTableTile *v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[128];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  if ((TSTTableTile *)-[TSPContainedObject owner](a2, "owner") != a1)
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_InsertRowInfoWithRowIndex(TSTTableTile *, TSTTableTileRowInfo *, TSURowIndex)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 253, CFSTR("Tile doesn't own that row!"));
  }
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v23 = a1;
  mRowInfos = a1->mRowInfos;
  v8 = -[NSMutableArray countByEnumeratingWithState:objects:count:](mRowInfos, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
  if (v8)
  {
    v9 = v8;
    v10 = *(_QWORD *)v25;
    v11 = 0;
    while (2)
    {
      v12 = 0;
      v21 = v11;
      v20 = v11 + v9;
      do
      {
        if (*(_QWORD *)v25 != v10)
          objc_enumerationMutation(mRowInfos);
        v13 = *(unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)&v24 + 1) + 8 * v12) + 536);
        if (v13 > a3)
        {
          v16 = v21 + v12;
          goto LABEL_16;
        }
        if (v13 == a3)
        {
          v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_InsertRowInfoWithRowIndex(TSTTableTile *, TSTTableTileRowInfo *, TSURowIndex)");
          objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 263, CFSTR("Duplicate row indices!"));
        }
        ++v12;
      }
      while (v9 != v12);
      v9 = -[NSMutableArray countByEnumeratingWithState:objects:count:](mRowInfos, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
      v16 = v20;
      v11 = v20;
      if (v9)
        continue;
      break;
    }
  }
  else
  {
    v16 = 0;
  }
LABEL_16:
  -[TSPObject willModify](v23, "willModify", v20);
  result = -[NSMutableArray insertObject:atIndex:](v23->mRowInfos, "insertObject:atIndex:", a2, v16);
  ++v23->mNumRows;
  v23->mNumCells += a2->mCellCount;
  if (v23->mMaxRow < a3)
    v23->mMaxRow = a3;
  if (!a2->mMaxTileColumnIndexValid)
    result = TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)a2);
  mMaxTileColumnIndex = a2->mMaxTileColumnIndex;
  if (mMaxTileColumnIndex != 255)
  {
    mMaxColumn = v23->mMaxColumn;
    if (mMaxColumn == 255 || mMaxTileColumnIndex > mMaxColumn)
      v23->mMaxColumn = mMaxTileColumnIndex;
  }
  return result;
}

BOOL TSTTableTileShouldSplitRows(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 64) > 0x1Fu;
}

BOOL TSTTableTileShouldMergeRows(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 64) < 4u;
}

BOOL TSTTableTilesShouldMergeRowsTogether(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int16 *)(a2 + 64) + *(unsigned __int16 *)(a1 + 64) < 0x1D;
}

uint64_t TSTTableTileFindMidpointForRowSplit(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  unsigned __int16 *ValueAtIndex;
  unsigned int v8;
  void *v9;
  uint64_t v10;
  unsigned __int16 v11;
  unsigned int v12;
  void *v13;
  uint64_t v14;

  if (*(unsigned __int16 *)(a1 + 64) <= 1u)
  {
    v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSURowIndex TSTTableTileFindMidpointForRowSplit(TSTTableTile *)");
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 747, CFSTR("Can't split a tile with out more than one row!"));
  }
  v4 = *(unsigned __int16 *)(objc_msgSend(*(id *)(a1 + 56), "objectAtIndex:", 0) + 536);
  v5 = *(unsigned __int16 *)(a1 + 64);
  v6 = 1;
  if (v5 >= 2)
  {
    while (1)
    {
      ValueAtIndex = (unsigned __int16 *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), (unsigned __int16)v6);
      v8 = ValueAtIndex[268];
      if (v4 + 1 != v8)
        break;
      ++v6;
      v5 = *(unsigned __int16 *)(a1 + 64);
      v4 = ValueAtIndex[268];
      if (v5 <= (unsigned __int16)v6)
      {
        v4 = ValueAtIndex[268];
        goto LABEL_10;
      }
    }
    if (v8 <= v4)
    {
      v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSURowIndex TSTTableTileFindMidpointForRowSplit(TSTTableTile *)");
      objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 768, CFSTR("Row indexes out of order in split!"));
    }
    v5 = *(unsigned __int16 *)(a1 + 64);
  }
LABEL_10:
  if ((unsigned __int16)v6 >= v5 >> 1)
  {
    LOWORD(v12) = v4;
  }
  else
  {
    v11 = v6;
    do
    {
      v12 = *((unsigned __int16 *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), v11) + 268);
      if (v12 <= v4)
      {
        v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSURowIndex TSTTableTileFindMidpointForRowSplit(TSTTableTile *)");
        objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 779, CFSTR("Row indexes out of order in split!"));
      }
      ++v6;
      ++v11;
      v4 = v12;
    }
    while ((unsigned __int16)v6 < (*(unsigned __int16 *)(a1 + 64) >> 1));
  }
  return (unsigned __int16)v12;
}

TSTTableTile *TSTTableTileSplitRows(TSTTableTile *a1, unsigned int a2)
{
  TSTTableTile *v4;
  id v5;
  void *v6;
  NSMutableArray *mRowInfos;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t j;
  TSTTableTileRowInfo *v16;
  unsigned __int16 v17;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];
  _BYTE v28[128];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  -[TSPObject willModify](a1, "willModify");
  v4 = -[TSTTableTile initWithContext:]([TSTTableTile alloc], "initWithContext:", -[TSPObject context](a1, "context"));
  if (a1->mMaxRow <= a2)
    v5 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
  else
    v5 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDBCEB8]), "initWithCapacity:", a1->mMaxRow - (unint64_t)a2);
  v6 = v5;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  mRowInfos = a1->mRowInfos;
  v8 = -[NSMutableArray countByEnumeratingWithState:objects:count:](mRowInfos, "countByEnumeratingWithState:objects:count:", &v23, v28, 16);
  if (v8)
  {
    v9 = v8;
    v10 = *(_QWORD *)v24;
    do
    {
      for (i = 0; i != v9; ++i)
      {
        if (*(_QWORD *)v24 != v10)
          objc_enumerationMutation(mRowInfos);
        if (*(unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)&v23 + 1) + 8 * i) + 536) >= a2)
          objc_msgSend(v6, "addObject:");
      }
      v9 = -[NSMutableArray countByEnumeratingWithState:objects:count:](mRowInfos, "countByEnumeratingWithState:objects:count:", &v23, v28, 16);
    }
    while (v9);
  }
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v12 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v19, v27, 16);
  if (v12)
  {
    v13 = v12;
    v14 = *(_QWORD *)v20;
    do
    {
      for (j = 0; j != v13; ++j)
      {
        if (*(_QWORD *)v20 != v14)
          objc_enumerationMutation(v6);
        v16 = *(TSTTableTileRowInfo **)(*((_QWORD *)&v19 + 1) + 8 * j);
        v17 = v16->mTileRowIndex - a2;
        p_RemoveRowInfo(a1, v16);
        -[TSPContainedObject setOwner:](v16, "setOwner:", v4);
        -[TSPContainedObject willModify](v16, "willModify");
        v16->mTileRowIndex = v17;
        p_InsertRowInfoWithRowIndex(v4, v16, v17);
      }
      v13 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v19, v27, 16);
    }
    while (v13);
  }

  return v4;
}

uint64_t TSTTableTileMergeRows(uint64_t a1, uint64_t a2, unsigned int a3)
{
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  _WORD *v13;
  __int16 v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t j;
  unsigned int v20;
  uint64_t result;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _BYTE v30[128];
  _BYTE v31[128];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  objc_msgSend((id)a1, "willModify");
  objc_msgSend((id)a2, "willModify");
  if (*(unsigned __int16 *)(a1 + 50) >= a3)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableTileMergeRows(TSTTableTile *, TSTTableTile *, TSURowIndex)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTile.mm"), 841, CFSTR("Overlapping tiles in tile merge!"));
  }
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v8 = *(void **)(a2 + 56);
  v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v26, v31, 16);
  if (v9)
  {
    v10 = v9;
    v11 = *(_QWORD *)v27;
    do
    {
      for (i = 0; i != v10; ++i)
      {
        if (*(_QWORD *)v27 != v11)
          objc_enumerationMutation(v8);
        v13 = *(_WORD **)(*((_QWORD *)&v26 + 1) + 8 * i);
        v14 = v13[268] + a3;
        objc_msgSend(v13, "willModify");
        v13[268] = v14;
      }
      v10 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v26, v31, 16);
    }
    while (v10);
  }
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v15 = *(void **)(a2 + 56);
  v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v22, v30, 16);
  if (v16)
  {
    v17 = v16;
    v18 = *(_QWORD *)v23;
    do
    {
      for (j = 0; j != v17; ++j)
      {
        if (*(_QWORD *)v23 != v18)
          objc_enumerationMutation(v15);
        objc_msgSend(*(id *)(*((_QWORD *)&v22 + 1) + 8 * j), "setOwner:", a1);
      }
      v17 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v22, v30, 16);
    }
    while (v17);
  }
  objc_msgSend(*(id *)(a1 + 56), "addObjectsFromArray:", *(_QWORD *)(a2 + 56));
  v20 = *(unsigned __int8 *)(a1 + 48);
  if (v20 <= *(unsigned __int8 *)(a2 + 48))
    LOBYTE(v20) = *(_BYTE *)(a2 + 48);
  *(_BYTE *)(a1 + 48) = v20;
  *(_WORD *)(a1 + 50) = *(_WORD *)(a2 + 50) + a3;
  *(_WORD *)(a1 + 52) += *(_WORD *)(a2 + 52);
  *(_WORD *)(a1 + 64) = objc_msgSend(*(id *)(a1 + 56), "count");
  result = objc_msgSend(*(id *)(a2 + 56), "removeAllObjects");
  *(_BYTE *)(a2 + 48) = 0;
  *(_WORD *)(a2 + 50) = 0;
  *(_WORD *)(a2 + 52) = 0;
  *(_WORD *)(a2 + 64) = 0;
  return result;
}

uint64_t TSTTableSetDefaultRowHeight(double *a1, double a2)
{
  uint64_t result;

  result = objc_msgSend(a1, "willModify");
  a1[12] = a2;
  return result;
}

double TSTTableDefaultRowHeight(uint64_t a1)
{
  if (a1)
    return *(double *)(a1 + 96);
  else
    return 10.0;
}

uint64_t TSTTableSetDefaultColumnWidth(double *a1, double a2)
{
  uint64_t result;

  result = objc_msgSend(a1, "willModify");
  a1[13] = a2;
  return result;
}

double TSTTableDefaultColumnWidth(uint64_t a1)
{
  if (a1)
    return *(double *)(a1 + 104);
  else
    return 0.0;
}

id TSTTableMergeRangesForCellRegion(uint64_t a1, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  id v5;
  id v6;
  void *v7;
  uint64_t v8;

  if (a1)
    v3 = *(_QWORD *)(a1 + 48);
  else
    v3 = 0;
  v4 = objc_msgSend(a2, "boundingCellRange");
  v5 = TSTTableDataStoreMergeRangesForCellRange(v3, v4);
  v6 = TSTTableDataStoreMergeRangesForCellRange(v3, v4);
  if (v6)
  {
    v7 = (void *)objc_msgSend(v5, "iterator");
    if (objc_msgSend(v7, "hasNextMergeRegion"))
    {
      do
      {
        v8 = objc_msgSend(v7, "nextMergeRegion");
        if ((objc_msgSend(a2, "intersectsCellRange:", v8) & 1) == 0)
          objc_msgSend(v6, "remove:", v8);
      }
      while ((objc_msgSend(v7, "hasNextMergeRegion") & 1) != 0);
    }
  }
  return v6;
}

uint64_t TSTTableMerge(uint64_t a1, uint64_t a2)
{
  return TSTTableDataStoreMerge(*(_QWORD **)(a1 + 48), a2);
}

BOOL TSTTableCellIDIsLegal(uint64_t a1, int a2)
{
  return *(unsigned __int16 *)(a1 + 72) > (unsigned __int16)a2
      && *(unsigned __int16 *)(a1 + 74) > BYTE2(a2);
}

id TSTSetDefaultCellForTableArea(id *a1, int a2, void *a3)
{
  id result;
  void *v6;
  uint64_t v7;

  switch(a2)
  {
    case 0:

      result = a3;
      *a1 = result;
      break;
    case 1:
    case 4:

      result = a3;
      a1[1] = result;
      break;
    case 2:

      result = a3;
      a1[2] = result;
      break;
    case 3:
    case 5:

      result = a3;
      a1[3] = result;
      break;
    default:
      v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTSetDefaultCellForTableArea(TSTDefaultCellBlock *, TSTTableArea, TSTCell *)");
      result = (id)objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 1651, CFSTR("illegal table region"));
      break;
  }
  return result;
}

uint64_t TSTTableDefaultCellForCellID(unsigned __int16 *a1, int a2, uint64_t a3)
{
  if ((unsigned __int16)a2 >= a1[36] || BYTE2(a2) >= a1[37])
    return 3;
  TSTCellCopy(objc_msgSend(a1, "defaultCellForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", a2 & 0xFF000000 | (BYTE2(a2) << 16) | (unsigned __int16)a2)), a3);
  return 0;
}

BOOL TSTCellExistsAtCellID(uint64_t a1, int a2)
{
  return (unsigned __int16)a2 < *(unsigned __int16 *)(a1 + 72)
      && BYTE2(a2) < *(unsigned __int16 *)(a1 + 74)
      && TSTTableDataStoreCellExistsAtCellID(*(_QWORD *)(a1 + 48), a2 & 0xFF000000 | (BYTE2(a2) << 16) | (unsigned __int16)a2);
}

uint64_t TSTCellAtCellIDSuppressingFormula(uint64_t a1, int a2, void *a3, uint64_t a4)
{
  UInt8 *v7;

  if ((unsigned __int16)a2 >= *(unsigned __int16 *)(a1 + 72)
    || BYTE2(a2) >= *(unsigned __int16 *)(a1 + 74))
  {
    return 3;
  }
  v7 = TSTTableDataStoreCellStorageRefAtCellID(*(_QWORD *)(a1 + 48), a2 & 0xFF000000 | (BYTE2(a2) << 16) | (unsigned __int16)a2);
  if (!v7)
    return 1000;
  objc_msgSend(a3, "inflateFromStorageRef:dataStore:suppressingFormulaInflation:", v7, *(_QWORD *)(a1 + 48), a4);
  return 0;
}

uint64_t TSTCellAtCellID(uint64_t a1, int a2, void *a3)
{
  return TSTCellAtCellIDSuppressingFormula(a1, a2, a3, 0);
}

uint64_t TSTTablePreflightSetCellAtCellID(uint64_t a1, uint64_t a2, int a3)
{
  int v4;
  int v6;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t result;
  unsigned int v12;
  BOOL v13;
  int v14;
  BOOL v15;
  _BOOL4 v16;
  void *v17;
  uint64_t v18;

  v4 = (unsigned __int16)a3;
  if ((unsigned __int16)a3 < *(unsigned __int16 *)(a1 + 72))
  {
    v6 = BYTE2(a3);
    if (BYTE2(a3) < *(unsigned __int16 *)(a1 + 74))
    {
      v8 = objc_msgSend((id)a1, "range");
      v9 = WORD2(v8) * HIWORD(v8);
      v10 = objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "maxNumberOfPopulatedCells");
      if (v9 < v10
        || (v12 = v10,
            v13 = TSTTableDataStoreCellExistsAtCellID(*(_QWORD *)(a1 + 48), a3 & 0xFF000000 | (v6 << 16) | v4),
            !a2)
        || v13)
      {
        if (!a2)
          return 0;
      }
      else if (TSTTableDataStoreNumberOfPopulatedCells(*(_QWORD *)(a1 + 48)) >= v12)
      {
        return 1001;
      }
      result = 0;
      v14 = *(_DWORD *)(a2 + 104);
      switch(BYTE1(*(_DWORD *)(a2 + 8)))
      {
        case 2u:
          if ((v14 & 0xFFFFFFFC) == 0x100 || (v14 - 262) < 9 && ((0x1BFu >> (v14 - 6)) & 1) != 0)
            return 0;
          v15 = (v14 - 268) >= 0xFFFFFFFB || (v14 & 0xFFFFFFF7) == 262;
          goto LABEL_33;
        case 3u:
        case 9u:
          result = 0;
          if (v14 > 259)
          {
            if (v14 == 260 || v14 == 271)
              return result;
          }
          else if ((v14 + 1) < 3 || v14 == -999)
          {
            return result;
          }
          v16 = 0;
          switch(BYTE1(*(_DWORD *)(a2 + 8)))
          {
            case 3u:
            case 9u:
              v16 = v14 != 271;
              break;
            case 5u:
              goto LABEL_25;
            case 6u:
              goto LABEL_30;
            case 7u:
              goto LABEL_32;
            default:
              break;
          }
LABEL_36:
          NSLog((NSString *)CFSTR("%d"), v16);
          v17 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v18 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSUError TSTTablePreflightSetCellAtCellID(TSTTableModel *, TSTCell *, TSTCellID)");
          objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 1782, CFSTR("Attempting to add invalid cell to the model"));
          break;
        case 5u:
          result = 0;
          if (v14 == 261 || v14 == 272)
            return result;
LABEL_25:
          v15 = v14 == 261 || v14 == 272;
          goto LABEL_33;
        case 6u:
          result = 0;
          if (v14 == 1 || v14 == 263)
            return result;
LABEL_30:
          v15 = v14 == 263;
LABEL_33:
          v16 = !v15;
          goto LABEL_36;
        case 7u:
          if (v14 == 268)
            return 0;
LABEL_32:
          v15 = v14 == 268;
          goto LABEL_33;
        default:
          return result;
      }
      return 0;
    }
  }
  return 3;
}

uint64_t TSTTableSetCellAtCellID(uint64_t a1, _QWORD *a2, unsigned int a3)
{
  return TSTTableSetCellAtCellIDIgnoringFormula(a1, a2, a3);
}

uint64_t TSTTableSetCellAtCellIDIgnoringFormula(uint64_t a1, _QWORD *a2, unsigned int a3)
{
  unint64_t v5;
  uint64_t v6;

  v5 = a3;
  v6 = TSTTablePreflightSetCellAtCellID(a1, (uint64_t)a2, a3);
  if (!(_DWORD)v6)
    TSTTableDataStoreSetCellAtCellID(*(id **)(a1 + 48), a2, v5);
  return v6;
}

uint64_t TSTTablePreflightSetCellsWithCellMap(uint64_t a1, void *a2)
{
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v8;
  uint64_t v9;
  unint64_t i;
  unsigned int v11;
  uint64_t v12;

  v4 = objc_msgSend(a2, "count");
  v5 = TSTTableDataStoreNumberOfPopulatedCells(*(_QWORD *)(a1 + 48));
  v6 = objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "maxNumberOfPopulatedCells");
  if (v4 + v5 < v6 || v4 == 0)
    return 0;
  v8 = v6;
  v9 = 0;
  for (i = v4 - 1; ; --i)
  {
    v11 = objc_msgSend(a2, "cellIDAtIndex:", v9);
    v12 = objc_msgSend(a2, "cellAtIndex:", v9);
    v4 = v4 & 0xFFFFFFFF00000000 | v11;
    v5 += (v12 != 0) & ~TSTTableDataStoreCellExistsAtCellID(*(_QWORD *)(a1 + 48), v4);
    if (v8 < v5)
      break;
    ++v9;
    if (i < v8 - v5 || i == 0)
      return 0;
  }
  return 1001;
}

uint64_t TSTTableSetCellsWithCellMap(uint64_t a1, void *a2)
{
  return TSTTableSetCellsWithCellMapIgnoringFormulas(a1, a2);
}

uint64_t TSTTableSetCellsWithCellMapIgnoringFormulas(uint64_t a1, void *a2)
{
  uint64_t v4;

  v4 = TSTTablePreflightSetCellsWithCellMap(a1, a2);
  if (!(_DWORD)v4)
    TSTTableDataStoreSetCellsWithCellMap(*(void **)(a1 + 48), a2);
  return v4;
}

uint64_t TSTCellAtCellIDHoldingReadLock(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  unsigned int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;

  v6 = a1;
  v7 = a2;
  v8 = a3;
  v5 = 1;
  objc_msgSend(a4, "performRead:withTarget:argument:argument2:", sel_p_fetchCellHoldingReadLock_returnCode_, a1, &v6, &v5);
  return v5;
}

void TSTTableGetFormatAtCellIDForFormulaReference(uint64_t a1@<X0>, int a2@<W1>, BOOL *a3@<X2>, _QWORD *a4@<X3>, uint64_t a5@<X8>)
{
  unsigned int v9;
  char *v10;
  uint64_t v11;
  __int128 v12;
  int v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  if ((unsigned __int16)a2 >= *(unsigned __int16 *)(a1 + 72)
    || BYTE2(a2) >= *(unsigned __int16 *)(a1 + 74))
  {
    *(_QWORD *)(a5 + 32) = 0;
    *(_OWORD *)a5 = TSUInvalidFormat;
    *(_OWORD *)(a5 + 16) = unk_217C2BE60;
    return;
  }
  v9 = a2 & 0xFF000000 | (BYTE2(a2) << 16) | (unsigned __int16)a2;
  v10 = (char *)TSTCellDictionaryCellAtCellID(*(_QWORD *)(a1 + 280), v9);
  if (v10)
  {
    if (a3)
      *a3 = (*((_WORD *)v10 + 48) & 0x8010) == 0;
    v11 = *((_QWORD *)v10 + 17);
    v12 = *(_OWORD *)(v10 + 120);
    *(_OWORD *)a5 = *(_OWORD *)(v10 + 104);
    *(_OWORD *)(a5 + 16) = v12;
    *(_QWORD *)(a5 + 32) = v11;
    v13 = *(_DWORD *)a5;
    if ((*(_DWORD *)a5 & 0xFFFFFFFE) != 0x108)
      goto LABEL_13;
    TSTCellGetFormatOfType(v10, *(_DWORD *)(a5 + 32), a5);
    goto LABEL_12;
  }
  TSTTableDataStoreGetFormatAtCellID(*(_QWORD *)(a1 + 48), v9, a3, 0, (uint64_t)&v16);
  v14 = v17;
  *(_OWORD *)a5 = v16;
  *(_OWORD *)(a5 + 16) = v14;
  *(_QWORD *)(a5 + 32) = v18;
  v13 = *(_DWORD *)a5;
  if ((*(_DWORD *)a5 & 0xFFFFFFFE) == 0x108)
  {
    TSTTableDataStoreGetFormatForFormatTypeAtCellID(*(_QWORD *)(a1 + 48), v9, *(_DWORD *)(a5 + 32), 0, (uint64_t)&v16);
    v15 = v17;
    *(_OWORD *)a5 = v16;
    *(_OWORD *)(a5 + 16) = v15;
    *(_QWORD *)(a5 + 32) = v18;
LABEL_12:
    v13 = *(_DWORD *)a5;
  }
LABEL_13:
  if (a4)
  {
    if (v13 == 270)
    {
      *a4 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)a1, "documentRoot"), "customFormatList"), "customFormatForKey:", *(unsigned int *)(a5 + 8));
      v13 = *(_DWORD *)a5;
    }
    else
    {
      *a4 = 0;
    }
  }
  if ((v13 - 270) <= 2)
    TSTTableDataStorePopulateCustomFormat(*(_QWORD **)(a1 + 48), a5, 0.0);
}

uint64_t TSTTableNumberOfComments(void *a1)
{
  return TSTTableDataListGetCount(objc_msgSend(*(id *)(objc_msgSend(a1, "dataStore") + 120), "object"));
}

UInt8 *TSTTableHasCommentStorageAtCellID(uint64_t a1, int a2)
{
  UInt8 *result;

  result = TSTTableDataStoreCellStorageRefAtCellID(*(_QWORD *)(a1 + 48), a2);
  if (result)
    return (UInt8 *)((result[5] >> 4) & 1);
  return result;
}

UInt8 *TSTTableGetCommentStorageAtCellID(uint64_t a1, int a2)
{
  UInt8 *result;
  UInt8 *v4;
  TSTCell *v5;
  TSDCommentStorage *mCommentStorage;
  TSDCommentStorage *v7;

  result = TSTTableDataStoreCellStorageRefAtCellID(*(_QWORD *)(a1 + 48), a2);
  if (result)
  {
    v4 = result;
    v5 = objc_alloc_init(TSTCell);
    -[TSTCell inflateFromStorageRef:dataStore:](v5, "inflateFromStorageRef:dataStore:", v4, *(_QWORD *)(a1 + 48));
    if (v5)
      mCommentStorage = v5->mPrivate.mCommentStorage;
    else
      mCommentStorage = 0;
    v7 = mCommentStorage;

    return (UInt8 *)v7;
  }
  return result;
}

uint64_t TSTTableSetCommentStorageAtCellID(uint64_t a1, TSDCommentStorage *a2, unsigned int a3)
{
  TSTCell *v6;
  UInt8 *v7;
  uint64_t v8;

  v6 = objc_alloc_init(TSTCell);
  v7 = TSTTableDataStoreCellStorageRefAtCellID(*(_QWORD *)(a1 + 48), a3);
  if (v7)
    -[TSTCell inflateFromStorageRef:dataStore:](v6, "inflateFromStorageRef:dataStore:", v7, *(_QWORD *)(a1 + 48));
  else
    v6->mPrivate.mCommentStorageID = 0;
  TSTCellSetCommentStorageClearingID((TSDCommentStorage *)v6, a2, 1);
  v8 = TSTTableSetCellAtCellIDIgnoringFormula(a1, v6, a3);

  return v8;
}

uint64_t TSTTableRemoveCommentStorageAtCellID(uint64_t a1, unsigned int a2)
{
  TSTCell *v4;
  UInt8 *v5;
  TSDCommentStorage *mCommentStorage;
  uint64_t v7;

  v4 = objc_alloc_init(TSTCell);
  v5 = TSTTableDataStoreCellStorageRefAtCellID(*(_QWORD *)(a1 + 48), a2);
  if (v5)
  {
    -[TSTCell inflateFromStorageRef:dataStore:](v4, "inflateFromStorageRef:dataStore:", v5, *(_QWORD *)(a1 + 48));
    mCommentStorage = v4->mPrivate.mCommentStorage;
    if (mCommentStorage)
    {

      v4->mPrivate.mCommentStorage = 0;
    }
    v4->mPrivate.mCommentStorageID = 0;
    v7 = TSTTableSetCellAtCellIDIgnoringFormula(a1, v4, a2);
  }
  else
  {
    v7 = 2;
  }

  return v7;
}

BOOL TSTTableHeaderInfoForRowIsNilOrEmpty(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = TSTTableDataStoreHeaderInfoForRow(*(_QWORD *)(a1 + 48), a2, 0, 0);
  if (!v2)
    return 1;
  if (*(double *)(v2 + 24) != 0.0 || *(_WORD *)(v2 + 34) || *(_QWORD *)(v2 + 8) || *(_QWORD *)(v2 + 16))
    return 0;
  return *(_BYTE *)(v2 + 32) == 0;
}

BOOL TSTTableHeaderInfoForColumnIsNilOrEmpty(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = TSTTableDataStoreHeaderInfoForColumn(*(_QWORD *)(a1 + 48), a2, 0, 0);
  if (!v2)
    return 1;
  if (*(double *)(v2 + 24) != 0.0 || *(_WORD *)(v2 + 34) || *(_QWORD *)(v2 + 8) || *(_QWORD *)(v2 + 16))
    return 0;
  return *(_BYTE *)(v2 + 32) == 0;
}

uint64_t TSTTableSetCellStyleAtRow(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;

  v6 = TSTTableDataStoreHeaderInfoForRow(*(_QWORD *)(a1 + 48), a3, 1, 1);
  if (!v6)
    return 2;
  v7 = v6;
  *(_QWORD *)(v6 + 8) = a2;
  if (*(double *)(v7 + 24) == 0.0
    && !*(_WORD *)(v7 + 34)
    && !*(_QWORD *)(v7 + 8)
    && !*(_QWORD *)(v7 + 16)
    && !*(_BYTE *)(v7 + 32))
  {
    TSTTableDataStoreRemoveRowHeadersAtIndex(*(_QWORD *)(a1 + 48), a3, 1);
  }
  return 0;
}

uint64_t TSTTableSetTextStyleAtRow(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;

  v6 = TSTTableDataStoreHeaderInfoForRow(*(_QWORD *)(a1 + 48), a3, 1, 1);
  if (!v6)
    return 2;
  v7 = v6;
  *(_QWORD *)(v6 + 16) = a2;
  if (*(double *)(v7 + 24) == 0.0
    && !*(_WORD *)(v7 + 34)
    && !*(_QWORD *)(v7 + 8)
    && !*(_QWORD *)(v7 + 16)
    && !*(_BYTE *)(v7 + 32))
  {
    TSTTableDataStoreRemoveRowHeadersAtIndex(*(_QWORD *)(a1 + 48), a3, 1);
  }
  return 0;
}

uint64_t TSTTableGetCellStyleAtRow(uint64_t *a1, uint64_t a2, _BYTE *a3)
{
  signed int v4;
  uint64_t v6;
  uint64_t result;
  int v8;

  v4 = a2;
  v6 = TSTTableDataStoreHeaderInfoForRow(a1[6], a2, 0, 0);
  if (v6 && (result = *(_QWORD *)(v6 + 8)) != 0)
  {
    *a3 = 0;
  }
  else
  {
    if (a3)
      *a3 = 1;
    if (objc_msgSend(a1, "numberOfHeaderRows") <= v4)
    {
      v8 = objc_msgSend(a1, "numberOfRows");
      if ((int)(v8 - objc_msgSend(a1, "numberOfFooterRows")) >= v4)
        return objc_msgSend(a1, "bodyCellStyle");
      else
        return objc_msgSend(a1, "footerRowCellStyle");
    }
    else
    {
      return objc_msgSend(a1, "headerRowCellStyle");
    }
  }
  return result;
}

uint64_t TSTTableGetTextStyleAtRow(uint64_t *a1, uint64_t a2, _BYTE *a3)
{
  signed int v4;
  uint64_t v6;
  uint64_t result;
  int v8;

  v4 = a2;
  v6 = TSTTableDataStoreHeaderInfoForRow(a1[6], a2, 0, 0);
  if (v6 && (result = *(_QWORD *)(v6 + 16)) != 0)
  {
    *a3 = 0;
  }
  else
  {
    if (a3)
      *a3 = 1;
    if (objc_msgSend(a1, "numberOfHeaderRows") <= v4)
    {
      v8 = objc_msgSend(a1, "numberOfRows");
      if ((int)(v8 - objc_msgSend(a1, "numberOfFooterRows")) >= v4)
        return objc_msgSend(a1, "bodyTextStyle");
      else
        return objc_msgSend(a1, "footerRowTextStyle");
    }
    else
    {
      return objc_msgSend(a1, "headerRowTextStyle");
    }
  }
  return result;
}

uint64_t TSTTableSetCellStyleAtColumn(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;

  v6 = TSTTableDataStoreHeaderInfoForColumn(*(_QWORD *)(a1 + 48), a3, 1, 1);
  if (!v6)
    return 2;
  v7 = v6;
  *(_QWORD *)(v6 + 8) = a2;
  if (*(double *)(v7 + 24) == 0.0
    && !*(_WORD *)(v7 + 34)
    && !*(_QWORD *)(v7 + 8)
    && !*(_QWORD *)(v7 + 16)
    && !*(_BYTE *)(v7 + 32))
  {
    TSTTableDataStoreRemoveColumnHeadersAtIndex(*(_QWORD *)(a1 + 48), a3, 1);
  }
  return 0;
}

uint64_t TSTTableSetTextStyleAtColumn(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;

  v6 = TSTTableDataStoreHeaderInfoForColumn(*(_QWORD *)(a1 + 48), a3, 1, 1);
  if (!v6)
    return 2;
  v7 = v6;
  *(_QWORD *)(v6 + 16) = a2;
  if (*(double *)(v7 + 24) == 0.0
    && !*(_WORD *)(v7 + 34)
    && !*(_QWORD *)(v7 + 8)
    && !*(_QWORD *)(v7 + 16)
    && !*(_BYTE *)(v7 + 32))
  {
    TSTTableDataStoreRemoveColumnHeadersAtIndex(*(_QWORD *)(a1 + 48), a3, 1);
  }
  return 0;
}

uint64_t TSTTableGetCellStyleAtColumn(uint64_t *a1, uint64_t a2, _BYTE *a3)
{
  unsigned int v4;
  uint64_t v6;

  v4 = a2;
  v6 = TSTTableDataStoreHeaderInfoForColumn(a1[6], a2, 0, 0);
  if (v6 && *(_QWORD *)(v6 + 8))
  {
    *a3 = 0;
    return *(_QWORD *)(v6 + 8);
  }
  else
  {
    if (a3)
      *a3 = 1;
    if (objc_msgSend(a1, "numberOfHeaderColumns") <= v4)
      return objc_msgSend(a1, "bodyCellStyle");
    else
      return objc_msgSend(a1, "headerColumnCellStyle");
  }
}

uint64_t TSTTableGetTextStyleAtColumn(uint64_t *a1, uint64_t a2, _BYTE *a3)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t result;

  v4 = a2;
  v6 = TSTTableDataStoreHeaderInfoForColumn(a1[6], a2, 0, 0);
  if (v6 && (result = *(_QWORD *)(v6 + 16)) != 0)
  {
    *a3 = 0;
  }
  else
  {
    if (a3)
      *a3 = 1;
    if (objc_msgSend(a1, "numberOfHeaderColumns") <= v4)
      return objc_msgSend(a1, "bodyTextStyle");
    else
      return objc_msgSend(a1, "headerColumnTextStyle");
  }
  return result;
}

uint64_t TSTTableDefaultCellStyleForCellID(void *a1, unsigned int a2)
{
  return objc_msgSend(a1, "defaultCellStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", a2));
}

uint64_t TSTTableCellStyleForCellWithEmptyStyleAtCellID(uint64_t *a1, unsigned int a2, char *a3)
{
  uint64_t CellStyleAtRow;
  uint64_t result;
  char v8;
  BOOL v9;
  __int16 v10;

  v10 = 0;
  CellStyleAtRow = TSTTableGetCellStyleAtRow(a1, (unsigned __int16)a2, (_BYTE *)&v10 + 1);
  result = TSTTableGetCellStyleAtColumn(a1, BYTE2(a2), &v10);
  v8 = v10;
  if (HIBYTE(v10))
    v9 = v10 == 0;
  else
    v9 = 1;
  if (v9)
  {
    if (!HIBYTE(v10))
    {
      result = CellStyleAtRow;
      v8 = 0;
    }
    if (a3)
      goto LABEL_12;
  }
  else
  {
    result = objc_msgSend(a1, "defaultCellStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", a2));
    if (a3)
    {
      v8 = 1;
LABEL_12:
      *a3 = v8;
    }
  }
  return result;
}

uint64_t TSTTableDefaultTextStyleForCellID(void *a1, unsigned int a2)
{
  return objc_msgSend(a1, "defaultTextStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", a2));
}

uint64_t TSTTableTextStyleForCellWithEmptyStyleAtCellID(uint64_t *a1, unsigned int a2, char *a3)
{
  uint64_t TextStyleAtRow;
  uint64_t result;
  char v8;
  BOOL v9;
  __int16 v10;

  v10 = 0;
  TextStyleAtRow = TSTTableGetTextStyleAtRow(a1, (unsigned __int16)a2, (_BYTE *)&v10 + 1);
  result = TSTTableGetTextStyleAtColumn(a1, BYTE2(a2), &v10);
  v8 = v10;
  if (HIBYTE(v10))
    v9 = v10 == 0;
  else
    v9 = 1;
  if (v9)
  {
    if (!HIBYTE(v10))
    {
      result = TextStyleAtRow;
      v8 = 0;
    }
    if (a3)
      goto LABEL_12;
  }
  else
  {
    result = objc_msgSend(a1, "defaultTextStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", a2));
    if (a3)
    {
      v8 = 1;
LABEL_12:
      *a3 = v8;
    }
  }
  return result;
}

uint64_t TSTCellStyleIsEqualToDefaultCellStyleForCellID(void *a1, void *a2, unsigned int a3)
{
  uint64_t v4;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;

  v4 = objc_msgSend(a1, "defaultCellStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", a3));
  if (v4)
  {
    if (a2)
      return objc_msgSend(a2, "isEqual:", v4);
  }
  else
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTCellStyleIsEqualToDefaultCellStyleForCellID(TSTTableModel *, TSTCellStyle *, TSTCellID)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2378, CFSTR("null cell style"));
    if (a2)
      return objc_msgSend(a2, "isEqual:", v4);
  }
  v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTCellStyleIsEqualToDefaultCellStyleForCellID(TSTTableModel *, TSTCellStyle *, TSTCellID)");
  objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2383, CFSTR("null style"));
  return 0;
}

uint64_t TSTCellStyleIsEqualToDefaultTextStyleForCellID(void *a1, void *a2, unsigned int a3)
{
  uint64_t v4;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;

  v4 = objc_msgSend(a1, "defaultTextStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", a3));
  if (v4)
  {
    if (a2)
      return objc_msgSend(a2, "isEqual:", v4);
  }
  else
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTCellStyleIsEqualToDefaultTextStyleForCellID(TSTTableModel *, TSWPParagraphStyle *, TSTCellID)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2392, CFSTR("null cell style"));
    if (a2)
      return objc_msgSend(a2, "isEqual:", v4);
  }
  v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTCellStyleIsEqualToDefaultTextStyleForCellID(TSTTableModel *, TSWPParagraphStyle *, TSTCellID)");
  objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2397, CFSTR("null style"));
  return 0;
}

uint64_t TSTTableSetCellStyleAtCellID(uint64_t a1, TSTCellStyle *a2, unsigned int a3)
{
  TSTCell *v6;
  UInt8 *v7;
  TSTCellStyle *mCellStyle;
  uint64_t v9;

  v6 = objc_alloc_init(TSTCell);
  v7 = TSTTableDataStoreCellStorageRefAtCellID(*(_QWORD *)(a1 + 48), a3);
  if (v7)
    -[TSTCell inflateFromStorageRef:dataStore:](v6, "inflateFromStorageRef:dataStore:", v7, *(_QWORD *)(a1 + 48));
  else
    v6->mPrivate.mCellStyleID = 0;
  mCellStyle = v6->mPrivate.mCellStyle;
  if (mCellStyle != a2)
  {

    v6->mPrivate.mCellStyle = a2;
    v6->mPrivate.mCellStyleID = 0;
  }
  v9 = TSTTableSetCellAtCellIDIgnoringFormula(a1, v6, a3);

  return v9;
}

uint64_t TSTTableSetTextStyleAtCellID(uint64_t a1, TSWPParagraphStyle *a2, unsigned int a3)
{
  TSTCell *v6;
  UInt8 *v7;
  TSWPParagraphStyle *mTextStyle;
  uint64_t v9;

  v6 = objc_alloc_init(TSTCell);
  v7 = TSTTableDataStoreCellStorageRefAtCellID(*(_QWORD *)(a1 + 48), a3);
  if (v7)
    -[TSTCell inflateFromStorageRef:dataStore:](v6, "inflateFromStorageRef:dataStore:", v7, *(_QWORD *)(a1 + 48));
  else
    v6->mPrivate.mTextStyleID = 0;
  mTextStyle = v6->mPrivate.mTextStyle;
  if (mTextStyle != a2)
  {

    v6->mPrivate.mTextStyle = a2;
    v6->mPrivate.mTextStyleID = 0;
  }
  v9 = TSTTableSetCellAtCellIDIgnoringFormula(a1, v6, a3);

  return v9;
}

uint64_t TSTTableGetCellStyleAtCellID(uint64_t *a1, unsigned int a2, char *a3)
{
  uint64_t v5;
  int CellStyleAtCellID;
  uint64_t result;
  BOOL v8;
  void *v9;
  uint64_t v10;

  v10 = 0;
  v5 = a2;
  CellStyleAtCellID = TSTTableDataStoreGetCellStyleAtCellID(a1[6], a2, &v10);
  result = v10;
  if (CellStyleAtCellID)
    v8 = 1;
  else
    v8 = v10 == 0;
  if (v8)
    return TSTTableCellStyleForCellWithEmptyStyleAtCellID(a1, v5, a3);
  if (a3)
  {
    v9 = (void *)objc_msgSend(a1, "defaultCellStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", v5));
    *a3 = objc_msgSend(v9, "isEqual:", v10);
    return v10;
  }
  return result;
}

TSWPParagraphStyle *TSTTableGetTextStyleAtCellID(uint64_t *a1, unsigned int a2, char *a3)
{
  uint64_t v5;
  int TextStyleAtCellID;
  TSWPParagraphStyle *result;
  BOOL v8;
  void *v9;
  TSWPParagraphStyle *v10;

  v10 = 0;
  v5 = a2;
  TextStyleAtCellID = TSTTableDataStoreGetTextStyleAtCellID(a1[6], a2, &v10);
  result = v10;
  if (TextStyleAtCellID)
    v8 = 1;
  else
    v8 = v10 == 0;
  if (v8)
    return (TSWPParagraphStyle *)TSTTableTextStyleForCellWithEmptyStyleAtCellID(a1, v5, a3);
  if (a3)
  {
    v9 = (void *)objc_msgSend(a1, "defaultTextStyleForTableArea:", objc_msgSend(a1, "tableAreaForCellID:", v5));
    *a3 = objc_msgSend(v9, "isEqual:", v10);
    return v10;
  }
  return result;
}

uint64_t TSTTableGetConditionalStyleSetAtCellID()
{
  return 0;
}

uint64_t TSTTableNumberOfCells(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 74) * *(unsigned __int16 *)(a1 + 72);
}

uint64_t TSTTableNumberOfPopulatedCells(uint64_t a1)
{
  return TSTTableDataStoreNumberOfPopulatedCells(*(_QWORD *)(a1 + 48));
}

uint64_t TSTTableNumberOfPopulatedCellsInRows(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  void *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  void *v11;
  uint64_t v12;
  uint64_t v13;

  v3 = a3;
  if (!(_DWORD)a3)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "UInt32 TSTTableNumberOfPopulatedCellsInRows(TSTTableModel *, TSURowIndex, TSUColumnRowCount)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2615, CFSTR("Invalid count argument in TSTTableNumberPopulatedCellsInColumns"));
  }
  v8 = *(unsigned __int16 *)(a1 + 72);
  v9 = v3 + a2;
  if (v8 <= a2 || v9 > v8)
  {
    v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "UInt32 TSTTableNumberOfPopulatedCellsInRows(TSTTableModel *, TSURowIndex, TSUColumnRowCount)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2616, CFSTR("Bounds violation in TSTTableNumberPopulatedCellsInColumns"));
  }
  if ((_DWORD)v3)
  {
    v3 = 0;
    do
    {
      v13 = TSTTableDataStoreHeaderInfoForRow(*(_QWORD *)(a1 + 48), (unsigned __int16)a2, 0, 0);
      if (v13)
        v3 = v3 + *(unsigned __int16 *)(v13 + 34);
      LOWORD(a2) = a2 + 1;
    }
    while (v9 > (unsigned __int16)a2);
  }
  return v3;
}

uint64_t TSTTableNumberOfPopulatedCellsInColumns(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  void *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  void *v11;
  uint64_t v12;
  uint64_t v13;

  v3 = a3;
  if (!(_DWORD)a3)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "UInt32 TSTTableNumberOfPopulatedCellsInColumns(TSTTableModel *, TSUColumnIndex, TSUColumnRowCount)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2632, CFSTR("Invalid count argument in TSTTableNumberPopulatedCellsInColumns"));
  }
  v8 = *(unsigned __int16 *)(a1 + 74);
  v9 = v3 + a2;
  if (a2 >= v8 || v9 > v8)
  {
    v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "UInt32 TSTTableNumberOfPopulatedCellsInColumns(TSTTableModel *, TSUColumnIndex, TSUColumnRowCount)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2633, CFSTR("Bounds violation in TSTTableNumberPopulatedCellsInColumns"));
  }
  if ((_DWORD)v3)
  {
    v3 = 0;
    do
    {
      v13 = TSTTableDataStoreHeaderInfoForColumn(*(_QWORD *)(a1 + 48), a2, 0, 0);
      if (v13)
        v3 = v3 + *(unsigned __int16 *)(v13 + 34);
      LOBYTE(a2) = a2 + 1;
    }
    while (v9 > a2);
  }
  return v3;
}

uint64_t TSTTableCellLeftOfCell(uint64_t *a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v8;
  unsigned __int8 v9;

  v2 = a2;
  v4 = a2 >> 24;
  v5 = TSTTableDataStoreMergeRangeAtCellID(a1[6], a2);
  v6 = v2;
  if ((_WORD)v5 != 0xFFFF)
  {
    v6 = v2;
    if ((v5 & 0xFF0000) != 0xFF0000)
    {
      if ((v5 & 0xFFFF00000000) == 0 || HIWORD(v5) == 0)
        v6 = v2;
      else
        v6 = v5;
    }
  }
  v8 = v6 >> 16;
  v9 = objc_msgSend(a1, "range") >> 16;
  while (v8 > v9)
  {
    LOBYTE(v8) = v8 - 1;
    if (!TSTHidingActionForColumn((uint64_t)a1, v8))
      return (v8 << 16) | ((_DWORD)v4 << 24) | (unsigned __int16)v2;
  }
  LODWORD(v4) = 0;
  LOBYTE(v8) = -1;
  LOWORD(v2) = -1;
  return (v8 << 16) | ((_DWORD)v4 << 24) | (unsigned __int16)v2;
}

uint64_t TSTTableMergeRangeAtCellID(uint64_t a1, unsigned int a2)
{
  return TSTTableDataStoreMergeRangeAtCellID(*(_QWORD *)(a1 + 48), a2);
}

BOOL TSTTableIsColumnHidden(uint64_t a1, uint64_t a2)
{
  return TSTHidingActionForColumn(a1, a2) != 0;
}

uint64_t TSTTableCellRightOfCell(uint64_t *a1, unint64_t a2)
{
  unsigned __int16 v2;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v9;
  unsigned int v10;

  v2 = a2;
  v4 = a2 >> 16;
  v5 = a2 >> 24;
  v6 = TSTTableDataStoreMergeRangeAtCellID(a1[6], a2);
  if ((_WORD)v6 != 0xFFFF && (v6 & 0xFF0000) != 0xFF0000 && HIWORD(v6) != 0 && (v6 & 0xFFFF00000000) != 0)
    LODWORD(v4) = HIDWORD(v6) + WORD1(v6) + 255;
  v9 = objc_msgSend(a1, "range");
  v10 = HIDWORD(v9) + WORD1(v9) + 255;
  while (v4 < v10)
  {
    LOBYTE(v4) = v4 + 1;
    if (!TSTHidingActionForColumn((uint64_t)a1, v4))
      return (v4 << 16) | ((_DWORD)v5 << 24) | v2;
  }
  LODWORD(v5) = 0;
  LOBYTE(v4) = -1;
  v2 = -1;
  return (v4 << 16) | ((_DWORD)v5 << 24) | v2;
}

uint64_t TSTTableCellAboveCell(uint64_t *a1, unint64_t a2)
{
  unsigned __int16 v2;
  unint64_t v4;
  unint64_t v5;
  unsigned __int16 v7;

  v2 = a2;
  v4 = a2 >> 16;
  v5 = TSTTableDataStoreMergeRangeAtCellID(a1[6], a2);
  if ((_WORD)v5 != 0xFFFF && (v5 & 0xFF0000) != 0xFF0000 && (v5 & 0xFFFF00000000) != 0 && HIWORD(v5) != 0)
    v2 = v5;
  v7 = objc_msgSend(a1, "range");
  while (v2 > v7)
  {
    if (!TSTHidingActionForRow((uint64_t)a1, --v2))
      return v2 | ((unsigned __int16)v4 << 16);
  }
  LOWORD(v4) = 255;
  v2 = -1;
  return v2 | ((unsigned __int16)v4 << 16);
}

BOOL TSTTableIsRowHidden(uint64_t a1, uint64_t a2)
{
  return TSTHidingActionForRow(a1, a2) != 0;
}

uint64_t TSTTableCellBelowCell(uint64_t *a1, unint64_t a2)
{
  unsigned __int16 v2;
  unint64_t v4;
  unint64_t v5;
  unint64_t v8;
  int v9;

  v2 = a2;
  v4 = a2 >> 16;
  v5 = TSTTableDataStoreMergeRangeAtCellID(a1[6], a2);
  if ((_WORD)v5 != 0xFFFF && (v5 & 0xFF0000) != 0xFF0000 && HIWORD(v5) != 0 && (v5 & 0xFFFF00000000) != 0)
    v2 = v5 + HIWORD(v5) - 1;
  v8 = objc_msgSend(a1, "range");
  v9 = v8 + HIWORD(v8) - 1;
  while (v2 < (unsigned __int16)v9)
  {
    if (!TSTHidingActionForRow((uint64_t)a1, ++v2))
      return v2 | ((unsigned __int16)v4 << 16);
  }
  LOWORD(v4) = 255;
  v2 = -1;
  return v2 | ((unsigned __int16)v4 << 16);
}

uint64_t TSTTableColumnLeftOfColumn(void *a1, unsigned __int8 a2)
{
  unsigned __int8 v4;

  v4 = objc_msgSend(a1, "range") >> 16;
  while (a2 > v4)
  {
    if (!TSTHidingActionForColumn((uint64_t)a1, --a2))
      return a2;
  }
  return -1;
}

uint64_t TSTTableColumnRightOfColumn(void *a1, unsigned __int8 a2)
{
  uint64_t v4;
  unsigned int v5;

  v4 = objc_msgSend(a1, "range");
  v5 = HIDWORD(v4) + WORD1(v4) + 255;
  while (a2 < v5)
  {
    if (!TSTHidingActionForColumn((uint64_t)a1, ++a2))
      return a2;
  }
  return -1;
}

uint64_t TSTTableRowAboveRow(void *a1, unsigned __int16 a2)
{
  unsigned __int16 v4;

  v4 = objc_msgSend(a1, "range");
  while (a2 > v4)
  {
    if (!TSTHidingActionForRow((uint64_t)a1, --a2))
      return a2;
  }
  return (unsigned __int16)-1;
}

uint64_t TSTTableRowBelowRow(void *a1, unsigned __int16 a2)
{
  unint64_t v4;
  int v5;

  v4 = objc_msgSend(a1, "range");
  v5 = v4 + HIWORD(v4) - 1;
  while (a2 < (unsigned __int16)v5)
  {
    if (!TSTHidingActionForRow((uint64_t)a1, ++a2))
      return a2;
  }
  return (unsigned __int16)-1;
}

double TSTTableHeightOfRow(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if ((_DWORD)a2 == 0xFFFF)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSTTableHeightOfRow(TSTTableModel *, TSURowIndex, BOOL *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2799, CFSTR("Bad row index!"));
  }
  v8 = TSTTableDataStoreHeaderInfoForRow(*(_QWORD *)(a1 + 48), a2, 0, 0);
  if (v8 && *(double *)(v8 + 24) != 0.0)
  {
    if (a3)
      *a3 = 0;
    v9 = v8 + 24;
  }
  else
  {
    if (a3)
      *a3 = 1;
    v9 = a1 + 96;
  }
  return *(double *)v9;
}

double TSTTableWidthOfColumn(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if ((_DWORD)a2 == 255)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSTTableWidthOfColumn(TSTTableModel *, TSUColumnIndex, BOOL *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2819, CFSTR("Bad column index!"));
  }
  v8 = TSTTableDataStoreHeaderInfoForColumn(*(_QWORD *)(a1 + 48), a2, 0, 0);
  if (v8 && *(double *)(v8 + 24) != 0.0)
  {
    if (a3)
      *a3 = 0;
    v9 = v8 + 24;
  }
  else
  {
    if (a3)
      *a3 = 1;
    v9 = a1 + 104;
  }
  return *(double *)v9;
}

uint64_t TSTTableSetHeightOfRow(uint64_t a1, uint64_t a2, double a3)
{
  void *v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v10;
  void *v11;
  uint64_t v12;

  if ((_DWORD)a2 == 0xFFFF)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableSetHeightOfRow(TSTTableModel *, TSURowIndex, CGFloat)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2839, CFSTR("Bad row index!"));
  }
  if (a3 < 8.0 && a3 != 0.0)
    a3 = 8.0;
  result = TSTTableDataStoreHeaderInfoForRow(*(_QWORD *)(a1 + 48), a2, 1, 1);
  v10 = result;
  if (!result)
  {
    v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableSetHeightOfRow(TSTTableModel *, TSURowIndex, CGFloat)");
    result = objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2849, CFSTR("invalid nil value for '%s'"), "hdr");
  }
  *(double *)(v10 + 24) = a3;
  if (*(double *)(v10 + 24) == 0.0
    && !*(_WORD *)(v10 + 34)
    && !*(_QWORD *)(v10 + 8)
    && !*(_QWORD *)(v10 + 16)
    && !*(_BYTE *)(v10 + 32))
  {
    return TSTTableDataStoreRemoveRowHeadersAtIndex(*(_QWORD *)(a1 + 48), a2, 1);
  }
  return result;
}

uint64_t TSTTableSetWidthOfColumn(uint64_t a1, uint64_t a2, double a3)
{
  void *v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v10;
  void *v11;
  uint64_t v12;

  if ((_DWORD)a2 == 255)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableSetWidthOfColumn(TSTTableModel *, TSUColumnIndex, CGFloat)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2860, CFSTR("Bad column index!"));
  }
  if (a3 < 8.0 && a3 != 0.0)
    a3 = 8.0;
  result = TSTTableDataStoreHeaderInfoForColumn(*(_QWORD *)(a1 + 48), a2, 1, 1);
  v10 = result;
  if (!result)
  {
    v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableSetWidthOfColumn(TSTTableModel *, TSUColumnIndex, CGFloat)");
    result = objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 2868, CFSTR("invalid nil value for '%s'"), "hdr");
  }
  *(double *)(v10 + 24) = a3;
  if (*(double *)(v10 + 24) == 0.0
    && !*(_WORD *)(v10 + 34)
    && !*(_QWORD *)(v10 + 8)
    && !*(_QWORD *)(v10 + 16)
    && !*(_BYTE *)(v10 + 32))
  {
    return TSTTableDataStoreRemoveColumnHeadersAtIndex(*(_QWORD *)(a1 + 48), a2, 1);
  }
  return result;
}

uint64_t TSTTableComputeDefaultRowHeight(double *a1)
{
  uint64_t result;
  double v3;
  double v4;
  double v5;

  result = TSTTableComputeDefaultFontHeight(a1, 0);
  v4 = v3;
  if (a1)
    v5 = a1[12];
  else
    v5 = 10.0;
  if (v4 > v5)
  {
    result = objc_msgSend(a1, "willModify");
    a1[12] = v4;
  }
  return result;
}

uint64_t TSTTableComputeDefaultFontHeight(void *a1, uint64_t a2)
{
  uint64_t result;
  void *v3;
  void *v4;

  result = objc_msgSend(a1, "defaultCellForTableArea:", a2);
  if (result)
  {
    v3 = *(void **)(result + 56);
    v4 = (void *)objc_msgSend(*(id *)(result + 40), "valueForProperty:", 904);
    TSWPFastCreateFontForStyle(0, v3, 0x64uLL);
    TSWPFontGetLineHeight();
    objc_msgSend(v4, "topInset");
    return objc_msgSend(v4, "bottomInset");
  }
  return result;
}

uint64_t TSTTableInsertRows(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result;

  objc_msgSend((id)a1, "willModify");
  result = TSTTableDataStoreInsertRows(*(_QWORD *)(a1 + 48), a2, a3, a4);
  if (!(_DWORD)result)
    *(_WORD *)(a1 + 72) += a3;
  return result;
}

uint64_t TSTTableInsertColumns(uint64_t a1, char a2, uint64_t a3, char a4)
{
  objc_msgSend((id)a1, "willModify");
  TSTTableDataStoreInsertColumns(*(TSTTableDataStore **)(a1 + 48), a2, a3, a4);
  *(_WORD *)(a1 + 74) += a3;
  return 0;
}

uint64_t TSTTableRemoveRows(uint64_t a1, unsigned int a2, uint64_t a3)
{
  TSTTableRemoveRowsIgnoringSize(a1, a2, a3, 0);
  return 0;
}

uint64_t TSTTableRemoveRowsIgnoringSize(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4)
{
  unsigned __int16 v6;
  void *v7;
  uint64_t v8;
  uint64_t v10;

  objc_msgSend((id)a1, "willModify");
  v10 = objc_msgSend((id)a1, "range");
  if (*(_WORD *)(a1 + 84))
  {
    v6 = a2;
    do
    {
      if (a3 + a2 <= v6)
        break;
      if (!*(_WORD *)(a1 + 88) && !*(_WORD *)(a1 + 92))
      {
        v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSUError TSTTableRemoveRowsIgnoringSize(TSTTableModel *, TSURowIndex, TSUColumnRowCount, BOOL)");
        objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3053, CFSTR("Either mNumberOfUserHiddenRows or mNumberOfFilteredRows should be larger than 0 when mNumberOfHiddenRows is larger than 0"));
      }
      if ((TSTHidingActionForRow(a1, v6) & 1) != 0)
      {
        --*(_WORD *)(a1 + 88);
        --*(_WORD *)(a1 + 84);
      }
      if ((TSTHidingActionForRow(a1, v6) & 2) != 0)
      {
        --*(_WORD *)(a1 + 92);
        --*(_WORD *)(a1 + 84);
      }
      ++v6;
    }
    while (*(_WORD *)(a1 + 84));
  }
  objc_msgSend((id)a1, "p_clearDataListEntriesInRange:ignoreSizeChecks:", v10 & 0xFFFFFFFF0000 | (a3 << 48) | a2, a4, v10);
  TSTTableDataStoreRemoveRows(*(TSTTableDataStore **)(a1 + 48), a2, a3);
  *(_WORD *)(a1 + 72) -= a3;
  return 0;
}

BOOL TSTTableIsRowHiddenForAction(uint64_t a1, uint64_t a2, int a3)
{
  return (TSTHidingActionForRow(a1, a2) & a3) != 0;
}

uint64_t TSTTableRemoveColumns(uint64_t a1, uint64_t a2, uint64_t a3)
{
  TSTTableRemoveColumnsIgnoringSize(a1, a2, a3, 0);
  return 0;
}

uint64_t TSTTableRemoveColumnsIgnoringSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unsigned __int8 v9;

  objc_msgSend((id)a1, "willModify");
  v8 = objc_msgSend((id)a1, "range");
  if (*(_WORD *)(a1 + 86))
  {
    v9 = a2;
    do
    {
      if ((int)a3 + (int)a2 <= v9)
        break;
      if (TSTHidingActionForColumn(a1, v9))
      {
        --*(_WORD *)(a1 + 90);
        --*(_WORD *)(a1 + 86);
      }
      ++v9;
    }
    while (*(_WORD *)(a1 + 86));
  }
  objc_msgSend((id)a1, "p_clearDataListEntriesInRange:ignoreSizeChecks:", v8 & 0xFFFF0000FF000000 | (a3 << 32) | ((unint64_t)a2 << 16) | (unsigned __int16)v8, a4);
  TSTTableDataStoreRemoveColumns(*(TSTTableDataStore **)(a1 + 48), a2, a3);
  *(_WORD *)(a1 + 74) -= a3;
  return 0;
}

void TSTTableUpdateMergeRegionsRightOrBelowAndIncludingIndex(uint64_t *a1, unsigned int a2, uint64_t a3, int a4, int a5)
{
  unint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  id v18;
  void *v19;
  uint64_t v20;
  unint64_t v21;
  BOOL v22;
  int v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unsigned __int16 v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char *v33;
  unint64_t *v34;
  uint64_t *v35;
  unint64_t v36;
  uint64_t *v37;
  uint64_t **v38;
  int v39;
  _BYTE v40[12];
  uint64_t *v41;
  uint64_t *v42;

  if (!a1 || !a3)
    return;
  v39 = a3;
  if (a4)
  {
    v9 = (unint64_t)a2 << 16;
    v10 = (unsigned __int16)(objc_msgSend(a1, "numberOfColumns") - a2);
    v11 = objc_msgSend(a1, "numberOfRows");
    if (v10 >= 0xFF)
      v12 = 255;
    else
      v12 = v10;
    v13 = v11 << 48;
    v14 = v12 << 32;
  }
  else
  {
    v15 = objc_msgSend(a1, "numberOfColumns");
    v16 = objc_msgSend(a1, "numberOfRows");
    v9 = a2;
    if (v15 >= 0xFF)
      v17 = 255;
    else
      v17 = v15;
    v14 = (unint64_t)(v16 - a2) << 48;
    v13 = v17 << 32;
  }
  v18 = TSTTableDataStoreMergeRangesForCellRange(a1[6], v14 | v13 | v9);
  *(_DWORD *)&v40[8] = 0;
  v41 = 0;
  v42 = 0;
  v19 = (void *)objc_msgSend(v18, "iterator");
  *(_QWORD *)v40 = a5 ^ 1u;
  v38 = &v42;
  while (objc_msgSend(v19, "hasNextMergeRegion", v38))
  {
    v20 = objc_msgSend(v19, "nextMergeRegion");
    v21 = v20;
    if (a4)
      v22 = 1;
    else
      v22 = a2 > (unsigned __int16)v20;
    if (v22)
      v23 = *(_DWORD *)v40;
    else
      v23 = 0;
    if (v23 != 1 || a4 == 1 && BYTE2(v20) >= a2)
    {
      TSTTableDataStoreUnmerge((id *)a1[6], v20);
      v24 = v21 >> 16;
      v25 = HIDWORD(v21);
      v26 = HIWORD(v21);
      if (a4)
      {
        if (a2 > BYTE2(v21) && a2 <= (BYTE4(v21) + BYTE2(v21) - 1))
          LOWORD(v25) = WORD2(v21) + v39;
        else
          LOBYTE(v24) = BYTE2(v21) + v39;
      }
      else
      {
        if (a2 <= (unsigned __int16)v21 || a2 > (unsigned __int16)(v21 + HIWORD(v21) - 1))
        {
          v27 = v21 + v39;
          goto LABEL_33;
        }
        v26 = (v26 + v39);
      }
      v27 = v21;
LABEL_33:
      v28 = v21 & 0xFF000000;
      if (v41 >= v42)
      {
        v30 = ((uint64_t)v41 - *(_QWORD *)&v40[4]) >> 3;
        if ((unint64_t)(v30 + 1) >> 61)
          std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
        v31 = ((uint64_t)v42 - *(_QWORD *)&v40[4]) >> 2;
        if (v31 <= v30 + 1)
          v31 = v30 + 1;
        if ((unint64_t)v42 - *(_QWORD *)&v40[4] >= 0x7FFFFFFFFFFFFFF8)
          v32 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v32 = v31;
        if (v32)
          v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>((uint64_t)v38, v32);
        else
          v33 = 0;
        v34 = (unint64_t *)&v33[8 * v30];
        *v34 = ((unint64_t)(unsigned __int16)v25 << 32) | (v26 << 48) | ((unint64_t)v24 << 16) | v27 | v28;
        v29 = (uint64_t *)(v34 + 1);
        v35 = v41;
        if (v41 != *(uint64_t **)&v40[4])
        {
          do
          {
            v36 = *--v35;
            *--v34 = v36;
          }
          while (v35 != *(uint64_t **)&v40[4]);
          v35 = *(uint64_t **)&v40[4];
        }
        *(_QWORD *)&v40[4] = v34;
        v42 = (uint64_t *)&v33[8 * v32];
        if (v35)
          operator delete(v35);
      }
      else
      {
        *v41 = ((unint64_t)(unsigned __int16)v25 << 32) | (v26 << 48) | ((unint64_t)v24 << 16) | v27 | v28;
        v29 = v41 + 1;
      }
      v41 = v29;
    }
  }
  v37 = *(uint64_t **)&v40[4];
  if (*(uint64_t **)&v40[4] != v41)
  {
    do
      TSTTableDataStoreMerge((_QWORD *)a1[6], *v37++);
    while (v37 != v41);
    v37 = *(uint64_t **)&v40[4];
  }
  if (v37)
    operator delete(v37);
}

void sub_217B996BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

id TSTTableMergeRangesForCellRange(uint64_t a1, uint64_t a2)
{
  return TSTTableDataStoreMergeRangesForCellRange(*(_QWORD *)(a1 + 48), a2);
}

uint64_t TSTTableUnmerge(uint64_t a1, uint64_t a2)
{
  return TSTTableDataStoreUnmerge(*(id **)(a1 + 48), a2);
}

uint64_t TSTTableMoveMergeRegionsWithColumnsOrRows(uint64_t *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  uint64_t v7;
  uint64_t v8;
  __int16 v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t result;
  void *v18;
  void *v19;
  void *v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  unsigned __int16 v39;
  uint64_t v40;
  __int16 v41;
  unsigned int v44;
  unsigned int v45;

  if (a3 >= a2)
    v7 = a3 - a2;
  else
    v7 = a2 - a3 + a4;
  if (a3 >= a2)
    v8 = a2;
  else
    v8 = a3;
  if (a3 >= a2)
    v9 = a4;
  else
    v9 = 0;
  if (a5)
  {
    v10 = (unint64_t)v8 << 16;
    v11 = objc_msgSend(a1, "numberOfRows");
    if ((unsigned __int16)v7 >= 0xFFu)
      v12 = 255;
    else
      v12 = (unsigned __int16)v7;
    v13 = v11 << 48;
    v14 = v12 << 32;
  }
  else
  {
    v15 = objc_msgSend(a1, "numberOfColumns");
    if (v15 >= 0xFF)
      v16 = 255;
    else
      v16 = v15;
    v14 = v7 << 48;
    v13 = v16 << 32;
    v10 = v8;
  }
  result = (uint64_t)TSTTableDataStoreMergeRangesForCellRange(a1[6], v13 | v14 | v10);
  if (result)
  {
    v18 = (void *)result;
    v19 = (void *)objc_msgSend((id)result, "iterator");
    if (objc_msgSend(v19, "hasNextMergeRegion"))
    {
      do
        TSTTableDataStoreUnmerge((id *)a1[6], objc_msgSend(v19, "nextMergeRegion"));
      while ((objc_msgSend(v19, "hasNextMergeRegion") & 1) != 0);
    }
    v20 = (void *)objc_msgSend(v18, "iterator");
    result = objc_msgSend(v20, "hasNextMergeRegion");
    if ((_DWORD)result)
    {
      v41 = a3 - v9 - a2;
      v44 = a4 + a2;
      v45 = v8 + (unsigned __int16)v7;
      v40 = a4;
      v21 = v8;
      do
      {
        v22 = objc_msgSend(v20, "nextMergeRegion", v40);
        v23 = v22;
        v24 = v22 >> 16;
        if (a5)
        {
          v25 = BYTE2(v22);
          if (BYTE2(v22) < v8)
          {
            v26 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableMoveMergeRegionsWithColumnsOrRows(TSTTableModel *, TSUColumnOrRowIndex, TSUColumnOrRowIndex, TSUColumnRowCount, TSTCommandDirection)");
            v27 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm");
            v28 = v8;
            LODWORD(v8) = v21;
            objc_msgSend(v26, "handleFailureInFunction:file:lineNumber:description:", v28, v27, 3223, CFSTR("Merged cell range started before first row moved."));
          }
          if (v25 + WORD2(v23) > v45)
          {
            v29 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableMoveMergeRegionsWithColumnsOrRows(TSTTableModel *, TSUColumnOrRowIndex, TSUColumnOrRowIndex, TSUColumnRowCount, TSTCommandDirection)");
            v30 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm");
            v31 = v8;
            LODWORD(v8) = v21;
            objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v31, v30, 3224, CFSTR("Merged cell range ended after last row moved."));
          }
          if (v25 < a2 || v25 >= v44)
          {
            if (a3 < a2)
              LOBYTE(v24) = v25 + a4;
            else
              LOBYTE(v24) = v24 - v40;
          }
          else
          {
            LOBYTE(v24) = v25 + v41;
          }
          v39 = v23;
        }
        else
        {
          v32 = (unsigned __int16)v22;
          if ((unsigned __int16)v22 < v8)
          {
            v8 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v33 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableMoveMergeRegionsWithColumnsOrRows(TSTTableModel *, TSUColumnOrRowIndex, TSUColumnOrRowIndex, TSUColumnRowCount, TSTCommandDirection)");
            v34 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm");
            v35 = (void *)v8;
            LODWORD(v8) = v21;
            objc_msgSend(v35, "handleFailureInFunction:file:lineNumber:description:", v33, v34, 3208, CFSTR("Merged cell range started before first row moved."));
          }
          if (v32 + HIWORD(v23) > v45)
          {
            v36 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableMoveMergeRegionsWithColumnsOrRows(TSTTableModel *, TSUColumnOrRowIndex, TSUColumnOrRowIndex, TSUColumnRowCount, TSTCommandDirection)");
            v37 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm");
            v38 = v8;
            LODWORD(v8) = v21;
            objc_msgSend(v36, "handleFailureInFunction:file:lineNumber:description:", v38, v37, 3209, CFSTR("Merged cell range ended after last row moved."));
          }
          if (v32 < a2 || v32 >= v44)
          {
            v39 = v32 - a4;
            if (a3 < a2)
              v39 = v32 + a4;
          }
          else
          {
            v39 = v32 + v41;
          }
        }
        TSTTableDataStoreMerge((_QWORD *)a1[6], v23 & 0xFFFFFFFFFF000000 | v39 | ((unint64_t)v24 << 16));
        result = objc_msgSend(v20, "hasNextMergeRegion");
      }
      while ((result & 1) != 0);
    }
  }
  return result;
}

uint64_t TSTTableMoveRows(uint64_t *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  objc_msgSend(a1, "willModify");
  TSTTableDataStoreMoveRows(a1[6], a2, a3, a4);
  return TSTTableMoveMergeRegionsWithColumnsOrRows(a1, a2, a3, a4, 0);
}

uint64_t TSTTableMoveColumns(uint64_t *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  objc_msgSend(a1, "willModify");
  TSTTableDataStoreMoveColumns(a1[6], a2, a3, a4);
  return TSTTableMoveMergeRegionsWithColumnsOrRows(a1, a2, a3, a4, 1);
}

void TSTTableSwapRows(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  objc_msgSend(a1, "willModify");
  TSTTableDataStoreSwapRows(a1[6], a2, a3);
}

uint64_t TSTHidingActionForRow(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  void *v9;
  uint64_t v10;

  if ((_DWORD)a2 == 0xFFFF)
    return 0;
  if (*(_WORD *)(a1 + 84))
  {
    result = TSTTableDataStoreHeaderInfoForRow(*(_QWORD *)(a1 + 48), a2, 0, 0);
    if (result)
      return *(unsigned __int8 *)(result + 32);
  }
  else
  {
    if (*(_WORD *)(a1 + 88) || *(_WORD *)(a1 + 92))
    {
      v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler", v5, v4, v3, v2, v6, v7);
      v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTHidingAction TSTHidingActionForRow(TSTTableModel *, TSURowIndex)");
      objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3279, CFSTR("Both mNumberOfUserHiddenRows and mNumberOfFilteredRows should equal to 0 when mNumberOfHiddenRows is equal to 0"));
    }
    return 0;
  }
  return result;
}

uint64_t TSTHidingActionForColumn(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  void *v3;
  uint64_t v4;

  if ((_DWORD)a2 == 255)
    return 0;
  if (*(_WORD *)(a1 + 86))
  {
    result = TSTTableDataStoreHeaderInfoForColumn(*(_QWORD *)(a1 + 48), a2, 0, 0);
    if (result)
      return *(unsigned __int8 *)(result + 32);
  }
  else
  {
    if (*(_WORD *)(a1 + 90))
    {
      v3 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v4 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTHidingAction TSTHidingActionForColumn(TSTTableModel *, TSUColumnIndex)");
      objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3300, CFSTR("mNumberOfUserHiddenColumns should equal to 0 when mNumberOfHiddenColumns is equal to 0"));
    }
    return 0;
  }
  return result;
}

uint64_t TSTTableNumHiddenRowsInCellRange(uint64_t a1, uint64_t a2)
{
  unsigned __int16 v2;
  unsigned int v3;
  unsigned __int16 v5;

  v2 = a2;
  v3 = (unsigned __int16)(HIWORD(a2) + a2);
  if (v3 <= (unsigned __int16)a2)
  {
    return 0;
  }
  else
  {
    v5 = 0;
    do
    {
      if (TSTHidingActionForRow(a1, v2))
        ++v5;
      ++v2;
    }
    while (v3 > v2);
  }
  return v5;
}

uint64_t TSTTableNumHiddenColumnsInCellRange(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  unsigned int v3;
  unsigned __int16 v5;

  v2 = a2 >> 16;
  v3 = (BYTE2(a2) + BYTE4(a2));
  if (v3 <= BYTE2(a2))
  {
    return 0;
  }
  else
  {
    v5 = 0;
    do
    {
      if (TSTHidingActionForColumn(a1, v2))
        ++v5;
      LOBYTE(v2) = v2 + 1;
    }
    while (v3 > v2);
  }
  return v5;
}

TSTEphemeralCellMap *TSTEphemeralCellMapForOrderedCellIDs(uint64_t a1, int *a2, int a3)
{
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  TSTEphemeralCellMap *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  int v14;
  int v15;
  int v16;
  unint64_t v17;
  unsigned int v18;
  unsigned __int8 v19;
  unsigned int v20;
  BOOL v21;
  int v22;
  unsigned __int16 v23;
  unint64_t v24;
  TSTCellIterator *v25;
  int v26;
  char v28[4];
  unsigned int v29;
  uint64_t v30;

  if (!a2)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTEphemeralCellMap *TSTEphemeralCellMapForOrderedCellIDs(TSTTableModel *, TSTCellID *, int)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3425, CFSTR("No cell id array given to TSTEphemeralCellMapForOrderedCellIDs!"));
  }
  if (a3 <= 0)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTEphemeralCellMap *TSTEphemeralCellMapForOrderedCellIDs(TSTTableModel *, TSTCellID *, int)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3426, CFSTR("Need at least one cell ID in TSTEphemeralCellMapForOrderedCellIDs."));
  }
  v10 = -[TSTEphemeralCellMap initWithCapacity:]([TSTEphemeralCellMap alloc], "initWithCapacity:", a3);
  v11 = *a2;
  v12 = a2[a3 - 1];
  v13 = v12 >> 16;
  v14 = v12 & 0xFF000000;
  v15 = 0x10000;
  v16 = 1;
  if (*(_WORD *)a2 == 0xFFFF || (v11 & 0xFF0000) == 0xFF0000)
  {
    LODWORD(v17) = a2[a3 - 1];
  }
  else
  {
    v17 = v11 | 0x1000100000000;
    if ((_WORD)v12 == 0xFFFF || (v12 & 0xFF0000) == 0xFF0000)
    {
      v13 = v17 >> 16;
      v14 = v11 & 0xFF000000;
    }
    else
    {
      if ((unsigned __int16)*a2 == (unsigned __int16)v12)
      {
        v18 = WORD1(v11);
        if (BYTE2(v11) <= BYTE2(v12) && BYTE2(v11) >= BYTE2(v12))
        {
          v14 = v11 & 0xFF000000;
          v15 = 0x10000;
          v13 = v17 >> 16;
          goto LABEL_28;
        }
      }
      else
      {
        v18 = WORD1(v11);
      }
      v14 = 0;
      if (BYTE2(v12) <= BYTE2(v11))
        v19 = BYTE2(a2[a3 - 1]);
      else
        v19 = BYTE2(*a2);
      v20 = (unsigned __int16)a2[a3 - 1];
      if (BYTE2(v12) >= v18)
        LOBYTE(v18) = BYTE2(a2[a3 - 1]);
      v21 = v20 >= (unsigned __int16)v11;
      if (v20 <= (unsigned __int16)v11)
        v22 = a2[a3 - 1];
      else
        v22 = *a2;
      LOWORD(v17) = v22;
      if (v21)
        LODWORD(v11) = a2[a3 - 1];
      LOBYTE(v13) = v19;
      v23 = v18 - v19 + 1;
      v15 = (((_DWORD)v11 - v22) << 16) + 0x10000;
      v16 = v23;
    }
  }
LABEL_28:
  v24 = v14 & 0xFF000000 | ((unint64_t)(v15 | v16) << 32) | ((unint64_t)v13 << 16) | (unsigned __int16)v17;
  v25 = -[TSTCellIterator initWithTableModel:range:]([TSTCellIterator alloc], "initWithTableModel:range:", a1, v24);
  if (a3 >= 1)
  {
    v26 = 0;
    do
    {
      if (!TSTCellIteratorGetNextCell(v25, v28))
        break;
      if (((v29 ^ a2[v26]) & 0xFFFFFF) == 0)
      {
        v24 = v24 & 0xFFFFFFFF00000000 | v29;
        -[TSTEphemeralCellMap addCell:andCellID:](v10, "addCell:andCellID:", v30, v24);
        ++v26;
      }
    }
    while (v26 < a3);
  }

  return v10;
}

BOOL TSTTableIsColumnHiddenForAction(uint64_t a1, uint64_t a2, int a3)
{
  return (TSTHidingActionForColumn(a1, a2) & a3) != 0;
}

BOOL TSTTableHasRowHiddenForActionInRange(_WORD *a1, unint64_t a2, int a3)
{
  unsigned __int16 v4;
  unint64_t v6;
  void *v7;
  uint64_t v8;
  char v9;
  unsigned int v10;
  _BOOL8 v11;

  if (!a1[42])
    return 0;
  v4 = a2;
  v6 = HIWORD(a2);
  if (!a1[44] && !a1[46])
  {
    v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTTableHasRowHiddenForActionInRange(TSTTableModel *, TSTCellRange, TSTHidingAction)");
    objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3587, CFSTR("Either mNumberOfUserHiddenRows or mNumberOfFilteredRows should be larger than 0 when mNumberOfHiddenRows is larger than 0"));
  }
  v9 = 0;
  v10 = v6 + v4;
  do
  {
    v11 = v10 > v4;
    if (v10 <= v4)
      break;
    if ((TSTHidingActionForRow((uint64_t)a1, v4) & a3) != 0)
      v9 = 1;
    ++v4;
  }
  while ((v9 & 1) == 0);
  return v11;
}

uint64_t TSTTableHasRowShownInRange(_WORD *a1, unint64_t a2)
{
  unsigned __int16 v2;
  unint64_t v4;
  void *v5;
  uint64_t v6;
  char v7;
  unsigned int v8;
  _BOOL8 v9;

  if (!a1[42])
    return 1;
  v2 = a2;
  v4 = HIWORD(a2);
  if (!a1[44] && !a1[46])
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTTableHasRowShownInRange(TSTTableModel *, TSTCellRange)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3603, CFSTR("Either mNumberOfUserHiddenRows or mNumberOfFilteredRows should be larger than 0 when mNumberOfHiddenRows is larger than 0"));
  }
  v7 = 0;
  v8 = v4 + v2;
  do
  {
    v9 = v8 > v2;
    if (v8 <= v2)
      break;
    if (!TSTHidingActionForRow((uint64_t)a1, v2))
      v7 = 1;
    ++v2;
  }
  while ((v7 & 1) == 0);
  return v9;
}

BOOL TSTTableHasColumnHiddenForActionInRange(uint64_t a1, unint64_t a2, int a3)
{
  unsigned __int8 v4;
  unint64_t v6;
  unint64_t v7;
  void *v8;
  uint64_t v9;
  char v10;
  unsigned int v11;
  _BOOL8 v12;

  if (!*(_WORD *)(a1 + 86))
    return 0;
  v4 = BYTE2(a2);
  v6 = a2 >> 16;
  v7 = HIDWORD(a2);
  if (!*(_WORD *)(a1 + 90))
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTTableHasColumnHiddenForActionInRange(TSTTableModel *, TSTCellRange, TSTHidingAction)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3620, CFSTR("mNumberOfUserHiddenColumns should be larger than 0 when mNumberOfHiddenColumns is larger than 0"));
  }
  v10 = 0;
  v11 = v4 + (unsigned __int16)v7;
  do
  {
    v12 = v11 > v6;
    if (v11 <= v6)
      break;
    if ((TSTHidingActionForColumn(a1, v6) & a3) != 0)
      v10 = 1;
    LOBYTE(v6) = v6 + 1;
  }
  while ((v10 & 1) == 0);
  return v12;
}

uint64_t TSTTableHasColumnShownInRange(uint64_t a1, unint64_t a2)
{
  unsigned __int8 v2;
  unint64_t v4;
  unint64_t v5;
  void *v6;
  uint64_t v7;
  char v8;
  unsigned int v9;
  _BOOL8 v10;

  if (!*(_WORD *)(a1 + 86))
    return 1;
  v2 = BYTE2(a2);
  v4 = a2 >> 16;
  v5 = HIDWORD(a2);
  if (!*(_WORD *)(a1 + 90))
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTTableHasColumnShownInRange(TSTTableModel *, TSTCellRange)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3636, CFSTR("mNumberOfUserHiddenColumns should be larger than 0 when mNumberOfHiddenColumns is larger than 0"));
  }
  v8 = 0;
  v9 = v2 + (unsigned __int16)v5;
  do
  {
    v10 = v9 > v4;
    if (v9 <= v4)
      break;
    if (!TSTHidingActionForColumn(a1, v4))
      v8 = 1;
    LOBYTE(v4) = v4 + 1;
  }
  while ((v8 & 1) == 0);
  return v10;
}

uint64_t TSTTableHasCellRangeHidden(_WORD *a1, unint64_t a2)
{
  unint64_t v4;
  void *v5;
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;
  unsigned __int16 v9;
  uint64_t result;

  if (!a1[43] && !a1[42])
    return 0;
  v4 = HIDWORD(a2);
  if (!a1[45] && !a1[44] && !a1[46])
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTTableHasCellRangeHidden(TSTTableModel *, TSTCellRange)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3654, CFSTR("mNumberOfUserHiddenColumns, mNumberOfUserHiddenRows or mNumberOfFilteredRows should be larger than 0 when mNumberOfHiddenColumns or mNumberOfHiddenColumns is larger than 0"));
  }
  if (!(_WORD)v4)
    return 1;
  v7 = a2 >> 16;
  v8 = BYTE2(a2) + (unsigned __int16)v4;
  while (1)
  {
    if (!TSTHidingActionForColumn((uint64_t)a1, v7))
    {
      v9 = a2;
      if (HIWORD(a2))
        break;
    }
LABEL_13:
    LOBYTE(v7) = v7 + 1;
    if (v8 <= v7)
      return 1;
  }
  while (1)
  {
    result = TSTHidingActionForRow((uint64_t)a1, v9);
    if (!(_DWORD)result)
      return result;
    if ((HIWORD(a2) + (unsigned __int16)a2) <= ++v9)
      goto LABEL_13;
  }
}

uint64_t TSTTableStringForCellAtCellID(uint64_t a1, uint64_t a2, int a3)
{
  UInt8 *v5;
  unsigned int *Element;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  TSTCell *v10;
  uint64_t v11;

  if (a2)
    return NSStringFromNativeTSTCell(a2);
  v5 = TSTTableDataStoreCellStorageRefAtCellID(*(_QWORD *)(a1 + 48), a3);
  if (!v5)
    return 0;
  if (v5[2] << 8 == 768)
  {
    if ((v5[4] & 0x10) != 0)
    {
      Element = (unsigned int *)TSTCellStorageGetElement((uint64_t)v5, 16);
      if (!Element)
      {
        v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageStringID(TSTCellStorage *)");
        objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 401, CFSTR("Can't get string ID storage element!"));
      }
      v9 = *Element;
      if ((_DWORD)v9)
        return TSTTableDataStoreGetStringForKey(*(_QWORD *)(a1 + 48), v9);
    }
    return 0;
  }
  v10 = -[TSTCell initWithStorageRef:dataStore:]([TSTCell alloc], "initWithStorageRef:dataStore:", v5, *(_QWORD *)(a1 + 48));
  v11 = NSStringFromNativeTSTCell((uint64_t)v10);

  return v11;
}

uint64_t TSTTableGetFontColorForCell(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  TSWPParagraphStyle *TextStyleAtCellID;
  uint64_t result;

  if (!a2 || (TextStyleAtCellID = *(TSWPParagraphStyle **)(a2 + 56)) == 0)
    TextStyleAtCellID = TSTTableGetTextStyleAtCellID(a1, a3, 0);
  result = -[TSSStyle valueForProperty:](TextStyleAtCellID, "valueForProperty:", 18);
  if (!result)
    return objc_msgSend(MEMORY[0x24BEB3C40], "blackColor");
  return result;
}

uint64_t TSTTableRangeOfTableWithMerges(uint64_t a1)
{
  return TSTTableDataStoreRangeOfTableWithMerges(*(_QWORD *)(a1 + 48));
}

void *TSTTableMergeRangesPartiallyIntersectCellRange(uint64_t a1, uint64_t a2)
{
  return TSTTableDataStoreMergeRangesPartiallyIntersectCellRange(*(_QWORD *)(a1 + 48), a2);
}

id TSTTableCreateMergeRangesForCellRange(uint64_t a1, uint64_t a2)
{
  return TSTTableDataStoreCreateMergeRangesForCellRange(*(_QWORD *)(a1 + 48), a2);
}

unint64_t TSTTableExpandCellRangeToCoverMergedCells(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  unint64_t v4;
  void *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  __int16 v13;
  __int16 v14;
  unsigned int v15;
  unint64_t v16;
  void *v17;
  uint64_t v18;

  v2 = a2;
  if (a1)
  {
    v4 = a2;
    do
    {
      v5 = (void *)objc_msgSend(TSTTableDataStoreMergeRangesForCellRange(*(_QWORD *)(a1 + 48), v2), "iterator");
      if (objc_msgSend(v5, "hasNextMergeRegion"))
      {
        v4 = v2;
        do
        {
          v6 = objc_msgSend(v5, "nextMergeRegion");
          if ((_WORD)v6 == 0xFFFF
            || (v6 & 0xFF0000) == 0xFF0000
            || (v7 = HIWORD(v6)) == 0
            || (v6 & 0xFFFF00000000) == 0)
          {
            v8 = v4 >> 16;
            v12 = v4 & 0xFF000000;
            v9 = HIDWORD(v4);
            LOWORD(v6) = v4;
            v7 = HIWORD(v4);
          }
          else if ((_WORD)v4 == 0xFFFF || (v4 & 0xFF0000) == 0xFF0000 || !HIWORD(v4) || (v4 & 0xFFFF00000000) == 0)
          {
            v8 = v6 >> 16;
            v12 = v6 & 0xFF000000;
            v9 = HIDWORD(v6);
          }
          else if ((unsigned __int16)v6 <= (unsigned __int16)v4
                 && (unsigned __int16)(v6 + HIWORD(v6) - 1) >= (unsigned __int16)v4
                 && (v8 = v6 >> 16, BYTE2(v4) >= BYTE2(v6))
                 && (v9 = HIDWORD(v6), v10 = (BYTE4(v6) + BYTE2(v6) - 1), v10 >= BYTE2(v4))
                 && v10 >= (BYTE4(v4) + BYTE2(v4) - 1)
                 && (unsigned __int16)(v6 + HIWORD(v6) - 1) >= (unsigned __int16)(v4 + HIWORD(v4) - 1))
          {
            v12 = v6 & 0xFF000000;
          }
          else if ((unsigned __int16)v4 <= (unsigned __int16)v6
                 && (unsigned __int16)(v4 + HIWORD(v4) - 1) >= (unsigned __int16)v6
                 && (v8 = v4 >> 16, BYTE2(v6) >= BYTE2(v4))
                 && (v9 = HIDWORD(v4), v11 = (BYTE4(v4) + BYTE2(v4) - 1), v11 >= BYTE2(v6))
                 && v11 >= (BYTE4(v6) + BYTE2(v6) - 1)
                 && (unsigned __int16)(v4 + HIWORD(v4) - 1) >= (unsigned __int16)(v6 + HIWORD(v6) - 1))
          {
            v12 = v4 & 0xFF000000;
            LOWORD(v6) = v4;
            v7 = HIWORD(v4);
          }
          else
          {
            v12 = 0;
            if (BYTE2(v6) >= BYTE2(v4))
              LOWORD(v8) = BYTE2(v4);
            else
              LOWORD(v8) = BYTE2(v6);
            v13 = v6;
            if ((unsigned __int16)v6 >= (unsigned __int16)v4)
              v13 = v4;
            v14 = v6 + HIWORD(v6);
            LOWORD(v6) = v13;
            LODWORD(v9) = (BYTE4(v6) + BYTE2(v6) - 1);
            if (v9 <= (BYTE4(v4) + BYTE2(v4) - 1))
              LOWORD(v9) = (BYTE4(v4) + BYTE2(v4) - 1);
            v15 = (unsigned __int16)(v14 - 1);
            if (v15 <= (unsigned __int16)(v4 + HIWORD(v4) - 1))
              LOWORD(v15) = v4 + HIWORD(v4) - 1;
            LOWORD(v9) = v9 - v8 + 1;
            v7 = (unsigned __int16)(v15 - v13 + 1);
          }
          v4 = ((unint64_t)(unsigned __int16)v9 << 32) | (v7 << 48) | v12 & 0xFF000000 | ((unint64_t)v8 << 16) | (unsigned __int16)v6;
        }
        while ((objc_msgSend(v5, "hasNextMergeRegion") & 1) != 0);
      }
      v16 = v4 ^ v2;
      v2 = v4;
    }
    while ((v16 & 0xFFFFFFFF00FFFFFFLL) != 0);
  }
  else
  {
    v17 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v18 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTCellRange TSTTableExpandCellRangeToCoverMergedCells(TSTTableModel *, TSTCellRange)");
    objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableModel.mm"), 3863, CFSTR("No table model!  Aborting expandCellRangeToCoverMergedCells:.  This is a bug in the calling code."));
    return v2;
  }
  return v4;
}

uint64_t TSTTableGetBackgroundFill()
{
  return 0;
}

uint64_t TSTTableGetBodyFill(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "bodyCellStyle"), "valueForProperty:", 898);
}

uint64_t TSTTableGetHeaderColumnsFill(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "headerColumnCellStyle"), "valueForProperty:", 898);
}

uint64_t TSTTableGetHeaderRowsFill(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "headerRowCellStyle"), "valueForProperty:", 898);
}

uint64_t TSTTableGetFooterRowsFill(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "footerRowCellStyle"), "valueForProperty:", 898);
}

uint64_t TSTTableGetRowFill(uint64_t *a1, uint64_t a2)
{
  void *CellStyleAtRow;
  char v4;

  v4 = 0;
  CellStyleAtRow = (void *)TSTTableGetCellStyleAtRow(a1, a2, &v4);
  if (v4)
    return 0;
  else
    return objc_msgSend(CellStyleAtRow, "valueForProperty:", 898);
}

uint64_t TSTTableGetColumnFill(uint64_t *a1, uint64_t a2)
{
  void *CellStyleAtColumn;
  char v4;

  v4 = 0;
  CellStyleAtColumn = (void *)TSTTableGetCellStyleAtColumn(a1, a2, &v4);
  if (v4)
    return 0;
  else
    return objc_msgSend(CellStyleAtColumn, "valueForProperty:", 898);
}

id TSTTableGetDefaultHorizontalBorderStroke(TSTTableModel *a1)
{
  if (-[TSSStyle intValueForProperty:](-[TSTTableModel tableStyle](a1, "tableStyle"), "intValueForProperty:", 796))
    return -[TSSStyle valueForProperty:](-[TSTTableModel tableStyle](a1, "tableStyle"), "valueForProperty:", 771);
  else
    return 0;
}

id TSTTableGetDefaultVerticalBorderStroke(TSTTableModel *a1)
{
  if (-[TSSStyle intValueForProperty:](-[TSTTableModel tableStyle](a1, "tableStyle"), "intValueForProperty:", 796))
    return -[TSSStyle valueForProperty:](-[TSTTableModel tableStyle](a1, "tableStyle"), "valueForProperty:", 772);
  else
    return 0;
}

uint64_t TSTTableGetDefaultBorderStroke(void *a1)
{
  if (objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 796))
    return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 771);
  else
    return 0;
}

uint64_t TSTTableGetDefaultBodyColumnStroke(void *a1)
{
  if (objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 788))
    return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 774);
  else
    return 0;
}

uint64_t TSTTableGetDefaultBodyRowStroke(void *a1)
{
  if (objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 789))
    return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 773);
  else
    return 0;
}

uint64_t TSTTableGetDefaultHeaderColumnBorderStroke(void *a1)
{
  if (objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 796))
    return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 778);
  else
    return 0;
}

uint64_t TSTTableGetDefaultHeaderColumnBodyColumnStroke(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 777);
}

uint64_t TSTTableGetDefaultHeaderColumnBodyRowStroke(void *a1)
{
  if (objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 793))
    return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 776);
  else
    return 0;
}

uint64_t TSTTableGetDefaultHeaderColumnSeparatorStroke(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 775);
}

uint64_t TSTTableGetDefaultHeaderRowBorderStroke(void *a1)
{
  if (objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 796))
    return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 782);
  else
    return 0;
}

uint64_t TSTTableGetDefaultHeaderRowBodyColumnStroke(void *a1)
{
  if (objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 791))
    return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 780);
  else
    return 0;
}

uint64_t TSTTableGetDefaultHeaderRowBodyRowStroke(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 781);
}

uint64_t TSTTableGetDefaultHeaderRowSeparatorStroke(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 779);
}

uint64_t TSTTableGetDefaultFooterRowBorderStroke(void *a1)
{
  if (objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 796))
    return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 786);
  else
    return 0;
}

uint64_t TSTTableGetDefaultFooterRowBodyColumnStroke(void *a1)
{
  if (objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "intValueForProperty:", 795))
    return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 784);
  else
    return 0;
}

uint64_t TSTTableGetDefaultFooterRowBodyRowStroke(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 785);
}

uint64_t TSTTableGetDefaultFooterRowSeparatorStroke(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "tableStyle"), "valueForProperty:", 783);
}

void *TSTTableGetDefaultStrokesForColumn(uint64_t *a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  void *result;
  void *v9;
  char v10;

  if (a3)
    *a3 = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  if (a4)
    *a4 = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  v10 = 0;
  result = (void *)TSTTableGetCellStyleAtColumn(a1, a2, &v10);
  if (result && !v10)
  {
    v9 = result;
    if (a3)
    {
      result = (void *)objc_msgSend(result, "valueForProperty:", 901);
      if (result)
        *a3 = result;
    }
    if (a4)
    {
      result = (void *)objc_msgSend(v9, "valueForProperty:", 902);
      if (result)
        *a4 = result;
    }
  }
  return result;
}

void *TSTTableGetDefaultStrokesForRow(uint64_t *a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  void *result;
  void *v9;
  char v10;

  if (a3)
    *a3 = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  if (a4)
    *a4 = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  v10 = 0;
  result = (void *)TSTTableGetCellStyleAtRow(a1, a2, &v10);
  if (result && !v10)
  {
    v9 = result;
    if (a3)
    {
      result = (void *)objc_msgSend(result, "valueForProperty:", 899);
      if (result)
        *a3 = result;
    }
    if (a4)
    {
      result = (void *)objc_msgSend(v9, "valueForProperty:", 900);
      if (result)
        *a4 = result;
    }
  }
  return result;
}

uint64_t p_setStrokeResult(uint64_t a1, int a2, void *a3, uint64_t *a4)
{
  uint64_t v6;
  uint64_t result;

  v6 = objc_msgSend(a3, "valueForProperty:", a1);
  result = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  if (!a2)
    goto LABEL_6;
  if (v6 == result)
  {
    result = 0;
    goto LABEL_6;
  }
  result = v6;
  if (v6)
LABEL_6:
    *a4 = result;
  return result;
}

uint64_t TSTTableGetStrokesForCellID(uint64_t a1, unsigned int a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  unint64_t v14;

  v14 = TSTTableDataStoreMergeRangeAtCellID(*(_QWORD *)(a1 + 48), a2);
  return TSTTableGetStrokesForCellIDWithMergeRange(a1, a2, v14, a3, a4, a5, a6, a7);
}

uint64_t TSTTableGetStrokesForCellIDWithMergeRange(uint64_t a1, int a2, unint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t a8)
{
  uint64_t result;
  unsigned int *v17;
  void *v18;
  uint64_t *v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  BOOL v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  UInt8 *v33;
  UInt8 *v34;
  unsigned int *Element;
  uint64_t v36;
  uint64_t StyleForKey;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  int v57;
  void *v58;
  uint64_t v59;

  result = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  if (a8)
  {
    v17 = (unsigned int *)(a8 + 8);
    v18 = *(void **)(a8 + 40);
    if (v18)
    {
      v59 = result;
      v19 = a7;
      v55 = a5;
      v20 = *v17;
      goto LABEL_4;
    }
  }
  else
  {
    v59 = result;
    v32 = *(_QWORD *)(a1 + 48);
    v33 = TSTTableDataStoreCellStorageRefAtCellID(v32, a2);
    if (v33)
    {
      v34 = v33;
      if ((v33[4] & 2) != 0)
      {
        Element = (unsigned int *)TSTCellStorageGetElement((uint64_t)v33, 2);
        if (!Element)
        {
          v58 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v56 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageStyleID(TSTCellStorage *)");
          objc_msgSend(v58, "handleFailureInFunction:file:lineNumber:description:", v56, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 182, CFSTR("Can't get style ID storage element!"));
        }
        v36 = *Element;
        if ((_DWORD)v36)
        {
          StyleForKey = TSTTableDataListGetStyleForKey(objc_msgSend(*(id *)(v32 + 72), "object"), v36);
          if (StyleForKey)
          {
            v18 = (void *)StyleForKey;
            v19 = a7;
            v55 = a5;
            v20 = *((_DWORD *)v34 + 1);
LABEL_4:
            v21 = (v20 >> 20) & 1;
            v22 = (v20 >> 21) & 1;
            v23 = (v20 >> 22) & 1;
            v24 = (v20 & 0x8000000) == 0;
            if ((v20 & 0x8000000) != 0)
              v25 = (v20 >> 23) & 1;
            else
              v25 = 1;
            v57 = v25;
            if (v24)
              v26 = 1;
            else
              v26 = v23;
            if (v24)
              v27 = 1;
            else
              v27 = v22;
            if (v24)
              v28 = 1;
            else
              v28 = v21;
            v29 = objc_msgSend(v18, "valueForProperty:", 899);
            v30 = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
            if (v28)
            {
              if (v29 == v30)
              {
                v30 = 0;
              }
              else
              {
                v30 = v29;
                v31 = v59;
                if (!v29)
                {
LABEL_31:
                  v41 = objc_msgSend(v18, "valueForProperty:", 900);
                  v42 = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
                  if (v27)
                  {
                    if (v41 == v42)
                    {
                      v42 = 0;
                    }
                    else
                    {
                      v42 = v41;
                      v39 = v59;
                      if (!v41)
                      {
LABEL_37:
                        v43 = objc_msgSend(v18, "valueForProperty:", 901);
                        v44 = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
                        if (v26)
                        {
                          if (v43 == v44)
                          {
                            v44 = 0;
                          }
                          else
                          {
                            v44 = v43;
                            v45 = v59;
                            if (!v43)
                            {
LABEL_43:
                              v46 = v45;
                              v47 = objc_msgSend(v18, "valueForProperty:", 902);
                              result = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
                              v38 = v31;
                              a7 = v19;
                              if (v57)
                              {
                                if (v47 == result)
                                {
                                  result = 0;
                                }
                                else
                                {
                                  result = v47;
                                  if (!v47)
                                  {
                                    a5 = v55;
                                    result = v59;
LABEL_49:
                                    v40 = v46;
                                    goto LABEL_50;
                                  }
                                }
                              }
                              a5 = v55;
                              goto LABEL_49;
                            }
                          }
                        }
                        v45 = v44;
                        goto LABEL_43;
                      }
                    }
                  }
                  v39 = v42;
                  goto LABEL_37;
                }
              }
            }
            v31 = v30;
            goto LABEL_31;
          }
        }
      }
    }
    result = v59;
  }
  v38 = result;
  v39 = result;
  v40 = result;
LABEL_50:
  if ((_WORD)a3 != 0xFFFF && (a3 & 0xFF0000) != 0xFF0000 && HIWORD(a3) && (a3 & 0xFFFF00000000) != 0)
  {
    v48 = a2 & 0xFF0000 | (unsigned __int16)(a2 - 1);
    if (!(_WORD)a2)
      v48 = 0xFFFFFFLL;
    if ((unsigned __int16)a3 <= (unsigned __int16)v48
      && (unsigned __int16)(a3 + HIWORD(a3) - 1) >= (unsigned __int16)v48)
    {
      v49 = v48 >> 16;
      if (v49 >= BYTE2(a3) && v49 <= (BYTE4(a3) + BYTE2(a3) - 1))
        v38 = 0;
    }
    v50 = (unsigned __int16)(a2 + 1) | a2 & 0xFF0000u;
    if ((~(_WORD)a2 & 0xFFFE) == 0)
      v50 = 0xFFFFFFLL;
    if ((unsigned __int16)a3 <= (unsigned __int16)v50
      && (unsigned __int16)(a3 + HIWORD(a3) - 1) >= (unsigned __int16)v50)
    {
      v51 = v50 >> 16;
      if (v51 >= BYTE2(a3) && v51 <= (BYTE4(a3) + BYTE2(a3) - 1))
        v39 = 0;
    }
    v52 = 0xFFFFFFLL;
    if ((*(_QWORD *)&a2 & 0xFF0000) != 0)
      v52 = (a2 + 16711680) & 0xFF0000 | (unsigned __int16)a2;
    if ((unsigned __int16)a3 <= (unsigned __int16)v52
      && (unsigned __int16)(a3 + HIWORD(a3) - 1) >= (unsigned __int16)v52)
    {
      v53 = v52 >> 16;
      if (v53 >= BYTE2(a3) && v53 <= (BYTE4(a3) + BYTE2(a3) - 1))
        v40 = 0;
    }
    v54 = (a2 + 0x10000) & 0xFF0000 | (unsigned __int16)a2;
    if ((~a2 & 0xFE0000) == 0)
      v54 = 0xFFFFFFLL;
    if ((unsigned __int16)a3 <= (unsigned __int16)v54
      && (unsigned __int16)(a3 + HIWORD(a3) - 1) >= (unsigned __int16)v54
      && (v54 >> 16) >= BYTE2(a3)
      && (v54 >> 16) <= (BYTE4(a3) + BYTE2(a3) - 1))
    {
      result = 0;
    }
  }
  if (a4)
    *a4 = v38;
  if (a6)
    *a6 = v39;
  if (a7)
    *a7 = result;
  if (a5)
    *a5 = v40;
  return result;
}

BOOL TSTTableHasCellID(uint64_t a1, int a2)
{
  return *(unsigned __int16 *)(a1 + 72) > (unsigned __int16)a2
      && *(unsigned __int16 *)(a1 + 74) > BYTE2(a2);
}

void p_insertObjectInDictionary(const void *key, const void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

double TSTWidthHeightCache_Private::WHCCol::getMaxWidth(TSTWidthHeightCache_Private::WHCCol *this)
{
  double result;

  if (*(_QWORD *)this != *((_QWORD *)this + 1))
    return **(double **)this;
  result = -1.0;
  if (!*((_BYTE *)this + 24))
    return 0.0;
  return result;
}

uint64_t TSTWidthHeightCache_Private::WHCCol::setWidth(TSTWidthHeightCache_Private::WHCCol *this, int a2, double a3)
{
  char *v4;
  unint64_t v5;
  double v7;
  char *v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  _OWORD *v12;
  uint64_t result;
  char *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  _DWORD *v22;
  _DWORD *v23;
  uint64_t v24;
  int v25;
  _DWORD *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  char *v36;
  _DWORD *v37;
  uint64_t v38;
  int v39;
  __int128 v40;

  *(double *)&v40 = a3;
  DWORD2(v40) = (__int16)a2;
  v5 = *(_QWORD *)this;
  v4 = (char *)*((_QWORD *)this + 1);
  if (*(char **)this == v4)
  {
    if (!*((_BYTE *)this + 24))
    {
      v14 = (char *)this + 16;
      v15 = *((_QWORD *)this + 2);
      if (v5 < v15)
      {
        *(_OWORD *)v5 = v40;
        v12 = (_OWORD *)(v5 + 16);
        goto LABEL_37;
      }
      v16 = v15 - v5;
      v17 = v16 >> 3;
      if ((unint64_t)(v16 >> 3) <= 1)
        v17 = 1;
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0)
        v18 = 0xFFFFFFFFFFFFFFFLL;
      else
        v18 = v17;
      v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)v14, v18);
      v21 = &v19[16 * v20];
      *(_OWORD *)v19 = v40;
      v12 = v19 + 16;
      v23 = *(_DWORD **)this;
      v22 = (_DWORD *)*((_QWORD *)this + 1);
      if (v22 != *(_DWORD **)this)
      {
        do
        {
          v24 = *((_QWORD *)v22 - 2);
          v22 -= 4;
          v25 = v22[2];
          *((_QWORD *)v19 - 2) = v24;
          v19 -= 16;
          *((_DWORD *)v19 + 2) = v25;
        }
        while (v22 != v23);
        v22 = *(_DWORD **)this;
      }
      *(_QWORD *)this = v19;
      *((_QWORD *)this + 1) = v12;
      *((_QWORD *)this + 2) = v21;
      if (!v22)
        goto LABEL_37;
      v26 = v22;
LABEL_36:
      operator delete(v26);
      goto LABEL_37;
    }
    return 0;
  }
  while (*(_DWORD *)(v5 + 8) != a2)
  {
    v5 += 16;
    if ((char *)v5 == v4)
    {
      v5 = *((_QWORD *)this + 1);
      break;
    }
  }
  if ((char *)v5 == v4)
  {
LABEL_10:
    v9 = *(char **)this;
    v10 = (uint64_t)&v4[-*(_QWORD *)this];
    if (*((double *)v4 - 2) <= a3)
    {
      if (v10 == 160)
      {
        *((_QWORD *)this + 1) = v4 - 16;
        v4 -= 16;
      }
      while (v9 < v4 && *(double *)v9 > a3)
        v9 += 16;
      std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::insert((uint64_t)this, v9, (char *)&v40);
      return 1;
    }
    if ((unint64_t)v10 > 0x9F)
    {
      result = 1;
      *((_BYTE *)this + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)this + 24))
    {
      v11 = *((_QWORD *)this + 2);
      if ((unint64_t)v4 < v11)
      {
        *(_OWORD *)v4 = v40;
        v12 = v4 + 16;
LABEL_37:
        *((_QWORD *)this + 1) = v12;
        return 1;
      }
      v27 = v10 >> 4;
      v28 = (v10 >> 4) + 1;
      v29 = v11 - (_QWORD)v9;
      v30 = (uint64_t)(v11 - (_QWORD)v9) >> 3;
      if (v30 <= v28)
        v31 = v27 + 1;
      else
        v31 = v30;
      if (v29 >= 0x7FFFFFFFFFFFFFF0)
        v32 = 0xFFFFFFFFFFFFFFFLL;
      else
        v32 = v31;
      v33 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)this + 16, v32);
      v34 = &v33[16 * v27];
      v36 = &v33[16 * v35];
      *(_OWORD *)v34 = v40;
      v12 = v34 + 16;
      v37 = *(_DWORD **)this;
      v26 = (_DWORD *)*((_QWORD *)this + 1);
      if (v26 != *(_DWORD **)this)
      {
        do
        {
          v38 = *((_QWORD *)v26 - 2);
          v26 -= 4;
          v39 = v26[2];
          *((_QWORD *)v34 - 2) = v38;
          v34 -= 16;
          *((_DWORD *)v34 + 2) = v39;
        }
        while (v26 != v37);
        v26 = *(_DWORD **)this;
      }
      *(_QWORD *)this = v34;
      *((_QWORD *)this + 1) = v12;
      *((_QWORD *)this + 2) = v36;
      if (!v26)
        goto LABEL_37;
      goto LABEL_36;
    }
    return 0;
  }
  if (*(double *)v5 != a3)
  {
    v7 = *((double *)v4 - 2);
    v8 = &v4[-v5 - 16];
    if (v4 != (char *)(v5 + 16))
      memmove((void *)v5, (const void *)(v5 + 16), (size_t)(v8 - 4));
    v4 = &v8[v5];
    *((_QWORD *)this + 1) = &v8[v5];
    if (v7 > a3)
      return 0;
    goto LABEL_10;
  }
  return 1;
}

char *std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::insert(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _OWORD *v11;
  __int128 v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  void *__p;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 4) + 1;
    if (v14 >> 60)
      abort();
    v15 = __src - v13;
    v16 = (__src - v13) >> 4;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 3 > v14)
      v14 = v17 >> 3;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0)
      v18 = 0xFFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v31 = a1 + 16;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>(a1 + 16, v18);
    else
      v19 = 0;
    v21 = &v19[16 * v16];
    __p = v19;
    v28 = v21;
    v29 = v21;
    v30 = &v19[16 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v23 = 1;
        else
          v23 = v15 >> 3;
        v24 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>(v8, v23);
        v21 = &v24[16 * (v23 >> 2)];
        __p = v24;
        v28 = v21;
        v30 = &v24[16 * v25];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v22 = v16 + 2;
        if (v16 >= -1)
          v22 = v16 + 1;
        v21 -= 16 * (v22 >> 1);
        v28 = v21;
      }
    }
    *(_OWORD *)v21 = *(_OWORD *)v3;
    v29 = v21 + 16;
    v4 = (char *)std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v29 != v28)
      v29 += (v28 - v29 + 15) & 0xFFFFFFFFFFFFFFF0;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_OWORD *)__src = *(_OWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 16;
  }
  else
  {
    v9 = __src + 16;
    v10 = v6 - 16;
    v11 = *(_OWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_OWORD *)v10;
      v10 += 16;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-16 * ((v6 - v9) >> 4)], __src, v6 - v9 - 4);
    if (v4 <= v3)
      v3 += 16 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    v20 = *(_QWORD *)v3;
    *((_DWORD *)v4 + 2) = *((_DWORD *)v3 + 2);
    *(_QWORD *)v4 = v20;
  }
  return v4;
}

void sub_217B9E494(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t TSTWidthHeightCache_Private::WHCCol::resetInvalid(uint64_t this)
{
  *(_BYTE *)(this + 24) = 0;
  return this;
}

uint64_t *TSTWidthHeightCache_Private::WHCCol::resetAfter(uint64_t **this, int a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *result;
  _QWORD v6[4];
  int v7;

  v3 = *this;
  v4 = this[1];
  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 3221225472;
  v6[2] = ___ZN27TSTWidthHeightCache_Private6WHCCol10resetAfterEj_block_invoke;
  v6[3] = &__block_descriptor_36_e28_B16__0r__WHCWidthBucket_dI_8l;
  v7 = a2;
  result = std::remove_if[abi:nn180100]<std::__wrap_iter<TSTWidthHeightCache_Private::WHCWidthBucket *>,BOOL({block_pointer})(TSTWidthHeightCache_Private::WHCWidthBucket const&)>(v3, v4, (uint64_t)v6);
  if (this[1] != result)
    this[1] = result;
  return result;
}

uint64_t *std::remove_if[abi:nn180100]<std::__wrap_iter<TSTWidthHeightCache_Private::WHCWidthBucket *>,BOOL({block_pointer})(TSTWidthHeightCache_Private::WHCWidthBucket const&)>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t *i;
  uint64_t v7;

  if (a1 == a2)
    return a2;
  v5 = (uint64_t)a1;
  while (((*(uint64_t (**)(uint64_t, uint64_t))(a3 + 16))(a3, v5) & 1) == 0)
  {
    v5 += 16;
    if ((uint64_t *)v5 == a2)
      return a2;
  }
  if ((uint64_t *)v5 == a2)
    return a2;
  for (i = (uint64_t *)(v5 + 16); i != a2; i += 2)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t *))(a3 + 16))(a3, i) & 1) == 0)
    {
      v7 = *i;
      *(_DWORD *)(v5 + 8) = *((_DWORD *)i + 2);
      *(_QWORD *)v5 = v7;
      v5 += 16;
    }
  }
  return (uint64_t *)v5;
}

BOOL ___ZN27TSTWidthHeightCache_Private6WHCCol10resetAfterEj_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 32) <= *(_DWORD *)(a2 + 8);
}

uint64_t TSTWidthHeightCache_Private::WHCCol::resetAll(uint64_t this)
{
  *(_QWORD *)(this + 8) = *(_QWORD *)this;
  *(_BYTE *)(this + 24) = 0;
  return this;
}

uint64_t *TSTWidthHeightCache_Private::WHCCol::removeRowDataInRange(uint64_t **this, int a2, int a3)
{
  uint64_t *result;
  uint64_t *v6;
  _QWORD v8[4];
  int v9;
  int v10;

  result = *this;
  v6 = this[1];
  if (v6 != result)
  {
    v8[0] = MEMORY[0x24BDAC760];
    v8[1] = 3221225472;
    v8[2] = ___ZN27TSTWidthHeightCache_Private6WHCCol20removeRowDataInRangeEjj_block_invoke;
    v8[3] = &__block_descriptor_40_e28_B16__0r__WHCWidthBucket_dI_8l;
    v9 = a2;
    v10 = a3;
    result = std::remove_if[abi:nn180100]<std::__wrap_iter<TSTWidthHeightCache_Private::WHCWidthBucket *>,BOOL({block_pointer})(TSTWidthHeightCache_Private::WHCWidthBucket const&)>(result, v6, (uint64_t)v8);
    if (this[1] != result)
      this[1] = result;
  }
  return result;
}

BOOL ___ZN27TSTWidthHeightCache_Private6WHCCol20removeRowDataInRangeEjj_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v2;

  v2 = *(_DWORD *)(a2 + 8);
  return *(_DWORD *)(a1 + 32) <= v2 && v2 < *(_DWORD *)(a1 + 36);
}

unint64_t *TSTWidthHeightCache_Private::WHCCol::moveRowIds(unint64_t *this, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v10;
  unsigned int v11;

  v4 = a3 + a2;
  v5 = *this;
  v6 = this[1];
  if (a4 <= a2)
  {
    while (v5 < v6)
    {
      v11 = *(_DWORD *)(v5 + 8);
      if (v11 >= a2 && v11 < v4)
        *(_DWORD *)(v5 + 8) = a4 - a2 + v11;
      v5 += 16;
    }
  }
  else
  {
    for (; v5 < v6; v5 += 16)
    {
      v7 = *(_DWORD *)(v5 + 8);
      if (v7 < a2 || v7 >= v4)
      {
        if (v4 > v7 || v7 >= a4)
          continue;
        v10 = v7 - a3;
      }
      else
      {
        v10 = a4 - v4 + v7;
      }
      *(_DWORD *)(v5 + 8) = v10;
    }
  }
  return this;
}

uint64_t *TSTWidthHeightCache_Private::WHCCol::insertRows(uint64_t *this, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[2];
  uint64_t (*v6)(uint64_t, uint64_t);
  void *v7;
  int v8;
  int v9;

  v3 = *this;
  v4 = this[1];
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 3221225472;
  v6 = ___ZN27TSTWidthHeightCache_Private6WHCCol10insertRowsEjj_block_invoke;
  v7 = &__block_descriptor_40_e27_v16__0__WHCWidthBucket_dI_8l;
  v8 = a3;
  v9 = a2;
  while (v3 != v4)
  {
    this = (uint64_t *)v6((uint64_t)v5, v3);
    v3 += 16;
  }
  return this;
}

uint64_t ___ZN27TSTWidthHeightCache_Private6WHCCol10insertRowsEjj_block_invoke(uint64_t result, uint64_t a2)
{
  unsigned int v2;

  v2 = *(_DWORD *)(a2 + 8);
  if (v2 >= *(_DWORD *)(result + 32))
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 36) + v2;
  return result;
}

double TSTWidthHeightCache_Private::WHCRow::getMaxHeight(TSTWidthHeightCache_Private::WHCRow *this)
{
  uint64_t v1;
  double result;

  v1 = *((_QWORD *)this + 16);
  if (v1 != *((_QWORD *)this + 17))
    return *(double *)v1;
  result = -1.0;
  if (!*((_BYTE *)this + 160))
    return 0.0;
  return result;
}

uint64_t TSTWidthHeightCache_Private::WHCRow::setHeight(TSTWidthHeightCache_Private::WHCRow *this, unsigned int a2, double a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  TSTWidthHeightCache_Private::WHCRow *v16;
  unsigned int v17;
  char v18;
  unint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  char *v31;
  _WORD *v32;
  _WORD *v33;
  uint64_t v34;
  __int16 v35;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  __n128 v40;

  v6 = TSTWidthHeightCache_NibArray::NibArray<8u>::get((uint64_t)this, a2);
  if ((v6 - 16) <= 0xFFFFFFFD)
  {
    v8 = *((_QWORD *)this + 16);
    v7 = *((_QWORD *)this + 17);
    v9 = v8;
    if (v8 != v7)
    {
      while (*(unsigned __int8 *)(v9 + 8) != v6)
      {
        v9 += 16;
        if (v9 == v7)
        {
          v9 = *((_QWORD *)this + 17);
          break;
        }
      }
    }
    if (*(double *)v9 == a3)
      return 1;
    v10 = v8 + 16 * ((v9 - v8) >> 4);
    v11 = *(_BYTE *)(v10 + 9) - 1;
    *(_BYTE *)(v10 + 9) = v11;
    if (!v11)
    {
      v12 = *(unsigned __int8 *)(v10 + 8);
      if (v12 >= 0xE)
        goto LABEL_31;
      *((_QWORD *)this + 19) &= ~(1 << v12);
      v13 = v7 - (v9 + 16);
      if (v7 != v9 + 16)
        memmove((void *)v9, (const void *)(v9 + 16), v13 - 6);
      *((_QWORD *)this + 17) = v9 + v13;
    }
    TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)this, a2, 15);
  }
  v14 = *((_QWORD *)this + 16);
  v15 = *((_QWORD *)this + 17);
  if (v14 == v15)
  {
    if (!*((_BYTE *)this + 160))
    {
      v19 = *((_QWORD *)this + 18);
      *((_QWORD *)this + 19) |= 1uLL;
      if (v14 >= v19)
      {
        v26 = v19 - v14;
        v27 = v26 >> 3;
        if ((unint64_t)(v26 >> 3) <= 1)
          v27 = 1;
        if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0)
          v28 = 0xFFFFFFFFFFFFFFFLL;
        else
          v28 = v27;
        v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)this + 144, v28);
        v31 = &v29[16 * v30];
        *(double *)v29 = a3;
        *((_WORD *)v29 + 4) = 256;
        v20 = v29 + 16;
        v33 = (_WORD *)*((_QWORD *)this + 16);
        v32 = (_WORD *)*((_QWORD *)this + 17);
        if (v32 != v33)
        {
          do
          {
            v34 = *((_QWORD *)v32 - 2);
            v32 -= 8;
            v35 = v32[4];
            *((_QWORD *)v29 - 2) = v34;
            v29 -= 16;
            *((_WORD *)v29 + 4) = v35;
          }
          while (v32 != v33);
          v32 = (_WORD *)*((_QWORD *)this + 16);
        }
        *((_QWORD *)this + 16) = v29;
        *((_QWORD *)this + 17) = v20;
        *((_QWORD *)this + 18) = v31;
        if (v32)
          operator delete(v32);
      }
      else
      {
        *(double *)v14 = a3;
        *(_WORD *)(v14 + 8) = 256;
        v20 = (char *)(v14 + 16);
      }
      *((_QWORD *)this + 17) = v20;
      v16 = this;
      v17 = a2;
      v18 = 0;
      goto LABEL_47;
    }
    goto LABEL_26;
  }
  if (*(double *)(v15 - 16) <= a3)
  {
    if (v14 >= v15)
    {
      v21 = (char *)*((_QWORD *)this + 16);
    }
    else
    {
      v21 = (char *)*((_QWORD *)this + 16);
      while (*(double *)v21 > a3)
      {
        v21 += 16;
        if ((unint64_t)v21 >= v15)
          goto LABEL_28;
      }
      if (*(double *)v21 == a3)
      {
        TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)this, a2, v21[8]);
        ++v21[9];
        return 1;
      }
      if (v15 - v14 == 224)
      {
        TSTWidthHeightCache_NibArray::NibArray<8u>::setValueToValue((uint64_t)this, *(unsigned __int8 *)(v15 - 8), 14, *(unsigned __int8 *)(v15 - 7), 0x100u);
        v37 = *((_QWORD *)this + 17);
        v38 = v37 - 16;
        if (v21 == (char *)(v37 - 16))
        {
          TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)this, a2, v21[8]);
          *(double *)v21 = a3;
          v22 = 1;
          v21[9] = 1;
          return v22;
        }
        v39 = *(unsigned __int8 *)(v37 - 8);
        if (v39 >= 0xE)
          goto LABEL_31;
        *((_QWORD *)this + 19) &= ~(1 << v39);
        *((_QWORD *)this + 17) = v38;
      }
    }
LABEL_28:
    v23 = 0;
    v24 = *((_QWORD *)this + 19);
    while (((v24 >> v23) & 1) != 0)
    {
      if (++v23 == 14)
        goto LABEL_31;
    }
    v25 = v23;
    if (v23 < 0xEu)
    {
      v22 = 1;
      *((_QWORD *)this + 19) = v24 | (1 << v23);
      v40.n128_f64[0] = a3;
      v40.n128_u8[8] = v23;
      v40.n128_u8[9] = 1;
      std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::insert((uint64_t)this + 128, v21, &v40);
      TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)this, a2, v25);
      return v22;
    }
LABEL_31:
    abort();
  }
  if (v15 - v14 == 224)
  {
    v16 = this;
    v17 = a2;
    v18 = 14;
LABEL_47:
    TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)v16, v17, v18);
    return 1;
  }
  v21 = (char *)*((_QWORD *)this + 17);
  if (!*((_BYTE *)this + 160))
    goto LABEL_28;
LABEL_26:
  TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)this, a2, 14);
  return 0;
}

uint64_t TSTWidthHeightCache_NibArray::NibArray<8u>::get(uint64_t a1, unsigned int a2)
{
  unsigned __int8 v2;
  void *v4;
  uint64_t v5;

  v2 = a2;
  if (a2 >= 0x100)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "uint8_t TSTWidthHeightCache_NibArray::NibArray<8>::get(uint) [log2NumElements = 8]");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 58, CFSTR("getting an element past the end of the nibble array."));
  }
  return (*(unsigned __int8 *)(a1 + (v2 >> 1)) >> (4 * (v2 & 1))) & 0xF;
}

uint64_t TSTWidthHeightCache_NibArray::NibArray<8u>::set(uint64_t result, unsigned int a2, char a3)
{
  unsigned __int8 v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;

  v4 = a2;
  v5 = result;
  if (a2 >= 0x100)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::set(uint, uint8_t) [log2NumElements = 8]");
    result = objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 50, CFSTR("setting an element past the end of the nibble array."));
  }
  *(_BYTE *)(v5 + (v4 >> 1)) = (0xF0u >> (4 * (v4 & 1))) & *(_BYTE *)(v5 + (v4 >> 1)) | ((a3 & 0xF) << (4 * (v4 & 1)));
  return result;
}

uint64_t TSTWidthHeightCache_NibArray::NibArray<8u>::setValueToValue(uint64_t a1, int a2, char a3, uint64_t a4, unsigned int a5)
{
  void *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int v14;

  if (a5 >= 0x101)
  {
    v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "uint TSTWidthHeightCache_NibArray::NibArray<8>::setValueToValue(uint8_t, uint8_t, uint, uint) [log2NumElements = 8]");
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 96, CFSTR("hint exceeds array length"));
  }
  if (a5 >= 0x100)
    v12 = 256;
  else
    v12 = a5;
  if (!v12)
    return 0;
  v13 = 0;
  v14 = 0;
  while (1)
  {
    if (TSTWidthHeightCache_NibArray::NibArray<8u>::get(a1, v14) == a2)
    {
      TSTWidthHeightCache_NibArray::NibArray<8u>::set(a1, v14, a3);
      v13 = (v13 + 1);
      if ((_DWORD)v13 == (_DWORD)a4)
        break;
    }
    if (v12 == ++v14)
      return v13;
  }
  return a4;
}

char *std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::insert(uint64_t a1, char *__src, __n128 *a3)
{
  char *v4;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;
  _BYTE *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  unint64_t v20;
  void *__p;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;

  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 16);
  v7 = a1 + 16;
  v8 = v9;
  if ((unint64_t)v6 >= v9)
  {
    v14 = *(_BYTE **)a1;
    v15 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 4) + 1;
    if (v15 >> 60)
      abort();
    v16 = (__src - v14) >> 4;
    v17 = v8 - (_QWORD)v14;
    if (v17 >> 3 > v15)
      v15 = v17 >> 3;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0)
      v18 = 0xFFFFFFFFFFFFFFFLL;
    else
      v18 = v15;
    v26 = v7;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>(v7, v18);
    else
      v19 = 0;
    __p = v19;
    v23 = &v19[16 * v16];
    v24 = v23;
    v25 = &v19[16 * v18];
    std::__split_buffer<TSTWidthHeightCache_Private::WHCHeightBucket>::push_back((__n128 **)&__p, a3);
    v4 = (char *)std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v24 != v23)
      v24 += (v23 - v24 + 15) & 0xFFFFFFFFFFFFFFF0;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(__n128 *)__src = *a3;
    *(_QWORD *)(a1 + 8) = __src + 16;
  }
  else
  {
    v10 = __src + 16;
    v11 = v6 - 16;
    v12 = v6;
    while (v11 < v6)
    {
      v13 = *(_OWORD *)v11;
      v11 += 16;
      *(_OWORD *)v12 = v13;
      v12 += 16;
    }
    *(_QWORD *)(a1 + 8) = v12;
    if (v6 != v10)
      memmove(&v6[-16 * ((v6 - v10) >> 4)], __src, v6 - v10 - 6);
    v20 = a3->n128_u64[0];
    *((_WORD *)v4 + 4) = a3->n128_u16[4];
    *(_QWORD *)v4 = v20;
  }
  return v4;
}

void sub_217B9EF68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t TSTWidthHeightCache_Private::WHCRow::getNumInvalid(TSTWidthHeightCache_Private::WHCRow *this)
{
  return *((unsigned __int8 *)this + 160);
}

uint64_t TSTWidthHeightCache_Private::WHCRow::getNextInvalid(TSTWidthHeightCache_Private::WHCRow *this, uint64_t a2)
{
  char v2;

  if (a2 <= 0xFF)
  {
    v2 = 4 * a2;
    do
    {
      if (*((unsigned __int8 *)this + ((unint64_t)a2 >> 1)) >> (v2 & 4) == 14)
        break;
      a2 = (a2 + 1);
      v2 += 4;
    }
    while ((_DWORD)a2 != 256);
  }
  return a2;
}

uint64_t TSTWidthHeightCache_Private::WHCRow::resetInvalid(TSTWidthHeightCache_Private::WHCRow *this)
{
  return TSTWidthHeightCache_NibArray::NibArray<8u>::setValueToValue((uint64_t)this, 14, 15, *((unsigned __int8 *)this + 160), 0x100u);
}

void TSTWidthHeightCache_Private::WHCRow::resetAll(TSTWidthHeightCache_Private::WHCRow *this)
{
  __int128 v2;
  char *v3;
  int v4;

  *(_QWORD *)&v2 = -1;
  *((_QWORD *)&v2 + 1) = -1;
  *((_OWORD *)this + 6) = v2;
  *((_OWORD *)this + 7) = v2;
  *((_OWORD *)this + 4) = v2;
  *((_OWORD *)this + 5) = v2;
  *((_OWORD *)this + 2) = v2;
  *((_OWORD *)this + 3) = v2;
  *(_OWORD *)this = v2;
  *((_OWORD *)this + 1) = v2;
  v3 = (char *)this + 152;
  v4 = 0;
  std::__fill_n[abi:nn180100]<false,std::__bitset<1ul,14ul>>((uint64_t)&v3, 0xEuLL);
  *((_QWORD *)this + 17) = *((_QWORD *)this + 16);
  *((_BYTE *)this + 160) = 0;
}

uint64_t TSTWidthHeightCache_Private::WHCRow::resetAfter(uint64_t this, unsigned int a2, unsigned int a3)
{
  _QWORD *v4;
  unsigned int v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unsigned __int8 v8;
  int64_t v9;

  if (a2 <= a3)
  {
    v4 = (_QWORD *)this;
    while (1)
    {
      v5 = a2;
      this = TSTWidthHeightCache_NibArray::NibArray<8u>::get((uint64_t)v4, a2);
      if ((_DWORD)this == 14)
        goto LABEL_14;
      if ((_DWORD)this != 15)
        break;
LABEL_15:
      LOBYTE(a2) = v5 + 1;
      if (a3 < (v5 + 1))
        return this;
    }
    v7 = (unsigned __int8 *)v4[16];
    v6 = (unsigned __int8 *)v4[17];
    if (v7 != v6)
    {
      while (v7[8] != (_DWORD)this)
      {
        v7 += 16;
        if (v7 == v6)
        {
          v7 = (unsigned __int8 *)v4[17];
          break;
        }
      }
    }
    v8 = v7[9] - 1;
    v7[9] = v8;
    if (!v8)
    {
      if (this >= 0xE)
        abort();
      v4[19] &= ~(1 << this);
      v9 = v6 - (v7 + 16);
      if (v6 != v7 + 16)
        memmove(v7, v7 + 16, v9 - 6);
      v4[17] = &v7[v9];
    }
LABEL_14:
    this = TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)v4, v5, 15);
    goto LABEL_15;
  }
  return this;
}

uint64_t TSTWidthHeightCache_Private::WHCRow::resetColDataInRange(uint64_t this, unsigned int a2, unsigned int a3)
{
  unsigned int v4;
  _QWORD *v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unsigned __int8 v8;
  int64_t v9;

  if (a2 < a3)
  {
    v4 = a2;
    v5 = (_QWORD *)this;
    while (1)
    {
      this = TSTWidthHeightCache_NibArray::NibArray<8u>::get((uint64_t)v5, v4);
      if ((_DWORD)this == 14)
        goto LABEL_14;
      if ((_DWORD)this != 15)
        break;
LABEL_15:
      if (++v4 == a3)
        return this;
    }
    v7 = (unsigned __int8 *)v5[16];
    v6 = (unsigned __int8 *)v5[17];
    if (v7 != v6)
    {
      while (v7[8] != (_DWORD)this)
      {
        v7 += 16;
        if (v7 == v6)
        {
          v7 = (unsigned __int8 *)v5[17];
          break;
        }
      }
    }
    v8 = v7[9] - 1;
    v7[9] = v8;
    if (!v8)
    {
      if (this >= 0xE)
        abort();
      v5[19] &= ~(1 << this);
      v9 = v6 - (v7 + 16);
      if (v6 != v7 + 16)
        memmove(v7, v7 + 16, v9 - 6);
      v5[17] = &v7[v9];
    }
LABEL_14:
    this = TSTWidthHeightCache_NibArray::NibArray<8u>::set((uint64_t)v5, v4, 15);
    goto LABEL_15;
  }
  return this;
}

void *TSTWidthHeightCache_Private::WHCRow::moveColIds(TSTWidthHeightCache_Private::WHCRow *this, unsigned int a2, int a3, unsigned int a4)
{
  return TSTWidthHeightCache_NibArray::NibArray<8u>::move((uint64_t)this, a2, a3 + a2, a4, 256);
}

void *TSTWidthHeightCache_NibArray::NibArray<8u>::move(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  unint64_t v5;
  unsigned __int8 v8;
  unsigned __int8 *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  unint64_t v23;
  unsigned __int8 *v24;
  unsigned int v25;
  char *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  void *result;
  uint64_t v31;
  _BYTE *v32;
  _QWORD v33[2];

  LODWORD(v5) = a5;
  v8 = a2;
  v9 = (unsigned __int8 *)a1;
  v33[1] = *MEMORY[0x24BDAC8D0];
  if (a2 >= 0x100)
  {
    v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::move(uint, uint, uint, uint) [log2NumElements = 8]");
    a1 = objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 130, CFSTR("src begin index exceeds array "));
  }
  if (a3 >= 0x100)
  {
    v12 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v13 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::move(uint, uint, uint, uint) [log2NumElements = 8]");
    a1 = objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 133, CFSTR("src end index exceeds array"));
  }
  v14 = v8;
  v15 = a3;
  if (v5 >= 0x101)
  {
    v16 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v17 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::move(uint, uint, uint, uint) [log2NumElements = 8]");
    a1 = objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 136, CFSTR("hint exceeds array length"));
  }
  if (v5 >= 0x100)
    v5 = 256;
  else
    v5 = v5;
  v18 = v15 - v14;
  if (v18 + a4 >= 0x101)
  {
    v28 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v29 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::move(uint, uint, uint, uint) [log2NumElements = 8]");
    return (void *)objc_msgSend(v28, "handleFailureInFunction:file:lineNumber:description:", v29, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 139, CFSTR("end of destination exceeds array length"));
  }
  else
  {
    v19 = MEMORY[0x24BDAC7A8](a1);
    v20 = (char *)v33 - ((v5 + 15) & 0x1FFFFFFF0);
    MEMORY[0x24BDAC7A8](v19);
    v22 = (char *)v33 - v21;
    if ((_DWORD)v5)
    {
      v23 = 0;
      v24 = v9;
      do
      {
        v25 = *v24++;
        v26 = &v20[v23];
        *v26 = v25 & 0xF;
        v26[1] = v25 >> 4;
        v23 += 2;
      }
      while (v23 < v5);
    }
    memcpy(v22, &v20[v14], v15 - v14);
    if (a4 <= v15)
    {
      v27 = a4;
      memmove(&v20[a4 + v18], &v20[a4], v14 - a4);
    }
    else
    {
      memmove(&v20[v14], &v20[v15], a4 - v15);
      v27 = a4 - v18;
    }
    result = memcpy(&v20[v27], v22, v15 - v14);
    if ((_DWORD)v5)
    {
      v31 = ((v5 - 1) >> 1) + 1;
      v32 = v20 + 1;
      do
      {
        *v9++ = *(v32 - 1) | (16 * *v32);
        v32 += 2;
        --v31;
      }
      while (v31);
    }
  }
  return result;
}

uint64_t TSTWidthHeightCache_Private::WHCRow::insertCols(TSTWidthHeightCache_Private::WHCRow *this, int a2, unsigned int a3)
{
  return TSTWidthHeightCache_NibArray::NibArray<8u>::insert((uint64_t)this, a2, a3, 15);
}

uint64_t TSTWidthHeightCache_NibArray::NibArray<8u>::insert(uint64_t result, int a2, unsigned int a3, char a4)
{
  uint64_t v7;
  unsigned int v8;
  void *v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  char v13;

  v7 = result;
  v8 = a3 + a2;
  if (a3 + a2 > 0xFF)
  {
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::insert(uint, uint, uint8_t) [log2NumElements = 8]");
    result = objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 184, CFSTR("destination exceeds array bounds"));
    if (a2)
    {
      v8 = 256;
      return TSTWidthHeightCache_NibArray::NibArray<8u>::setRange(v7, a3, v8, a4);
    }
  }
  else if (a2)
  {
    if (((v8 ^ a3) & 1) != 0)
    {
      v11 = -a2;
      v12 = 255;
      do
      {
        v13 = TSTWidthHeightCache_NibArray::NibArray<8u>::get(v7, v11 + v12);
        TSTWidthHeightCache_NibArray::NibArray<8u>::set(v7, v12--, v13);
      }
      while (v12 >= v8);
    }
    else
    {
      memmove((void *)(result + (v8 >> 1)), (const void *)(result + (a3 >> 1)), (256 - v8) >> 1);
    }
    return TSTWidthHeightCache_NibArray::NibArray<8u>::setRange(v7, a3, v8, a4);
  }
  return result;
}

uint64_t std::vector<TSTWidthHeightCache_Private::WHCCol>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 5)
  {
    if (a2 >> 59)
      abort();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Edge::CGPointVector>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 32 * v6;
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_217B9F79C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<TSTWidthHeightCache_Private::WHCCol>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      if (v3 != v5)
      {
        v6 = a1[1];
        do
        {
          v8 = *(void **)(v6 - 32);
          v6 -= 32;
          v7 = v8;
          if (v8)
          {
            *(_QWORD *)(v3 - 24) = v7;
            operator delete(v7);
          }
          v3 = v6;
        }
        while (v6 != v5);
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__append(a1, a2 - v4);
  }
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  void *v8;

  v3 = a1[1];
  v4 = 0xCF3CF3CF3CF3CF3DLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 168 * a2;
    while (v3 != v7)
    {
      v8 = *(void **)(v3 - 40);
      if (v8)
      {
        *(_QWORD *)(v3 - 32) = v8;
        operator delete(v8);
      }
      v3 -= 168;
    }
    a1[1] = v7;
  }
}

char *std::vector<TSTWidthHeightCache_Private::WHCCol>::erase(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  char v12;

  if (a2 != (char *)a3)
  {
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>((int)&v12, a3, *(_QWORD *)(a1 + 8), a2);
    v6 = v5;
    v7 = *(_QWORD *)(a1 + 8);
    if (v7 != v5)
    {
      v8 = *(_QWORD *)(a1 + 8);
      do
      {
        v10 = *(void **)(v8 - 32);
        v8 -= 32;
        v9 = v10;
        if (v10)
        {
          *(_QWORD *)(v7 - 24) = v9;
          operator delete(v9);
        }
        v7 = v8;
      }
      while (v8 != v6);
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  return a2;
}

uint64_t std::vector<TSTWidthHeightCache_Private::WHCRow>::erase(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  if ((__int128 *)a2 != a3)
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,0>(a3, *(__int128 **)(a1 + 8), a2);
    v6 = v5;
    v7 = *(_QWORD *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        v8 = *(void **)(v7 - 40);
        if (v8)
        {
          *(_QWORD *)(v7 - 32) = v8;
          operator delete(v8);
        }
        v7 -= 168;
      }
      while (v7 != v6);
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  return a2;
}

void sub_217BA0300(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *std::vector<TSTWidthHeightCache_Private::WHCCol>::insert(uint64_t *a1, char *a2, unint64_t a3, unint64_t a4)
{
  char *v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  char *v27;
  _QWORD v29[2];
  char *v30;
  char *v31;
  uint64_t v32;

  v4 = a2;
  if (a3)
  {
    v10 = a1[2];
    v8 = (uint64_t)(a1 + 2);
    v9 = v10;
    v11 = *(_QWORD *)(v8 - 8);
    if (a3 <= (uint64_t)(v10 - v11) >> 5)
    {
      v18 = v11 - (_QWORD)a2;
      v19 = a3;
      if (a3 <= (uint64_t)(v11 - (_QWORD)a2) >> 5)
        goto LABEL_15;
      v20 = 0;
      v19 = v18 >> 5;
      v21 = v11 + 32 * (a3 - (v18 >> 5));
      v22 = 32 * a3 - 32 * (v18 >> 5);
      do
      {
        std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector((_QWORD *)(v11 + v20), a4);
        *(_BYTE *)(v11 + v20 + 24) = *(_BYTE *)(a4 + 24);
        v20 += 32;
      }
      while (v22 != v20);
      a1[1] = v21;
      if ((char *)v11 != v4)
      {
LABEL_15:
        std::vector<TSTWidthHeightCache_Private::WHCCol>::__move_range((uint64_t)a1, (uint64_t)v4, v11, (uint64_t)&v4[32 * a3]);
        if ((unint64_t)v4 <= a4)
        {
          if (a1[1] <= a4)
            v23 = 0;
          else
            v23 = a3;
          a4 += 32 * v23;
        }
        v24 = v4;
        do
        {
          if (v24 != (char *)a4)
            std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCWidthBucket*,TSTWidthHeightCache_Private::WHCWidthBucket*>(v24, *(char **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 4);
          v24[24] = *(_BYTE *)(a4 + 24);
          v24 += 32;
          --v19;
        }
        while (v19);
      }
    }
    else
    {
      v12 = *a1;
      v13 = a3 + ((uint64_t)(v11 - *a1) >> 5);
      if (v13 >> 59)
        abort();
      v14 = (uint64_t)&a2[-v12] >> 5;
      v15 = v9 - v12;
      if (v15 >> 4 > v13)
        v13 = v15 >> 4;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFE0)
        v16 = 0x7FFFFFFFFFFFFFFLL;
      else
        v16 = v13;
      v32 = v8;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Edge::CGPointVector>>(v8, v16);
      else
        v17 = 0;
      v25 = &v17[32 * v14];
      v29[0] = v17;
      v29[1] = v25;
      v30 = v25;
      v31 = &v17[32 * v16];
      v26 = 32 * a3;
      v27 = &v25[32 * a3];
      do
      {
        std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector(v25, a4);
        v25[24] = *(_BYTE *)(a4 + 24);
        v25 += 32;
        v26 -= 32;
      }
      while (v26);
      v30 = v27;
      v4 = (char *)std::vector<TSTWidthHeightCache_Private::WHCCol>::__swap_out_circular_buffer(a1, v29, (uint64_t)v4);
      std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer((uint64_t)v29);
    }
  }
  return v4;
}

void sub_217BA04F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

char *std::vector<double>::insert(uint64_t a1, char *__src, unint64_t a3, char *a4)
{
  char *v4;
  char *v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  _BYTE *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  char *v28;
  uint64_t v29;
  char *v30;
  void *__p;
  char *v33;
  char *v34;
  char *v35;
  uint64_t v36;

  v4 = __src;
  if (a3)
  {
    v5 = a4;
    v10 = *(_QWORD *)(a1 + 16);
    v8 = a1 + 16;
    v9 = v10;
    v11 = *(char **)(v8 - 8);
    if (a3 <= (v10 - (uint64_t)v11) >> 3)
    {
      v18 = v11 - __src;
      if (a3 <= (v11 - __src) >> 3)
      {
        v21 = *(char **)(v8 - 8);
        v20 = a3;
      }
      else
      {
        v19 = 0;
        v20 = v18 >> 3;
        v21 = &v11[8 * (a3 - (v18 >> 3))];
        do
        {
          *(_QWORD *)&v11[v19] = *(_QWORD *)a4;
          v19 += 8;
        }
        while (8 * a3 - 8 * v20 != v19);
        *(_QWORD *)(a1 + 8) = v21;
        if (v11 == __src)
          return v4;
      }
      v22 = &__src[8 * a3];
      v23 = &v21[-8 * a3];
      v24 = v21;
      if (v23 < v11)
      {
        v24 = v21;
        do
        {
          v25 = *(_QWORD *)v23;
          v23 += 8;
          *(_QWORD *)v24 = v25;
          v24 += 8;
        }
        while (v23 < v11);
      }
      *(_QWORD *)(a1 + 8) = v24;
      if (v21 != v22)
        memmove(&v21[-8 * ((v21 - v22) >> 3)], __src, v21 - v22);
      if (v4 <= v5)
      {
        if (*(_QWORD *)(a1 + 8) <= (unint64_t)v5)
          v26 = 0;
        else
          v26 = a3;
        v5 += 8 * v26;
      }
      v27 = v4;
      do
      {
        *(_QWORD *)v27 = *(_QWORD *)v5;
        v27 += 8;
        --v20;
      }
      while (v20);
    }
    else
    {
      v12 = *(_BYTE **)a1;
      v13 = a3 + ((uint64_t)&v11[-*(_QWORD *)a1] >> 3);
      if (v13 >> 61)
        abort();
      v14 = (__src - v12) >> 3;
      v15 = v9 - (_QWORD)v12;
      if (v15 >> 2 > v13)
        v13 = v15 >> 2;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v13;
      v36 = v8;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>(v8, v16);
      else
        v17 = 0;
      v28 = &v17[8 * v14];
      __p = v17;
      v33 = v28;
      v35 = &v17[8 * v16];
      v29 = 8 * a3;
      v30 = &v28[8 * a3];
      do
      {
        *(_QWORD *)v28 = *(_QWORD *)v5;
        v28 += 8;
        v29 -= 8;
      }
      while (v29);
      v34 = v30;
      v4 = std::vector<double>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
      if (v34 != v33)
        v34 += (v33 - v34 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (__p)
        operator delete(__p);
    }
  }
  return v4;
}

void sub_217BA0700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_217BA0914(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

__int128 *std::vector<TSTWidthHeightCache_Private::WHCRow>::insert(uint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  __int128 *v6;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  char *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  uint64_t v48;
  unint64_t v50;
  __int128 *v51;
  uint64_t v52;
  _QWORD v53[2];
  char *v54;
  char *v55;
  uint64_t v56;

  v4 = *a1;
  v5 = (a2 - *a1) / 168;
  v6 = (__int128 *)(*a1 + 168 * v5);
  if (a3)
  {
    v9 = (uint64_t)a1;
    v12 = a1[2];
    v10 = (uint64_t)(a1 + 2);
    v11 = v12;
    v13 = *(_QWORD *)(v10 - 8);
    if (0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v12 - v13) >> 3) >= a3)
    {
      v18 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v13 - (_QWORD)v6) >> 3);
      v19 = a3;
      if (a3 <= v18)
        goto LABEL_15;
      v51 = v6;
      v52 = v9;
      v20 = 0;
      v19 = v18;
      v50 = v13 + 168 * (a3 - v18);
      v21 = 168 * a3 - 168 * v18;
      do
      {
        v22 = v13 + v20;
        v23 = *(_OWORD *)a4;
        v24 = *(_OWORD *)(a4 + 16);
        v25 = *(_OWORD *)(a4 + 48);
        *(_OWORD *)(v22 + 32) = *(_OWORD *)(a4 + 32);
        *(_OWORD *)(v22 + 48) = v25;
        *(_OWORD *)v22 = v23;
        *(_OWORD *)(v22 + 16) = v24;
        v26 = *(_OWORD *)(a4 + 64);
        v27 = *(_OWORD *)(a4 + 80);
        v28 = *(_OWORD *)(a4 + 112);
        *(_OWORD *)(v22 + 96) = *(_OWORD *)(a4 + 96);
        *(_OWORD *)(v22 + 112) = v28;
        *(_OWORD *)(v22 + 64) = v26;
        *(_OWORD *)(v22 + 80) = v27;
        std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::vector((_QWORD *)(v13 + v20 + 128), a4 + 128);
        v29 = *(_QWORD *)(a4 + 152);
        *(_BYTE *)(v22 + 160) = *(_BYTE *)(a4 + 160);
        *(_QWORD *)(v22 + 152) = v29;
        v20 += 168;
      }
      while (v21 != v20);
      v6 = v51;
      v9 = v52;
      *(_QWORD *)(v52 + 8) = v50;
      if ((__int128 *)v13 != v51)
      {
LABEL_15:
        std::vector<TSTWidthHeightCache_Private::WHCRow>::__move_range(v9, (uint64_t)v6, v13, (uint64_t)v6 + 168 * a3);
        if ((unint64_t)v6 <= a4)
        {
          if (*(_QWORD *)(v9 + 8) <= a4)
            v30 = 0;
          else
            v30 = a3;
          a4 += 168 * v30;
        }
        v31 = v4 + 168 * v5 + 128;
        do
        {
          v32 = *(_OWORD *)a4;
          v33 = *(_OWORD *)(a4 + 16);
          v34 = *(_OWORD *)(a4 + 48);
          *(_OWORD *)(v31 - 96) = *(_OWORD *)(a4 + 32);
          *(_OWORD *)(v31 - 80) = v34;
          *(_OWORD *)(v31 - 128) = v32;
          *(_OWORD *)(v31 - 112) = v33;
          v35 = *(_OWORD *)(a4 + 64);
          v36 = *(_OWORD *)(a4 + 80);
          v37 = *(_OWORD *)(a4 + 112);
          *(_OWORD *)(v31 - 32) = *(_OWORD *)(a4 + 96);
          *(_OWORD *)(v31 - 16) = v37;
          *(_OWORD *)(v31 - 64) = v35;
          *(_OWORD *)(v31 - 48) = v36;
          if (v31 - 128 != a4)
            std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCHeightBucket*,TSTWidthHeightCache_Private::WHCHeightBucket*>((char *)v31, *(char **)(a4 + 128), *(_QWORD *)(a4 + 136), (uint64_t)(*(_QWORD *)(a4 + 136) - *(_QWORD *)(a4 + 128)) >> 4);
          v38 = *(_QWORD *)(a4 + 152);
          *(_BYTE *)(v31 + 32) = *(_BYTE *)(a4 + 160);
          *(_QWORD *)(v31 + 24) = v38;
          v31 += 168;
          --v19;
        }
        while (v19);
      }
    }
    else
    {
      v14 = a3 - 0x30C30C30C30C30C3 * ((uint64_t)(v13 - v4) >> 3);
      if (v14 > 0x186186186186186)
        abort();
      v15 = 0xCF3CF3CF3CF3CF3DLL * ((v11 - v4) >> 3);
      if (2 * v15 > v14)
        v14 = 2 * v15;
      if (v15 >= 0xC30C30C30C30C3)
        v16 = 0x186186186186186;
      else
        v16 = v14;
      v56 = v10;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TSTWidthHeightCache_Private::WHCRow>>(v10, v16);
      else
        v17 = 0;
      v39 = &v17[168 * v5];
      v53[0] = v17;
      v53[1] = v39;
      v54 = v39;
      v55 = &v17[168 * v16];
      v40 = 168 * a3;
      v41 = &v39[168 * a3];
      do
      {
        v42 = *(_OWORD *)a4;
        v43 = *(_OWORD *)(a4 + 16);
        v44 = *(_OWORD *)(a4 + 48);
        *((_OWORD *)v39 + 2) = *(_OWORD *)(a4 + 32);
        *((_OWORD *)v39 + 3) = v44;
        *(_OWORD *)v39 = v42;
        *((_OWORD *)v39 + 1) = v43;
        v45 = *(_OWORD *)(a4 + 64);
        v46 = *(_OWORD *)(a4 + 80);
        v47 = *(_OWORD *)(a4 + 112);
        *((_OWORD *)v39 + 6) = *(_OWORD *)(a4 + 96);
        *((_OWORD *)v39 + 7) = v47;
        *((_OWORD *)v39 + 4) = v45;
        *((_OWORD *)v39 + 5) = v46;
        std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::vector((_QWORD *)v39 + 16, a4 + 128);
        v48 = *(_QWORD *)(a4 + 152);
        v39[160] = *(_BYTE *)(a4 + 160);
        *((_QWORD *)v39 + 19) = v48;
        v39 += 168;
        v40 -= 168;
      }
      while (v40);
      v54 = v41;
      v6 = std::vector<TSTWidthHeightCache_Private::WHCRow>::__swap_out_circular_buffer((__int128 **)v9, v53, v6);
      std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer((uint64_t)v53);
    }
  }
  return v6;
}

void sub_217BA0C38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_217BA0E70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16)
{
  a16 = (void **)&a12;
  std::vector<TSTWidthHeightCache_Private::WHCRow>::__destroy_vector::operator()[abi:nn180100](&a16);
  _Unwind_Resume(a1);
}

void sub_217BA1098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16)
{
  a16 = (void **)&a12;
  std::vector<TSTWidthHeightCache_Private::WHCCol>::__destroy_vector::operator()[abi:nn180100](&a16);
  _Unwind_Resume(a1);
}

void sub_217BA1D1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__28(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__28(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t std::vector<TSTWidthHeightCache_Private::WHCRow>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (0xCF3CF3CF3CF3CF3DLL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x186186186186187)
      abort();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<TSTWidthHeightCache_Private::WHCRow>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 168 * v6;
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_217BA20B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__fill_n[abi:nn180100]<false,std::__bitset<1ul,14ul>>(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  int v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;

  v2 = a2;
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_QWORD **)a1;
  if (v4)
  {
    if ((64 - v4) >= a2)
      v6 = a2;
    else
      v6 = (64 - v4);
    *v5++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4));
    v2 = a2 - v6;
    *(_QWORD *)a1 = v5;
  }
  v7 = v2 >> 6;
  if (v2 >= 0x40)
    bzero(v5, 8 * v7);
  if ((v2 & 0x3F) != 0)
  {
    v8 = &v5[v7];
    *(_QWORD *)a1 = v8;
    *v8 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F));
  }
}

_DWORD *std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  _DWORD *v5;
  char *v6;
  _DWORD *v7;
  char *v8;
  uint64_t v9;
  int v10;
  _BYTE *v11;
  uint64_t v12;
  int64_t v13;
  char *v14;
  void *v15;
  void *v16;

  v5 = *(_DWORD **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v7 = *(_DWORD **)(a2 + 8);
    do
    {
      v9 = *((_QWORD *)v8 - 2);
      v8 -= 16;
      v10 = *((_DWORD *)v8 + 2);
      *((_QWORD *)v7 - 2) = v9;
      v7 -= 4;
      v7[2] = v10;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v11 = a1[1];
  v12 = *(_QWORD *)(a2 + 16);
  v13 = v11 - __src;
  if (v11 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v13 - 4);
    v7 = *(_DWORD **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v12 + v13;
  v14 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v14;
  v15 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v15;
  v16 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v16;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

__n128 std::__split_buffer<TSTWidthHeightCache_Private::WHCHeightBucket>::push_back(__n128 **a1, __n128 *a2)
{
  __n128 *v4;
  __n128 *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __n128 *v13;
  int64_t v14;
  __n128 *v15;
  unint64_t v16;
  __n128 *v17;
  uint64_t v18;
  __n128 *v19;
  __n128 *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  __int128 v24;
  __n128 *v25;
  __n128 result;

  v4 = a1[2];
  if (v4 == a1[3])
  {
    v5 = a1[1];
    v6 = (char *)v5 - (char *)*a1;
    if (v5 <= *a1)
    {
      if (v4 == *a1)
        v16 = 1;
      else
        v16 = ((char *)v4 - (char *)*a1) >> 3;
      v17 = (__n128 *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)a1[4], v16);
      v19 = &v17[v16 >> 2];
      v20 = a1[1];
      v4 = v19;
      v21 = (char *)a1[2] - (char *)v20;
      if (v21)
      {
        v4 = (__n128 *)((char *)v19 + (v21 & 0xFFFFFFFFFFFFFFF0));
        v22 = 16 * (v21 >> 4);
        v23 = (char *)&v17[v16 >> 2];
        do
        {
          v24 = (__int128)*v20++;
          *(_OWORD *)v23 = v24;
          v23 += 16;
          v22 -= 16;
        }
        while (v22);
      }
      v25 = *a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[v18];
      if (v25)
      {
        operator delete(v25);
        v4 = a1[2];
      }
    }
    else
    {
      v7 = v6 >> 4;
      v8 = v6 >> 4 < -1;
      v9 = (v6 >> 4) + 2;
      if (v8)
        v10 = v9;
      else
        v10 = v7 + 1;
      v11 = -(v10 >> 1);
      v12 = v10 >> 1;
      v13 = &v5[-v12];
      v14 = (char *)v4 - (char *)v5;
      if (v4 != v5)
      {
        memmove(&v5[-v12], v5, v14 - 6);
        v4 = a1[1];
      }
      v15 = &v4[v11];
      v4 = (__n128 *)((char *)v13 + v14);
      a1[1] = v15;
      a1[2] = (__n128 *)((char *)v13 + v14);
    }
  }
  result = *a2;
  *v4 = *a2;
  ++a1[2];
  return result;
}

_WORD *std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  _WORD *v5;
  char *v6;
  _WORD *v7;
  char *v8;
  uint64_t v9;
  __int16 v10;
  _BYTE *v11;
  uint64_t v12;
  int64_t v13;
  char *v14;
  void *v15;
  void *v16;

  v5 = *(_WORD **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v7 = *(_WORD **)(a2 + 8);
    do
    {
      v9 = *((_QWORD *)v8 - 2);
      v8 -= 16;
      v10 = *((_WORD *)v8 + 4);
      *((_QWORD *)v7 - 2) = v9;
      v7 -= 8;
      v7[4] = v10;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v11 = a1[1];
  v12 = *(_QWORD *)(a2 + 16);
  v13 = v11 - __src;
  if (v11 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v13 - 6);
    v7 = *(_WORD **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v12 + v13;
  v14 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v14;
  v15 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v15;
  v16 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v16;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

uint64_t TSTWidthHeightCache_NibArray::NibArray<8u>::setRange(uint64_t result, unsigned int a2, unsigned int a3, char a4)
{
  unsigned int v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;

  LOBYTE(v6) = a2;
  v7 = result;
  if (a2 >= 0x100)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::setRange(uint, uint, uint8_t) [log2NumElements = 8]");
    result = objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 78, CFSTR("begin exceeds array length"));
  }
  v6 = v6;
  if (a3 >= 0x101)
  {
    v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTWidthHeightCache_NibArray::NibArray<8>::setRange(uint, uint, uint8_t) [log2NumElements = 8]");
    result = objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTWidthHeightCache_NibArray.h"), 81, CFSTR("end exceeds array length"));
  }
  if (a3 >= 0x100)
    a3 = 256;
  if (v6 < a3)
  {
    do
      result = TSTWidthHeightCache_NibArray::NibArray<8u>::set(v7, v6++, a4);
    while (a3 != v6);
  }
  return result;
}

_QWORD *std::vector<TSTWidthHeightCache_Private::WHCCol>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = *a1;
  v5 = a1[1];
  v6 = (_QWORD *)a2[1];
  if (v5 == *a1)
  {
    result = (_QWORD *)a2[1];
  }
  else
  {
    do
    {
      result = std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector(v6 - 4, v5 - 32);
      *((_BYTE *)v6 - 8) = *(_BYTE *)(v5 - 8);
      v5 -= 32;
      v6 = result;
    }
    while (v5 != v4);
  }
  a2[1] = result;
  v8 = *a1;
  *a1 = (uint64_t)result;
  a2[1] = v8;
  v9 = a1[1];
  a1[1] = a2[2];
  a2[2] = v9;
  v10 = a1[2];
  a1[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

_QWORD *std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  uint64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<CGPoint>::__vallocate[abi:nn180100](a1, v5 >> 4);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5 - 4);
    a1[1] = &v6[v5];
  }
  return a1;
}

uint64_t std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::__destruct_at_end[abi:nn180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::__destruct_at_end[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    v5 = *(void **)(v2 - 32);
    *(_QWORD *)(a1 + 16) = v2 - 32;
    if (v5)
    {
      *(_QWORD *)(v2 - 24) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 32;
    }
  }
}

uint64_t std::vector<TSTWidthHeightCache_Private::WHCCol>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  _QWORD v19[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      v14 = 32 * a2;
      v15 = v7 + 32 * a2;
      do
      {
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = 0;
        *(_BYTE *)(v7 + 24) = 0;
        *(_QWORD *)(v7 + 16) = 0;
        v7 += 32;
        v14 -= 32;
      }
      while (v14);
      v7 = v15;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      abort();
    v10 = v8 >> 5;
    v11 = v5 - *a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v19[4] = result;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Edge::CGPointVector>>(result, v12);
    else
      v13 = 0;
    v16 = &v13[32 * v10];
    v19[0] = v13;
    v19[1] = v16;
    v19[3] = &v13[32 * v12];
    v17 = 32 * a2;
    v18 = &v16[32 * a2];
    do
    {
      *(_QWORD *)v16 = 0;
      *((_QWORD *)v16 + 1) = 0;
      v16[24] = 0;
      *((_QWORD *)v16 + 2) = 0;
      v16 += 32;
      v17 -= 32;
    }
    while (v17);
    v19[2] = v18;
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__swap_out_circular_buffer(a1, v19);
    return std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer((uint64_t)v19);
  }
  return result;
}

void sub_217BA29D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSTWidthHeightCache_Private::WHCCol>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (0xCF3CF3CF3CF3CF3DLL * ((v6 - v7) >> 3) >= a2)
  {
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end((uint64_t)a1, a2);
  }
  else
  {
    v8 = 0xCF3CF3CF3CF3CF3DLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x186186186186186)
      abort();
    v10 = 0xCF3CF3CF3CF3CF3DLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0xC30C30C30C30C3)
      v11 = 0x186186186186186;
    else
      v11 = v9;
    v17 = v4;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TSTWidthHeightCache_Private::WHCRow>>(v4, v11);
    else
      v12 = 0;
    v13 = v12;
    v14 = &v12[168 * v8];
    v15 = v14;
    v16 = &v12[168 * v11];
    std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end((uint64_t)&v13, a2);
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__swap_out_circular_buffer(a1, &v13);
    std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer((uint64_t)&v13);
  }
}

void sub_217BA2B0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  int v9;

  v3 = *(_QWORD *)(a1 + 8);
  if (a2)
  {
    v4 = v3 + 168 * a2;
    v5 = v3 + 152;
    v6 = 168 * a2;
    do
    {
      *(_BYTE *)(v5 + 8) = 0;
      *(_OWORD *)(v5 - 8) = 0u;
      *(_OWORD *)(v5 - 24) = 0u;
      *(_QWORD *)&v7 = -1;
      *((_QWORD *)&v7 + 1) = -1;
      *(_OWORD *)(v5 - 152) = v7;
      *(_OWORD *)(v5 - 136) = v7;
      *(_OWORD *)(v5 - 120) = v7;
      *(_OWORD *)(v5 - 104) = v7;
      *(_OWORD *)(v5 - 88) = v7;
      *(_OWORD *)(v5 - 72) = v7;
      *(_OWORD *)(v5 - 56) = v7;
      *(_OWORD *)(v5 - 40) = v7;
      v8 = v5;
      v9 = 0;
      std::__fill_n[abi:nn180100]<false,std::__bitset<1ul,14ul>>((uint64_t)&v8, 0xEuLL);
      v5 += 168;
      v6 -= 168;
    }
    while (v6);
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 8);
  }
  *(_QWORD *)(a1 + 8) = v4;
}

void std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  int v9;

  v3 = *(_QWORD *)(a1 + 16);
  if (a2)
  {
    v4 = v3 + 168 * a2;
    v5 = v3 + 152;
    v6 = 168 * a2;
    do
    {
      *(_BYTE *)(v5 + 8) = 0;
      *(_OWORD *)(v5 - 8) = 0u;
      *(_OWORD *)(v5 - 24) = 0u;
      *(_QWORD *)&v7 = -1;
      *((_QWORD *)&v7 + 1) = -1;
      *(_OWORD *)(v5 - 152) = v7;
      *(_OWORD *)(v5 - 136) = v7;
      *(_OWORD *)(v5 - 120) = v7;
      *(_OWORD *)(v5 - 104) = v7;
      *(_OWORD *)(v5 - 88) = v7;
      *(_OWORD *)(v5 - 72) = v7;
      *(_OWORD *)(v5 - 56) = v7;
      *(_OWORD *)(v5 - 40) = v7;
      v8 = v5;
      v9 = 0;
      std::__fill_n[abi:nn180100]<false,std::__bitset<1ul,14ul>>((uint64_t)&v8, 0xEuLL);
      v5 += 168;
      v6 -= 168;
    }
    while (v6);
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 16);
  }
  *(_QWORD *)(a1 + 16) = v4;
}

uint64_t *std::vector<TSTWidthHeightCache_Private::WHCRow>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v2 = *result;
  v3 = result[1];
  v4 = a2[1];
  if (v3 == *result)
  {
    v5 = a2[1];
  }
  else
  {
    do
    {
      v5 = v4 - 168;
      v6 = *(_OWORD *)(v3 - 168);
      v7 = *(_OWORD *)(v3 - 152);
      v8 = *(_OWORD *)(v3 - 136);
      *(_OWORD *)(v4 - 120) = *(_OWORD *)(v3 - 120);
      *(_OWORD *)(v4 - 136) = v8;
      *(_OWORD *)(v4 - 152) = v7;
      *(_OWORD *)(v4 - 168) = v6;
      v9 = *(_OWORD *)(v3 - 104);
      v10 = *(_OWORD *)(v3 - 88);
      v11 = *(_OWORD *)(v3 - 72);
      *(_OWORD *)(v4 - 56) = *(_OWORD *)(v3 - 56);
      *(_OWORD *)(v4 - 72) = v11;
      *(_OWORD *)(v4 - 88) = v10;
      *(_OWORD *)(v4 - 104) = v9;
      *(_QWORD *)(v4 - 32) = 0;
      *(_QWORD *)(v4 - 24) = 0;
      *(_QWORD *)(v4 - 40) = 0;
      *(_OWORD *)(v4 - 40) = *(_OWORD *)(v3 - 40);
      *(_QWORD *)(v4 - 24) = *(_QWORD *)(v3 - 24);
      *(_QWORD *)(v3 - 40) = 0;
      *(_QWORD *)(v3 - 32) = 0;
      *(_QWORD *)(v3 - 24) = 0;
      v12 = *(_QWORD *)(v3 - 16);
      *(_BYTE *)(v4 - 8) = *(_BYTE *)(v3 - 8);
      *(_QWORD *)(v4 - 16) = v12;
      v3 -= 168;
      v4 -= 168;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  v13 = *result;
  *result = v5;
  a2[1] = v13;
  v14 = result[1];
  result[1] = a2[2];
  a2[2] = v14;
  v15 = result[2];
  result[2] = a2[3];
  a2[3] = v15;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<TSTWidthHeightCache_Private::WHCRow>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x186186186186187)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(168 * a2);
}

uint64_t std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::__destruct_at_end[abi:nn180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<TSTWidthHeightCache_Private::WHCRow>::__destruct_at_end[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    *(_QWORD *)(a1 + 16) = v2 - 168;
    v5 = *(void **)(v2 - 40);
    if (v5)
    {
      *(_QWORD *)(v2 - 32) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 168;
    }
  }
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>(int a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5;

  v5 = a2;
  if (a2 != a3)
  {
    do
    {
      if ((char *)v5 != a4)
        std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCWidthBucket*,TSTWidthHeightCache_Private::WHCWidthBucket*>(a4, *(char **)v5, *(_QWORD *)(v5 + 8), (uint64_t)(*(_QWORD *)(v5 + 8) - *(_QWORD *)v5) >> 4);
      a4[24] = *(_BYTE *)(v5 + 24);
      v5 += 32;
      a4 += 32;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

char *std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCWidthBucket*,TSTWidthHeightCache_Private::WHCWidthBucket*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  size_t v18;
  void *v19;
  char *v20;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60)
      abort();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<CGPoint>::__vallocate[abi:nn180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v17 - 4;
      v19 = v9;
      v20 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 4;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9 - 4);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v17 - 4;
    v19 = v9;
    v20 = v16;
LABEL_18:
    result = (char *)memmove(v19, v20, v18);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

__int128 *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,0>(__int128 *a1, __int128 *a2, uint64_t a3)
{
  __int128 *v4;
  __int128 *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v4 = a1;
  if (a1 == a2)
    return a1;
  v5 = a2;
  do
  {
    v6 = *v4;
    v7 = v4[1];
    v8 = v4[3];
    *(_OWORD *)(a3 + 32) = v4[2];
    *(_OWORD *)(a3 + 48) = v8;
    *(_OWORD *)a3 = v6;
    *(_OWORD *)(a3 + 16) = v7;
    v9 = v4[4];
    v10 = v4[5];
    v11 = v4[7];
    *(_OWORD *)(a3 + 96) = v4[6];
    *(_OWORD *)(a3 + 112) = v11;
    *(_OWORD *)(a3 + 64) = v9;
    *(_OWORD *)(a3 + 80) = v10;
    std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__move_assign(a3 + 128, (__n128 *)v4 + 8);
    v12 = *((_QWORD *)v4 + 19);
    *(_BYTE *)(a3 + 160) = *((_BYTE *)v4 + 160);
    *(_QWORD *)(a3 + 152) = v12;
    a3 += 168;
    v4 = (__int128 *)((char *)v4 + 168);
  }
  while (v4 != v5);
  return v5;
}

__n128 std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__move_assign(uint64_t a1, __n128 *a2)
{
  void *v4;
  __n128 result;

  v4 = *(void **)a1;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = v4;
    operator delete(v4);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  result = *a2;
  *(__n128 *)a1 = *a2;
  *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

uint64_t std::vector<TSTWidthHeightCache_Private::WHCCol>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v10;
  char v12;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = a2 + v6 - a4;
  v8 = v6;
  if (v7 < a3)
  {
    v10 = a2 + v6 - a4;
    v8 = *(_QWORD *)(a1 + 8);
    do
    {
      std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector((_QWORD *)v8, v10);
      *(_BYTE *)(v8 + 24) = *(_BYTE *)(v10 + 24);
      v10 += 32;
      v8 += 32;
    }
    while (v10 < a3);
  }
  *(_QWORD *)(a1 + 8) = v8;
  return std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>((uint64_t)&v12, a2, v7, v6);
}

void sub_217BA3120(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

_QWORD *std::vector<TSTWidthHeightCache_Private::WHCCol>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = a3;
  v6 = (_QWORD *)a2[1];
  v7 = *a1;
  v8 = v6;
  if (v7 != a3)
  {
    v9 = a3;
    v10 = (_QWORD *)a2[1];
    do
    {
      v8 = std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector(v10 - 4, v9 - 32);
      *((_BYTE *)v10 - 8) = *(_BYTE *)(v9 - 8);
      v9 -= 32;
      v10 = v8;
    }
    while (v9 != v7);
  }
  a2[1] = v8;
  v11 = a1[1];
  v12 = a2[2];
  if (v11 != v3)
  {
    do
    {
      std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector((_QWORD *)v12, v3);
      *(_BYTE *)(v12 + 24) = *(_BYTE *)(v3 + 24);
      v3 += 32;
      v12 += 32;
    }
    while (v3 != v11);
    v8 = (_QWORD *)a2[1];
  }
  a2[2] = v12;
  v13 = *a1;
  *a1 = (uint64_t)v8;
  a2[1] = v13;
  v14 = a1[1];
  a1[1] = a2[2];
  a2[2] = v14;
  v15 = a1[2];
  a1[2] = a2[3];
  a2[3] = v15;
  *a2 = a2[1];
  return v6;
}

uint64_t std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  if (a3 != a2)
  {
    v7 = a3;
    do
    {
      if (v7 != a4)
        std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCWidthBucket*,TSTWidthHeightCache_Private::WHCWidthBucket*>((char *)(a4 - 32), *(char **)(v7 - 32), *(_QWORD *)(v7 - 24), (uint64_t)(*(_QWORD *)(v7 - 24) - *(_QWORD *)(v7 - 32)) >> 4);
      *(_BYTE *)(a4 - 8) = *(_BYTE *)(v7 - 8);
      v7 -= 32;
      a4 -= 32;
    }
    while (v7 != a2);
  }
  return a3;
}

char *std::vector<double>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(char **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v7 = *(char **)(a2 + 8);
    do
    {
      v9 = *((_QWORD *)v8 - 1);
      v8 -= 8;
      *((_QWORD *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(char **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

uint64_t std::vector<TSTWidthHeightCache_Private::WHCRow>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = a2 + v6 - a4;
  v8 = v6;
  if (v7 < a3)
  {
    v9 = v7;
    v8 = *(_QWORD *)(a1 + 8);
    do
    {
      v10 = *(_OWORD *)v9;
      v11 = *(_OWORD *)(v9 + 16);
      v12 = *(_OWORD *)(v9 + 48);
      *(_OWORD *)(v8 + 32) = *(_OWORD *)(v9 + 32);
      *(_OWORD *)(v8 + 48) = v12;
      *(_OWORD *)v8 = v10;
      *(_OWORD *)(v8 + 16) = v11;
      v13 = *(_OWORD *)(v9 + 64);
      v14 = *(_OWORD *)(v9 + 80);
      v15 = *(_OWORD *)(v9 + 112);
      *(_OWORD *)(v8 + 96) = *(_OWORD *)(v9 + 96);
      *(_OWORD *)(v8 + 112) = v15;
      *(_OWORD *)(v8 + 64) = v13;
      *(_OWORD *)(v8 + 80) = v14;
      *(_QWORD *)(v8 + 136) = 0;
      *(_QWORD *)(v8 + 144) = 0;
      *(_QWORD *)(v8 + 128) = 0;
      *(_OWORD *)(v8 + 128) = *(_OWORD *)(v9 + 128);
      *(_QWORD *)(v8 + 144) = *(_QWORD *)(v9 + 144);
      *(_QWORD *)(v9 + 128) = 0;
      *(_QWORD *)(v9 + 136) = 0;
      *(_QWORD *)(v9 + 144) = 0;
      v16 = *(_QWORD *)(v9 + 152);
      *(_BYTE *)(v8 + 160) = *(_BYTE *)(v9 + 160);
      *(_QWORD *)(v8 + 152) = v16;
      v8 += 168;
      v9 += 168;
    }
    while (v9 < a3);
  }
  *(_QWORD *)(a1 + 8) = v8;
  return std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,0>(a2, v7, v6);
}

__int128 *std::vector<TSTWidthHeightCache_Private::WHCRow>::__swap_out_circular_buffer(__int128 **a1, _QWORD *a2, __int128 *a3)
{
  __int128 *result;
  __int128 *v5;
  __int128 *v6;
  __int128 *v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  __int128 *v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  __int128 *v25;
  __int128 *v26;
  __int128 *v27;

  result = (__int128 *)a2[1];
  v5 = *a1;
  v6 = result;
  if (*a1 != a3)
  {
    v7 = a3;
    v8 = a2[1];
    do
    {
      v6 = (__int128 *)(v8 - 168);
      v9 = *(__int128 *)((char *)v7 - 168);
      v10 = *(__int128 *)((char *)v7 - 152);
      v11 = *(__int128 *)((char *)v7 - 136);
      *(_OWORD *)(v8 - 120) = *(__int128 *)((char *)v7 - 120);
      *(_OWORD *)(v8 - 136) = v11;
      *(_OWORD *)(v8 - 152) = v10;
      *(_OWORD *)(v8 - 168) = v9;
      v12 = *(__int128 *)((char *)v7 - 104);
      v13 = *(__int128 *)((char *)v7 - 88);
      v14 = *(__int128 *)((char *)v7 - 72);
      *(_OWORD *)(v8 - 56) = *(__int128 *)((char *)v7 - 56);
      *(_OWORD *)(v8 - 72) = v14;
      *(_OWORD *)(v8 - 88) = v13;
      *(_OWORD *)(v8 - 104) = v12;
      *(_QWORD *)(v8 - 32) = 0;
      *(_QWORD *)(v8 - 24) = 0;
      *(_QWORD *)(v8 - 40) = 0;
      *(_OWORD *)(v8 - 40) = *(__int128 *)((char *)v7 - 40);
      *(_QWORD *)(v8 - 24) = *((_QWORD *)v7 - 3);
      *((_QWORD *)v7 - 5) = 0;
      *((_QWORD *)v7 - 4) = 0;
      *((_QWORD *)v7 - 3) = 0;
      v15 = *((_QWORD *)v7 - 2);
      *(_BYTE *)(v8 - 8) = *((_BYTE *)v7 - 8);
      *(_QWORD *)(v8 - 16) = v15;
      v7 = (__int128 *)((char *)v7 - 168);
      v8 -= 168;
    }
    while (v7 != v5);
  }
  a2[1] = v6;
  v16 = a1[1];
  v17 = a2[2];
  if (v16 != a3)
  {
    do
    {
      v18 = *a3;
      v19 = a3[1];
      v20 = a3[3];
      *(_OWORD *)(v17 + 32) = a3[2];
      *(_OWORD *)(v17 + 48) = v20;
      *(_OWORD *)v17 = v18;
      *(_OWORD *)(v17 + 16) = v19;
      v21 = a3[4];
      v22 = a3[5];
      v23 = a3[7];
      *(_OWORD *)(v17 + 96) = a3[6];
      *(_OWORD *)(v17 + 112) = v23;
      *(_OWORD *)(v17 + 64) = v21;
      *(_OWORD *)(v17 + 80) = v22;
      *(_QWORD *)(v17 + 136) = 0;
      *(_QWORD *)(v17 + 144) = 0;
      *(_QWORD *)(v17 + 128) = 0;
      *(_OWORD *)(v17 + 128) = a3[8];
      *(_QWORD *)(v17 + 144) = *((_QWORD *)a3 + 18);
      *((_QWORD *)a3 + 16) = 0;
      *((_QWORD *)a3 + 17) = 0;
      *((_QWORD *)a3 + 18) = 0;
      v24 = *((_QWORD *)a3 + 19);
      *(_BYTE *)(v17 + 160) = *((_BYTE *)a3 + 160);
      *(_QWORD *)(v17 + 152) = v24;
      v17 += 168;
      a3 = (__int128 *)((char *)a3 + 168);
    }
    while (a3 != v16);
    v6 = (__int128 *)a2[1];
  }
  a2[2] = v17;
  v25 = *a1;
  *a1 = v6;
  a2[1] = v25;
  v26 = a1[1];
  a1[1] = (__int128 *)a2[2];
  a2[2] = v26;
  v27 = a1[2];
  a1[2] = (__int128 *)a2[3];
  a2[3] = v27;
  *a2 = a2[1];
  return result;
}

_QWORD *std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  uint64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<CGPoint>::__vallocate[abi:nn180100](a1, v5 >> 4);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5 - 6);
    a1[1] = &v6[v5];
  }
  return a1;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  if (a2 != a1)
  {
    v6 = a2;
    do
    {
      v7 = *(_OWORD *)(v6 - 168);
      v8 = *(_OWORD *)(v6 - 152);
      v9 = *(_OWORD *)(v6 - 136);
      *(_OWORD *)(a3 - 120) = *(_OWORD *)(v6 - 120);
      *(_OWORD *)(a3 - 136) = v9;
      *(_OWORD *)(a3 - 152) = v8;
      *(_OWORD *)(a3 - 168) = v7;
      v10 = *(_OWORD *)(v6 - 104);
      v11 = *(_OWORD *)(v6 - 88);
      v12 = *(_OWORD *)(v6 - 72);
      *(_OWORD *)(a3 - 56) = *(_OWORD *)(v6 - 56);
      *(_OWORD *)(a3 - 72) = v12;
      *(_OWORD *)(a3 - 88) = v11;
      *(_OWORD *)(a3 - 104) = v10;
      std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__move_assign(a3 - 40, (__n128 *)(v6 - 40));
      v13 = *(_QWORD *)(v6 - 16);
      *(_BYTE *)(a3 - 8) = *(_BYTE *)(v6 - 8);
      *(_QWORD *)(a3 - 16) = v13;
      a3 -= 168;
      v6 -= 168;
    }
    while (v6 != a1);
  }
  return a2;
}

char *std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCHeightBucket*,TSTWidthHeightCache_Private::WHCHeightBucket*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  size_t v18;
  void *v19;
  char *v20;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60)
      abort();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<CGPoint>::__vallocate[abi:nn180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v17 - 6;
      v19 = v9;
      v20 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 4;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9 - 6);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v17 - 6;
    v19 = v9;
    v20 = v16;
LABEL_18:
    result = (char *)memmove(v19, v20, v18);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 168)
  {
    v4 = *(void **)(i - 40);
    if (v4)
    {
      *(_QWORD *)(i - 32) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::__assign_with_size[abi:nn180100]<std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>>(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  char v16;
  char v17;

  v8 = *a1;
  if (0xCF3CF3CF3CF3CF3DLL * ((a1[2] - *a1) >> 3) >= a4)
  {
    if (0xCF3CF3CF3CF3CF3DLL * ((a1[1] - v8) >> 3) >= a4)
    {
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *>((uint64_t)&v17, a2, a3, v8);
      v13 = v12;
      v14 = a1[1];
      if (v14 != v12)
      {
        do
        {
          v15 = *(void **)(v14 - 40);
          if (v15)
          {
            *(_QWORD *)(v14 - 32) = v15;
            operator delete(v15);
          }
          v14 -= 168;
        }
        while (v14 != v13);
      }
      a1[1] = v13;
    }
    else
    {
      v11 = a2 + 8 * ((a1[1] - v8) >> 3);
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *>((uint64_t)&v16, a2, v11, v8);
      std::vector<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end<std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>>(a1, v11, a3);
    }
  }
  else
  {
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__vdeallocate(a1);
    if (a4 > 0x186186186186186)
      abort();
    v9 = 0x9E79E79E79E79E7ALL * ((a1[2] - *a1) >> 3);
    if (v9 <= a4)
      v9 = a4;
    if (0xCF3CF3CF3CF3CF3DLL * ((a1[2] - *a1) >> 3) >= 0xC30C30C30C30C3)
      v10 = 0x186186186186186;
    else
      v10 = v9;
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__vallocate[abi:nn180100](a1, v10);
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end<std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>>(a1, a2, a3);
  }
}

_QWORD *std::vector<TSTWidthHeightCache_Private::WHCRow>::__construct_at_end<std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCRow*>>(_QWORD *result, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v3 = result;
  v4 = result[1];
  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      v8 = a2 + v7;
      v9 = v4 + v7;
      v10 = *(_OWORD *)(a2 + v7);
      v11 = *(_OWORD *)(a2 + v7 + 16);
      v12 = *(_OWORD *)(a2 + v7 + 48);
      *(_OWORD *)(v9 + 32) = *(_OWORD *)(a2 + v7 + 32);
      *(_OWORD *)(v9 + 48) = v12;
      *(_OWORD *)v9 = v10;
      *(_OWORD *)(v9 + 16) = v11;
      v13 = *(_OWORD *)(a2 + v7 + 64);
      v14 = *(_OWORD *)(a2 + v7 + 80);
      v15 = *(_OWORD *)(a2 + v7 + 112);
      *(_OWORD *)(v9 + 96) = *(_OWORD *)(a2 + v7 + 96);
      *(_OWORD *)(v9 + 112) = v15;
      *(_OWORD *)(v9 + 64) = v13;
      *(_OWORD *)(v9 + 80) = v14;
      result = std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::vector((_QWORD *)(v4 + v7 + 128), a2 + v7 + 128);
      v16 = *(_QWORD *)(a2 + v7 + 152);
      *(_BYTE *)(v9 + 160) = *(_BYTE *)(a2 + v7 + 160);
      *(_QWORD *)(v9 + 152) = v16;
      v7 += 168;
    }
    while (v8 + 168 != a3);
    v4 += v7;
  }
  v3[1] = v4;
  return result;
}

void sub_217BA3A6C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<TSTWidthHeightCache_Private::WHCRow>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<TSTWidthHeightCache_Private::WHCRow>::__clear[abi:nn180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *std::vector<TSTWidthHeightCache_Private::WHCRow>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x186186186186187)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TSTWidthHeightCache_Private::WHCRow>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[168 * v4];
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  if (a2 == a3)
    return a2;
  v5 = a3;
  v6 = a2 + 136;
  do
  {
    v7 = v6 - 136;
    v8 = *(_OWORD *)(v6 - 136);
    v9 = *(_OWORD *)(v6 - 120);
    v10 = *(_OWORD *)(v6 - 88);
    *(_OWORD *)(a4 + 32) = *(_OWORD *)(v6 - 104);
    *(_OWORD *)(a4 + 48) = v10;
    *(_OWORD *)a4 = v8;
    *(_OWORD *)(a4 + 16) = v9;
    v11 = *(_OWORD *)(v6 - 72);
    v12 = *(_OWORD *)(v6 - 56);
    v13 = *(_OWORD *)(v6 - 24);
    *(_OWORD *)(a4 + 96) = *(_OWORD *)(v6 - 40);
    *(_OWORD *)(a4 + 112) = v13;
    *(_OWORD *)(a4 + 64) = v11;
    *(_OWORD *)(a4 + 80) = v12;
    if (a4 != v6 - 136)
      std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCHeightBucket*,TSTWidthHeightCache_Private::WHCHeightBucket*>((char *)(a4 + 128), *(char **)(v6 - 8), *(_QWORD *)v6, (uint64_t)(*(_QWORD *)v6 - *(_QWORD *)(v6 - 8)) >> 4);
    v14 = *(_QWORD *)(v6 + 16);
    *(_BYTE *)(a4 + 160) = *(_BYTE *)(v6 + 24);
    *(_QWORD *)(a4 + 152) = v14;
    a4 += 168;
    v6 += 168;
  }
  while (v7 + 168 != v5);
  return v5;
}

uint64_t std::__copy_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *,TSTWidthHeightCache_Private::WHCRow *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  if (a3 != a2)
  {
    v7 = a3;
    do
    {
      v8 = *(_OWORD *)(v7 - 168);
      v9 = *(_OWORD *)(v7 - 152);
      v10 = *(_OWORD *)(v7 - 136);
      *(_OWORD *)(a4 - 120) = *(_OWORD *)(v7 - 120);
      *(_OWORD *)(a4 - 136) = v10;
      *(_OWORD *)(a4 - 152) = v9;
      *(_OWORD *)(a4 - 168) = v8;
      v11 = *(_OWORD *)(v7 - 104);
      v12 = *(_OWORD *)(v7 - 88);
      v13 = *(_OWORD *)(v7 - 72);
      *(_OWORD *)(a4 - 56) = *(_OWORD *)(v7 - 56);
      *(_OWORD *)(a4 - 72) = v13;
      *(_OWORD *)(a4 - 88) = v12;
      *(_OWORD *)(a4 - 104) = v11;
      if (a4 != v7)
        std::vector<TSTWidthHeightCache_Private::WHCHeightBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCHeightBucket*,TSTWidthHeightCache_Private::WHCHeightBucket*>((char *)(a4 - 40), *(char **)(v7 - 40), *(_QWORD *)(v7 - 32), (uint64_t)(*(_QWORD *)(v7 - 32) - *(_QWORD *)(v7 - 40)) >> 4);
      v14 = *(_QWORD *)(v7 - 16);
      *(_BYTE *)(a4 - 8) = *(_BYTE *)(v7 - 8);
      *(_QWORD *)(a4 - 16) = v14;
      v7 -= 168;
      a4 -= 168;
    }
    while (v7 != a2);
  }
  return a3;
}

void std::vector<TSTWidthHeightCache_Private::WHCCol>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<TSTWidthHeightCache_Private::WHCCol>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(void **)(v4 - 32);
      v4 -= 32;
      v5 = v6;
      if (v6)
      {
        *(_QWORD *)(v2 - 24) = v5;
        operator delete(v5);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void std::vector<TSTWidthHeightCache_Private::WHCCol>::__assign_with_size[abi:nn180100]<std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>>(char **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  void *v18;
  void *v19;
  char v20;
  char v21;

  v8 = *a1;
  if (a4 <= (a1[2] - *a1) >> 5)
  {
    v12 = (a1[1] - v8) >> 5;
    if (v12 >= a4)
    {
      std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>((int)&v21, a2, a3, v8);
      v15 = v14;
      v16 = a1[1];
      if (v16 != v14)
      {
        v17 = a1[1];
        do
        {
          v19 = (void *)*((_QWORD *)v17 - 4);
          v17 -= 32;
          v18 = v19;
          if (v19)
          {
            *((_QWORD *)v16 - 3) = v18;
            operator delete(v18);
          }
          v16 = v17;
        }
        while (v17 != v15);
      }
      a1[1] = v15;
    }
    else
    {
      v13 = a2 + 32 * v12;
      std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>((int)&v20, a2, v13, v8);
      std::vector<TSTWidthHeightCache_Private::WHCCol>::__construct_at_end<std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>>(a1, v13, a3);
    }
  }
  else
  {
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__vdeallocate((uint64_t *)a1);
    if (a4 >> 59)
      abort();
    v9 = a1[2] - *a1;
    v10 = v9 >> 4;
    if (v9 >> 4 <= a4)
      v10 = a4;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0)
      v11 = 0x7FFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    std::vector<TSDBrushVertexData>::__vallocate[abi:nn180100](a1, v11);
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__construct_at_end<std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>>(a1, a2, a3);
  }
}

_QWORD *std::vector<TSTWidthHeightCache_Private::WHCCol>::__construct_at_end<std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>,std::__wrap_iter<TSTWidthHeightCache_Private::WHCCol*>>(_QWORD *result, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v7;

  v3 = result;
  v4 = result[1];
  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      result = std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::vector((_QWORD *)(v4 + v7), a2 + v7);
      *((_BYTE *)result + 24) = *(_BYTE *)(a2 + v7 + 24);
      v7 += 32;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  v3[1] = v4;
  return result;
}

void sub_217BA3ED0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<TSTWidthHeightCache_Private::WHCCol>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<TSTWidthHeightCache_Private::WHCCol>::__clear[abi:nn180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::__copy_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *,TSTWidthHeightCache_Private::WHCCol *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  if (a3 != a2)
  {
    v7 = a3;
    do
    {
      if (a4 != v7)
        std::vector<TSTWidthHeightCache_Private::WHCWidthBucket>::__assign_with_size[abi:nn180100]<TSTWidthHeightCache_Private::WHCWidthBucket*,TSTWidthHeightCache_Private::WHCWidthBucket*>((char *)(a4 - 32), *(char **)(v7 - 32), *(_QWORD *)(v7 - 24), (uint64_t)(*(_QWORD *)(v7 - 24) - *(_QWORD *)(v7 - 32)) >> 4);
      *(_BYTE *)(a4 - 8) = *(_BYTE *)(v7 - 8);
      v7 -= 32;
      a4 -= 32;
    }
    while (v7 != a2);
  }
  return a3;
}

void TSTEditingStateSetSelection(TSTEditingState *a1, TSTTableSelection *a2)
{
  TSTTableSelection *mSelection;

  -[TSPObject willModify](a1, "willModify");
  mSelection = a1->mSelection;
  if (mSelection != a2)
  {

    a1->mSelection = (TSTTableSelection *)-[TSTTableSelection copy](a2, "copy");
    -[TSTEditingState setSearchReference:](a1, "setSearchReference:", 0);
  }

  a1->mSelectionReflectingEditingState = 0;
}

TSTTableSelection *TSTEditingStateGetSelection(TSTEditingState *a1, int a2)
{
  TSTTableModel *v4;
  TSTTableModel *v5;
  TSTTableSelection *result;
  BOOL v7;
  TSTTableSelection *v8;
  uint64_t v9;
  TSTCellRegion *v10;
  uint64_t v11;

  v4 = -[TSTEditingState tableModel](a1, "tableModel");
  if ((a2 & 1) == 0)
  {
    v9 = 80;
    return *(TSTTableSelection **)((char *)&a1->super.super.isa + v9);
  }
  v5 = v4;
  if (a1->mSelectionReflectingEditingState && !-[TSTEditingState editingMode](a1, "editingMode"))
  {
    v10 = -[TSTTableSelection cellRegion](a1->mSelectionReflectingEditingState, "cellRegion");
    if (!-[TSTCellRegion isRectangle](v10, "isRectangle")
      || (v11 = -[TSTCellRegion boundingCellRange](v10, "boundingCellRange"),
          ((-[TSTTableModel range](v5, "range") ^ v11) & 0xFFFFFFFF00FFFFFFLL) != 0))
    {

      result = -[TSTTableSelection initWithTableModel:selectionType:]([TSTTableSelection alloc], "initWithTableModel:selectionType:", v5, 5);
      a1->mSelectionReflectingEditingState = result;
      return result;
    }
    goto LABEL_25;
  }
  result = a1->mSelection;
  if (result)
    v7 = 1;
  else
    v7 = a2 == 0;
  if (!v7)
  {
    if (!a1->mSelectionReflectingEditingState)
    {
      switch(-[TSTEditingState editingMode](a1, "editingMode"))
      {
        case 0:
          v8 = -[TSTTableSelection initWithTableModel:selectionType:]([TSTTableSelection alloc], "initWithTableModel:selectionType:", v5, 5);
          break;
        case 1:
          if (!a1->mSelection)
            goto LABEL_25;
          v8 = -[TSTTableSelection initWithTableModel:startingRowIndex:numberOfRows:]([TSTTableSelection alloc], "initWithTableModel:startingRowIndex:numberOfRows:", v5, (unsigned __int16)-[TSTCellRegion boundingCellRange](-[TSTTableSelection cellRegion](a1->mSelection, "cellRegion"), "boundingCellRange"), (unint64_t)-[TSTCellRegion boundingCellRange](-[TSTTableSelection cellRegion](a1->mSelection, "cellRegion"), "boundingCellRange") >> 48);
          break;
        case 2:
          if (!a1->mSelection)
            goto LABEL_25;
          v8 = -[TSTTableSelection initWithTableModel:startingColumnIndex:numberOfColumns:]([TSTTableSelection alloc], "initWithTableModel:startingColumnIndex:numberOfColumns:", v5, (-[TSTCellRegion boundingCellRange](-[TSTTableSelection cellRegion](a1->mSelection, "cellRegion"), "boundingCellRange") >> 16), (unsigned __int16)((unint64_t)-[TSTCellRegion boundingCellRange](-[TSTTableSelection cellRegion](a1->mSelection, "cellRegion"), "boundingCellRange") >> 32));
          break;
        case 3:
        case 4:
        case 5:
          if (!a1->mSelection)
            goto LABEL_25;
          v8 = -[TSTTableSelection initWithTableModel:cellRegion:anchorCellID:cursorCellID:]([TSTTableSelection alloc], "initWithTableModel:cellRegion:anchorCellID:cursorCellID:", v5, -[TSTTableSelection cellRegion](a1->mSelection, "cellRegion"), -[TSTTableSelection anchorCellID](a1->mSelection, "anchorCellID"), -[TSTTableSelection cursorCellID](a1->mSelection, "cursorCellID"));
          break;
        case 6:
        case 9:
          if (!a1->mSelection)
            goto LABEL_25;
          v8 = -[TSTTableSelection initWithTableModel:andCellID:]([TSTTableSelection alloc], "initWithTableModel:andCellID:", v5, -[TSTCellRegion upperLeftCellID](-[TSTTableSelection cellRegion](a1->mSelection, "cellRegion"), "upperLeftCellID"));
          break;
        case 7:
        case 8:
          v8 = -[TSTTableSelection initWithTableModel:andCellRange:]([TSTTableSelection alloc], "initWithTableModel:andCellRange:", v5, 0xFFFFFFLL);
          break;
        default:
          goto LABEL_25;
      }
      a1->mSelectionReflectingEditingState = v8;
    }
LABEL_25:
    v9 = 88;
    return *(TSTTableSelection **)((char *)&a1->super.super.isa + v9);
  }
  return result;
}

unint64_t TSTAnimationSetKind(uint64_t a1, int a2)
{
  unint64_t result;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;

  *(_DWORD *)(a1 + 16) = a2;
  result = TSTAnimationGetStageCountForChunkStyle((TSTTableModel *)objc_msgSend(*(id *)(a1 + 8), "tableModel"), a2);
  *(_DWORD *)(a1 + 60) = 0;
  v5 = (_BYTE *)(a1 + 60);
  *(_QWORD *)(a1 + 40) = result;
  *(_DWORD *)(a1 + 57) = 0;
  v6 = (_BYTE *)(a1 + 57);
  *(_QWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = result < 2;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 64) = 0x10000;
  v7 = (_BYTE *)(a1 + 58);
  v8 = (_BYTE *)(a1 + 59);
  switch(a2)
  {
    case 2:
      goto LABEL_16;
    case 3:
      *v6 = 1;
      goto LABEL_15;
    case 4:
      v6 = (_BYTE *)(a1 + 58);
      goto LABEL_16;
    case 5:
      *v7 = 1;
      goto LABEL_15;
    case 6:
      v6 = (_BYTE *)(a1 + 59);
      goto LABEL_16;
    case 7:
      *v8 = 1;
      goto LABEL_15;
    case 8:
      *v6 = 1;
      goto LABEL_12;
    case 9:
      *v6 = 1;
      *v5 = 1;
      goto LABEL_15;
    case 10:
      *v7 = 1;
      goto LABEL_12;
    case 11:
      *v7 = 1;
      goto LABEL_14;
    case 12:
      *v8 = 1;
LABEL_12:
      v6 = (_BYTE *)(a1 + 60);
      goto LABEL_16;
    case 13:
      *v8 = 1;
LABEL_14:
      *v5 = 1;
LABEL_15:
      v6 = (_BYTE *)(a1 + 63);
      goto LABEL_16;
    case 14:
      v6 = (_BYTE *)(a1 + 61);
LABEL_16:
      *v6 = 1;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TSTAnimationGetStageCountForChunkStyle(TSTTableModel *a1, int a2)
{
  uint64_t result;
  uint64_t NumberOfColumns;

  switch(a2)
  {
    case 0:
    case 1:
    case 14:
      return 1;
    case 2:
    case 3:
      return TSTAnimationGetNumberOfColumns(a1);
    case 4:
    case 5:
      return TSTAnimationGetNumberOfRows(a1);
    case 6:
    case 7:
      return TSTAnimationGetNumberOfCells(a1);
    case 8:
    case 9:
      NumberOfColumns = TSTAnimationGetNumberOfColumns(a1);
      goto LABEL_9;
    case 10:
    case 11:
      NumberOfColumns = TSTAnimationGetNumberOfRows(a1);
      goto LABEL_9;
    case 12:
    case 13:
      NumberOfColumns = TSTAnimationGetNumberOfCells(a1);
LABEL_9:
      result = NumberOfColumns + 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t TSTAnimationAddCellRangesForColumnIndex(TSTAnimation *a1, TSTTableModel *a2, uint64_t a3)
{
  unsigned __int8 v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  BOOL v16;
  BOOL v17;
  TSTTableModel *v18;
  int v19;
  unsigned __int8 v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  BOOL v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  BOOL v30;
  BOOL v31;
  uint64_t v32;
  BOOL v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  unint64_t v40;
  unint64_t v41;
  unsigned __int16 v43;
  unint64_t v44;
  unsigned __int8 v45;
  unsigned int v46;

  v5 = -[TSTTableModel numberOfColumns](a2, "numberOfColumns");
  v6 = -[TSTTableModel numberOfRows](a2, "numberOfRows");
  v7 = v6;
  v45 = v5;
  if (!v5)
  {
    v41 = 0;
    v20 = -1;
    v43 = -1;
    goto LABEL_26;
  }
  v8 = 0;
  v9 = 0;
  v10 = ((unint64_t)v6 << 16) | 1;
  v44 = v10 << 32;
  v40 = v10 << 8;
  v41 = 0;
  v43 = -1;
  v11 = 255;
  do
  {
    if (!v7)
    {
LABEL_21:
      v19 = v9;
      v9 = v11;
      goto LABEL_22;
    }
    v12 = 0;
    v13 = (unint64_t)v9 << 16;
    while (1)
    {
      v14 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a2, v13 | v12 | 0x1000100000000);
      v15 = v14;
      if ((_WORD)v14 == 0xFFFF
        || ((v14 & 0xFF0000) != 0xFF0000 ? (v16 = HIWORD(v14) == 0) : (v16 = 1),
            !v16 ? (v17 = (v14 & 0xFFFF00000000) == 0) : (v17 = 1),
            v17))
      {
        v18 = a2;
        v15 = v44 | ((unint64_t)v9 << 16);
      }
      else
      {
        if ((v14 & 0xFFFFFF) != (v13 | v12))
          goto LABEL_20;
        v18 = a2;
      }
      if ((TSTTableHasCellRangeHidden(v18, v15) & 1) == 0)
        break;
LABEL_20:
      if (++v12 >= v7)
        goto LABEL_21;
    }
    if (v8 != a3)
    {
      ++v8;
      v12 = 65534;
      goto LABEL_20;
    }
    v43 = 0;
    v19 = 254;
    v8 = a3;
    v41 = v40;
LABEL_22:
    v20 = v9;
    v11 = v9;
    v9 = (v19 + 1);
  }
  while ((v19 + 1) < v45);
LABEL_26:
  if (v7)
  {
    v21 = 0;
    v22 = (unint64_t)v20 << 16;
    v23 = v41 >> 24;
    v25 = (v41 & 0xFFFF00) == 0 || v23 == 0;
    v26 = 0xFFFFFFLL;
    v46 = (unsigned __int16)(v43 + v23 - 1);
    v27 = 0xFFFFFFLL;
    while (1)
    {
      v28 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a2, v22 | v21 | 0x1000100000000);
      v29 = v28;
      if ((_WORD)v28 == 0xFFFF
        || ((v28 & 0xFF0000) != 0xFF0000 ? (v30 = HIWORD(v28) == 0) : (v30 = 1),
            !v30 ? (v31 = (v28 & 0xFFFF00000000) == 0) : (v31 = 1),
            v31))
      {
        if ((_WORD)v27 == 0xFFFF)
        {
          v27 = v22 | v21 | 0x1000100000000;
        }
        else
        {
          v32 = v27 & 0xFF0000;
          v34 = (v27 & 0xFFFF00000000) != 0 && HIWORD(v27) != 0;
          v35 = !v34;
          if (v34)
            v36 = v27;
          else
            v36 = v22 | v21 | 0x1000100000000;
          if (v35)
            v37 = v26;
          else
            v37 = v22 | v21 | 0x1000100000000;
          if (v32 == 16711680)
            v27 = v22 | v21 | 0x1000100000000;
          else
            v27 = v36;
          if (v32 != 16711680)
            v26 = v37;
        }
        goto LABEL_72;
      }
      -[TSTAnimation addCellRange:](a1, "addCellRange:", TSTCellRangeUnionCellRange(v27, v26));
      v38 = v43 > (unsigned __int16)v29 || v25;
      if ((v38 & 1) != 0)
        goto LABEL_70;
      v27 = 0xFFFFFFLL;
      v26 = 0xFFFFFFLL;
      if (v46 >= (unsigned __int16)v29)
      {
        if (v20 > BYTE2(v29))
          goto LABEL_70;
        v27 = 0xFFFFFFLL;
        v26 = 0xFFFFFFLL;
        if ((v20 + BYTE1(v41) - 1) >= BYTE2(v29))
          break;
      }
LABEL_72:
      if (v7 == ++v21)
        return -[TSTAnimation addCellRange:](a1, "addCellRange:", TSTCellRangeUnionCellRange(v27, v26));
    }
    -[TSTAnimation addCellRange:](a1, "addCellRange:", v29);
LABEL_70:
    v27 = 0xFFFFFFLL;
    v26 = 0xFFFFFFLL;
    goto LABEL_72;
  }
  v27 = 0xFFFFFFLL;
  v26 = 0xFFFFFFLL;
  return -[TSTAnimation addCellRange:](a1, "addCellRange:", TSTCellRangeUnionCellRange(v27, v26));
}

uint64_t TSTAnimationAddCellRangesForRowIndex(TSTAnimation *a1, TSTTableModel *a2, uint64_t a3)
{
  unsigned int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  BOOL v13;
  BOOL v14;
  TSTTableModel *v15;
  int v16;
  unsigned __int16 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  BOOL v26;
  BOOL v27;
  BOOL v28;
  __int16 v30;
  unsigned int v32;

  v5 = -[TSTTableModel numberOfColumns](a2, "numberOfColumns");
  v32 = -[TSTTableModel numberOfRows](a2, "numberOfRows");
  if (!v32)
  {
    v9 = v5;
    v17 = -1;
    if ((_BYTE)v5)
      goto LABEL_32;
    goto LABEL_63;
  }
  v6 = 0;
  v7 = 0;
  if (v5 >= 0xFF)
    v8 = 255;
  else
    v8 = v5;
  v9 = v5;
  v30 = -1;
  do
  {
    if (!v9)
    {
      v16 = v7;
      goto LABEL_30;
    }
    v10 = 0;
    while (1)
    {
      v11 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a2, (unsigned __int16)v7 | (unint64_t)(v10 << 16) | 0x1000100000000);
      v12 = v11;
      if ((_WORD)v11 == 0xFFFF
        || ((v11 & 0xFF0000) != 0xFF0000 ? (v13 = HIWORD(v11) == 0) : (v13 = 1),
            !v13 ? (v14 = (v11 & 0xFFFF00000000) == 0) : (v14 = 1),
            v14))
      {
        v15 = a2;
        v12 = (v8 << 32) | (unsigned __int16)v7 | 0x1000000000000;
      }
      else
      {
        if (!(_DWORD)v8
          || (unsigned __int16)v7 != (unsigned __int16)v11
          || (v8 - 1) < BYTE2(v11))
        {
          goto LABEL_21;
        }
        v15 = a2;
      }
      if ((TSTTableHasCellRangeHidden(v15, v12) & 1) == 0)
        break;
LABEL_21:
      if (++v10 >= (unint64_t)v5)
      {
        v16 = v7;
        goto LABEL_29;
      }
    }
    if (v6 != a3)
    {
      ++v6;
      v10 = 254;
      goto LABEL_21;
    }
    v16 = 65534;
    v6 = a3;
    v30 = v7;
LABEL_29:
    v9 = v5;
LABEL_30:
    v7 = v16 + 1;
  }
  while (v32 > (unsigned __int16)(v16 + 1));
  v17 = v30;
  if (!v9)
  {
LABEL_63:
    v19 = 0;
    v18 = 0;
    v22 = 0xFFFFFFLL;
    v21 = 0xFFFFFFLL;
    return -[TSTAnimation addCellRange:](a1, "addCellRange:", TSTCellRangeUnionCellRange(v22 | (v19 << 32), v21 | (v18 << 32)));
  }
LABEL_32:
  v18 = 0;
  v19 = 0;
  v20 = v17;
  v21 = 0xFFFFFFLL;
  v22 = 0xFFFFFFLL;
  v23 = v9;
  do
  {
    v24 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a2, v20 | 0x1000100000000);
    v25 = v24;
    if ((_WORD)v24 == 0xFFFF
      || ((v24 & 0xFF0000) != 0xFF0000 ? (v26 = HIWORD(v24) == 0) : (v26 = 1),
          !v26 ? (v27 = (v24 & 0xFFFF00000000) == 0) : (v27 = 1),
          v27))
    {
      if ((_WORD)v22 == 0xFFFF || (v22 & 0xFF0000) == 0xFF0000)
      {
        v22 = v20;
        v19 = 65537;
      }
      else
      {
        if ((_WORD)v19)
          v28 = (v19 & 0xFFFFFFFFFFFF0000) == 0;
        else
          v28 = 1;
        if (v28)
          v19 = 65537;
        if (v28)
          v22 = v20;
        if (!v28)
        {
          v18 = 65537;
          v21 = v20;
        }
      }
    }
    else
    {
      -[TSTAnimation addCellRange:](a1, "addCellRange:", TSTCellRangeUnionCellRange(v22 | (v19 << 32), v21 | (v18 << 32)));
      if (v20 == (v25 & 0xFFFFFF))
        -[TSTAnimation addCellRange:](a1, "addCellRange:", v25);
      v19 = 0;
      v18 = 0;
      v22 = 0xFFFFFFLL;
      v21 = 0xFFFFFFLL;
    }
    v20 += 0x10000;
    --v23;
  }
  while (v23);
  return -[TSTAnimation addCellRange:](a1, "addCellRange:", TSTCellRangeUnionCellRange(v22 | (v19 << 32), v21 | (v18 << 32)));
}

unint64_t TSTAnimationAddCellRangeForCellIndex(TSTAnimation *a1, TSTTableModel *a2, uint64_t a3)
{
  unsigned __int8 v5;
  unint64_t result;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  BOOL v13;
  uint64_t v15;
  int v16;

  v5 = -[TSTTableModel numberOfColumns](a2, "numberOfColumns");
  result = -[TSTTableModel numberOfRows](a2, "numberOfRows");
  if ((_DWORD)result)
  {
    v7 = 0;
    v8 = 0;
    v15 = result;
    v16 = v5;
    v9 = (unint64_t)v5 << 16;
    while (!v16)
    {
LABEL_21:
      if (++v7 == v15)
        return result;
    }
    v10 = 0;
    while (1)
    {
      result = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a2, v10 | v7 | 0x1000100000000);
      v11 = result;
      if ((_WORD)result == 0xFFFF
        || ((result & 0xFF0000) != 0xFF0000 ? (v12 = HIWORD(result) == 0) : (v12 = 1),
            !v12 ? (v13 = (result & 0xFFFF00000000) == 0) : (v13 = 1),
            v13))
      {
        result = TSTTableHasCellRangeHidden(a2, v10 | v7 | 0x1000100000000);
        if ((result & 1) != 0)
          goto LABEL_20;
        v11 = v10 | v7 | 0x1000100000000;
      }
      else
      {
        if ((v10 | v7) != (result & 0xFFFFFF))
          goto LABEL_20;
        result = TSTTableHasCellRangeHidden(a2, result);
        if ((result & 1) != 0)
          goto LABEL_20;
      }
      if (v8 == a3)
        return -[TSTAnimation addCellRange:](a1, "addCellRange:", v11);
      ++v8;
LABEL_20:
      v10 += 0x10000;
      if (v9 == v10)
        goto LABEL_21;
    }
  }
  return result;
}

uint64_t TSTAnimationGetNumberOfColumns(TSTTableModel *a1)
{
  unsigned __int8 v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned __int16 v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  TSTTableModel *v13;
  int HasCellRangeHidden;
  uint64_t v16;
  uint64_t v17;

  v2 = -[TSTTableModel numberOfColumns](a1, "numberOfColumns");
  v3 = -[TSTTableModel numberOfRows](a1, "numberOfRows");
  v17 = v2;
  if (v2)
  {
    v4 = v3;
    v5 = 0;
    v6 = 0;
    v16 = v3 << 48;
    v7 = (unsigned __int16)(v3 - 1);
    while (!v4)
    {
LABEL_24:
      if (++v5 == v17)
        return v6;
    }
    v8 = 0;
    while (1)
    {
      v9 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a1, (v5 << 16) & 0xFFFF0000 | v8 | 0x1000100000000);
      v10 = v9;
      if ((_WORD)v9 == 0xFFFF)
        break;
      v11 = (v9 & 0xFF0000) == 0xFF0000 || HIWORD(v9) == 0;
      if (v11 || (v9 & 0xFFFF00000000) == 0)
        break;
      if ((v16 | (v5 << 16) | 0x100000000uLL) >> 48 && v7 >= (unsigned __int16)v9 && v5 == BYTE2(v9))
      {
        v13 = a1;
        goto LABEL_15;
      }
LABEL_18:
      if (v4 <= ++v8)
        goto LABEL_24;
    }
    v13 = a1;
    v10 = v16 | (v5 << 16) | 0x100000000;
LABEL_15:
    HasCellRangeHidden = TSTTableHasCellRangeHidden(v13, v10);
    if (!HasCellRangeHidden)
      v8 = -2;
    v6 += HasCellRangeHidden ^ 1u;
    goto LABEL_18;
  }
  return 0;
}

uint64_t TSTAnimationGetNumberOfRows(TSTTableModel *a1)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 v7;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  TSTTableModel *v12;
  int HasCellRangeHidden;
  uint64_t v15;

  v2 = -[TSTTableModel numberOfColumns](a1, "numberOfColumns");
  v3 = -[TSTTableModel numberOfRows](a1, "numberOfRows");
  if (v3)
  {
    v4 = 0;
    v5 = 0;
    if (v2 >= 0xFF)
      v6 = 255;
    else
      v6 = v2;
    v15 = v3;
    while (!(_BYTE)v2)
    {
LABEL_27:
      if (++v4 == v15)
        return v5;
    }
    v7 = 0;
    while (1)
    {
      v8 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a1, v4 | ((unint64_t)v7 << 16) | 0x1000100000000);
      if ((unsigned __int16)v8 == 0xFFFFLL)
        break;
      v9 = v8;
      v10 = (v8 & 0xFF0000) == 0xFF0000 || HIWORD(v8) == 0;
      if (v10 || (v8 & 0xFFFF00000000) == 0)
        break;
      if ((_DWORD)v6 && v4 == (unsigned __int16)v8 && (v6 - 1) >= BYTE2(v8))
      {
        v12 = a1;
        goto LABEL_18;
      }
LABEL_21:
      if (++v7 >= v2)
        goto LABEL_27;
    }
    v12 = a1;
    v9 = (v6 << 32) | v4 | 0x1000000000000;
LABEL_18:
    HasCellRangeHidden = TSTTableHasCellRangeHidden(v12, v9);
    if (!HasCellRangeHidden)
      v7 = -2;
    v5 += HasCellRangeHidden ^ 1u;
    goto LABEL_21;
  }
  return 0;
}

uint64_t TSTAnimationGetNumberOfCells(TSTTableModel *a1)
{
  unsigned __int8 v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  BOOL v13;

  v2 = -[TSTTableModel numberOfColumns](a1, "numberOfColumns");
  v3 = -[TSTTableModel numberOfRows](a1, "numberOfRows");
  if (!v3)
    return 0;
  v4 = 0;
  v5 = 0;
  v6 = v2;
  v7 = v3;
  v8 = (unint64_t)v2 << 16;
  do
  {
    if (v6)
    {
      v9 = 0;
      do
      {
        v10 = v9 | v4 | 0x1000100000000;
        v11 = TSTTableExpandCellRangeToCoverMergedCells((uint64_t)a1, v10);
        if ((_WORD)v11 == 0xFFFF
          || ((v11 & 0xFF0000) != 0xFF0000 ? (v12 = HIWORD(v11) == 0) : (v12 = 1),
              !v12 ? (v13 = (v11 & 0xFFFF00000000) == 0) : (v13 = 1),
              v13 || (v10 = v11, (v9 | v4) == (v11 & 0xFFFFFF))))
        {
          v5 += TSTTableHasCellRangeHidden(a1, v10) ^ 1;
        }
        v9 += 0x10000;
      }
      while (v8 != v9);
    }
    ++v4;
  }
  while (v4 != v7);
  return v5;
}

void TSTTableDumpTileRowInfo(uint64_t a1)
{
  UInt8 *MutableBytePtr;
  uint64_t v3;
  unsigned __int16 v4;
  uint64_t v5;
  UInt8 *v6;
  int mPrivate;
  uint64_t v8;
  const __CFString *v9;
  TSTCell *v10;

  if (*(_WORD *)(a1 + 538))
  {
    MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 16));
    v10 = objc_alloc_init(TSTCell);
    v3 = 0;
    v4 = 0;
    do
    {
      if (*(unsigned __int16 *)(a1 + 538) == v4)
        break;
      v5 = *(unsigned __int16 *)(a1 + 24 + 2 * v3);
      if (v5 != 0xFFFF)
      {
        v6 = &MutableBytePtr[v5];
        TSTCellInflateFromStorageRef((uint64_t)v10, &MutableBytePtr[v5], 0);
        if (v10)
        {
          mPrivate = (int)v10->mPrivate;
          v8 = BYTE1(mPrivate);
          if (BYTE1(mPrivate) <= 9u)
            __asm { BR              X11 }
          v9 = CFSTR("<unknown cell type>");
        }
        else
        {
          v8 = 0;
          v9 = CFSTR("<empty>");
        }
        NSLog((NSString *)CFSTR("cell: column %d cell %p type %d [value %@]"), v3, v6, v8, v9);
        ++v4;
      }
      ++v3;
    }
    while (v3 != 255);

  }
  else
  {
    NSLog((NSString *)CFSTR("<empty row>"));
  }
}

size_t TSTTableTileRowInfoFlushableSize(uint64_t a1)
{
  objc_class *v2;
  size_t InstanceSize;
  const __CFData *v4;

  v2 = (objc_class *)objc_opt_class();
  InstanceSize = class_getInstanceSize(v2);
  v4 = *(const __CFData **)(a1 + 16);
  if (v4)
    InstanceSize += CFDataGetLength(v4);
  return InstanceSize;
}

uint64_t TSTTableTileRowInfoRecalculateMaxTileColumnIndex(uint64_t result)
{
  unsigned int v1;

  *(_BYTE *)(result + 540) = -1;
  v1 = 254;
  while (*(__int16 *)(result + 24 + 2 * v1) == -1)
  {
    if (--v1 == -1)
      goto LABEL_6;
  }
  *(_BYTE *)(result + 540) = v1;
LABEL_6:
  *(_BYTE *)(result + 541) = 1;
  return result;
}

UInt8 *TSTTableTileRowInfoCellStorageRefAtTileColumnIndex(uint64_t a1, unsigned int a2)
{
  uint64_t v2;

  if (!*(_WORD *)(a1 + 538))
    return 0;
  v2 = *(unsigned __int16 *)(a1 + 24 + 2 * a2);
  if (v2 == 0xFFFF)
    return 0;
  else
    return &CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 16))[v2];
}

void TSTTableTileRowInfoSetCell(TSTTableTileRowInfo *a1, unsigned int a2, _QWORD *a3)
{
  int v5;
  UInt8 *v7;
  uint64_t v8;
  UInt8 *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  __int16 v16;
  int v17;
  CFIndex v18;
  __CFData *Mutable;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  __int16 v24;
  CFIndex v25;
  __CFData *mStorageBuffer;
  BOOL v27;
  unsigned __int8 *MutableBytePtr;
  unsigned int v29;
  unsigned __int16 v30;
  int v31;
  unsigned int mMaxTileColumnIndex;
  BOOL v33;
  uint64_t v34;
  unsigned __int8 v35;
  int v36;
  unsigned int v37;
  unsigned int v39;
  unsigned __int8 v40;
  int v41;
  CFIndex v42;
  __CFData *v43;

  v5 = a1->mStorageOffsets[a2];
  if (a3)
  {
    -[TSPContainedObject willModify](a1, "willModify");
    if (v5 == 0xFFFF)
    {
      v21 = TSTCellStorageHeaderFlagsForCell((uint64_t)a3);
      v22 = TSTCellStorageFormatFlagsForCell(a3);
      v23 = TSTCellStorageSizeForHeaderFlags(v21, v22);
      v24 = v23;
      v25 = a1->mBufferSize + (unint64_t)v23;
      mStorageBuffer = a1->mStorageBuffer;
      if (v25)
        v27 = mStorageBuffer == 0;
      else
        v27 = 0;
      if (v27)
      {
        mStorageBuffer = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
        a1->mStorageBuffer = mStorageBuffer;
      }
      if (CFDataGetLength(mStorageBuffer) < v25)
      {
        CFDataSetLength(a1->mStorageBuffer, v25);
        a1->mBufferSize = v25;
      }
      MutableBytePtr = CFDataGetMutableBytePtr(a1->mStorageBuffer);
      v29 = p_OffsetForInsert(a1, a2, MutableBytePtr);
      v30 = v29;
      if (!a1->mMaxTileColumnIndexValid)
      {
        a1->mMaxTileColumnIndex = -1;
        v31 = 254;
        while ((__int16)a1->mStorageOffsets[v31] == -1)
        {
          if (--v31 == -1)
            goto LABEL_31;
        }
        a1->mMaxTileColumnIndex = v31;
LABEL_31:
        a1->mMaxTileColumnIndexValid = 1;
      }
      mMaxTileColumnIndex = a1->mMaxTileColumnIndex;
      if (a1->mCellCount)
        v33 = mMaxTileColumnIndex > a2;
      else
        v33 = 0;
      if (v33)
      {
        v34 = v29;
        memmove(&MutableBytePtr[v29 + v24], &MutableBytePtr[v29], a1->mBufferSize - ((v24 & ~(v24 >> 31)) + (unint64_t)v29));
        v35 = a2 + 1;
        do
        {
          v36 = a1->mStorageOffsets[v35];
          if (v36 != 0xFFFF)
            a1->mStorageOffsets[v35] = v36 + v24;
          ++v35;
        }
        while (mMaxTileColumnIndex >= v35);
      }
      else
      {
        v34 = v29;
      }
      TSTCellWriteStorageRef(a3, &MutableBytePtr[v34]);
      a1->mStorageOffsets[a2] = v30;
      ++a1->mCellCount;
      if (a1->mMaxTileColumnIndexValid)
      {
        v37 = a1->mMaxTileColumnIndex;
        if (v37 == 255 || v37 < a2)
          a1->mMaxTileColumnIndex = a2;
      }
    }
    else
    {
      v7 = CFDataGetMutableBytePtr(a1->mStorageBuffer);
      v8 = a1->mStorageOffsets[a2];
      v9 = &v7[v8];
      TSTCellStorageVersionAssert(&v7[v8]);
      v10 = TSTCellStorageHeaderFlagsForStorage((uint64_t)&v7[v8]);
      v11 = TSTCellStorageFormatFlagsForStorage(&v7[v8]);
      v12 = TSTCellStorageSizeForHeaderFlags(v10, v11);
      v13 = TSTCellStorageHeaderFlagsForCell((uint64_t)a3);
      v14 = TSTCellStorageFormatFlagsForCell(a3);
      v15 = TSTCellStorageSizeForHeaderFlags(v13, v14);
      v16 = v15 - v12;
      if (v15 != v12)
      {
        v17 = v16;
        if (v16 >= 1)
        {
          v18 = a1->mBufferSize + v16;
          Mutable = a1->mStorageBuffer;
          if (!Mutable)
          {
            Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
            a1->mStorageBuffer = Mutable;
          }
          if (CFDataGetLength(Mutable) < v18)
          {
            CFDataSetLength(a1->mStorageBuffer, v18);
            a1->mBufferSize = v18;
          }
          v7 = CFDataGetMutableBytePtr(a1->mStorageBuffer);
        }
        if (!a1->mMaxTileColumnIndexValid)
        {
          a1->mMaxTileColumnIndex = -1;
          v20 = 254;
          while ((__int16)a1->mStorageOffsets[v20] == -1)
          {
            if (--v20 == -1)
              goto LABEL_49;
          }
          a1->mMaxTileColumnIndex = v20;
LABEL_49:
          a1->mMaxTileColumnIndexValid = 1;
        }
        v39 = a1->mMaxTileColumnIndex;
        if (v39 > a2)
        {
          memmove(&v7[(unsigned __int16)(v12 + v8) + v17], &v7[(unsigned __int16)(v12 + v8)], a1->mBufferSize - ((v17 & ~(v17 >> 31)) + (unint64_t)(unsigned __int16)(v12 + v8)));
          v40 = a2 + 1;
          do
          {
            v41 = a1->mStorageOffsets[v40];
            if (v41 != 0xFFFF)
              a1->mStorageOffsets[v40] = v41 + v17;
            ++v40;
          }
          while (v39 >= v40);
        }
        if (v17 < 0)
        {
          v42 = a1->mBufferSize + (uint64_t)v17;
          v43 = a1->mStorageBuffer;
          if ((int)v42 >= 1 && v43 == 0)
          {
            v43 = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
            a1->mStorageBuffer = v43;
          }
          if (CFDataGetLength(v43) < v42)
          {
            CFDataSetLength(a1->mStorageBuffer, v42);
            a1->mBufferSize = v42;
          }
          v7 = CFDataGetMutableBytePtr(a1->mStorageBuffer);
        }
        v9 = &v7[v8];
      }
      TSTCellWriteStorageRef(a3, v9);
    }
  }
  else if (v5 != 0xFFFF)
  {
    p_RemoveCell(a1, a2);
  }
}

void p_RemoveCell(TSTTableTileRowInfo *a1, unsigned int a2)
{
  uint64_t v4;
  UInt8 *MutableBytePtr;
  int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  unsigned int mMaxTileColumnIndex;
  unsigned __int8 v12;
  int v13;
  CFIndex v14;
  __CFData *mStorageBuffer;

  -[TSPContainedObject willModify](a1, "willModify");
  v4 = a1->mStorageOffsets[a2];
  if (v4 != 0xFFFF)
  {
    MutableBytePtr = CFDataGetMutableBytePtr(a1->mStorageBuffer);
    TSTCellStorageVersionAssert(&MutableBytePtr[v4]);
    v6 = TSTCellStorageHeaderFlagsForStorage((uint64_t)&MutableBytePtr[v4]);
    v7 = TSTCellStorageFormatFlagsForStorage(&MutableBytePtr[v4]);
    v8 = TSTCellStorageSizeForHeaderFlags(v6, v7);
    v9 = v8;
    if (!a1->mMaxTileColumnIndexValid)
    {
      a1->mMaxTileColumnIndex = -1;
      v10 = 254;
      while ((__int16)a1->mStorageOffsets[v10] == -1)
      {
        if (--v10 == -1)
          goto LABEL_8;
      }
      a1->mMaxTileColumnIndex = v10;
LABEL_8:
      a1->mMaxTileColumnIndexValid = 1;
    }
    mMaxTileColumnIndex = a1->mMaxTileColumnIndex;
    if (mMaxTileColumnIndex > a2)
    {
      memmove(&MutableBytePtr[(unsigned __int16)(v8 + v4) + (__int16)-(__int16)v8], &MutableBytePtr[(unsigned __int16)(v8 + v4)], a1->mBufferSize- (((__int16)-(__int16)v8 & ~((__int16)-(__int16)v8 >> 31))+ (unint64_t)(unsigned __int16)(v8 + v4)));
      v12 = a2 + 1;
      do
      {
        v13 = a1->mStorageOffsets[v12];
        if (v13 != 0xFFFF)
          a1->mStorageOffsets[v12] = v13 - v9;
        ++v12;
      }
      while (mMaxTileColumnIndex >= v12);
    }
    v14 = a1->mBufferSize - (unint64_t)v9;
    mStorageBuffer = a1->mStorageBuffer;
    if (v14 >= 1 && mStorageBuffer == 0)
    {
      mStorageBuffer = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
      a1->mStorageBuffer = mStorageBuffer;
    }
    if (CFDataGetLength(mStorageBuffer) < v14)
    {
      CFDataSetLength(a1->mStorageBuffer, v14);
      a1->mBufferSize = v14;
    }
    a1->mStorageOffsets[a2] = -1;
    --a1->mCellCount;
    if (a1->mMaxTileColumnIndexValid && a1->mMaxTileColumnIndex <= a2)
    {
      a1->mMaxTileColumnIndex = -1;
      a1->mMaxTileColumnIndexValid = 0;
    }
  }
}

uint64_t TSTTableTileRowInfoInsertColumns(_BYTE *a1, char a2, unsigned int a3, char a4)
{
  uint64_t result;
  unsigned __int8 v9;
  unint64_t v10;
  _BYTE *v12;
  unint64_t v13;

  result = objc_msgSend(a1, "willModify");
  v9 = (a4 ^ 1) + a2;
  if (v9 + (_BYTE)a3 != 0xFF)
  {
    v10 = 254;
    do
      *(_WORD *)&a1[2 * v10 + 24] = *(_WORD *)&a1[2 * v10 + 24 + -2 * a3];
    while (v10-- > (v9 + a3));
  }
  if (((a4 ^ 1) + a2) < (v9 + a3))
  {
    v12 = &a1[2 * v9];
    v13 = (v9 + a3) - (unint64_t)v9;
    do
    {
      *((_WORD *)v12 + 12) = -1;
      v12 += 2;
      --v13;
    }
    while (v13);
  }
  a1[540] = -1;
  a1[541] = 0;
  return result;
}

void TSTTableTileRowInfoRemoveColumns(TSTTableTileRowInfo *a1, int a2, int a3)
{
  unsigned __int8 v6;
  int v7;
  uint64_t v8;

  -[TSPContainedObject willModify](a1, "willModify");
  if ((_BYTE)a3)
  {
    v6 = a2;
    do
    {
      if ((__int16)a1->mStorageOffsets[v6] != -1)
        p_RemoveCell(a1, v6);
      ++v6;
    }
    while (a2 + a3 > v6);
  }
  if (254 - a3 >= a2)
  {
    v7 = a2;
    do
    {
      a1->mStorageOffsets[a2++] = a1->mStorageOffsets[v7 + a3];
      v7 = a2;
    }
    while (254 - a3 >= a2);
  }
  if ((_BYTE)a3)
  {
    v8 = ~(_BYTE)a3;
    do
      a1->mStorageOffsets[v8++] = -1;
    while (v8 != 255);
  }
  a1->mMaxTileColumnIndex = -1;
  a1->mMaxTileColumnIndexValid = 0;
}

void TSTTableTileRowInfoMoveColumns(TSTTableTileRowInfo *a1, unsigned int a2, unsigned int a3, int a4, void *a5, unsigned __int16 *a6)
{
  unsigned __int8 v12;
  void *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int mMaxTileColumnIndex;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unsigned __int8 v22;
  UInt8 *MutableBytePtr;
  int v24;
  UInt8 *v25;
  int v26;
  void *v27;
  uint64_t v28;
  int v29;
  int v30;
  UInt8 *v31;
  UInt8 *v32;
  void *v33;
  unsigned __int16 *v34;
  unsigned int v35;
  unsigned __int8 v36;
  uint64_t v37;
  unsigned __int16 v38;
  __int16 v39;
  unsigned __int8 *v40;
  unsigned int v41;
  __int16 v42;
  unsigned __int8 *v43;
  uint64_t v44;
  char *v45;
  void *v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  void *__dst;
  unsigned __int16 *v52;
  unsigned int v53;
  unsigned __int16 *v54;
  unsigned int size;
  unsigned __int8 size_4;

  -[TSPContainedObject willModify](a1, "willModify");
  v12 = a3;
  if (a3 > a2)
  {
    if (a4 + a2 > a3)
    {
      v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableTileRowInfoMoveColumns(TSTTableTileRowInfo *, TSUColumnIndex, TSUColumnIndex, TSUColumnRowCount, UInt8 *, UInt16 *)");
      objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTileRowInfo.mm"), 520, CFSTR("Move column ranges cannot overlap!"));
    }
    v12 = a3 - a4;
  }
  if (a1->mCellCount)
  {
    if (!a1->mMaxTileColumnIndexValid)
    {
      a1->mMaxTileColumnIndex = -1;
      v15 = 254;
      while ((__int16)a1->mStorageOffsets[v15] == -1)
      {
        if (--v15 == -1)
          goto LABEL_12;
      }
      a1->mMaxTileColumnIndex = v15;
LABEL_12:
      a1->mMaxTileColumnIndexValid = 1;
    }
    mMaxTileColumnIndex = a1->mMaxTileColumnIndex;
    if (mMaxTileColumnIndex >= a3 || mMaxTileColumnIndex >= a2)
    {
      v18 = a2;
      v19 = (a2 + a4 - 1);
      do
      {
        v20 = v18;
        v21 = a1->mStorageOffsets[v18++];
      }
      while (v20 < v19 && (_DWORD)v21 == 0xFFFF);
      __dst = a5;
      v52 = a6;
      size = a4;
      size_4 = v12;
      v53 = a2;
      if ((_DWORD)v21 == 0xFFFF
        || (v22 = v18 - 1, MutableBytePtr = CFDataGetMutableBytePtr(a1->mStorageBuffer), v19 < v22))
      {
        LOWORD(v24) = 0;
      }
      else
      {
        v25 = MutableBytePtr;
        v24 = 0;
        do
        {
          v26 = a1->mStorageOffsets[v22];
          if (v26 != 0xFFFF)
          {
            if ((_DWORD)v21 + (unsigned __int16)v24 != v26)
            {
              v27 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
              v28 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableTileRowInfoRegion p_RegionForColumns(TSTTableTileRowInfo *, TSUColumnIndex, TSUColumnRowCount)");
              objc_msgSend(v27, "handleFailureInFunction:file:lineNumber:description:", v28, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTileRowInfo.mm"), 395, CFSTR("Storage region is out of sync!"));
            }
            TSTCellStorageVersionAssert(&v25[v26]);
            v29 = TSTCellStorageHeaderFlagsForStorage((uint64_t)&v25[v26]);
            v30 = TSTCellStorageFormatFlagsForStorage(&v25[v26]);
            v24 += TSTCellStorageSizeForHeaderFlags(v29, v30);
          }
          ++v22;
        }
        while (v19 >= v22);
      }
      v31 = CFDataGetMutableBytePtr(a1->mStorageBuffer);
      if ((_WORD)v24)
      {
        v32 = v31;
        v33 = a5;
        if (!a5)
          v33 = malloc_type_malloc((unsigned __int16)v24, 0x3D73AB96uLL);
        memcpy(v33, &v32[v21], (unsigned __int16)v24);
        v34 = v52;
        v35 = size;
        if (!v52)
          v34 = (unsigned __int16 *)malloc_type_calloc(2uLL, size, 0xE86D943EuLL);
        v36 = size_4;
        if ((_BYTE)size)
        {
          v37 = 0;
          do
          {
            v38 = a1->mStorageOffsets[v53 + v37];
            if (v38 == 0xFFFF)
              v39 = -1;
            else
              v39 = v38 - v21;
            v34[v37++] = v39;
          }
          while (size != v37);
        }
      }
      else
      {
        v33 = 0;
        v34 = 0;
        v35 = size;
        v36 = size_4;
      }
      TSTTableTileRowInfoRemoveColumns(a1, v53, v35);
      TSTTableTileRowInfoInsertColumns(a1, v36, v35, 1);
      v40 = CFDataGetMutableBytePtr(a1->mStorageBuffer);
      v41 = p_OffsetForInsert(a1, v36, v40);
      if (v33)
      {
        v42 = v41;
        v54 = v34;
        v43 = &v40[v41];
        memmove(&v43[(__int16)v24], v43, a1->mBufferSize - (((__int16)v24 & ~((__int16)v24 >> 31)) + (unint64_t)v41));
        memcpy(v43, v33, (unsigned __int16)v24);
        v44 = v35;
        if ((_BYTE)v35)
        {
          v45 = (char *)a1 + 2 * size_4;
          do
          {
            if (*((__int16 *)v45 + 12) != -1)
            {
              v46 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
              v47 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableTileRowInfoMoveColumns(TSTTableTileRowInfo *, TSUColumnIndex, TSUColumnIndex, TSUColumnRowCount, UInt8 *, UInt16 *)");
              objc_msgSend(v46, "handleFailureInFunction:file:lineNumber:description:", v47, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableTileRowInfo.mm"), 580, CFSTR("Overwriting a column in move!"));
            }
            v48 = *v34;
            if (v48 != 0xFFFF)
            {
              *((_WORD *)v45 + 12) = v48 + v42;
              ++a1->mCellCount;
            }
            v45 += 2;
            ++v34;
            --v44;
          }
          while (v44);
        }
        if (size_4 + (_BYTE)size != 0xFF)
        {
          v49 = (size_4 + size);
          do
          {
            v50 = a1->mStorageOffsets[v49];
            if (v50 != 0xFFFF)
              a1->mStorageOffsets[v49] = v50 + v24;
            ++v49;
          }
          while (v49 != 255);
        }
        if (v33 != __dst)
          free(v33);
        if (v54 != v52)
          free(v54);
      }
      a1->mMaxTileColumnIndex = -1;
      a1->mMaxTileColumnIndexValid = 0;
    }
  }
}

uint64_t p_OffsetForInsert(TSTTableTileRowInfo *a1, unsigned int a2, unsigned __int8 *a3)
{
  uint64_t v3;
  uint64_t v5;
  unsigned __int8 *v6;
  int v7;
  int v8;

  if (a2)
  {
    v3 = a2;
    while (v3-- >= 1)
    {
      v5 = a1->mStorageOffsets[v3];
      if (v5 != 0xFFFF)
      {
        v6 = &a3[v5];
        TSTCellStorageVersionAssert(&a3[v5]);
        v7 = TSTCellStorageHeaderFlagsForStorage((uint64_t)v6);
        v8 = TSTCellStorageFormatFlagsForStorage(v6);
        return (unsigned __int16)(TSTCellStorageSizeForHeaderFlags(v7, v8) + v5);
      }
    }
    return 0;
  }
  else
  {
    return 0;
  }
}

void sub_217BAA020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void SFUtility::ObjcSharedPtr<NSObject>::reset(void **a1, void *a2)
{
  id v4;
  void *v5;

  if (*a1 != a2)
  {
    v4 = a2;
    v5 = *a1;
    *a1 = a2;

  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,TSTIntHasher,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::equal_to<unsigned int>,TSTIntHasher,true>,std::allocator<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,SFUtility::ObjcSharedPtr<NSObject>>>(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  void *v13;
  id v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v12 = (_QWORD *)(a1 + 16);
  v10 = operator new(0x20uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *(_DWORD *)a3;
  v13 = *(void **)(a3 + 8);
  v10[3] = v13;
  v14 = v13;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v7 || (float)(v16 * (float)v7) < v15)
  {
    v17 = 1;
    if (v7 >= 3)
      v17 = (v7 & (v7 - 1)) != 0;
    v18 = v17 | (2 * v7);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::__unordered_map_hasher<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::hash<EQKit::StemStretch::Key>,std::equal_to<EQKit::StemStretch::Key>,true>,std::__unordered_map_equal<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::equal_to<EQKit::StemStretch::Key>,std::hash<EQKit::StemStretch::Key>,true>,std::allocator<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>>>::__rehash<true>(a1, v20);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *v10 = *v22;
LABEL_38:
    *v22 = v10;
    goto LABEL_39;
  }
  *v10 = *v12;
  *v12 = v10;
  *(_QWORD *)(v21 + 8 * v3) = v12;
  if (*v10)
  {
    v23 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v23 >= v7)
        v23 %= v7;
    }
    else
    {
      v23 &= v7 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_217BAA4AC(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<long long const,NSMutableArray * {__strong}>,void *>>>::operator()[abi:nn180100](v2, v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,TSTIntHasher,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::equal_to<unsigned int>,TSTIntHasher,true>,std::allocator<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::__erase_unique<unsigned int>(_QWORD *a1, unsigned int *a2)
{
  uint64_t *result;

  result = std::__hash_table<std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>>>::find<unsigned int>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,TSTIntHasher,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::equal_to<unsigned int>,TSTIntHasher,true>,std::allocator<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,TSTIntHasher,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::equal_to<unsigned int>,TSTIntHasher,true>,std::allocator<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  id *v3;
  void *__p;
  char v6;

  v2 = *a2;
  std::__hash_table<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::__unordered_map_hasher<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::hash<EQKit::StemStretch::Key>,std::equal_to<EQKit::StemStretch::Key>,true>,std::__unordered_map_equal<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::equal_to<EQKit::StemStretch::Key>,std::hash<EQKit::StemStretch::Key>,true>,std::allocator<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>>>::remove(a1, a2, (uint64_t)&__p);
  v3 = (id *)__p;
  __p = 0;
  if (v3)
  {
    if (v6)

    operator delete(v3);
  }
  return v2;
}

void std::__hash_table<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,TSTIntHasher,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::equal_to<unsigned int>,TSTIntHasher,true>,std::allocator<std::__hash_value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<long long const,NSMutableArray * {__strong}>,std::__unordered_map_hasher<long long const,std::__hash_value_type<long long const,NSMutableArray * {__strong}>,TSP::IdentifierHash,std::equal_to<long long const>,true>,std::__unordered_map_equal<long long const,std::__hash_value_type<long long const,NSMutableArray * {__strong}>,std::equal_to<long long const>,TSP::IdentifierHash,true>,std::allocator<std::__hash_value_type<long long const,NSMutableArray * {__strong}>>>::__deallocate_node(a1, *(id **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

double TSTTableBadgeCheckboxFrame(double a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, uint64_t a6, int a7, _QWORD *a8, uint64_t a9)
{
  void *v15;
  void *v16;
  uint64_t v17;
  double v18;
  double v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  double MidX;
  double v25;
  CGRect v26;
  CGRect v27;

  v25 = 0.0;
  v15 = (void *)p_TSTTableBadgeCheckboxImageForScale(a7, &v25, a1);
  if (!v15)
  {
    v16 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v17 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGRect TSTTableBadgeCheckboxFrame(TSTTableRep *, CGFloat, CGRect, BOOL, TSUImage **, CGSize *)");
    objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableBadge.m"), 196, CFSTR("No checkbox image for rendering!"));
  }
  objc_msgSend(v15, "size");
  v20 = TSDMultiplySizeScalar(v18, v19, v25);
  v22 = v21;
  v26.origin.x = a2;
  v26.origin.y = a3;
  v26.size.width = a4;
  v26.size.height = a5;
  MidX = CGRectGetMidX(v26);
  v27.origin.x = a2;
  v27.origin.y = a3;
  v27.size.width = a4;
  v27.size.height = a5;
  CGRectGetMidY(v27);
  if (a8)
    *a8 = v15;
  if (a9)
  {
    *(double *)a9 = v20;
    *(_QWORD *)(a9 + 8) = v22;
  }
  return MidX - v20 * 0.5;
}

uint64_t p_TSTTableBadgeCheckboxImageForScale(int a1, double *a2, double a3)
{
  void *v5;
  uint64_t v6;
  const __CFString *v7;
  uint64_t result;
  double v9;

  if (a1)
  {
    if (a3 > 0.5)
    {
      if (a3 <= 1.0)
      {
        v5 = (void *)MEMORY[0x24BEB3C90];
        v6 = TSTBundle();
        v7 = CFSTR("TSTiOSCheckboxChecked12");
      }
      else
      {
        v5 = (void *)MEMORY[0x24BEB3C90];
        v6 = TSTBundle();
        if (a3 <= 1.5)
          v7 = CFSTR("TSTiOSCheckboxChecked18");
        else
          v7 = CFSTR("TSTiOSCheckboxChecked24");
      }
    }
    else
    {
      v5 = (void *)MEMORY[0x24BEB3C90];
      v6 = TSTBundle();
      v7 = CFSTR("TSTiOSCheckboxChecked6");
    }
  }
  else if (a3 > 0.5)
  {
    if (a3 <= 1.0)
    {
      v5 = (void *)MEMORY[0x24BEB3C90];
      v6 = TSTBundle();
      v7 = CFSTR("TSTiOSCheckboxUnchecked12");
    }
    else
    {
      v5 = (void *)MEMORY[0x24BEB3C90];
      v6 = TSTBundle();
      if (a3 <= 1.5)
        v7 = CFSTR("TSTiOSCheckboxUnchecked18");
      else
        v7 = CFSTR("TSTiOSCheckboxUnchecked24");
    }
  }
  else
  {
    v5 = (void *)MEMORY[0x24BEB3C90];
    v6 = TSTBundle();
    v7 = CFSTR("TSTiOSCheckboxUnchecked6");
  }
  result = objc_msgSend(v5, "imageNamed:inBundle:", v7, v6);
  if (a2)
  {
    v9 = 2.0;
    if (a3 > 0.5)
    {
      v9 = 1.0;
      if (a3 > 1.0)
      {
        v9 = 0.666666687;
        if (a3 > 1.5)
          v9 = 0.5;
      }
    }
    *a2 = v9;
  }
  return result;
}

CGFloat TSTTableBadgeRatingsFrame(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  TSDCenterOfRect(a1, a2, a3, a4);
  return a1;
}

BOOL TSTTableBadgeIsDrawingControlCell(_BOOL8 result)
{
  unsigned int v1;

  if (result)
  {
    v1 = *(_DWORD *)(result + 104) - 263;
    return v1 <= 4 && (v1 & 0xFFFFFFFB) == 0;
  }
  return result;
}

void TSTTableBadgeDrawCellControl(uint64_t a1, CGContext *a2, uint64_t a3, unsigned int a4, double a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9)
{
  void *v17;
  int v18;
  void *v19;
  uint64_t v20;
  int v21;
  int v22;
  void *v23;
  uint64_t v24;
  uint64_t FontColorForCell;
  double v26;
  void *v28;
  uint64_t v29;
  double v30;
  double v31;
  CGFloat v32;
  double v33;
  CGFloat v34;
  double v35;
  CGFloat v36;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CGFloat v41;
  CGFloat v42;
  CGFloat v43;
  CGFloat v44;
  CGFloat MinX;
  CGFloat MaxY;
  CGImage *v47;
  CGAffineTransform v48;
  CGAffineTransform v49;
  CGAffineTransform v50;
  __int128 v51;
  id v52;
  CGRect v53;
  CGRect v54;
  CGRect v55;
  CGRect v56;
  CGRect v57;
  CGRect v58;
  CGRect v59;
  CGRect v60;
  CGRect v61;

  if (a3)
  {
    v17 = (void *)a1;
    v18 = *(_DWORD *)(a3 + 104);
    if ((v18 - 263) >= 5)
    {
      v19 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v20 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableBadgeDrawCellControl(TSTTableRep *, CGContextRef, CGFloat, CGRect, TSTCell *, TSTCellID)");
      a1 = objc_msgSend(v19, "handleFailureInFunction:file:lineNumber:description:", v20, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableBadge.m"), 247, CFSTR("Can't render controls on a cell without controls!"));
      v18 = *(_DWORD *)(a3 + 104);
    }
    v21 = BYTE1(*(_DWORD *)(a3 + 8));
    if (v18 == 267)
    {
      FontColorForCell = TSTTableGetFontColorForCell((uint64_t *)objc_msgSend(v17, "tableModel"), a3, a4);
      v26 = 0.0;
      if (v21 == 2)
      {
        if ((*(_DWORD *)(a3 + 8) & 0xFB00) == 0x200 || BYTE1(*(_DWORD *)(a3 + 8)) == 7)
        {
          v26 = *(double *)(a3 + 16);
        }
        else if (BYTE1(*(_DWORD *)(a3 + 8)))
        {
          v28 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v29 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
          objc_msgSend(v28, "handleFailureInFunction:file:lineNumber:description:", v29, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a3);
        }
      }
      +[TSKStarRatingViewRenderer renderRating:intoContext:rect:style:showDots:color:](TSKStarRatingViewRenderer, "renderRating:intoContext:rect:style:showDots:color:", llround(v26), a2, 0, 1, FontColorForCell, a6, a7, a8, a9);
    }
    else if (v18 == 263)
    {
      v22 = v21 == 6 && *(double *)(a3 + 16) != 0.0;
      v52 = 0;
      v51 = *MEMORY[0x24BDBF148];
      v30 = TSTTableBadgeCheckboxFrame(a5, a6, a7, a8, a9, a1, v22, &v52, (uint64_t)&v51);
      v32 = v31;
      v34 = v33;
      v36 = v35;
      memset(&v50, 0, sizeof(v50));
      CGContextGetUserSpaceToDeviceSpaceTransform(&v50, a2);
      v49 = v50;
      v53.origin.x = v30;
      v53.origin.y = v32;
      v53.size.width = v34;
      v53.size.height = v36;
      v54 = CGRectApplyAffineTransform(v53, &v49);
      v55 = CGRectIntegral(v54);
      x = v55.origin.x;
      y = v55.origin.y;
      width = v55.size.width;
      height = v55.size.height;
      v49 = v50;
      CGAffineTransformInvert(&v48, &v49);
      v56.origin.x = x;
      v56.origin.y = y;
      v56.size.width = width;
      v56.size.height = height;
      v57 = CGRectApplyAffineTransform(v56, &v48);
      v41 = v57.origin.x;
      v42 = v57.origin.y;
      v43 = v57.size.width;
      v44 = v57.size.height;
      CGContextSaveGState(a2);
      v58.origin.x = a6;
      v58.origin.y = a7;
      v58.size.width = a8;
      v58.size.height = a9;
      CGContextClipToRect(a2, v58);
      v59.origin.x = v41;
      v59.origin.y = v42;
      v59.size.width = v43;
      v59.size.height = v44;
      MinX = CGRectGetMinX(v59);
      v60.origin.x = v41;
      v60.origin.y = v42;
      v60.size.width = v43;
      v60.size.height = v44;
      MaxY = CGRectGetMaxY(v60);
      CGContextTranslateCTM(a2, MinX, MaxY);
      CGContextScaleCTM(a2, 1.0, -1.0);
      v47 = (CGImage *)objc_msgSend(v52, "CGImageForSize:inContext:orLayer:", a2, 0, v51);
      v61.origin.x = TSDRectWithSize();
      CGContextDrawImage(a2, v61, v47);
      CGContextRestoreGState(a2);
    }
  }
  else
  {
    v23 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v24 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableBadgeDrawCellControl(TSTTableRep *, CGContextRef, CGFloat, CGRect, TSTCell *, TSTCellID)");
    objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v24, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableBadge.m"), 247, CFSTR("Can't render controls on a cell without controls!"));
  }
}

void TSTTableBadgeCellErrorIndicatorFrame(double a1, double a2, double a3, double a4)
{
  double v4;
  double v5;
  double v6;

  v4 = fmin(a3, a4) * 0.899999976;
  v5 = 2.0;
  if (v4 >= 2.0)
  {
    if (v4 >= 4.0)
    {
      v5 = 4.0;
      if (v4 >= 8.0)
      {
        v5 = 8.0;
        if (v4 >= 16.0)
        {
          v5 = 16.0;
          if (v4 >= 32.0)
            v5 = 32.0;
        }
      }
    }
    v6 = a1 + a3 * 0.5 - v5 * 0.5;
    TSDRoundedSize();
    TSDFlooredPoint(v6);
  }
}

void TSTTableBadgeDrawCellErrorIndicator(CGContext *a1, double a2, double a3, double a4, double a5, double a6)
{
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  void *v20;
  CGImage *v21;
  CGFloat tx;
  CGAffineTransform v23;
  CGRect v24;
  CGRect v25;

  TSTTableBadgeCellErrorIndicatorFrame(a3, a4, a5, a6);
  tx = v13;
  v15 = v14;
  v16 = v12;
  v18 = v17;
  if (a2 <= 1.0)
  {
    v19 = v12;
    if (a2 <= 0.5)
      v19 = v12 * 0.5;
  }
  else
  {
    v19 = v12 + v12;
  }
  v20 = (void *)p_TSTTableBadgeErrorIndicatorImageForSize(v19);
  CGContextSaveGState(a1);
  v24.origin.x = a3;
  v24.origin.y = a4;
  v24.size.width = a5;
  v24.size.height = a6;
  CGContextClipToRect(a1, v24);
  CGContextTranslateCTM(a1, tx, v15 + v18);
  memset(&v23, 0, sizeof(v23));
  CGContextGetCTM(&v23, a1);
  v23.tx = ceil(v23.tx) - v23.tx;
  v23.ty = v23.ty - ceil(v23.ty);
  CGContextTranslateCTM(a1, v23.tx, v23.ty);
  CGContextScaleCTM(a1, 1.0, -1.0);
  v21 = (CGImage *)objc_msgSend(v20, "CGImageForSize:inContext:orLayer:", a1, 0, v16, v18);
  v25.origin.x = TSDRectWithSize();
  CGContextDrawImage(a1, v25, v21);
  CGContextRestoreGState(a1);
}

uint64_t p_TSTTableBadgeErrorIndicatorImageForSize(double a1)
{
  void *v2;
  uint64_t v3;
  const __CFString *v4;

  if (a1 >= 4.0)
  {
    if (a1 >= 8.0)
    {
      if (a1 >= 16.0)
      {
        if (a1 >= 32.0)
        {
          v2 = (void *)MEMORY[0x24BEB3C90];
          v3 = TSTBundle();
          if (a1 >= 64.0)
            v4 = CFSTR("TSTErrorMessageIcon-64");
          else
            v4 = CFSTR("TSTErrorMessageIcon-32");
        }
        else
        {
          v2 = (void *)MEMORY[0x24BEB3C90];
          v3 = TSTBundle();
          v4 = CFSTR("TSTErrorMessageIcon-16");
        }
      }
      else
      {
        v2 = (void *)MEMORY[0x24BEB3C90];
        v3 = TSTBundle();
        v4 = CFSTR("TSTErrorMessageIcon-8");
      }
    }
    else
    {
      v2 = (void *)MEMORY[0x24BEB3C90];
      v3 = TSTBundle();
      v4 = CFSTR("TSTErrorMessageIcon-4");
    }
  }
  else
  {
    v2 = (void *)MEMORY[0x24BEB3C90];
    v3 = TSTBundle();
    v4 = CFSTR("TSTErrorMessageIcon-2");
  }
  return objc_msgSend(v2, "imageNamed:inBundle:", v4, v3);
}

CGPath *newTSTTableBadgeCellCommentBadgePath(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  CGFloat v8;
  CGFloat v9;
  CGPath *Mutable;
  CGRect v12;

  v8 = CGRectGetMaxX(*(CGRect *)&a1) + -9.0 + -1.0;
  v12.origin.x = a1;
  v12.origin.y = a2;
  v12.size.width = a3;
  v12.size.height = a4;
  v9 = CGRectGetMinY(v12) + 1.0;
  Mutable = CGPathCreateMutable();
  CGPathMoveToPoint(Mutable, 0, v8, v9);
  CGPathAddLineToPoint(Mutable, 0, v8 + 9.0, v9);
  CGPathAddLineToPoint(Mutable, 0, v8 + 9.0, v9 + 9.0);
  CGPathAddLineToPoint(Mutable, 0, v8, v9);
  return Mutable;
}

void TSTTableBadgeDrawCellOverflowIndicator(CGContext *a1, double a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double y;
  CGFloat v22;
  CGFloat x;
  CGFloat v24;
  CGFloat v25;
  CGFloat height;
  CGFloat v27;
  CGFloat v28;
  CGFloat v29;
  CGFloat v30;
  CGPath *v31;
  double width;
  double v33;
  CGFloat v34;
  double v35;
  CGFloat v36;
  double v37;
  CGFloat v38;
  double v39;
  CGFloat v40;
  CGFloat v41;
  double v42;
  double v43;
  double v44;
  CGAffineTransform v45;
  CGAffineTransform v46;
  CGAffineTransform v47;
  CGRect v48;
  CGRect v49;
  CGRect v50;
  CGRect v51;
  CGRect v52;
  CGRect v53;
  CGRect v54;
  CGRect v55;

  if (objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "showsCellOverflowIndicator"))
  {
    v12 = TSDCGContextAssociatedScreenScale((uint64_t)a1);
    if (a2 >= 0.75)
    {
      v14 = v12 * 12.5;
      v15 = v12 * 2.5;
      v16 = v12 * 11.0;
      v17 = v12 * 7.0;
      if (a2 < 1.0)
        v18 = v12 * 5.0;
      else
        v18 = v12 * 7.0;
      if (a2 < 1.0)
        v17 = v12 * 5.0;
      v42 = v17;
      if (a2 < 1.0)
        v16 = v12 * 8.0;
      v43 = v16;
      v44 = v18;
      if (a2 < 1.0)
        v19 = v12 * 3.0;
      else
        v19 = v12 * 4.0;
      if (a2 < 1.0)
        v20 = v12 * 6.0;
      else
        v20 = v12 * 8.0;
      v37 = v19;
      v39 = v20;
      if (a2 < 1.0)
        v13 = v12 * 8.0;
      else
        v13 = v12 * 10.0;
      if (a2 < 1.0)
      {
        v15 = v12 * 1.5;
        v14 = v12 * 9.5;
      }
      v33 = v14;
      v35 = v15;
    }
    else
    {
      v33 = v12 * 7.5;
      v35 = v12 * 1.5;
      v13 = v12 * 6.0;
      v42 = v12 * 4.0;
      v43 = v12 * 6.0;
      v44 = v12 * 3.0;
      v37 = v12 * 3.0;
      v39 = v12 * 5.0;
    }
    v41 = 1.0 / a2;
    CGContextSaveGState(a1);
    v48.origin.x = a3;
    v48.origin.y = a4;
    v48.size.width = a5;
    v48.size.height = a6;
    CGContextClipToRect(a1, v48);
    memset(&v47, 0, sizeof(v47));
    CGContextGetCTM(&v47, a1);
    v47.tx = ceil(v47.tx) - v47.tx;
    v47.ty = v47.ty - ceil(v47.ty);
    v45 = v47;
    memset(&v46, 0, sizeof(v46));
    CGAffineTransformInvert(&v46, &v45);
    v45 = v47;
    v49.origin.x = a3;
    v49.origin.y = a4;
    v49.size.width = a5;
    v49.size.height = a6;
    v50 = CGRectApplyAffineTransform(v49, &v45);
    y = v50.origin.y;
    width = v12 * v46.c + v46.a * v12;
    v22 = v50.origin.x + v50.size.width;
    v50.origin.x = v50.origin.x + v50.size.width - v33;
    v50.origin.y = v35 + v50.origin.y;
    v45 = v46;
    v50.size.width = v13;
    v50.size.height = v13;
    v51 = CGRectApplyAffineTransform(v50, &v45);
    x = v51.origin.x;
    v24 = v51.origin.y;
    v25 = v51.size.width;
    height = v51.size.height;
    v51.origin.x = v22 - v39;
    v51.origin.y = v37 + y;
    v45 = v46;
    v51.size.width = v12;
    v51.size.height = v44;
    v52 = CGRectApplyAffineTransform(v51, &v45);
    v38 = v52.origin.y;
    v40 = v52.origin.x;
    v34 = v52.size.height;
    v36 = v52.size.width;
    v52.origin.x = v22 - v43;
    v52.origin.y = v42 + y;
    v45 = v46;
    v52.size.width = v44;
    v52.size.height = v12;
    v53 = CGRectApplyAffineTransform(v52, &v45);
    v27 = v53.origin.x;
    v28 = v53.origin.y;
    v29 = v53.size.width;
    v30 = v53.size.height;
    CGContextSetLineWidth(a1, width);
    v31 = TSDCreateRoundRectPathForRectWithRadius(x, v24, v25, height, v41);
    CGContextSaveGState(a1);
    CGContextSetStrokeColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend(MEMORY[0x24BEB3C40], "blackColor"), "CGColor"));
    CGContextSetFillColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend(MEMORY[0x24BEB3C40], "whiteColor"), "CGColor"));
    CGContextAddPath(a1, v31);
    CGContextDrawPath(a1, kCGPathFillStroke);
    CGContextRestoreGState(a1);
    CGContextSaveGState(a1);
    CGContextSetFillColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend(MEMORY[0x24BEB3C40], "blackColor"), "CGColor"));
    v54.origin.y = v38;
    v54.origin.x = v40;
    v54.size.height = v34;
    v54.size.width = v36;
    CGContextFillRect(a1, v54);
    v55.origin.x = v27;
    v55.origin.y = v28;
    v55.size.width = v29;
    v55.size.height = v30;
    CGContextFillRect(a1, v55);
    CGContextRestoreGState(a1);
    CGPathRelease(v31);
    CGContextRestoreGState(a1);
  }
}

double TSTTableBadgeCellWarningIndicatorFrame()
{
  return *MEMORY[0x24BDBF090];
}

double TSTTableBadgeCheckboxSizeForScale(int a1, double a2, double a3)
{
  CGImage *v4;
  CGImage *v5;
  size_t Width;
  double v7;
  double v9;

  v9 = 0.0;
  v4 = (CGImage *)objc_msgSend((id)p_TSTTableBadgeCheckboxImageForScale(a1, &v9, a2), "CGImage");
  if (!v4)
    return *MEMORY[0x24BDBF148];
  v5 = v4;
  Width = CGImageGetWidth(v4);
  v7 = v9 / a3 * (double)Width;
  CGImageGetHeight(v5);
  return v7;
}

void TSTTableBadgeDrawHorizontalShadow(CGContext *a1, int a2, CGFloat a3, double a4, CGFloat a5, double a6, CGFloat a7)
{
  double v14;
  double v15;
  double *v16;
  double v17;
  double v18;
  uint64_t v19;
  void *v20;
  double v21;

  v14 = TSDCGContextAssociatedScreenScale((uint64_t)a1);
  if (a2 == 2)
    v15 = a7;
  else
    v15 = -0.0;
  if (v14 == 1.0)
    v16 = (double *)&TSTTableBadgeShadowAlphaValues1x;
  else
    v16 = (double *)&TSTTableBadgeShadowAlphaValues2x;
  v17 = a4 + a7 * 0.5;
  v18 = a6 + a7 * 0.5;
  if (v14 == 1.0)
    v19 = 5;
  else
    v19 = 10;
  do
  {
    a5 = v15 + a5;
    CGContextSaveGState(a1);
    CGContextBeginPath(a1);
    CGContextMoveToPoint(a1, a3, v17);
    CGContextAddLineToPoint(a1, a5, v18);
    CGContextSetLineWidth(a1, a7);
    v20 = (void *)objc_msgSend(MEMORY[0x24BEB3C40], "blackColor");
    v21 = *v16++;
    CGContextSetStrokeColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend(v20, "colorWithAlphaComponent:", v21), "CGColor"));
    CGContextStrokePath(a1);
    CGContextRestoreGState(a1);
    v17 = v17 + a7;
    v18 = v18 + a7;
    --v19;
  }
  while (v19);
}

void TSTTableBadgeDrawVerticalShadow(CGContext *a1, int a2, double a3, CGFloat a4, double a5, CGFloat a6, CGFloat a7)
{
  double v14;
  double v15;
  double *v16;
  double v17;
  double v18;
  uint64_t v19;
  void *v20;
  double v21;

  v14 = TSDCGContextAssociatedScreenScale((uint64_t)a1);
  if (a2 == 2)
    v15 = a7;
  else
    v15 = -0.0;
  if (v14 == 1.0)
    v16 = (double *)&TSTTableBadgeShadowAlphaValues1x;
  else
    v16 = (double *)&TSTTableBadgeShadowAlphaValues2x;
  v17 = a3 + a7 * 0.5;
  v18 = a5 + a7 * 0.5;
  if (v14 == 1.0)
    v19 = 5;
  else
    v19 = 10;
  do
  {
    CGContextSaveGState(a1);
    CGContextBeginPath(a1);
    CGContextMoveToPoint(a1, v17, a4);
    CGContextAddLineToPoint(a1, v18, a6);
    CGContextSetLineWidth(a1, a7);
    v20 = (void *)objc_msgSend(MEMORY[0x24BEB3C40], "blackColor");
    v21 = *v16++;
    CGContextSetStrokeColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend(v20, "colorWithAlphaComponent:", v21), "CGColor"));
    CGContextStrokePath(a1);
    CGContextRestoreGState(a1);
    v17 = v17 + a7;
    v18 = v18 + a7;
    a6 = v15 + a6;
    --v19;
  }
  while (v19);
}

uint64_t TSTTableBadgeContentsCenterInfoInit(uint64_t result, double a2, double a3, double a4, double a5, double a6, double a7)
{
  double *v13;
  void *v14;
  uint64_t v15;

  v13 = (double *)result;
  if (!result)
  {
    v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableBadgeContentsCenterInfoInit(TSTTableBadgeContentsCenterInfo *, CGFloat, CGFloat, CGFloat, CGFloat, CGFloat, CGFloat)");
    result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableBadge.m"), 738, CFSTR("invalid nil value for '%s'"), "info");
  }
  v13[1] = a2;
  v13[2] = a3;
  v13[3] = a4;
  v13[4] = a5;
  v13[5] = a6;
  v13[6] = a7;
  return result;
}

uint64_t TSTTableDataStoreHeaderInfoForRow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend(*(id *)(a1 + 40), "headerForKey:willModify:createIfNotThere:", a2, a3, a4);
}

uint64_t TSTTableDataStoreHeaderInfoForColumn(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "headerForKey:willModify:createIfNotThere:", a2, a3, a4);
}

uint64_t privateRemoveIndexedItemsFromStorage(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3;
  void *v4;
  unsigned int v5;

  if (a3)
  {
    v3 = a2;
    v4 = (void *)result;
    v5 = a3 + a2;
    do
    {
      result = objc_msgSend(v4, "removeHeaderForKey:", v3);
      v3 = (v3 + 1);
    }
    while (v3 < v5);
  }
  return result;
}

uint64_t TSTTableDataStoreRemoveRowHeadersAtIndex(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3;
  void *v4;
  unsigned int v5;

  if (a3)
  {
    v3 = a2;
    v4 = *(void **)(result + 40);
    v5 = a3 + a2;
    do
    {
      result = objc_msgSend(v4, "removeHeaderForKey:", v3);
      v3 = (v3 + 1);
    }
    while (v3 < v5);
  }
  return result;
}

uint64_t TSTTableDataStoreShiftRowHeaderIndexes(TSTTableDataStore *a1, uint64_t a2, uint64_t a3)
{
  return -[TSTTableHeaderStorage shiftKeysAtIndex:amount:](a1->mRowHeaderStorage, "shiftKeysAtIndex:amount:", a2, a3);
}

uint64_t TSTTableDataStoreShiftColumnHeaderIndexes(TSTTableDataStore *a1, uint64_t a2, uint64_t a3)
{
  return objc_msgSend(-[TSPLazyReference object](a1->mColumnHeaderStorageReference, "object"), "shiftKeysAtIndex:amount:", a2, a3);
}

uint64_t TSTTableDataStoreRemoveColumnHeadersAtIndex(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result;
  void *v6;
  unsigned int v7;

  result = objc_msgSend(*(id *)(a1 + 48), "object");
  if (a3)
  {
    v6 = (void *)result;
    v7 = a3 + a2;
    do
    {
      result = objc_msgSend(v6, "removeHeaderForKey:", a2);
      a2 = (a2 + 1);
    }
    while (a2 < v7);
  }
  return result;
}

uint64_t TSTDataStoreDecrementColumnCellCount(uint64_t result, TSTTableHeaderInfo *a2)
{
  uint64_t v3;
  unsigned __int16 mNumberOfCells;
  void *v5;
  uint64_t v6;
  int v7;
  void *v8;
  uint64_t v9;

  v3 = result;
  mNumberOfCells = a2->mNumberOfCells;
  if (!mNumberOfCells)
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTDataStoreDecrementColumnCellCount(TSTTableDataStore *, TSTTableHeaderInfo *)");
    result = objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 120, CFSTR("Can't drive column cell count below zero!"));
    mNumberOfCells = a2->mNumberOfCells;
  }
  a2->mNumberOfCells = mNumberOfCells - 1;
  if (*(_BYTE *)(v3 + 156))
  {
    v7 = *(_DWORD *)(v3 + 152);
    if (!v7)
    {
      v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTDataStoreDecrementColumnCellCount(TSTTableDataStore *, TSTTableHeaderInfo *)");
      result = objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 124, CFSTR("Can't drive cell count below zero!"));
      v7 = *(_DWORD *)(v3 + 152);
    }
    *(_DWORD *)(v3 + 152) = v7 - 1;
  }
  return result;
}

uint64_t TSTDataStoreIncrementColumnCellCount(uint64_t result, TSTTableHeaderInfo *a2)
{
  if (*(_BYTE *)(result + 156))
    ++*(_DWORD *)(result + 152);
  ++a2->mNumberOfCells;
  return result;
}

void TSTDataStoreDecrementRowCellCount(TSTTableDataStore *a1, TSTTableHeaderInfo *a2)
{
  unsigned __int16 mNumberOfCells;
  void *v4;
  uint64_t v5;

  mNumberOfCells = a2->mNumberOfCells;
  if (!mNumberOfCells)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTDataStoreDecrementRowCellCount(TSTTableDataStore *, TSTTableHeaderInfo *)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 140, CFSTR("Can't drive row cell count below zero!"));
    mNumberOfCells = a2->mNumberOfCells;
  }
  a2->mNumberOfCells = mNumberOfCells - 1;
}

void TSTDataStoreIncrementRowCellCount(TSTTableDataStore *a1, TSTTableHeaderInfo *a2)
{
  ++a2->mNumberOfCells;
}

uint64_t TSTTableDataStoreDecrementCellCounts(uint64_t a1, uint64_t a2, uint64_t a3)
{
  TSTTableDataStore *v6;
  TSTTableHeaderInfo *v7;
  void *v8;
  uint64_t v9;
  TSTTableHeaderInfo *v10;

  v6 = (TSTTableDataStore *)objc_msgSend(*(id *)(a1 + 40), "headerForKey:willModify:createIfNotThere:", a3, 1, 1);
  v7 = (TSTTableHeaderInfo *)v6;
  if (!v6)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSUError TSTTableDataStoreDecrementCellCounts(TSTTableDataStore *, TSUColumnIndex, TSURowIndex)");
    v6 = (TSTTableDataStore *)objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 154, CFSTR("invalid nil value for '%s'"), "rowInfo");
  }
  TSTDataStoreDecrementRowCellCount(v6, v7);
  if (v7->mSize == 0.0 && !v7->mNumberOfCells && !v7->mCellStyle && !v7->mTextStyle && !v7->mHidingState)
    objc_msgSend(*(id *)(a1 + 40), "removeHeaderForKey:", a3);
  v10 = (TSTTableHeaderInfo *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "headerForKey:willModify:createIfNotThere:", a2, 1, 1);
  TSTDataStoreDecrementColumnCellCount(a1, v10);
  if (v10->mSize == 0.0 && !v10->mNumberOfCells && !v10->mCellStyle && !v10->mTextStyle && !v10->mHidingState)
    objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "removeHeaderForKey:", a2);
  return 0;
}

uint64_t TSTTableDataStoreIncrementCellCounts(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = objc_msgSend(*(id *)(a1 + 40), "headerForKey:willModify:createIfNotThere:", a3, 1, 1);
  if (!v5)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSUError TSTTableDataStoreIncrementCellCounts(TSTTableDataStore *, TSUColumnIndex, TSURowIndex)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 173, CFSTR("invalid nil value for '%s'"), "rowInfo");
  }
  ++*(_WORD *)(v5 + 34);
  v8 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "headerForKey:willModify:createIfNotThere:", a2, 1, 1);
  if (*(_BYTE *)(a1 + 156))
    ++*(_DWORD *)(a1 + 152);
  ++*(_WORD *)(v8 + 34);
  return 0;
}

uint64_t TSTTableDataStoreNumberOfPopulatedCells(uint64_t a1)
{
  int v3;

  if (!*(_BYTE *)(a1 + 156))
  {
    v3 = 0;
    objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "applyFunction:withState:willModify:", p_countCellsInColumn, &v3, 0);
    *(_DWORD *)(a1 + 152) = v3;
    *(_BYTE *)(a1 + 156) = 1;
  }
  return *(unsigned int *)(a1 + 152);
}

void p_countCellsInColumn(unsigned int a1, objc_object *a2, _DWORD *a3)
{
  *a3 += WORD1(a2[4].isa);
}

uint64_t TSTTableDataStoreNumberOfFormulas(uint64_t a1)
{
  return TSTTableDataListGetCount(objc_msgSend(*(id *)(a1 + 80), "object"));
}

uint64_t p_findEmptyTiles(uint64_t result, unsigned int a2, id *a3)
{
  unsigned int v4;

  if ((_DWORD)result)
  {
    v4 = result;
    result = objc_msgSend((id)objc_msgSend(*((id *)*a3 + 4), "tileForID:", a2), "numRows");
    if (!(_DWORD)result)
      return objc_msgSend(a3[1], "addIndex:", v4);
  }
  return result;
}

id TSTDataStoreGetTileForRow(TSTTableDataStore *a1, unsigned int a2, unsigned __int16 *a3)
{
  return -[TSTTileIDKeyDict tileForID:](a1->mTileStorage, "tileForID:", TSTTableRBTreeStripIDForCellIndex(&a1->mRowTileIndex->var0, a2, a3));
}

uint64_t p_TileForRowIndex(uint64_t a1, unsigned int a2, unsigned __int16 *a3, unsigned int *a4)
{
  unsigned int v6;
  uint64_t result;

  v6 = TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)(a1 + 24), a2, a3);
  result = objc_msgSend(*(id *)(a1 + 32), "tileForID:", v6);
  if (a4)
  {
    if (result)
      *a4 = v6;
  }
  return result;
}

id TSTDataStoreGetTileAtOrAfterRow(TSTTableDataStore *a1, unsigned int a2, unsigned __int16 *a3)
{
  unsigned __int16 *v6;

  v6 = TSTTableRBFirstNodeGreaterThanOrEqualTo(&a1->mRowTileIndex->var0, a2);
  if (a2 && v6 == (unsigned __int16 *)&TSTTableRBTreeNil)
    return 0;
  if (a3)
    *a3 = *v6;
  return -[TSTTileIDKeyDict tileForID:](a1->mTileStorage, "tileForID:", v6[1]);
}

TSTTableTile *TSTDataStoreGetRowInfoForRow(TSTTableDataStore *a1, unsigned int a2)
{
  __int16 v2;
  TSTTableTile *result;
  unsigned __int16 v4;

  v2 = a2;
  v4 = -1;
  result = -[TSTTileIDKeyDict tileForID:](a1->mTileStorage, "tileForID:", TSTTableRBTreeStripIDForCellIndex(&a1->mRowTileIndex->var0, a2, &v4));
  if (result)
    return (TSTTableTile *)TSTTableTileRowInfoForTileRowIndex(result, (unsigned __int16)(v2 - v4), 0);
  return result;
}

uint64_t TSTTableDataStoreIterateTiles(TSTTableDataStore *a1, TSTTableRBTreeNode_s *a2, void *a3, void (*a4)(TSTTableTile *, void *))
{
  TSTTableRBTreeNode_s *var2;
  id v9;
  void *v10;
  uint64_t v11;
  uint64_t result;

  do
  {
    var2 = a2->var2;
    if (var2 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil)
      TSTTableDataStoreIterateTiles(a1, var2, a3, a4);
    v9 = -[TSTTileIDKeyDict tileForID:](a1->mTileStorage, "tileForID:", a2->var1);
    if (!v9)
    {
      v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreIterateTiles(TSTTableDataStore *, TSTTableRBTreeNode *, void *, void (*)(TSTTableTile *, void *))");
      objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 411, CFSTR("failure while iterating over tiles: error retrieving tile"));
    }
    result = ((uint64_t (*)(id, void *))a4)(v9, a3);
    a2 = a2->var3;
  }
  while (a2 != (TSTTableRBTreeNode_s *)&TSTTableRBTreeNil);
  return result;
}

UInt8 *TSTTableDataStoreCellStorageRefAtCellID(uint64_t a1, int a2)
{
  TSTTableTile *v3;
  void *v4;
  uint64_t v5;
  unsigned __int16 v7;

  v7 = 0;
  v3 = (TSTTableTile *)objc_msgSend(*(id *)(a1 + 32), "tileForID:", TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)(a1 + 24), (unsigned __int16)a2, &v7));
  if (!v3)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTCellStorageRef TSTTableDataStoreCellStorageRefAtCellID(TSTTableDataStore *, TSTCellID)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 431, CFSTR("Failed to get tile for cell!"));
  }
  return TSTTableTileGetCellStorageRef(v3, BYTE2(a2), (unsigned __int16)(a2 - v7));
}

BOOL TSTTableDataStoreCellExistsAtCellID(uint64_t a1, int a2)
{
  return TSTTableDataStoreCellStorageRefAtCellID(a1, a2) != 0;
}

uint64_t TSTTableDataStoreGetCellStyleAtCellID(uint64_t a1, int a2, uint64_t *a3)
{
  UInt8 *v5;
  uint64_t result;
  unsigned int *Element;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t StyleForKey;

  if (a3)
    *a3 = 0;
  v5 = TSTTableDataStoreCellStorageRefAtCellID(a1, a2);
  if (!v5)
    return 1000;
  if ((v5[4] & 2) == 0)
    return 0;
  Element = (unsigned int *)TSTCellStorageGetElement((uint64_t)v5, 2);
  if (!Element)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageStyleID(TSTCellStorage *)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 182, CFSTR("Can't get style ID storage element!"));
  }
  result = 0;
  if (a3)
  {
    v10 = *Element;
    if ((_DWORD)v10)
    {
      StyleForKey = TSTTableDataListGetStyleForKey(objc_msgSend(*(id *)(a1 + 72), "object"), v10);
      result = 0;
      *a3 = StyleForKey;
    }
  }
  return result;
}

uint64_t TSTTableDataStoreGetTextStyleAtCellID(uint64_t a1, int a2, TSWPParagraphStyle **a3)
{
  UInt8 *v5;
  TSTCell *v6;
  TSWPParagraphStyle *mTextStyle;

  if (a3)
    *a3 = 0;
  v5 = TSTTableDataStoreCellStorageRefAtCellID(a1, a2);
  if (!v5)
    return 1000;
  v6 = -[TSTCell initWithStorageRef:dataStore:]([TSTCell alloc], "initWithStorageRef:dataStore:", v5, a1);
  if (a3)
  {
    if (v6)
      mTextStyle = v6->mPrivate.mTextStyle;
    else
      mTextStyle = 0;
    *a3 = mTextStyle;
  }

  return 0;
}

double TSTTableDataStoreGetFormatForFormatTypeAtCellID@<D0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, UInt8 *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v8;
  unsigned int *ElementForFormat;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  double result;

  if (!a4)
  {
    a4 = TSTTableDataStoreCellStorageRefAtCellID(a1, a2);
    if (!a4)
      goto LABEL_20;
  }
  v8 = 0;
  switch(a3)
  {
    case 254:
    case 260:
    case 263:
    case 267:
      goto LABEL_20;
    case 255:
      goto LABEL_15;
    case 256:
    case 258:
    case 259:
    case 262:
      v8 = 1;
      break;
    case 257:
      v8 = 8;
      break;
    case 261:
      v8 = 2;
      break;
    case 264:
    case 265:
      v8 = 16;
      break;
    case 266:
      v8 = 128;
      break;
    case 268:
      v8 = 4;
      break;
    case 269:
      v8 = 64;
      break;
    case 270:
    case 271:
    case 272:
      v8 = 32;
      break;
    default:
      if ((a3 + 1) < 3 || a3 == -999)
        goto LABEL_20;
      break;
  }
  if (((unsigned __int16)v8 & *((_WORD *)a4 + 5)) == 0)
    goto LABEL_20;
LABEL_15:
  ElementForFormat = (unsigned int *)TSTCellStorageGetElementForFormat((uint64_t)a4, v8);
  if (!ElementForFormat)
  {
    v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageFormatIDForFormatFlag(TSTCellStorage *, TSTCellStorageFormatFlags)");
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 269, CFSTR("Can't get format ID storage element!"));
  }
  v12 = *ElementForFormat;
  if ((_DWORD)v12)
  {
    *(_QWORD *)&result = TSTTableDataListGetCellFormatForKey(objc_msgSend(*(id *)(a1 + 104), "object"), v12, a5).n128_u64[0];
  }
  else
  {
LABEL_20:
    *(_QWORD *)(a5 + 32) = 0;
    result = *(double *)&TSUNotSetFormat;
    *(_OWORD *)a5 = TSUNotSetFormat;
    *(_OWORD *)(a5 + 16) = *(_OWORD *)algn_217C2C068;
  }
  return result;
}

double TSTTableDataStoreGetFormatAtCellID@<D0>(uint64_t a1@<X0>, int a2@<W1>, BOOL *a3@<X2>, UInt8 *a4@<X3>, uint64_t a5@<X8>)
{
  unsigned int *Element;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  double result;

  if (!a4)
  {
    a4 = TSTTableDataStoreCellStorageRefAtCellID(a1, a2);
    if (!a4)
      goto LABEL_10;
  }
  if (a3)
    *a3 = (~*(_QWORD *)(a4 + 4) & 0x1000000004) != 0;
  if ((a4[4] & 4) == 0)
    goto LABEL_10;
  Element = (unsigned int *)TSTCellStorageGetElement((uint64_t)a4, 4);
  if (!Element)
  {
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageFormatID(TSTCellStorage *)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 249, CFSTR("Can't get format ID storage element!"));
  }
  v11 = *Element;
  if ((_DWORD)v11)
  {
    *(_QWORD *)&result = TSTTableDataListGetCellFormatForKey(objc_msgSend(*(id *)(a1 + 104), "object"), v11, a5).n128_u64[0];
  }
  else
  {
LABEL_10:
    *(_QWORD *)(a5 + 32) = 0;
    result = *(double *)&TSUNotSetFormat;
    *(_OWORD *)a5 = TSUNotSetFormat;
    *(_OWORD *)(a5 + 16) = *(_OWORD *)algn_217C2C068;
  }
  return result;
}

__n128 p_TSTCellFormatForFormatFlag@<Q0>(_QWORD *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  __int128 *v3;
  void *v4;
  __n128 result;
  __int128 v6;

  if (a2 > 15)
  {
    if (a2 > 63)
    {
      if (a2 == 64)
      {
        if (a1)
        {
          v4 = (void *)a1[31];
          if (v4)
            goto LABEL_10;
        }
      }
      else if (a2 == 128)
      {
        if (a1)
        {
          v4 = (void *)a1[33];
          if (v4)
            goto LABEL_10;
        }
      }
    }
    else if (a2 == 16)
    {
      if (a1)
      {
        v4 = (void *)a1[27];
        if (v4)
          goto LABEL_10;
      }
    }
    else if (a2 == 32)
    {
      if (a1)
      {
        v4 = (void *)a1[29];
        if (v4)
        {
LABEL_10:
          objc_msgSend(v4, "getFormatStruct");
          return result;
        }
      }
    }
LABEL_34:
    *(_QWORD *)(a3 + 32) = 0;
    result.n128_u64[0] = TSUInvalidFormat;
    *(_OWORD *)a3 = TSUInvalidFormat;
    *(_OWORD *)(a3 + 16) = *(_OWORD *)algn_217C2C090;
    return result;
  }
  switch(a2)
  {
    case 0:
      if (a1)
        v3 = (__int128 *)(a1 + 13);
      else
        v3 = &TSUInvalidFormat;
      result = (__n128)*v3;
      v6 = v3[1];
      *(_OWORD *)a3 = *v3;
      *(_OWORD *)(a3 + 16) = v6;
      *(_QWORD *)(a3 + 32) = *((_QWORD *)v3 + 4);
      break;
    case 1:
      if (!a1)
        goto LABEL_34;
      v4 = (void *)a1[19];
      if (!v4)
        goto LABEL_34;
      goto LABEL_10;
    case 2:
      if (a1)
      {
        v4 = (void *)a1[25];
        if (v4)
          goto LABEL_10;
      }
      goto LABEL_34;
    case 4:
      if (a1)
      {
        v4 = (void *)a1[23];
        if (v4)
          goto LABEL_10;
      }
      goto LABEL_34;
    case 8:
      if (a1)
      {
        v4 = (void *)a1[21];
        if (v4)
          goto LABEL_10;
      }
      goto LABEL_34;
    default:
      goto LABEL_34;
  }
  return result;
}

uint64_t p_TSTCellFormatIDForFormatFlag(unsigned int *a1, int a2)
{
  uint64_t result;

  result = 0;
  if (a2 > 15)
  {
    if (a2 > 63)
    {
      if (a2 == 64)
      {
        if (a1)
          return a1[60];
      }
      else
      {
        if (a2 != 128)
          return result;
        if (a1)
          return a1[64];
      }
    }
    else if (a2 == 16)
    {
      if (a1)
        return a1[52];
    }
    else
    {
      if (a2 != 32)
        return result;
      if (a1)
        return a1[56];
    }
    return 0;
  }
  switch(a2)
  {
    case 0:
      if (!a1)
        return 0;
      result = a1[25];
      break;
    case 1:
      if (!a1)
        return 0;
      result = a1[36];
      break;
    case 2:
      if (!a1)
        return 0;
      result = a1[48];
      break;
    case 4:
      if (!a1)
        return 0;
      result = a1[44];
      break;
    case 8:
      if (!a1)
        return 0;
      result = a1[40];
      break;
    default:
      return result;
  }
  return result;
}

void p_UpdateDataListsForNewCell(id *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *Element;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  __CFString *v25;
  _BOOL4 v26;
  _BOOL4 v27;
  uint64_t StringForKey;
  void *v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const __CFString *v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  BOOL v44;
  char v45;
  TSTTableDataList *v46;
  uint64_t RichTextPayloadForKey;
  BOOL v48;
  int v49;
  void *v50;
  uint64_t v51;
  BOOL v52;
  char v53;
  TSTTableDataList *v54;
  uint64_t CommentStorageForKey;
  BOOL v56;
  int v57;
  void *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int *v62;
  void *v63;
  uint64_t v64;
  BOOL v65;
  int v66;
  uint64_t StyleForKey;
  uint64_t v68;
  void *v69;
  uint64_t v70;
  void *v71;
  uint64_t v72;
  void *v73;
  uint64_t v74;
  uint64_t v75;
  void *v76;
  unsigned int *v77;
  void *v78;
  uint64_t v79;
  BOOL v80;
  int v81;
  uint64_t v82;
  void *v83;
  uint64_t v84;
  void *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  void *v89;
  unsigned int v90;
  void *v91;

  v3 = a3;
  if (!a3)
  {
    v11 = 0;
    v7 = 0;
    goto LABEL_13;
  }
  v6 = *(_QWORD *)(a3 + 4);
  if ((v6 & 0x10) != 0)
  {
    Element = (unsigned int *)TSTCellStorageGetElement(a3, 16);
    if (!Element)
    {
      v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageStringID(TSTCellStorage *)");
      objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 401, CFSTR("Can't get string ID storage element!"));
    }
    v7 = *Element;
    v6 = *(_QWORD *)(v3 + 4);
    if ((v6 & 0x200) != 0)
    {
LABEL_4:
      v8 = (unsigned int *)TSTCellStorageGetElement(v3, 512);
      if (!v8)
      {
        v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageRichTextPayloadID(TSTCellStorage *)");
        objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 357, CFSTR("Can't get formula error ID storage element!"));
      }
      v11 = *v8;
      if ((*(_QWORD *)(v3 + 4) & 0x1000) != 0)
        goto LABEL_14;
LABEL_13:
      v15 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    v7 = 0;
    if ((v6 & 0x200) != 0)
      goto LABEL_4;
  }
  v11 = 0;
  if ((v6 & 0x1000) == 0)
    goto LABEL_13;
LABEL_14:
  v16 = (unsigned int *)TSTCellStorageGetElement(v3, 4096);
  if (!v16)
  {
    v17 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v18 = v11;
    v19 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageCommentStorageID(TSTCellStorage *)");
    v20 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h");
    v21 = v19;
    v11 = v18;
    objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v21, v20, 382, CFSTR("Can't get cell comment ID storage element!"));
  }
  v15 = *v16;
LABEL_17:
  v90 = v11;
  if (!a2 || (v22 = *(_DWORD *)(a2 + 8), (v22 & 0xFF00) != 0x300))
  {
    if ((_DWORD)v7)
      TSTTableDataListRemoveReferenceForKey(objc_msgSend(a1[8], "object"), v7);
    if (!a2)
      goto LABEL_84;
    goto LABEL_62;
  }
  v23 = *(unsigned int *)(a2 + 16);
  v24 = BYTE1(v22);
  if (!v24)
  {
    v26 = v7 != v23;
    v27 = (_DWORD)v7 != (_DWORD)v23 && v7 != 0;
    v25 = &stru_24D82FEB0;
    if ((_DWORD)v23)
    {
LABEL_38:
      StringForKey = TSTTableDataListGetStringForKey(objc_msgSend(a1[8], "object"), v23);
      if (StringForKey)
      {
        if ((-[__CFString isEqualToString:](v25, "isEqualToString:", StringForKey) & 1) == 0)
        {
          v89 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v88 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
          objc_msgSend(v89, "handleFailureInFunction:file:lineNumber:description:", v88, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 920, CFSTR("Corrupted string keys!"));
        }
        if (v26)
        {
          TSTTableDataListAddReferenceForKey((id *)objc_msgSend(a1[8], "object"), v23);
          goto LABEL_60;
        }
        goto LABEL_51;
      }
      goto LABEL_56;
    }
    goto LABEL_56;
  }
  if (v24 != 9)
  {
    if (v24 == 3)
    {
      v25 = *(__CFString **)(a2 + 24);
      goto LABEL_33;
    }
    v29 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v30 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
    objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), a2);
    if ((_DWORD)v7)
      v31 = (_DWORD)v7 == (_DWORD)v23;
    else
      v31 = 1;
    v27 = !v31;
    if ((_DWORD)v23)
      goto LABEL_50;
    v25 = 0;
LABEL_56:
    v39 = TSTTableDataListAddString((TSTTableDataList *)objc_msgSend(a1[8], "object"), (uint64_t)v25);
    if (*(unsigned __int8 *)(a2 + 9) << 8 == 768)
    {
      *(_DWORD *)(a2 + 16) = v39;
      goto LABEL_60;
    }
    v40 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v41 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetStringID(TSTCell *, TSTTableDataListKey)");
    v34 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h");
    v35 = CFSTR("can't set string ID on non-string cell: %p");
    v87 = a2;
    v36 = (void *)v40;
    v37 = v41;
    v38 = 958;
LABEL_59:
    objc_msgSend(v36, "handleFailureInFunction:file:lineNumber:description:", v37, v34, v38, v35, v87);
LABEL_60:
    v11 = v90;
    if (!v27)
      goto LABEL_62;
    goto LABEL_61;
  }
  v25 = (__CFString *)objc_msgSend(*(id *)(a2 + 72), "string");
LABEL_33:
  v26 = v7 != v23;
  v27 = (_DWORD)v7 != (_DWORD)v23 && v7 != 0;
  if (!(_DWORD)v23)
    goto LABEL_56;
  if (v25)
    goto LABEL_38;
LABEL_50:
  if (!TSTTableDataListGetStringForKey(objc_msgSend(a1[8], "object"), v23))
  {
    v32 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v33 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
    v34 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm");
    v35 = CFSTR("Handed a bad string key!");
    v36 = (void *)v32;
    v37 = v33;
    v38 = 930;
    goto LABEL_59;
  }
LABEL_51:
  v11 = v90;
  if (v27)
LABEL_61:
    TSTTableDataListRemoveReferenceForKey(objc_msgSend(a1[8], "object"), v7);
LABEL_62:
  v42 = *(void **)(a2 + 72);
  v43 = *(unsigned int *)(a2 + 64);
  if (!v42)
  {
    if ((_DWORD)v43)
    {
      if ((_DWORD)v11)
        v48 = (_DWORD)v11 == (_DWORD)v43;
      else
        v48 = 1;
      v49 = !v48;
      if (TSTTableDataListGetRichTextPayloadForKey(objc_msgSend(a1[12], "object"), v43))
      {
        if (v49)
          goto LABEL_89;
      }
      else
      {
        v85 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v86 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
        objc_msgSend(v85, "handleFailureInFunction:file:lineNumber:description:", v86, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1075, CFSTR("Handed a bad text storage key!"));
        if ((v49 & 1) != 0)
          goto LABEL_89;
      }
      goto LABEL_90;
    }
LABEL_84:
    if ((_DWORD)v11)
      TSTTableDataListRemoveReferenceForKey(objc_msgSend(a1[12], "object"), v11);
    if (!a2)
      goto LABEL_112;
    goto LABEL_90;
  }
  if ((_DWORD)v11)
    v44 = (_DWORD)v11 == (_DWORD)v43;
  else
    v44 = 1;
  v45 = !v44;
  v46 = (TSTTableDataList *)objc_msgSend(a1[12], "object");
  if (!(_DWORD)v43
    || (RichTextPayloadForKey = TSTTableDataListGetRichTextPayloadForKey((uint64_t)v46, v43),
        v46 = (TSTTableDataList *)objc_msgSend(a1[12], "object"),
        !RichTextPayloadForKey))
  {
    *(_DWORD *)(a2 + 64) = TSTTableDataListAddRichTextPayload(v46, (uint64_t)v42);
    if ((v45 & 1) == 0)
      goto LABEL_90;
    goto LABEL_89;
  }
  if (v90 != (_DWORD)v43)
  {
    TSTTableDataListAddReferenceForKey((id *)&v46->super.super.isa, v43);
    if ((v45 & 1) == 0)
      goto LABEL_90;
LABEL_89:
    TSTTableDataListRemoveReferenceForKey(objc_msgSend(a1[12], "object"), v90);
    goto LABEL_90;
  }
  if ((objc_msgSend(v42, "isEqual:", TSTTableDataListGetRichTextPayloadForKey((uint64_t)v46, v90)) & 1) == 0)
  {
    v71 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v72 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
    objc_msgSend(v71, "handleFailureInFunction:file:lineNumber:description:", v72, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1070, CFSTR("Corrupted rich text storage table!"));
  }
LABEL_90:
  v50 = *(void **)(a2 + 88);
  v51 = *(unsigned int *)(a2 + 80);
  if (!v50)
  {
    if ((_DWORD)v51)
    {
      if ((_DWORD)v15)
        v56 = (_DWORD)v15 == (_DWORD)v51;
      else
        v56 = 1;
      v57 = !v56;
      if (TSTTableDataListGetCommentStorageForKey(objc_msgSend(a1[15], "object"), v51))
      {
        if (v57)
          goto LABEL_120;
      }
      else
      {
        v73 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v74 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
        objc_msgSend(v73, "handleFailureInFunction:file:lineNumber:description:", v74, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1117, CFSTR("Handed a cell comment key!"));
        if ((v57 & 1) != 0)
          goto LABEL_120;
      }
      goto LABEL_121;
    }
LABEL_112:
    if ((_DWORD)v15)
      TSTTableDataListRemoveReferenceForKey(objc_msgSend(a1[15], "object"), v15);
    if (!a2)
    {
      v58 = 0;
      v59 = 0;
      if (!v3)
        goto LABEL_123;
      goto LABEL_122;
    }
    goto LABEL_121;
  }
  if ((_DWORD)v15)
    v52 = (_DWORD)v15 == (_DWORD)v51;
  else
    v52 = 1;
  v53 = !v52;
  v54 = (TSTTableDataList *)objc_msgSend(a1[15], "object");
  if (!(_DWORD)v51)
  {
    v60 = (uint64_t)v50;
    goto LABEL_119;
  }
  CommentStorageForKey = TSTTableDataListGetCommentStorageForKey((uint64_t)v54, v51);
  if (!CommentStorageForKey)
  {
    v54 = (TSTTableDataList *)objc_msgSend(a1[15], "object");
    v60 = (uint64_t)v50;
LABEL_119:
    *(_DWORD *)(a2 + 80) = TSTTableDataListAddCommentStorage(v54, v60);
    if ((v53 & 1) == 0)
      goto LABEL_121;
    goto LABEL_120;
  }
  if ((_DWORD)v15 != (_DWORD)v51)
  {
    TSTTableDataListAddReferenceForKey((id *)objc_msgSend(a1[15], "object"), v51);
    if ((v53 & 1) == 0)
      goto LABEL_121;
LABEL_120:
    TSTTableDataListRemoveReferenceForKey(objc_msgSend(a1[15], "object"), v15);
    goto LABEL_121;
  }
  if ((objc_msgSend(v50, "isEqual:", CommentStorageForKey) & 1) == 0)
  {
    v69 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v70 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
    objc_msgSend(v69, "handleFailureInFunction:file:lineNumber:description:", v70, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1112, CFSTR("Corrupted cell comment table!"));
  }
LABEL_121:
  v58 = *(void **)(a2 + 40);
  v59 = *(unsigned int *)(a2 + 32);
  if (!v3)
  {
LABEL_123:
    v61 = 0;
    goto LABEL_127;
  }
LABEL_122:
  if ((*(_BYTE *)(v3 + 4) & 2) == 0)
    goto LABEL_123;
  v62 = (unsigned int *)TSTCellStorageGetElement(v3, 2);
  if (!v62)
  {
    v63 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v64 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageStyleID(TSTCellStorage *)");
    objc_msgSend(v63, "handleFailureInFunction:file:lineNumber:description:", v64, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 182, CFSTR("Can't get style ID storage element!"));
  }
  v61 = *v62;
LABEL_127:
  if ((_DWORD)v61)
    v65 = (_DWORD)v61 == (_DWORD)v59;
  else
    v65 = 1;
  v66 = !v65;
  if (v58 || (_DWORD)v59)
  {
    if (!(_DWORD)v59)
      goto LABEL_149;
    if (!v58)
      goto LABEL_150;
    StyleForKey = TSTTableDataListGetStyleForKey(objc_msgSend(a1[9], "object"), v59);
    if (StyleForKey)
    {
      if ((objc_msgSend(v58, "isEqual:", StyleForKey) & 1) == 0)
      {
        v91 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v68 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
        objc_msgSend(v91, "handleFailureInFunction:file:lineNumber:description:", v68, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1162, CFSTR("Corrupted style keys!"));
      }
      if ((_DWORD)v61 != (_DWORD)v59)
        TSTTableDataListAddReferenceForKey((id *)objc_msgSend(a1[9], "object"), v59);
    }
    else
    {
LABEL_149:
      *(_DWORD *)(a2 + 32) = TSTTableDataListAddStyle((TSTTableDataList *)objc_msgSend(a1[9], "object"), (uint64_t)v58);
    }
  }
LABEL_150:
  if (v66)
    TSTTableDataListRemoveReferenceForKey(objc_msgSend(a1[9], "object"), v61);
  if (v3)
  {
    if ((*(_BYTE *)(v3 + 4) & 0x80) != 0)
    {
      v77 = (unsigned int *)TSTCellStorageGetElement(v3, 128);
      if (!v77)
      {
        v78 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v79 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageTextStyleID(TSTCellStorage *)");
        objc_msgSend(v78, "handleFailureInFunction:file:lineNumber:description:", v79, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 201, CFSTR("Can't get style ID storage element!"));
      }
      v3 = *v77;
      if (a2)
        goto LABEL_156;
      goto LABEL_160;
    }
    v3 = 0;
  }
  if (a2)
  {
LABEL_156:
    v75 = *(unsigned int *)(a2 + 48);
    v76 = *(void **)(a2 + 56);
    goto LABEL_161;
  }
LABEL_160:
  v75 = 0;
  v76 = 0;
LABEL_161:
  if ((_DWORD)v3)
    v80 = (_DWORD)v3 == (_DWORD)v75;
  else
    v80 = 1;
  v81 = !v80;
  if (v76 || (_DWORD)v75)
  {
    if (!(_DWORD)v75)
      goto LABEL_178;
    if (!v76)
      goto LABEL_176;
    v82 = TSTTableDataListGetStyleForKey(objc_msgSend(a1[9], "object"), v75);
    if (!v82)
    {
LABEL_178:
      *(_DWORD *)(a2 + 48) = TSTTableDataListAddStyle((TSTTableDataList *)objc_msgSend(a1[9], "object"), (uint64_t)v76);
      if (v81)
        goto LABEL_177;
      return;
    }
    if ((objc_msgSend(v76, "isEqual:", v82) & 1) == 0)
    {
      v83 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v84 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_UpdateDataListsForNewCell(TSTTableDataStore *, TSTCell *, TSTCellStorageRef, TSTCellID, CFUUIDRef, TSCECalculationEngine *)");
      objc_msgSend(v83, "handleFailureInFunction:file:lineNumber:description:", v84, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1205, CFSTR("Corrupted style keys!"));
    }
    if ((_DWORD)v3 != (_DWORD)v75)
      TSTTableDataListAddReferenceForKey((id *)objc_msgSend(a1[9], "object"), v75);
  }
LABEL_176:
  if (v81)
LABEL_177:
    TSTTableDataListRemoveReferenceForKey(objc_msgSend(a1[9], "object"), v3);
}

uint64_t TSTTableDataStoreSetCellAtCellID(id *a1, _QWORD *a2, unint64_t a3)
{
  unsigned __int16 v3;
  unint64_t v6;
  TSTTableTile *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  UInt8 *CellStorageRef;
  uint64_t result;
  __int16 v13;
  __int16 MidpointForRowSplit;
  unsigned int v15;
  unsigned __int16 v16;

  v3 = a3;
  v6 = a3 >> 16;
  v16 = 0;
  v7 = (TSTTableTile *)p_TileForRowIndex((uint64_t)a1, (unsigned __int16)a3, &v16, &v15);
  if (!v7)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreSetCellAtCellID(TSTTableDataStore *, TSTCell *, TSTCellID, CFUUIDRef, TSCECalculationEngine *, TSTConditionalStyleFormulaOwner *, BOOL)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1308, CFSTR("Failed to get tile for cell!"));
  }
  v10 = (unsigned __int16)(v3 - v16);
  CellStorageRef = TSTTableTileGetCellStorageRef(v7, v6, v10);
  p_UpdateDataListsForNewCell(a1, (uint64_t)a2, (uint64_t)CellStorageRef);
  TSTTableTileSetCell(v7, v6, v10, a2);
  result = TSTTableTileShouldSplitRows((uint64_t)v7);
  if ((_DWORD)result)
  {
    v13 = v16;
    objc_msgSend(a1, "willModify");
    MidpointForRowSplit = TSTTableTileFindMidpointForRowSplit((uint64_t)v7);
    result = p_SplitTileAtRowIndex((uint64_t)a1, v7, v13, MidpointForRowSplit + v13);
  }
  else if (!a2)
  {
    result = TSTTableTileShouldMergeRows((uint64_t)v7);
    if ((_DWORD)result)
      result = (uint64_t)p_MergeTileRows((uint64_t)a1, v7, v16, v15);
    goto LABEL_11;
  }
  if (a2 && !CellStorageRef)
    return TSTTableDataStoreIncrementCellCounts((uint64_t)a1, v6, v3);
LABEL_11:
  if (!a2)
  {
    if (CellStorageRef)
      return TSTTableDataStoreDecrementCellCounts((uint64_t)a1, v6, v3);
  }
  return result;
}

unsigned __int16 *p_MergeTileRows(uint64_t a1, void *a2, unsigned int a3, unsigned int a4)
{
  void *v8;
  uint64_t v9;
  unsigned __int16 *result;
  BOOL v11;
  unsigned __int16 *v12;
  unsigned int v13;
  void *v14;
  uint64_t v15;
  unsigned __int16 v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  unsigned __int16 *v20;
  void *v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  unsigned __int16 v25;

  objc_msgSend((id)a1, "willModify");
  if (!TSTTableTileShouldMergeRows((uint64_t)a2))
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_MergeTileRows(TSTTableDataStore *, TSTTableTile *, TSURowIndex, TSTTableTileID)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 269, CFSTR("Shouldn't merge a tile that doesn't want to merge!"));
  }
  result = TSTTableRBFirstNodeGreaterThanOrEqualTo(*(unsigned __int16 **)(a1 + 24), (unsigned __int16)(a3 + 1));
  if (result)
    v11 = result == (unsigned __int16 *)&TSTTableRBTreeNil;
  else
    v11 = 1;
  if (!v11)
  {
    v12 = result;
    v13 = *result;
    if (objc_msgSend(a2, "maxRow") + a3 >= v13)
    {
      v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_MergeTileRows(TSTTableDataStore *, TSTTableTile *, TSURowIndex, TSTTableTileID)");
      objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 274, CFSTR("Tile rbtree is corrupt!"));
    }
    v16 = *v12;
    v17 = v12[1];
    v18 = (void *)objc_msgSend(*(id *)(a1 + 32), "tileForID:", v17);
    if (!objc_msgSend(v18, "numRows"))
      goto LABEL_12;
    result = (unsigned __int16 *)TSTTableTilesShouldMergeRowsTogether((uint64_t)a2, (uint64_t)v18);
    if ((_DWORD)result)
    {
      TSTTableTileMergeRows((uint64_t)a2, (uint64_t)v18, (unsigned __int16)(v16 - a3));
LABEL_12:
      *(_QWORD *)(a1 + 24) = TSTTableRBTreeDelete(*(TSTTableRBTreeNode_s **)(a1 + 24), v12);
      result = (unsigned __int16 *)objc_msgSend(*(id *)(a1 + 32), "removeTileForID:", v17);
    }
  }
  if (a3)
  {
    result = (unsigned __int16 *)TSTTableTileShouldMergeRows((uint64_t)a2);
    if ((_DWORD)result)
    {
      v25 = a3 - 1;
      v19 = objc_msgSend(*(id *)(a1 + 32), "tileForID:", TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)(a1 + 24), (unsigned __int16)(a3 - 1), &v25));
      result = (unsigned __int16 *)TSTTableTilesShouldMergeRowsTogether(v19, (uint64_t)a2);
      if ((_DWORD)result)
      {
        TSTTableTileMergeRows(v19, (uint64_t)a2, (unsigned __int16)(a3 - v25));
        v20 = TSTTableRBTreeFind(*(unsigned __int16 **)(a1 + 24), a3);
        if (*v20 != a3)
        {
          v21 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v22 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_MergeTileRows(TSTTableDataStore *, TSTTableTile *, TSURowIndex, TSTTableTileID)");
          objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 310, CFSTR("Found the wrong node (bad key)!"));
        }
        if (v20[1] != (unsigned __int16)a4)
        {
          v23 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v24 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_MergeTileRows(TSTTableDataStore *, TSTTableTile *, TSURowIndex, TSTTableTileID)");
          objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v24, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 311, CFSTR("Found the wrong node (bad value)!"));
        }
        *(_QWORD *)(a1 + 24) = TSTTableRBTreeDelete(*(TSTTableRBTreeNode_s **)(a1 + 24), v20);
        return (unsigned __int16 *)objc_msgSend(*(id *)(a1 + 32), "removeTileForID:", a4);
      }
    }
  }
  return result;
}

uint64_t TSTTableDataStoreSetCellsWithCellMap(void *a1, void *a2)
{
  uint64_t result;
  TSTTableTile *v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  _QWORD *v9;
  unsigned __int16 v10;
  BOOL v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  UInt8 *CellStorageRef;
  __int16 v16;
  __int16 MidpointForRowSplit;
  unint64_t v18;
  uint64_t v19;
  unsigned __int16 v20;
  unsigned int v21;

  v20 = -1;
  result = objc_msgSend(a2, "count");
  v19 = result;
  if (result)
  {
    v5 = 0;
    v6 = 0;
    v7 = 0xFFFF;
    do
    {
      v8 = objc_msgSend(a2, "cellIDAtIndex:", v6);
      v9 = (_QWORD *)objc_msgSend(a2, "cellAtIndex:", v6);
      if (!v5
        || ((v10 = v20, (unsigned __int16)v8 >= v20) ? (v11 = (unsigned __int16)v8 > v7) : (v11 = 1), v11))
      {
        v5 = (TSTTableTile *)p_TileForRowIndex((uint64_t)a1, (unsigned __int16)v8, &v20, &v21);
        if (!v5)
        {
          v12 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v13 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreSetCellsWithCellMap(TSTTableDataStore *, id<TSTCellMap>, CFUUIDRef, TSCECalculationEngine *, TSTConditionalStyleFormulaOwner *, BOOL, BOOL)");
          objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1378, CFSTR("Failed to get a tile while setting a map!"));
        }
        v7 = -[TSTTableTile maxRow](v5, "maxRow");
        v10 = v20;
      }
      v14 = (unsigned __int16)(v8 - v10);
      CellStorageRef = TSTTableTileGetCellStorageRef(v5, BYTE2(v8), v14);
      TSTTableTileSetCell(v5, BYTE2(v8), v14, v9);
      result = TSTTableTileShouldSplitRows((uint64_t)v5);
      if ((_DWORD)result)
      {
        v16 = v20;
        objc_msgSend(a1, "willModify");
        MidpointForRowSplit = TSTTableTileFindMidpointForRowSplit((uint64_t)v5);
        result = p_SplitTileAtRowIndex((uint64_t)a1, v5, v16, MidpointForRowSplit + v16);
        v5 = 0;
      }
      else if (!v9)
      {
        result = TSTTableTileShouldMergeRows((uint64_t)v5);
        if ((_DWORD)result)
        {
          v18 = v18 & 0xFFFFFFFF00000000 | v21;
          result = (uint64_t)p_MergeTileRows((uint64_t)a1, v5, v20, v21);
          v5 = 0;
        }
LABEL_20:
        if (!v9)
        {
          if (CellStorageRef)
            result = TSTTableDataStoreDecrementCellCounts((uint64_t)a1, BYTE2(v8), (unsigned __int16)v8);
        }
        goto LABEL_23;
      }
      if (!v9 || CellStorageRef)
        goto LABEL_20;
      result = TSTTableDataStoreIncrementCellCounts((uint64_t)a1, BYTE2(v8), (unsigned __int16)v8);
LABEL_23:
      ++v6;
    }
    while (v19 != v6);
  }
  return result;
}

_QWORD *TSTTableDataStorePopulateCustomFormat(_QWORD *result, uint64_t a2, double a3)
{
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  if ((*(_DWORD *)a2 - 270) <= 2)
  {
    v5 = result;
    v6 = objc_msgSend(result, "documentRoot");
    if (v6
      && (v7 = (void *)v6, (objc_opt_respondsToSelector() & 1) != 0)
      && (result = (_QWORD *)objc_msgSend((id)objc_msgSend(v7, "customFormatList"), "customFormatForKey:", *(unsigned int *)(a2 + 8))) != 0|| (result = (_QWORD *)v5[16]) != 0&& (result = (_QWORD *)objc_msgSend(result, "customFormatForKey:", *(unsigned int *)(a2 + 8))) != 0)
    {
      if (*(_DWORD *)a2 == 270)
        result = (_QWORD *)TSUCustomFormat::formatByEvaluatingConditionsWithDouble((TSUCustomFormat *)result, a3);
      else
        result = (_QWORD *)TSUCustomFormat::defaultFormatData((TSUCustomFormat *)result);
      *(_QWORD *)(a2 + 16) = result;
    }
    else
    {
      *(_QWORD *)(a2 + 16) = 0;
    }
  }
  return result;
}

void TSTTableDataStoreResolveCellDataIDs(id *a1, uint64_t a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *StringForKey;
  int v8;
  void *v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  TSTRichTextPayload *RichTextPayloadForKey;
  uint64_t v17;
  TSDCommentStorage *CommentStorageForKey;
  uint64_t v19;
  uint64_t StyleForKey;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  void *v26;
  __int128 v27;
  int v28;
  int v30;
  void *v31;
  int v32;
  _OWORD v33[2];
  int v34;
  int v35;
  _OWORD v36[2];
  int v37;
  int v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    if (*(unsigned __int8 *)(a2 + 9) << 8 == 768)
    {
      v4 = *(unsigned int *)(a2 + 16);
      if (!(_DWORD)v4)
      {
        v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreResolveCellDataIDs(TSTTableDataStore *, TSTCell *, BOOL, BOOL)");
        objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1481, CFSTR("String cell has bad string!"));
      }
      StringForKey = (void *)TSTTableDataListGetStringForKey(objc_msgSend(a1[8], "object"), v4);
      v8 = *(_DWORD *)(a2 + 8);
      if ((v8 & 0xFF00) == 0)
      {
        TSTCellClearValue(a2);
        *(_BYTE *)(a2 + 9) = 3;
        v8 = *(_DWORD *)(a2 + 8);
      }
      if ((v8 & 0xFF00) == 0x300)
      {
        v9 = *(void **)(a2 + 24);
        if (v9 != StringForKey)
        {

          *(_QWORD *)(a2 + 24) = StringForKey;
          v10 = HIWORD(*(_DWORD *)(a2 + 8));
          v11 = objc_msgSend(StringForKey, "rangeOfCharacterFromSet:", objc_msgSend(MEMORY[0x24BDD14A8], "newlineCharacterSet"));
          v12 = v10 | 1;
          if (v11 == 0x7FFFFFFFFFFFFFFFLL)
            v12 = v10 & 0xFFFE;
          *(_WORD *)(a2 + 10) = v12;
        }
      }
      else
      {
        v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetStringValueClearingID(TSTCell *, NSString *, BOOL)");
        objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1003, CFSTR("can't set string on non-string cell: %p"), a2);
      }
    }
    v15 = *(unsigned int *)(a2 + 64);
    if ((_DWORD)v15)
    {
      RichTextPayloadForKey = (TSTRichTextPayload *)TSTTableDataListGetRichTextPayloadForKey(objc_msgSend(a1[12], "object"), v15);
      TSTCellSetRichTextPayloadClearingIDConvertToPlaintext((TSTRichTextPayload *)a2, RichTextPayloadForKey, 0, 1);
    }
    v17 = *(unsigned int *)(a2 + 80);
    if ((_DWORD)v17)
    {
      CommentStorageForKey = (TSDCommentStorage *)TSTTableDataListGetCommentStorageForKey(objc_msgSend(a1[15], "object"), v17);
      TSTCellSetCommentStorageClearingID((TSDCommentStorage *)a2, CommentStorageForKey, 0);
    }
    v19 = *(unsigned int *)(a2 + 32);
    if ((_DWORD)v19)
    {
      StyleForKey = TSTTableDataListGetStyleForKey(objc_msgSend(a1[9], "object"), v19);
      v21 = *(void **)(a2 + 40);
      if (v21 != (void *)StyleForKey)
      {
        v22 = (void *)StyleForKey;

        *(_QWORD *)(a2 + 40) = v22;
      }
    }
    v23 = *(unsigned int *)(a2 + 48);
    if ((_DWORD)v23)
    {
      v24 = TSTTableDataListGetStyleForKey(objc_msgSend(a1[9], "object"), v23);
      v25 = *(void **)(a2 + 56);
      if (v25 != (void *)v24)
      {
        v26 = (void *)v24;

        *(_QWORD *)(a2 + 56) = v26;
      }
    }
    if ((*(_DWORD *)(a2 + 104) & 0xFFFFFFFE) == 0x108)
    {
      v27 = *(_OWORD *)(a2 + 120);
      v42 = *(_OWORD *)(a2 + 104);
      v43 = v27;
      v28 = *(_DWORD *)(a2 + 136);
      if ((v28 - 256) <= 6 && ((1 << v28) & 0x4D) != 0)
      {
        v30 = *(_DWORD *)(a2 + 140);
        v41 = 0;
        v39 = 0u;
        v40 = 0u;
        v31 = *(void **)(a2 + 152);
        if (v31)
        {
          objc_msgSend(v31, "getFormatStruct");
          v32 = v39;
          if (v28 == (_DWORD)v39)
            return;
        }
        else
        {
          v41 = 0;
          v39 = TSUInvalidFormat;
          v40 = *(_OWORD *)algn_217C2C090;
          v32 = -1;
        }
        if ((*(_WORD *)(a2 + 96) & 0x10) != 0)
        {
          v36[0] = v42;
          v36[1] = v43;
          v37 = v32;
          v38 = v30;
          TSTCellSetExplicitFormat(a2, (uint64_t)v36);
        }
        else
        {
          v33[0] = v42;
          v33[1] = v43;
          v34 = v32;
          v35 = v30;
          TSTCellSetImplicitFormat(a2, (uint64_t)v33);
        }
      }
    }
  }
}

void TSTTableDataStoreClearDataListEntriesForCellStorageRef(TSTTableDataStore *a1, TSTCellStorage *a2)
{
  unsigned int *Element;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;

  if (a2)
  {
    if ((*((_BYTE *)&a2->var0 + 4) & 0x10) != 0)
    {
      Element = (unsigned int *)TSTCellStorageGetElement((uint64_t)a2, 16);
      if (!Element)
      {
        v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageStringID(TSTCellStorage *)");
        objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 401, CFSTR("Can't get string ID storage element!"));
      }
      v7 = *Element;
      if ((_DWORD)v7)
      {
        TSTTableDataListRemoveReferenceForKey((uint64_t)-[TSPLazyReference object](a1->mStringTableReference, "object"), v7);
        if ((*((_BYTE *)&a2->var0 + 4) & 0x10) != 0)
          *(_DWORD *)TSTCellStorageGetElement((uint64_t)a2, 16) = 0;
      }
    }
    if ((*((_BYTE *)&a2->var0 + 4) & 8) != 0)
    {
      v8 = (unsigned int *)TSTCellStorageGetElement((uint64_t)a2, 8);
      if (!v8)
      {
        v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageFormulaID(TSTCellStorage *)");
        objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 319, CFSTR("Can't get formula ID storage element!"));
      }
      v11 = *v8;
      if ((_DWORD)v11)
      {
        TSTTableDataListRemoveReferenceForKey((uint64_t)-[TSPLazyReference object](a1->mFormulaTableReference, "object"), v11);
        if ((*((_BYTE *)&a2->var0 + 4) & 8) != 0)
          *(_DWORD *)TSTCellStorageGetElement((uint64_t)a2, 8) = 0;
      }
    }
    if ((*((_BYTE *)&a2->var0 + 5) & 1) != 0)
    {
      v12 = (unsigned int *)TSTCellStorageGetElement((uint64_t)a2, 256);
      if (!v12)
      {
        v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageFormulaErrorID(TSTCellStorage *)");
        objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 338, CFSTR("Can't get formula error ID storage element!"));
      }
      v15 = *v12;
      if ((_DWORD)v15)
      {
        TSTTableDataListRemoveReferenceForKey((uint64_t)-[TSPLazyReference object](a1->mFormulaErrorTableReference, "object"), v15);
        if ((*((_BYTE *)&a2->var0 + 5) & 1) != 0)
          *(_DWORD *)TSTCellStorageGetElement((uint64_t)a2, 256) = 0;
      }
    }
    if ((*((_BYTE *)&a2->var0 + 5) & 2) != 0)
    {
      v16 = (unsigned int *)TSTCellStorageGetElement((uint64_t)a2, 512);
      if (!v16)
      {
        v17 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v18 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageRichTextPayloadID(TSTCellStorage *)");
        objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 357, CFSTR("Can't get formula error ID storage element!"));
      }
      v19 = *v16;
      if ((_DWORD)v19)
      {
        TSTTableDataListRemoveReferenceForKey((uint64_t)-[TSPLazyReference object](a1->mRichTextPayloadTableReference, "object"), v19);
        if ((*((_BYTE *)&a2->var0 + 5) & 2) != 0)
          *(_DWORD *)TSTCellStorageGetElement((uint64_t)a2, 512) = 0;
      }
    }
    if ((*((_BYTE *)&a2->var0 + 5) & 0x10) != 0)
    {
      v20 = (unsigned int *)TSTCellStorageGetElement((uint64_t)a2, 4096);
      if (!v20)
      {
        v21 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v22 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageCommentStorageID(TSTCellStorage *)");
        objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 382, CFSTR("Can't get cell comment ID storage element!"));
      }
      v23 = *v20;
      if ((_DWORD)v23)
      {
        TSTTableDataListRemoveReferenceForKey((uint64_t)-[TSPLazyReference object](a1->mCommentStorageTableReference, "object"), v23);
        if ((*((_BYTE *)&a2->var0 + 5) & 0x10) != 0)
          *(_DWORD *)TSTCellStorageGetElement((uint64_t)a2, 4096) = 0;
      }
    }
    if ((*((_BYTE *)&a2->var0 + 4) & 2) != 0)
    {
      v24 = (unsigned int *)TSTCellStorageGetElement((uint64_t)a2, 2);
      if (!v24)
      {
        v25 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v26 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageStyleID(TSTCellStorage *)");
        objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 182, CFSTR("Can't get style ID storage element!"));
      }
      v27 = *v24;
      if ((_DWORD)v27)
      {
        TSTTableDataListRemoveReferenceForKey((uint64_t)-[TSPLazyReference object](a1->mStyleTableReference, "object"), v27);
        if ((*((_BYTE *)&a2->var0 + 4) & 2) != 0)
          *(_DWORD *)TSTCellStorageGetElement((uint64_t)a2, 2) = 0;
      }
    }
    if ((*((_BYTE *)&a2->var0 + 4) & 0x80) != 0)
    {
      v28 = (unsigned int *)TSTCellStorageGetElement((uint64_t)a2, 128);
      if (!v28)
      {
        v29 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v30 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageTextStyleID(TSTCellStorage *)");
        objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 201, CFSTR("Can't get style ID storage element!"));
      }
      v31 = *v28;
      if ((_DWORD)v31)
      {
        TSTTableDataListRemoveReferenceForKey((uint64_t)-[TSPLazyReference object](a1->mStyleTableReference, "object"), v31);
        if ((*((_BYTE *)&a2->var0 + 4) & 0x80) != 0)
          *(_DWORD *)TSTCellStorageGetElement((uint64_t)a2, 128) = 0;
      }
    }
    if ((*((_BYTE *)&a2->var0 + 4) & 4) != 0)
    {
      v32 = (unsigned int *)TSTCellStorageGetElement((uint64_t)a2, 4);
      if (!v32)
      {
        v33 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v34 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageFormatID(TSTCellStorage *)");
        objc_msgSend(v33, "handleFailureInFunction:file:lineNumber:description:", v34, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 249, CFSTR("Can't get format ID storage element!"));
      }
      v35 = *v32;
      if ((_DWORD)v35)
      {
        TSTTableDataListRemoveReferenceForKey((uint64_t)-[TSPLazyReference object](a1->mFormatTableReference, "object"), v35);
        if ((*((_BYTE *)&a2->var0 + 4) & 4) != 0)
          *(_DWORD *)TSTCellStorageGetElement((uint64_t)a2, 4) = 0;
      }
    }
    if ((*((_BYTE *)&a2->var0 + 4) & 4) != 0)
    {
      v36 = (unsigned int *)TSTCellStorageGetElement((uint64_t)a2, 4);
      if (!v36)
      {
        v37 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v38 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageFormatID(TSTCellStorage *)");
        objc_msgSend(v37, "handleFailureInFunction:file:lineNumber:description:", v38, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h"), 249, CFSTR("Can't get format ID storage element!"));
      }
      v39 = *v36;
      if ((_DWORD)v39)
      {
        TSTTableDataListRemoveReferenceForKey((uint64_t)-[TSPLazyReference object](a1->mMultipleChoiceListFormatTableReference, "object"), v39);
        if ((*((_BYTE *)&a2->var0 + 4) & 4) != 0)
          *(_DWORD *)TSTCellStorageGetElement((uint64_t)a2, 4) = 0;
      }
    }
  }
}

uint64_t TSTTableDataStoreAddTileAtID(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return objc_msgSend(*(id *)(a1 + 32), "setTile:forID:", a3, a2);
}

uint64_t privateGetStorageObjectFromDictionary(const __CFDictionary *a1, int a2, _QWORD *a3)
{
  const void *Value;
  const void *v5;
  uint64_t result;
  int key;

  key = a2;
  Value = CFDictionaryGetValue(a1, &key);
  if (!Value)
    return 2;
  v5 = Value;
  result = 0;
  *a3 = v5;
  return result;
}

uint64_t TSTTableDataStoreInsertRows(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 v11;

  objc_msgSend((id)a1, "willModify");
  v11 = 0;
  v8 = objc_msgSend(*(id *)(a1 + 32), "tileForID:", TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)(a1 + 24), a2, &v11));
  if (!v8)
    return 2;
  TSTTableTileInsertRows(v8, (unsigned __int16)(a2 - v11), a3, a4);
  v9 = *(_QWORD *)(a1 + 24);
  if (a4)
  {
    TSTTableRBTreeShiftNodesAfter(v9, a2, a3);
  }
  else
  {
    LOWORD(a2) = a2 + 1;
    TSTTableRBTreeShiftNodesAtOrAfter(v9, (unsigned __int16)a2, a3);
  }
  objc_msgSend(*(id *)(a1 + 40), "shiftKeysAtIndex:amount:", (unsigned __int16)a2, a3);
  return 0;
}

uint64_t privateInsertColumnsIntoTile(TSTTableTile *a1, char *a2)
{
  return TSTTableTileInsertColumns((uint64_t)a1, *a2, *((unsigned __int16 *)a2 + 1), a2[4]);
}

uint64_t TSTTableDataStoreInsertColumns(TSTTableDataStore *a1, char a2, uint64_t a3, char a4)
{
  _BYTE v9[2];
  __int16 v10;
  char v11;

  -[TSPContainedObject willModify](a1, "willModify");
  v9[0] = a2;
  v11 = a4;
  v10 = a3;
  TSTTableDataStoreIterateTiles(a1, a1->mRowTileIndex, v9, (void (*)(TSTTableTile *, void *))privateInsertColumnsIntoTile);
  return objc_msgSend(-[TSPLazyReference object](a1->mColumnHeaderStorageReference, "object"), "shiftKeysAtIndex:amount:", ((a4 ^ 1) + a2), a3);
}

uint64_t p_updateColumnCellCountsForDeletionGivenTile(TSTTableDataStore *a1, TSTTableTile *a2, unsigned int a3, int a4)
{
  uint64_t result;
  unsigned __int16 v8;
  unsigned __int16 v9;
  int v10;
  unsigned int v11;
  uint64_t v13;
  unsigned __int8 v14;
  unsigned int v15;

  result = -[TSTTableTile numRows](a2, "numRows");
  if ((_DWORD)result)
  {
    v8 = 0;
    v9 = -[TSTTableTile numRows](a2, "numRows") - 1;
    v10 = a3 + a4;
    do
    {
      result = (uint64_t)TSTTableTileRowInfoForRowArrayIndex((uint64_t)a2, (unsigned __int16)(v9 - v8));
      v11 = *(unsigned __int16 *)(result + 536);
      if (v11 >= a3 && v10 > (int)v11)
      {
        v13 = result;
        if (*(_WORD *)(result + 538))
        {
          if (!*(_BYTE *)(result + 541))
            TSTTableTileRowInfoRecalculateMaxTileColumnIndex(result);
          v14 = 0;
          v15 = *(unsigned __int8 *)(v13 + 540);
          do
          {
            result = (uint64_t)TSTTableTileRowInfoCellStorageRefAtTileColumnIndex(v13, v14);
            if (result)
            {
              result = objc_msgSend(-[TSPLazyReference object](a1->mColumnHeaderStorageReference, "object"), "headerForKey:willModify:createIfNotThere:", v14, 1, 0);
              if (result)
                result = TSTDataStoreDecrementColumnCellCount((uint64_t)a1, (TSTTableHeaderInfo *)result);
            }
            ++v14;
          }
          while (v15 >= v14);
        }
      }
      ++v8;
    }
    while (v8 <= v9);
  }
  return result;
}

uint64_t TSTTableDataStoreRemoveRows(TSTTableDataStore *a1, uint64_t a2, int a3)
{
  unsigned __int16 v6;
  int *v7;
  int *v8;
  unsigned __int16 v9;
  int *v10;
  uint64_t v11;
  TSTTableTile *v12;
  void *v13;
  uint64_t v14;
  unsigned int v15;
  void *v16;
  uint64_t v17;
  unsigned __int16 v18;
  BOOL v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  unsigned __int16 *v23;
  TSTTableHeaderStorage *mRowHeaderStorage;
  uint64_t v25;
  unsigned int v26;
  id v27;
  uint64_t mNextRowStripID;
  TSTTableTile *v29;
  TSTTableRBTreeNode_s *v30;
  uint64_t result;
  unsigned int v32;
  id v33;
  unsigned int v34;
  int v35;
  unint64_t v36;
  unsigned int v37;
  unsigned __int16 v38;
  unsigned __int16 v39;
  unsigned __int16 v40;

  -[TSPContainedObject willModify](a1, "willModify");
  v6 = a3 + a2;
  v7 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
  v8 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
  if (a3)
  {
    v34 = a3 + a2;
    v35 = a3;
    v9 = a3;
    v37 = a2;
    do
    {
      v40 = -1;
      v10 = v8;
      v11 = TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)((char *)&a1->super.super.isa + v8[833]), (unsigned __int16)(v6 - 1), &v40);
      v12 = -[TSTTileIDKeyDict tileForID:](a1->mTileStorage, "tileForID:", v11);
      if (!v12)
      {
        v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreRemoveRows(TSTTableDataStore *, TSURowIndex, TSUColumnRowCount)");
        a2 = v37;
        objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1841, CFSTR("Couldn't find a tile for row %hu!"), (unsigned __int16)(v6 - 1));
      }
      v15 = v40;
      if (v40 > (unsigned __int16)(v6 - 1))
      {
        v16 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v17 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreRemoveRows(TSTTableDataStore *, TSURowIndex, TSUColumnRowCount)");
        a2 = v37;
        objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1842, CFSTR("Tile for row deletion doesn't match!"));
        v15 = v40;
      }
      v18 = v6 - v15;
      if (v15 <= a2)
        v18 = v9;
      v19 = a2 >= v15;
      v20 = a2 - v15;
      if (v19)
        v21 = v20;
      else
        v21 = 0;
      v22 = v18;
      p_updateColumnCellCountsForDeletionGivenTile(a1, v12, v21, v18);
      TSTTableTileRemoveRows((uint64_t)v12, v21, v22);
      if (-[TSTTableTile numRows](v12, "numRows"))
      {
        v8 = v10;
      }
      else
      {
        v8 = v10;
        v23 = TSTTableRBTreeFind(*(unsigned __int16 **)((char *)&a1->super.super.isa + v10[833]), v40);
        *(Class *)((char *)&a1->super.super.isa + v10[833]) = (Class)TSTTableRBTreeDelete(*(TSTTableRBTreeNode_s **)((char *)&a1->super.super.isa+ v10[833]), v23);
        v36 = v36 & 0xFFFFFFFF00000000 | v11;
        -[TSTTileIDKeyDict removeTileForID:](a1->mTileStorage, "removeTileForID:");
      }
      v9 -= v22;
      v6 = v40 + v21;
      TSTTableRBTreeShiftNodesAfter(*(uint64_t *)((char *)&a1->super.super.isa + v8[833]), v40, -v22);
    }
    while (v9);
    v7 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
    mRowHeaderStorage = a1->mRowHeaderStorage;
    v25 = a2;
    v6 = v34;
    a3 = v35;
    do
    {
      -[TSTTableHeaderStorage removeHeaderForKey:](mRowHeaderStorage, "removeHeaderForKey:", v25);
      v25 = (v25 + 1);
    }
    while (v25 < v34);
  }
  objc_msgSend(*(id *)((char *)&a1->super.super.isa + v7[827]), "shiftKeysAtIndex:amount:", v6, -a3);
  if (-[TSTTileIDKeyDict tileForID:](a1->mTileStorage, "tileForID:", TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)((char *)&a1->super.super.isa + v8[833]), 0, 0)))
  {
    if ((_DWORD)a2)
      goto LABEL_20;
LABEL_23:
    v26 = 0xFFFF;
    goto LABEL_24;
  }
  mNextRowStripID = a1->mNextRowStripID;
  a1->mNextRowStripID = mNextRowStripID + 1;
  v29 = -[TSTTableTile initWithContext:]([TSTTableTile alloc], "initWithContext:", -[TSPObject context](-[TSPContainedObject owner](a1, "owner"), "context"));
  v30 = (TSTTableRBTreeNode_s *)TSTTableRBTreeNewNode(0, mNextRowStripID);
  *(Class *)((char *)&a1->super.super.isa + v8[833]) = (Class)TSTTableRBTreeInsert(*(TSTTableRBTreeNode_s **)((char *)&a1->super.super.isa+ v8[833]), v30);
  -[TSTTileIDKeyDict setTile:forID:](a1->mTileStorage, "setTile:forID:", v29, mNextRowStripID);

  if (!(_DWORD)a2)
    goto LABEL_23;
LABEL_20:
  v39 = 0;
  v26 = TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)((char *)&a1->super.super.isa + v8[833]), (unsigned __int16)(a2 - 1), &v39);
  v27 = -[TSTTileIDKeyDict tileForID:](a1->mTileStorage, "tileForID:", v26);
  if (TSTTableTileShouldMergeRows((uint64_t)v27))
    p_MergeTileRows((uint64_t)a1, v27, v39, v26);
LABEL_24:
  v38 = 0;
  result = TSTTableRBTreeStripIDForCellIndex(*(unsigned __int16 **)((char *)&a1->super.super.isa + v8[833]), a2, &v38);
  if (v26 != (_DWORD)result)
  {
    v32 = result;
    v33 = -[TSTTileIDKeyDict tileForID:](a1->mTileStorage, "tileForID:", result);
    result = TSTTableTileShouldMergeRows((uint64_t)v33);
    if ((_DWORD)result)
      return (uint64_t)p_MergeTileRows((uint64_t)a1, v33, v38, v32);
  }
  return result;
}

uint64_t privateRemoveColumnsFromTile(TSTTableTile *a1, unsigned __int16 *a2)
{
  return TSTTableTileRemoveColumns((uint64_t)a1, *(unsigned __int8 *)a2, a2[1]);
}

uint64_t TSTTableDataStoreRemoveColumns(TSTTableDataStore *a1, uint64_t a2, int a3)
{
  uint64_t v6;
  unsigned int v7;
  void *v8;
  _BYTE v10[2];
  __int16 v11;
  char v12;

  -[TSPContainedObject willModify](a1, "willModify");
  v10[0] = a2;
  v12 = 0;
  v11 = a3;
  TSTTableDataStoreIterateTiles(a1, a1->mRowTileIndex, v10, (void (*)(TSTTableTile *, void *))privateRemoveColumnsFromTile);
  v6 = -[TSPLazyReference object](a1->mColumnHeaderStorageReference, "object");
  v7 = a3 + a2;
  if (a3)
  {
    v8 = (void *)v6;
    do
    {
      objc_msgSend(v8, "removeHeaderForKey:", a2);
      a2 = (a2 + 1);
    }
    while (a2 < v7);
  }
  objc_msgSend(-[TSPLazyReference object](a1->mColumnHeaderStorageReference, "object"), "shiftKeysAtIndex:amount:", v7, -a3);
  a1->mCellCountValid = 0;
  return TSTTableDataStoreNumberOfPopulatedCells((uint64_t)a1);
}

uint64_t TSTTableDataStoreMoveRows(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  void *v6;
  uint64_t v7;
  TSTTableTile *v8;
  unsigned int v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  TSTTableTile *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  unsigned int v17;
  unint64_t v18;
  int v19;
  unsigned int v20;
  unsigned __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t i;
  _WORD *v26;
  __int16 v27;
  unsigned __int16 v28;
  uint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  void *v33;
  void *v34;
  id v35;
  id v36;
  unsigned __int16 *v37;
  void *v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  TSTTableTile *v42;
  void *v43;
  uint64_t v44;
  TSTTableTile *v45;
  uint64_t v46;
  TSTTableRBTreeNode_s *v47;
  uint64_t *v48;
  uint64_t *v49;
  uint64_t *v50;
  BOOL v51;
  void *v52;
  uint64_t j;
  unsigned __int16 *v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  uint64_t result;
  TSTTableTile *v59;
  __int16 v60;
  __int16 MidpointForRowSplit;
  unint64_t v62;
  unsigned int v63;
  unsigned __int16 v65;
  uint64_t v66;
  uint64_t *v67;
  id obj;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  unsigned int v74;
  unsigned __int16 v75;
  uint64_t v76;
  id v77;
  _BYTE v78[128];
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  objc_msgSend((id)a1, "willModify");
  v65 = a3;
  if (a3 > a2)
  {
    if (a4 + a2 > a3)
    {
      v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreMoveRows(TSTTableDataStore *, TSURowIndex, TSURowIndex, TSUColumnRowCount)");
      objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1978, CFSTR("Move row ranges cannot overlap!"));
    }
    v65 = a3 - a4;
  }
  v75 = -1;
  v8 = (TSTTableTile *)p_TileForRowIndex(a1, a2, &v75, &v74);
  v9 = a2;
  if (v8)
  {
    if (v75 != a2)
    {
      p_SplitTileAtRowIndex(a1, v8, v75, a2);
      v10 = p_TileForRowIndex(a1, a2, &v75, &v74);
      v9 = a2;
      if (!v10 || v75 != a2)
      {
        v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreMoveRows(TSTTableDataStore *, TSURowIndex, TSURowIndex, TSUColumnRowCount)");
        objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 1993, CFSTR("Tile tree isn't in the expected state after forced split!"));
        v9 = a2;
      }
    }
  }
  v63 = a4 + v9;
  v13 = (TSTTableTile *)p_TileForRowIndex(a1, (unsigned __int16)(a4 + v9), &v75, &v74);
  if (v13)
  {
    if (v63 != v75)
    {
      p_SplitTileAtRowIndex(a1, v13, v75, v63);
      if (!p_TileForRowIndex(a1, (unsigned __int16)v63, &v75, &v74) || v63 != v75)
      {
        v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreMoveRows(TSTTableDataStore *, TSURowIndex, TSURowIndex, TSUColumnRowCount)");
        objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2002, CFSTR("Tile tree isn't in the expected state after forced split!"));
      }
    }
  }
  obj = (id)objc_msgSend(MEMORY[0x24BDBCEB8], "arrayWithCapacity:", a4);
  v66 = operator new();
  v16 = 0;
  *(_QWORD *)(v66 + 8) = 0;
  v17 = a2;
  *(_QWORD *)(v66 + 16) = 0;
  v67 = (uint64_t *)(v66 + 8);
  *(_QWORD *)v66 = v66 + 8;
  v75 = -1;
  v18 = v63;
  do
  {
    v19 = v18 - 1;
    if (v17 > (unsigned __int16)(v18 - 1))
      break;
    v20 = v75;
    while (!v16 || v20 > (unsigned __int16)v19)
    {
      v16 = (void *)p_TileForRowIndex(a1, (unsigned __int16)v19, &v75, &v74);
      if (v16)
      {
        if (v20 != 0xFFFF)
        {
          v21 = v75;
          v70 = 0u;
          v71 = 0u;
          v72 = 0u;
          v73 = 0u;
          v22 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v70, v78, 16);
          if (v22)
          {
            v23 = v20 - v21;
            v24 = *(_QWORD *)v71;
            do
            {
              for (i = 0; i != v22; ++i)
              {
                if (*(_QWORD *)v71 != v24)
                  objc_enumerationMutation(obj);
                v26 = *(_WORD **)(*((_QWORD *)&v70 + 1) + 8 * i);
                v27 = v26[268];
                objc_msgSend(v26, "willModify");
                v26[268] = v23 + v27;
              }
              v22 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v70, v78, 16);
            }
            while (v22);
          }
        }
        v17 = a2;
        break;
      }
      v75 = v20;
      --v19;
      v18 = (v18 - 1);
      v17 = a2;
      if (a2 > (unsigned __int16)v19)
        goto LABEL_48;
    }
    v28 = v75;
    if (v75 <= v17)
      v29 = v17;
    else
      v29 = v75;
    v30 = (unsigned __int16)(v19 - v29) + 1;
    if ((v30 & 0x10000) == 0)
    {
      v31 = (unsigned __int16)(v18 - v29);
      v32 = v29;
      do
      {
        v33 = (void *)objc_msgSend(*(id *)(a1 + 40), "headerForKey:willModify:createIfNotThere:", v32, 0, 0);
        v34 = v33;
        if (v33)
        {
          v35 = v33;
          LODWORD(v76) = (unsigned __int16)(v65 - a2 + v32);
          v77 = v34;
          v36 = v34;
          std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,SFUtility::ObjcSharedPtr<NSObject>>>((uint64_t **)v66, (unsigned int *)&v76, (uint64_t)&v76);

          objc_msgSend(*(id *)(a1 + 40), "removeHeaderForKey:", v32);
        }
        v32 = (v32 + 1);
        --v31;
      }
      while (v31);
      v28 = v75;
    }
    TSTTableTileYankRows((uint64_t)v16, (unsigned __int16)(v29 - v28), (unsigned __int16)v30, obj);
    if (!objc_msgSend(v16, "numRows"))
    {
      v37 = TSTTableRBTreeFind(*(unsigned __int16 **)(a1 + 24), v75);
      if (*v37 != v75)
      {
        v38 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v39 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreMoveRows(TSTTableDataStore *, TSURowIndex, TSURowIndex, TSUColumnRowCount)");
        objc_msgSend(v38, "handleFailureInFunction:file:lineNumber:description:", v39, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2057, CFSTR("Found the wrong node (bad key)!"));
      }
      if (v37[1] != (unsigned __int16)v74)
      {
        v40 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v41 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreMoveRows(TSTTableDataStore *, TSURowIndex, TSURowIndex, TSUColumnRowCount)");
        objc_msgSend(v40, "handleFailureInFunction:file:lineNumber:description:", v41, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2058, CFSTR("Found the wrong node (bad value)!"));
      }
      *(_QWORD *)(a1 + 24) = TSTTableRBTreeDelete(*(TSTTableRBTreeNode_s **)(a1 + 24), v37);
      v62 = v62 & 0xFFFFFFFF00000000 | v74;
      objc_msgSend(*(id *)(a1 + 32), "removeTileForID:");
      v16 = 0;
      v29 = v75;
    }
    v18 = v29;
    v17 = a2;
  }
  while ((_DWORD)v29);
LABEL_48:
  objc_msgSend(*(id *)(a1 + 40), "shiftKeysAtIndex:amount:", (unsigned __int16)v63, -a4);
  TSTTableRBTreeShiftNodesAtOrAfter(*(_QWORD *)(a1 + 24), a2, -a4);
  v42 = (TSTTableTile *)p_TileForRowIndex(a1, v65, &v75, &v74);
  if (v42)
  {
    if (v75 != v65)
    {
      p_SplitTileAtRowIndex(a1, v42, v75, v65);
      if (!p_TileForRowIndex(a1, v65, &v75, &v74) || v75 != v65)
      {
        v43 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v44 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreMoveRows(TSTTableDataStore *, TSURowIndex, TSURowIndex, TSUColumnRowCount)");
        objc_msgSend(v43, "handleFailureInFunction:file:lineNumber:description:", v44, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2092, CFSTR("Tile tree isn't in the expected state after forced split!"));
      }
    }
  }
  v45 = -[TSTTableTile initWithRows:context:]([TSTTableTile alloc], "initWithRows:context:", obj, objc_msgSend((id)objc_msgSend((id)a1, "owner"), "context"));
  objc_msgSend(*(id *)(a1 + 40), "shiftKeysAtIndex:amount:", v65, a4);
  TSTTableRBTreeShiftNodesAtOrAfter(*(_QWORD *)(a1 + 24), v65, a4);
  v46 = *(unsigned __int16 *)(a1 + 136);
  *(_WORD *)(a1 + 136) = v46 + 1;
  v47 = (TSTTableRBTreeNode_s *)TSTTableRBTreeNewNode(v65, v46);
  *(_QWORD *)(a1 + 24) = TSTTableRBTreeInsert(*(TSTTableRBTreeNode_s **)(a1 + 24), v47);
  objc_msgSend(*(id *)(a1 + 32), "setTile:forID:", v45, v46);

  v48 = *(uint64_t **)v66;
  if (*(uint64_t **)v66 != v67)
  {
    do
    {
      objc_msgSend(*(id *)(a1 + 40), "setHeader:forKey:", v48[5], *((unsigned __int16 *)v48 + 16));
      v49 = (uint64_t *)v48[1];
      if (v49)
      {
        do
        {
          v50 = v49;
          v49 = (uint64_t *)*v49;
        }
        while (v49);
      }
      else
      {
        do
        {
          v50 = (uint64_t *)v48[2];
          v51 = *v50 == (_QWORD)v48;
          v48 = v50;
        }
        while (!v51);
      }
      v48 = v50;
    }
    while (v50 != v67);
  }
  std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::destroy(v66, *(_QWORD **)(v66 + 8));
  MEMORY[0x219A153B8](v66, 0x1020C4062D53EE8);
  v52 = (void *)objc_msgSend(MEMORY[0x24BDD1698], "indexSet");
  v76 = a1;
  v77 = v52;
  TSTTableRBTreeApply(*(_QWORD *)(a1 + 24), (uint64_t (*)(_QWORD, _QWORD, uint64_t))p_findEmptyTiles, (uint64_t)&v76);
  if (objc_msgSend(v52, "count"))
  {
    for (j = objc_msgSend(v52, "firstIndex"); j != 0x7FFFFFFFFFFFFFFFLL; j = objc_msgSend(v52, "indexGreaterThanIndex:", j))
    {
      v54 = TSTTableRBTreeFind(*(unsigned __int16 **)(a1 + 24), (unsigned __int16)j);
      v55 = v54[1];
      *(_QWORD *)(a1 + 24) = TSTTableRBTreeDelete(*(TSTTableRBTreeNode_s **)(a1 + 24), v54);
      v18 = v18 & 0xFFFFFFFF00000000 | v55;
      objc_msgSend(*(id *)(a1 + 32), "removeTileForID:", v18);
    }
  }
  if (v65)
  {
    v56 = p_TileForRowIndex(a1, (unsigned __int16)(v65 - 1), &v75, &v74);
    v57 = (void *)v56;
    if (v56)
    {
      if (TSTTableTileShouldMergeRows(v56))
        p_MergeTileRows(a1, v57, v75, v74);
    }
  }
  result = p_TileForRowIndex(a1, v65, &v75, &v74);
  v59 = (TSTTableTile *)result;
  if (result)
  {
    result = TSTTableTileShouldSplitRows(result);
    if ((_DWORD)result)
    {
      v60 = v75;
      objc_msgSend((id)a1, "willModify");
      MidpointForRowSplit = TSTTableTileFindMidpointForRowSplit((uint64_t)v59);
      return p_SplitTileAtRowIndex(a1, v59, v60, MidpointForRowSplit + v60);
    }
  }
  return result;
}

void sub_217BAFE8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  void *v28;

  _Unwind_Resume(a1);
}

uint64_t p_SplitTileAtRowIndex(uint64_t a1, TSTTableTile *a2, __int16 a3, __int16 a4)
{
  unsigned __int16 v8;
  uint64_t v9;
  TSTTableTile *v10;
  TSTTableRBTreeNode_s *v11;

  objc_msgSend((id)a1, "willModify");
  v8 = a4 - a3;
  v9 = *(unsigned __int16 *)(a1 + 136);
  *(_WORD *)(a1 + 136) = v9 + 1;
  v10 = TSTTableTileSplitRows(a2, v8);
  v11 = (TSTTableRBTreeNode_s *)TSTTableRBTreeNewNode(a4, v9);
  *(_QWORD *)(a1 + 24) = TSTTableRBTreeInsert(*(TSTTableRBTreeNode_s **)(a1 + 24), v11);
  return objc_msgSend(*(id *)(a1 + 32), "setTile:forID:", v10, v9);
}

void p_moveColumnsInTile(unsigned __int16 a1, unsigned int a2, unsigned __int8 *a3)
{
  TSTTableTileMoveColumns(objc_msgSend(*(id *)(*(_QWORD *)a3 + 32), "tileForID:", a2), a3[8], a3[9], *((unsigned __int16 *)a3 + 5));
}

uint64_t TSTTableDataStoreMoveColumns(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6;
  unsigned __int8 v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;
  int v15;
  void *v16;
  void *v17;
  id v18;
  id v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t *v22;
  BOOL v23;
  char v25;
  char v26;
  uint64_t v27;
  id v28;

  LODWORD(v6) = a2;
  objc_msgSend((id)a1, "willModify");
  v8 = a3;
  if (a3 > v6)
  {
    if ((int)a4 + (int)v6 > a3)
    {
      v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreMoveColumns(TSTTableDataStore *, TSUColumnIndex, TSUColumnIndex, TSUColumnRowCount)");
      objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2178, CFSTR("Move column ranges cannot overlap!"));
    }
    v8 = a3 - a4;
  }
  v25 = a3;
  v26 = v6;
  v11 = operator new();
  *(_QWORD *)(v11 + 8) = 0;
  v12 = (uint64_t *)(v11 + 8);
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)v11 = v11 + 8;
  v13 = v8;
  v14 = a4;
  if ((_BYTE)a4)
  {
    v15 = v13;
    v6 = v6;
    do
    {
      v16 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "headerForKey:willModify:createIfNotThere:", v6, 0, 0);
      if (v16)
      {
        v17 = v16;
        v18 = v16;
        LODWORD(v27) = v15;
        v28 = v17;
        v19 = v17;
        std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,SFUtility::ObjcSharedPtr<NSObject>>>((uint64_t **)v11, (unsigned int *)&v27, (uint64_t)&v27);

        objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "removeHeaderForKey:", v6);
      }
      v6 = (v6 + 1);
      ++v15;
      --v14;
    }
    while (v14);
  }
  objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "shiftKeysAtIndex:amount:", (a4 + v26), -(int)a4);
  objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "shiftKeysAtIndex:amount:", v13, a4);
  v20 = *(uint64_t **)v11;
  if (*(uint64_t **)v11 != v12)
  {
    do
    {
      objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "object"), "setHeader:forKey:", v20[5], *((unsigned __int8 *)v20 + 32));
      v21 = (uint64_t *)v20[1];
      if (v21)
      {
        do
        {
          v22 = v21;
          v21 = (uint64_t *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          v22 = (uint64_t *)v20[2];
          v23 = *v22 == (_QWORD)v20;
          v20 = v22;
        }
        while (!v23);
      }
      v20 = v22;
    }
    while (v22 != v12);
  }
  std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::destroy(v11, *(_QWORD **)(v11 + 8));
  MEMORY[0x219A153B8](v11, 0x1020C4062D53EE8);
  v27 = a1;
  LOBYTE(v28) = v26;
  BYTE1(v28) = v25;
  WORD1(v28) = a4;
  return TSTTableRBTreeApply(*(_QWORD *)(a1 + 24), (uint64_t (*)(_QWORD, _QWORD, uint64_t))p_moveColumnsInTile, (uint64_t)&v27);
}

void sub_217BB01F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

void TSTTableDataStoreSwapRows(uint64_t a1, uint64_t a2, uint64_t a3)
{
  TSTTableTile *v6;
  uint64_t v7;
  TSTTableTile *v8;
  void *v9;
  uint64_t v10;
  TSTTableTileRowInfo *v11;
  TSTTableTileRowInfo *v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  id v15;
  id v16;
  unsigned int v17;
  unsigned int v18;
  unsigned __int16 v19;
  unsigned __int16 v20;

  v20 = -1;
  v19 = -1;
  v6 = (TSTTableTile *)p_TileForRowIndex(a1, a2, &v20, &v18);
  v7 = p_TileForRowIndex(a1, a3, &v19, &v17);
  v8 = (TSTTableTile *)v7;
  if (!v6 || !v7)
  {
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTTableDataStoreSwapRows(TSTTableDataStore *, TSURowIndex, TSURowIndex)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2229, CFSTR("Can't get tiles for rows in swap!"));
  }
  v11 = (TSTTableTileRowInfo *)TSTTableTileYankRow((uint64_t)v6, (unsigned __int16)(a2 - v20));
  v12 = (TSTTableTileRowInfo *)TSTTableTileYankRow((uint64_t)v8, (unsigned __int16)(a3 - v19));
  if (v11)
  {
    -[TSPContainedObject setOwner:](v11, "setOwner:", v8);
    v13 = a3 - v19;
    -[TSPContainedObject willModify](v11, "willModify");
    v11->mTileRowIndex = v13;
    TSTTableTileSpliceRow(v8, (unsigned __int16)(a3 - v19), v11);
  }
  if (v12)
  {
    -[TSPContainedObject setOwner:](v12, "setOwner:", v6);
    v14 = a2 - v20;
    -[TSPContainedObject willModify](v12, "willModify");
    v12->mTileRowIndex = v14;
    TSTTableTileSpliceRow(v6, (unsigned __int16)(a2 - v20), v12);
  }
  v15 = (id)objc_msgSend(*(id *)(a1 + 40), "headerForKey:willModify:createIfNotThere:", a2, 0, 0);
  v16 = (id)objc_msgSend(*(id *)(a1 + 40), "headerForKey:willModify:createIfNotThere:", a3, 0, 0);
  objc_msgSend(*(id *)(a1 + 40), "removeHeaderForKey:", a2);
  objc_msgSend(*(id *)(a1 + 40), "removeHeaderForKey:", a3);
  if (v15)
    objc_msgSend(*(id *)(a1 + 40), "setHeader:forKey:", v15, a3);
  if (v16)
    objc_msgSend(*(id *)(a1 + 40), "setHeader:forKey:", v16, a2);

}

uint64_t TSTTableDataStoreGetReorganizeValuesForColumn(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v4;
  char v5;
  uint64_t v6;

  v4 = a1;
  v5 = a2;
  v6 = a3;
  return TSTTableRBTreeApply(*(_QWORD *)(a1 + 24), (uint64_t (*)(_QWORD, _QWORD, uint64_t))p_ReorganizeValuesForTile, (uint64_t)&v4);
}

uint64_t p_ReorganizeValuesForTile(int a1, unsigned int a2, _BYTE *a3)
{
  void *v5;
  uint64_t result;
  uint64_t v7;
  int v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  unint64_t v13;
  BOOL v14;
  BOOL v15;
  UInt8 *v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unsigned int v19;
  __int16 *v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unsigned int *Element;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  int *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  const __CFString *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  const __CFString *v53;
  int v54;
  void *MultipleChoiceListFormatForKey;
  double v56;
  double *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *v75;
  BOOL v76;
  uint64_t v77;
  uint64_t v78;
  double *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  void *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  void *v88;
  void *v89;
  uint64_t v90;
  id obj;
  int v92;
  uint64_t v93;
  _OWORD v94[2];
  uint64_t v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  _BYTE v100[128];
  uint64_t v101;

  v101 = *MEMORY[0x24BDAC8D0];
  v5 = (void *)objc_msgSend(*(id *)(*(_QWORD *)a3 + 32), "tileForID:", a2);
  v96 = 0u;
  v97 = 0u;
  v98 = 0u;
  v99 = 0u;
  obj = (id)objc_msgSend(v5, "rowInfos");
  result = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v96, v100, 16);
  if (result)
  {
    v7 = result;
    v8 = a1;
    v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
    v92 = v8;
    v93 = *(_QWORD *)v97;
    do
    {
      v10 = 0;
      v90 = v7;
      do
      {
        if (*(_QWORD *)v97 != v93)
          objc_enumerationMutation(obj);
        v11 = *(_QWORD *)(*((_QWORD *)&v96 + 1) + 8 * v10);
        v12 = *(void **)(*(_QWORD *)a3 + v9[842]);
        if (!v12
          || (v13 = objc_msgSend(v12, "mergedRangeForCellID:", *(unsigned __int16 *)(v11 + 536) | ((unint64_t)a3[8] << 16)), (_WORD)v13 == 0xFFFF)|| ((v13 & 0xFF0000) != 0xFF0000 ? (v14 = HIWORD(v13) == 0) : (v14 = 1), !v14 ? (v15 = (v13 & 0xFFFF00000000) == 0) : (v15 = 1), v15))
        {
          LOBYTE(v25) = a3[8];
        }
        else
        {
          v25 = v13 >> 16;
        }
        v16 = TSTTableTileRowInfoCellStorageRefAtTileColumnIndex(v11, v25);
        if (v16)
        {
          v17 = v16;
          v18 = *((_QWORD *)a3 + 2);
          v19 = *(unsigned __int16 *)(v11 + 536) + v92;
          v20 = (__int16 *)(v18 + 24 * v19);
          v21 = HIBYTE(*(unsigned __int16 *)(v16 + 1));
          LOBYTE(v22) = HIBYTE(*(_WORD *)(v16 + 1));
          *v20 = HIBYTE(*(_WORD *)(v16 + 1)) | (*((unsigned __int8 *)v20 + 1) << 8);
          if (v21 == 2)
          {
            if ((v16[4] & 4) != 0)
            {
              Element = (unsigned int *)TSTCellStorageGetElement((uint64_t)v16, 4);
              if (!Element)
              {
                v27 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                v28 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageFormatID(TSTCellStorage *)");
                v7 = v90;
                v29 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h");
                v30 = v28;
                v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
                objc_msgSend(v27, "handleFailureInFunction:file:lineNumber:description:", v30, v29, 249, CFSTR("Can't get format ID storage element!"));
              }
              v23 = *Element;
            }
            else
            {
              v23 = 0;
            }
            v95 = 0;
            memset(v94, 0, sizeof(v94));
            TSTTableDataListGetCellFormatForKey(objc_msgSend(*(id *)(*(_QWORD *)a3 + 104), "object"), v23, (uint64_t)v94);
            if (LODWORD(v94[0]) == 266)
            {
              *(_BYTE *)v20 = 10;
              v24 = HIDWORD(v94[0]);
            }
            else
            {
              v24 = 0;
            }
            v22 = *v20;
          }
          else
          {
            v24 = 0;
          }
          switch((char)v22)
          {
            case 0:
              *v20 = v22;
              break;
            case 2:
              *v20 = v22 | 0x600;
              v31 = 0;
              if ((v17[4] & 0x20) == 0)
                goto LABEL_59;
              v32 = (uint64_t *)TSTCellStorageGetElement((uint64_t)v17, 32);
              if (v32)
                goto LABEL_58;
              v33 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
              v34 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellStorageDoubleValue(TSTCellStorage *)");
              v35 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h");
              v36 = (void *)v33;
              v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
              v37 = v34;
              v38 = 420;
              goto LABEL_42;
            case 3:
              *v20 = v22 | 0x200;
              if ((v17[4] & 0x10) == 0)
                goto LABEL_44;
              v39 = (int *)TSTCellStorageGetElement((uint64_t)v17, 16);
              if (v39)
                goto LABEL_67;
              v40 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
              v41 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageStringID(TSTCellStorage *)");
              v42 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h");
              v43 = (void *)v40;
              v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
              v44 = v41;
              v45 = 401;
              v46 = CFSTR("Can't get string ID storage element!");
              goto LABEL_66;
            case 5:
              *v20 = v22 | 0x400;
              if (v17[2] << 8 != 1280)
              {
                v62 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                v63 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellStorageRawDateValue(TSTCellStorage *)");
                v64 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h");
                v65 = (void *)v62;
                v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
                objc_msgSend(v65, "handleFailureInFunction:file:lineNumber:description:", v63, v64, 439, CFSTR("Asked for date value from non-date cell."));
              }
              if ((v17[4] & 0x40) == 0)
              {
                v66 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                v67 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellStorageRawDateValue(TSTCellStorage *)");
                v68 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h");
                v69 = (void *)v66;
                v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
                objc_msgSend(v69, "handleFailureInFunction:file:lineNumber:description:", v67, v68, 440, CFSTR("No date content in date cell."));
              }
              v32 = (uint64_t *)TSTCellStorageGetElement((uint64_t)v17, 64);
              if (v32)
                goto LABEL_58;
              v70 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
              v71 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellStorageRawDateValue(TSTCellStorage *)");
              v35 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h");
              v36 = (void *)v70;
              v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
              v37 = v71;
              v38 = 442;
              v53 = CFSTR("Can't get date storage element!");
              goto LABEL_57;
            case 6:
              *v20 = v22 | 0x100;
              if (v17[2] << 8 != 1536)
              {
                v72 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                v73 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTCellStorageBoolValue(TSTCellStorage *)");
                v74 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h");
                v75 = (void *)v72;
                v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
                objc_msgSend(v75, "handleFailureInFunction:file:lineNumber:description:", v73, v74, 427, CFSTR("Asked for BOOL value from non-BOOL cell."));
              }
              if ((v17[4] & 0x20) != 0)
              {
                v79 = (double *)TSTCellStorageGetElement((uint64_t)v17, 32);
                if (!v79)
                {
                  v80 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                  v81 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTCellStorageBoolValue(TSTCellStorage *)");
                  v82 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h");
                  v83 = (void *)v80;
                  v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
                  objc_msgSend(v83, "handleFailureInFunction:file:lineNumber:description:", v81, v82, 432, CFSTR("Can't get has numbers storage element!"));
                }
                v76 = *v79 != 0.0;
              }
              else
              {
                v76 = 0;
              }
              *(_BYTE *)(v18 + 24 * v19 + 8) = v76;
              break;
            case 7:
              *v20 = v22 | 0x500;
              if (v17[2] << 8 != 1792)
              {
                v47 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                v48 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellStorageDurationValue(TSTCellStorage *)");
                v49 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h");
                v50 = (void *)v47;
                v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
                objc_msgSend(v50, "handleFailureInFunction:file:lineNumber:description:", v48, v49, 453, CFSTR("Asked for duration value from non-duration cell."));
              }
              v31 = 0;
              if ((v17[4] & 0x20) == 0)
                goto LABEL_59;
              v32 = (uint64_t *)TSTCellStorageGetElement((uint64_t)v17, 32);
              if (v32)
                goto LABEL_58;
              v51 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
              v52 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellStorageDurationValue(TSTCellStorage *)");
              v35 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h");
              v36 = (void *)v51;
              v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
              v37 = v52;
              v38 = 458;
LABEL_42:
              v53 = CFSTR("Can't get has number storage element!");
LABEL_57:
              objc_msgSend(v36, "handleFailureInFunction:file:lineNumber:description:", v37, v35, v38, v53);
LABEL_58:
              v31 = *v32;
LABEL_59:
              *(_QWORD *)(v18 + 24 * v19 + 8) = v31;
              break;
            case 9:
              *v20 = v22 | 0x200;
              if ((v17[5] & 2) != 0)
              {
                v39 = (int *)TSTCellStorageGetElement((uint64_t)v17, 512);
                if (!v39)
                {
                  v77 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                  v78 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTCellStorageRichTextPayloadID(TSTCellStorage *)");
                  v42 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h");
                  v43 = (void *)v77;
                  v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
                  v44 = v78;
                  v45 = 357;
                  v46 = CFSTR("Can't get formula error ID storage element!");
LABEL_66:
                  objc_msgSend(v43, "handleFailureInFunction:file:lineNumber:description:", v44, v42, v45, v46);
                }
LABEL_67:
                v54 = *v39;
              }
              else
              {
LABEL_44:
                v54 = 0;
              }
              *(_DWORD *)(v18 + 24 * v19 + 8) = v54;
              break;
            case 10:
              MultipleChoiceListFormatForKey = (void *)TSTTableDataListGetMultipleChoiceListFormatForKey(objc_msgSend(*(id *)(*(_QWORD *)a3 + 112), "object"), v24);
              v56 = 0.0;
              if ((v17[4] & 0x20) != 0)
              {
                v57 = (double *)TSTCellStorageGetElement((uint64_t)v17, 32);
                if (!v57)
                {
                  v89 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                  v58 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellStorageDoubleValue(TSTCellStorage *)");
                  v7 = v90;
                  v59 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCellStorage.h");
                  v60 = v58;
                  v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
                  objc_msgSend(v89, "handleFailureInFunction:file:lineNumber:description:", v60, v59, 420, CFSTR("Can't get has number storage element!"));
                }
                v56 = *v57;
              }
              v61 = (uint64_t)v56;
              switch(objc_msgSend(MultipleChoiceListFormatForKey, "valueTypeOfItemAtIndex:", (uint64_t)v56))
              {
                case 0u:
                  *v20 = 0;
                  break;
                case 1u:
                  *v20 = 262;
                  *(_BYTE *)(v18 + 24 * v19 + 8) = objc_msgSend(MultipleChoiceListFormatForKey, "BOOLeanAtIndex:", v61);
                  break;
                case 2u:
                  *((_BYTE *)v20 + 1) = 2;
                  v84 = v18 + 24 * v19;
                  *(_DWORD *)(v84 + 8) = v24;
                  *(_QWORD *)(v84 + 16) = v61;
                  break;
                case 3u:
                  *v20 = 1029;
                  objc_msgSend((id)objc_msgSend(MultipleChoiceListFormatForKey, "dateAtIndex:", v61), "timeIntervalSinceReferenceDate");
                  goto LABEL_59;
                case 4u:
                  *v20 = 1538;
                  objc_msgSend(MultipleChoiceListFormatForKey, "numberAtIndex:", v61);
                  goto LABEL_59;
                default:
                  v85 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                  v86 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_ReorganizeValuesForTile(TSURowIndex, TSTTableTileStripID, void *)");
                  v87 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm");
                  v88 = (void *)v85;
                  v9 = &OBJC_IVAR___TSDMetalBloomEffect__fboTransferShader;
                  objc_msgSend(v88, "handleFailureInFunction:file:lineNumber:description:", v86, v87, 2387, CFSTR("Unexpected value type found in TSCECellValue"));
                  break;
              }
              break;
            default:
              break;
          }
        }
        ++v10;
      }
      while (v7 != v10);
      result = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v96, v100, 16);
      v7 = result;
    }
    while (result);
  }
  return result;
}

uint64_t privateDumpTile(unsigned int a1, unsigned int a2, id *a3)
{
  NSLog((NSString *)CFSTR("tile at row index %hu"), a1);
  return objc_msgSend((id)objc_msgSend(a3[4], "tileForID:", a2), "debugDump");
}

uint64_t privateDumpTiles(TSTTableDataStore *a1)
{
  return TSTTableRBTreeApply((uint64_t)a1->mRowTileIndex, (uint64_t (*)(_QWORD, _QWORD, uint64_t))privateDumpTile, (uint64_t)a1);
}

uint64_t privateValidateTile(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "validate");
}

uint64_t privateValidateTileStorage(void *a1, const char *a2)
{
  return objc_msgSend(a1, "applyFunction:withState:", privateValidateTile, 0);
}

uint64_t privateValidateRowTileIndex(TSTTableDataStore *a1)
{
  return TSTTableRBTreeApply((uint64_t)a1->mRowTileIndex, (uint64_t (*)(_QWORD, _QWORD, uint64_t))p_validateTileCB, (uint64_t)a1);
}

uint64_t p_validateTileCB(unsigned __int16 a1, unsigned int a2, id *a3)
{
  uint64_t result;
  void *v4;
  uint64_t v5;

  result = objc_msgSend(a3[4], "tileForID:", a2);
  if (!result)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_validateTileCB(UInt16, UInt16, void *)");
    return objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2449, CFSTR("No tile for valid strip ID!"));
  }
  return result;
}

TSTTableTileRowInfo *privateValidateRowHeader(unsigned __int16 *a1, unsigned __int16 *a2, void *a3)
{
  uint64_t v4;
  TSTTableTile *v5;
  void *v6;
  uint64_t v7;
  TSTTableTileRowInfo *result;
  TSTTableTileRowInfo *v9;
  void *v10;
  uint64_t v11;
  unsigned __int16 v12;

  v12 = 0;
  v4 = *a1;
  v5 = (TSTTableTile *)objc_msgSend(*((id *)a3 + 4), "tileForID:", TSTTableRBTreeStripIDForCellIndex(*((unsigned __int16 **)a3 + 3), v4, &v12));
  if (!v5)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void privateValidateRowHeader(const void *, const void *, void *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2469, CFSTR("tile not found for index %d"), v4);
  }
  result = TSTTableTileRowInfoForTileRowIndex(v5, (unsigned __int16)(v4 - v12), 0);
  if (result)
  {
    v9 = result;
    if (result->mCellCount != a2[17])
    {
      v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void privateValidateRowHeader(const void *, const void *, void *)");
      return (TSTTableTileRowInfo *)objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2477, CFSTR("row info (%p) cell count and row header (%p) cell count do not match at row: %d"), v9, a2, v4);
    }
  }
  return result;
}

_BYTE *privateCollectColumnCellCountsInTile(uint64_t a1, void *a2, uint64_t a3)
{
  __int16 v5;
  _BYTE *result;
  unsigned __int16 v7;
  unsigned __int16 v8;
  int v9;
  uint64_t v10;
  unsigned __int8 v11;
  unsigned __int16 v12;
  unsigned int v13;

  v5 = objc_msgSend(a2, "numRows");
  result = (_BYTE *)objc_msgSend(a2, "numRows");
  if ((_DWORD)result)
  {
    v7 = 0;
    v8 = v5 - 1;
    do
    {
      result = TSTTableTileRowInfoForRowArrayIndex((uint64_t)a2, (unsigned __int16)(v8 - v7));
      v9 = *((unsigned __int16 *)result + 269);
      if (*((_WORD *)result + 269))
      {
        v10 = (uint64_t)result;
        if (!result[541])
          TSTTableTileRowInfoRecalculateMaxTileColumnIndex((uint64_t)result);
        v11 = 0;
        v12 = 0;
        v13 = *(unsigned __int8 *)(v10 + 540);
        do
        {
          result = TSTTableTileRowInfoCellStorageRefAtTileColumnIndex(v10, v11);
          if (result)
          {
            ++*(_WORD *)(a3 + 2 * v11);
            ++v12;
          }
          ++v11;
        }
        while (v13 >= v11 && v9 != v12);
      }
      ++v7;
    }
    while (v7 <= v8);
  }
  return result;
}

uint64_t privateValidateColumnCellCounts(TSTTableDataStore *a1)
{
  uint64_t i;
  uint64_t result;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  _OWORD v7[32];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  memset(v7, 0, 510);
  -[TSTTileIDKeyDict applyFunction:withState:](a1->mTileStorage, "applyFunction:withState:", privateCollectColumnCellCountsInTile, v7);
  for (i = 0; i != 255; ++i)
  {
    result = objc_msgSend(-[TSPLazyReference object](a1->mColumnHeaderStorageReference, "object"), "headerForKey:willModify:createIfNotThere:", i, 0, 0);
    if (result)
    {
      v4 = result;
      if (*((unsigned __int16 *)v7 + i) != *(unsigned __int16 *)(result + 34))
      {
        v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void privateValidateColumnCellCounts(TSTTableDataStore *)");
        result = objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2531, CFSTR("info (%p) column counts do not match tile counts in column %d for dataStore %p"), v4, i, a1);
      }
    }
  }
  return result;
}

uint64_t TSTTableDataStoreAddString(uint64_t a1, uint64_t a2)
{
  return TSTTableDataListAddString((TSTTableDataList *)objc_msgSend(*(id *)(a1 + 64), "object"), a2);
}

uint64_t TSTTableDataStoreGetStringForKey(uint64_t a1, uint64_t a2)
{
  return TSTTableDataListGetStringForKey(objc_msgSend(*(id *)(a1 + 64), "object"), a2);
}

uint64_t TSTTableDataStoreAddStringReferenceForKey(uint64_t a1, uint64_t a2)
{
  return TSTTableDataListAddReferenceForKey((id *)objc_msgSend(*(id *)(a1 + 64), "object"), a2);
}

void TSTTableDataStoreRemoveStringReferenceForKey(uint64_t a1, uint64_t a2)
{
  TSTTableDataListRemoveReferenceForKey(objc_msgSend(*(id *)(a1 + 64), "object"), a2);
}

BOOL TSTTableDataStoreHasMergeRanges(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 144), "count") != 0;
}

uint64_t TSTTableDataStoreMerge(_QWORD *a1, uint64_t a2)
{
  TSTMergeRegionMap *v4;

  objc_msgSend(a1, "willModify");
  v4 = (TSTMergeRegionMap *)a1[18];
  if (!v4)
  {
    v4 = -[TSTMergeRegionMap initWithContext:]([TSTMergeRegionMap alloc], "initWithContext:", objc_msgSend((id)objc_msgSend(a1, "owner"), "context"));
    a1[18] = v4;
  }
  return -[TSTMergeRegionMap insert:](v4, "insert:", a2);
}

uint64_t TSTTableDataStoreUnmerge(id *a1, uint64_t a2)
{
  objc_msgSend(a1, "willModify");
  return objc_msgSend(a1[18], "remove:", a2);
}

uint64_t TSTTableDataStoreApplyRowRemappingToMergeRanges(id *a1, uint64_t a2)
{
  id v4;
  id v5;

  objc_msgSend(a1, "willModify");
  v4 = a1[18];
  if (v4 && objc_msgSend(v4, "count"))
  {
    v5 = -[TSTMergeRegionMap initRegionMapFromMap:rowRemapping:]([TSTMergeRegionMap alloc], "initRegionMapFromMap:rowRemapping:", a1[18], a2);

    a1[18] = v5;
  }
  return 1;
}

uint64_t TSTTableDataStoreRangeOfTableWithMerges(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 144);
  if (v1)
    return objc_msgSend(v1, "unionedMergeRange");
  else
    return 0xFFFFFFLL;
}

uint64_t TSTTableDataStoreMergeRangeAtCellID(uint64_t a1, unsigned int a2)
{
  void *v2;

  v2 = *(void **)(a1 + 144);
  if (v2)
    return objc_msgSend(v2, "mergedRangeForCellID:", a2);
  else
    return 0xFFFFFFLL;
}

void *TSTTableDataStoreMergeRangesPartiallyIntersectCellRange(uint64_t a1, uint64_t a2)
{
  void *result;

  result = *(void **)(a1 + 144);
  if (result)
    return (void *)objc_msgSend(result, "partiallyIntersectsCellRange:", a2);
  return result;
}

uint64_t TSTTableDataStoreMergedGridIndicesForDirection(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 144), "mergedGridIndicesForDimension:", a2);
}

id TSTTableDataStoreCreateMergeRangesForCellRange(uint64_t a1, uint64_t a2)
{
  if (*(_QWORD *)(a1 + 144))
    return -[TSTMergeRegionMap initRegionMapFromMap:intersectingRange:]([TSTMergeRegionMap alloc], "initRegionMapFromMap:intersectingRange:", *(_QWORD *)(a1 + 144), a2);
  else
    return 0;
}

id TSTTableDataStoreMergeRangesForCellRange(uint64_t a1, uint64_t a2)
{
  return TSTTableDataStoreCreateMergeRangesForCellRange(a1, a2);
}

uint64_t TSTTableDataStoreCopyAPasteboardCustomFormatToDoc(uint64_t a1, void *a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;
  void *v9;
  uint64_t v10;

  if (a2 && *(_QWORD *)(a1 + 128) && (objc_opt_respondsToSelector() & 1) != 0)
  {
    v6 = (void *)objc_msgSend(a2, "customFormatList");
    v7 = objc_msgSend(*(id *)(a1 + 128), "customFormatForKey:", a3);
    if (v7)
      return objc_msgSend(v6, "addCustomFormat:withOldKey:", v7, a3);
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableDataListKey TSTTableDataStoreCopyAPasteboardCustomFormatToDoc(TSTTableDataStore *, TSKDocumentRoot *, TSTTableDataListKey)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableDataStore.mm"), 2739, CFSTR("The pasteboard should have had every custom format."));
  }
  return 0;
}

uint64_t TSTTableDataListPasteboardCustomFormatListCount(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 128), "count");
}

uint64_t TSTTableDataStoreAddConditionalStyle(uint64_t a1, uint64_t a2)
{
  return TSTTableDataListAddConditionalStyleSet((TSTTableDataList *)objc_msgSend(*(id *)(a1 + 56), "object"), a2);
}

uint64_t TSTTableDataStoreConditionalStyleForKey(uint64_t a1, uint64_t a2)
{
  return TSTTableDataListGetConditionalStyleSetForKey(objc_msgSend(*(id *)(a1 + 56), "object"), a2);
}

uint64_t TSTTableDataStoreConditionalStyleRefCountForKey(uint64_t a1, uint64_t a2)
{
  return TSTTableDataListRefCountForKey(objc_msgSend(*(id *)(a1 + 56), "object"), a2);
}

uint64_t p_upgradeTileRowInfos(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "i_upgradeTileRowInfosWithDataStore:");
}

uint64_t **std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,SFUtility::ObjcSharedPtr<NSObject>>>(uint64_t **a1, unsigned int *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unsigned int v7;
  uint64_t **v8;
  unsigned int v9;
  _DWORD *v10;
  void *v11;
  id v12;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = operator new(0x30uLL);
    v10[8] = *(_DWORD *)a3;
    v11 = *(void **)(a3 + 8);
    *((_QWORD *)v10 + 5) = v11;
    v12 = v11;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, (uint64_t)v8, v6, (uint64_t *)v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::destroy(a1, a2[1]);

    operator delete(a2);
  }
}

uint64_t TSTMasterLayoutInvalidateStrokeRange(TSTMasterLayout *a1, uint64_t a2)
{
  char TableNumberOfColumns;
  __int16 TableNumberOfRows;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  TSTStrokeRunArray *v13;
  unsigned int *DefaultStrokesForGridRow;
  unsigned int v15;
  uint64_t v16;
  TSTStrokeRunArray *v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  TSTStrokeRunArray *v22;
  unsigned int *DefaultStrokesForGridColumn;
  unsigned int v24;
  uint64_t v25;
  TSTStrokeRunArray *v26;
  unsigned int *v27;
  unsigned int v29;
  unsigned int v30;

  TSTMasterLayoutStrokesArrayRangeUpdate(a1);
  TableNumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
  v6 = (unsigned __int16)a2;
  if ((unsigned __int16)(a2 + HIWORD(a2) - 1) >= (unsigned __int16)(TableNumberOfRows - 1))
    v7 = (unsigned __int16)(TableNumberOfRows - 1);
  else
    v7 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
  v8 = BYTE2(a2);
  if ((TableNumberOfColumns - 1) >= (BYTE4(a2) + BYTE2(a2) - 1))
    v9 = (BYTE4(a2) + BYTE2(a2) - 1);
  else
    v9 = (TableNumberOfColumns - 1);
  -[NSRecursiveLock lock](a1->mStrokesLock, "lock");
  v29 = v7 + 1;
  if ((unsigned __int16)a2 <= v7 + 1)
  {
    v10 = (unsigned __int16)a2;
    do
    {
      if ((TSTMasterLayoutIsGridRowHidden(a1, v10) & 1) == 0)
      {
        if (v10 <= v7)
        {
          v30 = v10;
          if (TSTMasterLayoutStrokeAdjustGridRowForVisibility(a1, 1, &v30))
          {
            objc_opt_class();
            v11 = v30;
            -[NSMutableArray objectAtIndex:](a1->mTopRowStrokes, "objectAtIndex:", v30);
            v12 = TSUDynamicCast();
            if (v12)
            {
              v13 = (TSTStrokeRunArray *)v12;
              TSTStrokeRunArrayWriteLock(v12);
              DefaultStrokesForGridRow = (unsigned int *)TSTMasterLayoutGetDefaultStrokesForGridRow(a1, v11, 1);
              TSTStrokeRunArrayResetRange(v13, DefaultStrokesForGridRow, BYTE2(a2), v9 + 1);
              TSTStrokeRunArrayUnlock((uint64_t)v13);
              TSTStrokeRunArrayUnlock((uint64_t)DefaultStrokesForGridRow);
            }
          }
        }
        if (v10 > (unsigned __int16)a2)
        {
          v30 = v10;
          if (TSTMasterLayoutStrokeAdjustGridRowForVisibility(a1, 0, &v30))
          {
            objc_opt_class();
            v15 = v30;
            -[NSMutableArray objectAtIndex:](a1->mBottomRowStrokes, "objectAtIndex:", v30);
            v16 = TSUDynamicCast();
            if (v16)
            {
              v17 = (TSTStrokeRunArray *)v16;
              TSTStrokeRunArrayWriteLock(v16);
              v18 = (unsigned int *)TSTMasterLayoutGetDefaultStrokesForGridRow(a1, v15, 0);
              TSTStrokeRunArrayResetRange(v17, v18, BYTE2(a2), v9 + 1);
              TSTStrokeRunArrayUnlock((uint64_t)v17);
              TSTStrokeRunArrayUnlock((uint64_t)v18);
            }
          }
        }
      }
      ++v10;
    }
    while (v7 + 2 != v10);
  }
  if (BYTE2(a2) <= v9 + 1)
  {
    v19 = BYTE2(a2);
    do
    {
      if ((TSTMasterLayoutIsGridColumnHidden(a1, v19) & 1) == 0)
      {
        if (v19 <= v9)
        {
          v30 = v19;
          if (TSTMasterLayoutStrokeAdjustGridColumnForVisibility(a1, 1, &v30))
          {
            objc_opt_class();
            v20 = v30;
            -[NSMutableArray objectAtIndex:](a1->mLeftColumnStrokes, "objectAtIndex:", v30);
            v21 = TSUDynamicCast();
            if (v21)
            {
              v22 = (TSTStrokeRunArray *)v21;
              TSTStrokeRunArrayWriteLock(v21);
              DefaultStrokesForGridColumn = (unsigned int *)TSTMasterLayoutGetDefaultStrokesForGridColumn(a1, v20, 1);
              TSTStrokeRunArrayResetRange(v22, DefaultStrokesForGridColumn, v6, v29);
              TSTStrokeRunArrayUnlock((uint64_t)v22);
              TSTStrokeRunArrayUnlock((uint64_t)DefaultStrokesForGridColumn);
            }
          }
        }
        if (v19 > v8)
        {
          v30 = v19;
          if (TSTMasterLayoutStrokeAdjustGridColumnForVisibility(a1, 0, &v30))
          {
            objc_opt_class();
            v24 = v30;
            -[NSMutableArray objectAtIndex:](a1->mRightColumnStrokes, "objectAtIndex:", v30);
            v25 = TSUDynamicCast();
            if (v25)
            {
              v26 = (TSTStrokeRunArray *)v25;
              TSTStrokeRunArrayWriteLock(v25);
              v27 = (unsigned int *)TSTMasterLayoutGetDefaultStrokesForGridColumn(a1, v24, 0);
              TSTStrokeRunArrayResetRange(v26, v27, v6, v29);
              TSTStrokeRunArrayUnlock((uint64_t)v26);
              TSTStrokeRunArrayUnlock((uint64_t)v27);
            }
          }
        }
      }
      ++v19;
    }
    while (v9 + 2 != v19);
  }
  return -[NSRecursiveLock unlock](a1->mStrokesLock, "unlock");
}

uint64_t TSTMasterLayoutSetRange(_WORD *a1)
{
  uint64_t result;

  a1[84] = objc_msgSend((id)objc_msgSend(a1, "tableModel"), "numberOfHeaderColumns");
  a1[92] = objc_msgSend((id)objc_msgSend(a1, "tableModel"), "numberOfHeaderRows");
  result = objc_msgSend((id)objc_msgSend(a1, "tableModel"), "numberOfFooterRows");
  a1[93] = result;
  return result;
}

uint64_t TSTMasterLayoutGetRange(uint64_t a1)
{
  uint64_t TableNumberOfColumns;

  TableNumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns(a1);
  return (TableNumberOfColumns << 32) | (TSTMasterLayoutGetTableNumberOfRows(a1) << 48);
}

uint64_t TSTMasterLayoutInvalidateStrokeDefaults(uint64_t a1)
{
  uint64_t v2;

  objc_msgSend((id)a1, "invalidateBandedFill");
  objc_msgSend(*(id *)(a1 + 240), "lock");
  v2 = *(_QWORD *)(a1 + 200);
  if (v2)
  {
    TSTTableStrokeDefaultsRelease(v2);
    *(_QWORD *)(a1 + 200) = 0;
  }
  return objc_msgSend(*(id *)(a1 + 240), "unlock");
}

uint64_t TSTMasterLayoutGetTableNumberOfHeaderRows(unsigned __int16 *a1)
{
  if ((objc_msgSend(a1, "emptyFilteredTable") & 1) != 0)
    return 0;
  else
    return a1[92];
}

uint64_t TSTMasterLayoutGetTableNumberOfHeaderColumns(unsigned __int16 *a1)
{
  if ((objc_msgSend(a1, "emptyFilteredTable") & 1) != 0)
    return 0;
  else
    return a1[84];
}

uint64_t TSTMasterLayoutGetTableNumberOfFooterRows(unsigned __int16 *a1)
{
  if ((objc_msgSend(a1, "emptyFilteredTable") & 1) != 0)
    return 0;
  else
    return a1[93];
}

uint64_t TSTMasterLayoutGetTableNumberOfColumns(uint64_t a1)
{
  int64_t v2;
  int v3;
  unsigned int v4;
  void *v5;
  uint64_t v6;

  if ((objc_msgSend((id)a1, "emptyFilteredTable") & 1) != 0)
  {
    LOWORD(v2) = 1;
  }
  else
  {
    v3 = objc_msgSend((id)a1, "isDynamicallyChangingRowOrColumnCount");
    v4 = objc_msgSend((id)objc_msgSend((id)a1, "tableModel"), "numberOfColumns");
    LOWORD(v2) = v4;
    if (v3)
    {
      v2 = *(int *)(a1 + 364) + (unint64_t)v4;
      if (v2 < 1
        || (objc_msgSend((id)a1, "emptyFilteredTable") & 1) == 0
        && v2 <= (unint64_t)*(unsigned __int16 *)(a1 + 168))
      {
        v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSUColumnRowCount TSTMasterLayoutGetTableNumberOfColumns(TSTMasterLayout *)");
        objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 799, CFSTR("Size invariants violated by dynamic add/remove"));
      }
    }
  }
  return (unsigned __int16)v2;
}

uint64_t TSTMasterLayoutGetTableNumberOfRows(uint64_t a1)
{
  int64_t v2;
  int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;

  if ((objc_msgSend((id)a1, "emptyFilteredTable") & 1) != 0)
  {
    LOWORD(v2) = 1;
  }
  else
  {
    v3 = objc_msgSend((id)a1, "isDynamicallyChangingRowOrColumnCount");
    v4 = objc_msgSend((id)objc_msgSend((id)a1, "tableModel"), "numberOfRows");
    LOWORD(v2) = v4;
    if (v3)
    {
      v2 = *(int *)(a1 + 508) + (unint64_t)v4;
      if (v2 < 1
        || ((objc_msgSend((id)a1, "emptyFilteredTable") & 1) == 0 ? (v5 = *(unsigned __int16 *)(a1 + 184)) : (v5 = 0),
            (objc_msgSend((id)a1, "emptyFilteredTable") & 1) == 0 ? (v6 = *(unsigned __int16 *)(a1 + 186)) : (v6 = 0),
            v2 <= (unint64_t)(v6 + v5)))
      {
        v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSUColumnRowCount TSTMasterLayoutGetTableNumberOfRows(TSTMasterLayout *)");
        objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 823, CFSTR("Size invariants violated by dynamic add/remove"));
      }
    }
  }
  return (unsigned __int16)v2;
}

uint64_t TSTMasterLayoutGetHeaderRowsRepeat(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 123);
}

double TSTMasterLayoutHeightOfRow(TSTMasterLayout *a1, uint64_t a2, char a3, char *a4, int a5, int a6)
{
  TSTTableModel *v12;
  double v13;
  int v14;
  double v15;
  TSTLayoutDynamicRowSwapProtocol *mDynamicRowSwapDelegate;
  double v17;
  double v18;
  _BOOL4 v19;
  int TableNumberOfRows;
  int mCachedNumberOfFooterRows;
  int v22;
  int v23;
  double mDynamicAddOrRemoveRowElementSize;
  char v25;
  _BOOL4 v27;
  double v28;
  TSTTableInfo *v29;
  double v30;
  double v31;
  double v33;
  double v34;
  BOOL v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  unsigned int mCachedNumberOfHeaderRows;
  int v44;
  char v46;

  v12 = -[TSTMasterLayout tableModel](a1, "tableModel");
  v13 = TSTTableDefaultRowHeight((uint64_t)v12);
  v14 = -[TSTMasterLayout tableRowsBehavior](a1, "tableRowsBehavior");
  if (a6)
  {
    v15 = 0.0;
    if (-[TSTHiddenRowsColumnsCache isRowHidden:](-[TSTMasterLayout hiddenRowsColumnsCache](a1, "hiddenRowsColumnsCache"), "isRowHidden:", a2))
    {
      return v15;
    }
  }
  if ((a3 & 1) == 0)
  {
    mDynamicRowSwapDelegate = a1->mDynamicRowSwapDelegate;
    if (mDynamicRowSwapDelegate)
      a2 = -[TSTLayoutDynamicRowSwapProtocol rowForRowID:](mDynamicRowSwapDelegate, "rowForRowID:", a2);
  }
  v17 = TSTMasterLayoutStrokeHeightOfGridRow(a1, a2, 0, 0xFFFFFFFF) * 0.5;
  v18 = TSTMasterLayoutStrokeHeightOfGridRow(a1, (int)a2 + 1, 0, 0xFFFFFFFF) * 0.5;
  v19 = -[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable");
  if (!(_DWORD)a2 && v19)
  {
    if (a4)
      *a4 = 1;
    return v18 + v17 + a1->mTableDefaultFontHeightForArea[0];
  }
  if (!-[TSTMasterLayout isDynamicallyChangingRowOrColumnCount](a1, "isDynamicallyChangingRowOrColumnCount")
    || !a1->mDynamicResizingRows
    || ((TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1),
         !-[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable"))
      ? (mCachedNumberOfFooterRows = a1->mCachedNumberOfFooterRows)
      : (mCachedNumberOfFooterRows = 0),
        TableNumberOfRows - mCachedNumberOfFooterRows - a1->mDynamicRowAdjustment > (int)a2
     || ((v22 = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1),
          !-[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable"))
       ? (v23 = a1->mCachedNumberOfFooterRows)
       : (v23 = 0),
         v22 - v23 <= (int)a2)))
  {
    v29 = -[TSTMasterLayout tableInfo](a1, "tableInfo");
    v46 = 0;
    -[TSTWidthHeightCache getModelHeightForRow:](-[TSTMasterLayout widthHeightCache](a1, "widthHeightCache"), "getModelHeightForRow:", a2);
    if (v30 == 0.0)
    {
      v31 = TSTTableHeightOfRow((uint64_t)v12, a2, &v46);
      if (v14 != 3 || v46 == 0)
        v33 = v31;
      else
        v33 = -1.0;
      -[TSTWidthHeightCache setModelHeight:forRow:](-[TSTMasterLayout widthHeightCache](a1, "widthHeightCache", v31), "setModelHeight:forRow:", a2, v33);
    }
    else
    {
      v33 = -1.0;
      if (v30 == -1.0)
        v46 = 1;
      else
        v33 = v30;
    }
    -[TSTWidthHeightCache getFitHeightForRow:](-[TSTMasterLayout widthHeightCache](a1, "widthHeightCache"), "getFitHeightForRow:", a2);
    if (v14 == 1)
    {
      if (v34 == 0.0)
        TSTTableComputeDefaultFontHeight(v12, 0);
      v27 = v33 == v13;
      if (v34 >= v33 - (v17 + v18))
      {
        v27 = 1;
        v35 = 1;
        mDynamicAddOrRemoveRowElementSize = v34;
LABEL_55:
        v25 = vabdd_f64(v18 + v17 + v34, v33) < 0.01 || v35;
        if (-[TSTMasterLayout isDynamicallyResizing:rowColIndex:](a1, "isDynamicallyResizing:rowColIndex:", 0, a2))
          mDynamicAddOrRemoveRowElementSize = mDynamicAddOrRemoveRowElementSize + a1->mDynamicResizingRowAdjustment;
        v28 = 1.0;
        if (-[TSTTableInfo partitioner](v29, "partitioner")
          && -[TSTTablePartitioner scaleIsValid](-[TSTTableInfo partitioner](v29, "partitioner"), "scaleIsValid"))
        {
          -[TSTTablePartitioner scaleToFit](-[TSTTableInfo partitioner](v29, "partitioner"), "scaleToFit");
          v28 = v36;
        }
        goto LABEL_63;
      }
    }
    else
    {
      if (v14 == 3)
      {
        v27 = v33 == -1.0;
        if (v33 == -1.0)
          mDynamicAddOrRemoveRowElementSize = v34;
        else
          mDynamicAddOrRemoveRowElementSize = v33;
        v35 = v33 == -1.0;
        goto LABEL_55;
      }
      if (v34 == 0.0)
        TSTTableComputeDefaultFontHeight(v12, 0);
      v27 = 0;
    }
    v35 = 0;
    mDynamicAddOrRemoveRowElementSize = v33;
    goto LABEL_55;
  }
  mDynamicAddOrRemoveRowElementSize = a1->mDynamicAddOrRemoveRowElementSize;
  if (-[TSTMasterLayout isDynamicallyResizing:rowColIndex:](a1, "isDynamicallyResizing:rowColIndex:", 0, a2))
    mDynamicAddOrRemoveRowElementSize = mDynamicAddOrRemoveRowElementSize + a1->mDynamicResizingRowAdjustment;
  v25 = 0;
  v27 = mDynamicAddOrRemoveRowElementSize == v13 && v14 != 2;
  v28 = 1.0;
LABEL_63:
  v37 = v17 + v18;
  if ((a5 & v27) == 0)
    v37 = -0.0;
  v38 = mDynamicAddOrRemoveRowElementSize + v37;
  if (a4)
    *a4 = v25;
  v15 = v38 * v28;
  -[TSTMasterLayout maximumPartitionSize](a1, "maximumPartitionSize");
  if (v40 != *MEMORY[0x24BDBF148] || v39 != *(double *)(MEMORY[0x24BDBF148] + 8))
  {
    -[TSTMasterLayout maximumPartitionSize](a1, "maximumPartitionSize");
    v42 = v41;
    if (!-[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable") && a1->mHeaderRowsRepeat)
    {
      mCachedNumberOfHeaderRows = a1->mCachedNumberOfHeaderRows;
      if (mCachedNumberOfHeaderRows <= a2)
      {
        if (a1->mCachedNumberOfHeaderRows)
        {
          v44 = 0;
          do
            v42 = v42 - TSTMasterLayoutHeightOfRow(a1, (unsigned __int16)v44++, 0, 0, 1, 1);
          while (mCachedNumberOfHeaderRows > (unsigned __int16)v44);
        }
      }
    }
    if (v42 <= v15)
      return v42;
  }
  return v15;
}

double TSTMasterLayoutWidthOfColumn(uint64_t a1, uint64_t a2, char a3, _BYTE *a4, int a5)
{
  void *v10;
  uint64_t v11;
  int v12;
  unsigned __int8 v13;
  double v14;
  void *v15;
  double v16;
  double v17;
  double v18;
  double v19;
  char v21;
  char v22;

  v22 = 0;
  v10 = (void *)objc_msgSend((id)a1, "tableInfo");
  v11 = objc_msgSend((id)a1, "tableModel");
  v12 = objc_msgSend((id)a1, "emptyFilteredTable");
  if (!(_DWORD)a2 && v12)
  {
    if (!objc_msgSend((id)objc_msgSend((id)a1, "tableModel"), "numberOfColumns"))
      return 0.0;
    v13 = 0;
    v14 = 0.0;
    do
    {
      v21 = 0;
      if (!TSTTableIsColumnHidden(objc_msgSend((id)a1, "tableModel"), v13))
        v14 = v14 + TSTTableWidthOfColumn(objc_msgSend((id)a1, "tableModel"), v13, &v21);
      ++v13;
    }
    while (objc_msgSend((id)objc_msgSend((id)a1, "tableModel"), "numberOfColumns") > v13);
    return v14;
  }
  if (a5)
  {
    v14 = 0.0;
    if ((objc_msgSend((id)objc_msgSend((id)a1, "hiddenRowsColumnsCache"), "isColumnHidden:", a2) & 1) != 0)
      return v14;
  }
  if ((a3 & 1) == 0)
  {
    v15 = *(void **)(a1 + 368);
    if (v15)
      a2 = objc_msgSend(v15, "columnForColumnID:", a2);
  }
  if (!objc_msgSend((id)a1, "isDynamicallyChangingRowOrColumnCount")
    || !*(_BYTE *)(a1 + 450)
    || (int)(TSTMasterLayoutGetTableNumberOfColumns(a1) - *(_DWORD *)(a1 + 364)) > (int)a2)
  {
    objc_msgSend((id)objc_msgSend((id)a1, "widthHeightCache"), "getModelWidthForColumn:", a2);
    v17 = v16;
    if (v16 <= 0.0)
    {
      v17 = TSTTableWidthOfColumn(v11, a2, &v22);
      objc_msgSend((id)objc_msgSend((id)a1, "widthHeightCache"), "setModelWidth:forColumn:", a2, v17);
    }
    if (a4)
      *a4 = 0;
    if (!objc_msgSend((id)a1, "isDynamicallyResizing:rowColIndex:", 1, a2))
      goto LABEL_23;
    goto LABEL_22;
  }
  v17 = *(double *)(a1 + 344);
  if ((objc_msgSend((id)a1, "isDynamicallyResizing:rowColIndex:", 1, a2) & 1) != 0)
LABEL_22:
    v17 = v17 + *(double *)(a1 + 464);
LABEL_23:
  v18 = 1.0;
  if (objc_msgSend(v10, "partitioner")
    && objc_msgSend((id)objc_msgSend(v10, "partitioner"), "scaleIsValid"))
  {
    objc_msgSend((id)objc_msgSend(v10, "partitioner"), "scaleToFit");
    v18 = v19;
  }
  return v17 * v18;
}

uint64_t TSTMasterLayoutSetHeaderColumnsRepeat(uint64_t result, char a2)
{
  *(_BYTE *)(result + 122) = a2;
  return result;
}

uint64_t TSTMasterLayoutSetHeaderRowsRepeat(uint64_t result, char a2)
{
  *(_BYTE *)(result + 123) = a2;
  return result;
}

uint64_t TSTMasterLayoutSetHeaderColumnsFrozen(uint64_t result, char a2)
{
  *(_BYTE *)(result + 120) = a2;
  return result;
}

uint64_t TSTMasterLayoutSetHeaderRowsFrozen(uint64_t result, char a2)
{
  *(_BYTE *)(result + 121) = a2;
  return result;
}

uint64_t TSTMasterLayoutGetRangeForHint(uint64_t a1, void *a2)
{
  void *v3;
  uint64_t v4;

  if (!a2)
  {
    v3 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v4 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTCellRange TSTMasterLayoutGetRangeForHint(TSTMasterLayout *, TSTLayoutHint *)");
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 553, CFSTR("invalid nil value for '%s'"), "layoutHint");
  }
  return objc_msgSend(a2, "cellRange");
}

uint64_t TSTMasterLayoutGetHeaderColumnsFrozen(_BYTE *a1)
{
  if ((objc_msgSend(a1, "isDynamicallyRepressingFrozenHeaders") & 1) != 0 || !a1[120])
    return 0;
  else
    return objc_msgSend(a1, "dynamicRepResize") ^ 1;
}

uint64_t TSTMasterLayoutGetHeaderRowsFrozen(_BYTE *a1)
{
  if ((objc_msgSend(a1, "isDynamicallyRepressingFrozenHeaders") & 1) != 0 || !a1[121])
    return 0;
  else
    return objc_msgSend(a1, "dynamicRepResize") ^ 1;
}

uint64_t TSTMasterLayoutGetHeaderColumnsRepeat(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 122);
}

uint64_t TSTMasterLayoutSetTableNameEnabled(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 124) != a2)
    *(_BYTE *)(result + 124) = a2;
  return result;
}

uint64_t TSTMasterLayoutGetTableNameEnabled(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 124);
}

uint64_t TSTMasterLayoutGetTableNumberOfNonHiddenFooterRows(_WORD *a1)
{
  __int16 v2;

  if ((objc_msgSend(a1, "emptyFilteredTable") & 1) != 0 || !a1[93])
  {
    return 0;
  }
  else
  {
    v2 = a1[93];
    return (unsigned __int16)(v2
                            - objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "numberRowsHiddenInCellRange:", TSTMasterLayoutGetEntireFooterRowsCellRange(a1)));
  }
}

uint64_t TSTMasterLayoutGetEntireFooterRowsCellRange(unsigned __int16 *a1)
{
  uint64_t v2;
  uint64_t TableNumberOfColumns;

  if ((objc_msgSend(a1, "emptyFilteredTable") & 1) != 0)
    return 0xFFFFFFLL;
  v2 = a1[93];
  if (!a1[93])
    return 0xFFFFFFLL;
  TableNumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  return (v2 << 48) | (TableNumberOfColumns << 32) | (unsigned __int16)(TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1)
                                                                      - v2);
}

uint64_t TSTMasterLayoutGetEntireHeaderColumnsCellRange(unsigned __int16 *a1)
{
  uint64_t v2;

  if ((objc_msgSend(a1, "emptyFilteredTable") & 1) != 0)
    return 0xFFFFFFLL;
  v2 = a1[84];
  if (!a1[84])
    return 0xFFFFFFLL;
  TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  return (v2 << 32) | (TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1) << 48);
}

uint64_t TSTMasterLayoutGetEntireHeaderRowsCellRange(unsigned __int16 *a1)
{
  uint64_t v2;
  uint64_t TableNumberOfColumns;

  if ((objc_msgSend(a1, "emptyFilteredTable") & 1) != 0)
    return 0xFFFFFFLL;
  v2 = a1[92];
  if (!a1[92])
    return 0xFFFFFFLL;
  TableNumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
  return (v2 << 48) | (TableNumberOfColumns << 32);
}

unint64_t TSTMasterLayoutExpandCellRangeToCoverMergedCells(void *a1, unint64_t a2)
{
  if ((objc_msgSend(a1, "emptyFilteredTable") & 1) != 0)
    return a2;
  else
    return TSTTableExpandCellRangeToCoverMergedCells(objc_msgSend(a1, "tableModel"), a2);
}

uint64_t TSTMasterLayoutIsColumnHidden(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "isColumnHidden:", a2);
}

uint64_t TSTMasterLayoutIsRowHidden(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "isRowHidden:", a2);
}

double TSTMasterLayoutStrokeHeightOfGridRow(TSTMasterLayout *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  TSTStrokeRunArray *StrokesForGridRow;
  TSTStrokeRunArray *v9;
  double v10;

  -[NSRecursiveLock lock](a1->mStrokesLock, "lock");
  StrokesForGridRow = TSTMasterLayoutGetStrokesForGridRow(a1, a2, 1, 0);
  v9 = TSTMasterLayoutGetStrokesForGridRow(a1, a2, 0, 0);
  v10 = TSTStrokeRunArrayMaxWidthForMergedHorizontalStrokes(StrokesForGridRow, v9, a3, a4);
  if (StrokesForGridRow)
    TSTStrokeRunArrayUnlock((uint64_t)StrokesForGridRow);
  if (v9)
    TSTStrokeRunArrayUnlock((uint64_t)v9);
  -[NSRecursiveLock unlock](a1->mStrokesLock, "unlock");
  return v10;
}

uint64_t TSTMasterLayoutFittingHeightOfRow(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "widthHeightCache"), "getFitHeightForRow:", a2);
}

double TSTMasterLayoutHeightOfRowIgnoringFitting(TSTMasterLayout *a1, uint64_t a2, unint64_t TableNumberOfRows)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v8;
  int v9;
  TSTLayoutDynamicRowSwapProtocol *mDynamicRowSwapDelegate;
  int v11;
  double v12;
  double v13;
  _BOOL4 v14;
  _BOOL4 v15;
  double v16;
  double mDynamicAddOrRemoveRowElementSize;
  TSTTableInfo *v18;
  double v19;
  unsigned int TableNumberOfColumns;
  uint64_t v21;
  TSTLayoutCellIterator *v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  id v38;
  TSTTextEngineDelegate *v39;
  void *v40;
  double v41;
  double v42;
  void *v43;
  uint64_t v44;
  double v45;
  double v46;
  double v47;
  double v49;
  double v50;
  double v51;
  uint64_t v52;
  uint64_t v53;
  char v54;

  v8 = -[TSTMasterLayout tableModel](a1, "tableModel");
  v9 = -[TSTMasterLayout tableRowsBehavior](a1, "tableRowsBehavior");
  mDynamicRowSwapDelegate = a1->mDynamicRowSwapDelegate;
  if (mDynamicRowSwapDelegate)
    a2 = -[TSTLayoutDynamicRowSwapProtocol rowForRowID:](mDynamicRowSwapDelegate, "rowForRowID:", a2);
  v50 = 0.0;
  v51 = 0.0;
  if ((_DWORD)TableNumberOfRows)
  {
    v50 = TSTMasterLayoutStrokeHeightOfGridRow(a1, a2, 0, 0xFFFFFFFF) * 0.5;
    v51 = TSTMasterLayoutStrokeHeightOfGridRow(a1, (int)a2 + 1, 0, 0xFFFFFFFF) * 0.5;
  }
  if (-[TSTMasterLayout isDynamicallyChangingRowOrColumnCount](a1, "isDynamicallyChangingRowOrColumnCount")
    && a1->mDynamicResizingRows)
  {
    TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
    v11 = -[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable") ? 0 : a1->mCachedNumberOfFooterRows;
    if ((int)TableNumberOfRows - v11 - a1->mDynamicRowAdjustment <= (int)a2)
    {
      mDynamicAddOrRemoveRowElementSize = a1->mDynamicAddOrRemoveRowElementSize;
      v49 = 1.0;
      goto LABEL_55;
    }
  }
  v54 = 0;
  -[TSTWidthHeightCache getModelHeightForRow:](-[TSTMasterLayout widthHeightCache](a1, "widthHeightCache"), "getModelHeightForRow:", a2);
  if (v12 == 0.0)
  {
    v13 = TSTTableHeightOfRow(v8, a2, &v54);
    v14 = v54 != 0;
    v15 = v9 == 3;
    if (v14 && v15)
      v16 = -1.0;
    else
      v16 = v13;
    if (v14 && v15)
      mDynamicAddOrRemoveRowElementSize = 0.0;
    else
      mDynamicAddOrRemoveRowElementSize = v13;
    -[TSTWidthHeightCache setModelHeight:forRow:](-[TSTMasterLayout widthHeightCache](a1, "widthHeightCache", v13), "setModelHeight:forRow:", a2, v16);
  }
  else
  {
    mDynamicAddOrRemoveRowElementSize = v12;
    v16 = -1.0;
    if (v12 == -1.0)
    {
      v54 = 1;
      mDynamicAddOrRemoveRowElementSize = 0.0;
    }
    else
    {
      v16 = v12;
    }
  }
  v18 = -[TSTMasterLayout tableInfo](a1, "tableInfo");
  v49 = 1.0;
  if (-[TSTTableInfo partitioner](v18, "partitioner")
    && -[TSTTablePartitioner scaleIsValid](-[TSTTableInfo partitioner](v18, "partitioner"), "scaleIsValid"))
  {
    -[TSTTablePartitioner scaleToFit](-[TSTTableInfo partitioner](v18, "partitioner"), "scaleToFit");
    v49 = v19;
  }
  if (v16 == -1.0)
  {
    TableNumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
    if (TableNumberOfColumns >= 0xFF)
      v21 = 255;
    else
      v21 = TableNumberOfColumns;
    v22 = -[TSTLayoutCellIterator initWithMasterLayout:range:flags:]([TSTLayoutCellIterator alloc], "initWithMasterLayout:range:flags:", a1, a2 | (unint64_t)(v21 << 32) | 0x1000000000000, 16);
    if (!TSTLayoutCellIteratorGetNextCell((uint64_t)v22, &v52))
    {

      goto LABEL_54;
    }
    mDynamicAddOrRemoveRowElementSize = 0.0;
    while (1)
    {
      v4 = v4 & 0xFFFFFFFF00000000 | HIDWORD(v52);
      -[TSTMasterLayout defaultPaddingForCellID:](a1, "defaultPaddingForCellID:", v4);
      v24 = v23;
      v26 = v25;
      v3 = v3 & 0xFFFFFFFF00000000 | HIDWORD(v52);
      -[TSTMasterLayout paddingForCellID:](a1, "paddingForCellID:", v3);
      v30 = v29;
      v32 = v31;
      v33 = v24 + v26;
      v34 = v29 + v27;
      v35 = v34 <= v33 ? 0.0 : v34 - v33;
      if (!v53)
        break;
      if (*(unsigned __int8 *)(v53 + 9) << 8 != 1536)
      {
        v43 = *(void **)(v53 + 56);
LABEL_42:
        if (objc_msgSend(v43, "isVariation"))
        {
          if (v53)
            v44 = *(_QWORD *)(v53 + 56);
          else
            v44 = 0;
          -[TSTMasterLayout fontHeightOfParagraphStyle:](a1, "fontHeightOfParagraphStyle:", v44);
          v45 = v33 + v46;
        }
        else
        {
          v45 = a1->mTableDefaultFontHeightForArea[0];
        }
        v47 = v51 + v50 + v35 + v45;
        if (mDynamicAddOrRemoveRowElementSize <= v47)
          mDynamicAddOrRemoveRowElementSize = v47;
        goto LABEL_50;
      }
      v36 = v27;
      v37 = v28;
      TableNumberOfRows = TableNumberOfRows & 0xFFFFFFFF00000000 | HIDWORD(v52);
      v38 = -[TSTMasterLayout newTextEngineForCell:atCellID:](a1, "newTextEngineForCell:atCellID:");
      v39 = -[TSTTextEngineDelegate initWithPadding:verticalAlignment:]([TSTTextEngineDelegate alloc], "initWithPadding:verticalAlignment:", 0, v30, v32, v36, v37);
      objc_msgSend(v38, "setDelegate:", v39);
      v40 = (void *)objc_msgSend(v38, "layoutText:kind:minSize:maxSize:anchor:flags:", CFSTR("X"), 5, 15, 8.0, 8.0, 4294967300.0, 4294967300.0, *MEMORY[0x24BDBEFB0], *(double *)(MEMORY[0x24BDBEFB0] + 8));
      objc_msgSend(v38, "setDelegate:", 0);
      objc_msgSend(v40, "typographicBoundsForCell");
      objc_msgSend(v40, "frameBounds");
      if (mDynamicAddOrRemoveRowElementSize <= v51 + v50 + v35 + v33 + v41)
      {
        objc_msgSend(v40, "typographicBoundsForCell");
        objc_msgSend(v40, "frameBounds");
        mDynamicAddOrRemoveRowElementSize = v51 + v50 + v35 + v33 + v42;
      }

LABEL_50:
      if (!TSTLayoutCellIteratorGetNextCell((uint64_t)v22, &v52))
      {

        if (mDynamicAddOrRemoveRowElementSize != 0.0)
          goto LABEL_55;
LABEL_54:
        mDynamicAddOrRemoveRowElementSize = v51 + v50 + a1->mTableDefaultFontHeightForArea[0];
        goto LABEL_55;
      }
    }
    v43 = 0;
    goto LABEL_42;
  }
LABEL_55:
  if (-[TSTMasterLayout isDynamicallyResizing:rowColIndex:](a1, "isDynamicallyResizing:rowColIndex:", 0, a2))
    mDynamicAddOrRemoveRowElementSize = mDynamicAddOrRemoveRowElementSize + a1->mDynamicResizingRowAdjustment;
  return v49 * mDynamicAddOrRemoveRowElementSize;
}

double TSTMasterLayoutSizeOfTextInColumn(void *a1)
{
  double v2;
  double v3;

  objc_msgSend(a1, "typographicBoundsForCell");
  v3 = v2;
  objc_msgSend(a1, "frameBounds");
  return v3;
}

void TSTMasterLayoutFittingWidthForColumnDirect(TSTMasterLayout *a1, uint64_t a2)
{
  double v4;
  double v5;
  double v6;

  -[TSTWidthHeightCache getFitWidthForCol:](-[TSTMasterLayout widthHeightCache](a1, "widthHeightCache"), "getFitWidthForCol:", a2);
  v5 = v4;
  if (v4 == -1.0)
  {
    -[TSTWidthHeightCache resetColWidthsStartingWith:andEndingWith:](-[TSTMasterLayout widthHeightCache](a1, "widthHeightCache"), "resetColWidthsStartingWith:andEndingWith:", a2, a2);
    TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
    -[TSTMasterLayout addChangeDescriptorWithType:andCellRange:](a1, "addChangeDescriptorWithType:andCellRange:", 19, ((unint64_t)a2 << 16) | (TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1) << 48) | 0x100000000);
  }
  if (v5 > 0.0)
  {
    v6 = v5 + TSTMasterLayoutStrokeWidthOfGridColumn(a1, a2, 0, 0xFFFFFFFF) * 0.5;
    ceil(v6 + TSTMasterLayoutStrokeWidthOfGridColumn(a1, (int)a2 + 1, 0, 0xFFFFFFFF) * 0.5);
  }
}

uint64_t TSTMasterLayoutRemoveFittingWidthForColumnRange(void *a1, unsigned __int8 a2, char a3)
{
  return objc_msgSend((id)objc_msgSend(a1, "widthHeightCache"), "resetColWidthsStartingWith:andEndingWith:", a2, (a2 + a3 - 1));
}

double TSTMasterLayoutStrokeWidthOfGridColumn(TSTMasterLayout *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  TSTStrokeRunArray *StrokesForGridColumn;
  TSTStrokeRunArray *v9;
  double v10;

  -[NSRecursiveLock lock](a1->mStrokesLock, "lock");
  StrokesForGridColumn = TSTMasterLayoutGetStrokesForGridColumn(a1, a2, 1, 0);
  v9 = TSTMasterLayoutGetStrokesForGridColumn(a1, a2, 0, 0);
  v10 = TSTStrokeRunArrayMaxWidthForMergedVerticalStrokes(StrokesForGridColumn, v9, a3, a4);
  if (StrokesForGridColumn)
    TSTStrokeRunArrayUnlock((uint64_t)StrokesForGridColumn);
  if (v9)
    TSTStrokeRunArrayUnlock((uint64_t)v9);
  -[NSRecursiveLock unlock](a1->mStrokesLock, "unlock");
  return v10;
}

uint64_t TSTMasterLayoutPurgeFittingWidths(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "widthHeightCache"), "resetAllCol");
}

BOOL TSTMasterLayoutFittingWidthOfColumn(TSTMasterLayout *a1, uint64_t a2, double *a3)
{
  double v4;

  TSTMasterLayoutFittingWidthForColumnDirect(a1, a2);
  if (a3 && v4 > 0.0)
    *a3 = v4;
  return v4 > 0.0;
}

uint64_t TSTMasterLayoutRemoveFittingHeightForRow(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "widthHeightCache"), "resetRowHeightsStartingWith:andEndingWith:", a2, a2);
}

TSTStrokeRunArray *TSTMasterLayoutSetStrokeForGridColumn(TSTMasterLayout *a1, TSDStroke *a2, unsigned int a3, int a4, unsigned int a5, unsigned int a6)
{
  TSTStrokeRunArray *result;
  uint64_t v10;

  result = TSTMasterLayoutGetStrokesForGridColumn(a1, a3, a4, 1);
  if (result)
  {
    v10 = (uint64_t)result;
    TSTStrokeRunArrayInsertCustomStroke(result, a5, a6, a2);
    return (TSTStrokeRunArray *)TSTStrokeRunArrayUnlock(v10);
  }
  return result;
}

TSTStrokeRunArray *TSTMasterLayoutGetStrokesForGridColumn(TSTMasterLayout *a1, unsigned int a2, int a3, int a4)
{
  uint64_t v7;
  void *v8;
  uint64_t v9;
  TSTStrokeRunArray *v10;
  TSTStrokeRunArray *DefaultStrokesForGridColumn;
  unsigned int v13;

  v13 = a2;
  -[NSRecursiveLock lock](a1->mStrokesLock, "lock");
  v7 = 232;
  if (a3)
    v7 = 224;
  v8 = *(Class *)((char *)&a1->super.isa + v7);
  if (TSTMasterLayoutStrokeAdjustGridColumnForVisibility(a1, a3, &v13))
  {
    v9 = v13;
    v10 = (TSTStrokeRunArray *)objc_msgSend(v8, "objectAtIndex:", v13);
    if (v10 == (TSTStrokeRunArray *)objc_msgSend(MEMORY[0x24BDBCEF8], "null"))
    {
      DefaultStrokesForGridColumn = TSTMasterLayoutGetDefaultStrokesForGridColumn(a1, v9, a3);
      v10 = TSTStrokeRunArrayCopy((uint64_t)DefaultStrokesForGridColumn);
      TSTStrokeRunArrayUnlock((uint64_t)DefaultStrokesForGridColumn);
      objc_msgSend(v8, "replaceObjectAtIndex:withObject:", v9, v10);
    }
    if (v10)
    {
      if (a4)
        TSTStrokeRunArrayWriteLock((uint64_t)v10);
      else
        TSTStrokeRunArrayReadLock((uint64_t)v10);
    }
  }
  else
  {
    v10 = 0;
  }
  -[NSRecursiveLock unlock](a1->mStrokesLock, "unlock");
  return v10;
}

uint64_t TSTMasterLayoutStrokeAdjustGridColumnForVisibility(TSTMasterLayout *a1, int a2, unsigned int *a3)
{
  unint64_t v6;
  uint64_t v7;
  void *v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t result;
  char v13;

  v6 = *a3;
  v7 = 232;
  if (a2)
    v7 = 224;
  v8 = *(Class *)((char *)&a1->super.isa + v7);
  if (a2)
  {
    if (objc_msgSend(*(id *)((char *)&a1->super.isa + v7), "count") > v6
      && -[TSTHiddenRowsColumnsCache isColumnHidden:](-[TSTMasterLayout hiddenRowsColumnsCache](a1, "hiddenRowsColumnsCache"), "isColumnHidden:", v6))
    {
      LODWORD(v6) = -[TSTHiddenRowsColumnsCache nextVisibleColumn:](-[TSTMasterLayout hiddenRowsColumnsCache](a1, "hiddenRowsColumnsCache"), "nextVisibleColumn:", v6);
    }
    v9 = 255;
  }
  else
  {
    if (!(_DWORD)v6)
      goto LABEL_13;
    v10 = (v6 - 1);
    if (-[TSTHiddenRowsColumnsCache isColumnHidden:](-[TSTMasterLayout hiddenRowsColumnsCache](a1, "hiddenRowsColumnsCache"), "isColumnHidden:", v10))
    {
      LODWORD(v6) = -[TSTHiddenRowsColumnsCache previousVisibleColumn:](-[TSTMasterLayout hiddenRowsColumnsCache](a1, "hiddenRowsColumnsCache"), "previousVisibleColumn:", v10)+ 1;
    }
    v9 = 256;
  }
  if (v6 >= v9)
    return 0;
LABEL_13:
  v11 = objc_msgSend(v8, "count");
  result = 0;
  v13 = a2 ^ 1;
  if ((_DWORD)v6)
    v13 = 0;
  if ((v13 & 1) == 0 && v11 > v6)
  {
    if (a2 && objc_msgSend(v8, "count") - 1 == v6)
      return 0;
    *a3 = v6;
    return 1;
  }
  return result;
}

TSTStrokeRunArray *TSTMasterLayoutGetDefaultStrokesForGridColumn(TSTMasterLayout *a1, unsigned int a2, int a3)
{
  TSTTableStrokeDefaults *StrokeDefaults;
  int mCachedNumberOfHeaderColumns;
  TSTStrokeRunArray *v8;
  TSTStrokeRunArray *v9;

  StrokeDefaults = TSTMasterLayoutGetStrokeDefaults(a1);
  if (!-[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable")
    && a1->mCachedNumberOfHeaderColumns
    && (!-[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable")
      ? (mCachedNumberOfHeaderColumns = a1->mCachedNumberOfHeaderColumns)
      : (mCachedNumberOfHeaderColumns = 0),
        mCachedNumberOfHeaderColumns == a2))
  {
    v8 = TSTTableStrokeDefaultsForColumn((uint64_t)StrokeDefaults, a3 + a2);
    v9 = v8;
    if ((a3 & 1) == 0)
    {
      TSTStrokeRunArrayWriteLock((uint64_t)v8);
      TSTStrokeRunArraySetEntireCustom((uint64_t)v9);
      TSTStrokeRunArrayUnlock((uint64_t)v9);
    }
  }
  else
  {
    v9 = TSTTableStrokeDefaultsForColumn((uint64_t)StrokeDefaults, a2);
  }
  TSTStrokeRunArrayReadLock((uint64_t)v9);
  return v9;
}

TSTStrokeRunArray *TSTMasterLayoutGetMergedStrokesForGridColumn(TSTMasterLayout *a1, unsigned int a2)
{
  TSTStrokeRunArray *StrokesForGridColumn;
  TSTStrokeRunArray *v5;
  TSTStrokeRunArray *v6;

  -[NSRecursiveLock lock](a1->mStrokesLock, "lock");
  StrokesForGridColumn = TSTMasterLayoutGetStrokesForGridColumn(a1, a2, 1, 0);
  v5 = TSTMasterLayoutGetStrokesForGridColumn(a1, a2, 0, 0);
  v6 = TSTStrokeRunArrayMergeVerticalStrokes(StrokesForGridColumn, v5);
  if (StrokesForGridColumn)
    TSTStrokeRunArrayUnlock((uint64_t)StrokesForGridColumn);
  if (v5)
    TSTStrokeRunArrayUnlock((uint64_t)v5);
  -[NSRecursiveLock unlock](a1->mStrokesLock, "unlock");
  return v6;
}

TSTStrokeRunArray *TSTMasterLayoutSetStrokeForGridRow(TSTMasterLayout *a1, TSDStroke *a2, unsigned int a3, int a4, unsigned int a5, unsigned int a6)
{
  TSTStrokeRunArray *result;
  uint64_t v10;

  result = TSTMasterLayoutGetStrokesForGridRow(a1, a3, a4, 1);
  if (result)
  {
    v10 = (uint64_t)result;
    TSTStrokeRunArrayInsertCustomStroke(result, a5, a6, a2);
    return (TSTStrokeRunArray *)TSTStrokeRunArrayUnlock(v10);
  }
  return result;
}

TSTStrokeRunArray *TSTMasterLayoutGetStrokesForGridRow(TSTMasterLayout *a1, unsigned int a2, int a3, int a4)
{
  uint64_t v7;
  void *v8;
  uint64_t v9;
  TSTStrokeRunArray *v10;
  uint64_t DefaultStrokesForGridRow;
  unsigned int v13;

  v13 = a2;
  -[NSRecursiveLock lock](a1->mStrokesLock, "lock");
  v7 = 216;
  if (a3)
    v7 = 208;
  v8 = *(Class *)((char *)&a1->super.isa + v7);
  if (TSTMasterLayoutStrokeAdjustGridRowForVisibility(a1, a3, &v13))
  {
    v9 = v13;
    v10 = (TSTStrokeRunArray *)objc_msgSend(v8, "objectAtIndex:", v13);
    if (v10 == (TSTStrokeRunArray *)objc_msgSend(MEMORY[0x24BDBCEF8], "null"))
    {
      DefaultStrokesForGridRow = TSTMasterLayoutGetDefaultStrokesForGridRow(a1, v9, a3);
      v10 = TSTStrokeRunArrayCopy(DefaultStrokesForGridRow);
      TSTStrokeRunArrayUnlock(DefaultStrokesForGridRow);
      objc_msgSend(v8, "replaceObjectAtIndex:withObject:", v9, v10);
    }
    if (v10)
    {
      if (a4)
        TSTStrokeRunArrayWriteLock((uint64_t)v10);
      else
        TSTStrokeRunArrayReadLock((uint64_t)v10);
    }
  }
  else
  {
    v10 = 0;
  }
  -[NSRecursiveLock unlock](a1->mStrokesLock, "unlock");
  return v10;
}

uint64_t TSTMasterLayoutStrokeAdjustGridRowForVisibility(TSTMasterLayout *a1, int a2, unsigned int *a3)
{
  unint64_t v6;
  uint64_t v7;
  void *v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t result;
  char v13;

  v6 = *a3;
  v7 = 216;
  if (a2)
    v7 = 208;
  v8 = *(Class *)((char *)&a1->super.isa + v7);
  if (a2)
  {
    if (objc_msgSend(*(id *)((char *)&a1->super.isa + v7), "count") > v6
      && -[TSTHiddenRowsColumnsCache isRowHidden:](-[TSTMasterLayout hiddenRowsColumnsCache](a1, "hiddenRowsColumnsCache"), "isRowHidden:", (unsigned __int16)v6))
    {
      LODWORD(v6) = -[TSTHiddenRowsColumnsCache nextVisibleRow:](-[TSTMasterLayout hiddenRowsColumnsCache](a1, "hiddenRowsColumnsCache"), "nextVisibleRow:", (unsigned __int16)v6);
    }
    v9 = 0xFFFF;
  }
  else
  {
    if (!(_DWORD)v6)
      goto LABEL_13;
    v10 = (unsigned __int16)(v6 - 1);
    if (-[TSTHiddenRowsColumnsCache isRowHidden:](-[TSTMasterLayout hiddenRowsColumnsCache](a1, "hiddenRowsColumnsCache"), "isRowHidden:", v10))
    {
      LODWORD(v6) = -[TSTHiddenRowsColumnsCache previousVisibleRow:](-[TSTMasterLayout hiddenRowsColumnsCache](a1, "hiddenRowsColumnsCache"), "previousVisibleRow:", v10)+ 1;
    }
    v9 = 0x10000;
  }
  if (v6 >= v9)
    return 0;
LABEL_13:
  v11 = objc_msgSend(v8, "count");
  result = 0;
  v13 = a2 ^ 1;
  if ((_DWORD)v6)
    v13 = 0;
  if ((v13 & 1) == 0 && v11 > v6)
  {
    if (a2 && objc_msgSend(v8, "count") - 1 == v6)
      return 0;
    *a3 = v6;
    return 1;
  }
  return result;
}

uint64_t TSTMasterLayoutGetDefaultStrokesForGridRow(TSTMasterLayout *a1, unsigned int a2, int a3)
{
  TSTTableStrokeDefaults *StrokeDefaults;
  int mCachedNumberOfHeaderRows;
  int v8;
  int TableNumberOfRows;
  int v10;
  TSTStrokeRunArray *v11;
  uint64_t v12;

  StrokeDefaults = TSTMasterLayoutGetStrokeDefaults(a1);
  if (-[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable") || !a1->mCachedNumberOfHeaderRows)
  {
    v8 = 0;
  }
  else
  {
    if (-[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable"))
      mCachedNumberOfHeaderRows = 0;
    else
      mCachedNumberOfHeaderRows = a1->mCachedNumberOfHeaderRows;
    if (mCachedNumberOfHeaderRows == a2)
    {
      a2 += a3;
      v8 = a3 ^ 1;
    }
    else
    {
      v8 = 0;
    }
  }
  if (!-[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable") && a1->mCachedNumberOfFooterRows)
  {
    TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
    v10 = -[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable") ? 0 : a1->mCachedNumberOfFooterRows;
    if (a2 == TableNumberOfRows - v10)
      a2 -= a3 ^ 1;
  }
  v11 = TSTTableStrokeDefaultsForRow((uint64_t)StrokeDefaults, a2);
  v12 = (uint64_t)v11;
  if (v8)
  {
    TSTStrokeRunArrayWriteLock((uint64_t)v11);
    TSTStrokeRunArraySetEntireCustom(v12);
    TSTStrokeRunArrayUnlock(v12);
  }
  TSTStrokeRunArrayReadLock(v12);
  return v12;
}

TSTStrokeRunArray *TSTMasterLayoutGetMergedStrokesForGridRow(TSTMasterLayout *a1, unsigned int a2)
{
  TSTStrokeRunArray *StrokesForGridRow;
  TSTStrokeRunArray *v5;
  TSTStrokeRunArray *v6;

  -[NSRecursiveLock lock](a1->mStrokesLock, "lock");
  StrokesForGridRow = TSTMasterLayoutGetStrokesForGridRow(a1, a2, 1, 0);
  v5 = TSTMasterLayoutGetStrokesForGridRow(a1, a2, 0, 0);
  v6 = TSTStrokeRunArrayMergeHorizontalStrokes(StrokesForGridRow, v5);
  if (StrokesForGridRow)
    TSTStrokeRunArrayUnlock((uint64_t)StrokesForGridRow);
  if (v5)
    TSTStrokeRunArrayUnlock((uint64_t)v5);
  -[NSRecursiveLock unlock](a1->mStrokesLock, "unlock");
  return v6;
}

TSTStrokeRunArray *TSTMasterLayoutSetStrokesForCellID(TSTMasterLayout *a1, int a2, TSDStroke *a3, TSDStroke *a4, TSDStroke *a5, TSDStroke *a6)
{
  TSTStrokeRunArray *result;
  TSDStroke *v13;

  result = (TSTStrokeRunArray *)objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  v13 = (TSDStroke *)result;
  if (result != (TSTStrokeRunArray *)a3)
    result = TSTMasterLayoutSetStrokeForGridRow(a1, a3, (unsigned __int16)a2, 1, BYTE2(a2), BYTE2(a2) + 1);
  if (v13 != a4)
    result = TSTMasterLayoutSetStrokeForGridRow(a1, a4, (unsigned __int16)a2 + 1, 0, BYTE2(a2), BYTE2(a2) + 1);
  if (v13 != a6)
    result = TSTMasterLayoutSetStrokeForGridColumn(a1, a6, BYTE2(a2), 1, (unsigned __int16)a2, (unsigned __int16)a2 + 1);
  if (v13 != a5)
    return TSTMasterLayoutSetStrokeForGridColumn(a1, a5, BYTE2(a2) + 1, 0, (unsigned __int16)a2, (unsigned __int16)a2 + 1);
  return result;
}

uint64_t TSTMasterLayoutSetStrokesValidForRange(TSTMasterLayout *a1, unint64_t a2)
{
  unsigned __int8 v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  TSTStrokeRunArray *StrokesForGridRow;
  uint64_t v12;
  TSTStrokeRunArray *v13;
  uint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unsigned int v17;
  unsigned int v18;
  unint64_t v19;
  uint64_t v20;
  TSTStrokeRunArray *StrokesForGridColumn;
  uint64_t v22;
  TSTStrokeRunArray *v23;
  uint64_t v24;
  unint64_t v26;
  unsigned int v27;

  v4 = BYTE2(a2);
  v5 = HIDWORD(a2);
  -[NSRecursiveLock lock](a1->mStrokesLock, "lock");
  v6 = -[NSMutableArray count](a1->mTopRowStrokes, "count");
  v26 = -[NSMutableArray count](a1->mLeftColumnStrokes, "count");
  v7 = BYTE2(a2);
  v8 = (v5 + BYTE2(a2) - 1);
  v9 = HIWORD(a2);
  if (v8 >= v4)
  {
    v10 = 0;
    v27 = v8 + 1;
    do
    {
      if ((TSTMasterLayoutIsGridRowHidden(a1, (unsigned __int16)a2 + v10) & 1) == 0
        && v6 > (unsigned __int16)a2 + v10)
      {
        if (v10 < v9)
        {
          StrokesForGridRow = TSTMasterLayoutGetStrokesForGridRow(a1, (unsigned __int16)a2 + v10, 1, 1);
          if (StrokesForGridRow)
          {
            v12 = (uint64_t)StrokesForGridRow;
            TSTStrokeRunArraySetValid((uint64_t)StrokesForGridRow, BYTE2(a2), v27);
            TSTStrokeRunArrayUnlock(v12);
          }
        }
        if (v10)
        {
          v13 = TSTMasterLayoutGetStrokesForGridRow(a1, (unsigned __int16)a2 + v10, 0, 1);
          if (v13)
          {
            v14 = (uint64_t)v13;
            TSTStrokeRunArraySetValid((uint64_t)v13, BYTE2(a2), v27);
            TSTStrokeRunArrayUnlock(v14);
          }
        }
      }
      ++v10;
    }
    while (v9 + 1 != v10);
  }
  v15 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
  if (v15 >= (unsigned __int16)a2)
  {
    v16 = 0;
    v17 = (unsigned __int16)a2;
    v18 = v15 + 1;
    v19 = WORD2(a2);
    v20 = WORD2(a2) + 1;
    do
    {
      if ((TSTMasterLayoutIsGridColumnHidden(a1, (int)v7 + (int)v16) & 1) == 0 && v26 > v7 + v16)
      {
        if (v16 < v19)
        {
          StrokesForGridColumn = TSTMasterLayoutGetStrokesForGridColumn(a1, (int)v7 + (int)v16, 1, 1);
          if (StrokesForGridColumn)
          {
            v22 = (uint64_t)StrokesForGridColumn;
            TSTStrokeRunArraySetValid((uint64_t)StrokesForGridColumn, v17, v18);
            TSTStrokeRunArrayUnlock(v22);
          }
        }
        if (v16)
        {
          v23 = TSTMasterLayoutGetStrokesForGridColumn(a1, (int)v7 + (int)v16, 0, 1);
          if (v23)
          {
            v24 = (uint64_t)v23;
            TSTStrokeRunArraySetValid((uint64_t)v23, v17, v18);
            TSTStrokeRunArrayUnlock(v24);
          }
        }
      }
      ++v16;
    }
    while (v20 != v16);
  }
  return -[NSRecursiveLock unlock](a1->mStrokesLock, "unlock");
}

uint64_t TSTMasterLayoutIsGridRowHidden(void *a1, unsigned int a2)
{
  __int16 TableNumberOfRows;
  int v5;
  int v6;

  TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
  if (a2)
    v5 = objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "isRowHidden:", (unsigned __int16)(a2 - 1));
  else
    v5 = 1;
  if (a2 <= (unsigned __int16)(TableNumberOfRows - 1))
    v6 = objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "isRowHidden:", (unsigned __int16)a2);
  else
    v6 = 1;
  return v5 & v6;
}

uint64_t TSTMasterLayoutIsGridColumnHidden(void *a1, unsigned int a2)
{
  char TableNumberOfColumns;
  int v5;
  int v6;

  TableNumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
  if (a2)
    v5 = objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "isColumnHidden:", (a2 - 1));
  else
    v5 = 1;
  if (a2 <= (TableNumberOfColumns - 1))
    v6 = objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "isColumnHidden:", a2);
  else
    v6 = 1;
  return v5 & v6;
}

TSTMasterLayout *TSTMasterLayoutGetStrokesForCellID(TSTMasterLayout *result, int a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  TSTMasterLayout *v10;
  unsigned int *MergedStrokesForGridRow;
  unsigned int *v13;
  unsigned int *v14;
  unsigned int *v15;
  unsigned int *MergedStrokesForGridColumn;
  unsigned int *v17;
  unsigned int *v18;
  unsigned int *v19;

  v10 = result;
  if (a3)
  {
    MergedStrokesForGridRow = (unsigned int *)TSTMasterLayoutGetMergedStrokesForGridRow(result, (unsigned __int16)a2);
    v13 = TSTStrokeRunArrayLookupStroke(MergedStrokesForGridRow, BYTE2(a2));
    if (v13)
      *a3 = *((id *)v13 + 1);
    result = (TSTMasterLayout *)TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridRow);
  }
  if (a5)
  {
    v14 = (unsigned int *)TSTMasterLayoutGetMergedStrokesForGridRow(v10, (unsigned __int16)a2 + 1);
    v15 = TSTStrokeRunArrayLookupStroke(v14, BYTE2(a2));
    if (v15)
      *a5 = *((id *)v15 + 1);
    result = (TSTMasterLayout *)TSTStrokeRunArrayUnlock((uint64_t)v14);
  }
  if (a4)
  {
    MergedStrokesForGridColumn = (unsigned int *)TSTMasterLayoutGetMergedStrokesForGridColumn(v10, BYTE2(a2));
    v17 = TSTStrokeRunArrayLookupStroke(MergedStrokesForGridColumn, (unsigned __int16)a2);
    if (v17)
      *a4 = *((id *)v17 + 1);
    result = (TSTMasterLayout *)TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridColumn);
  }
  if (a6)
  {
    v18 = (unsigned int *)TSTMasterLayoutGetMergedStrokesForGridColumn(v10, BYTE2(a2) + 1);
    v19 = TSTStrokeRunArrayLookupStroke(v18, (unsigned __int16)a2);
    if (v19)
      *a6 = *((id *)v19 + 1);
    return (TSTMasterLayout *)TSTStrokeRunArrayUnlock((uint64_t)v18);
  }
  return result;
}

uint64_t TSTMasterLayoutGetStrokesForCellRange(TSTMasterLayout *a1, unint64_t a2, id *a3, id *a4, id *a5, id *a6)
{
  uint64_t result;
  int v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  id v30;
  id v31;
  id v32;
  id v33;

  if (HIDWORD(a2) == 65537 && (unsigned __int16)a2 != 0xFFFFLL && (a2 & 0xFF0000) != 0xFF0000)
    return (uint64_t)TSTMasterLayoutGetStrokesForCellID(a1, a2, a3, a4, a5, a6);
  v32 = 0;
  v33 = 0;
  v30 = 0;
  v31 = 0;
  TSTMasterLayoutGetStrokesForCellID(a1, a2 & 0xFFFFFF, a3, a4, 0, 0);
  v13 = (a2 + ((a2 >> 16) & 0xFF0000) + 16711680) & 0xFF0000;
  result = (uint64_t)TSTMasterLayoutGetStrokesForCellID(a1, v13 | (unsigned __int16)(a2 + HIWORD(a2) - 1), 0, 0, a5, a6);
  if ((unint64_t)a3 | (unint64_t)a6)
    result = (uint64_t)TSTMasterLayoutGetStrokesForCellID(a1, v13 | (unsigned __int16)a2, &v33, 0, 0, &v30);
  if ((unint64_t)a4 | (unint64_t)a5)
    result = (uint64_t)TSTMasterLayoutGetStrokesForCellID(a1, (unsigned __int16)(a2 + HIWORD(a2) - 1) | a2 & 0xFF0000, 0, &v32, &v31, 0);
  if (a3 && v33)
  {
    v14 = 0.0;
    v15 = 0.0;
    if (*a3 && (objc_msgSend(*a3, "empty") & 1) == 0)
    {
      objc_msgSend(*a3, "width");
      v15 = v16;
    }
    result = objc_msgSend(v33, "empty", v30);
    if ((result & 1) == 0)
    {
      result = objc_msgSend(v33, "width");
      v14 = v17;
    }
    if (v15 < v14)
      *a3 = v33;
  }
  if (a4 && v32)
  {
    v18 = 0.0;
    v19 = 0.0;
    if (*a4 && (objc_msgSend(*a4, "empty") & 1) == 0)
    {
      objc_msgSend(*a4, "width");
      v19 = v20;
    }
    result = objc_msgSend(v32, "empty", v30);
    if ((result & 1) == 0)
    {
      result = objc_msgSend(v32, "width");
      v18 = v21;
    }
    if (v19 < v18)
      *a4 = v32;
  }
  if (a5 && v31)
  {
    v22 = 0.0;
    v23 = 0.0;
    if (*a5 && (objc_msgSend(*a5, "empty") & 1) == 0)
    {
      objc_msgSend(*a5, "width");
      v23 = v24;
    }
    result = objc_msgSend(v31, "empty", v30);
    if ((result & 1) == 0)
    {
      result = objc_msgSend(v31, "width");
      v22 = v25;
    }
    if (v23 < v22)
      *a5 = v31;
  }
  if (a6 && v30)
  {
    v26 = 0.0;
    v27 = 0.0;
    if (*a6 && (objc_msgSend(*a6, "empty") & 1) == 0)
    {
      objc_msgSend(*a6, "width");
      v27 = v28;
    }
    result = objc_msgSend(v30, "empty", v30);
    if ((result & 1) == 0)
    {
      result = objc_msgSend(v30, "width");
      v26 = v29;
    }
    if (v27 < v26)
      *a6 = v30;
  }
  return result;
}

double TSTMasterLayoutContentSizeForCellRange(TSTMasterLayout *a1, unint64_t a2, char a3)
{
  double v6;

  v6 = 0.0;
  if ((a2 & 0xFFFF00000000) != 0)
    v6 = TSTMasterLayoutContentWidthForCellRange(a1, a2, a3);
  if (HIWORD(a2))
    TSTMasterLayoutContentHeightForCellRange(a1, a2, a3);
  return v6;
}

double TSTMasterLayoutContentWidthForCellRange(TSTMasterLayout *a1, unint64_t a2, char a3)
{
  unsigned int v5;
  double v6;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  double v11;
  unsigned int TableNumberOfColumns;

  v5 = HIDWORD(a2) + WORD1(a2) + 255;
  v6 = 0.0;
  if (BYTE2(a2) <= (BYTE4(a2) + BYTE2(a2) - 1))
  {
    v8 = a2 >> 16;
    do
    {
      v6 = v6 + TSTMasterLayoutWidthOfColumn((uint64_t)a1, v8, a3, 0, 1);
      LODWORD(v8) = v8 + 1;
    }
    while (v8 <= v5);
  }
  v9 = (unsigned __int16)a2;
  v10 = (unsigned __int16)(a2 + HIWORD(a2) - 1) + 1;
  v11 = TSTMasterLayoutStrokeWidthOfGridColumn(a1, BYTE2(a2), (unsigned __int16)a2, v10);
  TableNumberOfColumns = v5 + 1;
  if (TableNumberOfColumns >= TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1))
    TableNumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  return fmax(v6 - v11 * 0.5 - TSTMasterLayoutStrokeWidthOfGridColumn(a1, TableNumberOfColumns, v9, v10) * 0.5, 0.0);
}

double TSTMasterLayoutContentHeightForCellRange(TSTMasterLayout *a1, unint64_t a2, char a3)
{
  int v5;
  unsigned int v6;
  double v7;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  double v13;
  unsigned int TableNumberOfRows;

  v5 = a2 + HIWORD(a2) - 1;
  v6 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
  v7 = 0.0;
  if (v6 >= (unsigned __int16)a2)
  {
    v9 = a2;
    do
      v7 = v7 + TSTMasterLayoutHeightOfRow(a1, (unsigned __int16)v9++, a3, 0, 1, 1);
    while ((unsigned __int16)v9 <= (unsigned __int16)v5);
  }
  v10 = BYTE2(a2);
  if (BYTE2(a2) <= (BYTE4(a2) + BYTE2(a2) - 1))
    v11 = (BYTE4(a2) + BYTE2(a2) - 1);
  else
    v11 = BYTE2(a2);
  v12 = v11 + 1;
  v13 = TSTMasterLayoutStrokeHeightOfGridRow(a1, (unsigned __int16)a2, BYTE2(a2), v11 + 1);
  TableNumberOfRows = v6 + 1;
  if (v6 + 1 >= TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1))
    TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
  return fmax(v7 - v13 * 0.5 - TSTMasterLayoutStrokeHeightOfGridRow(a1, TableNumberOfRows, v10, v12) * 0.5, 0.0);
}

uint64_t TSTMasterLayoutUpdateStrokesForCell(TSTMasterLayout *a1, uint64_t a2, unsigned int a3)
{
  unsigned int v7;
  uint64_t result;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  __int16 v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  __int16 v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  TSDStroke *v23;
  TSDStroke *v24;
  TSDStroke *v25;
  TSDStroke *v26;

  v7 = -[TSTMasterLayout modelCellIDForStrokesOfLayoutCellID:](a1, "modelCellIDForStrokesOfLayoutCellID:", a3);
  result = -[TSTHiddenRowsColumnsCache isRowHidden:](-[TSTMasterLayout hiddenRowsColumnsCache](a1, "hiddenRowsColumnsCache"), "isRowHidden:", (unsigned __int16)a3);
  if ((result & 1) == 0)
  {
    result = -[TSTHiddenRowsColumnsCache isColumnHidden:](-[TSTMasterLayout hiddenRowsColumnsCache](a1, "hiddenRowsColumnsCache"), "isColumnHidden:", BYTE2(a3));
    if ((result & 1) == 0)
    {
      v25 = 0;
      v26 = 0;
      v23 = 0;
      v24 = 0;
      v9 = TSTTableMergeRangeAtCellID((uint64_t)-[TSTMasterLayout tableModel](a1, "tableModel"), v7);
      if (!-[TSTMasterLayout isDynamicallyChangingRowCount](a1, "isDynamicallyChangingRowCount"))
        goto LABEL_36;
      v10 = -[TSTTableModel bodyRowRange](-[TSTMasterLayout tableModel](a1, "tableModel"), "bodyRowRange");
      if (!HIWORD(v10))
        goto LABEL_36;
      if ((v10 & 0xFFFF00000000) == 0)
        goto LABEL_36;
      if (!HIWORD(v9))
        goto LABEL_36;
      if ((v9 & 0xFFFF00000000) == 0)
        goto LABEL_36;
      if ((unsigned __int16)v10 > (unsigned __int16)v9)
        goto LABEL_36;
      if ((unsigned __int16)(v10 + HIWORD(v10) - 1) < (unsigned __int16)v9)
        goto LABEL_36;
      if (BYTE2(v10) > BYTE2(v9))
        goto LABEL_36;
      v11 = (BYTE4(v10) + BYTE2(v10) - 1);
      if (v11 < BYTE2(v9)
        || v11 < (BYTE4(v9) + BYTE2(v9) - 1)
        || (unsigned __int16)(v10 + HIWORD(v10) - 1) < (unsigned __int16)(v9 + HIWORD(v9) - 1))
      {
        goto LABEL_36;
      }
      v12 = -[TSTTableModel bodyRowRange](-[TSTMasterLayout tableModel](a1, "tableModel"), "bodyRowRange");
      v13 = -[TSTMasterLayout dynamicRowAdjustment](a1, "dynamicRowAdjustment");
      v14 = 0;
      v15 = 16711680;
      v16 = 0xFFFFLL;
      if ((_WORD)v9 != 0xFFFF)
      {
        v17 = 0;
        if ((v9 & 0xFF0000) == 0xFF0000)
          goto LABEL_35;
        v14 = 0;
        v15 = 16711680;
        v16 = 0xFFFFLL;
        if ((_WORD)v12 != 0xFFFF)
        {
          v17 = 0;
          if ((v12 & 0xFF0000) != 0xFF0000)
          {
            v14 = 0;
            v15 = 16711680;
            v16 = 0xFFFFLL;
            if ((v12 & 0xFFFF00000000) != 0)
            {
              v18 = v13 + HIWORD(v12);
              v17 = 0;
              if (v13 + HIWORD(v12))
              {
                v16 = 0;
                v19 = BYTE2(v12);
                if (BYTE2(v9) > BYTE2(v12))
                  v19 = BYTE2(v9);
                if ((unsigned __int16)v9 <= (unsigned __int16)v12)
                  v20 = (unsigned __int16)v12;
                else
                  v20 = (unsigned __int16)v9;
                if ((BYTE4(v9) + BYTE2(v9) - 1) >= (BYTE4(v12) + BYTE2(v12) - 1))
                  v21 = (BYTE4(v12) + BYTE2(v12) - 1);
                else
                  v21 = (BYTE4(v9) + BYTE2(v9) - 1);
                if ((unsigned __int16)(v9 + HIWORD(v9) - 1) >= (unsigned __int16)(v12 + v18 - 1))
                  v22 = (unsigned __int16)(v12 + v18 - 1);
                else
                  v22 = (unsigned __int16)(v9 + HIWORD(v9) - 1);
                v15 = 0;
                v14 = 0;
                v17 = 0;
                if (v20 <= v22 && v19 <= v21)
                {
                  v17 = ((unint64_t)(v22 - v20) << 48) + 0x1000000000000;
                  v14 = (unint64_t)(unsigned __int16)(v21 - v19 + 1) << 32;
                  v15 = v19 << 16;
                  v16 = v20;
                }
              }
              goto LABEL_35;
            }
            goto LABEL_34;
          }
LABEL_35:
          v9 = v15 | v17 | v16 | v14;
LABEL_36:
          TSTTableGetStrokesForCellIDWithMergeRange((uint64_t)-[TSTMasterLayout tableModel](a1, "tableModel"), v7, v9, (uint64_t *)&v26, (uint64_t *)&v24, (uint64_t *)&v25, (uint64_t *)&v23, a2);
          return (uint64_t)TSTMasterLayoutSetStrokesForCellID(a1, a3, v26, v25, v23, v24);
        }
      }
LABEL_34:
      v17 = 0;
      goto LABEL_35;
    }
  }
  return result;
}

uint64_t TSTMasterLayoutPreviousVisibleRow(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "previousVisibleRow:", a2);
}

uint64_t TSTMasterLayoutPreviousVisibleColumn(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "previousVisibleColumn:", a2);
}

uint64_t TSTMasterLayoutMergeRangeAtCellID(void *a1, unsigned int a2)
{
  uint64_t v5;

  v5 = 0xFFFFFFLL;
  if (objc_msgSend(a1, "dynamicContentDelegate")
    && (objc_msgSend(a1, "dynamicContentDelegate"), (objc_opt_respondsToSelector() & 1) != 0)
    && objc_msgSend((id)objc_msgSend(a1, "dynamicContentDelegate"), "mergeRange:forCellID:", &v5, a2))
  {
    return v5;
  }
  else
  {
    return TSTTableMergeRangeAtCellID(objc_msgSend(a1, "tableModel"), a2);
  }
}

uint64_t TSTMasterLayoutIsRowHiddenWorker(void *a1, uint64_t a2)
{
  char v4;
  uint64_t result;
  char v6;

  v4 = objc_msgSend(a1, "isDynamicallyRevealingRowsCols:rowColIndex:", 0, a2);
  result = 0;
  if ((v4 & 1) == 0)
  {
    if ((objc_msgSend(a1, "isDynamicallyHidingRowsCols:rowColIndex:", 0, a2) & 1) != 0)
    {
      return 1;
    }
    else
    {
      v6 = objc_msgSend(a1, "emptyFilteredTable");
      if (!(_DWORD)a2 && (v6 & 1) != 0 || (objc_msgSend(a1, "processHiddenRowsForExport") & 1) != 0)
        return 0;
      else
        return TSTHidingActionForRow(objc_msgSend(a1, "tableModel"), a2);
    }
  }
  return result;
}

uint64_t TSTMasterLayoutIsRowUserHidden(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "isRowUserHidden:", a2);
}

uint64_t TSTMasterLayoutIsColumnHiddenWorker(void *a1, uint64_t a2)
{
  uint64_t v4;

  if ((objc_msgSend(a1, "isDynamicallyRevealingRowsCols:rowColIndex:", 1, a2) & 1) != 0)
    return 0;
  v4 = 1;
  if ((objc_msgSend(a1, "isDynamicallyHidingRowsCols:rowColIndex:", 1, a2) & 1) != 0)
    return v4;
  return TSTHidingActionForColumn(objc_msgSend(a1, "tableModel"), a2);
}

BOOL TSTMasterLayoutIsEntireCellRangeHidden(void *a1, unint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "numberRowsHiddenInCellRange:", a2) == HIWORD(a2)
      || objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "numberColumnsHiddenInCellRange:", a2) == WORD2(a2);
}

uint64_t TSTMasterLayoutIsAnyPartOfCellRangeHidden(void *a1, unint64_t a2)
{
  uint64_t result;

  result = 0;
  if ((_WORD)a2 != 0xFFFF && (a2 & 0xFF0000) != 0xFF0000)
  {
    result = 0;
    if (HIWORD(a2))
    {
      if ((a2 & 0xFFFF00000000) != 0)
      {
        if ((objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "anyRowsHiddenInCellRange:", a2) & 1) != 0)
          return 1;
        else
          return objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "anyColumnsHiddenInCellRange:", a2);
      }
    }
  }
  return result;
}

uint64_t TSTMasterLayoutIsRowHiddenInCellRange(void *a1, unint64_t a2)
{
  if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000 || !HIWORD(a2) || (a2 & 0xFFFF00000000) == 0)
    return 0;
  else
    return objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "anyRowsHiddenInCellRange:", a2);
}

uint64_t TSTMasterLayoutIsRowUserHiddenInCellRange(void *a1, unint64_t a2)
{
  if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000 || !HIWORD(a2) || (a2 & 0xFFFF00000000) == 0)
    return 0;
  else
    return objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "anyRowsUserHiddenInCellRange:", a2);
}

uint64_t TSTMasterLayoutIsColumnHiddenInCellRange(void *a1, unint64_t a2)
{
  if ((_WORD)a2 == 0xFFFF || (a2 & 0xFF0000) == 0xFF0000 || !HIWORD(a2) || (a2 & 0xFFFF00000000) == 0)
    return 0;
  else
    return objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "anyColumnsHiddenInCellRange:", a2);
}

uint64_t TSTMasterLayoutNextVisibleRow(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "nextVisibleRow:", a2);
}

uint64_t TSTMasterLayoutNextVisibleColumn(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "hiddenRowsColumnsCache"), "nextVisibleColumn:", a2);
}

double TSTMasterLayoutDynamicResizeSave(uint64_t a1, _BYTE *a2, _QWORD *a3, _QWORD *a4, _BYTE *a5, _QWORD *a6, double *a7)
{
  void *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  double result;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;

  if (a1)
  {
    if (a2)
      goto LABEL_3;
LABEL_12:
    v20 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v21 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
    objc_msgSend(v20, "handleFailureInFunction:file:lineNumber:description:", v21, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3949, CFSTR("invalid nil value for '%s'"), "resizingColumns");
    if (a3)
      goto LABEL_4;
    goto LABEL_13;
  }
  v18 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v19 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
  objc_msgSend(v18, "handleFailureInFunction:file:lineNumber:description:", v19, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3946, CFSTR("invalid nil value for '%s'"), "masterLayout");
  if (!a2)
    goto LABEL_12;
LABEL_3:
  if (a3)
    goto LABEL_4;
LABEL_13:
  v22 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v23 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
  objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3950, CFSTR("invalid nil value for '%s'"), "resizeColumnRange");
LABEL_4:
  if (!a4)
  {
    v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
    objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3951, CFSTR("invalid nil value for '%s'"), "resizeColumnAdjustment");
  }
  *a2 = *(_BYTE *)(a1 + 450);
  *a3 = *(_QWORD *)(a1 + 452);
  *a4 = *(_QWORD *)(a1 + 464);
  if (!a5)
  {
    v15 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v16 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
    objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3957, CFSTR("invalid nil value for '%s'"), "resizingRows");
  }
  if (!a6)
  {
    v24 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v25 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
    objc_msgSend(v24, "handleFailureInFunction:file:lineNumber:description:", v25, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3958, CFSTR("invalid nil value for '%s'"), "resizeRowRange");
    if (a7)
      goto LABEL_10;
LABEL_15:
    v26 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v27 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeSave(TSTMasterLayout *, BOOL *, TSTCellRange *, CGFloat *, BOOL *, TSTCellRange *, CGFloat *)");
    objc_msgSend(v26, "handleFailureInFunction:file:lineNumber:description:", v27, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3959, CFSTR("invalid nil value for '%s'"), "resizeRowAdjustment");
    goto LABEL_10;
  }
  if (!a7)
    goto LABEL_15;
LABEL_10:
  *a5 = *(_BYTE *)(a1 + 472);
  *a6 = *(_QWORD *)(a1 + 474);
  result = *(double *)(a1 + 488);
  *a7 = result;
  return result;
}

uint64_t TSTMasterLayoutDynamicResizeRestore(uint64_t result, char a2, uint64_t a3, char a4, uint64_t a5, double a6, double a7)
{
  uint64_t v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;

  v13 = result;
  v14 = (_QWORD *)(result + 452);
  if (!result)
  {
    v15 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v16 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTMasterLayoutDynamicResizeRestore(TSTMasterLayout *, BOOL, TSTCellRange, CGFloat, BOOL, TSTCellRange, CGFloat)");
    result = objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTMasterLayout.mm"), 3970, CFSTR("invalid nil value for '%s'"), "masterLayout");
  }
  *(_BYTE *)(v13 + 450) = a2;
  *v14 = a3;
  *(double *)(v13 + 464) = a6;
  *(_BYTE *)(v13 + 472) = a4;
  *(_QWORD *)((char *)v14 + 22) = a5;
  *(double *)(v13 + 488) = a7;
  return result;
}

void sub_217BB951C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t TSTMasterLayoutLock(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 256), "lock");
}

uint64_t TSTMasterLayoutStrokesArrayRangeUpdate(TSTMasterLayout *a1)
{
  unsigned int TableNumberOfColumns;
  uint64_t v3;
  unsigned int v4;
  unsigned int TableNumberOfRows;
  uint64_t v6;
  unsigned int v7;
  TSTTableStrokeDefaults *mDefaultStrokes;
  int v10;
  __int16 v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t result;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;

  -[NSRecursiveLock lock](a1->mStrokesLock, "lock");
  TableNumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
  v3 = TableNumberOfColumns + 1;
  v4 = -[NSMutableArray count](a1->mLeftColumnStrokes, "count");
  TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
  v6 = TableNumberOfRows + 1;
  v7 = -[NSMutableArray count](a1->mTopRowStrokes, "count");
  mDefaultStrokes = a1->mDefaultStrokes;
  if (mDefaultStrokes)
  {
    if ((_DWORD)v3 != v4 || (_DWORD)v6 != v7)
    {
      TSTTableStrokeDefaultsRelease((uint64_t)mDefaultStrokes);
      a1->mDefaultStrokes = 0;
    }
  }
  if (TableNumberOfColumns < v4)
  {
    v32 = 0;
    v29 = 0xFFFFLL;
    v30 = 0;
    v12 = 16711680;
  }
  else
  {
    if ((_DWORD)v3 != v4)
    {
      if (v3 - v4 <= 1)
        v10 = 1;
      else
        v10 = v3 - v4;
      do
      {
        -[NSMutableArray addObject:](a1->mLeftColumnStrokes, "addObject:", objc_msgSend(MEMORY[0x24BDBCEF8], "null"));
        -[NSMutableArray addObject:](a1->mRightColumnStrokes, "addObject:", objc_msgSend(MEMORY[0x24BDBCEF8], "null"));
        --v10;
      }
      while (v10);
    }
    v11 = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
    v29 = 0;
    v30 = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1) << 48;
    v32 = (unint64_t)(unsigned __int16)(v11 - (v4 - 1)) << 32;
    v12 = (unint64_t)(v4 - 1) << 16;
  }
  v35 = v12;
  if (TableNumberOfRows >= v7)
  {
    if ((_DWORD)v6 != v7)
    {
      if (v6 - v7 <= 1)
        v14 = 1;
      else
        v14 = v6 - v7;
      do
      {
        -[NSMutableArray addObject:](a1->mTopRowStrokes, "addObject:", objc_msgSend(MEMORY[0x24BDBCEF8], "null"));
        -[NSMutableArray addObject:](a1->mBottomRowStrokes, "addObject:", objc_msgSend(MEMORY[0x24BDBCEF8], "null"));
        --v14;
      }
      while (v14);
    }
    v34 = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1) << 32;
    v31 = (unint64_t)(TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1) - ((unsigned __int16)v7 - 1)) << 48;
    v13 = (unsigned __int16)(v7 - 1);
  }
  else
  {
    v31 = 0;
    v34 = 16711680;
    v13 = 0xFFFFLL;
  }
  v33 = v13;
  if (v3 < v4)
  {
    v15 = 0;
    do
    {
      objc_opt_class();
      -[NSMutableArray objectAtIndex:](a1->mTopRowStrokes, "objectAtIndex:", v15);
      v16 = TSUDynamicCast();
      if (v16)
      {
        v17 = v16;
        TSTStrokeRunArrayWriteLock(v16);
        TSTStrokeRunArrayTruncate(v17, TableNumberOfColumns);
        TSTStrokeRunArrayUnlock(v17);
      }
      objc_opt_class();
      -[NSMutableArray objectAtIndex:](a1->mBottomRowStrokes, "objectAtIndex:", v15);
      v18 = TSUDynamicCast();
      if (v18)
      {
        v19 = v18;
        TSTStrokeRunArrayWriteLock(v18);
        TSTStrokeRunArrayTruncate(v19, TableNumberOfColumns);
        TSTStrokeRunArrayUnlock(v19);
      }
      ++v15;
    }
    while (v6 != v15);
    if ((_DWORD)v3 != v4)
    {
      if (v4 - v3 <= 1)
        v20 = 1;
      else
        v20 = v4 - v3;
      do
      {
        -[NSMutableArray removeLastObject](a1->mLeftColumnStrokes, "removeLastObject");
        -[NSMutableArray removeLastObject](a1->mRightColumnStrokes, "removeLastObject");
        --v20;
      }
      while (v20);
    }
  }
  if (v6 < v7)
  {
    v21 = 0;
    do
    {
      objc_opt_class();
      -[NSMutableArray objectAtIndex:](a1->mLeftColumnStrokes, "objectAtIndex:", v21);
      v22 = TSUDynamicCast();
      if (v22)
      {
        v23 = v22;
        TSTStrokeRunArrayWriteLock(v22);
        TSTStrokeRunArrayTruncate(v23, TableNumberOfRows);
        TSTStrokeRunArrayUnlock(v23);
      }
      objc_opt_class();
      -[NSMutableArray objectAtIndex:](a1->mRightColumnStrokes, "objectAtIndex:", v21);
      v24 = TSUDynamicCast();
      if (v24)
      {
        v25 = v24;
        TSTStrokeRunArrayWriteLock(v24);
        TSTStrokeRunArrayTruncate(v25, TableNumberOfRows);
        TSTStrokeRunArrayUnlock(v25);
      }
      ++v21;
    }
    while (v3 != v21);
    if ((_DWORD)v6 != v7)
    {
      if (v7 - v6 <= 1)
        v26 = 1;
      else
        v26 = v7 - v6;
      do
      {
        -[NSMutableArray removeLastObject](a1->mTopRowStrokes, "removeLastObject");
        -[NSMutableArray removeLastObject](a1->mBottomRowStrokes, "removeLastObject");
        --v26;
      }
      while (v26);
    }
  }
  result = -[NSRecursiveLock unlock](a1->mStrokesLock, "unlock");
  if (TableNumberOfColumns >= v4 && v35 != 16711680 && v32 && (v29 | v30 | v35 | v32) >> 48)
    result = TSTMasterLayoutInvalidateStrokeRange(a1);
  if (v33 != 0xFFFF)
  {
    v28 = v33 | v31 | v34;
    if ((v28 & 0xFF0000) != 0xFF0000 && (v34 & 0xFFFF00000000) != 0)
    {
      if (HIWORD(v28))
        return TSTMasterLayoutInvalidateStrokeRange(a1);
    }
  }
  return result;
}

uint64_t TSTMasterLayoutUnlock(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 256), "unlock");
}

void sub_217BB9D20(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217BBAF10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  _Block_object_dispose(&a51, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__29(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__29(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

double TSTMasterLayoutApplyMinimumHorizontalInset(double a1)
{
  return fmax(a1, 2.0);
}

TSTTableStrokeDefaults *TSTMasterLayoutGetStrokeDefaults(TSTMasterLayout *a1)
{
  TSTTableStrokeDefaults *result;
  TSTTableModel *v3;
  unsigned int TableNumberOfColumns;
  unsigned int TableNumberOfRows;
  int mCachedNumberOfHeaderColumns;
  int mCachedNumberOfHeaderRows;
  int mCachedNumberOfFooterRows;

  result = a1->mDefaultStrokes;
  if (!result)
  {
    v3 = -[TSTMasterLayout tableModel](a1, "tableModel");
    TableNumberOfColumns = TSTMasterLayoutGetTableNumberOfColumns((uint64_t)a1);
    TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)a1);
    if (-[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable"))
      mCachedNumberOfHeaderColumns = 0;
    else
      mCachedNumberOfHeaderColumns = a1->mCachedNumberOfHeaderColumns;
    if (-[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable"))
      mCachedNumberOfHeaderRows = 0;
    else
      mCachedNumberOfHeaderRows = a1->mCachedNumberOfHeaderRows;
    if (-[TSTMasterLayout emptyFilteredTable](a1, "emptyFilteredTable"))
      mCachedNumberOfFooterRows = 0;
    else
      mCachedNumberOfFooterRows = a1->mCachedNumberOfFooterRows;
    result = (TSTTableStrokeDefaults *)TSTTableStrokeDefaultsCreate(v3, TableNumberOfColumns, TableNumberOfRows, mCachedNumberOfHeaderColumns, mCachedNumberOfHeaderRows, mCachedNumberOfFooterRows);
    a1->mDefaultStrokes = result;
  }
  return result;
}

id TSTCellCopy(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  id v5;
  char v6;
  id v7;
  id v8;
  id v9;
  id v10;
  id result;
  id v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  id v18;

  if (a1 && a2)
  {
    memcpy((void *)(a2 + 8), (const void *)(a1 + 8), 0x110uLL);
    goto LABEL_5;
  }
  if (a2)
  {
LABEL_5:
    v3 = *(unsigned __int8 *)(a2 + 9);
    if (v3 == 3)
    {
      v4 = 24;
    }
    else
    {
      if (v3 != 5)
      {
LABEL_10:
        v6 = 0;
        goto LABEL_12;
      }
      v4 = 16;
    }
    v5 = *(id *)(a2 + v4);
    goto LABEL_10;
  }
  v6 = 1;
LABEL_12:
  v7 = *(id *)(a2 + 40);
  v8 = *(id *)(a2 + 56);
  v9 = *(id *)(a2 + 72);
  v10 = *(id *)(a2 + 88);
  result = (id)TSUFormatStructRetain();
  if ((v6 & 1) == 0)
  {
    v12 = *(id *)(a2 + 152);
    v13 = *(id *)(a2 + 168);
    v14 = *(id *)(a2 + 200);
    v15 = *(id *)(a2 + 184);
    v16 = *(id *)(a2 + 248);
    v17 = *(id *)(a2 + 232);
    v18 = *(id *)(a2 + 216);
    return *(id *)(a2 + 264);
  }
  return result;
}

double TSTCellClear(uint64_t a1)
{
  int v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  double result;
  _OWORD *v8;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 8);
    if ((v2 & 0xFF00) == 0x300)
    {

      *(_QWORD *)(a1 + 24) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      v2 = *(_DWORD *)(a1 + 8);
    }
    if ((v2 & 0xFF00) == 0x500)
    {

      *(_QWORD *)(a1 + 16) = 0;
    }
  }
  v3 = *(void **)(a1 + 72);
  if (v3)
  {

    *(_QWORD *)(a1 + 72) = 0;
  }
  v4 = *(void **)(a1 + 88);
  if (v4)
  {

    *(_QWORD *)(a1 + 88) = 0;
  }
  v5 = *(void **)(a1 + 40);
  if (v5)
  {

    *(_QWORD *)(a1 + 40) = 0;
  }
  v6 = *(void **)(a1 + 56);
  if (v6)
  {

    *(_QWORD *)(a1 + 56) = 0;
  }
  TSUFormatStructRelease();

  *(_QWORD *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 144) = 0;

  *(_QWORD *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 160) = 0;

  *(_QWORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 192) = 0;

  *(_QWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 176) = 0;

  *(_QWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 208) = 0;

  *(_QWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 240) = 0;

  *(_QWORD *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 224) = 0;

  result = 0.0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  v8 = (_OWORD *)(a1 + 8);
  v8[16] = 0u;
  v8[4] = 0u;
  v8[5] = 0u;
  v8[2] = 0u;
  v8[3] = 0u;
  v8[1] = 0u;
  return result;
}

void TSTCellInflateFromStorageRef(uint64_t a1, unsigned __int8 *a2, id *a3)
{
  TSTCellClear(a1);
  TSTCellStorageToCell(a2, a1);
  if (a3)
    TSTTableDataStoreResolveCellDataIDs(a3, a1);
}

{
  TSTCellInflateFromStorageRef(a1, a2, a3);
}

void sub_217BBDD04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  TSUFormat::~TSUFormat((TSUFormat *)&a35);
  TSUFormat::~TSUFormat((TSUFormat *)&a42);
  _Unwind_Resume(a1);
}

uint64_t TSUEqualFormatStructs(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t result;
  void *v6;
  int v7;
  int v8;
  void *v9;
  uint64_t v10;
  char v11;
  _BOOL4 v12;
  BOOL v13;
  char v14;
  int v16;

  v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 == *(_DWORD *)a2)
  {
    result = 1;
    switch(v2)
    {
      case 0xFEu:
        return 1;
      case 0xFFu:
        goto LABEL_9;
      case 0x100u:
      case 0x101u:
      case 0x102u:
      case 0x103u:
        v6 = *(void **)(a1 + 8);
        if (v6 != *(void **)(a2 + 8))
        {
          result = objc_msgSend(v6, "isEqualToString:");
          if (!(_DWORD)result)
            return result;
        }
        return ((*(_WORD *)(a2 + 16) ^ *(_WORD *)(a1 + 16)) & 0x1FFF) == 0;
      case 0x104u:
      case 0x107u:
      case 0x10Bu:
        return result;
      case 0x105u:
        result = objc_msgSend(*(id *)(a1 + 16), "isEqualToString:", *(_QWORD *)(a2 + 16));
        if (!(_DWORD)result)
          return result;
        v14 = *(_BYTE *)(a2 + 8) ^ *(_BYTE *)(a1 + 8);
        v12 = (v14 & 2) == 0;
        v13 = (v14 & 1) == 0;
        return v13 && v12;
      case 0x106u:
        v7 = *(unsigned __int8 *)(a1 + 8);
        v8 = *(unsigned __int8 *)(a2 + 8);
        return v7 == v8;
      case 0x108u:
      case 0x109u:
        if (*(double *)(a1 + 8) != *(double *)(a2 + 8)
          || *(double *)(a1 + 16) != *(double *)(a2 + 16)
          || *(double *)(a1 + 24) != *(double *)(a2 + 24)
          || *(_DWORD *)(a1 + 32) != *(_DWORD *)(a2 + 32))
        {
          return 0;
        }
        v11 = *(_BYTE *)(a2 + 36) ^ *(_BYTE *)(a1 + 36);
        v12 = (v11 & 0xC) == 0;
        v13 = (v11 & 3) == 0;
        return v13 && v12;
      case 0x10Au:
        if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
          return 0;
        v7 = *(_DWORD *)(a1 + 12);
        v8 = *(_DWORD *)(a2 + 12);
        return v7 == v8;
      case 0x10Cu:
        if (*(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20)
          || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
          || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
        {
          return 0;
        }
        return ((*(unsigned __int8 *)(a2 + 8) ^ *(unsigned __int8 *)(a1 + 8)) & 1) == 0;
      case 0x10Du:
        v16 = *(unsigned __int16 *)(a2 + 8);
        if ((unsigned __int16)v16 != *(_WORD *)(a1 + 8))
          return 0;
        return (((v16 | (*(unsigned __int8 *)(a2 + 10) << 16)) ^ (*(unsigned __int16 *)(a1 + 8) | (*(unsigned __int8 *)(a1 + 10) << 16))) & 0x10000) == 0;
      case 0x10Eu:
      case 0x10Fu:
      case 0x110u:
        v7 = *(_DWORD *)(a1 + 8);
        v8 = *(_DWORD *)(a2 + 8);
        return v7 == v8;
      default:
        if (v2 < 2)
          return result;
LABEL_9:
        v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSUEqualFormatStructs(TSUFormatStruct, TSUFormatStruct)");
        objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Binaries/AlderShared/install/Root/usr/local/include/TSFrameworks/TSUtility/TSUFormatUtilities.h"), 191, CFSTR("We should have dealt with any types earlier."));
        return 0;
    }
  }
  return 0;
}

double TSTCellDoubleValue(TSTCell *a1)
{
  int mPrivate;
  NSDate *mDate;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;

  if (a1)
  {
    mPrivate = (int)a1->mPrivate;
    if ((mPrivate & 0xFB00) == 0x200 || BYTE1(mPrivate) == 7)
    {
      mDate = a1->mPrivate.mValue.mDate;
    }
    else
    {
      mDate = 0;
      if (BYTE1(mPrivate))
      {
        v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
        objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a1);
      }
    }
  }
  else
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 889, CFSTR("invalid nil value for '%s'"), "cell");
    mDate = 0;
  }
  return *(double *)&mDate;
}

uint64_t TSTCellDateValue(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    if (*(_BYTE *)(result + 9))
    {
      if (*(_BYTE *)(result + 9) == 5)
        return *(_QWORD *)(result + 16);
      v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSDate *TSTCellDateValue(TSTCell *)");
      objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1021, CFSTR("can't get date value from a non-date cell: %p"), v1);
    }
    return 0;
  }
  return result;
}

void *TSTCellIsEqualForValidation(uint64_t a1, uint64_t a2)
{
  void *result;
  __int128 v5;
  __int128 v6;
  void *v7;
  void *v8;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  _OWORD v40[2];
  uint64_t v41;
  _OWORD v42[2];
  uint64_t v43;
  _OWORD v44[2];
  uint64_t v45;
  _OWORD v46[2];
  uint64_t v47;
  _OWORD v48[2];
  uint64_t v49;
  _OWORD v50[2];
  uint64_t v51;
  _OWORD v52[2];
  uint64_t v53;
  _OWORD v54[2];
  uint64_t v55;
  _OWORD v56[2];
  uint64_t v57;
  _OWORD v58[2];
  uint64_t v59;
  _OWORD v60[2];
  uint64_t v61;
  _OWORD v62[2];
  uint64_t v63;
  _OWORD v64[2];
  uint64_t v65;
  _OWORD v66[2];
  uint64_t v67;
  _OWORD v68[2];
  uint64_t v69;
  _OWORD v70[2];
  uint64_t v71;
  _OWORD v72[2];
  uint64_t v73;
  _OWORD v74[2];
  uint64_t v75;
  int v76;

  if (!a1 || !a2)
    return (void *)(a1 == a2);
  result = (void *)objc_msgSend((id)a2, "isCellContentsEqualToCell:", a1);
  if (!(_DWORD)result)
    return result;
  if ((*(_DWORD *)(a1 + 8) ^ *(_DWORD *)(a2 + 8)) > 0xFF)
    return 0;
  if ((*(_DWORD *)(a2 + 104) - 1) < 0xFFFFFFFE || *(_DWORD *)(a2 + 100))
  {
    if ((*(_DWORD *)(a1 + 104) - 1) >= 0xFFFFFFFE && !*(_DWORD *)(a1 + 100))
      return 0;
    v5 = *(_OWORD *)(a1 + 120);
    v74[0] = *(_OWORD *)(a1 + 104);
    v74[1] = v5;
    v75 = *(_QWORD *)(a1 + 136);
    v6 = *(_OWORD *)(a2 + 120);
    v72[0] = *(_OWORD *)(a2 + 104);
    v72[1] = v6;
    v73 = *(_QWORD *)(a2 + 136);
    if ((TSUEqualFormatStructs((uint64_t)v74, (uint64_t)v72) & 1) == 0)
      return 0;
  }
  else if ((*(_DWORD *)(a1 + 104) - 1) < 0xFFFFFFFE || *(_DWORD *)(a1 + 100))
  {
    return 0;
  }
  v7 = *(void **)(a2 + 152);
  if (v7 && (objc_msgSend(v7, "getFormatStruct"), (v76 - 1) <= 0xFFFFFFFD))
  {
    result = *(void **)(a1 + 152);
    if (!result)
      return result;
    objc_msgSend(result, "getFormatStruct");
    if ((v76 - 1) > 0xFFFFFFFD)
      return 0;
    v8 = *(void **)(a1 + 152);
    if (v8)
    {
      objc_msgSend(v8, "getFormatStruct");
    }
    else
    {
      v71 = 0;
      v70[0] = TSUInvalidFormat;
      v70[1] = unk_217C2C278;
    }
    v25 = *(void **)(a2 + 152);
    if (v25)
    {
      objc_msgSend(v25, "getFormatStruct");
    }
    else
    {
      v69 = 0;
      v68[0] = TSUInvalidFormat;
      v68[1] = unk_217C2C278;
    }
    if ((TSUEqualFormatStructs((uint64_t)v70, (uint64_t)v68) & 1) == 0)
      return 0;
  }
  else
  {
    v10 = *(void **)(a1 + 152);
    if (v10)
    {
      objc_msgSend(v10, "getFormatStruct");
      if ((v76 - 1) < 0xFFFFFFFE)
        return 0;
    }
  }
  v11 = *(void **)(a2 + 168);
  if (v11 && (objc_msgSend(v11, "getFormatStruct"), (v76 - 1) <= 0xFFFFFFFD))
  {
    result = *(void **)(a1 + 168);
    if (!result)
      return result;
    objc_msgSend(result, "getFormatStruct");
    if ((v76 - 1) > 0xFFFFFFFD)
      return 0;
    v12 = *(void **)(a1 + 168);
    if (v12)
    {
      objc_msgSend(v12, "getFormatStruct");
    }
    else
    {
      v67 = 0;
      v66[0] = TSUInvalidFormat;
      v66[1] = unk_217C2C278;
    }
    v29 = *(void **)(a2 + 168);
    if (v29)
    {
      objc_msgSend(v29, "getFormatStruct");
    }
    else
    {
      v65 = 0;
      v64[0] = TSUInvalidFormat;
      v64[1] = unk_217C2C278;
    }
    if ((TSUEqualFormatStructs((uint64_t)v66, (uint64_t)v64) & 1) == 0)
      return 0;
  }
  else
  {
    v13 = *(void **)(a1 + 168);
    if (v13)
    {
      objc_msgSend(v13, "getFormatStruct");
      if ((v76 - 1) < 0xFFFFFFFE)
        return 0;
    }
  }
  v14 = *(void **)(a2 + 200);
  if (v14 && (objc_msgSend(v14, "getFormatStruct"), (v76 - 1) <= 0xFFFFFFFD))
  {
    result = *(void **)(a1 + 200);
    if (!result)
      return result;
    objc_msgSend(result, "getFormatStruct");
    if ((v76 - 1) > 0xFFFFFFFD)
      return 0;
    v15 = *(void **)(a1 + 200);
    if (v15)
    {
      objc_msgSend(v15, "getFormatStruct");
    }
    else
    {
      v63 = 0;
      v62[0] = TSUInvalidFormat;
      v62[1] = unk_217C2C278;
    }
    v33 = *(void **)(a2 + 200);
    if (v33)
    {
      objc_msgSend(v33, "getFormatStruct");
    }
    else
    {
      v61 = 0;
      v60[0] = TSUInvalidFormat;
      v60[1] = unk_217C2C278;
    }
    if ((TSUEqualFormatStructs((uint64_t)v62, (uint64_t)v60) & 1) == 0)
      return 0;
  }
  else
  {
    v16 = *(void **)(a1 + 200);
    if (v16)
    {
      objc_msgSend(v16, "getFormatStruct");
      if ((v76 - 1) < 0xFFFFFFFE)
        return 0;
    }
  }
  v17 = *(void **)(a2 + 184);
  if (v17 && (objc_msgSend(v17, "getFormatStruct"), (v76 - 1) <= 0xFFFFFFFD))
  {
    result = *(void **)(a1 + 184);
    if (!result)
      return result;
    objc_msgSend(result, "getFormatStruct");
    if ((v76 - 1) > 0xFFFFFFFD)
      return 0;
    v18 = *(void **)(a1 + 184);
    if (v18)
    {
      objc_msgSend(v18, "getFormatStruct");
    }
    else
    {
      v59 = 0;
      v58[0] = TSUInvalidFormat;
      v58[1] = unk_217C2C278;
    }
    v35 = *(void **)(a2 + 184);
    if (v35)
    {
      objc_msgSend(v35, "getFormatStruct");
    }
    else
    {
      v57 = 0;
      v56[0] = TSUInvalidFormat;
      v56[1] = unk_217C2C278;
    }
    if ((TSUEqualFormatStructs((uint64_t)v58, (uint64_t)v56) & 1) == 0)
      return 0;
  }
  else
  {
    v19 = *(void **)(a1 + 184);
    if (v19)
    {
      objc_msgSend(v19, "getFormatStruct");
      if ((v76 - 1) < 0xFFFFFFFE)
        return 0;
    }
  }
  v20 = *(void **)(a2 + 216);
  if (v20 && (objc_msgSend(v20, "getFormatStruct"), (v76 - 1) <= 0xFFFFFFFD))
  {
    result = *(void **)(a1 + 216);
    if (!result)
      return result;
    objc_msgSend(result, "getFormatStruct");
    if ((v76 - 1) > 0xFFFFFFFD)
      return 0;
    v21 = *(void **)(a1 + 216);
    if (v21)
    {
      objc_msgSend(v21, "getFormatStruct");
    }
    else
    {
      v55 = 0;
      v54[0] = TSUInvalidFormat;
      v54[1] = unk_217C2C278;
    }
    v36 = *(void **)(a2 + 216);
    if (v36)
    {
      objc_msgSend(v36, "getFormatStruct");
    }
    else
    {
      v53 = 0;
      v52[0] = TSUInvalidFormat;
      v52[1] = unk_217C2C278;
    }
    if ((TSUEqualFormatStructs((uint64_t)v54, (uint64_t)v52) & 1) == 0)
      return 0;
  }
  else
  {
    v22 = *(void **)(a1 + 216);
    if (v22)
    {
      objc_msgSend(v22, "getFormatStruct");
      if ((v76 - 1) < 0xFFFFFFFE)
        return 0;
    }
  }
  v23 = *(void **)(a2 + 232);
  if (v23 && (objc_msgSend(v23, "getFormatStruct"), (v76 - 1) <= 0xFFFFFFFD))
  {
    result = *(void **)(a1 + 232);
    if (!result)
      return result;
    objc_msgSend(result, "getFormatStruct");
    if ((v76 - 1) > 0xFFFFFFFD)
      return 0;
    v24 = *(void **)(a1 + 232);
    if (v24)
    {
      objc_msgSend(v24, "getFormatStruct");
    }
    else
    {
      v51 = 0;
      v50[0] = TSUInvalidFormat;
      v50[1] = unk_217C2C278;
    }
    v37 = *(void **)(a2 + 232);
    if (v37)
    {
      objc_msgSend(v37, "getFormatStruct");
    }
    else
    {
      v49 = 0;
      v48[0] = TSUInvalidFormat;
      v48[1] = unk_217C2C278;
    }
    if ((TSUEqualFormatStructs((uint64_t)v50, (uint64_t)v48) & 1) == 0)
      return 0;
  }
  else
  {
    v26 = *(void **)(a1 + 232);
    if (v26)
    {
      objc_msgSend(v26, "getFormatStruct");
      if ((v76 - 1) < 0xFFFFFFFE)
        return 0;
    }
  }
  v27 = *(void **)(a2 + 248);
  if (v27 && (objc_msgSend(v27, "getFormatStruct"), (v76 - 1) <= 0xFFFFFFFD))
  {
    result = *(void **)(a1 + 248);
    if (!result)
      return result;
    objc_msgSend(result, "getFormatStruct");
    if ((v76 - 1) > 0xFFFFFFFD)
      return 0;
    v28 = *(void **)(a1 + 248);
    if (v28)
    {
      objc_msgSend(v28, "getFormatStruct");
    }
    else
    {
      v47 = 0;
      v46[0] = TSUInvalidFormat;
      v46[1] = unk_217C2C278;
    }
    v38 = *(void **)(a2 + 248);
    if (v38)
    {
      objc_msgSend(v38, "getFormatStruct");
    }
    else
    {
      v45 = 0;
      v44[0] = TSUInvalidFormat;
      v44[1] = unk_217C2C278;
    }
    if ((TSUEqualFormatStructs((uint64_t)v46, (uint64_t)v44) & 1) == 0)
      return 0;
  }
  else
  {
    v30 = *(void **)(a1 + 248);
    if (v30)
    {
      objc_msgSend(v30, "getFormatStruct");
      if ((v76 - 1) < 0xFFFFFFFE)
        return 0;
    }
  }
  v31 = *(void **)(a2 + 264);
  if (v31 && (objc_msgSend(v31, "getFormatStruct"), (v76 - 1) <= 0xFFFFFFFD))
  {
    result = *(void **)(a1 + 264);
    if (!result)
      return result;
    objc_msgSend(result, "getFormatStruct");
    if ((v76 - 1) > 0xFFFFFFFD)
      return 0;
    v32 = *(void **)(a1 + 264);
    if (v32)
    {
      objc_msgSend(v32, "getFormatStruct");
    }
    else
    {
      v43 = 0;
      v42[0] = TSUInvalidFormat;
      v42[1] = unk_217C2C278;
    }
    v39 = *(void **)(a2 + 264);
    if (v39)
    {
      objc_msgSend(v39, "getFormatStruct");
    }
    else
    {
      v41 = 0;
      v40[0] = TSUInvalidFormat;
      v40[1] = unk_217C2C278;
    }
    if ((TSUEqualFormatStructs((uint64_t)v42, (uint64_t)v40) & 1) == 0)
      return 0;
  }
  else
  {
    v34 = *(void **)(a1 + 264);
    if (v34)
    {
      objc_msgSend(v34, "getFormatStruct");
      if ((v76 - 1) < 0xFFFFFFFE)
        return 0;
    }
  }
  if (*(unsigned __int16 *)(a2 + 96) != *(unsigned __int16 *)(a1 + 96))
    return 0;
  return (void *)(*(unsigned __int8 *)(a1 + 272) == *(unsigned __int8 *)(a2 + 272));
}

void TSTCellClearValue(uint64_t a1)
{
  int v2;
  void *v3;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 8);
    if ((v2 & 0xFF00) == 0x300)
    {

      *(_QWORD *)(a1 + 24) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      v2 = *(_DWORD *)(a1 + 8);
    }
    if ((v2 & 0xFF00) == 0x500)
    {

      *(_QWORD *)(a1 + 16) = 0;
      v2 = *(_DWORD *)(a1 + 8);
    }
    if ((v2 & 0xFF00) == 0x900)
    {
      v3 = *(void **)(a1 + 72);
      if (v3)
      {

        *(_QWORD *)(a1 + 72) = 0;
      }
      *(_DWORD *)(a1 + 64) = 0;
    }
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
}

uint64_t TSTCellClearAllFormats(uint64_t a1)
{
  if (a1)
  {

    *(_QWORD *)(a1 + 152) = 0;
    *(_DWORD *)(a1 + 144) = 0;

    *(_QWORD *)(a1 + 168) = 0;
    *(_DWORD *)(a1 + 160) = 0;

    *(_QWORD *)(a1 + 200) = 0;
    *(_DWORD *)(a1 + 192) = 0;

    *(_QWORD *)(a1 + 184) = 0;
    *(_DWORD *)(a1 + 176) = 0;

    *(_QWORD *)(a1 + 216) = 0;
    *(_DWORD *)(a1 + 208) = 0;

    *(_QWORD *)(a1 + 248) = 0;
    *(_DWORD *)(a1 + 240) = 0;

    *(_QWORD *)(a1 + 232) = 0;
    *(_DWORD *)(a1 + 224) = 0;

    *(_QWORD *)(a1 + 264) = 0;
    *(_DWORD *)(a1 + 256) = 0;
  }
  *(_WORD *)(a1 + 96) = 0;
  return TSTCellSetImplicitFormat(a1, (uint64_t)&TSUNotSetFormat);
}

uint64_t TSTCellSetImplicitFormat(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  _OWORD v7[2];
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;

  v4 = *(_OWORD *)(a2 + 16);
  v9[0] = *(_OWORD *)a2;
  v9[1] = v4;
  v10 = *(_QWORD *)(a2 + 32);
  TSTCellSetFormatClearingID(a1, (uint64_t)v9, 1);
  v5 = *(_OWORD *)(a2 + 16);
  v7[0] = *(_OWORD *)a2;
  v7[1] = v5;
  v8 = *(_QWORD *)(a2 + 32);
  return TSTCellSetFormatFlagsFromFormat(a1, (int *)v7, 0, 1);
}

id TSTCellCopyJustStyleAndStrokes(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  id result;

  v4 = *(void **)(a2 + 40);
  if (v4)

  v5 = *(void **)(a2 + 56);
  if (v5)

  *(_WORD *)(a2 + 10) = (*(_DWORD *)(a1 + 8) & 0x8F00000u) >> 16;
  *(_QWORD *)(a2 + 40) = *(id *)(a1 + 40);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
  result = *(id *)(a1 + 56);
  *(_QWORD *)(a2 + 56) = result;
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a1 + 48);
  *(_BYTE *)(a2 + 272) = *(_BYTE *)(a1 + 272);
  return result;
}

uint64_t TSTCellCopyAllFormats(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;
  id v15;
  void *v16;
  void *v17;
  void *v18;
  id v19;
  void *v20;
  void *v21;
  void *v22;
  id v23;
  void *v24;
  void *v25;
  void *v26;
  id v27;
  void *v28;
  void *v29;
  void *v30;
  id v31;
  void *v32;
  void *v33;
  void *v34;
  id v35;
  __int128 *v36;
  __int128 v37;
  uint64_t result;
  __int16 v39;
  _OWORD v40[2];
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;
  __int128 v72;
  __int128 v73;
  uint64_t v74;

  TSTCellClearAllFormats(a2);
  if (!a1)
    goto LABEL_90;
  v4 = *(void **)(a1 + 248);
  if (v4)
  {
    objc_msgSend(v4, "getFormatStruct");
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      v5 = *(void **)(a1 + 248);
      if (v5)
      {
        objc_msgSend(v5, "getFormatStruct");
        if (!a2)
          goto LABEL_13;
      }
      else
      {
        v65 = 0;
        v63 = TSUInvalidFormat;
        v64 = unk_217C2C278;
        if (!a2)
          goto LABEL_13;
      }
      v72 = v63;
      v73 = v64;
      v74 = v65;
      v6 = *(void **)(a2 + 248);
      if (v6)
      {
        objc_msgSend(v6, "getFormatStruct");
      }
      else
      {
        v71 = 0;
        v69 = 0u;
        v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        v7 = objc_alloc(MEMORY[0x24BEB3C88]);
        v66 = v63;
        v67 = v64;
        v68 = v65;
        *(_QWORD *)(a2 + 248) = objc_msgSend(v7, "initWithTSUFormatFormatStruct:", &v66);
        *(_DWORD *)(a2 + 240) = 0;
      }
    }
  }
LABEL_13:
  v8 = *(void **)(a1 + 216);
  if (v8)
  {
    objc_msgSend(v8, "getFormatStruct");
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      v9 = *(void **)(a1 + 216);
      if (v9)
      {
        objc_msgSend(v9, "getFormatStruct");
        if (!a2)
          goto LABEL_24;
      }
      else
      {
        v62 = 0;
        v60 = TSUInvalidFormat;
        v61 = unk_217C2C278;
        if (!a2)
          goto LABEL_24;
      }
      v72 = v60;
      v73 = v61;
      v74 = v62;
      v10 = *(void **)(a2 + 216);
      if (v10)
      {
        objc_msgSend(v10, "getFormatStruct");
      }
      else
      {
        v71 = 0;
        v69 = 0u;
        v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        v11 = objc_alloc(MEMORY[0x24BEB3C88]);
        v66 = v60;
        v67 = v61;
        v68 = v62;
        *(_QWORD *)(a2 + 216) = objc_msgSend(v11, "initWithTSUFormatFormatStruct:", &v66);
        *(_DWORD *)(a2 + 208) = 0;
      }
    }
  }
LABEL_24:
  v12 = *(void **)(a1 + 168);
  if (v12)
  {
    objc_msgSend(v12, "getFormatStruct");
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      v13 = *(void **)(a1 + 168);
      if (v13)
      {
        objc_msgSend(v13, "getFormatStruct");
        if (!a2)
          goto LABEL_35;
      }
      else
      {
        v59 = 0;
        v57 = TSUInvalidFormat;
        v58 = unk_217C2C278;
        if (!a2)
          goto LABEL_35;
      }
      v72 = v57;
      v73 = v58;
      v74 = v59;
      v14 = *(void **)(a2 + 168);
      if (v14)
      {
        objc_msgSend(v14, "getFormatStruct");
      }
      else
      {
        v71 = 0;
        v69 = 0u;
        v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        v15 = objc_alloc(MEMORY[0x24BEB3C88]);
        v66 = v57;
        v67 = v58;
        v68 = v59;
        *(_QWORD *)(a2 + 168) = objc_msgSend(v15, "initWithTSUFormatFormatStruct:", &v66);
        *(_DWORD *)(a2 + 160) = 0;
      }
    }
  }
LABEL_35:
  v16 = *(void **)(a1 + 232);
  if (v16)
  {
    objc_msgSend(v16, "getFormatStruct");
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      v17 = *(void **)(a1 + 232);
      if (v17)
      {
        objc_msgSend(v17, "getFormatStruct");
        if (!a2)
          goto LABEL_46;
      }
      else
      {
        v56 = 0;
        v54 = TSUInvalidFormat;
        v55 = unk_217C2C278;
        if (!a2)
          goto LABEL_46;
      }
      v72 = v54;
      v73 = v55;
      v74 = v56;
      v18 = *(void **)(a2 + 232);
      if (v18)
      {
        objc_msgSend(v18, "getFormatStruct");
      }
      else
      {
        v71 = 0;
        v69 = 0u;
        v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        v19 = objc_alloc(MEMORY[0x24BEB3C88]);
        v66 = v54;
        v67 = v55;
        v68 = v56;
        *(_QWORD *)(a2 + 232) = objc_msgSend(v19, "initWithTSUFormatFormatStruct:", &v66);
        *(_DWORD *)(a2 + 224) = 0;
      }
    }
  }
LABEL_46:
  v20 = *(void **)(a1 + 200);
  if (v20)
  {
    objc_msgSend(v20, "getFormatStruct");
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      v21 = *(void **)(a1 + 200);
      if (v21)
      {
        objc_msgSend(v21, "getFormatStruct");
        if (!a2)
          goto LABEL_57;
      }
      else
      {
        v53 = 0;
        v51 = TSUInvalidFormat;
        v52 = unk_217C2C278;
        if (!a2)
          goto LABEL_57;
      }
      v72 = v51;
      v73 = v52;
      v74 = v53;
      v22 = *(void **)(a2 + 200);
      if (v22)
      {
        objc_msgSend(v22, "getFormatStruct");
      }
      else
      {
        v71 = 0;
        v69 = 0u;
        v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        v23 = objc_alloc(MEMORY[0x24BEB3C88]);
        v66 = v51;
        v67 = v52;
        v68 = v53;
        *(_QWORD *)(a2 + 200) = objc_msgSend(v23, "initWithTSUFormatFormatStruct:", &v66);
        *(_DWORD *)(a2 + 192) = 0;
      }
    }
  }
LABEL_57:
  v24 = *(void **)(a1 + 184);
  if (v24)
  {
    objc_msgSend(v24, "getFormatStruct");
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      v25 = *(void **)(a1 + 184);
      if (v25)
      {
        objc_msgSend(v25, "getFormatStruct");
        if (!a2)
          goto LABEL_68;
      }
      else
      {
        v50 = 0;
        v48 = TSUInvalidFormat;
        v49 = unk_217C2C278;
        if (!a2)
          goto LABEL_68;
      }
      v72 = v48;
      v73 = v49;
      v74 = v50;
      v26 = *(void **)(a2 + 184);
      if (v26)
      {
        objc_msgSend(v26, "getFormatStruct");
      }
      else
      {
        v71 = 0;
        v69 = 0u;
        v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        v27 = objc_alloc(MEMORY[0x24BEB3C88]);
        v66 = v48;
        v67 = v49;
        v68 = v50;
        *(_QWORD *)(a2 + 184) = objc_msgSend(v27, "initWithTSUFormatFormatStruct:", &v66);
        *(_DWORD *)(a2 + 176) = 0;
      }
    }
  }
LABEL_68:
  v28 = *(void **)(a1 + 264);
  if (v28)
  {
    objc_msgSend(v28, "getFormatStruct");
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      v29 = *(void **)(a1 + 264);
      if (v29)
      {
        objc_msgSend(v29, "getFormatStruct");
        if (!a2)
          goto LABEL_79;
      }
      else
      {
        v47 = 0;
        v45 = TSUInvalidFormat;
        v46 = unk_217C2C278;
        if (!a2)
          goto LABEL_79;
      }
      v72 = v45;
      v73 = v46;
      v74 = v47;
      v30 = *(void **)(a2 + 264);
      if (v30)
      {
        objc_msgSend(v30, "getFormatStruct");
      }
      else
      {
        v71 = 0;
        v69 = 0u;
        v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        v31 = objc_alloc(MEMORY[0x24BEB3C88]);
        v66 = v45;
        v67 = v46;
        v68 = v47;
        *(_QWORD *)(a2 + 264) = objc_msgSend(v31, "initWithTSUFormatFormatStruct:", &v66);
        *(_DWORD *)(a2 + 256) = 0;
      }
    }
  }
LABEL_79:
  v32 = *(void **)(a1 + 152);
  if (v32)
  {
    objc_msgSend(v32, "getFormatStruct");
    if ((v72 - 1) <= 0xFFFFFFFD)
    {
      v33 = *(void **)(a1 + 152);
      if (v33)
      {
        objc_msgSend(v33, "getFormatStruct");
        if (!a2)
          goto LABEL_90;
      }
      else
      {
        v44 = 0;
        v42 = TSUInvalidFormat;
        v43 = unk_217C2C278;
        if (!a2)
          goto LABEL_90;
      }
      v72 = v42;
      v73 = v43;
      v74 = v44;
      v34 = *(void **)(a2 + 152);
      if (v34)
      {
        objc_msgSend(v34, "getFormatStruct");
      }
      else
      {
        v71 = 0;
        v69 = 0u;
        v70 = 0u;
      }
      if ((TSUEqualFormatStructs((uint64_t)&v72, (uint64_t)&v69) & 1) == 0)
      {

        v35 = objc_alloc(MEMORY[0x24BEB3C88]);
        v66 = v42;
        v67 = v43;
        v68 = v44;
        *(_QWORD *)(a2 + 152) = objc_msgSend(v35, "initWithTSUFormatFormatStruct:", &v66);
        *(_DWORD *)(a2 + 144) = 0;
      }
    }
  }
LABEL_90:
  v36 = (__int128 *)(a1 + 104);
  if (!a1)
    v36 = &TSUInvalidFormat;
  v37 = v36[1];
  v40[0] = *v36;
  v40[1] = v37;
  v41 = *((_QWORD *)v36 + 4);
  result = TSTCellSetFormatClearingID(a2, (uint64_t)v40, 1);
  if (a1)
    v39 = *(_WORD *)(a1 + 96);
  else
    v39 = 0;
  *(_WORD *)(a2 + 96) = v39;
  return result;
}

uint64_t TSTCellSetFormatClearingID(uint64_t a1, uint64_t a2, int a3)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v12[2];
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v6 = *(_OWORD *)(a2 + 16);
  v17 = *(_OWORD *)a2;
  v18 = v6;
  v19 = *(_QWORD *)(a2 + 32);
  TSUFormatStructRetain();
  v7 = *(_OWORD *)(a1 + 120);
  v14 = *(_OWORD *)(a1 + 104);
  v15 = v7;
  v16 = *(_QWORD *)(a1 + 136);
  TSUFormatStructRelease();
  v8 = *(_OWORD *)a2;
  v9 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 120) = v9;
  *(_OWORD *)(a1 + 104) = v8;
  if (a3)
    *(_DWORD *)(a1 + 100) = 0;
  v10 = *(_OWORD *)(a2 + 16);
  v12[0] = *(_OWORD *)a2;
  v12[1] = v10;
  v13 = *(_QWORD *)(a2 + 32);
  return TSTCellSetCellFormatStructBasedOnType(a1, v12, a3);
}

uint64_t TSTCellImpliedFormatType(uint64_t a1)
{
  uint64_t result;
  int v3;

  if (!a1)
    return 0xFFFFFFFFLL;
  result = *(unsigned int *)(a1 + 104);
  if ((result + 1) <= 2)
  {
    v3 = *(_DWORD *)(a1 + 8);
    if (BYTE1(v3) > 8u)
      return 260;
    else
      return dword_217C2C2B0[SBYTE1(v3)];
  }
  return result;
}

unint64_t TSTCellHasFormatOfType(_QWORD *a1, int a2)
{
  unint64_t result;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  result = 0;
  switch(a2)
  {
    case 256:
    case 258:
    case 259:
    case 262:
      if (!a1)
        goto LABEL_27;
      result = a1[19];
      if (result)
      {
        objc_msgSend((id)result, "getFormatStruct");
        v4 = v12;
        goto LABEL_26;
      }
      break;
    case 257:
      if (!a1)
        goto LABEL_27;
      result = a1[21];
      if (result)
      {
        objc_msgSend((id)result, "getFormatStruct");
        v4 = v11;
        goto LABEL_26;
      }
      break;
    case 261:
      if (!a1)
        goto LABEL_27;
      result = a1[25];
      if (result)
      {
        objc_msgSend((id)result, "getFormatStruct");
        v4 = v10;
        goto LABEL_26;
      }
      break;
    case 264:
    case 265:
      if (!a1)
        goto LABEL_27;
      result = a1[27];
      if (result)
      {
        objc_msgSend((id)result, "getFormatStruct");
        v4 = v6;
        goto LABEL_26;
      }
      break;
    case 266:
      if (!a1)
        goto LABEL_27;
      result = a1[33];
      if (result)
      {
        objc_msgSend((id)result, "getFormatStruct");
        v4 = v5;
        goto LABEL_26;
      }
      break;
    case 268:
      if (!a1)
        goto LABEL_27;
      result = a1[23];
      if (result)
      {
        objc_msgSend((id)result, "getFormatStruct");
        v4 = v9;
        goto LABEL_26;
      }
      break;
    case 269:
      if (!a1)
        goto LABEL_27;
      result = a1[31];
      if (result)
      {
        objc_msgSend((id)result, "getFormatStruct");
        v4 = v7;
        goto LABEL_26;
      }
      break;
    case 270:
    case 271:
    case 272:
      if (a1)
      {
        result = a1[29];
        if (result)
        {
          objc_msgSend((id)result, "getFormatStruct");
          v4 = v8;
LABEL_26:
          result = (v4 - 1) < 0xFFFFFFFE;
        }
      }
      else
      {
LABEL_27:
        result = 0;
      }
      break;
    default:
      return result;
  }
  return result;
}

void *TSTCellGetFormatOfType(_QWORD *a1, int a2, uint64_t a3)
{
  void *result;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  result = 0;
  switch(a2)
  {
    case 254:
    case 260:
    case 263:
    case 267:
      goto LABEL_29;
    case 255:
      return result;
    case 256:
    case 258:
    case 259:
    case 262:
      if (!a1)
        goto LABEL_29;
      v6 = (void *)a1[19];
      if (v6)
      {
        objc_msgSend(v6, "getFormatStruct");
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(_QWORD *)(a3 + 32) = v25;
      }
      else
      {
        *(_QWORD *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_217C2C278;
      }
      result = (void *)a1[19];
      if (!result)
        return result;
      objc_msgSend(result, "getFormatStruct");
      v14 = v22;
      break;
    case 257:
      if (!a1)
        goto LABEL_29;
      v9 = (void *)a1[21];
      if (v9)
      {
        objc_msgSend(v9, "getFormatStruct");
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(_QWORD *)(a3 + 32) = v25;
      }
      else
      {
        *(_QWORD *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_217C2C278;
      }
      result = (void *)a1[21];
      if (!result)
        return result;
      objc_msgSend(result, "getFormatStruct");
      v14 = v21;
      break;
    case 261:
      if (!a1)
        goto LABEL_29;
      v10 = (void *)a1[25];
      if (v10)
      {
        objc_msgSend(v10, "getFormatStruct");
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(_QWORD *)(a3 + 32) = v25;
      }
      else
      {
        *(_QWORD *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_217C2C278;
      }
      result = (void *)a1[25];
      if (!result)
        return result;
      objc_msgSend(result, "getFormatStruct");
      v14 = v20;
      break;
    case 264:
    case 265:
      if (!a1)
        goto LABEL_29;
      v8 = (void *)a1[27];
      if (v8)
      {
        objc_msgSend(v8, "getFormatStruct");
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(_QWORD *)(a3 + 32) = v25;
      }
      else
      {
        *(_QWORD *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_217C2C278;
      }
      result = (void *)a1[27];
      if (!result)
        return result;
      objc_msgSend(result, "getFormatStruct");
      v14 = v16;
      break;
    case 266:
      if (!a1)
        goto LABEL_29;
      v11 = (void *)a1[33];
      if (v11)
      {
        objc_msgSend(v11, "getFormatStruct");
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(_QWORD *)(a3 + 32) = v25;
      }
      else
      {
        *(_QWORD *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_217C2C278;
      }
      result = (void *)a1[33];
      if (!result)
        return result;
      objc_msgSend(result, "getFormatStruct");
      v14 = v15;
      break;
    case 268:
      if (!a1)
        goto LABEL_29;
      v12 = (void *)a1[23];
      if (v12)
      {
        objc_msgSend(v12, "getFormatStruct");
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(_QWORD *)(a3 + 32) = v25;
      }
      else
      {
        *(_QWORD *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_217C2C278;
      }
      result = (void *)a1[23];
      if (!result)
        return result;
      objc_msgSend(result, "getFormatStruct");
      v14 = v19;
      break;
    case 269:
      if (!a1)
        goto LABEL_29;
      v13 = (void *)a1[31];
      if (v13)
      {
        objc_msgSend(v13, "getFormatStruct");
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(_QWORD *)(a3 + 32) = v25;
      }
      else
      {
        *(_QWORD *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_217C2C278;
      }
      result = (void *)a1[31];
      if (!result)
        return result;
      objc_msgSend(result, "getFormatStruct");
      v14 = v17;
      break;
    case 270:
    case 271:
    case 272:
      if (!a1)
        goto LABEL_29;
      v7 = (void *)a1[29];
      if (v7)
      {
        objc_msgSend(v7, "getFormatStruct");
        *(_OWORD *)a3 = v23;
        *(_OWORD *)(a3 + 16) = v24;
        *(_QWORD *)(a3 + 32) = v25;
      }
      else
      {
        *(_QWORD *)(a3 + 32) = 0;
        *(_OWORD *)a3 = TSUInvalidFormat;
        *(_OWORD *)(a3 + 16) = unk_217C2C278;
      }
      result = (void *)a1[29];
      if (!result)
        return result;
      objc_msgSend(result, "getFormatStruct");
      v14 = v18;
      break;
    default:
      if ((a2 + 1) >= 3 && a2 != -999)
        return result;
LABEL_29:
      result = 0;
      *(_QWORD *)(a3 + 32) = 0;
      *(_OWORD *)a3 = TSUInvalidFormat;
      *(_OWORD *)(a3 + 16) = unk_217C2C278;
      return result;
  }
  return (void *)((v14 - 1) < 0xFFFFFFFE);
}

uint64_t TSTCellSetCellFormatStructBasedOnType(uint64_t result, __int128 *a2, int a3)
{
  uint64_t v4;
  __int128 v5;
  void *v6;
  __int128 v7;
  void *v8;
  __int128 v9;
  void *v10;
  __int128 v11;
  void *v12;
  __int128 v13;
  void *v14;
  __int128 v15;
  void *v16;
  __int128 v17;
  void *v18;
  __int128 v19;
  void *v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v4 = result;
  switch(*(_DWORD *)a2)
  {
    case 0x100:
    case 0x102:
    case 0x103:
    case 0x106:
      v42 = *a2;
      v43 = a2[1];
      v44 = *((_QWORD *)a2 + 4);
      if (result)
      {
        v5 = a2[1];
        v51 = *a2;
        v52 = v5;
        v53 = *((_QWORD *)a2 + 4);
        v6 = *(void **)(result + 152);
        if (v6)
        {
          objc_msgSend(v6, "getFormatStruct");
        }
        else
        {
          v50 = 0;
          v48 = 0u;
          v49 = 0u;
        }
        result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          v45 = v42;
          v46 = v43;
          v47 = v44;
          result = objc_msgSend(objc_alloc(MEMORY[0x24BEB3C88]), "initWithTSUFormatFormatStruct:", &v45);
          *(_QWORD *)(v4 + 152) = result;
          if (a3)
            *(_DWORD *)(v4 + 144) = 0;
        }
      }
      break;
    case 0x101:
      v39 = *a2;
      v40 = a2[1];
      v41 = *((_QWORD *)a2 + 4);
      if (result)
      {
        v11 = a2[1];
        v51 = *a2;
        v52 = v11;
        v53 = *((_QWORD *)a2 + 4);
        v12 = *(void **)(result + 168);
        if (v12)
        {
          objc_msgSend(v12, "getFormatStruct");
        }
        else
        {
          v50 = 0;
          v48 = 0u;
          v49 = 0u;
        }
        result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          v45 = v39;
          v46 = v40;
          v47 = v41;
          result = objc_msgSend(objc_alloc(MEMORY[0x24BEB3C88]), "initWithTSUFormatFormatStruct:", &v45);
          *(_QWORD *)(v4 + 168) = result;
          if (a3)
            *(_DWORD *)(v4 + 160) = 0;
        }
      }
      break;
    case 0x105:
      v36 = *a2;
      v37 = a2[1];
      v38 = *((_QWORD *)a2 + 4);
      if (result)
      {
        v13 = a2[1];
        v51 = *a2;
        v52 = v13;
        v53 = *((_QWORD *)a2 + 4);
        v14 = *(void **)(result + 200);
        if (v14)
        {
          objc_msgSend(v14, "getFormatStruct");
        }
        else
        {
          v50 = 0;
          v48 = 0u;
          v49 = 0u;
        }
        result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          v45 = v36;
          v46 = v37;
          v47 = v38;
          result = objc_msgSend(objc_alloc(MEMORY[0x24BEB3C88]), "initWithTSUFormatFormatStruct:", &v45);
          *(_QWORD *)(v4 + 200) = result;
          if (a3)
            *(_DWORD *)(v4 + 192) = 0;
        }
      }
      break;
    case 0x108:
    case 0x109:
      v24 = *a2;
      v25 = a2[1];
      v26 = *((_QWORD *)a2 + 4);
      if (result)
      {
        v9 = a2[1];
        v51 = *a2;
        v52 = v9;
        v53 = *((_QWORD *)a2 + 4);
        v10 = *(void **)(result + 216);
        if (v10)
        {
          objc_msgSend(v10, "getFormatStruct");
        }
        else
        {
          v50 = 0;
          v48 = 0u;
          v49 = 0u;
        }
        result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          v45 = v24;
          v46 = v25;
          v47 = v26;
          result = objc_msgSend(objc_alloc(MEMORY[0x24BEB3C88]), "initWithTSUFormatFormatStruct:", &v45);
          *(_QWORD *)(v4 + 216) = result;
          if (a3)
            *(_DWORD *)(v4 + 208) = 0;
        }
      }
      break;
    case 0x10A:
      v21 = *a2;
      v22 = a2[1];
      v23 = *((_QWORD *)a2 + 4);
      if (result)
      {
        v15 = a2[1];
        v51 = *a2;
        v52 = v15;
        v53 = *((_QWORD *)a2 + 4);
        v16 = *(void **)(result + 264);
        if (v16)
        {
          objc_msgSend(v16, "getFormatStruct");
        }
        else
        {
          v50 = 0;
          v48 = 0u;
          v49 = 0u;
        }
        result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          v45 = v21;
          v46 = v22;
          v47 = v23;
          result = objc_msgSend(objc_alloc(MEMORY[0x24BEB3C88]), "initWithTSUFormatFormatStruct:", &v45);
          *(_QWORD *)(v4 + 264) = result;
          if (a3)
            *(_DWORD *)(v4 + 256) = 0;
        }
      }
      break;
    case 0x10C:
      v33 = *a2;
      v34 = a2[1];
      v35 = *((_QWORD *)a2 + 4);
      if (result)
      {
        v17 = a2[1];
        v51 = *a2;
        v52 = v17;
        v53 = *((_QWORD *)a2 + 4);
        v18 = *(void **)(result + 184);
        if (v18)
        {
          objc_msgSend(v18, "getFormatStruct");
        }
        else
        {
          v50 = 0;
          v48 = 0u;
          v49 = 0u;
        }
        result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          v45 = v33;
          v46 = v34;
          v47 = v35;
          result = objc_msgSend(objc_alloc(MEMORY[0x24BEB3C88]), "initWithTSUFormatFormatStruct:", &v45);
          *(_QWORD *)(v4 + 184) = result;
          if (a3)
            *(_DWORD *)(v4 + 176) = 0;
        }
      }
      break;
    case 0x10D:
      v27 = *a2;
      v28 = a2[1];
      v29 = *((_QWORD *)a2 + 4);
      if (result)
      {
        v19 = a2[1];
        v51 = *a2;
        v52 = v19;
        v53 = *((_QWORD *)a2 + 4);
        v20 = *(void **)(result + 248);
        if (v20)
        {
          objc_msgSend(v20, "getFormatStruct");
        }
        else
        {
          v50 = 0;
          v48 = 0u;
          v49 = 0u;
        }
        result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          v45 = v27;
          v46 = v28;
          v47 = v29;
          result = objc_msgSend(objc_alloc(MEMORY[0x24BEB3C88]), "initWithTSUFormatFormatStruct:", &v45);
          *(_QWORD *)(v4 + 248) = result;
          if (a3)
            *(_DWORD *)(v4 + 240) = 0;
        }
      }
      break;
    case 0x10E:
    case 0x10F:
    case 0x110:
      v30 = *a2;
      v31 = a2[1];
      v32 = *((_QWORD *)a2 + 4);
      if (result)
      {
        v7 = a2[1];
        v51 = *a2;
        v52 = v7;
        v53 = *((_QWORD *)a2 + 4);
        v8 = *(void **)(result + 232);
        if (v8)
        {
          objc_msgSend(v8, "getFormatStruct");
        }
        else
        {
          v50 = 0;
          v48 = 0u;
          v49 = 0u;
        }
        result = TSUEqualFormatStructs((uint64_t)&v51, (uint64_t)&v48);
        if ((result & 1) == 0)
        {

          v45 = v30;
          v46 = v31;
          v47 = v32;
          result = objc_msgSend(objc_alloc(MEMORY[0x24BEB3C88]), "initWithTSUFormatFormatStruct:", &v45);
          *(_QWORD *)(v4 + 232) = result;
          if (a3)
            *(_DWORD *)(v4 + 224) = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TSTCellMostRecentlySetNumberFormatType(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 96) >> 11) & 3;
}

uint64_t TSTCellMostRecentlySetDateFormatType(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 96) >> 13) & 1;
}

uint64_t TSTCellMostRecentlySetTextFormatType(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 96) >> 14) & 1;
}

uint64_t TSTCellSetFormatFlagsFromFormat(uint64_t result, int *a2, int a3, int a4)
{
  int v4;
  int v5;
  __int16 v6;
  __int16 v7;
  __int16 v8;
  __int16 v9;
  BOOL v10;
  __int16 v11;
  __int16 v12;
  __int16 v13;
  __int16 v14;
  __int16 v15;
  __int16 v16;
  __int16 v17;
  __int16 v18;
  __int16 v19;
  __int16 v20;
  __int16 v21;
  __int16 v22;
  __int16 v23;

  v4 = *a2;
  if (result)
    v5 = *(_DWORD *)(result + 104);
  else
    v5 = -1;
  if (v4 == v5)
  {
    if (a3)
      v6 = 16;
    else
      v6 = 0;
    *(_WORD *)(result + 96) = *(_WORD *)(result + 96) & 0xFFEF | v6;
  }
  switch(v4)
  {
    case 256:
    case 258:
    case 259:
    case 262:
      v7 = *(_WORD *)(result + 96) & 0xFFFE | a3;
      *(_WORD *)(result + 96) = v7;
      if (a4)
      {
        v8 = v7 & 0xE7FF;
        break;
      }
      return result;
    case 257:
      if (a3)
        v12 = 2;
      else
        v12 = 0;
      v13 = *(_WORD *)(result + 96) & 0xFFFD | v12;
      *(_WORD *)(result + 96) = v13;
      if (a4)
      {
        v8 = v13 & 0xE7FF | 0x800;
        break;
      }
      return result;
    case 260:
      if (a4)
      {
        v8 = *(_WORD *)(result + 96) & 0xBFFF;
        break;
      }
      return result;
    case 261:
      if (a3)
        v14 = 8;
      else
        v14 = 0;
      v15 = *(_WORD *)(result + 96) & 0xFFF7 | v14;
      *(_WORD *)(result + 96) = v15;
      if (a4)
      {
        v8 = v15 & 0xDFFF;
        break;
      }
      return result;
    case 264:
    case 265:
      v9 = *(_WORD *)(result + 96) & 0xFFBF;
      v10 = a3 == 0;
      v11 = 64;
      goto LABEL_27;
    case 266:
      v9 = *(_WORD *)(result + 96) & 0xFBFF;
      v10 = a3 == 0;
      v11 = 1024;
      goto LABEL_27;
    case 268:
      v9 = *(_WORD *)(result + 96) & 0xFFFB;
      v10 = a3 == 0;
      v11 = 4;
LABEL_27:
      if (v10)
        v11 = 0;
      v8 = v9 | v11;
      break;
    case 269:
      if (a3)
        v16 = 512;
      else
        v16 = 0;
      v17 = *(_WORD *)(result + 96) & 0xFDFF | v16;
      *(_WORD *)(result + 96) = v17;
      if (!a4)
        return result;
      v8 = v17 & 0xE7FF | 0x1000;
      break;
    case 270:
      if (a3)
        v18 = 256;
      else
        v18 = 0;
      v19 = *(_WORD *)(result + 96) & 0xFEFF | v18;
      *(_WORD *)(result + 96) = v19;
      if (!a4)
        return result;
      v8 = v19 | 0x1800;
      break;
    case 271:
      if (a3)
        v22 = 256;
      else
        v22 = 0;
      v23 = *(_WORD *)(result + 96) & 0xFEFF | v22;
      *(_WORD *)(result + 96) = v23;
      if (!a4)
        return result;
      v8 = v23 | 0x4000;
      break;
    case 272:
      if (a3)
        v20 = 256;
      else
        v20 = 0;
      v21 = *(_WORD *)(result + 96) & 0xFEFF | v20;
      *(_WORD *)(result + 96) = v21;
      if (!a4)
        return result;
      v8 = v21 | 0x2000;
      break;
    default:
      return result;
  }
  *(_WORD *)(result + 96) = v8;
  return result;
}

uint64_t TSTCellSetExplicitFormat(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  _OWORD v7[2];
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;

  v4 = *(_OWORD *)(a2 + 16);
  v9[0] = *(_OWORD *)a2;
  v9[1] = v4;
  v10 = *(_QWORD *)(a2 + 32);
  TSTCellSetFormatClearingID(a1, (uint64_t)v9, 1);
  v5 = *(_OWORD *)(a2 + 16);
  v7[0] = *(_OWORD *)a2;
  v7[1] = v5;
  v8 = *(_QWORD *)(a2 + 32);
  return TSTCellSetFormatFlagsFromFormat(a1, (int *)v7, 1, 1);
}

uint64_t TSTCellSetImplicitFormatForFormulaResult(uint64_t a1, uint64_t a2, int a3)
{
  __int128 v6;
  __int128 v7;
  uint64_t result;
  __int16 v9;
  _OWORD v10[2];
  uint64_t v11;
  _OWORD v12[2];
  uint64_t v13;

  v6 = *(_OWORD *)(a2 + 16);
  v12[0] = *(_OWORD *)a2;
  v12[1] = v6;
  v13 = *(_QWORD *)(a2 + 32);
  TSTCellSetFormatClearingID(a1, (uint64_t)v12, 1);
  v7 = *(_OWORD *)(a2 + 16);
  v10[0] = *(_OWORD *)a2;
  v10[1] = v7;
  v11 = *(_QWORD *)(a2 + 32);
  result = TSTCellSetFormatFlagsFromFormat(a1, (int *)v10, 0, 0);
  if (a3)
    v9 = 0x8000;
  else
    v9 = 0;
  *(_WORD *)(a1 + 96) = v9 & 0x8000 | *(_WORD *)(a1 + 96) & 0x7FFF;
  return result;
}

uint64_t NSStringFromNativeTSTCell(uint64_t result)
{
  int v1;
  void *v2;
  uint64_t v3;

  if (result)
  {
    v1 = *(_DWORD *)(result + 8);
    if (BYTE1(v1) <= 9u)
      __asm { BR              X12 }
    v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *NSStringFromNativeTSTCell(TSTCell *)");
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1081, CFSTR("Impossible cell value type reached."));
    return 0;
  }
  return result;
}

const __CFString *NSStringForUnderlyingValueWithTSTCell(const __CFString *result)
{
  __int128 *p_info;
  const __CFString *v2;
  int info;
  int v4;
  int v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  if (result)
    p_info = (__int128 *)&result[3].info;
  else
    p_info = &TSUInvalidFormat;
  if (result)
  {
    v2 = result;
    info = result->info;
    if (BYTE1(info))
    {
      if (BYTE1(info) != 2)
        return NSStringForEditingWithTSTCell((uint64_t)result);
      v4 = *(_DWORD *)p_info;
      v5 = *((_DWORD *)p_info + 8);
      if ((v4 & 0xFFFFFFFE) != 0x108)
        v5 = v4;
      if ((v5 | 4) == 0x106)
      {
        LODWORD(v8) = 256;
        v9 = ((unint64_t)(*MEMORY[0x24BEB4028] & 7) << 8) | 0xFD;
        if ((result->info & 0xFB00) != 0x200)
        {
          v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
          objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v2, v8, 0, v9);
        }
        return (const __CFString *)TSUFormatStructStringFromDouble();
      }
      else
      {
        return NSStringForEditingWithTSTCell((uint64_t)result);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const __CFString *NSStringForEditingWithTSTCell(uint64_t a1)
{
  __int128 *v2;
  __int128 v3;
  int v4;
  void *v6;
  uint64_t v7;
  _OWORD v8[2];
  uint64_t v9;

  v2 = &TSUInvalidFormat;
  if (a1)
    v2 = (__int128 *)(a1 + 104);
  v3 = v2[1];
  v8[0] = *v2;
  v8[1] = v3;
  v9 = *((_QWORD *)v2 + 4);
  if ((v8[0] & 0xFFFFFFFE) == 0x108)
    TSTCellGetFormatOfType((_QWORD *)a1, v9, (uint64_t)v8);
  if (a1)
  {
    v4 = *(_DWORD *)(a1 + 8);
    if (BYTE1(v4) <= 9u)
      __asm { BR              X12 }
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *NSStringForEditingWithTSTCell(TSTCell *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1243, CFSTR("Impossible cell value type reached."));
    return 0;
  }
  else if (LODWORD(v8[0]) == 258)
  {
    return CFSTR("%");
  }
  else
  {
    return 0;
  }
}

uint64_t TSTCellCustomFormatString(uint64_t a1)
{
  __int128 *v1;
  void *v3;
  uint64_t v4;

  v1 = &TSUInvalidFormat;
  if (a1)
    v1 = (__int128 *)(a1 + 104);
  if ((*(_DWORD *)v1 - 270) < 3)
    return *(_QWORD *)(*((_QWORD *)v1 + 2) + 8);
  v3 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v4 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellCustomFormatString(TSTCell *)");
  objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1253, CFSTR("Can't get a custom format string for a non-custom format."));
  return 0;
}

id TSTCellRichTextStorageForLayout(uint64_t a1)
{
  void *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1 || *(unsigned __int8 *)(a1 + 9) << 8 != 2304)
    return 0;
  v2 = (void *)objc_msgSend(*(id *)(a1 + 72), "storage");
  v3 = v2;
  if (*(_DWORD *)(a1 + 104) == 271)
  {
    v3 = (id)objc_msgSend(v2, "copyWithContext:", objc_msgSend(v2, "context"));
    v4 = *(_QWORD *)(a1 + 120);
    v5 = objc_msgSend(*(id *)(v4 + 8), "rangeOfString:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%C"), (unsigned __int16)*MEMORY[0x24BEB3DA0]));
    v6 = objc_msgSend(*(id *)(v4 + 8), "substringToIndex:", v5);
    v7 = objc_msgSend(*(id *)(v4 + 8), "substringFromIndex:", v5 + 1);
    if (v6)
      objc_msgSend(v3, "insertString:atCharIndex:undoTransaction:", v6, 0, 0);
    if (v7)
      objc_msgSend(v3, "insertString:atCharIndex:undoTransaction:", v7, objc_msgSend(v3, "length"), 0);
  }
  return v3;
}

_QWORD *TSTCellFormatUsesAccountingStyle(_QWORD *result)
{
  __int128 *v1;
  int v2;
  unint64_t v3;
  void *v4;
  uint64_t v5;

  v1 = &TSUInvalidFormat;
  if (result)
    v1 = (__int128 *)(result + 13);
  v2 = *(_DWORD *)v1;
  if ((*(_DWORD *)v1 - 264) >= 2)
  {
    v3 = *((_QWORD *)v1 + 2);
    if (v2 == 270)
    {
      if (v3)
        return (_QWORD *)((*(unsigned __int8 *)(v3 + 56) >> 1) & 1);
      v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSUFormatGetCustomNumberFormatUseAccountingStyle(const TSUFormatStruct)");
      objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Binaries/AlderShared/install/Root/usr/local/include/TSFrameworks/TSUtility/TSUFormatTypes.h"), 635, CFSTR("Custom format is not correctly populated."));
    }
    else if (v2 == 257)
    {
      return (_QWORD *)((v3 >> 12) & 1);
    }
    return 0;
  }
  if (*((_DWORD *)v1 + 8) != 257)
    return 0;
  if (result)
  {
    result = (_QWORD *)result[21];
    if (result)
    {
      objc_msgSend(result, "getFormatStruct", (unsigned __int128)0);
      return 0;
    }
  }
  return result;
}

BOOL p_defaultAlignmentForTableWritingDirection(TSTTableModel *a1)
{
  return -[TSSStyle intValueForProperty:](-[TSTTableModel tableStyle](a1, "tableStyle"), "intValueForProperty:", 798) == 1;
}

_QWORD *TSTCellTextProperties(uint64_t a1, void *a2, unsigned int a3, BOOL *a4, _DWORD *a5, _DWORD *a6, uint64_t *a7)
{
  void *v14;
  void *CellStyleAtCellID;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  _QWORD *result;

  if (a5)
  {
    if (!a1
      || (*(unsigned __int8 *)(a1 + 9) << 8 != 2304
       || (v14 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 72), "storage"), "paragraphStyleAtCharIndex:effectiveRange:", 0, 0)) == 0)&& (v14 = *(void **)(a1 + 56)) == 0)
    {
      v14 = (void *)TSTTableDefaultTextStyleForCellID(a2, a3);
    }
    if (a4)
      goto LABEL_12;
LABEL_10:
    if (!a6 && !a7)
      goto LABEL_29;
    goto LABEL_12;
  }
  v14 = 0;
  if (!a4)
    goto LABEL_10;
LABEL_12:
  if (a1 && (CellStyleAtCellID = *(void **)(a1 + 40)) != 0
    || (CellStyleAtCellID = (void *)TSTTableGetCellStyleAtCellID((uint64_t *)a2, a3, 0)) != 0)
  {
    if (a6)
    {
      *a6 = 1;
      v16 = objc_msgSend(CellStyleAtCellID, "intValueForProperty:", 903);
      if (v16 != 0x80000000)
        *a6 = v16;
    }
    if (a4)
    {
      if ((*a4 = 0, a1) && ((v17 = *(unsigned __int8 *)(a1 + 9), v17 == 3) || v17 == 9)
        || *(_DWORD *)(a1 + 100) && *(_DWORD *)(a1 + 104) == 266)
      {
        v18 = objc_msgSend(CellStyleAtCellID, "intValueForProperty:", 896);
        if (v18 != 0x80000000)
          *a4 = v18 != 0;
      }
    }
    if (a7)
    {
      v19 = objc_msgSend(CellStyleAtCellID, "valueForProperty:", 904);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
        *a7 = v19;
    }
  }
LABEL_29:
  if (a5)
  {
    if (v14)
    {
      *a5 = objc_msgSend((id)objc_msgSend(a2, "tableStyle"), "intValueForProperty:", 798) == 1;
      v20 = objc_msgSend(v14, "intValueForProperty:", 86);
      if (v20 != 0x80000000)
      {
        *a5 = v20;
        if (v20 == 4)
        {
          v21 = objc_msgSend(v14, "intValueForProperty:", 44);
          if (v21 == 1)
          {
            *a5 = 1;
          }
          else if (!v21)
          {
            *a5 = 0;
          }
        }
        else if (v20 == 3 && a4)
        {
          *a4 = 1;
        }
      }
    }
  }
  result = TSTCellFormatUsesAccountingStyle((_QWORD *)a1);
  if ((_DWORD)result)
  {
    if (a5)
      *a5 = 0;
    if (a4)
      *a4 = 0;
  }
  return result;
}

uint64_t TSTCellGetCellFill(_QWORD *a1)
{
  if (a1)
    a1 = (_QWORD *)a1[5];
  return objc_msgSend(a1, "valueForProperty:", 898);
}

void *TSTCellGetCellFillAndIsDefault(_QWORD *a1, void *a2, uint64_t a3, char *a4)
{
  void *v6;
  void *v7;
  char v8;

  if (a1)
    a1 = (_QWORD *)a1[5];
  v6 = (void *)objc_msgSend(a1, "valueForProperty:", 898);
  if (!v6 || (v7 = v6, (objc_msgSend(v6, "isEqual:", a2) & 1) != 0))
  {
    if (!a4)
      return a2;
    v8 = 1;
    v7 = a2;
    goto LABEL_9;
  }
  if (a4)
  {
    v8 = 0;
LABEL_9:
    *a4 = v8;
  }
  return v7;
}

TSTRichTextPayload *TSTCellSetRichTextPayloadClearingIDConvertToPlaintext(TSTRichTextPayload *result, TSTRichTextPayload *a2, int a3, int a4)
{
  uint64_t v7;
  void *v8;
  uint64_t v9;
  int v10;
  int v11;
  TSTRichTextPayload *v12;
  TSTRichTextPayload *v13;

  v7 = (uint64_t)result;
  if (!a2)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetRichTextPayloadClearingIDConvertToPlaintext(TSTCell *, TSTRichTextPayload *, BOOL, BOOL)");
    result = (TSTRichTextPayload *)objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1907, CFSTR("expected rich text payload but didn't get it"));
  }
  v10 = *(_DWORD *)(v7 + 8);
  if ((v10 & 0xFF00) != 0x900 || *(TSTRichTextPayload **)(v7 + 72) != a2)
  {
    if (!a4)
    {
LABEL_8:
      if ((v10 & 0xFF00) == 0x900)
        v11 = *(_DWORD *)(v7 + 64);
      else
        v11 = 0;
      TSTCellClearValue(v7);
      *(_BYTE *)(v7 + 9) = 9;
      result = a2;
      *(_QWORD *)(v7 + 72) = result;
      if (a3)
        *(_DWORD *)(v7 + 64) = 0;
      else
        *(_DWORD *)(v7 + 64) = v11;
      return result;
    }
    if (-[TSTRichTextPayload requiresRichText](a2, "requiresRichText"))
    {
      v10 = *(_DWORD *)(v7 + 8);
      goto LABEL_8;
    }
    TSTCellClearValue(v7);
    *(_BYTE *)(v7 + 9) = 3;
    TSTCellSetStringValueClearingID((TSTCell *)v7, (NSString *)-[TSTRichTextPayload string](a2, "string"), a3);
    result = -[TSWPStorage paragraphStyleAtCharIndex:effectiveRange:](-[TSTRichTextPayload storage](a2, "storage"), "paragraphStyleAtCharIndex:effectiveRange:", 0, 0);
    v12 = *(TSTRichTextPayload **)(v7 + 56);
    if (v12 != result)
    {
      v13 = result;

      result = v13;
      *(_QWORD *)(v7 + 56) = result;
      *(_DWORD *)(v7 + 48) = 0;
    }
  }
  return result;
}

void TSTCellSetStringValueClearingID(TSTCell *a1, NSString *a2, int a3)
{
  int mPrivate;
  NSString *mString;
  int v8;
  uint64_t v9;
  __int16 v10;
  void *v11;
  uint64_t v12;

  if (!a1 || (mPrivate = (int)a1->mPrivate, (mPrivate & 0xFF00) == 0))
  {
    TSTCellClearValue((uint64_t)a1);
    mPrivate = *(_DWORD *)&a1->mPrivate & 0xFFFF00FF | 0x300;
    *(_DWORD *)&a1->mPrivate = mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0x300)
  {
    mString = a1->mPrivate.mValue.mString.mString;
    if (mString != a2)
    {

      a1->mPrivate.mValue.mString.mString = a2;
      v8 = HIWORD(*(_DWORD *)&a1->mPrivate);
      v9 = -[NSString rangeOfCharacterFromSet:](a2, "rangeOfCharacterFromSet:", objc_msgSend(MEMORY[0x24BDD14A8], "newlineCharacterSet"));
      v10 = v8 | 1;
      if (v9 == 0x7FFFFFFFFFFFFFFFLL)
        v10 = v8 & 0xFFFE;
      *((_WORD *)&a1->mPrivate + 1) = v10;
      if (a3)
        a1->mPrivate.mValue.mString.mID = 0;
    }
  }
  else
  {
    v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetStringValueClearingID(TSTCell *, NSString *, BOOL)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1003, CFSTR("can't set string on non-string cell: %p"), a1);
  }
}

TSDCommentStorage *TSTCellSetCommentStorageClearingID(TSDCommentStorage *result, TSDCommentStorage *a2, int a3)
{
  TSDCommentStorage *v5;
  void *v6;
  uint64_t v7;
  TSDCommentStorage *v8;

  v5 = result;
  if (!a2)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetCommentStorageClearingID(TSTCell *, TSDCommentStorage *, BOOL)");
    result = (TSDCommentStorage *)objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1952, CFSTR("expected cell comment but didn't get it"));
  }
  v8 = (TSDCommentStorage *)*((_QWORD *)v5 + 11);
  if (v8 != a2)
  {

    result = a2;
    *((_QWORD *)v5 + 11) = result;
    if (a3)
      *((_DWORD *)v5 + 20) = 0;
  }
  return result;
}

uint64_t TSTCellCoerceCellToFormat(uint64_t a1, int a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t result;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  _DWORD v13[2];
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a1)
    return TSTCellCoerceEmptyCellToFormat(a1, a2);
  v4 = *(_DWORD *)(a1 + 8);
  if ((v4 & 0xFF00) == 0)
    return TSTCellCoerceEmptyCellToFormat(a1, a2);
  v5 = BYTE1(v4) - 2;
  v6 = *(_DWORD *)(a1 + 104);
  switch(v5)
  {
    case 0:
      if ((v6 & 0xFFFFFFFC) != 0x100 && (v6 - 262) >= 6 && (v6 - 269) >= 2)
        goto LABEL_23;
      break;
    case 1:
    case 7:
      if (v6 > 259)
      {
        if (v6 != 260 && v6 != 271)
          goto LABEL_23;
      }
      else if ((v6 + 1) >= 3 && v6 != -999)
      {
        goto LABEL_23;
      }
      break;
    case 3:
      if (v6 != 261 && v6 != 272)
        goto LABEL_23;
      break;
    case 4:
      if (v6 != 1 && v6 != 263)
        goto LABEL_23;
      break;
    case 5:
      if (v6 != 268)
      {
LABEL_23:
        v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTCellCoerceCellToFormat(TSTCell *, TSUFormatType)");
        objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 1987, CFSTR("Attempting to coerce a cell with mismatched format and value types"));
        v10 = 0;
        v11 = -1;
        v12 = 0;
        switch(*(_BYTE *)(a1 + 9))
        {
          case 2:
            v10 = 0;
            v12 = ((unint64_t)(*MEMORY[0x24BEB4028] & 7) << 8) | 0xFD;
            v11 = 256;
            break;
          case 3:
          case 9:
            v10 = 0;
            v12 = 0;
            v11 = 260;
            break;
          case 4:
          case 8:
            break;
          case 5:
            v12 = TSUDefaultDateTimeFormat();
            v10 = 0;
            v11 = 261;
            break;
          case 6:
            v10 = 0;
            v12 = 0;
            v11 = 1;
            break;
          case 7:
            v12 = ((unint64_t)*MEMORY[0x24BEB4018] << 32) | 4;
            v10 = 0x1000000001;
            v11 = 268;
            break;
          default:
            v12 = 0;
            break;
        }
        v13[0] = v11;
        v13[1] = 0;
        v14 = v10;
        v15 = v12;
        v16 = 0;
        v17 = 0;
        TSTCellSetImplicitFormat(a1, (uint64_t)v13);
      }
      break;
    default:
      break;
  }
  switch(a2)
  {
    case 256:
      result = TSTCellCoerceCellToDecimalFormat(a1);
      break;
    case 257:
      result = TSTCellCoerceCellToCurrencyFormat(a1);
      break;
    case 258:
      result = TSTCellCoerceCellToPercentageFormat(a1);
      break;
    case 259:
      result = TSTCellCoerceCellToScientificFormat(a1);
      break;
    case 260:
      result = TSTCellCoerceCellToTextFormat(a1);
      break;
    case 261:
      result = TSTCellCoerceCellToDateTimeFormat(a1);
      break;
    case 262:
      result = TSTCellCoerceCellToFractionFormat(a1);
      break;
    case 263:
      result = TSTCellCoerceCellToCheckboxFormat(a1);
      break;
    case 264:
      result = p_TSTCellCoerceCellToControlFormat(a1, 264);
      break;
    case 265:
      result = p_TSTCellCoerceCellToControlFormat(a1, 265);
      break;
    case 267:
      result = TSTCellCoerceCellToRatingFormat(a1);
      break;
    case 268:
      result = TSTCellCoerceCellToDurationFormat(a1);
      break;
    case 269:
      result = TSTCellCoerceCellToBaseFormat(a1);
      break;
    case 270:
      result = TSTCellCoerceCellToCustomNumberFormat(a1);
      break;
    case 271:
      result = TSTCellCoerceCellToCustomTextFormat(a1);
      break;
    case 272:
      result = TSTCellCoerceCellToCustomDateTimeFormat(a1);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

BOOL TSTCellCoerceEmptyCellToFormat(uint64_t a1, int a2)
{
  int v4;
  unint64_t v5;
  int v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  double v10;
  unint64_t v11;
  __CFString *v13;
  uint64_t v14;
  _DWORD v15[2];
  unint64_t v16;
  uint64_t v17;
  __int128 v18;
  _QWORD v19[5];
  __int128 v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;

  if (a1)
    v4 = *(_DWORD *)(a1 + 104);
  else
    v4 = -1;
  if (v4 != a2)
  {
    v5 = 0;
    v6 = 0;
    v24 = 0uLL;
    v7 = -1;
    v8 = 0;
    v9 = 0;
    switch(a2)
    {
      case 254:
      case 266:
      case 270:
      case 271:
      case 272:
        goto LABEL_11;
      case 255:
        break;
      case 256:
        if ((TSTCellCoerceCellToDecimalFormat(a1) & 1) != 0)
          return v4 != a2;
        v6 = 0;
        v8 = 0;
        v5 = 0;
        v9 = ((unint64_t)(*MEMORY[0x24BEB4028] & 7) << 8) | 0xFD;
        v7 = 256;
        break;
      case 257:
        if ((TSTCellCoerceCellToCurrencyFormat(a1) & 1) != 0)
          return v4 != a2;
        v13 = TSUDefaultFormatStructCurrency();
        v9 = v14;
        v8 = v13 & 0xFF000000;
        v5 = (unint64_t)v13 & 0xFFFFFFFF00000000;
        v6 = v13 & 0xFFFFFF;
        v7 = 257;
        break;
      case 258:
        if ((TSTCellCoerceCellToPercentageFormat(a1) & 1) != 0)
          return v4 != a2;
        v6 = 0;
        v8 = 0;
        v5 = 0;
        v9 = ((unint64_t)(*MEMORY[0x24BEB4028] & 7) << 8) | 0xFD;
        v7 = 258;
        break;
      case 259:
        if ((TSTCellCoerceCellToScientificFormat(a1) & 1) != 0)
          return v4 != a2;
        v6 = 0;
        v8 = 0;
        v5 = 0;
        v9 = ((unint64_t)(*MEMORY[0x24BEB4028] & 7) << 8) | 0xFD;
        v7 = 259;
        break;
      case 260:
        v6 = 0;
        v8 = 0;
        v5 = 0;
        v9 = 0;
        v7 = 260;
        break;
      case 261:
        v9 = TSUDefaultDateTimeFormat();
        v6 = 0;
        v8 = 0;
        v5 = 0;
        v7 = 261;
        break;
      case 262:
        if ((TSTCellCoerceCellToFractionFormat(a1) & 1) != 0)
          return v4 != a2;
        v8 = 0;
        v5 = 0;
        v9 = 0;
        v6 = *MEMORY[0x24BEB4020];
        v7 = 262;
        break;
      case 263:
        TSTCellClearValue(a1);
        v6 = 0;
        v8 = 0;
        v5 = 0;
        v9 = 0;
        *(_BYTE *)(a1 + 9) = 6;
        *(_QWORD *)(a1 + 16) = 0;
        v7 = 263;
        break;
      case 264:
      case 265:
        TSTCellClearValue(a1);
        *(_BYTE *)(a1 + 9) = 2;
        v10 = 50.0;
        if (a2 == 264)
          v10 = 1.0;
        *(double *)(a1 + 16) = v10;
        v24 = xmmword_217C2C2A0;
        v19[3] = 0;
        v19[4] = 0;
        v11 = ((unint64_t)(*MEMORY[0x24BEB4028] & 7) << 8) | 0xFD;
        v20 = 0x100uLL;
        v21 = v11;
        v22 = 0;
        v23 = 0;
        TSTCellSetCellFormatStructBasedOnType(a1, &v20, 1);
        v19[0] = 256;
        v19[1] = 0;
        v19[2] = v11;
        TSTCellSetFormatFlagsFromFormat(a1, (int *)v19, 1, 1);
        v6 = 0;
        v8 = 0;
        v9 = 0x4059000000000000;
        v5 = 0x3FF0000000000000;
        goto LABEL_12;
      case 267:
        TSTCellClearValue(a1);
        v6 = 0;
        v8 = 0;
        v5 = 0;
        v9 = 0;
        *(_BYTE *)(a1 + 9) = 2;
        *(_QWORD *)(a1 + 16) = 0;
        v7 = 267;
        break;
      case 268:
        v8 = 0;
        v9 = ((unint64_t)*MEMORY[0x24BEB4018] << 32) | 4;
        v7 = 268;
        v5 = 0x1000000000;
        v6 = 1;
        break;
      case 269:
        if ((TSTCellCoerceCellToBaseFormat(a1) & 1) != 0)
          return v4 != a2;
        v8 = 0;
        v5 = 0;
        v9 = 0;
        if (*MEMORY[0x24BEB4010])
          v6 = 65546;
        else
          v6 = 10;
        v7 = 269;
        break;
      default:
        if ((a2 + 1) >= 3)
        {
          v8 = 0;
          v9 = 0;
          if (a2 != -999)
            break;
        }
LABEL_11:
        v6 = 0;
        v8 = 0;
        v5 = 0;
        v9 = 0;
LABEL_12:
        v7 = a2;
        break;
    }
    v15[0] = v7;
    v15[1] = 0;
    v16 = v5 | v8 | v6;
    v17 = v9;
    v18 = v24;
    TSTCellSetImplicitFormat(a1, (uint64_t)v15);
  }
  return v4 != a2;
}

uint64_t TSTCellCoerceCellToDecimalFormat(uint64_t result)
{
  uint64_t v1;
  int v2;
  unsigned int v3;
  __int16 v4;
  int v5;
  int v6;
  double v8;
  int v9;
  int v10;
  double v12;
  int v13;
  double v15;
  int v16;
  void *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  _QWORD v25[5];
  int v26;
  double v27;

  v27 = 0.0;
  if (result)
  {
    v1 = result;
    result = 0;
    v2 = (*MEMORY[0x24BEB4028] & 7) << 8;
    v3 = v2 | 0xFD;
    v4 = *(_WORD *)(v1 + 120);
    switch(*(_DWORD *)(v1 + 104))
    {
      case 0x101:
        v3 = v4 & 0xF00 | 0xFD;
        goto LABEL_29;
      case 0x102:
        v3 = v4 & 0xFFF;
        goto LABEL_3;
      case 0x103:
        v3 = *(_WORD *)(v1 + 120) | v2;
LABEL_29:
        v16 = *(_DWORD *)(v1 + 8);
        if ((v16 & 0xFB00) != 0x200)
        {
          v6 = BYTE1(v16);
          if (v6 != 7)
            goto LABEL_31;
        }
        goto LABEL_8;
      case 0x104:
      case 0x10F:
        v9 = *(unsigned __int8 *)(v1 + 9);
        if (*(_BYTE *)(v1 + 9))
        {
          if (v9 == 9)
          {
            objc_msgSend(*(id *)(v1 + 72), "string");
          }
          else if (v9 != 3)
          {
            v23 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v24 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
            objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v24, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), v1);
          }
        }
        v26 = -999;
        if (TSUGetNumberValueAndTypeFromString())
        {
          v3 = v2 | 0xFD;
          goto LABEL_34;
        }
        return 0;
      case 0x106:
      case 0x107:
      case 0x108:
      case 0x109:
      case 0x10D:
      case 0x10E:
LABEL_3:
        v5 = *(_DWORD *)(v1 + 8);
        v6 = BYTE1(v5);
        if ((v5 & 0xFB00) == 0x200 || BYTE1(v5) == 7)
        {
LABEL_8:
          v8 = *(double *)(v1 + 16);
        }
        else
        {
LABEL_31:
          v8 = 0.0;
          if (v6)
          {
            v17 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v18 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
        }
        v27 = v8;
        goto LABEL_34;
      case 0x10B:
        v10 = *(_DWORD *)(v1 + 8);
        if ((v10 & 0xFB00) != 0x200 && BYTE1(v10) != 7)
        {
          if (BYTE1(v10))
          {
            v19 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v20 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v19, "handleFailureInFunction:file:lineNumber:description:", v20, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
LABEL_50:
          v27 = 0.0;
          goto LABEL_34;
        }
        v12 = *(double *)(v1 + 16);
        v27 = v12;
        if (v12 > 5.0)
        {
          v27 = 5.0;
          goto LABEL_34;
        }
        if (v12 < 0.0)
          goto LABEL_50;
LABEL_34:
        v25[0] = 256;
        v25[1] = 0;
        v25[2] = v3;
        v25[3] = 0;
        v25[4] = 0;
        TSTCellSetImplicitFormat(v1, (uint64_t)v25);
        if (*(_BYTE *)(v1 + 9))
        {
          TSTCellClearValue(v1);
          *(_BYTE *)(v1 + 9) = 2;
          *(double *)(v1 + 16) = v27;
        }
        result = 1;
        break;
      case 0x10C:
        v13 = *(_DWORD *)(v1 + 8);
        if ((v13 & 0xFB00) == 0x200 || BYTE1(v13) == 7)
        {
          v15 = *(double *)(v1 + 16);
        }
        else
        {
          v15 = 0.0;
          if (BYTE1(v13))
          {
            v21 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v22 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
        }
        v27 = v15 / 86400.0;
        goto LABEL_34;
      default:
        return result;
    }
  }
  return result;
}

uint64_t TSTCellCoerceCellToCurrencyFormat(uint64_t a1)
{
  const __CFLocale *v2;
  __CFString *Value;
  __CFString *v4;
  int DecimalInfoForCurrencyCode;
  __CFString *v6;
  __int16 v7;
  uint64_t v8;
  __int16 v9;
  unsigned __int16 v10;
  CFStringRef v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  void *v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  int v35;
  __int16 v36;
  double v37;
  __int16 v38;
  void *v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  _QWORD v46[3];
  __int128 v47;
  int32_t v48;
  __int128 v49;
  CFStringRef currencyCode;
  uint64_t v51;
  int32_t defaultFractionDigits;

  currencyCode = 0;
  v51 = 0;
  v49 = 0uLL;
  v2 = (const __CFLocale *)TSUGetCurrentLocale();
  Value = (__CFString *)CFLocaleGetValue(v2, (CFLocaleKey)*MEMORY[0x24BDBD3E0]);
  if (Value)
    v4 = Value;
  else
    v4 = CFSTR("USD");
  defaultFractionDigits = 0;
  DecimalInfoForCurrencyCode = CFNumberFormatterGetDecimalInfoForCurrencyCode(v4, &defaultFractionDigits, 0);
  v6 = v4;
  if (DecimalInfoForCurrencyCode)
    v7 = defaultFractionDigits;
  else
    v7 = 2;
  if (a1)
  {
    v8 = 0;
    v9 = *MEMORY[0x24BEB4028];
    v10 = v7 & 0xF8FF | ((*MEMORY[0x24BEB4028] & 7) << 8);
    v11 = v6;
    v12 = *(_QWORD *)(a1 + 120);
    switch(*(_DWORD *)(a1 + 104))
    {
      case 0x100:
      case 0x102:
        v18 = *(_DWORD *)(a1 + 8);
        if ((v18 & 0xFB00) == 0x200 || (v19 = BYTE1(v18), v19 == 7))
        {
          v20 = *(_QWORD *)(a1 + 16);
        }
        else
        {
          v20 = 0;
          if (v19)
          {
            v21 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v22 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a1);
          }
        }
        v51 = v20;
        v10 = v12 & 0xF00 | v7;
        goto LABEL_56;
      case 0x103:
      case 0x106:
      case 0x107:
      case 0x108:
      case 0x109:
      case 0x10D:
        v13 = *(_DWORD *)(a1 + 8);
        if ((v13 & 0xFB00) == 0x200 || (v14 = BYTE1(v13), v14 == 7))
        {
          v15 = *(_QWORD *)(a1 + 16);
        }
        else
        {
          v15 = 0;
          if (v14)
          {
            v16 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v17 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a1);
          }
        }
        v51 = v15;
        goto LABEL_56;
      case 0x104:
      case 0x10F:
        v23 = *(unsigned __int8 *)(a1 + 9);
        if (*(_BYTE *)(a1 + 9))
        {
          if (v23 == 9)
          {
            objc_msgSend(*(id *)(a1 + 72), "string");
          }
          else if (v23 != 3)
          {
            v33 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v34 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
            objc_msgSend(v33, "handleFailureInFunction:file:lineNumber:description:", v34, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), a1);
          }
        }
        defaultFractionDigits = -999;
        if (!TSUGetNumberValueAndTypeFromString() || defaultFractionDigits == -999)
          goto LABEL_44;
        if (defaultFractionDigits == 1)
        {
          v48 = 0;
          v35 = CFNumberFormatterGetDecimalInfoForCurrencyCode(currencyCode, &v48, 0);
          v36 = v48;
          if (v48 >= 0xFF)
            v36 = 255;
          if (!v35)
            v36 = 2;
          v10 = v36 | ((v9 & 7) << 8);
          v11 = currencyCode;
        }
        goto LABEL_56;
      case 0x10B:
        v24 = *(_DWORD *)(a1 + 8);
        if ((v24 & 0xFB00) != 0x200)
        {
          v25 = BYTE1(v24);
          if (v25 != 7)
          {
            if (v25)
            {
              v26 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
              v27 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
              objc_msgSend(v26, "handleFailureInFunction:file:lineNumber:description:", v27, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a1);
            }
LABEL_55:
            v51 = 0;
            goto LABEL_56;
          }
        }
        v37 = *(double *)(a1 + 16);
        v51 = *(_QWORD *)&v37;
        if (v37 > 5.0)
        {
          v51 = 0x4014000000000000;
          goto LABEL_56;
        }
        if (v37 < 0.0)
          goto LABEL_55;
LABEL_56:
        v46[0] = 257;
        v46[1] = v11;
        v46[2] = v10;
        v47 = v49;
        TSTCellSetImplicitFormat(a1, (uint64_t)v46);
        if (*(_BYTE *)(a1 + 9))
        {
          TSTCellClearValue(a1);
          *(_BYTE *)(a1 + 9) = 2;
          *(_QWORD *)(a1 + 16) = v51;
        }
        v8 = 1;
        break;
      case 0x10E:
        v28 = *(_DWORD *)(a1 + 8);
        if ((v28 & 0xFB00) == 0x200 || (v29 = BYTE1(v28), v29 == 7))
        {
          v30 = *(_QWORD *)(a1 + 16);
        }
        else
        {
          v30 = 0;
          if (v29)
          {
            v31 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v32 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v31, "handleFailureInFunction:file:lineNumber:description:", v32, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a1);
          }
        }
        v51 = v30;
        if (v12)
        {
          if (*(_QWORD *)(v12 + 16))
            v11 = *(CFStringRef *)(v12 + 16);
          v38 = (*(_BYTE *)(v12 + 56) & 3) << 11;
        }
        else
        {
          v39 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v40 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSUFormatGetCustomNumberFormatCurrencyCode(const TSUFormatStruct)");
          objc_msgSend(v39, "handleFailureInFunction:file:lineNumber:description:", v40, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Binaries/AlderShared/install/Root/usr/local/include/TSFrameworks/TSUtility/TSUFormatTypes.h"), 604, CFSTR("Custom format is not correctly populated."));
          v41 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v42 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSUFormatGetCustomNumberFormatUseAccountingStyle(const TSUFormatStruct)");
          objc_msgSend(v41, "handleFailureInFunction:file:lineNumber:description:", v42, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Binaries/AlderShared/install/Root/usr/local/include/TSFrameworks/TSUtility/TSUFormatTypes.h"), 635, CFSTR("Custom format is not correctly populated."));
          v43 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v44 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSUFormatGetCustomNumberFormatShowThousandsSeparator(const TSUFormatStruct)");
          objc_msgSend(v43, "handleFailureInFunction:file:lineNumber:description:", v44, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Binaries/AlderShared/install/Root/usr/local/include/TSFrameworks/TSUtility/TSUFormatTypes.h"), 625, CFSTR("Custom format is not correctly populated."));
          v38 = 0;
        }
        v10 |= v38;
        goto LABEL_56;
      default:
        break;
    }
  }
  else
  {
LABEL_44:
    v8 = 0;
  }
  if (currencyCode)

  return v8;
}

uint64_t TSTCellCoerceCellToPercentageFormat(uint64_t result)
{
  uint64_t v1;
  int v2;
  unsigned int v3;
  __int16 v4;
  int v5;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v13;
  int v14;
  uint64_t v16;
  int v17;
  uint64_t v19;
  int v20;
  double v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  _QWORD v33[5];
  int v34;
  uint64_t v35;

  v35 = 0;
  if (result)
  {
    v1 = result;
    result = 0;
    v2 = (*MEMORY[0x24BEB4028] & 7) << 8;
    v3 = v2 | 0xFD;
    v4 = *(_WORD *)(v1 + 120);
    switch(*(_DWORD *)(v1 + 104))
    {
      case 0x100:
        v11 = *(_DWORD *)(v1 + 8);
        if ((v11 & 0xFB00) == 0x200 || BYTE1(v11) == 7)
        {
          v13 = *(_QWORD *)(v1 + 16);
        }
        else
        {
          v13 = 0;
          if (BYTE1(v11))
          {
            v25 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v26 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
        }
        v35 = v13;
        v3 = v4 & 0xFFF;
        goto LABEL_12;
      case 0x101:
        v14 = *(_DWORD *)(v1 + 8);
        if ((v14 & 0xFB00) == 0x200 || BYTE1(v14) == 7)
        {
          v16 = *(_QWORD *)(v1 + 16);
        }
        else
        {
          v16 = 0;
          if (BYTE1(v14))
          {
            v27 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v28 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v27, "handleFailureInFunction:file:lineNumber:description:", v28, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
        }
        v35 = v16;
        v3 = v4 & 0xF00 | 0xFD;
        goto LABEL_12;
      case 0x103:
        v17 = *(_DWORD *)(v1 + 8);
        if ((v17 & 0xFB00) == 0x200 || BYTE1(v17) == 7)
        {
          v19 = *(_QWORD *)(v1 + 16);
        }
        else
        {
          v19 = 0;
          if (BYTE1(v17))
          {
            v29 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v30 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
        }
        v35 = v19;
        v3 = v4 | v2;
        goto LABEL_12;
      case 0x104:
      case 0x10F:
        v10 = *(unsigned __int8 *)(v1 + 9);
        if (*(_BYTE *)(v1 + 9))
        {
          if (v10 == 9)
          {
            objc_msgSend(*(id *)(v1 + 72), "string");
          }
          else if (v10 != 3)
          {
            v23 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v24 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
            objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v24, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), v1);
          }
        }
        v34 = -999;
        if ((TSUGetNumberValueAndTypeFromString() & 1) != 0)
          goto LABEL_12;
        return 0;
      case 0x106:
      case 0x107:
      case 0x108:
      case 0x109:
      case 0x10D:
      case 0x10E:
        v5 = *(_DWORD *)(v1 + 8);
        if ((v5 & 0xFB00) == 0x200 || BYTE1(v5) == 7)
        {
          v7 = *(_QWORD *)(v1 + 16);
        }
        else
        {
          v7 = 0;
          if (BYTE1(v5))
          {
            v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
        }
        v35 = v7;
        goto LABEL_12;
      case 0x10B:
        v20 = *(_DWORD *)(v1 + 8);
        if ((v20 & 0xFB00) != 0x200 && BYTE1(v20) != 7)
        {
          if (BYTE1(v20))
          {
            v31 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v32 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v31, "handleFailureInFunction:file:lineNumber:description:", v32, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
LABEL_62:
          v35 = 0;
          goto LABEL_63;
        }
        v22 = *(double *)(v1 + 16);
        v35 = *(_QWORD *)&v22;
        if (v22 > 5.0)
        {
          v35 = 0x4014000000000000;
          goto LABEL_63;
        }
        if (v22 < 0.0)
          goto LABEL_62;
LABEL_63:
        v3 = v2;
LABEL_12:
        v33[0] = 258;
        v33[1] = 0;
        v33[2] = v3;
        v33[3] = 0;
        v33[4] = 0;
        TSTCellSetImplicitFormat(v1, (uint64_t)v33);
        if (*(_BYTE *)(v1 + 9))
        {
          TSTCellClearValue(v1);
          *(_BYTE *)(v1 + 9) = 2;
          *(_QWORD *)(v1 + 16) = v35;
        }
        result = 1;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t TSTCellCoerceCellToDurationFormat(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  double v6;
  int v7;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  void *v12;
  uint64_t v13;
  _QWORD v15[5];
  int v16;
  int v17;
  int v18;
  double v19;

  v19 = 0.0;
  if (!a1)
    return 0;
  v2 = 0;
  if ((*(_DWORD *)(a1 + 104) - 256) <= 0xF)
  {
    v3 = 1 << *(_BYTE *)(a1 + 104);
    if ((v3 & 0x4301) != 0)
    {
      v4 = *(_DWORD *)(a1 + 8);
      if ((v4 & 0xFB00) == 0x200 || BYTE1(v4) == 7)
      {
        v6 = *(double *)(a1 + 16) * 86400.0;
      }
      else
      {
        v6 = 0.0;
        if (BYTE1(v4))
        {
          v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
          objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a1);
        }
      }
      v19 = v6;
      goto LABEL_18;
    }
    if ((v3 & 0x8010) != 0)
    {
      v7 = *(unsigned __int8 *)(a1 + 9);
      if (*(_BYTE *)(a1 + 9))
      {
        if (v7 == 9)
        {
          objc_msgSend(*(id *)(a1 + 72), "string");
        }
        else if (v7 != 3)
        {
          v12 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v13 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
          objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), a1);
        }
      }
      v17 = 1;
      v18 = 0;
      if (TSUDurationFormatterTimeIntervalFromStringWithCompactStyleStartUnit())
      {
        TSUDurationFormatterMaxDurationUnitInUnits();
        TSUDurationFormatterMinDurationUnitInUnits();
LABEL_18:
        v10 = (unint64_t)*MEMORY[0x24BEB4018] << 32;
        v2 = 1;
        TSUDurationFormatterDurationUnitsNecessaryToFullyDisplayDuration();
        v11 = TSUDurationFormatterMaxDurationUnitInUnits();
        v15[0] = 268;
        v15[1] = (TSUDurationFormatterMinDurationUnitInUnits() << 32) | 1;
        v15[2] = v10 | v11;
        v15[3] = 0;
        v15[4] = 0;
        TSTCellSetImplicitFormat(a1, (uint64_t)v15);
        TSTCellClearValue(a1);
        *(_BYTE *)(a1 + 9) = 7;
        *(double *)(a1 + 16) = v19;
        return v2;
      }
      v16 = -999;
      TSUGetNumberValueAndTypeFromString();
      return 0;
    }
  }
  return v2;
}

uint64_t TSTCellCoerceCellToScientificFormat(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  int v3;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  uint64_t v12;
  int v13;
  int v14;
  double v16;
  void *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  _QWORD v23[5];
  int v24;
  uint64_t v25;

  v25 = 0;
  if (result)
  {
    v1 = result;
    result = 0;
    v2 = ((*MEMORY[0x24BEB4028] & 7) << 8) | 0xFD;
    switch(*(_DWORD *)(v1 + 104))
    {
      case 0x100:
      case 0x102:
        v8 = (*MEMORY[0x24BEB4028] & 7) << 8;
        v9 = *(unsigned __int8 *)(v1 + 120);
        v10 = *(_DWORD *)(v1 + 8);
        if ((v10 & 0xFB00) == 0x200 || BYTE1(v10) == 7)
        {
          v12 = *(_QWORD *)(v1 + 16);
        }
        else
        {
          v12 = 0;
          if (BYTE1(v10))
          {
            v17 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v18 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
        }
        v25 = v12;
        v2 = v9 | v8;
        goto LABEL_41;
      case 0x101:
      case 0x106:
      case 0x107:
      case 0x108:
      case 0x109:
      case 0x10D:
      case 0x10E:
        v3 = *(_DWORD *)(v1 + 8);
        if ((v3 & 0xFB00) == 0x200 || BYTE1(v3) == 7)
        {
          v5 = *(_QWORD *)(v1 + 16);
        }
        else
        {
          v5 = 0;
          if (BYTE1(v3))
          {
            v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
        }
        v25 = v5;
        goto LABEL_41;
      case 0x104:
      case 0x10F:
        v13 = *(unsigned __int8 *)(v1 + 9);
        if (*(_BYTE *)(v1 + 9))
        {
          if (v13 == 9)
          {
            objc_msgSend(*(id *)(v1 + 72), "string");
          }
          else if (v13 != 3)
          {
            v19 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v20 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
            objc_msgSend(v19, "handleFailureInFunction:file:lineNumber:description:", v20, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), v1);
          }
        }
        v24 = -999;
        if ((TSUGetNumberValueAndTypeFromString() & 1) != 0)
          goto LABEL_41;
        return 0;
      case 0x10B:
        v14 = *(_DWORD *)(v1 + 8);
        if ((v14 & 0xFB00) != 0x200 && BYTE1(v14) != 7)
        {
          if (BYTE1(v14))
          {
            v21 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v22 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
LABEL_40:
          v25 = 0;
          goto LABEL_41;
        }
        v16 = *(double *)(v1 + 16);
        v25 = *(_QWORD *)&v16;
        if (v16 > 5.0)
        {
          v25 = 0x4014000000000000;
          goto LABEL_41;
        }
        if (v16 < 0.0)
          goto LABEL_40;
LABEL_41:
        v23[0] = 259;
        v23[1] = 0;
        v23[2] = v2;
        v23[3] = 0;
        v23[4] = 0;
        TSTCellSetImplicitFormat(v1, (uint64_t)v23);
        if (*(_BYTE *)(v1 + 9))
        {
          TSTCellClearValue(v1);
          *(_BYTE *)(v1 + 9) = 2;
          *(_QWORD *)(v1 + 16) = v25;
        }
        result = 1;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t TSTCellCoerceCellToFractionFormat(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  void *v11;
  uint64_t v12;
  double v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;

  v23 = 0;
  if (!result)
    return result;
  v1 = result;
  result = 0;
  if ((*(_DWORD *)(v1 + 104) - 256) > 0xF)
    return result;
  if (((1 << *(_BYTE *)(v1 + 104)) & 0x638F) != 0)
  {
    v2 = *(_DWORD *)(v1 + 8);
    if ((v2 & 0xFB00) == 0x200 || BYTE1(v2) == 7)
    {
      v4 = *(_QWORD *)(v1 + 16);
    }
    else
    {
      v4 = 0;
      if (BYTE1(v2))
      {
        v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
        objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
      }
    }
    v23 = v4;
    goto LABEL_13;
  }
  if (((1 << *(_BYTE *)(v1 + 104)) & 0x8010) != 0)
  {
    v8 = *(unsigned __int8 *)(v1 + 9);
    if (*(_BYTE *)(v1 + 9))
    {
      if (v8 == 9)
      {
        objc_msgSend(*(id *)(v1 + 72), "string");
      }
      else if (v8 != 3)
      {
        v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
        objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), v1);
      }
    }
    v22 = -999;
    if ((TSUGetNumberValueAndTypeFromString() & 1) == 0)
      return 0;
    goto LABEL_13;
  }
  if (*(_DWORD *)(v1 + 104) != 267)
    return result;
  v9 = *(_DWORD *)(v1 + 8);
  if ((v9 & 0xFB00) != 0x200)
  {
    v10 = BYTE1(v9);
    if (v10 != 7)
    {
      if (v10)
      {
        v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
        objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
      }
      goto LABEL_35;
    }
  }
  v13 = *(double *)(v1 + 16);
  v23 = *(_QWORD *)&v13;
  if (v13 <= 5.0)
  {
    if (v13 < 0.0)
LABEL_35:
      v23 = 0;
  }
  else
  {
    v23 = 0x4014000000000000;
  }
LABEL_13:
  v7 = *MEMORY[0x24BEB4020];
  v16 = 262;
  v17 = v7;
  v18 = 0;
  v20 = 0;
  v19 = 0;
  v21 = 0;
  TSTCellSetImplicitFormat(v1, (uint64_t)&v16);
  if (*(_BYTE *)(v1 + 9))
  {
    TSTCellClearValue(v1);
    *(_BYTE *)(v1 + 9) = 2;
    *(_QWORD *)(v1 + 16) = v23;
  }
  return 1;
}

uint64_t TSTCellCoerceCellToRatingFormat(uint64_t result)
{
  uint64_t v1;
  int v2;
  void *v4;
  uint64_t v5;
  int v6;
  __CFString *v7;
  int v8;
  int v9;
  double v10;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  __int128 v18;
  __int128 v19;
  int v20;
  int v21;
  double v22;

  v22 = 0.0;
  if (!result)
    return result;
  v1 = result;
  result = 0;
  if ((*(_DWORD *)(v1 + 104) - 256) > 0xF)
    return result;
  if (((1 << *(_BYTE *)(v1 + 104)) & 0x634F) != 0)
  {
    v2 = *(_DWORD *)(v1 + 8);
    if ((v2 & 0xFB00) != 0x200 && BYTE1(v2) != 7)
    {
      if (BYTE1(v2))
      {
        v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
        objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
      }
      goto LABEL_19;
    }
    v22 = *(double *)(v1 + 16);
    if (v22 <= 5.0)
    {
      if (v22 < 0.0)
LABEL_19:
        v22 = 0.0;
    }
    else
    {
      v22 = 5.0;
    }
LABEL_20:
    v17 = 267;
    v18 = 0u;
    v19 = 0u;
    v20 = 0;
    TSTCellSetImplicitFormat(v1, (uint64_t)&v17);
    if (*(_BYTE *)(v1 + 9))
    {
      TSTCellClearValue(v1);
      *(_BYTE *)(v1 + 9) = 2;
      *(double *)(v1 + 16) = v22;
    }
    return 1;
  }
  if (((1 << *(_BYTE *)(v1 + 104)) & 0x8010) == 0)
  {
    if (*(_DWORD *)(v1 + 104) != 263)
      return result;
    v8 = *(_DWORD *)(v1 + 8);
    if ((v8 & 0xFB00) == 0x200 || (v9 = BYTE1(v8), v9 == 7))
    {
      v10 = *(double *)(v1 + 16);
    }
    else
    {
      v10 = 0.0;
      if (v9)
      {
        v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
        objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
      }
    }
    v22 = v10;
    goto LABEL_20;
  }
  v6 = *(unsigned __int8 *)(v1 + 9);
  if (*(_BYTE *)(v1 + 9))
  {
    if (v6 == 9)
    {
      v7 = (__CFString *)objc_msgSend(*(id *)(v1 + 72), "string");
    }
    else if (v6 == 3)
    {
      v7 = *(__CFString **)(v1 + 24);
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
      objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), v1);
      v7 = 0;
    }
  }
  else
  {
    v7 = &stru_24D82FEB0;
  }
  v21 = -999;
  TSUGetNumberValueAndTypeFromString();
  if ((unint64_t)-[__CFString length](v7, "length") > 4)
  {
    v15 = 5;
  }
  else
  {
    v15 = -[__CFString length](v7, "length");
    if (v15 < 1)
    {
      v15 = 0;
LABEL_39:
      v22 = (double)v15;
      goto LABEL_20;
    }
  }
  v16 = 0;
  while (-[__CFString characterAtIndex:](v7, "characterAtIndex:", v16) == 42)
  {
    if (v15 == ++v16)
      goto LABEL_39;
  }
  return 0;
}

uint64_t TSTCellCoerceCellToCheckboxFormat(uint64_t result)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  _BOOL4 v6;
  void *v7;
  uint64_t v8;
  double v9;
  int v10;
  __CFString *v11;
  int v12;
  int v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v18;
  int v19;
  void *v20;
  uint64_t v21;
  int v22;
  __int128 v23;
  __int128 v24;
  int v25;
  int v26;
  uint64_t v27;

  v27 = 0;
  if (!result)
    return result;
  v1 = result;
  v2 = *(_DWORD *)(result + 104);
  if ((v2 - 256) > 0xF)
    goto LABEL_22;
  v3 = 1 << *(_DWORD *)(result + 104);
  if ((v3 & 0x6B4F) == 0)
  {
    if ((v3 & 0x8010) != 0)
    {
      v10 = *(unsigned __int8 *)(result + 9);
      if (*(_BYTE *)(result + 9))
      {
        if (v10 == 9)
        {
          v11 = (__CFString *)objc_msgSend(*(id *)(result + 72), "string");
        }
        else if (v10 == 3)
        {
          v11 = *(__CFString **)(result + 24);
        }
        else
        {
          v16 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v17 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
          objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), v1);
          v11 = 0;
        }
      }
      else
      {
        v11 = &stru_24D82FEB0;
      }
      v18 = (void *)-[__CFString uppercaseString](v11, "uppercaseString");
      if ((objc_msgSend(v18, "isEqual:", objc_msgSend((id)TSTBundle(), "localizedStringForKey:value:table:", CFSTR("TRUE"), &stru_24D82FEB0, CFSTR("TSTables"))) & 1) != 0)
      {
        v6 = 1;
        goto LABEL_13;
      }
      if ((objc_msgSend(v18, "isEqual:", objc_msgSend((id)TSTBundle(), "localizedStringForKey:value:table:", CFSTR("FALSE"), &stru_24D82FEB0, CFSTR("TSTables"))) & 1) != 0)goto LABEL_12;
      v19 = *(unsigned __int8 *)(v1 + 9);
      if (*(_BYTE *)(v1 + 9))
      {
        if (v19 == 9)
        {
          objc_msgSend(*(id *)(v1 + 72), "string");
        }
        else if (v19 != 3)
        {
          v20 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v21 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
          objc_msgSend(v20, "handleFailureInFunction:file:lineNumber:description:", v21, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), v1);
        }
      }
      v26 = -999;
      TSUGetNumberValueAndTypeFromString();
      return 0;
    }
LABEL_22:
    if (v2 == 1)
    {
      v12 = *(_DWORD *)(result + 8);
      if ((v12 & 0xFF00) == 0x600)
      {
        v13 = BYTE1(v12);
        if (v13)
        {
          if (v13 == 6)
            goto LABEL_9;
          v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTCellBoolValue(TSTCell *)");
          objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 925, CFSTR("can't get BOOL value from non-BOOL cell: %p"), v1);
        }
LABEL_12:
        v6 = 0;
        goto LABEL_13;
      }
    }
    return 0;
  }
  v4 = *(_DWORD *)(result + 8);
  if ((v4 & 0xFB00) != 0x200 && BYTE1(v4) != 7)
  {
    if (BYTE1(v4))
    {
      v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
      objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
    }
    goto LABEL_12;
  }
LABEL_9:
  v6 = *(double *)(result + 16) != 0.0;
LABEL_13:
  v22 = 263;
  v23 = 0u;
  v24 = 0u;
  v25 = 0;
  TSTCellSetImplicitFormat(v1, (uint64_t)&v22);
  TSTCellClearValue(v1);
  *(_BYTE *)(v1 + 9) = 6;
  v9 = 0.0;
  if (v6)
    v9 = 1.0;
  *(double *)(v1 + 16) = v9;
  return 1;
}

uint64_t TSTCellCoerceCellToTextFormat(uint64_t a1)
{
  uint64_t v2;
  NSString *v3;
  int v5;
  double v7;
  double v8;
  int v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  int v15;
  __int128 v16;
  __int128 v17;
  int v18;

  if (!a1)
    return 0;
  v2 = 0;
  if ((*(_DWORD *)(a1 + 104) - 256) > 0x10)
    return v2;
  if (((1 << *(_BYTE *)(a1 + 104)) & 0x177EF) != 0)
  {
    v3 = (NSString *)NSStringFromNativeTSTCell(a1);
    if (v3)
      goto LABEL_5;
    return 0;
  }
  v5 = *(_DWORD *)(a1 + 8);
  if (*(_DWORD *)(a1 + 104) == 267)
  {
    if ((*(_DWORD *)(a1 + 8) & 0xFB00) == 0x200 || BYTE1(v5) == 7)
    {
      v7 = *(double *)(a1 + 16);
      v3 = (NSString *)objc_msgSend(MEMORY[0x24BDD16A8], "stringWithString:", &stru_24D82FEB0);
      if (v7 > 0.0)
      {
        v8 = 0.0;
        do
        {
          -[NSString appendString:](v3, "appendString:", CFSTR("*"));
          v8 = v8 + 1.0;
        }
        while (v8 < v7);
      }
      goto LABEL_5;
    }
    if (BYTE1(v5))
    {
      v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
      objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a1);
    }
    v12 = objc_msgSend(MEMORY[0x24BDD16A8], "stringWithString:", &stru_24D82FEB0);
    goto LABEL_32;
  }
  if (*(_DWORD *)(a1 + 104) != 271)
    return v2;
  if ((*(_DWORD *)(a1 + 8) & 0xFF00) == 0x900)
    goto LABEL_13;
  v9 = BYTE1(v5);
  if (!v9)
  {
    v3 = (NSString *)&stru_24D82FEB0;
    goto LABEL_5;
  }
  if (v9 == 9)
  {
    v12 = objc_msgSend(*(id *)(a1 + 72), "string");
LABEL_32:
    v3 = (NSString *)v12;
    goto LABEL_5;
  }
  if (v9 != 3)
  {
    v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
    objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), a1);
LABEL_13:
    v3 = 0;
    goto LABEL_5;
  }
  v3 = *(NSString **)(a1 + 24);
LABEL_5:
  v15 = 260;
  v16 = 0u;
  v17 = 0u;
  v18 = 0;
  TSTCellSetImplicitFormat(a1, (uint64_t)&v15);
  if (!v3)
    return 1;
  TSTCellClearValue(a1);
  *(_BYTE *)(a1 + 9) = 3;
  v2 = 1;
  TSTCellSetStringValueClearingID((TSTCell *)a1, v3, 1);
  return v2;
}

uint64_t TSTCellCoerceCellToStepperFormat(uint64_t a1)
{
  return p_TSTCellCoerceCellToControlFormat(a1, 264);
}

uint64_t TSTCellCoerceCellToSliderFormat(uint64_t a1)
{
  return p_TSTCellCoerceCellToControlFormat(a1, 265);
}

uint64_t TSTCellCoerceCellToMultipleChoiceListFormat()
{
  return 0;
}

uint64_t TSTCellCoerceCellToDateTimeFormat(uint64_t a1)
{
  uint64_t v2;
  int v3;
  void *v4;
  int v5;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  id v13;
  _QWORD v15[3];
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  id v19;

  v19 = 0;
  v17 = 0uLL;
  v2 = TSUDefaultDateTimeFormat();
  v18 = v2;
  if (!a1)
    goto LABEL_16;
  v3 = *(_DWORD *)(a1 + 104);
  if (v3 == 260)
    goto LABEL_5;
  if (v3 == 272)
  {
    v6 = v2;
    if (*(_BYTE *)(a1 + 9))
    {
      if (*(_BYTE *)(a1 + 9) == 5)
      {
        v7 = *(void **)(a1 + 16);
LABEL_27:
        v8 = v7;
        goto LABEL_28;
      }
      v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSDate *TSTCellDateValue(TSTCell *)");
      objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1021, CFSTR("can't get date value from a non-date cell: %p"), a1);
    }
    v7 = 0;
    goto LABEL_27;
  }
  if (v3 != 271)
  {
    a1 = 0;
LABEL_16:
    v8 = 0;
    goto LABEL_31;
  }
LABEL_5:
  if (TSTCellHasFormatOfType((_QWORD *)a1, 261))
  {
    v4 = *(void **)(a1 + 200);
    if (v4)
      objc_msgSend(v4, "getFormatStruct");
  }
  v5 = *(unsigned __int8 *)(a1 + 9);
  if (*(_BYTE *)(a1 + 9))
  {
    if (v5 == 9)
    {
      objc_msgSend(*(id *)(a1 + 72), "string");
    }
    else if (v5 != 3)
    {
      v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
      objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), a1);
    }
  }
  v8 = (id)TSUCreateDateFromStringWithPreferredFormat();
  if (!v8)
  {
    a1 = 0;
    goto LABEL_31;
  }
  if (objc_msgSend(v19, "length"))
  {
    v6 = (uint64_t)v19;
    v18 = (uint64_t)v19;
  }
  else
  {
    v6 = v18;
  }
LABEL_28:
  v15[0] = 261;
  v15[1] = 0;
  v15[2] = v6;
  v16 = v17;
  TSTCellSetImplicitFormat(a1, (uint64_t)v15);
  TSTCellClearValue(a1);
  *(_BYTE *)(a1 + 9) = 5;
  v13 = *(id *)(a1 + 16);
  if (v13 != v8)
  {

    *(_QWORD *)(a1 + 16) = v8;
  }
  a1 = 1;
LABEL_31:
  if (v19)

  return a1;
}

uint64_t TSTCellCoerceCellToCustomNumberFormat(uint64_t result)
{
  uint64_t v1;
  int v2;
  double v4;
  void *v5;
  uint64_t v6;
  int v7;
  int v8;
  double v10;
  int v11;
  double v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  int v20;
  __int128 v21;
  __int128 v22;
  int v23;
  int v24;
  double v25;

  v25 = 0.0;
  if (result)
  {
    v1 = result;
    result = 0;
    switch(*(_DWORD *)(v1 + 104))
    {
      case 0x100:
      case 0x101:
      case 0x102:
      case 0x103:
      case 0x106:
      case 0x107:
      case 0x108:
      case 0x109:
      case 0x10D:
      case 0x10E:
        v2 = *(_DWORD *)(v1 + 8);
        if ((v2 & 0xFB00) == 0x200 || BYTE1(v2) == 7)
        {
          v4 = *(double *)(v1 + 16);
        }
        else
        {
          v4 = 0.0;
          if (BYTE1(v2))
          {
            v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
        }
        v25 = v4;
        goto LABEL_12;
      case 0x104:
      case 0x10F:
        v7 = *(unsigned __int8 *)(v1 + 9);
        if (*(_BYTE *)(v1 + 9))
        {
          if (v7 == 9)
          {
            objc_msgSend(*(id *)(v1 + 72), "string");
          }
          else if (v7 != 3)
          {
            v16 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v17 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
            objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), v1);
          }
        }
        v24 = -999;
        if ((TSUGetNumberValueAndTypeFromString() & 1) != 0)
          return 0;
        else
          return 0;
      case 0x10B:
        v11 = *(_DWORD *)(v1 + 8);
        if ((v11 & 0xFB00) != 0x200 && BYTE1(v11) != 7)
        {
          if (BYTE1(v11))
          {
            v18 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v19 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v18, "handleFailureInFunction:file:lineNumber:description:", v19, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
LABEL_45:
          v25 = 0.0;
          goto LABEL_12;
        }
        v13 = *(double *)(v1 + 16);
        v25 = v13;
        if (v13 > 5.0)
        {
          v25 = 5.0;
          goto LABEL_12;
        }
        if (v13 < 0.0)
          goto LABEL_45;
LABEL_12:
        v20 = 270;
        v21 = 0u;
        v22 = 0u;
        v23 = 0;
        TSTCellSetImplicitFormat(v1, (uint64_t)&v20);
        if (*(_BYTE *)(v1 + 9))
        {
          TSTCellClearValue(v1);
          *(_BYTE *)(v1 + 9) = 2;
          *(double *)(v1 + 16) = v25;
        }
        result = 1;
        break;
      case 0x10C:
        v8 = *(_DWORD *)(v1 + 8);
        if ((v8 & 0xFB00) == 0x200 || BYTE1(v8) == 7)
        {
          v10 = *(double *)(v1 + 16);
        }
        else
        {
          v10 = 0.0;
          if (BYTE1(v8))
          {
            v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
            objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v1);
          }
        }
        v25 = v10 / 86400.0;
        goto LABEL_12;
      default:
        return result;
    }
  }
  return result;
}

uint64_t TSTCellCoerceCellToCustomTextFormat(uint64_t a1)
{
  NSString *v2;
  uint64_t v3;
  int v5;
  void *v6;
  uint64_t v7;
  int v8;
  __int128 v9;
  __int128 v10;
  int v11;

  if (!a1 || (*(_DWORD *)(a1 + 104) - 256) > 0x10)
    return 0;
  if (((1 << *(_BYTE *)(a1 + 104)) & 0x17FEF) != 0)
  {
LABEL_4:
    v2 = (NSString *)NSStringFromNativeTSTCell(a1);
    if (v2)
      goto LABEL_5;
    return 0;
  }
  v5 = BYTE1(*(_DWORD *)(a1 + 8));
  if (*(_DWORD *)(a1 + 104) == 260)
  {
    if (v5 != 9)
      goto LABEL_4;
  }
  else if (v5 != 9)
  {
    if (!BYTE1(*(_DWORD *)(a1 + 8)))
    {
      v2 = (NSString *)&stru_24D82FEB0;
      goto LABEL_5;
    }
    if (v5 == 3)
    {
      v2 = *(NSString **)(a1 + 24);
      goto LABEL_5;
    }
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), a1);
  }
  v2 = 0;
LABEL_5:
  v8 = 271;
  v9 = 0u;
  v10 = 0u;
  v11 = 0;
  TSTCellSetImplicitFormat(a1, (uint64_t)&v8);
  if (!v2)
    return 1;
  TSTCellClearValue(a1);
  *(_BYTE *)(a1 + 9) = 3;
  v3 = 1;
  TSTCellSetStringValueClearingID((TSTCell *)a1, v2, 1);
  return v3;
}

uint64_t TSTCellCoerceCellToCustomDateTimeFormat(uint64_t result)
{
  uint64_t v1;
  int v2;
  const void *v3;
  void *v4;
  int v5;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  int v11;
  __int128 v12;
  __int128 v13;
  int v14;
  uint64_t v15;

  if (!result)
    return result;
  v1 = result;
  result = 0;
  v2 = *(_DWORD *)(v1 + 104);
  if (v2 > 270)
  {
    if (v2 != 271)
    {
      if (v2 != 272)
        return result;
      goto LABEL_8;
    }
  }
  else if (v2 != 260)
  {
    if (v2 != 261)
      return result;
LABEL_8:
    if (*(_BYTE *)(v1 + 9))
    {
      if (*(_BYTE *)(v1 + 9) == 5)
      {
        v3 = 0;
        v4 = *(void **)(v1 + 16);
LABEL_21:
        v11 = 272;
        v12 = 0u;
        v13 = 0u;
        v14 = 0;
        TSTCellSetImplicitFormat(v1, (uint64_t)&v11);
        TSTCellClearValue(v1);
        *(_BYTE *)(v1 + 9) = 5;
        v10 = *(void **)(v1 + 16);
        if (v10 != v4)
        {

          *(_QWORD *)(v1 + 16) = v4;
        }
        if (v3)
          CFRelease(v3);
        return 1;
      }
      v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSDate *TSTCellDateValue(TSTCell *)");
      objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1021, CFSTR("can't get date value from a non-date cell: %p"), v1);
    }
    v4 = 0;
    v3 = 0;
    goto LABEL_21;
  }
  v5 = *(unsigned __int8 *)(v1 + 9);
  if (*(_BYTE *)(v1 + 9))
  {
    if (v5 == 9)
    {
      objc_msgSend(*(id *)(v1 + 72), "string");
    }
    else if (v5 != 3)
    {
      v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
      objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), v1);
    }
  }
  v15 = 0;
  result = TSUCreateDateFromString();
  v4 = (void *)result;
  v3 = (const void *)result;
  if (result)
    goto LABEL_21;
  return result;
}

uint64_t TSTCellCoerceCellToBaseFormat(uint64_t result)
{
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  __int16 v8;
  int v9;
  int v10;
  int v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  unsigned int v16;
  double v17;
  uint64_t v18;
  __int16 v19;
  char v20;
  int v21;
  char v22;
  __int16 v23;
  uint64_t v24;
  _QWORD v25[2];
  int v26;
  uint64_t v27;

  v27 = 0;
  if (*MEMORY[0x24BEB4010])
    v1 = 65546;
  else
    v1 = 10;
  if (!result)
    return result;
  v2 = result;
  result = 0;
  if ((*(_DWORD *)(v2 + 104) - 256) > 0xF)
    return result;
  if (((1 << *(_BYTE *)(v2 + 104)) & 0x43CF) != 0)
  {
    v3 = *(_DWORD *)(v2 + 8);
    if ((v3 & 0xFB00) == 0x200 || BYTE1(v3) == 7)
    {
      v5 = *(_QWORD *)(v2 + 16);
    }
    else
    {
      v5 = 0;
      if (BYTE1(v3))
      {
        v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
        objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v2);
      }
    }
    v8 = 0;
    v27 = v5;
    goto LABEL_16;
  }
  if (((1 << *(_BYTE *)(v2 + 104)) & 0x8010) != 0)
  {
    v9 = *(unsigned __int8 *)(v2 + 9);
    if (*(_BYTE *)(v2 + 9))
    {
      if (v9 == 9)
      {
        objc_msgSend(*(id *)(v2 + 72), "string");
      }
      else if (v9 != 3)
      {
        v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
        objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), v2);
      }
    }
    v26 = -999;
    if (!TSUGetNumberValueAndTypeFromString())
      return 0;
    v16 = TSUNumberOfDecimalPlacesInNumericString();
    LOBYTE(v8) = v16;
    if (v16 >= (unint64_t)(unsigned __int16)*MEMORY[0x24BEB4030])
      v8 = *MEMORY[0x24BEB4030];
    v8 = v8;
    goto LABEL_16;
  }
  if (*(_DWORD *)(v2 + 104) != 267)
    return result;
  v10 = *(_DWORD *)(v2 + 8);
  if ((v10 & 0xFB00) != 0x200)
  {
    v11 = BYTE1(v10);
    if (v11 != 7)
    {
      if (v11)
      {
        v12 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v13 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
        objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), v2);
      }
LABEL_41:
      v8 = 0;
      v27 = 0;
      goto LABEL_16;
    }
  }
  v17 = *(double *)(v2 + 16);
  v27 = *(_QWORD *)&v17;
  if (v17 <= 5.0)
  {
    if (v17 >= 0.0)
    {
      v8 = 0;
      goto LABEL_16;
    }
    goto LABEL_41;
  }
  v8 = 0;
  v27 = 0x4014000000000000;
LABEL_16:
  v18 = 269;
  v19 = v1;
  v20 = BYTE2(v1);
  v21 = 0;
  v22 = 0;
  v23 = v8;
  v25[0] = 0;
  v24 = 0;
  *(_QWORD *)((char *)v25 + 6) = 0;
  TSTCellSetImplicitFormat(v2, (uint64_t)&v18);
  if (*(_BYTE *)(v2 + 9))
  {
    TSTCellClearValue(v2);
    *(_BYTE *)(v2 + 9) = 2;
    *(_QWORD *)(v2 + 16) = v27;
  }
  return 1;
}

__CFString *TSUDefaultFormatStructCurrency(void)
{
  const __CFLocale *v0;
  __CFString *Value;
  __CFString *v2;
  int32_t defaultFractionDigits;

  v0 = (const __CFLocale *)TSUGetCurrentLocale();
  Value = (__CFString *)CFLocaleGetValue(v0, (CFLocaleKey)*MEMORY[0x24BDBD3E0]);
  if (Value)
    v2 = Value;
  else
    v2 = CFSTR("USD");
  defaultFractionDigits = 0;
  CFNumberFormatterGetDecimalInfoForCurrencyCode(v2, &defaultFractionDigits, 0);
  return v2;
}

uint64_t p_TSTCellCoerceCellToControlFormat(uint64_t a1, int a2)
{
  uint64_t v3;
  int v4;
  int v6;
  uint64_t v8;
  int v9;
  double v10;
  void *v11;
  uint64_t v12;
  int v13;
  int v15;
  int v16;
  int v18;
  double v20;
  double v21;
  void *v22;
  uint64_t v23;
  unsigned int v24;
  double v25;
  double v26;
  double v27;
  int v28;
  void *v30;
  uint64_t v31;
  double v32;
  double v33;
  void *v34;
  uint64_t v35;
  unsigned int v36;
  void *v37;
  uint64_t v38;
  int v40[2];
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _DWORD v49[2];
  double v50;
  double v51;
  double v52;
  int v53;
  int v54;

  if (!a1)
    return 0;
  v3 = 0;
  v4 = *(_DWORD *)(a1 + 104);
  switch(v4)
  {
    case 256:
    case 257:
    case 258:
    case 259:
    case 262:
    case 269:
      v6 = *(_DWORD *)(a1 + 8);
      if ((v6 & 0xFB00) == 0x200 || BYTE1(v6) == 7)
      {
        v8 = 0;
        v9 = 0;
        v10 = *(double *)(a1 + 16);
      }
      else
      {
        v10 = 0.0;
        if (BYTE1(v6))
        {
          v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
          objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a1);
        }
        v8 = 0;
        v9 = 0;
      }
      goto LABEL_49;
    case 260:
    case 271:
      v3 = 0;
      if (!TSTCellCoerceTextCellToBestNumberFormatUsingSpares(a1, 0))
        return v3;
      v13 = *(_DWORD *)(a1 + 8);
      if ((v13 & 0xFB00) == 0x200 || BYTE1(v13) == 7)
      {
        v10 = *(double *)(a1 + 16);
      }
      else
      {
        v10 = 0.0;
        if (BYTE1(v13))
        {
          v30 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v31 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
          objc_msgSend(v30, "handleFailureInFunction:file:lineNumber:description:", v31, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a1);
        }
      }
      v8 = 0;
      v9 = 0;
      v4 = *(_DWORD *)(a1 + 104);
LABEL_49:
      v24 = -1;
      goto LABEL_50;
    case 263:
    case 270:
      v15 = *(_DWORD *)(a1 + 8);
      v16 = BYTE1(v15);
      if ((v15 & 0xFB00) != 0x200 && BYTE1(v15) != 7)
        goto LABEL_37;
      v10 = *(double *)(a1 + 16);
      goto LABEL_39;
    case 264:
    case 265:
      if (v4 == a2)
        return 0;
      v25 = *(double *)(a1 + 112);
      v26 = *(double *)(a1 + 120);
      v27 = *(double *)(a1 + 128);
      v4 = *(_DWORD *)(a1 + 136);
      v28 = *(_DWORD *)(a1 + 8);
      if ((v28 & 0xFB00) == 0x200 || BYTE1(v28) == 7)
      {
        v9 = 0;
        v8 = 0;
        v10 = *(double *)(a1 + 16);
      }
      else
      {
        v10 = 0.0;
        if (BYTE1(v28))
        {
          v34 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v35 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
          objc_msgSend(v34, "handleFailureInFunction:file:lineNumber:description:", v35, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a1);
        }
        v9 = 0;
        v8 = 0;
      }
      v24 = -1;
      goto LABEL_70;
    case 267:
      v18 = *(_DWORD *)(a1 + 8);
      v16 = BYTE1(v18);
      if ((v18 & 0xFB00) == 0x200 || BYTE1(v18) == 7)
      {
        v20 = *(double *)(a1 + 16);
        v21 = 0.0;
        if (v20 >= 0.0)
          v21 = *(double *)(a1 + 16);
        if (v20 <= 5.0)
          v10 = v21;
        else
          v10 = 5.0;
      }
      else
      {
LABEL_37:
        v10 = 0.0;
        if (v16)
        {
          v22 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v23 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
          objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a1);
        }
      }
LABEL_39:
      v8 = ((*MEMORY[0x24BEB4028] & 7) << 8) | 0xFD;
      v9 = 1;
      v24 = 256;
      v4 = 256;
LABEL_50:
      TSTCellClearValue(a1);
      *(_BYTE *)(a1 + 9) = 2;
      if (v10 <= -1.0)
      {
        v25 = round(v10);
        v26 = 0.0;
        v27 = 1.0;
        v10 = v25;
      }
      else if (v10 >= 0.0)
      {
        v25 = 0.0;
        v27 = 1.0;
        if (v10 == 0.0)
        {
          v26 = 1.0;
          v10 = 1.0;
        }
        else if (v10 <= 0.0 || v10 >= 1.0)
        {
          if (v10 >= 1.0)
          {
            v26 = round(v10);
            v10 = v26;
          }
          else
          {
            v26 = 100.0;
            v25 = 1.0;
          }
        }
        else
        {
          v33 = 2.0;
          if (v4 != 262)
            v33 = (double)(unint64_t)TSUNumberOfDecimalPlacesInValue();
          v26 = 1.0;
          v27 = 1.0 / __exp10(v33);
        }
      }
      else
      {
        v32 = 2.0;
        if (v4 != 262)
          v32 = (double)(unint64_t)TSUNumberOfDecimalPlacesInValue();
        v25 = -1.0;
        v26 = 0.0;
        v27 = 1.0 / __exp10(v32);
      }
LABEL_70:
      v36 = *(_DWORD *)(a1 + 8);
      if ((v36 & 0xFF00) == 0)
      {
        TSTCellClearValue(a1);
        v36 = *(_DWORD *)(a1 + 8) & 0xFFFF00FF | 0x200;
        *(_DWORD *)(a1 + 8) = v36;
      }
      if ((v36 & 0xFF00) == 0x200)
      {
        *(double *)(a1 + 16) = v10;
      }
      else
      {
        v37 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v38 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
        objc_msgSend(v37, "handleFailureInFunction:file:lineNumber:description:", v38, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 912, CFSTR("can't set value to non-value cell: %p"), a1);
      }
      v49[0] = a2;
      v49[1] = 0;
      v50 = v25;
      v51 = v26;
      v52 = v27;
      v53 = v4;
      v54 = 0;
      TSTCellSetImplicitFormat(a1, (uint64_t)v49);
      if (v9)
      {
        v45 = v24;
        v46 = v8;
        v47 = 0;
        v48 = 0;
        v3 = 1;
        TSTCellSetCellFormatStructBasedOnType(a1, &v45, 1);
        v40[0] = v24;
        v40[1] = 0;
        v41 = 0;
        v42 = v8;
        v43 = 0;
        v44 = 0;
        TSTCellSetFormatFlagsFromFormat(a1, v40, 1, 1);
      }
      else
      {
        v3 = 1;
      }
      break;
    default:
      return v3;
  }
  return v3;
}

uint64_t TSTCellCoerceTextCellToBestNumberFormatUsingSpares(uint64_t a1, unsigned int a2)
{
  int v4;
  int v5;
  NSString *v6;
  int v7;
  void *v8;
  uint64_t v9;
  NSString *v10;
  void *v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  const __CFLocale *v15;
  __CFString *Value;
  __CFString *v17;
  int DecimalInfoForCurrencyCode;
  __CFString *v19;
  uint64_t v20;
  unint64_t v21;
  __int16 v22;
  int v23;
  int *v24;
  _OWORD *v25;
  unint64_t v26;
  __int16 v27;
  int v28;
  unint64_t v29;
  unint64_t v30;
  __int16 v31;
  void *v33;
  uint64_t v34;
  _OWORD v35[2];
  uint64_t v36;
  int v37;
  __int128 v38;
  __int128 v39;
  int v40;
  _OWORD v41[2];
  uint64_t v42;
  _OWORD v43[2];
  uint64_t v44;
  _OWORD v45[2];
  uint64_t v46;
  _OWORD v47[2];
  uint64_t v48;
  _OWORD v49[2];
  uint64_t v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  id v54;
  uint64_t v55;
  int v56;
  int32_t defaultFractionDigits;

  if (!a1 || (v4 = *(_DWORD *)(a1 + 104), v4 != 271) && v4 != 260)
  {
    v7 = 0;
    return v7 | a2;
  }
  v5 = *(unsigned __int8 *)(a1 + 9);
  if (*(_BYTE *)(a1 + 9))
  {
    if (v5 == 9)
    {
      v6 = (NSString *)objc_msgSend(*(id *)(a1 + 72), "string");
    }
    else if (v5 == 3)
    {
      v6 = *(NSString **)(a1 + 24);
    }
    else
    {
      v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
      objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), a1);
      v6 = 0;
    }
  }
  else
  {
    v6 = (NSString *)&stru_24D82FEB0;
  }
  v10 = -[NSString stringByTrimmingCharactersInSet:](v6, "stringByTrimmingCharactersInSet:", objc_msgSend(MEMORY[0x24BDD14A8], "whitespaceAndNewlineCharacterSet"));
  v56 = -999;
  v54 = 0;
  v55 = 0;
  if (TSTCellHasFormatOfType((_QWORD *)a1, 257))
  {
    v11 = *(void **)(a1 + 168);
    if (v11)
      objc_msgSend(v11, "getFormatStruct");
  }
  v7 = TSUGetNumberValueAndTypeFromStringWithCurrencyCode();
  if (v7)
  {
    v12 = TSUFormatTypeFromTSUNumberValueType();
    TSTCellClearValue(a1);
    *(_BYTE *)(a1 + 9) = 2;
    v13 = v55;
    *(_QWORD *)(a1 + 16) = v55;
    v53 = 0;
    v51 = 0u;
    v52 = 0u;
    LODWORD(v51) = -1;
    v14 = *(_WORD *)(a1 + 96);
    if (v12 == 257)
    {
      if ((v14 & 2) == 0)
      {
        v15 = (const __CFLocale *)TSUGetCurrentLocale();
        Value = (__CFString *)CFLocaleGetValue(v15, (CFLocaleKey)*MEMORY[0x24BDBD3E0]);
        if (Value)
          v17 = Value;
        else
          v17 = CFSTR("USD");
        defaultFractionDigits = 0;
        DecimalInfoForCurrencyCode = CFNumberFormatterGetDecimalInfoForCurrencyCode(v17, &defaultFractionDigits, 0);
        v19 = v17;
        if (DecimalInfoForCurrencyCode)
          v20 = defaultFractionDigits;
        else
          v20 = 2;
        v21 = v20 & 0xFFFFFFFFFFFFF8FFLL | ((unint64_t)(*MEMORY[0x24BEB4028] & 7) << 8);
        *((_QWORD *)&v51 + 1) = v19;
        *(_QWORD *)&v52 = v21;
        LODWORD(v51) = 257;
        if (v54)
          *((_QWORD *)&v51 + 1) = v54;
        TSUGetCurrentLocale();
        if (TSUIsGroupingSeparatorUsedInNumericString())
        {
          LOWORD(v21) = v21 | 0x800;
          LOWORD(v52) = v21;
        }
        if (-[NSString characterAtIndex:](v10, "characterAtIndex:", 0) == 40)
        {
          LOWORD(v21) = v21 & 0xF8FF | 0x200;
          LOWORD(v52) = v21;
        }
        if (a2)
        {
          v22 = 253;
          if ((v55 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            TSUGetCurrentLocale();
            v23 = TSUNumberOfDecimalPlacesInNumericString();
            if (TSUNumberOfDecimalPlacesInValue() == v23)
              v22 = 253;
            else
              v22 = v23;
          }
          LOWORD(v52) = v21 & 0xFF00 | v22;
        }
        v47[0] = v51;
        v47[1] = v52;
        v48 = v53;
        v24 = (int *)v47;
        goto LABEL_60;
      }
      TSTCellGetFormatOfType((_QWORD *)a1, 257, (uint64_t)&v51);
      if (v54)
        *((_QWORD *)&v51 + 1) = v54;
      v49[0] = v51;
      v49[1] = v52;
      v50 = v53;
      v25 = v49;
LABEL_45:
      TSTCellSetExplicitFormat(a1, (uint64_t)v25);
      goto LABEL_61;
    }
    if ((v14 & 1) != 0)
    {
      TSTCellGetFormatOfType((_QWORD *)a1, v12, (uint64_t)&v51);
      v45[0] = v51;
      v45[1] = v52;
      v46 = v53;
      v25 = v45;
      goto LABEL_45;
    }
    if (v12 == 256)
    {
      if ((v14 & 2) != 0)
      {
        TSTCellGetFormatOfType((_QWORD *)a1, 257, (uint64_t)&v51);
        v43[0] = v51;
        v43[1] = v52;
        v44 = v53;
        v25 = v43;
        goto LABEL_45;
      }
LABEL_47:
      v26 = (unint64_t)(*MEMORY[0x24BEB4028] & 7) << 8;
      v27 = 253;
      *(_QWORD *)&v52 = v26 | 0xFD;
      LODWORD(v51) = v12;
      if ((v13 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        TSUGetCurrentLocale();
        v28 = TSUNumberOfDecimalPlacesInNumericString();
        v29 = TSUNumberOfDecimalPlacesInValue();
        v30 = v29 - 2;
        if (v29 <= 1)
          v30 = 0;
        if (v12 != 258)
          v30 = v29;
        if (v30 == v28)
          v27 = 253;
        else
          v27 = v28;
      }
      v31 = v27 | v26;
      LOWORD(v52) = v27 | v26;
      TSUGetCurrentLocale();
      if (TSUIsGroupingSeparatorUsedInNumericString())
      {
        v31 |= 0x800u;
        LOWORD(v52) = v31;
      }
      if (-[NSString characterAtIndex:](v10, "characterAtIndex:", 0) == 40)
        LOWORD(v52) = v31 & 0xF8FF | 0x200;
      v41[0] = v51;
      v41[1] = v52;
      v42 = v53;
      v24 = (int *)v41;
      goto LABEL_60;
    }
    if ((v12 & 0xFFFFFFFC) == 0x100)
      goto LABEL_47;
    if (v12 == 262)
    {
      if (a2)
      {
        TSTCellClearValue(a1);
        *(_BYTE *)(a1 + 9) = 3;
        TSTCellSetStringValueClearingID((TSTCell *)a1, v6, 1);
        v40 = 0;
        v39 = 0u;
        v38 = 0u;
        v37 = 260;
        v24 = &v37;
      }
      else
      {
        DWORD2(v51) = *MEMORY[0x24BEB4020];
        LODWORD(v51) = 262;
        v36 = v53;
        v35[0] = v51;
        v35[1] = v52;
        v24 = (int *)v35;
      }
LABEL_60:
      TSTCellSetImplicitFormat(a1, (uint64_t)v24);
      goto LABEL_61;
    }
    v33 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v34 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSTCellCoerceTextCellToBestNumberFormatUsingSpares(TSTCell *, BOOL)");
    objc_msgSend(v33, "handleFailureInFunction:file:lineNumber:description:", v34, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.mm"), 3998, CFSTR("unexpected format type"));
  }
LABEL_61:
  if (v54)

  return v7 | a2;
}

BOOL TSTCellCoerceStepperSliderToRootFormatType(_QWORD *a1)
{
  __int128 *v1;
  unsigned int v2;
  _BYTE v5[40];

  v1 = &TSUInvalidFormat;
  if (a1)
    v1 = (__int128 *)(a1 + 13);
  v2 = *(_DWORD *)v1 & 0xFFFFFFFE;
  if (v2 == 264)
  {
    TSTCellGetFormatOfType(a1, *((_DWORD *)v1 + 8), (uint64_t)v5);
    TSTCellSetExplicitFormat((uint64_t)a1, (uint64_t)v5);
  }
  return v2 == 264;
}

uint64_t TSTCellCoerceControlCellToNonControlType(uint64_t result)
{
  int v1;

  if (result)
  {
    v1 = *(_DWORD *)(result + 104);
    if ((v1 - 263) > 4)
    {
      return 0;
    }
    else
    {
      if ((v1 - 264) < 2)
      {
        TSTCellCoerceStepperSliderToRootFormatType((_QWORD *)result);
      }
      else if (v1 == 267)
      {
        TSTCellCoerceCellToDecimalFormat(result);
      }
      else if (v1 == 263)
      {
        TSTCellSetImplicitFormat(result, (uint64_t)&TSUNotSetFormat);
      }
      return 1;
    }
  }
  return result;
}

uint64_t TSTCellHasExplicitFormatOfType(uint64_t a1, int a2)
{
  uint64_t result;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  int v12;

  result = 0;
  switch(a2)
  {
    case 256:
    case 258:
    case 259:
    case 262:
      if (!a1)
        goto LABEL_34;
      v4 = *(void **)(a1 + 152);
      if (!v4)
        goto LABEL_34;
      objc_msgSend(v4, "getFormatStruct");
      if ((v12 - 1) > 0xFFFFFFFD)
        goto LABEL_34;
      result = *(_WORD *)(a1 + 96) & 1;
      break;
    case 257:
      if (!a1)
        goto LABEL_34;
      v7 = *(void **)(a1 + 168);
      if (!v7)
        goto LABEL_34;
      objc_msgSend(v7, "getFormatStruct");
      if ((v12 - 1) > 0xFFFFFFFD)
        goto LABEL_34;
      result = (*(unsigned __int16 *)(a1 + 96) >> 1) & 1;
      break;
    case 261:
      if (!a1)
        goto LABEL_34;
      v8 = *(void **)(a1 + 200);
      if (!v8)
        goto LABEL_34;
      objc_msgSend(v8, "getFormatStruct");
      if ((v12 - 1) > 0xFFFFFFFD)
        goto LABEL_34;
      result = (*(unsigned __int16 *)(a1 + 96) >> 3) & 1;
      break;
    case 264:
    case 265:
      if (!a1)
        goto LABEL_34;
      v6 = *(void **)(a1 + 216);
      if (!v6)
        goto LABEL_34;
      objc_msgSend(v6, "getFormatStruct");
      if ((v12 - 1) > 0xFFFFFFFD)
        goto LABEL_34;
      result = (*(unsigned __int16 *)(a1 + 96) >> 6) & 1;
      break;
    case 266:
      if (!a1)
        goto LABEL_34;
      v9 = *(void **)(a1 + 264);
      if (!v9)
        goto LABEL_34;
      objc_msgSend(v9, "getFormatStruct");
      if ((v12 - 1) > 0xFFFFFFFD)
        goto LABEL_34;
      result = (*(unsigned __int16 *)(a1 + 96) >> 10) & 1;
      break;
    case 268:
      if (!a1)
        goto LABEL_34;
      v10 = *(void **)(a1 + 184);
      if (!v10)
        goto LABEL_34;
      objc_msgSend(v10, "getFormatStruct");
      if ((v12 - 1) > 0xFFFFFFFD)
        goto LABEL_34;
      result = (*(unsigned __int16 *)(a1 + 96) >> 2) & 1;
      break;
    case 269:
      if (!a1)
        goto LABEL_34;
      v11 = *(void **)(a1 + 248);
      if (!v11)
        goto LABEL_34;
      objc_msgSend(v11, "getFormatStruct");
      if ((v12 - 1) > 0xFFFFFFFD)
        goto LABEL_34;
      result = (*(unsigned __int16 *)(a1 + 96) >> 9) & 1;
      break;
    case 270:
    case 271:
    case 272:
      if (a1
        && (v5 = *(void **)(a1 + 232)) != 0
        && (objc_msgSend(v5, "getFormatStruct"), (v12 - 1) <= 0xFFFFFFFD))
      {
        result = HIBYTE(*(unsigned __int16 *)(a1 + 96)) & 1;
      }
      else
      {
LABEL_34:
        result = 0;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TSTCellCoerceCellToFormatUsingSpares(uint64_t a1, int a2)
{
  int v4;
  int HasExplicitFormatOfType;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  int v9;
  int v10;
  int v11;
  double v12;
  void *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  double v17;
  __int128 v18;
  void *v19;
  uint64_t v20;
  unsigned int v21;
  void *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  _OWORD v27[2];
  uint64_t v28;
  _OWORD v29[2];
  uint64_t v30;
  int v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = 0;
  v32 = 0u;
  v33 = 0u;
  v4 = -1;
  LODWORD(v32) = -1;
  if (TSTCellHasFormatOfType((_QWORD *)a1, a2))
  {
    TSTCellGetFormatOfType((_QWORD *)a1, a2, (uint64_t)&v32);
    if ((_DWORD)v32 == a2)
    {
      HasExplicitFormatOfType = TSTCellHasExplicitFormatOfType(a1, a2);
      v4 = a2;
    }
    else
    {
      HasExplicitFormatOfType = 0;
      v34 = 0;
      v32 = TSUInvalidFormat;
      v33 = unk_217C2C278;
    }
  }
  else
  {
    HasExplicitFormatOfType = 0;
  }
  v6 = TSTCellCoerceCellToFormat(a1, a2);
  v7 = v6;
  if (v4 != -1 && (_DWORD)v6)
  {
    if ((a2 & 0xFFFFFFFE) != 0x108)
      goto LABEL_36;
    if ((v34 - 256) <= 6 && ((1 << v34) & 0x4D) != 0)
    {
      if (a1 && (v8 = *(void **)(a1 + 152)) != 0)
      {
        objc_msgSend(v8, "getFormatStruct");
        v9 = v31;
      }
      else
      {
        v9 = -1;
      }
      LODWORD(v34) = v9;
    }
    if (a1)
    {
      v10 = *(_DWORD *)(a1 + 8);
      if ((v10 & 0xFB00) == 0x200 || (v11 = BYTE1(v10), v11 == 7))
      {
        v12 = *(double *)(a1 + 16);
      }
      else
      {
        v12 = 0.0;
        if (v11)
        {
          v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
          objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 897, CFSTR("can't get value from non-value cell: %p"), a1);
        }
      }
    }
    else
    {
      v15 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v16 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSTCellDoubleValue(TSTCell *)");
      objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 889, CFSTR("invalid nil value for '%s'"), "cell");
      v12 = 0.0;
    }
    v17 = *((double *)&v32 + 1);
    v18 = v33;
    if ((v4 & 0xFFFFFFFE) != 0x108)
    {
      v19 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v20 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSUFormatRecomputedControlValue(double, TSUFormatStruct)");
      objc_msgSend(v19, "handleFailureInFunction:file:lineNumber:description:", v20, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Binaries/AlderShared/install/Root/usr/local/include/TSFrameworks/TSUtility/TSUFormatTypes.h"), 779, CFSTR("Expected a stepper or slider format."));
    }
    if (v17 < v12)
    {
      if (*(double *)&v18 <= v12
        || (v17 = v17 + *((double *)&v18 + 1) * round((v12 - v17) / *((double *)&v18 + 1)), v17 > *(double *)&v18))
      {
        v17 = *(double *)&v18;
      }
    }
    if (a1)
    {
      v21 = *(_DWORD *)(a1 + 8);
      if ((v21 & 0xFF00) != 0)
      {
LABEL_34:
        if ((v21 & 0xFF00) != 0x200)
        {
          v24 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v25 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
          objc_msgSend(v24, "handleFailureInFunction:file:lineNumber:description:", v25, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 912, CFSTR("can't set value to non-value cell: %p"), a1);
          if (HasExplicitFormatOfType)
            goto LABEL_37;
          goto LABEL_39;
        }
        *(double *)(a1 + 16) = v17;
LABEL_36:
        if (HasExplicitFormatOfType)
        {
LABEL_37:
          v29[0] = v32;
          v29[1] = v33;
          v30 = v34;
          TSTCellSetExplicitFormat(a1, (uint64_t)v29);
          return v7;
        }
LABEL_39:
        v27[0] = v32;
        v27[1] = v33;
        v28 = v34;
        TSTCellSetImplicitFormat(a1, (uint64_t)v27);
        return v7;
      }
    }
    else
    {
      v22 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v23 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
      objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 904, CFSTR("invalid nil value for '%s'"), "cell");
    }
    TSTCellClearValue(a1);
    v21 = *(_DWORD *)(a1 + 8) & 0xFFFF00FF | 0x200;
    *(_DWORD *)(a1 + 8) = v21;
    goto LABEL_34;
  }
  return v7;
}

uint64_t TSTCellCoerceTextCellToNumberFormatWithSeparatorFixing(uint64_t a1, int a2)
{
  int v4;
  __CFString *v5;
  void *v6;
  uint64_t v7;
  uint64_t result;
  const __CFLocale *v9;
  NSString *v10;
  TSTCell *v11;
  __int128 *p_mFormatType;
  __int16 v13;
  int v14;
  uint64_t v15;
  int v16;
  __int16 v17;
  _BYTE v18[22];

  if (a1 && (v4 = *(unsigned __int8 *)(a1 + 9), *(_BYTE *)(a1 + 9)))
  {
    if (v4 == 9)
    {
      v5 = (__CFString *)objc_msgSend(*(id *)(a1 + 72), "string");
    }
    else if (v4 == 3)
    {
      v5 = *(__CFString **)(a1 + 24);
    }
    else
    {
      v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
      objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 972, CFSTR("can't get string from non-string cell: %p"), a1);
      v5 = 0;
    }
  }
  else
  {
    v5 = &stru_24D82FEB0;
  }
  TSUGetCurrentLocale();
  result = TSUIsGroupingSeparatorUsedInNumericString();
  if ((_DWORD)result)
  {
    v9 = (const __CFLocale *)TSUGetCurrentLocale();
    v10 = (NSString *)-[__CFString stringByReplacingOccurrencesOfString:withString:](v5, "stringByReplacingOccurrencesOfString:withString:", CFLocaleGetValue(v9, (CFLocaleKey)*MEMORY[0x24BDBD408]), &stru_24D82FEB0);
    v11 = objc_alloc_init(TSTCell);
    TSTCellCopy(a1, (uint64_t)v11);
    TSTCellSetStringValueClearingID(v11, v10, 1);
    result = TSTCellCoerceCellToFormat((uint64_t)v11, a2);
    if ((_DWORD)result)
    {
      p_mFormatType = (__int128 *)&v11->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType;
      if (!v11)
        p_mFormatType = &TSUInvalidFormat;
      if (*(_DWORD *)p_mFormatType != 259 && (*(_DWORD *)p_mFormatType & 0xFFFFFFFC) == 0x100)
      {
        v13 = *((_WORD *)p_mFormatType + 8) | 0x800;
        v14 = *(_DWORD *)p_mFormatType;
        v15 = *(_QWORD *)((char *)p_mFormatType + 4);
        v16 = *((_DWORD *)p_mFormatType + 3);
        v17 = v13;
        *(_OWORD *)v18 = *(__int128 *)((char *)p_mFormatType + 18);
        *(_QWORD *)&v18[14] = *((_QWORD *)p_mFormatType + 4);
        TSTCellSetImplicitFormat((uint64_t)v11, (uint64_t)&v14);
      }
      TSTCellCopy((uint64_t)v11, a1);
      return 1;
    }
  }
  return result;
}

uint64_t TSTCellCreateWithCellAndSetFormulaError(TSTCell *a1, TSWPStorage *a2)
{
  TSTCell *v3;
  uint64_t v4;
  void *v5;

  v3 = objc_alloc_init(TSTCell);
  v4 = (uint64_t)v3;
  if (a1)
    TSTCellCopy((uint64_t)a1, (uint64_t)v3);
  else
    TSTCellSetImplicitFormat((uint64_t)v3, (uint64_t)&TSUNotSetFormat);
  v5 = *(void **)(v4 + 72);
  if (v5)
  {

    *(_QWORD *)(v4 + 72) = 0;
  }
  *(_DWORD *)(v4 + 64) = 0;
  TSTCellClearValue(v4);
  *(_BYTE *)(v4 + 9) = 8;
  if ((*(_DWORD *)(v4 + 104) - 263) <= 4)
    TSTCellSetImplicitFormat(v4, (uint64_t)&TSUNotSetFormat);
  return v4;
}

uint64_t TSTCellCreateWithCellAndSetFormula(uint64_t a1)
{
  TSTCell *v2;
  uint64_t v3;
  void *v4;

  v2 = objc_alloc_init(TSTCell);
  v3 = (uint64_t)v2;
  if (a1)
    TSTCellCopy(a1, (uint64_t)v2);
  else
    TSTCellSetImplicitFormat((uint64_t)v2, (uint64_t)&TSUNotSetFormat);
  v4 = *(void **)(v3 + 72);
  if (v4)
  {

    *(_QWORD *)(v3 + 72) = 0;
  }
  *(_DWORD *)(v3 + 64) = 0;
  TSTCellClearValue(v3);
  *(_DWORD *)(v3 + 8) &= 0xFFFF00FF;
  if ((*(_DWORD *)(v3 + 104) - 263) <= 4)
    TSTCellSetImplicitFormat(v3, (uint64_t)&TSUNotSetFormat);
  return v3;
}

TSTCell *TSTCellCreateWithCellAndSetBoolean(uint64_t a1, int a2)
{
  TSTCell *v4;
  TSTRichTextPayload *mRichTextPayload;
  int mFormatType;
  unsigned int mPrivate;
  double v8;
  void *v9;
  uint64_t v10;
  int v12;
  __int128 v13;
  __int128 v14;
  int v15;

  v4 = objc_alloc_init(TSTCell);
  if (a1)
    TSTCellCopy(a1, (uint64_t)v4);
  mRichTextPayload = v4->mPrivate.mRichTextPayload;
  if (mRichTextPayload)
  {

    v4->mPrivate.mRichTextPayload = 0;
  }
  v4->mPrivate.mRichTextPayloadID = 0;
  mFormatType = v4->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType;
  TSTCellClearValue((uint64_t)v4);
  mPrivate = *(_DWORD *)&v4->mPrivate & 0xFFFF00FF | 0x600;
  *(_DWORD *)&v4->mPrivate = mPrivate;
  if (mFormatType != 263)
  {
    v15 = 0;
    v14 = 0u;
    v13 = 0u;
    v12 = 263;
    TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)&v12);
    mPrivate = v4->mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0)
  {
    TSTCellClearValue((uint64_t)v4);
    mPrivate = *(_DWORD *)&v4->mPrivate & 0xFFFF00FF | 0x600;
    *(_DWORD *)&v4->mPrivate = mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0x600)
  {
    v8 = 0.0;
    if (a2)
      v8 = 1.0;
    v4->mPrivate.mValue.mDouble = v8;
  }
  else
  {
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetBoolValue(TSTCell *, BOOL)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 939, CFSTR("can't set BOOL value to non-BOOL cell: %p"), v4);
  }
  return v4;
}

TSTCell *TSTCellCreateWithCellAndSetDate(uint64_t a1, NSDate *a2)
{
  TSTCell *v4;
  TSTRichTextPayload *mRichTextPayload;
  int mFormatType;
  TSUFormatReferenceObject *mDateFormatRef;
  TSUFormatReferenceObject *v8;
  int *v9;
  unsigned int mPrivate;
  NSDate *mDate;
  void *v12;
  uint64_t v13;
  int v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD v18[2];
  uint64_t v19;
  _OWORD v20[2];
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v4 = objc_alloc_init(TSTCell);
  if (a1)
    TSTCellCopy(a1, (uint64_t)v4);
  mRichTextPayload = v4->mPrivate.mRichTextPayload;
  if (mRichTextPayload)
  {

    v4->mPrivate.mRichTextPayload = 0;
  }
  v4->mPrivate.mRichTextPayloadID = 0;
  mFormatType = v4->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType;
  if (mFormatType == 272 || mFormatType == 261)
  {
    TSTCellClearValue((uint64_t)v4);
    *((_BYTE *)&v4->mPrivate + 1) = 5;
    goto LABEL_19;
  }
  mDateFormatRef = v4->mPrivate.mCellFormats.mDateFormatRef;
  if (!mDateFormatRef
    || (-[TSUFormatReferenceObject getFormatStruct](mDateFormatRef, "getFormatStruct"),
        (v22 - 1) > 0xFFFFFFFD))
  {
    if ((TSTCellCoerceCellToFormat((uint64_t)v4, 261) & 1) != 0)
      goto LABEL_19;
    TSTCellClearValue((uint64_t)v4);
    *((_BYTE *)&v4->mPrivate + 1) = 5;
    v15 = 261;
    v16 = 0;
    v17 = TSUDefaultDateTimeFormat();
    v9 = &v15;
    goto LABEL_17;
  }
  TSTCellClearValue((uint64_t)v4);
  *((_BYTE *)&v4->mPrivate + 1) = 5;
  v24 = 0;
  v22 = 0u;
  v23 = 0u;
  v8 = v4->mPrivate.mCellFormats.mDateFormatRef;
  if (v8)
  {
    -[TSUFormatReferenceObject getFormatStruct](v8, "getFormatStruct");
  }
  else
  {
    v24 = 0;
    v22 = TSUInvalidFormat;
    v23 = unk_217C2C278;
  }
  if ((*(_WORD *)&v4->mPrivate.mCellFormats & 8) == 0)
  {
    v18[0] = v22;
    v18[1] = v23;
    v19 = v24;
    v9 = (int *)v18;
LABEL_17:
    TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)v9);
    goto LABEL_19;
  }
  v20[0] = v22;
  v20[1] = v23;
  v21 = v24;
  TSTCellSetExplicitFormat((uint64_t)v4, (uint64_t)v20);
LABEL_19:
  mPrivate = v4->mPrivate;
  if ((mPrivate & 0xFF00) == 0)
  {
    TSTCellClearValue((uint64_t)v4);
    mPrivate = *(_DWORD *)&v4->mPrivate & 0xFFFF00FF | 0x500;
    *(_DWORD *)&v4->mPrivate = mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0x500)
  {
    mDate = v4->mPrivate.mValue.mDate;
    if (mDate != a2)
    {

      v4->mPrivate.mValue.mDate = a2;
    }
  }
  else
  {
    v12 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v13 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetDateValue(TSTCell *, NSDate *)");
    objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1038, CFSTR("can't set date value on a non-date cell: %p"), v4);
  }
  return v4;
}

TSTCell *TSTCellCreateWithCellAndSetDuration(uint64_t a1, double a2)
{
  TSTCell *v4;
  TSTRichTextPayload *mRichTextPayload;
  TSUFormatReferenceObject *mDurationFormatRef;
  TSUFormatReferenceObject *v7;
  unint64_t v8;
  int *v9;
  unsigned int mPrivate;
  void *v11;
  uint64_t v12;
  int v14;
  uint64_t v15;
  unint64_t v16;
  _OWORD v17[2];
  uint64_t v18;
  _OWORD v19[2];
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v4 = objc_alloc_init(TSTCell);
  if (a1)
    TSTCellCopy(a1, (uint64_t)v4);
  mRichTextPayload = v4->mPrivate.mRichTextPayload;
  if (mRichTextPayload)
  {

    v4->mPrivate.mRichTextPayload = 0;
  }
  v4->mPrivate.mRichTextPayloadID = 0;
  if (v4->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType == 268)
  {
    TSTCellClearValue((uint64_t)v4);
    *((_BYTE *)&v4->mPrivate + 1) = 7;
    goto LABEL_18;
  }
  mDurationFormatRef = v4->mPrivate.mCellFormats.mDurationFormatRef;
  if (!mDurationFormatRef
    || (-[TSUFormatReferenceObject getFormatStruct](mDurationFormatRef, "getFormatStruct"),
        (v21 - 1) > 0xFFFFFFFD))
  {
    if ((TSTCellCoerceCellToFormat((uint64_t)v4, 268) & 1) != 0)
      goto LABEL_18;
    TSTCellClearValue((uint64_t)v4);
    *((_BYTE *)&v4->mPrivate + 1) = 7;
    v8 = ((unint64_t)*MEMORY[0x24BEB4018] << 32) | 4;
    v14 = 268;
    v15 = 0x1000000001;
    v16 = v8;
    v9 = &v14;
    goto LABEL_16;
  }
  TSTCellClearValue((uint64_t)v4);
  *((_BYTE *)&v4->mPrivate + 1) = 7;
  v23 = 0;
  v21 = 0u;
  v22 = 0u;
  v7 = v4->mPrivate.mCellFormats.mDurationFormatRef;
  if (v7)
  {
    -[TSUFormatReferenceObject getFormatStruct](v7, "getFormatStruct");
  }
  else
  {
    v23 = 0;
    v21 = TSUInvalidFormat;
    v22 = unk_217C2C278;
  }
  if ((*(_WORD *)&v4->mPrivate.mCellFormats & 4) == 0)
  {
    v17[0] = v21;
    v17[1] = v22;
    v18 = v23;
    v9 = (int *)v17;
LABEL_16:
    TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)v9);
    goto LABEL_18;
  }
  v19[0] = v21;
  v19[1] = v22;
  v20 = v23;
  TSTCellSetExplicitFormat((uint64_t)v4, (uint64_t)v19);
LABEL_18:
  mPrivate = v4->mPrivate;
  if ((mPrivate & 0xFF00) == 0)
  {
    TSTCellClearValue((uint64_t)v4);
    mPrivate = *(_DWORD *)&v4->mPrivate & 0xFFFF00FF | 0x700;
    *(_DWORD *)&v4->mPrivate = mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0x700)
  {
    v4->mPrivate.mValue.mDouble = a2;
  }
  else
  {
    v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetDurationValue(TSTCell *, NSTimeInterval)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 1080, CFSTR("can't set duration value on a non-duration cell: %p"), v4);
  }
  return v4;
}

TSTCell *TSTCellCreateWithCellAndSetText(uint64_t a1, NSString *a2)
{
  TSTCell *v4;
  TSTRichTextPayload *mRichTextPayload;
  int mFormatType;
  int v8;
  __int128 v9;
  __int128 v10;
  int v11;

  v4 = objc_alloc_init(TSTCell);
  if (a1)
    TSTCellCopy(a1, (uint64_t)v4);
  mRichTextPayload = v4->mPrivate.mRichTextPayload;
  if (mRichTextPayload)
  {

    v4->mPrivate.mRichTextPayload = 0;
  }
  v4->mPrivate.mRichTextPayloadID = 0;
  mFormatType = v4->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType;
  if (mFormatType == 271 || mFormatType == 260)
  {
    TSTCellClearValue((uint64_t)v4);
    *((_BYTE *)&v4->mPrivate + 1) = 3;
  }
  else
  {
    TSTCellClearValue((uint64_t)v4);
    *((_BYTE *)&v4->mPrivate + 1) = 3;
    v9 = 0u;
    v10 = 0u;
    v11 = 0;
    v8 = 260;
    TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)&v8);
  }
  TSTCellSetStringValueClearingID(v4, a2, 1);
  return v4;
}

TSTCell *TSTCellCreateWithCellAndSetNumber(uint64_t a1, double mMinimum)
{
  TSTCell *v4;
  TSTRichTextPayload *mRichTextPayload;
  $F03D4CA5AAEDD23196D77D4402B24C2D *p_mCurrentCellFormat;
  int mFormatType;
  unsigned int v8;
  int v9;
  __int128 v10;
  double v11;
  TSUFormatReferenceObject *v12;
  TSUFormatReferenceObject *v13;
  uint64_t v14;
  int *v15;
  TSUFormatReferenceObject *mNumberFormatRef;
  unint64_t v17;
  id v18;
  double mMaximum;
  unsigned int mPrivate;
  void *v21;
  uint64_t v22;
  int v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD v27[2];
  uint64_t v28;
  _OWORD v29[2];
  uint64_t v30;
  _OWORD v31[2];
  int v32;
  int v33;
  _OWORD v34[2];
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  unint64_t v39;
  _BYTE v40[32];
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  v4 = objc_alloc_init(TSTCell);
  if (a1)
    TSTCellCopy(a1, (uint64_t)v4);
  mRichTextPayload = v4->mPrivate.mRichTextPayload;
  if (mRichTextPayload)
  {

    v4->mPrivate.mRichTextPayload = 0;
  }
  p_mCurrentCellFormat = &v4->mPrivate.mCellFormats.mCurrentCellFormat;
  mFormatType = v4->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType;
  v4->mPrivate.mRichTextPayloadID = 0;
  v8 = mFormatType - 256;
  if (v8 > 0xE)
    goto LABEL_18;
  if (((1 << v8) & 0x604D) != 0)
  {
    TSTCellClearValue((uint64_t)v4);
    *((_BYTE *)&v4->mPrivate + 1) = 2;
    goto LABEL_43;
  }
  if (((1 << v8) & 0x300) != 0)
  {
    if (v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mDisplayFormatType == 257)
    {
      v9 = *((_DWORD *)&v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mMultipleChoiceListFormatStruct + 7);
      v10 = *(_OWORD *)&v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mMultipleChoiceListFormatStruct.mData;
      if ((*(_WORD *)&v4->mPrivate.mCellFormats & 0x10) != 0)
      {
        v34[0] = *(_OWORD *)&p_mCurrentCellFormat->mFormatType;
        v34[1] = v10;
        v35 = 256;
        v36 = v9;
        TSTCellSetExplicitFormat((uint64_t)v4, (uint64_t)v34);
      }
      else
      {
        v31[0] = *(_OWORD *)&p_mCurrentCellFormat->mFormatType;
        v31[1] = v10;
        v32 = 256;
        v33 = v9;
        TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)v31);
      }
      mNumberFormatRef = v4->mPrivate.mCellFormats.mNumberFormatRef;
      if (!mNumberFormatRef)
      {
LABEL_28:
        v17 = ((unint64_t)(*MEMORY[0x24BEB4028] & 7) << 8) | 0xFD;
        LODWORD(v42) = 256;
        *((_QWORD *)&v42 + 1) = 0;
        *(_QWORD *)&v43 = v17;
        if (mNumberFormatRef)
        {
          -[TSUFormatReferenceObject getFormatStruct](mNumberFormatRef, "getFormatStruct");
        }
        else
        {
          v41 = 0;
          memset(v40, 0, sizeof(v40));
        }
        if ((TSUEqualFormatStructs((uint64_t)&v42, (uint64_t)v40) & 1) == 0)
        {

          v18 = objc_alloc(MEMORY[0x24BEB3C88]);
          v37 = 256;
          v38 = 0;
          v39 = v17;
          v4->mPrivate.mCellFormats.mNumberFormatRef = (TSUFormatReferenceObject *)objc_msgSend(v18, "initWithTSUFormatFormatStruct:", &v37);
          v4->mPrivate.mCellFormats.mNumberFormatID = 0;
        }
        goto LABEL_33;
      }
      -[TSUFormatReferenceObject getFormatStruct](mNumberFormatRef, "getFormatStruct");
      if ((v42 - 1) >= 0xFFFFFFFE)
      {
        mNumberFormatRef = v4->mPrivate.mCellFormats.mNumberFormatRef;
        goto LABEL_28;
      }
    }
LABEL_33:
    TSTCellClearValue((uint64_t)v4);
    *((_BYTE *)&v4->mPrivate + 1) = 2;
    mMaximum = v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mMaximum;
    if (mMaximum >= mMinimum)
      mMaximum = mMinimum;
    if (v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mMinimum <= mMaximum)
      mMinimum = mMaximum;
    else
      mMinimum = v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mMinimum;
    goto LABEL_43;
  }
  if (v8 != 11)
  {
LABEL_18:
    v12 = v4->mPrivate.mCellFormats.mNumberFormatRef;
    if (v12
      && (-[TSUFormatReferenceObject getFormatStruct](v12, "getFormatStruct"), (v42 - 1) <= 0xFFFFFFFD))
    {
      TSTCellClearValue((uint64_t)v4);
      *((_BYTE *)&v4->mPrivate + 1) = 2;
      v44 = 0;
      v42 = 0u;
      v43 = 0u;
      v13 = v4->mPrivate.mCellFormats.mNumberFormatRef;
      if (v13)
      {
        -[TSUFormatReferenceObject getFormatStruct](v13, "getFormatStruct");
      }
      else
      {
        v44 = 0;
        v42 = TSUInvalidFormat;
        v43 = unk_217C2C278;
      }
      if ((*(_WORD *)&v4->mPrivate.mCellFormats & 1) != 0)
      {
        v29[0] = v42;
        v29[1] = v43;
        v30 = v44;
        TSTCellSetExplicitFormat((uint64_t)v4, (uint64_t)v29);
        goto LABEL_43;
      }
      v27[0] = v42;
      v27[1] = v43;
      v28 = v44;
      v15 = (int *)v27;
    }
    else
    {
      if ((TSTCellCoerceCellToFormat((uint64_t)v4, 256) & 1) != 0)
        goto LABEL_43;
      TSTCellClearValue((uint64_t)v4);
      *((_BYTE *)&v4->mPrivate + 1) = 2;
      v14 = ((*MEMORY[0x24BEB4028] & 7) << 8) | 0xFD;
      v24 = 256;
      v25 = 0;
      v26 = v14;
      v15 = &v24;
    }
    TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)v15);
    goto LABEL_43;
  }
  TSTCellClearValue((uint64_t)v4);
  *((_BYTE *)&v4->mPrivate + 1) = 2;
  v11 = 5.0;
  if (mMinimum <= 5.0)
    v11 = mMinimum;
  if (v11 >= 0.0)
    mMinimum = v11;
  else
    mMinimum = 0.0;
LABEL_43:
  mPrivate = v4->mPrivate;
  if ((mPrivate & 0xFF00) == 0)
  {
    TSTCellClearValue((uint64_t)v4);
    mPrivate = *(_DWORD *)&v4->mPrivate & 0xFFFF00FF | 0x200;
    *(_DWORD *)&v4->mPrivate = mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0x200)
  {
    v4->mPrivate.mValue.mDouble = mMinimum;
  }
  else
  {
    v21 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v22 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
    objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 912, CFSTR("can't set value to non-value cell: %p"), v4);
  }
  return v4;
}

TSTCell *TSTCellCreateWithCellAndSetCurrency(uint64_t a1, double mMinimum)
{
  TSTCell *v4;
  TSTRichTextPayload *mRichTextPayload;
  $F03D4CA5AAEDD23196D77D4402B24C2D *p_mCurrentCellFormat;
  int mFormatType;
  int v8;
  __int128 v9;
  TSUFormatReferenceObject *mCurrencyFormatRef;
  TSUFormatReferenceObject *v11;
  const __CFLocale *v12;
  __CFString *Value;
  __CFString *v14;
  int DecimalInfoForCurrencyCode;
  __CFString *v16;
  uint64_t v17;
  unint64_t v18;
  int *v19;
  TSUFormatReferenceObject *v20;
  const __CFLocale *v21;
  const __CFString *v22;
  __CFString *v23;
  int v24;
  __CFString *v25;
  __CFString *v26;
  uint64_t v27;
  unint64_t v28;
  TSUFormatReferenceObject *v29;
  id v30;
  double mMaximum;
  unsigned int mPrivate;
  void *v33;
  uint64_t v34;
  int v36;
  __CFString *v37;
  unint64_t v38;
  _OWORD v39[2];
  uint64_t v40;
  _OWORD v41[2];
  uint64_t v42;
  _OWORD v43[2];
  int v44;
  int v45;
  _OWORD v46[2];
  int v47;
  int v48;
  int v49;
  __CFString *v50;
  unint64_t v51;
  _BYTE v52[32];
  uint64_t v53;
  __int128 defaultFractionDigits;
  __int128 v55;
  uint64_t v56;

  v4 = objc_alloc_init(TSTCell);
  if (a1)
    TSTCellCopy(a1, (uint64_t)v4);
  mRichTextPayload = v4->mPrivate.mRichTextPayload;
  if (mRichTextPayload)
  {

    v4->mPrivate.mRichTextPayload = 0;
  }
  p_mCurrentCellFormat = &v4->mPrivate.mCellFormats.mCurrentCellFormat;
  mFormatType = v4->mPrivate.mCellFormats.mCurrentCellFormat.mFormatType;
  v4->mPrivate.mRichTextPayloadID = 0;
  if ((mFormatType - 264) >= 2)
  {
    if (mFormatType == 257)
    {
      TSTCellClearValue((uint64_t)v4);
      *((_BYTE *)&v4->mPrivate + 1) = 2;
      goto LABEL_46;
    }
    mCurrencyFormatRef = v4->mPrivate.mCellFormats.mCurrencyFormatRef;
    if (mCurrencyFormatRef
      && (-[TSUFormatReferenceObject getFormatStruct](mCurrencyFormatRef, "getFormatStruct"),
          (defaultFractionDigits - 1) <= 0xFFFFFFFD))
    {
      TSTCellClearValue((uint64_t)v4);
      *((_BYTE *)&v4->mPrivate + 1) = 2;
      v56 = 0;
      defaultFractionDigits = 0u;
      v55 = 0u;
      v11 = v4->mPrivate.mCellFormats.mCurrencyFormatRef;
      if (v11)
      {
        -[TSUFormatReferenceObject getFormatStruct](v11, "getFormatStruct");
      }
      else
      {
        v56 = 0;
        defaultFractionDigits = TSUInvalidFormat;
        v55 = unk_217C2C278;
      }
      if ((*(_WORD *)&v4->mPrivate.mCellFormats & 2) != 0)
      {
        v41[0] = defaultFractionDigits;
        v41[1] = v55;
        v42 = v56;
        TSTCellSetExplicitFormat((uint64_t)v4, (uint64_t)v41);
        goto LABEL_46;
      }
      v39[0] = defaultFractionDigits;
      v39[1] = v55;
      v40 = v56;
      v19 = (int *)v39;
    }
    else
    {
      if ((TSTCellCoerceCellToFormat((uint64_t)v4, 257) & 1) != 0)
        goto LABEL_46;
      TSTCellClearValue((uint64_t)v4);
      *((_BYTE *)&v4->mPrivate + 1) = 2;
      v12 = (const __CFLocale *)TSUGetCurrentLocale();
      Value = (__CFString *)CFLocaleGetValue(v12, (CFLocaleKey)*MEMORY[0x24BDBD3E0]);
      if (Value)
        v14 = Value;
      else
        v14 = CFSTR("USD");
      LODWORD(defaultFractionDigits) = 0;
      DecimalInfoForCurrencyCode = CFNumberFormatterGetDecimalInfoForCurrencyCode(v14, (int32_t *)&defaultFractionDigits, 0);
      v16 = v14;
      v17 = defaultFractionDigits;
      if (!DecimalInfoForCurrencyCode)
        v17 = 2;
      v18 = v17 & 0xFFFFFFFFFFFFF8FFLL | ((*MEMORY[0x24BEB4028] & 7) << 8);
      v36 = 257;
      v37 = v16;
      v38 = v18;
      v19 = &v36;
    }
    TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)v19);
    goto LABEL_46;
  }
  if (v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mDisplayFormatType != 257)
  {
    v8 = *((_DWORD *)&v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mMultipleChoiceListFormatStruct + 7);
    v9 = *(_OWORD *)&v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mMultipleChoiceListFormatStruct.mData;
    if ((*(_WORD *)&v4->mPrivate.mCellFormats & 0x10) != 0)
    {
      v46[0] = *(_OWORD *)&p_mCurrentCellFormat->mFormatType;
      v46[1] = v9;
      v47 = 257;
      v48 = v8;
      TSTCellSetExplicitFormat((uint64_t)v4, (uint64_t)v46);
    }
    else
    {
      v43[0] = *(_OWORD *)&p_mCurrentCellFormat->mFormatType;
      v43[1] = v9;
      v44 = 257;
      v45 = v8;
      TSTCellSetImplicitFormat((uint64_t)v4, (uint64_t)v43);
    }
    v20 = v4->mPrivate.mCellFormats.mCurrencyFormatRef;
    if (!v20
      || (-[TSUFormatReferenceObject getFormatStruct](v20, "getFormatStruct"),
          (defaultFractionDigits - 1) >= 0xFFFFFFFE))
    {
      v21 = (const __CFLocale *)TSUGetCurrentLocale();
      v22 = (const __CFString *)CFLocaleGetValue(v21, (CFLocaleKey)*MEMORY[0x24BDBD3E0]);
      v23 = v22 ? (__CFString *)v22 : CFSTR("USD");
      LODWORD(defaultFractionDigits) = 0;
      v24 = CFNumberFormatterGetDecimalInfoForCurrencyCode(v23, (int32_t *)&defaultFractionDigits, 0);
      v25 = v23;
      v26 = v25;
      v27 = v24 ? defaultFractionDigits : 2;
      v28 = v27 & 0xFFFFFFFFFFFFF8FFLL | ((unint64_t)(*MEMORY[0x24BEB4028] & 7) << 8);
      LODWORD(defaultFractionDigits) = 257;
      *((_QWORD *)&defaultFractionDigits + 1) = v25;
      *(_QWORD *)&v55 = v28;
      v29 = v4->mPrivate.mCellFormats.mCurrencyFormatRef;
      if (v29)
      {
        -[TSUFormatReferenceObject getFormatStruct](v29, "getFormatStruct");
      }
      else
      {
        v53 = 0;
        memset(v52, 0, sizeof(v52));
      }
      if ((TSUEqualFormatStructs((uint64_t)&defaultFractionDigits, (uint64_t)v52) & 1) == 0)
      {

        v30 = objc_alloc(MEMORY[0x24BEB3C88]);
        v49 = 257;
        v50 = v26;
        v51 = v28;
        v4->mPrivate.mCellFormats.mCurrencyFormatRef = (TSUFormatReferenceObject *)objc_msgSend(v30, "initWithTSUFormatFormatStruct:", &v49);
        v4->mPrivate.mCellFormats.mCurrencyFormatID = 0;
      }
    }
  }
  TSTCellClearValue((uint64_t)v4);
  *((_BYTE *)&v4->mPrivate + 1) = 2;
  mMaximum = v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mMaximum;
  if (mMaximum >= mMinimum)
    mMaximum = mMinimum;
  if (v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mMinimum <= mMaximum)
    mMinimum = mMaximum;
  else
    mMinimum = v4->mPrivate.mCellFormats.mCurrentCellFormat.var0.mControlFormatStruct.mMinimum;
LABEL_46:
  mPrivate = v4->mPrivate;
  if ((mPrivate & 0xFF00) == 0)
  {
    TSTCellClearValue((uint64_t)v4);
    mPrivate = *(_DWORD *)&v4->mPrivate & 0xFFFF00FF | 0x200;
    *(_DWORD *)&v4->mPrivate = mPrivate;
  }
  if ((mPrivate & 0xFF00) == 0x200)
  {
    v4->mPrivate.mValue.mDouble = mMinimum;
  }
  else
  {
    v33 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v34 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTCellSetDoubleValue(TSTCell *, double)");
    objc_msgSend(v33, "handleFailureInFunction:file:lineNumber:description:", v34, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h"), 912, CFSTR("can't set value to non-value cell: %p"), v4);
  }
  return v4;
}

void sub_217BC6FBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_217BC7430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_217BC75B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 64), 8);
  _Unwind_Resume(a1);
}

void *TSTCellIteratorGetNextCell(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "getNext:", a2);
  return a1;
}

uint64_t TSTCellIteratorCellIsStyleOnly(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 32);
}

uint64_t TSTCellIteratorCellIsCommentStorageOnly(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 33);
}

uint64_t TSTCellIteratorCellStylePointer(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1)
    return *(_QWORD *)(v1 + 40);
  else
    return 0;
}

uint64_t TSTCellIteratorTextStylePointer(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1)
    return *(_QWORD *)(v1 + 56);
  else
    return 0;
}

uint64_t TSTCellIteratorGetCell(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t TSTCellIteratorCellHasFormula(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
    return (*(unsigned __int8 *)(v1 + 4) >> 3) & 1;
  else
    return 0;
}

uint64_t TSTCellIteratorCellHasCustomFormat(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1 && (v2 = *(_QWORD *)(v1 + 4), (v2 & 4) != 0))
    return (v2 >> 53) & 1;
  else
    return 0;
}

uint64_t TSTCellIteratorCellHasCommentStorage(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
    return (*(unsigned __int8 *)(v1 + 5) >> 4) & 1;
  else
    return 0;
}

uint64_t TSTCellIteratorValueTypeOfCell(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
    return *(unsigned __int8 *)(v1 + 2);
  else
    return 0;
}

void *TSTCellIteratorExpandCell(uint64_t a1, uint64_t a2)
{
  void *result;
  uint64_t v4;

  result = *(void **)(a1 + 88);
  *(_QWORD *)(a2 + 8) = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4)
    return (void *)objc_msgSend(result, "inflateFromStorageRef:dataStore:", v4, *(_QWORD *)(a1 + 32));
  return result;
}

void *TSTCellIteratorExpandCellForLayout(uint64_t a1, uint64_t a2)
{
  void *result;
  uint64_t v4;

  result = *(void **)(a1 + 88);
  *(_QWORD *)(a2 + 8) = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4)
    return (void *)objc_msgSend(result, "inflateFromStorageRef:dataStore:suppressingFormulaInflation:", v4, *(_QWORD *)(a1 + 32), 1);
  return result;
}

uint64_t TSTLayoutSpaceSetGridRange(uint64_t result, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  BOOL v10;
  BOOL v11;

  v3 = *(_DWORD *)(result + 24);
  v4 = *(_DWORD *)(result + 28);
  v5 = *(_DWORD *)(result + 32);
  v6 = *(_DWORD *)(result + 36);
  if ((_DWORD)a2 != -1
    && (_DWORD)a3 != -1
    && a2 <= a3
    && HIDWORD(a2) != -1
    && HIDWORD(a3) != -1
    && HIDWORD(a2) <= HIDWORD(a3)
    || (v3 != -1 ? (v7 = v5 == -1) : (v7 = 1),
        !v7 ? (v8 = v3 > v5) : (v8 = 1),
        !v8 ? (v9 = v4 == -1) : (v9 = 1),
        !v9 ? (v10 = v6 == -1) : (v10 = 1),
        !v10 ? (v11 = v4 > v6) : (v11 = 1),
        !v11))
  {
    if ((_DWORD)a2 != v3 || HIDWORD(a2) != v4 || (_DWORD)a3 != v5 || HIDWORD(a3) != v6)
    {
      *(_QWORD *)(result + 24) = a2;
      *(_QWORD *)(result + 32) = a3;
      *(_BYTE *)(result + 20) = 1;
    }
  }
  return result;
}

uint64_t TSTLayoutSpaceGetGridRange(uint64_t a1)
{
  void *v1;

  v1 = (void *)(a1 + 24);
  if (!a1)
    v1 = &TSTGridRangeEmpty;
  return *(_QWORD *)v1;
}

unint64_t TSTLayoutSpaceGetRange(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v5;
  unint64_t v8;
  unint64_t v9;

  if (!a1)
    return 0xFFFFFFLL;
  v1 = *(_QWORD *)(a1 + 24);
  v2 = *(_QWORD *)(a1 + 32);
  if (HIDWORD(v1) == -1 || HIDWORD(v2) == -1 || HIDWORD(v1) > HIDWORD(v2))
    v5 = 0;
  else
    v5 = ((v2 - (v1 & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (v2 - v1 + 1)) + 0x100000000;
  if ((_DWORD)v1 == -1 || (_DWORD)v2 == -1 || v1 > v2)
    v8 = 0;
  else
    v8 = v5;
  v9 = (unint64_t)v1 << 16;
  if ((_DWORD)v1 == -1)
    v9 = 16711680;
  return v9 & 0xFFFFFFFFFFFF0000 | WORD2(v1) | (((v8 >> 16) & 0xFFFF0000 | v8) << 32);
}

unint64_t TSTLayoutSpaceGetHeaderRowsGridRange(uint64_t a1)
{
  int TableNumberOfHeaderRows;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  TableNumberOfHeaderRows = TSTMasterLayoutGetTableNumberOfHeaderRows((unsigned __int16 *)objc_msgSend((id)a1, "masterLayout"));
  if (!TableNumberOfHeaderRows)
    goto LABEL_18;
  v3 = *(_DWORD *)(a1 + 32);
  v4 = TableNumberOfHeaderRows - 1;
  if (v3 == -1)
  {
    v6 = -1;
    goto LABEL_15;
  }
  v5 = *(_QWORD *)(a1 + 24);
  v6 = -1;
  if ((_DWORD)v5 == -1)
  {
LABEL_15:
    v7 = -1;
    goto LABEL_16;
  }
  v7 = -1;
  if (v5 <= v3 && HIDWORD(v5) != -1)
  {
    LODWORD(v8) = *(_DWORD *)(a1 + 36);
    if ((_DWORD)v8 != -1 && HIDWORD(v5) <= v8 && v3 >= v5)
    {
      if (v4 >= v8)
        v8 = v8;
      else
        v8 = v4;
      if (v8 >= HIDWORD(v5))
      {
        v7 = v3 | (unint64_t)(v8 << 32);
        v6 = *(_QWORD *)(a1 + 24);
      }
    }
  }
LABEL_16:
  if (objc_msgSend((id)a1, "isMain") && (objc_msgSend((id)a1, "headerRowsRepeat") & 1) != 0)
  {
LABEL_18:
    v9 = 0xFFFFFFFF00000000;
    LODWORD(v10) = -1;
    return v9 | v10;
  }
  if (objc_msgSend((id)a1, "layoutSpaceType") == 6)
  {
    v10 = *(_QWORD *)(a1 + 24);
    v9 = v10 & 0xFFFFFFFF00000000;
    return v9 | v10;
  }
  v9 = 0xFFFFFFFF00000000;
  LODWORD(v10) = -1;
  if ((_DWORD)v6 != -1 && (_DWORD)v7 != -1 && v6 <= v7)
  {
    LODWORD(v10) = -1;
    if (HIDWORD(v6) != -1 && HIDWORD(v7) != -1 && HIDWORD(v6) <= HIDWORD(v7))
    {
      if (TSTLayoutIsPartitionAlongTop((void *)objc_msgSend((id)a1, "layout")))
      {
        v9 = 0;
        LODWORD(v10) = *(_DWORD *)(a1 + 24);
        return v9 | v10;
      }
      goto LABEL_18;
    }
  }
  return v9 | v10;
}

uint64_t TSTLayoutSpaceGetFooterRowsGridRange(uint64_t a1)
{
  int TableNumberOfFooterRows;
  int v3;
  unint64_t PartitionNonHeaderRowCellRange;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t result;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;

  TableNumberOfFooterRows = TSTMasterLayoutGetTableNumberOfFooterRows((unsigned __int16 *)objc_msgSend((id)a1, "masterLayout"));
  if (!TableNumberOfFooterRows)
    return -1;
  v3 = TableNumberOfFooterRows;
  PartitionNonHeaderRowCellRange = TSTLayoutGetPartitionNonHeaderRowCellRange((void *)objc_msgSend((id)a1, "layout"));
  v5 = (unsigned __int16)PartitionNonHeaderRowCellRange;
  if ((unsigned __int16)PartitionNonHeaderRowCellRange == 0xFFFF)
    v5 = -1;
  v6 = v5 + ((unint64_t)((HIDWORD(PartitionNonHeaderRowCellRange) << 16) - 0x100000000) >> 32);
  v7 = *(_QWORD *)(a1 + 32);
  v8 = HIWORD(PartitionNonHeaderRowCellRange) ? v6 : -1;
  if (v8 + v3 != HIDWORD(v7))
    return -1;
  v9 = BYTE2(PartitionNonHeaderRowCellRange);
  if (BYTE2(PartitionNonHeaderRowCellRange) == 255)
    LODWORD(v10) = -1;
  else
    LODWORD(v10) = BYTE2(PartitionNonHeaderRowCellRange);
  v11 = WORD2(PartitionNonHeaderRowCellRange) + (_DWORD)v10 - 1;
  v12 = *(_DWORD *)(a1 + 24);
  if (!WORD2(PartitionNonHeaderRowCellRange))
    v11 = -1;
  result = -1;
  if (v12 <= v7 && (_DWORD)v7 != -1 && v12 != -1)
  {
    v14 = *(_DWORD *)(a1 + 28);
    if (v14 <= HIDWORD(v7) && HIDWORD(v7) != -1 && v14 != -1 && v9 != 255 && v11 != -1 && v10 <= v11)
    {
      LODWORD(v15) = v8 + 1;
      if (v15 <= HIDWORD(v7) && (_DWORD)v15 != -1)
      {
        v10 = v12 <= v10 ? v10 : v12;
        v16 = v7 >= v11 ? v11 : *(_QWORD *)(a1 + 32);
        if (v10 <= v16)
        {
          if (v14 <= v15)
            v15 = v15;
          else
            v15 = v14;
          if (v15 <= HIDWORD(v7))
            return v10 | (v15 << 32);
        }
      }
    }
  }
  return result;
}

unint64_t TSTLayoutSpaceGetHeaderColumnsGridRange(uint64_t a1)
{
  int TableNumberOfHeaderColumns;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;

  TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns((unsigned __int16 *)objc_msgSend((id)a1, "masterLayout"));
  if (!TableNumberOfHeaderColumns)
    goto LABEL_18;
  v3 = TableNumberOfHeaderColumns - 1;
  v4 = *(_DWORD *)(a1 + 36);
  if (v4 == -1)
  {
    v6 = -1;
LABEL_15:
    v8 = -1;
    goto LABEL_16;
  }
  v5 = *(_QWORD *)(a1 + 24);
  v6 = -1;
  if ((_DWORD)v5 == -1)
    goto LABEL_15;
  LODWORD(v7) = *(_DWORD *)(a1 + 32);
  if ((_DWORD)v7 == -1)
    goto LABEL_15;
  v8 = -1;
  if (v5 <= v7 && HIDWORD(v5) != -1 && HIDWORD(v5) <= v4)
  {
    if (v3 >= v7)
      v7 = v7;
    else
      v7 = v3;
    if (v7 >= v5 && v4 >= HIDWORD(v5))
    {
      v8 = v7 | ((unint64_t)v4 << 32);
      v6 = *(_QWORD *)(a1 + 24);
    }
  }
LABEL_16:
  if (objc_msgSend((id)a1, "isMain") && (objc_msgSend((id)a1, "headerColumnsRepeat") & 1) != 0)
  {
LABEL_18:
    v9 = 0xFFFFFFFF00000000;
    v10 = 0xFFFFFFFFLL;
    return v9 | v10;
  }
  if (objc_msgSend((id)a1, "layoutSpaceType") == 5)
  {
    v9 = *(_QWORD *)(a1 + 24) & 0xFFFFFFFF00000000;
    v10 = *(_QWORD *)(a1 + 24);
    return v9 | v10;
  }
  v9 = 0xFFFFFFFF00000000;
  v10 = 0xFFFFFFFFLL;
  if ((_DWORD)v6 != -1 && (_DWORD)v8 != -1 && v6 <= v8)
  {
    v10 = 0xFFFFFFFFLL;
    if (HIDWORD(v6) != -1 && HIDWORD(v8) != -1 && HIDWORD(v6) <= HIDWORD(v8))
    {
      if (TSTLayoutIsPartitionAlongLeft((void *)objc_msgSend((id)a1, "layout")))
      {
        v10 = 0;
        v9 = (unint64_t)*(unsigned int *)(a1 + 28) << 32;
        return v9 | v10;
      }
      goto LABEL_18;
    }
  }
  return v9 | v10;
}

unint64_t TSTLayoutSpaceGetTopLeftCornerGridRange(void *a1)
{
  int TableNumberOfHeaderColumns;
  int TableNumberOfHeaderRows;
  unint64_t v4;
  uint64_t v5;
  unint64_t HeaderColumnsGridRange;
  uint64_t v7;
  uint64_t v8;
  unint64_t HeaderRowsGridRange;
  unsigned int v10;
  unsigned int v11;

  TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns((unsigned __int16 *)objc_msgSend(a1, "masterLayout"));
  TableNumberOfHeaderRows = TSTMasterLayoutGetTableNumberOfHeaderRows((unsigned __int16 *)objc_msgSend(a1, "masterLayout"));
  v4 = 0xFFFFFFFF00000000;
  v5 = 0xFFFFFFFFLL;
  if (TableNumberOfHeaderColumns)
  {
    if (TableNumberOfHeaderRows)
    {
      HeaderColumnsGridRange = TSTLayoutSpaceGetHeaderColumnsGridRange((uint64_t)a1);
      v8 = v7;
      HeaderRowsGridRange = TSTLayoutSpaceGetHeaderRowsGridRange((uint64_t)a1);
      v4 = 0xFFFFFFFF00000000;
      v5 = 0xFFFFFFFFLL;
      if ((_DWORD)HeaderColumnsGridRange != -1
        && (_DWORD)v8 != -1
        && HeaderColumnsGridRange <= v8)
      {
        v5 = 0xFFFFFFFFLL;
        if (HIDWORD(HeaderColumnsGridRange) != -1
          && HIDWORD(v8) != -1
          && HIDWORD(HeaderColumnsGridRange) <= HIDWORD(v8))
        {
          v5 = 0xFFFFFFFFLL;
          if ((_DWORD)HeaderRowsGridRange != -1 && v10 != -1 && HeaderRowsGridRange <= v10)
          {
            v5 = 0xFFFFFFFFLL;
            if (HIDWORD(HeaderRowsGridRange) != -1 && v11 != -1 && HIDWORD(HeaderRowsGridRange) <= v11)
            {
              v5 = 0;
              v4 = 0;
            }
          }
        }
      }
    }
  }
  return v4 | v5;
}

unint64_t TSTLayoutSpaceGetBottomLeftCornerGridRange(void *a1)
{
  unint64_t HeaderColumnsGridRange;
  uint64_t v3;
  uint64_t v4;
  uint64_t FooterRowsGridRange;
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  uint64_t v9;

  if (TSTMasterLayoutGetTableNumberOfFooterRows((unsigned __int16 *)objc_msgSend(a1, "masterLayout"))
    && TSTMasterLayoutGetTableNumberOfHeaderColumns((unsigned __int16 *)objc_msgSend(a1, "masterLayout")))
  {
    HeaderColumnsGridRange = TSTLayoutSpaceGetHeaderColumnsGridRange((uint64_t)a1);
    v4 = v3;
    FooterRowsGridRange = TSTLayoutSpaceGetFooterRowsGridRange((uint64_t)a1);
    v8 = 0xFFFFFFFF00000000;
    v9 = 0xFFFFFFFFLL;
    if ((_DWORD)FooterRowsGridRange != -1 && v6 != -1 && FooterRowsGridRange <= v6)
    {
      v9 = 0xFFFFFFFFLL;
      if (HIDWORD(FooterRowsGridRange) != -1 && v7 != -1 && HIDWORD(FooterRowsGridRange) <= v7)
      {
        v9 = 0xFFFFFFFFLL;
        if ((_DWORD)HeaderColumnsGridRange != -1
          && (_DWORD)v4 != -1
          && HeaderColumnsGridRange <= v4)
        {
          v9 = 0xFFFFFFFFLL;
          if (HIDWORD(HeaderColumnsGridRange) != -1
            && HIDWORD(v4) != -1
            && HIDWORD(HeaderColumnsGridRange) <= HIDWORD(v4))
          {
            v9 = 0;
            v8 = FooterRowsGridRange & 0xFFFFFFFF00000000;
          }
        }
      }
    }
  }
  else
  {
    v8 = 0xFFFFFFFF00000000;
    v9 = 0xFFFFFFFFLL;
  }
  return v8 | v9;
}

unint64_t TSTLayoutSpaceGetBodyGridRange(uint64_t a1)
{
  unint64_t v2;
  unint64_t HeaderColumnsGridRange;
  unsigned int v4;
  unsigned int v5;
  BOOL v6;
  BOOL v7;
  unsigned int v8;
  unint64_t HeaderRowsGridRange;
  unsigned int v10;
  unsigned int v11;
  BOOL v12;
  BOOL v13;
  unint64_t v14;

  v2 = *(_QWORD *)(a1 + 24);
  HeaderColumnsGridRange = TSTLayoutSpaceGetHeaderColumnsGridRange(a1);
  if ((_DWORD)HeaderColumnsGridRange == -1
    || v4 == -1
    || HeaderColumnsGridRange > v4
    || (HIDWORD(HeaderColumnsGridRange) <= v5 ? (v6 = v5 == -1) : (v6 = 1),
        !v6 ? (v7 = HIDWORD(HeaderColumnsGridRange) == -1) : (v7 = 1),
        v7))
  {
    v8 = v2;
  }
  else
  {
    v8 = v4 + 1;
  }
  HeaderRowsGridRange = TSTLayoutSpaceGetHeaderRowsGridRange(a1);
  if ((_DWORD)HeaderRowsGridRange == -1
    || v10 == -1
    || HeaderRowsGridRange > v10
    || (HIDWORD(HeaderRowsGridRange) <= v11 ? (v12 = v11 == -1) : (v12 = 1),
        !v12 ? (v13 = HIDWORD(HeaderRowsGridRange) == -1) : (v13 = 1),
        v13))
  {
    v14 = HIDWORD(v2);
  }
  else
  {
    LODWORD(v14) = v11 + 1;
  }
  TSTLayoutSpaceGetFooterRowsGridRange(a1);
  return v8 | ((unint64_t)v14 << 32);
}

unint64_t TSTLayoutSpaceExpandGridRange(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  _DWORD *v3;
  unsigned int v4;

  v2 = HIDWORD(a2);
  v3 = (_DWORD *)(a1 + 24);
  if (!a1)
    v3 = &TSTGridRangeEmpty;
  if (a2 <= *v3)
    v4 = a2;
  else
    v4 = a2 - 1;
  if (HIDWORD(a2) > v3[1])
    LODWORD(v2) = HIDWORD(a2) - 1;
  return v4 | ((unint64_t)v2 << 32);
}

unint64_t TSTLayoutSpaceExpandRange(uint64_t a1, int a2)
{
  unsigned int v2;
  unsigned int v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v8;
  unint64_t v11;

  v2 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v2 = -1;
  if ((unsigned __int16)a2 == 0xFFFF)
    v3 = -1;
  else
    v3 = (unsigned __int16)a2;
  v4 = TSTLayoutSpaceExpandGridRange(a1, v2 | ((unint64_t)v3 << 32));
  if (HIDWORD(v4) == -1 || HIDWORD(v5) == -1 || HIDWORD(v4) > HIDWORD(v5))
    v8 = 0;
  else
    v8 = ((v5 - (v4 & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (v5 - v4 + 1)) + 0x100000000;
  if ((_DWORD)v4 == -1 || (_DWORD)v5 == -1 || v4 > v5)
    v8 = 0;
  v11 = (unint64_t)v4 << 16;
  if ((_DWORD)v4 == -1)
    v11 = 16711680;
  return v11 & 0xFFFFFFFFFFFF0000 | WORD2(v4) | (((v8 >> 16) & 0xFFFF0000 | v8) << 32);
}

_DWORD *TSTLayoutSpaceContainsGridRange(_DWORD *result, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  _BOOL4 v13;
  _BOOL4 v14;
  _BOOL4 v15;

  if (result)
  {
    v3 = result[6];
    v4 = result[8];
    if (v3 == -1 || v4 == -1 || v3 > v4)
      return 0;
    v7 = result[7];
    v8 = result[9];
    v9 = v7 == -1 || v8 == -1;
    if (v9 || v7 > v8)
    {
      return 0;
    }
    else
    {
      v13 = HIDWORD(a2) != -1 && HIDWORD(a3) != -1 && HIDWORD(a2) <= HIDWORD(a3);
      if (a2 > a3)
        v13 = 0;
      if ((_DWORD)a3 == -1)
        v13 = 0;
      if ((_DWORD)a2 == -1)
        v13 = 0;
      v14 = v3 <= a2 && v13;
      if (v7 > HIDWORD(a2))
        v14 = 0;
      v15 = a3 <= v4 && v14;
      if (HIDWORD(a3) <= v8)
        return (_DWORD *)v15;
      else
        return 0;
    }
  }
  return result;
}

BOOL TSTLayoutSpaceIntersectsCellRange(_BOOL8 result, unint64_t a2)
{
  unint64_t Range;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;

  if (!result)
    return result;
  Range = TSTLayoutSpaceGetRange(result);
  v4 = 0;
  v5 = 16711680;
  v6 = 0xFFFFLL;
  if ((_WORD)Range == 0xFFFF)
    goto LABEL_24;
  v7 = 0;
  if ((Range & 0xFF0000) == 0xFF0000)
    goto LABEL_25;
  v4 = 0;
  v5 = 16711680;
  v6 = 0xFFFFLL;
  if (!HIWORD(Range))
    goto LABEL_24;
  v7 = 0;
  if ((Range & 0xFFFF00000000) == 0)
    goto LABEL_25;
  v4 = 0;
  v5 = 16711680;
  v6 = 0xFFFFLL;
  if ((_WORD)a2 == 0xFFFF)
  {
LABEL_24:
    v7 = 0;
    goto LABEL_25;
  }
  v7 = 0;
  if ((a2 & 0xFF0000) != 0xFF0000)
  {
    v4 = 0;
    v5 = 16711680;
    v6 = 0xFFFFLL;
    if (HIWORD(a2))
    {
      v7 = 0;
      if ((a2 & 0xFFFF00000000) != 0)
      {
        v6 = 0;
        if (BYTE2(Range) <= BYTE2(a2))
          v8 = BYTE2(a2);
        else
          v8 = BYTE2(Range);
        if ((unsigned __int16)Range <= (unsigned __int16)a2)
          v9 = (unsigned __int16)a2;
        else
          v9 = (unsigned __int16)Range;
        if ((BYTE4(Range) + BYTE2(Range) - 1) >= (BYTE4(a2)
                                                                                                 + BYTE2(a2)
                                                                                                 - 1))
          v10 = (BYTE4(a2) + BYTE2(a2) - 1);
        else
          v10 = (BYTE4(Range) + BYTE2(Range) - 1);
        v11 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
        if ((unsigned __int16)(Range + HIWORD(Range) - 1) < v11)
          v11 = (unsigned __int16)(Range + HIWORD(Range) - 1);
        v5 = 0;
        v4 = 0;
        v7 = 0;
        if (v9 <= v11 && v8 <= v10)
        {
          v7 = ((unint64_t)(v11 - v9) << 48) + 0x1000000000000;
          v4 = (unint64_t)(unsigned __int16)(v10 - v8 + 1) << 32;
          v5 = v8 << 16;
          v6 = v9;
        }
      }
      goto LABEL_25;
    }
    goto LABEL_24;
  }
LABEL_25:
  result = 0;
  v12 = v5 | v7 | v6 | v4;
  if ((_WORD)v12 != 0xFFFF && (v12 & 0xFF0000) != 0xFF0000)
  {
    v14 = (v12 & 0xFFFF00000000) == 0;
    v13 = HIWORD(v12);
    v14 = v14 || v13 == 0;
    return !v14;
  }
  return result;
}

_DWORD *TSTLayoutSpaceIntersectsGridRange(_DWORD *result, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  unsigned int v4;
  BOOL v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  unsigned int v11;
  int v12;
  int v13;

  if (result)
  {
    v3 = result[6];
    v4 = result[8];
    v6 = v3 == -1 || v4 == -1 || v3 > v4;
    if (v6)
      return 0;
    v7 = result[7];
    v8 = result[9];
    v9 = v7 == -1 || v8 == -1;
    if (v9 || v7 > v8)
      return 0;
    result = 0;
    if ((_DWORD)a2 == -1)
      return result;
    if ((_DWORD)a3 == -1)
      return result;
    if (a2 > a3)
      return result;
    result = 0;
    if (HIDWORD(a2) == -1 || HIDWORD(a3) == -1 || HIDWORD(a2) > HIDWORD(a3))
      return result;
    if (v3 <= a2)
      v3 = a2;
    if (v4 >= a3)
      v4 = a3;
    if (v3 > v4)
      return 0;
    if (v8 >= HIDWORD(a3))
      v11 = HIDWORD(a3);
    else
      v11 = v8;
    if (v7 <= HIDWORD(a2))
      v7 = HIDWORD(a2);
    v6 = v7 > v11;
    v12 = v7 > v11;
    v13 = !v6;
    return (_DWORD *)(v13 & ~v12);
  }
  return result;
}

uint64_t TSTLayoutSpaceIntersectionCellRange(uint64_t a1, unint64_t a2)
{
  unint64_t Range;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;

  if (!a1)
    return 0xFFFFFFLL;
  Range = TSTLayoutSpaceGetRange(a1);
  v4 = 0;
  v5 = 16711680;
  v6 = 0xFFFFLL;
  if ((_WORD)Range == 0xFFFF)
    goto LABEL_25;
  v7 = 0;
  if ((Range & 0xFF0000) == 0xFF0000)
    return v5 | v7 | v6 | v4;
  v4 = 0;
  v5 = 16711680;
  v6 = 0xFFFFLL;
  if (!HIWORD(Range))
    goto LABEL_25;
  v7 = 0;
  if ((Range & 0xFFFF00000000) == 0)
    return v5 | v7 | v6 | v4;
  v4 = 0;
  v5 = 16711680;
  v6 = 0xFFFFLL;
  if ((_WORD)a2 == 0xFFFF)
  {
LABEL_25:
    v7 = 0;
    return v5 | v7 | v6 | v4;
  }
  v7 = 0;
  if ((a2 & 0xFF0000) != 0xFF0000)
  {
    v4 = 0;
    v5 = 16711680;
    v6 = 0xFFFFLL;
    if (HIWORD(a2))
    {
      v7 = 0;
      if ((a2 & 0xFFFF00000000) != 0)
      {
        v6 = 0;
        if (BYTE2(Range) <= BYTE2(a2))
          v8 = BYTE2(a2);
        else
          v8 = BYTE2(Range);
        if ((unsigned __int16)Range <= (unsigned __int16)a2)
          v9 = (unsigned __int16)a2;
        else
          v9 = (unsigned __int16)Range;
        if ((BYTE4(Range) + BYTE2(Range) - 1) >= (BYTE4(a2)
                                                                                                 + BYTE2(a2)
                                                                                                 - 1))
          v10 = (BYTE4(a2) + BYTE2(a2) - 1);
        else
          v10 = (BYTE4(Range) + BYTE2(Range) - 1);
        v11 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
        if ((unsigned __int16)(Range + HIWORD(Range) - 1) < v11)
          v11 = (unsigned __int16)(Range + HIWORD(Range) - 1);
        v5 = 0;
        v4 = 0;
        v7 = 0;
        if (v9 <= v11 && v8 <= v10)
        {
          v7 = ((unint64_t)(v11 - v9) << 48) + 0x1000000000000;
          v4 = (unint64_t)(unsigned __int16)(v10 - v8 + 1) << 32;
          v5 = v8 << 16;
          v6 = v9;
        }
      }
      return v5 | v7 | v6 | v4;
    }
    goto LABEL_25;
  }
  return v5 | v7 | v6 | v4;
}

uint64_t TSTLayoutSpaceIntersectionGridRange(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  uint64_t v7;
  unsigned int v8;
  BOOL v9;
  uint64_t result;
  unsigned int v12;
  unsigned int v13;

  if (!a1)
    return -1;
  LODWORD(v3) = a1[6];
  v4 = a1[8];
  v5 = (_DWORD)v3 == -1 || v4 == -1;
  if (v5 || v3 > v4)
    return -1;
  LODWORD(v7) = a1[7];
  v8 = a1[9];
  v9 = (_DWORD)v7 == -1 || v8 == -1;
  if (v9 || v7 > v8)
    return -1;
  result = -1;
  if ((_DWORD)a2 != -1
    && (_DWORD)a3 != -1
    && a2 <= a3
    && HIDWORD(a2) != -1
    && HIDWORD(a3) != -1
    && HIDWORD(a2) <= HIDWORD(a3))
  {
    v3 = v3 <= a2 ? a2 : v3;
    v12 = v4 >= a3 ? a3 : v4;
    if (v3 <= v12)
    {
      if (v8 >= HIDWORD(a3))
        v13 = HIDWORD(a3);
      else
        v13 = v8;
      if (v7 <= HIDWORD(a2))
        v7 = HIDWORD(a2);
      else
        v7 = v7;
      if (v7 <= v13)
        return v3 | (v7 << 32);
    }
  }
  return result;
}

uint64_t TSTLayoutSpaceIntersectsRowGridRange(uint64_t result, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  uint64_t v4;
  BOOL v6;
  unsigned int v7;
  unint64_t v8;
  BOOL v9;
  unsigned int v11;
  int v12;
  int v13;

  if (result)
  {
    v3 = *(_DWORD *)(result + 24);
    v4 = *(_QWORD *)(result + 32);
    v6 = v3 == -1 || (_DWORD)v4 == -1 || v3 > v4;
    if (v6)
      return 0;
    v7 = *(_DWORD *)(result + 28);
    v8 = (unint64_t)(v4 + 0x100000000) >> 32;
    v9 = v7 == -1 || (_DWORD)v8 == -1;
    if (v9 || v7 > v8)
      return 0;
    result = 0;
    if ((_DWORD)a2 == -1)
      return result;
    if ((_DWORD)a3 == -1)
      return result;
    if (a2 > a3)
      return result;
    result = 0;
    if (HIDWORD(a2) == -1 || HIDWORD(a3) == -1 || HIDWORD(a2) > HIDWORD(a3))
      return result;
    if (v3 <= a2)
      v3 = a2;
    if (v4 >= a3)
      LODWORD(v4) = a3;
    if (v3 > v4)
      return 0;
    if (v8 >= HIDWORD(a3))
      v11 = HIDWORD(a3);
    else
      v11 = v8;
    if (v7 <= HIDWORD(a2))
      v7 = HIDWORD(a2);
    v6 = v7 > v11;
    v12 = v7 > v11;
    v13 = !v6;
    return v13 & ~v12;
  }
  return result;
}

_DWORD *TSTLayoutSpaceIntersectsColumnGridRange(_DWORD *result, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  BOOL v10;
  unsigned int v11;
  int v12;
  int v13;

  if (result)
  {
    v3 = result[6];
    v4 = result[8] + 1;
    if (v3 == -1 || result[8] == -2 || v4 < v3)
      return 0;
    v7 = result[7];
    v8 = result[9];
    v9 = v7 == -1 || v8 == -1;
    v10 = v9 || v7 > v8;
    if (v10)
      return 0;
    result = 0;
    if ((_DWORD)a2 == -1)
      return result;
    if ((_DWORD)a3 == -1)
      return result;
    if (a2 > a3)
      return result;
    result = 0;
    if (HIDWORD(a2) == -1 || HIDWORD(a3) == -1 || HIDWORD(a2) > HIDWORD(a3))
      return result;
    if (v3 <= a2)
      v3 = a2;
    if (v4 >= a3)
      v4 = a3;
    if (v3 > v4)
      return 0;
    if (v8 >= HIDWORD(a3))
      v11 = HIDWORD(a3);
    else
      v11 = v8;
    if (v7 <= HIDWORD(a2))
      v7 = HIDWORD(a2);
    v10 = v7 > v11;
    v12 = v7 > v11;
    v13 = !v10;
    return (_DWORD *)(v13 & ~v12);
  }
  return result;
}

uint64_t TSTLayoutSpaceIntersectionRowGridRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t result;
  uint64_t v8;
  unint64_t v9;
  BOOL v10;
  unsigned int v11;
  unsigned int v12;

  if (!a1)
    return -1;
  LODWORD(v3) = *(_DWORD *)(a1 + 24);
  v4 = *(_QWORD *)(a1 + 32);
  v5 = (_DWORD)v3 == -1 || (_DWORD)v4 == -1;
  if (v5 || v3 > v4)
    return -1;
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  result = -1;
  if ((_DWORD)v8 != -1)
  {
    v9 = (unint64_t)(v4 + 0x100000000) >> 32;
    v10 = (_DWORD)v9 == -1 || v8 > v9;
    if (!v10
      && (_DWORD)a2 != -1
      && (_DWORD)a3 != -1
      && a2 <= a3
      && HIDWORD(a2) != -1
      && HIDWORD(a3) != -1
      && HIDWORD(a2) <= HIDWORD(a3))
    {
      v3 = v3 <= a2 ? a2 : v3;
      v11 = v4 >= a3 ? a3 : v4;
      if (v3 <= v11)
      {
        if (v9 >= HIDWORD(a3))
          v12 = HIDWORD(a3);
        else
          v12 = (unint64_t)(v4 + 0x100000000) >> 32;
        if (v8 <= HIDWORD(a2))
          v8 = HIDWORD(a2);
        else
          v8 = v8;
        if (v8 <= v12)
          return v3 | (v8 << 32);
      }
    }
  }
  return result;
}

uint64_t TSTLayoutSpaceIntersectionColumnGridRange(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  uint64_t v7;
  unsigned int v8;
  BOOL v9;
  uint64_t result;
  unsigned int v12;
  unsigned int v13;

  if (!a1)
    return -1;
  LODWORD(v3) = a1[6];
  v4 = a1[8] + 1;
  v5 = (_DWORD)v3 == -1 || a1[8] == -2;
  if (v5 || v4 < v3)
    return -1;
  LODWORD(v7) = a1[7];
  v8 = a1[9];
  v9 = (_DWORD)v7 == -1 || v8 == -1;
  if (v9 || v7 > v8)
    return -1;
  result = -1;
  if ((_DWORD)a2 != -1
    && (_DWORD)a3 != -1
    && a2 <= a3
    && HIDWORD(a2) != -1
    && HIDWORD(a3) != -1
    && HIDWORD(a2) <= HIDWORD(a3))
  {
    v3 = v3 <= a2 ? a2 : v3;
    v12 = v4 >= a3 ? a3 : v4;
    if (v3 <= v12)
    {
      if (v8 >= HIDWORD(a3))
        v13 = HIDWORD(a3);
      else
        v13 = v8;
      if (v7 <= HIDWORD(a2))
        v7 = HIDWORD(a2);
      else
        v7 = v7;
      if (v7 <= v13)
        return v3 | (v7 << 32);
    }
  }
  return result;
}

uint64_t TSTLayoutSpaceGetGridRangeForLayoutRect(TSTLayoutSpace *a1, double a2, double a3, double a4, double a5)
{
  CGRect v7;

  v7.origin.x = TSTLayoutSpaceGetTableRectForLayoutRect(a1, *(CGRect *)&a2);
  return TSTLayoutSpaceGetGridRangeForTableRect(a1, v7);
}

double TSTLayoutSpaceGetTableRectForLayoutRect(TSTLayoutSpace *a1, CGRect a2)
{
  double height;
  double width;
  double TablePointForLayoutPoint;
  uint64_t v5;
  double v6;

  height = a2.size.height;
  width = a2.size.width;
  TablePointForLayoutPoint = TSTLayoutSpaceGetTablePointForLayoutPoint(a1, a2.origin);
  return TSDRectWithOriginAndSize(v5, TablePointForLayoutPoint, v6, width, height);
}

uint64_t TSTLayoutSpaceGetGridRangeForTableRect(TSTLayoutSpace *a1, CGRect a2)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  CGFloat v7;
  CGFloat v8;
  CGFloat v9;
  CGFloat v10;
  double MaxY;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  uint64_t GridColumnForTableCoordinate;
  uint64_t v21;
  $FC6C44E672DFCBD714A302CF0DF56F45 *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t GridRowForTableCoordinate;
  uint64_t v27;
  $FC6C44E672DFCBD714A302CF0DF56F45 *p_mGridRange;
  double MinY;
  double MaxX;
  double MinX;
  CGRect v33;
  CGRect v34;
  CGRect v35;
  CGRect v36;
  CGRect v37;
  CGRect v38;
  CGRect v39;
  CGRect v40;
  CGRect v41;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  v33.origin.x = TSTLayoutSpaceGetFrame((uint64_t)a1);
  v34.origin.x = TSTLayoutSpaceGetTableRectForLayoutRect(a1, v33);
  v7 = v34.origin.x;
  v8 = v34.origin.y;
  v9 = v34.size.width;
  v10 = v34.size.height;
  MinX = CGRectGetMinX(v34);
  v35.origin.x = v7;
  v35.origin.y = v8;
  v35.size.width = v9;
  v35.size.height = v10;
  MaxX = CGRectGetMaxX(v35);
  v36.origin.x = v7;
  v36.origin.y = v8;
  v36.size.width = v9;
  v36.size.height = v10;
  MinY = CGRectGetMinY(v36);
  v37.origin.x = v7;
  v37.origin.y = v8;
  v37.size.width = v9;
  v37.size.height = v10;
  MaxY = CGRectGetMaxY(v37);
  v38.origin.x = x;
  v38.origin.y = y;
  v38.size.width = width;
  v38.size.height = height;
  v12 = CGRectGetMinX(v38);
  v39.origin.x = x;
  v39.origin.y = y;
  v39.size.width = width;
  v39.size.height = height;
  v13 = CGRectGetMaxX(v39);
  v40.origin.x = x;
  v40.origin.y = y;
  v40.size.width = width;
  v40.size.height = height;
  v14 = CGRectGetMinY(v40);
  v41.origin.x = x;
  v41.origin.y = y;
  v41.size.width = width;
  v41.size.height = height;
  v15 = CGRectGetMaxY(v41);
  if (v12 >= MinX)
    v16 = v12;
  else
    v16 = MinX;
  if (MaxX >= v13)
    v17 = v13;
  else
    v17 = MaxX;
  if (v14 >= MinY)
    v18 = v14;
  else
    v18 = MinY;
  if (MaxY >= v15)
    v19 = v15;
  else
    v19 = MaxY;
  if (v16 > v17)
  {
    LODWORD(GridColumnForTableCoordinate) = -1;
LABEL_24:
    LODWORD(v21) = -1;
    goto LABEL_25;
  }
  GridColumnForTableCoordinate = TSTLayoutSpaceGetGridColumnForTableCoordinate(a1, v16);
  if ((_DWORD)GridColumnForTableCoordinate == -1)
    goto LABEL_24;
  v21 = TSTLayoutSpaceGetGridColumnForTableCoordinate(a1, v17);
  if ((_DWORD)v21 == -1 || !-[TSTLayoutSpace layoutDirectionIsLeftToRight](a1, "layoutDirectionIsLeftToRight"))
  {
    if (!-[TSTLayoutSpace layoutDirectionIsLeftToRight](a1, "layoutDirectionIsLeftToRight")
      && TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, GridColumnForTableCoordinate) + 0.00999999978 > v16)
    {
      p_mGridRange = &a1->mGridRange;
      if (!a1)
        p_mGridRange = ($FC6C44E672DFCBD714A302CF0DF56F45 *)&TSTGridRangeEmpty;
      if (GridColumnForTableCoordinate >= p_mGridRange->topLeft.column)
        LODWORD(GridColumnForTableCoordinate) = GridColumnForTableCoordinate + 1;
      else
        LODWORD(GridColumnForTableCoordinate) = -1;
    }
  }
  else if (TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, v21) + 0.00999999978 < v17)
  {
    v22 = &a1->mGridRange;
    if (!a1)
      v22 = ($FC6C44E672DFCBD714A302CF0DF56F45 *)&TSTGridRangeEmpty;
    if (v21 <= v22->bottomRight.column)
      LODWORD(v21) = v21 + 1;
    else
      LODWORD(v21) = -1;
  }
LABEL_25:
  if (v18 > v19 || (v23 = TSTLayoutSpaceGetGridRowForTableCoordinate(a1, v18), (_DWORD)v23 == -1))
  {
    v24 = 0xFFFFFFFFLL;
  }
  else
  {
    v24 = v23;
    GridRowForTableCoordinate = TSTLayoutSpaceGetGridRowForTableCoordinate(a1, v19);
    if ((_DWORD)GridRowForTableCoordinate != -1)
      TSTLayoutSpaceGetTableCoordinateForGridRow(a1, GridRowForTableCoordinate);
  }
  if (-[TSTLayoutSpace layoutDirectionIsLeftToRight](a1, "layoutDirectionIsLeftToRight"))
    v27 = GridColumnForTableCoordinate;
  else
    v27 = v21;
  return v27 | (v24 << 32);
}

unint64_t TSTLayoutSpaceGetRangeForLayoutRect(TSTLayoutSpace *a1, double a2, double a3, double a4, double a5)
{
  uint64_t GridRangeForTableRect;
  unint64_t v7;
  unint64_t v8;
  BOOL v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  CGRect v21;

  v21.origin.x = TSTLayoutSpaceGetTableRectForLayoutRect(a1, *(CGRect *)&a2);
  GridRangeForTableRect = TSTLayoutSpaceGetGridRangeForTableRect(a1, v21);
  v8 = 0;
  v13 = (_DWORD)GridRangeForTableRect == -1
     || (_DWORD)v7 == -1
     || GridRangeForTableRect > v7
     || HIDWORD(GridRangeForTableRect) == -1
     || HIDWORD(v7) == -1
     || HIDWORD(GridRangeForTableRect) > HIDWORD(v7);
  if (v13)
    v14 = v7;
  else
    v14 = v7 - 1;
  if (v13)
    v15 = v7;
  else
    v15 = (v7 & 0xFFFFFFFF00000000 | (v7 - 1)) - 0x100000000;
  if ((_DWORD)GridRangeForTableRect != -1 && v14 != -1 && v14 >= GridRangeForTableRect)
  {
    if (HIDWORD(GridRangeForTableRect) == -1)
    {
      v8 = 0;
    }
    else
    {
      v16 = HIDWORD(v15);
      v17 = ((v15 - (GridRangeForTableRect & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (v15 - GridRangeForTableRect + 1))
          + 0x100000000;
      if (HIDWORD(GridRangeForTableRect) <= v16)
        v18 = v17;
      else
        v18 = 0;
      if ((_DWORD)v16 == -1)
        v8 = 0;
      else
        v8 = v18;
    }
  }
  v19 = (unint64_t)GridRangeForTableRect << 16;
  if ((_DWORD)GridRangeForTableRect == -1)
    v19 = 16711680;
  return v19 & 0xFFFFFFFFFFFF0000 | WORD2(GridRangeForTableRect) | (((v8 >> 16) & 0xFFFF0000 | v8) << 32);
}

unint64_t TSTLayoutSpaceGetNearestRangeForLayoutRect(TSTLayoutSpace *a1, double a2, double a3, double a4, double a5)
{
  unint64_t RangeForLayoutRect;
  unint64_t v11;
  double Frame;
  double v13;
  double v14;
  double v15;
  unint64_t Range;
  double FrameForRange;
  double v18;
  CGFloat v19;
  double v20;
  CGFloat v21;
  double v22;
  CGFloat v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double MaxY;
  double MaxX;
  unint64_t v37;
  void *v38;
  uint64_t v39;
  CGRect rect_8;
  double v42;
  double v43;
  CGRect v44;
  CGRect v45;
  CGRect v46;
  CGRect v47;
  CGRect v48;

  RangeForLayoutRect = TSTLayoutSpaceGetRangeForLayoutRect(a1, a2, a3, a4, a5);
  v11 = RangeForLayoutRect;
  if ((_WORD)RangeForLayoutRect == 0xFFFF
    || (RangeForLayoutRect & 0xFF0000) == 0xFF0000
    || !HIWORD(RangeForLayoutRect)
    || (RangeForLayoutRect & 0xFFFF00000000) == 0)
  {
    Frame = TSTLayoutSpaceGetFrame((uint64_t)a1);
    if (!TSDIntersectsRect(a2, a3, a4, a5, Frame, v13, v14, v15))
    {
      Range = TSTLayoutSpaceGetRange((uint64_t)a1);
      FrameForRange = TSTLayoutSpaceGetFrameForRange(a1, Range);
      v19 = v18;
      v21 = v20;
      v23 = v22;
      v24 = TSDClampPointInRect();
      v42 = v25;
      v43 = v24;
      v44.origin.x = a2;
      v44.origin.y = a3;
      v44.size.width = a4;
      v44.size.height = a5;
      CGRectGetMaxX(v44);
      v45.size.width = a4;
      rect_8.origin.x = a2;
      rect_8.origin.y = a3;
      v45.origin.x = a2;
      v45.origin.y = a3;
      rect_8.size.width = a4;
      rect_8.size.height = a5;
      v45.size.height = a5;
      CGRectGetMaxY(v45);
      v26 = TSDClampPointInRect();
      v27 = TSDRectWithPoints(v43, v42, v26);
      v31 = v27;
      v32 = v28;
      v33 = v29;
      v34 = v30;
      if (v30 == 0.0)
      {
        MaxY = CGRectGetMaxY(*(CGRect *)&v27);
        v46.origin.x = FrameForRange;
        v46.origin.y = v19;
        v46.size.width = v21;
        v46.size.height = v23;
        if (MaxY == CGRectGetMaxY(v46))
          v32 = v32 + -1.0;
        v34 = 1.0;
      }
      if (v33 == 0.0)
      {
        v47.origin.x = v31;
        v47.origin.y = v32;
        v47.size.width = v33;
        v47.size.height = v34;
        MaxX = CGRectGetMaxX(v47);
        v48.origin.x = FrameForRange;
        v48.origin.y = v19;
        v48.size.width = v21;
        v48.size.height = v23;
        if (MaxX == CGRectGetMaxX(v48))
          v31 = v31 + -1.0;
        v33 = 1.0;
      }
      v37 = TSTLayoutSpaceGetRangeForLayoutRect(a1, v31, v32, v33, v34);
      v11 = v37;
      if ((_WORD)v37 == 0xFFFF || (v37 & 0xFF0000) == 0xFF0000 || !HIWORD(v37) || (v37 & 0xFFFF00000000) == 0)
      {
        v38 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v39 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTCellRange TSTLayoutSpaceGetNearestRangeForLayoutRect(TSTLayoutSpace *, CGRect)");
        objc_msgSend(v38, "handleFailureInFunction:file:lineNumber:description:", v39, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 794, CFSTR("Failed to get nearest cell range from space %@ for layout rect %@"), a1, NSStringFromCGRect(rect_8));
      }
    }
  }
  return v11;
}

double TSTLayoutSpaceGetFrame(uint64_t a1)
{
  double *v2;
  double *v3;
  double *v4;
  double *v5;
  unint64_t v6;
  uint64_t v7;
  double *v8;
  BOOL v10;
  double FrameForGridRange;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double Frame;

  v2 = (double *)(a1 + 304);
  v3 = (double *)(a1 + 312);
  v4 = (double *)(a1 + 320);
  v5 = (double *)(a1 + 328);
  if (CGRectIsEmpty(*(CGRect *)(a1 + 304)))
  {
    v6 = *(_QWORD *)(a1 + 24);
    v7 = *(_QWORD *)(a1 + 32);
    v8 = (double *)MEMORY[0x24BDBF090];
    v10 = (_DWORD)v6 == -1 || (_DWORD)v7 == -1 || v6 > v7;
    if (!v10 && HIDWORD(v6) != -1 && HIDWORD(v7) != -1 && HIDWORD(v6) <= HIDWORD(v7))
    {
      FrameForGridRange = TSTLayoutSpaceGetFrameForGridRange((TSTLayoutSpace *)a1, v6, v7);
      v13 = v12;
      v15 = v14;
      v17 = v16;
      if (objc_msgSend((id)a1, "isMain")
        && objc_msgSend((id)a1, "headerRowsRepeat")
        && objc_msgSend((id)objc_msgSend((id)a1, "bundle"), "repeatHeaderRowsSpace"))
      {
        TSTLayoutSpaceGetFrame();
        v17 = v17 + v13 - v18;
        v13 = v18;
      }
      if (objc_msgSend((id)a1, "isMain")
        && objc_msgSend((id)a1, "headerColumnsRepeat")
        && objc_msgSend((id)objc_msgSend((id)a1, "bundle"), "repeatHeaderColumnsSpace"))
      {
        Frame = TSTLayoutSpaceGetFrame();
        v15 = v15 + FrameForGridRange - Frame;
        FrameForGridRange = Frame;
      }
      *v2 = FrameForGridRange;
      *v3 = v13;
      v8 = v2;
      *v4 = v15;
      *v5 = v17;
    }
  }
  else
  {
    v8 = v2;
  }
  return *v8;
}

double TSTLayoutSpaceGetFrameForRange(TSTLayoutSpace *a1, unint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v2 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v2 = -1;
  v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2))
    v3 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v4 = 0xFFFFFFFFLL;
  else
    v4 = (unsigned __int16)a2;
  v5 = v2 | ((unint64_t)v4 << 32);
  v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v6 = 0xFFFFFFFF00000000;
  return TSTLayoutSpaceGetFrameForGridRange(a1, v5, v3 | v6);
}

unint64_t TSTLayoutSpaceGetRangeIntersectingLayoutRect(TSTLayoutSpace *a1, double a2, double a3, double a4, double a5)
{
  double TableRectForLayoutRect;
  double v7;
  CGFloat v8;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  uint64_t v20;
  uint64_t GridRangeForTableRect;
  unint64_t v22;
  $FC6C44E672DFCBD714A302CF0DF56F45 *p_mGridRange;
  $3C36844D3994842D9102894F8152D7DE topLeft;
  $3C36844D3994842D9102894F8152D7DE bottomRight;
  BOOL v30;
  unsigned int column;
  unint64_t v32;
  double TableCoordinateForGridColumn;
  double TableCoordinateForGridRow;
  unint64_t v35;
  unint64_t v36;
  CGRect v38;
  CGRect v39;
  CGRect v40;
  CGRect v41;
  CGRect v42;
  CGRect v43;

  TableRectForLayoutRect = TSTLayoutSpaceGetTableRectForLayoutRect(a1, *(CGRect *)&a2);
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v38.origin.x = TSTLayoutSpaceGetFrame((uint64_t)a1);
  v43.origin.x = TSTLayoutSpaceGetTableRectForLayoutRect(a1, v38);
  v43.origin.y = v13;
  v43.size.width = v14;
  v43.size.height = v15;
  v39.origin.x = TableRectForLayoutRect;
  v39.origin.y = v8;
  v39.size.width = v10;
  v39.size.height = v12;
  v40 = CGRectIntersection(v39, v43);
  x = v40.origin.x;
  y = v40.origin.y;
  width = v40.size.width;
  height = v40.size.height;
  GridRangeForTableRect = TSTLayoutSpaceGetGridRangeForTableRect(a1, v40);
  v22 = v20;
  p_mGridRange = &a1->mGridRange;
  if (!a1)
    p_mGridRange = ($FC6C44E672DFCBD714A302CF0DF56F45 *)&TSTGridRangeEmpty;
  topLeft = p_mGridRange->topLeft;
  bottomRight = p_mGridRange->bottomRight;
  v30 = *(_QWORD *)&p_mGridRange->topLeft == -1
     || bottomRight.column == -1
     || topLeft.column > bottomRight.column
     || topLeft.row == -1
     || bottomRight.row == -1
     || topLeft.row > bottomRight.row;
  column = bottomRight.column + 1;
  if (v30)
  {
    column = bottomRight.column;
    HIDWORD(v32) = bottomRight.row;
  }
  else
  {
    v32 = (*(_QWORD *)&bottomRight & 0xFFFFFFFF00000000 | (bottomRight.column + 1)) + 0x100000000;
  }
  if ((_DWORD)v20 != -1 && column > v20)
  {
    TableCoordinateForGridColumn = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, v20);
    v41.origin.x = x;
    v41.origin.y = y;
    v41.size.width = width;
    v41.size.height = height;
    if (TableCoordinateForGridColumn == CGRectGetMaxX(v41))
      v22 = (v22 + 1) | v22 & 0xFFFFFFFF00000000;
  }
  if (HIDWORD(v22) != -1 && HIDWORD(v22) < HIDWORD(v32))
  {
    TableCoordinateForGridRow = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, HIDWORD(v22));
    v42.origin.x = x;
    v42.origin.y = y;
    v42.size.width = width;
    v42.size.height = height;
    if (TableCoordinateForGridRow == CGRectGetMaxY(v42))
      v22 += 0x100000000;
  }
  if (GridRangeForTableRect <= v22
    && (_DWORD)GridRangeForTableRect != -1
    && (_DWORD)v22 != -1
    && HIDWORD(GridRangeForTableRect) <= HIDWORD(v22)
    && HIDWORD(GridRangeForTableRect) != -1
    && HIDWORD(v22) != -1)
  {
    v22 = (v22 & 0xFFFFFFFF00000000 | (v22 - 1)) - 0x100000000;
  }
  v35 = 0;
  if ((_DWORD)GridRangeForTableRect != -1
    && (_DWORD)v22 != -1
    && GridRangeForTableRect <= v22)
  {
    v35 = 0;
    if (HIDWORD(GridRangeForTableRect) != -1 && HIDWORD(v22) != -1 && HIDWORD(GridRangeForTableRect) <= HIDWORD(v22))
      v35 = ((v22 - (GridRangeForTableRect & 0xFFFFFFFF00000000)) & 0xFFFFFFFF00000000 | (v22 - GridRangeForTableRect + 1))
          + 0x100000000;
  }
  v36 = (unint64_t)GridRangeForTableRect << 16;
  if ((_DWORD)GridRangeForTableRect == -1)
    v36 = 16711680;
  return v36 & 0xFFFFFFFFFFFF0000 | WORD2(GridRangeForTableRect) | (((v35 >> 16) & 0xFFFF0000 | v35) << 32);
}

double TSTLayoutSpaceGetTableCoordinateForGridColumn(TSTLayoutSpace *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  BOOL v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int column;
  uint64_t row;
  $3C36844D3994842D9102894F8152D7DE bottomRight;
  void *v13;
  uint64_t v14;
  const __CFString *v15;
  const __CFString *v16;
  void *v17;
  uint64_t v18;
  TSTCoordinateArray *mHeaderRowColumnCoordinates;
  uint64_t *p_mHeaderRowColumnCoordinates;
  uint64_t v22;

  if (!a1)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetTableCoordinateForGridColumn(TSTLayoutSpace *, TSTGridColumn)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3165, CFSTR("space should be non-NULL"));
  }
  if ((_DWORD)a2 == -1
    || (a1->mGridRange.topLeft.column <= a2
      ? (v6 = a1->mGridRange.bottomRight.column + 1 >= a2)
      : (v6 = 0),
        !v6))
  {
    v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetTableCoordinateForGridColumn(TSTLayoutSpace *, TSTGridColumn)");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm");
    column = a1->mGridRange.topLeft.column;
    row = a1->mGridRange.topLeft.row;
    bottomRight = a1->mGridRange.bottomRight;
    v13 = (void *)MEMORY[0x24BDD17C8];
    if ((row & column) == 0xFFFFFFFF)
    {
      v15 = CFSTR("{invalid, invalid}");
    }
    else
    {
      if (column == -1)
      {
        v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{invalid, %u}"), a1->mGridRange.topLeft.row, v22);
      }
      else if ((_DWORD)row == -1)
      {
        v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, invalid}"), a1->mGridRange.topLeft.column, v22);
      }
      else
      {
        v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, %u}"), a1->mGridRange.topLeft.column, row);
      }
      v15 = (const __CFString *)v14;
    }
    if ((bottomRight.row & bottomRight.column) == -1)
    {
      v16 = CFSTR("{invalid, invalid}");
    }
    else if (bottomRight.column == -1)
    {
      v16 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{invalid, %u}"), HIDWORD(*(unint64_t *)&bottomRight), v22);
    }
    else if (bottomRight.row == -1)
    {
      v16 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, invalid}"), bottomRight, v22);
    }
    else
    {
      v16 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, %u}"), bottomRight, HIDWORD(*(unint64_t *)&bottomRight));
    }
    objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, v9, 3167, CFSTR("column %u not in gridRange %@"), a2, objc_msgSend(v13, "stringWithFormat:", CFSTR("{%@->%@}"), v15, v16));
  }
  if (!a1->mBodyColumnCoordinates && !a1->mHeaderRowColumnCoordinates)
  {
    v17 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v18 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetTableCoordinateForGridColumn(TSTLayoutSpace *, TSTGridColumn)");
    objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3169, CFSTR("Body column coordinates and header row column coordinates have not been filled."));
  }
  mHeaderRowColumnCoordinates = a1->mHeaderRowColumnCoordinates;
  if (mHeaderRowColumnCoordinates && TSTCoordinateArrayContainsIndex((uint64_t)mHeaderRowColumnCoordinates, a2))
    p_mHeaderRowColumnCoordinates = (uint64_t *)&a1->mHeaderRowColumnCoordinates;
  else
    p_mHeaderRowColumnCoordinates = (uint64_t *)&a1->mBodyColumnCoordinates;
  return TSTCoordinateArrayGetCoordinate(*p_mHeaderRowColumnCoordinates, a2);
}

double TSTLayoutSpaceGetTableCoordinateForGridRow(TSTLayoutSpace *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int column;
  uint64_t row;
  $3C36844D3994842D9102894F8152D7DE bottomRight;
  void *v10;
  uint64_t v11;
  const __CFString *v12;
  const __CFString *v13;
  void *v14;
  uint64_t v15;
  TSTCoordinateArray *mHeaderColumnRowCoordinates;
  uint64_t *p_mHeaderColumnRowCoordinates;
  uint64_t v19;

  if ((_DWORD)a2 == -1
    || a1->mGridRange.topLeft.row > a2
    || a1->mGridRange.bottomRight.row + 1 < a2)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetTableCoordinateForGridRow(TSTLayoutSpace *, TSTGridRow)");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm");
    column = a1->mGridRange.topLeft.column;
    row = a1->mGridRange.topLeft.row;
    bottomRight = a1->mGridRange.bottomRight;
    v10 = (void *)MEMORY[0x24BDD17C8];
    if ((row & column) == 0xFFFFFFFF)
    {
      v12 = CFSTR("{invalid, invalid}");
    }
    else
    {
      if (column == -1)
      {
        v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{invalid, %u}"), a1->mGridRange.topLeft.row, v19);
      }
      else if ((_DWORD)row == -1)
      {
        v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, invalid}"), a1->mGridRange.topLeft.column, v19);
      }
      else
      {
        v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, %u}"), a1->mGridRange.topLeft.column, row);
      }
      v12 = (const __CFString *)v11;
    }
    if ((bottomRight.row & bottomRight.column) == -1)
    {
      v13 = CFSTR("{invalid, invalid}");
    }
    else if (bottomRight.column == -1)
    {
      v13 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{invalid, %u}"), HIDWORD(*(unint64_t *)&bottomRight), v19);
    }
    else if (bottomRight.row == -1)
    {
      v13 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, invalid}"), bottomRight, v19);
    }
    else
    {
      v13 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, %u}"), bottomRight, HIDWORD(*(unint64_t *)&bottomRight));
    }
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, v6, 3209, CFSTR("row %u not in gridRange %@"), a2, objc_msgSend(v10, "stringWithFormat:", CFSTR("{%@->%@}"), v12, v13));
  }
  if (!a1->mBodyRowCoordinates && !a1->mHeaderColumnRowCoordinates)
  {
    v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetTableCoordinateForGridRow(TSTLayoutSpace *, TSTGridRow)");
    objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3211, CFSTR("Body row coordinates and header column row coordinates have not been filled."));
  }
  mHeaderColumnRowCoordinates = a1->mHeaderColumnRowCoordinates;
  if (mHeaderColumnRowCoordinates && TSTCoordinateArrayContainsIndex((uint64_t)mHeaderColumnRowCoordinates, a2))
    p_mHeaderColumnRowCoordinates = (uint64_t *)&a1->mHeaderColumnRowCoordinates;
  else
    p_mHeaderColumnRowCoordinates = (uint64_t *)&a1->mBodyRowCoordinates;
  return TSTCoordinateArrayGetCoordinate(*p_mHeaderColumnRowCoordinates, a2);
}

double TSTLayoutSpaceGetLayoutCoordinateForGridColumn(TSTLayoutSpace *a1, uint64_t a2)
{
  CGPoint v4;

  v4.x = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, a2);
  v4.y = 0.0;
  return TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v4);
}

double TSTLayoutSpaceGetLayoutPointForTablePoint(TSTLayoutSpace *a1, CGPoint a2)
{
  double y;
  double x;
  unsigned int GridColumnForTableCoordinate;
  uint64_t GridRowForTableCoordinate;

  y = a2.y;
  x = a2.x;
  GridColumnForTableCoordinate = TSTLayoutSpaceGetGridColumnForTableCoordinate(a1, a2.x);
  GridRowForTableCoordinate = TSTLayoutSpaceGetGridRowForTableCoordinate(a1, y);
  return x
       + TSTLayoutSpaceGetLayoutOffsetForGridPoint(a1, GridColumnForTableCoordinate | (unint64_t)(GridRowForTableCoordinate << 32));
}

double TSTLayoutSpaceGetLayoutCoordinateForGridRow(TSTLayoutSpace *a1, uint64_t a2)
{
  double v3;
  CGPoint v5;

  v5.y = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, a2);
  v5.x = 0.0;
  TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v5);
  return v3;
}

double TSTLayoutSpaceGetFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, uint64_t a3)
{
  double TableCoordinateForGridColumn;
  double TableCoordinateForGridRow;
  double v8;
  double v9;
  _BOOL4 v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double LayoutPointForTablePoint;
  uint64_t v16;
  double v17;

  TableCoordinateForGridColumn = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, a2);
  TableCoordinateForGridRow = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, HIDWORD(a2));
  v8 = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, (a3 + 1));
  v9 = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, (HIDWORD(a3) + 1));
  v10 = -[TSTLayoutSpace layoutDirectionIsLeftToRight](a1, "layoutDirectionIsLeftToRight");
  if (v10)
    v11 = TableCoordinateForGridColumn;
  else
    v11 = v8;
  if (v10)
    v12 = v8;
  else
    v12 = TableCoordinateForGridColumn;
  v13 = v12 - v11;
  v14 = TableCoordinateForGridRow;
  LayoutPointForTablePoint = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, *(CGPoint *)&v11);
  return TSDRectWithOriginAndSize(v16, LayoutPointForTablePoint, v17, v13, v9 - TableCoordinateForGridRow);
}

double TSTLayoutSpaceGetContentFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3)
{
  _OWORD v4[5];
  __int128 v5;

  v5 = 0u;
  memset(v4, 0, sizeof(v4));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 0, 0, (double *)v4);
  return *(double *)v4 + *(double *)&v5 * 0.5;
}

double TSTLayoutSpaceGetFrameSpecForGridRange@<D0>(TSTLayoutSpace *a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, double *a5@<X4>, double *a6@<X8>)
{
  TSTMasterLayout *v12;
  TSTMasterLayout *v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  double v24;
  double TableCoordinateForGridColumn;
  double v26;
  $FC6C44E672DFCBD714A302CF0DF56F45 *p_mGridRange;
  $3C36844D3994842D9102894F8152D7DE bottomRight;
  $3C36844D3994842D9102894F8152D7DE topLeft;
  BOOL v30;
  BOOL v31;
  unint64_t v32;
  unint64_t v33;
  BOOL v34;
  BOOL v35;
  double TableCoordinateForGridRow;
  double v38;
  int v39;
  int v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  double LayoutOffsetForGridPoint;
  double v45;
  double v46;
  double v47;
  double result;
  double v49;
  double v50;
  double v51;

  v12 = -[TSTLayoutSpace masterLayout](a1, "masterLayout");
  v13 = v12;
  if (a5)
  {
    v14 = *a5;
    v15 = *a5;
    v16 = *a5;
    v17 = *a5;
  }
  else
  {
    v17 = TSTMasterLayoutStrokeHeightOfGridRow(v12, HIDWORD(a2), a2, (int)a3 + 1);
    if (a4 == 1)
    {
      v15 = TSTMasterLayoutStrokeWidthOfGridColumn(v13, a2, HIDWORD(a2), HIDWORD(a3) + 1);
      v16 = v17;
    }
    else
    {
      v16 = TSTMasterLayoutStrokeHeightOfGridRow(v13, HIDWORD(a3) + 1, a2, (int)a3 + 1);
      v18 = TSTMasterLayoutStrokeWidthOfGridColumn(v13, a2, HIDWORD(a2), HIDWORD(a3) + 1);
      v15 = v18;
      if (a4 == 2)
      {
        v14 = v18;
        goto LABEL_11;
      }
    }
    v14 = v15;
    v15 = TSTMasterLayoutStrokeWidthOfGridColumn(v13, (int)a3 + 1, HIDWORD(a2), HIDWORD(a3) + 1);
  }
  if (a4 != 2)
  {
    if (a4 == 1)
      v19 = TSTLayoutSpaceIntersectionRowGridRange((uint64_t)a1, a2, a3);
    else
      v19 = TSTLayoutSpaceIntersectionGridRange(a1, a2, a3);
    v21 = v19;
    v23 = v20;
    TableCoordinateForGridColumn = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, v19);
    v24 = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, (v23 + 1));
    goto LABEL_14;
  }
LABEL_11:
  v21 = TSTLayoutSpaceIntersectionColumnGridRange(a1, a2, a3);
  v23 = v22;
  v24 = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, v21);
  TableCoordinateForGridColumn = v24;
LABEL_14:
  v26 = v24;
  if (-[TSTLayoutSpace layoutDirectionIsLeftToRight](a1, "layoutDirectionIsLeftToRight"))
    goto LABEL_34;
  p_mGridRange = &a1->mGridRange;
  if (!a1)
    p_mGridRange = ($FC6C44E672DFCBD714A302CF0DF56F45 *)&TSTGridRangeEmpty;
  topLeft = p_mGridRange->topLeft;
  bottomRight = p_mGridRange->bottomRight;
  v30 = topLeft.column == -1 || bottomRight.column == -1;
  v31 = v30 || topLeft.column > bottomRight.column;
  v32 = HIDWORD(*(unint64_t *)&topLeft);
  v33 = HIDWORD(*(unint64_t *)&bottomRight);
  v34 = v31 || (_DWORD)v32 == -1;
  v35 = v34 || (_DWORD)v33 == -1;
  if (v35 || v32 > v33)
  {
LABEL_34:
    v50 = v14;
    v14 = v15;
    v51 = TableCoordinateForGridColumn;
    TableCoordinateForGridColumn = v26;
  }
  else
  {
    v50 = v15;
    v51 = v26;
  }
  TableCoordinateForGridRow = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, HIDWORD(v21));
  v38 = TableCoordinateForGridRow;
  if (a4 != 1)
    v38 = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, (HIDWORD(v23) + 1));
  if (v21 > a2)
  {
    v39 = a2;
    do
      v51 = v51 - TSTMasterLayoutWidthOfColumn((uint64_t)v13, v39++, 0, 0, 1);
    while ((_DWORD)v21 != v39);
  }
  if ((int)v23 + 1 < (a3 + 1))
  {
    v40 = v23;
    do
      TableCoordinateForGridColumn = TableCoordinateForGridColumn
                                   + TSTMasterLayoutWidthOfColumn((uint64_t)v13, ++v40, 0, 0, 1);
    while ((_DWORD)a3 != v40);
  }
  v41 = HIDWORD(a2);
  if (HIDWORD(a2) < HIDWORD(v21))
  {
    do
    {
      TableCoordinateForGridRow = TableCoordinateForGridRow
                                - TSTMasterLayoutHeightOfRow(v13, (unsigned __int16)v41, 0, 0, 1, 1);
      LODWORD(v41) = v41 + 1;
    }
    while (HIDWORD(v21) != (_DWORD)v41);
  }
  v42 = HIDWORD(v23);
  v43 = HIDWORD(a3);
  if (HIDWORD(v23) + 1 < (v43 + 1))
  {
    do
    {
      LODWORD(v42) = v42 + 1;
      v38 = v38 + TSTMasterLayoutHeightOfRow(v13, (unsigned __int16)v42, 0, 0, 1, 1);
    }
    while ((_DWORD)v43 != (_DWORD)v42);
  }
  LayoutOffsetForGridPoint = TSTLayoutSpaceGetLayoutOffsetForGridPoint(a1, a2);
  v45 = v51 + LayoutOffsetForGridPoint;
  v47 = TableCoordinateForGridRow + v46;
  result = TableCoordinateForGridColumn + LayoutOffsetForGridPoint;
  *a6 = v45;
  a6[1] = TableCoordinateForGridRow + v46;
  v49 = v38 + v46;
  a6[2] = v45;
  a6[3] = v49;
  a6[4] = result;
  a6[5] = v47;
  a6[6] = result;
  a6[7] = v49;
  a6[8] = v17;
  a6[9] = v16;
  a6[10] = v50;
  a6[11] = v14;
  return result;
}

double TSTLayoutSpaceGetStrokeFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3)
{
  _OWORD v4[5];
  __int128 v5;

  v5 = 0u;
  memset(v4, 0, sizeof(v4));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 0, 0, (double *)v4);
  return *(double *)v4 - *(double *)&v5 * 0.5;
}

double TSTLayoutSpaceGetContentFrameForRange(TSTLayoutSpace *a1, unint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v2 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v2 = -1;
  v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2))
    v3 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v4 = 0xFFFFFFFFLL;
  else
    v4 = (unsigned __int16)a2;
  v5 = v2 | ((unint64_t)v4 << 32);
  v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v6 = 0xFFFFFFFF00000000;
  return TSTLayoutSpaceGetContentFrameForGridRange(a1, v5, v3 | v6);
}

double TSTLayoutSpaceGetStrokeFrameForRange(TSTLayoutSpace *a1, unint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v2 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v2 = -1;
  v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2))
    v3 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v4 = 0xFFFFFFFFLL;
  else
    v4 = (unsigned __int16)a2;
  v5 = v2 | ((unint64_t)v4 << 32);
  v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v6 = 0xFFFFFFFF00000000;
  return TSTLayoutSpaceGetStrokeFrameForGridRange(a1, v5, v3 | v6);
}

double TSTLayoutSpaceGetHeaderColumnsWidth(TSTLayoutSpace *a1)
{
  unint64_t HeaderColumnsGridRange;
  unsigned int v3;
  unsigned int v4;

  HeaderColumnsGridRange = TSTLayoutSpaceGetHeaderColumnsGridRange((uint64_t)a1);
  if ((_DWORD)HeaderColumnsGridRange == -1
    || v3 == -1
    || HeaderColumnsGridRange > v3
    || HIDWORD(HeaderColumnsGridRange) == -1
    || v4 == -1
    || HIDWORD(HeaderColumnsGridRange) > v4)
  {
    return 0.0;
  }
  else
  {
    return TSTLayoutSpaceGetRawTableCoordinateForGridColumn(a1, v3 + 1);
  }
}

double TSTLayoutSpaceGetRawTableCoordinateForGridColumn(TSTLayoutSpace *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  BOOL v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int column;
  uint64_t row;
  $3C36844D3994842D9102894F8152D7DE bottomRight;
  void *v13;
  uint64_t v14;
  const __CFString *v15;
  const __CFString *v16;
  void *v17;
  uint64_t v18;
  TSTCoordinateArray *mHeaderRowColumnCoordinates;
  uint64_t *p_mHeaderRowColumnCoordinates;
  uint64_t v22;

  if (!a1)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetRawTableCoordinateForGridColumn(TSTLayoutSpace *, TSTGridColumn)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3186, CFSTR("space should be non-NULL"));
  }
  if ((_DWORD)a2 == -1
    || (a1->mGridRange.topLeft.column <= a2
      ? (v6 = a1->mGridRange.bottomRight.column + 1 >= a2)
      : (v6 = 0),
        !v6))
  {
    v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetRawTableCoordinateForGridColumn(TSTLayoutSpace *, TSTGridColumn)");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm");
    column = a1->mGridRange.topLeft.column;
    row = a1->mGridRange.topLeft.row;
    bottomRight = a1->mGridRange.bottomRight;
    v13 = (void *)MEMORY[0x24BDD17C8];
    if ((row & column) == 0xFFFFFFFF)
    {
      v15 = CFSTR("{invalid, invalid}");
    }
    else
    {
      if (column == -1)
      {
        v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{invalid, %u}"), a1->mGridRange.topLeft.row, v22);
      }
      else if ((_DWORD)row == -1)
      {
        v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, invalid}"), a1->mGridRange.topLeft.column, v22);
      }
      else
      {
        v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, %u}"), a1->mGridRange.topLeft.column, row);
      }
      v15 = (const __CFString *)v14;
    }
    if ((bottomRight.row & bottomRight.column) == -1)
    {
      v16 = CFSTR("{invalid, invalid}");
    }
    else if (bottomRight.column == -1)
    {
      v16 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{invalid, %u}"), HIDWORD(*(unint64_t *)&bottomRight), v22);
    }
    else if (bottomRight.row == -1)
    {
      v16 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, invalid}"), bottomRight, v22);
    }
    else
    {
      v16 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("{%u, %u}"), bottomRight, HIDWORD(*(unint64_t *)&bottomRight));
    }
    objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, v9, 3188, CFSTR("column %u not in gridRange %@"), a2, objc_msgSend(v13, "stringWithFormat:", CFSTR("{%@->%@}"), v15, v16));
  }
  if (!a1->mBodyColumnCoordinates && !a1->mHeaderRowColumnCoordinates)
  {
    v17 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v18 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSTLayoutSpaceGetRawTableCoordinateForGridColumn(TSTLayoutSpace *, TSTGridColumn)");
    objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3190, CFSTR("Body column coordinates and header row column coordinates have not been filled."));
  }
  mHeaderRowColumnCoordinates = a1->mHeaderRowColumnCoordinates;
  if (mHeaderRowColumnCoordinates && TSTCoordinateArrayContainsIndex((uint64_t)mHeaderRowColumnCoordinates, a2))
    p_mHeaderRowColumnCoordinates = (uint64_t *)&a1->mHeaderRowColumnCoordinates;
  else
    p_mHeaderRowColumnCoordinates = (uint64_t *)&a1->mBodyColumnCoordinates;
  return TSTCoordinateArrayGetRawCoordinate(*p_mHeaderRowColumnCoordinates, a2);
}

double TSTLayoutSpaceGetHeaderRowsHeight(TSTLayoutSpace *a1)
{
  unint64_t HeaderRowsGridRange;
  unsigned int v3;
  unsigned int v4;

  HeaderRowsGridRange = TSTLayoutSpaceGetHeaderRowsGridRange((uint64_t)a1);
  if ((_DWORD)HeaderRowsGridRange == -1
    || v3 == -1
    || HeaderRowsGridRange > v3
    || HIDWORD(HeaderRowsGridRange) == -1
    || v4 == -1
    || HIDWORD(HeaderRowsGridRange) > v4)
  {
    return 0.0;
  }
  else
  {
    return TSTLayoutSpaceGetTableCoordinateForGridRow(a1, v4 + 1);
  }
}

double TSTLayoutSpaceGetStrokeFrame(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  BOOL v5;
  BOOL v6;
  BOOL v7;
  double StrokeFrameForGridRange;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double StrokeFrame;
  double v18;

  objc_msgSend((id)a1, "lockForRead");
  if (CGRectIsEmpty(*(CGRect *)(a1 + 368)))
  {
    v2 = *(_QWORD *)(a1 + 24);
    v3 = *(_QWORD *)(a1 + 32);
    v4 = (_DWORD)v2 == -1 || (_DWORD)v3 == -1;
    v5 = v4 || v2 > v3;
    v6 = v5 || HIDWORD(v2) == -1;
    v7 = v6 || HIDWORD(v3) == -1;
    if (!v7 && HIDWORD(v2) <= HIDWORD(v3))
    {
      StrokeFrameForGridRange = TSTLayoutSpaceGetStrokeFrameForGridRange((TSTLayoutSpace *)a1, v2, v3);
      v11 = v10;
      v13 = v12;
      v15 = v14;
      if (objc_msgSend((id)a1, "isMain")
        && objc_msgSend((id)a1, "headerRowsRepeat")
        && objc_msgSend((id)objc_msgSend((id)a1, "bundle"), "repeatHeaderRowsSpace"))
      {
        TSTLayoutSpaceGetStrokeFrame();
        v15 = v15 + v11 - v16;
        v11 = v16;
      }
      if (objc_msgSend((id)a1, "isMain")
        && objc_msgSend((id)a1, "headerColumnsRepeat")
        && objc_msgSend((id)objc_msgSend((id)a1, "bundle"), "repeatHeaderColumnsSpace"))
      {
        StrokeFrame = TSTLayoutSpaceGetStrokeFrame();
        v13 = v13 + StrokeFrameForGridRange - StrokeFrame;
        StrokeFrameForGridRange = StrokeFrame;
      }
      *(double *)(a1 + 368) = StrokeFrameForGridRange;
      *(double *)(a1 + 376) = v11;
      *(double *)(a1 + 384) = v13;
      *(double *)(a1 + 392) = v15;
    }
  }
  v18 = *(double *)(a1 + 368);
  objc_msgSend((id)a1, "unlock");
  return v18;
}

double TSTLayoutSpaceGetFrameForTableNameBorder(TSTLayoutSpace *a1)
{
  void *v2;
  uint64_t v3;
  double v4;
  double v5;
  $FC6C44E672DFCBD714A302CF0DF56F45 *p_mGridRange;
  unsigned int column;
  double LayoutPointForTablePoint;
  double v9;
  CGPoint v12;
  CGPoint v13;
  CGPoint v14;

  if (!-[TSTLayoutSpace isMain](a1, "isMain"))
  {
    v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGRect TSTLayoutSpaceGetFrameForTableNameBorder(TSTLayoutSpace *)");
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 1034, CFSTR("this API is intended to run on the main space"));
  }
  v4 = *MEMORY[0x24BDBF090];
  TSTLayoutGetTableNameHeight((uint64_t)-[TSTLayoutSpace layout](a1, "layout"));
  if (v5 > 0.0)
  {
    p_mGridRange = &a1->mGridRange;
    if (!a1)
      p_mGridRange = ($FC6C44E672DFCBD714A302CF0DF56F45 *)&TSTGridRangeEmpty;
    column = p_mGridRange->bottomRight.column;
    v12.x = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, 0);
    v12.y = 0.0;
    LayoutPointForTablePoint = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v12);
    v13.x = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, column + 1);
    v13.y = 0.0;
    v9 = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v13);
    v14.y = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, 0);
    v14.x = 0.0;
    if (-[TSTLayoutSpace layoutDirectionIsLeftToRight](a1, "layoutDirectionIsLeftToRight", TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v14)))
    {
      return LayoutPointForTablePoint;
    }
    else
    {
      return v9;
    }
  }
  return v4;
}

double TSTLayoutSpaceGetStrokeFrameForTableNameBorder(TSTLayoutSpace *a1)
{
  void *v2;
  uint64_t v3;
  double v4;
  TSTLayout *v5;
  double v6;
  unint64_t *p_topLeft;
  unint64_t v8;
  unint64_t v9;
  double v10;
  _OWORD v12[2];
  __int128 v13;
  __int128 v14;

  if (!-[TSTLayoutSpace isMain](a1, "isMain"))
  {
    v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGRect TSTLayoutSpaceGetStrokeFrameForTableNameBorder(TSTLayoutSpace *)");
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 1062, CFSTR("this API is intended to run on the main space"));
  }
  v4 = *MEMORY[0x24BDBF090];
  v5 = -[TSTLayoutSpace layout](a1, "layout");
  TSTLayoutGetTableNameHeight((uint64_t)v5);
  if (v6 > 0.0)
  {
    p_topLeft = (unint64_t *)&a1->mGridRange.topLeft;
    if (!a1)
      p_topLeft = (unint64_t *)&TSTGridRangeEmpty;
    v8 = *p_topLeft;
    v9 = p_topLeft[1];
    v10 = TSTLayoutTableNameBorderStrokeWidth(v5);
    v13 = 0u;
    v14 = 0u;
    memset(v12, 0, sizeof(v12));
    TSTLayoutSpaceGetFrameSpecForGridRange(a1, v8, v9, 0, 0, (double *)v12);
    v14 = v13;
    return *(double *)v12 - v10 * 0.5;
  }
  return v4;
}

double TSTLayoutSpaceGetAlignedStrokeFrameForTableNameBorder(TSTLayoutSpace *a1)
{
  void *v2;
  uint64_t v3;
  double v4;
  TSTLayout *v5;
  double v6;
  unint64_t *p_topLeft;
  unint64_t v8;
  unint64_t v9;
  double v10;
  _OWORD v12[2];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  if (!-[TSTLayoutSpace isMain](a1, "isMain"))
  {
    v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGRect TSTLayoutSpaceGetAlignedStrokeFrameForTableNameBorder(TSTLayoutSpace *)");
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 1098, CFSTR("this API is intended to run on the main space"));
  }
  v4 = *MEMORY[0x24BDBF090];
  v5 = -[TSTLayoutSpace layout](a1, "layout");
  TSTLayoutGetTableNameHeight((uint64_t)v5);
  if (v6 > 0.0)
  {
    p_topLeft = (unint64_t *)&a1->mGridRange.topLeft;
    if (!a1)
      p_topLeft = (unint64_t *)&TSTGridRangeEmpty;
    v8 = *p_topLeft;
    v9 = p_topLeft[1];
    v10 = TSTLayoutTableNameBorderStrokeWidth(v5);
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    memset(v12, 0, sizeof(v12));
    TSTLayoutSpaceGetFrameSpecForGridRange(a1, v8, v9, 0, 0, (double *)v12);
    TSTLayoutSpaceGetAlignFrameSpec(a1, (double *)v12);
    v14 = v13;
    return *(double *)v12 - v10 * 0.5;
  }
  return v4;
}

double TSTLayoutSpaceGetLayoutPointForCanvasPoint(uint64_t a1, double a2, double a3)
{
  double result;

  *(_QWORD *)&result = *(_OWORD *)&vaddq_f64(*(float64x2_t *)(a1 + 136), vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)(a1 + 120), a3), *(float64x2_t *)(a1 + 104), a2));
  return result;
}

double TSTLayoutSpaceGetCanvasPointForLayoutPoint(uint64_t a1, double a2, double a3)
{
  double result;

  *(_QWORD *)&result = *(_OWORD *)&vaddq_f64(*(float64x2_t *)(a1 + 88), vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)(a1 + 72), a3), *(float64x2_t *)(a1 + 56), a2));
  return result;
}

double TSTLayoutSpaceGetLayoutRectForCanvasRect(uint64_t a1, double a2, double a3, double a4, double a5)
{
  __int128 v5;
  double result;
  CGAffineTransform v7;

  v5 = *(_OWORD *)(a1 + 120);
  *(_OWORD *)&v7.a = *(_OWORD *)(a1 + 104);
  *(_OWORD *)&v7.c = v5;
  *(_OWORD *)&v7.tx = *(_OWORD *)(a1 + 136);
  *(_QWORD *)&result = (unint64_t)CGRectApplyAffineTransform(*(CGRect *)&a2, &v7);
  return result;
}

double TSTLayoutSpaceGetCanvasRectForLayoutRect(uint64_t a1, double a2, double a3, double a4, double a5)
{
  __int128 v5;
  double result;
  CGAffineTransform v7;

  v5 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v7.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v7.c = v5;
  *(_OWORD *)&v7.tx = *(_OWORD *)(a1 + 88);
  *(_QWORD *)&result = (unint64_t)CGRectApplyAffineTransform(*(CGRect *)&a2, &v7);
  return result;
}

uint64_t TSTLayoutSpaceGetGridRangeForCanvasRect(uint64_t a1, double a2, double a3, double a4, double a5)
{
  __int128 v6;
  CGAffineTransform v8;
  CGRect v9;
  CGRect v10;

  v6 = *(_OWORD *)(a1 + 120);
  *(_OWORD *)&v8.a = *(_OWORD *)(a1 + 104);
  *(_OWORD *)&v8.c = v6;
  *(_OWORD *)&v8.tx = *(_OWORD *)(a1 + 136);
  v9 = CGRectApplyAffineTransform(*(CGRect *)&a2, &v8);
  v10.origin.x = TSTLayoutSpaceGetTableRectForLayoutRect((TSTLayoutSpace *)a1, v9);
  return TSTLayoutSpaceGetGridRangeForTableRect((TSTLayoutSpace *)a1, v10);
}

double TSTLayoutSpaceGetCanvasFrameForGridRange(uint64_t a1, unint64_t a2, uint64_t a3)
{
  __int128 v4;
  double result;
  CGAffineTransform v6;
  CGRect v7;

  v7.origin.x = TSTLayoutSpaceGetFrameForGridRange((TSTLayoutSpace *)a1, a2, a3);
  v4 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v6.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v6.c = v4;
  *(_OWORD *)&v6.tx = *(_OWORD *)(a1 + 88);
  *(_QWORD *)&result = (unint64_t)CGRectApplyAffineTransform(v7, &v6);
  return result;
}

double TSTLayoutSpaceGetCanvasFrameForCellRange(uint64_t a1, unint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  double result;
  CGAffineTransform v10;
  CGRect v11;

  v3 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v3 = -1;
  v4 = WORD2(a2) + v3 - 1;
  if (!WORD2(a2))
    v4 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v5 = 0xFFFFFFFFLL;
  else
    v5 = (unsigned __int16)a2;
  v6 = v3 | ((unint64_t)v5 << 32);
  v7 = ((a2 >> 16) & 0xFFFF00000000) + (v5 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v7 = 0xFFFFFFFF00000000;
  v11.origin.x = TSTLayoutSpaceGetFrameForGridRange((TSTLayoutSpace *)a1, v6, v4 | v7);
  v8 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v10.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v10.c = v8;
  *(_OWORD *)&v10.tx = *(_OWORD *)(a1 + 88);
  *(_QWORD *)&result = (unint64_t)CGRectApplyAffineTransform(v11, &v10);
  return result;
}

double TSTLayoutSpaceGetCanvasFrame(uint64_t a1)
{
  __int128 v2;
  double result;
  CGAffineTransform v4;
  CGRect v5;

  v5.origin.x = TSTLayoutSpaceGetFrame(a1);
  v2 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v4.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v4.c = v2;
  *(_OWORD *)&v4.tx = *(_OWORD *)(a1 + 88);
  *(_QWORD *)&result = (unint64_t)CGRectApplyAffineTransform(v5, &v4);
  return result;
}

double TSTLayoutSpaceGetCanvasStrokeFrameForGridRange(uint64_t a1, unint64_t a2, unint64_t a3)
{
  __int128 v6;
  double v7;
  CGAffineTransform v9;
  CGRect v10;

  objc_msgSend((id)a1, "lockForRead");
  v10.origin.x = TSTLayoutSpaceGetStrokeFrameForGridRange((TSTLayoutSpace *)a1, a2, a3);
  v6 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v9.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v9.c = v6;
  *(_OWORD *)&v9.tx = *(_OWORD *)(a1 + 88);
  *(_QWORD *)&v7 = (unint64_t)CGRectApplyAffineTransform(v10, &v9);
  objc_msgSend((id)a1, "unlock");
  return v7;
}

double TSTLayoutSpaceGetCanvasStrokeFrame(uint64_t a1)
{
  __int128 v2;
  double result;
  CGAffineTransform v4;
  CGRect v5;

  v5.origin.x = TSTLayoutSpaceGetStrokeFrame(a1);
  v2 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v4.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v4.c = v2;
  *(_OWORD *)&v4.tx = *(_OWORD *)(a1 + 88);
  *(_QWORD *)&result = (unint64_t)CGRectApplyAffineTransform(v5, &v4);
  return result;
}

double TSTLayoutSpaceGetLayoutRectForOtherLayoutSpaceRect(uint64_t a1, uint64_t a2, double result, double a4, double a5, double a6)
{
  uint64_t v6;
  uint64_t v7;
  __int128 v9;
  __int128 v10;
  CGAffineTransform v11;
  uint64_t v12;
  uint64_t v13;
  CGRect v14;

  if (a2 != a1)
  {
    v12 = v6;
    v13 = v7;
    v9 = *(_OWORD *)(a2 + 72);
    *(_OWORD *)&v11.a = *(_OWORD *)(a2 + 56);
    *(_OWORD *)&v11.c = v9;
    *(_OWORD *)&v11.tx = *(_OWORD *)(a2 + 88);
    v14 = CGRectApplyAffineTransform(*(CGRect *)&result, &v11);
    v10 = *(_OWORD *)(a1 + 120);
    *(_OWORD *)&v11.a = *(_OWORD *)(a1 + 104);
    *(_OWORD *)&v11.c = v10;
    *(_OWORD *)&v11.tx = *(_OWORD *)(a1 + 136);
    *(_QWORD *)&result = (unint64_t)CGRectApplyAffineTransform(v14, &v11);
  }
  return result;
}

CGFloat TSTLayoutSpaceGetCanvasPositionForGridColumn(TSTLayoutSpace *a1, uint64_t a2)
{
  return a1->mTransformToCanvas.tx
       + a1->mTransformToCanvas.c * 0.0
       + a1->mTransformToCanvas.a * TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, a2);
}

CGFloat TSTLayoutSpaceGetCanvasPositionForGridRow(TSTLayoutSpace *a1, uint64_t a2)
{
  return a1->mTransformToCanvas.ty
       + TSTLayoutSpaceGetTableCoordinateForGridRow(a1, a2) * a1->mTransformToCanvas.d
       + a1->mTransformToCanvas.b * 0.0;
}

uint64_t TSTLayoutSpaceGetGridPointHitByCanvasPoint(uint64_t a1, int a2, double a3, CGFloat a4)
{
  BOOL v6;
  double v7;
  _BOOL4 v8;
  float64x2_t v9;
  double point;
  CGPoint v12;
  CGPoint v13;
  CGRect v14;
  CGRect v15;

  if (!a2)
  {
LABEL_5:
    v7 = a4;
    goto LABEL_6;
  }
  point = a3;
  TSTLayoutGetColumnTabsCanvasFrame((void *)objc_msgSend((id)a1, "layout"));
  v12.x = point;
  v12.y = a4;
  v6 = CGRectContainsPoint(v14, v12);
  a3 = point;
  v7 = -31.0;
  if (!v6)
  {
    TSTLayoutGetRowTabsCanvasFrame((void *)objc_msgSend((id)a1, "layout", point));
    v13.x = point;
    v13.y = a4;
    v8 = CGRectContainsPoint(v15, v13);
    a3 = point;
    if (v8)
      a3 = -31.0;
    goto LABEL_5;
  }
LABEL_6:
  v9 = vaddq_f64(*(float64x2_t *)(a1 + 136), vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)(a1 + 120), v7), *(float64x2_t *)(a1 + 104), a3));
  return TSTLayoutSpaceGetGridPointHitByLayoutPoint((TSTLayoutSpace *)a1, v9.f64[0], v9.f64[1]);
}

uint64_t TSTLayoutSpaceGetGridPointHitByLayoutPoint(TSTLayoutSpace *a1, double a2, double a3)
{
  double TablePointForLayoutPoint;
  double v5;
  double v6;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  uint64_t GridColumnForTableCoordinate;
  CGFloat MinY;
  uint64_t v13;
  uint64_t v14;
  CGRect v16;
  CGRect v17;
  CGRect v18;

  TablePointForLayoutPoint = TSTLayoutSpaceGetTablePointForLayoutPoint(a1, *(CGPoint *)&a2);
  v6 = v5;
  v16.origin.x = TSTLayoutSpaceGetFrame((uint64_t)a1);
  v17.origin.x = TSTLayoutSpaceGetTableRectForLayoutRect(a1, v16);
  x = v17.origin.x;
  y = v17.origin.y;
  width = v17.size.width;
  height = v17.size.height;
  if (TablePointForLayoutPoint + 0.00000011920929 >= CGRectGetMinX(v17))
    GridColumnForTableCoordinate = TSTLayoutSpaceGetGridColumnForTableCoordinate(a1, TablePointForLayoutPoint);
  else
    GridColumnForTableCoordinate = 0xFFFFFFFFLL;
  v18.origin.x = x;
  v18.origin.y = y;
  v18.size.width = width;
  v18.size.height = height;
  MinY = CGRectGetMinY(v18);
  v13 = 0xFFFFFFFF00000000;
  if (v6 + 0.00000011920929 >= MinY)
    v13 = TSTLayoutSpaceGetGridRowForTableCoordinate(a1, v6) << 32;
  v14 = 0xFFFFFFFFLL;
  if (a1->mGridRange.bottomRight.column >= GridColumnForTableCoordinate)
    v14 = GridColumnForTableCoordinate;
  if (a1->mGridRange.bottomRight.row < HIDWORD(v13))
    v13 = 0xFFFFFFFF00000000;
  return v13 | v14;
}

double TSTLayoutSpaceGetTablePointForLayoutPoint(TSTLayoutSpace *a1, CGPoint a2)
{
  double y;
  double x;
  double v5;
  double v6;
  double BodyTranslationX;
  double v8;
  double v9;

  y = a2.y;
  x = a2.x;
  -[TSTLayoutSpace tableOffset](a1, "tableOffset");
  v6 = x - v5;
  if ((TSTLayoutIsPartitionAlongLeft(-[TSTLayoutSpace layout](a1, "layout")) & 1) == 0
    && v6 > TSTLayoutSpaceGetHeaderColumnsWidth(a1))
  {
    BodyTranslationX = TSTLayoutSpaceGetBodyTranslationX(a1);
    v6 = v6 + BodyTranslationX - TSTLayoutSpaceGetHeaderColumnsWidth(a1);
  }
  -[TSTLayoutSpace tableOffset](a1, "tableOffset");
  v9 = y - v8;
  if ((TSTLayoutIsPartitionAlongTop(-[TSTLayoutSpace layout](a1, "layout")) & 1) == 0
    && v9 > TSTLayoutSpaceGetHeaderRowsHeight(a1))
  {
    TSTLayoutSpaceGetBodyTranslationY(a1);
    TSTLayoutSpaceGetHeaderRowsHeight(a1);
  }
  return v6;
}

uint64_t TSTLayoutSpaceGetVisibleRange(TSTLayoutSpace *a1)
{
  unint64_t VisibleRange;
  unint64_t v4;
  unint64_t v5;
  unint64_t Range;
  unint64_t v7;
  unsigned __int16 v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;

  if (!a1)
    return 0xFFFFFFLL;
  if (-[TSTLayoutSpace layoutSpaceType](a1, "layoutSpaceType") == 1
    || -[TSTLayoutSpace layoutSpaceType](a1, "layoutSpaceType") == 4)
  {
    return TSTLayoutSpaceGetRange((uint64_t)a1);
  }
  if (-[TSTLayoutSpace layoutSpaceType](a1, "layoutSpaceType") == 6
    || -[TSTLayoutSpace layoutSpaceType](a1, "layoutSpaceType") == 5)
  {
    return TSTLayoutGetVisibleRangeForSpace((double *)-[TSTLayoutSpace layout](a1, "layout"), a1);
  }
  VisibleRange = TSTLayoutGetVisibleRange((double *)-[TSTLayoutSpace layout](a1, "layout"));
  v4 = VisibleRange >> 16;
  v5 = HIWORD(VisibleRange);
  Range = TSTLayoutSpaceGetRange((uint64_t)a1);
  if (-[TSTLayoutSpace layoutSpaceType](a1, "layoutSpaceType") == 2)
  {
    LOWORD(v7) = WORD2(VisibleRange) + BYTE2(VisibleRange);
    v8 = VisibleRange;
    LOBYTE(v4) = 0;
  }
  else
  {
    v7 = HIDWORD(VisibleRange);
    if (-[TSTLayoutSpace layoutSpaceType](a1, "layoutSpaceType") == 3)
    {
      v5 = (unsigned __int16)(HIWORD(VisibleRange) + VisibleRange);
      v8 = 0;
    }
    else
    {
      v8 = VisibleRange;
    }
  }
  v9 = 0;
  v10 = 16711680;
  v11 = 0xFFFFLL;
  if (v8 == 0xFFFF)
    goto LABEL_37;
  v12 = 0;
  if ((unint64_t)v4 << 16 == 16711680)
    return v10 | v12 | v11 | v9;
  v9 = 0;
  v10 = 16711680;
  v11 = 0xFFFFLL;
  if (!((unint64_t)(unsigned __int16)v7 << 32))
    goto LABEL_37;
  v13 = VisibleRange & 0xFF000000 | (v5 << 48) | ((unint64_t)(unsigned __int16)v7 << 32);
  v14 = v13 | ((unint64_t)v4 << 16);
  v12 = 0;
  if (!HIWORD(v14))
    return v10 | v12 | v11 | v9;
  v9 = 0;
  v10 = 16711680;
  v11 = 0xFFFFLL;
  if ((_WORD)Range == 0xFFFF)
  {
LABEL_37:
    v12 = 0;
    return v10 | v12 | v11 | v9;
  }
  v12 = 0;
  if ((Range & 0xFF0000) != 0xFF0000)
  {
    v9 = 0;
    v10 = 16711680;
    v11 = 0xFFFFLL;
    if (HIWORD(Range))
    {
      v12 = 0;
      if ((Range & 0xFFFF00000000) != 0)
      {
        v11 = 0;
        if (v4 <= BYTE2(Range))
          v15 = BYTE2(Range);
        else
          v15 = v4;
        if (v8 <= (unsigned __int16)Range)
          v16 = (unsigned __int16)Range;
        else
          v16 = v8;
        if ((BYTE4(v13) + BYTE2(v14) - 1) >= (BYTE4(Range)
                                                                                             + BYTE2(Range)
                                                                                             - 1))
          v17 = (BYTE4(Range) + BYTE2(Range) - 1);
        else
          v17 = (BYTE4(v13) + BYTE2(v14) - 1);
        if ((unsigned __int16)(v5 + v8 - 1) >= (unsigned __int16)(Range + HIWORD(Range) - 1))
          v18 = (unsigned __int16)(Range + HIWORD(Range) - 1);
        else
          v18 = (unsigned __int16)(v5 + v8 - 1);
        v10 = 0;
        v9 = 0;
        v12 = 0;
        if (v16 <= v18 && v15 <= v17)
        {
          v12 = ((unint64_t)(v18 - v16) << 48) + 0x1000000000000;
          v9 = (unint64_t)(unsigned __int16)(v17 - v15 + 1) << 32;
          v10 = v15 << 16;
          v11 = v16;
        }
      }
      return v10 | v12 | v11 | v9;
    }
    goto LABEL_37;
  }
  return v10 | v12 | v11 | v9;
}

uint64_t TSTLayoutSpaceGetVisibleRangeForRect(TSTLayoutSpace *a1, double a2, double a3, double a4, double a5)
{
  unint64_t RangeForLayoutRect;
  unint64_t VisibleRange;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unint64_t v16;

  if (!a1)
    return 0xFFFFFFLL;
  RangeForLayoutRect = TSTLayoutSpaceGetRangeForLayoutRect(a1, a2, a3, a4, a5);
  VisibleRange = TSTLayoutSpaceGetVisibleRange(a1);
  v8 = 0;
  v9 = 16711680;
  v10 = 0xFFFFLL;
  if ((_WORD)RangeForLayoutRect == 0xFFFF)
    goto LABEL_25;
  v11 = 0;
  if ((RangeForLayoutRect & 0xFF0000) == 0xFF0000)
    goto LABEL_26;
  v8 = 0;
  v9 = 16711680;
  v10 = 0xFFFFLL;
  if (!HIWORD(RangeForLayoutRect))
    goto LABEL_25;
  v11 = 0;
  if ((RangeForLayoutRect & 0xFFFF00000000) == 0)
    goto LABEL_26;
  v8 = 0;
  v9 = 16711680;
  v10 = 0xFFFFLL;
  if ((_WORD)VisibleRange == 0xFFFF)
  {
LABEL_25:
    v11 = 0;
    goto LABEL_26;
  }
  v11 = 0;
  if ((VisibleRange & 0xFF0000) != 0xFF0000)
  {
    v8 = 0;
    v9 = 16711680;
    v10 = 0xFFFFLL;
    if (HIWORD(VisibleRange))
    {
      v11 = 0;
      if ((VisibleRange & 0xFFFF00000000) != 0)
      {
        v10 = 0;
        if (BYTE2(RangeForLayoutRect) <= BYTE2(VisibleRange))
          v12 = BYTE2(VisibleRange);
        else
          v12 = BYTE2(RangeForLayoutRect);
        if ((unsigned __int16)RangeForLayoutRect <= (unsigned __int16)VisibleRange)
          v13 = (unsigned __int16)VisibleRange;
        else
          v13 = (unsigned __int16)RangeForLayoutRect;
        if ((BYTE4(RangeForLayoutRect) + BYTE2(RangeForLayoutRect) - 1) >= (BYTE4(VisibleRange) + BYTE2(VisibleRange) - 1))
          v14 = (BYTE4(VisibleRange) + BYTE2(VisibleRange) - 1);
        else
          v14 = (BYTE4(RangeForLayoutRect) + BYTE2(RangeForLayoutRect) - 1);
        v15 = (unsigned __int16)(VisibleRange + HIWORD(VisibleRange) - 1);
        if ((unsigned __int16)(RangeForLayoutRect + HIWORD(RangeForLayoutRect) - 1) < v15)
          v15 = (unsigned __int16)(RangeForLayoutRect + HIWORD(RangeForLayoutRect) - 1);
        v9 = 0;
        v8 = 0;
        v11 = 0;
        if (v13 <= v15 && v12 <= v14)
        {
          v11 = ((unint64_t)(v15 - v13) << 48) + 0x1000000000000;
          v8 = (unint64_t)(unsigned __int16)(v14 - v12 + 1) << 32;
          v9 = v12 << 16;
          v10 = v13;
        }
      }
      goto LABEL_26;
    }
    goto LABEL_25;
  }
LABEL_26:
  v16 = v9 | v11 | v10 | v8;
  if ((_WORD)v16 == 0xFFFF || (v16 & 0xFF0000) == 0xFF0000 || !HIWORD(v16) || (v16 & 0xFFFF00000000) == 0)
    return VisibleRange;
  return v16;
}

void TSTLayoutSpaceGetVisibleFrameForRange(uint64_t a1, unint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  double CanvasFrameForGridRange;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  double v13;
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  CGFloat v17;
  __int128 v18;
  CGAffineTransform v19;
  CGRect v20;
  CGRect v21;
  CGRect v22;

  v3 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v3 = -1;
  v4 = WORD2(a2) + v3 - 1;
  if (!WORD2(a2))
    v4 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v5 = 0xFFFFFFFFLL;
  else
    v5 = (unsigned __int16)a2;
  v6 = v3 | ((unint64_t)v5 << 32);
  v7 = ((a2 >> 16) & 0xFFFF00000000) + (v5 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v7 = 0xFFFFFFFF00000000;
  CanvasFrameForGridRange = TSTLayoutSpaceGetCanvasFrameForGridRange(a1, v6, v4 | v7);
  v10 = v9;
  v12 = v11;
  v14 = v13;
  v22.origin.x = TSTLayoutGetCanvasVisibleRect(objc_msgSend((id)a1, "layout"));
  v22.origin.y = v15;
  v22.size.width = v16;
  v22.size.height = v17;
  v20.origin.x = CanvasFrameForGridRange;
  v20.origin.y = v10;
  v20.size.width = v12;
  v20.size.height = v14;
  v21 = CGRectIntersection(v20, v22);
  v18 = *(_OWORD *)(a1 + 120);
  *(_OWORD *)&v19.a = *(_OWORD *)(a1 + 104);
  *(_OWORD *)&v19.c = v18;
  *(_OWORD *)&v19.tx = *(_OWORD *)(a1 + 136);
  CGRectApplyAffineTransform(v21, &v19);
}

void TSTLayoutSpaceGetVisibleStrokeFrameForRange(uint64_t a1, unint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  double CanvasStrokeFrameForGridRange;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  double v13;
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  CGFloat v17;
  __int128 v18;
  CGAffineTransform v19;
  CGRect v20;
  CGRect v21;
  CGRect v22;

  v3 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v3 = -1;
  v4 = WORD2(a2) + v3 - 1;
  if (!WORD2(a2))
    v4 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v5 = 0xFFFFFFFFLL;
  else
    v5 = (unsigned __int16)a2;
  v6 = v3 | ((unint64_t)v5 << 32);
  v7 = ((a2 >> 16) & 0xFFFF00000000) + (v5 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v7 = 0xFFFFFFFF00000000;
  CanvasStrokeFrameForGridRange = TSTLayoutSpaceGetCanvasStrokeFrameForGridRange(a1, v6, v4 | v7);
  v10 = v9;
  v12 = v11;
  v14 = v13;
  v22.origin.x = TSTLayoutGetCanvasVisibleRect(objc_msgSend((id)a1, "layout"));
  v22.origin.y = v15;
  v22.size.width = v16;
  v22.size.height = v17;
  v20.origin.x = CanvasStrokeFrameForGridRange;
  v20.origin.y = v10;
  v20.size.width = v12;
  v20.size.height = v14;
  v21 = CGRectIntersection(v20, v22);
  v18 = *(_OWORD *)(a1 + 120);
  *(_OWORD *)&v19.a = *(_OWORD *)(a1 + 104);
  *(_OWORD *)&v19.c = v18;
  *(_OWORD *)&v19.tx = *(_OWORD *)(a1 + 136);
  CGRectApplyAffineTransform(v21, &v19);
}

void TSTLayoutSpaceGetVisibleAlignedStrokeFrameForRange(uint64_t a1, unint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  __int128 v16;
  CGAffineTransform v17;
  CGRect v18;
  CGRect v19;
  CGRect v20;
  CGRect v21;
  CGRect v22;

  v3 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v3 = -1;
  v4 = WORD2(a2) + v3 - 1;
  if (!WORD2(a2))
    v4 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v5 = 0xFFFFFFFFLL;
  else
    v5 = (unsigned __int16)a2;
  v6 = v3 | ((unint64_t)v5 << 32);
  v7 = ((a2 >> 16) & 0xFFFF00000000) + (v5 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v7 = 0xFFFFFFFF00000000;
  v18.origin.x = TSTLayoutSpaceGetAlignedStrokeFrameForGridRange((TSTLayoutSpace *)a1, v6, v4 | v7);
  v8 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v17.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v17.c = v8;
  *(_OWORD *)&v17.tx = *(_OWORD *)(a1 + 88);
  v19 = CGRectApplyAffineTransform(v18, &v17);
  x = v19.origin.x;
  y = v19.origin.y;
  width = v19.size.width;
  height = v19.size.height;
  v22.origin.x = TSTLayoutGetCanvasVisibleRect(objc_msgSend((id)a1, "layout"));
  v22.origin.y = v13;
  v22.size.width = v14;
  v22.size.height = v15;
  v20.origin.x = x;
  v20.origin.y = y;
  v20.size.width = width;
  v20.size.height = height;
  v21 = CGRectIntersection(v20, v22);
  v16 = *(_OWORD *)(a1 + 120);
  *(_OWORD *)&v17.a = *(_OWORD *)(a1 + 104);
  *(_OWORD *)&v17.c = v16;
  *(_OWORD *)&v17.tx = *(_OWORD *)(a1 + 136);
  CGRectApplyAffineTransform(v21, &v17);
}

double TSTLayoutSpaceGetAlignedStrokeFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3)
{
  _OWORD v5[5];
  __int128 v6;

  v6 = 0u;
  memset(v5, 0, sizeof(v5));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 0, 0, (double *)v5);
  TSTLayoutSpaceGetAlignFrameSpec(a1, (double *)v5);
  return *(double *)v5 - *(double *)&v6 * 0.5;
}

__n128 TSTLayoutSpaceSetUserSpaceToDeviceSpaceTransform(uint64_t a1, __int128 *a2)
{
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __n128 result;
  __int128 v8;
  CGAffineTransform v9;
  CGAffineTransform v10;

  v3 = *a2;
  v4 = a2[1];
  *(_OWORD *)(a1 + 184) = a2[2];
  *(_OWORD *)(a1 + 168) = v4;
  *(_OWORD *)(a1 + 152) = v3;
  v5 = a2[1];
  *(_OWORD *)&v9.a = *a2;
  *(_OWORD *)&v9.c = v5;
  *(_OWORD *)&v9.tx = a2[2];
  CGAffineTransformInvert(&v10, &v9);
  v6 = *(_OWORD *)&v10.c;
  *(_OWORD *)(a1 + 200) = *(_OWORD *)&v10.a;
  *(_OWORD *)(a1 + 216) = v6;
  *(_OWORD *)(a1 + 232) = *(_OWORD *)&v10.tx;
  result = *(__n128 *)MEMORY[0x24BDBF090];
  v8 = *(_OWORD *)(MEMORY[0x24BDBF090] + 16);
  *(_OWORD *)(a1 + 336) = *MEMORY[0x24BDBF090];
  *(_OWORD *)(a1 + 352) = v8;
  *(__n128 *)(a1 + 400) = result;
  *(_OWORD *)(a1 + 416) = v8;
  return result;
}

__n128 TSTLayoutSpaceGetTransformToDevice@<Q0>(TSTLayoutSpace *a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2;
  __n128 result;

  v2 = *(_OWORD *)&a1->mTransformToDevice.c;
  *(_OWORD *)a2 = *(_OWORD *)&a1->mTransformToDevice.a;
  *(_OWORD *)(a2 + 16) = v2;
  result = *(__n128 *)&a1->mTransformToDevice.tx;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

__n128 TSTLayoutSpaceGetTransformFromDevice@<Q0>(TSTLayoutSpace *a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2;
  __n128 result;

  v2 = *(_OWORD *)&a1->mTransformFromDevice.c;
  *(_OWORD *)a2 = *(_OWORD *)&a1->mTransformFromDevice.a;
  *(_OWORD *)(a2 + 16) = v2;
  result = *(__n128 *)&a1->mTransformFromDevice.tx;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

CGFloat TSTLayoutSpaceGetAlignedRectForLayoutRect(double *a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  double MinX;
  double MinY;
  CGRect v13;
  CGRect v14;
  CGRect v15;
  CGRect v16;

  if ((objc_msgSend(a1, "drawPreventAntialias") & 1) != 0)
  {
    v13.origin.x = a2;
    v13.origin.y = a3;
    v13.size.width = a4;
    v13.size.height = a5;
    MinX = CGRectGetMinX(v13);
    v14.origin.x = a2;
    v14.origin.y = a3;
    v14.size.width = a4;
    v14.size.height = a5;
    MinY = CGRectGetMinY(v14);
    v15.origin.x = a2;
    v15.origin.y = a3;
    v15.size.width = a4;
    v15.size.height = a5;
    CGRectGetMaxX(v15);
    v16.origin.x = a2;
    v16.origin.y = a3;
    v16.size.width = a4;
    v16.size.height = a5;
    CGRectGetMaxY(v16);
    return a1[29]
         + floor(a1[24] + MinY * a1[22] + a1[20] * MinX + 0.00000011920929) * a1[27]
         + a1[25] * floor(a1[23] + MinY * a1[21] + a1[19] * MinX + 0.00000011920929);
  }
  return a2;
}

void TSTLayoutSpaceAlignRect(double *a1, CGFloat *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a2 = TSTLayoutSpaceGetAlignedRectForLayoutRect(a1, *a2, a2[1], a2[2], a2[3]);
  *((_QWORD *)a2 + 1) = v3;
  *((_QWORD *)a2 + 2) = v4;
  *((_QWORD *)a2 + 3) = v5;
}

double TSTLayoutSpaceGetAlignedPointForLayoutPoint(double *a1, double a2, double a3)
{
  if ((objc_msgSend(a1, "drawPreventAntialias") & 1) != 0)
    return a1[29]
         + floor(a1[24] + a3 * a1[22] + a1[20] * a2 + 0.00000011920929) * a1[27]
         + a1[25] * floor(a1[23] + a3 * a1[21] + a1[19] * a2 + 0.00000011920929);
  return a2;
}

void TSTLayoutSpaceAlignLayoutPoint(double *a1, double *a2)
{
  uint64_t v3;

  *a2 = TSTLayoutSpaceGetAlignedPointForLayoutPoint(a1, *a2, a2[1]);
  *((_QWORD *)a2 + 1) = v3;
}

double TSTLayoutSpaceStrokeWidthForDrawing(double a1, double a2)
{
  return a2;
}

void TSTLayoutSpaceAlignStrokeCoordinates(TSTLayoutSpace *a1, double *a2, CGPoint *a3, double *a4)
{
  double v8;
  double v9;
  double y;
  double v11;
  NSString *v12;
  NSString *v13;
  double v14;
  double v15;
  double b;
  double d;
  double tx;
  double ty;
  double v20;
  double v21;
  double v22;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  NSString *v33;
  NSString *v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double a;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v52;
  double v53;
  double v54;
  double v55;
  CGFloat v56;
  double v57;
  double v58;

  if (-[TSTLayoutSpace drawPreventAntialias](a1, "drawPreventAntialias"))
  {
    v57 = 0.0;
    v58 = 0.0;
    v8 = *a2;
    v9 = a2[1];
    y = a3->y;
    if (*a2 == a3->x)
    {
      if (v9 >= y)
      {
        v11 = *a4;
        v12 = NSStringFromCGPoint(*(CGPoint *)&v8);
        v13 = NSStringFromCGPoint(*a3);
        NSLog((NSString *)CFSTR("WARNING: vertical stroke(%f %@ => %@) length <= 0.0"), *(_QWORD *)&v11, v12, v13);
        a3->y = a2[1] + 1.0;
      }
      TSTLayoutSpaceAlignStrokeWidth(a1, *a4, &v57, &v58);
      v14 = v57;
      *a4 = v57;
      v15 = a2[1];
      b = a1->mTransformToDevice.b;
      d = a1->mTransformToDevice.d;
      tx = a1->mTransformToDevice.tx;
      ty = a1->mTransformToDevice.ty;
      v20 = ty + a3->y * d + b * *a2;
      v21 = floor(tx + v15 * a1->mTransformToDevice.c + a1->mTransformToDevice.a * *a2 - v58 * 0.5 + 0.00000011920929);
      v22 = floor(ty + v15 * d + b * *a2 + 0.00000011920929);
      if (v21 <= 0.0 && *a2 >= 0.0 && tx >= -1.0)
        v21 = 0.0;
      v25 = a1->mTransformFromDevice.b;
      v26 = a1->mTransformFromDevice.d;
      v27 = a1->mTransformFromDevice.ty;
      v28 = v27 + v22 * v26 + v25 * v21;
      v29 = v27 + floor(v20 + 0.00000011920929) * v26 + v25 * v21;
      v30 = v14 * 0.5
          + a1->mTransformFromDevice.tx
          + v22 * a1->mTransformFromDevice.c
          + a1->mTransformFromDevice.a * v21;
      v31 = v30;
    }
    else
    {
      if (v9 != y)
        return;
      if (v8 >= a3->x)
      {
        v32 = *a4;
        v33 = NSStringFromCGPoint(*(CGPoint *)&v8);
        v34 = NSStringFromCGPoint(*a3);
        NSLog((NSString *)CFSTR("WARNING: horizontal stroke(%f %@ => %@) length <= 0.0"), *(_QWORD *)&v32, v33, v34);
        a3->x = *a2 + 1.0;
      }
      v35 = *a4;
      if (*a4 >= 0.0)
      {
        v36 = 0.0;
        v37 = 0.0;
        if (*a4 > 0.0)
        {
          v38 = v35 * a1->mTransformToDevice.c + a1->mTransformToDevice.a * v35;
          v39 = fabs(v35 * a1->mTransformToDevice.d + a1->mTransformToDevice.b * v35);
          v40 = floor(v39 + 0.00000011920929);
          if (v39 >= 1.0)
            v41 = v40;
          else
            v41 = 1.0;
          v37 = a1->mTransformFromDevice.d * v41 + a1->mTransformFromDevice.b * v38;
          v36 = v41 * 0.5;
        }
      }
      else
      {
        NSLog((NSString *)CFSTR("WARNING: stroke width %f < 0.0"), *(_QWORD *)a4);
        v36 = 0.0;
        v37 = 0.0;
      }
      *a4 = v37;
      v42 = a2[1];
      a = a1->mTransformToDevice.a;
      v44 = a1->mTransformToDevice.tx;
      v45 = a1->mTransformToDevice.ty;
      v46 = v42 * a1->mTransformToDevice.c;
      v47 = v44 + v46 + a * a3->x;
      v48 = floor(v44 + v46 + a * *a2 + 0.00000011920929);
      v49 = floor(v45 + v42 * a1->mTransformToDevice.d + a1->mTransformToDevice.b * *a2 - v36 + 0.00000011920929);
      if (v49 > 0.0 || v42 < 0.0 || v45 < -1.0)
        v52 = v49;
      else
        v52 = 0.0;
      v53 = floor(v47 + 0.00000011920929);
      v54 = a1->mTransformFromDevice.a;
      v55 = a1->mTransformFromDevice.tx;
      v56 = a1->mTransformFromDevice.c * v52;
      v30 = v55 + v56 + v54 * v48;
      v31 = v55 + v56 + v54 * v53;
      v28 = v37 * 0.5
          + a1->mTransformFromDevice.ty
          + a1->mTransformFromDevice.d * v52
          + a1->mTransformFromDevice.b * v48;
      v29 = v28;
    }
    *a2 = v30;
    a2[1] = v28;
    a3->x = v31;
    a3->y = v29;
  }
}

void TSTLayoutSpaceAlignStrokeWidth(TSTLayoutSpace *a1, double a2, double *a3, double *a4)
{
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;

  if (a2 < 0.0)
  {
    NSLog((NSString *)CFSTR("WARNING: stroke width %f < 0.0"), *(_QWORD *)&a2);
LABEL_8:
    *a4 = 0.0;
    v11 = 0.0;
    goto LABEL_9;
  }
  if (a2 <= 0.0)
    goto LABEL_8;
  v6 = a1->mTransformToDevice.c * a2 + a1->mTransformToDevice.a * a2;
  v7 = a1->mTransformToDevice.d * a2 + a1->mTransformToDevice.b * a2;
  v8 = fabs(v6);
  v9 = floor(v8 + 0.00000011920929);
  if (v8 >= 1.0)
    v10 = v9;
  else
    v10 = 1.0;
  *a4 = v10;
  v11 = v7 * a1->mTransformFromDevice.c + a1->mTransformFromDevice.a * v10;
LABEL_9:
  *a3 = v11;
}

CGFloat TSTLayoutSpaceGetAlignedFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, uint64_t a3)
{
  double FrameForGridRange;
  CGFloat v5;
  CGFloat v6;
  CGFloat v7;

  FrameForGridRange = TSTLayoutSpaceGetFrameForGridRange(a1, a2, a3);
  return TSTLayoutSpaceGetAlignedRectForLayoutRect((double *)a1, FrameForGridRange, v5, v6, v7);
}

double TSTLayoutSpaceGetAlignedContentFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3)
{
  _OWORD v5[5];
  __int128 v6;

  v6 = 0u;
  memset(v5, 0, sizeof(v5));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 0, 0, (double *)v5);
  TSTLayoutSpaceGetAlignFrameSpec(a1, (double *)v5);
  return *(double *)v5 + *(double *)&v6 * 0.5;
}

double TSTLayoutSpaceGetAlignedStrokeFrameForCellRange(TSTLayoutSpace *a1, unint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v2 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v2 = -1;
  v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2))
    v3 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v4 = 0xFFFFFFFFLL;
  else
    v4 = (unsigned __int16)a2;
  v5 = v2 | ((unint64_t)v4 << 32);
  v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v6 = 0xFFFFFFFF00000000;
  return TSTLayoutSpaceGetAlignedStrokeFrameForGridRange(a1, v5, v3 | v6);
}

double TSTLayoutSpaceGetAlignedStrokeLineForRowGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3)
{
  _OWORD v5[5];
  __int128 v6;

  v6 = 0u;
  memset(v5, 0, sizeof(v5));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 1, 0, (double *)v5);
  TSTLayoutSpaceGetAlignFrameSpec(a1, (double *)v5);
  return *(double *)v5 - *(double *)&v6 * 0.5;
}

double TSTLayoutSpaceGetAlignedStrokeLineForColumnGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3)
{
  _OWORD v5[5];
  __int128 v6;

  v6 = 0u;
  memset(v5, 0, sizeof(v5));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 2, 0, (double *)v5);
  TSTLayoutSpaceGetAlignFrameSpec(a1, (double *)v5);
  return *(double *)v5 - *(double *)&v6 * 0.5;
}

TSDBezierPath *TSTLayoutSpaceGetAlignedStrokeFramePathForGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3, _OWORD *a4, int a5, CGFloat a6)
{
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  TSTMasterLayout *v14;
  unsigned int v15;
  TSTMasterLayout *v16;
  unsigned int v17;
  TSTStrokeRunArray *MergedStrokesForGridColumn;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int *NextStroke;
  unsigned int *v23;
  double v24;
  unsigned int v25;
  double v26;
  double v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  _OWORD *v32;
  _OWORD *v33;
  uint64_t v34;
  TSDBezierPath *v35;
  double v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  BOOL v44;
  unint64_t v45;
  unint64_t v46;
  double AlignedStrokeFrameForGridRange;
  double v48;
  double y;
  double v50;
  double width;
  double v52;
  double height;
  double v54;
  __int128 v55;
  double v56;
  double v57;
  double v58;
  TSDBezierPath *v59;
  unint64_t v63;
  unsigned int v65;
  unint64_t v66;
  unint64_t v67;
  int v69;
  TSTStrokeRunArray *v71;
  CGAffineTransform v72;
  _DWORD v73[3];
  CGRect v74;
  CGRect v75;
  CGRect v76;

  v67 = HIDWORD(a2);
  v7 = a3;
  v63 = HIDWORD(a3);
  if ((_DWORD)a2 == -1
    || (_DWORD)a3 == -1
    || a2 > a3
    || HIDWORD(a2) == -1
    || HIDWORD(a3) == -1)
  {
    v65 = a3;
    v66 = HIDWORD(a3);
  }
  else
  {
    v66 = HIDWORD(a3);
    v65 = a3;
    if (HIDWORD(a2) <= HIDWORD(a3))
    {
      v8 = (a3 & 0xFFFFFFFF00000000) + 0x100000000;
      v65 = a3 + 1;
      v66 = HIDWORD(v8);
      v7 = v8 & 0xFFFFFFFF00000000 | (a3 + 1);
    }
  }
  v9 = malloc_type_malloc(0x10uLL, 0x1000040451B5BE8uLL);
  *v9 = a2;
  v9[1] = v7;
  v10 = 1;
  v11 = 1;
  do
  {
    v12 = v11 - 1;
    if ((v11 - 1) > 1)
    {
      if ((_DWORD)a3 == (_DWORD)a2)
        break;
    }
    else if ((_DWORD)v63 == (_DWORD)v67)
    {
      v13 = 2;
      goto LABEL_45;
    }
    v69 = v11;
    switch(v11)
    {
      case 3:
        v16 = -[TSTLayoutSpace masterLayout](a1, "masterLayout");
        v17 = v67;
        break;
      case 2:
        v14 = -[TSTLayoutSpace masterLayout](a1, "masterLayout");
        v15 = v65;
        goto LABEL_20;
      case 1:
        v14 = -[TSTLayoutSpace masterLayout](a1, "masterLayout");
        v15 = a2;
LABEL_20:
        MergedStrokesForGridColumn = TSTMasterLayoutGetMergedStrokesForGridColumn(v14, v15);
        v19 = v66;
        v20 = v67;
        goto LABEL_23;
      default:
        v16 = -[TSTLayoutSpace masterLayout](a1, "masterLayout");
        v17 = v66;
        break;
    }
    MergedStrokesForGridColumn = TSTMasterLayoutGetMergedStrokesForGridRow(v16, v17);
    v19 = v65;
    v20 = a2;
LABEL_23:
    v21 = v20;
    v73[0] = 0;
    NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridColumn, v20, v19, v73);
    if (NextStroke)
    {
      v23 = NextStroke;
      v24 = 0.0;
      v25 = -1;
      v71 = MergedStrokesForGridColumn;
      while (1)
      {
        objc_msgSend(*((id *)v23 + 1), "width");
        v27 = v26;
        v28 = v23[1] >= v19 ? v19 : v23[1];
        if (v25 != -1)
        {
          if (v26 == v24)
          {
            v27 = v24;
            goto LABEL_43;
          }
          if (v10 >= 1)
            break;
        }
LABEL_43:
        v23 = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridColumn, v21, v19, v73);
        v25 = v28;
        v24 = v27;
        if (!v23)
          goto LABEL_44;
      }
      v29 = 0;
      v30 = 0;
      while (1)
      {
        if (v12 > 1)
        {
          if (LODWORD(v9[v29]) >= v25 || v25 >= LODWORD(v9[v29 + 1]))
            goto LABEL_41;
          v31 = v10 + 1;
          v9 = malloc_type_realloc(v9, 16 * (v10 + 1), 0x1000040451B5BE8uLL);
          v33 = &v9[2 * v10];
          *v33 = *(_OWORD *)&v9[v29];
          LODWORD(v9[v29 + 1]) = v25;
        }
        else
        {
          if (HIDWORD(v9[v29]) >= v25 || v25 >= HIDWORD(v9[v29 + 1]))
            goto LABEL_41;
          v31 = v10 + 1;
          v9 = malloc_type_realloc(v9, 16 * (v10 + 1), 0x1000040451B5BE8uLL);
          v32 = &v9[2 * v10];
          *v32 = *(_OWORD *)&v9[v29];
          HIDWORD(v9[v29 + 1]) = v25;
          v33 = (_OWORD *)((char *)v32 + 4);
        }
        v10 = v31;
        *(_DWORD *)v33 = v25;
LABEL_41:
        ++v30;
        v29 += 2;
        if (v30 >= v10)
        {
          MergedStrokesForGridColumn = v71;
          goto LABEL_43;
        }
      }
    }
LABEL_44:
    TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridColumn);
    v13 = v69;
LABEL_45:
    v11 = v13 + 1;
  }
  while (v13 < 4);
  if (v10 < 1)
  {
    v59 = 0;
  }
  else
  {
    v34 = 0;
    v35 = 0;
    v36 = *MEMORY[0x24BDBEFB0];
    do
    {
      v37 = &v9[v34];
      v38 = v9[v34];
      v39 = v9[v34 + 1];
      v44 = (_DWORD)v38 == -1
         || (_DWORD)v39 == -1
         || v38 > v39
         || HIDWORD(v38) == -1
         || HIDWORD(v39) == -1
         || HIDWORD(v38) > HIDWORD(v39);
      v45 = v9[v34];
      if (v44)
        v46 = v9[v34 + 1];
      else
        v46 = (v39 & 0xFFFFFFFF00000000 | (v39 - 1)) - 0x100000000;
      *v37 = v38;
      v37[1] = v46;
      AlignedStrokeFrameForGridRange = TSTLayoutSpaceGetAlignedStrokeFrameForGridRange(a1, v45, v46);
      y = v48;
      width = v50;
      height = v52;
      if (a5)
      {
        if (!(v34 * 8))
          v36 = TSTLayoutSpaceGetAlignedStrokeFrameForGridRange(a1, a2, a3);
        AlignedStrokeFrameForGridRange = TSDSubtractPoints(AlignedStrokeFrameForGridRange, y, v36);
        y = v54;
      }
      if (a6 != 0.0)
      {
        v74.origin.x = AlignedStrokeFrameForGridRange;
        v74.origin.y = y;
        v74.size.width = width;
        v74.size.height = height;
        v75 = CGRectInset(v74, a6, a6);
        AlignedStrokeFrameForGridRange = v75.origin.x;
        y = v75.origin.y;
        width = v75.size.width;
        height = v75.size.height;
      }
      if (a4)
      {
        v55 = a4[1];
        *(_OWORD *)&v72.a = *a4;
        *(_OWORD *)&v72.c = v55;
        *(_OWORD *)&v72.tx = a4[2];
        v56 = AlignedStrokeFrameForGridRange;
        *(double *)&v55 = y;
        v57 = width;
        v58 = height;
        v76 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v55 - 8), &v72);
        AlignedStrokeFrameForGridRange = v76.origin.x;
        y = v76.origin.y;
        width = v76.size.width;
        height = v76.size.height;
      }
      v59 = +[TSDBezierPath bezierPathWithRect:](TSDBezierPath, "bezierPathWithRect:", AlignedStrokeFrameForGridRange, y, width, height);
      if (v35)
        v59 = -[TSDBezierPath uniteWithBezierPath:](v35, "uniteWithBezierPath:", v59);
      v34 += 2;
      v35 = v59;
    }
    while (2 * v10 != v34);
  }
  free(v9);
  return v59;
}

TSDBezierPath *TSTLayoutSpaceGetAlignedStrokeFramePathForCellRange(TSTLayoutSpace *a1, unint64_t a2, _OWORD *a3, int a4, CGFloat a5)
{
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;

  v5 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v5 = -1;
  v6 = WORD2(a2) + v5 - 1;
  if (!WORD2(a2))
    v6 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v7 = 0xFFFFFFFFLL;
  else
    v7 = (unsigned __int16)a2;
  v8 = v5 | ((unint64_t)v7 << 32);
  v9 = ((a2 >> 16) & 0xFFFF00000000) + (v7 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v9 = 0xFFFFFFFF00000000;
  return TSTLayoutSpaceGetAlignedStrokeFramePathForGridRange(a1, v8, v6 | v9, a3, a4, a5);
}

uint64_t TSTLayoutSpaceGetAlignedMaskStrokeFramePathForGridRange(TSTLayoutSpace *a1, __int128 *a2)
{
  int v4;
  unint64_t VisibleRange;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  TSDBezierPath *AlignedStrokeFramePathForGridRange;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  double v16;
  double v17;
  double v19;
  double v20;
  __int128 v21;
  CGAffineTransform *v22;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double MaxX;
  double v28;
  __int128 v29;
  CGFloat v30;
  CGFloat v31;
  CGFloat v32;
  CGFloat v33;
  double v34;
  double v35;
  __int128 v36;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  CGAffineTransform v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  CGRect v45;
  CGRect v46;
  CGRect v47;
  CGRect v48;
  CGRect v49;
  CGRect v50;
  CGRect v51;

  v4 = -[TSTLayoutSpace layoutSpaceType](a1, "layoutSpaceType");
  VisibleRange = TSTLayoutSpaceGetVisibleRange(a1);
  v6 = 0;
  if ((_WORD)VisibleRange != 0xFFFF && (VisibleRange & 0xFF0000) != 0xFF0000)
  {
    v6 = 0;
    if (HIWORD(VisibleRange))
    {
      if ((VisibleRange & 0xFFFF00000000) != 0)
      {
        if (BYTE2(VisibleRange) == 255)
          v7 = 0xFFFFFFFFLL;
        else
          v7 = BYTE2(VisibleRange);
        if (WORD2(VisibleRange))
          v8 = WORD2(VisibleRange) + v7 - 1;
        else
          v8 = 0xFFFFFFFFLL;
        v9 = (unsigned __int16)VisibleRange;
        if (((VisibleRange >> 16) & 0xFFFF00000000) != 0)
          v10 = ((VisibleRange >> 16) & 0xFFFF00000000)
              + ((unint64_t)(unsigned __int16)VisibleRange << 32)
              - 0x100000000;
        else
          v10 = 0xFFFFFFFF00000000;
        AlignedStrokeFramePathForGridRange = TSTLayoutSpaceGetAlignedStrokeFramePathForGridRange(a1, v7 | ((unint64_t)(unsigned __int16)VisibleRange << 32), v8 | v10, a2, 0, 0.0);
        switch(v4)
        {
          case 3:
            v47.origin.x = TSTLayoutSpaceGetAlignedOverrideFrameForGridRange(a1, v10 | v7, v8 | v10, 0.0);
            x = v47.origin.x;
            y = v47.origin.y;
            width = v47.size.width;
            height = v47.size.height;
            MaxX = CGRectGetMaxX(v47);
            v48.origin.x = x;
            v48.origin.y = y;
            v48.size.width = width;
            v48.size.height = height;
            CGRectGetMaxY(v48);
            v17 = TSDRectWithPoints(-100000.0, -100000.0, MaxX);
            v19 = v28 + 100000.0;
            v29 = a2[1];
            v38 = *a2;
            v39 = v29;
            v40 = a2[2];
            v22 = (CGAffineTransform *)&v38;
            break;
          case 2:
            v49.origin.x = TSTLayoutSpaceGetAlignedOverrideFrameForGridRange(a1, v8 | (v9 << 32), v8 | v10, 0.0);
            v30 = v49.origin.x;
            v31 = v49.origin.y;
            v32 = v49.size.width;
            v33 = v49.size.height;
            v34 = CGRectGetMaxX(v49);
            v50.origin.x = v30;
            v50.origin.y = v31;
            v50.size.width = v32;
            v50.size.height = v33;
            CGRectGetMaxY(v50);
            v17 = TSDRectWithPoints(-100000.0, -100000.0, v34);
            v20 = v35 + 100000.0;
            v36 = a2[1];
            *(_OWORD *)&v41.a = *a2;
            *(_OWORD *)&v41.c = v36;
            *(_OWORD *)&v41.tx = a2[2];
            v22 = &v41;
            break;
          case 1:
            v45.origin.x = TSTLayoutSpaceGetAlignedOverrideFrameForGridRange(a1, v8 | v10, v8 | v10, 0.0);
            v12 = v45.origin.x;
            v13 = v45.origin.y;
            v14 = v45.size.width;
            v15 = v45.size.height;
            v16 = CGRectGetMaxX(v45);
            v46.origin.x = v12;
            v46.origin.y = v13;
            v46.size.width = v14;
            v46.size.height = v15;
            CGRectGetMaxY(v46);
            v17 = TSDRectWithPoints(-100000.0, -100000.0, v16);
            v21 = a2[1];
            v42 = *a2;
            v43 = v21;
            v44 = a2[2];
            v22 = (CGAffineTransform *)&v42;
            break;
          default:
            v51 = *(CGRect *)*(_QWORD *)&MEMORY[0x24BDBF090];
            return (uint64_t)-[TSDBezierPath uniteWithBezierPath:](AlignedStrokeFramePathForGridRange, "uniteWithBezierPath:", +[TSDBezierPath bezierPathWithRect:](TSDBezierPath, "bezierPathWithRect:", v51.origin.x, v51.origin.y, v51.size.width, v51.size.height, v38, v39, v40, *(_QWORD *)&v41.a, *(_QWORD *)&v41.b, *(_QWORD *)&v41.c, *(_QWORD *)&v41.d, *(_QWORD *)&v41.tx, *(_QWORD *)&v41.ty, v42,
                                v43,
                                v44));
        }
        v51 = CGRectApplyAffineTransform(*(CGRect *)&v17, v22);
        return (uint64_t)-[TSDBezierPath uniteWithBezierPath:](AlignedStrokeFramePathForGridRange, "uniteWithBezierPath:", +[TSDBezierPath bezierPathWithRect:](TSDBezierPath, "bezierPathWithRect:", v51.origin.x, v51.origin.y, v51.size.width, v51.size.height, v38, v39, v40, *(_QWORD *)&v41.a, *(_QWORD *)&v41.b, *(_QWORD *)&v41.c, *(_QWORD *)&v41.d, *(_QWORD *)&v41.tx, *(_QWORD *)&v41.ty, v42,
                            v43,
                            v44));
      }
    }
  }
  return v6;
}

double TSTLayoutSpaceGetAlignedOverrideFrameForGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3, double a4)
{
  _OWORD v6[5];
  double v7[3];
  double v8;

  v8 = a4;
  *(_OWORD *)v7 = 0u;
  memset(v6, 0, sizeof(v6));
  TSTLayoutSpaceGetFrameSpecForGridRange(a1, a2, a3, 0, &v8, (double *)v6);
  TSTLayoutSpaceGetAlignFrameSpec(a1, (double *)v6);
  return *(double *)v6 - v7[0] * 0.5;
}

TSDBezierPath *TSTLayoutSpaceGetAlignedStrokeLinePathForRowGridRange(TSTLayoutSpace *a1, uint64_t a2, unint64_t a3, _OWORD *a4, int a5, CGFloat a6)
{
  uint64_t v9;
  TSTStrokeRunArray *MergedStrokesForGridRow;
  unsigned int v11;
  double v12;
  unsigned int *NextStroke;
  unsigned int *v14;
  TSDBezierPath *v15;
  double v16;
  char v17;
  uint64_t v18;
  double v19;
  double v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  TSDBezierPath *v24;
  unint64_t v25;
  double v26;
  double AlignedStrokeLineForRowGridRange;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  __int128 v38;
  double v39;
  double v40;
  double v41;
  TSDBezierPath *v42;
  unsigned int v44;
  uint64_t v45;
  unint64_t v46;
  CGAffineTransform v49;
  _DWORD v50[3];

  v9 = a2;
  MergedStrokesForGridRow = TSTMasterLayoutGetMergedStrokesForGridRow(-[TSTLayoutSpace masterLayout](a1, "masterLayout"), HIDWORD(a2));
  v11 = a3 + 1;
  v12 = *MEMORY[0x24BDBEFB0];
  v50[0] = 0;
  v45 = (uint64_t)MergedStrokesForGridRow;
  NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridRow, v9, (int)a3 + 1, v50);
  if (NextStroke)
  {
    v14 = NextStroke;
    v15 = 0;
    v46 = v9 & 0xFFFFFFFF00000000;
    v16 = -1.0;
    v17 = 1;
    LODWORD(v18) = v9;
    v44 = v9;
    do
    {
      objc_msgSend(*((id *)v14 + 1), "width");
      v20 = v19;
      v21 = v14[1];
      if (*v14 > v9)
        LODWORD(v9) = *v14;
      if (v21 >= v11)
        v22 = v11;
      else
        v22 = v14[1];
      v23 = v22 - 1;
      v24 = v15;
      while (1)
      {
        v25 = v16 == v20 ? a3 & 0xFFFFFFFF00000000 | v23 : a3;
        a3 = v16 < 0.0 ? a3 & 0xFFFFFFFF00000000 | v23 : v25;
        v18 = v16 < 0.0 ? v9 : v18;
        v26 = v16 < 0.0 ? v20 : v16;
        if (v26 == v20 && v11 > v21)
          break;
        AlignedStrokeLineForRowGridRange = TSTLayoutSpaceGetAlignedStrokeLineForRowGridRange(a1, v46 | v18, a3);
        v31 = v30;
        v33 = v32;
        if (a5)
        {
          if ((v17 & 1) != 0)
            v12 = AlignedStrokeLineForRowGridRange;
          AlignedStrokeLineForRowGridRange = TSDSubtractPoints(AlignedStrokeLineForRowGridRange, v29, v12);
          v17 = 0;
        }
        if (a6 != 0.0)
        {
          v34 = v31;
          v35 = v33;
          *(CGRect *)&AlignedStrokeLineForRowGridRange = CGRectInset(*(CGRect *)&AlignedStrokeLineForRowGridRange, a6, a6);
          v31 = v36;
          v33 = v37;
        }
        if (a4)
        {
          v38 = a4[1];
          *(_OWORD *)&v49.a = *a4;
          *(_OWORD *)&v49.c = v38;
          *(_OWORD *)&v49.tx = a4[2];
          v39 = v31;
          *(double *)&v38 = v33;
          *(CGRect *)&AlignedStrokeLineForRowGridRange = CGRectApplyAffineTransform(*(CGRect *)&AlignedStrokeLineForRowGridRange, &v49);
          v31 = v40;
          v33 = v41;
        }
        v42 = +[TSDBezierPath bezierPathWithRect:](TSDBezierPath, "bezierPathWithRect:", AlignedStrokeLineForRowGridRange, v29, v31, v33);
        v15 = v42;
        if (v24)
        {
          v24 = -[TSDBezierPath uniteWithBezierPath:](v24, "uniteWithBezierPath:", v42);
          v16 = -1.0;
          v15 = v24;
          if (v26 == v20)
            goto LABEL_39;
        }
        else
        {
          v16 = -1.0;
          v24 = v42;
          if (v26 == v20)
            goto LABEL_39;
        }
      }
      v15 = v24;
      v16 = v26;
LABEL_39:
      LODWORD(v9) = v44;
      v14 = TSTStrokeRunArrayGetNextStroke(v45, v44, v11, v50);
    }
    while (v14);
  }
  else
  {
    v15 = 0;
  }
  TSTStrokeRunArrayUnlock(v45);
  return v15;
}

TSDBezierPath *TSTLayoutSpaceGetAlignedStrokeLinePathForColumnGridRange(TSTLayoutSpace *a1, unint64_t a2, unint64_t a3, _OWORD *a4, int a5, CGFloat a6)
{
  unint64_t v8;
  unsigned int v9;
  unint64_t v10;
  unint64_t v11;
  TSTStrokeRunArray *MergedStrokesForGridColumn;
  unsigned int v13;
  double v14;
  unsigned int *NextStroke;
  unsigned int *v16;
  TSDBezierPath *v17;
  double v18;
  char v19;
  uint64_t v20;
  double v21;
  double v22;
  unsigned int v23;
  unsigned int v24;
  unint64_t v25;
  TSDBezierPath *v26;
  unint64_t v27;
  double v28;
  double AlignedStrokeLineForColumnGridRange;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  __int128 v40;
  double v41;
  double v42;
  double v43;
  TSDBezierPath *v44;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  CGAffineTransform v51;
  _DWORD v52[3];

  v8 = a3;
  v9 = a2;
  v10 = HIDWORD(a2);
  v11 = HIDWORD(a3);
  MergedStrokesForGridColumn = TSTMasterLayoutGetMergedStrokesForGridColumn(-[TSTLayoutSpace masterLayout](a1, "masterLayout"), a2);
  v13 = v11 + 1;
  v14 = *MEMORY[0x24BDBEFB0];
  v52[0] = 0;
  v47 = (uint64_t)MergedStrokesForGridColumn;
  NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridColumn, v10, (int)v11 + 1, v52);
  if (NextStroke)
  {
    v16 = NextStroke;
    v17 = 0;
    v48 = v9;
    v18 = -1.0;
    v19 = 1;
    LODWORD(v20) = v10;
    v46 = v10;
    do
    {
      objc_msgSend(*((id *)v16 + 1), "width");
      v22 = v21;
      v23 = v16[1];
      if (*v16 > v10)
        LODWORD(v10) = *v16;
      if (v23 >= v13)
        v24 = v13;
      else
        v24 = v16[1];
      v25 = (unint64_t)(v24 - 1) << 32;
      v26 = v17;
      while (1)
      {
        v27 = v18 == v22 ? v8 | v25 : v8;
        v8 = v18 < 0.0 ? v8 | v25 : v27;
        v20 = v18 < 0.0 ? v10 : v20;
        v28 = v18 < 0.0 ? v22 : v18;
        if (v28 == v22 && v13 > v23)
          break;
        AlignedStrokeLineForColumnGridRange = TSTLayoutSpaceGetAlignedStrokeLineForColumnGridRange(a1, v48 | (v20 << 32), v8);
        v33 = v32;
        v35 = v34;
        if (a5)
        {
          if ((v19 & 1) != 0)
            v14 = AlignedStrokeLineForColumnGridRange;
          AlignedStrokeLineForColumnGridRange = TSDSubtractPoints(AlignedStrokeLineForColumnGridRange, v31, v14);
          v19 = 0;
        }
        if (a6 != 0.0)
        {
          v36 = v33;
          v37 = v35;
          *(CGRect *)&AlignedStrokeLineForColumnGridRange = CGRectInset(*(CGRect *)&AlignedStrokeLineForColumnGridRange, a6, a6);
          v33 = v38;
          v35 = v39;
        }
        if (a4)
        {
          v40 = a4[1];
          *(_OWORD *)&v51.a = *a4;
          *(_OWORD *)&v51.c = v40;
          *(_OWORD *)&v51.tx = a4[2];
          v41 = v33;
          *(double *)&v40 = v35;
          *(CGRect *)&AlignedStrokeLineForColumnGridRange = CGRectApplyAffineTransform(*(CGRect *)&AlignedStrokeLineForColumnGridRange, &v51);
          v33 = v42;
          v35 = v43;
        }
        v44 = +[TSDBezierPath bezierPathWithRect:](TSDBezierPath, "bezierPathWithRect:", AlignedStrokeLineForColumnGridRange, v31, v33, v35);
        v17 = v44;
        if (v26)
        {
          v26 = -[TSDBezierPath uniteWithBezierPath:](v26, "uniteWithBezierPath:", v44);
          v18 = -1.0;
          v17 = v26;
          if (v28 == v22)
            goto LABEL_39;
        }
        else
        {
          v18 = -1.0;
          v26 = v44;
          if (v28 == v22)
            goto LABEL_39;
        }
      }
      v17 = v26;
      v18 = v28;
LABEL_39:
      LODWORD(v10) = v46;
      v16 = TSTStrokeRunArrayGetNextStroke(v47, v46, v13, v52);
    }
    while (v16);
  }
  else
  {
    v17 = 0;
  }
  TSTStrokeRunArrayUnlock(v47);
  return v17;
}

CGFloat TSTLayoutSpaceGetAlignedFrame(uint64_t a1)
{
  CGFloat result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!CGRectIsEmpty(*(CGRect *)(a1 + 336)))
    return *(double *)(a1 + 336);
  result = TSTLayoutSpaceGetAlignedFrameForGridRange((TSTLayoutSpace *)a1, *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
  *(CGFloat *)(a1 + 336) = result;
  *(_QWORD *)(a1 + 344) = v3;
  *(_QWORD *)(a1 + 352) = v4;
  *(_QWORD *)(a1 + 360) = v5;
  return result;
}

double TSTLayoutSpaceGetAlignedStrokeFrame(uint64_t a1)
{
  double result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!CGRectIsEmpty(*(CGRect *)(a1 + 400)))
    return *(double *)(a1 + 400);
  result = TSTLayoutSpaceGetAlignedStrokeFrameForGridRange((TSTLayoutSpace *)a1, *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
  *(double *)(a1 + 400) = result;
  *(_QWORD *)(a1 + 408) = v3;
  *(_QWORD *)(a1 + 416) = v4;
  *(_QWORD *)(a1 + 424) = v5;
  return result;
}

void TSTLayoutSpaceDrawSingleStroke(void *a1, CGContext *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, double a7, double a8, double a9, double a10, CGFloat a11, CGFloat a12, CGFloat a13, CGFloat a14)
{
  char v26;
  int v27;
  int v28;
  double v29;
  double v30;
  void *v31;
  double v32;
  uint64_t v33;
  CGPath *Mutable;
  double v35;
  double v36;
  CGFloat MinY;
  double v38;
  double v39;
  double v40;
  CGFloat MinX;
  double v42;
  double v43;
  double v44;
  CGPath *v45;
  double rect;
  double recta;
  id v48;
  CGRect v49;
  CGRect v50;

  v26 = objc_msgSend(a1, "empty");
  if (a7 > 0.0 && (v26 & 1) == 0)
  {
    v48 = (id)objc_msgSend(a1, "mutableCopy");
    objc_msgSend(v48, "setWidth:", a7);
    v27 = objc_msgSend(a1, "solid");
    v28 = objc_msgSend(a1, "dontClearBackground");
    if (a8 < 1.0)
    {
      rect = a6;
      objc_msgSend((id)objc_msgSend(a1, "color"), "alphaComponent");
      v30 = v29;
      v31 = (void *)objc_msgSend(a1, "color");
      v32 = 1.0 - a8;
      if (v30 >= 1.0)
        v33 = objc_msgSend(MEMORY[0x24BEB3C40], "whiteColor");
      else
        v33 = objc_msgSend(MEMORY[0x24BEB3C40], "clearColor");
      objc_msgSend(v48, "setColor:", (id)objc_msgSend(v31, "newBlendedColorWithFraction:ofColor:", v33, v32));
      a6 = rect;
    }
    if ((v27 ^ 1 | v28) != 1)
    {
      Mutable = CGPathCreateMutable();
      CGPathMoveToPoint(Mutable, 0, a3, a4);
      CGPathAddLineToPoint(Mutable, 0, a5, a6);
      objc_msgSend(v48, "paintPath:inContext:", Mutable, a2);
      CGPathRelease(Mutable);
LABEL_20:

      return;
    }
    CGContextSaveGState(a2);
    if ((v27 & 1) != 0)
    {
      if (!v28)
        goto LABEL_19;
    }
    else
    {
      v35 = a7 * 0.5;
      if (a3 == a5)
      {
        v36 = a3 - v35;
        v49.origin.x = a11;
        v49.origin.y = a12;
        v49.size.width = a13;
        v49.size.height = a14;
        MinY = CGRectGetMinY(v49);
        v38 = v36;
        v39 = a4;
        v40 = a7;
        a7 = a6 - a4;
        a4 = MinY;
      }
      else
      {
        recta = a4 - v35;
        v40 = a5 - a3;
        v50.origin.x = a11;
        v50.origin.y = a12;
        v50.size.width = a13;
        v50.size.height = a14;
        MinX = CGRectGetMinX(v50);
        v39 = recta;
        v38 = a3;
        a3 = MinX;
      }
      v42 = v38;
      v43 = v40;
      v44 = a7;
      CGContextClipToRect(a2, *(CGRect *)(&v39 - 1));
      if (!v28)
        goto LABEL_19;
    }
    CGContextSetBlendMode(a2, kCGBlendModeNormal);
LABEL_19:
    v45 = CGPathCreateMutable();
    CGPathMoveToPoint(v45, 0, a3, a4);
    CGPathAddLineToPoint(v45, 0, a5, a6);
    objc_msgSend(v48, "paintPath:inContext:", v45, a2);
    CGPathRelease(v45);
    CGContextRestoreGState(a2);
    goto LABEL_20;
  }
}

void TSTLayoutSpaceDrawStrokes(TSTLayoutSpace *a1, uint64_t a2, uint64_t a3, int a4, CGContext *a5)
{
  TSTMasterLayout *v9;
  $FC6C44E672DFCBD714A302CF0DF56F45 *p_mGridRange;
  $3C36844D3994842D9102894F8152D7DE topLeft;
  unint64_t bottomRight;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t Range;
  unint64_t v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  int PartitionFirstBodyColumn;
  int v31;
  uint64_t v32;
  int PartitionFirstBodyRow;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  char v39;
  uint64_t v40;
  char v41;
  char v42;
  char v43;
  char v44;
  unsigned int PartitionLastBodyRow;
  CGContext *c;
  unsigned int v47;
  unsigned int v48;
  char v49;
  unint64_t v50;
  char v51;
  unint64_t v52;

  v9 = -[TSTLayoutSpace masterLayout](a1, "masterLayout");
  CGContextSaveGState(a5);
  c = a5;
  CGContextSetBlendMode(a5, kCGBlendModeCopy);
  p_mGridRange = ($FC6C44E672DFCBD714A302CF0DF56F45 *)&TSTGridRangeEmpty;
  if (a1)
    p_mGridRange = &a1->mGridRange;
  topLeft = p_mGridRange->topLeft;
  bottomRight = (unint64_t)p_mGridRange->bottomRight;
  if (topLeft.column != -1
    && (_DWORD)bottomRight != -1
    && topLeft.column <= bottomRight
    && topLeft.row != -1
    && HIDWORD(bottomRight) != -1
    && topLeft.row <= HIDWORD(bottomRight))
  {
    bottomRight = (bottomRight & 0xFFFFFFFF00000000 | (bottomRight + 1)) + 0x100000000;
  }
  v18 = -1;
  if ((_DWORD)a2 == -1 || (_DWORD)a3 == -1)
  {
    v19 = -1;
  }
  else
  {
    v19 = -1;
    if (a2 <= a3
      && HIDWORD(a2) != -1
      && HIDWORD(a3) != -1
      && HIDWORD(a2) <= HIDWORD(a3)
      && topLeft.column != -1
      && (_DWORD)bottomRight != -1
      && topLeft.column <= bottomRight)
    {
      v20 = HIDWORD(*(unint64_t *)&topLeft);
      if (topLeft.row != -1)
      {
        v21 = HIDWORD(bottomRight);
        if (HIDWORD(bottomRight) != -1 && topLeft.row <= HIDWORD(bottomRight))
        {
          topLeft = a2 <= topLeft.column
                  ? ($3C36844D3994842D9102894F8152D7DE)topLeft.column
                  : ($3C36844D3994842D9102894F8152D7DE)a2;
          bottomRight = a3 >= bottomRight ? bottomRight : a3;
          if (topLeft.column <= bottomRight)
          {
            v22 = HIDWORD(a3) >= v21 ? v21 : HIDWORD(a3);
            v23 = HIDWORD(a2) <= v20 ? v20 : HIDWORD(a2);
            if (v23 <= v22)
            {
              v19 = bottomRight | (v22 << 32);
              v18 = *(_QWORD *)&topLeft | (v23 << 32);
            }
          }
        }
      }
    }
  }
  v52 = v18;
  Range = TSTMasterLayoutGetRange((uint64_t)-[TSTLayoutSpace masterLayout](a1, "masterLayout"));
  v25 = Range;
  if (BYTE2(Range) == 255)
    v26 = -1;
  else
    v26 = BYTE2(Range);
  if (WORD2(Range))
    v27 = WORD2(Range) + v26 - 1;
  else
    v27 = -1;
  if ((unsigned __int16)Range == 0xFFFF)
    v28 = -1;
  else
    v28 = (unsigned __int16)Range;
  v50 = (unint64_t)((HIDWORD(Range) << 16) - 0x100000000) >> 32;
  if (TSTMasterLayoutIsColumnHidden(v9, v26))
    v29 = 0xFFFFFFFFLL;
  else
    v29 = v26;
  PartitionFirstBodyColumn = TSTLayoutGetPartitionFirstBodyColumn(-[TSTLayoutSpace layout](a1, "layout"));
  if (!TSTMasterLayoutGetTableNumberOfHeaderColumns((unsigned __int16 *)v9)
    || TSTMasterLayoutIsColumnHidden(v9, PartitionFirstBodyColumn))
  {
    PartitionFirstBodyColumn = -1;
  }
  if (TSTMasterLayoutIsColumnHidden(v9, v27))
    v31 = -1;
  else
    v31 = PartitionFirstBodyColumn;
  v47 = v31;
  if (TSTMasterLayoutIsRowHidden(v9, (unsigned __int16)v28))
    v32 = 0xFFFFFFFFLL;
  else
    v32 = v28;
  PartitionFirstBodyRow = TSTLayoutGetPartitionFirstBodyRow(-[TSTLayoutSpace layout](a1, "layout"));
  if (!TSTMasterLayoutGetTableNumberOfHeaderRows((unsigned __int16 *)v9)
    || TSTMasterLayoutIsRowHidden(v9, (unsigned __int16)PartitionFirstBodyRow))
  {
    PartitionFirstBodyRow = -1;
  }
  v48 = PartitionFirstBodyRow;
  v34 = HIDWORD(v52);
  v35 = v28 + v50;
  PartitionLastBodyRow = TSTLayoutGetPartitionLastBodyRow(-[TSTLayoutSpace layout](a1, "layout"));
  if (!TSTMasterLayoutGetTableNumberOfFooterRows((unsigned __int16 *)v9)
    || !TSTMasterLayoutGetTableNumberOfNonHiddenFooterRows(v9)
    || TSTMasterLayoutIsRowHidden(v9, (unsigned __int16)(PartitionLastBodyRow + 1)))
  {
    PartitionLastBodyRow = -1;
  }
  v36 = (v27 + 1);
  if (HIWORD(v25))
    v37 = v35;
  else
    v37 = -1;
  if (TSTMasterLayoutIsRowHidden(v9, (unsigned __int16)v37))
    v38 = 0xFFFFFFFFLL;
  else
    v38 = (v37 + 1);
  if (v52 <= v19)
  {
    v39 = 0;
    v44 = 0;
    v51 = 0;
    v40 = v52;
    do
    {
      if ((_DWORD)v29 == (_DWORD)v40)
      {
        v39 = 1;
      }
      else if ((_DWORD)v36 == (_DWORD)v40)
      {
        v51 = 1;
      }
      else if (v47 == (_DWORD)v40)
      {
        v44 = 1;
      }
      else
      {
        TSTLayoutSpaceDrawColumnStroke(a1, v40, v52, v19, a4, c, 0);
      }
      v40 = (v40 + 1);
    }
    while (v40 <= v19);
  }
  else
  {
    v51 = 0;
    v44 = 0;
    v39 = 0;
  }
  if (HIDWORD(v52) <= HIDWORD(v19))
  {
    v42 = 0;
    v41 = 0;
    v43 = 0;
    v49 = 0;
    do
    {
      if ((_DWORD)v32 == (_DWORD)v34)
      {
        v42 = 1;
      }
      else if ((_DWORD)v38 == (_DWORD)v34)
      {
        v49 = 1;
      }
      else if (v48 == (_DWORD)v34)
      {
        v41 = 1;
      }
      else if (PartitionLastBodyRow == (_DWORD)v34)
      {
        v43 = 1;
      }
      else
      {
        TSTLayoutSpaceDrawRowStroke(a1, v34, v52, v19, a4, c, 0);
      }
      v34 = (v34 + 1);
    }
    while (v34 <= HIDWORD(v19));
  }
  else
  {
    v49 = 0;
    v43 = 0;
    v41 = 0;
    v42 = 0;
  }
  if ((v44 & 1) != 0)
    TSTLayoutSpaceDrawColumnStroke(a1, v47, v52, v19, a4, c, -[TSTLayoutSpace layoutSpaceType](a1, "layoutSpaceType") - 1 < 2);
  if ((v41 & 1) != 0)
    TSTLayoutSpaceDrawRowStroke(a1, v48, v52, v19, a4, c, (-[TSTLayoutSpace layoutSpaceType](a1, "layoutSpaceType") & 0xFFFFFFFD) == 1);
  if ((v43 & 1) != 0)
    TSTLayoutSpaceDrawRowStroke(a1, PartitionLastBodyRow, v52, v19, a4, c, 0);
  if ((v39 & 1) != 0)
    TSTLayoutSpaceDrawColumnStroke(a1, v29, v52, v19, a4, c, 0);
  if ((v51 & 1) != 0)
    TSTLayoutSpaceDrawColumnStroke(a1, v36, v52, v19, a4, c, 0);
  if ((v42 & 1) != 0)
    TSTLayoutSpaceDrawRowStroke(a1, v32, v52, v19, a4, c, 0);
  if ((v49 & 1) != 0)
    TSTLayoutSpaceDrawRowStroke(a1, v38, v52, v19, a4, c, 0);
  CGContextRestoreGState(c);
}

uint64_t TSTLayoutSpaceDrawColumnStroke(TSTLayoutSpace *a1, uint64_t a2, unint64_t a3, unint64_t a4, int a5, CGContext *a6, int a7)
{
  TSTMasterLayout *v13;
  double AlignedStrokeFrame;
  double v15;
  double v16;
  double v17;
  double LayoutPointForTablePoint;
  uint64_t result;
  unint64_t v20;
  unint64_t v21;
  TSTStrokeRunArray *MergedStrokesForGridColumn;
  unsigned int *NextStroke;
  unsigned int *v24;
  unsigned int v25;
  void *v26;
  double v27;
  double v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  double v32;
  double v33;
  double v34;
  CGFloat v35;
  double v36;
  char v37;
  char v38;
  void *v39;
  double *v40;
  uint64_t v41;
  CGFloat v42;
  CGFloat x;
  uint64_t v44;
  CGFloat v45;
  CGFloat v46;
  CGFloat v47;
  CGFloat v48;
  double v49;
  double v50;
  int v51;
  double v52;
  double v53;
  int v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  CGFloat v60;
  double v61;
  CGFloat v62;
  CGFloat v63;
  int v64;
  TSTStrokeRunArray *v65;
  CGFloat rect2;
  CGFloat width;
  CGFloat y;
  CGFloat height;
  CGFloat v71;
  CGFloat v72;
  CGFloat v73;
  unsigned int v74;
  unsigned int v75;
  TSTMasterLayout *v76;
  double v77;
  double v78;
  double v79;
  double v80;
  double v81;
  double v82;
  CGPoint v83;
  CGFloat v84;
  double v85;
  CGFloat v86;
  _DWORD v87[3];
  CGPoint v88;
  CGPoint v89;
  CGPoint v90;
  CGPoint v91;
  CGPoint v92;
  CGRect v93;
  CGRect v94;
  CGRect v95;
  CGRect v96;
  CGRect ClipBoundingBox;
  CGRect v98;
  CGRect v99;
  CGRect v100;
  CGRect v101;
  CGRect v102;

  v13 = -[TSTLayoutSpace masterLayout](a1, "masterLayout");
  if (-[TSTLayoutSpace drawPreventAntialias](a1, "drawPreventAntialias"))
    AlignedStrokeFrame = TSTLayoutSpaceGetAlignedStrokeFrame((uint64_t)a1);
  else
    AlignedStrokeFrame = TSTLayoutSpaceGetStrokeFrame((uint64_t)a1);
  v62 = v15;
  v63 = AlignedStrokeFrame;
  v60 = v17;
  v61 = v16;
  v88.x = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, a2);
  v88.y = 0.0;
  LayoutPointForTablePoint = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v88);
  result = TSTMasterLayoutIsGridColumnHidden(v13, a2);
  if ((result & 1) == 0)
  {
    v20 = HIDWORD(a3);
    v21 = HIDWORD(a4);
    v76 = v13;
    MergedStrokesForGridColumn = TSTMasterLayoutGetMergedStrokesForGridColumn(v13, a2);
    v87[0] = 0;
    NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridColumn, v20, HIDWORD(a4), v87);
    if (NextStroke)
    {
      v24 = NextStroke;
      if ((_DWORD)a2)
        v25 = a2 - 1;
      else
        v25 = 0;
      v74 = a2 + 1;
      v75 = v25;
      v65 = MergedStrokesForGridColumn;
      v64 = a7;
      while (1)
      {
        v26 = (void *)*((_QWORD *)v24 + 1);
        objc_msgSend(v26, "width");
        v28 = v27;
        v86 = v27;
        v29 = v24[1];
        v30 = *v24 <= v20 ? v20 : *v24;
        v31 = v29 >= v21 ? v21 : v29;
        v89.y = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, v30);
        v89.x = 0.0;
        TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v89);
        v33 = v32;
        v84 = LayoutPointForTablePoint;
        v85 = v32;
        v90.y = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, v31);
        v90.x = 0.0;
        v34 = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v90);
        v36 = v35;
        v83.x = LayoutPointForTablePoint;
        v83.y = v35;
        v37 = objc_msgSend(v26, "empty", v34);
        v38 = a7 ? 0 : v37;
        if ((v38 & 1) == 0 && v33 != v36)
          break;
LABEL_61:
        v24 = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridColumn, v20, v21, v87);
        if (!v24)
          return TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridColumn);
      }
      v78 = v28;
      if (-[TSTLayoutSpace drawBlackAndWhite](a1, "drawBlackAndWhite"))
      {
        v39 = (void *)objc_msgSend(v26, "mutableCopy");
        objc_msgSend(v39, "setColor:", objc_msgSend(MEMORY[0x24BEB3C40], "blackColor"));
      }
      else
      {
        if ((objc_msgSend(v26, "solid") & 1) != 0 || -[TSTMasterLayout tableEnvironment](v76, "tableEnvironment") != 1)
        {
          v39 = 0;
          goto LABEL_28;
        }
        v39 = (void *)objc_msgSend(v26, "mutableCopy");
        v28 = 1.0;
        objc_msgSend(v39, "setWidth:", 1.0);
        v86 = 1.0;
      }
      v26 = v39;
LABEL_28:
      v81 = 0.0;
      v82 = 0.0;
      TSTLayoutSpaceAlignStrokeWidth(a1, v28, &v82, &v81);
      v40 = (double *)MEMORY[0x24BDBF148];
      v93.origin.x = TSDRectWithOriginAndSize(v41, LayoutPointForTablePoint, v33, *MEMORY[0x24BDBF148], *(double *)(MEMORY[0x24BDBF148] + 8));
      v42 = -v81;
      v94 = CGRectInset(v93, -v81, -v81);
      x = v94.origin.x;
      width = v94.size.width;
      y = v94.origin.y;
      rect2 = v94.size.height;
      v77 = v36;
      v95.origin.x = TSDRectWithOriginAndSize(v44, LayoutPointForTablePoint, v36, *v40, v40[1]);
      v96 = CGRectInset(v95, v42, v42);
      v72 = v96.origin.y;
      v73 = v96.origin.x;
      height = v96.size.height;
      v71 = v96.size.width;
      ClipBoundingBox = CGContextGetClipBoundingBox(a6);
      v45 = ClipBoundingBox.origin.x;
      v46 = ClipBoundingBox.origin.y;
      v47 = ClipBoundingBox.size.width;
      v48 = ClipBoundingBox.size.height;
      v91.x = LayoutPointForTablePoint;
      v91.y = v33;
      if (CGRectContainsPoint(ClipBoundingBox, v91))
        goto LABEL_30;
      v98.origin.x = v45;
      v98.origin.y = v46;
      v98.size.width = v47;
      v98.size.height = v48;
      v101.origin.x = x;
      v101.size.width = width;
      v101.origin.y = y;
      v101.size.height = rect2;
      v49 = 0.0;
      if (CGRectIntersectsRect(v98, v101))
LABEL_30:
        v49 = TSTMasterLayoutStrokeHeightOfGridRow(v76, v30, v75, v74);
      v99.origin.x = v45;
      v99.origin.y = v46;
      v99.size.width = v47;
      v99.size.height = v48;
      v92.x = LayoutPointForTablePoint;
      v92.y = v77;
      if (CGRectContainsPoint(v99, v92))
        goto LABEL_33;
      v100.origin.x = v45;
      v100.origin.y = v46;
      v100.size.width = v47;
      v100.size.height = v48;
      v102.origin.y = v72;
      v102.origin.x = v73;
      v102.size.height = height;
      v102.size.width = v71;
      v50 = 0.0;
      if (CGRectIntersectsRect(v100, v102))
LABEL_33:
        v50 = TSTMasterLayoutStrokeHeightOfGridRow(v76, v31, v75, v74);
      a7 = v64;
      if (v49 > 0.0 && ((*((unsigned __int8 *)v24 + 24) >> 2) & 3u) - 1 <= 1)
      {
        v80 = 0.0;
        TSTLayoutSpaceAlignStrokeWidth(a1, v49, &v80, &v79);
        v51 = (*((unsigned __int8 *)v24 + 24) >> 2) & 3;
        if (v51 == 2)
        {
          v52 = v80;
          v53 = 0.5;
          goto LABEL_40;
        }
        if (v51 == 1)
        {
          v52 = v80;
          v53 = -0.5;
LABEL_40:
          v85 = v33 + v52 * v53;
        }
      }
      if (v50 <= 0.0 || ((*((unsigned __int8 *)v24 + 24) >> 4) & 3u) - 1 > 1)
        goto LABEL_48;
      v80 = 0.0;
      TSTLayoutSpaceAlignStrokeWidth(a1, v50, &v80, &v79);
      v54 = (*((unsigned __int8 *)v24 + 24) >> 4) & 3;
      if (v54 == 2)
      {
        v55 = v80;
        v56 = -0.5;
      }
      else
      {
        if (v54 != 1)
          goto LABEL_48;
        v55 = v80;
        v56 = 0.5;
      }
      v83.y = v77 + v55 * v56;
LABEL_48:
      if (-[TSTLayoutSpace drawPreventAntialias](a1, "drawPreventAntialias"))
      {
        TSTLayoutSpaceAlignStrokeCoordinates(a1, &v84, &v83, &v86);
        -[TSTLayoutSpace viewScale](a1, "viewScale");
        if (v57 < 0.330000013)
          v86 = v78;
      }
      if (a5)
      {
        objc_msgSend((id)objc_msgSend(v26, "color"), "alphaComponent");
        if (v58 > 0.0)
        {
          CGContextSaveGState(a6);
          CGContextBeginPath(a6);
          CGContextMoveToPoint(a6, v84, v85);
          CGContextAddLineToPoint(a6, v83.x, v83.y);
          CGContextSetLineWidth(a6, v86);
          CGContextSetBlendMode(a6, kCGBlendModeClear);
          CGContextStrokePath(a6);
          CGContextRestoreGState(a6);
        }
      }
      else if ((objc_msgSend(v26, "empty") & 1) == 0)
      {
        TSTLayoutSpaceDrawSingleStroke(v26, a6, v84, v85, v83.x, v83.y, v86, v78, v61, v59, v63, v62, v61, v60);
      }
      if (v64 == 1)
      {
        v84 = v84 + v86 * 0.5;
        v83.x = v86 * 0.5 + v83.x;
        TSTTableBadgeDrawVerticalShadow(a6, 1, v84, v85, v83.x, v83.y, a1->mTransformFromDevice.a + a1->mTransformFromDevice.c);
      }
      if (v39)

      MergedStrokesForGridColumn = v65;
      goto LABEL_61;
    }
    return TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridColumn);
  }
  return result;
}

uint64_t TSTLayoutSpaceDrawRowStroke(TSTLayoutSpace *a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, CGContext *a6, int a7)
{
  TSTMasterLayout *v13;
  double AlignedStrokeFrame;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  uint64_t result;
  TSTStrokeRunArray *MergedStrokesForGridRow;
  unsigned int *NextStroke;
  unsigned int *v23;
  unsigned int v24;
  void *v25;
  double v26;
  double v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  double LayoutPointForTablePoint;
  double v32;
  double v33;
  char v34;
  char v35;
  void *v36;
  double *v37;
  uint64_t v38;
  CGFloat v39;
  CGFloat x;
  uint64_t v41;
  CGFloat v42;
  CGFloat v43;
  CGFloat v44;
  CGFloat v45;
  double v46;
  double v47;
  int v48;
  double v49;
  double v50;
  int v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  CGFloat v57;
  double v58;
  CGFloat v59;
  CGFloat v60;
  int v61;
  TSTStrokeRunArray *v62;
  CGFloat rect2;
  CGFloat width;
  CGFloat y;
  CGFloat height;
  CGFloat v68;
  CGFloat v69;
  CGFloat v70;
  unsigned int v71;
  unsigned int v72;
  TSTMasterLayout *v73;
  double v74;
  CGPoint point;
  double v76;
  double v77;
  double v78;
  CGPoint v79;
  double v80;
  CGFloat v81;
  CGFloat v82;
  _DWORD v83[3];
  CGPoint v84;
  CGPoint v85;
  CGPoint v86;
  CGPoint v87;
  CGPoint v88;
  CGRect v89;
  CGRect v90;
  CGRect v91;
  CGRect v92;
  CGRect ClipBoundingBox;
  CGRect v94;
  CGRect v95;
  CGRect v96;
  CGRect v97;
  CGRect v98;

  v13 = -[TSTLayoutSpace masterLayout](a1, "masterLayout");
  if (-[TSTLayoutSpace drawPreventAntialias](a1, "drawPreventAntialias"))
    AlignedStrokeFrame = TSTLayoutSpaceGetAlignedStrokeFrame((uint64_t)a1);
  else
    AlignedStrokeFrame = TSTLayoutSpaceGetStrokeFrame((uint64_t)a1);
  v59 = v15;
  v60 = AlignedStrokeFrame;
  v57 = v17;
  v58 = v16;
  v84.y = TSTLayoutSpaceGetTableCoordinateForGridRow(a1, a2);
  v84.x = 0.0;
  TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v84);
  v19 = v18;
  result = TSTMasterLayoutIsGridRowHidden(v13, a2);
  if ((result & 1) == 0)
  {
    v73 = v13;
    MergedStrokesForGridRow = TSTMasterLayoutGetMergedStrokesForGridRow(v13, a2);
    v83[0] = 0;
    NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridRow, a3, a4, v83);
    if (NextStroke)
    {
      v23 = NextStroke;
      if ((_DWORD)a2)
        v24 = a2 - 1;
      else
        v24 = 0;
      v71 = a2 + 1;
      v72 = v24;
      v62 = MergedStrokesForGridRow;
      v61 = a7;
      while (1)
      {
        v25 = (void *)*((_QWORD *)v23 + 1);
        objc_msgSend(v25, "width");
        v27 = v26;
        v82 = v26;
        v28 = v23[1];
        v29 = *v23 <= a3 ? a3 : *v23;
        v30 = v28 >= a4 ? a4 : v28;
        v85.x = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, v29);
        v85.y = 0.0;
        LayoutPointForTablePoint = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v85);
        v80 = LayoutPointForTablePoint;
        v81 = v19;
        v86.x = TSTLayoutSpaceGetTableCoordinateForGridColumn(a1, v30);
        v86.y = 0.0;
        v32 = TSTLayoutSpaceGetLayoutPointForTablePoint(a1, v86);
        v79.x = v32;
        v79.y = v19;
        if (-[TSTLayoutSpace layoutDirectionIsLeftToRight](a1, "layoutDirectionIsLeftToRight"))
        {
          v33 = v32;
          v32 = LayoutPointForTablePoint;
        }
        else
        {
          v80 = v32;
          v79.x = LayoutPointForTablePoint;
          v33 = LayoutPointForTablePoint;
        }
        v34 = objc_msgSend(v25, "empty");
        v35 = a7 ? 0 : v34;
        if ((v35 & 1) == 0 && v32 != v33)
          break;
LABEL_64:
        v23 = TSTStrokeRunArrayGetNextStroke((uint64_t)MergedStrokesForGridRow, a3, a4, v83);
        if (!v23)
          return TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridRow);
      }
      v74 = v27;
      if (-[TSTLayoutSpace drawBlackAndWhite](a1, "drawBlackAndWhite"))
      {
        v36 = (void *)objc_msgSend(v25, "mutableCopy");
        objc_msgSend(v36, "setColor:", objc_msgSend(MEMORY[0x24BEB3C40], "blackColor"));
      }
      else
      {
        if ((objc_msgSend(v25, "solid") & 1) != 0 || -[TSTMasterLayout tableEnvironment](v73, "tableEnvironment") != 1)
        {
          v36 = 0;
          goto LABEL_31;
        }
        v36 = (void *)objc_msgSend(v25, "mutableCopy");
        v27 = 1.0;
        objc_msgSend(v36, "setWidth:", 1.0);
        v82 = 1.0;
      }
      v25 = v36;
LABEL_31:
      v77 = 0.0;
      v78 = 0.0;
      TSTLayoutSpaceAlignStrokeWidth(a1, v27, &v78, &v77);
      v37 = (double *)MEMORY[0x24BDBF148];
      v89.origin.x = TSDRectWithOriginAndSize(v38, v32, v19, *MEMORY[0x24BDBF148], *(double *)(MEMORY[0x24BDBF148] + 8));
      v39 = -v77;
      v90 = CGRectInset(v89, -v77, -v77);
      x = v90.origin.x;
      width = v90.size.width;
      y = v90.origin.y;
      rect2 = v90.size.height;
      point.x = v33;
      v91.origin.x = TSDRectWithOriginAndSize(v41, v33, v19, *v37, v37[1]);
      v92 = CGRectInset(v91, v39, v39);
      v69 = v92.origin.y;
      v70 = v92.origin.x;
      height = v92.size.height;
      v68 = v92.size.width;
      ClipBoundingBox = CGContextGetClipBoundingBox(a6);
      v42 = ClipBoundingBox.origin.x;
      v43 = ClipBoundingBox.origin.y;
      v44 = ClipBoundingBox.size.width;
      v45 = ClipBoundingBox.size.height;
      v87.x = v32;
      v87.y = v19;
      if (CGRectContainsPoint(ClipBoundingBox, v87))
        goto LABEL_33;
      v94.origin.x = v42;
      v94.origin.y = v43;
      v94.size.width = v44;
      v94.size.height = v45;
      v97.origin.x = x;
      v97.size.width = width;
      v97.origin.y = y;
      v97.size.height = rect2;
      v46 = 0.0;
      if (CGRectIntersectsRect(v94, v97))
LABEL_33:
        v46 = TSTMasterLayoutStrokeWidthOfGridColumn(v73, v29, v72, v71);
      v95.origin.x = v42;
      v95.origin.y = v43;
      v95.size.width = v44;
      v95.size.height = v45;
      v88.x = point.x;
      v88.y = v19;
      if (CGRectContainsPoint(v95, v88))
        goto LABEL_36;
      v96.origin.x = v42;
      v96.origin.y = v43;
      v96.size.width = v44;
      v96.size.height = v45;
      v98.origin.y = v69;
      v98.origin.x = v70;
      v98.size.height = height;
      v98.size.width = v68;
      v47 = 0.0;
      if (CGRectIntersectsRect(v96, v98))
LABEL_36:
        v47 = TSTMasterLayoutStrokeWidthOfGridColumn(v73, v30, v72, v71);
      a7 = v61;
      if (v46 > 0.0 && ((*((unsigned __int8 *)v23 + 24) >> 2) & 3u) - 1 <= 1)
      {
        v76 = 0.0;
        TSTLayoutSpaceAlignStrokeWidth(a1, v46, &v76, &point.y);
        v48 = (*((unsigned __int8 *)v23 + 24) >> 2) & 3;
        if (v48 == 2)
        {
          v49 = v76;
          v50 = 0.5;
          goto LABEL_43;
        }
        if (v48 == 1)
        {
          v49 = v76;
          v50 = -0.5;
LABEL_43:
          v80 = v32 + v49 * v50;
        }
      }
      if (v47 <= 0.0 || ((*((unsigned __int8 *)v23 + 24) >> 4) & 3u) - 1 > 1)
        goto LABEL_51;
      v76 = 0.0;
      TSTLayoutSpaceAlignStrokeWidth(a1, v47, &v76, &point.y);
      v51 = (*((unsigned __int8 *)v23 + 24) >> 4) & 3;
      if (v51 == 2)
      {
        v52 = v76;
        v53 = -0.5;
      }
      else
      {
        if (v51 != 1)
          goto LABEL_51;
        v52 = v76;
        v53 = 0.5;
      }
      v79.x = point.x + v52 * v53;
LABEL_51:
      if (-[TSTLayoutSpace drawPreventAntialias](a1, "drawPreventAntialias"))
      {
        TSTLayoutSpaceAlignStrokeCoordinates(a1, &v80, &v79, &v82);
        -[TSTLayoutSpace viewScale](a1, "viewScale");
        if (v54 < 0.330000013)
          v82 = v74;
      }
      if (a5)
      {
        objc_msgSend((id)objc_msgSend(v25, "color"), "alphaComponent");
        if (v55 > 0.0)
        {
          CGContextSaveGState(a6);
          CGContextBeginPath(a6);
          CGContextMoveToPoint(a6, v80, v81);
          CGContextAddLineToPoint(a6, v79.x, v79.y);
          CGContextSetLineWidth(a6, v82);
          CGContextSetBlendMode(a6, kCGBlendModeClear);
          CGContextStrokePath(a6);
          CGContextRestoreGState(a6);
        }
      }
      else if ((objc_msgSend(v25, "empty") & 1) == 0)
      {
        TSTLayoutSpaceDrawSingleStroke(v25, a6, v80, v81, v79.x, v79.y, v82, v74, v58, v56, v60, v59, v58, v57);
      }
      if (v61 == 1)
      {
        v81 = v81 + v82 * 0.5;
        v79.y = v82 * 0.5 + v79.y;
        TSTTableBadgeDrawHorizontalShadow(a6, 1, v80, v81, v79.x, v79.y, a1->mTransformFromDevice.a + a1->mTransformFromDevice.c);
      }
      if (v36)

      MergedStrokesForGridRow = v62;
      goto LABEL_64;
    }
    return TSTStrokeRunArrayUnlock((uint64_t)MergedStrokesForGridRow);
  }
  return result;
}

uint64_t TSTLayoutSpaceGetBoundsGridRange(TSTLayoutSpace *a1)
{
  TSTLayoutSpaceGetHeaderColumnsGridRange((uint64_t)a1);
  TSTLayoutSpaceGetHeaderRowsGridRange((uint64_t)a1);
  return 0;
}

uint64_t TSTLayoutSpaceCreateRowCoordinates(void *a1, unint64_t a2, unint64_t a3, void *a4, char *a5)
{
  TSTCoordinateArray *v10;
  unint64_t v11;
  unint64_t v12;
  int v15;
  uint64_t v16;
  void *v17;
  char v18;
  double v19;
  unint64_t v20;
  int v21;
  double v22;
  double v23;
  char v24;
  char v26;

  v10 = [TSTCoordinateArray alloc];
  v11 = HIDWORD(a3);
  if ((_DWORD)a2 == -1 || (_DWORD)a3 == -1 || a2 > a3)
  {
    v12 = HIDWORD(a2);
  }
  else
  {
    v12 = HIDWORD(a2);
    if (v11 >= HIDWORD(a2) && (_DWORD)v11 != -1 && HIDWORD(a2) != -1)
    {
      v15 = v11 - HIDWORD(a2) + 1;
      goto LABEL_14;
    }
  }
  v15 = 0;
LABEL_14:
  v16 = -[TSTCoordinateArray initWithCount:atOffset:](v10, "initWithCount:atOffset:", (v15 + 1), v12);
  v17 = (void *)objc_msgSend(a1, "layout");
  v26 = 0;
  if (objc_msgSend(a1, "headerRowsRepeat")
    && (v18 = objc_msgSend(a1, "isMain"), HIDWORD(a2))
    && (v18 & 1) != 0
    || (v19 = 0.0, objc_msgSend(a1, "headerRowsRepeat"))
    && objc_msgSend(a1, "layoutSpaceType") == 5)
  {
    v20 = TSTLayoutGetPartitionHeaderRowsCellRange(v17) >> 48;
    if ((_DWORD)v20)
    {
      v21 = 0;
      v19 = 0.0;
      do
        v19 = v19 + TSTLayoutHeightOfRow((double *)v17, (unsigned __int16)v21++, &v26, 1, 1);
      while ((_DWORD)v20 != v21);
    }
    else
    {
      v19 = 0.0;
    }
  }
  if (TSTMasterLayoutGetTableNumberOfRows(objc_msgSend(v17, "masterLayout")) - 1 <= v11)
    LODWORD(v11) = TSTMasterLayoutGetTableNumberOfRows(objc_msgSend(v17, "masterLayout")) - 1;
  for (; v12 <= v11; LODWORD(v12) = v12 + 1)
  {
    TSTCoordinateArraySetCoordinate(v16, v12, v19);
    v22 = TSTLayoutHeightOfRow((double *)v17, (unsigned __int16)v12, &v26, 1, 1);
    if (v22 == 0.0)
      TSTCoordinateArraySetIndexHidden(v16, v12);
    v19 = v19 + v22;
  }
  v23 = TSTCoordinateArraySetCoordinate(v16, v12, v19);
  if (a5)
  {
    if (a4)
      v24 = objc_msgSend(a4, "isEqual:", v16, v23) ^ 1;
    else
      v24 = 1;
    *a5 = v24;
  }
  return v16;
}

uint64_t TSTLayoutSpaceCreateColumnCoordinates(void *a1, uint64_t a2, uint64_t a3, void *a4, char *a5)
{
  TSTCoordinateArray *v10;
  BOOL v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  void *v15;
  char v16;
  double v17;
  uint64_t PartitionHeaderColumnsCellRange;
  unsigned int v19;
  int v20;
  double v21;
  double v22;
  char v23;
  char v25;

  v10 = [TSTCoordinateArray alloc];
  if ((_DWORD)a2 == -1
    || (_DWORD)a3 == -1
    || a3 < a2
    || (HIDWORD(a2) <= HIDWORD(a3) ? (v11 = HIDWORD(a3) == -1) : (v11 = 1),
        !v11 ? (v12 = HIDWORD(a2) == -1) : (v12 = 1),
        v12))
  {
    v13 = 0;
  }
  else
  {
    v13 = a3 - a2 + 1;
  }
  v14 = -[TSTCoordinateArray initWithCount:atOffset:](v10, "initWithCount:atOffset:", (v13 + 1), a2);
  v15 = (void *)objc_msgSend(a1, "layout");
  v25 = 0;
  if (objc_msgSend(a1, "headerColumnsRepeat")
    && (v16 = objc_msgSend(a1, "isMain"), (_DWORD)a2)
    && (v16 & 1) != 0
    || (v17 = 0.0, objc_msgSend(a1, "headerColumnsRepeat"))
    && objc_msgSend(a1, "layoutSpaceType") == 6)
  {
    PartitionHeaderColumnsCellRange = TSTLayoutGetPartitionHeaderColumnsCellRange(v15);
    v19 = WORD2(PartitionHeaderColumnsCellRange);
    if (WORD2(PartitionHeaderColumnsCellRange))
    {
      v20 = 0;
      v17 = 0.0;
      do
        v17 = v17 + private_LayoutWidthOfColumn(v15, v20++, 0, &v25);
      while (v19 > v20);
    }
    else
    {
      v17 = 0.0;
    }
  }
  if (TSTMasterLayoutGetTableNumberOfColumns(objc_msgSend(v15, "masterLayout")) - 1 <= a3)
    LODWORD(a3) = TSTMasterLayoutGetTableNumberOfColumns(objc_msgSend(v15, "masterLayout")) - 1;
  for (; a2 <= a3; LODWORD(a2) = a2 + 1)
  {
    TSTCoordinateArraySetCoordinate(v14, a2, v17);
    v21 = private_LayoutWidthOfColumn(v15, a2, 0, &v25);
    if (v21 == 0.0)
      TSTCoordinateArraySetIndexHidden(v14, a2);
    v17 = v17 + v21;
  }
  v22 = TSTCoordinateArraySetCoordinate(v14, a2, v17);
  if (a5)
  {
    if (a4)
      v23 = objc_msgSend(a4, "isEqual:", v14, v22) ^ 1;
    else
      v23 = 1;
    *a5 = v23;
  }
  return v14;
}

$3C36844D3994842D9102894F8152D7DE TSTLayoutSpaceGetExtendedBodyGridRange(TSTLayoutSpace *a1)
{
  $3C36844D3994842D9102894F8152D7DE topLeft;

  topLeft = a1->mGridRange.topLeft;
  TSTLayoutSpaceGetFooterRowsGridRange((uint64_t)a1);
  return topLeft;
}

double TSTLayoutSpaceGetLayoutOffsetForGridPoint(TSTLayoutSpace *a1, unint64_t a2)
{
  double v4;
  TSTLayout *v5;
  unint64_t PartitionNonHeaderRowCellRange;
  unsigned int v7;
  unsigned int v8;
  double BodyTranslationX;
  double v10;
  double v11;

  v4 = *MEMORY[0x24BDBEFB0];
  v5 = -[TSTLayoutSpace layout](a1, "layout");
  if (a2 > 0xFFFFFFFEFFFFFFFFLL || a2 == 0xFFFFFFFFLL)
    goto LABEL_19;
  PartitionNonHeaderRowCellRange = TSTLayoutGetPartitionNonHeaderRowCellRange(v5);
  if (BYTE2(PartitionNonHeaderRowCellRange) == 255)
    v7 = -1;
  else
    v7 = BYTE2(PartitionNonHeaderRowCellRange);
  v8 = (unsigned __int16)PartitionNonHeaderRowCellRange;
  if ((unsigned __int16)PartitionNonHeaderRowCellRange == 0xFFFF)
    v8 = -1;
  if (v7 <= a2)
  {
    if (WORD2(PartitionNonHeaderRowCellRange)
      && WORD2(PartitionNonHeaderRowCellRange) + v7 - 1 < a2
      && v8 > HIDWORD(a2))
    {
      if (!-[TSTLayoutSpace layoutDirectionIsLeftToRight](a1, "layoutDirectionIsLeftToRight"))
        goto LABEL_21;
      goto LABEL_18;
    }
    if (v8 > HIDWORD(a2))
    {
LABEL_18:
      BodyTranslationX = TSTLayoutSpaceGetBodyTranslationX(a1);
      v4 = v4 - (BodyTranslationX - TSTLayoutSpaceGetHeaderColumnsWidth(a1));
      goto LABEL_21;
    }
LABEL_19:
    v10 = TSTLayoutSpaceGetBodyTranslationX(a1);
    v4 = v4 - (v10 - TSTLayoutSpaceGetHeaderColumnsWidth(a1));
LABEL_20:
    TSTLayoutSpaceGetBodyTranslationY(a1);
    TSTLayoutSpaceGetHeaderRowsHeight(a1);
    goto LABEL_21;
  }
  if (v8 <= HIDWORD(a2) || !-[TSTLayoutSpace layoutDirectionIsLeftToRight](a1, "layoutDirectionIsLeftToRight"))
    goto LABEL_20;
LABEL_21:
  -[TSTLayoutSpace tableOffset](a1, "tableOffset");
  return v4 + v11;
}

double TSTLayoutSpaceGetBodyTranslationX(TSTLayoutSpace *a1)
{
  unint64_t BodyGridRange;

  BodyGridRange = TSTLayoutSpaceGetBodyGridRange((uint64_t)a1);
  if (-[TSTLayoutSpace headerColumnsRepeat](a1, "headerColumnsRepeat")
    && (-[TSTLayoutSpace isMain](a1, "isMain") || -[TSTLayoutSpace layoutSpaceType](a1, "layoutSpaceType") == 6))
  {
    return 0.0;
  }
  else
  {
    return TSTLayoutSpaceGetRawTableCoordinateForGridColumn(a1, BodyGridRange);
  }
}

double TSTLayoutSpaceGetBodyTranslationY(TSTLayoutSpace *a1)
{
  unint64_t BodyGridRange;

  BodyGridRange = TSTLayoutSpaceGetBodyGridRange((uint64_t)a1);
  if (-[TSTLayoutSpace headerRowsRepeat](a1, "headerRowsRepeat")
    && (-[TSTLayoutSpace isMain](a1, "isMain") || -[TSTLayoutSpace layoutSpaceType](a1, "layoutSpaceType") == 5))
  {
    return 0.0;
  }
  else
  {
    return TSTLayoutSpaceGetTableCoordinateForGridRow(a1, HIDWORD(BodyGridRange));
  }
}

uint64_t TSTLayoutSpaceGetGridColumnForTableCoordinate(TSTLayoutSpace *a1, double a2)
{
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  TSTCoordinateArray *mHeaderRowColumnCoordinates;
  uint64_t result;

  if (!a1)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTGridColumn TSTLayoutSpaceGetGridColumnForTableCoordinate(TSTLayoutSpace *, CGFloat)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3230, CFSTR("space should not be NULL"));
  }
  if (!a1->mBodyColumnCoordinates && !a1->mHeaderRowColumnCoordinates)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTGridColumn TSTLayoutSpaceGetGridColumnForTableCoordinate(TSTLayoutSpace *, CGFloat)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3233, CFSTR("Body column coordinates and header row column coordinates have not been filled."));
  }
  mHeaderRowColumnCoordinates = a1->mHeaderRowColumnCoordinates;
  if (!mHeaderRowColumnCoordinates)
    return TSTCoordinateArrayLookup(a1->mBodyColumnCoordinates, a2);
  result = TSTCoordinateArrayLookup(mHeaderRowColumnCoordinates, a2);
  if ((_DWORD)result == -1)
    return TSTCoordinateArrayLookup(a1->mBodyColumnCoordinates, a2);
  return result;
}

uint64_t TSTLayoutSpaceGetGridRowForTableCoordinate(TSTLayoutSpace *a1, double a2)
{
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  TSTCoordinateArray *mHeaderColumnRowCoordinates;
  uint64_t result;

  if (!a1)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTGridRow TSTLayoutSpaceGetGridRowForTableCoordinate(TSTLayoutSpace *, CGFloat)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3252, CFSTR("space should not be NULL"));
  }
  if (!a1->mBodyRowCoordinates && !a1->mHeaderColumnRowCoordinates)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTGridRow TSTLayoutSpaceGetGridRowForTableCoordinate(TSTLayoutSpace *, CGFloat)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTLayoutSpace.mm"), 3254, CFSTR("Body row coordinates and header column row coordinates have not been filled."));
  }
  mHeaderColumnRowCoordinates = a1->mHeaderColumnRowCoordinates;
  if (!mHeaderColumnRowCoordinates)
    return TSTCoordinateArrayLookup(a1->mBodyRowCoordinates, a2);
  result = TSTCoordinateArrayLookup(mHeaderColumnRowCoordinates, a2);
  if ((_DWORD)result == -1)
    return TSTCoordinateArrayLookup(a1->mBodyRowCoordinates, a2);
  return result;
}

double TSTLayoutSpaceGetAlignFrameSpec(TSTLayoutSpace *a1, double *a2)
{
  uint64_t v4;
  double result;
  uint64_t v6;
  CGPoint v7;
  __int128 v8;
  CGPoint v9;
  __int128 v10;
  CGPoint v11;
  __int128 v12;
  CGPoint v13;
  __int128 v14;

  v14 = *(_OWORD *)a2;
  v13.x = *(double *)&v14 + 1.0;
  v13.y = *((CGFloat *)&v14 + 1);
  TSTLayoutSpaceAlignStrokeCoordinates(a1, (double *)&v14, &v13, a2 + 8);
  v12 = *(_OWORD *)a2;
  *(_QWORD *)&v11.x = v12;
  v11.y = *((double *)&v12 + 1) + 1.0;
  TSTLayoutSpaceAlignStrokeCoordinates(a1, (double *)&v12, &v11, a2 + 10);
  v10 = *((_OWORD *)a2 + 1);
  v9.x = *(double *)&v10 + 1.0;
  v9.y = *((CGFloat *)&v10 + 1);
  TSTLayoutSpaceAlignStrokeCoordinates(a1, (double *)&v10, &v9, a2 + 9);
  v8 = *((_OWORD *)a2 + 2);
  *(_QWORD *)&v7.x = v8;
  v7.y = *((double *)&v8 + 1) + 1.0;
  TSTLayoutSpaceAlignStrokeCoordinates(a1, (double *)&v8, &v7, a2 + 11);
  v4 = *((_QWORD *)&v14 + 1);
  *(_QWORD *)a2 = v12;
  *((_QWORD *)a2 + 1) = v4;
  result = *(double *)&v8;
  v6 = *((_QWORD *)&v10 + 1);
  *((_QWORD *)a2 + 6) = v8;
  *((_QWORD *)a2 + 7) = v6;
  return result;
}

uint64_t *std::__tree<TSUColumnRowRect,TSTCellRangeRowMajorLess,std::allocator<TSUColumnRowRect>>::__emplace_unique_key_args<TSUColumnRowRect,TSUColumnRowRect const&>(uint64_t **a1, unsigned __int16 *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t v9;

  v5 = std::__tree<TSUColumnRowRect,TSTCellRangeRowMajorLess,std::allocator<TSUColumnRowRect>>::__find_equal<TSUColumnRowRect>((uint64_t)a1, &v9, a2);
  v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v6 + 26) = *a3;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

uint64_t *std::__tree<TSUColumnRowRect,TSTCellRangeRowMajorLess,std::allocator<TSUColumnRowRect>>::__find_equal<TSUColumnRowRect>(uint64_t a1, _QWORD *a2, unsigned __int16 *a3)
{
  uint64_t *result;
  uint64_t *v4;
  uint64_t *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t *v8;
  unsigned int v9;
  unsigned int v10;
  _BOOL4 v11;
  _BOOL4 v12;
  _BOOL4 v13;

  v5 = *(uint64_t **)(a1 + 8);
  result = (uint64_t *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    v6 = *a3;
    v7 = *((unsigned __int8 *)a3 + 2);
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = *((unsigned __int16 *)v4 + 13);
        v10 = *((unsigned __int8 *)v8 + 28);
        v11 = v7 < v10;
        if (v6 != v9)
          v11 = v6 < v9;
        if (!v11)
          break;
        v4 = (uint64_t *)*v8;
        result = v8;
        if (!*v8)
          goto LABEL_15;
      }
      v12 = v10 < v7;
      if (v6 == v9)
        v13 = v12;
      else
        v13 = v9 < v6;
      if (!v13)
        break;
      result = v8 + 1;
      v4 = (uint64_t *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = result;
  }
LABEL_15:
  *a2 = v8;
  return result;
}

uint64_t *std::__tree<TSUColumnRowRect,TSTCellRangeColumnMajorLess,std::allocator<TSUColumnRowRect>>::__emplace_unique_key_args<TSUColumnRowRect,TSUColumnRowRect const&>(uint64_t **a1, unsigned __int16 *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t v9;

  v5 = std::__tree<TSUColumnRowRect,TSTCellRangeColumnMajorLess,std::allocator<TSUColumnRowRect>>::__find_equal<TSUColumnRowRect>((uint64_t)a1, &v9, a2);
  v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v6 + 26) = *a3;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

uint64_t *std::__tree<TSUColumnRowRect,TSTCellRangeColumnMajorLess,std::allocator<TSUColumnRowRect>>::__find_equal<TSUColumnRowRect>(uint64_t a1, _QWORD *a2, unsigned __int16 *a3)
{
  uint64_t *result;
  uint64_t *v4;
  uint64_t *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t *v8;
  unsigned int v9;
  unsigned int v10;
  _BOOL4 v11;
  _BOOL4 v12;
  _BOOL4 v13;

  v5 = *(uint64_t **)(a1 + 8);
  result = (uint64_t *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    v6 = *((unsigned __int8 *)a3 + 2);
    v7 = *a3;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = *((unsigned __int8 *)v4 + 28);
        v10 = *((unsigned __int16 *)v8 + 13);
        v11 = v7 < v10;
        if (v6 != v9)
          v11 = v6 < v9;
        if (!v11)
          break;
        v4 = (uint64_t *)*v8;
        result = v8;
        if (!*v8)
          goto LABEL_15;
      }
      v12 = v10 < v7;
      if (v6 == v9)
        v13 = v12;
      else
        v13 = v9 < v6;
      if (!v13)
        break;
      result = v8 + 1;
      v4 = (uint64_t *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = result;
  }
LABEL_15:
  *a2 = v8;
  return result;
}

void TSTTableInitDefaultHeightAndWidth(TSTTableInfo *a1, double a2, double a3)
{
  TSTTableModel *v6;
  unsigned int v7;
  double v8;
  double v9;
  double v10;
  BOOL v11;
  int v12;
  TSDInfoGeometry *v13;
  TSDInfoGeometry *v14;

  v6 = -[TSTTableInfo tableModel](a1, "tableModel");
  v7 = -[TSTTableModel numberOfRows](v6, "numberOfRows");
  v8 = a3 / (double)-[TSTTableModel numberOfColumns](v6, "numberOfColumns");
  TSTTableComputeDefaultFontHeight(v6, 0);
  v10 = v9;
  if (v8 < 8.0)
    v8 = 8.0;
  TSTTableSetDefaultRowHeight((double *)v6, v9);
  TSTTableSetDefaultColumnWidth((double *)v6, v8);
  if (a2 / (double)v7 <= v10)
  {
    v11 = 1;
  }
  else
  {
    v10 = a2 / (double)v7;
    v11 = v7 == 0;
  }
  if (!v11)
  {
    v12 = 0;
    do
      TSTTableSetHeightOfRow((uint64_t)v6, (unsigned __int16)v12++, v10);
    while (v7 > (unsigned __int16)v12);
  }
  if (v10 * (double)v7 != a2)
  {
    v13 = [TSDInfoGeometry alloc];
    -[TSDInfoGeometry position](-[TSDDrawableInfo geometry](a1, "geometry"), "position");
    v14 = -[TSDInfoGeometry initWithPosition:size:](v13, "initWithPosition:size:");
    -[TSTTableInfo setGeometry:resizeInternal:](a1, "setGeometry:resizeInternal:", v14, 0);

  }
}

BOOL TSTLayoutSetTabsVisible(uint64_t a1, int a2)
{
  int v2;

  v2 = *(unsigned __int8 *)(a1 + 385);
  if (v2 != a2)
    *(_BYTE *)(a1 + 385) = a2;
  return v2 != a2;
}

uint64_t TSTLayoutSetPartitionRange(void *a1)
{
  uint64_t RangeForHint;
  unint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;

  RangeForHint = TSTMasterLayoutGetRangeForHint(objc_msgSend(a1, "masterLayout"), (void *)objc_msgSend(a1, "layoutHint"));
  v3 = RangeForHint;
  if (BYTE2(RangeForHint) == 255)
    v4 = -1;
  else
    v4 = BYTE2(RangeForHint);
  if (WORD2(RangeForHint))
    v5 = WORD2(RangeForHint) + v4 - 1;
  else
    v5 = 0xFFFFFFFFLL;
  v6 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  if ((unsigned __int16)v3 == 0xFFFF)
    v7 = 0xFFFFFFFFLL;
  else
    v7 = (unsigned __int16)v3;
  v8 = v4 | ((unint64_t)v7 << 32);
  v9 = ((v3 >> 16) & 0xFFFF00000000) + (v7 << 32) - 0x100000000;
  if (((v3 >> 16) & 0xFFFF00000000) == 0)
    v9 = 0xFFFFFFFF00000000;
  return TSTLayoutSpaceSetGridRange(v6, v8, v5 | v9);
}

uint64_t TSTLayoutInvalidateLayoutSpaceTableOffsets(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateTableOffsets");
}

double TSTLayoutGetRenderingFrameOutset(double a1, double a2, double a3, double a4)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&a1, -1.0, -1.0);
  return result;
}

double TSTLayoutGetRenderingFrame(void *a1, void *a2)
{
  uint64_t v4;
  uint64_t v5;
  CGFloat x;
  double y;
  CGFloat width;
  double height;
  double v10;
  double v11;
  double v12;
  double RenderingFrame;
  double v14;
  CGRect v16;
  CGRect v17;
  CGRect v18;

  v4 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  v5 = v4;
  if (!a2)
    a2 = (void *)v4;
  v16.origin.x = TSTLayoutSpaceGetStrokeFrame((uint64_t)a2);
  v17 = CGRectInset(v16, -1.0, -1.0);
  x = v17.origin.x;
  y = v17.origin.y;
  width = v17.size.width;
  height = v17.size.height;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  v11 = -0.0;
  if (v10 > 0.0)
    v11 = v10;
  v18.size.height = height + v11;
  v18.origin.y = y - fmax(v10, 0.0);
  v18.origin.x = x;
  v18.size.width = width;
  *(_QWORD *)&v12 = (unint64_t)CGRectIntegral(v18);
  if (objc_msgSend(a2, "isFrozen"))
  {
    RenderingFrame = TSTLayoutGetRenderingFrame(a1, v5);
    v14 = v12 - RenderingFrame;
    if (RenderingFrame >= v12)
      v14 = 0.0;
    return v12 - v14;
  }
  return v12;
}

uint64_t TSTLayoutGetSpace(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
}

uint64_t TSTLayoutGetTableNameHeight(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 387))
    return objc_msgSend(*(id *)(a1 + 304), "invalidateTableNameHeight");
  objc_msgSend((id)objc_msgSend((id)a1, "masterLayout"), "tableNameHeight");
  return objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)a1, "spaceBundle"), "space"), "viewScale");
}

uint64_t TSTLayoutInvalidateLayoutSpaceCoordinates(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateCoordinates");
}

double TSTLayoutGetStrokeFrame(void *a1)
{
  return TSTLayoutSpaceGetStrokeFrame(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
}

uint64_t TSTLayoutUpdateTransformToCanvas(void *a1)
{
  CGFloat v2;
  CGFloat v3;
  void *v4;
  _QWORD v6[4];
  CGAffineTransform v7;
  CGAffineTransform v8;

  objc_msgSend(a1, "frameInRoot");
  memset(&v8, 0, sizeof(v8));
  CGAffineTransformMakeTranslation(&v8, v2, v3);
  v4 = (void *)objc_msgSend(a1, "spaceBundle");
  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 3221225472;
  v6[2] = __TSTLayoutUpdateTransformToCanvas_block_invoke;
  v6[3] = &__block_descriptor_80_e24_B16__0__TSTLayoutSpace_8l;
  v7 = v8;
  return objc_msgSend(v4, "performActionOnEachLayoutSpace:", v6);
}

uint64_t TSTLayoutSetNeedsDisplayInCanvasRect(TSTLayout *a1, CGRect a2)
{
  return -[TSTLayout setNeedsDisplayInRect:](a1, "setNeedsDisplayInRect:", TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), a2.origin.x, a2.origin.y, a2.size.width, a2.size.height));
}

void *TSTLayoutInvalidateCellRangeAndFittingRange(void *a1)
{
  void *result;

  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateCoordinates");
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateTableOffsets");
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateCoordinates");
  objc_msgSend(a1, "invalidateChildren");
  objc_msgSend(a1, "invalidate");
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "cellIDToWPColumnCache"), "removeAllObjects");
  result = (void *)objc_msgSend(a1, "containedTextEditingLayout");
  if (result)
    return (void *)objc_msgSend(result, "invalidateSize");
  return result;
}

uint64_t TSTLayoutInvalidateRows(void *a1)
{
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateCoordinates");
  objc_msgSend(a1, "invalidateChildren");
  return objc_msgSend(a1, "invalidate");
}

uint64_t TSTLayoutInvalidateCell(void *a1, unsigned int a2)
{
  void *v4;
  unint64_t v5;

  v4 = (void *)objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "cellIDToWPColumnCache");
  HIDWORD(v5) = a2;
  LODWORD(v5) = a2;
  objc_msgSend(v4, "removeObjectForKey:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", (v5 >> 16) & 0xFFFF00FF));
  objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "addChangeDescriptor:", +[TSTChangeDescriptor changeDescriptorWithType:cellRange:](TSTChangeDescriptor, "changeDescriptorWithType:cellRange:", 33, a2 | 0x1000100000000));
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateCoordinates");
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateTableOffsets");
  objc_msgSend(a1, "invalidateChildren");
  return objc_msgSend(a1, "invalidate");
}

uint64_t TSTLayoutInvalidateColumns(void *a1)
{
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateCoordinates");
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "invalidateTableOffsets");
  objc_msgSend(a1, "invalidateChildren");
  return objc_msgSend(a1, "invalidate");
}

uint64_t TSTLayoutInvalidateContentRange(void *a1, unint64_t a2)
{
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t GridRange;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v4 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v5 = -1;
  else
    v5 = BYTE2(a2);
  v6 = (unsigned __int16)a2;
  if (WORD2(a2))
    v7 = WORD2(a2) + v5 - 1;
  else
    v7 = -1;
  if ((unsigned __int16)a2 == 0xFFFF)
    v8 = -1;
  else
    v8 = (unsigned __int16)a2;
  v9 = v8 + ((unint64_t)((HIDWORD(a2) << 16) - 0x100000000) >> 32);
  GridRange = TSTLayoutSpaceGetGridRange(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
  if (HIWORD(a2))
    v13 = v9;
  else
    v13 = -1;
  v14 = -1;
  if (v4 == 255 || v7 == -1)
  {
    v15 = -1;
  }
  else
  {
    v15 = -1;
    if (v5 <= v7
      && v6 != 0xFFFF
      && v13 != -1
      && v8 <= v13
      && (_DWORD)GridRange != -1
      && v11 != -1
      && GridRange <= v11
      && HIDWORD(GridRange) != -1
      && v12 != -1
      && HIDWORD(GridRange) <= v12)
    {
      v16 = v5 <= GridRange ? GridRange : v5;
      v17 = v7 >= v11 ? v11 : v7;
      if (v16 <= v17)
      {
        if (v13 >= v12)
          v18 = v12;
        else
          v18 = v13;
        if (v8 <= HIDWORD(GridRange))
          v19 = HIDWORD(GridRange);
        else
          v19 = v8;
        if (v19 <= v18)
        {
          v15 = v17 | (v18 << 32);
          v14 = v16 | (v19 << 32);
        }
      }
    }
  }
  return objc_msgSend(a1, "setNeedsDisplayInRect:", TSTLayoutSpaceGetFrameForGridRange((TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), v14, v15));
}

double TSTLayoutWidthOfColumn(double *a1, uint64_t a2, _BYTE *a3)
{
  return TSTMasterLayoutWidthOfColumn(objc_msgSend(a1, "masterLayout"), a2, 0, a3, 1) * a1[51];
}

double private_LayoutWidthOfColumn(void *a1, uint64_t a2, char a3, _BYTE *a4)
{
  return TSTMasterLayoutWidthOfColumn(objc_msgSend(a1, "masterLayout"), a2, a3, a4, 1);
}

double TSTLayoutHeightOfRow(double *a1, uint64_t a2, char *a3, int a4, int a5)
{
  return TSTMasterLayoutHeightOfRow((TSTMasterLayout *)objc_msgSend(a1, "masterLayout"), a2, 0, a3, a4, a5) * a1[52];
}

uint64_t TSTLayoutGetPartitionRange(void *a1)
{
  return TSTMasterLayoutGetRangeForHint(objc_msgSend(a1, "masterLayout"), (void *)objc_msgSend(a1, "layoutHint"));
}

BOOL TSTLayoutExtendedPartitionRangeContainsCellID(void *a1, int a2)
{
  unint64_t RangeForHint;
  unint64_t PartitionHeaderColumnsCellRange;
  unint64_t PartitionHeaderRowsCellRange;
  unint64_t PartitionHeaderCornerCellRange;
  uint64_t v8;

  RangeForHint = TSTMasterLayoutGetRangeForHint(objc_msgSend(a1, "masterLayout"), (void *)objc_msgSend(a1, "layoutHint"));
  if (HIWORD(RangeForHint)
    && (RangeForHint & 0xFFFF00000000) != 0
    && (unsigned __int16)RangeForHint <= (unsigned __int16)a2
    && (unsigned __int16)(RangeForHint + HIWORD(RangeForHint) - 1) >= (unsigned __int16)a2
    && BYTE2(a2) >= BYTE2(RangeForHint)
    && BYTE2(a2) <= (BYTE4(RangeForHint) + BYTE2(RangeForHint) - 1))
  {
    return 1;
  }
  PartitionHeaderColumnsCellRange = TSTLayoutGetPartitionHeaderColumnsCellRange(a1);
  if (HIWORD(PartitionHeaderColumnsCellRange))
  {
    if ((PartitionHeaderColumnsCellRange & 0xFFFF00000000) != 0
      && (unsigned __int16)PartitionHeaderColumnsCellRange <= (unsigned __int16)a2
      && (unsigned __int16)(PartitionHeaderColumnsCellRange + HIWORD(PartitionHeaderColumnsCellRange) - 1) >= (unsigned __int16)a2
      && BYTE2(a2) >= BYTE2(PartitionHeaderColumnsCellRange)
      && BYTE2(a2) <= (BYTE4(PartitionHeaderColumnsCellRange)
                                                    + BYTE2(PartitionHeaderColumnsCellRange)
                                                    - 1))
    {
      return 1;
    }
  }
  PartitionHeaderRowsCellRange = TSTLayoutGetPartitionHeaderRowsCellRange(a1);
  if (HIWORD(PartitionHeaderRowsCellRange))
  {
    if ((PartitionHeaderRowsCellRange & 0xFFFF00000000) != 0
      && (unsigned __int16)PartitionHeaderRowsCellRange <= (unsigned __int16)a2
      && (unsigned __int16)(PartitionHeaderRowsCellRange + HIWORD(PartitionHeaderRowsCellRange) - 1) >= (unsigned __int16)a2
      && BYTE2(a2) >= BYTE2(PartitionHeaderRowsCellRange)
      && BYTE2(a2) <= (BYTE4(PartitionHeaderRowsCellRange)
                                                    + BYTE2(PartitionHeaderRowsCellRange)
                                                    - 1))
    {
      return 1;
    }
  }
  PartitionHeaderCornerCellRange = TSTLayoutGetPartitionHeaderCornerCellRange(a1);
  v8 = 0;
  if (HIWORD(PartitionHeaderCornerCellRange) && (PartitionHeaderCornerCellRange & 0xFFFF00000000) != 0)
    return (unsigned __int16)PartitionHeaderCornerCellRange <= (unsigned __int16)a2
        && (unsigned __int16)(PartitionHeaderCornerCellRange + HIWORD(PartitionHeaderCornerCellRange) - 1) >= (unsigned __int16)a2
        && BYTE2(a2) >= BYTE2(PartitionHeaderCornerCellRange)
        && BYTE2(a2) <= (BYTE4(PartitionHeaderCornerCellRange)
                                                      + BYTE2(PartitionHeaderCornerCellRange)
                                                      - 1);
  return v8;
}

uint64_t TSTLayoutGetPartitionHeaderColumnsCellRange(void *a1)
{
  unsigned __int16 *v2;
  uint64_t TableNumberOfHeaderColumns;
  unint64_t RangeForHint;
  unsigned __int16 v5;
  unint64_t v6;
  unint64_t v7;
  unsigned __int16 TableNumberOfHeaderRows;
  uint64_t v9;

  v2 = (unsigned __int16 *)objc_msgSend(a1, "masterLayout");
  TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns(v2);
  if (!(_DWORD)TableNumberOfHeaderColumns)
  {
    LODWORD(v6) = 0;
LABEL_10:
    v7 = 0;
    v9 = 16711680;
    v5 = -1;
    return (TableNumberOfHeaderColumns << 32) | (v7 << 48) | ((_DWORD)v6 << 24) | v9 | v5;
  }
  if ((objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "cacheHintID") & 0xFF0000) != 0
    && !objc_msgSend((id)objc_msgSend(a1, "tableModel"), "repeatingHeaderColumnsEnabled"))
  {
    LODWORD(v6) = 0;
    TableNumberOfHeaderColumns = 0;
    goto LABEL_10;
  }
  RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)objc_msgSend(a1, "layoutHint"));
  v5 = RangeForHint;
  v6 = RangeForHint >> 24;
  v7 = HIWORD(RangeForHint);
  if ((_WORD)RangeForHint
    || !objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "headerRowsRepeat"))
  {
    v9 = 0;
  }
  else
  {
    TableNumberOfHeaderRows = TSTMasterLayoutGetTableNumberOfHeaderRows(v2);
    v9 = 0;
    v5 = TableNumberOfHeaderRows;
    v7 = (unsigned __int16)(v7 - TableNumberOfHeaderRows);
  }
  return (TableNumberOfHeaderColumns << 32) | (v7 << 48) | ((_DWORD)v6 << 24) | v9 | v5;
}

unint64_t TSTLayoutGetPartitionHeaderRowsCellRange(void *a1)
{
  unsigned __int16 *v2;
  uint64_t TableNumberOfHeaderRows;
  unint64_t RangeForHint;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __int16 v8;
  __int16 TableNumberOfHeaderColumns;
  uint64_t v10;

  v2 = (unsigned __int16 *)objc_msgSend(a1, "masterLayout");
  TableNumberOfHeaderRows = TSTMasterLayoutGetTableNumberOfHeaderRows(v2);
  if (!(_DWORD)TableNumberOfHeaderRows)
  {
    LODWORD(v6) = 0;
    LOWORD(v7) = 0;
LABEL_10:
    LOBYTE(v5) = -1;
    v10 = 0xFFFFLL;
    return ((unint64_t)(unsigned __int16)v7 << 32) | (TableNumberOfHeaderRows << 48) | ((_DWORD)v6 << 24) | ((unint64_t)v5 << 16) | v10;
  }
  if ((unsigned __int16)objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "cacheHintID")
    && !objc_msgSend((id)objc_msgSend(a1, "tableModel"), "repeatingHeaderRowsEnabled"))
  {
    LODWORD(v6) = 0;
    LOWORD(v7) = 0;
    TableNumberOfHeaderRows = 0;
    goto LABEL_10;
  }
  RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)objc_msgSend(a1, "layoutHint"));
  v5 = RangeForHint >> 16;
  v6 = RangeForHint >> 24;
  v7 = HIDWORD(RangeForHint);
  if ((RangeForHint & 0xFF0000) != 0
    || (v8 = WORD2(RangeForHint),
        !objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "headerColumnsRepeat")))
  {
    v10 = 0;
  }
  else
  {
    TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns(v2);
    v10 = 0;
    LOBYTE(v5) = TableNumberOfHeaderColumns;
    LOWORD(v7) = v8 - TableNumberOfHeaderColumns;
  }
  return ((unint64_t)(unsigned __int16)v7 << 32) | (TableNumberOfHeaderRows << 48) | ((_DWORD)v6 << 24) | ((unint64_t)v5 << 16) | v10;
}

uint64_t TSTLayoutGetPartitionHeaderCornerCellRange(void *a1)
{
  unint64_t PartitionHeaderRowsCellRange;
  unint64_t PartitionHeaderColumnsCellRange;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  BOOL v15;

  PartitionHeaderRowsCellRange = TSTLayoutGetPartitionHeaderRowsCellRange(a1);
  PartitionHeaderColumnsCellRange = TSTLayoutGetPartitionHeaderColumnsCellRange(a1);
  v4 = 0;
  v5 = 0xFFFFFFLL;
  if ((_WORD)PartitionHeaderRowsCellRange == 0xFFFF)
    goto LABEL_23;
  v6 = 0;
  if ((PartitionHeaderRowsCellRange & 0xFF0000) == 0xFF0000)
    return v6 | v4 | v5;
  v4 = 0;
  v5 = 0xFFFFFFLL;
  if (!HIWORD(PartitionHeaderRowsCellRange))
  {
LABEL_23:
    v6 = 0;
    return v6 | v4 | v5;
  }
  v6 = 0;
  if ((PartitionHeaderRowsCellRange & 0xFFFF00000000) != 0)
  {
    v5 = 0xFFFFFFLL;
    if ((_WORD)PartitionHeaderColumnsCellRange == 0xFFFF)
    {
      v4 = 0;
      v6 = 0;
    }
    else
    {
      v7 = PartitionHeaderRowsCellRange & 0xFFFF000000000000;
      v8 = PartitionHeaderColumnsCellRange & 0xFF0000;
      v9 = PartitionHeaderColumnsCellRange & 0xFFFF00000000;
      v10 = 0xFFFFFFLL;
      v11 = HIWORD(PartitionHeaderColumnsCellRange);
      if ((PartitionHeaderColumnsCellRange & 0xFFFF00000000) != 0)
      {
        v12 = 0;
      }
      else
      {
        v9 = 0;
        v7 = 0;
        v12 = 0xFFFFFFLL;
      }
      v13 = v11 == 0;
      if (v11)
      {
        v14 = v7;
      }
      else
      {
        v9 = 0;
        v14 = 0;
      }
      if (!v13)
        v10 = v12;
      v15 = v8 == 16711680;
      if (v8 == 16711680)
        v4 = 0;
      else
        v4 = v9;
      if (v8 == 16711680)
        v6 = 0;
      else
        v6 = v14;
      if (!v15)
        v5 = v10;
    }
  }
  return v6 | v4 | v5;
}

BOOL TSTLayoutExtendedPartitionRangeIntersectsCellRange(void *a1, unint64_t a2)
{
  int v4;
  unint64_t RangeForHint;
  _BOOL4 v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t PartitionHeaderColumnsCellRange;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  unint64_t v25;
  unint64_t PartitionHeaderRowsCellRange;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  unint64_t v35;
  _BOOL8 result;
  unint64_t PartitionHeaderCornerCellRange;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int v42;
  uint64_t v43;
  unsigned int v44;
  unsigned int v45;
  unint64_t v46;
  unint64_t v47;
  BOOL v48;

  v4 = ~(_DWORD)a2;
  RangeForHint = TSTMasterLayoutGetRangeForHint(objc_msgSend(a1, "masterLayout"), (void *)objc_msgSend(a1, "layoutHint"));
  v6 = (*(_QWORD *)&v4 & 0xFF0000) != 0 && (unsigned __int16)v4 != 0;
  if (v6)
  {
    v7 = 0;
    v8 = 16711680;
    v9 = 0xFFFFLL;
    if (HIWORD(a2))
    {
      v10 = 0;
      if ((a2 & 0xFFFF00000000) == 0)
        goto LABEL_27;
      v7 = 0;
      v8 = 16711680;
      v9 = 0xFFFFLL;
      if ((_WORD)RangeForHint != 0xFFFF)
      {
        v10 = 0;
        if ((RangeForHint & 0xFF0000) == 0xFF0000)
          goto LABEL_27;
        v7 = 0;
        v8 = 16711680;
        v9 = 0xFFFFLL;
        if (HIWORD(RangeForHint))
        {
          v10 = 0;
          if ((RangeForHint & 0xFFFF00000000) != 0)
          {
            v9 = 0;
            if (BYTE2(a2) <= BYTE2(RangeForHint))
              v11 = BYTE2(RangeForHint);
            else
              v11 = BYTE2(a2);
            if ((unsigned __int16)a2 <= (unsigned __int16)RangeForHint)
              v12 = (unsigned __int16)RangeForHint;
            else
              v12 = (unsigned __int16)a2;
            if ((BYTE4(a2) + BYTE2(a2) - 1) >= (BYTE4(RangeForHint)
                                                                                               + BYTE2(RangeForHint)
                                                                                               - 1))
              v13 = (BYTE4(RangeForHint) + BYTE2(RangeForHint) - 1);
            else
              v13 = (BYTE4(a2) + BYTE2(a2) - 1);
            v14 = (unsigned __int16)(RangeForHint + HIWORD(RangeForHint) - 1);
            if ((unsigned __int16)(a2 + HIWORD(a2) - 1) < v14)
              v14 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
            v8 = 0;
            v7 = 0;
            v10 = 0;
            if (v12 <= v14 && v11 <= v13)
            {
              v10 = ((unint64_t)(v14 - v12) << 48) + 0x1000000000000;
              v7 = (unint64_t)(unsigned __int16)(v13 - v11 + 1) << 32;
              v8 = v11 << 16;
              v9 = v12;
            }
          }
          goto LABEL_27;
        }
      }
    }
    v10 = 0;
  }
  else
  {
    v7 = 0;
    v10 = 0;
    v8 = 16711680;
    v9 = 0xFFFFLL;
  }
LABEL_27:
  v15 = v8 | v10 | v9 | v7;
  if ((_WORD)v15 != 0xFFFF && (v15 & 0xFF0000) != 0xFF0000 && HIWORD(v15) && (v15 & 0xFFFF00000000) != 0)
    return 1;
  PartitionHeaderColumnsCellRange = TSTLayoutGetPartitionHeaderColumnsCellRange(a1);
  v17 = 0;
  if (!v6)
  {
    v20 = 0;
    v18 = 16711680;
    v19 = 0xFFFFLL;
    goto LABEL_54;
  }
  v18 = 16711680;
  v19 = 0xFFFFLL;
  if (!HIWORD(a2))
    goto LABEL_53;
  v20 = 0;
  if ((a2 & 0xFFFF00000000) == 0)
    goto LABEL_54;
  v17 = 0;
  v18 = 16711680;
  v19 = 0xFFFFLL;
  if ((_WORD)PartitionHeaderColumnsCellRange == 0xFFFF)
    goto LABEL_53;
  v20 = 0;
  if ((PartitionHeaderColumnsCellRange & 0xFF0000) == 0xFF0000)
    goto LABEL_54;
  v17 = 0;
  v18 = 16711680;
  v19 = 0xFFFFLL;
  if (!HIWORD(PartitionHeaderColumnsCellRange))
  {
LABEL_53:
    v20 = 0;
    goto LABEL_54;
  }
  v20 = 0;
  if ((PartitionHeaderColumnsCellRange & 0xFFFF00000000) != 0)
  {
    v19 = 0;
    if (BYTE2(a2) <= BYTE2(PartitionHeaderColumnsCellRange))
      v21 = BYTE2(PartitionHeaderColumnsCellRange);
    else
      v21 = BYTE2(a2);
    if ((unsigned __int16)a2 <= (unsigned __int16)PartitionHeaderColumnsCellRange)
      v22 = (unsigned __int16)PartitionHeaderColumnsCellRange;
    else
      v22 = (unsigned __int16)a2;
    if ((BYTE4(a2) + BYTE2(a2) - 1) >= (BYTE4(PartitionHeaderColumnsCellRange)
                                                                                       + BYTE2(PartitionHeaderColumnsCellRange)
                                                                                       - 1))
      v23 = (BYTE4(PartitionHeaderColumnsCellRange) + BYTE2(PartitionHeaderColumnsCellRange) - 1);
    else
      v23 = (BYTE4(a2) + BYTE2(a2) - 1);
    v24 = (unsigned __int16)(PartitionHeaderColumnsCellRange + HIWORD(PartitionHeaderColumnsCellRange) - 1);
    if ((unsigned __int16)(a2 + HIWORD(a2) - 1) < v24)
      v24 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
    v18 = 0;
    v17 = 0;
    v20 = 0;
    if (v22 <= v24 && v21 <= v23)
    {
      v20 = ((unint64_t)(v24 - v22) << 48) + 0x1000000000000;
      v17 = (unint64_t)(unsigned __int16)(v23 - v21 + 1) << 32;
      v18 = v21 << 16;
      v19 = v22;
    }
  }
LABEL_54:
  v25 = v18 | v20 | v19 | v17;
  if ((_WORD)v25 != 0xFFFF && (v25 & 0xFF0000) != 0xFF0000 && HIWORD(v25) && (v25 & 0xFFFF00000000) != 0)
    return 1;
  PartitionHeaderRowsCellRange = TSTLayoutGetPartitionHeaderRowsCellRange(a1);
  v27 = 0;
  if (v6)
  {
    v28 = 16711680;
    v29 = 0xFFFFLL;
    if (HIWORD(a2))
    {
      v30 = 0;
      if ((a2 & 0xFFFF00000000) == 0)
        goto LABEL_81;
      v27 = 0;
      v28 = 16711680;
      v29 = 0xFFFFLL;
      if ((_WORD)PartitionHeaderRowsCellRange != 0xFFFF)
      {
        v30 = 0;
        if ((PartitionHeaderRowsCellRange & 0xFF0000) == 0xFF0000)
          goto LABEL_81;
        v27 = 0;
        v28 = 16711680;
        v29 = 0xFFFFLL;
        if (HIWORD(PartitionHeaderRowsCellRange))
        {
          v30 = 0;
          if ((PartitionHeaderRowsCellRange & 0xFFFF00000000) != 0)
          {
            v29 = 0;
            if (BYTE2(a2) <= BYTE2(PartitionHeaderRowsCellRange))
              v31 = BYTE2(PartitionHeaderRowsCellRange);
            else
              v31 = BYTE2(a2);
            if ((unsigned __int16)a2 <= (unsigned __int16)PartitionHeaderRowsCellRange)
              v32 = (unsigned __int16)PartitionHeaderRowsCellRange;
            else
              v32 = (unsigned __int16)a2;
            if ((BYTE4(a2) + BYTE2(a2) - 1) >= (BYTE4(PartitionHeaderRowsCellRange)
                                                                                               + BYTE2(PartitionHeaderRowsCellRange)
                                                                                               - 1))
              v33 = (BYTE4(PartitionHeaderRowsCellRange) + BYTE2(PartitionHeaderRowsCellRange) - 1);
            else
              v33 = (BYTE4(a2) + BYTE2(a2) - 1);
            v34 = (unsigned __int16)(PartitionHeaderRowsCellRange + HIWORD(PartitionHeaderRowsCellRange) - 1);
            if ((unsigned __int16)(a2 + HIWORD(a2) - 1) < v34)
              v34 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
            v28 = 0;
            v27 = 0;
            v30 = 0;
            if (v32 <= v34 && v31 <= v33)
            {
              v30 = ((unint64_t)(v34 - v32) << 48) + 0x1000000000000;
              v27 = (unint64_t)(unsigned __int16)(v33 - v31 + 1) << 32;
              v28 = v31 << 16;
              v29 = v32;
            }
          }
          goto LABEL_81;
        }
      }
    }
    v30 = 0;
  }
  else
  {
    v30 = 0;
    v28 = 16711680;
    v29 = 0xFFFFLL;
  }
LABEL_81:
  v35 = v28 | v30 | v29 | v27;
  if ((_WORD)v35 != 0xFFFF && (v35 & 0xFF0000) != 0xFF0000 && HIWORD(v35) && (v35 & 0xFFFF00000000) != 0)
    return 1;
  PartitionHeaderCornerCellRange = TSTLayoutGetPartitionHeaderCornerCellRange(a1);
  v38 = 0;
  if (!v6)
  {
    v41 = 0;
    v39 = 16711680;
    v40 = 0xFFFFLL;
    goto LABEL_109;
  }
  v39 = 16711680;
  v40 = 0xFFFFLL;
  if (!HIWORD(a2))
    goto LABEL_108;
  v41 = 0;
  if ((a2 & 0xFFFF00000000) == 0)
    goto LABEL_109;
  v38 = 0;
  v39 = 16711680;
  v40 = 0xFFFFLL;
  if ((_WORD)PartitionHeaderCornerCellRange == 0xFFFF)
  {
LABEL_108:
    v41 = 0;
    goto LABEL_109;
  }
  v41 = 0;
  if ((PartitionHeaderCornerCellRange & 0xFF0000) != 0xFF0000)
  {
    v38 = 0;
    v39 = 16711680;
    v40 = 0xFFFFLL;
    if (HIWORD(PartitionHeaderCornerCellRange))
    {
      v41 = 0;
      if ((PartitionHeaderCornerCellRange & 0xFFFF00000000) != 0)
      {
        v40 = 0;
        if (BYTE2(a2) <= BYTE2(PartitionHeaderCornerCellRange))
          v42 = BYTE2(PartitionHeaderCornerCellRange);
        else
          v42 = BYTE2(a2);
        if ((unsigned __int16)a2 <= (unsigned __int16)PartitionHeaderCornerCellRange)
          v43 = (unsigned __int16)PartitionHeaderCornerCellRange;
        else
          v43 = (unsigned __int16)a2;
        if ((BYTE4(a2) + BYTE2(a2) - 1) >= (BYTE4(PartitionHeaderCornerCellRange)
                                                                                           + BYTE2(PartitionHeaderCornerCellRange)
                                                                                           - 1))
          v44 = (BYTE4(PartitionHeaderCornerCellRange) + BYTE2(PartitionHeaderCornerCellRange) - 1);
        else
          v44 = (BYTE4(a2) + BYTE2(a2) - 1);
        v45 = (unsigned __int16)(PartitionHeaderCornerCellRange + HIWORD(PartitionHeaderCornerCellRange) - 1);
        if ((unsigned __int16)(a2 + HIWORD(a2) - 1) < v45)
          v45 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
        v39 = 0;
        v38 = 0;
        v41 = 0;
        if (v43 <= v45 && v42 <= v44)
        {
          v41 = ((unint64_t)(v45 - v43) << 48) + 0x1000000000000;
          v38 = (unint64_t)(unsigned __int16)(v44 - v42 + 1) << 32;
          v39 = v42 << 16;
          v40 = v43;
        }
      }
      goto LABEL_109;
    }
    goto LABEL_108;
  }
LABEL_109:
  result = 0;
  v46 = v39 | v41 | v40 | v38;
  if ((_WORD)v46 != 0xFFFF && (v46 & 0xFF0000) != 0xFF0000)
  {
    v48 = (v46 & 0xFFFF00000000) == 0;
    v47 = HIWORD(v46);
    v48 = v48 || v47 == 0;
    return !v48;
  }
  return result;
}

uint64_t TSTLayoutGetPartitionFirstBodyColumn(void *a1)
{
  unsigned __int16 *v2;
  unsigned int v3;
  uint64_t result;

  v2 = (unsigned __int16 *)objc_msgSend(a1, "masterLayout");
  v3 = (TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)objc_msgSend(a1, "layoutHint")) >> 16);
  LODWORD(result) = TSTMasterLayoutGetTableNumberOfHeaderColumns(v2);
  if (v3 <= result)
    return result;
  else
    return v3;
}

uint64_t TSTLayoutGetPartitionLastBodyColumn(void *a1)
{
  uint64_t RangeForHint;

  RangeForHint = TSTMasterLayoutGetRangeForHint(objc_msgSend(a1, "masterLayout"), (void *)objc_msgSend(a1, "layoutHint"));
  return (BYTE4(RangeForHint) + BYTE2(RangeForHint) - 1);
}

uint64_t TSTLayoutGetPartitionFirstBodyRow(void *a1)
{
  unsigned __int16 *v2;
  unsigned int RangeForHint;
  uint64_t result;

  v2 = (unsigned __int16 *)objc_msgSend(a1, "masterLayout");
  RangeForHint = (unsigned __int16)TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)objc_msgSend(a1, "layoutHint"));
  LODWORD(result) = TSTMasterLayoutGetTableNumberOfHeaderRows(v2);
  if (RangeForHint <= result)
    return result;
  else
    return RangeForHint;
}

uint64_t TSTLayoutGetPartitionLastBodyRow(void *a1)
{
  unsigned __int16 *v2;
  uint64_t RangeForHint;
  unsigned int v4;
  uint64_t result;

  v2 = (unsigned __int16 *)objc_msgSend(a1, "masterLayout");
  RangeForHint = TSTMasterLayoutGetRangeForHint(objc_msgSend(a1, "masterLayout"), (void *)objc_msgSend(a1, "layoutHint"));
  v4 = (unsigned __int16)(RangeForHint + HIWORD(RangeForHint) - 1);
  LOWORD(result) = TSTMasterLayoutGetEntireFooterRowsCellRange(v2);
  if (v4 >= (unsigned __int16)result)
    return (unsigned __int16)result;
  else
    return v4;
}

unint64_t TSTLayoutGetPartitionNonHeaderRowCellRange(void *a1)
{
  unsigned __int16 *v2;
  unint64_t RangeForHint;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unsigned int TableNumberOfHeaderColumns;
  unsigned int TableNumberOfHeaderRows;
  unint64_t v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unint64_t v13;
  unsigned __int8 v14;

  v2 = (unsigned __int16 *)objc_msgSend(a1, "masterLayout");
  RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)objc_msgSend(a1, "layoutHint"));
  v4 = RangeForHint;
  v5 = RangeForHint >> 16;
  v6 = HIDWORD(RangeForHint);
  v7 = HIWORD(RangeForHint);
  TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns(v2);
  TableNumberOfHeaderRows = TSTMasterLayoutGetTableNumberOfHeaderRows(v2);
  if ((unsigned __int16)v4 >= TableNumberOfHeaderRows)
    v10 = v7;
  else
    v10 = v7 - TableNumberOfHeaderRows;
  if ((unsigned __int16)v4 >= TableNumberOfHeaderRows)
    v11 = v4;
  else
    v11 = TableNumberOfHeaderRows;
  if (BYTE2(v4) >= TableNumberOfHeaderColumns)
    v12 = v6;
  else
    v12 = v6 - TableNumberOfHeaderColumns;
  v13 = (v10 << 48) | ((unint64_t)v12 << 32) | v4;
  if (BYTE2(v4) >= TableNumberOfHeaderColumns)
    v14 = v5;
  else
    v14 = TableNumberOfHeaderColumns;
  return v13 & 0xFFFFFFFFFF000000 | ((unint64_t)v14 << 16) | v11;
}

unint64_t TSTLayoutGetPartitionBodyCellRange(void *a1)
{
  unsigned __int16 *v2;
  unint64_t RangeForHint;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unsigned int TableNumberOfHeaderColumns;
  unsigned int TableNumberOfHeaderRows;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int TableNumberOfFooterRows;
  int TableNumberOfRows;
  uint64_t v15;
  unsigned __int16 v16;
  unint64_t v17;
  unsigned __int8 v18;

  v2 = (unsigned __int16 *)objc_msgSend(a1, "masterLayout");
  RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)objc_msgSend(a1, "layoutHint"));
  v4 = RangeForHint;
  v5 = RangeForHint >> 16;
  v6 = HIDWORD(RangeForHint);
  v7 = HIWORD(RangeForHint);
  TableNumberOfHeaderColumns = TSTMasterLayoutGetTableNumberOfHeaderColumns(v2);
  TableNumberOfHeaderRows = TSTMasterLayoutGetTableNumberOfHeaderRows(v2);
  if ((unsigned __int16)v4 >= TableNumberOfHeaderRows)
    v10 = 0;
  else
    v10 = TableNumberOfHeaderRows;
  if ((unsigned __int16)v4 >= TableNumberOfHeaderRows)
    v11 = v4;
  else
    v11 = TableNumberOfHeaderRows;
  v12 = v7 - v10;
  TableNumberOfFooterRows = TSTMasterLayoutGetTableNumberOfFooterRows(v2);
  TableNumberOfRows = TSTMasterLayoutGetTableNumberOfRows((uint64_t)v2);
  if ((unsigned __int16)v12 + (unsigned __int16)v11 <= (unsigned __int16)(TableNumberOfRows
                                                                                       - TableNumberOfFooterRows))
    v15 = v12;
  else
    v15 = TableNumberOfRows - TableNumberOfFooterRows - v11;
  if (BYTE2(v4) >= TableNumberOfHeaderColumns)
    v16 = v6;
  else
    v16 = v6 - TableNumberOfHeaderColumns;
  v17 = ((unint64_t)v16 << 32) | (v15 << 48) | v4;
  if (BYTE2(v4) >= TableNumberOfHeaderColumns)
    v18 = v5;
  else
    v18 = TableNumberOfHeaderColumns;
  return v17 & 0xFFFFFFFFFF000000 | ((unint64_t)v18 << 16) | (unsigned __int16)v11;
}

uint64_t TSTLayoutGetPartitionFooterRowsCellRange(void *a1)
{
  unsigned __int16 *v2;
  unint64_t EntireFooterRowsCellRange;
  unint64_t v4;
  unint64_t v6;
  unint64_t RangeForHint;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;

  v2 = (unsigned __int16 *)objc_msgSend(a1, "masterLayout");
  EntireFooterRowsCellRange = TSTMasterLayoutGetEntireFooterRowsCellRange(v2);
  v4 = HIWORD(EntireFooterRowsCellRange);
  if (!HIWORD(EntireFooterRowsCellRange))
    return 0xFFFFFFLL;
  v6 = EntireFooterRowsCellRange;
  RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)v2, (void *)objc_msgSend(a1, "layoutHint"));
  v8 = 0;
  v9 = 16711680;
  v10 = 0xFFFFLL;
  if ((_WORD)RangeForHint == 0xFFFF)
    goto LABEL_24;
  v11 = 0;
  if ((RangeForHint & 0xFF0000) == 0xFF0000)
    return v9 | v11 | v10 | v8;
  v8 = 0;
  v9 = 16711680;
  v10 = 0xFFFFLL;
  if (!HIWORD(RangeForHint))
  {
LABEL_24:
    v11 = 0;
    return v9 | v11 | v10 | v8;
  }
  v11 = 0;
  if ((RangeForHint & 0xFFFF00000000) != 0)
  {
    v8 = 0;
    v9 = 16711680;
    v10 = 0xFFFFLL;
    if ((v6 & 0xFFFF00000000) != 0 && (unsigned __int16)v6 != 0xFFFFLL)
    {
      v11 = 0;
      if ((v6 & 0xFF0000) != 0xFF0000)
      {
        v10 = 0;
        if (BYTE2(RangeForHint) <= BYTE2(v6))
          v12 = BYTE2(v6);
        else
          v12 = BYTE2(RangeForHint);
        if ((unsigned __int16)RangeForHint <= (unsigned __int16)v6)
          v13 = (unsigned __int16)v6;
        else
          v13 = (unsigned __int16)RangeForHint;
        if ((BYTE4(RangeForHint) + BYTE2(RangeForHint) - 1) >= (BYTE4(v6) + BYTE2(v6) - 1))
          v14 = (BYTE4(v6) + BYTE2(v6) - 1);
        else
          v14 = (BYTE4(RangeForHint) + BYTE2(RangeForHint) - 1);
        v15 = (unsigned __int16)(v6 + v4 - 1);
        if ((unsigned __int16)(RangeForHint + HIWORD(RangeForHint) - 1) < v15)
          v15 = (unsigned __int16)(RangeForHint + HIWORD(RangeForHint) - 1);
        v9 = 0;
        v8 = 0;
        v11 = 0;
        if (v13 <= v15 && v12 <= v14)
        {
          v11 = ((unint64_t)(v15 - v13) << 48) + 0x1000000000000;
          v8 = (unint64_t)(unsigned __int16)(v14 - v12 + 1) << 32;
          v9 = v12 << 16;
          v10 = v13;
        }
      }
      return v9 | v11 | v10 | v8;
    }
    goto LABEL_24;
  }
  return v9 | v11 | v10 | v8;
}

uint64_t TSTLayoutIsPartitionAlongTop(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") & 1;
}

uint64_t TSTLayoutIsPartitionAlongBottom(void *a1)
{
  return (objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") >> 1) & 1;
}

uint64_t TSTLayoutIsPartitionAlongLeft(void *a1)
{
  return (objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") >> 2) & 1;
}

uint64_t TSTLayoutIsPartitionAlongRight(void *a1)
{
  return (objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") >> 3) & 1;
}

BOOL TSTLayoutIsPartitionPaginated(void *a1)
{
  return (~objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") & 0xF) != 0;
}

uint64_t TSTLayoutGetFrozenHeaderColumnsSpace(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "frozenHeaderColumnsSpace");
}

uint64_t TSTLayoutGetFrozenHeaderRowsSpace(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "frozenHeaderRowsSpace");
}

uint64_t TSTLayoutGetFrozenHeaderCornerSpace(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "frozenHeaderCornerSpace");
}

uint64_t TSTLayoutGetRepeatHeaderColumnsSpace(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "repeatHeaderColumnsSpace");
}

uint64_t TSTLayoutGetRepeatHeaderRowsSpace(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "repeatHeaderRowsSpace");
}

uint64_t TSTLayoutGetRepeatHeaderCornerSpace(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "repeatHeaderCornerSpace");
}

double TSTLayoutGetAlignedMaskRectForSpace(TSTLayout *a1, void *a2)
{
  double AlignedStrokeFrame;
  double v5;
  double v6;
  double v7;
  double CanvasRectForLayoutRect;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double *v14;
  double v15;
  double v16;
  double v17;
  int FrozenHeaderColumnsFloating;
  int FrozenHeaderRowsFloating;
  double AlignedFrame;
  double v21;
  double v22;
  CGFloat v23;
  double v24;
  double v25;
  double v26;
  double v27;
  uint64_t v28;
  double v29;
  double v30;
  double v31;
  int v32;
  CGFloat v33;
  double v34;
  double v35;
  double v36;
  CGFloat v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  uint64_t v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v51;
  double v52;
  double v53;
  double x;
  double v55;
  double v56;
  double y;
  CGFloat v58;
  CGFloat v59;
  double FrozenHeadersTabOffset;
  double v61;
  double v62;
  double v63;
  double rect;
  CGRect v65;
  CGRect v66;

  objc_msgSend(a2, "lockForRead");
  AlignedStrokeFrame = TSTLayoutSpaceGetAlignedStrokeFrame((uint64_t)a2);
  CanvasRectForLayoutRect = TSTLayoutSpaceGetCanvasRectForLayoutRect((uint64_t)a2, AlignedStrokeFrame, v5, v6, v7);
  v10 = v9;
  v63 = v11;
  rect = v12;
  FrozenHeadersTabOffset = TSTLayoutGetFrozenHeadersTabOffset(a1);
  v62 = v13;
  v14 = (double *)MEMORY[0x24BDBEFB0];
  v16 = *MEMORY[0x24BDBEFB0];
  v15 = *(double *)(MEMORY[0x24BDBEFB0] + 8);
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  v61 = v17;
  FrozenHeaderColumnsFloating = TSTLayoutGetFrozenHeaderColumnsFloating(a1);
  FrozenHeaderRowsFloating = TSTLayoutGetFrozenHeaderRowsFloating(a1);
  if (-[TSTLayoutSpaceBundle frozenHeaderColumnsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderColumnsSpace")&& FrozenHeaderColumnsFloating&& (-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space") == a2|| -[TSTLayoutSpaceBundle frozenHeaderRowsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderRowsSpace") == a2))
  {
    x = a1->mCanvasVisibleRect.origin.x;
    v58 = v10;
    AlignedFrame = TSTLayoutSpaceGetAlignedFrame((uint64_t)-[TSTLayoutSpaceBundle frozenHeaderColumnsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderColumnsSpace"));
    v51 = v22;
    v52 = v21;
    v23 = CanvasRectForLayoutRect;
    v25 = v24;
    v56 = AlignedStrokeFrame;
    v26 = TSTLayoutSpaceGetAlignedStrokeFrame((uint64_t)-[TSTLayoutSpaceBundle frozenHeaderColumnsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderColumnsSpace"));
    v27 = v25 + AlignedFrame - v26;
    CanvasRectForLayoutRect = v23;
    v28 = -[TSTLayoutSpaceBundle frozenHeaderColumnsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderColumnsSpace");
    v29 = v27;
    v10 = v58;
    TSTLayoutSpaceGetCanvasRectForLayoutRect(v28, v26, v52, v29, v51);
    v31 = FrozenHeadersTabOffset + x + v30;
    v65.origin.x = v23;
    v65.origin.y = v58;
    v65.size.width = v63;
    v65.size.height = rect;
    v16 = v31 - CGRectGetMinX(v65);
    AlignedStrokeFrame = v56;
  }
  if (-[TSTLayoutSpaceBundle frozenHeaderRowsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderRowsSpace"))
  {
    v32 = FrozenHeaderRowsFloating;
  }
  else
  {
    v32 = 0;
  }
  if (v32 == 1
    && (-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space") == a2
     || -[TSTLayoutSpaceBundle frozenHeaderColumnsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderColumnsSpace") == a2))
  {
    y = a1->mCanvasVisibleRect.origin.y;
    v33 = TSTLayoutSpaceGetAlignedFrame((uint64_t)-[TSTLayoutSpaceBundle frozenHeaderRowsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderRowsSpace"));
    v53 = v34;
    v55 = v33;
    v59 = v10;
    v36 = v35;
    v37 = CanvasRectForLayoutRect;
    v39 = v38;
    TSTLayoutSpaceGetAlignedStrokeFrame((uint64_t)-[TSTLayoutSpaceBundle frozenHeaderRowsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderRowsSpace"));
    v40 = AlignedStrokeFrame;
    v42 = v41;
    v43 = v39 + v36 - v41;
    CanvasRectForLayoutRect = v37;
    v44 = -[TSTLayoutSpaceBundle frozenHeaderRowsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderRowsSpace");
    v45 = v42;
    AlignedStrokeFrame = v40;
    v46 = v43;
    v10 = v59;
    TSTLayoutSpaceGetCanvasRectForLayoutRect(v44, v55, v45, v53, v46);
    v66.size.width = v63;
    v48 = v62 + v61 + y + v47;
    v66.origin.x = v37;
    v66.origin.y = v59;
    v66.size.height = rect;
    v15 = v48 - CGRectGetMinY(v66);
  }
  if (v16 != *v14 || v15 != v14[1])
    AlignedStrokeFrame = TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)a2, CanvasRectForLayoutRect + v16, v10 + v15, v63 - v16, rect - v15);
  objc_msgSend(a2, "unlock");
  return AlignedStrokeFrame;
}

double TSTLayoutGetFrozenHeadersTabOffset(TSTLayout *a1)
{
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CGRect v14;
  CGRect v15;

  v2 = *MEMORY[0x24BDBEFB0];
  -[TSTLayoutSpace viewScale](-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), "viewScale");
  if (a1->mTabsVisible)
  {
    v4 = v3;
    TSTLayoutGetTopLeftTabCanvasFrame((double *)a1);
    v14.origin.x = TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), v5, v6, v7, v8);
    x = v14.origin.x;
    y = v14.origin.y;
    width = v14.size.width;
    height = v14.size.height;
    v2 = 6.0 / v4 + CGRectGetWidth(v14);
    v15.origin.x = x;
    v15.origin.y = y;
    v15.size.width = width;
    v15.size.height = height;
    CGRectGetHeight(v15);
  }
  return v2;
}

uint64_t TSTLayoutGetFrozenHeaderColumnsFloating(TSTLayout *a1)
{
  uint64_t result;
  BOOL v3;
  BOOL v4;
  uint64_t v5;
  double FrozenHeadersTabOffset;
  double CanvasStrokeFrame;
  double v8;

  result = objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "supportsFrozenHeaders");
  if ((_DWORD)result)
  {
    v3 = -[TSTLayout inFindReplaceMode](a1, "inFindReplaceMode");
    v4 = -[TSTLayout isZoomedEditing](a1, "isZoomedEditing");
    v5 = -[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space");
    FrozenHeadersTabOffset = TSTLayoutGetFrozenHeadersTabOffset(a1);
    CanvasStrokeFrame = TSTLayoutSpaceGetCanvasStrokeFrame(v5);
    result = 0;
    if (!v3 && !v4)
    {
      v8 = CanvasStrokeFrame;
      result = TSTLayoutGetFrozenHeadersBodyVisible(a1);
      if ((_DWORD)result)
        return v8 < FrozenHeadersTabOffset + a1->mCanvasVisibleRect.origin.x;
    }
  }
  return result;
}

uint64_t TSTLayoutGetFrozenHeaderRowsFloating(TSTLayout *a1)
{
  uint64_t result;
  _BOOL4 v3;
  _BOOL4 v4;
  int v5;
  uint64_t v6;
  double v7;
  double v8;
  double v9;
  double v10;

  result = objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "supportsFrozenHeaders");
  if ((_DWORD)result)
  {
    v3 = -[TSTLayout inFindReplaceMode](a1, "inFindReplaceMode");
    v4 = -[TSTLayout isZoomedEditing](a1, "isZoomedEditing");
    v5 = -[TSTEditingState editingMode](-[TSTTableInfo editingState](-[TSTLayout tableInfo](a1, "tableInfo"), "editingState"), "editingMode");
    v6 = -[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space");
    TSTLayoutGetFrozenHeadersTabOffset(a1);
    v8 = v7;
    if (a1->mTableNameVisible)
      TSTLayoutGetCanvasStrokeFrameForTableName(a1);
    else
      TSTLayoutSpaceGetCanvasStrokeFrame(v6);
    v10 = v9;
    result = 0;
    if (!v3 && !v4 && v5 != 7)
    {
      result = TSTLayoutGetFrozenHeadersBodyVisible(a1);
      if ((_DWORD)result)
        return v10 < v8 + a1->mCanvasVisibleRect.origin.y;
    }
  }
  return result;
}

double TSTLayoutGetCanvasVisibleRect(uint64_t a1)
{
  return *(double *)(a1 + 320);
}

double TSTLayoutGetTransformToCanvas@<D0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  void *v3;
  double result;

  v3 = (void *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  if (v3)
  {
    objc_msgSend(v3, "transformToCanvas");
  }
  else
  {
    result = 0.0;
    a2[1] = 0u;
    a2[2] = 0u;
    *a2 = 0u;
  }
  return result;
}

double TSTLayoutGetTransformToDevice@<D0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  void *v3;
  double result;

  v3 = (void *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  if (v3)
  {
    objc_msgSend(v3, "transformToDevice");
  }
  else
  {
    result = 0.0;
    a2[1] = 0u;
    a2[2] = 0u;
    *a2 = 0u;
  }
  return result;
}

uint64_t TSTLayoutSetViewScale(void *a1, double a2)
{
  void *v3;
  _QWORD v5[5];

  v3 = (void *)objc_msgSend(a1, "spaceBundle");
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 3221225472;
  v5[2] = __TSTLayoutSetViewScale_block_invoke;
  v5[3] = &__block_descriptor_40_e24_B16__0__TSTLayoutSpace_8l;
  *(double *)&v5[4] = a2;
  return objc_msgSend(v3, "performActionOnEachLayoutSpace:", v5);
}

uint64_t TSTLayoutGetViewScale(void *a1)
{
  return objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
}

double TSTLayoutGetRectForCanvasRect(void *a1, double a2, double a3, double a4, double a5)
{
  return TSTLayoutSpaceGetLayoutRectForCanvasRect(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), a2, a3, a4, a5);
}

double TSTLayoutGetPointForCanvasPoint(void *a1, double a2, double a3)
{
  return TSTLayoutSpaceGetLayoutPointForCanvasPoint(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), a2, a3);
}

double TSTLayoutGetCanvasRectForRect(void *a1, double a2, double a3, double a4, double a5)
{
  return TSTLayoutSpaceGetCanvasRectForLayoutRect(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), a2, a3, a4, a5);
}

double TSTLayoutGetCanvasPointForPoint(void *a1, double a2, double a3)
{
  return TSTLayoutSpaceGetCanvasPointForLayoutPoint(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), a2, a3);
}

double TSTLayoutGetCanvasFrame(void *a1)
{
  return TSTLayoutSpaceGetCanvasFrame(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
}

double TSTLayoutGetCanvasStrokeFrame(void *a1)
{
  return TSTLayoutSpaceGetCanvasStrokeFrame(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
}

uint64_t TSTLayoutGetTabsVisible(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 385);
}

void TSTLayoutGetTopLeftTabCanvasFrame(double *a1)
{
  uint64_t v2;
  double AlignedStrokeFrame;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double CanvasRectForLayoutRect;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  CGFloat v23;
  CGFloat v24;
  CGFloat v25;
  CGFloat v26;
  CGFloat MaxX;
  BOOL v28;
  CGFloat v29;
  CGFloat v30;
  CGFloat v31;
  CGFloat v32;
  double v33;
  CGRect v34;
  CGRect v35;

  v2 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  AlignedStrokeFrame = TSTLayoutGetAlignedStrokeFrame(a1);
  v5 = v4;
  v7 = v6;
  v9 = v8;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  v11 = v10;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  v33 = v12;
  v13 = v5 - v12;
  CanvasRectForLayoutRect = TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, AlignedStrokeFrame - 31.0 / v11, v13 - 31.0 / v11, 25.0 / v11, 25.0 / v11);
  v16 = v15;
  v17 = TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, AlignedStrokeFrame, v13, v7, v9);
  v22 = a1[40];
  v21 = a1[41];
  if (CanvasRectForLayoutRect < v22)
  {
    v23 = v17;
    v24 = v18;
    v25 = v19;
    v26 = v20;
    MaxX = CGRectGetMaxX(*(CGRect *)&v17);
    v18 = v24;
    v20 = v26;
    v19 = v25;
    v28 = v22 < MaxX;
    v17 = v23;
    if (!v28)
    {
      v34.origin.x = v23;
      v34.origin.y = v24;
      v34.size.width = v25;
      v34.size.height = v26;
      CGRectGetMaxX(v34);
      v18 = v24;
      v20 = v26;
      v19 = v25;
      v17 = v23;
    }
  }
  if (v16 < v21)
  {
    v29 = v17;
    v30 = v18;
    v31 = v19;
    v32 = v20;
    if (v21 >= v33 + CGRectGetMaxY(*(CGRect *)&v17))
    {
      v35.origin.x = v29;
      v35.origin.y = v30;
      v35.size.width = v31;
      v35.size.height = v32;
      CGRectGetMaxY(v35);
    }
  }
}

double TSTLayoutGetAlignedStrokeFrame(void *a1)
{
  __int128 v1;
  void *v2;
  double v3;
  _QWORD v5[5];
  uint64_t v6;
  double *v7;
  uint64_t v8;
  __n128 (*v9)(uint64_t, uint64_t);
  uint64_t (*v10)();
  void *v11;
  __int128 v12;
  __int128 v13;

  v6 = 0;
  v7 = (double *)&v6;
  v8 = 0x5012000000;
  v9 = __Block_byref_object_copy__30;
  v10 = __Block_byref_object_dispose__30;
  v11 = &unk_217C8B239;
  v1 = *(_OWORD *)(MEMORY[0x24BDBF070] + 16);
  v12 = *MEMORY[0x24BDBF070];
  v13 = v1;
  v2 = (void *)objc_msgSend(a1, "spaceBundle");
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 3221225472;
  v5[2] = __TSTLayoutGetAlignedStrokeFrame_block_invoke;
  v5[3] = &unk_24D82F808;
  v5[4] = &v6;
  objc_msgSend(v2, "performActionOnEachLayoutSpace:", v5);
  v3 = v7[6];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_217BD8D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double TSTLayoutGetTopRightTabCanvasFrame(double *a1)
{
  uint64_t v2;
  double AlignedStrokeFrame;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  CGFloat MaxX;
  double CanvasRectForLayoutRect;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  CGFloat v24;
  CGFloat v25;
  CGFloat v26;
  CGFloat v27;
  CGRect v29;
  CGRect v30;

  v2 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  AlignedStrokeFrame = TSTLayoutGetAlignedStrokeFrame(a1);
  v5 = v4;
  v7 = v6;
  v9 = v8;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  v11 = v10;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  v13 = v5 - v12;
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyColumnTabResizing"))
  {
    objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicColumnTabSize");
    v7 = v14;
  }
  v29.origin.x = AlignedStrokeFrame;
  v29.origin.y = v13;
  v29.size.width = v7;
  v29.size.height = v9;
  MaxX = CGRectGetMaxX(v29);
  CanvasRectForLayoutRect = TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, 6.0 / v11 + MaxX, v13 + -31.0 / v11, 25.0 / v11, 25.0 / v11);
  v18 = v17;
  v19 = TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, AlignedStrokeFrame, v13, v7, v9);
  v23 = a1[41];
  if (v18 < v23)
  {
    v24 = v19;
    v25 = v20;
    v26 = v21;
    v27 = v22;
    if (v23 >= CGRectGetMaxY(*(CGRect *)&v19))
    {
      v30.origin.x = v24;
      v30.origin.y = v25;
      v30.size.width = v26;
      v30.size.height = v27;
      CGRectGetMaxY(v30);
    }
  }
  return CanvasRectForLayoutRect;
}

double TSTLayoutGetBottomLeftTabCanvasFrame(double *a1)
{
  uint64_t v2;
  double AlignedStrokeFrame;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  CGFloat MaxY;
  double CanvasRectForLayoutRect;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  CGFloat v20;
  CGFloat v21;
  CGFloat v22;
  CGFloat v23;
  CGRect v25;
  CGRect v26;

  v2 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  AlignedStrokeFrame = TSTLayoutGetAlignedStrokeFrame(a1);
  v5 = v4;
  v7 = v6;
  v9 = v8;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  v11 = v10;
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyRowTabResizing"))
  {
    objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicRowTabSize");
    v9 = v12;
  }
  v25.origin.x = AlignedStrokeFrame;
  v25.origin.y = v5;
  v25.size.width = v7;
  v25.size.height = v9;
  MaxY = CGRectGetMaxY(v25);
  CanvasRectForLayoutRect = TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, AlignedStrokeFrame + -31.0 / v11, 6.0 / v11 + MaxY, 25.0 / v11, 25.0 / v11);
  v15 = TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, AlignedStrokeFrame, v5, v7, v9);
  v19 = a1[40];
  if (CanvasRectForLayoutRect < v19)
  {
    v20 = v15;
    v21 = v16;
    v22 = v17;
    v23 = v18;
    CanvasRectForLayoutRect = a1[40];
    if (v19 >= CGRectGetMaxX(*(CGRect *)&v15))
    {
      v26.origin.x = v20;
      v26.origin.y = v21;
      v26.size.width = v22;
      v26.size.height = v23;
      return CGRectGetMaxX(v26);
    }
  }
  return CanvasRectForLayoutRect;
}

double TSTLayoutGetBottomRightTabCanvasFrame(void *a1)
{
  uint64_t v2;
  double AlignedStrokeFrame;
  double v4;
  CGFloat v5;
  double v6;
  CGFloat v7;
  double v8;
  CGFloat v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  CGRect v17;
  CGRect v18;

  v2 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  AlignedStrokeFrame = TSTLayoutGetAlignedStrokeFrame(a1);
  v5 = v4;
  v7 = v6;
  v9 = v8;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  v11 = v10;
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyColumnTabResizing"))
  {
    objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicColumnTabSize");
    v7 = v12;
  }
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyRowTabResizing"))
  {
    objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicRowTabSize");
    v9 = v13;
  }
  v17.origin.x = AlignedStrokeFrame;
  v17.origin.y = v5;
  v17.size.width = v7;
  v17.size.height = v9;
  v14 = 6.0 / v11 + CGRectGetMaxX(v17);
  v18.origin.x = AlignedStrokeFrame;
  v18.origin.y = v5;
  v18.size.width = v7;
  v18.size.height = v9;
  v15 = 6.0 / v11 + CGRectGetMaxY(v18);
  return TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, v14, v15, 25.0 / v11, 25.0 / v11);
}

double TSTLayoutGetColumnTabsRangeFrame(TSTLayout *a1, unint64_t a2)
{
  double AlignedOverrideFrameForRange;

  -[TSTLayoutSpace viewScale](-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle", TSTLayoutGetAlignedStrokeFrame(a1)), "space"), "viewScale");
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  AlignedOverrideFrameForRange = *MEMORY[0x24BDBF090];
  if (HIWORD(a2) && (a2 & 0xFFFF00000000) != 0)
    AlignedOverrideFrameForRange = TSTLayoutGetAlignedOverrideFrameForRange(a1, a2, 1.0);
  TSTLayoutGetVisibleRect((double *)a1);
  return AlignedOverrideFrameForRange;
}

double TSTLayoutGetAlignedOverrideFrameForRange(TSTLayout *a1, unint64_t a2, double a3)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD v9[5];

  v3 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v3 = -1;
  v4 = WORD2(a2) + v3 - 1;
  if (!WORD2(a2))
    v4 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v5 = 0xFFFFFFFFLL;
  else
    v5 = (unsigned __int16)a2;
  v6 = v3 | ((unint64_t)v5 << 32);
  v7 = ((a2 >> 16) & 0xFFFF00000000) + (v5 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v7 = 0xFFFFFFFF00000000;
  v9[0] = MEMORY[0x24BDAC760];
  v9[1] = 3221225472;
  v9[2] = __TSTLayoutGetAlignedOverrideFrameForGridRange_block_invoke;
  v9[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__32__0__TSTLayoutSpace_8______II____II__16l;
  *(double *)&v9[4] = a3;
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, v6, v4 | v7, (uint64_t)v9);
}

double TSTLayoutGetVisibleRect(double *a1)
{
  return TSTLayoutSpaceGetLayoutRectForCanvasRect(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), a1[40], a1[41], a1[42], a1[43]);
}

void TSTLayoutGetColumnTabsCanvasFrame(void *a1)
{
  TSTLayoutGetColumnTabsCanvasFrameAndAdjustment(a1, 0);
}

void TSTLayoutGetColumnTabsCanvasFrameAndAdjustment(void *a1, double *a2)
{
  double AlignedStrokeFrame;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  uint64_t v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  CGFloat v22;
  double v23;
  double VisibleRect;
  double v25;
  double v26;
  double v27;
  BOOL v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  CGFloat v35;
  CGFloat v36;
  CGRect v37;
  CGRect v38;

  AlignedStrokeFrame = TSTLayoutGetAlignedStrokeFrame(a1);
  v6 = v5;
  v8 = v7;
  v36 = v9;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  v11 = v10;
  v12 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  v14 = v13;
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyColumnTabResizing"))
  {
    objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicColumnTabSize");
    v8 = v15;
  }
  v16 = 2.0 / v11;
  v17 = AlignedStrokeFrame - 2.0 / v11;
  v18 = v6 - v14;
  v33 = v11;
  v19 = 29.0 / v11;
  v35 = v6;
  v20 = v18 - 29.0 / v11;
  v21 = 2.0 / v11 + 2.0;
  v22 = v8;
  v23 = v21 + v8;
  VisibleRect = TSTLayoutGetVisibleRect((double *)a1);
  v26 = v25;
  v27 = VisibleRect - (v17 - v19);
  v28 = v17 - v19 < VisibleRect;
  v29 = 0.0;
  if (v28)
    v29 = v27;
  v34 = v29;
  v30 = v23 - v29;
  v31 = -0.0;
  if (v28)
    v31 = v27;
  v32 = v31;
  if (v20 < v16 + v25)
  {
    v37.origin.x = AlignedStrokeFrame;
    v37.origin.y = v35;
    v37.size.height = v36;
    v37.size.width = v22;
    v20 = v16 + v26;
    if (v26 >= CGRectGetMaxY(v37))
    {
      v38.origin.x = AlignedStrokeFrame;
      v38.origin.y = v35;
      v38.size.height = v36;
      v38.size.width = v22;
      v20 = v16 + CGRectGetMaxY(v38);
    }
  }
  if (v30 <= 0.0)
  {
    if (!a2)
      return;
    goto LABEL_14;
  }
  TSTLayoutSpaceGetCanvasRectForLayoutRect(v12, v17 + v32, v20, v30, 22.0 / v33);
  if (a2)
LABEL_14:
    *a2 = v34;
}

void TSTLayoutGetRowTabsRangeFrame(TSTLayout *a1, unint64_t a2)
{
  TSTLayoutGetAlignedStrokeFrame(a1);
  -[TSTLayoutSpace viewScale](-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), "viewScale");
  TSTMasterLayoutGetTableNumberOfRows((uint64_t)-[TSTLayout masterLayout](a1, "masterLayout"));
  if (HIWORD(a2) && (a2 & 0xFFFF00000000) != 0)
    TSTLayoutGetAlignedOverrideFrameForRange(a1, a2, 1.0);
  TSTLayoutGetVisibleRect((double *)a1);
}

void TSTLayoutGetRowTabsCanvasFrame(void *a1)
{
  TSTLayoutGetRowTabsCanvasFrameAndAdjustment(a1, 0);
}

void TSTLayoutGetRowTabsCanvasFrameAndAdjustment(void *a1, double *a2)
{
  double AlignedStrokeFrame;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  uint64_t v12;
  double v13;
  double v14;
  double v15;
  unsigned int v16;
  double v17;
  double v18;
  double v19;
  double VisibleRect;
  double v21;
  double v22;
  double v23;
  CGFloat v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  CGFloat v31;
  CGFloat v32;
  double v33;
  double v34;
  CGRect v35;
  CGRect v36;

  AlignedStrokeFrame = TSTLayoutGetAlignedStrokeFrame(a1);
  v6 = v5;
  v32 = v7;
  v9 = v8;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  v11 = v10;
  v12 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  v14 = v13;
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyRowTabResizing"))
  {
    objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicRowTabSize");
    v9 = v15;
  }
  v16 = TSTMasterLayoutGetTableNumberOfRows(objc_msgSend(a1, "masterLayout")) >> 4;
  if (v16 <= 0x270)
    v17 = 24.0;
  else
    v17 = 28.0;
  if (v16 <= 0x270)
    v18 = 1.0;
  else
    v18 = -3.0;
  v30 = v17;
  v31 = v6;
  v19 = AlignedStrokeFrame - (v17 + 6.0) / v11;
  v33 = v14 + 2.0 / v11 + 2.0 + v9;
  v34 = v6 - v14 - 2.0 / v11;
  VisibleRect = TSTLayoutGetVisibleRect((double *)a1);
  v22 = v21;
  v23 = v18 / v11;
  v24 = v9;
  v25 = VisibleRect + v23;
  if (v19 < VisibleRect + v23)
  {
    v26 = VisibleRect;
    v35.origin.x = AlignedStrokeFrame;
    v35.origin.y = v31;
    v35.size.width = v32;
    v35.size.height = v24;
    v19 = v25;
    if (v26 >= CGRectGetMaxX(v35))
    {
      v36.origin.x = AlignedStrokeFrame;
      v36.origin.y = v31;
      v36.size.width = v32;
      v36.size.height = v24;
      v19 = v23 + CGRectGetMaxX(v36);
    }
  }
  v27 = v34 + -29.0 / v11;
  v28 = v22 - v27;
  if (v27 >= v22)
    v29 = 0.0;
  else
    v29 = v22 - v27;
  if (v33 - v29 <= 0.0)
  {
    if (!a2)
      return;
    goto LABEL_21;
  }
  if (v27 >= v22)
    v28 = -0.0;
  TSTLayoutSpaceGetCanvasRectForLayoutRect(v12, v19, v34 + v28, v30 / v11, v33 - v29);
  if (a2)
LABEL_21:
    *a2 = v29;
}

double TSTLayoutGetTextLayerFrame(TSTLayout *a1)
{
  double Frame;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;

  Frame = TSTLayoutSpaceGetFrame((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"));
  v4 = v3;
  v6 = v5;
  v8 = v7;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  return TSTLayoutSpaceGetCanvasRectForLayoutRect((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), Frame, v4 - v9, v6, v8);
}

double TSTLayoutGetFrame(void *a1)
{
  return TSTLayoutSpaceGetFrame(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
}

void TSTLayoutGetTabsWidthOffset(void *a1)
{
  double Frame;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;

  Frame = TSTLayoutSpaceGetFrame(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
  v4 = v3;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  v6 = v4 - v5;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  TSTLayoutSpaceGetCanvasRectForLayoutRect(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), (Frame + -31.0) / v7, (v6 + -31.0) / v7, 25.0 / v7, 25.0 / v7);
}

void TSTLayoutGetTabsHeightOffset(void *a1)
{
  double Frame;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;

  Frame = TSTLayoutSpaceGetFrame(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
  v4 = v3;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  v6 = v4 - v5;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), "viewScale");
  TSTLayoutSpaceGetCanvasRectForLayoutRect(objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"), (Frame + -31.0) / v7, (v6 + -31.0) / v7, 25.0 / v7, 25.0 / v7);
}

double TSTLayoutGetCanvasFrozenHeaderColumnsOffset(TSTLayout *a1)
{
  uint64_t v2;
  double x;
  double FrozenHeadersTabOffset;
  double v5;

  v2 = -[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space");
  x = a1->mCanvasVisibleRect.origin.x;
  if (a1->mTabsVisible)
    FrozenHeadersTabOffset = TSTLayoutGetFrozenHeadersTabOffset(a1);
  else
    FrozenHeadersTabOffset = *MEMORY[0x24BDBEFB0];
  v5 = x + FrozenHeadersTabOffset;
  TSTLayoutSpaceGetCanvasStrokeFrame(v2);
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  return v5;
}

double TSTLayoutGetCanvasFrozenHeaderRowsOffset(TSTLayout *a1)
{
  uint64_t v2;
  double CanvasStrokeFrame;

  v2 = -[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space");
  if (a1->mTabsVisible)
    TSTLayoutGetFrozenHeadersTabOffset(a1);
  CanvasStrokeFrame = TSTLayoutSpaceGetCanvasStrokeFrame(v2);
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  return CanvasStrokeFrame;
}

double TSTLayoutGetCanvasFrozenHeaderCornerOffset(TSTLayout *a1)
{
  uint64_t v2;
  double x;
  double y;
  double FrozenHeadersTabOffset;
  double v6;
  double CanvasStrokeFrame;
  double v8;
  double v9;
  double v10;
  double v11;

  v2 = -[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space");
  x = a1->mCanvasVisibleRect.origin.x;
  y = a1->mCanvasVisibleRect.origin.y;
  if (a1->mTabsVisible)
  {
    FrozenHeadersTabOffset = TSTLayoutGetFrozenHeadersTabOffset(a1);
  }
  else
  {
    FrozenHeadersTabOffset = *MEMORY[0x24BDBEFB0];
    v6 = *(double *)(MEMORY[0x24BDBEFB0] + 8);
  }
  CanvasStrokeFrame = x + FrozenHeadersTabOffset;
  v8 = y + v6;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  v10 = v8 + v9;
  if (CanvasStrokeFrame < TSTLayoutSpaceGetCanvasStrokeFrame(v2))
    CanvasStrokeFrame = TSTLayoutSpaceGetCanvasStrokeFrame(v2);
  TSTLayoutSpaceGetCanvasStrokeFrame(v2);
  if (v10 < v11)
    TSTLayoutSpaceGetCanvasStrokeFrame(v2);
  return CanvasStrokeFrame;
}

CGAffineTransform *TSTLayoutGetFrozenHeaderColumnsTransformToLayout@<X0>(TSTLayout *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  double CanvasFrozenHeaderColumnsOffset;
  double v6;
  double LayoutPointForCanvasPoint;
  CGFloat v8;

  v4 = -[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space");
  CanvasFrozenHeaderColumnsOffset = TSTLayoutGetCanvasFrozenHeaderColumnsOffset(a1);
  LayoutPointForCanvasPoint = TSTLayoutSpaceGetLayoutPointForCanvasPoint(v4, CanvasFrozenHeaderColumnsOffset, v6);
  v8 = fmax(LayoutPointForCanvasPoint - TSTLayoutSpaceGetAlignedStrokeFrame(v4), 0.0);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  return CGAffineTransformMakeTranslation((CGAffineTransform *)a2, v8, 0.0);
}

CGAffineTransform *TSTLayoutGetFrozenTableNameTransformToLayout@<X0>(TSTLayout *a1@<X0>, CGAffineTransform *a2@<X8>)
{
  double AlignedStrokeFrameForTableNameBorder;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;

  AlignedStrokeFrameForTableNameBorder = TSTLayoutSpaceGetAlignedStrokeFrameForTableNameBorder(-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"));
  TSTLayoutSpaceGetCanvasRectForLayoutRect((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), AlignedStrokeFrameForTableNameBorder, v5, v6, v7);
  v9 = a1->mCanvasVisibleRect.origin.y - v8;
  if (a1->mTabsVisible)
  {
    TSTLayoutGetFrozenHeadersTabOffset(a1);
    v9 = v9 + v10;
  }
  return CGAffineTransformMakeTranslation(a2, 0.0, fmax(v9, 0.0));
}

double TSTLayoutGetAlignedStrokeFrameForTableNameBorder(void *a1)
{
  return TSTLayoutSpaceGetAlignedStrokeFrameForTableNameBorder((TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
}

CGAffineTransform *TSTLayoutGetFrozenHeaderRowsTransformToLayout@<X0>(TSTLayout *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  double CanvasFrozenHeaderRowsOffset;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  BOOL v11;
  double v12;

  v4 = -[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space");
  CanvasFrozenHeaderRowsOffset = TSTLayoutGetCanvasFrozenHeaderRowsOffset(a1);
  TSTLayoutSpaceGetLayoutPointForCanvasPoint(v4, CanvasFrozenHeaderRowsOffset, v6);
  v8 = v7;
  TSTLayoutSpaceGetAlignedStrokeFrame(v4);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  v10 = v8 - v9;
  v11 = v8 - v9 < 0.0;
  v12 = 0.0;
  if (!v11)
    v12 = v10;
  return CGAffineTransformMakeTranslation((CGAffineTransform *)a2, 0.0, v12);
}

CGAffineTransform *TSTLayoutGetFrozenHeaderCornerTransformToLayout@<X0>(TSTLayout *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  double CanvasFrozenHeaderCornerOffset;
  double v6;
  double LayoutPointForCanvasPoint;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;

  v4 = -[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space");
  CanvasFrozenHeaderCornerOffset = TSTLayoutGetCanvasFrozenHeaderCornerOffset(a1);
  LayoutPointForCanvasPoint = TSTLayoutSpaceGetLayoutPointForCanvasPoint(v4, CanvasFrozenHeaderCornerOffset, v6);
  v9 = v8;
  v10 = LayoutPointForCanvasPoint - TSTLayoutSpaceGetAlignedStrokeFrame(v4);
  if (v10 < 0.0)
    v10 = 0.0;
  v12 = v9 - v11;
  if (v12 < 0.0)
    v12 = 0.0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  return CGAffineTransformMakeTranslation((CGAffineTransform *)a2, v10, v12);
}

BOOL TSTLayoutGetFrozenHeadersBodyVisible(TSTLayout *a1)
{
  TSTLayoutSpace *v2;
  double x;
  double y;
  CGFloat width;
  CGFloat height;
  double FrozenHeadersTabOffset;
  double v8;
  double v9;
  CGFloat v10;
  double HeaderRowsHeight;
  double v12;
  CGFloat v13;
  CGRect v15;
  CGRect v16;

  v2 = -[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space");
  x = a1->mCanvasVisibleRect.origin.x;
  y = a1->mCanvasVisibleRect.origin.y;
  width = a1->mCanvasVisibleRect.size.width;
  height = a1->mCanvasVisibleRect.size.height;
  FrozenHeadersTabOffset = TSTLayoutGetFrozenHeadersTabOffset(a1);
  v9 = v8;
  v10 = x + TSTLayoutSpaceGetHeaderColumnsWidth(v2) + FrozenHeadersTabOffset;
  HeaderRowsHeight = TSTLayoutSpaceGetHeaderRowsHeight(v2);
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  v13 = y + v9 + HeaderRowsHeight + v12;
  v15.origin.x = TSTLayoutSpaceGetCanvasStrokeFrame((uint64_t)v2);
  v16.origin.x = v10;
  v16.origin.y = v13;
  v16.size.width = width;
  v16.size.height = height;
  return CGRectIntersectsRect(v15, v16);
}

uint64_t TSTLayoutGetFrozenHeaderColumnsEnabled(void *a1)
{
  uint64_t result;
  unsigned __int16 *v3;
  unint64_t EntireHeaderColumnsCellRange;
  _BOOL4 IsEntireCellRangeHidden;

  result = objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "supportsFrozenHeaders");
  if ((_DWORD)result)
  {
    v3 = (unsigned __int16 *)objc_msgSend(a1, "masterLayout");
    EntireHeaderColumnsCellRange = TSTMasterLayoutGetEntireHeaderColumnsCellRange(v3);
    IsEntireCellRangeHidden = TSTMasterLayoutIsEntireCellRangeHidden(v3, EntireHeaderColumnsCellRange);
    if ((objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") & 1) != 0
      && (objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") & 4) != 0)
    {
      result = TSTMasterLayoutGetHeaderColumnsFrozen(v3);
      if ((_DWORD)result)
        return TSTMasterLayoutGetTableNumberOfHeaderColumns(v3) && !IsEntireCellRangeHidden;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t TSTLayoutGetTableNameVisible(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 387);
}

double TSTLayoutGetCanvasStrokeFrameForTableName(void *a1)
{
  uint64_t v2;
  double StrokeFrameForTableNameBorder;
  double v4;
  double v5;
  double v6;

  v2 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  StrokeFrameForTableNameBorder = TSTLayoutSpaceGetStrokeFrameForTableNameBorder((TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
  return TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, StrokeFrameForTableNameBorder, v4, v5, v6);
}

uint64_t TSTLayoutGetFrozenHeaderRowsEnabled(void *a1)
{
  uint64_t result;
  unsigned __int16 *v3;
  unint64_t EntireHeaderRowsCellRange;
  _BOOL4 IsEntireCellRangeHidden;

  result = objc_msgSend(+[TSTConfiguration sharedTableConfiguration](TSTConfiguration, "sharedTableConfiguration"), "supportsFrozenHeaders");
  if ((_DWORD)result)
  {
    v3 = (unsigned __int16 *)objc_msgSend(a1, "masterLayout");
    EntireHeaderRowsCellRange = TSTMasterLayoutGetEntireHeaderRowsCellRange(v3);
    IsEntireCellRangeHidden = TSTMasterLayoutIsEntireCellRangeHidden(v3, EntireHeaderRowsCellRange);
    if ((objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") & 1) != 0
      && (objc_msgSend((id)objc_msgSend(a1, "layoutHint"), "partitionPosition") & 4) != 0)
    {
      result = TSTMasterLayoutGetHeaderRowsFrozen(v3);
      if ((_DWORD)result)
        return TSTMasterLayoutGetTableNumberOfHeaderRows(v3) && !IsEntireCellRangeHidden;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unint64_t TSTLayoutSetCanvasVisibleRect(uint64_t a1, double a2, double a3, double a4, double a5)
{
  CGFloat v6;
  CGFloat v7;
  CGFloat v8;
  CGFloat v9;
  double x;
  double y;
  double width;
  double height;
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  CGFloat v17;
  double MinX;
  double MinY;
  double MaxX;
  double MaxY;
  unint64_t result;
  __int128 v23;
  TSTChangeDescriptor *v24;
  CGFloat rect;
  CGRect v26;
  CGRect v27;
  CGRect v28;
  CGRect v29;
  CGRect v30;
  CGRect v31;
  CGRect v32;
  CGRect v33;
  CGRect v34;
  CGRect v35;
  CGRect v36;

  *(double *)(a1 + 320) = a2;
  *(double *)(a1 + 328) = a3;
  *(double *)(a1 + 336) = a4;
  *(double *)(a1 + 344) = a5;
  v26.origin.x = TSTLayoutGetVisibleAlignedStrokeFrame((void *)a1);
  v6 = *(double *)(a1 + 352);
  v7 = *(double *)(a1 + 360);
  v8 = *(double *)(a1 + 368);
  v9 = *(double *)(a1 + 376);
  *(CGRect *)(a1 + 352) = v26;
  v27 = CGRectIntegral(v26);
  x = v27.origin.x;
  y = v27.origin.y;
  width = v27.size.width;
  height = v27.size.height;
  v27.origin.x = v6;
  v27.origin.y = v7;
  v27.size.width = v8;
  v27.size.height = v9;
  v28 = CGRectIntegral(v27);
  v14 = v28.origin.x;
  v15 = v28.origin.y;
  v16 = v28.size.width;
  v17 = v28.size.height;
  if (CGRectIsEmpty(v28))
  {
    objc_msgSend((id)a1, "setNeedsDisplayInRect:", x, y, width, height);
  }
  else
  {
    v29.origin.x = x;
    v29.origin.y = y;
    v29.size.width = width;
    v29.size.height = height;
    rect = height;
    MinX = CGRectGetMinX(v29);
    v30.origin.x = v14;
    v30.origin.y = v15;
    v30.size.width = v16;
    v30.size.height = v17;
    if (MinX < CGRectGetMinX(v30))
      objc_msgSend((id)a1, "setNewCanvasRevealedHorizontally:", 1);
    v31.origin.x = x;
    v31.origin.y = y;
    v31.size.width = width;
    v31.size.height = rect;
    MinY = CGRectGetMinY(v31);
    v32.origin.x = v14;
    v32.origin.y = v15;
    v32.size.width = v16;
    v32.size.height = v17;
    if (MinY < CGRectGetMinY(v32))
      objc_msgSend((id)a1, "setNewCanvasRevealedVertically:", 1);
    v33.origin.x = x;
    v33.origin.y = y;
    v33.size.width = width;
    v33.size.height = rect;
    MaxX = CGRectGetMaxX(v33);
    v34.origin.x = v14;
    v34.origin.y = v15;
    v34.size.width = v16;
    v34.size.height = v17;
    if (MaxX > CGRectGetMaxX(v34))
      objc_msgSend((id)a1, "setNewCanvasRevealedHorizontally:", 1);
    v35.origin.x = x;
    v35.origin.y = y;
    v35.size.width = width;
    v35.size.height = rect;
    MaxY = CGRectGetMaxY(v35);
    v36.origin.x = v14;
    v36.origin.y = v15;
    v36.size.width = v16;
    v36.size.height = v17;
    if (MaxY > CGRectGetMaxY(v36))
      objc_msgSend((id)a1, "setNewCanvasRevealedVertically:", 1);
  }
  result = objc_msgSend((id)a1, "containedTextEditingLayout");
  if (result)
  {
    result = objc_msgSend((id)a1, "editingSpillingTextRange");
    if ((_WORD)result != 0xFFFF && (result & 0xFF0000) != 0xFF0000)
    {
      if (HIWORD(result))
      {
        if ((result & 0xFFFF00000000) != 0)
        {
          if ((TSTLayoutGetFrozenHeaderColumnsEnabled((void *)a1) & 1) != 0
            || (result = TSTLayoutGetFrozenHeaderRowsEnabled((void *)a1), (_DWORD)result))
          {
            objc_msgSend((id)objc_msgSend((id)a1, "containedTextEditingLayout"), "invalidateSize");
            v23 = *(_OWORD *)(MEMORY[0x24BDBF090] + 16);
            *(_OWORD *)(a1 + 512) = *MEMORY[0x24BDBF090];
            *(_OWORD *)(a1 + 528) = v23;
            v24 = +[TSTChangeDescriptor changeDescriptorWithType:strokeRange:](TSTChangeDescriptor, "changeDescriptorWithType:strokeRange:", 27, objc_msgSend((id)a1, "editingSpillingTextRange"));
            objc_msgSend((id)objc_msgSend((id)a1, "masterLayout"), "addChangeDescriptor:", v24);
            return +[TSKBroadcast asyncNotificationWithAccessController:changeNotifier:changeKind:details:changeSource:](TSKBroadcast, "asyncNotificationWithAccessController:changeNotifier:changeKind:details:changeSource:", objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)a1, "layoutController"), "canvas"), "accessController"), objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)a1, "layoutController"), "canvas"), "changeNotifier"), 1, v24, objc_msgSend((id)a1, "tableInfo"));
          }
        }
      }
    }
  }
  return result;
}

double TSTLayoutGetVisibleAlignedStrokeFrame(void *a1)
{
  __int128 v1;
  double v2;
  uint64_t v4;
  uint64_t v5;
  double *v6;
  uint64_t v7;
  __n128 (*v8)(uint64_t, uint64_t);
  uint64_t (*v9)();
  void *v10;
  __int128 v11;
  __int128 v12;

  v5 = 0;
  v6 = (double *)&v5;
  v7 = 0x5012000000;
  v8 = __Block_byref_object_copy__30;
  v9 = __Block_byref_object_dispose__30;
  v10 = &unk_217C8B239;
  v1 = *(_OWORD *)(MEMORY[0x24BDBF090] + 16);
  v11 = *MEMORY[0x24BDBF090];
  v12 = v1;
  objc_msgSend((id)objc_msgSend(a1, "spaceBundle", MEMORY[0x24BDAC760], 3221225472, __TSTLayoutGetVisibleAlignedStrokeFrame_block_invoke, &unk_24D82F760, a1, &v5), "performActionOnEachLayoutSpace:", &v4);
  v2 = v6[6];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_217BDA368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double TSTLayoutGetPreviousVisibleStrokeFrame(uint64_t a1)
{
  return *(double *)(a1 + 352);
}

double *TSTLayoutSetPreviousVisibleStrokeFrame(double *result, double a2, double a3, double a4, double a5)
{
  result[44] = a2;
  result[45] = a3;
  result[46] = a4;
  result[47] = a5;
  return result;
}

unint64_t TSTLayoutGetVisibleRange(double *a1)
{
  return TSTLayoutGetVisibleRangeForSpace(a1, (TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
}

unint64_t TSTLayoutGetVisibleRangeForSpace(double *a1, TSTLayoutSpace *a2)
{
  double LayoutRectForCanvasRect;
  double v4;
  double v5;
  double v6;

  LayoutRectForCanvasRect = TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)a2, a1[40], a1[41], a1[42], a1[43]);
  return TSTLayoutSpaceGetRangeIntersectingLayoutRect(a2, LayoutRectForCanvasRect, v4, v5, v6);
}

unint64_t TSTLayoutGetVisiblePartOfRange(double *a1, unint64_t a2)
{
  __int16 v3;
  unint64_t VisibleRangeForSpace;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;

  v3 = ~(_WORD)a2;
  VisibleRangeForSpace = TSTLayoutGetVisibleRangeForSpace(a1, (TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
  v5 = 0;
  v6 = 16711680;
  v7 = 0xFFFFLL;
  if (!v3)
    goto LABEL_23;
  v8 = 0;
  if ((a2 & 0xFF0000) == 0xFF0000)
    return v6 | v8 | v7 | v5;
  v5 = 0;
  v6 = 16711680;
  v7 = 0xFFFFLL;
  if (!HIWORD(a2))
    goto LABEL_23;
  v8 = 0;
  if ((a2 & 0xFFFF00000000) == 0)
    return v6 | v8 | v7 | v5;
  v5 = 0;
  v6 = 16711680;
  v7 = 0xFFFFLL;
  if ((_WORD)VisibleRangeForSpace == 0xFFFF)
    goto LABEL_23;
  v8 = 0;
  if ((VisibleRangeForSpace & 0xFF0000) == 0xFF0000)
    return v6 | v8 | v7 | v5;
  v5 = 0;
  v6 = 16711680;
  v7 = 0xFFFFLL;
  if (!HIWORD(VisibleRangeForSpace))
  {
LABEL_23:
    v8 = 0;
    return v6 | v8 | v7 | v5;
  }
  v8 = 0;
  if ((VisibleRangeForSpace & 0xFFFF00000000) != 0)
  {
    v7 = 0;
    if (BYTE2(a2) <= BYTE2(VisibleRangeForSpace))
      v9 = BYTE2(VisibleRangeForSpace);
    else
      v9 = BYTE2(a2);
    if ((unsigned __int16)a2 <= (unsigned __int16)VisibleRangeForSpace)
      v10 = (unsigned __int16)VisibleRangeForSpace;
    else
      v10 = (unsigned __int16)a2;
    if ((BYTE4(a2) + BYTE2(a2) - 1) >= (BYTE4(VisibleRangeForSpace)
                                                                                       + BYTE2(VisibleRangeForSpace)
                                                                                       - 1))
      v11 = (BYTE4(VisibleRangeForSpace) + BYTE2(VisibleRangeForSpace) - 1);
    else
      v11 = (BYTE4(a2) + BYTE2(a2) - 1);
    v12 = (unsigned __int16)(VisibleRangeForSpace + HIWORD(VisibleRangeForSpace) - 1);
    if ((unsigned __int16)(a2 + HIWORD(a2) - 1) < v12)
      v12 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
    v6 = 0;
    v5 = 0;
    v8 = 0;
    if (v10 <= v12 && v9 <= v11)
    {
      v8 = ((unint64_t)(v12 - v10) << 48) + 0x1000000000000;
      v5 = (unint64_t)(unsigned __int16)(v11 - v9 + 1) << 32;
      v6 = v9 << 16;
      v7 = v10;
    }
  }
  return v6 | v8 | v7 | v5;
}

__n128 __Block_byref_object_copy__30(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void *TSTLayoutGetVisibleLayoutSpaces(TSTLayout *a1)
{
  uint64_t v2;
  void *v3;
  uint64_t i;
  uint64_t v5;
  int v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (-[TSTMasterLayout isDynamicallyRepressingFrozenHeaders](-[TSTLayout masterLayout](a1, "masterLayout"), "isDynamicallyRepressingFrozenHeaders"))
  {
    v2 = 0;
    v8 = 0;
    v9 = 0;
  }
  else
  {
    v9 = -[TSTLayoutSpaceBundle frozenHeaderRowsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle", -[TSTLayoutSpaceBundle frozenHeaderCornerSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderCornerSpace")), "frozenHeaderRowsSpace");
    v2 = -[TSTLayoutSpaceBundle frozenHeaderColumnsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderColumnsSpace");
  }
  v10 = -[TSTLayoutSpaceBundle repeatHeaderCornerSpace](-[TSTLayout spaceBundle](a1, "spaceBundle", v8, v9, v2), "repeatHeaderCornerSpace");
  v11 = -[TSTLayoutSpaceBundle repeatHeaderRowsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "repeatHeaderRowsSpace");
  v12 = -[TSTLayoutSpaceBundle repeatHeaderColumnsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "repeatHeaderColumnsSpace");
  v13 = -[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space");
  v3 = (void *)objc_msgSend(MEMORY[0x24BDBCEB8], "arrayWithCapacity:", 7);
  for (i = 0; i != 56; i += 8)
  {
    v5 = *(uint64_t *)((char *)&v8 + i);
    if (!v5)
      continue;
    v6 = objc_msgSend(*(id *)((char *)&v8 + i), "layoutSpaceType");
    if (v6 == 3)
    {
      if (TSTLayoutGetFrozenHeaderRowsFloating(a1))
        goto LABEL_13;
    }
    else
    {
      if (v6 == 2)
      {
        if ((TSTLayoutGetFrozenHeaderColumnsFloating(a1) & 1) == 0)
          continue;
LABEL_13:
        objc_msgSend(v3, "addObject:", v5);
        continue;
      }
      if (v6 != 1
        || TSTLayoutGetFrozenHeaderColumnsFloating(a1)
        && (TSTLayoutGetFrozenHeaderRowsFloating(a1) & 1) != 0)
      {
        goto LABEL_13;
      }
    }
  }
  return v3;
}

uint64_t TSTLayoutGetCellIDHitByCanvasPoint(TSTLayout *a1, CGFloat a2, double a3)
{
  TSTLayout *v3;
  void *VisibleLayoutSpaces;
  uint64_t v5;
  uint64_t v6;
  double v7;
  double v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t GridRange;
  unsigned int v16;
  unsigned int v17;
  BOOL v18;
  BOOL v19;
  BOOL v20;
  BOOL v21;
  int v23;
  int v24;
  float64x2_t v25;
  float64x2_t v26;
  float64x2_t v27;
  int v28;
  uint64_t v29;
  CGAffineTransform *v30;
  unint64_t v31;
  unint64_t v32;
  int v35;
  int v36;
  float64x2_t v38;
  uint64_t v39;
  uint64_t v43;
  _BOOL4 v44;
  double *v45;
  double v46;
  double v47;
  uint64_t GridPointHitByCanvasPoint;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  double Frame;
  double v53;
  double v54;
  double v55;
  double v56;
  CGFloat v57;
  double v58;
  CGFloat v59;
  double v60;
  CGFloat v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double CanvasRectForLayoutRect;
  double v67;
  CGFloat v68;
  double v69;
  CGFloat v70;
  double v71;
  CGFloat v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  CGFloat MaxX;
  unsigned int v77;
  CGFloat MinX;
  CGFloat MaxY;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CGFloat v87;
  unsigned int v88;
  unsigned int v89;
  BOOL v94;
  uint64_t v95;
  int v96;
  int v97;
  double rect;
  float64x2_t rect_8;
  TSTLayout *rect_24;
  uint64_t v101;
  int v103;
  int v104;
  int v105;
  float64x2_t v107;
  double v108;
  float64x2_t v109;
  CGAffineTransform v110;
  _BYTE v111[48];
  _BYTE v112[48];
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  CGAffineTransform v117;
  CGAffineTransform v118;
  _BYTE v119[128];
  uint64_t v120;
  CGPoint v121;
  CGRect v122;
  CGRect v123;
  CGRect v124;
  CGRect v125;
  CGRect v126;
  CGRect v127;
  CGRect v128;
  CGRect v129;

  v3 = a1;
  v120 = *MEMORY[0x24BDAC8D0];
  v101 = -[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space");
  VisibleLayoutSpaces = TSTLayoutGetVisibleLayoutSpaces(v3);
  if (v3->mTableNameVisible
    && !-[TSTMasterLayout isDynamicallyRepressingFrozenHeaders](-[TSTLayout masterLayout](v3, "masterLayout"), "isDynamicallyRepressingFrozenHeaders"))
  {
    if (TSTLayoutGetFrozenHeaderRowsEnabled(v3))
    {
      if (TSTLayoutGetFrozenHeaderRowsFloating(v3))
      {
        v5 = -[TSTLayoutSpaceBundle frozenHeaderRowsSpace](-[TSTLayout spaceBundle](v3, "spaceBundle"), "frozenHeaderRowsSpace");
        if (v5)
        {
          v6 = v5;
          memset(&v118, 0, sizeof(v118));
          TSTLayoutGetFrozenHeaderRowsTransformToLayout(v3, (uint64_t)&v118);
          TSTLayoutGetCanvasFrameForFrozenTableName(v3);
          v8 = v7;
          v122.origin.x = TSTLayoutSpaceGetCanvasFrame(v6);
          v117 = v118;
          v123 = CGRectApplyAffineTransform(v122, &v117);
          if (a3 < CGRectGetMinY(v123) && a3 > v8)
            return 0xFFFFFFLL;
        }
      }
    }
  }
  v115 = 0u;
  v116 = 0u;
  v113 = 0u;
  v114 = 0u;
  v10 = objc_msgSend(VisibleLayoutSpaces, "countByEnumeratingWithState:objects:count:", &v113, v119, 16);
  if (!v10)
  {
    LOWORD(v103) = -1;
    LOBYTE(v104) = -1;
    return (unsigned __int16)v103 | (v104 << 16);
  }
  v11 = v10;
  v12 = *(_QWORD *)v114;
  rect_8 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a2, 0);
  v103 = -1;
  v104 = -1;
  rect_24 = v3;
  while (2)
  {
    v13 = 0;
    do
    {
      if (*(_QWORD *)v114 != v12)
        objc_enumerationMutation(VisibleLayoutSpaces);
      v14 = *(void **)(*((_QWORD *)&v113 + 1) + 8 * v13);
      if (!v14)
        goto LABEL_32;
      GridRange = TSTLayoutSpaceGetGridRange(*(_QWORD *)(*((_QWORD *)&v113 + 1) + 8 * v13));
      v18 = (_DWORD)GridRange == -1 || v16 == -1;
      v19 = v18 || GridRange > v16;
      v20 = v19 || HIDWORD(GridRange) == -1;
      v21 = v20 || v17 == -1;
      if (v21 || HIDWORD(GridRange) > v17)
        goto LABEL_32;
      v23 = objc_msgSend(v14, "layoutSpaceType");
      if (v23)
      {
        v24 = v23;
        v25 = *(float64x2_t *)MEMORY[0x24BDBD8B8];
        v26 = *(float64x2_t *)(MEMORY[0x24BDBD8B8] + 16);
        v27 = *(float64x2_t *)(MEMORY[0x24BDBD8B8] + 32);
        v28 = 1;
        v29 = (uint64_t)v14;
        switch(v23)
        {
          case 1:
            TSTLayoutGetFrozenHeaderCornerTransformToLayout(v3, (uint64_t)v112);
            v30 = (CGAffineTransform *)v112;
            goto LABEL_55;
          case 2:
            TSTLayoutGetFrozenHeaderColumnsTransformToLayout(v3, (uint64_t)v111);
            v30 = (CGAffineTransform *)v111;
            goto LABEL_55;
          case 3:
            TSTLayoutGetFrozenHeaderRowsTransformToLayout(v3, (uint64_t)&v110);
            v30 = &v110;
LABEL_55:
            CGAffineTransformInvert(&v118, v30);
            v25 = *(float64x2_t *)&v118.a;
            v26 = *(float64x2_t *)&v118.c;
            v28 = 1;
            v29 = v101;
            v27 = *(float64x2_t *)&v118.tx;
            break;
          case 5:
          case 6:
            break;
          default:
            v28 = 0;
            v29 = (uint64_t)v14;
            break;
        }
        v38 = vaddq_f64(v27, vmlaq_f64(vmulq_n_f64(v26, a3), rect_8, v25));
        v105 = v28;
        if (v3->mTabsVisible)
        {
          if (v24 == 3)
          {
            v107 = v38;
            TSTLayoutGetRowTabsCanvasFrameAndAdjustment((void *)objc_msgSend(v14, "layout"), 0);
            v43 = 0;
          }
          else
          {
            if (v24 != 2)
              goto LABEL_65;
            v107 = v38;
            TSTLayoutGetColumnTabsCanvasFrameAndAdjustment((void *)objc_msgSend(v14, "layout"), 0);
            v43 = 1;
          }
          v121.x = a2;
          v121.y = a3;
          v44 = CGRectContainsPoint(*(CGRect *)&v39, v121);
          v45 = (double *)((unint64_t)&v109 | (8 * v43));
          v109 = v107;
          v46 = *v45;
          if (v44)
            v46 = -31.0;
          *v45 = v46;
          v38 = v109;
        }
LABEL_65:
        v47 = v38.f64[1];
        v108 = v38.f64[0];
        GridPointHitByCanvasPoint = TSTLayoutSpaceGetGridPointHitByCanvasPoint(v29, 0, v38.f64[0], v38.f64[1]);
        v49 = TSTLayoutSpaceGetGridRange((uint64_t)v14);
        v51 = v50;
        if (v24 == 4)
        {
          Frame = TSTLayoutSpaceGetFrame(v101);
          rect = TSTLayoutSpaceGetCanvasRectForLayoutRect(v101, Frame, v53, v54, v55);
          v57 = v56;
          v59 = v58;
          v61 = v60;
          v62 = TSTLayoutSpaceGetFrame((uint64_t)v14);
          CanvasRectForLayoutRect = TSTLayoutSpaceGetCanvasRectForLayoutRect((uint64_t)v14, v62, v63, v64, v65);
          v68 = v67;
          v70 = v69;
          v72 = v71;
          v73 = TSTLayoutSpaceGetGridRange((uint64_t)v14);
          v75 = v74;
          v124.origin.x = CanvasRectForLayoutRect;
          v124.origin.y = v68;
          v124.size.width = v70;
          v124.size.height = v72;
          MaxX = CGRectGetMaxX(v124);
          v77 = HIDWORD(GridPointHitByCanvasPoint);
          if (v108 <= MaxX)
          {
            v125.origin.x = CanvasRectForLayoutRect;
            v125.origin.y = v68;
            v125.size.width = v70;
            v125.size.height = v72;
            if (v108 >= CGRectGetMinX(v125)
              || (v126.origin.x = rect,
                  v126.origin.y = v57,
                  v126.size.width = v59,
                  v126.size.height = v61,
                  MinX = CGRectGetMinX(v126),
                  v77 = HIDWORD(GridPointHitByCanvasPoint),
                  v108 <= MinX))
            {
              v127.origin.x = CanvasRectForLayoutRect;
              v127.origin.y = v68;
              v127.size.width = v70;
              v127.size.height = v72;
              MaxY = CGRectGetMaxY(v127);
              v77 = HIDWORD(GridPointHitByCanvasPoint);
              if (v47 <= MaxY)
              {
                if ((_DWORD)GridPointHitByCanvasPoint == -1
                  && HIDWORD(GridPointHitByCanvasPoint) != -1
                  && HIDWORD(v73) <= HIDWORD(GridPointHitByCanvasPoint))
                {
                  if (HIDWORD(v75) < HIDWORD(GridPointHitByCanvasPoint))
                  {
                    if (v105)
                      v89 = 0;
                    else
                      v89 = GridPointHitByCanvasPoint;
                    v77 = HIDWORD(GridPointHitByCanvasPoint);
                    goto LABEL_98;
                  }
                  v88 = 0;
                  v89 = 0;
                  v77 = HIDWORD(GridPointHitByCanvasPoint);
                  if ((v105 & 1) == 0)
                    goto LABEL_98;
LABEL_93:
                  if (v77 == -1)
                    v77 = 0;
                  v89 = v88;
LABEL_98:
                  v94 = v89 == -1
                     || v49 > v89
                     || v51 < v89
                     || v77 == -1
                     || v77 < HIDWORD(v49)
                     || v77 > HIDWORD(v51);
                  v3 = rect_24;
                  if (!v94)
                  {
                    if ((_DWORD)GridPointHitByCanvasPoint == -1)
                      v97 = 16711680;
                    else
                      v97 = GridPointHitByCanvasPoint << 16;
                    return v97 & 0xFFFF0000 | WORD2(GridPointHitByCanvasPoint);
                  }
                  goto LABEL_32;
                }
                v77 = (v75 >= GridPointHitByCanvasPoint) - 1;
                if ((_DWORD)GridPointHitByCanvasPoint == -1
                  || v73 > GridPointHitByCanvasPoint)
                {
                  v77 = -1;
                }
                if (HIDWORD(GridPointHitByCanvasPoint) != -1)
                  v77 = HIDWORD(GridPointHitByCanvasPoint);
              }
            }
          }
        }
        else
        {
          v77 = HIDWORD(GridPointHitByCanvasPoint);
          if ((v24 - 5) <= 1)
          {
            v128.origin.x = TSTLayoutSpaceGetCanvasFrame((uint64_t)v14);
            x = v128.origin.x;
            y = v128.origin.y;
            width = v128.size.width;
            height = v128.size.height;
            if (v108 > CGRectGetMaxX(v128)
              || (v129.origin.x = x,
                  v129.origin.y = y,
                  v129.size.width = width,
                  v129.size.height = height,
                  v87 = CGRectGetMaxY(v129),
                  v77 = HIDWORD(GridPointHitByCanvasPoint),
                  v47 > v87))
            {
              v3 = rect_24;
              goto LABEL_32;
            }
          }
        }
        if ((v105 & 1) == 0)
        {
          v89 = GridPointHitByCanvasPoint;
          goto LABEL_98;
        }
        if ((_DWORD)GridPointHitByCanvasPoint == -1)
        {
          v89 = 0;
          goto LABEL_98;
        }
        v88 = GridPointHitByCanvasPoint;
        goto LABEL_93;
      }
      v31 = TSTLayoutSpaceGetGridPointHitByCanvasPoint((uint64_t)v14, v3->mTabsVisible, a2, a3);
      v32 = HIDWORD(v31);
      if (v31 > 0xFFFFFFFEFFFFFFFFLL || v31 == 0xFFFFFFFFLL)
      {
        if (v31 == 0xFFFFFFFFLL)
          v96 = 16711680;
        else
          v96 = v31 << 16;
        return v96 & 0xFFFF0000 | (unsigned __int16)v32;
      }
      if ((_DWORD)v31 != -1 && v104 == -1)
        v35 = v31;
      else
        v35 = v104;
      v36 = v103;
      if (HIDWORD(v31) != -1 && v103 == -1)
        v36 = HIDWORD(v31);
      v103 = v36;
      v104 = v35;
LABEL_32:
      ++v13;
    }
    while (v11 != v13);
    v95 = objc_msgSend(VisibleLayoutSpaces, "countByEnumeratingWithState:objects:count:", &v113, v119, 16);
    v11 = v95;
    if (v95)
      continue;
    return (unsigned __int16)v103 | (v104 << 16);
  }
}

double TSTLayoutGetCanvasFrameForFrozenTableName(TSTLayout *a1)
{
  double FrameForFrozenTableName;
  double v3;
  double v4;
  double v5;

  FrameForFrozenTableName = TSTLayoutGetFrameForFrozenTableName(a1);
  return TSTLayoutSpaceGetCanvasRectForLayoutRect((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), FrameForFrozenTableName, v3, v4, v5);
}

uint64_t TSTLayoutGetCellIDNearbyCanvasPoint(TSTLayout *a1)
{
  double v2;
  double v3;

  TSTLayoutSpaceGetCanvasFrame((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"));
  v2 = TSDClampPointInRect();
  return TSTLayoutGetCellIDHitByCanvasPoint(a1, v2, v3);
}

uint64_t TSTLayoutColumnGridlineNearCanvasPoint(TSTLayout *a1, double *a2, CGFloat a3, double a4)
{
  unsigned int CellIDHitByCanvasPoint;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t RangeForHint;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double v17;
  double v18;
  CGRect v20;
  CGRect v21;

  CellIDHitByCanvasPoint = TSTLayoutGetCellIDHitByCanvasPoint(a1, a3, a4);
  v8 = BYTE2(CellIDHitByCanvasPoint);
  if (BYTE2(CellIDHitByCanvasPoint) == 255)
  {
    if (a2)
      *a2 = 1.79769313e308;
    LOBYTE(v9) = -1;
    return v9;
  }
  v10 = CellIDHitByCanvasPoint;
  v11 = CellIDHitByCanvasPoint & 0xFF000000;
  RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)-[TSTLayout masterLayout](a1, "masterLayout"), -[TSTLayout layoutHint](a1, "layoutHint"));
  v20.origin.x = TSTLayoutGetCanvasFrameForRange(a1, v11 & 0xFFFF0000 | (v8 << 16) | (unsigned __int16)RangeForHint | 0x1000100000000);
  x = v20.origin.x;
  y = v20.origin.y;
  width = v20.size.width;
  height = v20.size.height;
  v17 = a3 - CGRectGetMinX(v20);
  v21.origin.x = x;
  v21.origin.y = y;
  v21.size.width = width;
  v21.size.height = height;
  v18 = CGRectGetMaxX(v21) - a3;
  if (-[TSTLayout layoutDirectionIsLeftToRight](a1, "layoutDirectionIsLeftToRight"))
  {
    if (v17 < v18 && v8 > BYTE2(RangeForHint))
    {
      if (a2)
        *a2 = v17;
      return TSTMasterLayoutPreviousVisibleColumn(-[TSTLayout masterLayout](a1, "masterLayout"), (BYTE2(v10) - 1));
    }
LABEL_16:
    v9 = HIWORD(v10);
    if (a2)
      *a2 = v18;
    return v9;
  }
  if (v17 >= v18 || v8 >= (BYTE4(RangeForHint) + BYTE2(RangeForHint) - 1))
    goto LABEL_16;
  if (a2)
    *a2 = v17;
  return TSTMasterLayoutNextVisibleColumn(-[TSTLayout masterLayout](a1, "masterLayout"), (BYTE2(v10) + 1));
}

double TSTLayoutGetCanvasFrameForRange(TSTLayout *a1, unint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v2 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v2 = -1;
  v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2))
    v3 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v4 = 0xFFFFFFFFLL;
  else
    v4 = (unsigned __int16)a2;
  v5 = v2 | ((unint64_t)v4 << 32);
  v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v6 = 0xFFFFFFFF00000000;
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, v5, v3 | v6, (uint64_t)&__block_literal_global_82);
}

uint64_t TSTLayoutRowGridlineNearCanvasPoint(TSTLayout *a1, double *a2, CGFloat a3, double a4)
{
  int CellIDHitByCanvasPoint;
  unsigned int v8;
  int v9;
  uint64_t RangeForHint;
  unsigned __int16 v11;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double v16;
  double v17;
  CGRect v20;
  CGRect v21;

  CellIDHitByCanvasPoint = TSTLayoutGetCellIDHitByCanvasPoint(a1, a3, a4);
  v8 = (unsigned __int16)CellIDHitByCanvasPoint;
  if ((unsigned __int16)CellIDHitByCanvasPoint == 0xFFFF)
  {
    if (a2)
      *a2 = 1.79769313e308;
    LOWORD(v9) = -1;
    return (unsigned __int16)v9;
  }
  v9 = CellIDHitByCanvasPoint;
  RangeForHint = TSTMasterLayoutGetRangeForHint((uint64_t)-[TSTLayout masterLayout](a1, "masterLayout"), -[TSTLayout layoutHint](a1, "layoutHint"));
  v11 = RangeForHint;
  v20.origin.x = TSTLayoutGetCanvasFrameForRange(a1, v9 & 0xFF00FFFF | (BYTE2(RangeForHint) << 16) | 0x1000100000000);
  x = v20.origin.x;
  y = v20.origin.y;
  width = v20.size.width;
  height = v20.size.height;
  v16 = a4 - CGRectGetMinY(v20);
  v21.origin.x = x;
  v21.origin.y = y;
  v21.size.width = width;
  v21.size.height = height;
  v17 = CGRectGetMaxY(v21) - a4;
  if (v16 >= v17 || v8 <= v11)
  {
    if (a2)
      *a2 = v17;
    return (unsigned __int16)v9;
  }
  if (a2)
    *a2 = v16;
  return TSTMasterLayoutPreviousVisibleRow(-[TSTLayout masterLayout](a1, "masterLayout"), (unsigned __int16)(v9 - 1));
}

double TSTLayoutGetCanvasFrameForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3)
{
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, a2, a3, (uint64_t)&__block_literal_global_82);
}

double TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  double v7;
  double v8;
  CGFloat v9;
  CGFloat v10;
  void *VisibleLayoutSpaces;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t i;
  _DWORD *v17;
  uint64_t v18;
  uint64_t v19;
  double x;
  double v21;
  double y;
  double v23;
  double width;
  double v25;
  double height;
  int v27;
  int v28;
  uint64_t v31;
  CGAffineTransform v32;
  CGAffineTransform v33;
  CGAffineTransform v34;
  CGAffineTransform v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  _BYTE v40[128];
  uint64_t v41;
  CGRect v42;
  CGRect v43;
  CGRect v44;
  CGRect v45;
  CGRect v46;
  CGRect v47;
  CGRect v48;
  CGRect v49;
  CGRect v50;
  CGRect v51;

  v41 = *MEMORY[0x24BDAC8D0];
  v7 = *MEMORY[0x24BDBF070];
  v8 = *(double *)(MEMORY[0x24BDBF070] + 8);
  v9 = *(double *)(MEMORY[0x24BDBF070] + 16);
  v10 = *(double *)(MEMORY[0x24BDBF070] + 24);
  VisibleLayoutSpaces = TSTLayoutGetVisibleLayoutSpaces(a1);
  v36 = 0u;
  v37 = 0u;
  v38 = 0u;
  v39 = 0u;
  v12 = objc_msgSend(VisibleLayoutSpaces, "countByEnumeratingWithState:objects:count:", &v36, v40, 16);
  if (!v12)
    return v7;
  v13 = v12;
  v31 = 0;
  v14 = HIDWORD(a2);
  v15 = *(_QWORD *)v37;
  do
  {
    for (i = 0; i != v13; ++i)
    {
      if (*(_QWORD *)v37 != v15)
        objc_enumerationMutation(VisibleLayoutSpaces);
      v17 = *(_DWORD **)(*((_QWORD *)&v36 + 1) + 8 * i);
      if (TSTLayoutSpaceIntersectsGridRange(v17, a2 | (v14 << 32), a3))
      {
        v18 = TSTLayoutSpaceIntersectionGridRange(v17, a2 | (v14 << 32), a3);
        x = (*(double (**)(uint64_t, _DWORD *, uint64_t, uint64_t))(a4 + 16))(a4, v17, v18, v19);
        y = v21;
        width = v23;
        height = v25;
        switch(objc_msgSend(v17, "layoutSpaceType"))
        {
          case 0u:
            goto LABEL_12;
          case 1u:
            memset(&v35, 0, sizeof(v35));
            TSTLayoutGetFrozenHeaderCornerTransformToLayout(a1, (uint64_t)&v35);
            v32 = v35;
            v42.origin.x = x;
            v42.origin.y = y;
            v42.size.width = width;
            v42.size.height = height;
            v43 = CGRectApplyAffineTransform(v42, &v32);
            x = v43.origin.x;
            y = v43.origin.y;
            width = v43.size.width;
            height = v43.size.height;
            v31 = 0x100000001;
            goto LABEL_12;
          case 2u:
            memset(&v35, 0, sizeof(v35));
            TSTLayoutGetFrozenHeaderColumnsTransformToLayout(a1, (uint64_t)&v35);
            v34 = v35;
            v44.origin.x = x;
            v44.origin.y = y;
            v44.size.width = width;
            v44.size.height = height;
            v45 = CGRectApplyAffineTransform(v44, &v34);
            x = v45.origin.x;
            y = v45.origin.y;
            width = v45.size.width;
            height = v45.size.height;
            TSTLayoutSpaceGetGridRange((uint64_t)v17);
            LODWORD(a2) = v27 + 1;
            BYTE4(v31) = 1;
            goto LABEL_12;
          case 3u:
            memset(&v35, 0, sizeof(v35));
            TSTLayoutGetFrozenHeaderRowsTransformToLayout(a1, (uint64_t)&v35);
            v33 = v35;
            v46.origin.x = x;
            v46.origin.y = y;
            v46.size.width = width;
            v46.size.height = height;
            v47 = CGRectApplyAffineTransform(v46, &v33);
            x = v47.origin.x;
            y = v47.origin.y;
            width = v47.size.width;
            height = v47.size.height;
            TSTLayoutSpaceGetGridRange((uint64_t)v17);
            v14 = (v28 + 1);
            LOBYTE(v31) = 1;
            goto LABEL_12;
          default:
            if ((TSTLayoutSpaceContainsGridRange(v17, a2 | (v14 << 32), a3) & 1) != 0)
              return x;
LABEL_12:
            v48.origin.x = v7;
            v48.origin.y = v8;
            v48.size.width = v9;
            v48.size.height = v10;
            if (CGRectIsNull(v48))
            {
              v7 = x;
              v8 = y;
              v9 = width;
              v10 = height;
            }
            else
            {
              if ((BYTE4(v31) & (x < v7)) == 1)
              {
                width = width - (v7 - x);
                if (width >= 0.0)
                {
                  x = x + v7 - x;
                }
                else
                {
                  x = *MEMORY[0x24BDBF070];
                  y = *(double *)(MEMORY[0x24BDBF070] + 8);
                  width = *(double *)(MEMORY[0x24BDBF070] + 16);
                  height = *(double *)(MEMORY[0x24BDBF070] + 24);
                }
              }
              if ((v31 & (y < v8)) == 1)
              {
                height = height - (v8 - y);
                if (height >= 0.0)
                {
                  y = y + v8 - y;
                }
                else
                {
                  x = *MEMORY[0x24BDBF070];
                  y = *(double *)(MEMORY[0x24BDBF070] + 8);
                  width = *(double *)(MEMORY[0x24BDBF070] + 16);
                  height = *(double *)(MEMORY[0x24BDBF070] + 24);
                }
              }
              v49.origin.x = v7;
              v49.origin.y = v8;
              v49.size.width = v9;
              v49.size.height = v10;
              v51.origin.x = x;
              v51.origin.y = y;
              v51.size.width = width;
              v51.size.height = height;
              v50 = CGRectUnion(v49, v51);
              v7 = v50.origin.x;
              v8 = v50.origin.y;
              v9 = v50.size.width;
              v10 = v50.size.height;
            }
            break;
        }
      }
    }
    v13 = objc_msgSend(VisibleLayoutSpaces, "countByEnumeratingWithState:objects:count:", &v36, v40, 16);
    x = v7;
  }
  while (v13);
  return x;
}

double TSTLayoutGetFrameForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3)
{
  double ArbitraryRectAcrossSpacesForGridRange;
  double v5;
  double v6;
  double v7;

  ArbitraryRectAcrossSpacesForGridRange = TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, a2, a3, (uint64_t)&__block_literal_global_82);
  return TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), ArbitraryRectAcrossSpacesForGridRange, v5, v6, v7);
}

double TSTLayoutGetFrameForRange(TSTLayout *a1, unint64_t a2)
{
  double CanvasFrameForRange;
  double v4;
  double v5;
  double v6;

  CanvasFrameForRange = TSTLayoutGetCanvasFrameForRange(a1, a2);
  return TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), CanvasFrameForRange, v4, v5, v6);
}

double TSTLayoutGetBoundsForCellRange(TSTLayout *a1, unint64_t a2)
{
  __int16 v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  BOOL v15;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v4 = ~(_WORD)a2;
  v5 = -[TSTTableModel range](-[TSTLayout tableModel](a1, "tableModel"), "range");
  v6 = 0;
  v7 = 16711680;
  v8 = 0xFFFFLL;
  if (!v4)
    goto LABEL_23;
  v9 = 0;
  if ((a2 & 0xFF0000) == 0xFF0000)
    goto LABEL_24;
  v6 = 0;
  v7 = 16711680;
  v8 = 0xFFFFLL;
  if (!HIWORD(a2))
    goto LABEL_23;
  v9 = 0;
  if ((a2 & 0xFFFF00000000) == 0)
    goto LABEL_24;
  v6 = 0;
  v7 = 16711680;
  v8 = 0xFFFFLL;
  if ((_WORD)v5 == 0xFFFF)
    goto LABEL_23;
  v9 = 0;
  if ((v5 & 0xFF0000) == 0xFF0000)
    goto LABEL_24;
  v6 = 0;
  v7 = 16711680;
  v8 = 0xFFFFLL;
  if (!HIWORD(v5))
  {
LABEL_23:
    v9 = 0;
    goto LABEL_24;
  }
  v9 = 0;
  if ((v5 & 0xFFFF00000000) != 0)
  {
    v8 = 0;
    if (BYTE2(a2) <= BYTE2(v5))
      v10 = BYTE2(v5);
    else
      v10 = BYTE2(a2);
    if ((unsigned __int16)a2 <= (unsigned __int16)v5)
      v11 = (unsigned __int16)v5;
    else
      v11 = (unsigned __int16)a2;
    if ((BYTE4(a2) + BYTE2(a2) - 1) >= (BYTE4(v5) + BYTE2(v5) - 1))
      v12 = (BYTE4(v5) + BYTE2(v5) - 1);
    else
      v12 = (BYTE4(a2) + BYTE2(a2) - 1);
    v13 = (unsigned __int16)(v5 + HIWORD(v5) - 1);
    if ((unsigned __int16)(a2 + HIWORD(a2) - 1) < v13)
      v13 = (unsigned __int16)(a2 + HIWORD(a2) - 1);
    v7 = 0;
    v6 = 0;
    v9 = 0;
    if (v11 <= v13 && v10 <= v12)
    {
      v9 = ((unint64_t)(v13 - v11) << 48) + 0x1000000000000;
      v6 = (unint64_t)(unsigned __int16)(v12 - v10 + 1) << 32;
      v7 = v10 << 16;
      v8 = v11;
    }
  }
LABEL_24:
  v14 = v7 | v9 | v8 | v6;
  if ((_WORD)v14 == 0xFFFF)
    return *MEMORY[0x24BDBF090];
  v15 = (v14 & 0xFF0000) == 0xFF0000 || HIWORD(v14) == 0;
  if (v15 || (v14 & 0xFFFF00000000) == 0)
    return *MEMORY[0x24BDBF090];
  if (BYTE2(v14) == 255)
    v18 = -1;
  else
    v18 = BYTE2(v14);
  v19 = WORD2(v14) + v18 - 1;
  if (!WORD2(v14))
    v19 = 0xFFFFFFFFLL;
  v20 = (unsigned __int16)v14;
  v21 = v18 | ((unint64_t)(unsigned __int16)v14 << 32);
  v22 = (v14 >> 16) & 0xFFFF00000000;
  v15 = v22 == 0;
  v23 = v22 + (v20 << 32) - 0x100000000;
  if (v15)
    v23 = 0xFFFFFFFF00000000;
  return TSTLayoutGetFrameForGridRange(a1, v21, v19 | v23);
}

double TSTLayoutGetScrollBoundsForCellRange(TSTLayout *a1, unint64_t a2)
{
  double x;
  double y;
  CGFloat width;
  double height;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  unint64_t v18;
  double Frame;
  double v20;
  CGFloat v21;
  double v22;
  CGFloat v23;
  double v24;
  CGFloat v25;
  double v26;
  double MaxY;
  double v28;
  double v29;
  unint64_t v30;
  double v31;
  double v32;
  CGFloat v33;
  double v34;
  CGFloat v35;
  double v36;
  CGFloat v37;
  double v38;
  double MaxX;
  BOOL v40;
  double v41;
  double v43;
  double v44;
  CGAffineTransform v45;
  CGAffineTransform v46;
  CGAffineTransform v47;
  CGRect v48;
  CGRect v49;
  CGRect v50;
  CGRect v51;
  CGRect v52;
  CGRect v53;
  CGRect v54;

  v48.origin.x = TSTLayoutGetBoundsForCellRange(a1, a2);
  x = v48.origin.x;
  y = v48.origin.y;
  width = v48.size.width;
  height = v48.size.height;
  if (!CGRectIsEmpty(v48))
  {
    v8 = -[TSTLayoutSpaceBundle frozenHeaderRowsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderRowsSpace");
    v9 = -[TSTLayoutSpaceBundle frozenHeaderColumnsSpace](-[TSTLayout spaceBundle](a1, "spaceBundle"), "frozenHeaderColumnsSpace");
    if (v8 | v9)
    {
      v10 = v9;
      TSTLayoutGetTopLeftTabCanvasFrame((double *)a1);
      TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), v11, v12, v13, v14);
      v44 = v16;
      if (v8)
      {
        v17 = v15;
        v18 = TSTLayoutSpaceIntersectionCellRange(v8, a2);
        if ((_WORD)v18 == 0xFFFF || (v18 & 0xFF0000) == 0xFF0000 || !HIWORD(v18) || (v18 & 0xFFFF00000000) == 0)
        {
          v43 = v17;
          Frame = TSTLayoutSpaceGetFrame(v8);
          v21 = v20;
          v23 = v22;
          v25 = v24;
          memset(&v47, 0, sizeof(v47));
          TSTLayoutGetFrozenHeaderRowsTransformToLayout(a1, (uint64_t)&v47);
          v46 = v47;
          v49.origin.x = Frame;
          v49.origin.y = v21;
          v49.size.width = v23;
          v49.size.height = v25;
          v50 = CGRectApplyAffineTransform(v49, &v46);
          v26 = v50.size.height;
          MaxY = CGRectGetMaxY(v50);
          v51.origin.x = x;
          v51.origin.y = y;
          v51.size.width = width;
          v51.size.height = height;
          if (MaxY > CGRectGetMinY(v51))
          {
            TSTLayoutGetTableNameHeight((uint64_t)a1);
            v29 = v43 + v26 + v28;
            y = y - v29;
            height = height + v29;
          }
        }
      }
      if (v10)
      {
        v30 = TSTLayoutSpaceIntersectionCellRange(v10, a2);
        if ((_WORD)v30 == 0xFFFF || (v30 & 0xFF0000) == 0xFF0000 || !HIWORD(v30) || (v30 & 0xFFFF00000000) == 0)
        {
          v31 = TSTLayoutSpaceGetFrame(v10);
          v33 = v32;
          v35 = v34;
          v37 = v36;
          memset(&v47, 0, sizeof(v47));
          TSTLayoutGetFrozenHeaderColumnsTransformToLayout(a1, (uint64_t)&v47);
          v45 = v47;
          v52.origin.x = v31;
          v52.origin.y = v33;
          v52.size.width = v35;
          v52.size.height = v37;
          v53 = CGRectApplyAffineTransform(v52, &v45);
          v38 = v53.size.width;
          MaxX = CGRectGetMaxX(v53);
          v54.origin.x = x;
          v54.origin.y = y;
          v54.size.width = width;
          v54.size.height = height;
          v40 = MaxX <= CGRectGetMinX(v54);
          v41 = 0.0;
          if (!v40)
            v41 = v44 + v38;
          return x - v41;
        }
      }
    }
  }
  return x;
}

double TSTLayoutGetCanvasStrokeFrameForGridRange(TSTLayout *a1, uint64_t a2, uint64_t a3)
{
  double x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  void *VisibleLayoutSpaces;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  _DWORD *v14;
  unint64_t v15;
  unint64_t v16;
  double CanvasStrokeFrameForGridRange;
  double v18;
  CGFloat v19;
  double v20;
  CGFloat v21;
  double v22;
  CGFloat v23;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _BYTE v29[128];
  uint64_t v30;
  CGRect v31;
  CGRect v32;
  CGRect v33;
  CGRect v34;

  v30 = *MEMORY[0x24BDAC8D0];
  x = *MEMORY[0x24BDBF070];
  y = *(double *)(MEMORY[0x24BDBF070] + 8);
  width = *(double *)(MEMORY[0x24BDBF070] + 16);
  height = *(double *)(MEMORY[0x24BDBF070] + 24);
  VisibleLayoutSpaces = TSTLayoutGetVisibleLayoutSpaces(a1);
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v10 = objc_msgSend(VisibleLayoutSpaces, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
  if (v10)
  {
    v11 = v10;
    v12 = *(_QWORD *)v26;
    while (2)
    {
      for (i = 0; i != v11; ++i)
      {
        if (*(_QWORD *)v26 != v12)
          objc_enumerationMutation(VisibleLayoutSpaces);
        v14 = *(_DWORD **)(*((_QWORD *)&v25 + 1) + 8 * i);
        if (TSTLayoutSpaceIntersectsGridRange(v14, a2, a3))
        {
          v15 = TSTLayoutSpaceIntersectionGridRange(v14, a2, a3);
          CanvasStrokeFrameForGridRange = TSTLayoutSpaceGetCanvasStrokeFrameForGridRange((uint64_t)v14, v15, v16);
          v19 = v18;
          v21 = v20;
          v23 = v22;
          if ((TSTLayoutSpaceContainsGridRange(v14, a2, a3) & 1) != 0)
            return CanvasStrokeFrameForGridRange;
          v31.origin.x = x;
          v31.origin.y = y;
          v31.size.width = width;
          v31.size.height = height;
          if (CGRectIsNull(v31))
          {
            x = CanvasStrokeFrameForGridRange;
            y = v19;
            width = v21;
            height = v23;
          }
          else
          {
            v32.origin.x = x;
            v32.origin.y = y;
            v32.size.width = width;
            v32.size.height = height;
            v34.origin.x = CanvasStrokeFrameForGridRange;
            v34.origin.y = v19;
            v34.size.width = v21;
            v34.size.height = v23;
            v33 = CGRectUnion(v32, v34);
            x = v33.origin.x;
            y = v33.origin.y;
            width = v33.size.width;
            height = v33.size.height;
          }
        }
      }
      v11 = objc_msgSend(VisibleLayoutSpaces, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
      if (v11)
        continue;
      break;
    }
  }
  return x;
}

double TSTLayoutGetStrokeFrameForGridRange(TSTLayout *a1, uint64_t a2, uint64_t a3)
{
  double CanvasStrokeFrameForGridRange;
  double v5;
  double v6;
  double v7;

  CanvasStrokeFrameForGridRange = TSTLayoutGetCanvasStrokeFrameForGridRange(a1, a2, a3);
  return TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), CanvasStrokeFrameForGridRange, v5, v6, v7);
}

double TSTLayoutGetCanvasStrokeFrameForRange(TSTLayout *a1, unint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v2 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v2 = -1;
  v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2))
    v3 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v4 = 0xFFFFFFFFLL;
  else
    v4 = (unsigned __int16)a2;
  v5 = v2 | ((unint64_t)v4 << 32);
  v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v6 = 0xFFFFFFFF00000000;
  return TSTLayoutGetCanvasStrokeFrameForGridRange(a1, v5, v3 | v6);
}

double TSTLayoutGetStrokeFrameForRange(TSTLayout *a1, unint64_t a2)
{
  double CanvasStrokeFrameForRange;
  double v4;
  double v5;
  double v6;

  CanvasStrokeFrameForRange = TSTLayoutGetCanvasStrokeFrameForRange(a1, a2);
  return TSTLayoutSpaceGetLayoutRectForCanvasRect((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), CanvasStrokeFrameForRange, v4, v5, v6);
}

double TSTLayoutGetContentFrameForRange(TSTLayout *a1, unint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v2 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v2 = -1;
  v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2))
    v3 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v4 = 0xFFFFFFFFLL;
  else
    v4 = (unsigned __int16)a2;
  v5 = v2 | ((unint64_t)v4 << 32);
  v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v6 = 0xFFFFFFFF00000000;
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, v5, v3 | v6, (uint64_t)&__block_literal_global_65_0);
}

double TSTLayoutGetContentFrameForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3)
{
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, a2, a3, (uint64_t)&__block_literal_global_65_0);
}

double TSTLayoutGetAlignedOverrideFrameForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3, double a4)
{
  _QWORD v5[5];

  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 3221225472;
  v5[2] = __TSTLayoutGetAlignedOverrideFrameForGridRange_block_invoke;
  v5[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__32__0__TSTLayoutSpace_8______II____II__16l;
  *(double *)&v5[4] = a4;
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, a2, a3, (uint64_t)v5);
}

double TSTLayoutGetAlignedStrokeFrameForRange(TSTLayout *a1, unint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v2 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v2 = -1;
  v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2))
    v3 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v4 = 0xFFFFFFFFLL;
  else
    v4 = (unsigned __int16)a2;
  v5 = v2 | ((unint64_t)v4 << 32);
  v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v6 = 0xFFFFFFFF00000000;
  return TSTLayoutGetAlignedStrokeFrameForGridRange(a1, v5, v3 | v6, 0);
}

double TSTLayoutGetAlignedStrokeFrameForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3, int a4)
{
  double v7;
  double v8;
  CGFloat v9;
  CGFloat v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t i;
  TSTLayoutSpace *v17;
  unint64_t v18;
  unint64_t v19;
  double AlignedStrokeLineForColumnGridRange;
  double v21;
  double v22;
  double v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  double x;
  double y;
  double width;
  double height;
  int v32;
  int v33;
  int v34;
  char v37;
  id obj;
  CGAffineTransform v39;
  CGAffineTransform v40;
  CGAffineTransform v41;
  CGAffineTransform v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  _BYTE v47[128];
  uint64_t v48;
  CGRect v49;
  CGRect v50;
  CGRect v51;
  CGRect v52;
  CGRect v53;
  CGRect v54;
  CGRect v55;
  CGRect v56;
  CGRect v57;
  CGRect v58;

  v48 = *MEMORY[0x24BDAC8D0];
  v7 = *MEMORY[0x24BDBF070];
  v8 = *(double *)(MEMORY[0x24BDBF070] + 8);
  v9 = *(double *)(MEMORY[0x24BDBF070] + 16);
  v10 = *(double *)(MEMORY[0x24BDBF070] + 24);
  v43 = 0u;
  v44 = 0u;
  v45 = 0u;
  v46 = 0u;
  obj = TSTLayoutGetVisibleLayoutSpaces(a1);
  v11 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v43, v47, 16);
  if (v11)
  {
    v12 = v11;
    v37 = 0;
    v13 = 0;
    v14 = HIDWORD(a2);
    v15 = *(_QWORD *)v44;
    while (1)
    {
      for (i = 0; i != v12; ++i)
      {
        if (*(_QWORD *)v44 != v15)
          objc_enumerationMutation(obj);
        v17 = *(TSTLayoutSpace **)(*((_QWORD *)&v43 + 1) + 8 * i);
        if (a4 == 2)
        {
          if (!TSTLayoutSpaceIntersectsColumnGridRange(*(_DWORD **)(*((_QWORD *)&v43 + 1) + 8 * i), a2 | (v14 << 32), a3))continue;
          v24 = TSTLayoutSpaceIntersectionColumnGridRange(v17, a2 | (v14 << 32), a3);
          AlignedStrokeLineForColumnGridRange = TSTLayoutSpaceGetAlignedStrokeLineForColumnGridRange(v17, v24, v25);
        }
        else if (a4 == 1)
        {
          if (!TSTLayoutSpaceIntersectsRowGridRange(*(_QWORD *)(*((_QWORD *)&v43 + 1) + 8 * i), a2 | (v14 << 32), a3))continue;
          v18 = TSTLayoutSpaceIntersectionRowGridRange((uint64_t)v17, a2 | (v14 << 32), a3);
          AlignedStrokeLineForColumnGridRange = TSTLayoutSpaceGetAlignedStrokeLineForRowGridRange(v17, v18, v19);
        }
        else
        {
          if (!TSTLayoutSpaceIntersectsGridRange(*(_DWORD **)(*((_QWORD *)&v43 + 1) + 8 * i), a2 | (v14 << 32), a3))continue;
          v26 = TSTLayoutSpaceIntersectionGridRange(v17, a2 | (v14 << 32), a3);
          AlignedStrokeLineForColumnGridRange = TSTLayoutSpaceGetAlignedStrokeFrameForGridRange(v17, v26, v27);
        }
        x = AlignedStrokeLineForColumnGridRange;
        y = v21;
        width = v22;
        height = v23;
        v32 = -[TSTLayoutSpace layoutSpaceType](v17, "layoutSpaceType");
        if (v32 == 1)
        {
          memset(&v42, 0, sizeof(v42));
          TSTLayoutGetFrozenHeaderCornerTransformToLayout(a1, (uint64_t)&v42);
          v39 = v42;
          v51.origin.x = x;
          v51.origin.y = y;
          v51.size.width = width;
          v51.size.height = height;
          v52 = CGRectApplyAffineTransform(v51, &v39);
          x = v52.origin.x;
          y = v52.origin.y;
          width = v52.size.width;
          height = v52.size.height;
          v37 = 1;
        }
        else
        {
          if (v32 != 3)
          {
            if (v32 == 2)
            {
              memset(&v42, 0, sizeof(v42));
              TSTLayoutGetFrozenHeaderColumnsTransformToLayout(a1, (uint64_t)&v42);
              v41 = v42;
              v49.origin.x = x;
              v49.origin.y = y;
              v49.size.width = width;
              v49.size.height = height;
              v50 = CGRectApplyAffineTransform(v49, &v41);
              x = v50.origin.x;
              y = v50.origin.y;
              width = v50.size.width;
              height = v50.size.height;
              TSTLayoutSpaceGetGridRange((uint64_t)v17);
              LODWORD(a2) = v33 + 1;
              v37 = 1;
            }
            else if (-[TSTLayoutSpace isRepeat](v17, "isRepeat")
                   && (TSTLayoutSpaceContainsGridRange(v17, a2 | (v14 << 32), a3) & 1) != 0)
            {
              return x;
            }
            goto LABEL_21;
          }
          memset(&v42, 0, sizeof(v42));
          TSTLayoutGetFrozenHeaderRowsTransformToLayout(a1, (uint64_t)&v42);
          v40 = v42;
          v53.origin.x = x;
          v53.origin.y = y;
          v53.size.width = width;
          v53.size.height = height;
          v54 = CGRectApplyAffineTransform(v53, &v40);
          x = v54.origin.x;
          y = v54.origin.y;
          width = v54.size.width;
          height = v54.size.height;
          TSTLayoutSpaceGetGridRange((uint64_t)v17);
          v14 = (v34 + 1);
        }
        v13 = 1;
LABEL_21:
        v55.origin.x = v7;
        v55.origin.y = v8;
        v55.size.width = v9;
        v55.size.height = v10;
        if (CGRectIsNull(v55))
        {
          v7 = x;
          v8 = y;
          v9 = width;
          v10 = height;
        }
        else
        {
          if ((v37 & (x < v7)) == 1)
          {
            width = width - (v7 - x);
            if (width >= 0.0)
            {
              x = x + v7 - x;
            }
            else
            {
              x = *MEMORY[0x24BDBF070];
              y = *(double *)(MEMORY[0x24BDBF070] + 8);
              width = *(double *)(MEMORY[0x24BDBF070] + 16);
              height = *(double *)(MEMORY[0x24BDBF070] + 24);
            }
          }
          if ((v13 & (y < v8)) == 1)
          {
            height = height - (v8 - y);
            if (height >= 0.0)
            {
              y = y + v8 - y;
            }
            else
            {
              x = *MEMORY[0x24BDBF070];
              y = *(double *)(MEMORY[0x24BDBF070] + 8);
              width = *(double *)(MEMORY[0x24BDBF070] + 16);
              height = *(double *)(MEMORY[0x24BDBF070] + 24);
            }
          }
          v56.origin.x = v7;
          v56.origin.y = v8;
          v56.size.width = v9;
          v56.size.height = v10;
          v58.origin.x = x;
          v58.origin.y = y;
          v58.size.width = width;
          v58.size.height = height;
          v57 = CGRectUnion(v56, v58);
          v7 = v57.origin.x;
          v8 = v57.origin.y;
          v9 = v57.size.width;
          v10 = v57.size.height;
        }
      }
      v12 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v43, v47, 16);
      x = v7;
      if (!v12)
        return x;
    }
  }
  return v7;
}

TSDBezierPath *TSTLayoutGetAlignedStrokeFramePathForRange(TSTLayout *a1, unint64_t a2, int a3, _QWORD *a4, CGFloat a5, CGFloat a6)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v6 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v6 = -1;
  v7 = WORD2(a2) + v6 - 1;
  if (!WORD2(a2))
    v7 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v8 = 0xFFFFFFFFLL;
  else
    v8 = (unsigned __int16)a2;
  v9 = v6 | ((unint64_t)v8 << 32);
  v10 = ((a2 >> 16) & 0xFFFF00000000) + (v8 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v10 = 0xFFFFFFFF00000000;
  return TSTLayoutGetAlignedStrokeFramePathForGridRange(a1, v9, v7 | v10, 0, a3, a4, a5, a6);
}

TSDBezierPath *TSTLayoutGetAlignedStrokeFramePathForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3, int a4, int a5, _QWORD *a6, CGFloat a7, CGFloat a8)
{
  __int128 v15;
  double AlignedStrokeFrameForGridRange;
  double v17;
  float64x2_t v18;
  uint64_t v19;
  TSDBezierPath *v20;
  uint64_t v21;
  uint64_t i;
  TSTLayoutSpace *v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  TSDBezierPath *AlignedStrokeLinePathForColumnGridRange;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  TSDBezierPath *v32;
  TSDBezierPath *v33;
  unint64_t v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  void *AlignedMaskStrokeFramePathForGridRange;
  _OWORD *v40;
  int v41;
  double x;
  double width;
  BOOL v44;
  char v45;
  int v47;
  _QWORD *v48;
  float64x2_t v49;
  void *v50;
  int v51;
  uint64_t v52;
  id obj;
  int v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  CGAffineTransform v59;
  CGAffineTransform v60;
  _OWORD v61[3];
  _OWORD v62[2];
  float64_t v63;
  double v64;
  _OWORD v65[2];
  double v66;
  float64_t v67;
  CGAffineTransform v68;
  _OWORD v69[3];
  _OWORD v70[2];
  float64_t v71;
  double v72;
  _OWORD v73[2];
  double v74;
  float64_t v75;
  __int128 v76;
  __int128 v77;
  float64x2_t v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  CGAffineTransform v83;
  __int128 v84;
  __int128 v85;
  _BYTE v86[128];
  uint64_t v87;
  CGRect v88;
  CGRect v89;

  v87 = *MEMORY[0x24BDAC8D0];
  v15 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  v84 = *MEMORY[0x24BDBD8B8];
  v85 = v15;
  memset(&v83, 0, sizeof(v83));
  CGAffineTransformMakeScale(&v83, a7, a7);
  v52 = a3;
  if (a5)
  {
    AlignedStrokeFrameForGridRange = TSTLayoutGetAlignedStrokeFrameForGridRange(a1, a2, a3, a4);
    v18 = vaddq_f64(*(float64x2_t *)&v83.tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v83.c, v17), *(float64x2_t *)&v83.a, AlignedStrokeFrameForGridRange));
  }
  else
  {
    v18 = (float64x2_t)vdupq_n_s64(0xC0F86A0000000000);
  }
  v49 = v18;
  v79 = 0u;
  v80 = 0u;
  v81 = 0u;
  v82 = 0u;
  obj = TSTLayoutGetVisibleLayoutSpaces(a1);
  v57 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v79, v86, 16);
  if (!v57)
    return 0;
  v47 = a5;
  v48 = a6;
  v19 = 0;
  v55 = 0;
  v50 = 0;
  v20 = 0;
  v56 = *(_QWORD *)v80;
  v58 = HIDWORD(a2);
  v21 = v52;
  v51 = a4;
  do
  {
    for (i = 0; i != v57; ++i)
    {
      if (*(_QWORD *)v80 != v56)
        objc_enumerationMutation(obj);
      v23 = *(TSTLayoutSpace **)(*((_QWORD *)&v79 + 1) + 8 * i);
      v24 = -[TSTLayoutSpace layoutSpaceType](v23, "layoutSpaceType");
      if (a4 == 2)
      {
        if (!TSTLayoutSpaceIntersectsColumnGridRange(v23, a2 | (v58 << 32), v21))
          goto LABEL_22;
        v28 = TSTLayoutSpaceIntersectionColumnGridRange(v23, a2 | (v58 << 32), v21);
        AlignedStrokeLinePathForColumnGridRange = TSTLayoutSpaceGetAlignedStrokeLinePathForColumnGridRange(v23, v28, v29, &v83, 0, a8);
LABEL_17:
        v32 = AlignedStrokeLinePathForColumnGridRange;
        switch(v24)
        {
          case 1:
            TSTLayoutGetFrozenHeaderCornerTransformToLayout(a1, (uint64_t)&v76);
            v84 = v76;
            v85 = v77;
            v69[0] = v76;
            v69[1] = v77;
            v69[2] = vmulq_n_f64(v78, a7);
            -[TSDBezierPath transformUsingAffineTransform:](v32, "transformUsingAffineTransform:", v69);
            v38 = 1;
            goto LABEL_60;
          case 2:
            v33 = v20;
            TSTLayoutGetFrozenHeaderColumnsTransformToLayout(a1, (uint64_t)&v76);
            v84 = v76;
            v85 = v77;
            v73[0] = v76;
            v73[1] = v77;
            v74 = v78.f64[0] * a7;
            v75 = v78.f64[1];
            -[TSDBezierPath transformUsingAffineTransform:](v32, "transformUsingAffineTransform:", v73);
            TSTLayoutSpaceGetGridRange((uint64_t)v23);
            v35 = 0;
            v34 = (v41 + 1);
            v37 = 1;
            v38 = 1;
            if ((v55 & 1) == 0)
            {
              v24 = 0;
              goto LABEL_28;
            }
            break;
          case 3:
            v33 = v20;
            v34 = a2;
            TSTLayoutGetFrozenHeaderRowsTransformToLayout(a1, (uint64_t)&v76);
            v84 = v76;
            v85 = v77;
            v70[0] = v76;
            v70[1] = v77;
            v71 = v78.f64[0];
            v72 = v78.f64[1] * a7;
            -[TSDBezierPath transformUsingAffineTransform:](v32, "transformUsingAffineTransform:", v70);
            TSTLayoutSpaceGetGridRange((uint64_t)v23);
            v35 = 0;
            v58 = (v36 + 1);
            v37 = 1;
            v38 = 1;
            if ((v19 & 1) == 0)
            {
              v24 = 1;
              v38 = 0;
LABEL_28:
              a2 = v34;
              v21 = v52;
LABEL_59:
              v20 = v33;
              a4 = v51;
LABEL_60:
              v55 = v24;
              if (v20)
              {
                v20 = -[TSDBezierPath uniteWithBezierPath:](v20, "uniteWithBezierPath:", v32);
                v19 = v38;
              }
              else
              {
                v19 = v38;
                v20 = v32;
              }
              continue;
            }
            break;
          default:
            if (v24)
            {
              v38 = v19;
              v24 = v55;
              goto LABEL_60;
            }
            if (((v19 | v55) & 1) == 0)
            {
              v38 = v19;
              v24 = v55;
              goto LABEL_60;
            }
            v33 = v20;
            v34 = a2;
            v35 = 1;
            v37 = v55;
            v38 = v19;
            break;
        }
        v88.origin.x = TSTLayoutGetAlignedMaskRectForSpace(a1, -[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"));
        v68 = v83;
        v89 = CGRectApplyAffineTransform(v88, &v68);
        x = v89.origin.x;
        width = v89.size.width;
        if (!v35 || (v38 & 1) == 0)
        {
          if (v24 != 3)
            goto LABEL_38;
          if ((v38 & 1) == 0)
          {
            v45 = v35 & v37;
            v21 = v52;
            if ((v45 & 1) == 0)
            {
LABEL_55:
              v24 = v37;
LABEL_56:
              if (-[TSDBezierPath isEmpty](v32, "isEmpty"))
                v32 = 0;
              a2 = v34;
              goto LABEL_59;
            }
LABEL_54:
            v32 = -[TSDBezierPath subtractBezierPath:](v32, "subtractBezierPath:", +[TSDBezierPath bezierPathWithRect:](TSDBezierPath, "bezierPathWithRect:", TSDRectWithPoints(-100000.0, -100000.0, x + width)));
            goto LABEL_55;
          }
        }
        v32 = -[TSDBezierPath subtractBezierPath:](v32, "subtractBezierPath:", +[TSDBezierPath bezierPathWithRect:](TSDBezierPath, "bezierPathWithRect:", TSDRectWithPoints(-100000.0, -100000.0, v89.origin.x)));
LABEL_38:
        if ((v35 & v37 & 1) != 0)
        {
          v21 = v52;
        }
        else
        {
          v44 = v24 == 2;
          v24 = (v24 != 2) & v37;
          v21 = v52;
          if (!v44 || ((v37 ^ 1) & 1) != 0)
            goto LABEL_56;
        }
        goto LABEL_54;
      }
      if (a4 != 1)
      {
        if (!TSTLayoutSpaceIntersectsGridRange(v23, a2 | (v58 << 32), v21))
          goto LABEL_22;
        v30 = TSTLayoutSpaceIntersectionGridRange(v23, a2 | (v58 << 32), v21);
        AlignedStrokeLinePathForColumnGridRange = TSTLayoutSpaceGetAlignedStrokeFramePathForGridRange(v23, v30, v31, &v83, 0, a8);
        goto LABEL_17;
      }
      if (TSTLayoutSpaceIntersectsRowGridRange((uint64_t)v23, a2 | (v58 << 32), v21))
      {
        v25 = TSTLayoutSpaceIntersectionRowGridRange((uint64_t)v23, a2 | (v58 << 32), v21);
        AlignedStrokeLinePathForColumnGridRange = TSTLayoutSpaceGetAlignedStrokeLinePathForRowGridRange(v23, v25, v26, &v83, 0, a8);
        goto LABEL_17;
      }
LABEL_22:
      if (-[TSTLayoutSpace isFrozen](v23, "isFrozen"))
      {
        AlignedMaskStrokeFramePathForGridRange = (void *)TSTLayoutSpaceGetAlignedMaskStrokeFramePathForGridRange(v23, (__int128 *)&v83);
        if (v24 == 3)
        {
          TSTLayoutGetFrozenHeaderRowsTransformToLayout(a1, (uint64_t)&v76);
          v84 = v76;
          v85 = v77;
          v62[0] = v76;
          v62[1] = v77;
          v63 = v78.f64[0];
          v64 = v78.f64[1] * a7;
          v40 = v62;
        }
        else if (v24 == 2)
        {
          TSTLayoutGetFrozenHeaderColumnsTransformToLayout(a1, (uint64_t)&v76);
          v84 = v76;
          v85 = v77;
          v65[0] = v76;
          v65[1] = v77;
          v66 = v78.f64[0] * a7;
          v67 = v78.f64[1];
          v40 = v65;
        }
        else
        {
          TSTLayoutGetFrozenHeaderCornerTransformToLayout(a1, (uint64_t)&v76);
          v84 = v76;
          v85 = v77;
          v61[0] = v76;
          v61[1] = v77;
          v61[2] = vmulq_n_f64(v78, a7);
          v40 = v61;
        }
        objc_msgSend(AlignedMaskStrokeFramePathForGridRange, "transformUsingAffineTransform:", v40);
        if (AlignedMaskStrokeFramePathForGridRange)
        {
          if ((objc_msgSend(AlignedMaskStrokeFramePathForGridRange, "isEmpty") & 1) == 0)
          {
            if (v50)
              v50 = (void *)objc_msgSend(v50, "uniteWithBezierPath:", AlignedMaskStrokeFramePathForGridRange);
            else
              v50 = AlignedMaskStrokeFramePathForGridRange;
          }
        }
      }
    }
    v57 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v79, v86, 16);
  }
  while (v57);
  if (v20)
  {
    if (v47)
    {
      CGAffineTransformMakeTranslation(&v60, -v49.f64[0], -v49.f64[1]);
      -[TSDBezierPath transformUsingAffineTransform:](v20, "transformUsingAffineTransform:", &v60);
      CGAffineTransformMakeTranslation(&v59, -v49.f64[0], -v49.f64[1]);
      objc_msgSend(v50, "transformUsingAffineTransform:", &v59);
    }
    if (v48)
      *v48 = v50;
  }
  return v20;
}

double TSTLayoutGetAlignedContentFrameForRange(TSTLayout *a1, unint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v2 = BYTE2(a2);
  if (BYTE2(a2) == 255)
    v2 = -1;
  v3 = WORD2(a2) + v2 - 1;
  if (!WORD2(a2))
    v3 = 0xFFFFFFFFLL;
  if ((unsigned __int16)a2 == 0xFFFF)
    v4 = 0xFFFFFFFFLL;
  else
    v4 = (unsigned __int16)a2;
  v5 = v2 | ((unint64_t)v4 << 32);
  v6 = ((a2 >> 16) & 0xFFFF00000000) + (v4 << 32) - 0x100000000;
  if (((a2 >> 16) & 0xFFFF00000000) == 0)
    v6 = 0xFFFFFFFF00000000;
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, v5, v3 | v6, (uint64_t)&__block_literal_global_69);
}

double TSTLayoutGetAlignedContentFrameForGridRange(TSTLayout *a1, unint64_t a2, uint64_t a3)
{
  return TSTLayoutGetArbitraryRectAcrossSpacesForGridRange(a1, a2, a3, (uint64_t)&__block_literal_global_69);
}

void sub_217BDD364(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  _Block_object_dispose(&a47, 8);
  _Block_object_dispose(&a53, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__70(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__71(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

BOOL TSTLayoutTableNameHitByCanvasPoint(TSTLayout *a1, double a2, double a3)
{
  double FrameForTableName;
  double v7;
  CGFloat y;
  double v9;
  double width;
  double v11;
  CGFloat height;
  double v13;
  double v14;
  CGFloat v15;
  CGFloat v16;
  CGFloat v17;
  CGAffineTransform v19;
  CGAffineTransform v20;
  CGPoint v21;
  CGRect v22;
  CGRect v23;
  CGRect v24;

  if (!a1->mTableNameVisible)
    return 0;
  FrameForTableName = TSTLayoutGetFrameForTableName(a1);
  y = v7;
  width = v9;
  height = v11;
  if (TSTLayoutGetFrozenHeaderRowsEnabled(a1))
  {
    if (TSTLayoutGetFrozenHeaderRowsFloating(a1))
    {
      memset(&v20, 0, sizeof(v20));
      TSTLayoutGetFrozenTableNameTransformToLayout(a1, &v20);
      v19 = v20;
      v22.origin.x = FrameForTableName;
      v22.origin.y = y;
      v22.size.width = width;
      v22.size.height = height;
      v23 = CGRectApplyAffineTransform(v22, &v19);
      FrameForTableName = v23.origin.x;
      y = v23.origin.y;
      width = v23.size.width;
      height = v23.size.height;
    }
  }
  TSTLayoutGetRowTabsRangeFrame(a1, -[TSTTableModel range](-[TSTLayout tableModel](a1, "tableModel"), "range"));
  v14 = FrameForTableName - v13;
  v15 = FrameForTableName - v14;
  v16 = width + v14;
  v21.x = TSTLayoutSpaceGetLayoutPointForCanvasPoint((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), a2, a3);
  v21.y = v17;
  v24.origin.x = v15;
  v24.origin.y = y;
  v24.size.width = v16;
  v24.size.height = height;
  return CGRectContainsPoint(v24, v21);
}

double TSTLayoutGetFrameForTableName(void *a1)
{
  __int128 v2;
  double v3;
  double v4;
  TSTLayoutSpace *v5;
  unsigned int GridRange;
  unsigned int v7;
  double FrameForGridRange;
  double v9;
  uint64_t v10;
  __int128 v12;
  __int128 v13;

  v2 = *(_OWORD *)(MEMORY[0x24BDBF090] + 16);
  v12 = *MEMORY[0x24BDBF090];
  v13 = v2;
  TSTLayoutGetTableNameHeight((uint64_t)a1);
  if (v3 <= 0.0)
    return *(double *)&v12;
  v4 = v3;
  v5 = (TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  GridRange = TSTLayoutSpaceGetGridRange((uint64_t)v5);
  FrameForGridRange = TSTLayoutSpaceGetFrameForGridRange(v5, GridRange, v7);
  *(double *)&v12 = FrameForGridRange;
  *((double *)&v12 + 1) = v9 - v4;
  *(_QWORD *)&v13 = v10;
  *((double *)&v13 + 1) = v4;
  TSTLayoutSpaceAlignRect((double *)v5, (CGFloat *)&v12);
  return FrameForGridRange;
}

BOOL TSTLayoutTableNameChromeHitByCanvasPoint(TSTLayout *a1, double a2, double a3)
{
  double FrameForTableName;
  double v7;
  CGFloat y;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat height;
  double v13;
  CGFloat v14;
  double v15;
  CGFloat v16;
  CGFloat v17;
  CGAffineTransform v19;
  CGAffineTransform v20;
  CGPoint v21;
  CGRect v22;
  CGRect v23;
  CGRect v24;

  if (!a1->mTableNameVisible)
    return 0;
  FrameForTableName = TSTLayoutGetFrameForTableName(a1);
  y = v7;
  v10 = v9;
  height = v11;
  if (TSTLayoutGetFrozenHeaderRowsEnabled(a1))
  {
    if (TSTLayoutGetFrozenHeaderRowsFloating(a1))
    {
      memset(&v20, 0, sizeof(v20));
      TSTLayoutGetFrozenTableNameTransformToLayout(a1, &v20);
      v19 = v20;
      v22.origin.x = FrameForTableName;
      v22.origin.y = y;
      v22.size.width = v10;
      v22.size.height = height;
      v23 = CGRectApplyAffineTransform(v22, &v19);
      y = v23.origin.y;
      height = v23.size.height;
    }
  }
  TSTLayoutGetRowTabsRangeFrame(a1, -[TSTTableModel range](-[TSTLayout tableModel](a1, "tableModel"), "range"));
  v14 = v13;
  v16 = v15;
  v21.x = TSTLayoutSpaceGetLayoutPointForCanvasPoint((uint64_t)-[TSTLayoutSpaceBundle space](-[TSTLayout spaceBundle](a1, "spaceBundle"), "space"), a2, a3);
  v21.y = v17;
  v24.origin.x = v14;
  v24.origin.y = y;
  v24.size.width = v16;
  v24.size.height = height;
  return CGRectContainsPoint(v24, v21);
}

uint64_t TSTLayoutTableNameBorderEnabled(_BYTE *a1)
{
  void *v1;

  if (a1[387]
    && (v1 = (void *)objc_msgSend(a1, "tableModel"), objc_msgSend(v1, "tableNameBorderEnabled")))
  {
    return objc_msgSend(v1, "hasTableBorder");
  }
  else
  {
    return 0;
  }
}

double TSTLayoutTableNameBorderStrokeWidth(_BYTE *a1)
{
  void *v2;
  double result;

  if (!a1[387])
    return 0.0;
  v2 = (void *)objc_msgSend(a1, "tableModel");
  if (!objc_msgSend(v2, "tableNameBorderEnabled") || !objc_msgSend(v2, "hasTableBorder"))
    return 0.0;
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "tableModel"), "tableNameBorderStroke"), "width");
  return result;
}

void TSTLayoutGetVisibleRectForTableName(_BYTE *a1)
{
  double FrameForTableName;
  double v3;
  CGFloat v4;
  double v5;
  CGFloat v6;
  double v7;
  CGFloat v8;
  CGFloat v9;
  CGFloat v10;
  CGFloat v11;
  CGRect v12;
  CGRect v13;

  if (a1[387])
  {
    FrameForTableName = TSTLayoutGetFrameForTableName(a1);
    v4 = v3;
    v6 = v5;
    v8 = v7;
    v13.origin.x = TSTLayoutGetVisibleRect((double *)a1);
    v13.origin.y = v9;
    v13.size.width = v10;
    v13.size.height = v11;
    v12.origin.x = FrameForTableName;
    v12.origin.y = v4;
    v12.size.width = v6;
    v12.size.height = v8;
    CGRectIntersection(v12, v13);
  }
}

double TSTLayoutGetFrameForTableNameBorder(void *a1)
{
  return TSTLayoutSpaceGetFrameForTableNameBorder((TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
}

double TSTLayoutGetStrokeFrameForTableNameBorder(void *a1)
{
  return TSTLayoutSpaceGetStrokeFrameForTableNameBorder((TSTLayoutSpace *)objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space"));
}

double TSTLayoutGetCanvasFrameForTableName(void *a1)
{
  uint64_t v2;
  double FrameForTableName;
  double v4;
  double v5;
  double v6;

  v2 = objc_msgSend((id)objc_msgSend(a1, "spaceBundle"), "space");
  FrameForTableName = TSTLayoutGetFrameForTableName(a1);
  return TSTLayoutSpaceGetCanvasRectForLayoutRect(v2, FrameForTableName, v4, v5, v6);
}

double TSTLayoutGetFrameForFrozenTableName(TSTLayout *a1)
{
  double FrameForTableName;
  double v3;
  CGFloat v4;
  double v5;
  CGFloat v6;
  double v7;
  CGFloat v8;
  CGAffineTransform v10;
  CGAffineTransform v11;
  CGRect v12;

  FrameForTableName = TSTLayoutGetFrameForTableName(a1);
  v4 = v3;
  v6 = v5;
  v8 = v7;
  if (TSTLayoutGetFrozenHeaderRowsEnabled(a1) && TSTLayoutGetFrozenHeaderRowsFloating(a1))
  {
    memset(&v11, 0, sizeof(v11));
    TSTLayoutGetFrozenTableNameTransformToLayout(a1, &v11);
    v10 = v11;
    v12.origin.x = FrameForTableName;
    v12.origin.y = v4;
    v12.size.width = v6;
    v12.size.height = v8;
    *(_QWORD *)&FrameForTableName = (unint64_t)CGRectApplyAffineTransform(v12, &v10);
  }
  return FrameForTableName;
}

uint64_t TSTLayoutCellLeftOfCell(void *a1, uint64_t a2, int a3)
{
  unint64_t v3;
  uint64_t v7;
  uint64_t v8;
  TSTLayoutCellIterator *v9;
  uint64_t v10;
  const __CFString *v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  __CFString *v16;
  void *v17;
  void *v18;
  unint64_t v19;
  void *v22;
  unint64_t v23;
  const __CFString *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v29 = objc_msgSend(a1, "tableModel");
  if ((a2 & 0xFF0000) == 0)
    return 0xFFFFFFLL;
  v7 = (a2 << 16) & 0xFF00000000 | (unsigned __int16)a2 | 0x1000000000000;
  if (a3)
    v8 = 293;
  else
    v8 = 261;
  v9 = -[TSTLayoutCellIterator initWithLayout:range:flags:]([TSTLayoutCellIterator alloc], "initWithLayout:range:flags:", a1, v7, v8);
  v10 = 0xFFFFFFLL;
  v11 = &stru_24D82FEB0;
  v12 = 0x24BEB3000uLL;
  while (TSTLayoutCellIteratorGetNextCell((uint64_t)v9, &v32))
  {
    v13 = v33;
    if (!v33)
    {
      v31 = 0;
      goto LABEL_15;
    }
    v14 = *(_DWORD *)(v33 + 8);
    if ((v14 & 0xFF00) == 0)
    {
      v31 = 0;
      if (*(_BYTE *)(v33 + 9))
      {
LABEL_20:
        if ((_WORD)v10 == 0xFFFF || (v10 & 0xFF0000) == 0xFF0000)
        {
          v18 = (void *)objc_msgSend(a1, "masterLayout");
          v3 = v3 & 0xFFFFFFFF00000000 | HIDWORD(v32);
          v19 = TSTTableMergeRangeAtCellID(v29, objc_msgSend(v18, "modelCellIDForLayoutCellID:", v3));
          if ((_WORD)v19 != 0xFFFF && (v19 & 0xFF0000) != 0xFF0000)
          {
            if ((v19 & 0xFFFF00000000) != 0 && HIWORD(v19) != 0)
              v10 = HIDWORD(v32);
            else
              v10 = v10;
          }
        }
        goto LABEL_38;
      }
LABEL_15:
      if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyChangingContent"))
      {
        v17 = (void *)objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicContentDelegate");
        v30 = v30 & 0xFFFFFFFF00000000 | HIDWORD(v32);
        if (objc_msgSend(v17, "cell:forCellID:", &v31))
          v10 = HIDWORD(v32);
        else
          v10 = v10;
      }
      goto LABEL_20;
    }
    if ((*(_DWORD *)(v33 + 8) & 0xFF00) != 0x300)
      goto LABEL_37;
    v15 = BYTE1(v14);
    if (v15)
    {
      if (v15 == 9)
      {
        v16 = (__CFString *)objc_msgSend(*(id *)(v33 + 72), "string");
      }
      else if (v15 == 3)
      {
        v16 = *(__CFString **)(v33 + 24);
      }
      else
      {
        v22 = (void *)objc_msgSend(*(id *)(v12 + 3112), "currentHandler");
        v23 = v12;
        v24 = v11;
        v25 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
        v26 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h");
        v27 = v25;
        v11 = v24;
        v12 = v23;
        objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v27, v26, 972, CFSTR("can't get string from non-string cell: %p"), v13);
        v16 = 0;
      }
    }
    else
    {
      v16 = (__CFString *)v11;
    }
    if (-[__CFString length](v16, "length"))
LABEL_37:
      v10 = HIDWORD(v32);
LABEL_38:
    if ((_WORD)v10 != 0xFFFF && (v10 & 0xFF0000) != 0xFF0000)
      break;
  }

  return v10;
}

uint64_t TSTLayoutCellRightOfCell(void *a1, int a2, int a3)
{
  unint64_t v3;
  uint64_t v7;
  uint64_t v8;
  TSTLayoutCellIterator *v9;
  uint64_t v10;
  const __CFString *v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  __CFString *v16;
  void *v17;
  void *v18;
  unint64_t v19;
  void *v22;
  unint64_t v23;
  const __CFString *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v29 = objc_msgSend(a1, "tableModel");
  if (BYTE2(a2) >= (int)(TSTMasterLayoutGetTableNumberOfColumns(objc_msgSend(a1, "masterLayout")) - 1))
    return 0xFFFFFFLL;
  LODWORD(v7) = (unsigned __int16)(TSTMasterLayoutGetTableNumberOfColumns(objc_msgSend(a1, "masterLayout")) + ~BYTE2(a2));
  if (v7 >= 0xFF)
    v7 = 255;
  else
    v7 = v7;
  if (a3)
    v8 = 289;
  else
    v8 = 257;
  v9 = -[TSTLayoutCellIterator initWithLayout:range:flags:]([TSTLayoutCellIterator alloc], "initWithLayout:range:flags:", a1, (a2 + 0x10000) & 0xFF0000 | (unint64_t)(unsigned __int16)a2 | (v7 << 32) | 0x1000000000000, v8);
  v10 = 0xFFFFFFLL;
  v11 = &stru_24D82FEB0;
  v12 = 0x24BEB3000uLL;
  while (TSTLayoutCellIteratorGetNextCell((uint64_t)v9, &v32))
  {
    v13 = v33;
    if (!v33)
    {
      v31 = 0;
      goto LABEL_18;
    }
    v14 = *(_DWORD *)(v33 + 8);
    if ((v14 & 0xFF00) == 0)
    {
      v31 = 0;
      if (*(_BYTE *)(v33 + 9))
      {
LABEL_23:
        if ((_WORD)v10 == 0xFFFF || (v10 & 0xFF0000) == 0xFF0000)
        {
          v18 = (void *)objc_msgSend(a1, "masterLayout");
          v3 = v3 & 0xFFFFFFFF00000000 | HIDWORD(v32);
          v19 = TSTTableMergeRangeAtCellID(v29, objc_msgSend(v18, "modelCellIDForLayoutCellID:", v3));
          if ((_WORD)v19 != 0xFFFF && (v19 & 0xFF0000) != 0xFF0000)
          {
            if ((v19 & 0xFFFF00000000) != 0 && HIWORD(v19) != 0)
              v10 = HIDWORD(v32);
            else
              v10 = v10;
          }
        }
        goto LABEL_41;
      }
LABEL_18:
      if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyChangingContent"))
      {
        v17 = (void *)objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "dynamicContentDelegate");
        v30 = v30 & 0xFFFFFFFF00000000 | HIDWORD(v32);
        if (objc_msgSend(v17, "cell:forCellID:", &v31))
          v10 = HIDWORD(v32);
        else
          v10 = v10;
      }
      goto LABEL_23;
    }
    if ((*(_DWORD *)(v33 + 8) & 0xFF00) != 0x300)
      goto LABEL_40;
    v15 = BYTE1(v14);
    if (v15)
    {
      if (v15 == 9)
      {
        v16 = (__CFString *)objc_msgSend(*(id *)(v33 + 72), "string");
      }
      else if (v15 == 3)
      {
        v16 = *(__CFString **)(v33 + 24);
      }
      else
      {
        v22 = (void *)objc_msgSend(*(id *)(v12 + 3112), "currentHandler");
        v23 = v12;
        v24 = v11;
        v25 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSTCellStringValue(TSTCell *)");
        v26 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCell.h");
        v27 = v25;
        v11 = v24;
        v12 = v23;
        objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v27, v26, 972, CFSTR("can't get string from non-string cell: %p"), v13);
        v16 = 0;
      }
    }
    else
    {
      v16 = (__CFString *)v11;
    }
    if (-[__CFString length](v16, "length"))
LABEL_40:
      v10 = HIDWORD(v32);
LABEL_41:
    if ((_WORD)v10 != 0xFFFF && (v10 & 0xFF0000) != 0xFF0000)
      break;
  }

  return v10;
}

uint64_t TSTLayoutGetCellStyleAtCellID(void *a1, unint64_t a2, char *a3)
{
  int v4;
  unsigned __int16 v6;
  unint64_t v7;
  void *v8;

  v4 = a2;
  v6 = a2;
  v7 = a2 >> 16;
  v8 = (void *)objc_msgSend(a1, "tableModel");
  if (objc_msgSend((id)objc_msgSend(a1, "masterLayout"), "isDynamicallyChangingRowOrColumnCount"))
  {
    if (objc_msgSend(v8, "numberOfRows") <= (unsigned __int16)v4)
      v6 = objc_msgSend(v8, "numberOfRows");
    if (objc_msgSend(v8, "numberOfColumns") <= v7)
      LOBYTE(v7) = objc_msgSend(v8, "numberOfColumns");
  }
  return TSTTableGetCellStyleAtCellID((uint64_t *)v8, v4 & 0xFF000000 | v6 | (v7 << 16), a3);
}

void sub_217BDFCF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__93(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

void sub_217BDFE44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSTLayoutStarRatingForCanvasPoint(TSTLayout *a1, unint64_t a2, double a3)
{
  double CanvasFrameForRange;
  double v5;
  double v6;

  CanvasFrameForRange = TSTLayoutGetCanvasFrameForRange(a1, a2);
  v6 = (a3 - CanvasFrameForRange) / v5;
  if (v6 < 0.0700000003)
    return 0;
  if (v6 < 0.200000003)
    return 1;
  if (v6 < 0.400000006)
    return 2;
  if (v6 < 0.600000024)
    return 3;
  if (v6 >= 0.800000012)
    return 5;
  return 4;
}

uint64_t ___ZL28TSTLayoutUpdateFrozenHeadersP9TSTLayout_block_invoke(uint64_t a1, void *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v7[3];
  _OWORD v8[3];

  objc_msgSend(a2, "setViewScale:", *(double *)(a1 + 32));
  v4 = *(_OWORD *)(a1 + 56);
  v8[0] = *(_OWORD *)(a1 + 40);
  v8[1] = v4;
  v8[2] = *(_OWORD *)(a1 + 72);
  objc_msgSend(a2, "setTransformToCanvas:", v8);
  v5 = *(_OWORD *)(a1 + 104);
  v7[0] = *(_OWORD *)(a1 + 88);
  v7[1] = v5;
  v7[2] = *(_OWORD *)(a1 + 120);
  TSTLayoutSpaceSetUserSpaceToDeviceSpaceTransform((uint64_t)a2, v7);
  return 0;
}

uint64_t ___ZL28TSTLayoutUpdateRepeatHeadersP9TSTLayout_block_invoke(uint64_t a1, void *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v7[3];
  _OWORD v8[3];

  objc_msgSend(a2, "setHeaderRowsRepeat:", *(unsigned __int8 *)(a1 + 136));
  objc_msgSend(a2, "setHeaderColumnsRepeat:", *(unsigned __int8 *)(a1 + 137));
  objc_msgSend(a2, "setViewScale:", *(double *)(a1 + 32));
  v4 = *(_OWORD *)(a1 + 56);
  v8[0] = *(_OWORD *)(a1 + 40);
  v8[1] = v4;
  v8[2] = *(_OWORD *)(a1 + 72);
  objc_msgSend(a2, "setTransformToCanvas:", v8);
  v5 = *(_OWORD *)(a1 + 104);
  v7[0] = *(_OWORD *)(a1 + 88);
  v7[1] = v5;
  v7[2] = *(_OWORD *)(a1 + 120);
  TSTLayoutSpaceSetUserSpaceToDeviceSpaceTransform((uint64_t)a2, v7);
  return 0;
}

id TSTStrokeRunSet(id result, int a2, int a3, TSDStroke *a4, char a5, int a6)
{
  uint64_t v10;
  TSDStroke *v11;
  uint64_t v13;
  uint64_t v14;
  char v15;

  v10 = (uint64_t)result;
  v11 = (TSDStroke *)*((_QWORD *)result + 1);
  if (v11 != a4)
  {

    *(_QWORD *)(v10 + 8) = a4;
    v13 = 0;
    if (a4 && !-[TSDStroke empty](a4, "empty"))
    {
      -[TSDStroke width](a4, "width");
      v13 = v14;
    }
    *(_QWORD *)(v10 + 16) = v13;
    result = *(id *)(v10 + 8);
  }
  *(_DWORD *)v10 = a2;
  *(_DWORD *)(v10 + 4) = a3;
  if (a6)
    v15 = 2;
  else
    v15 = 0;
  *(_BYTE *)(v10 + 24) = v15 | a5 | *(_BYTE *)(v10 + 24) & 0xFC;
  return result;
}

uint64_t TSTStrokeRunArrayGetStrokeRun(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 24) <= a2)
    return 0;
  else
    return *(_QWORD *)(a1 + 40) + 32 * a2;
}

uint64_t TSTStrokeRunArrayGetCount(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 24);
  return result;
}

TSTStrokeRunArray *TSTStrokeRunArrayCopy(uint64_t a1)
{
  uint64_t v1;
  TSTStrokeRunArray *v2;
  TSTStrokeRunArray *v3;
  unint64_t v4;
  uint64_t v5;
  TSTStrokeRun *mStrokes;
  id v7;
  void *v8;
  uint64_t v9;

  if (a1)
    v1 = *(unsigned int *)(a1 + 24);
  else
    v1 = 0;
  v2 = -[TSTStrokeRunArray initWithCount:]([TSTStrokeRunArray alloc], "initWithCount:", v1);
  v3 = v2;
  if ((_DWORD)v1)
  {
    memcpy(v2->mStrokes, *(const void **)(a1 + 40), 32 * v1);
    v4 = 0;
    v5 = 8;
    do
    {
      if (v4 < v3->mCount && (mStrokes = v3->mStrokes) != 0)
      {
        v7 = *(id *)((char *)&mStrokes->var0 + v5);
      }
      else
      {
        v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTStrokeRunArray *TSTStrokeRunArrayCopy(TSTStrokeRunArray *)");
        objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 176, CFSTR("NULL strokeRun"));
      }
      ++v4;
      v5 += 32;
    }
    while (v1 != v4);
  }
  if (a1)
  {
    v3->mHasCustomStrokes = *(_BYTE *)(a1 + 8);
    v3->mMaxWidth = *(double *)(a1 + 16);
  }
  return v3;
}

unsigned int *TSTStrokeRunArrayGetNextStroke(uint64_t a1, unsigned int a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v4;
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = *a4;
  if (!(_DWORD)v4)
  {
    v6 = *(unsigned int *)(a1 + 32);
    if (v6 >= *(_DWORD *)(a1 + 24))
    {
      *(_DWORD *)(a1 + 32) = 0;
      LODWORD(v6) = *a4;
    }
    else if ((_DWORD)v6)
    {
      if (*(_DWORD *)(*(_QWORD *)(a1 + 40) + 32 * v6) <= a2)
        *a4 = v6;
      else
        LODWORD(v6) = 0;
    }
    while (*(_DWORD *)(a1 + 24) > v6)
    {
      v5 = *(unsigned int **)(a1 + 40);
      if (!v5)
        return v5;
      v7 = v6;
      *(_DWORD *)(a1 + 32) = v6;
      LODWORD(v6) = *a4 + 1;
      *a4 = v6;
      v5 += 8 * v7;
      if (v5[1] > a2)
        goto LABEL_14;
    }
    return 0;
  }
  if (v4 >= *(_DWORD *)(a1 + 24))
    return 0;
  v5 = (unsigned int *)(*(_QWORD *)(a1 + 40) + 32 * v4);
  *(_DWORD *)(a1 + 32) = v4;
  ++*a4;
LABEL_14:
  if (*v5 >= a3 || v5[1] <= a2)
    return 0;
  return v5;
}

unsigned int *TSTStrokeRunArrayLookupStroke(unsigned int *result, unsigned int a2)
{
  int v3;

  v3 = 0;
  if (result)
  {
    result = TSTStrokeRunArrayGetNextStroke((uint64_t)result, a2, a2 + 1, &v3);
    if (!result || *result > a2 || result[1] <= a2)
      return 0;
  }
  return result;
}

TSTStrokeRunArray *TSTStrokeRunArrayCreateWithArguments(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  TSTStrokeRunArray *v3;
  unint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  int v8;
  TSDStroke **v9;
  TSDStroke *v10;
  TSTStrokeRun *v11;
  double mMaxWidth;
  BOOL v13;
  double v14;
  double v15;
  BOOL v16;
  TSDStroke **v19;

  v2 = a1;
  v3 = -[TSTStrokeRunArray initWithCount:]([TSTStrokeRunArray alloc], "initWithCount:", a1);
  if (v2)
  {
    v4 = 0;
    v5 = (int *)a2;
    v19 = (TSDStroke **)(a2 + 8);
    v6 = *v5;
    v7 = v2;
    while (1)
    {
      v8 = v6;
      v9 = v19;
      v10 = *v19;
      v19 += 2;
      v11 = v4 >= v3->mCount ? 0 : &v3->mStrokes[v4];
      v6 = *((_DWORD *)v9 + 2);
      TSTStrokeRunSet(v11, v8, v6, v10, 0, 0);
      mMaxWidth = v3->mMaxWidth;
      if (v10)
        break;
      v15 = 0.0;
      if (mMaxWidth > 0.0)
        goto LABEL_12;
LABEL_15:
      v3->mMaxWidth = v15;
      if (++v4 == v7)
        return v3;
    }
    v13 = -[TSDStroke empty](v10, "empty");
    v14 = 0.0;
    if (!v13)
      -[TSDStroke width](v10, "width", 0.0);
    if (mMaxWidth <= v14)
    {
      v16 = -[TSDStroke empty](v10, "empty");
      v15 = 0.0;
      if (!v16)
        -[TSDStroke width](v10, "width", 0.0);
      goto LABEL_15;
    }
    mMaxWidth = v3->mMaxWidth;
LABEL_12:
    v15 = mMaxWidth;
    goto LABEL_15;
  }
  return v3;
}

TSTStrokeRunArray *TSTStrokeRunArrayCreateWithStroke(TSDStroke *a1, int a2, int a3)
{
  TSTStrokeRunArray *v6;
  TSTStrokeRunArray *v7;
  TSTStrokeRun *mStrokes;
  double v9;
  uint64_t v10;
  double v11;

  v6 = -[TSTStrokeRunArray initWithCount:]([TSTStrokeRunArray alloc], "initWithCount:", 1);
  v7 = v6;
  if (v6->mCount)
    mStrokes = v6->mStrokes;
  else
    mStrokes = 0;
  TSTStrokeRunSet(mStrokes, a2, a3, a1, 0, 0);
  v9 = 0.0;
  if (-[TSDStroke pattern](a1, "pattern"))
  {
    v10 = -[TSDStrokePattern patternType](-[TSDStroke pattern](a1, "pattern"), "patternType");
    if (a1)
    {
      if (v10 != 2)
      {
        -[TSDStroke width](a1, "width");
        v9 = v11;
      }
    }
  }
  v7->mMaxWidth = v9;
  return v7;
}

TSTStrokeRunArray *TSTStrokeRunArrayInsertDefaultStroke(TSTStrokeRunArray *a1, unsigned int a2, unsigned int a3, TSDStroke *a4)
{
  TSTStrokeRunArray *inserted;

  inserted = p_TSTStrokeRunArrayInsertStroke(a1, a2, a3, a4, 0, 0);
  p_updateStrokeRunArrayMetadata((uint64_t)inserted);
  return a1;
}

TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *a1, unsigned int var0, unsigned int var1, TSDStroke *a4, int a5, int a6)
{
  double mMaxWidth;
  BOOL v11;
  double v12;
  double v13;
  BOOL v14;
  unsigned int *NextStroke;
  TSTStrokeRun *v16;
  unsigned int v17;
  char v18;
  TSDStroke *v19;
  TSTStrokeRun *v20;
  unsigned int v21;
  uint64_t v22;
  TSTStrokeRun *mStrokes;
  uint64_t v24;
  void *v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  TSDStroke *v32;
  char v33;
  TSDStroke *var2;
  unsigned int mCount;
  BOOL v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  TSTStrokeRun *v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  TSTStrokeRun *v47;
  unsigned int v48;
  char v49;
  TSTStrokeRun *v50;
  TSDStroke *v51;
  _BOOL4 v52;
  unsigned int v53;
  int v54;
  int v55;
  TSDStroke *v56;
  char v57;
  int v58;
  uint64_t v60;
  TSTStrokeRun *v61;
  TSTStrokeRun *v62;
  int v63;
  TSTStrokeRun *v64;
  void *v65;
  uint64_t v66;
  char v67;
  TSDStroke *v68;
  unsigned int v69;
  uint64_t v70;
  int v71;
  unsigned int v72;
  unsigned int v73;
  TSTStrokeRun *v74;
  void *v75;
  uint64_t v76;
  void *v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  TSTStrokeRun *v81;
  TSTStrokeRun *v82;
  BOOL v83[8];
  int v84;
  unsigned int v87;

  mMaxWidth = a1->mMaxWidth;
  if (!a4)
  {
    v13 = 0.0;
    if (mMaxWidth <= 0.0)
      goto LABEL_10;
    goto LABEL_7;
  }
  v11 = -[TSDStroke empty](a4, "empty");
  v12 = 0.0;
  if (!v11)
    -[TSDStroke width](a4, "width", 0.0);
  if (mMaxWidth > v12)
  {
    mMaxWidth = a1->mMaxWidth;
LABEL_7:
    v13 = mMaxWidth;
    goto LABEL_10;
  }
  v14 = -[TSDStroke empty](a4, "empty");
  v13 = 0.0;
  if (!v14)
    -[TSDStroke width](a4, "width", 0.0);
LABEL_10:
  a1->mMaxWidth = v13;
  v87 = 0;
  NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)a1, var0, var0 + 1, &v87);
  if (!NextStroke)
  {
    if (!v87
      || ((v24 = v87 - 1, a1->mCount <= v24) ? (v20 = 0) : (v20 = &a1->mStrokes[v24]),
          v20->var1 != var0
       || (v33 = *((_BYTE *)v20 + 24), ((v33 & 1) == 0) == a5)
       || ((v33 & 2) == 0) == a6
       || (var2 = (TSDStroke *)v20->var2, var2 != a4) && !-[TSDStroke isEqualToStroke:](var2, "isEqualToStroke:", a4)))
    {
      mCount = a1->mCount;
      v36 = mCount != 0;
      v37 = mCount - 1;
      if (v36)
        v38 = v37;
      else
        v38 = 0;
      TSTStrokeRunArrayExpand(a1, v38, 1u);
      v39 = a1->mCount;
      if (v39)
      {
        v40 = &a1->mStrokes[v39 - 1];
LABEL_62:
        v54 = var0;
        v55 = var1;
        v56 = a4;
        v57 = a5;
        v58 = a6;
LABEL_63:
        TSTStrokeRunSet(v40, v54, v55, v56, v57, v58);
        return a1;
      }
LABEL_61:
      v40 = 0;
      goto LABEL_62;
    }
    goto LABEL_37;
  }
  v16 = (TSTStrokeRun *)NextStroke;
  v17 = *NextStroke;
  if (*NextStroke <= var0)
  {
    v18 = *((_BYTE *)NextStroke + 24);
    if (((v18 & 1) == 0) != a5 && ((v18 & 2) == 0) != a6)
    {
      v19 = (TSDStroke *)*((_QWORD *)NextStroke + 1);
      if (v19 == a4)
      {
        var0 = v17;
        goto LABEL_44;
      }
      if (-[TSDStroke isEqualToStroke:](v19, "isEqualToStroke:", a4))
      {
        v20 = v16;
LABEL_37:
        var0 = v20->var0;
        v16 = v20;
        goto LABEL_44;
      }
    }
  }
  v21 = v87;
  v22 = v87 - 2;
  if (v87 >= 2)
  {
    if (a1->mCount > v22 && (mStrokes = a1->mStrokes) != 0)
    {
      v20 = &mStrokes[v22];
    }
    else
    {
      v25 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v26 = a6;
      v27 = a5;
      v28 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex, TSDStroke *, BOOL, BOOL)");
      v29 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm");
      v30 = v28;
      a5 = v27;
      a6 = v26;
      objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v30, v29, 427, CFSTR("previousStrokeRun must be non-NULL"));
      v20 = 0;
    }
    if (v20->var1 == var0)
    {
      v31 = *((_BYTE *)v20 + 24);
      if (((v31 & 1) == 0) != a5 && ((v31 & 2) == 0) != a6)
      {
        v32 = (TSDStroke *)v20->var2;
        if (v32 == a4 || -[TSDStroke isEqualToStroke:](v32, "isEqualToStroke:", a4))
        {
          v87 = v21 - 1;
          goto LABEL_37;
        }
      }
    }
  }
LABEL_44:
  v41 = v16->var0;
  v42 = v87;
  v43 = v87 - 1;
  if (v41 >= var1)
  {
    TSTStrokeRunArrayExpand(a1, v87 - 1, 1u);
    if (a1->mCount > v43)
    {
      v40 = &a1->mStrokes[v43];
      goto LABEL_62;
    }
    goto LABEL_61;
  }
  v44 = a1->mCount;
  v84 = a5;
  if (v87 >= v44)
  {
    v53 = v87;
  }
  else
  {
    *(_QWORD *)v83 = v87 - 1;
    v45 = 0;
    v46 = v87;
    while (1)
    {
      v47 = a1->mStrokes;
      a1->mLastLookup = v42 + v45;
      if (!v47)
        break;
      v48 = v47[v46].var0;
      if (v48 >= var1)
      {
        if (v48 != var1
          || (v49 = *((_BYTE *)&v47[v46] + 24), ((v49 & 1) == 0) == a5)
          || ((v49 & 2) == 0) == a6
          || (v50 = &v47[v46], v51 = (TSDStroke *)v47[v46].var2, v51 != a4)
          && (v52 = -[TSDStroke isEqualToStroke:](v51, "isEqualToStroke:", a4), v44 = a1->mCount, !v52))
        {
LABEL_58:
          v53 = v42 + v45;
          goto LABEL_67;
        }
        if (var1 <= v50->var1)
          var1 = v50->var1;
        a5 = v84;
      }
      ++v45;
      ++v46;
      if (v42 + v45 >= (unint64_t)v44)
        goto LABEL_58;
    }
    v53 = v42 + v45 + 1;
LABEL_67:
    v43 = *(_QWORD *)v83;
  }
  v60 = v53 - 1;
  if (v44 <= v43)
    v61 = 0;
  else
    v61 = &a1->mStrokes[v43];
  *(_DWORD *)v83 = a6;
  if (v44 > v60 && (v62 = a1->mStrokes) != 0)
  {
    v63 = 0;
    v64 = &v62[v60];
  }
  else
  {
    v65 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler", *(_QWORD *)v83);
    v66 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex, TSDStroke *, BOOL, BOOL)");
    objc_msgSend(v65, "handleFailureInFunction:file:lineNumber:description:", v66, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 509, CFSTR("lastStrokeRun should be non-NULL"));
    v64 = 0;
    v63 = 1;
  }
  v67 = *((_BYTE *)v61 + 24);
  if (((v67 & 1) == 0) != v84 && ((v67 & 2) == 0) != *(_DWORD *)v83)
  {
    v68 = (TSDStroke *)v61->var2;
    if ((v68 == a4 || -[TSDStroke isEqualToStroke:](v68, "isEqualToStroke:", a4)) && v61 == v64)
    {
      if (var1 > v61->var1)
        v61->var1 = var1;
      return a1;
    }
  }
  v69 = v64->var1;
  if (var0 > v61->var0)
  {
    if (v69 > var1)
    {
      if ((_DWORD)v42 == v53)
      {
        TSTStrokeRunArrayExpand(a1, v43, 2u);
        v71 = *(_DWORD *)v83;
        if (a1->mCount <= v43)
          goto LABEL_100;
      }
      else
      {
        v71 = *(_DWORD *)v83;
        if ((_DWORD)v60 != (_DWORD)v42)
        {
          v70 = (v60 - v43 - 2);
          if ((_DWORD)v60 - (_DWORD)v43 != 2)
            TSTStrokeRunArrayShrink(a1, v42, v70);
          goto LABEL_119;
        }
        TSTStrokeRunArrayExpand(a1, v43, 1u);
        if (a1->mCount <= v43)
          goto LABEL_100;
      }
      v74 = a1->mStrokes;
      if (v74)
      {
        v61 = &v74[v43];
LABEL_119:
        if (v63)
        {
          v79 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler", v70);
          v80 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex, TSDStroke *, BOOL, BOOL)");
          objc_msgSend(v79, "handleFailureInFunction:file:lineNumber:description:", v80, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 634, CFSTR("lastStrokeRun should be non-NULL"));
        }
        v61->var1 = var0;
        if (a1->mCount <= v42)
          v81 = 0;
        else
          v81 = &a1->mStrokes[v42];
        TSTStrokeRunSet(v81, var0, var1, a4, v84, v71);
        if (a1->mCount <= (v42 + 1) || (v82 = a1->mStrokes) == 0)
          p_TSTStrokeRunArrayInsertStroke();
        v82[(v42 + 1)].var0 = var1;
        return a1;
      }
LABEL_100:
      v75 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler", *(_QWORD *)v83);
      v76 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex, TSDStroke *, BOOL, BOOL)");
      objc_msgSend(v75, "handleFailureInFunction:file:lineNumber:description:", v76, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 633, CFSTR("firstStrokeRun should be non-NULL"));
      v61 = 0;
      goto LABEL_119;
    }
    if ((_DWORD)v42 == v53)
    {
      TSTStrokeRunArrayExpand(a1, v43, 1u);
      v73 = a1->mCount;
      if (v73 <= v43)
        v61 = 0;
      else
        v61 = &a1->mStrokes[v43];
      if (v73 <= v42)
      {
        v64 = 0;
LABEL_128:
        if (v61 == v64)
        {
LABEL_130:
          v40 = v61;
          v57 = v84;
          v54 = var0;
          v55 = var1;
          v56 = a4;
          v58 = *(_DWORD *)v83;
          goto LABEL_63;
        }
LABEL_129:
        v61->var1 = var0;
        v61 = v64;
        goto LABEL_130;
      }
    }
    else
    {
      if ((_DWORD)v60 == (_DWORD)v42)
        goto LABEL_128;
      TSTStrokeRunArrayShrink(a1, v42, v60 - v42);
      if (a1->mCount <= v42)
      {
        v64 = 0;
        goto LABEL_129;
      }
    }
    v64 = &a1->mStrokes[v42];
    goto LABEL_128;
  }
  if (v69 > var1)
  {
    if ((_DWORD)v42 == v53)
    {
      TSTStrokeRunArrayExpand(a1, v43, 1u);
      v72 = a1->mCount;
      if (v72 <= v43)
        v61 = 0;
      else
        v61 = &a1->mStrokes[v43];
    }
    else
    {
      if ((_DWORD)v60 == (_DWORD)v42)
        goto LABEL_110;
      TSTStrokeRunArrayShrink(a1, v42, v60 - v42);
      v72 = a1->mCount;
    }
    if (v72 <= v42)
      v64 = 0;
    else
      v64 = &a1->mStrokes[v42];
LABEL_110:
    TSTStrokeRunSet(v61, var0, var1, a4, v84, *(int *)v83);
    if (v64 != v61)
    {
      if (!v64)
      {
        v77 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v78 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex, TSDStroke *, BOOL, BOOL)");
        objc_msgSend(v77, "handleFailureInFunction:file:lineNumber:description:", v78, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 564, CFSTR("lastStrokeRun should be non-NULL"));
      }
      v64->var0 = var1;
    }
    return a1;
  }
  TSTStrokeRunSet(v61, var0, var1, a4, v84, *(int *)v83);
  if (v53 != (_DWORD)v42)
    TSTStrokeRunArrayShrink(a1, v42, v60 - v43);
  return a1;
}

uint64_t p_updateStrokeRunArrayMetadata(uint64_t result)
{
  double v1;
  uint64_t v2;
  unint64_t v3;
  double *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  double *v8;
  unsigned __int8 v9;
  double v10;
  double v11;
  char v12;
  char v13;

  v1 = 0.0;
  if (!result || (v2 = *(unsigned int *)(result + 24), !(_DWORD)v2))
  {
    LOBYTE(v5) = 0;
    goto LABEL_21;
  }
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 24;
  do
  {
    if (v3 < *(unsigned int *)(result + 24))
    {
      v7 = *(_QWORD *)(result + 40);
      if (v7)
      {
        v8 = (double *)(v7 + v6);
        v9 = *(_BYTE *)v8;
        v10 = *(v8 - 1);
        if (v1 <= v10)
          v1 = *(v8 - 1);
        if (v4)
        {
          v11 = v4[2];
          if (v11 > v10)
          {
            *((_BYTE *)v4 + 24) = (_BYTE)v4[3] & 0xCF | 0x10;
            v12 = *(_BYTE *)v8 & 0xF3 | 8;
LABEL_16:
            v4 = v8 - 3;
            v5 |= (v9 & 2) >> 1;
            *(_BYTE *)v8 = v12;
            goto LABEL_17;
          }
          v13 = *((_BYTE *)v4 + 24);
          if (v11 == v10)
          {
            *((_BYTE *)v4 + 24) = v13 | 0x30;
            v12 = *(_BYTE *)v8 | 0xC;
            goto LABEL_16;
          }
          *((_BYTE *)v4 + 24) = v13 & 0xCF | 0x20;
          LOBYTE(v4) = *(_BYTE *)v8 & 0xF7;
        }
        else
        {
          v4 = (double *)(v9 & 0xF7);
        }
        v12 = v4 | 4;
        goto LABEL_16;
      }
    }
LABEL_17:
    ++v3;
    v6 += 32;
  }
  while (v2 != v3);
  if (v4)
    *((_BYTE *)v4 + 24) = (_BYTE)v4[3] & 0xCF | 0x10;
LABEL_21:
  *(_BYTE *)(result + 8) = v5 & 1;
  *(double *)(result + 16) = v1;
  return result;
}

TSTStrokeRunArray *TSTStrokeRunArrayInsertCustomStroke(TSTStrokeRunArray *a1, unsigned int a2, unsigned int a3, TSDStroke *a4)
{
  TSTStrokeRunArray *inserted;

  inserted = p_TSTStrokeRunArrayInsertStroke(a1, a2, a3, a4, 0, 1);
  inserted->mHasCustomStrokes = 1;
  p_updateStrokeRunArrayMetadata((uint64_t)inserted);
  return a1;
}

unsigned int *TSTStrokeRunArrayGetStrokeAtIndex(unsigned int *a1, unsigned int a2)
{
  unsigned int *result;

  result = TSTStrokeRunArrayLookupStroke(a1, a2);
  if (result)
    return (unsigned int *)*((_QWORD *)result + 1);
  return result;
}

uint64_t TSTStrokeRunArraySetValid(uint64_t result, unsigned int a2, unsigned int a3)
{
  TSTStrokeRunArray *v5;
  unsigned int *NextStroke;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  TSDStroke *v10;
  int v11;
  unsigned int v12;
  unsigned int v13;

  if (!result)
    return result;
  v5 = (TSTStrokeRunArray *)result;
  v13 = 0;
  NextStroke = TSTStrokeRunArrayGetNextStroke(result, a2, a3, &v13);
  if (!NextStroke)
    return p_updateStrokeRunArrayMetadata((uint64_t)v5);
  while (1)
  {
    v7 = *((unsigned __int8 *)NextStroke + 24);
    if ((v7 & 1) != 0)
      goto LABEL_12;
    v8 = NextStroke[1];
    v9 = *NextStroke <= a2 ? a2 : *NextStroke;
    v10 = (TSDStroke *)*((_QWORD *)NextStroke + 1);
    v11 = (v7 >> 1) & 1;
    if (v8 > a3)
      break;
    p_TSTStrokeRunArrayInsertStroke(v5, v9, v8, v10, 1, v11);
    if (v8 != -1)
    {
      if (v8 >= a3)
        return p_updateStrokeRunArrayMetadata((uint64_t)v5);
      v13 = 0;
      NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)v5, v8, a3, &v13);
      if (!NextStroke)
        return p_updateStrokeRunArrayMetadata((uint64_t)v5);
      goto LABEL_14;
    }
LABEL_12:
    v12 = v13;
    if (v13 >= v5->mCount)
      return p_updateStrokeRunArrayMetadata((uint64_t)v5);
    NextStroke = &v5->mStrokes[v13].var0;
    v5->mLastLookup = v13;
    v13 = v12 + 1;
    if (!NextStroke)
      return p_updateStrokeRunArrayMetadata((uint64_t)v5);
LABEL_14:
    if (*NextStroke >= a3)
      return p_updateStrokeRunArrayMetadata((uint64_t)v5);
  }
  p_TSTStrokeRunArrayInsertStroke(v5, v9, a3, v10, 1, v11);
  return p_updateStrokeRunArrayMetadata((uint64_t)v5);
}

uint64_t TSTStrokeRunArraySetEntireCustom(uint64_t result)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (result)
  {
    v1 = *(unsigned int *)(result + 24);
    if ((_DWORD)v1)
    {
      v2 = 0;
      v3 = 24;
      do
      {
        if (v2 < *(unsigned int *)(result + 24))
        {
          v4 = *(_QWORD *)(result + 40);
          if (v4)
            *(_BYTE *)(v4 + v3) |= 2u;
        }
        ++v2;
        v3 += 32;
      }
      while (v1 != v2);
    }
  }
  *(_BYTE *)(result + 8) = 1;
  return result;
}

uint64_t TSTStrokeRunArrayResetRange(TSTStrokeRunArray *a1, unsigned int *a2, unsigned int a3, unsigned int a4)
{
  unsigned int mCount;
  TSTStrokeRun *mStrokes;
  unsigned int var1;
  unsigned int v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  TSDStroke *v16;
  TSTStrokeRunArray *v17;
  unsigned int v18;
  TSDStroke *v19;
  TSTStrokeRunArray *v20;
  TSTStrokeRunArray *inserted;
  TSTStrokeRunArray *v22;

  if (!a1 || (mCount = a1->mCount) == 0 || (mStrokes = a1->mStrokes) == 0)
    TSTStrokeRunArrayResetRange_cold_1();
  var1 = mStrokes[mCount - 1].var1;
  if (var1 >= a3)
    v10 = a3;
  else
    v10 = var1;
  do
  {
    while (1)
    {
      v11 = TSTStrokeRunArrayLookupStroke((unsigned int *)a1, v10);
      v12 = TSTStrokeRunArrayLookupStroke(a2, v10);
      v13 = v12;
      if (!v11)
        break;
      v14 = v11[1];
      if (v14 >= v12[1])
        v14 = v12[1];
      if (v14 >= a4)
        v15 = a4;
      else
        v15 = v14;
      if (v10 >= v15)
      {
        v13 = 0;
        goto LABEL_25;
      }
      v16 = (TSDStroke *)*((_QWORD *)v12 + 1);
      if ((v12[6] & 2) != 0)
      {
        inserted = p_TSTStrokeRunArrayInsertStroke(a1, v10, v15, v16, 0, 1);
        a1->mHasCustomStrokes = 1;
        p_updateStrokeRunArrayMetadata((uint64_t)inserted);
        a1->mHasCustomStrokes = 1;
      }
      else
      {
        v17 = p_TSTStrokeRunArrayInsertStroke(a1, v10, v15, v16, 0, 0);
        p_updateStrokeRunArrayMetadata((uint64_t)v17);
      }
      v10 = v15;
    }
    if (v12)
    {
      v18 = v12[1];
      v19 = (TSDStroke *)*((_QWORD *)v12 + 1);
      if ((v12[6] & 2) != 0)
      {
        v22 = p_TSTStrokeRunArrayInsertStroke(a1, v10, v18, v19, 0, 1);
        a1->mHasCustomStrokes = 1;
        p_updateStrokeRunArrayMetadata((uint64_t)v22);
        a1->mHasCustomStrokes = 1;
      }
      else
      {
        v20 = p_TSTStrokeRunArrayInsertStroke(a1, v10, v18, v19, 0, 0);
        p_updateStrokeRunArrayMetadata((uint64_t)v20);
      }
      v10 = v13[1];
    }
LABEL_25:
    ;
  }
  while (v13);
  return p_updateStrokeRunArrayMetadata((uint64_t)a1);
}

uint64_t TSTStrokeRunArrayTruncate(uint64_t a1, unsigned int a2)
{
  unsigned int *NextStroke;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v9;
  uint64_t v10;
  unsigned int v12;

  v12 = 0;
  NextStroke = TSTStrokeRunArrayGetNextStroke(a1, a2 - 1, a2, &v12);
  v5 = 0;
  if (NextStroke)
  {
    v6 = v12;
    do
    {
      v7 = NextStroke[1];
      if (v7 != a2)
      {
        if (v7 <= a2 || *NextStroke >= a2)
        {
          TSTStrokeRunSet(NextStroke, 0, 0, 0, 0, 0);
          ++v5;
        }
        else
        {
          NextStroke[1] = a2;
        }
      }
      v9 = *(_DWORD *)(a1 + 24);
      if (v9 <= v6)
        break;
      v10 = *(_QWORD *)(a1 + 40);
      NextStroke = (unsigned int *)(v10 + 32 * v6++);
    }
    while (v10);
  }
  else
  {
    v9 = *(_DWORD *)(a1 + 24);
  }
  *(_DWORD *)(a1 + 24) = v9 - v5;
  return p_updateStrokeRunArrayMetadata(a1);
}

TSTStrokeRunArray *TSTStrokeRunArrayMergeHorizontalStrokes(TSTStrokeRunArray *a1, TSTStrokeRunArray *a2)
{
  return p_TSTStrokeRunArrayMergeStrokes(a2, a1);
}

TSTStrokeRunArray *p_TSTStrokeRunArrayMergeStrokes(TSTStrokeRunArray *a1, TSTStrokeRunArray *a2)
{
  _BOOL4 mHasCustomStrokes;
  TSTStrokeRunArray *v4;
  unint64_t mCount;
  uint64_t v6;
  unint64_t i;
  TSTStrokeRun *v8;

  if (!a1)
    goto LABEL_11;
  if (!a2)
  {
LABEL_12:
    v4 = TSTStrokeRunArrayCopy((uint64_t)a1);
    pthread_rwlock_wrlock(&v4->mRWLock);
    return v4;
  }
  if (!a1->mHasCustomStrokes)
  {
LABEL_11:
    a1 = a2;
    goto LABEL_12;
  }
  mHasCustomStrokes = a2->mHasCustomStrokes;
  v4 = TSTStrokeRunArrayCopy((uint64_t)a1);
  pthread_rwlock_wrlock(&v4->mRWLock);
  if (mHasCustomStrokes)
  {
    mCount = a2->mCount;
    if ((_DWORD)mCount)
    {
      v6 = 0;
      for (i = 0; i < mCount; ++i)
      {
        v8 = &a2->mStrokes[v6];
        if ((*((_BYTE *)v8 + 24) & 2) != 0)
        {
          p_TSTStrokeRunArrayInsertStroke(v4, v8->var0, v8->var1, (TSDStroke *)v8->var2, *((_BYTE *)v8 + 24) & 1, 1);
          mCount = a2->mCount;
        }
        ++v6;
      }
    }
    p_updateStrokeRunArrayMetadata((uint64_t)v4);
  }
  return v4;
}

TSTStrokeRunArray *TSTStrokeRunArrayMergeVerticalStrokes(TSTStrokeRunArray *a1, TSTStrokeRunArray *a2)
{
  return p_TSTStrokeRunArrayMergeStrokes(a2, a1);
}

double TSTStrokeRunArrayMaxWidthForMergedHorizontalStrokes(TSTStrokeRunArray *a1, TSTStrokeRunArray *a2, unsigned int a3, unsigned int a4)
{
  return p_TSTStrokeRunArrayMaxWidthForMergedStrokes(a2, a1, a3, a4);
}

double p_TSTStrokeRunArrayMaxWidthForMergedStrokes(TSTStrokeRunArray *a1, TSTStrokeRunArray *a2, unsigned int a3, unsigned int a4)
{
  double v8;
  double mMaxWidth;
  unsigned int *NextStroke;
  unsigned int *v11;
  _BOOL4 v12;
  double v13;
  _BOOL4 v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int *v18;
  uint64_t v21;

  if (!a2)
  {
    v8 = 0.0;
    if (!a1)
      goto LABEL_10;
    mMaxWidth = a1->mMaxWidth;
    if (mMaxWidth < 0.0)
      goto LABEL_10;
    goto LABEL_7;
  }
  v8 = a2->mMaxWidth;
  if (!a1)
  {
    if (v8 <= 0.0)
      v8 = 0.0;
    goto LABEL_10;
  }
  mMaxWidth = a1->mMaxWidth;
  if (v8 <= mMaxWidth)
LABEL_7:
    v8 = mMaxWidth;
LABEL_10:
  NextStroke = 0;
  v11 = 0;
  v21 = 0;
  LOBYTE(v12) = 1;
  v13 = 0.0;
  LOBYTE(v14) = 1;
  do
  {
    if (v12)
    {
      NextStroke = TSTStrokeRunArrayGetNextStroke((uint64_t)a2, a3, a4, (_DWORD *)&v21 + 1);
      if (!v14)
      {
LABEL_13:
        if (!NextStroke)
          goto LABEL_28;
        goto LABEL_17;
      }
    }
    else if (!v14)
    {
      goto LABEL_13;
    }
    v11 = TSTStrokeRunArrayGetNextStroke((uint64_t)a1, a3, a4, &v21);
    if (!NextStroke)
      goto LABEL_28;
LABEL_17:
    if (v11)
    {
      v15 = NextStroke[1];
      v16 = v11[1];
      if (v15 >= v16)
        v17 = v11[1];
      else
        v17 = NextStroke[1];
      v18 = NextStroke;
      if ((v11[6] & 2) != 0)
      {
        if ((NextStroke[6] & 2) != 0)
          v18 = NextStroke;
        else
          v18 = v11;
      }
      if (v13 <= *((double *)v18 + 2))
        v13 = *((double *)v18 + 2);
      v12 = v15 <= v16;
      goto LABEL_37;
    }
LABEL_28:
    if (NextStroke)
    {
      v17 = NextStroke[1];
      if (v13 <= *((double *)NextStroke + 2))
        v13 = *((double *)NextStroke + 2);
      if (!v11)
      {
        v14 = 0;
        v12 = 1;
        goto LABEL_38;
      }
      v16 = v11[1];
      v12 = 1;
    }
    else
    {
      if (!v11)
        return v13;
      v12 = 0;
      v16 = v11[1];
      if (v13 <= *((double *)v11 + 2))
        v13 = *((double *)v11 + 2);
      v17 = v11[1];
    }
LABEL_37:
    v14 = v16 == v17;
LABEL_38:
    if (!v12 && !v14)
      break;
  }
  while (v13 < v8 && v17 < a4);
  return v13;
}

double TSTStrokeRunArrayMaxWidthForMergedVerticalStrokes(TSTStrokeRunArray *a1, TSTStrokeRunArray *a2, unsigned int a3, unsigned int a4)
{
  return p_TSTStrokeRunArrayMaxWidthForMergedStrokes(a2, a1, a3, a4);
}

uint64_t TSTStrokeRunArrayWriteLock(uint64_t a1)
{
  return pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 48));
}

uint64_t TSTStrokeRunArrayReadLock(uint64_t a1)
{
  return pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 48));
}

uint64_t TSTStrokeRunArrayUnlock(uint64_t a1)
{
  return pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 48));
}

id TSTStrokeRunArrayExpand(TSTStrokeRunArray *a1, unsigned int a2, unsigned int a3)
{
  unsigned int mCount;
  unsigned int v7;
  BOOL v8;
  unsigned int v9;
  TSTStrokeRun *v10;
  TSTStrokeRun *mStrokes;
  void *v13;
  uint64_t v14;

  mCount = a1->mCount;
  v7 = mCount + a3;
  if (mCount + a3 > a1->mAllocCount)
  {
    a1->mAllocCount = v7;
    a1->mStrokes = (TSTStrokeRun *)malloc_type_realloc(a1->mStrokes, 32 * (mCount + a3), 0x1080040D89E363BuLL);
    mCount = a1->mCount;
  }
  v8 = mCount >= a2;
  v9 = mCount - a2;
  if (v9 != 0 && v8)
  {
    memmove(&a1->mStrokes[a3 + a2], &a1->mStrokes[a2], 32 * v9);
    if (a3 >= 2)
    {
      v10 = &a1->mStrokes[a2 + 1];
      *(_OWORD *)&v10->var0 = 0u;
      *(_OWORD *)&v10->var3 = 0u;
    }
  }
  a1->mCount = v7;
  if (v7 > a2)
  {
    mStrokes = a1->mStrokes;
    if (mStrokes)
      return mStrokes[a2].var2;
  }
  v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTStrokeRunArrayExpand(TSTStrokeRunArray *, unsigned int, unsigned int)");
  return (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 334, CFSTR("NULL strokeRun"));
}

uint64_t TSTStrokeRunArrayShrink(TSTStrokeRunArray *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6;
  unsigned int v7;
  TSTStrokeRun *v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;

  if (a3)
  {
    v6 = a3;
    v7 = a2;
    do
    {
      if (a1->mCount <= v7)
        v8 = 0;
      else
        v8 = &a1->mStrokes[v7];
      TSTStrokeRunSet(v8, 0, 0, 0, 0, 0);
      ++v7;
      --v6;
    }
    while (v6);
  }
  v9 = a1->mCount - a3;
  a1->mCount = v9;
  v10 = v9 >= a2;
  v11 = v9 - a2;
  if (v11 != 0 && v10)
    memmove(&a1->mStrokes[a2], &a1->mStrokes[a3 + a2], 32 * v11);
  return p_updateStrokeRunArrayMetadata((uint64_t)a1);
}

void p_TSTStrokeRunArrayInsertStroke()
{
  void *v0;
  uint64_t v1;

  v0 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v1 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTStrokeRunArray *p_TSTStrokeRunArrayInsertStroke(TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex, TSDStroke *, BOOL, BOOL)");
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v1, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 647, CFSTR("lastStrokeRun should be non-NULL"));
  __break(1u);
}

void TSTStrokeRunArrayResetRange_cold_1()
{
  void *v0;
  uint64_t v1;

  v0 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v1 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSTStrokeRunArrayResetRange(TSTStrokeRunArray *, TSTStrokeRunArray *, TSTGridIndex, TSTGridIndex)");
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v1, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTStrokeRunArray.mm"), 798, CFSTR("invalid nil value for '%s'"), "strokeRun");
  __break(1u);
}

void sub_217BE3580(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217BE368C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217BE378C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::__unordered_map_hasher<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,TSTCellIDHasher,std::equal_to<TSUColumnRowCoordinate>,true>,std::__unordered_map_equal<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::equal_to<TSUColumnRowCoordinate>,TSTCellIDHasher,true>,std::allocator<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>>>::find<TSUColumnRowCoordinate>(_QWORD *a1, int *a2)
{
  int8x8_t v2;
  int v3;
  unint64_t v4;
  uint8x8_t v5;
  unint64_t v6;
  uint64_t ***v7;
  uint64_t **result;
  int v9;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = BYTE2(*a2) | ((unint64_t)(unsigned __int16)*a2 << 8);
  v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    v6 = BYTE2(v3) | ((unint64_t)(unsigned __int16)*a2 << 8);
    if (v4 >= *(_QWORD *)&v2)
      v6 = v4 % *(_QWORD *)&v2;
  }
  else
  {
    v6 = v4 & (*(_QWORD *)&v2 + 0xFFFFFFLL);
  }
  v7 = *(uint64_t ****)(*a1 + 8 * v6);
  if (!v7)
    return 0;
  result = *v7;
  if (*v7)
  {
    v9 = BYTE2(v3);
    do
    {
      v10 = (unint64_t)result[1];
      if (v10 == v4)
      {
        if (*((unsigned __int16 *)result + 8) == (unsigned __int16)*a2 && *((unsigned __int8 *)result + 18) == v9)
          return result;
      }
      else
      {
        if (v5.u32[0] > 1uLL)
        {
          if (v10 >= *(_QWORD *)&v2)
            v10 %= *(_QWORD *)&v2;
        }
        else
        {
          v10 &= *(_QWORD *)&v2 - 1;
        }
        if (v10 != v6)
          return 0;
      }
      result = (uint64_t **)*result;
    }
    while (result);
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::__unordered_map_hasher<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,TSTCellIDHasher,std::equal_to<TSUColumnRowCoordinate>,true>,std::__unordered_map_equal<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::equal_to<TSUColumnRowCoordinate>,TSTCellIDHasher,true>,std::allocator<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>>>::__emplace_unique_key_args<TSUColumnRowCoordinate,std::piecewise_construct_t const&,std::tuple<TSUColumnRowCoordinate const&>,std::tuple<>>(uint64_t a1, _DWORD *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v7 = BYTE2(*a2) | ((unint64_t)(unsigned __int16)*a2 << 8);
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = BYTE2(*a2) | ((unint64_t)(unsigned __int16)*a2 << 8);
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = v7 & (v8 + 0xFFFFFF);
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (*((unsigned __int16 *)v11 + 8) == (unsigned __int16)*a2
              && *((unsigned __int8 *)v11 + 18) == BYTE2(*a2))
            {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x18uLL);
  *v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((_DWORD *)v11 + 5) = 0;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    v16 = 1;
    if (v8 >= 3)
      v16 = (v8 & (v8 - 1)) != 0;
    v17 = v16 | (2 * v8);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::__unordered_map_hasher<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::hash<EQKit::StemStretch::Key>,std::equal_to<EQKit::StemStretch::Key>,true>,std::__unordered_map_equal<EQKit::StemStretch::Key,std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>,std::equal_to<EQKit::StemStretch::Key>,std::hash<EQKit::StemStretch::Key>,true>,std::allocator<std::__hash_value_type<EQKit::StemStretch::Key,std::pair<std::shared_ptr<EQKit::StemStretch::Glyph>,unsigned long>>>>::__rehash<true>(a1, v19);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = ((_DWORD)v8 - 1) & v7;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v21)
  {
    *v11 = *v21;
LABEL_42:
    *v21 = v11;
    goto LABEL_43;
  }
  *v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v20 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    v22 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8)
        v22 %= v8;
    }
    else
    {
      v22 &= v8 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_42;
  }
LABEL_43:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_217BE74D8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::__unordered_map_hasher<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,TSTCellIDHasher,std::equal_to<TSUColumnRowCoordinate>,true>,std::__unordered_map_equal<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::equal_to<TSUColumnRowCoordinate>,TSTCellIDHasher,true>,std::allocator<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>>>::__erase_unique<TSUColumnRowCoordinate>(_QWORD *a1, int *a2)
{
  uint64_t *result;

  result = (uint64_t *)std::__hash_table<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::__unordered_map_hasher<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,TSTCellIDHasher,std::equal_to<TSUColumnRowCoordinate>,true>,std::__unordered_map_equal<TSUColumnRowCoordinate,std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>,std::equal_to<TSUColumnRowCoordinate>,TSTCellIDHasher,true>,std::allocator<std::__hash_value_type<TSUColumnRowCoordinate,TSUColumnRowCoordinate>>>::find<TSUColumnRowCoordinate>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::pair<EQKit::Font::STIXCollection::StretchInfo,unsigned long>>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

void sub_217BE7630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__31(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__31(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t TSTCoordinateArraySetIndexHidden(uint64_t a1, unsigned int a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "removeIndex:", a2);
}

BOOL TSTCoordinateArrayContainsIndex(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  BOOL v3;
  unsigned int v4;

  v2 = *(_DWORD *)(a1 + 8);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  return v3 && v4 < *(_DWORD *)(a1 + 12);
}

double TSTCoordinateArraySetCoordinate(uint64_t a1, unsigned int a2, double result)
{
  unsigned int v3;
  BOOL v4;
  unsigned int v5;
  unsigned int v6;
  double *v7;

  v3 = *(_DWORD *)(a1 + 8);
  v4 = a2 >= v3;
  v5 = a2 - v3;
  if (v4)
  {
    v6 = *(_DWORD *)(a1 + 12);
    if (v5 < v6)
    {
      v7 = *(double **)(a1 + 16);
      v7[v5] = result;
      if (v5 == v6 - 1)
      {
        v7[v5 + 1] = result;
        result = (result - *v7) / (double)v5;
        *(double *)(a1 + 24) = result;
      }
    }
  }
  return result;
}

double TSTCoordinateArrayGetCoordinate(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  double result;
  BOOL v4;
  unsigned int v5;
  void *v6;
  uint64_t v7;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 8);
    result = 0.0;
    v4 = a2 >= v2;
    v5 = a2 - v2;
    if (v4 && v5 < *(_DWORD *)(a1 + 12))
    {
      if (*(_BYTE *)(a1 + 40))
        return *(double *)(*(_QWORD *)(a1 + 16) + 8 * v5);
      else
        return *(double *)(a1 + 48) - *(double *)(*(_QWORD *)(a1 + 16) + 8 * v5);
    }
  }
  else
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSTCoordinateArrayGetCoordinate(TSTCoordinateArray *, TSTGridIndex)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCoordinateArray.mm"), 120, CFSTR("invalid nil value for '%s'"), "coordinateArray");
    return 0.0;
  }
  return result;
}

double TSTCoordinateArrayGetRawCoordinate(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  double result;
  BOOL v4;
  unsigned int v5;
  void *v6;
  uint64_t v7;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 8);
    result = 0.0;
    v4 = a2 >= v2;
    v5 = a2 - v2;
    if (v4 && v5 < *(_DWORD *)(a1 + 12))
      return *(double *)(*(_QWORD *)(a1 + 16) + 8 * v5);
  }
  else
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSTCoordinateArrayGetRawCoordinate(TSTCoordinateArray *, TSTGridIndex)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTCoordinateArray.mm"), 144, CFSTR("invalid nil value for '%s'"), "coordinateArray");
    return 0.0;
  }
  return result;
}

uint64_t TSTCoordinateArrayLookup(TSTCoordinateArray *a1, double a2)
{
  double v2;
  double *mCoordinates;
  uint64_t v5;
  unsigned int v7;
  double v8;
  unsigned int v9;
  unsigned int v10;
  char v11;
  unsigned int v12;

  if (!a1)
    return 0xFFFFFFFFLL;
  v2 = a2;
  if (!a1->mLayoutDirectionIsLeftToRight)
    v2 = a1->mTableWidth - a2;
  mCoordinates = a1->mCoordinates;
  if (v2 <= *mCoordinates)
    return a1->mOffset;
  if (v2 > mCoordinates[a1->mCount - 1] + 0.00999999978)
    return 0xFFFFFFFFLL;
  v7 = ((v2 - *mCoordinates) / a1->mAverage);
  v8 = mCoordinates[v7];
  if (v2 >= v8)
    v9 = ((v2 - *mCoordinates) / a1->mAverage);
  else
    v9 = 0;
  if (v2 >= v8)
    v10 = a1->mCount - 1;
  else
    v10 = ((v2 - *mCoordinates) / a1->mAverage);
  if (v2 < v8 || v2 > mCoordinates[v7 + 1] + 0.00999999978)
    goto LABEL_20;
  v11 = -[NSMutableIndexSet containsIndex:](a1->mVisibleIndices, "containsIndex:", a1->mOffset + v7);
  v5 = a1->mOffset + v7;
  if ((v11 & 1) == 0)
    v5 = TSTCoordinateArrayVisibleGridIndexForHiddenGridIndex(a1, v5);
  if ((_DWORD)v5 == -1)
  {
LABEL_20:
    v5 = 0xFFFFFFFFLL;
    while (v9 <= v10)
    {
      v12 = (v10 + v9) >> 1;
      if (v2 >= mCoordinates[v12])
      {
        v9 = v12 + 1;
        if (v2 <= mCoordinates[v12 + 1] + 0.00999999978)
          v5 = a1->mOffset + v12;
      }
      else
      {
        v10 = v12 - 1;
      }
    }
    if ((-[NSMutableIndexSet containsIndex:](a1->mVisibleIndices, "containsIndex:", v5) & 1) == 0)
      v5 = TSTCoordinateArrayVisibleGridIndexForHiddenGridIndex(a1, v5);
  }
  if (a1->mLayoutDirectionIsLeftToRight && (_DWORD)v5 == a1->mCount + a1->mOffset - 1)
    return -[NSMutableIndexSet indexLessThanIndex:](a1->mVisibleIndices, "indexLessThanIndex:", v5);
  return v5;
}

uint64_t TSTCoordinateArrayVisibleGridIndexForHiddenGridIndex(TSTCoordinateArray *a1, unsigned int a2)
{
  double Coordinate;
  NSMutableIndexSet *mVisibleIndices;

  Coordinate = TSTCoordinateArrayGetCoordinate((uint64_t)a1, a2);
  mVisibleIndices = a1->mVisibleIndices;
  if (Coordinate <= 0.0)
    return -[NSMutableIndexSet indexGreaterThanIndex:](mVisibleIndices, "indexGreaterThanIndex:", a2);
  else
    return -[NSMutableIndexSet indexLessThanIndex:](mVisibleIndices, "indexLessThanIndex:", a2);
}

void sub_217BE855C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217BE8734(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t p_setStrokeColors(TSSPropertyMap *a1, uint64_t a2, NSArray *a3)
{
  int *v5;
  id v6;
  id v7;
  id v8;
  id v9;

  if (a3)
  {
    v5 = (int *)((char *)&s_TableStyleStrokeColors + 16 * a2);
    v6 = -[NSArray objectAtIndex:](a3, "objectAtIndex:", *v5);
    v7 = -[NSArray objectAtIndex:](a3, "objectAtIndex:", v5[1]);
    v8 = -[NSArray objectAtIndex:](a3, "objectAtIndex:", v5[2]);
    v9 = -[NSArray objectAtIndex:](a3, "objectAtIndex:", v5[3]);
  }
  else
  {
    v6 = (id)objc_msgSend(MEMORY[0x24BEB3C40], "colorWithRed:green:blue:alpha:", 0.838999987, 0.838999987, 0.838999987, 1.0);
    v7 = v6;
    v9 = v6;
    v8 = v6;
  }
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v6, 1.0), 771);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v6, 1.0), 772);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v6, 1.0), 773);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v6, 1.0), 774);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v7, 1.0), 778);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v7, 1.0), 782);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v7, 1.0), 781);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v7, 1.0), 780);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v7, 1.0), 776);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v7, 1.0), 777);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v9, 1.0), 786);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v9, 1.0), 785);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v9, 1.0), 784);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v8, 1.0), 779);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v8, 1.0), 775);
  -[TSSPropertyMap setObject:forProperty:](a1, "setObject:forProperty:", +[TSDStroke strokeWithColor:width:](TSDStroke, "strokeWithColor:width:", v8, 1.0), 783);
  -[TSSPropertyMap setIntValue:forProperty:](a1, "setIntValue:forProperty:", 1, 788);
  -[TSSPropertyMap setIntValue:forProperty:](a1, "setIntValue:forProperty:", 1, 789);
  -[TSSPropertyMap setIntValue:forProperty:](a1, "setIntValue:forProperty:", 1, 790);
  -[TSSPropertyMap setIntValue:forProperty:](a1, "setIntValue:forProperty:", 1, 792);
  -[TSSPropertyMap setIntValue:forProperty:](a1, "setIntValue:forProperty:", 1, 796);
  -[TSSPropertyMap setIntValue:forProperty:](a1, "setIntValue:forProperty:", 1, 794);
  -[TSSPropertyMap setIntValue:forProperty:](a1, "setIntValue:forProperty:", 1, 793);
  -[TSSPropertyMap setIntValue:forProperty:](a1, "setIntValue:forProperty:", 1, 791);
  return -[TSSPropertyMap setIntValue:forProperty:](a1, "setIntValue:forProperty:", 1, 795);
}

void sub_217BE991C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_217BE9A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_217BE9E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,SFUtility::ObjcSharedPtr<NSObject>>>>::__erase_unique<unsigned int>(uint64_t a1, unsigned int *a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  uint64_t *v7;

  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0;
  v3 = *a2;
  v4 = a1 + 8;
  do
  {
    v5 = *(_DWORD *)(v2 + 32);
    v6 = v5 >= v3;
    if (v5 >= v3)
      v7 = (uint64_t *)v2;
    else
      v7 = (uint64_t *)(v2 + 8);
    if (v6)
      v4 = v2;
    v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32))
    return 0;
  std::__tree<std::__value_type<EQKit::ILayoutOffset::Kind,EQKit::ILayoutOffset>,std::__map_value_compare<EQKit::ILayoutOffset::Kind,std::__value_type<EQKit::ILayoutOffset::Kind,EQKit::ILayoutOffset>,std::less<EQKit::ILayoutOffset::Kind>,true>,std::allocator<std::__value_type<EQKit::ILayoutOffset::Kind,EQKit::ILayoutOffset>>>::erase((uint64_t **)a1, v4);
  return 1;
}

_QWORD *TSTTableStrokeDefaultsCreate(void *a1, unsigned int a2, unsigned int a3, int a4, int a5, int a6)
{
  _QWORD *v12;
  _QWORD *v13;
  int v14;
  unsigned int v15;
  void *DefaultBorderStroke;
  void *DefaultBodyColumnStroke;
  void *DefaultBodyRowStroke;
  void *DefaultHeaderColumnBorderStroke;
  void *DefaultHeaderColumnBodyColumnStroke;
  void *DefaultFooterRowSeparatorStroke;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  void *DefaultHeaderColumnBodyRowStroke;
  void *DefaultFooterRowBodyColumnStroke;
  void *DefaultHeaderColumnSeparatorStroke;
  void *DefaultFooterRowBodyRowStroke;
  void *DefaultHeaderRowBorderStroke;
  void *DefaultHeaderRowBodyColumnStroke;
  void *DefaultHeaderRowBodyRowStroke;
  void *DefaultHeaderRowSeparatorStroke;
  void *DefaultFooterRowBorderStroke;
  unsigned int v36;
  int v37;

  v12 = malloc_type_calloc(0xC0uLL, 1uLL, 0x44CB0A38uLL);
  v13 = v12;
  if (a5 + a6 + 1 > a3)
    v14 = a5 + a6 + 1;
  else
    v14 = a3;
  if (a4 + 1 > a2)
    v15 = a4 + 1;
  else
    v15 = a2;
  *v12 = a1;
  v36 = v15;
  v37 = a5;
  if (!v15)
  {
    v23 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v24 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableStrokeDefaults *TSTTableStrokeDefaultsCreate(TSTTableModel *, TSTGridColumnCount, TSTGridRowCount, TSTGridColumnCount, TSTGridRowCount, TSTGridRowCount)");
    objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v24, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableStrokeDefaults.mm"), 77, CFSTR("numberOfColumns is zero"));
    if (v14)
      goto LABEL_9;
LABEL_11:
    v25 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v26 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSTTableStrokeDefaults *TSTTableStrokeDefaultsCreate(TSTTableModel *, TSTGridColumnCount, TSTGridRowCount, TSTGridColumnCount, TSTGridRowCount, TSTGridRowCount)");
    objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/tables/TSTTableStrokeDefaults.mm"), 78, CFSTR("numberOfRows is zero"));
    goto LABEL_9;
  }
  if (!v14)
    goto LABEL_11;
LABEL_9:
  DefaultBorderStroke = (void *)TSTTableGetDefaultBorderStroke(a1);
  DefaultBodyColumnStroke = (void *)TSTTableGetDefaultBodyColumnStroke(a1);
  DefaultBodyRowStroke = (void *)TSTTableGetDefaultBodyRowStroke(a1);
  DefaultHeaderColumnBorderStroke = (void *)TSTTableGetDefaultHeaderColumnBorderStroke(a1);
  DefaultHeaderColumnBodyColumnStroke = (void *)TSTTableGetDefaultHeaderColumnBodyColumnStroke(a1);
  DefaultHeaderColumnBodyRowStroke = (void *)TSTTableGetDefaultHeaderColumnBodyRowStroke(a1);
  DefaultHeaderColumnSeparatorStroke = (void *)TSTTableGetDefaultHeaderColumnSeparatorStroke(a1);
  DefaultHeaderRowBorderStroke = (void *)TSTTableGetDefaultHeaderRowBorderStroke(a1);
  DefaultHeaderRowBodyColumnStroke = (void *)TSTTableGetDefaultHeaderRowBodyColumnStroke(a1);
  DefaultHeaderRowBodyRowStroke = (void *)TSTTableGetDefaultHeaderRowBodyRowStroke(a1);
  DefaultHeaderRowSeparatorStroke = (void *)TSTTableGetDefaultHeaderRowSeparatorStroke(a1);
  DefaultFooterRowBorderStroke = (void *)TSTTableGetDefaultFooterRowBorderStroke(a1);
  DefaultFooterRowBodyColumnStroke = (void *)TSTTableGetDefaultFooterRowBodyColumnStroke(a1);
  DefaultFooterRowBodyRowStroke = (void *)TSTTableGetDefaultFooterRowBodyRowStroke(a1);
  DefaultFooterRowSeparatorStroke = (void *)TSTTableGetDefaultFooterRowSeparatorStroke(a1);
  *((_DWORD *)v13 + 2) = v36;
  *((_DWORD *)v13 + 3) = v14;
  *((_DWORD *)v13 + 4) = a4;
  *((_DWORD *)v13 + 5) = v37;
  *((_DWORD *)v13 + 6) = a6;
  *((_DWORD *)v13 + 7) = v14 - a6;
  v13[4] = DefaultBorderStroke;
  v13[5] = DefaultBodyColumnStroke;
  v13[6] = DefaultBodyRowStroke;
  v13[7] = DefaultHeaderColumnBorderStroke;
  v13[8] = DefaultHeaderColumnBodyColumnStroke;
  v13[9] = DefaultHeaderColumnBodyRowStroke;
  v13[10] = DefaultHeaderColumnSeparatorStroke;
  v13[11] = DefaultHeaderRowBorderStroke;
  v13[12] = DefaultHeaderRowBodyColumnStroke;
  v13[13] = DefaultHeaderRowBodyRowStroke;
  v13[14] = DefaultHeaderRowSeparatorStroke;
  v13[15] = DefaultFooterRowBodyColumnStroke;
  v13[16] = DefaultFooterRowBodyRowStroke;
  v13[17] = DefaultFooterRowBorderStroke;
  v13[18] = DefaultFooterRowSeparatorStroke;
  *((_DWORD *)v13 + 40) = 60;
  v13[21] = malloc_type_calloc(8uLL, 0x3CuLL, 0x9453EB97uLL);
  v13[22] = malloc_type_calloc(8uLL, (*((_DWORD *)v13 + 2) + 1), 0x7E253C94uLL);
  *(_QWORD *)v13[22] = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  *(_QWORD *)(v13[22] + 8 * *((unsigned int *)v13 + 4)) = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  *(_QWORD *)(v13[22] + 8 * *((unsigned int *)v13 + 2)) = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  v13[23] = malloc_type_calloc(8uLL, (*((_DWORD *)v13 + 3) + 1), 0xBA41484BuLL);
  *(_QWORD *)v13[23] = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  *(_QWORD *)(v13[23] + 8 * *((unsigned int *)v13 + 5)) = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  *(_QWORD *)(v13[23] + 8 * *((unsigned int *)v13 + 7)) = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  *(_QWORD *)(v13[23] + 8 * *((unsigned int *)v13 + 3)) = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  return v13;
}

void TSTTableStrokeDefaultsRelease(uint64_t a1)
{
  void *v2;
  int v3;
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;

  if (a1)
  {
    v2 = *(void **)(a1 + 168);
    if (v2)
    {
      v3 = *(_DWORD *)(a1 + 160);
      if (v3)
      {
        v4 = v3 - 1;
        do
        {
          v5 = v4;

          *(_QWORD *)(*(_QWORD *)(a1 + 168) + 8 * v4--) = 0;
        }
        while (v5);
        v2 = *(void **)(a1 + 168);
      }
      free(v2);
    }

    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;

    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;

    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 72) = 0;

    *(_QWORD *)(a1 + 80) = 0;
    *(_QWORD *)(a1 + 88) = 0;

    *(_QWORD *)(a1 + 96) = 0;
    *(_QWORD *)(a1 + 104) = 0;

    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 120) = 0;

    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = 0;

    *(_QWORD *)(a1 + 144) = 0;
    if (*(_QWORD *)(a1 + 176))
    {
      v6 = 0;
      do
      {
        v7 = v6;
        v8 = *(_QWORD *)(*(_QWORD *)(a1 + 176) + 8 * v6);
        if (v8 && v8 != objc_msgSend(MEMORY[0x24BDBCEF8], "null"))
        {

          *(_QWORD *)(*(_QWORD *)(a1 + 176) + 8 * v7) = 0;
        }
        v6 = v7 + 1;
      }
      while ((v7 + 1) <= *(_DWORD *)(a1 + 8));
      free(*(void **)(a1 + 176));
    }
    if (*(_QWORD *)(a1 + 184))
    {
      v9 = 0;
      do
      {
        v10 = v9;
        v11 = *(_QWORD *)(*(_QWORD *)(a1 + 184) + 8 * v9);
        if (v11)
        {
          if (v11 != objc_msgSend(MEMORY[0x24BDBCEF8], "null"))
          {

            *(_QWORD *)(*(_QWORD *)(a1 + 184) + 8 * v10) = 0;
          }
        }
        v9 = v10 + 1;
      }
      while ((v10 + 1) <= *(_DWORD *)(a1 + 12));
      free(*(void **)(a1 + 184));
    }
    free((void *)a1);
  }
}

TSTStrokeRunArray *TSTTableStrokeDefaultsForColumn(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  TSDStroke *v8;
  TSDStroke *v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  TSTTableStrokeDefaults *v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  TSDStroke *v29;

  v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= a2)
    v4 = a2;
  else
    v4 = v3;
  v5 = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  v6 = *(_QWORD *)(a1 + 176);
  if (v6)
  {
    v7 = *(_QWORD *)(v6 + 8 * v4);
    if (!v7)
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 176) + 8 * v4) = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
      v29 = 0;
      TSTTableGetDefaultStrokesForColumn(*(uint64_t **)a1, v4, &v29, 0);
      v8 = v29;
      if (v8 == (TSDStroke *)objc_msgSend(MEMORY[0x24BDBCEF8], "null"))
        TSTTableGetDefaultStrokesForColumn(*(uint64_t **)a1, (v4 - 1), 0, &v29);
      v9 = v29;
      if (v9 != (TSDStroke *)objc_msgSend(MEMORY[0x24BDBCEF8], "null"))
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 176) + 8 * v4) = TSTStrokeRunArrayCreateWithStroke(v29, 0, *(_DWORD *)(a1 + 12));
        v10 = *(id *)(*(_QWORD *)(a1 + 176) + 8 * v4);
      }
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 176) + 8 * v4);
    }
  }
  else
  {
    v7 = v5;
  }
  if (v7 == objc_msgSend(MEMORY[0x24BDBCEF8], "null"))
  {
    if (*(_DWORD *)(a1 + 160) == 2)
    {
      v23 = *(_QWORD *)(a1 + 32);
      v24 = *(unsigned int *)(a1 + 12);
      v13 = (TSTTableStrokeDefaults *)a1;
      v14 = 0;
LABEL_15:
      v15 = 1;
      return TSTTableStrokeDefaultsStrokeArray(v13, v14, v15, v11, v12, 0, v23, v24, v25, v26, v27, v28);
    }
    v17 = *(_DWORD *)(a1 + 16);
    v16 = *(_DWORD *)(a1 + 20);
    if (v17)
    {
      if (v16)
      {
        if ((_DWORD)v4)
        {
          if (v4 >= v17)
          {
            if ((_DWORD)v4 == v17)
            {
              if (*(_DWORD *)(a1 + 24))
              {
                v27 = *(_QWORD *)(a1 + 120);
                v28 = *(unsigned int *)(a1 + 12);
                v25 = *(_QWORD *)(a1 + 80);
                v26 = *(unsigned int *)(a1 + 28);
                v23 = *(_QWORD *)(a1 + 96);
                v24 = *(unsigned int *)(a1 + 20);
                v13 = (TSTTableStrokeDefaults *)a1;
                v14 = 4;
                goto LABEL_65;
              }
              v25 = *(_QWORD *)(a1 + 80);
              v26 = *(unsigned int *)(a1 + 12);
              v23 = *(_QWORD *)(a1 + 96);
              v24 = *(unsigned int *)(a1 + 20);
              v13 = (TSTTableStrokeDefaults *)a1;
              v14 = 5;
            }
            else
            {
              v20 = *(_DWORD *)(a1 + 24);
              if (v4 >= *(_DWORD *)(a1 + 8))
              {
                if (v20)
                {
                  v27 = *(_QWORD *)(a1 + 136);
                  v28 = *(unsigned int *)(a1 + 12);
                  v25 = *(_QWORD *)(a1 + 32);
                  v26 = *(unsigned int *)(a1 + 28);
                  v23 = *(_QWORD *)(a1 + 88);
                  v24 = *(unsigned int *)(a1 + 20);
                  v13 = (TSTTableStrokeDefaults *)a1;
                  v14 = 8;
                  goto LABEL_65;
                }
                v25 = *(_QWORD *)(a1 + 32);
                v26 = *(unsigned int *)(a1 + 12);
                v23 = *(_QWORD *)(a1 + 88);
                v24 = *(unsigned int *)(a1 + 20);
                v13 = (TSTTableStrokeDefaults *)a1;
                v14 = 9;
              }
              else
              {
                if (v20)
                {
                  v27 = *(_QWORD *)(a1 + 120);
                  v28 = *(unsigned int *)(a1 + 12);
                  v25 = *(_QWORD *)(a1 + 40);
                  v26 = *(unsigned int *)(a1 + 28);
                  v23 = *(_QWORD *)(a1 + 96);
                  v24 = *(unsigned int *)(a1 + 20);
                  v13 = (TSTTableStrokeDefaults *)a1;
                  v14 = 6;
                  goto LABEL_65;
                }
                v25 = *(_QWORD *)(a1 + 40);
                v26 = *(unsigned int *)(a1 + 12);
                v23 = *(_QWORD *)(a1 + 96);
                v24 = *(unsigned int *)(a1 + 20);
                v13 = (TSTTableStrokeDefaults *)a1;
                v14 = 7;
              }
            }
          }
          else
          {
            if (*(_DWORD *)(a1 + 24))
            {
              v27 = *(_QWORD *)(a1 + 120);
              v28 = *(unsigned int *)(a1 + 12);
              v25 = *(_QWORD *)(a1 + 64);
              v26 = *(unsigned int *)(a1 + 28);
              v23 = *(_QWORD *)(a1 + 96);
              v24 = *(unsigned int *)(a1 + 20);
              v13 = (TSTTableStrokeDefaults *)a1;
              v14 = 2;
LABEL_65:
              v15 = 3;
              return TSTTableStrokeDefaultsStrokeArray(v13, v14, v15, v11, v12, 0, v23, v24, v25, v26, v27, v28);
            }
            v25 = *(_QWORD *)(a1 + 64);
            v26 = *(unsigned int *)(a1 + 12);
            v23 = *(_QWORD *)(a1 + 96);
            v24 = *(unsigned int *)(a1 + 20);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 3;
          }
        }
        else
        {
          if (*(_DWORD *)(a1 + 24))
          {
            v27 = *(_QWORD *)(a1 + 136);
            v28 = *(unsigned int *)(a1 + 12);
            v25 = *(_QWORD *)(a1 + 56);
            v26 = *(unsigned int *)(a1 + 28);
            v23 = *(_QWORD *)(a1 + 88);
            v24 = *(unsigned int *)(a1 + 20);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 0;
            goto LABEL_65;
          }
          v25 = *(_QWORD *)(a1 + 56);
          v26 = *(unsigned int *)(a1 + 12);
          v23 = *(_QWORD *)(a1 + 88);
          v24 = *(unsigned int *)(a1 + 20);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 1;
        }
      }
      else if ((_DWORD)v4)
      {
        if (v4 >= v17)
        {
          if ((_DWORD)v4 == v17)
          {
            if (!*(_DWORD *)(a1 + 24))
            {
              v23 = *(_QWORD *)(a1 + 80);
              v24 = *(unsigned int *)(a1 + 12);
              v13 = (TSTTableStrokeDefaults *)a1;
              v14 = 15;
              goto LABEL_15;
            }
            v25 = *(_QWORD *)(a1 + 120);
            v26 = *(unsigned int *)(a1 + 12);
            v23 = *(_QWORD *)(a1 + 80);
            v24 = *(unsigned int *)(a1 + 28);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 14;
          }
          else
          {
            v21 = *(_DWORD *)(a1 + 24);
            if (v4 >= *(_DWORD *)(a1 + 8))
            {
              if (!v21)
              {
                v23 = *(_QWORD *)(a1 + 32);
                v24 = *(unsigned int *)(a1 + 12);
                v13 = (TSTTableStrokeDefaults *)a1;
                v14 = 19;
                goto LABEL_15;
              }
              v25 = *(_QWORD *)(a1 + 136);
              v26 = *(unsigned int *)(a1 + 12);
              v23 = *(_QWORD *)(a1 + 32);
              v24 = *(unsigned int *)(a1 + 28);
              v13 = (TSTTableStrokeDefaults *)a1;
              v14 = 18;
            }
            else
            {
              if (!v21)
              {
                v23 = *(_QWORD *)(a1 + 40);
                v24 = *(unsigned int *)(a1 + 12);
                v13 = (TSTTableStrokeDefaults *)a1;
                v14 = 17;
                goto LABEL_15;
              }
              v25 = *(_QWORD *)(a1 + 120);
              v26 = *(unsigned int *)(a1 + 12);
              v23 = *(_QWORD *)(a1 + 40);
              v24 = *(unsigned int *)(a1 + 28);
              v13 = (TSTTableStrokeDefaults *)a1;
              v14 = 16;
            }
          }
        }
        else
        {
          if (!*(_DWORD *)(a1 + 24))
          {
            v23 = *(_QWORD *)(a1 + 64);
            v24 = *(unsigned int *)(a1 + 12);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 13;
            goto LABEL_15;
          }
          v25 = *(_QWORD *)(a1 + 120);
          v26 = *(unsigned int *)(a1 + 12);
          v23 = *(_QWORD *)(a1 + 64);
          v24 = *(unsigned int *)(a1 + 28);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 12;
        }
      }
      else
      {
        if (!*(_DWORD *)(a1 + 24))
        {
          v23 = *(_QWORD *)(a1 + 56);
          v24 = *(unsigned int *)(a1 + 12);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 11;
          goto LABEL_15;
        }
        v25 = *(_QWORD *)(a1 + 136);
        v26 = *(unsigned int *)(a1 + 12);
        v23 = *(_QWORD *)(a1 + 56);
        v24 = *(unsigned int *)(a1 + 28);
        v13 = (TSTTableStrokeDefaults *)a1;
        v14 = 10;
      }
    }
    else if (v16)
    {
      if ((_DWORD)v4)
      {
        v18 = *(_DWORD *)(a1 + 24);
        if (v4 >= *(_DWORD *)(a1 + 8))
        {
          if (v18)
          {
            v27 = *(_QWORD *)(a1 + 136);
            v28 = *(unsigned int *)(a1 + 12);
            v25 = *(_QWORD *)(a1 + 32);
            v26 = *(unsigned int *)(a1 + 28);
            v23 = *(_QWORD *)(a1 + 88);
            v24 = *(unsigned int *)(a1 + 20);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 24;
            goto LABEL_65;
          }
          v25 = *(_QWORD *)(a1 + 32);
          v26 = *(unsigned int *)(a1 + 12);
          v23 = *(_QWORD *)(a1 + 88);
          v24 = *(unsigned int *)(a1 + 20);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 25;
        }
        else
        {
          if (v18)
          {
            v27 = *(_QWORD *)(a1 + 120);
            v28 = *(unsigned int *)(a1 + 12);
            v25 = *(_QWORD *)(a1 + 40);
            v26 = *(unsigned int *)(a1 + 28);
            v23 = *(_QWORD *)(a1 + 96);
            v24 = *(unsigned int *)(a1 + 20);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 22;
            goto LABEL_65;
          }
          v25 = *(_QWORD *)(a1 + 40);
          v26 = *(unsigned int *)(a1 + 12);
          v23 = *(_QWORD *)(a1 + 96);
          v24 = *(unsigned int *)(a1 + 20);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 23;
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 24))
        {
          v27 = *(_QWORD *)(a1 + 136);
          v28 = *(unsigned int *)(a1 + 12);
          v25 = *(_QWORD *)(a1 + 32);
          v26 = *(unsigned int *)(a1 + 28);
          v23 = *(_QWORD *)(a1 + 88);
          v24 = *(unsigned int *)(a1 + 20);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 20;
          goto LABEL_65;
        }
        v25 = *(_QWORD *)(a1 + 32);
        v26 = *(unsigned int *)(a1 + 12);
        v23 = *(_QWORD *)(a1 + 88);
        v24 = *(unsigned int *)(a1 + 20);
        v13 = (TSTTableStrokeDefaults *)a1;
        v14 = 21;
      }
    }
    else if ((_DWORD)v4)
    {
      v19 = *(_DWORD *)(a1 + 24);
      if (v4 >= *(_DWORD *)(a1 + 8))
      {
        if (!v19)
        {
          v23 = *(_QWORD *)(a1 + 32);
          v24 = *(unsigned int *)(a1 + 12);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 31;
          goto LABEL_15;
        }
        v25 = *(_QWORD *)(a1 + 136);
        v26 = *(unsigned int *)(a1 + 12);
        v23 = *(_QWORD *)(a1 + 32);
        v24 = *(unsigned int *)(a1 + 28);
        v13 = (TSTTableStrokeDefaults *)a1;
        v14 = 30;
      }
      else
      {
        if (!v19)
        {
          v23 = *(_QWORD *)(a1 + 40);
          v24 = *(unsigned int *)(a1 + 12);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 29;
          goto LABEL_15;
        }
        v25 = *(_QWORD *)(a1 + 120);
        v26 = *(unsigned int *)(a1 + 12);
        v23 = *(_QWORD *)(a1 + 40);
        v24 = *(unsigned int *)(a1 + 28);
        v13 = (TSTTableStrokeDefaults *)a1;
        v14 = 28;
      }
    }
    else
    {
      if (!*(_DWORD *)(a1 + 24))
      {
        v23 = *(_QWORD *)(a1 + 32);
        v24 = *(unsigned int *)(a1 + 12);
        v13 = (TSTTableStrokeDefaults *)a1;
        v14 = 27;
        goto LABEL_15;
      }
      v25 = *(_QWORD *)(a1 + 136);
      v26 = *(unsigned int *)(a1 + 12);
      v23 = *(_QWORD *)(a1 + 32);
      v24 = *(unsigned int *)(a1 + 28);
      v13 = (TSTTableStrokeDefaults *)a1;
      v14 = 26;
    }
    v15 = 2;
    return TSTTableStrokeDefaultsStrokeArray(v13, v14, v15, v11, v12, 0, v23, v24, v25, v26, v27, v28);
  }
  return (TSTStrokeRunArray *)v7;
}

TSTStrokeRunArray *TSTTableStrokeDefaultsStrokeArray(TSTTableStrokeDefaults *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  TSTStrokeRunArray *v6;
  uint64_t v7;
  TSTStrokeRunArray *v8;

  if (*((_DWORD *)a1 + 40) <= a2)
    return 0;
  v6 = *(TSTStrokeRunArray **)(*((_QWORD *)a1 + 21) + 8 * a2);
  if (!v6)
  {
    v7 = a2;
    v6 = TSTStrokeRunArrayCreateWithArguments(a3, (uint64_t)&a4);
    v8 = v6;
    *(_QWORD *)(*((_QWORD *)a1 + 21) + 8 * v7) = v6;
  }
  return v6;
}

TSTStrokeRunArray *TSTTableStrokeDefaultsForRow(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  TSDStroke *v8;
  TSDStroke *v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  TSTTableStrokeDefaults *v13;
  unsigned int v14;
  uint64_t v15;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  TSDStroke *v27;

  v3 = *(_DWORD *)(a1 + 12);
  if (v3 >= a2)
    v4 = a2;
  else
    v4 = v3;
  v5 = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  v6 = *(_QWORD *)(a1 + 184);
  if (v6)
  {
    v7 = *(_QWORD *)(v6 + 8 * v4);
    if (!v7)
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 184) + 8 * v4) = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
      v27 = 0;
      TSTTableGetDefaultStrokesForRow(*(uint64_t **)a1, (unsigned __int16)v4, &v27, 0);
      v8 = v27;
      if (v8 == (TSDStroke *)objc_msgSend(MEMORY[0x24BDBCEF8], "null"))
        TSTTableGetDefaultStrokesForRow(*(uint64_t **)a1, (unsigned __int16)(v4 - 1), 0, &v27);
      v9 = v27;
      if (v9 != (TSDStroke *)objc_msgSend(MEMORY[0x24BDBCEF8], "null"))
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 184) + 8 * v4) = TSTStrokeRunArrayCreateWithStroke(v27, 0, *(_DWORD *)(a1 + 8));
        v10 = *(id *)(*(_QWORD *)(a1 + 184) + 8 * v4);
      }
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 184) + 8 * v4);
    }
  }
  else
  {
    v7 = v5;
  }
  if (v7 == objc_msgSend(MEMORY[0x24BDBCEF8], "null"))
  {
    if (*(_DWORD *)(a1 + 160) == 2)
    {
      v23 = *(_QWORD *)(a1 + 32);
      v24 = *(unsigned int *)(a1 + 8);
      v13 = (TSTTableStrokeDefaults *)a1;
      v14 = 1;
      goto LABEL_15;
    }
    v17 = *(_DWORD *)(a1 + 16);
    v18 = *(_DWORD *)(a1 + 20);
    if (v18)
    {
      if (!v17)
      {
        if ((_DWORD)v4)
        {
          if (v4 >= v18)
          {
            if ((_DWORD)v4 != v18)
            {
              if (*(_DWORD *)(a1 + 24))
              {
                v22 = *(_DWORD *)(a1 + 28);
                if ((_DWORD)v4 == v22)
                {
                  v23 = *(_QWORD *)(a1 + 144);
                  v24 = *(unsigned int *)(a1 + 8);
                  v13 = (TSTTableStrokeDefaults *)a1;
                  v14 = 43;
                  goto LABEL_15;
                }
                if (v4 >= *(_DWORD *)(a1 + 12))
                {
                  v23 = *(_QWORD *)(a1 + 136);
                  v24 = *(unsigned int *)(a1 + 8);
                  v13 = (TSTTableStrokeDefaults *)a1;
                  v14 = 45;
                  goto LABEL_15;
                }
                if (v4 > v22)
                {
                  v23 = *(_QWORD *)(a1 + 128);
                  v24 = *(unsigned int *)(a1 + 8);
                  v13 = (TSTTableStrokeDefaults *)a1;
                  v14 = 58;
                  goto LABEL_15;
                }
              }
              else if (v4 >= *(_DWORD *)(a1 + 12))
              {
                v23 = *(_QWORD *)(a1 + 32);
                v24 = *(unsigned int *)(a1 + 8);
                v13 = (TSTTableStrokeDefaults *)a1;
                v14 = 46;
                goto LABEL_15;
              }
              v23 = *(_QWORD *)(a1 + 48);
              v24 = *(unsigned int *)(a1 + 8);
              v13 = (TSTTableStrokeDefaults *)a1;
              v14 = 44;
              goto LABEL_15;
            }
            v23 = *(_QWORD *)(a1 + 112);
            v24 = *(unsigned int *)(a1 + 8);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 42;
          }
          else
          {
            v23 = *(_QWORD *)(a1 + 104);
            v24 = *(unsigned int *)(a1 + 8);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 41;
          }
        }
        else
        {
          v23 = *(_QWORD *)(a1 + 88);
          v24 = *(unsigned int *)(a1 + 8);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 40;
        }
LABEL_15:
        v15 = 1;
        return TSTTableStrokeDefaultsStrokeArray(v13, v14, v15, v11, v12, 0, v23, v24, v25, v26);
      }
      if (!(_DWORD)v4)
      {
        v23 = *(_QWORD *)(a1 + 88);
        v24 = *(unsigned int *)(a1 + 8);
        v13 = (TSTTableStrokeDefaults *)a1;
        v14 = 32;
        goto LABEL_15;
      }
      if (v4 < v18)
      {
        v23 = *(_QWORD *)(a1 + 104);
        v24 = *(unsigned int *)(a1 + 8);
        v13 = (TSTTableStrokeDefaults *)a1;
        v14 = 33;
        goto LABEL_15;
      }
      if ((_DWORD)v4 == v18)
      {
        v23 = *(_QWORD *)(a1 + 112);
        v24 = *(unsigned int *)(a1 + 8);
        v13 = (TSTTableStrokeDefaults *)a1;
        v14 = 34;
        goto LABEL_15;
      }
      if (*(_DWORD *)(a1 + 24))
      {
        v21 = *(_DWORD *)(a1 + 28);
        if ((_DWORD)v4 == v21)
        {
          v23 = *(_QWORD *)(a1 + 144);
          v24 = *(unsigned int *)(a1 + 8);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 35;
          goto LABEL_15;
        }
        if (v4 >= *(_DWORD *)(a1 + 12))
        {
          v23 = *(_QWORD *)(a1 + 136);
          v24 = *(unsigned int *)(a1 + 8);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 38;
          goto LABEL_15;
        }
        if (v4 > v21)
        {
          v23 = *(_QWORD *)(a1 + 128);
          v24 = *(unsigned int *)(a1 + 8);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 36;
          goto LABEL_15;
        }
        goto LABEL_67;
      }
      if (v4 < *(_DWORD *)(a1 + 12))
      {
LABEL_67:
        v25 = *(_QWORD *)(a1 + 48);
        v26 = *(unsigned int *)(a1 + 8);
        v23 = *(_QWORD *)(a1 + 72);
        v24 = *(unsigned int *)(a1 + 16);
        v13 = (TSTTableStrokeDefaults *)a1;
        v14 = 37;
        goto LABEL_68;
      }
      v25 = *(_QWORD *)(a1 + 32);
      v26 = *(unsigned int *)(a1 + 8);
      v23 = *(_QWORD *)(a1 + 56);
      v24 = *(unsigned int *)(a1 + 16);
      v13 = (TSTTableStrokeDefaults *)a1;
      v14 = 39;
    }
    else
    {
      if (!v17)
      {
        if (!(_DWORD)v4)
        {
          v23 = *(_QWORD *)(a1 + 32);
          v24 = *(unsigned int *)(a1 + 8);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 53;
          goto LABEL_15;
        }
        if (*(_DWORD *)(a1 + 24))
        {
          v20 = *(_DWORD *)(a1 + 28);
          if ((_DWORD)v4 == v20)
          {
            v23 = *(_QWORD *)(a1 + 144);
            v24 = *(unsigned int *)(a1 + 8);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 54;
            goto LABEL_15;
          }
          if (v4 >= *(_DWORD *)(a1 + 12))
          {
            v23 = *(_QWORD *)(a1 + 136);
            v24 = *(unsigned int *)(a1 + 8);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 56;
            goto LABEL_15;
          }
          if (v4 > v20)
          {
            v23 = *(_QWORD *)(a1 + 128);
            v24 = *(unsigned int *)(a1 + 8);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 59;
            goto LABEL_15;
          }
        }
        else if (v4 >= *(_DWORD *)(a1 + 12))
        {
          v23 = *(_QWORD *)(a1 + 32);
          v24 = *(unsigned int *)(a1 + 8);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 57;
          goto LABEL_15;
        }
        v23 = *(_QWORD *)(a1 + 48);
        v24 = *(unsigned int *)(a1 + 8);
        v13 = (TSTTableStrokeDefaults *)a1;
        v14 = 55;
        goto LABEL_15;
      }
      if ((_DWORD)v4)
      {
        if (*(_DWORD *)(a1 + 24))
        {
          v19 = *(_DWORD *)(a1 + 28);
          if ((_DWORD)v4 == v19)
          {
            v23 = *(_QWORD *)(a1 + 144);
            v24 = *(unsigned int *)(a1 + 8);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 48;
            goto LABEL_15;
          }
          if (v4 >= *(_DWORD *)(a1 + 12))
          {
            v23 = *(_QWORD *)(a1 + 136);
            v24 = *(unsigned int *)(a1 + 8);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 51;
            goto LABEL_15;
          }
          if (v4 > v19)
          {
            v23 = *(_QWORD *)(a1 + 128);
            v24 = *(unsigned int *)(a1 + 8);
            v13 = (TSTTableStrokeDefaults *)a1;
            v14 = 49;
            goto LABEL_15;
          }
        }
        else if (v4 >= *(_DWORD *)(a1 + 12))
        {
          v25 = *(_QWORD *)(a1 + 32);
          v26 = *(unsigned int *)(a1 + 8);
          v23 = *(_QWORD *)(a1 + 56);
          v24 = *(unsigned int *)(a1 + 16);
          v13 = (TSTTableStrokeDefaults *)a1;
          v14 = 52;
          goto LABEL_68;
        }
        v25 = *(_QWORD *)(a1 + 48);
        v26 = *(unsigned int *)(a1 + 8);
        v23 = *(_QWORD *)(a1 + 72);
        v24 = *(unsigned int *)(a1 + 16);
        v13 = (TSTTableStrokeDefaults *)a1;
        v14 = 50;
        goto LABEL_68;
      }
      v25 = *(_QWORD *)(a1 + 32);
      v26 = *(unsigned int *)(a1 + 8);
      v23 = *(_QWORD *)(a1 + 56);
      v24 = *(unsigned int *)(a1 + 16);
      v13 = (TSTTableStrokeDefaults *)a1;
      v14 = 47;
    }
LABEL_68:
    v15 = 2;
    return TSTTableStrokeDefaultsStrokeArray(v13, v14, v15, v11, v12, 0, v23, v24, v25, v26);
  }
  return (TSTStrokeRunArray *)v7;
}

BOOL TSTLayoutCellIteratorGetNextCell(uint64_t a1, _QWORD *a2)
{
  void *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  int *v12;
  unsigned int v13;
  void *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  unint64_t v18;
  unsigned int v19;
  unsigned __int8 v20;
  uint64_t v21;
  __int16 v22;
  unsigned int v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  _QWORD *v29;
  unint64_t v30;
  void *v31;
  signed int v32;
  _QWORD *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  unsigned int v38;
  int v39;
  id v40;

  v4 = (void *)objc_msgSend((id)a1, "masterLayout");
  v5 = *(unsigned __int16 *)(a1 + 186);
  v6 = *(_QWORD *)(a1 + 120);
  v7 = v6 + HIWORD(v6) - 1;
  v38 = HIDWORD(v6) + WORD1(v6) + 255;
  v8 = objc_msgSend(v4, "isDynamicallyChangingContent");
  v39 = objc_msgSend(v4, "isDynamicallyHidingRowsCols");
  v33 = a2;
  v9 = a2;
  v10 = v8;
  v9[1] = 0;
  *((_DWORD *)++v9 - 1) = 0xFFFFFF;
  v9[1] = 0;
  v9[2] = 0xFFFFFFLL;
  v29 = v9;
  v32 = v5 - 1;
  v11 = 0;
  v12 = &OBJC_IVAR___TSTCellStateForLayout_mKeyVal;
  v30 = v6 >> 16;
  v31 = v4;
  while (1)
  {
    v13 = *(unsigned __int16 *)(a1 + 128);
    if (v13 > (unsigned __int16)v7)
      return v13 <= (unsigned __int16)v7;
    if (!*(_BYTE *)(a1 + v12[164]))
    {
      *(_BYTE *)(a1 + 185) = TSTCellIteratorGetNextCell((void *)a1, (const char *)(a1 + 144));
      *(_BYTE *)(a1 + v12[164]) = 1;
    }
    if (v39)
      v11 |= objc_msgSend(v4, "isDynamicallyHidingRowsCols:rowColIndex:", 1, *(unsigned __int8 *)(a1 + 130));
    if (((v10 | v11) & 1) != 0)
    {
      v40 = 0;
      if ((v10 & 1) != 0)
      {
        v14 = (void *)objc_msgSend(v4, "dynamicContentDelegate");
        v34 = v34 & 0xFFFFFFFF00000000 | *(unsigned int *)(a1 + 128);
        if (objc_msgSend(v14, "cell:forCellID:", &v40))
          goto LABEL_13;
      }
      else if ((v11 & 1) != 0)
      {
        v40 = +[TSTCell cell](TSTCell, "cell");
LABEL_13:
        TSTCellClear(*(_QWORD *)(a1 + 136));
        TSTCellCopy((uint64_t)v40, *(_QWORD *)(a1 + 136));
        v33[1] = *(_QWORD *)(a1 + 136);
        v15 = *(unsigned int *)(a1 + 128);
        *((_DWORD *)v33 + 1) = v15;
        v35 = v35 & 0xFFFFFFFF00000000 | v15;
        v33[3] = TSTMasterLayoutMergeRangeAtCellID(v4, v15);
        if (*(_BYTE *)(a1 + 185) && ((*(_DWORD *)(a1 + 148) ^ *(_DWORD *)(a1 + 128)) & 0xFFFFFF) == 0)
          *(_BYTE *)(a1 + 185) = TSTCellIteratorGetNextCell((void *)a1, (const char *)(a1 + 144));
        v16 = 1;
LABEL_35:
        v12 = &OBJC_IVAR___TSTCellStateForLayout_mKeyVal;
        goto LABEL_36;
      }
    }
    if (*(unsigned __int16 *)(a1 + 128) >= *(unsigned __int16 *)(a1 + 190)
      || *(unsigned __int16 *)(a1 + 188) <= *(unsigned __int8 *)(a1 + 130))
    {
      if (objc_msgSend(v4, "isDynamicallyChangingRowOrColumnCount"))
      {
        v37 = v11;
        v17 = v10;
        v18 = v7;
        v19 = *(unsigned __int16 *)(a1 + 128);
        v20 = *(_BYTE *)(a1 + 130);
        v21 = *(unsigned __int8 *)(a1 + 131);
        if (v19 >= objc_msgSend(*(id *)(a1 + 8), "numberOfRows"))
        {
          v22 = objc_msgSend(*(id *)(a1 + 8), "numberOfRows");
          LOWORD(v19) = v22 + ~(unsigned __int16)objc_msgSend(*(id *)(a1 + 8), "numberOfFooterRows");
        }
        v23 = *(unsigned __int8 *)(a1 + 130);
        if (objc_msgSend(*(id *)(a1 + 8), "numberOfColumns") <= v23)
          v20 = objc_msgSend(*(id *)(a1 + 8), "numberOfColumns") - 1;
        v24 = (v21 << 24) | ((unint64_t)v20 << 16) | (unsigned __int16)v19;
        v36 = v24 | v36 & 0xFFFFFFFF00000000;
        v10 = v17;
        if (TSTCellAtCellID(*(_QWORD *)(a1 + 8), v24, *(void **)(a1 + 136)))
        {
          v16 = 0;
        }
        else
        {
          v25 = *(_QWORD *)(a1 + 136);
          TSTCellClearValue(v25);
          *(_DWORD *)(v25 + 8) &= 0xFFFF00FF;
          v33[1] = *(_QWORD *)(a1 + 136);
          *((_DWORD *)v33 + 1) = *(_DWORD *)(a1 + 128);
          v16 = 1;
        }
        v7 = v18;
        v4 = v31;
        v11 = v37;
        goto LABEL_35;
      }
    }
    else if (*(_BYTE *)(a1 + 185) && ((*(_DWORD *)(a1 + 148) ^ *(_DWORD *)(a1 + 128)) & 0xFFFFFF) == 0)
    {
      if ((objc_msgSend((id)a1, "dontExpandCellRefs") & 1) == 0 && *(_QWORD *)(a1 + 152))
      {
        TSTCellClear(*(_QWORD *)(a1 + 136));
        TSTCellCopy(*(_QWORD *)(a1 + 152), *(_QWORD *)(a1 + 136));
        *v29 = *(_QWORD *)(a1 + 136);
      }
      v33[2] = *(_QWORD *)(a1 + 160);
      *((_DWORD *)v33 + 1) = *(_DWORD *)(a1 + 148);
      v33[3] = *(_QWORD *)(a1 + 168);
      *(_BYTE *)(a1 + 185) = TSTCellIteratorGetNextCell((void *)a1, (const char *)(a1 + 144));
      v16 = 1;
      goto LABEL_36;
    }
    v16 = 0;
LABEL_36:
    v26 = objc_msgSend((id)a1, "rowWalkDirection");
    v27 = *(unsigned __int8 *)(a1 + 130);
    if (v26)
    {
      if (*(_BYTE *)(a1 + 130) && v27 > *(unsigned __int8 *)(a1 + 122))
      {
        *(_BYTE *)(a1 + 130) = v27 - 1;
        if (v16)
          return v13 <= (unsigned __int16)v7;
      }
      else
      {
        *(_BYTE *)(a1 + 130) = v38;
LABEL_47:
        ++*(_WORD *)(a1 + 128);
        if (v16)
          return v13 <= (unsigned __int16)v7;
      }
    }
    else
    {
      if (v32 <= (int)v27 || v27 >= v38)
      {
        *(_BYTE *)(a1 + 130) = v30;
        goto LABEL_47;
      }
      *(_BYTE *)(a1 + 130) = v27 + 1;
      if (v16)
        return v13 <= (unsigned __int16)v7;
    }
  }
}

uint64_t TSTLayoutCellIteratorValueTypeOfCell(uint64_t a1)
{
  uint64_t v2;

  if (*(_QWORD *)(a1 + 16))
    return TSTCellIteratorValueTypeOfCell(a1);
  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
    return *(unsigned __int8 *)(v2 + 9);
  else
    return 0;
}

uint64_t TSTLayoutCellIteratorExpandCell(uint64_t a1, uint64_t a2)
{
  if (!*(_QWORD *)(a2 + 8) && ((*(_DWORD *)(a1 + 128) ^ *(_DWORD *)(a2 + 4)) & 0xFFFFFF) == 0)
    return (uint64_t)TSTCellIteratorExpandCellForLayout(a1, a2);
  return a1;
}

uint64_t TSABundle()
{
  if (TSABundle::onceToken != -1)
    dispatch_once(&TSABundle::onceToken, &__block_literal_global_84);
  return TSABundle::bundle;
}

void sub_217BED39C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__32(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__32(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_217BED47C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

const __CFString *TSABuildVersionHistoryPrefix()
{
  return CFSTR("T");
}

uint64_t TSABuildVersionString()
{
  uint64_t v0;
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  BOOL v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _BYTE v32[128];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v0 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x24BDD1488], "mainBundle"), "bundlePath"), "stringByAppendingPathComponent:", CFSTR("Contents")), "stringByAppendingPathComponent:", CFSTR("version.plist"));
  if (!objc_msgSend((id)objc_msgSend(MEMORY[0x24BDD1580], "defaultManager"), "fileExistsAtPath:", v0)
    || ((v1 = (void *)objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithContentsOfFile:", v0),
         v2 = objc_msgSend(v1, "objectForKey:", CFSTR("CFBundleShortVersionString")),
         v3 = objc_msgSend(v1, "objectForKey:", CFSTR("CFBundleVersion")),
         v4 = objc_msgSend(v1, "objectForKey:", CFSTR("BuildVersion")),
         v2)
      ? (v5 = v3 == 0)
      : (v5 = 1),
        !v5 ? (v6 = v4 == 0) : (v6 = 1),
        v6
     || (v7 = (void *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@-%@-%@"), v2, v3, v4)) == 0))
  {
    v8 = objc_msgSend((id)objc_msgSend(MEMORY[0x24BDD1488], "mainBundle"), "pathForResource:ofType:", CFSTR("BuildVersion"), CFSTR("plist"));
    v7 = (void *)objc_msgSend((id)objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithContentsOfFile:", v8), "objectForKey:", CFSTR("build"));
    if (!v7)
    {
      v9 = objc_msgSend((id)objc_msgSend(MEMORY[0x24BDD1488], "mainBundle"), "pathForResource:ofType:inDirectory:", CFSTR("Root"), CFSTR("plist"), CFSTR("Settings.bundle"));
      v10 = (void *)objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithContentsOfFile:", v9);
      if (!v10
        || (v11 = (void *)objc_msgSend(v10, "objectForKey:", CFSTR("PreferenceSpecifiers"))) == 0
        || (v12 = v11,
            v30 = 0u,
            v31 = 0u,
            v28 = 0u,
            v29 = 0u,
            (v13 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v28, v32, 16)) == 0))
      {
LABEL_27:
        objc_msgSend(0, "isEqualToString:", CFSTR("Local Build"));
LABEL_28:
        v24 = objc_msgSend((id)objc_msgSend(MEMORY[0x24BDD1488], "mainBundle"), "bundlePath");
        if (!v24
          || (v25 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x24BDD1580], "defaultManager"), "attributesOfItemAtPath:error:", v24, 0), "fileModificationDate")) == 0|| (v7 = (void *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("local build-%@"), v25)) == 0)
        {
          v26 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", "Aug  3 2024", 4);
          v7 = (void *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("local build-%@"), v26);

        }
        return objc_msgSend(CFSTR("T"), "stringByAppendingString:", v7);
      }
      v14 = v13;
      v15 = *(_QWORD *)v29;
LABEL_15:
      v16 = 0;
      while (1)
      {
        if (*(_QWORD *)v29 != v15)
          objc_enumerationMutation(v12);
        v17 = *(void **)(*((_QWORD *)&v28 + 1) + 8 * v16);
        if (objc_msgSend((id)objc_msgSend(v17, "objectForKey:", CFSTR("Key")), "isEqualToString:", CFSTR("TSABuildID")))break;
        if (v14 == ++v16)
        {
          v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v28, v32, 16);
          if (v14)
            goto LABEL_15;
          goto LABEL_27;
        }
      }
      v18 = (void *)objc_msgSend(v17, "objectForKey:", CFSTR("Titles"));
      if (!v18)
        goto LABEL_27;
      v19 = v18;
      if (!objc_msgSend(v18, "count"))
        goto LABEL_27;
      v7 = (void *)objc_msgSend(v19, "objectAtIndex:", 0);
      v20 = objc_msgSend(v7, "rangeOfString:", CFSTR("-"));
      if (v20 != 0x7FFFFFFFFFFFFFFFLL)
      {
        v21 = v20;
        if (v20 == objc_msgSend(v7, "length") - 1)
        {
          v22 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v23 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSABuildVersionString()");
          objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/application/common/TSADocumentRoot.mm"), 2536, CFSTR("Not expecting to find a build version string with the only hyphen as the last character"));
        }
        else
        {
          v7 = (void *)objc_msgSend(v7, "substringFromIndex:", v21 + 1);
        }
      }
      if ((objc_msgSend(v7, "isEqualToString:", CFSTR("Local Build")) & 1) != 0 || !v7)
        goto LABEL_28;
    }
  }
  return objc_msgSend(CFSTR("T"), "stringByAppendingString:", v7);
}

NSArray *TSAUpdateBuildVersionHistory(NSArray *a1)
{
  NSArray *v1;
  uint64_t v2;

  v1 = a1;
  if (!a1)
    v1 = (NSArray *)objc_msgSend(MEMORY[0x24BDBCE30], "array");
  v2 = TSABuildVersionString();
  objc_opt_class();
  -[NSArray lastObject](v1, "lastObject");
  if ((objc_msgSend((id)TSUDynamicCast(), "isEqualToString:", v2) & 1) != 0 || !v2)
    return v1;
  else
    return -[NSArray arrayByAddingObject:](v1, "arrayByAddingObject:", v2);
}

void sub_217BF20A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

CFTimeInterval CACurrentMediaTime(void)
{
  CFTimeInterval result;

  MEMORY[0x24BDE5410]();
  return result;
}

CATransform3D *__cdecl CATransform3DConcat(CATransform3D *__return_ptr retstr, CATransform3D *a, CATransform3D *b)
{
  return (CATransform3D *)MEMORY[0x24BDE5578](retstr, a, b);
}

uint64_t CATransform3DInterpolate()
{
  return MEMORY[0x24BDE55A0]();
}

BOOL CATransform3DIsIdentity(CATransform3D *t)
{
  return MEMORY[0x24BDE55B8](t);
}

CATransform3D *__cdecl CATransform3DMakeAffineTransform(CATransform3D *__return_ptr retstr, CGAffineTransform *m)
{
  return (CATransform3D *)MEMORY[0x24BDE55C0](retstr, m);
}

CATransform3D *__cdecl CATransform3DMakeRotation(CATransform3D *__return_ptr retstr, CGFloat angle, CGFloat x, CGFloat y, CGFloat z)
{
  return (CATransform3D *)MEMORY[0x24BDE55C8](retstr, angle, x, y, z);
}

CATransform3D *__cdecl CATransform3DMakeScale(CATransform3D *__return_ptr retstr, CGFloat sx, CGFloat sy, CGFloat sz)
{
  return (CATransform3D *)MEMORY[0x24BDE55D0](retstr, sx, sy, sz);
}

CATransform3D *__cdecl CATransform3DMakeTranslation(CATransform3D *__return_ptr retstr, CGFloat tx, CGFloat ty, CGFloat tz)
{
  return (CATransform3D *)MEMORY[0x24BDE55D8](retstr, tx, ty, tz);
}

CATransform3D *__cdecl CATransform3DRotate(CATransform3D *__return_ptr retstr, CATransform3D *t, CGFloat angle, CGFloat x, CGFloat y, CGFloat z)
{
  return (CATransform3D *)MEMORY[0x24BDE55E8](retstr, t, angle, x, y, z);
}

CATransform3D *__cdecl CATransform3DScale(CATransform3D *__return_ptr retstr, CATransform3D *t, CGFloat sx, CGFloat sy, CGFloat sz)
{
  return (CATransform3D *)MEMORY[0x24BDE55F8](retstr, t, sx, sy, sz);
}

CATransform3D *__cdecl CATransform3DTranslate(CATransform3D *__return_ptr retstr, CATransform3D *t, CGFloat tx, CGFloat ty, CGFloat tz)
{
  return (CATransform3D *)MEMORY[0x24BDE5600](retstr, t, tx, ty, tz);
}

CCCryptorStatus CCCryptorCreate(CCOperation op, CCAlgorithm alg, CCOptions options, const void *key, size_t keyLength, const void *iv, CCCryptorRef *cryptorRef)
{
  return MEMORY[0x24BDAC110](*(_QWORD *)&op, *(_QWORD *)&alg, *(_QWORD *)&options, key, keyLength, iv, cryptorRef);
}

CCCryptorStatus CCCryptorFinal(CCCryptorRef cryptorRef, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return MEMORY[0x24BDAC130](cryptorRef, dataOut, dataOutAvailable, dataOutMoved);
}

size_t CCCryptorGetOutputLength(CCCryptorRef cryptorRef, size_t inputLength, BOOL final)
{
  return MEMORY[0x24BDAC178](cryptorRef, inputLength, final);
}

CCCryptorStatus CCCryptorRelease(CCCryptorRef cryptorRef)
{
  return MEMORY[0x24BDAC188](cryptorRef);
}

CCCryptorStatus CCCryptorUpdate(CCCryptorRef cryptorRef, const void *dataIn, size_t dataInLength, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return MEMORY[0x24BDAC198](cryptorRef, dataIn, dataInLength, dataOut, dataOutAvailable, dataOutMoved);
}

void CCHmacFinal(CCHmacContext *ctx, void *macOut)
{
  MEMORY[0x24BDAC240](ctx, macOut);
}

void CCHmacInit(CCHmacContext *ctx, CCHmacAlgorithm algorithm, const void *key, size_t keyLength)
{
  MEMORY[0x24BDAC248](ctx, *(_QWORD *)&algorithm, key, keyLength);
}

void CCHmacUpdate(CCHmacContext *ctx, const void *data, size_t dataLength)
{
  MEMORY[0x24BDAC250](ctx, data, dataLength);
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x24BDAC320](data, *(_QWORD *)&len, md);
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return MEMORY[0x24BDAC328](md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return MEMORY[0x24BDAC330](c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x24BDAC338](c, data, *(_QWORD *)&len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x24BDBB780]();
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x24BDBB7C8](theArray, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x24BDBB7F0](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x24BDBB7F8](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x24BDBB808](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x24BDBB820](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x24BDBB838](theArray, range.location, range.length, value);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x24BDBB860](theArray, idx);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x24BDBB870](theArray, idx, value);
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
  MEMORY[0x24BDBB878](theArray);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x24BDBB880](theArray, idx);
}

CFAttributedStringRef CFAttributedStringCreate(CFAllocatorRef alloc, CFStringRef str, CFDictionaryRef attributes)
{
  return (CFAttributedStringRef)MEMORY[0x24BDBB8B0](alloc, str, attributes);
}

CFMutableAttributedStringRef CFAttributedStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableAttributedStringRef)MEMORY[0x24BDBB8C0](alloc, maxLength);
}

CFTypeRef CFAttributedStringGetAttribute(CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange *effectiveRange)
{
  return (CFTypeRef)MEMORY[0x24BDBB8E0](aStr, loc, attrName, effectiveRange);
}

CFTypeRef CFAttributedStringGetAttributeAndLongestEffectiveRange(CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange inRange, CFRange *longestEffectiveRange)
{
  return (CFTypeRef)MEMORY[0x24BDBB8E8](aStr, loc, attrName, inRange.location, inRange.length, longestEffectiveRange);
}

CFIndex CFAttributedStringGetLength(CFAttributedStringRef aStr)
{
  return MEMORY[0x24BDBB900](aStr);
}

CFStringRef CFAttributedStringGetString(CFAttributedStringRef aStr)
{
  return (CFStringRef)MEMORY[0x24BDBB908](aStr);
}

void CFAttributedStringReplaceString(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef replacement)
{
  MEMORY[0x24BDBB918](aStr, range.location, range.length, replacement);
}

void CFAttributedStringSetAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName, CFTypeRef value)
{
  MEMORY[0x24BDBB920](aStr, range.location, range.length, attrName, value);
}

void CFAttributedStringSetAttributes(CFMutableAttributedStringRef aStr, CFRange range, CFDictionaryRef replacement, Boolean clearOtherAttributes)
{
  MEMORY[0x24BDBB928](aStr, range.location, range.length, replacement, clearOtherAttributes);
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  return (CFTypeRef)MEMORY[0x24BDBB930](arg);
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x24BDBBA20](BOOLean);
}

void CFCharacterSetAddCharactersInRange(CFMutableCharacterSetRef theSet, CFRange theRange)
{
  MEMORY[0x24BDBBBE0](theSet, theRange.location, theRange.length);
}

void CFCharacterSetAddCharactersInString(CFMutableCharacterSetRef theSet, CFStringRef theString)
{
  MEMORY[0x24BDBBBE8](theSet, theString);
}

CFMutableCharacterSetRef CFCharacterSetCreateMutable(CFAllocatorRef alloc)
{
  return (CFMutableCharacterSetRef)MEMORY[0x24BDBBC00](alloc);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x24BDBBC18](alloc, theString);
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  return (CFCharacterSetRef)MEMORY[0x24BDBBC20](theSetIdentifier);
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  return MEMORY[0x24BDBBC30](theSet, theChar);
}

Boolean CFCharacterSetIsLongCharacterMember(CFCharacterSetRef theSet, UTF32Char theChar)
{
  return MEMORY[0x24BDBBC38](theSet, *(_QWORD *)&theChar);
}

void CFCharacterSetRemoveCharactersInRange(CFMutableCharacterSetRef theSet, CFRange theRange)
{
  MEMORY[0x24BDBBC40](theSet, theRange.location, theRange.length);
}

void CFCharacterSetUnion(CFMutableCharacterSetRef theSet, CFCharacterSetRef theOtherSet)
{
  MEMORY[0x24BDBBC50](theSet, theOtherSet);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x24BDBBCB0](allocator, capacity);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x24BDBBCF8](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x24BDBBD00](theData);
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
  MEMORY[0x24BDBBD20](theData, length);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBDB0](theDict, key, value);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x24BDBBDC0](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x24BDBBDD8](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF0](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x24BDBBE00](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x24BDBBE10](theDict, keys, values);
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x24BDBBE30](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x24BDBBE38](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  MEMORY[0x24BDBBE40](theDict);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x24BDBBE48](theDict, key);
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBE50](theDict, key, value);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBE60](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x24BDBBE68](cf1, cf2);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x24BDBBEF8](cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x24BDBBF10](cf);
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)MEMORY[0x24BDBBF28]();
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x24BDBBF48](allocator, localeIdentifier);
}

CFLocaleRef CFLocaleGetSystem(void)
{
  return (CFLocaleRef)MEMORY[0x24BDBBF88]();
}

CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey key)
{
  return (CFTypeRef)MEMORY[0x24BDBBF98](locale, key);
}

Boolean CFNumberFormatterGetDecimalInfoForCurrencyCode(CFStringRef currencyCode, int32_t *defaultFractionDigits, double *roundingIncrement)
{
  return MEMORY[0x24BDBC0D8](currencyCode, defaultFractionDigits, roundingIncrement);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x24BDBC2A8](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  MEMORY[0x24BDBC2C8](rl, source, mode);
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x24BDBC300]();
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
  MEMORY[0x24BDBC338](rl, mode, block);
}

CFRunLoopRunResult CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  return MEMORY[0x24BDBC360](mode, returnAfterSourceHandled, seconds);
}

CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  return (CFRunLoopSourceRef)MEMORY[0x24BDBC370](allocator, order, context);
}

void CFRunLoopSourceInvalidate(CFRunLoopSourceRef source)
{
  MEMORY[0x24BDBC378](source);
}

void CFRunLoopSourceSignal(CFRunLoopSourceRef source)
{
  MEMORY[0x24BDBC380](source);
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
  MEMORY[0x24BDBC3B8](rl);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x24BDBC3C0](theSet, value);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x24BDBC3E8](allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x24BDBC3F8](theSet);
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x24BDBC428](theSet, value);
}

void CFStringCapitalize(CFMutableStringRef theString, CFLocaleRef locale)
{
  MEMORY[0x24BDBC4C8](theString, locale);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x24BDBC4D0](theString1, theString2, compareOptions);
}

unint64_t CFStringConvertEncodingToNSStringEncoding(CFStringEncoding encoding)
{
  return MEMORY[0x24BDBC4F0](*(_QWORD *)&encoding);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x24BDBC520](alloc, theString);
}

CFMutableStringRef CFStringCreateMutableWithExternalCharactersNoCopy(CFAllocatorRef alloc, UniChar *chars, CFIndex numChars, CFIndex capacity, CFAllocatorRef externalCharactersAllocator)
{
  return (CFMutableStringRef)MEMORY[0x24BDBC548](alloc, chars, numChars, capacity, externalCharactersAllocator);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)MEMORY[0x24BDBC580](alloc, chars, numChars);
}

CFStringRef CFStringCreateWithCharactersNoCopy(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x24BDBC588](alloc, chars, numChars, contentsDeallocator);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x24BDBC610](theString, *(_QWORD *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x24BDBC618](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
  MEMORY[0x24BDBC620](theString, range.location, range.length, buffer);
}

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  return (const UniChar *)MEMORY[0x24BDBC628](theString);
}

CFIndex CFStringGetHyphenationLocationBeforeIndex(CFStringRef string, CFIndex location, CFRange limitRange, CFOptionFlags options, CFLocaleRef locale, UTF32Char *character)
{
  return MEMORY[0x24BDBC648](string, location, limitRange.location, limitRange.length, options, locale, character);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x24BDBC658](theString);
}

CFRange CFStringGetRangeOfComposedCharactersAtIndex(CFStringRef theString, CFIndex theIndex)
{
  CFIndex v2;
  CFIndex v3;
  CFRange result;

  v2 = MEMORY[0x24BDBC680](theString, theIndex);
  result.length = v3;
  result.location = v2;
  return result;
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x24BDBC6A8](theString, prefix);
}

CFStringTokenizerTokenType CFStringTokenizerAdvanceToNextToken(CFStringTokenizerRef tokenizer)
{
  return MEMORY[0x24BDBC6F8](tokenizer);
}

CFStringRef CFStringTokenizerCopyBestStringLanguage(CFStringRef string, CFRange range)
{
  return (CFStringRef)MEMORY[0x24BDBC700](string, range.location, range.length);
}

CFTypeRef CFStringTokenizerCopyCurrentTokenAttribute(CFStringTokenizerRef tokenizer, CFOptionFlags attribute)
{
  return (CFTypeRef)MEMORY[0x24BDBC708](tokenizer, attribute);
}

CFStringTokenizerRef CFStringTokenizerCreate(CFAllocatorRef alloc, CFStringRef string, CFRange range, CFOptionFlags options, CFLocaleRef locale)
{
  return (CFStringTokenizerRef)MEMORY[0x24BDBC710](alloc, string, range.location, range.length, options, locale);
}

CFRange CFStringTokenizerGetCurrentTokenRange(CFStringTokenizerRef tokenizer)
{
  CFIndex v1;
  CFIndex v2;
  CFRange result;

  v1 = MEMORY[0x24BDBC718](tokenizer);
  result.length = v2;
  result.location = v1;
  return result;
}

CFStringTokenizerTokenType CFStringTokenizerGoToTokenAtIndex(CFStringTokenizerRef tokenizer, CFIndex index)
{
  return MEMORY[0x24BDBC720](tokenizer, index);
}

Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse)
{
  return MEMORY[0x24BDBC730](string, range, transform, reverse);
}

void CFStringUppercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  MEMORY[0x24BDBC748](theString, locale);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x24BDBC798](anURL, pathStyle);
}

CFStringRef CFURLCreateStringByAddingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveUnescaped, CFStringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x24BDBC838](allocator, originalString, charactersToLeaveUnescaped, legalURLCharactersToBeEscaped, *(_QWORD *)&encoding);
}

CFStringRef CFURLCreateStringByReplacingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x24BDBC840](allocator, originalString, charactersToLeaveEscaped);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x24BDBC858](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPathRelativeToBase(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x24BDBC860](allocator, filePath, pathStyle, isDirectory, baseURL);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x24BDBC8D0](alloc);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x24BDBC8E8](alloc, uuid);
}

CGAffineTransform *__cdecl CGAffineTransformConcat(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t1, CGAffineTransform *t2)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8A0](retstr, t1, t2);
}

BOOL CGAffineTransformEqualToTransform(CGAffineTransform *t1, CGAffineTransform *t2)
{
  return MEMORY[0x24BDBD8B0](t1, t2);
}

CGAffineTransform *__cdecl CGAffineTransformInvert(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8C0](retstr, t);
}

BOOL CGAffineTransformIsIdentity(CGAffineTransform *t)
{
  return MEMORY[0x24BDBD8C8](t);
}

CGAffineTransform *__cdecl CGAffineTransformMakeRotation(CGAffineTransform *__return_ptr retstr, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8D8](retstr, angle);
}

CGAffineTransform *__cdecl CGAffineTransformMakeScale(CGAffineTransform *__return_ptr retstr, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8E0](retstr, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformMakeTranslation(CGAffineTransform *__return_ptr retstr, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8E8](retstr, tx, ty);
}

CGAffineTransform *__cdecl CGAffineTransformRotate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8F8](retstr, t, angle);
}

CGAffineTransform *__cdecl CGAffineTransformScale(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD900](retstr, t, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformTranslate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD908](retstr, t, tx, ty);
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return (CGContextRef)MEMORY[0x24BDBD918](data, width, height, bitsPerComponent, bytesPerRow, space, *(_QWORD *)&bitmapInfo);
}

CGImageRef CGBitmapContextCreateImage(CGContextRef context)
{
  return (CGImageRef)MEMORY[0x24BDBD920](context);
}

CGContextRef CGBitmapContextCreateWithData(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo, CGBitmapContextReleaseDataCallback releaseCallback, void *releaseInfo)
{
  return (CGContextRef)MEMORY[0x24BDBD930](data, width, height, bitsPerComponent, bytesPerRow, space, *(_QWORD *)&bitmapInfo, releaseCallback);
}

size_t CGBitmapContextGetBytesPerRow(CGContextRef context)
{
  return MEMORY[0x24BDBD958](context);
}

void *__cdecl CGBitmapContextGetData(CGContextRef context)
{
  return (void *)MEMORY[0x24BDBD968](context);
}

CGColorRef CGColorCreate(CGColorSpaceRef space, const CGFloat *components)
{
  return (CGColorRef)MEMORY[0x24BDBDA78](space, components);
}

CGColorRef CGColorCreateCopy(CGColorRef color)
{
  return (CGColorRef)MEMORY[0x24BDBDA80](color);
}

CGColorRef CGColorCreateCopyByMatchingToColorSpace(CGColorSpaceRef a1, CGColorRenderingIntent intent, CGColorRef color, CFDictionaryRef options)
{
  return (CGColorRef)MEMORY[0x24BDBDA88](a1, *(_QWORD *)&intent, color, options);
}

CGColorRef CGColorCreateCopyWithAlpha(CGColorRef color, CGFloat alpha)
{
  return (CGColorRef)MEMORY[0x24BDBDA90](color, alpha);
}

BOOL CGColorEqualToColor(CGColorRef color1, CGColorRef color2)
{
  return MEMORY[0x24BDBDAC0](color1, color2);
}

CGFloat CGColorGetAlpha(CGColorRef color)
{
  CGFloat result;

  MEMORY[0x24BDBDAE8](color);
  return result;
}

CGColorSpaceRef CGColorGetColorSpace(CGColorRef color)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBDAF0](color);
}

const CGFloat *__cdecl CGColorGetComponents(CGColorRef color)
{
  return (const CGFloat *)MEMORY[0x24BDBDAF8](color);
}

CFTypeID CGColorGetTypeID(void)
{
  return MEMORY[0x24BDBDB20]();
}

void CGColorRelease(CGColorRef color)
{
  MEMORY[0x24BDBDB40](color);
}

CGColorRef CGColorRetain(CGColorRef color)
{
  return (CGColorRef)MEMORY[0x24BDBDB48](color);
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBDB88]();
}

CGColorSpaceRef CGColorSpaceCreateWithName(CFStringRef name)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBDBB8](name);
}

CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef space)
{
  return MEMORY[0x24BDBDC10](space);
}

BOOL CGColorSpaceIsWideGamutRGB(CGColorSpaceRef a1)
{
  return MEMORY[0x24BDBDC58](a1);
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
  MEMORY[0x24BDBDC60](space);
}

CGColorSpaceRef CGColorSpaceRetain(CGColorSpaceRef space)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBDC68](space);
}

void CGContextAddCurveToPoint(CGContextRef c, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBDCC0](c, cp1x, cp1y, cp2x, cp2y, x, y);
}

void CGContextAddEllipseInRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x24BDBDCC8](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextAddLineToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBDCD0](c, x, y);
}

void CGContextAddPath(CGContextRef c, CGPathRef path)
{
  MEMORY[0x24BDBDCE0](c, path);
}

void CGContextAddQuadCurveToPoint(CGContextRef c, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBDCE8](c, cpx, cpy, x, y);
}

void CGContextAddRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x24BDBDCF0](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextBeginPage(CGContextRef c, const CGRect *mediaBox)
{
  MEMORY[0x24BDBDCF8](c, mediaBox);
}

void CGContextBeginPath(CGContextRef c)
{
  MEMORY[0x24BDBDD00](c);
}

void CGContextBeginTransparencyLayer(CGContextRef c, CFDictionaryRef auxiliaryInfo)
{
  MEMORY[0x24BDBDD08](c, auxiliaryInfo);
}

void CGContextBeginTransparencyLayerWithRect(CGContextRef c, CGRect rect, CFDictionaryRef auxInfo)
{
  MEMORY[0x24BDBDD10](c, auxInfo, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextClearRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x24BDBDD20](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextClip(CGContextRef c)
{
  MEMORY[0x24BDBDD28](c);
}

void CGContextClipToMask(CGContextRef c, CGRect rect, CGImageRef mask)
{
  MEMORY[0x24BDBDD30](c, mask, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextClipToRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x24BDBDD38](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextClipToRects(CGContextRef c, const CGRect *rects, size_t count)
{
  MEMORY[0x24BDBDD40](c, rects, count);
}

void CGContextClosePath(CGContextRef c)
{
  MEMORY[0x24BDBDD48](c);
}

void CGContextConcatCTM(CGContextRef c, CGAffineTransform *transform)
{
  MEMORY[0x24BDBDD50](c, transform);
}

CGPoint CGContextConvertPointToDeviceSpace(CGContextRef c, CGPoint point)
{
  double v2;
  double v3;
  CGPoint result;

  MEMORY[0x24BDBDD58](c, (__n128)point, *(__n128 *)&point.y);
  result.y = v3;
  result.x = v2;
  return result;
}

CGPoint CGContextConvertPointToUserSpace(CGContextRef c, CGPoint point)
{
  double v2;
  double v3;
  CGPoint result;

  MEMORY[0x24BDBDD60](c, (__n128)point, *(__n128 *)&point.y);
  result.y = v3;
  result.x = v2;
  return result;
}

CGRect CGContextConvertRectToDeviceSpace(CGContextRef c, CGRect rect)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDBDD68](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

CGRect CGContextConvertRectToUserSpace(CGContextRef c, CGRect rect)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDBDD70](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

CGSize CGContextConvertSizeToDeviceSpace(CGContextRef c, CGSize size)
{
  double v2;
  double v3;
  CGSize result;

  MEMORY[0x24BDBDD78](c, (__n128)size, *(__n128 *)&size.height);
  result.height = v3;
  result.width = v2;
  return result;
}

CGSize CGContextConvertSizeToUserSpace(CGContextRef c, CGSize size)
{
  double v2;
  double v3;
  CGSize result;

  MEMORY[0x24BDBDD80](c, (__n128)size, *(__n128 *)&size.height);
  result.height = v3;
  result.width = v2;
  return result;
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
  MEMORY[0x24BDBDDD8](c, image, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextDrawLayerInRect(CGContextRef context, CGRect rect, CGLayerRef layer)
{
  MEMORY[0x24BDBDDF0](context, layer, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextDrawLinearGradient(CGContextRef c, CGGradientRef gradient, CGPoint startPoint, CGPoint endPoint, CGGradientDrawingOptions options)
{
  MEMORY[0x24BDBDDF8](c, gradient, *(_QWORD *)&options, (__n128)startPoint, *(__n128 *)&startPoint.y, (__n128)endPoint, *(__n128 *)&endPoint.y);
}

void CGContextDrawPDFPage(CGContextRef c, CGPDFPageRef page)
{
  MEMORY[0x24BDBDE00](c, page);
}

void CGContextDrawPath(CGContextRef c, CGPathDrawingMode mode)
{
  MEMORY[0x24BDBDE18](c, *(_QWORD *)&mode);
}

void CGContextDrawShading(CGContextRef c, CGShadingRef shading)
{
  MEMORY[0x24BDBDE30](c, shading);
}

void CGContextDrawTiledImage(CGContextRef c, CGRect rect, CGImageRef image)
{
  MEMORY[0x24BDBDE38](c, image, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextEOClip(CGContextRef c)
{
  MEMORY[0x24BDBDE40](c);
}

void CGContextEOFillPath(CGContextRef c)
{
  MEMORY[0x24BDBDE48](c);
}

void CGContextEndPage(CGContextRef c)
{
  MEMORY[0x24BDBDE50](c);
}

void CGContextEndTransparencyLayer(CGContextRef c)
{
  MEMORY[0x24BDBDE58](c);
}

void CGContextFillEllipseInRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x24BDBDE60](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextFillPath(CGContextRef c)
{
  MEMORY[0x24BDBDE68](c);
}

void CGContextFillRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x24BDBDE70](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextFlush(CGContextRef c)
{
  MEMORY[0x24BDBDE78](c);
}

CGAffineTransform *__cdecl CGContextGetCTM(CGAffineTransform *__return_ptr retstr, CGContextRef c)
{
  return (CGAffineTransform *)MEMORY[0x24BDBDE98](retstr, c);
}

CGRect CGContextGetClipBoundingBox(CGContextRef c)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x24BDBDEA0](c);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGAffineTransform *__cdecl CGContextGetUserSpaceToDeviceSpaceTransform(CGAffineTransform *__return_ptr retstr, CGContextRef c)
{
  return (CGAffineTransform *)MEMORY[0x24BDBDF18](retstr, c);
}

void CGContextMoveToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBDF20](c, x, y);
}

void CGContextRelease(CGContextRef c)
{
  MEMORY[0x24BDBDF30](c);
}

void CGContextReplacePathWithStrokedPath(CGContextRef c)
{
  MEMORY[0x24BDBDF38](c);
}

void CGContextRestoreGState(CGContextRef c)
{
  MEMORY[0x24BDBDF58](c);
}

CGContextRef CGContextRetain(CGContextRef c)
{
  return (CGContextRef)MEMORY[0x24BDBDF60](c);
}

void CGContextRotateCTM(CGContextRef c, CGFloat angle)
{
  MEMORY[0x24BDBDF68](c, angle);
}

void CGContextSaveGState(CGContextRef c)
{
  MEMORY[0x24BDBDF70](c);
}

void CGContextScaleCTM(CGContextRef c, CGFloat sx, CGFloat sy)
{
  MEMORY[0x24BDBDF78](c, sx, sy);
}

void CGContextSetAllowsFontSmoothing(CGContextRef c, BOOL allowsFontSmoothing)
{
  MEMORY[0x24BDBDF88](c, allowsFontSmoothing);
}

void CGContextSetAllowsFontSubpixelQuantization(CGContextRef c, BOOL allowsFontSubpixelQuantization)
{
  MEMORY[0x24BDBDF98](c, allowsFontSubpixelQuantization);
}

void CGContextSetAlpha(CGContextRef c, CGFloat alpha)
{
  MEMORY[0x24BDBDFA0](c, alpha);
}

void CGContextSetBlendMode(CGContextRef c, CGBlendMode mode)
{
  MEMORY[0x24BDBDFB0](c, *(_QWORD *)&mode);
}

void CGContextSetFillColorWithColor(CGContextRef c, CGColorRef color)
{
  MEMORY[0x24BDBDFD8](c, color);
}

void CGContextSetFlatness(CGContextRef c, CGFloat flatness)
{
  MEMORY[0x24BDBDFE8](c, flatness);
}

void CGContextSetGrayFillColor(CGContextRef c, CGFloat gray, CGFloat alpha)
{
  MEMORY[0x24BDBE008](c, gray, alpha);
}

void CGContextSetInterpolationQuality(CGContextRef c, CGInterpolationQuality quality)
{
  MEMORY[0x24BDBE018](c, *(_QWORD *)&quality);
}

void CGContextSetLineCap(CGContextRef c, CGLineCap cap)
{
  MEMORY[0x24BDBE020](c, *(_QWORD *)&cap);
}

void CGContextSetLineDash(CGContextRef c, CGFloat phase, const CGFloat *lengths, size_t count)
{
  MEMORY[0x24BDBE028](c, lengths, count, phase);
}

void CGContextSetLineJoin(CGContextRef c, CGLineJoin join)
{
  MEMORY[0x24BDBE030](c, *(_QWORD *)&join);
}

void CGContextSetLineWidth(CGContextRef c, CGFloat width)
{
  MEMORY[0x24BDBE038](c, width);
}

void CGContextSetMiterLimit(CGContextRef c, CGFloat limit)
{
  MEMORY[0x24BDBE048](c, limit);
}

void CGContextSetRGBFillColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  MEMORY[0x24BDBE060](c, red, green, blue, alpha);
}

void CGContextSetRGBStrokeColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  MEMORY[0x24BDBE068](c, red, green, blue, alpha);
}

void CGContextSetShadow(CGContextRef c, CGSize offset, CGFloat blur)
{
  MEMORY[0x24BDBE078](c, (__n128)offset, *(__n128 *)&offset.height, blur);
}

void CGContextSetShadowWithColor(CGContextRef c, CGSize offset, CGFloat blur, CGColorRef color)
{
  MEMORY[0x24BDBE080](c, color, (__n128)offset, *(__n128 *)&offset.height, blur);
}

void CGContextSetShouldAntialias(CGContextRef c, BOOL shouldAntialias)
{
  MEMORY[0x24BDBE088](c, shouldAntialias);
}

void CGContextSetShouldSmoothFonts(CGContextRef c, BOOL shouldSmoothFonts)
{
  MEMORY[0x24BDBE098](c, shouldSmoothFonts);
}

void CGContextSetShouldSubpixelQuantizeFonts(CGContextRef c, BOOL shouldSubpixelQuantizeFonts)
{
  MEMORY[0x24BDBE0A8](c, shouldSubpixelQuantizeFonts);
}

void CGContextSetStrokeColorWithColor(CGContextRef c, CGColorRef color)
{
  MEMORY[0x24BDBE0D0](c, color);
}

void CGContextSetTextDrawingMode(CGContextRef c, CGTextDrawingMode mode)
{
  MEMORY[0x24BDBE0E0](c, *(_QWORD *)&mode);
}

void CGContextSetTextMatrix(CGContextRef c, CGAffineTransform *t)
{
  MEMORY[0x24BDBE0F0](c, t);
}

void CGContextSetTextPosition(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBE0F8](c, x, y);
}

void CGContextStrokePath(CGContextRef c)
{
  MEMORY[0x24BDBE118](c);
}

void CGContextStrokeRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x24BDBE120](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextStrokeRectWithWidth(CGContextRef c, CGRect rect, CGFloat width)
{
  MEMORY[0x24BDBE128](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, width);
}

void CGContextTranslateCTM(CGContextRef c, CGFloat tx, CGFloat ty)
{
  MEMORY[0x24BDBE130](c, tx, ty);
}

CGDataConsumerRef CGDataConsumerCreateWithCFData(CFMutableDataRef data)
{
  return (CGDataConsumerRef)MEMORY[0x24BDBE148](data);
}

void CGDataConsumerRelease(CGDataConsumerRef consumer)
{
  MEMORY[0x24BDBE160](consumer);
}

CGDataProviderRef CGDataProviderCreateSequential(void *info, const CGDataProviderSequentialCallbacks *callbacks)
{
  return (CGDataProviderRef)MEMORY[0x24BDBE178](info, callbacks);
}

CGDataProviderRef CGDataProviderCreateWithCFData(CFDataRef data)
{
  return (CGDataProviderRef)MEMORY[0x24BDBE180](data);
}

CGDataProviderRef CGDataProviderCreateWithData(void *info, const void *data, size_t size, CGDataProviderReleaseDataCallback releaseData)
{
  return (CGDataProviderRef)MEMORY[0x24BDBE190](info, data, size, releaseData);
}

CGDataProviderRef CGDataProviderCreateWithFilename(const char *filename)
{
  return (CGDataProviderRef)MEMORY[0x24BDBE198](filename);
}

CGDataProviderRef CGDataProviderCreateWithURL(CFURLRef url)
{
  return (CGDataProviderRef)MEMORY[0x24BDBE1A0](url);
}

void CGDataProviderRelease(CGDataProviderRef provider)
{
  MEMORY[0x24BDBE1C8](provider);
}

CGFontRef CGFontCreateWithDataProvider(CGDataProviderRef provider)
{
  return (CGFontRef)MEMORY[0x24BDBE2D8](provider);
}

int CGFontGetAscent(CGFontRef font)
{
  return MEMORY[0x24BDBE2E8](font);
}

int CGFontGetDescent(CGFontRef font)
{
  return MEMORY[0x24BDBE2F0](font);
}

BOOL CGFontGetGlyphAdvances(CGFontRef font, const CGGlyph *glyphs, size_t count, int *advances)
{
  return MEMORY[0x24BDBE308](font, glyphs, count, advances);
}

int CGFontGetUnitsPerEm(CGFontRef font)
{
  return MEMORY[0x24BDBE350](font);
}

void CGFontRelease(CGFontRef font)
{
  MEMORY[0x24BDBE3C8](font);
}

CGFontRef CGFontRetain(CGFontRef font)
{
  return (CGFontRef)MEMORY[0x24BDBE3D0](font);
}

CGFunctionRef CGFunctionCreate(void *info, size_t domainDimension, const CGFloat *domain, size_t rangeDimension, const CGFloat *range, const CGFunctionCallbacks *callbacks)
{
  return (CGFunctionRef)MEMORY[0x24BDBE3D8](info, domainDimension, domain, rangeDimension, range, callbacks);
}

void CGFunctionRelease(CGFunctionRef function)
{
  MEMORY[0x24BDBE400](function);
}

CGGradientRef CGGradientCreateWithColors(CGColorSpaceRef space, CFArrayRef colors, const CGFloat *locations)
{
  return (CGGradientRef)MEMORY[0x24BDBE538](space, colors, locations);
}

void CGGradientRelease(CGGradientRef gradient)
{
  MEMORY[0x24BDBE550](gradient);
}

CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  return (CGImageRef)MEMORY[0x24BDBE5E0](width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, *(_QWORD *)&bitmapInfo, provider);
}

CGImageRef CGImageCreateCopy(CGImageRef image)
{
  return (CGImageRef)MEMORY[0x24BDBE5E8](image);
}

void CGImageDestinationAddImage(CGImageDestinationRef idst, CGImageRef image, CFDictionaryRef properties)
{
  MEMORY[0x24BDD9048](idst, image, properties);
}

CGImageDestinationRef CGImageDestinationCreateWithData(CFMutableDataRef data, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return (CGImageDestinationRef)MEMORY[0x24BDD9078](data, type, count, options);
}

CGImageDestinationRef CGImageDestinationCreateWithURL(CFURLRef url, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return (CGImageDestinationRef)MEMORY[0x24BDD9088](url, type, count, options);
}

BOOL CGImageDestinationFinalize(CGImageDestinationRef idst)
{
  return MEMORY[0x24BDD9090](idst);
}

void CGImageDestinationSetProperties(CGImageDestinationRef idst, CFDictionaryRef properties)
{
  MEMORY[0x24BDD9098](idst, properties);
}

CGImageAlphaInfo CGImageGetAlphaInfo(CGImageRef image)
{
  return MEMORY[0x24BDBE620](image);
}

size_t CGImageGetBitsPerComponent(CGImageRef image)
{
  return MEMORY[0x24BDBE630](image);
}

size_t CGImageGetBitsPerPixel(CGImageRef image)
{
  return MEMORY[0x24BDBE638](image);
}

size_t CGImageGetBytesPerRow(CGImageRef image)
{
  return MEMORY[0x24BDBE648](image);
}

CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)
{
  return (CGColorSpaceRef)MEMORY[0x24BDBE658](image);
}

CGDataProviderRef CGImageGetDataProvider(CGImageRef image)
{
  return (CGDataProviderRef)MEMORY[0x24BDBE668](image);
}

size_t CGImageGetHeight(CGImageRef image)
{
  return MEMORY[0x24BDBE680](image);
}

BOOL CGImageGetShouldInterpolate(CGImageRef image)
{
  return MEMORY[0x24BDBE6C8](image);
}

size_t CGImageGetWidth(CGImageRef image)
{
  return MEMORY[0x24BDBE6E0](image);
}

CGImageRef CGImageMaskCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate)
{
  return (CGImageRef)MEMORY[0x24BDBE6F8](width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, provider, decode, shouldInterpolate);
}

void CGImageRelease(CGImageRef image)
{
  MEMORY[0x24BDBE770](image);
}

CGImageRef CGImageRetain(CGImageRef image)
{
  return (CGImageRef)MEMORY[0x24BDBE778](image);
}

CFDictionaryRef CGImageSourceCopyPropertiesAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CFDictionaryRef)MEMORY[0x24BDD9148](isrc, index, options);
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageRef)MEMORY[0x24BDD9158](isrc, index, options);
}

CGImageRef CGImageSourceCreateThumbnailAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageRef)MEMORY[0x24BDD9168](isrc, index, options);
}

CGImageSourceRef CGImageSourceCreateWithData(CFDataRef data, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x24BDD9170](data, options);
}

CGImageSourceRef CGImageSourceCreateWithDataProvider(CGDataProviderRef provider, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x24BDD9178](provider, options);
}

CGImageSourceRef CGImageSourceCreateWithURL(CFURLRef url, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x24BDD9180](url, options);
}

CGImageSourceStatus CGImageSourceGetStatus(CGImageSourceRef isrc)
{
  return MEMORY[0x24BDD9198](isrc);
}

CFStringRef CGImageSourceGetType(CGImageSourceRef isrc)
{
  return (CFStringRef)MEMORY[0x24BDD91A0](isrc);
}

CGLayerRef CGLayerCreateWithContext(CGContextRef context, CGSize size, CFDictionaryRef auxiliaryInfo)
{
  return (CGLayerRef)MEMORY[0x24BDBE7D0](context, auxiliaryInfo, (__n128)size, *(__n128 *)&size.height);
}

CGContextRef CGLayerGetContext(CGLayerRef layer)
{
  return (CGContextRef)MEMORY[0x24BDBE7D8](layer);
}

void CGLayerRelease(CGLayerRef layer)
{
  MEMORY[0x24BDBE7E0](layer);
}

void CGPDFContextClose(CGContextRef context)
{
  MEMORY[0x24BDBE8E8](context);
}

CGContextRef CGPDFContextCreate(CGDataConsumerRef consumer, const CGRect *mediaBox, CFDictionaryRef auxiliaryInfo)
{
  return (CGContextRef)MEMORY[0x24BDBE8F0](consumer, mediaBox, auxiliaryInfo);
}

CGPDFDocumentRef CGPDFDocumentCreateWithProvider(CGDataProviderRef provider)
{
  return (CGPDFDocumentRef)MEMORY[0x24BDBEA00](provider);
}

CGPDFPageRef CGPDFDocumentGetPage(CGPDFDocumentRef document, size_t pageNumber)
{
  return (CGPDFPageRef)MEMORY[0x24BDBEA70](document, pageNumber);
}

void CGPDFDocumentRelease(CGPDFDocumentRef document)
{
  MEMORY[0x24BDBEAC8](document);
}

CGRect CGPDFPageGetBoxRect(CGPDFPageRef page, CGPDFBox box)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDBEBF0](page, *(_QWORD *)&box);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

int CGPDFPageGetRotationAngle(CGPDFPageRef page)
{
  return MEMORY[0x24BDBEC18](page);
}

void CGPathAddArc(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, BOOL clockwise)
{
  MEMORY[0x24BDBEDA8](path, m, clockwise, x, y, radius, startAngle, endAngle);
}

void CGPathAddArcToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius)
{
  MEMORY[0x24BDBEDB0](path, m, x1, y1, x2, y2, radius);
}

void CGPathAddCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEDB8](path, m, cp1x, cp1y, cp2x, cp2y, x, y);
}

void CGPathAddEllipseInRect(CGMutablePathRef path, const CGAffineTransform *m, CGRect rect)
{
  MEMORY[0x24BDBEDC0](path, m, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGPathAddLineToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEDC8](path, m, x, y);
}

void CGPathAddPath(CGMutablePathRef path1, const CGAffineTransform *m, CGPathRef path2)
{
  MEMORY[0x24BDBEDD8](path1, m, path2);
}

void CGPathAddQuadCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEDE0](path, m, cpx, cpy, x, y);
}

void CGPathAddRect(CGMutablePathRef path, const CGAffineTransform *m, CGRect rect)
{
  MEMORY[0x24BDBEDE8](path, m, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGPathApply(CGPathRef path, void *info, CGPathApplierFunction function)
{
  MEMORY[0x24BDBEE08](path, info, function);
}

void CGPathCloseSubpath(CGMutablePathRef path)
{
  MEMORY[0x24BDBEE20](path);
}

BOOL CGPathContainsPoint(CGPathRef path, const CGAffineTransform *m, CGPoint point, BOOL eoFill)
{
  return MEMORY[0x24BDBEE28](path, m, eoFill, (__n128)point, *(__n128 *)&point.y);
}

CGPathRef CGPathCreateCopy(CGPathRef path)
{
  return (CGPathRef)MEMORY[0x24BDBEE30](path);
}

CGPathRef CGPathCreateCopyByStrokingPath(CGPathRef path, const CGAffineTransform *transform, CGFloat lineWidth, CGLineCap lineCap, CGLineJoin lineJoin, CGFloat miterLimit)
{
  return (CGPathRef)MEMORY[0x24BDBEE48](path, transform, *(_QWORD *)&lineCap, *(_QWORD *)&lineJoin, lineWidth, miterLimit);
}

CGPathRef CGPathCreateCopyByTransformingPath(CGPathRef path, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x24BDBEE60](path, transform);
}

CGMutablePathRef CGPathCreateMutable(void)
{
  return (CGMutablePathRef)MEMORY[0x24BDBEE80]();
}

CGMutablePathRef CGPathCreateMutableCopy(CGPathRef path)
{
  return (CGMutablePathRef)MEMORY[0x24BDBEE88](path);
}

CGPathRef CGPathCreateWithRect(CGRect rect, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x24BDBEEA8](transform, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGPathEqualToPath(CGPathRef path1, CGPathRef path2)
{
  return MEMORY[0x24BDBEEB8](path1, path2);
}

CGRect CGPathGetBoundingBox(CGPathRef path)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x24BDBEEC0](path);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGPoint CGPathGetCurrentPoint(CGPathRef path)
{
  double v1;
  double v2;
  CGPoint result;

  MEMORY[0x24BDBEEC8](path);
  result.y = v2;
  result.x = v1;
  return result;
}

CGRect CGPathGetPathBoundingBox(CGPathRef path)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x24BDBEEE0](path);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

BOOL CGPathIsEmpty(CGPathRef path)
{
  return MEMORY[0x24BDBEF10](path);
}

void CGPathMoveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEF40](path, m, x, y);
}

void CGPathRelease(CGPathRef path)
{
  MEMORY[0x24BDBEF48](path);
}

CGPathRef CGPathRetain(CGPathRef path)
{
  return (CGPathRef)MEMORY[0x24BDBEF50](path);
}

CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform *t)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDBEFB8](t, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

BOOL CGRectContainsPoint(CGRect rect, CGPoint point)
{
  return MEMORY[0x24BDBEFC0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, (__n128)point, *(__n128 *)&point.y);
}

BOOL CGRectContainsRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x24BDBEFC8]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

void CGRectDivide(CGRect rect, CGRect *slice, CGRect *remainder, CGFloat amount, CGRectEdge edge)
{
  MEMORY[0x24BDBEFD8](slice, remainder, *(_QWORD *)&edge, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, amount);
}

BOOL CGRectEqualToRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x24BDBEFE0]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

CGFloat CGRectGetHeight(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBEFE8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBEFF0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBEFF8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMidX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF000]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMidY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF008]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF010]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF018]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetWidth(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF020]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)
{
  double v3;
  double v4;
  double v5;
  double v6;
  CGRect result;

  MEMORY[0x24BDBF030]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.height = v6;
  result.size.width = v5;
  result.origin.y = v4;
  result.origin.x = v3;
  return result;
}

CGRect CGRectIntegral(CGRect rect)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x24BDBF038]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGRect CGRectIntersection(CGRect r1, CGRect r2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDBF040]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

BOOL CGRectIntersectsRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x24BDBF048]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x24BDBF050]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsInfinite(CGRect rect)
{
  return MEMORY[0x24BDBF058]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsNull(CGRect rect)
{
  return MEMORY[0x24BDBF060]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)
{
  double v3;
  double v4;
  double v5;
  double v6;
  CGRect result;

  MEMORY[0x24BDBF078]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.height = v6;
  result.size.width = v5;
  result.origin.y = v4;
  result.origin.x = v3;
  return result;
}

CGRect CGRectStandardize(CGRect rect)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x24BDBF080]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDBF088]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

CGShadingRef CGShadingCreateAxial(CGColorSpaceRef space, CGPoint start, CGPoint end, CGFunctionRef function, BOOL extendStart, BOOL extendEnd)
{
  return (CGShadingRef)MEMORY[0x24BDBF0E0](space, function, extendStart, extendEnd, (__n128)start, *(__n128 *)&start.y, (__n128)end, *(__n128 *)&end.y);
}

CGShadingRef CGShadingCreateRadial(CGColorSpaceRef space, CGPoint start, CGFloat startRadius, CGPoint end, CGFloat endRadius, CGFunctionRef function, BOOL extendStart, BOOL extendEnd)
{
  return (CGShadingRef)MEMORY[0x24BDBF0E8](space, function, extendStart, extendEnd, (__n128)start, *(__n128 *)&start.y, startRadius, (__n128)end, *(__n128 *)&end.y, endRadius);
}

void CGShadingRelease(CGShadingRef shading)
{
  MEMORY[0x24BDBF118](shading);
}

CGShadingRef CGShadingRetain(CGShadingRef shading)
{
  return (CGShadingRef)MEMORY[0x24BDBF120](shading);
}

const AudioStreamBasicDescription *__cdecl CMAudioFormatDescriptionGetStreamBasicDescription(CMAudioFormatDescriptionRef desc)
{
  return (const AudioStreamBasicDescription *)MEMORY[0x24BDC0058](desc);
}

CFPropertyListRef CMFormatDescriptionGetExtension(CMFormatDescriptionRef desc, CFStringRef extensionKey)
{
  return (CFPropertyListRef)MEMORY[0x24BDC01A8](desc, extensionKey);
}

FourCharCode CMFormatDescriptionGetMediaSubType(CMFormatDescriptionRef desc)
{
  return MEMORY[0x24BDC01C0](desc);
}

CMTime *__cdecl CMTimeClampToRange(CMTime *__return_ptr retstr, CMTime *time, CMTimeRange *range)
{
  return (CMTime *)MEMORY[0x24BDC0430](retstr, time, range);
}

int32_t CMTimeCompare(CMTime *time1, CMTime *time2)
{
  return MEMORY[0x24BDC0450](time1, time2);
}

Float64 CMTimeGetSeconds(CMTime *time)
{
  Float64 result;

  MEMORY[0x24BDC0490](time);
  return result;
}

CMTime *__cdecl CMTimeMakeWithSeconds(CMTime *__return_ptr retstr, Float64 seconds, int32_t preferredTimescale)
{
  return (CMTime *)MEMORY[0x24BDC04C0](retstr, *(_QWORD *)&preferredTimescale, seconds);
}

CMTimeRange *__cdecl CMTimeRangeMake(CMTimeRange *__return_ptr retstr, CMTime *start, CMTime *duration)
{
  return (CMTimeRange *)MEMORY[0x24BDC0580](retstr, start, duration);
}

CMVideoDimensions CMVideoFormatDescriptionGetDimensions(CMVideoFormatDescriptionRef videoDesc)
{
  return (CMVideoDimensions)MEMORY[0x24BDC0668](videoDesc);
}

CTFontCollectionRef CTFontCollectionCreateFromAvailableFonts(CFDictionaryRef options)
{
  return (CTFontCollectionRef)MEMORY[0x24BDC46D0](options);
}

CFArrayRef CTFontCollectionCreateMatchingFontDescriptors(CTFontCollectionRef collection)
{
  return (CFArrayRef)MEMORY[0x24BDC46D8](collection);
}

CFCharacterSetRef CTFontCopyCharacterSet(CTFontRef font)
{
  return (CFCharacterSetRef)MEMORY[0x24BDC46E8](font);
}

CFStringRef CTFontCopyFamilyName(CTFontRef font)
{
  return (CFStringRef)MEMORY[0x24BDC4700](font);
}

CFArrayRef CTFontCopyFeatures(CTFontRef font)
{
  return (CFArrayRef)MEMORY[0x24BDC4710](font);
}

CTFontDescriptorRef CTFontCopyFontDescriptor(CTFontRef font)
{
  return (CTFontDescriptorRef)MEMORY[0x24BDC4718](font);
}

CFStringRef CTFontCopyFullName(CTFontRef font)
{
  return (CFStringRef)MEMORY[0x24BDC4720](font);
}

CGFontRef CTFontCopyGraphicsFont(CTFontRef font, CTFontDescriptorRef *attributes)
{
  return (CGFontRef)MEMORY[0x24BDC4728](font, attributes);
}

CFStringRef CTFontCopyPostScriptName(CTFontRef font)
{
  return (CFStringRef)MEMORY[0x24BDC4748](font);
}

CTFontRef CTFontCreateCopyWithAttributes(CTFontRef font, CGFloat size, const CGAffineTransform *matrix, CTFontDescriptorRef attributes)
{
  return (CTFontRef)MEMORY[0x24BDC4788](font, matrix, attributes, size);
}

CTFontRef CTFontCreateCopyWithSymbolicTraits(CTFontRef font, CGFloat size, const CGAffineTransform *matrix, CTFontSymbolicTraits symTraitValue, CTFontSymbolicTraits symTraitMask)
{
  return (CTFontRef)MEMORY[0x24BDC4790](font, matrix, *(_QWORD *)&symTraitValue, *(_QWORD *)&symTraitMask, size);
}

CTFontRef CTFontCreateForString(CTFontRef currentFont, CFStringRef string, CFRange range)
{
  return (CTFontRef)MEMORY[0x24BDC4798](currentFont, string, range.location, range.length);
}

CGPathRef CTFontCreatePathForGlyph(CTFontRef font, CGGlyph glyph, const CGAffineTransform *matrix)
{
  return (CGPathRef)MEMORY[0x24BDC47A0](font, glyph, matrix);
}

CTFontRef CTFontCreateUIFontForLanguage(CTFontUIFontType uiType, CGFloat size, CFStringRef language)
{
  return (CTFontRef)MEMORY[0x24BDC47A8](*(_QWORD *)&uiType, language, size);
}

CTFontRef CTFontCreateWithFontDescriptor(CTFontDescriptorRef descriptor, CGFloat size, const CGAffineTransform *matrix)
{
  return (CTFontRef)MEMORY[0x24BDC47B0](descriptor, matrix, size);
}

CTFontRef CTFontCreateWithGraphicsFont(CGFontRef graphicsFont, CGFloat size, const CGAffineTransform *matrix, CTFontDescriptorRef attributes)
{
  return (CTFontRef)MEMORY[0x24BDC47C0](graphicsFont, matrix, attributes, size);
}

CTFontRef CTFontCreateWithName(CFStringRef name, CGFloat size, const CGAffineTransform *matrix)
{
  return (CTFontRef)MEMORY[0x24BDC47C8](name, matrix, size);
}

CFTypeRef CTFontDescriptorCopyAttribute(CTFontDescriptorRef descriptor, CFStringRef attribute)
{
  return (CFTypeRef)MEMORY[0x24BDC47D8](descriptor, attribute);
}

CFTypeRef CTFontDescriptorCopyLocalizedAttribute(CTFontDescriptorRef descriptor, CFStringRef attribute, CFStringRef *language)
{
  return (CFTypeRef)MEMORY[0x24BDC47E8](descriptor, attribute, language);
}

CTFontDescriptorRef CTFontDescriptorCreateCopyWithAttributes(CTFontDescriptorRef original, CFDictionaryRef attributes)
{
  return (CTFontDescriptorRef)MEMORY[0x24BDC47F0](original, attributes);
}

CFArrayRef CTFontDescriptorCreateMatchingFontDescriptors(CTFontDescriptorRef descriptor, CFSetRef mandatoryAttributes)
{
  return (CFArrayRef)MEMORY[0x24BDC4820](descriptor, mandatoryAttributes);
}

CTFontDescriptorRef CTFontDescriptorCreateWithAttributes(CFDictionaryRef attributes)
{
  return (CTFontDescriptorRef)MEMORY[0x24BDC4830](attributes);
}

CTFontDescriptorRef CTFontDescriptorCreateWithNameAndSize(CFStringRef name, CGFloat size)
{
  return (CTFontDescriptorRef)MEMORY[0x24BDC4840](name, size);
}

BOOL CTFontDescriptorMatchFontDescriptorsWithProgressHandler(CFArrayRef descriptors, CFSetRef mandatoryAttributes, CTFontDescriptorProgressHandler progressBlock)
{
  return MEMORY[0x24BDC4898](descriptors, mandatoryAttributes, progressBlock);
}

void CTFontDrawGlyphs(CTFontRef font, const CGGlyph *glyphs, const CGPoint *positions, size_t count, CGContextRef context)
{
  MEMORY[0x24BDC48A0](font, glyphs, positions, count, context);
}

double CTFontGetAdvancesForGlyphs(CTFontRef font, CTFontOrientation orientation, const CGGlyph *glyphs, CGSize *advances, CFIndex count)
{
  double result;

  MEMORY[0x24BDC48B0](font, *(_QWORD *)&orientation, glyphs, advances, count);
  return result;
}

CGFloat CTFontGetAscent(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x24BDC48B8](font);
  return result;
}

CGRect CTFontGetBoundingBox(CTFontRef font)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x24BDC48C0](font);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGRect CTFontGetBoundingRectsForGlyphs(CTFontRef font, CTFontOrientation orientation, const CGGlyph *glyphs, CGRect *boundingRects, CFIndex count)
{
  double v5;
  double v6;
  double v7;
  double v8;
  CGRect result;

  MEMORY[0x24BDC48C8](font, *(_QWORD *)&orientation, glyphs, boundingRects, count);
  result.size.height = v8;
  result.size.width = v7;
  result.origin.y = v6;
  result.origin.x = v5;
  return result;
}

CGFloat CTFontGetCapHeight(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x24BDC48D0](font);
  return result;
}

CGFloat CTFontGetDescent(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x24BDC48E0](font);
  return result;
}

BOOL CTFontGetGlyphsForCharacters(CTFontRef font, const UniChar *characters, CGGlyph *glyphs, CFIndex count)
{
  return MEMORY[0x24BDC48F0](font, characters, glyphs, count);
}

CGFloat CTFontGetLeading(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x24BDC4900](font);
  return result;
}

CGFloat CTFontGetSize(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x24BDC4908](font);
  return result;
}

CGFloat CTFontGetSlantAngle(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x24BDC4910](font);
  return result;
}

CFStringEncoding CTFontGetStringEncoding(CTFontRef font)
{
  return MEMORY[0x24BDC4918](font);
}

CTFontSymbolicTraits CTFontGetSymbolicTraits(CTFontRef font)
{
  return MEMORY[0x24BDC4920](font);
}

CFTypeID CTFontGetTypeID(void)
{
  return MEMORY[0x24BDC4930]();
}

CGFloat CTFontGetUnderlinePosition(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x24BDC4938](font);
  return result;
}

CGFloat CTFontGetUnderlineThickness(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x24BDC4940](font);
  return result;
}

void CTFontGetVerticalTranslationsForGlyphs(CTFontRef font, const CGGlyph *glyphs, CGSize *translations, CFIndex count)
{
  MEMORY[0x24BDC4950](font, glyphs, translations, count);
}

CGFloat CTFontGetXHeight(CTFontRef font)
{
  CGFloat result;

  MEMORY[0x24BDC4960](font);
  return result;
}

BOOL CTFontManagerRegisterGraphicsFont(CGFontRef font, CFErrorRef *error)
{
  return MEMORY[0x24BDC49A0](font, error);
}

BOOL CTFontManagerUnregisterGraphicsFont(CGFontRef font, CFErrorRef *error)
{
  return MEMORY[0x24BDC49B0](font, error);
}

CTLineRef CTLineCreateJustifiedLine(CTLineRef line, CGFloat justificationFactor, double justificationWidth)
{
  return (CTLineRef)MEMORY[0x24BDC4A20](line, justificationFactor, justificationWidth);
}

CTLineRef CTLineCreateTruncatedLine(CTLineRef line, double width, CTLineTruncationType truncationType, CTLineRef truncationToken)
{
  return (CTLineRef)MEMORY[0x24BDC4A28](line, *(_QWORD *)&truncationType, truncationToken, width);
}

CTLineRef CTLineCreateWithAttributedString(CFAttributedStringRef attrString)
{
  return (CTLineRef)MEMORY[0x24BDC4A30](attrString);
}

void CTLineDraw(CTLineRef line, CGContextRef context)
{
  MEMORY[0x24BDC4A68](line, context);
}

CGRect CTLineGetBoundsWithOptions(CTLineRef line, CTLineBoundsOptions options)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDC4A78](line, options);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

CFIndex CTLineGetGlyphCount(CTLineRef line)
{
  return MEMORY[0x24BDC4A80](line);
}

CFArrayRef CTLineGetGlyphRuns(CTLineRef line)
{
  return (CFArrayRef)MEMORY[0x24BDC4A88](line);
}

CGRect CTLineGetImageBounds(CTLineRef line, CGContextRef context)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x24BDC4A90](line, context);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

CGFloat CTLineGetOffsetForStringIndex(CTLineRef line, CFIndex charIndex, CGFloat *secondaryOffset)
{
  CGFloat result;

  MEMORY[0x24BDC4A98](line, charIndex, secondaryOffset);
  return result;
}

double CTLineGetPenOffsetForFlush(CTLineRef line, CGFloat flushFactor, double flushWidth)
{
  double result;

  MEMORY[0x24BDC4AA0](line, flushFactor, flushWidth);
  return result;
}

CFIndex CTLineGetStringIndexForPosition(CTLineRef line, CGPoint position)
{
  return MEMORY[0x24BDC4AB0](line, (__n128)position, *(__n128 *)&position.y);
}

CFRange CTLineGetStringRange(CTLineRef line)
{
  CFIndex v1;
  CFIndex v2;
  CFRange result;

  v1 = MEMORY[0x24BDC4AB8](line);
  result.length = v2;
  result.location = v1;
  return result;
}

double CTLineGetTrailingWhitespaceWidth(CTLineRef line)
{
  double result;

  MEMORY[0x24BDC4AC0](line);
  return result;
}

double CTLineGetTypographicBounds(CTLineRef line, CGFloat *ascent, CGFloat *descent, CGFloat *leading)
{
  double result;

  MEMORY[0x24BDC4AC8](line, ascent, descent, leading);
  return result;
}

CTParagraphStyleRef CTParagraphStyleCreate(const CTParagraphStyleSetting *settings, size_t settingCount)
{
  return (CTParagraphStyleRef)MEMORY[0x24BDC4AE0](settings, settingCount);
}

CTRunDelegateRef CTRunDelegateCreate(const CTRunDelegateCallbacks *callbacks, void *refCon)
{
  return (CTRunDelegateRef)MEMORY[0x24BDC4AF8](callbacks, refCon);
}

void CTRunDraw(CTRunRef run, CGContextRef context, CFRange range)
{
  MEMORY[0x24BDC4B00](run, context, range.location, range.length);
}

void CTRunGetAdvances(CTRunRef run, CFRange range, CGSize *buffer)
{
  MEMORY[0x24BDC4B08](run, range.location, range.length, buffer);
}

CFDictionaryRef CTRunGetAttributes(CTRunRef run)
{
  return (CFDictionaryRef)MEMORY[0x24BDC4B10](run);
}

CFIndex CTRunGetGlyphCount(CTRunRef run)
{
  return MEMORY[0x24BDC4B28](run);
}

void CTRunGetGlyphs(CTRunRef run, CFRange range, CGGlyph *buffer)
{
  MEMORY[0x24BDC4B30](run, range.location, range.length, buffer);
}

CGRect CTRunGetImageBounds(CTRunRef run, CGContextRef context, CFRange range)
{
  double v3;
  double v4;
  double v5;
  double v6;
  CGRect result;

  MEMORY[0x24BDC4B40](run, context, range.location, range.length);
  result.size.height = v6;
  result.size.width = v5;
  result.origin.y = v4;
  result.origin.x = v3;
  return result;
}

void CTRunGetPositions(CTRunRef run, CFRange range, CGPoint *buffer)
{
  MEMORY[0x24BDC4B48](run, range.location, range.length, buffer);
}

CTRunStatus CTRunGetStatus(CTRunRef run)
{
  return MEMORY[0x24BDC4B58](run);
}

void CTRunGetStringIndices(CTRunRef run, CFRange range, CFIndex *buffer)
{
  MEMORY[0x24BDC4B60](run, range.location, range.length, buffer);
}

CFRange CTRunGetStringRange(CTRunRef run)
{
  CFIndex v1;
  CFIndex v2;
  CFRange result;

  v1 = MEMORY[0x24BDC4B70](run);
  result.length = v2;
  result.location = v1;
  return result;
}

CGAffineTransform *__cdecl CTRunGetTextMatrix(CGAffineTransform *__return_ptr retstr, CTRunRef run)
{
  return (CGAffineTransform *)MEMORY[0x24BDC4B78](retstr, run);
}

double CTRunGetTypographicBounds(CTRunRef run, CFRange range, CGFloat *ascent, CGFloat *descent, CGFloat *leading)
{
  double result;

  MEMORY[0x24BDC4B88](run, range.location, range.length, ascent, descent, leading);
  return result;
}

CTTextTabRef CTTextTabCreate(CTTextAlignment alignment, double location, CFDictionaryRef options)
{
  return (CTTextTabRef)MEMORY[0x24BDC4BA0](alignment, options, location);
}

double CTTextTabGetLocation(CTTextTabRef tab)
{
  double result;

  MEMORY[0x24BDC4BA8](tab);
  return result;
}

CTLineRef CTTypesetterCreateLine(CTTypesetterRef typesetter, CFRange stringRange)
{
  return (CTLineRef)MEMORY[0x24BDC4BB0](typesetter, stringRange.location, stringRange.length);
}

CTLineRef CTTypesetterCreateLineWithOffset(CTTypesetterRef typesetter, CFRange stringRange, double offset)
{
  return (CTLineRef)MEMORY[0x24BDC4BB8](typesetter, stringRange.location, stringRange.length, offset);
}

CTTypesetterRef CTTypesetterCreateWithAttributedString(CFAttributedStringRef string)
{
  return (CTTypesetterRef)MEMORY[0x24BDC4BC0](string);
}

CFIndex CTTypesetterSuggestClusterBreakWithOffset(CTTypesetterRef typesetter, CFIndex startIndex, double width, double offset)
{
  return MEMORY[0x24BDC4BD0](typesetter, startIndex, width, offset);
}

CFIndex CTTypesetterSuggestLineBreakWithOffset(CTTypesetterRef typesetter, CFIndex startIndex, double width, double offset)
{
  return MEMORY[0x24BDC4BE0](typesetter, startIndex, width, offset);
}

id MTLCreateSystemDefaultDevice(void)
{
  return (id)MEMORY[0x24BDDD1E0]();
}

uint64_t NSExpandedRange()
{
  return MEMORY[0x24BEB3BE0]();
}

NSRange NSIntersectionRange(NSRange range1, NSRange range2)
{
  NSUInteger v2;
  NSUInteger v3;
  NSRange result;

  v2 = MEMORY[0x24BDD0E08](range1.location, range1.length, range2.location, range2.length);
  result.length = v3;
  result.location = v2;
  return result;
}

uint64_t NSIntersectionRangeInclusive()
{
  return MEMORY[0x24BEB3BE8]();
}

void NSLog(NSString *format, ...)
{
  MEMORY[0x24BDD1000](format);
}

NSArray *__cdecl NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde)
{
  return (NSArray *)MEMORY[0x24BDD1208](directory, domainMask, expandTilde);
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return (SEL)MEMORY[0x24BDD1218](aSelectorName);
}

uint64_t NSStringForTSUFormatType()
{
  return MEMORY[0x24BEB3BF8]();
}

NSString *__cdecl NSStringFromCGAffineTransform(CGAffineTransform *transform)
{
  return (NSString *)MEMORY[0x24BDF6660](transform);
}

NSString *__cdecl NSStringFromCGPoint(CGPoint point)
{
  return (NSString *)MEMORY[0x24BDF6668]((__n128)point, *(__n128 *)&point.y);
}

NSString *__cdecl NSStringFromCGRect(CGRect rect)
{
  return (NSString *)MEMORY[0x24BDF6670]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

NSString *__cdecl NSStringFromCGSize(CGSize size)
{
  return (NSString *)MEMORY[0x24BDF6678]((__n128)size, *(__n128 *)&size.height);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x24BDD1240](aClass);
}

NSString *__cdecl NSStringFromRange(NSRange range)
{
  return (NSString *)MEMORY[0x24BDD1258](range.location, range.length);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x24BDD1268](aSelector);
}

uint64_t NSStringFromUIGestureRecognizerState()
{
  return MEMORY[0x24BEB3C00]();
}

NSRange NSUnionRange(NSRange range1, NSRange range2)
{
  NSUInteger v2;
  NSUInteger v3;
  NSRange result;

  v2 = MEMORY[0x24BDD13D8](range1.location, range1.length, range2.location, range2.length);
  result.length = v3;
  result.location = v2;
  return result;
}

void NSZoneFree(NSZone *zone, void *ptr)
{
  MEMORY[0x24BDD1418](zone, ptr);
}

void *__cdecl NSZoneMalloc(NSZone *zone, NSUInteger size)
{
  return (void *)MEMORY[0x24BDD1420](zone, size);
}

void *__cdecl NSZoneRealloc(NSZone *zone, void *ptr, NSUInteger size)
{
  return (void *)MEMORY[0x24BDD1428](zone, ptr, size);
}

uint64_t SFUEqualCryptoKeys()
{
  return MEMORY[0x24BEB3D30]();
}

uint64_t TSUBitmapGetAlignedBytesPerRow()
{
  return MEMORY[0x24BEB3D48]();
}

uint64_t TSUCFTypeCast()
{
  return MEMORY[0x24BEB3D50]();
}

uint64_t TSUCGColorCreateDeviceRGB()
{
  return MEMORY[0x24BEB3D58]();
}

uint64_t TSUCGColorCreateRandomRGB()
{
  return MEMORY[0x24BEB3D60]();
}

uint64_t TSUCGImagePNGRepresentation()
{
  return MEMORY[0x24BEB3D68]();
}

uint64_t TSUCheckedDynamicCast()
{
  return MEMORY[0x24BEB3D70]();
}

uint64_t TSUClamp()
{
  return MEMORY[0x24BEB3D78]();
}

uint64_t TSUClassAndProtocolCast()
{
  return MEMORY[0x24BEB3D80]();
}

uint64_t TSUCreateCheckerBoardColor()
{
  return MEMORY[0x24BEB3D88]();
}

uint64_t TSUCreateDateFromString()
{
  return MEMORY[0x24BEB3D90]();
}

uint64_t TSUCreateDateFromStringWithPreferredFormat()
{
  return MEMORY[0x24BEB3D98]();
}

uint64_t TSUDateFormatterStringFromDateWithFormat()
{
  return MEMORY[0x24BEB3DA8]();
}

uint64_t TSUDefaultDateTimeFormat()
{
  return MEMORY[0x24BEB3DB0]();
}

uint64_t TSUDeviceGrayColorSpace()
{
  return MEMORY[0x24BEB3DB8]();
}

uint64_t TSUDeviceRGBColorSpace()
{
  return MEMORY[0x24BEB3DC0]();
}

uint64_t TSUDistance()
{
  return MEMORY[0x24BEB3DC8]();
}

uint64_t TSUDurationFormatterDurationUnitsNecessaryToFullyDisplayDuration()
{
  return MEMORY[0x24BEB3DD0]();
}

uint64_t TSUDurationFormatterFormatFromDurationUnits()
{
  return MEMORY[0x24BEB3DD8]();
}

uint64_t TSUDurationFormatterMaxDurationUnitInUnits()
{
  return MEMORY[0x24BEB3DE0]();
}

uint64_t TSUDurationFormatterMinDurationUnitInUnits()
{
  return MEMORY[0x24BEB3DE8]();
}

uint64_t TSUDurationFormatterStringFromTimeIntervalWithFormat()
{
  return MEMORY[0x24BEB3DF0]();
}

uint64_t TSUDurationFormatterTimeIntervalFromStringWithCompactStyleStartUnit()
{
  return MEMORY[0x24BEB3DF8]();
}

uint64_t TSUDurationUnroundedFormatterStringFromTimeIntervalWithFormat()
{
  return MEMORY[0x24BEB3E00]();
}

uint64_t TSUDynamicCast()
{
  return MEMORY[0x24BEB3E08]();
}

uint64_t TSUFindFirstResponderView()
{
  return MEMORY[0x24BEB3E10]();
}

uint64_t TSUFindInputLanguagesWithBlock()
{
  return MEMORY[0x24BEB3E18]();
}

uint64_t TSUFormatStructHash()
{
  return MEMORY[0x24BEB3E20]();
}

uint64_t TSUFormatStructRelease()
{
  return MEMORY[0x24BEB3E28]();
}

uint64_t TSUFormatStructRetain()
{
  return MEMORY[0x24BEB3E30]();
}

uint64_t TSUFractionalPart()
{
  return MEMORY[0x24BEB3E38]();
}

uint64_t TSUGetCurrentLocale()
{
  return MEMORY[0x24BEB3E40]();
}

uint64_t TSUGetNumberValueAndTypeFromString()
{
  return MEMORY[0x24BEB3E48]();
}

uint64_t TSUGetNumberValueAndTypeFromStringWithCurrencyCode()
{
  return MEMORY[0x24BEB3E50]();
}

uint64_t TSUHasBiDiLanguage()
{
  return MEMORY[0x24BEB3E58]();
}

uint64_t TSUHasCJKLanguage()
{
  return MEMORY[0x24BEB3E60]();
}

uint64_t TSUHasListLanguage()
{
  return MEMORY[0x24BEB3E68]();
}

uint64_t TSUHash()
{
  return MEMORY[0x24BEB3E70]();
}

uint64_t TSUHashWithSeed()
{
  return MEMORY[0x24BEB3E80]();
}

uint64_t TSUImageOrientationTransform()
{
  return MEMORY[0x24BEB3E90]();
}

uint64_t TSUIntersectionRangeWithEdge()
{
  return MEMORY[0x24BEB3E98]();
}

uint64_t TSUIsGroupingSeparatorUsedInNumericString()
{
  return MEMORY[0x24BEB3EA0]();
}

uint64_t TSULink()
{
  return MEMORY[0x24BEB3EA8]();
}

uint64_t TSULogErrorInFunction()
{
  return MEMORY[0x24BEB3EB0]();
}

uint64_t TSUMix()
{
  return MEMORY[0x24BEB3EB8]();
}

uint64_t TSUMixFloats()
{
  return MEMORY[0x24BEB3EC0]();
}

uint64_t TSUMixPoints()
{
  return MEMORY[0x24BEB3EC8]();
}

uint64_t TSUMixRects()
{
  return MEMORY[0x24BEB3ED0]();
}

uint64_t TSUMixSizes()
{
  return MEMORY[0x24BEB3ED8]();
}

uint64_t TSUNumberFormatterStringFromStringWithCustomFormat()
{
  return MEMORY[0x24BEB3EE0]();
}

uint64_t TSUNumberOfDecimalPlacesInNumericString()
{
  return MEMORY[0x24BEB3EE8]();
}

uint64_t TSUNumberOfDecimalPlacesInValue()
{
  return MEMORY[0x24BEB3EF0]();
}

uint64_t TSUObjectReferenceDescription()
{
  return MEMORY[0x24BEB3EF8]();
}

uint64_t TSUOpen()
{
  return MEMORY[0x24BEB3F00]();
}

uint64_t TSUP3ColorSpace()
{
  return MEMORY[0x24BEB3F08]();
}

uint64_t TSUPadUI()
{
  return MEMORY[0x24BEB3F10]();
}

uint64_t TSUPhoneUI()
{
  return MEMORY[0x24BEB3F18]();
}

uint64_t TSUPointIsFinite()
{
  return MEMORY[0x24BEB3F20]();
}

uint64_t TSUProtocolCast()
{
  return MEMORY[0x24BEB3F30]();
}

uint64_t TSURandom()
{
  return MEMORY[0x24BEB3F38]();
}

uint64_t TSURandomBetween()
{
  return MEMORY[0x24BEB3F40]();
}

uint64_t TSURectWithSize()
{
  return MEMORY[0x24BEB3F50]();
}

uint64_t TSURound()
{
  return MEMORY[0x24BEB3F58]();
}

uint64_t TSUScreenScale()
{
  return MEMORY[0x24BEB3F60]();
}

uint64_t TSUShortestCompleteDateTimeFormat()
{
  return MEMORY[0x24BEB3F68]();
}

uint64_t TSUShrinkSizeToFitInSize()
{
  return MEMORY[0x24BEB3F70]();
}

uint64_t TSUStatusBarIsLandscape()
{
  return MEMORY[0x24BEB3F78]();
}

uint64_t TSUSubtractPoints()
{
  return MEMORY[0x24BEB3F80]();
}

uint64_t TSUSupportsTextInteraction()
{
  return MEMORY[0x24BEB3F88]();
}

BOOL UIAccessibilityIsClosedCaptioningEnabled(void)
{
  return MEMORY[0x24BDF7270]();
}

BOOL UIAccessibilityIsVoiceOverRunning(void)
{
  return MEMORY[0x24BDF72C0]();
}

void UIGraphicsBeginImageContextWithOptions(CGSize size, BOOL opaque, CGFloat scale)
{
  MEMORY[0x24BDF78C8](opaque, (__n128)size, *(__n128 *)&size.height, scale);
}

void UIGraphicsEndImageContext(void)
{
  MEMORY[0x24BDF78D0]();
}

CGContextRef UIGraphicsGetCurrentContext(void)
{
  return (CGContextRef)MEMORY[0x24BDF78D8]();
}

UIImage *UIGraphicsGetImageFromCurrentImageContext(void)
{
  return (UIImage *)MEMORY[0x24BDF78E0]();
}

void UIGraphicsPopContext(void)
{
  MEMORY[0x24BDF78E8]();
}

void UIGraphicsPushContext(CGContextRef context)
{
  MEMORY[0x24BDF78F0](context);
}

Boolean UTTypeConformsTo(CFStringRef inUTI, CFStringRef inConformsToUTI)
{
  return MEMORY[0x24BDC15A8](inUTI, inConformsToUTI);
}

CFStringRef UTTypeCreatePreferredIdentifierForTag(CFStringRef inTagClass, CFStringRef inTag, CFStringRef inConformingToUTI)
{
  return (CFStringRef)MEMORY[0x24BDC15E0](inTagClass, inTag, inConformingToUTI);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x24BDAC720](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
  MEMORY[0x24BDAC728](a1, a2, *(_QWORD *)&a3);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x24BDAC738](aBlock);
}

NSDictionary *_NSDictionaryOfVariableBindings(NSString *commaSeparatedKeysString, id firstValue, ...)
{
  return (NSDictionary *)MEMORY[0x24BDD19C0](commaSeparatedKeysString, firstValue);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

uint64_t TSUFormatInit(void)
{
  return MEMORY[0x24BEB3F90]();
}

uint64_t TSUFormatBaseStringFromDouble()
{
  return MEMORY[0x24BEB3F98]();
}

uint64_t TSUFormatCustomStringFromDouble()
{
  return MEMORY[0x24BEB3FA0]();
}

uint64_t TSUFormatStructStringFromDouble()
{
  return MEMORY[0x24BEB3FA8]();
}

uint64_t TSUFormatTypeFromTSUNumberValueType()
{
  return MEMORY[0x24BEB3FB0]();
}

uint64_t TSUCustomFormat::formatName(TSUCustomFormat *this)
{
  return MEMORY[0x24BEB3FB8](this);
}

uint64_t TSUCustomFormat::setFormatName(TSUCustomFormat *this, NSString *a2)
{
  return MEMORY[0x24BEB3FC0](this, a2);
}

uint64_t TSUCustomFormat::customFormatIsEqual(TSUCustomFormat *this, TSUCustomFormat *a2)
{
  return MEMORY[0x24BEB3FC8](this, a2);
}

uint64_t TSUCustomFormat::hash(TSUCustomFormat *this)
{
  return MEMORY[0x24BEB3FD0](this);
}

void TSUCustomFormat::TSUCustomFormat(TSUCustomFormat *this, const TSUCustomFormat *a2)
{
  MEMORY[0x24BEB3FD8](this, a2);
}

void TSUCustomFormat::~TSUCustomFormat(TSUCustomFormat *this)
{
  MEMORY[0x24BEB3FE0](this);
}

uint64_t TSUFormat::TSUFormat()
{
  return MEMORY[0x24BEB3FE8]();
}

void TSUFormat::~TSUFormat(TSUFormat *this)
{
  MEMORY[0x24BEB3FF0](this);
}

uint64_t TSUCustomFormat::defaultFormatData(TSUCustomFormat *this)
{
  return MEMORY[0x24BEB3FF8](this);
}

uint64_t TSUCustomFormat::formatByEvaluatingConditionsWithDouble(TSUCustomFormat *this, double a2)
{
  return MEMORY[0x24BEB4000](this, a2);
}

uint64_t TSUFormat::isEqual(TSUFormat *this, const TSUFormat *a2)
{
  return MEMORY[0x24BEB4008](this, a2);
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x24BEDA9E0]();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x24BEDAA60](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x24BEDAA70](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAA8](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x24BEDABB0](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x24BEDABE8](__n);
}

std::string *__cdecl std::string::erase(std::string *this, std::string::size_type __pos, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x24BEDAC20](this, __pos, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x24BEDAC38](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x24BEDAC40](this, __s, __n);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x24BEDAC58](this, __s);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
  MEMORY[0x24BEDAC98](this, __n, __c);
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x24BEDACE8](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x24BEDAD00](this, __str);
}

uint64_t std::istream::peek()
{
  return MEMORY[0x24BEDAE10]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x24BEDAE70]();
}

uint64_t std::istream::operator>>()
{
  return MEMORY[0x24BEDAE80]();
}

{
  return MEMORY[0x24BEDAE88]();
}

{
  return MEMORY[0x24BEDAE90]();
}

{
  return MEMORY[0x24BEDAEA0]();
}

{
  return MEMORY[0x24BEDAEA8]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x24BEDAEF8]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x24BEDAF00]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x24BEDAF30]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x24BEDB010]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x24BEDB048]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x24BEDB050]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB180](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB190](this);
}

uint64_t std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>()
{
  return MEMORY[0x24BEDB3B8]();
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x24BEDB448](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x24BEDB518](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x24BEDB530](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x24BEDB5E8]();
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

uint64_t operator delete[]()
{
  return off_24D827DF8();
}

void operator delete(void *__p)
{
  off_24D827E00(__p);
}

void operator delete(void *__p, const std::nothrow_t *a2)
{
  off_24D827E08(__p, a2);
}

uint64_t operator delete()
{
  return off_24D827E10();
}

uint64_t operator new[]()
{
  return off_24D827E18();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_24D827E20(__sz);
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
  return (void *)off_24D827E28(__sz, a2);
}

uint64_t operator new()
{
  return off_24D827E30();
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x24BEDB8F8](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x24BEDB910](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x24BEDB928]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x24BEDB930](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x24BEDB940](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x24BEDB948](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x24BEDB950](a1);
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x24BEDB960](a1, lptinfo, a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x24BDAC7D0]();
}

double __exp10(double a1)
{
  double result;

  MEMORY[0x24BDAC7D8](a1);
  return result;
}

int __fpclassifyd(double a1)
{
  return MEMORY[0x24BDAC7F0](a1);
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x24BDAC838](*(_QWORD *)&a1, a2);
}

__double2 __sincos_stret(double a1)
{
  double v1;
  double v2;
  __double2 result;

  MEMORY[0x24BDAC890](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  float v1;
  float v2;
  __float2 result;

  MEMORY[0x24BDAC898](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB80](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

void abort(void)
{
  MEMORY[0x24BDAD008]();
}

long double acos(long double __x)
{
  long double result;

  MEMORY[0x24BDAD108](__x);
  return result;
}

float acosf(float a1)
{
  float result;

  MEMORY[0x24BDAD110](a1);
  return result;
}

long double asin(long double __x)
{
  long double result;

  MEMORY[0x24BDAD188](__x);
  return result;
}

long double atan2(long double __y, long double __x)
{
  long double result;

  MEMORY[0x24BDAD220](__y, __x);
  return result;
}

void *__cdecl bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return (void *)MEMORY[0x24BDAD310](__key, __base, __nel, __width, __compar);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
  return MEMORY[0x24BEDCE40](cls, name, imp, types);
}

BOOL class_conformsToProtocol(Class cls, Protocol *protocol)
{
  return MEMORY[0x24BEDCE60](cls, protocol);
}

size_t class_getInstanceSize(Class cls)
{
  return MEMORY[0x24BEDCEA8](cls);
}

const char *__cdecl class_getName(Class cls)
{
  return (const char *)MEMORY[0x24BEDCEC0](cls);
}

Class class_getSuperclass(Class cls)
{
  return (Class)MEMORY[0x24BEDCED0](cls);
}

int close(int a1)
{
  return MEMORY[0x24BDAD9D8](*(_QWORD *)&a1);
}

long double cos(long double __x)
{
  long double result;

  MEMORY[0x24BDADBE0](__x);
  return result;
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADC60](when, queue, block);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC0](queue, block);
}

void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCE0](queue, block);
}

void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCF8](queue, block);
}

BOOL dispatch_data_apply(dispatch_data_t data, dispatch_data_applier_t applier)
{
  return MEMORY[0x24BDADD48](data, applier);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return (dispatch_data_t)MEMORY[0x24BDADD60](buffer, size, queue, destructor);
}

dispatch_data_t dispatch_data_create_concat(dispatch_data_t data1, dispatch_data_t data2)
{
  return (dispatch_data_t)MEMORY[0x24BDADD70](data1, data2);
}

dispatch_data_t dispatch_data_create_subrange(dispatch_data_t data, size_t offset, size_t length)
{
  return (dispatch_data_t)MEMORY[0x24BDADD80](data, offset, length);
}

size_t dispatch_data_get_size(dispatch_data_t data)
{
  return MEMORY[0x24BDADD90](data);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x24BDADDA8](identifier, flags);
}

void *__cdecl dispatch_get_specific(const void *key)
{
  return (void *)MEMORY[0x24BDADDB0](key);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADDB8](group, queue, block);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x24BDADDC8]();
}

void dispatch_group_enter(dispatch_group_t group)
{
  MEMORY[0x24BDADDD0](group);
}

void dispatch_group_leave(dispatch_group_t group)
{
  MEMORY[0x24BDADDD8](group);
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADDF0](group, timeout);
}

void dispatch_io_barrier(dispatch_io_t channel, dispatch_block_t barrier)
{
  MEMORY[0x24BDADDF8](channel, barrier);
}

void dispatch_io_close(dispatch_io_t channel, dispatch_io_close_flags_t flags)
{
  MEMORY[0x24BDADE00](channel, flags);
}

dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t queue, void *cleanup_handler)
{
  return (dispatch_io_t)MEMORY[0x24BDADE08](type, *(_QWORD *)&fd, queue, cleanup_handler);
}

void dispatch_io_write(dispatch_io_t channel, off_t offset, dispatch_data_t data, dispatch_queue_t queue, dispatch_io_handler_t io_handler)
{
  MEMORY[0x24BDADE38](channel, offset, data, queue, io_handler);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED0](label, attr);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
  MEMORY[0x24BDADF00](queue, key, context, destructor);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x24BDADF10](object);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x24BDADF18](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x24BDADF20](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x24BDADF28](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x24BDADF30](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADF38](dsema, timeout);
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
  MEMORY[0x24BDADF60](object, queue);
}

void dispatch_suspend(dispatch_object_t object)
{
  MEMORY[0x24BDADFE0](object);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADFE8](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x24BDADFF8](when, delta);
}

long double exp2(long double __x)
{
  long double result;

  MEMORY[0x24BDAE278](__x);
  return result;
}

float exp2f(float a1)
{
  float result;

  MEMORY[0x24BDAE280](a1);
  return result;
}

long double fmod(long double __x, long double __y)
{
  long double result;

  MEMORY[0x24BDAE3F0](__x, __y);
  return result;
}

float fmodf(float a1, float a2)
{
  float result;

  MEMORY[0x24BDAE3F8](a1, a2);
  return result;
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAE428](a1, a2);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

long double frexp(long double __x, int *__e)
{
  long double result;

  MEMORY[0x24BDAE480](__e, __x);
  return result;
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE590](__ptr, __size, __nitems, __stream);
}

int getrlimit(int a1, rlimit *a2)
{
  return MEMORY[0x24BDAE730](*(_QWORD *)&a1, a2);
}

long double hypot(long double __x, long double __y)
{
  long double result;

  MEMORY[0x24BDAE838](__x, __y);
  return result;
}

long double ldexp(long double __x, int __e)
{
  long double result;

  MEMORY[0x24BDAEA30](*(_QWORD *)&__e, __x);
  return result;
}

float ldexpf(float a1, int a2)
{
  float result;

  MEMORY[0x24BDAEA38](*(_QWORD *)&a2, a1);
  return result;
}

long double log(long double __x)
{
  long double result;

  MEMORY[0x24BDAEAA8](__x);
  return result;
}

long double log2(long double __x)
{
  long double result;

  MEMORY[0x24BDAEAD8](__x);
  return result;
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x24BDAEC68](info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED70](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED88](ptr, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE70](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x24BDAEEB0](__b, __pattern16, __len);
}

int mergesort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return MEMORY[0x24BDAEED0](__base, __nel, __width, __compar);
}

long double nextafter(long double __x, long double __y)
{
  long double result;

  MEMORY[0x24BDAF110](__x, __y);
  return result;
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x24BEDCF68](a1);
}

id objc_allocWithZone(Class a1)
{
  return (id)MEMORY[0x24BEDCF78](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x24BEDCF88]();
}

Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)
{
  return (Class)MEMORY[0x24BEDCF90](superclass, name, extraBytes);
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x24BEDCFA8](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x24BEDCFB0](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x24BEDCFC0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDCFD0](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x24BEDCFD8](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x24BEDCFE8]();
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
  MEMORY[0x24BEDD020](dest, src, size, atomic, hasStrong);
}

void objc_copyWeak(id *to, id *from)
{
  MEMORY[0x24BEDD030](to, from);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x24BEDD038](location);
}

void objc_end_catch(void)
{
  MEMORY[0x24BEDD050]();
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x24BEDD068](obj);
}

void objc_exception_rethrow(void)
{
  MEMORY[0x24BEDD070]();
}

void objc_exception_throw(id exception)
{
  MEMORY[0x24BEDD078](exception);
}

id objc_getAssociatedObject(id object, const void *key)
{
  return (id)MEMORY[0x24BEDD080](object, key);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x24BEDD0B0](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x24BEDD0C0](location, val);
}

id objc_loadWeak(id *location)
{
  return (id)MEMORY[0x24BEDD0D8](location);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x24BEDD0E8](location);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD108](a1, a2);
}

id objc_msgSendSuper(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD110](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD120](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x24BEDD130]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x24BEDD138]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x24BEDD148]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x24BEDD160]();
}

void objc_registerClassPair(Class cls)
{
  MEMORY[0x24BEDD170](cls);
}

void objc_release(id a1)
{
  MEMORY[0x24BEDD188](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x24BEDD2A0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x24BEDD2A8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B0](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B8](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x24BEDD2C0](a1);
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
  MEMORY[0x24BEDD3C0](object, key, value, policy);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x24BEDD3D0](self, _cmd, newValue, offset);
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x24BEDD3E0](self, _cmd, newValue, offset);
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x24BEDD3F0](self, _cmd, newValue, offset);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x24BEDD408](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x24BEDD410](location, obj);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x24BEDD420](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x24BEDD438](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x24BEDD440](obj);
}

void objc_terminate(void)
{
  MEMORY[0x24BEDD450]();
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD458](a1);
}

Class object_getClass(id a1)
{
  return (Class)MEMORY[0x24BEDD460](a1);
}

const char *__cdecl object_getClassName(id a1)
{
  return (const char *)MEMORY[0x24BEDD468](a1);
}

Class object_setClass(id a1, Class a2)
{
  return (Class)MEMORY[0x24BEDD490](a1, a2);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x24BDAF460](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x24BDAF488](lock);
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x24BDAF688](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  float result;

  MEMORY[0x24BDAF690](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x24BDAF6A8](a1);
}

int pthread_main_np(void)
{
  return MEMORY[0x24BDAF8B0]();
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8C0](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x24BDAF8C8](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8D0](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8E0](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x24BDAF8E8](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x24BDAF8F0](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x24BDAF908](a1, *(_QWORD *)&a2);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x24BDAF910](a1, a2);
}

int pthread_rwlock_destroy(pthread_rwlock_t *a1)
{
  return MEMORY[0x24BDAF930](a1);
}

int pthread_rwlock_init(pthread_rwlock_t *a1, const pthread_rwlockattr_t *a2)
{
  return MEMORY[0x24BDAF938](a1, a2);
}

int pthread_rwlock_rdlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x24BDAF940](a1);
}

int pthread_rwlock_unlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x24BDAF958](a1);
}

int pthread_rwlock_wrlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x24BDAF960](a1);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x24BDAF978]();
}

int putchar(int a1)
{
  return MEMORY[0x24BDAF9F0](*(_QWORD *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x24BDAF9F8](a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x24BDAFA18](__base, __nel, __width, __compar);
}

void qsort_b(void *__base, size_t __nel, size_t __width, void *__compar)
{
  MEMORY[0x24BDAFA20](__base, __nel, __width, __compar);
}

uint64_t random(void)
{
  return MEMORY[0x24BDAFA48]();
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x24BDAFAB8](__ptr, __size);
}

int rmdir(const char *a1)
{
  return MEMORY[0x24BDAFBB0](a1);
}

const char *__cdecl sel_getName(SEL sel)
{
  return (const char *)MEMORY[0x24BEDD500](sel);
}

BOOL sel_isEqual(SEL lhs, SEL rhs)
{
  return MEMORY[0x24BEDD510](lhs, rhs);
}

int setrlimit(int a1, const rlimit *a2)
{
  return MEMORY[0x24BDAFD60](*(_QWORD *)&a1, a2);
}

long double sin(long double __x)
{
  long double result;

  MEMORY[0x24BDAFE18](__x);
  return result;
}

float sinf(float a1)
{
  float result;

  MEMORY[0x24BDAFE20](a1);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

int sqlite3_blob_bytes(sqlite3_blob *a1)
{
  return MEMORY[0x24BEDDFC0](a1);
}

int sqlite3_blob_close(sqlite3_blob *a1)
{
  return MEMORY[0x24BEDDFC8](a1);
}

int sqlite3_blob_read(sqlite3_blob *a1, void *Z, int N, int iOffset)
{
  return MEMORY[0x24BEDDFD8](a1, Z, *(_QWORD *)&N, *(_QWORD *)&iOffset);
}

void srandom(unsigned int a1)
{
  MEMORY[0x24BDAFE98](*(_QWORD *)&a1);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAFEA0](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x24BDAFEE8](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x24BDAFF18](*(_QWORD *)&__errnum);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x24BDAFF68](__s1, __s2, __n);
}

long double tan(long double __x)
{
  long double result;

  MEMORY[0x24BDB0138](__x);
  return result;
}

UCharDirection u_charDirection(UChar32 c)
{
  return MEMORY[0x24BEDBF40](*(_QWORD *)&c);
}

int32_t u_getIntPropertyValue(UChar32 c, UProperty which)
{
  return MEMORY[0x24BEDBF68](*(_QWORD *)&c, *(_QWORD *)&which);
}

UBlockCode ublock_getCode(UChar32 c)
{
  return MEMORY[0x24BEDC068](*(_QWORD *)&c);
}

int unlink(const char *a1)
{
  return MEMORY[0x24BDB02B0](a1);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x24BDB0358](a1, a2, a3);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x24BDB0558](*(_QWORD *)&__fd, __buf, __nbyte);
}

const xmlChar *__cdecl xmlBufferContent(const xmlBuffer *buf)
{
  return (const xmlChar *)MEMORY[0x24BEDE630](buf);
}

xmlBufferPtr xmlBufferCreate(void)
{
  return (xmlBufferPtr)MEMORY[0x24BEDE638]();
}

void xmlBufferFree(xmlBufferPtr buf)
{
  MEMORY[0x24BEDE650](buf);
}

xmlNodePtr xmlDocGetRootElement(const xmlDoc *doc)
{
  return (xmlNodePtr)MEMORY[0x24BEDE740](doc);
}

void xmlFreeDoc(xmlDocPtr cur)
{
  MEMORY[0x24BEDE760](cur);
}

xmlExternalEntityLoader xmlGetExternalEntityLoader(void)
{
  return (xmlExternalEntityLoader)MEMORY[0x24BEDE7E0]();
}

xmlAttrPtr xmlHasNsProp(const xmlNode *node, const xmlChar *name, const xmlChar *nameSpace)
{
  return (xmlAttrPtr)MEMORY[0x24BEDE830](node, name, nameSpace);
}

xmlAttrPtr xmlHasProp(const xmlNode *node, const xmlChar *name)
{
  return (xmlAttrPtr)MEMORY[0x24BEDE838](node, name);
}

int xmlNodeBufGetContent(xmlBufferPtr buffer, const xmlNode *cur)
{
  return MEMORY[0x24BEDEA30](buffer, cur);
}

int xmlNodeIsText(const xmlNode *node)
{
  return MEMORY[0x24BEDEA60](node);
}

xmlChar *__cdecl xmlNodeListGetString(xmlDocPtr doc, const xmlNode *list, int inLine)
{
  return (xmlChar *)MEMORY[0x24BEDEA68](doc, list, *(_QWORD *)&inLine);
}

xmlDocPtr xmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
{
  return (xmlDocPtr)MEMORY[0x24BEDEB00](buffer, *(_QWORD *)&size, URL, encoding, *(_QWORD *)&options);
}

xmlEntityPtr xmlSAX2GetEntity(void *ctx, const xmlChar *name)
{
  return (xmlEntityPtr)MEMORY[0x24BEDEB30](ctx, name);
}

xmlDocPtr xmlSAXParseMemory(xmlSAXHandlerPtr sax, const char *buffer, int size, int recovery)
{
  return (xmlDocPtr)MEMORY[0x24BEDEB48](sax, buffer, *(_QWORD *)&size, *(_QWORD *)&recovery);
}

int xmlSAXVersion(xmlSAXHandler *hdlr, int version)
{
  return MEMORY[0x24BEDEB50](hdlr, *(_QWORD *)&version);
}

xmlNsPtr xmlSearchNsByHref(xmlDocPtr doc, xmlNodePtr node, const xmlChar *href)
{
  return (xmlNsPtr)MEMORY[0x24BEDEBE0](doc, node, href);
}

void xmlSetExternalEntityLoader(xmlExternalEntityLoader f)
{
  MEMORY[0x24BEDEBF0](f);
}

int xmlSubstituteEntitiesDefault(int val)
{
  return MEMORY[0x24BEDECB0](*(_QWORD *)&val);
}

xmlXPathObjectPtr xmlXPathEvalExpression(const xmlChar *str, xmlXPathContextPtr ctxt)
{
  return (xmlXPathObjectPtr)MEMORY[0x24BEDEED0](str, ctxt);
}

void xmlXPathFreeContext(xmlXPathContextPtr ctxt)
{
  MEMORY[0x24BEDEEE8](ctxt);
}

void xmlXPathFreeObject(xmlXPathObjectPtr obj)
{
  MEMORY[0x24BEDEEF8](obj);
}

xmlXPathContextPtr xmlXPathNewContext(xmlDocPtr doc)
{
  return (xmlXPathContextPtr)MEMORY[0x24BEDEF58](doc);
}

int xmlXPathRegisterNs(xmlXPathContextPtr ctxt, const xmlChar *prefix, const xmlChar *ns_uri)
{
  return MEMORY[0x24BEDF038](ctxt, prefix, ns_uri);
}

