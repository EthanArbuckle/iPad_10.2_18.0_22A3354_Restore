void sub_2179782F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_217978610(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2179786BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  void *v9;

  _Unwind_Resume(a1);
}

void sub_217978758(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_2179787BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)TSPAVAssetResourceLoaderDelegate;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_2179789C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  void *v16;

  _Unwind_Resume(a1);
}

void sub_217978BA0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_217978D80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_217979374(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_2179794AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)TSPCryptoComponentWriteChannel;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_217979710(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_2179799BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217979DF8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_217979F0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)TSPCryptoReadChannel;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_21797A0A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_21797A954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  uint64_t v48;

  _Block_object_dispose(&a44, 8);
  _Block_object_dispose((const void *)(v48 - 136), 8);

  _Unwind_Resume(a1);
}

void sub_21797AD18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_21797AE20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_21797AF78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_21797B128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_21797B234(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_21797B428(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_21797B600(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_21797B6C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_21797B7E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_21797B88C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_21797B98C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v13 = v12;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__5(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{

}

void sub_21797CB2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_21797DCC0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL TSKMainThreadRunLoopEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t TSKMainThreadRunLoopPerform()
{
  objc_opt_class();
  return objc_msgSend((id)TSUDynamicCast(), "p_flushPendingMainThreadBlocksQueueAcquiringLock:", 1);
}

void sub_21797E6BC(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_21797E6DC(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x21797E69CLL);
}

void sub_21797E820(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_21797E95C(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x21797E92CLL);
}

void sub_21797EBC0(void *exc_buf)
{
  char v1;

  if ((v1 & 1) != 0)
    objc_end_catch();
  objc_begin_catch(exc_buf);
  JUMPOUT(0x21797EB84);
}

void sub_21797EE8C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_21797EEAC(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x21797EE24);
}

void sub_21797F1CC(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_21797F1EC(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x21797F1A0);
}

void sub_21797F380(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_21797F3A0(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x21797F34CLL);
}

void sub_21797F89C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_21797F8BC(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x21797F878);
}

void sub_21797F9B8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_21797F9D8(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x21797F970);
}

void sub_21797FBE8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_21797FC08(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x21797FBB8);
}

void sub_2179810A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21798111C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2179811AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2179812A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_217981318(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_217981390(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_217981408(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_217981480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2179814F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_217981570(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2179815E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_217981660(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2179830FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSKModelPathToDescendant(void *a1, void *a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  void *v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _BYTE v24[128];
  _BYTE v25[128];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if ((objc_opt_respondsToSelector() & 1) == 0)
    return 0;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v4 = (void *)objc_msgSend(a1, "childEnumerator");
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v20, v25, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v21;
LABEL_4:
    v8 = 0;
    while (1)
    {
      if (*(_QWORD *)v21 != v7)
        objc_enumerationMutation(v4);
      if (*(void **)(*((_QWORD *)&v20 + 1) + 8 * v8) == a2)
        break;
      if (v6 == ++v8)
      {
        v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v20, v25, 16);
        v6 = v5;
        if (v5)
          goto LABEL_4;
        goto LABEL_13;
      }
    }
    result = __TSKModelPathToDescendant_block_invoke(v5, a1, a2);
    if (result)
      return result;
  }
LABEL_13:
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v10 = (void *)objc_msgSend(a1, "childEnumerator", 0);
  result = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v16, v24, 16);
  if (result)
  {
    v11 = result;
    v12 = *(_QWORD *)v17;
    while (2)
    {
      for (i = 0; i != v11; ++i)
      {
        if (*(_QWORD *)v17 != v12)
          objc_enumerationMutation(v10);
        v14 = *(void **)(*((_QWORD *)&v16 + 1) + 8 * i);
        v15 = TSKModelPathToDescendant(v14, a2);
        if (v15)
          return objc_msgSend((id)__TSKModelPathToDescendant_block_invoke(v15, a1, v14), "stringByAppendingPathComponent:", v15);
      }
      v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v16, v24, 16);
      result = 0;
      if (v11)
        continue;
      break;
    }
  }
  return result;
}

void sub_217984964(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217984A08(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t TSKBundle()
{
  if (TSKBundle_onceToken != -1)
    dispatch_once(&TSKBundle_onceToken, &__block_literal_global_10);
  return TSKBundle_sTSKBundle;
}

void sub_217990218(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217990274(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217990354(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217996528(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179965F0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217996710(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217996818(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217996974(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217996D34(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179971F8(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x217997124);
  }
  _Unwind_Resume(a1);
}

void sub_217997208(_Unwind_Exception *a1)
{
  void *v1;

  objc_end_catch();
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217997228(uint64_t a1, int a2)
{
  if (!a2)
    JUMPOUT(0x217997230);
  objc_terminate();
}

void sub_217999890(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t TSKPositionSearchReferenceComparator_block_invoke(uint64_t a1, void *a2, void *a3)
{
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;

  objc_msgSend(a2, "searchReferencePoint");
  v6 = v5;
  v8 = v7;
  objc_msgSend(a3, "searchReferencePoint");
  if (v6 == v9 && v8 == v10)
  {
    v15 = objc_msgSend(a2, "model");
    if (v15 != objc_msgSend(a3, "model"))
      return 0;
    result = objc_msgSend((id)objc_msgSend(a2, "selection"), "compare:", objc_msgSend(a3, "selection"));
    if (result)
      return result;
    v16 = objc_msgSend(a2, "annotation");
    if (v16 == objc_msgSend(a3, "annotation"))
      return 0;
    if (!objc_msgSend(a2, "annotation"))
      return -1;
    if (!objc_msgSend(a3, "annotation"))
      return 1;
    v17 = objc_msgSend((id)objc_msgSend(a2, "annotation"), "annotationType");
    if (v17 < objc_msgSend((id)objc_msgSend(a3, "annotation"), "annotationType"))
      return -1;
    v18 = objc_msgSend((id)objc_msgSend(a2, "annotation"), "annotationType");
    return v18 > objc_msgSend((id)objc_msgSend(a3, "annotation"), "annotationType");
  }
  else
  {
    v12 = 1;
    v13 = -1;
    if (v6 >= v9)
      v13 = v6 > v9;
    if (v8 <= v10)
      v12 = v13;
    if (v8 >= v10)
      return v12;
    else
      return -1;
  }
}

uint64_t TSKSearchReferenceComparison(void *a1, void *a2)
{
  return TSKPositionSearchReferenceComparator_block_invoke((uint64_t)a1, a1, a2);
}

void sub_21799E2F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__6(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_21799E9E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_21799EEF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

CFIndex p_registerProperty(uint64_t a1, const void *a2)
{
  const __CFDictionary *v4;
  void *v5;
  uint64_t v6;
  CFIndex Count;
  void *v8;
  uint64_t v9;
  CFIndex v10;
  void *v11;
  uint64_t v12;
  CFIndex v13;
  CFIndex result;
  void *v15;
  uint64_t v16;
  int v17;

  v4 = (const __CFDictionary *)sStringToPropertyMap;
  if (!sStringToPropertyMap)
  {
    if (sPropertyToStringMap)
    {
      v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_registerProperty(TSSProperty, NSString *)");
      objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSProperties.m"), 25, CFSTR("Two-way dictionaries not set up correctly."));
    }
    sStringToPropertyMap = (uint64_t)CFDictionaryCreateMutable(0, 4624, MEMORY[0x24BDBD6A0], 0);
    sPropertyToStringMap = (uint64_t)CFDictionaryCreateMutable(0, 4624, 0, MEMORY[0x24BDBD6B0]);
    v4 = (const __CFDictionary *)sStringToPropertyMap;
  }
  Count = CFDictionaryGetCount(v4);
  CFDictionaryAddValue((CFMutableDictionaryRef)sStringToPropertyMap, a2, (const void *)(int)a1);
  if (CFDictionaryGetCount((CFDictionaryRef)sStringToPropertyMap) != Count + 1)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_registerProperty(TSSProperty, NSString *)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSProperties.m"), 37, CFSTR("Likely collision in string to property dictionary around %@ (%d)"), a2, a1);
  }
  v10 = CFDictionaryGetCount((CFDictionaryRef)sPropertyToStringMap);
  CFDictionaryAddValue((CFMutableDictionaryRef)sPropertyToStringMap, (const void *)(int)a1, a2);
  if (CFDictionaryGetCount((CFDictionaryRef)sPropertyToStringMap) != v10 + 1)
  {
    v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_registerProperty(TSSProperty, NSString *)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSProperties.m"), 42, CFSTR("Likely collision in property to string dictionary around %@ (%d)"), a2, a1);
  }
  v13 = CFDictionaryGetCount((CFDictionaryRef)sStringToPropertyMap);
  result = CFDictionaryGetCount((CFDictionaryRef)sPropertyToStringMap);
  if (v13 != result)
  {
    v15 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v16 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void p_registerProperty(TSSProperty, NSString *)");
    result = objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSProperties.m"), 45, CFSTR("Two-way string to property id dictionaries are out of sync."));
  }
  v17 = sMaxPropertyValue;
  if (sMaxPropertyValue <= (int)a1)
    v17 = a1;
  sMaxPropertyValue = v17;
  return result;
}

BOOL String(void *key, _DWORD *a2)
{
  int ValueIfPresent;
  void *value;

  if (p_buildStringToPropertyMapsIfNeeded_onceToken != -1)
    dispatch_once(&p_buildStringToPropertyMapsIfNeeded_onceToken, &__block_literal_global_18);
  value = 0;
  ValueIfPresent = CFDictionaryGetValueIfPresent((CFDictionaryRef)sStringToPropertyMap, key, (const void **)&value);
  if (a2)
    *a2 = (_DWORD)value;
  return ValueIfPresent != 0;
}

uint64_t String(void *a1)
{
  void *v2;
  uint64_t v3;
  unsigned int v5;

  v5 = 0;
  if (!String(a1, &v5))
  {
    v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSSProperty TSSPropertyFromString(NSString *)");
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSProperties.m"), 91, CFSTR("Unknown property key string: %@"), a1);
  }
  return v5;
}

{
  void *v1;
  void *v2;

  v1 = (void *)objc_msgSend(a1, "componentsSeparatedByString:", CFSTR("-"));
  if (v1 && (v2 = v1, (unint64_t)objc_msgSend(v1, "count") >= 3))
    return (int)objc_msgSend((id)objc_msgSend(v2, "objectAtIndexedSubscript:", 1), "intValue");
  else
    return 0x7FFFFFFFFFFFFFFFLL;
}

{
  void *v1;
  void *v2;

  v1 = (void *)objc_msgSend(a1, "componentsSeparatedByString:", CFSTR("-"));
  if (v1 && (v2 = v1, (unint64_t)objc_msgSend(v1, "count") >= 3))
    return objc_msgSend(v2, "objectAtIndexedSubscript:", 0);
  else
    return 0;
}

{
  void *v1;
  void *v2;

  v1 = (void *)objc_msgSend(a1, "componentsSeparatedByString:", CFSTR("-"));
  if (v1 && (v2 = v1, (unint64_t)objc_msgSend(v1, "count") >= 3))
    return objc_msgSend(v2, "objectAtIndexedSubscript:", 2);
  else
    return 0;
}

{
  void *v1;
  void *v2;

  v1 = (void *)objc_msgSend(a1, "componentsSeparatedByString:", CFSTR("-"));
  if (v1 && (v2 = v1, objc_msgSend(v1, "count") == 4))
    return objc_msgSend(v2, "objectAtIndexedSubscript:", 3);
  else
    return 0;
}

{
  void *v2;
  _QWORD v4[5];
  _QWORD v5[5];
  _QWORD v6[2];

  v6[1] = *MEMORY[0x24BDAC8D0];
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v6[0] = a1;
    a1 = (void *)objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v6, 1);
  }
  else
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
      a1 = 0;
  }
  v2 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "stringWithString:", CFSTR("$Source Class|Source|Relationship|Target|Target Sheet||Root Sheet|Child Sheet$"));
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 3221225472;
  v5[2] = __TSSDebugStyleRelationshipDescription_block_invoke;
  v5[3] = &unk_24D82AFA8;
  v5[4] = v2;
  if (a1)
  {
    v4[0] = MEMORY[0x24BDAC760];
    v4[1] = 3221225472;
    v4[2] = __TSSDebugStyleRelationshipDescription_block_invoke_2;
    v4[3] = &unk_24D82AFF8;
    v4[4] = v5;
    objc_msgSend(a1, "enumerateObjectsUsingBlock:", v4);
  }
  return objc_msgSend(v2, "tsu_stringByExpandingTableFormatting");
}

BOOL String(int a1, void **a2)
{
  int ValueIfPresent;
  void *value;

  if (p_buildStringToPropertyMapsIfNeeded_onceToken != -1)
    dispatch_once(&p_buildStringToPropertyMapsIfNeeded_onceToken, &__block_literal_global_18);
  value = 0;
  ValueIfPresent = CFDictionaryGetValueIfPresent((CFDictionaryRef)sPropertyToStringMap, (const void *)a1, (const void **)&value);
  if (a2)
    *a2 = value;
  return ValueIfPresent != 0;
}

void *String(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v5;

  v5 = 0;
  if (!String(a1, &v5))
  {
    v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSSStringFromProperty(TSSProperty)");
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSProperties.m"), 117, CFSTR("Unknown property key integer %u"), a1);
  }
  return v5;
}

BOOL String(_BOOL8 result)
{
  if (result)
    return String(result, 0);
  return result;
}

__CFString *String(unsigned int a1)
{
  void *v2;
  uint64_t v3;

  if (a1 < 4)
    return off_24D82AE18[(char)a1];
  v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSSStringFromValueType(TSSValueType)");
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSProperties.m"), 171, CFSTR("Unexpected entry type."));
  return 0;
}

CFIndex __p_buildStringToPropertyMapsIfNeeded_block_invoke()
{
  p_registerProperty(0, CFSTR("invalidProperty"));
  p_registerProperty(1, CFSTR("testString"));
  p_registerProperty(2, CFSTR("testDate"));
  p_registerProperty(3, CFSTR("testObject"));
  p_registerProperty(4, CFSTR("testObject2"));
  p_registerProperty(5, CFSTR("testTSPObject"));
  p_registerProperty(6, CFSTR("testTSPContainedObject"));
  p_registerProperty(7, CFSTR("testStyle"));
  p_registerProperty(8, CFSTR("testBool"));
  p_registerProperty(9, CFSTR("testInteger"));
  p_registerProperty(10, CFSTR("testInteger2"));
  p_registerProperty(11, CFSTR("testEnum"));
  p_registerProperty(12, CFSTR("testFloat"));
  p_registerProperty(13, CFSTR("testFloat2"));
  p_registerProperty(14, CFSTR("testDouble"));
  p_registerProperty(15, CFSTR("testDouble2"));
  p_registerProperty(16, CFSTR("fontName"));
  p_registerProperty(17, CFSTR("fontSize"));
  p_registerProperty(18, CFSTR("fontColor"));
  p_registerProperty(19, CFSTR("bold"));
  p_registerProperty(20, CFSTR("italic"));
  p_registerProperty(21, CFSTR("capitalization"));
  p_registerProperty(22, CFSTR("underline"));
  p_registerProperty(23, CFSTR("underlineWidth"));
  p_registerProperty(24, CFSTR("underlineColor"));
  p_registerProperty(25, CFSTR("word_underline"));
  p_registerProperty(26, CFSTR("strikethru"));
  p_registerProperty(27, CFSTR("strikethruWidth"));
  p_registerProperty(28, CFSTR("strikethruColor"));
  p_registerProperty(29, CFSTR("word_strikethrough"));
  p_registerProperty(30, CFSTR("hidden"));
  p_registerProperty(31, CFSTR("outline"));
  p_registerProperty(32, CFSTR("outlineColor"));
  p_registerProperty(33, CFSTR("baselineShift"));
  p_registerProperty(34, CFSTR("kerning"));
  p_registerProperty(35, CFSTR("tracking"));
  p_registerProperty(36, CFSTR("superscript"));
  p_registerProperty(37, CFSTR("textBackground"));
  p_registerProperty(38, CFSTR("dropCapBackground"));
  p_registerProperty(39, CFSTR("language"));
  p_registerProperty(40, CFSTR("textShadow"));
  p_registerProperty(41, CFSTR("ligatures"));
  p_registerProperty(42, CFSTR("hotKey"));
  p_registerProperty(43, CFSTR("coreTextFontFeatures"));
  p_registerProperty(44, CFSTR("writingDirection"));
  p_registerProperty(45, CFSTR("emphasisMarks"));
  p_registerProperty(46, CFSTR("compatibilityFont"));
  p_registerProperty(47, CFSTR("role"));
  p_registerProperty(48, CFSTR("allowNativeSmallCaps"));
  p_registerProperty(49, CFSTR("outlineFilled"));
  p_registerProperty(50, CFSTR("weight"));
  p_registerProperty(51, CFSTR("lineBalancing"));
  p_registerProperty(52, CFSTR("fontSizeDelta"));
  p_registerProperty(53, CFSTR("coreTextFontAttributes"));
  p_registerProperty(54, CFSTR("fontDesignTrait"));
  p_registerProperty(55, CFSTR("fontFamily"));
  p_registerProperty(56, CFSTR("monospacedDigits"));
  p_registerProperty(80, CFSTR("firstLineIndent"));
  p_registerProperty(81, CFSTR("leftIndent"));
  p_registerProperty(82, CFSTR("rightIndent"));
  p_registerProperty(83, CFSTR("defaultTabStops"));
  p_registerProperty(84, CFSTR("tabs"));
  p_registerProperty(85, CFSTR("lineSpacing"));
  p_registerProperty(86, CFSTR("alignment"));
  p_registerProperty(87, CFSTR("spaceBefore"));
  p_registerProperty(88, CFSTR("spaceAfter"));
  p_registerProperty(89, CFSTR("keepLinesTogether"));
  p_registerProperty(90, CFSTR("keepWithNext"));
  p_registerProperty(91, CFSTR("pageBreakBefore"));
  p_registerProperty(92, CFSTR("widowControl"));
  p_registerProperty(93, CFSTR("hyphenate"));
  p_registerProperty(94, CFSTR("hyphenationMinimumWordLength"));
  p_registerProperty(95, CFSTR("hyphenationMinimumCharactersBefore"));
  p_registerProperty(96, CFSTR("hyphenationMinimumCharactersAfter"));
  p_registerProperty(97, CFSTR("hyphenationZone"));
  p_registerProperty(98, CFSTR("paragraphFill"));
  p_registerProperty(99, CFSTR("followingParagraphStyle"));
  p_registerProperty(100, CFSTR("firstTopicNumber"));
  p_registerProperty(101, CFSTR("decimalTab"));
  p_registerProperty(102, CFSTR("paragraphBorderType"));
  p_registerProperty(103, CFSTR("paragraphStroke"));
  p_registerProperty(104, CFSTR("paragraphRuleWidth"));
  p_registerProperty(105, CFSTR("paragraphRuleOffset"));
  p_registerProperty(106, CFSTR("outlineLevel"));
  p_registerProperty(107, CFSTR("outlineStyleType"));
  p_registerProperty(108, CFSTR("listStyle"));
  p_registerProperty(109, CFSTR("dropCap"));
  p_registerProperty(110, CFSTR("hangingPunctuation"));
  p_registerProperty(111, CFSTR("lineStyling"));
  p_registerProperty(112, CFSTR("followingParagraphStyleIdentifier"));
  p_registerProperty(113, CFSTR("showInTOC"));
  p_registerProperty(114, CFSTR("tocStyle"));
  p_registerProperty(136, CFSTR("TSWPTOCShowPageNumber"));
  p_registerProperty(137, CFSTR("TSWPTOCPageNumberStyle"));
  p_registerProperty(144, CFSTR("layoutParagraphStyle"));
  p_registerProperty(145, CFSTR("layoutMargins"));
  p_registerProperty(146, CFSTR("padding"));
  p_registerProperty(147, CFSTR("minimumHorizontalInset"));
  p_registerProperty(148, CFSTR("columns"));
  p_registerProperty(149, CFSTR("verticalAlignment"));
  p_registerProperty(150, CFSTR("followingLayoutStyle"));
  p_registerProperty(151, CFSTR("layoutContinuous"));
  p_registerProperty(152, CFSTR("shrinkTextToFit"));
  p_registerProperty(153, CFSTR("verticalText"));
  p_registerProperty(154, CFSTR("truncateLastLine"));
  p_registerProperty(155, CFSTR("maxLineCount"));
  p_registerProperty(176, CFSTR("listTextIndents"));
  p_registerProperty(177, CFSTR("listLabelIndents"));
  p_registerProperty(178, CFSTR("listClassicTextIndents"));
  p_registerProperty(179, CFSTR("listClassicFontSize"));
  p_registerProperty(180, CFSTR("listLabelType"));
  p_registerProperty(181, CFSTR("listLabelGeometries"));
  p_registerProperty(182, CFSTR("listLabelImages"));
  p_registerProperty(183, CFSTR("listLabelStrings"));
  p_registerProperty(184, CFSTR("listLabelNumbers"));
  p_registerProperty(185, CFSTR("listLabelTieredNumbers"));
  p_registerProperty(186, CFSTR("listClassicGeometries"));
  p_registerProperty(187, CFSTR("labelCharacterStyle1"));
  p_registerProperty(188, CFSTR("labelCharacterStyle2"));
  p_registerProperty(189, CFSTR("labelCharacterStyle3"));
  p_registerProperty(190, CFSTR("labelCharacterStyle4"));
  p_registerProperty(191, CFSTR("labelCharacterStyle5"));
  p_registerProperty(192, CFSTR("labelCharacterStyle6"));
  p_registerProperty(193, CFSTR("labelCharacterStyle7"));
  p_registerProperty(194, CFSTR("labelCharacterStyle8"));
  p_registerProperty(195, CFSTR("labelCharacterStyle9"));
  p_registerProperty(196, CFSTR("textPosition"));
  p_registerProperty(197, CFSTR("labelPosition"));
  p_registerProperty(198, CFSTR("scale"));
  p_registerProperty(199, CFSTR("baselineOffset"));
  p_registerProperty(200, CFSTR("scaleWithText"));
  p_registerProperty(201, CFSTR("labelAlignment"));
  p_registerProperty(202, CFSTR("labelType"));
  p_registerProperty(203, CFSTR("bulletImage"));
  p_registerProperty(204, CFSTR("textLabel"));
  p_registerProperty(205, CFSTR("listLevelCharacterStyle"));
  p_registerProperty(206, CFSTR("listLevelFontSize"));
  p_registerProperty(207, CFSTR("listLevelLabelColor"));
  p_registerProperty(208, CFSTR("listLevelBodyFontSize"));
  p_registerProperty(209, CFSTR("listLevelBodyFont"));
  p_registerProperty(210, CFSTR("listLevelFontName"));
  p_registerProperty(211, CFSTR("defaultTextStylePresetIndex"));
  p_registerProperty(212, CFSTR("defaultParagraphStyle"));
  p_registerProperty(512, CFSTR("geometry"));
  p_registerProperty(513, CFSTR("geometryPosition"));
  p_registerProperty(514, CFSTR("children"));
  p_registerProperty(515, CFSTR("style"));
  p_registerProperty(516, CFSTR("fill"));
  p_registerProperty(517, CFSTR("stroke"));
  p_registerProperty(518, CFSTR("opacity"));
  p_registerProperty(519, CFSTR("reflection"));
  p_registerProperty(520, CFSTR("shadow"));
  p_registerProperty(521, CFSTR("externalTextWrap"));
  p_registerProperty(522, CFSTR("headLineEnd"));
  p_registerProperty(523, CFSTR("tailLineEnd"));
  p_registerProperty(524, CFSTR("hyperlinkURL"));
  p_registerProperty(525, CFSTR("aspectRatioLocked"));
  p_registerProperty(526, CFSTR("pathSource"));
  p_registerProperty(527, CFSTR("mediaFlags"));
  p_registerProperty(528, CFSTR("media"));
  p_registerProperty(529, CFSTR("mask"));
  p_registerProperty(530, CFSTR("instantAlpha"));
  p_registerProperty(531, CFSTR("imageAdjustments"));
  p_registerProperty(532, CFSTR("movieMedia"));
  p_registerProperty(533, CFSTR("posterImageData"));
  p_registerProperty(534, CFSTR("startTime"));
  p_registerProperty(535, CFSTR("endTime"));
  p_registerProperty(536, CFSTR("posterTime"));
  p_registerProperty(537, CFSTR("loopOption"));
  p_registerProperty(538, CFSTR("volume"));
  p_registerProperty(539, CFSTR("connectedTo"));
  p_registerProperty(540, CFSTR("connectedFrom"));
  p_registerProperty(768, CFSTR("TSTAutoResize"));
  p_registerProperty(769, CFSTR("TSTBandedRows"));
  p_registerProperty(770, CFSTR("TSTBandedCellFill"));
  p_registerProperty(771, CFSTR("TSTBodyCellsHorizontalBorderStroke"));
  p_registerProperty(772, CFSTR("TSTBodyCellsVerticalBorderStroke"));
  p_registerProperty(773, CFSTR("TSTBodyCellsHorizontalStroke"));
  p_registerProperty(774, CFSTR("TSTBodyCellsVerticalStroke"));
  p_registerProperty(775, CFSTR("TSTHeaderColumnSeparatorStroke"));
  p_registerProperty(776, CFSTR("TSTHeaderColumnHorizontalStroke"));
  p_registerProperty(777, CFSTR("TSTHeaderColumnVerticalStroke"));
  p_registerProperty(778, CFSTR("TSTHeaderColumnBorderStroke"));
  p_registerProperty(779, CFSTR("TSTHeaderRowSeparatorStroke"));
  p_registerProperty(780, CFSTR("TSTHeaderRowVerticalStroke"));
  p_registerProperty(781, CFSTR("TSTHeaderRowHorizontalStroke"));
  p_registerProperty(782, CFSTR("TSTHeaderRowBorderStroke"));
  p_registerProperty(783, CFSTR("TSTFooterRowSeparatorStroke"));
  p_registerProperty(784, CFSTR("TSTFooterRowVerticalStroke"));
  p_registerProperty(785, CFSTR("TSTFooterRowHorizontalStroke"));
  p_registerProperty(786, CFSTR("TSTFooterRowBorderStroke"));
  p_registerProperty(787, CFSTR("TSTTableStrokePresetList"));
  p_registerProperty(788, CFSTR("TSTTableVerticalStrokesVisible"));
  p_registerProperty(789, CFSTR("TSTTableHorizontalStrokesVisible"));
  p_registerProperty(790, CFSTR("TSTTableHeaderRowSepVisible"));
  p_registerProperty(791, CFSTR("TSTTableHeaderRowVerticalsVisible"));
  p_registerProperty(792, CFSTR("TSTTableHeaderColSepVisible"));
  p_registerProperty(793, CFSTR("TSTTableHeaderColHorizontalsVisible"));
  p_registerProperty(794, CFSTR("TSTTableFooterSepVisible"));
  p_registerProperty(795, CFSTR("TSTTableFooterVerticalsVisible"));
  p_registerProperty(796, CFSTR("TSTTableBorderStrokesVisible"));
  p_registerProperty(797, CFSTR("TSTTableMasterFontFamily"));
  p_registerProperty(798, CFSTR("TSTTableWritingDirection"));
  p_registerProperty(799, CFSTR("TSTTableBehavesLikeSpreadsheet"));
  p_registerProperty(800, CFSTR("TSTTableDefaultGeometry"));
  p_registerProperty(801, CFSTR("TSTTableDefaultInlineGeometry"));
  p_registerProperty(802, CFSTR("TSTTableDefaultRowCount"));
  p_registerProperty(803, CFSTR("TSTTableDefaultColumnCount"));
  p_registerProperty(804, CFSTR("TSTTableDefaultHeaderRowCount"));
  p_registerProperty(805, CFSTR("TSTTableDefaultHeaderColumnCount"));
  p_registerProperty(806, CFSTR("TSTTableDefaultFooterRowCount"));
  p_registerProperty(896, CFSTR("TSTCellTextWrap"));
  p_registerProperty(897, CFSTR("TSTCellType"));
  p_registerProperty(898, CFSTR("TSTCellFill"));
  p_registerProperty(899, CFSTR("TSTCellTopStroke"));
  p_registerProperty(900, CFSTR("TSTCellBottomStroke"));
  p_registerProperty(901, CFSTR("TSTCellLeftStroke"));
  p_registerProperty(902, CFSTR("TSTCellRightStroke"));
  p_registerProperty(903, CFSTR("TSTCellVerticalAlignment"));
  p_registerProperty(904, CFSTR("TSTCellPadding"));
  p_registerProperty(1024, CFSTR("TSCHChartInfoBorderOpacityProperty"));
  p_registerProperty(1025, CFSTR("TSCHChartSeriesTrendlineEquationParagraphStyleIndexProperty"));
  p_registerProperty(1026, CFSTR("TSCHChartSeriesLabelParagraphStyleIndexProperty"));
  p_registerProperty(1027, CFSTR("TSCHChartInfoCombineLayersProperty"));
  p_registerProperty(1028, CFSTR("TSCHChartAxisMajorGridlineOpacityProperty"));
  p_registerProperty(1029, CFSTR("TSCHChartSeriesShowSymbolProperty"));
  p_registerProperty(1030, CFSTR("TSCHChartInfoShowLegendProperty"));
  p_registerProperty(1031, CFSTR("TSCHChartSeriesErrorBarSettingProperty"));
  p_registerProperty(1032, CFSTR("TSCHChartAxisShowLabelsProperty"));
  p_registerProperty(1033, CFSTR("TSCHChartInfoInterBarGapProperty"));
  p_registerProperty(1034, CFSTR("TSCHChartSeriesErrorBarLineEndProperty"));
  p_registerProperty(1035, CFSTR("TSCHChartSeriesErrorBarCustomNegativeDataProperty"));
  p_registerProperty(1036, CFSTR("TSCHChartAxisShowSeriesLabelsProperty"));
  p_registerProperty(1037, CFSTR("TSCHChartAxis3DLabelPositionProperty"));
  p_registerProperty(1038, CFSTR("TSCHChartAxisNumberFormatProperty"));
  p_registerProperty(1039, CFSTR("TSCHChartSeriesTrendLineShowR2ValueProperty"));
  p_registerProperty(1040, CFSTR("TSCHChartInfoTitleColorProperty"));
  p_registerProperty(1041, CFSTR("TSCHLegendModelShadowProperty"));
  p_registerProperty(1042, CFSTR("TSCHChartSeriesTrendlineEquationOpacityProperty"));
  p_registerProperty(1043, CFSTR("TSCHChartAxisNumberOfMinorGridlinesProperty"));
  p_registerProperty(1044, CFSTR("TSCHChartSeriesShowSeriesLabelsProperty"));
  p_registerProperty(1045, CFSTR("TSCHChartAxisMajorGridlineShadowProperty"));
  p_registerProperty(1046, CFSTR("TSCHChartSeriesTrendLineShowEquationProperty"));
  p_registerProperty(1047, CFSTR("TSCHChartAxisShowMinorTickmarksProperty"));
  p_registerProperty(1048, CFSTR("TSCHChartAxisPlotToEdgesProperty"));
  p_registerProperty(1049, CFSTR("TSCHChartSeriesNumberFormatProperty"));
  p_registerProperty(1050, CFSTR("TSCHChartSeriesStrokeProperty"));
  p_registerProperty(1051, CFSTR("TSCHChartSeriesErrorBarCustomPositiveDataScatterXProperty"));
  p_registerProperty(1052, CFSTR("TSCHChartAxisHorizontalSpacingProperty"));
  p_registerProperty(1053, CFSTR("TSCHChartAxisTitleProperty"));
  p_registerProperty(1054, CFSTR("TSCHChartInfoDEPRECATEDTrendlineRSquaredParagraphStyleIndexProperty"));
  p_registerProperty(1055, CFSTR("TSCHChartAxisUserMaxProperty"));
  p_registerProperty(1056, CFSTR("TSCHChartSeriesTrendLineShadowProperty"));
  p_registerProperty(1057, CFSTR("TSCHChartInfoDataSetNameParagraphStyleIndexProperty"));
  p_registerProperty(1058, CFSTR("TSCHChartInfoMultiDataControlTypeProperty"));
  p_registerProperty(1059, CFSTR("TSCHChartInfoDEPRECATEDMasterFontFamilyProperty"));
  p_registerProperty(1060, CFSTR("TSCHChartInfoSkipHiddenDataProperty"));
  p_registerProperty(1061, CFSTR("TSCHChartAxisTickmarkLocationProperty"));
  p_registerProperty(1062, CFSTR("TSCHChartSeriesYAxisOrdinalProperty"));
  p_registerProperty(1063, CFSTR("TSCHChartSeriesSymbolFillUseSeriesFillProperty"));
  p_registerProperty(1064, CFSTR("TSCHChartSeriesPercentNumberFormatProperty"));
  p_registerProperty(1065, CFSTR("TSCHChartSeriesErrorBarPercentValueProperty"));
  p_registerProperty(1066, CFSTR("TSCHChartAxis3DGridlineOpacityProperty"));
  p_registerProperty(1067, CFSTR("TSCHChartInfo3DScaleProperty"));
  p_registerProperty(1068, CFSTR("TSCHChartInfo3DInterSetDepthGapProperty"));
  p_registerProperty(1069, CFSTR("TSCHChartSeriesTrendLinePeriodProperty"));
  p_registerProperty(1070, CFSTR("TSCHChartInfo3DLightingPackageProperty"));
  p_registerProperty(1071, CFSTR("TSCHChartSeriesValueLabelPositionProperty"));
  p_registerProperty(1072, CFSTR("TSCHChartSeriesErrorBarCustomNegativeDataScatterXProperty"));
  p_registerProperty(1073, CFSTR("TSCHChartInfoDEPRECATEDMasterFontNamedSizeProperty"));
  p_registerProperty(1074, CFSTR("TSCHChartSeriesSymbolTypeProperty"));
  p_registerProperty(1075, CFSTR("TSCHChartSeriesSizeDimensionProperty"));
  p_registerProperty(1076, CFSTR("TSCHChartSeriesWedgeExplosionProperty"));
  p_registerProperty(1077, CFSTR("TSCHChartInfoBackgroundStrokeProperty"));
  p_registerProperty(1078, CFSTR("TSCHLegendModelLabelParagraphStyleIndexProperty"));
  p_registerProperty(1079, CFSTR("TSCHChartSeriesTrendLineTypeProperty"));
  p_registerProperty(1080, CFSTR("TSCHChartSeriesShowErrorBarScatterXProperty"));
  p_registerProperty(1081, CFSTR("TSCHChartSeriesTrendLineRSquaredOffsetYProperty"));
  p_registerProperty(1082, CFSTR("TSCHChartInfoDEPRECATEDTrendlineEquationParagraphStyleIndexProperty"));
  p_registerProperty(1083, CFSTR("TSCHChartAxisNumberFormatTypeProperty"));
  p_registerProperty(1084, CFSTR("TSCHChartInfoDEPRECATED3DLightingPackageProperty"));
  p_registerProperty(1085, CFSTR("TSCHChartSeriesTrendlineRSquaredParagraphStyleIndexProperty"));
  p_registerProperty(1086, CFSTR("TSCHChartSeriesShowTrendLineProperty"));
  p_registerProperty(1087, CFSTR("TSCHChartAxisShowMajorGridlinesProperty"));
  p_registerProperty(1088, CFSTR("TSCHChartInfo3DBarShapeProperty"));
  p_registerProperty(1089, CFSTR("TSCHChartSeriesTrendLineShowLabelProperty"));
  p_registerProperty(1090, CFSTR("TSCHChartAxisUserMinProperty"));
  p_registerProperty(1091, CFSTR("TSCHChartSeriesErrorBarPercentValueScatterXProperty"));
  p_registerProperty(1092, CFSTR("TSCHChartAxisShowMinimumLabelProperty"));
  p_registerProperty(1093, CFSTR("TSCHChartInfoDEPRECATEDAGAINMasterFontNamedSizeProperty"));
  p_registerProperty(1094, CFSTR("TSCHChartInfoDEPRECATEDTrendlineEquationShadowProperty"));
  p_registerProperty(1095, CFSTR("TSCHChartSeriesDEPRECATED3DFillProperty"));
  p_registerProperty(1096, CFSTR("TSCHChartSeriesTrendlineRSquaredOpacityProperty"));
  p_registerProperty(1097, CFSTR("TSCHChartInfoDEPRECATED3DShadowProperty"));
  p_registerProperty(1098, CFSTR("TSCHChartSeriesSymbolFillProperty"));
  p_registerProperty(1099, CFSTR("TSCHChartInfoDEPRECATEDTrendlineEquationOpacityProperty"));
  p_registerProperty(1100, CFSTR("TSCHChartInfoTitleProperty"));
  p_registerProperty(1101, CFSTR("TSCHChartInfoTitleParagraphStyleIndexProperty"));
  p_registerProperty(1102, CFSTR("TSCHChartSeriesFillProperty"));
  p_registerProperty(1103, CFSTR("TSCHChartAxisNumberOfMajorGridlinesProperty"));
  p_registerProperty(1104, CFSTR("TSCHChartInfo3DRotationProperty"));
  p_registerProperty(1105, CFSTR("TSCHChartInfoBorderStrokeProperty"));
  p_registerProperty(1106, CFSTR("TSCHChartAxisScaleProperty"));
  p_registerProperty(1107, CFSTR("TSCHChartSeriesErrorBarTypeProperty"));
  p_registerProperty(1108, CFSTR("TSCHChartSeriesLineTypeProperty"));
  p_registerProperty(1109, CFSTR("TSCHChartSeriesShadowProperty"));
  p_registerProperty(1110, CFSTR("TSCHChartInfoDEPRECATED3DBarShapeProperty"));
  p_registerProperty(1111, CFSTR("TSCHChartSeriesErrorBarFixedValueProperty"));
  p_registerProperty(1112, CFSTR("TSCHChartInfo3DChartOpacityProperty"));
  p_registerProperty(1113, CFSTR("TSCHChartSeriesShowErrorBarProperty"));
  p_registerProperty(1114, CFSTR("TSCHChartSeriesLabelExplosionProperty"));
  p_registerProperty(1115, CFSTR("TSCHChartSeriesShowNegativeDataProperty"));
  p_registerProperty(1116, CFSTR("TSCHChartAxisLabelParagraphStyleIndexProperty"));
  p_registerProperty(1117, CFSTR("TSCHChartAxisMajorGridlineStrokeProperty"));
  p_registerProperty(1118, CFSTR("TSCHChartInfoBackgroundFillProperty"));
  p_registerProperty(1119, CFSTR("TSCHChartInfoBorderShadowProperty"));
  p_registerProperty(1120, CFSTR("TSCHChartInfo3DBevelEdgesProperty"));
  p_registerProperty(1121, CFSTR("TSCHChartInfoShowBorderProperty"));
  p_registerProperty(1122, CFSTR("TSCHChartSeriesErrorBarShadowProperty"));
  p_registerProperty(1123, CFSTR("TSCHLegendModelStrokeProperty"));
  p_registerProperty(1124, CFSTR("TSCHChartSeriesOpacityProperty"));
  p_registerProperty(1125, CFSTR("TSCHChartSeriesTrendLineOrderProperty"));
  p_registerProperty(1126, CFSTR("TSCHChartSeriesTrendLineStrokeProperty"));
  p_registerProperty(1127, CFSTR("TSCHChartAxis3DGridlineStrokeProperty"));
  p_registerProperty(1128, CFSTR("TSCHChartAxisShowTitleProperty"));
  p_registerProperty(1129, CFSTR("TSCHChartInfoShowTitleProperty"));
  p_registerProperty(1130, CFSTR("TSCHChartSeriesValueLabelsAxisProperty"));
  p_registerProperty(1131, CFSTR("TSCHChartAxisLabelsOrientationProperty"));
  p_registerProperty(1132, CFSTR("TSCHChartAxisMinorGridlineShadowProperty"));
  p_registerProperty(1133, CFSTR("TSCHChartAxisMinorGridlineStrokeProperty"));
  p_registerProperty(1134, CFSTR("TSCHChartAxisShowMinorGridlinesProperty"));
  p_registerProperty(1135, CFSTR("TSCHChartInfoPieStartAngleProperty"));
  p_registerProperty(1136, CFSTR("TSCHChartAxisShowLastLabelProperty"));
  p_registerProperty(1137, CFSTR("TSCHChartSeriesNumberFormatTypeProperty"));
  p_registerProperty(1138, CFSTR("TSCHChartSeriesTrendLineLabelStringProperty"));
  p_registerProperty(1139, CFSTR("TSCHChartSeriesErrorBarTypeScatterXProperty"));
  p_registerProperty(1140, CFSTR("TSCHChartSeriesShowLineProperty"));
  p_registerProperty(1141, CFSTR("TSCHChartSeriesErrorBarSettingScatterXProperty"));
  p_registerProperty(1142, CFSTR("TSCHChartSeriesErrorBarStrokeScatterXProperty"));
  p_registerProperty(1143, CFSTR("TSCHChartSeriesShowValueLabelsProperty"));
  p_registerProperty(1144, CFSTR("TSCHChartAxisShowAxisProperty"));
  p_registerProperty(1145, CFSTR("TSCHChartInfoDEPRECATEDTrendlineRSquaredOpacityProperty"));
  p_registerProperty(1146, CFSTR("TSCHChartInfoDataSetNameLocationProperty"));
  p_registerProperty(1147, CFSTR("TSCHChartSeriesTrendLineEquationOffsetYProperty"));
  p_registerProperty(1148, CFSTR("TSCHChartSeriesSymbolSizeProperty"));
  p_registerProperty(1149, CFSTR("TSCHChartAxisShowMajorTickmarksProperty"));
  p_registerProperty(1150, CFSTR("TSCHChartSeriesErrorBarLineEndScatterXProperty"));
  p_registerProperty(1151, CFSTR("TSCHChartSeriesSymbolFillUseSeriesStrokeProperty"));
  p_registerProperty(1152, CFSTR("TSCHChartSeriesOutsideLabelParagraphStyleIndexProperty"));
  p_registerProperty(1153, CFSTR("TSCHChartAxisMinorGridlineOpacityProperty"));
  p_registerProperty(1154, CFSTR("TSCHChartSeriesTrendLineRSquaredOffsetXProperty"));
  p_registerProperty(1155, CFSTR("TSCHChartInfoDEPRECATED3DBevelEdgesProperty"));
  p_registerProperty(1156, CFSTR("TSCHChartSeriesAdjustmentScaleProperty"));
  p_registerProperty(1157, CFSTR("TSCHChartInfo3DViewportProperty"));
  p_registerProperty(1158, CFSTR("TSCHChartSeriesTrendLineEquationOffsetXProperty"));
  p_registerProperty(1159, CFSTR("TSCHChartInfoGridBackgroundOpacityProperty"));
  p_registerProperty(1160, CFSTR("TSCHChartInfoInterSetGapProperty"));
  p_registerProperty(1161, CFSTR("TSCHChartSeriesSeriesTypeProperty"));
  p_registerProperty(1162, CFSTR("TSCHChartSeriesDEPRECATEDSeriesLabelsOnProperty"));
  p_registerProperty(1163, CFSTR("TSCHChartSeriesErrorBarFixedValueScatterXProperty"));
  p_registerProperty(1164, CFSTR("TSCHChartSeriesErrorBarStrokeProperty"));
  p_registerProperty(1165, CFSTR("TSCHChartInfoDEPRECATEDTrendlineRSquaredShadowProperty"));
  p_registerProperty(1166, CFSTR("TSCHLegendModelOpacityProperty"));
  p_registerProperty(1167, CFSTR("TSCHChartSeriesErrorBarStdDevValueProperty"));
  p_registerProperty(1168, CFSTR("TSCHChartInfoGridBackgroundFillProperty"));
  p_registerProperty(1169, CFSTR("TSCHChartSeriesErrorBarCustomPositiveDataProperty"));
  p_registerProperty(1170, CFSTR("TSCHChartSeriesErrorBarStdDevValueScatterXProperty"));
  p_registerProperty(1171, CFSTR("TSCHLegendModelFillProperty"));
  p_registerProperty(1172, CFSTR("TSCHChartSeriesSymbolStrokeProperty"));
  p_registerProperty(1173, CFSTR("TSCHChartAxisTitleParagraphStyleIndexProperty"));
  p_registerProperty(1174, CFSTR("TSCHChartAxisVerticalSpacingProperty"));
  p_registerProperty(1175, CFSTR("TSCHChartAxisNumberOfDecadesProperty"));
  p_registerProperty(1176, CFSTR("TSCHChartInfoAreaDEPRECATED3DLightingPackageProperty"));
  p_registerProperty(1177, CFSTR("TSCHChartInfoBarDEPRECATED3DLightingPackageProperty"));
  p_registerProperty(1178, CFSTR("TSCHChartInfoColumnDEPRECATED3DLightingPackageProperty"));
  p_registerProperty(1179, CFSTR("TSCHChartInfoDefaultDEPRECATED3DLightingPackageProperty"));
  p_registerProperty(1180, CFSTR("TSCHChartInfoLineDEPRECATED3DLightingPackageProperty"));
  p_registerProperty(1181, CFSTR("TSCHChartInfoPieDEPRECATED3DLightingPackageProperty"));
  p_registerProperty(1182, CFSTR("TSCHChartInfoDefaultDEPRECATEDAGAINMasterFontNamedSizeProperty"));
  p_registerProperty(1183, CFSTR("TSCHChartInfoDefaultDEPRECATED3DBarShapeProperty"));
  p_registerProperty(1184, CFSTR("TSCHChartInfoBarDEPRECATED3DBevelEdgesProperty"));
  p_registerProperty(1185, CFSTR("TSCHChartInfoColumnDEPRECATED3DBevelEdgesProperty"));
  p_registerProperty(1186, CFSTR("TSCHChartInfoDefaultDEPRECATED3DBevelEdgesProperty"));
  p_registerProperty(1187, CFSTR("TSCHChartInfoPieDEPRECATED3DBevelEdgesProperty"));
  p_registerProperty(1188, CFSTR("TSCHChartInfoAreaDEPRECATED3DShadowProperty"));
  p_registerProperty(1189, CFSTR("TSCHChartInfoBarDEPRECATED3DShadowProperty"));
  p_registerProperty(1190, CFSTR("TSCHChartInfoColumnDEPRECATED3DShadowProperty"));
  p_registerProperty(1191, CFSTR("TSCHChartInfoLineDEPRECATED3DShadowProperty"));
  p_registerProperty(1192, CFSTR("TSCHChartInfoPieDEPRECATED3DShadowProperty"));
  p_registerProperty(1193, CFSTR("TSCHChartInfoDefaultDEPRECATEDMasterFontFamilyProperty"));
  p_registerProperty(1194, CFSTR("TSCHChartInfoDefaultDEPRECATEDMasterFontNamedSizeProperty"));
  p_registerProperty(1195, CFSTR("TSCHChartInfoDefaultDEPRECATEDTrendlineEquationOpacityProperty"));
  p_registerProperty(1196, CFSTR("TSCHChartInfoDefaultDEPRECATEDTrendlineEquationParagraphStyleIndexProperty"));
  p_registerProperty(1197, CFSTR("TSCHChartInfoDefaultDEPRECATEDTrendlineEquationShadowProperty"));
  p_registerProperty(1198, CFSTR("TSCHChartInfoDefaultDEPRECATEDTrendlineRSquaredOpacityProperty"));
  p_registerProperty(1199, CFSTR("TSCHChartInfoDefaultDEPRECATEDTrendlineRSquaredParagraphStyleIndexProperty"));
  p_registerProperty(1200, CFSTR("TSCHChartInfoDefaultDEPRECATEDTrendlineRSquaredShadowProperty"));
  p_registerProperty(1201, CFSTR("TSCHChartSeriesAreaDEPRECATED3DFillProperty"));
  p_registerProperty(1202, CFSTR("TSCHChartSeriesBarDEPRECATED3DFillProperty"));
  p_registerProperty(1203, CFSTR("TSCHChartSeriesColumnDEPRECATED3DFillProperty"));
  p_registerProperty(1204, CFSTR("TSCHChartSeriesDefaultDEPRECATED3DFillProperty"));
  p_registerProperty(1205, CFSTR("TSCHChartSeriesLineDEPRECATED3DFillProperty"));
  p_registerProperty(1206, CFSTR("TSCHChartSeriesPieDEPRECATED3DFillProperty"));
  p_registerProperty(1207, CFSTR("TSCHChartSeriesPieDEPRECATEDSeriesLabelsOnProperty"));
  p_registerProperty(1208, CFSTR("TSCHChartAxisDefault3DLabelPositionProperty"));
  p_registerProperty(1209, CFSTR("TSCHChartAxisDefaultNumberFormatProperty"));
  p_registerProperty(1210, CFSTR("TSCHChartAxisDefaultNumberFormatTypeProperty"));
  p_registerProperty(1211, CFSTR("TSCHChartAxisValueNumberOfDecadesProperty"));
  p_registerProperty(1212, CFSTR("TSCHChartAxisValueNumberOfMajorGridlinesProperty"));
  p_registerProperty(1213, CFSTR("TSCHChartAxisValueNumberOfMinorGridlinesProperty"));
  p_registerProperty(1214, CFSTR("TSCHChartAxisCategoryPlotToEdgesProperty"));
  p_registerProperty(1215, CFSTR("TSCHChartAxisValueScaleProperty"));
  p_registerProperty(1216, CFSTR("TSCHChartAxisCategoryShowLabelsProperty"));
  p_registerProperty(1217, CFSTR("TSCHChartAxisDefaultShowLabelsProperty"));
  p_registerProperty(1218, CFSTR("TSCHChartAxisValueShowLabelsProperty"));
  p_registerProperty(1219, CFSTR("TSCHChartAxisCategoryShowSeriesLabelsProperty"));
  p_registerProperty(1220, CFSTR("TSCHChartAxisMultiDataShowSeriesLabelsProperty"));
  p_registerProperty(1221, CFSTR("TSCHChartAxisCategoryShowTitleProperty"));
  p_registerProperty(1222, CFSTR("TSCHChartAxisValueShowTitleProperty"));
  p_registerProperty(1223, CFSTR("TSCHChartAxisCategoryTitleProperty"));
  p_registerProperty(1224, CFSTR("TSCHChartAxisValueTitleProperty"));
  p_registerProperty(1225, CFSTR("TSCHChartAxisDefaultUserMaxProperty"));
  p_registerProperty(1226, CFSTR("TSCHChartAxisDefaultUserMinProperty"));
  p_registerProperty(1227, CFSTR("TSCHChartAxisCategory3DGridlineOpacityProperty"));
  p_registerProperty(1228, CFSTR("TSCHChartAxisValue3DGridlineOpacityProperty"));
  p_registerProperty(1229, CFSTR("TSCHChartAxisCategory3DGridlineStrokeProperty"));
  p_registerProperty(1230, CFSTR("TSCHChartAxisValue3DGridlineStrokeProperty"));
  p_registerProperty(1231, CFSTR("TSCHChartAxisCategoryHorizontalSpacingProperty"));
  p_registerProperty(1232, CFSTR("TSCHChartAxisCategoryLabelParagraphStyleIndexProperty"));
  p_registerProperty(1233, CFSTR("TSCHChartAxisDefaultLabelParagraphStyleIndexProperty"));
  p_registerProperty(1234, CFSTR("TSCHChartAxisValueLabelParagraphStyleIndexProperty"));
  p_registerProperty(1235, CFSTR("TSCHChartAxisCategoryLabelsOrientationProperty"));
  p_registerProperty(1236, CFSTR("TSCHChartAxisDefaultLabelsOrientationProperty"));
  p_registerProperty(1237, CFSTR("TSCHChartAxisValueLabelsOrientationProperty"));
  p_registerProperty(1238, CFSTR("TSCHChartAxisCategoryMajorGridlineOpacityProperty"));
  p_registerProperty(1239, CFSTR("TSCHChartAxisValueMajorGridlineOpacityProperty"));
  p_registerProperty(1240, CFSTR("TSCHChartAxisCategoryMajorGridlineShadowProperty"));
  p_registerProperty(1241, CFSTR("TSCHChartAxisValueMajorGridlineShadowProperty"));
  p_registerProperty(1242, CFSTR("TSCHChartAxisCategoryMajorGridlineStrokeProperty"));
  p_registerProperty(1243, CFSTR("TSCHChartAxisValueMajorGridlineStrokeProperty"));
  p_registerProperty(1244, CFSTR("TSCHChartAxisCategoryMinorGridlineOpacityProperty"));
  p_registerProperty(1245, CFSTR("TSCHChartAxisValueMinorGridlineOpacityProperty"));
  p_registerProperty(1246, CFSTR("TSCHChartAxisCategoryMinorGridlineShadowProperty"));
  p_registerProperty(1247, CFSTR("TSCHChartAxisValueMinorGridlineShadowProperty"));
  p_registerProperty(1248, CFSTR("TSCHChartAxisCategoryMinorGridlineStrokeProperty"));
  p_registerProperty(1249, CFSTR("TSCHChartAxisValueMinorGridlineStrokeProperty"));
  p_registerProperty(1250, CFSTR("TSCHChartAxisCategoryShowAxisProperty"));
  p_registerProperty(1251, CFSTR("TSCHChartAxisValueShowAxisProperty"));
  p_registerProperty(1252, CFSTR("TSCHChartAxisCategoryShowLastLabelProperty"));
  p_registerProperty(1253, CFSTR("TSCHChartAxisCategoryShowMajorGridlinesProperty"));
  p_registerProperty(1254, CFSTR("TSCHChartAxisValueShowMajorGridlinesProperty"));
  p_registerProperty(1255, CFSTR("TSCHChartAxisCategoryShowMajorTickmarksProperty"));
  p_registerProperty(1256, CFSTR("TSCHChartAxisValueShowMajorTickmarksProperty"));
  p_registerProperty(1257, CFSTR("TSCHChartAxisValueShowMinimumLabelProperty"));
  p_registerProperty(1258, CFSTR("TSCHChartAxisCategoryShowMinorGridlinesProperty"));
  p_registerProperty(1259, CFSTR("TSCHChartAxisValueShowMinorGridlinesProperty"));
  p_registerProperty(1260, CFSTR("TSCHChartAxisCategoryShowMinorTickmarksProperty"));
  p_registerProperty(1261, CFSTR("TSCHChartAxisValueShowMinorTickmarksProperty"));
  p_registerProperty(1262, CFSTR("TSCHChartAxisCategoryTickmarkLocationProperty"));
  p_registerProperty(1263, CFSTR("TSCHChartAxisValueTickmarkLocationProperty"));
  p_registerProperty(1264, CFSTR("TSCHChartAxisCategoryTitleParagraphStyleIndexProperty"));
  p_registerProperty(1265, CFSTR("TSCHChartAxisDefaultTitleParagraphStyleIndexProperty"));
  p_registerProperty(1266, CFSTR("TSCHChartAxisValueTitleParagraphStyleIndexProperty"));
  p_registerProperty(1267, CFSTR("TSCHChartAxisCategoryVerticalSpacingProperty"));
  p_registerProperty(1268, CFSTR("TSCHChartInfoDefault3DBarShapeProperty"));
  p_registerProperty(1269, CFSTR("TSCHChartInfoDefault3DBevelEdgesProperty"));
  p_registerProperty(1270, CFSTR("TSCHChartInfoDefault3DInterSetDepthGapProperty"));
  p_registerProperty(1271, CFSTR("TSCHChartInfoDefault3DRotationProperty"));
  p_registerProperty(1272, CFSTR("TSCHChartInfoArea3DScaleProperty"));
  p_registerProperty(1273, CFSTR("TSCHChartInfoBar3DScaleProperty"));
  p_registerProperty(1274, CFSTR("TSCHChartInfoColumn3DScaleProperty"));
  p_registerProperty(1275, CFSTR("TSCHChartInfoDefault3DScaleProperty"));
  p_registerProperty(1276, CFSTR("TSCHChartInfoLine3DScaleProperty"));
  p_registerProperty(1277, CFSTR("TSCHChartInfoPie3DScaleProperty"));
  p_registerProperty(1278, CFSTR("TSCHChartInfoDefault3DViewportProperty"));
  p_registerProperty(1279, CFSTR("TSCHChartInfoDefaultPieStartAngleProperty"));
  p_registerProperty(1280, CFSTR("TSCHChartInfoDefaultShowLegendProperty"));
  p_registerProperty(1281, CFSTR("TSCHChartInfoDefaultShowTitleProperty"));
  p_registerProperty(1282, CFSTR("TSCHChartInfoDefaultSkipHiddenDataProperty"));
  p_registerProperty(1283, CFSTR("TSCHChartInfoDefaultTitleProperty"));
  p_registerProperty(1284, CFSTR("TSCHChartInfoDefaultDataSetNameLocationProperty"));
  p_registerProperty(1285, CFSTR("TSCHChartInfoDefaultMultiDataControlTypeProperty"));
  p_registerProperty(1286, CFSTR("TSCHChartInfoDefault3DChartOpacityProperty"));
  p_registerProperty(1287, CFSTR("TSCHChartInfoArea3DLightingPackageProperty"));
  p_registerProperty(1288, CFSTR("TSCHChartInfoBar3DLightingPackageProperty"));
  p_registerProperty(1289, CFSTR("TSCHChartInfoColumn3DLightingPackageProperty"));
  p_registerProperty(1290, CFSTR("TSCHChartInfoDefault3DLightingPackageProperty"));
  p_registerProperty(1291, CFSTR("TSCHChartInfoLine3DLightingPackageProperty"));
  p_registerProperty(1292, CFSTR("TSCHChartInfoPie3DLightingPackageProperty"));
  p_registerProperty(1293, CFSTR("TSCHChartInfoDefaultBackgroundFillProperty"));
  p_registerProperty(1294, CFSTR("TSCHChartInfoDefaultBackgroundStrokeProperty"));
  p_registerProperty(1295, CFSTR("TSCHChartInfoDefaultBorderOpacityProperty"));
  p_registerProperty(1296, CFSTR("TSCHChartInfoDefaultBorderShadowProperty"));
  p_registerProperty(1297, CFSTR("TSCHChartInfoDefaultBorderStrokeProperty"));
  p_registerProperty(1298, CFSTR("TSCHChartInfoDefaultCombineLayersProperty"));
  p_registerProperty(1299, CFSTR("TSCHChartInfoDefaultGridBackgroundFillProperty"));
  p_registerProperty(1300, CFSTR("TSCHChartInfoDefaultGridBackgroundOpacityProperty"));
  p_registerProperty(1301, CFSTR("TSCHChartInfoDefaultInterBarGapProperty"));
  p_registerProperty(1302, CFSTR("TSCHChartInfoDefaultInterSetGapProperty"));
  p_registerProperty(1303, CFSTR("TSCHChartInfoDefaultShowBorderProperty"));
  p_registerProperty(1304, CFSTR("TSCHChartInfoDefaultTitleColorProperty"));
  p_registerProperty(1305, CFSTR("TSCHChartInfoDefaultTitleParagraphStyleIndexProperty"));
  p_registerProperty(1306, CFSTR("TSCHChartInfoDefaultDataSetNameParagraphStyleIndexProperty"));
  p_registerProperty(1307, CFSTR("TSCHChartSeriesBubbleAdjustmentScaleProperty"));
  p_registerProperty(1308, CFSTR("TSCHChartSeriesDefaultErrorBarCustomNegativeDataProperty"));
  p_registerProperty(1309, CFSTR("TSCHChartSeriesDefaultErrorBarCustomNegativeDataScatterXProperty"));
  p_registerProperty(1310, CFSTR("TSCHChartSeriesDefaultErrorBarCustomPositiveDataProperty"));
  p_registerProperty(1311, CFSTR("TSCHChartSeriesDefaultErrorBarCustomPositiveDataScatterXProperty"));
  p_registerProperty(1312, CFSTR("TSCHChartSeriesDefaultErrorBarFixedValueProperty"));
  p_registerProperty(1313, CFSTR("TSCHChartSeriesDefaultErrorBarFixedValueScatterXProperty"));
  p_registerProperty(1314, CFSTR("TSCHChartSeriesDefaultErrorBarPercentValueProperty"));
  p_registerProperty(1315, CFSTR("TSCHChartSeriesDefaultErrorBarPercentValueScatterXProperty"));
  p_registerProperty(1316, CFSTR("TSCHChartSeriesDefaultErrorBarSettingProperty"));
  p_registerProperty(1317, CFSTR("TSCHChartSeriesDefaultErrorBarSettingScatterXProperty"));
  p_registerProperty(1318, CFSTR("TSCHChartSeriesDefaultErrorBarStdDevValueProperty"));
  p_registerProperty(1319, CFSTR("TSCHChartSeriesDefaultErrorBarStdDevValueScatterXProperty"));
  p_registerProperty(1320, CFSTR("TSCHChartSeriesDefaultErrorBarTypeProperty"));
  p_registerProperty(1321, CFSTR("TSCHChartSeriesDefaultErrorBarTypeScatterXProperty"));
  p_registerProperty(1322, CFSTR("TSCHChartSeriesPieLabelExplosionProperty"));
  p_registerProperty(1323, CFSTR("TSCHChartSeriesBubbleLineTypeProperty"));
  p_registerProperty(1324, CFSTR("TSCHChartSeriesLineLineTypeProperty"));
  p_registerProperty(1325, CFSTR("TSCHChartSeriesMixedLineLineTypeProperty"));
  p_registerProperty(1326, CFSTR("TSCHChartSeriesScatterLineTypeProperty"));
  p_registerProperty(1327, CFSTR("TSCHChartSeriesDefaultNumberFormatProperty"));
  p_registerProperty(1328, CFSTR("TSCHChartSeriesPieNumberFormatProperty"));
  p_registerProperty(1329, CFSTR("TSCHChartSeriesDefaultNumberFormatTypeProperty"));
  p_registerProperty(1330, CFSTR("TSCHChartSeriesPieNumberFormatTypeProperty"));
  p_registerProperty(1331, CFSTR("TSCHChartSeriesStackedPercentNumberFormatProperty"));
  p_registerProperty(1332, CFSTR("TSCHChartSeriesDefaultSeriesTypeProperty"));
  p_registerProperty(1333, CFSTR("TSCHChartSeriesDefaultShowErrorBarProperty"));
  p_registerProperty(1334, CFSTR("TSCHChartSeriesDefaultShowErrorBarScatterXProperty"));
  p_registerProperty(1335, CFSTR("TSCHChartSeriesScatterShowLineProperty"));
  p_registerProperty(1336, CFSTR("TSCHChartSeriesBubbleShowNegativeDataProperty"));
  p_registerProperty(1337, CFSTR("TSCHChartSeriesPieShowSeriesLabelsProperty"));
  p_registerProperty(1338, CFSTR("TSCHChartSeriesAreaShowSymbolProperty"));
  p_registerProperty(1339, CFSTR("TSCHChartSeriesLineShowSymbolProperty"));
  p_registerProperty(1340, CFSTR("TSCHChartSeriesMixedAreaShowSymbolProperty"));
  p_registerProperty(1341, CFSTR("TSCHChartSeriesMixedLineShowSymbolProperty"));
  p_registerProperty(1342, CFSTR("TSCHChartSeriesScatterShowSymbolProperty"));
  p_registerProperty(1343, CFSTR("TSCHChartSeriesDefaultShowTrendLineProperty"));
  p_registerProperty(1344, CFSTR("TSCHChartSeriesAreaShowValueLabelsProperty"));
  p_registerProperty(1345, CFSTR("TSCHChartSeriesBarShowValueLabelsProperty"));
  p_registerProperty(1346, CFSTR("TSCHChartSeriesBubbleShowValueLabelsProperty"));
  p_registerProperty(1347, CFSTR("TSCHChartSeriesDefaultShowValueLabelsProperty"));
  p_registerProperty(1348, CFSTR("TSCHChartSeriesLineShowValueLabelsProperty"));
  p_registerProperty(1349, CFSTR("TSCHChartSeriesMixedShowValueLabelsProperty"));
  p_registerProperty(1350, CFSTR("TSCHChartSeriesPieShowValueLabelsProperty"));
  p_registerProperty(1351, CFSTR("TSCHChartSeriesScatterShowValueLabelsProperty"));
  p_registerProperty(1352, CFSTR("TSCHChartSeriesBubbleSizeDimensionProperty"));
  p_registerProperty(1353, CFSTR("TSCHChartSeriesAreaSymbolTypeProperty"));
  p_registerProperty(1354, CFSTR("TSCHChartSeriesLineSymbolTypeProperty"));
  p_registerProperty(1355, CFSTR("TSCHChartSeriesMixedAreaSymbolTypeProperty"));
  p_registerProperty(1356, CFSTR("TSCHChartSeriesMixedLineSymbolTypeProperty"));
  p_registerProperty(1357, CFSTR("TSCHChartSeriesScatterSymbolTypeProperty"));
  p_registerProperty(1358, CFSTR("TSCHChartSeriesDefaultTrendLineEquationOffsetXProperty"));
  p_registerProperty(1359, CFSTR("TSCHChartSeriesDefaultTrendLineEquationOffsetYProperty"));
  p_registerProperty(1360, CFSTR("TSCHChartSeriesDefaultTrendLineLabelStringProperty"));
  p_registerProperty(1361, CFSTR("TSCHChartSeriesDefaultTrendLineOrderProperty"));
  p_registerProperty(1362, CFSTR("TSCHChartSeriesDefaultTrendLinePeriodProperty"));
  p_registerProperty(1363, CFSTR("TSCHChartSeriesDefaultTrendLineRSquaredOffsetXProperty"));
  p_registerProperty(1364, CFSTR("TSCHChartSeriesDefaultTrendLineRSquaredOffsetYProperty"));
  p_registerProperty(1365, CFSTR("TSCHChartSeriesDefaultTrendLineShowEquationProperty"));
  p_registerProperty(1366, CFSTR("TSCHChartSeriesDefaultTrendLineShowLabelProperty"));
  p_registerProperty(1367, CFSTR("TSCHChartSeriesDefaultTrendLineShowR2ValueProperty"));
  p_registerProperty(1368, CFSTR("TSCHChartSeriesDefaultTrendLineTypeProperty"));
  p_registerProperty(1369, CFSTR("TSCHChartSeriesPieWedgeExplosionProperty"));
  p_registerProperty(1370, CFSTR("TSCHChartSeriesDefaultYAxisOrdinalProperty"));
  p_registerProperty(1371, CFSTR("TSCHChartSeriesBubbleShowSeriesLabelsProperty"));
  p_registerProperty(1372, CFSTR("TSCHChartSeriesBubbleValueLabelsAxisProperty"));
  p_registerProperty(1373, CFSTR("TSCHChartSeriesScatterShowSeriesLabelsProperty"));
  p_registerProperty(1374, CFSTR("TSCHChartSeriesScatterValueLabelsAxisProperty"));
  p_registerProperty(1375, CFSTR("TSCHChartSeriesDefaultErrorBarLineEndProperty"));
  p_registerProperty(1376, CFSTR("TSCHChartSeriesDefaultErrorBarLineEndScatterXProperty"));
  p_registerProperty(1377, CFSTR("TSCHChartSeriesDefaultErrorBarShadowProperty"));
  p_registerProperty(1378, CFSTR("TSCHChartSeriesDefaultErrorBarStrokeProperty"));
  p_registerProperty(1379, CFSTR("TSCHChartSeriesDefaultErrorBarStrokeScatterXProperty"));
  p_registerProperty(1380, CFSTR("TSCHChartSeries3DAreaFillProperty"));
  p_registerProperty(1381, CFSTR("TSCHChartSeries3DBarFillProperty"));
  p_registerProperty(1382, CFSTR("TSCHChartSeries3DColumnFillProperty"));
  p_registerProperty(1383, CFSTR("TSCHChartSeries3DLineFillProperty"));
  p_registerProperty(1384, CFSTR("TSCHChartSeries3DPieFillProperty"));
  p_registerProperty(1385, CFSTR("TSCHChartSeriesAreaFillProperty"));
  p_registerProperty(1386, CFSTR("TSCHChartSeriesBarFillProperty"));
  p_registerProperty(1387, CFSTR("TSCHChartSeriesColumnFillProperty"));
  p_registerProperty(1388, CFSTR("TSCHChartSeriesDefaultFillProperty"));
  p_registerProperty(1389, CFSTR("TSCHChartSeriesMixedAreaFillProperty"));
  p_registerProperty(1390, CFSTR("TSCHChartSeriesMixedColumnFillProperty"));
  p_registerProperty(1391, CFSTR("TSCHChartSeriesPieFillProperty"));
  p_registerProperty(1392, CFSTR("TSCHChartSeriesAreaLabelParagraphStyleIndexProperty"));
  p_registerProperty(1393, CFSTR("TSCHChartSeriesBarLabelParagraphStyleIndexProperty"));
  p_registerProperty(1394, CFSTR("TSCHChartSeriesDefaultLabelParagraphStyleIndexProperty"));
  p_registerProperty(1395, CFSTR("TSCHChartSeriesLineLabelParagraphStyleIndexProperty"));
  p_registerProperty(1396, CFSTR("TSCHChartSeriesMixedLabelParagraphStyleIndexProperty"));
  p_registerProperty(1397, CFSTR("TSCHChartSeriesPieLabelParagraphStyleIndexProperty"));
  p_registerProperty(1398, CFSTR("TSCHChartSeriesDefaultOpacityProperty"));
  p_registerProperty(1399, CFSTR("TSCHChartSeriesAreaOutsideLabelParagraphStyleIndexProperty"));
  p_registerProperty(1400, CFSTR("TSCHChartSeriesBarOutsideLabelParagraphStyleIndexProperty"));
  p_registerProperty(1401, CFSTR("TSCHChartSeriesDefaultOutsideLabelParagraphStyleIndexProperty"));
  p_registerProperty(1402, CFSTR("TSCHChartSeriesMixedOutsideLabelParagraphStyleIndexProperty"));
  p_registerProperty(1403, CFSTR("TSCHChartSeriesPieOutsideLabelParagraphStyleIndexProperty"));
  p_registerProperty(1404, CFSTR("TSCHChartSeries3DAreaShadowProperty"));
  p_registerProperty(1405, CFSTR("TSCHChartSeries3DBarShadowProperty"));
  p_registerProperty(1406, CFSTR("TSCHChartSeries3DColumnShadowProperty"));
  p_registerProperty(1407, CFSTR("TSCHChartSeries3DLineShadowProperty"));
  p_registerProperty(1408, CFSTR("TSCHChartSeries3DPieShadowProperty"));
  p_registerProperty(1409, CFSTR("TSCHChartSeriesAreaShadowProperty"));
  p_registerProperty(1410, CFSTR("TSCHChartSeriesBarShadowProperty"));
  p_registerProperty(1411, CFSTR("TSCHChartSeriesBubbleShadowProperty"));
  p_registerProperty(1412, CFSTR("TSCHChartSeriesDefaultShadowProperty"));
  p_registerProperty(1413, CFSTR("TSCHChartSeriesLineShadowProperty"));
  p_registerProperty(1414, CFSTR("TSCHChartSeriesMixedAreaShadowProperty"));
  p_registerProperty(1415, CFSTR("TSCHChartSeriesMixedColumnShadowProperty"));
  p_registerProperty(1416, CFSTR("TSCHChartSeriesMixedLineShadowProperty"));
  p_registerProperty(1417, CFSTR("TSCHChartSeriesPieShadowProperty"));
  p_registerProperty(1418, CFSTR("TSCHChartSeriesScatterShadowProperty"));
  p_registerProperty(1419, CFSTR("TSCHChartSeriesAreaStrokeProperty"));
  p_registerProperty(1420, CFSTR("TSCHChartSeriesBarStrokeProperty"));
  p_registerProperty(1421, CFSTR("TSCHChartSeriesBubbleStrokeProperty"));
  p_registerProperty(1422, CFSTR("TSCHChartSeriesLineStrokeProperty"));
  p_registerProperty(1423, CFSTR("TSCHChartSeriesMixedAreaStrokeProperty"));
  p_registerProperty(1424, CFSTR("TSCHChartSeriesMixedColumnStrokeProperty"));
  p_registerProperty(1425, CFSTR("TSCHChartSeriesMixedLineStrokeProperty"));
  p_registerProperty(1426, CFSTR("TSCHChartSeriesPieStrokeProperty"));
  p_registerProperty(1427, CFSTR("TSCHChartSeriesScatterStrokeProperty"));
  p_registerProperty(1428, CFSTR("TSCHChartSeriesAreaSymbolFillProperty"));
  p_registerProperty(1429, CFSTR("TSCHChartSeriesBubbleSymbolFillProperty"));
  p_registerProperty(1430, CFSTR("TSCHChartSeriesLineSymbolFillProperty"));
  p_registerProperty(1431, CFSTR("TSCHChartSeriesMixedAreaSymbolFillProperty"));
  p_registerProperty(1432, CFSTR("TSCHChartSeriesMixedLineSymbolFillProperty"));
  p_registerProperty(1433, CFSTR("TSCHChartSeriesScatterSymbolFillProperty"));
  p_registerProperty(1434, CFSTR("TSCHChartSeriesAreaSymbolFillUseSeriesFillProperty"));
  p_registerProperty(1435, CFSTR("TSCHChartSeriesLineSymbolFillUseSeriesFillProperty"));
  p_registerProperty(1436, CFSTR("TSCHChartSeriesMixedAreaSymbolFillUseSeriesFillProperty"));
  p_registerProperty(1437, CFSTR("TSCHChartSeriesMixedLineSymbolFillUseSeriesFillProperty"));
  p_registerProperty(1438, CFSTR("TSCHChartSeriesAreaSymbolFillUseSeriesStrokeProperty"));
  p_registerProperty(1439, CFSTR("TSCHChartSeriesBubbleSymbolFillUseSeriesStrokeProperty"));
  p_registerProperty(1440, CFSTR("TSCHChartSeriesLineSymbolFillUseSeriesStrokeProperty"));
  p_registerProperty(1441, CFSTR("TSCHChartSeriesMixedAreaSymbolFillUseSeriesStrokeProperty"));
  p_registerProperty(1442, CFSTR("TSCHChartSeriesMixedLineSymbolFillUseSeriesStrokeProperty"));
  p_registerProperty(1443, CFSTR("TSCHChartSeriesScatterSymbolFillUseSeriesStrokeProperty"));
  p_registerProperty(1444, CFSTR("TSCHChartSeriesAreaSymbolSizeProperty"));
  p_registerProperty(1445, CFSTR("TSCHChartSeriesLineSymbolSizeProperty"));
  p_registerProperty(1446, CFSTR("TSCHChartSeriesMixedAreaSymbolSizeProperty"));
  p_registerProperty(1447, CFSTR("TSCHChartSeriesMixedLineSymbolSizeProperty"));
  p_registerProperty(1448, CFSTR("TSCHChartSeriesScatterSymbolSizeProperty"));
  p_registerProperty(1449, CFSTR("TSCHChartSeriesAreaSymbolStrokeProperty"));
  p_registerProperty(1450, CFSTR("TSCHChartSeriesBubbleSymbolStrokeProperty"));
  p_registerProperty(1451, CFSTR("TSCHChartSeriesLineSymbolStrokeProperty"));
  p_registerProperty(1452, CFSTR("TSCHChartSeriesMixedAreaSymbolStrokeProperty"));
  p_registerProperty(1453, CFSTR("TSCHChartSeriesMixedLineSymbolStrokeProperty"));
  p_registerProperty(1454, CFSTR("TSCHChartSeriesScatterSymbolStrokeProperty"));
  p_registerProperty(1455, CFSTR("TSCHChartSeriesDefaultTrendlineEquationOpacityProperty"));
  p_registerProperty(1456, CFSTR("TSCHChartSeriesDefaultTrendlineEquationParagraphStyleIndexProperty"));
  p_registerProperty(1457, CFSTR("TSCHChartSeriesDefaultTrendlineRSquaredOpacityProperty"));
  p_registerProperty(1458, CFSTR("TSCHChartSeriesDefaultTrendlineRSquaredParagraphStyleIndexProperty"));
  p_registerProperty(1459, CFSTR("TSCHChartSeriesDefaultTrendLineShadowProperty"));
  p_registerProperty(1460, CFSTR("TSCHChartSeriesDefaultTrendLineStrokeProperty"));
  p_registerProperty(1461, CFSTR("TSCHChartSeriesAreaValueLabelPositionProperty"));
  p_registerProperty(1462, CFSTR("TSCHChartSeriesBarValueLabelPositionProperty"));
  p_registerProperty(1463, CFSTR("TSCHChartSeriesBubbleValueLabelPositionProperty"));
  p_registerProperty(1464, CFSTR("TSCHChartSeriesDefaultValueLabelPositionProperty"));
  p_registerProperty(1465, CFSTR("TSCHChartSeriesLineValueLabelPositionProperty"));
  p_registerProperty(1466, CFSTR("TSCHChartSeriesMixedAreaValueLabelPositionProperty"));
  p_registerProperty(1467, CFSTR("TSCHChartSeriesMixedColumnValueLabelPositionProperty"));
  p_registerProperty(1468, CFSTR("TSCHChartSeriesMixedLineValueLabelPositionProperty"));
  p_registerProperty(1469, CFSTR("TSCHChartSeriesScatterValueLabelPositionProperty"));
  p_registerProperty(1470, CFSTR("TSCHChartSeriesStackedAreaValueLabelPositionProperty"));
  p_registerProperty(1471, CFSTR("TSCHChartSeriesStackedBarValueLabelPositionProperty"));
  p_registerProperty(1472, CFSTR("TSCHLegendModelDefaultFillProperty"));
  p_registerProperty(1473, CFSTR("TSCHLegendModelDefaultLabelParagraphStyleIndexProperty"));
  p_registerProperty(1474, CFSTR("TSCHLegendModelDefaultOpacityProperty"));
  p_registerProperty(1475, CFSTR("TSCHLegendModelDefaultShadowProperty"));
  p_registerProperty(1476, CFSTR("TSCHLegendModelDefaultStrokeProperty"));
  p_registerProperty(4096, CFSTR("TKSlideTransitionProperty"));
  p_registerProperty(4097, CFSTR("TKSlideTitlePlaceholderVisibilityProperty"));
  p_registerProperty(4098, CFSTR("TKSlideBodyPlaceholderVisibilityProperty"));
  p_registerProperty(4099, CFSTR("TKSlideImagePlaceholderVisibilityProperty"));
  p_registerProperty(4100, CFSTR("TKSlideSlideNumberPlaceholderVisibilityProperty"));
  p_registerProperty(4101, CFSTR("text(Propagation)"));
  p_registerProperty(4102, CFSTR("firstParagraphStyle(Propagation)"));
  p_registerProperty(4103, CFSTR("firstListStyle(Propagation)"));
  p_registerProperty(4104, CFSTR("TKMasterSlideBodyParagraphStyles"));
  p_registerProperty(4105, CFSTR("TKMasterSlideBodyListStyles"));
  p_registerProperty(4106, CFSTR("TKSlideContentsProperty"));
  p_registerProperty(4107, CFSTR("TKSlidePlaceholdersForTagsProperty"));
  p_registerProperty(4608, CFSTR("TRWorkspaceCanvasScaleProperty"));
  p_registerProperty(4609, CFSTR("TRWorkspaceContentScaleProperty"));
  p_registerProperty(4610, CFSTR("TRWorkspacePaginagedProperty"));
  p_registerProperty(4611, CFSTR("TRWorkspacePageGutterProperty"));
  p_registerProperty(4612, CFSTR("TRWorkspacePageOrientationProperty"));
  p_registerProperty(4613, CFSTR("TRWorkspaceTopMarginProperty"));
  p_registerProperty(4614, CFSTR("TRWorkspaceLeftMarginProperty"));
  p_registerProperty(4615, CFSTR("TRWorkspaceRightMarginProperty"));
  p_registerProperty(4616, CFSTR("TRWorkspaceBottomMarginProperty"));
  p_registerProperty(4617, CFSTR("TRWorkspacePageNumberOrientationProperty"));
  p_registerProperty(4618, CFSTR("TRWorkspaceUsePrinterMarginsProperty"));
  p_registerProperty(4619, CFSTR("TRWorkspaceStartPageNumberProperty"));
  p_registerProperty(4620, CFSTR("TRWorkspaceUseStartPageNumberProperty"));
  p_registerProperty(4621, CFSTR("TRFitToSinglePage"));
  p_registerProperty(4622, CFSTR("stageStroke"));
  return p_registerProperty(4623, CFSTR("thumbnailStroke"));
}

const __CFString *p_infoStringFromPropertyValue(int a1)
{
  const __CFString *result;

  result = CFSTR("int");
  switch(a1)
  {
    case 0:
      result = (const __CFString *)TSUObjectReferenceDescription();
      break;
    case 1:
      return result;
    case 2:
      result = CFSTR("float");
      break;
    case 3:
      result = CFSTR("double");
      break;
    default:
      result = &stru_24D82FEB0;
      break;
  }
  return result;
}

const __CFString *p_summaryFromPropertyValue(uint64_t a1, void *a2)
{
  if ((objc_opt_respondsToSelector() & 1) != 0)
    return (const __CFString *)objc_msgSend(a2, "performSelector:", sel_tssPropertySummary);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return (const __CFString *)objc_msgSend(a2, "description");
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return (const __CFString *)objc_msgSend(a2, "description");
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return CFSTR("NSNull");
  else
    return &stru_24D82FEB0;
}

void sub_2179A390C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2179A3A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *String(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  return i_TSSPropertyStoreCreateWithFirstPropertyAndArgumentList(a1, &a9);
}

void String(size_t *a1, uint64_t a2, double a3)
{
  void *v6;
  uint64_t v7;
  size_t *v8;
  uint64_t v9;
  _QWORD v10[2];

  if (!a1)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSSPropertyStoreSetDoubleValueForProperty(TSSPropertyStoreRef, TSSProperty, double)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSPropertyStore.m"), 317, CFSTR("nil map reference"));
  }
  v8 = p_TSSPropertyStoreSearch(a1, a2);
  if (v8)
  {
    v9 = (uint64_t)v8;
    if (!*((_BYTE *)v8 + 10))

    String(v9, a2, a3);
  }
  else
  {
    v10[0] = 0;
    v10[1] = 0;
    String((uint64_t)v10, a2, a3);
    p_TSSPropertyStoreAddNewEntries((uint64_t *)a1, v10, 1);
  }
}

{
  void *v6;
  uint64_t v7;
  size_t *v8;
  size_t *v9;
  int v10;
  float v11;
  _QWORD v12[2];

  if (!a1)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSSPropertyStoreSetCGFloatValueForProperty(TSSPropertyStoreRef, TSSProperty, CGFloat)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSPropertyStore.m"), 334, CFSTR("nil map reference"));
  }
  v8 = p_TSSPropertyStoreSearch(a1, a2);
  v12[0] = 0;
  v12[1] = 0;
  if (v8)
  {
    v9 = v8;
    if (!*((_BYTE *)v8 + 10))

  }
  else
  {
    v9 = v12;
  }
  v10 = String(a2);
  if (v10 == 3)
  {
    String((uint64_t)v9, a2, a3);
  }
  else if (v10 == 2)
  {
    v11 = a3;
    String((uint64_t)v9, a2, v11);
  }
  if (v9 == v12)
    p_TSSPropertyStoreAddNewEntries((uint64_t *)a1, v12, 1);
}

void String(uint64_t *a1, int64_t *a2)
{
  int64_t v3;
  id *v5;
  id *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  id v13;
  id v14;
  __int128 v15;
  void *v16;
  const void *v17;
  int64_t v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  id v23;

  v3 = *a2;
  if (*a2)
  {
    if (*a1)
    {
      if (v3 >= 1)
      {
        v5 = 0;
        v6 = 0;
        v7 = a2[1];
        v8 = a1[1];
        v9 = v7;
        do
        {
          v10 = a1[1] + 16 * *a1;
          if (v8 >= v10)
          {
LABEL_10:
            if (!v6)
            {
              v6 = (id *)malloc_type_calloc(v3 - ((uint64_t)(v9 - v7) >> 4), 0x10uLL, 0x10820400B94AB5FuLL);
              v5 = v6;
            }
            *(_OWORD *)v5 = *(_OWORD *)v9;
            if (!*((_BYTE *)v5 + 10))
              v13 = *v5;
            v9 += 16;
            v5 += 2;
          }
          else
          {
            v11 = *(unsigned __int16 *)(v9 + 8);
            while (1)
            {
              v12 = *(unsigned __int16 *)(v8 + 8);
              if (v12 == v11)
                break;
              if (v12 < v11)
              {
                v8 += 16;
                if (v8 < v10)
                  continue;
              }
              goto LABEL_10;
            }
            if (!*(_BYTE *)(v9 + 10))
              v14 = *(id *)v9;
            if (!*(_BYTE *)(v8 + 10))

            v15 = *(_OWORD *)v9;
            v9 += 16;
            *(_OWORD *)v8 = v15;
            v8 += 16;
          }
          v3 = *a2;
          v7 = a2[1];
        }
        while (v9 < v7 + 16 * *a2);
        if (v6)
        {
          p_TSSPropertyStoreAddNewEntries(a1, v6, ((char *)v5 - (char *)v6) >> 4);
          free(v6);
        }
      }
    }
    else
    {
      v16 = malloc_type_calloc(v3, 0x10uLL, 0x10820400B94AB5FuLL);
      a1[1] = (uint64_t)v16;
      if (v16)
      {
        v18 = *a2;
        v17 = (const void *)a2[1];
        *a1 = *a2;
        memcpy(v16, v17, 16 * v18);
        v19 = *a1;
        if (*a1)
        {
          v20 = 0;
          v21 = 1;
          do
          {
            v22 = a1[1];
            if (!*(_BYTE *)(v22 + 16 * v20 + 10))
            {
              v23 = *(id *)(v22 + 16 * v20);
              v19 = *a1;
            }
            v20 = v21;
          }
          while (v19 > v21++);
        }
      }
    }
  }
}

_QWORD *String(_QWORD *result)
{
  _QWORD *v1;
  unint64_t v2;
  unint64_t v3;
  unsigned __int16 v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int16 v7;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result)
    {
      v3 = 0;
      v4 = 0;
      result = 0;
      v5 = v1[1];
      do
      {
        v6 = v5 + 16 * v3;
        v7 = v4;
        result = (_QWORD *)((char *)result + (v4 | (*(unsigned __int16 *)(v6 + 8) << 16)));
        if (*(_BYTE *)(v6 + 10) == 1)
          result = (_QWORD *)((char *)result + *(int *)(v5 + 16 * v3) + (unint64_t)v4);
        ++v4;
        v3 = (unsigned __int16)(v7 + 1);
      }
      while (v2 > v3);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

double String(size_t *a1, unsigned __int16 a2)
{
  size_t *v2;

  v2 = p_TSSPropertyStoreSearch(a1, a2);
  if (v2)
    return String((uint64_t)v2);
  else
    return INFINITY;
}

{
  size_t *v2;
  double v3;
  int v4;

  v2 = p_TSSPropertyStoreSearch(a1, a2);
  if (v2)
  {
    v4 = *((unsigned __int8 *)v2 + 10);
    if (v4 == 3)
      return String((uint64_t)v2);
    if (v4 == 2)
      return String((uint64_t)v2, v3);
  }
  return INFINITY;
}

void String(uint64_t *a1)
{
  uint64_t v1;

  v1 = String(a1);
  NSLog((NSString *)CFSTR("%@"), v1);
}

void *String(_QWORD *a1, _QWORD *a2, char a3)
{
  void *v6;
  void *v7;
  void *v8;
  TSSMutablePropertySet *v9;
  id v10;
  void *v11;
  unint64_t v12;
  const __CFString *v13;
  void *i;
  unint64_t v15;
  unint64_t v16;
  _QWORD v18[10];
  char v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;

  v6 = (void *)objc_msgSend(MEMORY[0x24BDBCEB8], "array");
  v7 = (void *)objc_msgSend(MEMORY[0x24BDBCEB8], "array");
  v8 = (void *)objc_msgSend(MEMORY[0x24BDBCEB8], "array");
  objc_msgSend(v6, "addObject:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("TSSPropertyStoreRef %p"), a1));
  objc_msgSend(v7, "addObject:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("TSSPropertyStoreRef %p"), a2));
  objc_msgSend(v8, "addObject:", CFSTR(" "));
  v20 = 0;
  v21 = &v20;
  v22 = 0x2020000000;
  v23 = 0;
  v23 = objc_msgSend((id)objc_msgSend(v6, "lastObject"), "length");
  v9 = p_TSSPropertyStoreBuildPropertySet(a1);
  v10 = -[TSSPropertySet propertySetByAddingPropertiesFromSet:](v9, "propertySetByAddingPropertiesFromSet:", p_TSSPropertyStoreBuildPropertySet(a2));
  v18[0] = MEMORY[0x24BDAC760];
  v18[1] = 3221225472;
  v18[2] = __TSSPropertyStoreDiffDescription_block_invoke;
  v18[3] = &unk_24D82AF50;
  v18[8] = a1;
  v18[9] = a2;
  v19 = a3;
  v18[4] = v8;
  v18[5] = v6;
  v18[6] = v7;
  v18[7] = &v20;
  objc_msgSend(v10, "enumeratePropertiesUsingBlock:", v18);
  v11 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
  v12 = 0;
  v13 = &stru_24D82FEB0;
  while (v12 < objc_msgSend(v8, "count"))
  {
    for (i = (void *)objc_msgSend(v6, "objectAtIndexedSubscript:", v12);
          ;
          i = (void *)objc_msgSend(i, "stringByAppendingString:", CFSTR("         ")))
    {
      v15 = objc_msgSend(i, "length");
      if (v15 >= v21[3])
        break;
    }
    v16 = objc_msgSend(i, "length");
    if (v16 > v21[3])
      i = (void *)objc_msgSend(i, "substringToIndex:");
    objc_msgSend(v11, "appendFormat:", CFSTR("%@%@ %@   %@"), v13, objc_msgSend(v8, "objectAtIndexedSubscript:", v12), i, objc_msgSend(v7, "objectAtIndexedSubscript:", v12));
    ++v12;
    v13 = CFSTR("\n");
  }
  _Block_object_dispose(&v20, 8);
  return v11;
}

void sub_2179A48F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

TSSMutablePropertySet *p_TSSPropertyStoreBuildPropertySet(_QWORD *a1)
{
  TSSMutablePropertySet *v2;
  uint64_t v3;
  unsigned int v4;

  v2 = objc_alloc_init(TSSMutablePropertySet);
  if (a1 && *a1)
  {
    v3 = 0;
    v4 = 1;
    do
    {
      -[TSSMutablePropertySet addProperty:](v2, "addProperty:", *(unsigned __int16 *)(a1[1] + 16 * v3 + 8));
      v3 = v4;
    }
    while (*a1 > (unint64_t)v4++);
  }
  return v2;
}

uint64_t String(_QWORD *a1, _QWORD *a2)
{
  TSSMutablePropertySet *v4;
  TSSMutablePropertySet *v5;
  TSSMutablePropertySet *v6;
  uint64_t v7;
  TSSMutablePropertySet *v8;
  id v9;
  _QWORD v11[9];
  _QWORD v12[4];

  v12[3] = *MEMORY[0x24BDAC8D0];
  v4 = objc_alloc_init(TSSMutablePropertySet);
  v5 = objc_alloc_init(TSSMutablePropertySet);
  v6 = objc_alloc_init(TSSMutablePropertySet);
  v12[0] = v4;
  v12[1] = v5;
  v12[2] = v6;
  v7 = objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v12, 3);
  v8 = p_TSSPropertyStoreBuildPropertySet(a1);
  v9 = -[TSSPropertySet propertySetByAddingPropertiesFromSet:](v8, "propertySetByAddingPropertiesFromSet:", p_TSSPropertyStoreBuildPropertySet(a2));
  v11[0] = MEMORY[0x24BDAC760];
  v11[1] = 3221225472;
  v11[2] = __TSSPropertyStoreDiffPropertyNames_block_invoke;
  v11[3] = &unk_24D82AF78;
  v11[7] = a1;
  v11[8] = a2;
  v11[4] = v4;
  v11[5] = v5;
  v11[6] = v6;
  objc_msgSend(v9, "enumeratePropertiesUsingBlock:", v11);
  return v7;
}

void String(unint64_t *a1)
{
  id *v2;
  unint64_t v3;
  uint64_t v4;
  unsigned int v5;

  v3 = *a1;
  v2 = (id *)a1[1];
  if (*a1)
  {
    v4 = 0;
    v5 = 1;
    do
    {
      if (!BYTE2(v2[2 * v4 + 1]))

      v4 = v5;
    }
    while (v3 > v5++);
    v2 = (id *)a1[1];
  }
  free(v2);
  *a1 = 0;
  a1[1] = 0;
}

uint64_t String(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@-%lu-%@"), a1, a2, a3);
}

uint64_t String(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@-%lu-%@"), a1, a2, a3);
  return objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@-%@"), v5, a4);
}

uint64_t String(void *a1, const char *a2)
{
  return objc_msgSend(a1, "stringByReplacingOccurrencesOfString:withString:", CFSTR("-"), CFSTR("_"));
}

{
  return objc_msgSend(a1, "componentsSeparatedByString:", CFSTR("-"));
}

uint64_t String(void *a1, uint64_t a2)
{
  void *v4;

  v4 = (void *)objc_msgSend(a1, "componentsSeparatedByString:", CFSTR("-"));
  if (v4 && objc_msgSend(v4, "count") == 3)
    return objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@-%@"), a1, a2);
  else
    return 0;
}

id String(void *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *i;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[128];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = (void *)objc_msgSend(MEMORY[0x24BEB3CA8], "setWithSet:", a1);
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v3 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
  if (v3)
  {
    v4 = v3;
    v5 = *(_QWORD *)v11;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v11 != v5)
          objc_enumerationMutation(a1);
        objc_opt_class();
        v7 = TSUDynamicCast();
        if (v7)
        {
          for (i = (void *)v7; objc_msgSend(i, "parent"); objc_msgSend(v2, "addObject:", i))
            i = (void *)objc_msgSend(i, "parent");
        }
        ++v6;
      }
      while (v6 != v4);
      v4 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
    }
    while (v4);
  }
  return (id)objc_msgSend(v2, "copy");
}

{
  id v2;
  id v3;
  _QWORD v5[6];

  if (!a1)
    return 0;
  v2 = (id)objc_msgSend(a1, "propertyMap");
  if (!v2)
    v2 = +[TSSPropertyMap propertyMap](TSSPropertyMap, "propertyMap");
  v3 = (id)objc_msgSend((id)objc_msgSend((id)objc_opt_class(), "properties"), "mutableCopy");
  objc_msgSend(v3, "removeProperties:", objc_msgSend(v2, "allProperties"));
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 3221225472;
  v5[2] = __TSSFullPropertyMapForStyle_block_invoke;
  v5[3] = &unk_24D82AF00;
  v5[4] = a1;
  v5[5] = v2;
  objc_msgSend(v3, "enumeratePropertiesUsingBlock:", v5);
  return v2;
}

const __CFString *String(void *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;

  if (!a1)
    return CFSTR("nil");
  v2 = (void *)objc_msgSend(a1, "rootAncestor");
  v3 = objc_msgSend(v2, "descendantCount") + 1;
  v4 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "documentRoot"), "theme"), "stylesheet");
  if (v3 != 2)
    return (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%lu of %lu"), v3 - objc_msgSend(a1, "descendantCount"), v3);
  if (v2 == (void *)v4)
  {
    if (v2 == a1)
    {
      return CFSTR("Theme");
    }
    else
    {
      if ((void *)objc_msgSend(v2, "child") != a1)
      {
        v12 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v13 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSSDebugStylesheetDescription(TSSStylesheet *)");
        v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSStyle.m");
        v8 = (void *)v12;
        v9 = v13;
        v10 = 209;
        goto LABEL_12;
      }
      return CFSTR("Document");
    }
  }
  else if (v2 == a1)
  {
    return CFSTR("Pasteboard-Root");
  }
  else
  {
    if ((void *)objc_msgSend(v2, "child") != a1)
    {
      v5 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSSDebugStylesheetDescription(TSSStylesheet *)");
      v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSStyle.m");
      v8 = (void *)v5;
      v9 = v6;
      v10 = 224;
LABEL_12:
      objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, v7, v10, CFSTR("Unexpected."));
      return CFSTR("Unexpected");
    }
    return CFSTR("Pasteboard-Child");
  }
}

{
  return String((void *)objc_msgSend(a1, "stylesheet"));
}

{
  if (objc_msgSend(a1, "styleIdentifier"))
    return (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("<%@>"), objc_msgSend(a1, "styleIdentifier"));
  else
    return &stru_24D82FEB0;
}

{
  if (objc_msgSend(a1, "name"))
    return (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("'%@'"), objc_msgSend(a1, "name"));
  else
    return &stru_24D82FEB0;
}

{
  if (!a1)
    return &stru_24D82FEB0;
  if (objc_msgSend(a1, "styleIdentifier"))
  {
    if (objc_msgSend(a1, "styleIdentifier"))
      return (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("<%@>"), objc_msgSend(a1, "styleIdentifier"));
    return &stru_24D82FEB0;
  }
  if (objc_msgSend(a1, "name") && objc_msgSend((id)objc_msgSend(a1, "name"), "length"))
  {
    if (objc_msgSend(a1, "name"))
      return (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("'%@'"), objc_msgSend(a1, "name"));
    return &stru_24D82FEB0;
  }
  return (const __CFString *)TSUObjectReferenceDescription();
}

void *String(void *a1)
{
  void *v2;
  const __CFString *v3;
  const __CFString *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  void *v10;
  const __CFString *v11;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _QWORD v17[2];
  _BYTE v18[128];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v2 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  if (objc_msgSend(a1, "styleIdentifier"))
    v3 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("<%@>"), objc_msgSend(a1, "styleIdentifier"));
  else
    v3 = &stru_24D82FEB0;
  v17[0] = v3;
  if (objc_msgSend(a1, "name"))
    v4 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("'%@'"), objc_msgSend(a1, "name"));
  else
    v4 = &stru_24D82FEB0;
  v17[1] = v4;
  v5 = (void *)objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v17, 2);
  v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v13, v18, 16);
  if (v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)v14;
    do
    {
      for (i = 0; i != v7; ++i)
      {
        if (*(_QWORD *)v14 != v8)
          objc_enumerationMutation(v5);
        v10 = *(void **)(*((_QWORD *)&v13 + 1) + 8 * i);
        if (objc_msgSend(v10, "length"))
        {
          if (objc_msgSend(v2, "length"))
            v11 = CFSTR(" ");
          else
            v11 = &stru_24D82FEB0;
          objc_msgSend(v2, "appendFormat:", CFSTR("%@%@"), v11, v10);
        }
      }
      v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v13, v18, 16);
    }
    while (v7);
  }
  return v2;
}

uint64_t String(void *a1, void *a2)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;

  if (!objc_msgSend(a1, "stylesheet"))
    return 1;
  v4 = objc_msgSend(a1, "stylesheet");
  if (v4 == objc_msgSend(a2, "stylesheet"))
    return 1;
  result = objc_msgSend((id)objc_msgSend(a1, "stylesheet"), "parent");
  if (result)
  {
    v6 = objc_msgSend((id)objc_msgSend(a1, "stylesheet"), "parent");
    return v6 == objc_msgSend(a2, "stylesheet");
  }
  return result;
}

void sub_2179A5E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_2179A72D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2179A7414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2179A7DB8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  objc_sync_exit(v2);
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A7E54(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A8030(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A82D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_2179A83AC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A840C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A8484(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A85B8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A8760(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_2179A88E4(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_2179A8A4C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_2179A8AB0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A8C10(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_2179A8D54(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A8F20(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A9128(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A953C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A963C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A97D8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A9888(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179A9C1C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

double String(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  unsigned int v4;
  void *v5;
  uint64_t v6;
  double result;
  void *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;

  if (!a1)
  {
    v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSSPropertyEntryGetDoubleValue(const TSSPropertyEntry *)");
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSPropertyEntry_Internal.m"), 106, CFSTR("invalid nil value for '%s'"), "entry");
  }
  v4 = *(unsigned __int8 *)(a1 + 10);
  if (v4 >= 3)
  {
    if (v4 == 3)
    {
      result = *(double *)a1;
      if (*(double *)a1 != INFINITY)
        return result;
    }
    else
    {
      v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSSPropertyEntryGetDoubleValue(const TSSPropertyEntry *)");
      objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSPropertyEntry_Internal.m"), 121, CFSTR("Unexpected entry type"), v12);
    }
  }
  else
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSSPropertyEntryGetDoubleValue(const TSSPropertyEntry *)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSPropertyEntry_Internal.m"), 118, CFSTR("Asked for double value of a %@-valued property."), String(*(unsigned __int8 *)(a1 + 10)));
  }
  v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler", result);
  v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "double TSSPropertyEntryGetDoubleValue(const TSSPropertyEntry *)");
  objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/styles/TSSPropertyEntry_Internal.m"), 125, CFSTR("Undefined value in entry for property %d %@"), *(unsigned __int16 *)(a1 + 8), String(*(unsigned __int16 *)(a1 + 8)));
  return INFINITY;
}

void sub_2179A9FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 135);
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 135);
}

uint64_t String()
{
  uint64_t v0;
  void *v1;
  void *v2;

  v0 = TSUProtocolCast();
  v1 = (void *)TSUProtocolCast();
  v2 = v1;
  if (v0)
  {
    v1 = (void *)v0;
    return objc_msgSend(v1, "isThemeEquivalent:", v2);
  }
  if (v1)
  {
    v2 = 0;
    return objc_msgSend(v1, "isThemeEquivalent:", v2);
  }
  return 0;
}

{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  char v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v6 = 1;
  if (_styleValidationQueue_onceToken != -1)
    dispatch_once(&_styleValidationQueue_onceToken, &__block_literal_global_21);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = __TSSShouldValidateStyles_block_invoke;
  block[3] = &unk_24D82B2A8;
  block[4] = &v3;
  dispatch_sync((dispatch_queue_t)_styleValidationQueue_queue, block);
  v0 = *((unsigned __int8 *)v4 + 24);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t identifierFollowsPackageConvention(NSString *a1)
{
  return objc_msgSend((id)String(a1), "isEqualToString:", CFSTR("imported")) ^ 1;
}

void sub_2179ACDDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__9(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_2179AD054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _styleValidationQueue()
{
  if (_styleValidationQueue_onceToken != -1)
    dispatch_once(&_styleValidationQueue_onceToken, &__block_literal_global_21);
  return _styleValidationQueue_queue;
}

dispatch_queue_t ___styleValidationQueue_block_invoke()
{
  dispatch_queue_t result;

  result = dispatch_queue_create("TSSValidation", 0);
  _styleValidationQueue_queue = (uint64_t)result;
  return result;
}

void String()
{
  if (_styleValidationQueue_onceToken != -1)
    dispatch_once(&_styleValidationQueue_onceToken, &__block_literal_global_21);
  dispatch_sync((dispatch_queue_t)_styleValidationQueue_queue, &__block_literal_global_3);
}

{
  if (_styleValidationQueue_onceToken != -1)
    dispatch_once(&_styleValidationQueue_onceToken, &__block_literal_global_21);
  dispatch_sync((dispatch_queue_t)_styleValidationQueue_queue, &__block_literal_global_4);
}

void sub_2179ADAD8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179AED84(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179AEDF8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179AEEC8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2179AFA34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2179B056C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;

  _Block_object_dispose(&a16, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 128), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__10(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_2179B8D40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2179BE73C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSDImageMaxAllowedDataLength()
{
  if (objc_msgSend(+[TSDCapabilities currentCapabilities](TSDCapabilities, "currentCapabilities"), "isRendererH4OrBelow"))return 0x2000000;
  else
    return 0x4000000;
}

uint64_t TSDDirectionOpposite(uint64_t a1)
{
  return TSDDirectionOpposite_opposite[a1];
}

uint64_t TSDDirectionTurnRight(uint64_t a1)
{
  return TSDDirectionTurnRight_rightTurn[a1];
}

double TSDDirectionDelta(uint64_t a1)
{
  return TSDDirectionDelta_deltas[2 * a1];
}

id TSDResampledImageFromProvider(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, double a6, double a7)
{
  double v14;
  double v15;
  double v16;
  double v17;
  void *v18;
  BOOL v19;
  __CFString *v22;
  __CFString *v23;
  uint64_t v24;
  TSDImageResamplingOperation *v25;
  id v26;
  id v27;
  void *v29;
  void *v30;
  uint64_t v31;

  objc_msgSend(a1, "naturalSize");
  v15 = v14;
  v17 = v16;
  objc_opt_class();
  v18 = (void *)TSUDynamicCast();
  if (v18)
    v19 = v15 <= a6;
  else
    v19 = 0;
  if (v19 && a2 == 0 && v17 <= a7)
  {
    v29 = v18;
    if ((a5 & 4) == 0 || (objc_msgSend(v18, "isOpaque") & 1) == 0)
    {
      v30 = (void *)objc_msgSend(v29, "imageData");
      v31 = objc_msgSend(+[TSDCapabilities currentCapabilities](TSDCapabilities, "currentCapabilities"), "isRendererH4OrBelow")? 0x2000000: 0x4000000;
      if (!objc_msgSend(v30, "isLengthLikelyToBeGreaterThan:", v31))
        return 0;
    }
  }
  v22 = (__CFString *)objc_msgSend(a3, "stringByDeletingPathExtension");
  if (!v22 || (v23 = v22, !-[__CFString length](v22, "length")))
    v23 = CFSTR("image");
  v24 = -[__CFString stringByAppendingString:](v23, "stringByAppendingString:", CFSTR("-small"));
  v25 = -[TSDImageResamplingOperation initWithImageProvider:desiredSize:]([TSDImageResamplingOperation alloc], "initWithImageProvider:desiredSize:", a1, a6, a7);
  -[TSDImageResamplingOperation setDisplayName:](v25, "setDisplayName:", v24);
  -[TSDImageResamplingOperation setObjectContext:](v25, "setObjectContext:", a4);
  -[TSDImageResamplingOperation setMaskingPath:](v25, "setMaskingPath:", a2);
  v26 = -[TSDImageResamplingOperation performResampleOperationWithResampleOptions:bitmapContextOptions:](v25, "performResampleOperationWithResampleOptions:bitmapContextOptions:", a5, 9);
  v27 = v26;

  return v26;
}

id TSDResampleImageData(void *a1, uint64_t a2, uint64_t a3, double a4, double a5)
{
  id v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v16;
  id v17;
  void *v18;
  char v19;
  void *v20;
  id v21;

  v9 = a1;
  if (!a1)
  {
    v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSPData *TSDResampleImageData(TSPData *, CGSize, CGPathRef, TSDImageResampleOptions)");
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDUtility.m"), 143, CFSTR("invalid nil value for '%s'"), "sourceImageData");
  }
  if (a4 <= 0.0 || a5 <= 0.0)
  {
    v12 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v13 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSPData *TSDResampleImageData(TSPData *, CGSize, CGPathRef, TSDImageResampleOptions)");
    objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDUtility.m"), 144, CFSTR("bogus size to resample"));
  }
  if (objc_msgSend(+[TSDCapabilities currentCapabilities](TSDCapabilities, "currentCapabilities"), "isRendererH4OrBelow"))v14 = 0x2000000;
  else
    v14 = 0x4000000;
  if ((objc_msgSend(v9, "isLengthLikelyToBeGreaterThan:", v14) & 1) != 0)
    return 0;
  v16 = 0;
  if (v9 && a4 > 0.0 && a5 > 0.0)
  {
    v17 = objc_alloc_init(MEMORY[0x24BDD1460]);
    v18 = (void *)objc_msgSend(+[TSDImageProviderPool sharedPool](TSDImageProviderPool, "sharedPool"), "temporaryProviderForData:shouldValidate:", v9, 1);
    v19 = objc_msgSend(v18, "isError");
    if ((a3 & 2) != 0)
    {
      if ((v19 & 1) != 0)
      {
LABEL_20:
        v21 = v9;

        v16 = v9;
        return v16;
      }
    }
    else
    {
      objc_opt_class();
      v20 = (void *)TSUDynamicCast();
      if (!v20 || (objc_msgSend(v20, "isValid") & 1) == 0)
        goto LABEL_20;
    }
    v9 = TSDResampledImageFromProvider(v18, a2, (void *)objc_msgSend(v9, "filename"), objc_msgSend(v9, "context"), a3, a4, a5);
    goto LABEL_20;
  }
  return v16;
}

id TSDPossiblyResampledImageDataFromNSData(void *a1, uint64_t a2, void *a3, uint64_t a4, double a5, double a6)
{
  void *v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  id v18;
  id v19;
  id v20;
  TSDBitmapImageProvider *v21;
  TSDBitmapImageProvider *v22;
  id v23;
  id v24;
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;

  if (!a1)
  {
    v25 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v26 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSPData *TSDPossiblyResampledImageDataFromNSData(NSData *, CGSize, TSPObjectContext *, NSString *, TSDImageResampleOptions)");
    objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDUtility.m"), 185, CFSTR("invalid nil value for '%s'"), "imageNSData");
    if (a2)
      goto LABEL_3;
LABEL_22:
    v27 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v28 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSPData *TSDPossiblyResampledImageDataFromNSData(NSData *, CGSize, TSPObjectContext *, NSString *, TSDImageResampleOptions)");
    objc_msgSend(v27, "handleFailureInFunction:file:lineNumber:description:", v28, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDUtility.m"), 186, CFSTR("invalid nil value for '%s'"), "context");
    goto LABEL_3;
  }
  if (!a2)
    goto LABEL_22;
LABEL_3:
  if (a5 <= 0.0 || a6 <= 0.0)
  {
    v12 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v13 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSPData *TSDPossiblyResampledImageDataFromNSData(NSData *, CGSize, TSPObjectContext *, NSString *, TSDImageResampleOptions)");
    objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDUtility.m"), 187, CFSTR("bogus size to resample"));
  }
  v14 = objc_msgSend(a1, "length");
  v15 = objc_msgSend(+[TSDCapabilities currentCapabilities](TSDCapabilities, "currentCapabilities"), "isRendererH4OrBelow");
  v16 = 0x4000000;
  if (v15)
    v16 = 0x2000000;
  if (v14 > v16)
    return 0;
  v18 = 0;
  if (a5 > 0.0 && a1 && a2 && a6 > 0.0)
  {
    v19 = objc_alloc_init(MEMORY[0x24BDD1460]);
    v20 = +[TSPData readOnlyDataFromNSData:filename:context:](TSPData, "readOnlyDataFromNSData:filename:context:", a1, a3, 0);
    v21 = -[TSDImageProvider initWithImageData:]([TSDBitmapImageProvider alloc], "initWithImageData:", v20);
    v22 = v21;
    if (!v21
      || !-[TSDBitmapImageProvider isValid](v21, "isValid")
      || (v23 = TSDResampledImageFromProvider(v22, 0, a3, a2, a4, a5, a6)) == 0
      || (v18 = v23, v23 == v20))
    {
      v18 = +[TSPData dataFromNSData:filename:context:](TSPData, "dataFromNSData:filename:context:", a1, a3, a2);
    }
    v24 = v18;

  }
  return v18;
}

void _TSDBitmapContextClearContextInfo(void *a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD v4[5];

  if (a1)
  {
    if (a2)
    {
      v3 = objc_msgSend((id)objc_msgSend(a1, "objectAtIndex:", 0), "pointerValue");
      v4[0] = MEMORY[0x24BDAC760];
      v4[1] = 3221225472;
      v4[2] = __TSDClearCGContextInfo_block_invoke;
      v4[3] = &__block_descriptor_40_e33_v16__0__TSUPointerKeyDictionary_8l;
      v4[4] = v3;
      TSDAccessCGContextInfoDictionaryWithBlock(1, 0, (uint64_t)v4);

    }
  }
}

uint64_t TSDClearCGContextInfo(uint64_t a1)
{
  _QWORD v2[5];

  v2[0] = MEMORY[0x24BDAC760];
  v2[1] = 3221225472;
  v2[2] = __TSDClearCGContextInfo_block_invoke;
  v2[3] = &__block_descriptor_40_e33_v16__0__TSUPointerKeyDictionary_8l;
  v2[4] = a1;
  return TSDAccessCGContextInfoDictionaryWithBlock(1, 0, (uint64_t)v2);
}

CGContext *TSDBitmapContextCreate(char a1, double a2)
{
  size_t v3;
  double v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  CGColorSpace *v8;
  uint32_t v9;
  uint64_t v10;
  size_t v11;
  int v12;
  uint64_t v13;
  int v14;
  size_t AlignedBytesPerRow;
  id releaseInfo;
  CGContext *v17;

  v3 = (unint64_t)TSDCeilSize(a2);
  v5 = (unint64_t)v4;
  if ((a1 & 1) != 0)
  {
    if ((a1 & 0x20) != 0)
      v10 = TSUP3ColorSpace();
    else
      v10 = TSUDeviceRGBColorSpace();
    v8 = (CGColorSpace *)v10;
    if ((a1 & 4) != 0)
      v12 = 4102;
    else
      v12 = 8198;
    v13 = 5;
    if ((a1 & 4) == 0)
      v13 = 8;
    if ((a1 & 0x10) != 0)
      v14 = 8193;
    else
      v14 = 8194;
    if ((a1 & 2) != 0)
      v9 = v14;
    else
      v9 = v12;
    if ((a1 & 2) != 0)
      v11 = 8;
    else
      v11 = v13;
  }
  else
  {
    if ((a1 & 2) != 0)
    {
      v8 = 0;
      v9 = 7;
    }
    else
    {
      v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGContextRef TSDBitmapContextCreate(CGSize, TSDBitmapContextOptions)");
      objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDUtility.m"), 304, CFSTR("Must include a color or alpha channel."));
      v8 = 0;
      v9 = 8194;
    }
    v11 = 8;
  }
  AlignedBytesPerRow = TSUBitmapGetAlignedBytesPerRow();
  releaseInfo = objc_alloc_init(MEMORY[0x24BDBCEB8]);
  v17 = CGBitmapContextCreateWithData(0, v3, v5, v11, AlignedBytesPerRow, v8, v9, (CGBitmapContextReleaseDataCallback)_TSDBitmapContextClearContextInfo, releaseInfo);
  objc_msgSend(releaseInfo, "addObject:", objc_msgSend(MEMORY[0x24BDD1968], "valueWithPointer:", v17));
  TSDSetCGContextInfo((uint64_t)v17, 0, 0, 0, 0, 1.0);
  if ((a1 & 8) != 0)
  {
    CGContextTranslateCTM(v17, 0.0, (double)v5);
    CGContextScaleCTM(v17, 1.0, -1.0);
  }
  return v17;
}

void TSDSetCGContextInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  void *v12;
  void *v13;
  double v14;
  double v15;
  double v16;
  double v17;

  v12 = (void *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x24BDD17F0], "currentThread"), "threadDictionary"), "objectForKey:", CFSTR("TSDTilingTileLayerPositionTLSKey"));
  v13 = v12;
  if (v12)
  {
    objc_msgSend(v12, "CGPointValue");
    v15 = v14;
    v17 = v16;
  }
  else
  {
    v15 = *MEMORY[0x24BDBEFB0];
    v17 = *(double *)(MEMORY[0x24BDBEFB0] + 8);
  }
  TSDSetCGContextInfoWithTileOffset(a1, a2, a3, a4, v13 != 0, a5, a6, v15, v17);
}

void *TSUCompositeImageWithColor(void *result, void *a2, CGBlendMode a3, CGFloat a4)
{
  void *v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  CGContext *v13;
  double v14;
  double v15;
  CGFloat v16;
  double v17;
  CGFloat v18;
  double v19;
  CGFloat v20;
  CGImage *v21;
  CGImage *Image;
  uint64_t v23;
  CGRect v24;
  CGRect v25;

  if (result)
  {
    v7 = result;
    objc_msgSend(result, "scale");
    v9 = v8;
    objc_msgSend(v7, "size");
    v12 = TSDMultiplySizeScalar(v10, v11, v9);
    v13 = TSDBitmapContextCreate(3, v12);
    v14 = TSDRectWithSize();
    v16 = v15;
    v18 = v17;
    v20 = v19;
    v21 = (CGImage *)objc_msgSend(v7, "CGImage");
    v24.origin.x = v14;
    v24.origin.y = v16;
    v24.size.width = v18;
    v24.size.height = v20;
    CGContextDrawImage(v13, v24, v21);
    CGContextSetFillColorWithColor(v13, (CGColorRef)objc_msgSend(a2, "CGColor"));
    CGContextSetAlpha(v13, a4);
    CGContextSetBlendMode(v13, a3);
    v25.origin.x = v14;
    v25.origin.y = v16;
    v25.size.width = v18;
    v25.size.height = v20;
    CGContextFillRect(v13, v25);
    Image = CGBitmapContextCreateImage(v13);
    v23 = objc_msgSend(MEMORY[0x24BEB3C90], "imageWithCGImage:scale:orientation:", Image, 0, v9);
    CGImageRelease(Image);
    CGContextRelease(v13);
    return (void *)v23;
  }
  return result;
}

double TSDComputeBoxTransformAndSizeForPDFPage(CGPDFPage *a1, uint64_t a2, CGFloat *a3)
{
  return TSDComputeBoxTransformAndSizeForPDFPageIgnoringAngle(a1, a2, a3, 0);
}

double TSDComputeBoxTransformAndSizeForPDFPageIgnoringAngle(CGPDFPage *a1, uint64_t a2, CGFloat *a3, int a4)
{
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  double v16;
  CGFloat v17;
  CGFloat v18;
  CGFloat v19;
  double MaxX;
  CGFloat MaxY;
  CGFloat v22;
  CGFloat v23;
  int RotationAngle;
  int v25;
  double v26;
  __int128 v27;
  double v28;
  void *v29;
  uint64_t v30;
  CGFloat v31;
  double MinY;
  double MinX;
  CGRect BoxRect;
  CGRect v36;
  CGRect v37;
  CGRect v38;
  CGRect v39;
  CGRect v40;
  CGRect v41;
  CGRect v42;
  CGRect v43;
  CGRect v44;
  CGRect v45;
  CGRect v46;

  if (!a1)
  {
    v29 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v30 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGRect TSDComputeBoxTransformAndSizeForPDFPageIgnoringAngle(CGPDFPageRef, CGAffineTransform *, CGSize *, BOOL)");
    objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDUtility.m"), 485, CFSTR("invalid nil value for '%s'"), "page");
    return *MEMORY[0x24BDBF090];
  }
  BoxRect = CGPDFPageGetBoxRect(a1, kCGPDFMediaBox);
  x = BoxRect.origin.x;
  y = BoxRect.origin.y;
  width = BoxRect.size.width;
  height = BoxRect.size.height;
  v36 = CGPDFPageGetBoxRect(a1, kCGPDFCropBox);
  v12 = v36.origin.x;
  v13 = v36.origin.y;
  v14 = v36.size.width;
  v15 = v36.size.height;
  v45 = CGPDFPageGetBoxRect(a1, kCGPDFArtBox);
  v37.origin.x = x;
  v37.origin.y = y;
  v37.size.width = width;
  v37.size.height = height;
  v46 = CGRectIntersection(v37, v45);
  v38.origin.x = v12;
  v38.origin.y = v13;
  v38.size.width = v14;
  v38.size.height = v15;
  v39 = CGRectIntersection(v38, v46);
  v16 = v39.origin.x;
  v17 = v39.origin.y;
  v18 = v39.size.width;
  v19 = v39.size.height;
  MinX = CGRectGetMinX(v39);
  v40.origin.x = v16;
  v40.origin.y = v17;
  v40.size.width = v18;
  v40.size.height = v19;
  MinY = CGRectGetMinY(v40);
  v41.origin.x = v16;
  v41.origin.y = v17;
  v41.size.width = v18;
  v41.size.height = v19;
  MaxX = CGRectGetMaxX(v41);
  v42.origin.x = v16;
  v42.origin.y = v17;
  v42.size.width = v18;
  v42.size.height = v19;
  MaxY = CGRectGetMaxY(v42);
  v43.origin.x = v16;
  v43.origin.y = v17;
  v43.size.width = v18;
  v43.size.height = v19;
  v22 = CGRectGetWidth(v43);
  v44.origin.x = v16;
  v44.origin.y = v17;
  v44.size.width = v18;
  v44.size.height = v19;
  v23 = CGRectGetHeight(v44);
  RotationAngle = CGPDFPageGetRotationAngle(a1);
  if (a4)
    v25 = 0;
  else
    v25 = RotationAngle;
  if (v25 == 90)
  {
    v27 = xmmword_217C28F20;
    v28 = MaxX;
    MaxX = -MinY;
    v26 = 1.0;
LABEL_11:
    v31 = v23;
    v23 = v22;
    if (!a2)
      goto LABEL_13;
    goto LABEL_12;
  }
  v26 = 0.0;
  if (v25 == 180)
  {
    v27 = xmmword_217C28F10;
    v28 = MaxY;
  }
  else
  {
    if (v25 == 270)
    {
      v27 = xmmword_217C28F30;
      v28 = -MinX;
      v26 = -1.0;
      MaxX = MaxY;
      goto LABEL_11;
    }
    MaxX = -MinX;
    v27 = xmmword_217C28F40;
    v28 = -MinY;
  }
  v31 = v22;
  if (a2)
  {
LABEL_12:
    *(_OWORD *)a2 = v27;
    *(double *)(a2 + 16) = v26;
    *(_QWORD *)(a2 + 24) = v27;
    *(double *)(a2 + 32) = MaxX;
    *(double *)(a2 + 40) = v28;
  }
LABEL_13:
  if (a3)
  {
    *a3 = v31;
    a3[1] = v23;
  }
  return v16;
}

__n128 TSDComputeDrawTransformForPDFPage@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>, double a3@<D0>, double a4@<D1>, CGFloat a5@<D2>, CGFloat a6@<D3>, CGFloat a7@<D4>, CGFloat a8@<D5>)
{
  __n128 v16;
  __n128 v17;
  CGFloat v18;
  CGFloat v19;
  CGFloat v20;
  CGFloat MinY;
  double Width;
  double Height;
  __n128 v24;
  __n128 v25;
  __n128 v26;
  __n128 v27;
  __n128 v28;
  __n128 v29;
  __n128 v30;
  __n128 result;
  CGFloat tx;
  CGAffineTransform t2;
  CGAffineTransform t1;
  CGAffineTransform v35;
  CGAffineTransform v36;
  CGRect v37;
  CGRect v38;
  CGRect v39;

  memset(&v36, 0, sizeof(v36));
  CGAffineTransformMakeTranslation(&v36, a3 * -0.5, a4 * -0.5);
  v16 = a1[1];
  *(__n128 *)&t1.a = *a1;
  *(__n128 *)&t1.c = v16;
  *(__n128 *)&t1.tx = a1[2];
  t2 = v36;
  CGAffineTransformConcat(&v35, &t1, &t2);
  v17 = *(__n128 *)&v35.c;
  *a1 = *(__n128 *)&v35.a;
  a1[1] = v17;
  a1[2] = *(__n128 *)&v35.tx;
  v18 = a5;
  v17.n128_f64[0] = a6;
  v19 = a7;
  v20 = a8;
  tx = CGRectGetMinX(*(CGRect *)((char *)&v17 - 8));
  v37.origin.x = a5;
  v37.origin.y = a6;
  v37.size.width = a7;
  v37.size.height = a8;
  MinY = CGRectGetMinY(v37);
  v38.origin.x = a5;
  v38.origin.y = a6;
  v38.size.width = a7;
  v38.size.height = a8;
  Width = CGRectGetWidth(v38);
  v39.origin.x = a5;
  v39.origin.y = a6;
  v39.size.width = a7;
  v39.size.height = a8;
  Height = CGRectGetHeight(v39);
  CGAffineTransformMakeScale(&v35, Width / a3, Height / a4);
  v36 = v35;
  v24 = a1[1];
  *(__n128 *)&t1.a = *a1;
  *(__n128 *)&t1.c = v24;
  *(__n128 *)&t1.tx = a1[2];
  t2 = v35;
  CGAffineTransformConcat(&v35, &t1, &t2);
  v25 = *(__n128 *)&v35.c;
  *a1 = *(__n128 *)&v35.a;
  a1[1] = v25;
  a1[2] = *(__n128 *)&v35.tx;
  CGAffineTransformMakeTranslation(&v35, Width * 0.5, Height * 0.5);
  v36 = v35;
  v26 = a1[1];
  *(__n128 *)&t1.a = *a1;
  *(__n128 *)&t1.c = v26;
  *(__n128 *)&t1.tx = a1[2];
  t2 = v35;
  CGAffineTransformConcat(&v35, &t1, &t2);
  v27 = *(__n128 *)&v35.c;
  *a1 = *(__n128 *)&v35.a;
  a1[1] = v27;
  a1[2] = *(__n128 *)&v35.tx;
  CGAffineTransformMakeTranslation(&v35, tx, MinY);
  v36 = v35;
  v28 = a1[1];
  *(__n128 *)&t1.a = *a1;
  *(__n128 *)&t1.c = v28;
  *(__n128 *)&t1.tx = a1[2];
  t2 = v35;
  CGAffineTransformConcat(&v35, &t1, &t2);
  v29 = *(__n128 *)&v35.c;
  *a1 = *(__n128 *)&v35.a;
  a1[1] = v29;
  a1[2] = *(__n128 *)&v35.tx;
  v30 = a1[1];
  *a2 = *a1;
  a2[1] = v30;
  result = a1[2];
  a2[2] = result;
  return result;
}

uint64_t TSDSetCGContextInfoForShadowContext(uint64_t a1, double a2)
{
  _QWORD v5[6];

  TSDSetCGContextInfo(a1, 0, 0, 0, 0, 1.0);
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 3221225472;
  v5[2] = __TSDSetCGContextInfoForShadowContext_block_invoke;
  v5[3] = &__block_descriptor_48_e33_v16__0__TSUPointerKeyDictionary_8l;
  v5[4] = a1;
  *(double *)&v5[5] = a2;
  return TSDAccessCGContextInfoDictionaryWithBlock(1, 1, (uint64_t)v5);
}

uint64_t TSDCGContextUpdateLayoutAngle(uint64_t a1, double a2)
{
  _QWORD v3[6];

  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = __TSDCGContextUpdateLayoutAngle_block_invoke;
  v3[3] = &__block_descriptor_48_e33_v16__0__TSUPointerKeyDictionary_8l;
  v3[4] = a1;
  *(double *)&v3[5] = a2;
  return TSDAccessCGContextInfoDictionaryWithBlock(1, 1, (uint64_t)v3);
}

uint64_t TSDCGContextSetIsReflection(uint64_t a1, char a2)
{
  _QWORD v3[5];
  char v4;

  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = __TSDCGContextSetIsReflection_block_invoke;
  v3[3] = &__block_descriptor_41_e33_v16__0__TSUPointerKeyDictionary_8l;
  v3[4] = a1;
  v4 = a2;
  return TSDAccessCGContextInfoDictionaryWithBlock(1, 1, (uint64_t)v3);
}

uint64_t TSDCGContextSetBitmapQualityInfo(uint64_t a1, uint64_t a2)
{
  _QWORD v3[6];

  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = __TSDCGContextSetBitmapQualityInfo_block_invoke;
  v3[3] = &unk_24D82B7A8;
  v3[4] = a2;
  v3[5] = a1;
  return TSDAccessCGContextInfoDictionaryWithBlock(1, 1, (uint64_t)v3);
}

void TSDSetCGContextInfoWithTileOffset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, double a7, double a8, double a9)
{
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  _QWORD v26[6];

  v18 = objc_alloc(MEMORY[0x24BDBCED8]);
  v19 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", a2);
  v20 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", a3);
  v21 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", a4);
  *(float *)&v22 = a7;
  v23 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v22);
  if (a5)
    v24 = objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGPoint:", a8, a9);
  else
    v24 = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
  v25 = (void *)objc_msgSend(v18, "initWithObjectsAndKeys:", v19, CFSTR("TSDCGContextInfoDictionaryKeyIsPrintContext"), v20, CFSTR("TSDCGContextInfoDictionaryKeyIsPDFContext"), v21, CFSTR("TSDCGContextInfoDictionaryKeyIsCALayerContext"), v23, CFSTR("TSDCGContextInfoDictionaryKeyAssociatedScreenScale"), v24, CFSTR("TSDCGContextInfoDictionaryKeyTileOffset"), objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", a6), CFSTR("TSDCGContextInfoDictionaryKeyHasBackgroundsSuppressed"), 0);
  v26[0] = MEMORY[0x24BDAC760];
  v26[1] = 3221225472;
  v26[2] = __TSDSetCGContextInfoWithTileOffset_block_invoke;
  v26[3] = &unk_24D82B7A8;
  v26[4] = v25;
  v26[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(1, 1, (uint64_t)v26);

}

const __CFString *NSStringFromCGLineCap(unsigned int a1)
{
  if (a1 > 2)
    return CFSTR("invalid CGLineCap");
  else
    return off_24D82B830[a1];
}

const __CFString *NSStringFromCGLineJoin(unsigned int a1)
{
  if (a1 > 2)
    return CFSTR("invalid CGLineJoin");
  else
    return off_24D82B848[a1];
}

double TSDCGContextGetShadowedLayoutAngle(uint64_t a1)
{
  double v1;
  _QWORD v3[6];
  uint64_t v4;
  double *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = (double *)&v4;
  v6 = 0x2020000000;
  v7 = 0;
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = __TSDCGContextGetShadowedLayoutAngle_block_invoke;
  v3[3] = &unk_24D82B7F0;
  v3[4] = &v4;
  v3[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_2179C767C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSDCGContextIsShadowContext(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = __TSDCGContextIsShadowContext_block_invoke;
  v3[3] = &unk_24D82B7F0;
  v3[4] = &v4;
  v3[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_2179C776C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSDCGContextGetIsReflection(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = __TSDCGContextGetIsReflection_block_invoke;
  v3[3] = &unk_24D82B7F0;
  v3[4] = &v4;
  v3[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_2179C785C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSDCGContextGetBitmapQualityInfo(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  void (*v7)(uint64_t, uint64_t);
  void (*v8)(uint64_t);
  uint64_t v9;

  v4 = 0;
  v5 = &v4;
  v6 = 0x3052000000;
  v7 = __Block_byref_object_copy__11;
  v8 = __Block_byref_object_dispose__11;
  v9 = 0;
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = __TSDCGContextGetBitmapQualityInfo_block_invoke;
  v3[3] = &unk_24D82B7F0;
  v3[4] = &v4;
  v3[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v3);
  v1 = v5[5];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_2179C795C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__11(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

double TSDCGContextGetLayoutAngle(uint64_t a1)
{
  double v1;
  _QWORD v3[6];
  uint64_t v4;
  double *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = (double *)&v4;
  v6 = 0x2020000000;
  v7 = 0;
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = __TSDCGContextGetLayoutAngle_block_invoke;
  v3[3] = &unk_24D82B7F0;
  v3[4] = &v4;
  v3[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_2179C7A68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSDCGContextIsPrintContext(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = __TSDCGContextIsPrintContext_block_invoke;
  v3[3] = &unk_24D82B7F0;
  v3[4] = &v4;
  v3[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_2179C7B58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSDCGContextIsPDFContext(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = __TSDCGContextIsPDFContext_block_invoke;
  v3[3] = &unk_24D82B7F0;
  v3[4] = &v4;
  v3[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_2179C7C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSDCGContextIsCALayerContext(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = __TSDCGContextIsCALayerContext_block_invoke;
  v3[3] = &unk_24D82B7F0;
  v3[4] = &v4;
  v3[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_2179C7D74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double TSDCGContextAssociatedScreenScale(uint64_t a1)
{
  double v1;
  double v2;
  _QWORD v4[6];
  uint64_t v5;
  double *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = (double *)&v5;
  v7 = 0x2020000000;
  v8 = 0;
  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 3221225472;
  v4[2] = __TSDCGContextAssociatedScreenScale_block_invoke;
  v4[3] = &unk_24D82B7F0;
  v4[4] = &v5;
  v4[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v4);
  v1 = v6[3];
  if (v1 == 0.0)
  {
    TSUScreenScale();
    v1 = v2;
  }
  _Block_object_dispose(&v5, 8);
  return v1;
}

void sub_2179C7E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL TSDCGContextHasTileOffset(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 v7;
  _QWORD v9[6];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  void (*v13)(uint64_t, uint64_t);
  void (*v14)(uint64_t);
  uint64_t v15;

  if (a2)
    *(_OWORD *)a2 = *MEMORY[0x24BDBEFB0];
  v10 = 0;
  v11 = &v10;
  v12 = 0x3052000000;
  v13 = __Block_byref_object_copy__11;
  v14 = __Block_byref_object_dispose__11;
  v15 = 0;
  v9[0] = MEMORY[0x24BDAC760];
  v9[1] = 3221225472;
  v9[2] = __TSDCGContextHasTileOffset_block_invoke;
  v9[3] = &unk_24D82B7F0;
  v9[4] = &v10;
  v9[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v9);
  v3 = v11;
  if (a2)
  {
    v4 = (void *)v11[5];
    if (v4)
    {
      objc_msgSend(v4, "CGPointValue");
      *(_QWORD *)a2 = v5;
      *(_QWORD *)(a2 + 8) = v6;
      v3 = v11;
    }
  }
  v7 = v3[5] != 0;
  _Block_object_dispose(&v10, 8);
  return v7;
}

void sub_2179C7FB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSDCGContextPrefersRasterRendering(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = __TSDCGContextPrefersRasterRendering_block_invoke;
  v3[3] = &unk_24D82B7F0;
  v3[4] = &v4;
  v3[5] = a1;
  TSDAccessCGContextInfoDictionaryWithBlock(0, 0, (uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_2179C80C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CGFloat TSDTransformConvertingRectToRectAtPercent@<D0>(uint64_t a1@<X8>, double a2@<D0>, double a3@<D2>, double a4@<D3>, double a5@<D4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, double a9)
{
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  CGFloat v20;
  double v21;
  double v22;
  CGFloat v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  CGFloat result;
  CGAffineTransform v31;
  CGAffineTransform v32;

  v14 = TSDSubtractPoints(a5, a6, a2);
  v15 = a7 / a3;
  v16 = a8 / a4;
  v18 = TSDMultiplyPointScalar(v14, v17, a9);
  v20 = v19;
  v21 = TSDMixSizes(1.0, 1.0, v15, v16, a9);
  v23 = v22;
  v24 = MEMORY[0x24BDBD8B8];
  v25 = *MEMORY[0x24BDBD8B8];
  v26 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  *(_OWORD *)a1 = *MEMORY[0x24BDBD8B8];
  *(_OWORD *)(a1 + 16) = v26;
  v27 = *(_OWORD *)(v24 + 32);
  *(_OWORD *)(a1 + 32) = v27;
  *(_OWORD *)&v32.a = v25;
  *(_OWORD *)&v32.c = v26;
  *(_OWORD *)&v32.tx = v27;
  CGAffineTransformTranslate((CGAffineTransform *)a1, &v32, v18, v20);
  v28 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v31.a = *(_OWORD *)a1;
  *(_OWORD *)&v31.c = v28;
  *(_OWORD *)&v31.tx = *(_OWORD *)(a1 + 32);
  CGAffineTransformScale(&v32, &v31, v21, v23);
  v29 = *(_OWORD *)&v32.c;
  *(_OWORD *)a1 = *(_OWORD *)&v32.a;
  *(_OWORD *)(a1 + 16) = v29;
  result = v32.tx;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v32.tx;
  return result;
}

BOOL TSDTransformsDifferOnlyByTranslation(double *a1, double *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3];
}

CGPath *TSDCreatePathFromTransformedRect(const CGAffineTransform *a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  CGPath *Mutable;
  CGRect v12;

  Mutable = CGPathCreateMutable();
  v12.origin.x = a2;
  v12.origin.y = a3;
  v12.size.width = a4;
  v12.size.height = a5;
  CGPathAddRect(Mutable, a1, v12);
  return Mutable;
}

float64x2_t TSDTransformedCornersOfRect(float64x2_t *a1, double *a2, double *a3, double *a4, double *a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9)
{
  CGFloat MinX;
  CGFloat MinY;
  CGFloat MaxX;
  CGFloat MaxY;
  float64x2_t result;
  CGRect v23;
  CGRect v24;
  CGRect v25;

  MinX = CGRectGetMinX(*(CGRect *)&a6);
  v23.origin.x = a6;
  v23.origin.y = a7;
  v23.size.width = a8;
  v23.size.height = a9;
  MinY = CGRectGetMinY(v23);
  v24.origin.x = a6;
  v24.origin.y = a7;
  v24.size.width = a8;
  v24.size.height = a9;
  MaxX = CGRectGetMaxX(v24);
  v25.origin.x = a6;
  v25.origin.y = a7;
  v25.size.width = a8;
  v25.size.height = a9;
  MaxY = CGRectGetMaxY(v25);
  *a2 = MinX;
  a2[1] = MinY;
  *a3 = MinX;
  a3[1] = MaxY;
  *a4 = MaxX;
  a4[1] = MaxY;
  *a5 = MaxX;
  a5[1] = MinY;
  *(float64x2_t *)a2 = vaddq_f64(a1[2], vmlaq_n_f64(vmulq_n_f64(a1[1], a2[1]), *a1, *a2));
  *(float64x2_t *)a3 = vaddq_f64(a1[2], vmlaq_n_f64(vmulq_n_f64(a1[1], a3[1]), *a1, *a3));
  *(float64x2_t *)a4 = vaddq_f64(a1[2], vmlaq_n_f64(vmulq_n_f64(a1[1], a4[1]), *a1, *a4));
  result = vaddq_f64(a1[2], vmlaq_n_f64(vmulq_n_f64(a1[1], a5[1]), *a1, *a5));
  *(float64x2_t *)a5 = result;
  return result;
}

CGAffineTransform *TSDAffineTransformShear@<X0>(_OWORD *a1@<X0>, CGAffineTransform *a2@<X8>, CGFloat a3@<D0>, CGFloat a4@<D1>)
{
  __int128 v9;
  CGAffineTransform v11;
  CGAffineTransform t1;

  t1.a = 1.0;
  t1.b = a3;
  t1.c = a4;
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)&t1.d = _Q0;
  t1.ty = 1.0;
  v9 = a1[1];
  *(_OWORD *)&v11.a = *a1;
  *(_OWORD *)&v11.c = v9;
  *(_OWORD *)&v11.tx = a1[2];
  return CGAffineTransformConcat(a2, &t1, &v11);
}

long double TSDTransformAngle(double *a1)
{
  double v1;
  double v2;

  v2 = *a1;
  v1 = a1[1];
  if (v1 * a1[2] - *a1 * a1[3] > 0.0)
  {
    v2 = -v2;
    v1 = -v1;
  }
  return atan2(v1, v2) * 57.2957795;
}

BOOL TSDIsTransformFlipped(double *a1)
{
  return a1[2] * a1[1] - *a1 * a1[3] > 0.0;
}

double TSDTransformScale(double *a1)
{
  return sqrt(a1[1] * a1[1] + *a1 * *a1);
}

CGAffineTransform *TSDTransformNormalizeScale@<X0>(uint64_t a1@<X0>, CGAffineTransform *a2@<X8>)
{
  CGFloat v2;
  CGFloat v3;
  __int128 v4;
  CGAffineTransform v6;

  v2 = 1.0 / sqrt(*(double *)(a1 + 8) * *(double *)(a1 + 8) + *(double *)a1 * *(double *)a1);
  v3 = 1.0 / sqrt(*(double *)(a1 + 24) * *(double *)(a1 + 24) + *(double *)(a1 + 16) * *(double *)(a1 + 16));
  v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v6.a = *(_OWORD *)a1;
  *(_OWORD *)&v6.c = v4;
  *(_OWORD *)&v6.tx = *(_OWORD *)(a1 + 32);
  return CGAffineTransformScale(a2, &v6, v2, v3);
}

BOOL TSDIsTransformAxisAlignedWithObjectSize(double *a1, double a2, double a3)
{
  double v3;
  double v4;
  double v5;

  v3 = 1.0 / (a2 * 0.5);
  v4 = 1.0 / (a3 * 0.5);
  if (v3 >= v4)
    v3 = v4;
  v5 = fabs(a1[3]);
  if (fabs(*a1) < v3 && v5 < v3)
    return 1;
  if (fabs(a1[1]) >= v3)
    return 0;
  return fabs(a1[2]) < v3;
}

BOOL TSDIsTransformAxisAlignedWithThreshold(double *a1, double a2)
{
  if (fabs(*a1) < a2 && fabs(a1[3]) < a2)
    return 1;
  if (fabs(a1[1]) >= a2)
    return 0;
  return fabs(a1[2]) < a2;
}

BOOL TSDIsTransformAxisAligned(double *a1)
{
  if (fabs(*a1) < 1.0e-12 && fabs(a1[3]) < 1.0e-12)
    return 1;
  if (fabs(a1[1]) >= 1.0e-12)
    return 0;
  return fabs(a1[2]) < 1.0e-12;
}

BOOL TSDIsTransformAxisAlignedUnflipped(double *a1)
{
  return fabs(a1[1]) < 1.0e-12 && fabs(a1[2]) < 1.0e-12 && *a1 >= 0.0 && a1[3] >= 0.0;
}

CGAffineTransform *TSDAffineTransformForFlips@<X0>(CGAffineTransform *result@<X0>, int a2@<W1>, uint64_t a3@<X8>, CGFloat a4@<D0>, CGFloat a5@<D1>, CGFloat a6@<D2>, CGFloat a7@<D3>)
{
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  CGFloat v17;
  CGFloat v18;
  CGFloat v19;
  double MinX;
  CGFloat MaxX;
  __int128 v22;
  __int128 v23;
  double MinY;
  CGFloat MaxY;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  CGAffineTransform v33;
  CGAffineTransform v34;
  CGRect v35;
  CGRect v36;
  CGRect v37;

  v13 = MEMORY[0x24BDBD8B8];
  v14 = *MEMORY[0x24BDBD8B8];
  v15 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  *(_OWORD *)a3 = *MEMORY[0x24BDBD8B8];
  *(_OWORD *)(a3 + 16) = v15;
  v16 = *(_OWORD *)(v13 + 32);
  *(_OWORD *)(a3 + 32) = v16;
  if ((_DWORD)result)
  {
    v31 = v15;
    v32 = v14;
    v17 = a4;
    v18 = a5;
    v30 = v16;
    v19 = a6;
    MinX = CGRectGetMinX(*(CGRect *)(&a7 - 3));
    v35.origin.x = a4;
    v35.origin.y = a5;
    v35.size.width = a6;
    v35.size.height = a7;
    MaxX = CGRectGetMaxX(v35);
    *(_OWORD *)&v34.a = v32;
    *(_OWORD *)&v34.c = v31;
    *(_OWORD *)&v34.tx = v30;
    CGAffineTransformTranslate((CGAffineTransform *)a3, &v34, MinX + MaxX, 0.0);
    v22 = *(_OWORD *)(a3 + 16);
    *(_OWORD *)&v33.a = *(_OWORD *)a3;
    *(_OWORD *)&v33.c = v22;
    *(_OWORD *)&v33.tx = *(_OWORD *)(a3 + 32);
    result = CGAffineTransformScale(&v34, &v33, -1.0, 1.0);
    v23 = *(_OWORD *)&v34.c;
    *(_OWORD *)a3 = *(_OWORD *)&v34.a;
    *(_OWORD *)(a3 + 16) = v23;
    *(_OWORD *)(a3 + 32) = *(_OWORD *)&v34.tx;
  }
  if (a2)
  {
    v36.origin.x = a4;
    v36.origin.y = a5;
    v36.size.width = a6;
    v36.size.height = a7;
    MinY = CGRectGetMinY(v36);
    v37.origin.x = a4;
    v37.origin.y = a5;
    v37.size.width = a6;
    v37.size.height = a7;
    MaxY = CGRectGetMaxY(v37);
    v26 = *(_OWORD *)(a3 + 16);
    *(_OWORD *)&v33.a = *(_OWORD *)a3;
    *(_OWORD *)&v33.c = v26;
    *(_OWORD *)&v33.tx = *(_OWORD *)(a3 + 32);
    CGAffineTransformTranslate(&v34, &v33, 0.0, MinY + MaxY);
    v27 = *(_OWORD *)&v34.c;
    *(_OWORD *)a3 = *(_OWORD *)&v34.a;
    *(_OWORD *)(a3 + 16) = v27;
    *(_OWORD *)(a3 + 32) = *(_OWORD *)&v34.tx;
    v28 = *(_OWORD *)(a3 + 16);
    *(_OWORD *)&v33.a = *(_OWORD *)a3;
    *(_OWORD *)&v33.c = v28;
    *(_OWORD *)&v33.tx = *(_OWORD *)(a3 + 32);
    result = CGAffineTransformScale(&v34, &v33, 1.0, -1.0);
    v29 = *(_OWORD *)&v34.c;
    *(_OWORD *)a3 = *(_OWORD *)&v34.a;
    *(_OWORD *)(a3 + 16) = v29;
    *(_OWORD *)(a3 + 32) = *(_OWORD *)&v34.tx;
  }
  return result;
}

CGAffineTransform *TSDTransformFromTransformSpace@<X0>(_OWORD *a1@<X0>, _OWORD *a2@<X1>, CGAffineTransform *a3@<X8>)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  CGAffineTransform v10;
  CGAffineTransform t1;
  CGAffineTransform v12;

  v6 = a2[1];
  *(_OWORD *)&v10.a = *a2;
  *(_OWORD *)&v10.c = v6;
  *(_OWORD *)&v10.tx = a2[2];
  CGAffineTransformInvert(&t1, &v10);
  v7 = a1[1];
  *(_OWORD *)&v10.a = *a1;
  *(_OWORD *)&v10.c = v7;
  *(_OWORD *)&v10.tx = a1[2];
  CGAffineTransformConcat(&v12, &t1, &v10);
  v8 = a2[1];
  *(_OWORD *)&v10.a = *a2;
  *(_OWORD *)&v10.c = v8;
  *(_OWORD *)&v10.tx = a2[2];
  return CGAffineTransformConcat(a3, &v12, &v10);
}

CGAffineTransform *TSDTransformInTransformSpace@<X0>(_OWORD *a1@<X0>, _OWORD *a2@<X1>, CGAffineTransform *a3@<X8>)
{
  __int128 v5;
  __int128 v6;
  __int128 v7;
  CGAffineTransform v9;
  CGAffineTransform t2;
  CGAffineTransform t1;
  CGAffineTransform v12;

  v5 = a2[1];
  *(_OWORD *)&t1.a = *a2;
  *(_OWORD *)&t1.c = v5;
  *(_OWORD *)&t1.tx = a2[2];
  v6 = a1[1];
  *(_OWORD *)&t2.a = *a1;
  *(_OWORD *)&t2.c = v6;
  *(_OWORD *)&t2.tx = a1[2];
  CGAffineTransformConcat(&v12, &t1, &t2);
  v7 = a2[1];
  *(_OWORD *)&t1.a = *a2;
  *(_OWORD *)&t1.c = v7;
  *(_OWORD *)&t1.tx = a2[2];
  CGAffineTransformInvert(&v9, &t1);
  return CGAffineTransformConcat(a3, &v12, &v9);
}

CGAffineTransform *TSDTransformConvertForNewOrigin@<X0>(_OWORD *a1@<X0>, CGAffineTransform *a2@<X8>, CGFloat a3@<D0>, CGFloat a4@<D1>)
{
  __int128 v8;
  CGAffineTransform v10;
  CGAffineTransform t1;
  CGAffineTransform v12;
  CGAffineTransform v13;
  CGAffineTransform v14;

  memset(&v14, 0, sizeof(v14));
  CGAffineTransformMakeTranslation(&v14, -a3, -a4);
  memset(&v13, 0, sizeof(v13));
  CGAffineTransformMakeTranslation(&v13, a3, a4);
  t1 = v13;
  v8 = a1[1];
  *(_OWORD *)&v10.a = *a1;
  *(_OWORD *)&v10.c = v8;
  *(_OWORD *)&v10.tx = a1[2];
  CGAffineTransformConcat(&v12, &t1, &v10);
  t1 = v14;
  return CGAffineTransformConcat(a2, &v12, &t1);
}

CGAffineTransform *TSDTransformMakeFree@<X0>(int a1@<W0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>, double a5@<D2>, double a6@<D3>, CGFloat a7@<D4>, double a8@<D5>, double a9@<D6>, double a10@<D7>)
{
  double v18;
  double v19;
  double v20;
  long double v21;
  double v22;
  double v23;
  long double v24;
  double v25;
  __int128 v26;
  __int128 v27;
  double v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  CGAffineTransform *result;
  __int128 v35;
  double sx;
  CGFloat v38;
  CGAffineTransform v39;
  CGAffineTransform v40;
  CGAffineTransform v41;
  CGAffineTransform t1;
  CGAffineTransform t2;
  CGAffineTransform v44;

  v18 = TSDDistance(a3, a4, a5, a6);
  v38 = a7;
  v19 = TSDDistance(a7, a8, a9, a10);
  if (v18 < 0.0001 || v19 < 0.0001)
    return CGAffineTransformMakeTranslation((CGAffineTransform *)a2, a7 - a3, a8 - a4);
  sx = v19 / v18;
  v20 = TSDSubtractPoints(a3, a4, a5);
  v22 = TSDAngleFromDelta(v20, v21);
  v23 = TSDSubtractPoints(a7, a8, a9);
  v25 = TSDAngleFromDelta(v23, v24);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  CGAffineTransformMakeTranslation((CGAffineTransform *)a2, -a3, -a4);
  CGAffineTransformMakeRotation(&t2, -v22);
  v26 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&t1.a = *(_OWORD *)a2;
  *(_OWORD *)&t1.c = v26;
  *(_OWORD *)&t1.tx = *(_OWORD *)(a2 + 32);
  CGAffineTransformConcat(&v44, &t1, &t2);
  v27 = *(_OWORD *)&v44.c;
  *(_OWORD *)a2 = *(_OWORD *)&v44.a;
  *(_OWORD *)(a2 + 16) = v27;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)&v44.tx;
  v28 = 1.0;
  if (!a1)
    v28 = sx;
  CGAffineTransformMakeScale(&v41, sx, v28);
  v29 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&t1.a = *(_OWORD *)a2;
  *(_OWORD *)&t1.c = v29;
  *(_OWORD *)&t1.tx = *(_OWORD *)(a2 + 32);
  CGAffineTransformConcat(&v44, &t1, &v41);
  v30 = *(_OWORD *)&v44.c;
  *(_OWORD *)a2 = *(_OWORD *)&v44.a;
  *(_OWORD *)(a2 + 16) = v30;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)&v44.tx;
  CGAffineTransformMakeRotation(&v40, v25);
  v31 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&t1.a = *(_OWORD *)a2;
  *(_OWORD *)&t1.c = v31;
  *(_OWORD *)&t1.tx = *(_OWORD *)(a2 + 32);
  CGAffineTransformConcat(&v44, &t1, &v40);
  v32 = *(_OWORD *)&v44.c;
  *(_OWORD *)a2 = *(_OWORD *)&v44.a;
  *(_OWORD *)(a2 + 16) = v32;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)&v44.tx;
  CGAffineTransformMakeTranslation(&v39, v38, a8);
  v33 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&t1.a = *(_OWORD *)a2;
  *(_OWORD *)&t1.c = v33;
  *(_OWORD *)&t1.tx = *(_OWORD *)(a2 + 32);
  result = CGAffineTransformConcat(&v44, &t1, &v39);
  v35 = *(_OWORD *)&v44.c;
  *(_OWORD *)a2 = *(_OWORD *)&v44.a;
  *(_OWORD *)(a2 + 16) = v35;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)&v44.tx;
  return result;
}

double TSD_CGAffineTransformDecompose(uint64_t a1, uint64_t a2)
{
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  __int128 v14;
  __int128 v15;
  double v16;
  __int128 v17;
  __int128 v18;
  double result;
  CGAffineTransform v20;
  CGAffineTransform v21;

  v4 = *(double *)(a1 + 8);
  v5 = *(double *)(a1 + 16);
  v6 = *(double *)(a1 + 24);
  v7 = sqrt(v4 * v4 + *(double *)a1 * *(double *)a1);
  v8 = sqrt(v6 * v6 + v5 * v5);
  v9 = *(double *)a1 * v6 - v5 * v4;
  v10 = -v8;
  v11 = -v7;
  if (*(double *)a1 < v6)
    v10 = v8;
  else
    v11 = v7;
  if (v9 < 0.0)
    v12 = v11;
  else
    v12 = v7;
  if (v9 < 0.0)
    v13 = v10;
  else
    v13 = v8;
  v14 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v20.a = *(_OWORD *)a1;
  *(_OWORD *)&v20.c = v14;
  *(_OWORD *)&v20.tx = *(_OWORD *)(a1 + 32);
  CGAffineTransformScale(&v21, &v20, 1.0 / v12, 1.0 / v13);
  v15 = *(_OWORD *)&v21.c;
  *(_OWORD *)a1 = *(_OWORD *)&v21.a;
  *(_OWORD *)(a1 + 16) = v15;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v21.tx;
  v16 = atan2(*(long double *)(a1 + 8), *(long double *)a1);
  v17 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v20.a = *(_OWORD *)a1;
  *(_OWORD *)&v20.c = v17;
  *(_OWORD *)&v20.tx = *(_OWORD *)(a1 + 32);
  CGAffineTransformRotate(&v21, &v20, -v16);
  v18 = *(_OWORD *)&v21.c;
  *(_OWORD *)a1 = *(_OWORD *)&v21.a;
  *(_OWORD *)(a1 + 16) = v18;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v21.tx;
  *(double *)a2 = v12;
  *(double *)(a2 + 8) = v13;
  *(double *)(a2 + 16) = v16;
  *(_QWORD *)(a2 + 24) = *(_QWORD *)a1;
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 32);
  result = *(double *)(a1 + 40);
  *(double *)(a2 + 64) = result;
  return result;
}

CGFloat TSD_CGAffineTransformCompose@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v4;
  CGFloat v5;
  __int128 v6;
  CGFloat v7;
  CGFloat v8;
  __int128 v9;
  __int128 v10;
  CGFloat result;
  CGAffineTransform v12;
  CGAffineTransform v13;

  v4 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 56);
  v5 = *(double *)(a1 + 16);
  v6 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&v13.a = *(_OWORD *)a2;
  *(_OWORD *)&v13.c = v6;
  *(_OWORD *)&v13.tx = *(_OWORD *)(a2 + 32);
  CGAffineTransformRotate((CGAffineTransform *)a2, &v13, v5);
  v7 = *(double *)a1;
  v8 = *(double *)(a1 + 8);
  v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&v12.a = *(_OWORD *)a2;
  *(_OWORD *)&v12.c = v9;
  *(_OWORD *)&v12.tx = *(_OWORD *)(a2 + 32);
  CGAffineTransformScale(&v13, &v12, v7, v8);
  v10 = *(_OWORD *)&v13.c;
  *(_OWORD *)a2 = *(_OWORD *)&v13.a;
  *(_OWORD *)(a2 + 16) = v10;
  result = v13.tx;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)&v13.tx;
  return result;
}

void TSDTransformMixAffineTransforms(__int128 *a1@<X0>, _OWORD *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  __int128 v7;
  __int128 v8;
  double v9;
  double v10;
  double v11;
  BOOL v12;
  double *v13;
  uint64_t i;
  _OWORD v15[3];
  __int128 v16;
  _OWORD v17[4];
  double v18;
  double v19;
  double __x;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v7 = a1[1];
  v16 = *a1;
  v17[0] = v7;
  v17[1] = a1[2];
  TSD_CGAffineTransformDecompose((uint64_t)&v16, (uint64_t)&v18);
  v8 = a2[1];
  v15[0] = *a2;
  v15[1] = v8;
  v15[2] = a2[2];
  TSD_CGAffineTransformDecompose((uint64_t)v15, (uint64_t)&v16);
  if ((v18 >= 0.0 || *((double *)&v16 + 1) >= 0.0) && (v19 >= 0.0 || *(double *)&v16 >= 0.0))
  {
    v9 = __x;
  }
  else
  {
    v18 = -v18;
    v19 = -v19;
    v9 = __x + dbl_217C29030[__x < 0.0];
  }
  v10 = fmod(v9, 6.28318531);
  __x = v10;
  v11 = fmod(*(long double *)v17, 6.28318531);
  *(double *)v17 = v11;
  if (vabdd_f64(v10, v11) > 3.14159265)
  {
    v12 = v10 <= v11;
    if (v10 > v11)
      v11 = v10;
    v13 = (double *)&v16;
    if (!v12)
      v13 = &v18;
    v13[2] = v11 + -6.28318531;
  }
  for (i = 0; i != 72; i += 8)
    *(double *)((char *)&v18 + i) = *(double *)((char *)&v18 + i)
                                  + (*(double *)((char *)&v17[-1] + i) - *(double *)((char *)&v18 + i)) * a4;
  TSD_CGAffineTransformCompose((uint64_t)&v18, a3);
}

double TSDOffsetForEdgeOfFrame(int a1, double a2, double a3, double a4, double a5)
{
  double result;

  switch(a1)
  {
    case 0:
      result = CGRectGetMinX(*(CGRect *)&a2);
      break;
    case 1:
      result = CGRectGetMidX(*(CGRect *)&a2);
      break;
    case 2:
      result = CGRectGetMaxX(*(CGRect *)&a2);
      break;
    case 3:
      result = CGRectGetMinY(*(CGRect *)&a2);
      break;
    case 4:
      result = CGRectGetMidY(*(CGRect *)&a2);
      break;
    case 5:
      result = CGRectGetMaxY(*(CGRect *)&a2);
      break;
    default:
      result = 0.0;
      break;
  }
  return result;
}

double TSDRectWithCenterAndSize(double a1, double a2, double a3)
{
  return a1 - a3 * 0.5;
}

double TSDRectWithPoints(double a1, double a2, double a3)
{
  if (a1 >= a3)
    return a3;
  else
    return a1;
}

double TSDRectWithSizeAlignedToRect(int a1, int a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double x;
  double width;
  CGRect v17;
  CGRect v18;
  CGRect v19;
  CGRect v20;
  CGRect v21;
  CGRect v22;
  CGRect v23;
  CGRect v24;

  v17.size.height = a4;
  v17.size.width = a3;
  v17.origin.x = 0.0;
  v17.origin.y = 0.0;
  v18 = CGRectStandardize(v17);
  x = v18.origin.x;
  width = v18.size.width;
  v18.origin.x = a5;
  v18.origin.y = a6;
  v18.size.width = a7;
  v18.size.height = a8;
  if (!CGRectIsNull(v18))
  {
    switch(a1)
    {
      case 3:
        v20.origin.x = a5;
        v20.origin.y = a6;
        v20.size.width = a7;
        v20.size.height = a8;
        x = CGRectGetMaxX(v20) - width;
        break;
      case 2:
        v21.origin.x = a5;
        v21.origin.y = a6;
        v21.size.width = a7;
        v21.size.height = a8;
        x = CGRectGetMidX(v21) + width * -0.5;
        break;
      case 1:
        v19.origin.x = a5;
        v19.origin.y = a6;
        v19.size.width = a7;
        v19.size.height = a8;
        x = CGRectGetMinX(v19);
        break;
    }
    switch(a2)
    {
      case 3:
        v23.origin.x = a5;
        v23.origin.y = a6;
        v23.size.width = a7;
        v23.size.height = a8;
        CGRectGetMaxY(v23);
        break;
      case 2:
        v24.origin.x = a5;
        v24.origin.y = a6;
        v24.size.width = a7;
        v24.size.height = a8;
        CGRectGetMidY(v24);
        break;
      case 1:
        v22.origin.x = a5;
        v22.origin.y = a6;
        v22.size.width = a7;
        v22.size.height = a8;
        CGRectGetMinY(v22);
        break;
    }
  }
  return x;
}

BOOL TSDNearlyEqualPoints(double a1, double a2, double a3, double a4)
{
  _BOOL4 v4;

  v4 = vabdd_f64(a1, a3) < 0.01;
  return vabdd_f64(a2, a4) < 0.01 && v4;
}

BOOL TSDNearlyEqualSizes(double a1, double a2, double a3, double a4)
{
  _BOOL4 v4;

  v4 = vabdd_f64(a1, a3) < 0.01;
  return vabdd_f64(a2, a4) < 0.01 && v4;
}

BOOL TSDNearlyEqualRects(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  _BOOL8 result;
  _BOOL4 v9;

  result = 0;
  if (vabdd_f64(a1, a5) < 0.01 && vabdd_f64(a2, a6) < 0.01)
  {
    v9 = vabdd_f64(a3, a7) < 0.01;
    return vabdd_f64(a4, a8) < 0.01 && v9;
  }
  return result;
}

BOOL TSDNearlyContainsRect(double a1, double a2, double a3, double a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  CGRect v13;
  CGRect v14;

  v13 = CGRectInset(*(CGRect *)&a1, -0.01, -0.01);
  v14.origin.x = a5;
  v14.origin.y = a6;
  v14.size.width = a7;
  v14.size.height = a8;
  return CGRectContainsRect(v13, v14);
}

BOOL TSDCollinearPoints(double a1, double a2, double a3, double a4, double a5, double a6)
{
  return fabs((a3 - a1) * (a6 - a2) - (a4 - a2) * (a5 - a1)) < 8.90029543e-308;
}

BOOL TSDNearlyCollinearPoints(double a1, double a2, double a3, double a4, double a5, double a6)
{
  double v6;

  v6 = a3 - a1;
  return (v6 * (a6 - a2) - (a4 - a2) * (a5 - a1)) * (v6 * (a6 - a2) - (a4 - a2) * (a5 - a1)) < ((a4 - a2) * (a4 - a2)
                                                                                              + v6 * v6)
                                                                                             * 0.0001
                                                                                             * ((a6 - a2) * (a6 - a2)
                                                                                              + (a5 - a1) * (a5 - a1));
}

double TSDDistanceSquared(double a1, double a2, double a3, double a4)
{
  return (a2 - a4) * (a2 - a4) + (a1 - a3) * (a1 - a3);
}

BOOL TSDRectsOverlapVertically(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double v16;
  double MaxX;
  double v18;
  double MinX;
  CGRect v22;
  CGRect v23;
  CGRect v24;

  MinX = CGRectGetMinX(*(CGRect *)&a1);
  v22.origin.x = a5;
  v22.origin.y = a6;
  v22.size.width = a7;
  v22.size.height = a8;
  v16 = CGRectGetMinX(v22);
  v23.origin.x = a1;
  v23.origin.y = a2;
  v23.size.width = a3;
  v23.size.height = a4;
  MaxX = CGRectGetMaxX(v23);
  v24.origin.x = a5;
  v24.origin.y = a6;
  v24.size.width = a7;
  v24.size.height = a8;
  v18 = CGRectGetMaxX(v24);
  if (MinX <= v16)
    return MaxX >= v16;
  else
    return v18 >= MinX;
}

BOOL TSDRectsOverlapHorizontally(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double v16;
  double MaxY;
  double v18;
  double MinY;
  CGRect v22;
  CGRect v23;
  CGRect v24;

  MinY = CGRectGetMinY(*(CGRect *)&a1);
  v22.origin.x = a5;
  v22.origin.y = a6;
  v22.size.width = a7;
  v22.size.height = a8;
  v16 = CGRectGetMinY(v22);
  v23.origin.x = a1;
  v23.origin.y = a2;
  v23.size.width = a3;
  v23.size.height = a4;
  MaxY = CGRectGetMaxY(v23);
  v24.origin.x = a5;
  v24.origin.y = a6;
  v24.size.width = a7;
  v24.size.height = a8;
  v18 = CGRectGetMaxY(v24);
  if (MinY <= v16)
    return MaxY >= v16;
  else
    return v18 >= MinY;
}

uint64_t TSDLineIntersectsRect(CGFloat a1, CGFloat a2, double a3, double a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double v12;
  double v13;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  double v19;
  double v20;
  int v21;

  v12 = a4;
  v13 = a3;
  while (1)
  {
    v16 = p_ComputeOutcode(a1, a2, a5, a6, a7, a8);
    v17 = p_ComputeOutcode(v13, v12, a5, a6, a7, a8);
    result = 1;
    if (!v16 || !v17)
      break;
    if ((v17 & v16) != 0)
      return 0;
    v19 = (v13 + a1) * 0.5;
    v20 = (v12 + a2) * 0.5;
    v21 = TSDLineIntersectsRect(1, a1, a2, v19, v20, a5, a6, a7, a8);
    a1 = v19;
    a2 = v20;
    v13 = a3;
    v12 = a4;
    if (v21)
      return 1;
  }
  return result;
}

uint64_t p_ComputeOutcode(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  uint64_t v12;
  CGRect v14;
  CGRect v15;
  CGRect v16;
  CGRect v17;

  v14.origin.x = a3;
  v14.origin.y = a4;
  v14.size.width = a5;
  v14.size.height = a6;
  if (a2 <= CGRectGetMaxY(v14))
  {
    v15.origin.x = a3;
    v15.origin.y = a4;
    v15.size.width = a5;
    v15.size.height = a6;
    if (a2 < CGRectGetMinY(v15))
      v12 = 2;
    else
      v12 = 0;
  }
  else
  {
    v12 = 1;
  }
  v16.origin.x = a3;
  v16.origin.y = a4;
  v16.size.width = a5;
  v16.size.height = a6;
  if (a1 > CGRectGetMaxX(v16))
    return v12 | 4;
  v17.origin.x = a3;
  v17.origin.y = a4;
  v17.size.width = a5;
  v17.size.height = a6;
  if (a1 < CGRectGetMinX(v17))
    return v12 | 8;
  else
    return v12;
}

double TSDAveragePoints(double a1, double a2, double a3)
{
  return (a1 + a3) * 0.5;
}

BOOL TSDSizeIsEmpty(double a1, double a2)
{
  return a2 == 0.0 || a1 == 0.0;
}

double TSDSizeWithMaxArea(double result, double a2, double a3, double a4)
{
  if (result * a2 <= a3 * a4)
    return a3;
  return result;
}

double TSDUnionRect(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  _BOOL4 v8;

  v8 = a7 <= 0.0;
  if (a8 > 0.0)
    v8 = 0;
  if (a3 > 0.0 || a4 > 0.0)
  {
    if (v8)
    {
      return a1;
    }
    else if (a1 < a5)
    {
      return a1;
    }
  }
  else if (v8)
  {
    return *MEMORY[0x24BDBF090];
  }
  return a5;
}

double TSDHorizontalSpacingRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double MaxY;
  CGFloat v16;
  double MinY;
  double v18;
  double result;
  CGFloat v20;
  double MaxX;
  double v23;
  double MinX;
  double v25;
  CGRect v26;
  CGRect v27;
  CGRect v28;
  CGRect v29;
  CGRect v30;
  CGRect v31;
  CGRect v32;
  CGRect v33;

  MinX = CGRectGetMinX(*(CGRect *)&a1);
  v26.origin.x = a5;
  v26.origin.y = a6;
  v26.size.width = a7;
  v20 = a7;
  v26.size.height = a8;
  v25 = fmax(MinX, CGRectGetMinX(v26));
  v27.origin.x = a1;
  v27.origin.y = a2;
  v27.size.width = a3;
  v27.size.height = a4;
  MaxX = CGRectGetMaxX(v27);
  v28.origin.x = a5;
  v28.origin.y = a6;
  v28.size.width = a7;
  v28.size.height = a8;
  v23 = fmin(MaxX, CGRectGetMaxX(v28));
  v29.origin.x = a1;
  v29.origin.y = a2;
  v29.size.width = a3;
  v29.size.height = a4;
  MaxY = CGRectGetMaxY(v29);
  v30.origin.x = a5;
  v30.origin.y = a6;
  v30.size.width = v20;
  v30.size.height = a8;
  v16 = fmin(MaxY, CGRectGetMaxY(v30));
  v31.origin.x = a1;
  v31.origin.y = a2;
  v31.size.width = a3;
  v31.size.height = a4;
  MinY = CGRectGetMinY(v31);
  v32.origin.x = a5;
  v32.origin.y = a6;
  v32.size.width = v20;
  v32.size.height = a8;
  v18 = fmax(MinY, CGRectGetMinY(v32));
  v33.origin.x = v25;
  v33.size.width = v23 - v25;
  v33.size.height = v18 - v16;
  v33.origin.y = v16;
  *(_QWORD *)&result = (unint64_t)CGRectStandardize(v33);
  return result;
}

double TSDVerticalSpacingRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double MinY;
  CGFloat v16;
  double MaxY;
  double v18;
  double result;
  CGFloat v20;
  double MinX;
  double v23;
  double MaxX;
  double v25;
  CGRect v26;
  CGRect v27;
  CGRect v28;
  CGRect v29;
  CGRect v30;
  CGRect v31;
  CGRect v32;
  CGRect v33;

  MaxX = CGRectGetMaxX(*(CGRect *)&a1);
  v26.origin.x = a5;
  v26.origin.y = a6;
  v26.size.width = a7;
  v20 = a7;
  v26.size.height = a8;
  v25 = fmin(MaxX, CGRectGetMaxX(v26));
  v27.origin.x = a1;
  v27.origin.y = a2;
  v27.size.width = a3;
  v27.size.height = a4;
  MinX = CGRectGetMinX(v27);
  v28.origin.x = a5;
  v28.origin.y = a6;
  v28.size.width = a7;
  v28.size.height = a8;
  v23 = fmax(MinX, CGRectGetMinX(v28));
  v29.origin.x = a1;
  v29.origin.y = a2;
  v29.size.width = a3;
  v29.size.height = a4;
  MinY = CGRectGetMinY(v29);
  v30.origin.x = a5;
  v30.origin.y = a6;
  v30.size.width = v20;
  v30.size.height = a8;
  v16 = fmax(MinY, CGRectGetMinY(v30));
  v31.origin.x = a1;
  v31.origin.y = a2;
  v31.size.width = a3;
  v31.size.height = a4;
  MaxY = CGRectGetMaxY(v31);
  v32.origin.x = a5;
  v32.origin.y = a6;
  v32.size.width = v20;
  v32.size.height = a8;
  v18 = fmin(MaxY, CGRectGetMaxY(v32));
  v33.origin.x = v25;
  v33.size.width = v23 - v25;
  v33.size.height = v18 - v16;
  v33.origin.y = v16;
  *(_QWORD *)&result = (unint64_t)CGRectStandardize(v33);
  return result;
}

BOOL TSDIntersectsRect(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  _BOOL8 result;

  if (a1 < a5)
    result = a1 + a3 > a5;
  else
    result = a5 + a7 > a1;
  if (a2 >= a6)
  {
    if (a6 + a8 > a2)
      return result;
    return 0;
  }
  if (a2 + a4 <= a6)
    return 0;
  return result;
}

BOOL TSDPointInRectInclusive(double a1, double a2, double a3, double a4, double a5, double a6)
{
  double v6;

  v6 = a3 + a5;
  return a1 >= a3 && a1 <= v6 && a2 >= a4 && a2 <= a4 + a6;
}

double TSDAddPoints(double a1, double a2, double a3)
{
  return a1 + a3;
}

double TSDSubtractPoints(double a1, double a2, double a3)
{
  return a1 - a3;
}

double TSDAddSizes(double a1, double a2, double a3)
{
  return a1 + a3;
}

double TSDSubtractSizes(double a1, double a2, double a3)
{
  return a1 - a3;
}

double TSDMultiplyPointScalar(double a1, double a2, double a3)
{
  return a1 * a3;
}

double TSDMultiplyPointBySize(double a1, double a2, double a3)
{
  return a1 * a3;
}

double TSDMultiplyRectScalar(double a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5)
{
  double v9;
  CGRect v11;

  v9 = a1;
  if (!CGRectIsInfinite(*(CGRect *)&a1))
  {
    v11.origin.x = v9;
    v11.origin.y = a2;
    v11.size.width = a3;
    v11.size.height = a4;
    if (!CGRectIsNull(v11))
      return v9 * a5;
  }
  return v9;
}

double TSDMultiplyRectBySize(double a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5)
{
  double v9;
  CGRect v11;

  v9 = a1;
  if (!CGRectIsInfinite(*(CGRect *)&a1))
  {
    v11.origin.x = v9;
    v11.origin.y = a2;
    v11.size.width = a3;
    v11.size.height = a4;
    if (!CGRectIsNull(v11))
      return v9 * a5;
  }
  return v9;
}

double TSDFlooredPoint(double a1)
{
  return floor(a1);
}

double TSDFlooredSize(double a1)
{
  return floor(a1);
}

double TSDPointLength(double a1, double a2)
{
  return sqrt(a2 * a2 + a1 * a1);
}

double TSDPointSquaredLength(double a1, double a2)
{
  return a2 * a2 + a1 * a1;
}

double TSDDistance(double a1, double a2, double a3, double a4)
{
  return sqrt((a2 - a4) * (a2 - a4) + (a1 - a3) * (a1 - a3));
}

double TSDOrthogonalDistance(double a1, double a2, double a3, double a4)
{
  double v4;
  double v5;

  v4 = a1 - a3;
  if (v4 < 0.0)
    v4 = -v4;
  v5 = a2 - a4;
  if (v5 < 0.0)
    v5 = -v5;
  return v4 + v5;
}

void TSDDistanceToRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  double MaxX;
  double MinY;
  double MaxY;
  double v15;
  CGRect v16;
  CGRect v17;
  CGRect v18;
  CGRect v19;
  CGRect v20;
  CGRect v21;
  CGRect v22;
  CGRect v23;
  CGRect v24;
  CGRect v25;
  CGRect v26;
  CGRect v27;
  CGRect v28;
  CGRect v29;
  CGRect v30;

  v16.origin.x = a3;
  v16.origin.y = a4;
  v16.size.width = a5;
  v16.size.height = a6;
  if (a1 < CGRectGetMinX(v16))
  {
    v17.origin.x = a3;
    v17.origin.y = a4;
    v17.size.width = a5;
    v17.size.height = a6;
    if (a2 < CGRectGetMinY(v17))
    {
      v18.origin.x = a3;
      v18.origin.y = a4;
      v18.size.width = a5;
      v18.size.height = a6;
      CGRectGetMinX(v18);
LABEL_7:
      v22.origin.x = a3;
      v22.origin.y = a4;
      v22.size.width = a5;
      v22.size.height = a6;
      CGRectGetMinY(v22);
      return;
    }
    v23.origin.x = a3;
    v23.origin.y = a4;
    v23.size.width = a5;
    v23.size.height = a6;
    MaxY = CGRectGetMaxY(v23);
    v24.origin.x = a3;
    v24.origin.y = a4;
    v24.size.width = a5;
    v24.size.height = a6;
    CGRectGetMinX(v24);
    if (a2 <= MaxY)
      return;
LABEL_13:
    v28.origin.x = a3;
    v28.origin.y = a4;
    v28.size.width = a5;
    v28.size.height = a6;
    CGRectGetMaxY(v28);
    return;
  }
  v19.origin.x = a3;
  v19.origin.y = a4;
  v19.size.width = a5;
  v19.size.height = a6;
  MaxX = CGRectGetMaxX(v19);
  v20.origin.x = a3;
  v20.origin.y = a4;
  v20.size.width = a5;
  v20.size.height = a6;
  MinY = CGRectGetMinY(v20);
  if (a1 <= MaxX)
  {
    if (a2 >= MinY)
    {
      v29.origin.x = a3;
      v29.origin.y = a4;
      v29.size.width = a5;
      v29.size.height = a6;
      if (a2 > CGRectGetMaxY(v29))
      {
        v30.origin.x = a3;
        v30.origin.y = a4;
        v30.size.width = a5;
        v30.size.height = a6;
        CGRectGetMaxY(v30);
      }
    }
    else
    {
      v25.origin.x = a3;
      v25.origin.y = a4;
      v25.size.width = a5;
      v25.size.height = a6;
      CGRectGetMinY(v25);
    }
    return;
  }
  if (a2 < MinY)
  {
    v21.origin.x = a3;
    v21.origin.y = a4;
    v21.size.width = a5;
    v21.size.height = a6;
    CGRectGetMaxX(v21);
    goto LABEL_7;
  }
  v26.origin.x = a3;
  v26.origin.y = a4;
  v26.size.width = a5;
  v26.size.height = a6;
  v15 = CGRectGetMaxY(v26);
  v27.origin.x = a3;
  v27.origin.y = a4;
  v27.size.width = a5;
  v27.size.height = a6;
  CGRectGetMaxX(v27);
  if (a2 > v15)
    goto LABEL_13;
}

void TSDDistanceToRectFromRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double MaxX;
  double v16;
  double MaxY;
  double MinY;
  double v19;
  CGFloat v20;
  CGFloat v21;
  CGFloat v22;
  CGFloat v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double MinX;
  CGFloat v29;
  CGRect v31;
  CGRect v32;
  CGRect v33;
  CGRect v34;
  CGRect v35;
  CGRect v36;
  CGRect v37;
  CGRect v38;
  CGRect v39;
  CGRect v40;
  CGRect v41;
  CGRect v42;
  CGRect v43;
  CGRect v44;
  CGRect v45;
  CGRect v46;
  CGRect v47;
  CGRect v48;
  CGRect v49;
  CGRect v50;
  CGRect v51;
  CGRect v52;
  CGRect v53;
  CGRect v54;
  CGRect v55;
  CGRect v56;
  CGRect v57;
  CGRect v58;
  CGRect v59;
  CGRect v60;
  CGRect v61;
  CGRect v62;
  CGRect v63;

  MaxX = CGRectGetMaxX(*(CGRect *)&a1);
  v31.origin.x = a5;
  v31.origin.y = a6;
  v31.size.width = a7;
  v31.size.height = a8;
  if (MaxX >= CGRectGetMinX(v31))
  {
    v38.origin.x = a1;
    v38.origin.y = a2;
    v38.size.width = a3;
    v38.size.height = a4;
    MinX = CGRectGetMinX(v38);
    v39.origin.x = a5;
    v39.origin.y = a6;
    v39.size.width = a7;
    v39.size.height = a8;
    v26 = CGRectGetMaxX(v39);
    v40.origin.x = a1;
    v40.origin.y = a2;
    v40.size.width = a3;
    v40.size.height = a4;
    MaxY = CGRectGetMaxY(v40);
    v29 = a6;
    v41.origin.x = a5;
    v41.origin.y = a6;
    v41.size.width = a7;
    v41.size.height = a8;
    MinY = CGRectGetMinY(v41);
    if (MinX <= v26)
    {
      if (MaxY >= MinY)
      {
        v61.origin.x = a1;
        v61.origin.y = a2;
        v61.size.width = a3;
        v61.size.height = a4;
        v25 = CGRectGetMinY(v61);
        v62.origin.x = a5;
        v62.origin.y = a6;
        v62.size.width = a7;
        v62.size.height = a8;
        if (v25 <= CGRectGetMaxY(v62))
          return;
        v63.origin.x = a1;
        v63.origin.y = a2;
        v63.size.width = a3;
        v63.size.height = a4;
        CGRectGetMinY(v63);
        v20 = a5;
        v21 = a6;
        v22 = a7;
        v23 = a8;
      }
      else
      {
        v52.origin.x = a5;
        v52.origin.y = a6;
        v52.size.width = a7;
        v52.size.height = a8;
        CGRectGetMinY(v52);
        v20 = a1;
        v21 = a2;
        v22 = a3;
        v23 = a4;
      }
      CGRectGetMaxY(*(CGRect *)&v20);
    }
    else if (MaxY >= MinY)
    {
      v53.origin.x = a1;
      v53.origin.y = a2;
      v53.size.width = a3;
      v53.size.height = a4;
      v27 = CGRectGetMinY(v53);
      v54.origin.x = a5;
      v54.origin.y = a6;
      v54.size.width = a7;
      v54.size.height = a8;
      v24 = CGRectGetMaxY(v54);
      v55.origin.x = a1;
      v55.origin.y = a2;
      v55.size.width = a3;
      v55.size.height = a4;
      CGRectGetMinX(v55);
      if (v27 > v24)
      {
        v56.origin.x = a1;
        v56.origin.y = a2;
        v56.size.width = a3;
        v56.size.height = a4;
        CGRectGetMinY(v56);
        v57.origin.x = a5;
        v57.origin.y = v29;
        v57.size.width = a7;
        v57.size.height = a8;
        CGRectGetMaxX(v57);
      }
      v58.origin.x = a5;
      v58.origin.y = v29;
      v58.size.width = a7;
      v58.size.height = a8;
      CGRectGetMaxY(v58);
    }
    else
    {
      v42.origin.x = a1;
      v42.origin.y = a2;
      v42.size.width = a3;
      v42.size.height = a4;
      CGRectGetMinX(v42);
      v43.origin.x = a1;
      v43.origin.y = a2;
      v43.size.width = a3;
      v43.size.height = a4;
      CGRectGetMaxY(v43);
      v44.origin.x = a5;
      v44.origin.y = a6;
      v44.size.width = a7;
      v44.size.height = a8;
      CGRectGetMaxX(v44);
      v45.origin.x = a5;
      v45.origin.y = a6;
      v45.size.width = a7;
      v45.size.height = a8;
      CGRectGetMinY(v45);
    }
  }
  else
  {
    v32.origin.x = a1;
    v32.origin.y = a2;
    v32.size.width = a3;
    v32.size.height = a4;
    v16 = CGRectGetMaxY(v32);
    v33.origin.x = a5;
    v33.origin.y = a6;
    v33.size.width = a7;
    v33.size.height = a8;
    if (v16 >= CGRectGetMinY(v33))
    {
      v46.origin.x = a1;
      v46.origin.y = a2;
      v46.size.width = a3;
      v46.size.height = a4;
      v19 = CGRectGetMinY(v46);
      v47.origin.x = a5;
      v47.origin.y = a6;
      v47.size.width = a7;
      v47.size.height = a8;
      if (v19 <= CGRectGetMaxY(v47))
      {
        v59.origin.x = a5;
        v59.origin.y = a6;
        v59.size.width = a7;
        v59.size.height = a8;
        CGRectGetMinX(v59);
        v60.origin.x = a1;
        v60.origin.y = a2;
        v60.size.width = a3;
        v60.size.height = a4;
        CGRectGetMaxX(v60);
      }
      else
      {
        v48.origin.x = a1;
        v48.origin.y = a2;
        v48.size.width = a3;
        v48.size.height = a4;
        CGRectGetMaxX(v48);
        v49.origin.x = a1;
        v49.origin.y = a2;
        v49.size.width = a3;
        v49.size.height = a4;
        CGRectGetMinY(v49);
        v50.origin.x = a5;
        v50.origin.y = a6;
        v50.size.width = a7;
        v50.size.height = a8;
        CGRectGetMinX(v50);
        v51.origin.x = a5;
        v51.origin.y = a6;
        v51.size.width = a7;
        v51.size.height = a8;
        CGRectGetMaxY(v51);
      }
    }
    else
    {
      v34.origin.x = a1;
      v34.origin.y = a2;
      v34.size.width = a3;
      v34.size.height = a4;
      CGRectGetMaxX(v34);
      v35.origin.x = a1;
      v35.origin.y = a2;
      v35.size.width = a3;
      v35.size.height = a4;
      CGRectGetMaxY(v35);
      v36.origin.x = a5;
      v36.origin.y = a6;
      v36.size.width = a7;
      v36.size.height = a8;
      CGRectGetMinX(v36);
      v37.origin.x = a5;
      v37.origin.y = a6;
      v37.size.width = a7;
      v37.size.height = a8;
      CGRectGetMinY(v37);
    }
  }
}

double TSDCenterOfRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  double MidX;
  CGRect v10;

  MidX = CGRectGetMidX(*(CGRect *)&a1);
  v10.origin.x = a1;
  v10.origin.y = a2;
  v10.size.width = a3;
  v10.size.height = a4;
  CGRectGetMidY(v10);
  return MidX;
}

double TSDRectGetMaxPoint(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  double MaxX;
  CGRect v10;

  MaxX = CGRectGetMaxX(*(CGRect *)&a1);
  v10.origin.x = a1;
  v10.origin.y = a2;
  v10.size.width = a3;
  v10.size.height = a4;
  CGRectGetMaxY(v10);
  return MaxX;
}

double TSDComplexMultiplyPoint(double a1, double a2, double a3, double a4)
{
  return a1 * a3 - a2 * a4;
}

double TSDNormalizePoint(double a1, double a2)
{
  return a1 * (1.0 / sqrt(a2 * a2 + a1 * a1));
}

double TSDDotPoints(double a1, double a2, double a3, double a4)
{
  return a2 * a4 + a1 * a3;
}

double TSDCrossPoints(double a1, double a2, double a3, double a4)
{
  return a2 * a3 - a1 * a4;
}

double TSDGrowRectToPoint(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  double MinX;
  CGRect v14;
  CGRect v15;
  CGRect v16;
  CGRect v17;
  CGRect v18;
  CGRect v19;
  CGRect v20;
  CGRect v21;

  if (CGRectIsNull(*(CGRect *)&a1))
    return a5;
  v14.origin.x = a1;
  v14.origin.y = a2;
  v14.size.width = a3;
  v14.size.height = a4;
  MinX = a5;
  if (CGRectGetMinX(v14) < a5)
  {
    v15.origin.x = a1;
    v15.origin.y = a2;
    v15.size.width = a3;
    v15.size.height = a4;
    MinX = CGRectGetMinX(v15);
  }
  v16.origin.x = a1;
  v16.origin.y = a2;
  v16.size.width = a3;
  v16.size.height = a4;
  if (CGRectGetMaxX(v16) > a5)
  {
    v17.origin.x = a1;
    v17.origin.y = a2;
    v17.size.width = a3;
    v17.size.height = a4;
    CGRectGetMaxX(v17);
  }
  v18.origin.x = a1;
  v18.origin.y = a2;
  v18.size.width = a3;
  v18.size.height = a4;
  if (CGRectGetMinY(v18) < a6)
  {
    v19.origin.x = a1;
    v19.origin.y = a2;
    v19.size.width = a3;
    v19.size.height = a4;
    CGRectGetMinY(v19);
  }
  v20.origin.x = a1;
  v20.origin.y = a2;
  v20.size.width = a3;
  v20.size.height = a4;
  if (CGRectGetMaxY(v20) > a6)
  {
    v21.origin.x = a1;
    v21.origin.y = a2;
    v21.size.width = a3;
    v21.size.height = a4;
    CGRectGetMaxY(v21);
  }
  return MinX;
}

double TSDFlipRect(double a1, double a2, double a3, double a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  CGRect v14;

  CGRectGetMidY(*(CGRect *)&a1);
  v14.origin.x = a5;
  v14.origin.y = a6;
  v14.size.width = a7;
  v14.size.height = a8;
  CGRectGetMidY(v14);
  return a1;
}

double TSDCenterRectOverRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double MidY;
  double v17;
  CGFloat v18;
  double result;
  double MidX;
  CGRect v21;
  CGRect v22;
  CGRect v23;
  CGRect v24;
  CGRect v25;

  v21.origin.x = a5;
  v21.origin.y = a6;
  v21.size.width = a7;
  v21.size.height = a8;
  MidX = CGRectGetMidX(v21);
  v22.origin.x = a5;
  v22.origin.y = a6;
  v22.size.width = a7;
  v22.size.height = a8;
  MidY = CGRectGetMidY(v22);
  v23.origin.x = a1;
  v23.origin.y = a2;
  v23.size.width = a3;
  v23.size.height = a4;
  v17 = CGRectGetMidX(v23);
  v24.origin.x = a1;
  v24.origin.y = a2;
  v24.size.width = a3;
  v24.size.height = a4;
  v18 = MidY - CGRectGetMidY(v24);
  v25.origin.x = a1;
  v25.origin.y = a2;
  v25.size.width = a3;
  v25.size.height = a4;
  *(_QWORD *)&result = (unint64_t)CGRectOffset(v25, MidX - v17, v18);
  return result;
}

BOOL TSDRectIsFinite(double a1, double a2, double a3, double a4)
{
  _BOOL8 result;
  double v5;

  result = 0;
  if (fabs(a1) != INFINITY && fabs(a2) != INFINITY && fabs(a3) != INFINITY)
  {
    v5 = fabs(a4);
    return v5 > INFINITY || v5 < INFINITY;
  }
  return result;
}

void TSDRectDivide(CGRect *a1, CGRect *a2, CGRectEdge a3, double a4, double a5, double a6, double a7, CGFloat a8)
{
  _OWORD v8[2];

  memset(v8, 0, sizeof(v8));
  if (!a1)
    a1 = (CGRect *)v8;
  if (!a2)
    a2 = (CGRect *)v8;
  CGRectDivide(*(CGRect *)&a4, a1, a2, a8, a3);
}

uint64_t TSDGetCanvasSpaceCorners(uint64_t a1, _OWORD *a2, _OWORD *a3, _OWORD *a4, _OWORD *a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9)
{
  __int128 v18;
  double MidX;
  CGFloat MidY;
  uint64_t v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  double *v26;
  long double v27;
  double v28;
  double v29;
  double v30;
  uint64_t v31;
  __int128 v32;
  _BOOL4 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  float64x2_t v46;
  __int128 v47;
  __int128 v48;
  double v49;
  uint64_t v50;
  double v51;
  double v52;
  double v53[3];
  CGRect v54;
  CGRect v55;

  v53[2] = *(double *)MEMORY[0x24BDAC8D0];
  v18 = *(_OWORD *)(a1 + 16);
  v46 = *(float64x2_t *)a1;
  v47 = v18;
  v48 = *(_OWORD *)(a1 + 32);
  TSDTransformedCornersOfRect(&v46, &v49, &v51, &v52, v53, a6, a7, a8, a9);
  v54.origin.x = a6;
  v54.origin.y = a7;
  v54.size.width = a8;
  v54.size.height = a9;
  MidX = CGRectGetMidX(v54);
  v55.origin.x = a6;
  v55.origin.y = a7;
  v55.size.width = a8;
  v55.size.height = a9;
  MidY = CGRectGetMidY(v55);
  v21 = 0;
  v22 = 0;
  v23 = *(double *)(a1 + 32) + MidY * *(double *)(a1 + 16) + *(double *)a1 * MidX;
  v24 = 1000000.0;
  v25 = *(double *)(a1 + 40) + MidY * *(double *)(a1 + 24) + *(double *)(a1 + 8) * MidX;
  v26 = (double *)&v50;
  do
  {
    v27 = atan2(*v26 - v25, *(v26 - 1) - v23);
    v28 = fmod(v27 * 57.2957795, 360.0);
    if (v28 < 0.0)
      v28 = v28 + 360.0;
    if (v28 == 0.0)
      v29 = 225.0;
    else
      v29 = 360.0 - v28 + -135.0;
    v30 = fabs(v29);
    if (v30 < v24)
    {
      v21 = v22;
      v24 = v30;
    }
    ++v22;
    v26 += 2;
  }
  while (v22 != 4);
  *a2 = *((_OWORD *)&v49 + v21);
  v31 = (v21 + 2) & 3;
  if (v21 + 2 <= 0)
    v31 = -(-(v21 + 2) & 3);
  *a4 = *((_OWORD *)&v49 + v31);
  v32 = *(_OWORD *)(a1 + 16);
  v46 = *(float64x2_t *)a1;
  v47 = v32;
  v48 = *(_OWORD *)(a1 + 32);
  v33 = TSDIsTransformFlipped(v46.f64);
  v34 = v21 + 3;
  if (v33)
    v35 = v21 + 1;
  else
    v35 = v21 + 3;
  v36 = v35 & 3;
  if (!v33)
    v34 = v21 + 1;
  v38 = -v35;
  v37 = v38 < 0;
  v39 = v38 & 3;
  if (v37)
    v40 = v36;
  else
    v40 = -v39;
  *a5 = *((_OWORD *)&v49 + v40);
  v41 = v34 & 3;
  v42 = -v34;
  v37 = v42 < 0;
  v43 = v42 & 3;
  if (v37)
    v44 = v41;
  else
    v44 = -v43;
  *a3 = *((_OWORD *)&v49 + v44);
  return v21;
}

double TSDAngleFromDelta(long double a1, long double a2)
{
  return atan2(a2, a1);
}

void TSDNormalizeAngleInDegrees(long double a1)
{
  fmod(a1, 360.0);
}

double TSDInterpolatePoints(double a1, double a2, double a3, double a4, double a5)
{
  return a3 * a5 + a1 * (1.0 - a5);
}

double TSDMixPoints(double a1, double a2, double a3, double a4, double a5)
{
  return a3 * a5 + a1 * (1.0 - a5);
}

double TSDInterpolateFloats(double a1, double a2, double a3)
{
  return a2 * a3 + a1 * (1.0 - a3);
}

double TSDMixFloats(double a1, double a2, double a3)
{
  return a2 * a3 + a1 * (1.0 - a3);
}

void TSDMixAnglesInDegrees(long double a1, long double a2, double a3)
{
  double v5;
  double v6;
  double v7;

  v5 = fmod(a1, 360.0);
  if (v5 < 0.0)
    v5 = v5 + 360.0;
  if (v5 == 0.0)
    v6 = 0.0;
  else
    v6 = v5;
  v7 = fmod(a2, 360.0);
  if (v7 < 0.0)
    v7 = v7 + 360.0;
  if (v7 == 0.0)
    v7 = 0.0;
  if (vabdd_f64(v7, v6) > 180.0)
  {
    if (v6 <= v7)
      v7 = v7 + -360.0;
    else
      v7 = v7 + 360.0;
  }
  fmod(v7 * a3 + v6 * (1.0 - a3), 360.0);
}

double TSDMixAnglesInRadians(double a1, double a2, double a3)
{
  double v3;

  TSDMixAnglesInDegrees(a1 * 57.2957795, a2 * 57.2957795, a3);
  return v3 * 0.0174532925;
}

double TSDMixSizes(double a1, double a2, double a3, double a4, double a5)
{
  return a3 * a5 + a1 * (1.0 - a5);
}

double TSDMixRects(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  return a5 * a9 + a1 * (1.0 - a9);
}

double TSDClampPointInRect()
{
  double v0;
  double v1;

  TSUClamp();
  v1 = v0;
  TSUClamp();
  return v1;
}

double TSDTranslatedRectMaximizingOverlapWithRect(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  double MaxX;
  double MinX;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double MaxY;
  double MinY;
  double v28;
  double v29;
  double v30;
  double v31;
  BOOL v32;
  CGFloat v33;
  CGFloat v34;
  CGFloat v35;
  CGFloat v36;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  CGFloat v46;
  double v47;
  CGRect v50;
  CGRect v51;
  CGRect v52;
  CGRect v53;
  CGRect v54;
  CGRect v55;
  CGRect v56;
  CGRect v57;
  CGRect v58;
  CGRect v59;
  CGRect v60;
  CGRect v61;
  CGRect v62;
  CGRect v63;
  CGRect v64;
  CGRect v65;
  CGRect v66;
  CGRect v67;
  CGRect v68;
  CGRect v69;
  CGRect v70;
  CGRect v71;
  CGRect v72;
  CGRect v73;
  CGRect v74;
  CGRect v75;
  CGRect v76;
  CGRect v77;
  CGRect v78;
  CGRect v79;
  CGRect v80;
  CGRect v81;
  CGRect v82;
  CGRect v83;
  CGRect v84;
  CGRect v85;
  CGRect v86;
  CGRect v87;
  CGRect v88;
  CGRect v89;
  CGRect v90;
  CGRect v91;
  CGRect v92;
  CGRect v93;
  CGRect v94;
  CGRect v95;

  v50.origin.x = a5;
  v50.origin.y = a6;
  v50.size.width = a7;
  v50.size.height = a8;
  MaxX = CGRectGetMaxX(v50);
  v47 = a1;
  v51.origin.x = a1;
  v51.origin.y = a2;
  v51.size.width = a3;
  v51.size.height = a4;
  v46 = a1;
  if (MaxX > CGRectGetMaxX(v51))
  {
    v52.origin.x = a5;
    v52.origin.y = a6;
    v52.size.width = a7;
    v52.size.height = a8;
    MinX = CGRectGetMinX(v52);
    v53.origin.x = a1;
    v53.origin.y = a2;
    v53.size.width = a3;
    v53.size.height = a4;
    if (MinX > CGRectGetMinX(v53))
    {
      v54.origin.x = a5;
      v54.origin.y = a6;
      v54.size.width = a7;
      v54.size.height = a8;
      v38 = CGRectGetMaxX(v54);
      v55.origin.x = a1;
      v55.origin.y = a2;
      v55.size.width = a3;
      v55.size.height = a4;
      v39 = v38 - CGRectGetMaxX(v55);
      v56.origin.x = a5;
      v56.origin.y = a6;
      v56.size.width = a7;
      v56.size.height = a8;
      v17 = CGRectGetMinX(v56);
      v57.origin.x = a1;
      v57.origin.y = a2;
      v57.size.width = a3;
      v57.size.height = a4;
      if (v39 >= v17 - CGRectGetMinX(v57))
      {
        v70.origin.x = a5;
        v70.origin.y = a6;
        v70.size.width = a7;
        v70.size.height = a8;
        v18 = CGRectGetMinX(v70);
        v71.origin.x = a1;
        v71.origin.y = a2;
        v71.size.width = a3;
        v71.size.height = a4;
        v19 = CGRectGetMinX(v71);
      }
      else
      {
        v58.origin.x = a5;
        v58.origin.y = a6;
        v58.size.width = a7;
        v58.size.height = a8;
        v18 = CGRectGetMaxX(v58);
        v59.origin.x = a1;
        v59.origin.y = a2;
        v59.size.width = a3;
        v59.size.height = a4;
        v19 = CGRectGetMaxX(v59);
      }
      v25 = v47 + v18 - v19;
LABEL_13:
      v47 = v25;
      goto LABEL_14;
    }
  }
  v60.origin.x = a5;
  v60.origin.y = a6;
  v60.size.width = a7;
  v60.size.height = a8;
  v20 = CGRectGetMinX(v60);
  v61.origin.x = a1;
  v61.origin.y = a2;
  v61.size.width = a3;
  v61.size.height = a4;
  if (v20 < CGRectGetMinX(v61))
  {
    v62.origin.x = a5;
    v62.origin.y = a6;
    v62.size.width = a7;
    v62.size.height = a8;
    v21 = CGRectGetMaxX(v62);
    v63.origin.x = a1;
    v63.origin.y = a2;
    v63.size.width = a3;
    v63.size.height = a4;
    if (v21 < CGRectGetMaxX(v63))
    {
      v64.origin.x = a1;
      v64.origin.y = a2;
      v64.size.width = a3;
      v64.size.height = a4;
      v40 = CGRectGetMinX(v64);
      v65.origin.x = a5;
      v65.origin.y = a6;
      v65.size.width = a7;
      v65.size.height = a8;
      v41 = v40 - CGRectGetMinX(v65);
      v66.origin.x = a1;
      v66.origin.y = a2;
      v66.size.width = a3;
      v66.size.height = a4;
      v22 = CGRectGetMaxX(v66);
      v67.origin.x = a5;
      v67.origin.y = a6;
      v67.size.width = a7;
      v67.size.height = a8;
      if (v41 >= v22 - CGRectGetMaxX(v67))
      {
        v72.origin.x = a1;
        v72.origin.y = a2;
        v72.size.width = a3;
        v72.size.height = a4;
        v23 = CGRectGetMaxX(v72);
        v73.origin.x = a5;
        v73.origin.y = a6;
        v73.size.width = a7;
        v73.size.height = a8;
        v24 = CGRectGetMaxX(v73);
      }
      else
      {
        v68.origin.x = a1;
        v68.origin.y = a2;
        v68.size.width = a3;
        v68.size.height = a4;
        v23 = CGRectGetMinX(v68);
        v69.origin.x = a5;
        v69.origin.y = a6;
        v69.size.width = a7;
        v69.size.height = a8;
        v24 = CGRectGetMinX(v69);
      }
      v25 = v47 - (v23 - v24);
      goto LABEL_13;
    }
  }
LABEL_14:
  v74.origin.x = a5;
  v74.origin.y = a6;
  v74.size.width = a7;
  v74.size.height = a8;
  MaxY = CGRectGetMaxY(v74);
  v75.origin.x = a1;
  v75.origin.y = a2;
  v75.size.width = a3;
  v75.size.height = a4;
  if (MaxY <= CGRectGetMaxY(v75))
    goto LABEL_18;
  v76.origin.x = a5;
  v76.origin.y = a6;
  v76.size.width = a7;
  v76.size.height = a8;
  MinY = CGRectGetMinY(v76);
  v77.origin.x = a1;
  v77.origin.y = a2;
  v77.size.width = a3;
  v77.size.height = a4;
  if (MinY <= CGRectGetMinY(v77))
  {
LABEL_18:
    v84.origin.x = a5;
    v84.origin.y = a6;
    v84.size.width = a7;
    v84.size.height = a8;
    v29 = CGRectGetMinY(v84);
    v85.origin.x = a1;
    v85.origin.y = a2;
    v85.size.width = a3;
    v85.size.height = a4;
    if (v29 < CGRectGetMinY(v85))
    {
      v86.origin.x = a5;
      v86.origin.y = a6;
      v86.size.width = a7;
      v86.size.height = a8;
      v30 = CGRectGetMaxY(v86);
      v87.origin.x = a1;
      v87.origin.y = a2;
      v87.size.width = a3;
      v87.size.height = a4;
      if (v30 < CGRectGetMaxY(v87))
      {
        v88.origin.x = a1;
        v88.origin.y = a2;
        v88.size.width = a3;
        v88.size.height = a4;
        v44 = CGRectGetMinY(v88);
        v89.origin.x = a5;
        v89.origin.y = a6;
        v89.size.width = a7;
        v89.size.height = a8;
        v45 = v44 - CGRectGetMinY(v89);
        v90.origin.x = a1;
        v90.origin.y = a2;
        v90.size.width = a3;
        v90.size.height = a4;
        v31 = CGRectGetMaxY(v90);
        v91.origin.x = a5;
        v91.origin.y = a6;
        v91.size.width = a7;
        v91.size.height = a8;
        v32 = v45 < v31 - CGRectGetMaxY(v91);
        v33 = v46;
        v34 = a2;
        v35 = a3;
        v36 = a4;
        if (v32)
        {
          CGRectGetMinY(*(CGRect *)&v33);
          v92.origin.x = a5;
          v92.origin.y = a6;
          v92.size.width = a7;
          v92.size.height = a8;
          CGRectGetMinY(v92);
        }
        else
        {
          CGRectGetMaxY(*(CGRect *)&v33);
          v95.origin.x = a5;
          v95.origin.y = a6;
          v95.size.width = a7;
          v95.size.height = a8;
          CGRectGetMaxY(v95);
        }
      }
    }
  }
  else
  {
    v78.origin.x = a5;
    v78.origin.y = a6;
    v78.size.width = a7;
    v78.size.height = a8;
    v42 = CGRectGetMaxY(v78);
    v79.origin.x = a1;
    v79.origin.y = a2;
    v79.size.width = a3;
    v79.size.height = a4;
    v43 = v42 - CGRectGetMaxY(v79);
    v80.origin.x = a5;
    v80.origin.y = a6;
    v80.size.width = a7;
    v80.size.height = a8;
    v28 = CGRectGetMinY(v80);
    v81.origin.x = v46;
    v81.origin.y = a2;
    v81.size.width = a3;
    v81.size.height = a4;
    if (v43 >= v28 - CGRectGetMinY(v81))
    {
      v93.origin.x = a5;
      v93.origin.y = a6;
      v93.size.width = a7;
      v93.size.height = a8;
      CGRectGetMinY(v93);
      v94.origin.x = v46;
      v94.origin.y = a2;
      v94.size.width = a3;
      v94.size.height = a4;
      CGRectGetMinY(v94);
    }
    else
    {
      v82.origin.x = a5;
      v82.origin.y = a6;
      v82.size.width = a7;
      v82.size.height = a8;
      CGRectGetMaxY(v82);
      v83.origin.x = v46;
      v83.origin.y = a2;
      v83.size.width = a3;
      v83.size.height = a4;
      CGRectGetMaxY(v83);
    }
  }
  return v47;
}

double TSDOriginRotate(double *a1, double a2, double a3)
{
  __double2 v5;
  double result;

  v5 = __sincos_stret(a3);
  result = v5.__sinval * a2;
  *a1 = v5.__cosval * a2;
  a1[1] = v5.__sinval * a2;
  return result;
}

double TSDNiceAngleFromDelta(long double a1, long double a2)
{
  double result;

  if (a2 != 0.0)
    return atan2(a2, a1);
  result = 3.14159265;
  if (a1 >= 0.0)
    return 0.0;
  return result;
}

double TSDDeltaFromAngle(double a1)
{
  if (a1 == 0.0)
    return 1.0;
  return __sincos_stret(a1).__cosval;
}

double TSDShiftConstrainDelta(long double a1, long double a2)
{
  long double v4;

  v4 = atan2(a2, a1);
  return sqrt(a2 * a2 + a1 * a1)
       * __sincos_stret((double)(int)((v4 + 6.28318531) / 0.785398163 + 0.5) * 0.785398163).__cosval;
}

double TSDShiftConstrainDeltaToAngle(double a1, double a2, double a3)
{
  return __sincos_stret(a3).__cosval * sqrt(a2 * a2 + a1 * a1);
}

double TSDRotatePoint90Degrees(int a1, double a2, double a3)
{
  if (a1)
    return -a3;
  else
    return a3;
}

void TSDNormalizeAngleInRadians(long double a1)
{
  fmod(a1, 6.28318531);
}

void TSDNormalizeAngleAboutZeroInRadians(double a1)
{
  fmod(a1 + 3.14159265, 6.28318531);
}

double TSDDeltaApplyAffineTransform(float64x2_t *a1, double a2, double a3)
{
  double result;

  *(_QWORD *)&result = *(_OWORD *)&vsubq_f64(vaddq_f64(a1[2], vmlaq_n_f64(vmulq_n_f64(a1[1], a3), *a1, a2)), vaddq_f64(a1[2], vmlaq_n_f64(vmulq_n_f64(a1[1], *(double *)(MEMORY[0x24BDBEFB0] + 8)), *a1, *MEMORY[0x24BDBEFB0])));
  return result;
}

void TSDDistanceBetweenAnglesInRadians(long double a1, long double a2)
{
  fmod(a1, 6.28318531);
  fmod(a2, 6.28318531);
}

double TSDNormalizedPointInRect(double a1, double a2, double a3, double a4, double a5)
{
  return (a1 - a3) / a5;
}

double TSDPointFromNormalizedRect(double a1, double a2, double a3, double a4, double a5)
{
  return a3 + a1 * a5;
}

void TSDRectFromNormalizedSubrect(double a1, double a2, double a3, double a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  CGRect v12;
  CGRect v13;

  v12.origin.x = a5;
  v12.origin.y = a6;
  v12.size.width = a7;
  v12.size.height = a8;
  CGRectGetMaxX(v12);
  v13.origin.x = a5;
  v13.origin.y = a6;
  v13.size.width = a7;
  v13.size.height = a8;
  CGRectGetMaxY(v13);
}

double TSDRectSubtractingRect(double a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, double a6, double a7, double a8)
{
  double v11;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  CGRectEdge v21;
  double MaxX;
  double v23;
  double v24;
  double v25;
  double MinX;
  double v27;
  CGFloat v28;
  double v29;
  double v30;
  double MinY;
  double v33;
  double MaxY;
  double v35;
  CGFloat v36;
  double v37;
  double v38;
  CGFloat v39;
  CGRect slice;
  CGRect remainder;
  CGRect v42;
  CGRect v43;
  CGRect v44;
  CGRect v45;
  CGRect v46;
  CGRect v47;
  CGRect v48;
  CGRect v49;
  CGRect v50;
  CGRect v51;
  CGRect v52;
  CGRect v53;
  CGRect v54;
  CGRect v55;
  CGRect v56;
  CGRect v57;
  CGRect v58;
  CGRect v59;
  CGRect v60;
  CGRect v61;
  CGRect v62;
  CGRect v63;

  v11 = a1;
  v42 = CGRectIntersection(*(CGRect *)&a1, *(CGRect *)&a5);
  x = v42.origin.x;
  y = v42.origin.y;
  width = v42.size.width;
  height = v42.size.height;
  if (!CGRectIsNull(v42))
  {
    v43.origin.x = x;
    v43.origin.y = y;
    v43.size.width = width;
    v43.size.height = height;
    MaxY = CGRectGetMaxY(v43);
    v44.origin.x = v11;
    v44.origin.y = a2;
    v44.size.width = a3;
    v44.size.height = a4;
    MinY = CGRectGetMinY(v44);
    v45.origin.x = v11;
    v45.origin.y = a2;
    v45.size.width = a3;
    v45.size.height = a4;
    v37 = CGRectGetMaxY(v45);
    v46.origin.x = x;
    v46.origin.y = y;
    v46.size.width = width;
    v46.size.height = height;
    v38 = v37 - CGRectGetMaxY(v46);
    v47.origin.x = v11;
    v47.origin.y = a2;
    v47.size.width = a3;
    v47.size.height = a4;
    v33 = v38 * CGRectGetWidth(v47);
    v36 = height;
    v39 = x;
    v48.origin.x = x;
    v48.origin.y = y;
    v48.size.width = width;
    v48.size.height = height;
    v16 = CGRectGetMinY(v48);
    v49.origin.x = v11;
    v49.origin.y = a2;
    v49.size.width = a3;
    v49.size.height = a4;
    v17 = v16 - CGRectGetMinY(v49);
    v50.origin.x = v11;
    v50.origin.y = a2;
    v50.size.width = a3;
    v50.size.height = a4;
    v18 = v17 * CGRectGetWidth(v50);
    v19 = v33;
    if (v18 <= v33)
    {
      v35 = MaxY - MinY;
      v21 = CGRectMinYEdge;
    }
    else
    {
      v51.origin.x = v11;
      v51.origin.y = a2;
      v51.size.width = a3;
      v51.size.height = a4;
      v20 = CGRectGetMaxY(v51);
      v52.size.height = v36;
      v52.origin.x = v39;
      v52.origin.y = y;
      v52.size.width = width;
      v35 = v20 - CGRectGetMinY(v52);
      v21 = CGRectMaxYEdge;
      v19 = v18;
    }
    v53.origin.x = v11;
    v53.origin.y = a2;
    v53.size.width = a3;
    v53.size.height = a4;
    MaxX = CGRectGetMaxX(v53);
    v54.size.height = v36;
    v54.origin.x = v39;
    v54.origin.y = y;
    v54.size.width = width;
    v23 = MaxX - CGRectGetMaxX(v54);
    v55.origin.x = v11;
    v55.origin.y = a2;
    v55.size.width = a3;
    v55.size.height = a4;
    v24 = v23 * CGRectGetHeight(v55);
    if (v24 > v19)
    {
      v56.size.height = v36;
      v56.origin.x = v39;
      v56.origin.y = y;
      v56.size.width = width;
      v25 = CGRectGetMaxX(v56);
      v57.origin.x = v11;
      v57.origin.y = a2;
      v57.size.width = a3;
      v57.size.height = a4;
      v21 = CGRectMinXEdge;
      v35 = v25 - CGRectGetMinX(v57);
      v19 = v24;
    }
    v58.size.height = v36;
    v58.origin.x = v39;
    v58.origin.y = y;
    v58.size.width = width;
    MinX = CGRectGetMinX(v58);
    v59.origin.x = v11;
    v59.origin.y = a2;
    v59.size.width = a3;
    v59.size.height = a4;
    v27 = MinX - CGRectGetMinX(v59);
    v60.origin.x = v11;
    v60.origin.y = a2;
    v60.size.width = a3;
    v60.size.height = a4;
    v28 = CGRectGetHeight(v60);
    v29 = v35;
    if (v27 * v28 > v19)
    {
      v61.origin.x = v11;
      v61.origin.y = a2;
      v61.size.width = a3;
      v61.size.height = a4;
      v30 = CGRectGetMaxX(v61);
      v62.size.height = v36;
      v62.origin.x = v39;
      v62.origin.y = y;
      v62.size.width = width;
      v29 = v30 - CGRectGetMinX(v62);
      v21 = CGRectMaxXEdge;
    }
    memset(&remainder, 0, sizeof(remainder));
    memset(&slice, 0, sizeof(slice));
    v63.origin.x = v11;
    v63.origin.y = a2;
    v63.size.width = a3;
    v63.size.height = a4;
    CGRectDivide(v63, &slice, &remainder, v29, v21);
    return remainder.origin.x;
  }
  return v11;
}

double TSDSizeWithAspectRatio(int a1, double result, double a3, double a4, double a5)
{
  BOOL v5;
  double v6;

  v5 = result == a4 && a3 == a5;
  if (!v5 && a4 != 0.0 && a5 != 0.0 && a4 != 3.40282347e38 && a5 != 3.40282347e38)
  {
    if (a1)
    {
      v6 = sqrt(a5 * a5 + a4 * a4);
      return a4 / v6 * (a3 * (a5 / v6) + result * (a4 / v6));
    }
    else if (vabdd_f64(result, a4) < 0.01)
    {
      return a3 * a4 / a5;
    }
  }
  return result;
}

double TSDSizeExpandedToMatchAspectRatio(double a1, double a2, double a3, double a4)
{
  _BOOL4 v4;
  BOOL v5;
  double v6;
  double v7;
  double v8;
  void *v9;
  uint64_t v10;

  v4 = a1 != a3;
  if (a2 != a4)
    v4 = 1;
  v5 = a3 <= 0.0 || !v4;
  if (v5 || a4 <= 0.0)
    goto LABEL_12;
  v6 = a3 / a4;
  if (v6 <= a1 / a2)
  {
    if (v6 < a1 / a2)
    {
      v7 = a1;
      v8 = a1 / v6;
      goto LABEL_13;
    }
LABEL_12:
    v8 = a2;
    v7 = a1;
    goto LABEL_13;
  }
  v7 = a2 * v6;
  v8 = a2;
LABEL_13:
  if (v7 < a1 || v8 < a2)
  {
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGSize TSDSizeExpandedToMatchAspectRatio(CGSize, CGSize)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGeometry.m"), 992, CFSTR("TSDSizeExpandedToMatchAspectRatio() actually shrank the size"));
  }
  return v7;
}

double TSDScaleSizeWithinSize(double a1, double a2, double a3, double a4)
{
  if (a1 / a2 < a3 / a4)
    return a1 * (a4 / a2);
  return a3;
}

double TSDShrinkSizeToFitInSize(double result, double a2, double a3, double a4)
{
  BOOL v4;
  BOOL v5;

  if (result <= a3)
  {
    v4 = a2 == a4;
    v5 = a2 < a4;
  }
  else
  {
    v4 = 0;
    v5 = 0;
  }
  if (!v5 && !v4)
  {
    if (result / a2 <= a3 / a4)
    {
      if (result / a2 < a3 / a4)
        return result * (a4 / a2);
      else
        return a3;
    }
    else
    {
      return a3;
    }
  }
  return result;
}

double TSDFitOrFillSizeInSize(int a1, double a2, double a3, double a4, double a5)
{
  double v5;
  double v6;
  double v7;

  v5 = a4 / a2;
  v6 = a5 / a3;
  if (v5 <= v6)
    v7 = v6;
  else
    v7 = v5;
  if (v5 >= v6)
    v5 = v6;
  if (a1)
    v5 = v7;
  return a2 * v5;
}

double TSDFitOrFillSizeInRect(int a1, double a2, double a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  double v11;
  double v12;
  double v13;

  v11 = a6 / a2;
  if (a6 / a2 <= a7 / a3)
    v12 = a7 / a3;
  else
    v12 = a6 / a2;
  if (a6 / a2 >= a7 / a3)
    v11 = a7 / a3;
  if (a1)
    v13 = v12;
  else
    v13 = v11;
  return TSDCenterRectOverRect(0.0, 0.0, a2 * v13, a3 * v13, a4, a5, a6, a7);
}

void TSDScaleRectAroundPoint(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, double a6, CGFloat a7)
{
  CGAffineTransform v12;
  CGAffineTransform t2;
  CGAffineTransform t1;
  CGAffineTransform v15;
  CGAffineTransform v16;
  CGAffineTransform v17;
  CGAffineTransform v18;
  CGRect v19;

  memset(&v18, 0, sizeof(v18));
  CGAffineTransformMakeTranslation(&v18, -a5, -a6);
  memset(&v17, 0, sizeof(v17));
  CGAffineTransformMakeScale(&v17, a7, a7);
  memset(&v16, 0, sizeof(v16));
  t1 = v18;
  t2 = v17;
  CGAffineTransformConcat(&v15, &t1, &t2);
  t1 = v18;
  CGAffineTransformInvert(&v12, &t1);
  CGAffineTransformConcat(&v16, &v15, &v12);
  t1 = v16;
  v19.origin.x = a1;
  v19.origin.y = a2;
  v19.size.width = a3;
  v19.size.height = a4;
  CGRectApplyAffineTransform(v19, &t1);
}

void TSDVisibleUnscaledRectForNewScale(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5, double a6, CGFloat a7, double a8)
{
  float64x2_t v14;
  CGAffineTransform v17;
  CGAffineTransform v18;
  CGAffineTransform v19;
  CGRect v20;
  CGRect v21;

  memset(&v19, 0, sizeof(v19));
  CGAffineTransformMakeScale(&v19, a7, a7);
  memset(&v18, 0, sizeof(v18));
  v17 = v19;
  CGAffineTransformInvert(&v18, &v17);
  v17 = v18;
  v20.origin.x = a1;
  v20.origin.y = a2;
  v20.size.width = a3;
  v20.size.height = a4;
  v21 = CGRectApplyAffineTransform(v20, &v17);
  v14 = vaddq_f64(*(float64x2_t *)&v18.tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v18.c, a6), *(float64x2_t *)&v18.a, a5));
  TSDScaleRectAroundPoint(v21.origin.x, v21.origin.y, v21.size.width, v21.size.height, v14.f64[0], v14.f64[1], a7 / a8);
}

double TSDRectWithInverseNormalizedRect(double a1, double a2, double a3)
{
  return -a1 / a3;
}

double TSDRectByExpandingBoundingRectToContentRect(double a1, double a2, double a3, double a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8, double a9, double a10, double a11, double a12)
{
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double MaxX;
  double v35;
  CGRect v36;
  CGRect v37;
  CGRect v38;
  CGRect v39;

  v25 = a1 + a5 * a3;
  v36.origin.x = a5;
  v36.origin.y = a6;
  v36.size.width = a7;
  v36.size.height = a8;
  MaxX = CGRectGetMaxX(v36);
  v37.origin.x = a5;
  v37.origin.y = a6;
  v37.size.width = a7;
  v37.size.height = a8;
  CGRectGetMaxY(v37);
  v26 = a1 + MaxX * a3;
  if (v25 >= v26)
    v27 = a1 + MaxX * a3;
  else
    v27 = v25;
  if (v25 > v26)
    v26 = v25;
  v35 = v27;
  v28 = v26 - v27;
  v29 = -a9 / a11 * (v26 - v27);
  v38.origin.x = -a9 / a11;
  v38.origin.y = -a10 / a12;
  v38.size.width = 1.0 / a11;
  v38.size.height = 1.0 / a12;
  v30 = CGRectGetMaxX(v38);
  v39.origin.x = -a9 / a11;
  v39.origin.y = -a10 / a12;
  v39.size.width = 1.0 / a11;
  v39.size.height = 1.0 / a12;
  CGRectGetMaxY(v39);
  if (v29 >= v30 * v28)
    v31 = v30 * v28;
  else
    v31 = v29;
  return v35 + v31;
}

double TSDAliasRound(double a1)
{
  double v1;
  double v2;

  v1 = fabs(a1);
  v2 = v1 - floor(v1);
  if ((a1 >= 0.0 || v2 > 0.49) && (a1 < 0.0 || v2 < 0.49))
    return floor(a1);
  else
    return ceil(a1);
}

double TSDAliasRoundedPoint(double a1)
{
  double v1;
  double v2;

  v1 = fabs(a1);
  v2 = v1 - floor(v1);
  if ((a1 >= 0.0 || v2 > 0.49) && (a1 < 0.0 || v2 < 0.49))
    return floor(a1);
  else
    return ceil(a1);
}

double TSDRoundForScale(double a1, double a2)
{
  double v3;

  TSURound();
  return v3 / a2;
}

double TSDRoundedPoint()
{
  double v0;
  double v1;

  TSURound();
  v1 = v0;
  TSURound();
  return v1;
}

double TSDRoundedPointForView(double a1, double a2)
{
  double v4;

  TSUScreenScale();
  return TSDRoundedPointForScale(a1, a2, v4);
}

double TSDRoundedPointForScale(double a1, double a2, double a3)
{
  void *v4;
  uint64_t v5;
  double v7;
  double v8;

  if (a3 == 0.0)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGPoint TSDRoundedPointForScale(CGPoint, CGFloat)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGeometry.m"), 1150, CFSTR("cannot give scale = 0 for TSDRoundedPointForScale!"));
  }
  else
  {
    TSURound();
    v8 = v7;
    TSURound();
    return 1.0 / a3 * v8;
  }
  return a1;
}

double TSDRoundedSize()
{
  double v0;
  double v1;

  TSURound();
  v1 = v0;
  TSURound();
  return v1;
}

double TSDRoundedSizeForScale(double a1, double a2, double a3)
{
  void *v4;
  uint64_t v5;
  double v7;
  double v8;

  if (a3 == 0.0)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGSize TSDRoundedSizeForScale(CGSize, CGFloat)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGeometry.m"), 1172, CFSTR("cannot give scale = 0 for TSDRoundedSizeForScale!"));
  }
  else
  {
    TSURound();
    v8 = v7;
    TSURound();
    return 1.0 / a3 * v8;
  }
  return a1;
}

double TSDCeilSize(double a1)
{
  return ceil(a1);
}

double TSDRoundedRect(double a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  return TSDRoundedRectForScale(a1, a2, a3, a4, 1.0);
}

double TSDRoundedRectForScale(double a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5)
{
  double v8;
  void *v9;
  uint64_t v10;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double v16;
  double v17;
  double v18;
  CGFloat v19;
  double v20;
  CGFloat v21;
  double v22;
  CGRect v24;
  CGRect v25;
  CGRect v26;
  CGRect v27;

  v8 = a1;
  if (a5 == 0.0)
  {
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGRect TSDRoundedRectForScale(CGRect, CGFloat)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGeometry.m"), 1221, CFSTR("cannot give scale = 0 for TSDRoundedRectForScale!"));
  }
  else if (!CGRectIsNull(*(CGRect *)&a1))
  {
    v24.origin.x = TSDMultiplyRectScalar(v8, a2, a3, a4, a5);
    x = v24.origin.x;
    y = v24.origin.y;
    width = v24.size.width;
    height = v24.size.height;
    CGRectGetMinX(v24);
    TSURound();
    v17 = v16;
    v25.origin.x = x;
    v25.origin.y = y;
    v25.size.width = width;
    v25.size.height = height;
    CGRectGetMinY(v25);
    TSURound();
    v19 = v18;
    v26.origin.x = x;
    v26.origin.y = y;
    v26.size.width = width;
    v26.size.height = height;
    CGRectGetMaxX(v26);
    TSURound();
    v21 = v20 - v17;
    v27.origin.x = x;
    v27.origin.y = y;
    v27.size.width = width;
    v27.size.height = height;
    CGRectGetMaxY(v27);
    TSURound();
    return TSDMultiplyRectScalar(v17, v19, v21, v22 - v19, 1.0 / a5);
  }
  return v8;
}

double TSDRoundedRectForView(double a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  double v8;

  TSUScreenScale();
  return TSDRoundedRectForScale(a1, a2, a3, a4, v8);
}

double TSDRoundedRectForMainScreen(double a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  double v8;

  TSUScreenScale();
  return TSDRoundedRectForScale(a1, a2, a3, a4, v8);
}

double TSDAliasRoundedRectForScale(double a1, CGFloat a2, CGFloat a3, CGFloat a4, double a5)
{
  double v8;
  void *v9;
  uint64_t v10;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double MinX;
  double v17;
  double v18;
  double v19;
  double MinY;
  double v21;
  double v22;
  double v23;
  double MaxX;
  double v25;
  double v26;
  double v27;
  double v28;
  double MaxY;
  double v30;
  double v31;
  double v32;
  CGRect v34;
  CGRect v35;
  CGRect v36;
  CGRect v37;

  v8 = a1;
  if (a5 == 0.0)
  {
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGRect TSDAliasRoundedRectForScale(CGRect, CGFloat)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGeometry.m"), 1247, CFSTR("cannot give scale = 0 for TSDRoundedRectForScale!"));
  }
  else if (!CGRectIsNull(*(CGRect *)&a1))
  {
    v34.origin.x = TSDMultiplyRectScalar(v8, a2, a3, a4, a5);
    x = v34.origin.x;
    y = v34.origin.y;
    width = v34.size.width;
    height = v34.size.height;
    MinX = CGRectGetMinX(v34);
    v17 = fabs(MinX);
    v18 = v17 - floor(v17);
    if ((MinX >= 0.0 || v18 > 0.49) && (MinX < 0.0 || v18 < 0.49))
      v19 = floor(MinX);
    else
      v19 = ceil(MinX);
    v35.origin.x = x;
    v35.origin.y = y;
    v35.size.width = width;
    v35.size.height = height;
    MinY = CGRectGetMinY(v35);
    v21 = fabs(MinY);
    v22 = v21 - floor(v21);
    if ((MinY >= 0.0 || v22 > 0.49) && (MinY < 0.0 || v22 < 0.49))
      v23 = floor(MinY);
    else
      v23 = ceil(MinY);
    v36.origin.x = x;
    v36.origin.y = y;
    v36.size.width = width;
    v36.size.height = height;
    MaxX = CGRectGetMaxX(v36);
    v25 = fabs(MaxX);
    v26 = v25 - floor(v25);
    if ((MaxX >= 0.0 || v26 > 0.49) && (MaxX < 0.0 || v26 < 0.49))
      v27 = floor(MaxX);
    else
      v27 = ceil(MaxX);
    v28 = v27 - v19;
    v37.origin.x = x;
    v37.origin.y = y;
    v37.size.width = width;
    v37.size.height = height;
    MaxY = CGRectGetMaxY(v37);
    v30 = fabs(MaxY);
    v31 = v30 - floor(v30);
    if ((MaxY >= 0.0 || v31 > 0.49) && (MaxY < 0.0 || v31 < 0.49))
      v32 = floor(MaxY);
    else
      v32 = ceil(MaxY);
    return TSDMultiplyRectScalar(v19, v23, v28, v32 - v23, 1.0 / a5);
  }
  return v8;
}

uint64_t TSDRoundedMinX(double a1, double a2, double a3, double a4)
{
  CGRectGetMinX(*(CGRect *)&a1);
  return TSURound();
}

uint64_t TSDRoundedMidX(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  CGRect v9;

  TSURound();
  v9.origin.x = a1;
  v9.origin.y = a2;
  v9.size.width = a3;
  v9.size.height = a4;
  CGRectGetMaxX(v9);
  TSURound();
  return TSURound();
}

uint64_t TSDRoundedMaxX(double a1, double a2, double a3, double a4)
{
  CGRectGetMaxX(*(CGRect *)&a1);
  return TSURound();
}

uint64_t TSDRoundedMinY(double a1, double a2, double a3, double a4)
{
  CGRectGetMinY(*(CGRect *)&a1);
  return TSURound();
}

uint64_t TSDRoundedMidY(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  CGRect v9;

  TSURound();
  v9.origin.x = a1;
  v9.origin.y = a2;
  v9.size.width = a3;
  v9.size.height = a4;
  CGRectGetMaxY(v9);
  TSURound();
  return TSURound();
}

uint64_t TSDRoundedMaxY(double a1, double a2, double a3, double a4)
{
  CGRectGetMaxY(*(CGRect *)&a1);
  return TSURound();
}

double TSDFloorForScale(double a1, double a2)
{
  double v3;

  TSURound();
  return v3 / a2;
}

double TSDFloorForMainScreen()
{
  double v0;
  double v1;
  double v2;

  TSUScreenScale();
  v1 = v0;
  TSURound();
  return v2 / v1;
}

uint64_t TSDSizeHasNaNComponents()
{
  return 0;
}

uint64_t TSDRectHasNaNComponents()
{
  return 0;
}

uint64_t TSDPointHasNaNComponents()
{
  return 0;
}

uint64_t TSDTransformHasNaNComponents()
{
  return 0;
}

double TSDCeilForMainScreen(double a1)
{
  double v2;
  float v3;

  TSUScreenScale();
  v3 = v2 * a1;
  return ceilf(v3) / v2;
}

void p_evaluateGradient(void *a1, double *a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  id v8;

  v8 = (id)objc_msgSend(a1, "newColorAtFraction:", *a2);
  objc_msgSend(v8, "redComponent");
  *a3 = v4;
  objc_msgSend(v8, "greenComponent");
  a3[1] = v5;
  objc_msgSend(v8, "blueComponent");
  a3[2] = v6;
  objc_msgSend(v8, "alphaComponent");
  a3[3] = v7;

}

uint64_t gradientStopCompare(void *a1, void *a2)
{
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  double v8;
  double v9;
  double v10;

  if (!a1 || !a2)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSComparisonResult gradientStopCompare(id, id, void *)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGradient.m"), 1723, CFSTR("Passing in nil is invalid."));
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSComparisonResult gradientStopCompare(id, id, void *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGradient.m"), 1724, CFSTR("Non-TSDGradients in array."));
  }
  objc_msgSend(a1, "fraction");
  v9 = v8;
  objc_msgSend(a2, "fraction");
  if (v9 >= v10)
    return v10 < v9;
  else
    return -1;
}

void sub_2179CE458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CGPath *TSDCreatePathByComputingArc(int a1, int a2, double a3, double a4, double a5, double a6, long double a7, double a8, double a9)
{
  double v16;
  double v17;
  __double2 v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  CGPath *Mutable;
  __int128 v40;
  double v42;
  double v44;
  double angle;
  CGAffineTransform v46;
  CGAffineTransform v47;
  CGAffineTransform m;

  v16 = (a3 - a8) * 0.5;
  v17 = (a4 - a9) * 0.5;
  angle = fmod(a7, 360.0) * 3.14159265 / 180.0;
  v18 = __sincos_stret(angle);
  v19 = v18.__sinval * v17 + v18.__cosval * v16;
  v20 = v18.__cosval * v17 - v18.__sinval * v16;
  v21 = fabs(a5);
  v22 = fabs(a6);
  v23 = a5 * a5;
  v24 = a6 * a6;
  v25 = v19 * v19 / (a5 * a5) + v20 * v20 / (a6 * a6);
  if (v25 > 1.0)
  {
    v26 = sqrt(v25);
    v21 = v21 * v26;
    v22 = v22 * v26;
    v23 = v21 * v21;
    v24 = v22 * v22;
  }
  v27 = (v23 * v24 - v23 * (v20 * v20) - v24 * (v19 * v19)) / (v19 * v19 * v24 + v23 * (v20 * v20));
  if (v27 < 0.0)
    v27 = 0.0;
  v28 = sqrt(v27);
  if (a1 == a2)
    v28 = -v28;
  v29 = v20 * v21 / v22 * v28;
  v30 = -(v22 * v19) / v21 * v28;
  v42 = (a4 + a9) * 0.5 + v18.__cosval * v30 + v18.__sinval * v29;
  v44 = (a3 + a8) * 0.5 + v30 * -v18.__sinval + v18.__cosval * v29;
  v31 = (v20 - v30) / v22;
  v32 = (-v19 - v29) / v21;
  v33 = (-v20 - v30) / v22;
  v34 = acos((v19 - v29) / v21 / sqrt(v31 * v31 + (v19 - v29) / v21 * ((v19 - v29) / v21)));
  if (v31 < 0.0)
    v34 = -v34;
  v35 = v34 * 180.0 / 3.14159265;
  v36 = acos(v32 / sqrt(v33 * v33 + v32 * v32));
  if (v33 < 0.0)
    v36 = -v36;
  v37 = fmod(v36 * 180.0 / 3.14159265, 360.0);
  v38 = fmod(v35, 360.0);
  Mutable = CGPathCreateMutable();
  v40 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  *(_OWORD *)&m.a = *MEMORY[0x24BDBD8B8];
  *(_OWORD *)&m.c = v40;
  *(_OWORD *)&m.tx = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
  *(_OWORD *)&v47.a = *(_OWORD *)&m.a;
  *(_OWORD *)&v47.c = v40;
  *(_OWORD *)&v47.tx = *(_OWORD *)&m.tx;
  CGAffineTransformTranslate(&m, &v47, v44, v42);
  v46 = m;
  CGAffineTransformRotate(&v47, &v46, angle);
  m = v47;
  v46 = v47;
  CGAffineTransformScale(&v47, &v46, 1.0, v22 / v21);
  m = v47;
  v46 = v47;
  CGAffineTransformTranslate(&v47, &v46, -v44, -v42);
  m = v47;
  CGPathAddArc(Mutable, &m, v44, v42, v21, v38 * 3.14159265 / 180.0, v37 * 3.14159265 / 180.0, a2 != 1);
  return Mutable;
}

CGPath *TSDCreatePathByAppendingPathFromElementToElement(const CGPath *a1, const CGPath *a2, uint64_t a3, uint64_t a4)
{
  CGPath *MutableCopy;
  CGFloat x[7];

  x[6] = *(CGFloat *)MEMORY[0x24BDAC8D0];
  MutableCopy = CGPathCreateMutableCopy(a1);
  if (a3 < a4)
  {
    do
    {
      switch(TSDPathGetElementTypeAtIndexAndAssociatedPoints(a2, a3, x))
      {
        case 0u:
          CGPathMoveToPoint(MutableCopy, 0, x[0], x[1]);
          break;
        case 1u:
          CGPathAddLineToPoint(MutableCopy, 0, x[0], x[0]);
          break;
        case 3u:
          CGPathAddCurveToPoint(MutableCopy, 0, x[0], x[1], x[2], x[3], x[4], x[5]);
          break;
        case 4u:
          CGPathCloseSubpath(MutableCopy);
          break;
        default:
          break;
      }
      ++a3;
    }
    while (a4 != a3);
  }
  return MutableCopy;
}

CGPath *TSDCreateTransformedPath(const CGPath *a1, const CGAffineTransform *a2)
{
  CGPath *Mutable;

  Mutable = CGPathCreateMutable();
  CGPathAddPath(Mutable, a2, a1);
  return Mutable;
}

void TSDCreateAADefeatedRectPoints(double a1, double a2, double a3, double a4, double a5, double a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  float v11;
  float v12;
  double v13;
  double *v14;
  double v15;

  v11 = a5 * a6;
  v12 = fmodf(v11, 2.0);
  if (a9 >= 1)
  {
    v13 = (float)(v12 * 0.5);
    v14 = (double *)(a8 + 8);
    do
    {
      *(v14 - 1) = TSDRoundedPoint() + v13;
      *v14 = v15 + v13;
      v14 += 2;
      --a9;
    }
    while (a9);
  }
}

void TSDCreateAADefeatedRect(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, double a6, double a7)
{
  double v14;
  double v15;
  double v16;
  _QWORD v17[3];
  double MaxY;
  uint64_t v19;
  CGRect v20;
  CGRect v21;
  CGRect v22;

  v19 = *MEMORY[0x24BDAC8D0];
  v17[0] = CGRectGetMinX(*(CGRect *)&a2);
  v20.origin.x = a2;
  v20.origin.y = a3;
  v20.size.width = a4;
  v20.size.height = a5;
  v17[1] = CGRectGetMinY(v20);
  v21.origin.x = a2;
  v21.origin.y = a3;
  v21.size.width = a4;
  v21.size.height = a5;
  v17[2] = CGRectGetMaxX(v21);
  v22.origin.x = a2;
  v22.origin.y = a3;
  v22.size.width = a4;
  v22.size.height = a5;
  MaxY = CGRectGetMaxY(v22);
  TSDCreateAADefeatedRectPoints(MaxY, v14, v15, v16, a6, a7, a1, (uint64_t)v17, 2);
}

CGPath *TSDCreateAADefeatedRectPath(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, double a6, double a7)
{
  double v14;
  double v15;
  double v16;
  CGPath *Mutable;
  uint64_t i;
  CGFloat v19;
  CGFloat v20;
  _QWORD v22[7];
  double MaxY;
  uint64_t v24;
  CGRect v25;
  CGRect v26;
  CGRect v27;
  CGRect v28;
  CGRect v29;
  CGRect v30;
  CGRect v31;

  v24 = *MEMORY[0x24BDAC8D0];
  v22[0] = CGRectGetMinX(*(CGRect *)&a2);
  v25.origin.x = a2;
  v25.origin.y = a3;
  v25.size.width = a4;
  v25.size.height = a5;
  v22[1] = CGRectGetMinY(v25);
  v26.origin.x = a2;
  v26.origin.y = a3;
  v26.size.width = a4;
  v26.size.height = a5;
  v22[2] = CGRectGetMaxX(v26);
  v27.origin.x = a2;
  v27.origin.y = a3;
  v27.size.width = a4;
  v27.size.height = a5;
  v22[3] = CGRectGetMinY(v27);
  v28.origin.x = a2;
  v28.origin.y = a3;
  v28.size.width = a4;
  v28.size.height = a5;
  v22[4] = CGRectGetMaxX(v28);
  v29.origin.x = a2;
  v29.origin.y = a3;
  v29.size.width = a4;
  v29.size.height = a5;
  v22[5] = CGRectGetMaxY(v29);
  v30.origin.x = a2;
  v30.origin.y = a3;
  v30.size.width = a4;
  v30.size.height = a5;
  v22[6] = CGRectGetMinX(v30);
  v31.origin.x = a2;
  v31.origin.y = a3;
  v31.size.width = a4;
  v31.size.height = a5;
  MaxY = CGRectGetMaxY(v31);
  TSDCreateAADefeatedRectPoints(MaxY, v14, v15, v16, a6, a7, a1, (uint64_t)v22, 4);
  Mutable = CGPathCreateMutable();
  for (i = 0; i != 8; i += 2)
  {
    v19 = *(double *)&v22[i];
    v20 = *(double *)&v22[i + 1];
    if (i * 8)
      CGPathAddLineToPoint(Mutable, 0, v19, v20);
    else
      CGPathMoveToPoint(Mutable, 0, v19, v20);
  }
  CGPathCloseSubpath(Mutable);
  return Mutable;
}

void TSDPathBoundsIncludingStroke(CGPathRef path, void *a2)
{
  double v4;
  double v5;
  double v6;
  CGRect BoundingBox;

  if (a2 && objc_msgSend(a2, "shouldRender"))
  {
    if (objc_msgSend(a2, "isFrame"))
    {
      BoundingBox = CGPathGetBoundingBox(path);
      objc_msgSend(a2, "coverageRect:", BoundingBox.origin.x, BoundingBox.origin.y, BoundingBox.size.width, BoundingBox.size.height);
    }
    else
    {
      objc_msgSend(a2, "width");
      v5 = v4;
      objc_msgSend(a2, "miterLimit");
      TSDPathBoundsIncludingStrokeWithParameters(path, objc_msgSend(a2, "cap"), objc_msgSend(a2, "join"), v5, v6);
    }
  }
  else
  {
    CGPathGetBoundingBox(path);
  }
}

double TSDPathBoundsIncludingStrokeWithParameters(const CGPath *a1, int a2, int a3, double a4, double a5)
{
  double x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  CGRect info;
  double v19;
  _BYTE v20[240];
  CGRect BoundingBox;
  CGRect v22;
  CGRect v23;

  BoundingBox = CGPathGetBoundingBox(a1);
  x = BoundingBox.origin.x;
  y = BoundingBox.origin.y;
  width = BoundingBox.size.width;
  height = BoundingBox.size.height;
  if (!CGPathIsEmpty(a1))
  {
    v22.origin.x = x;
    v22.origin.y = y;
    v22.size.width = width;
    v22.size.height = height;
    v23 = CGRectInset(v22, -(a4 * 0.5), -(a4 * 0.5));
    x = v23.origin.x;
    v14 = v23.origin.y;
    v15 = v23.size.width;
    v16 = v23.size.height;
    if (!a3)
    {
      memset(&v20[40], 0, 200);
      *(_OWORD *)&v20[24] = *MEMORY[0x24BDBEFB0];
      *(_OWORD *)&v20[8] = *(_OWORD *)&v20[24];
      v19 = a4 * 0.5;
      *(double *)v20 = a5;
      info = v23;
      CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathCornerBoundsApplier);
      v14 = info.origin.y;
      x = info.origin.x;
      v16 = info.size.height;
      v15 = info.size.width;
    }
    if (a2 == 2)
    {
      memset(&v20[32], 0, 112);
      *(_OWORD *)v20 = *MEMORY[0x24BDBEFB0];
      *(_OWORD *)&v20[16] = *(_OWORD *)v20;
      info.size.height = v16;
      v19 = a4 * 0.5;
      info.origin.x = x;
      info.origin.y = v14;
      info.size.width = v15;
      CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathEndBoundsApplier);
      TSDPathEndBoundsApplierFinishSubpath((uint64_t)&info);
      return info.origin.x;
    }
  }
  return x;
}

double TSDPathBoundsIncludingStrokeWithWidth(const CGPath *a1, double a2)
{
  return TSDPathBoundsIncludingStrokeWithParameters(a1, 0, 0, a2, 10.0);
}

void TSDPathCornerBoundsApplier(uint64_t a1, unsigned int *a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  _OWORD *v8;
  __int128 v9;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;

  v3 = *a2;
  if ((v3 - 1) >= 3)
  {
    if ((_DWORD)v3 == 4)
    {
      if (*(_DWORD *)(a1 + 80))
      {
        if (*(double *)(a1 + 64) != *(double *)(a1 + 48) || *(double *)(a1 + 72) != *(double *)(a1 + 56))
        {
          v13 = a1 + 48;
          v12 = 1;
          TSDPathCornerBoundsApplierProcessSegment(a1, (int *)&v12);
        }
        v11 = *(_DWORD *)(a1 + 224);
        v13 = a1 + 232;
        v12 = v11;
        TSDPathCornerBoundsApplierProcessSegment(a1, (int *)&v12);
      }
      *(_DWORD *)(a1 + 80) = 0;
      v9 = *(_OWORD *)(a1 + 48);
    }
    else
    {
      if ((_DWORD)v3)
        return;
      *(_DWORD *)(a1 + 80) = 0;
      v8 = (_OWORD *)*((_QWORD *)a2 + 1);
      *(_OWORD *)(a1 + 48) = *v8;
      v9 = *v8;
    }
    *(_OWORD *)(a1 + 64) = v9;
  }
  else
  {
    if (!*(_DWORD *)(a1 + 80))
    {
      v4 = 0;
      *(_DWORD *)(a1 + 224) = v3;
      v5 = kPointCountsByElementType[v3];
      if (v5 <= 1)
        v6 = 1;
      else
        v6 = v5;
      v7 = 16 * v6;
      do
      {
        *(_OWORD *)(a1 + 232 + v4) = *(_OWORD *)(*((_QWORD *)a2 + 1) + v4);
        v4 += 16;
      }
      while (v7 != v4);
    }
    TSDPathCornerBoundsApplierProcessSegment(a1, (int *)a2);
  }
}

__n128 TSDPathEndBoundsApplier(uint64_t a1, int *a2)
{
  int v4;
  uint64_t v5;
  _OWORD *v6;
  __n128 result;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;

  v4 = *a2;
  if ((*a2 - 1) >= 3)
  {
    if (v4 == 4)
    {
      *(_BYTE *)(a1 + 72) = 0;
      result = *(__n128 *)(a1 + 40);
      *(__n128 *)(a1 + 56) = result;
    }
    else if (!v4)
    {
      TSDPathEndBoundsApplierFinishSubpath(a1);
      *(_BYTE *)(a1 + 72) = 0;
      v6 = (_OWORD *)*((_QWORD *)a2 + 1);
      *(_OWORD *)(a1 + 56) = *v6;
      result = *(__n128 *)v6;
      *(_OWORD *)(a1 + 40) = *v6;
    }
  }
  else
  {
    if (!*(_BYTE *)(a1 + 72))
    {
      *(_BYTE *)(a1 + 72) = 1;
      *(_DWORD *)(a1 + 76) = v4;
      *(_OWORD *)(a1 + 80) = *(_OWORD *)(a1 + 56);
      v5 = *a2;
      if ((_DWORD)v5 == 4)
      {
        v4 = 4;
      }
      else
      {
        v8 = 0;
        v9 = kPointCountsByElementType[v5];
        if (v9 <= 1)
          v9 = 1;
        v10 = 16 * v9;
        do
        {
          *(_OWORD *)(a1 + 96 + v8) = *(_OWORD *)(*((_QWORD *)a2 + 1) + v8);
          v8 += 16;
        }
        while (v10 != v8);
        v4 = *a2;
      }
    }
    *(_DWORD *)(a1 + 128) = v4;
    *(_OWORD *)(a1 + 136) = *(_OWORD *)(a1 + 56);
    v11 = *a2;
    v12 = kPointCountsByElementType[v11];
    if ((_DWORD)v11 != 4)
    {
      v13 = 0;
      if (v12 <= 1)
        v12 = 1;
      v14 = 16 * v12;
      do
      {
        *(_OWORD *)(a1 + 152 + v13) = *(_OWORD *)(*((_QWORD *)a2 + 1) + v13);
        v13 += 16;
      }
      while (v14 != v13);
      v12 = kPointCountsByElementType[*a2];
    }
    result = *(__n128 *)(*((_QWORD *)a2 + 1) + 16 * (v12 - 1));
    *(__n128 *)(a1 + 56) = result;
  }
  return result;
}

void TSDPathEndBoundsApplierFinishSubpath(uint64_t a1)
{
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  CGFloat v14;
  double v15;
  double v16;
  CGFloat v17;
  double v18;
  CGFloat v19;
  double v20;
  CGFloat v21;
  double v22;
  CGFloat v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double *v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  CGFloat v41;
  double v42;
  double v43;
  CGFloat v44;
  double v45;
  CGFloat v46;
  double v47;
  CGFloat v48;
  double v49;
  CGFloat v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;

  if (*(_BYTE *)(a1 + 72))
  {
    v2 = *(double *)(a1 + 80);
    v3 = *(double *)(a1 + 88);
    v4 = gradientAtTFromTypeAndPoints(*(_DWORD *)(a1 + 76), (float64x2_t *)(a1 + 80));
    v6 = TSDMultiplyPointScalar(v4, v5, *(double *)(a1 + 32));
    v8 = v7;
    v9 = TSDSubtractPoints(v2, v3, v6);
    v11 = v10;
    v12 = TSDRotatePoint90Degrees(1, v6, v8);
    v13 = TSDAddPoints(v9, v11, v12);
    v15 = TSDGrowRectToPoint(*(CGFloat *)a1, *(CGFloat *)(a1 + 8), *(CGFloat *)(a1 + 16), *(CGFloat *)(a1 + 24), v13, v14);
    v17 = v16;
    v19 = v18;
    v21 = v20;
    v22 = TSDSubtractPoints(v9, v11, v12);
    *(double *)a1 = TSDGrowRectToPoint(v15, v17, v19, v21, v22, v23);
    *(_QWORD *)(a1 + 8) = v24;
    *(_QWORD *)(a1 + 16) = v25;
    *(_QWORD *)(a1 + 24) = v26;
    v27 = *(int *)(a1 + 128);
    v28 = (double *)(a1 + 136 + 16 * kPointCountsByElementType[v27]);
    v29 = *v28;
    v30 = v28[1];
    v31 = gradientAtTFromTypeAndPoints(v27, (float64x2_t *)(a1 + 136));
    v33 = TSDMultiplyPointScalar(v31, v32, *(double *)(a1 + 32));
    v35 = v34;
    v36 = TSDAddPoints(v29, v30, v33);
    v38 = v37;
    v39 = TSDRotatePoint90Degrees(1, v33, v35);
    v40 = TSDAddPoints(v36, v38, v39);
    v42 = TSDGrowRectToPoint(*(CGFloat *)a1, *(CGFloat *)(a1 + 8), *(CGFloat *)(a1 + 16), *(CGFloat *)(a1 + 24), v40, v41);
    v44 = v43;
    v46 = v45;
    v48 = v47;
    v49 = TSDSubtractPoints(v36, v38, v39);
    *(double *)a1 = TSDGrowRectToPoint(v42, v44, v46, v48, v49, v50);
    *(_QWORD *)(a1 + 8) = v51;
    *(_QWORD *)(a1 + 16) = v52;
    *(_QWORD *)(a1 + 24) = v53;
  }
}

CGPath *TSDCreateWobblyPathWithMaxWobbleAndSubdivisions(const CGPath *a1, unint64_t a2, double a3)
{
  CGPath *Mutable;
  uint64_t ElementCount;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  double v11;
  CGFloat v12;
  double v13;
  int v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  CGFloat v20;
  double v21;
  unint64_t v22;
  unint64_t v23;
  CGPoint CurrentPoint;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  CGFloat v30;
  CGFloat v31;
  double v32;
  CGFloat v33;
  double v34;
  double v36;
  CGFloat v37;
  __int128 v38;
  CGFloat v39;
  CGFloat v40;
  double v41;
  double v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  Mutable = CGPathCreateMutable();
  ElementCount = TSDPathGetElementCount(a1);
  if (ElementCount)
  {
    v8 = ElementCount;
    v9 = 0;
    v36 = *(double *)(MEMORY[0x24BDBEFB0] + 8);
    v37 = *MEMORY[0x24BDBEFB0];
    do
    {
      switch(TSDPathGetElementTypeAtIndexAndAssociatedPoints(a1, v9, &v38))
      {
        case 0u:
          v10 = v38;
          TSURandom();
          v12 = *(double *)&v10 + (v11 + -0.5) * a3;
          TSURandom();
          v36 = *((double *)&v10 + 1) + (v13 + -0.5) * a3;
          v37 = v12;
          CGPathMoveToPoint(Mutable, 0, v12, v36);
          break;
        case 1u:
          v14 = 0;
          v16 = *((double *)&v38 + 1);
          v15 = *(double *)&v38;
          goto LABEL_8;
        case 3u:
          v17 = v41;
          v18 = v42;
          TSURandom();
          v20 = v17 + (v19 + -0.5) * a3;
          TSURandom();
          CGPathAddCurveToPoint(Mutable, 0, *(CGFloat *)&v38, *((CGFloat *)&v38 + 1), v39, v40, v20, v18 + (v21 + -0.5) * a3);
          break;
        case 4u:
          v16 = v36;
          v15 = v37;
          *(CGFloat *)&v38 = v37;
          *((double *)&v38 + 1) = v36;
          v14 = 1;
LABEL_8:
          v22 = 0;
          v23 = a2;
          do
          {
            CurrentPoint = CGPathGetCurrentPoint(Mutable);
            v25 = TSDSubtractPoints(v15, v16, CurrentPoint.x);
            v27 = v26;
            if (v23)
            {
              TSURandom();
              *(float *)&v28 = 1.0 / (double)v23 * (v28 + 0.5);
              v29 = fminf(*(float *)&v28, 1.0);
            }
            else
            {
              v29 = 1.0;
            }
            v30 = CurrentPoint.x + v25 * v29;
            v31 = CurrentPoint.y + v27 * v29;
            TSURandom();
            v33 = v30 + (v32 + -0.5) * a3;
            TSURandom();
            CGPathAddLineToPoint(Mutable, 0, v33, v31 + (v34 + -0.5) * a3);
            ++v22;
            --v23;
          }
          while (v22 <= a2);
          if (v14)
            CGPathCloseSubpath(Mutable);
          break;
        default:
          break;
      }
      ++v9;
    }
    while (v9 != v8);
  }
  return Mutable;
}

CGPath *TSDCreateRoundRectPathForRectWithRadius(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  CGPath *Mutable;
  CGPath *v11;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  double MaxY;
  CGFloat v17;
  double MinY;
  double x1;
  CGFloat v21;
  double MaxX;
  CGRect v23;
  CGRect v24;
  CGRect v25;
  CGRect v26;
  CGRect v27;

  Mutable = CGPathCreateMutable();
  v11 = Mutable;
  v12 = a1;
  v13 = a2;
  v14 = a3;
  v15 = a4;
  if (a5 == 0.0)
  {
    CGPathAddRect(Mutable, 0, *(CGRect *)&v12);
  }
  else
  {
    x1 = CGRectGetMinX(*(CGRect *)&v12);
    v23.origin.x = a1;
    v23.origin.y = a2;
    v23.size.width = a3;
    v23.size.height = a4;
    MaxY = CGRectGetMaxY(v23);
    v24.origin.x = a1;
    v24.origin.y = a2;
    v24.size.width = a3;
    v24.size.height = a4;
    MaxX = CGRectGetMaxX(v24);
    v25.origin.x = a1;
    v25.origin.y = a2;
    v25.size.width = a3;
    v25.size.height = a4;
    v21 = CGRectGetMaxY(v25);
    v26.origin.x = a1;
    v26.origin.y = a2;
    v26.size.width = a3;
    v26.size.height = a4;
    v17 = CGRectGetMaxX(v26);
    v27.origin.x = a1;
    v27.origin.y = a2;
    v27.size.width = a3;
    v27.size.height = a4;
    MinY = CGRectGetMinY(v27);
    CGPathMoveToPoint(v11, 0, x1 + 0.0, MaxY - a5);
    CGPathAddArcToPoint(v11, 0, a1, a2, a1 + a5, a2 + 0.0, a5);
    CGPathAddArcToPoint(v11, 0, v17, MinY, v17, MinY + a5, a5);
    CGPathAddArcToPoint(v11, 0, MaxX, v21, MaxX - a5, v21, a5);
    CGPathAddArcToPoint(v11, 0, x1, MaxY, x1 + 0.0, MaxY - a5, a5);
    CGPathCloseSubpath(v11);
  }
  return v11;
}

CGPath *TSDCreateRoundRectPathForRectWithRadii(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  CGPath *Mutable;
  CGFloat MaxY;
  CGFloat MaxX;
  double MinY;
  CGFloat MinX;
  double y1;
  double x1;
  CGRect v24;
  CGRect v25;
  CGRect v26;
  CGRect v27;
  CGRect v28;
  CGRect v29;

  Mutable = CGPathCreateMutable();
  v24.origin.x = a1;
  v24.origin.y = a2;
  v24.size.width = a3;
  v24.size.height = a4;
  MinX = CGRectGetMinX(v24);
  v25.origin.x = a1;
  v25.origin.y = a2;
  v25.size.width = a3;
  v25.size.height = a4;
  y1 = CGRectGetMaxY(v25);
  v26.origin.x = a1;
  v26.origin.y = a2;
  v26.size.width = a3;
  v26.size.height = a4;
  x1 = CGRectGetMaxX(v26);
  v27.origin.x = a1;
  v27.origin.y = a2;
  v27.size.width = a3;
  v27.size.height = a4;
  MaxY = CGRectGetMaxY(v27);
  v28.origin.x = a1;
  v28.origin.y = a2;
  v28.size.width = a3;
  v28.size.height = a4;
  MaxX = CGRectGetMaxX(v28);
  v29.origin.x = a1;
  v29.origin.y = a2;
  v29.size.width = a3;
  v29.size.height = a4;
  MinY = CGRectGetMinY(v29);
  CGPathMoveToPoint(Mutable, 0, MinX, y1 - a5);
  CGPathAddArcToPoint(Mutable, 0, a1, a2, a1 + a6, a2, a6);
  CGPathAddArcToPoint(Mutable, 0, MaxX, MinY, MaxX, MinY + a7, a7);
  CGPathAddArcToPoint(Mutable, 0, x1, MaxY, x1 - a8, MaxY, a8);
  CGPathAddArcToPoint(Mutable, 0, MinX, y1, MinX, y1 - a5, a5);
  CGPathCloseSubpath(Mutable);
  return Mutable;
}

const CGPath *TSDPathIsOpen(const CGPath *result)
{
  uint64_t info;
  __int128 v2;

  info = 0;
  v2 = *MEMORY[0x24BDBEFB0];
  if (result)
  {
    CGPathApply(result, &info, (CGPathApplierFunction)TSDPathIsOpenApplier);
    return (const CGPath *)((_BYTE)info != 0);
  }
  return result;
}

uint64_t TSDPathIsOpenApplier(uint64_t result, unsigned int *a2)
{
  _BYTE *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = (_BYTE *)result;
  v3 = *a2;
  if ((v3 - 1) >= 3)
  {
    if ((_DWORD)v3 == 4)
    {
      *(_BYTE *)result = 0;
    }
    else if (!(_DWORD)v3)
    {
      *(_OWORD *)(result + 8) = *(_OWORD *)*((_QWORD *)a2 + 1);
    }
  }
  else
  {
    v4 = *((_QWORD *)a2 + 1) + 16 * kPointCountsByElementType[v3];
    result = TSDNearlyEqualPoints(*(double *)(v4 - 16), *(double *)(v4 - 8), *(double *)(result + 8), *(double *)(result + 16));
    *v2 = result ^ 1;
  }
  return result;
}

const CGPath *TSDPathIsLineSegment(const CGPath *result)
{
  int v1;
  _QWORD info[2];
  __int128 v3;
  __int128 v4;
  uint64_t v5;

  v1 = 0;
  if (result)
  {
    info[0] = &v1;
    info[1] = TSDPathIsLineSegmentApplier;
    v3 = *MEMORY[0x24BDBEFB0];
    v4 = v3;
    v5 = 0;
    CGPathApply(result, info, (CGPathApplierFunction)TSDPathApplyToSegmentsApplier);
    return (const CGPath *)(v1 == 1);
  }
  return result;
}

void TSDPathApplyToSegments(const CGPath *a1, uint64_t a2, uint64_t a3)
{
  _QWORD info[2];
  __int128 v4;
  __int128 v5;
  uint64_t v6;

  if (a1)
  {
    if (a3)
    {
      info[0] = a2;
      info[1] = a3;
      v4 = *MEMORY[0x24BDBEFB0];
      v5 = v4;
      v6 = 0;
      CGPathApply(a1, info, (CGPathApplierFunction)TSDPathApplyToSegmentsApplier);
    }
  }
}

int *TSDPathIsLineSegmentApplier(int *result, _DWORD *a2)
{
  int v2;

  if (*result == 1)
  {
    v2 = 2;
  }
  else
  {
    if (*result)
      return result;
    if (*a2 == 1)
      v2 = 1;
    else
      v2 = 2;
  }
  *result = v2;
  return result;
}

double TSDPathGetStartAndEndPoints(const CGPath *a1, _OWORD *a2, _OWORD *a3)
{
  double result;
  uint64_t info;
  __int128 v7;
  __int128 v8;

  info = 0;
  v7 = *MEMORY[0x24BDBEFB0];
  v8 = v7;
  CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathGetStartAndEndPointsApplier);
  if (a2)
  {
    result = *(double *)&v7;
    *a2 = v7;
  }
  if (a3)
  {
    result = *(double *)&v8;
    *a3 = v8;
  }
  return result;
}

__n128 TSDPathGetStartAndEndPointsApplier(uint64_t a1, int *a2)
{
  int v2;
  __n128 result;

  if (*(_BYTE *)a1)
    goto LABEL_2;
  v2 = *a2;
  if (!*a2)
  {
    result = *(__n128 *)*((_QWORD *)a2 + 1);
    *(__n128 *)(a1 + 8) = result;
    *(_BYTE *)a1 = 1;
LABEL_2:
    v2 = *a2;
  }
  if (v2 != 4)
  {
    result = *(__n128 *)(*((_QWORD *)a2 + 1) + 16 * kPointCountsByElementType[v2] - 16);
    *(__n128 *)(a1 + 24) = result;
  }
  return result;
}

void TSDPathApplyToSegmentsApplier(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  _OWORD *v4;
  __int128 v5;
  _QWORD v7[2];

  v3 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 - 1) < 3)
  {
    processSegmentElement(a1, (unsigned int *)a2);
    return;
  }
  if (v3 == 4)
  {
    if (*(_QWORD *)(a1 + 48))
    {
      if (*(double *)(a1 + 32) != *(double *)(a1 + 16) || *(double *)(a1 + 40) != *(double *)(a1 + 24))
      {
        v7[1] = a1 + 16;
        v7[0] = 1;
        processSegmentElement(a1, (unsigned int *)v7);
      }
    }
    *(_QWORD *)(a1 + 48) = 0;
    v5 = *(_OWORD *)(a1 + 16);
  }
  else
  {
    if (v3)
      return;
    *(_QWORD *)(a1 + 48) = 0;
    v4 = *(_OWORD **)(a2 + 8);
    *(_OWORD *)(a1 + 16) = *v4;
    v5 = *v4;
  }
  *(_OWORD *)(a1 + 32) = v5;
}

const CGPath *TSDPathGetSegmentCount(const CGPath *result)
{
  uint64_t v1;
  _QWORD info[2];
  __int128 v3;
  __int128 v4;
  uint64_t v5;

  v1 = 0;
  if (result)
  {
    info[0] = &v1;
    info[1] = TSDPathGetSegmentCountApplier;
    v3 = *MEMORY[0x24BDBEFB0];
    v4 = v3;
    v5 = 0;
    CGPathApply(result, info, (CGPathApplierFunction)TSDPathApplyToSegmentsApplier);
    return (const CGPath *)v1;
  }
  return result;
}

_QWORD *TSDPathGetSegmentCountApplier(_QWORD *result)
{
  ++*result;
  return result;
}

const CGPath *TSDPathGetSegmentAtIndex(const CGPath *result, uint64_t a2, uint64_t a3)
{
  _QWORD v3[3];
  _QWORD v4[2];
  _QWORD info[2];
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v4[0] = 0;
  v4[1] = a3;
  v3[0] = a2;
  v3[1] = 0;
  v3[2] = v4;
  if (result)
  {
    info[0] = v3;
    info[1] = TSDPathGetSegmentAtIndexApplier;
    v6 = *MEMORY[0x24BDBEFB0];
    v7 = v6;
    v8 = 0;
    CGPathApply(result, info, (CGPathApplierFunction)TSDPathApplyToSegmentsApplier);
    return (const CGPath *)LODWORD(v4[0]);
  }
  return result;
}

uint64_t TSDPathGetSegmentAtIndexApplier(uint64_t result, int *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(result + 8);
  if (*(_QWORD *)result == v2)
  {
    v3 = 0;
    v4 = *a2;
    **(_DWORD **)(result + 16) = v4;
    v5 = 16 * (kPointCountsByElementType[v4] & ~(kPointCountsByElementType[v4] >> 31)) + 16;
    do
    {
      *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(result + 16) + 8) + v3) = *(_OWORD *)(*((_QWORD *)a2 + 1) + v3);
      v3 += 16;
    }
    while (v5 != v3);
    v2 = *(_QWORD *)(result + 8);
  }
  *(_QWORD *)(result + 8) = v2 + 1;
  return result;
}

void TSDPathCornerBoundsApplierProcessSegment(uint64_t a1, int *a2)
{
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  CGFloat v27;
  double v28;
  double v29;
  CGFloat v30;
  double v31;
  CGFloat v32;
  double v33;
  CGFloat v34;
  double v35;
  CGFloat v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v4 = *(_DWORD *)(a1 + 80);
  if (v4)
  {
    v5 = *(int *)(a1 + 152);
    v6 = kPointCountsByElementType[v5];
    *(_DWORD *)(a1 + 84) = v5;
    memmove((void *)(a1 + 88), (const void *)(a1 + 160), 16 * (v6 & ~(v6 >> 31)) + 16);
  }
  *(_DWORD *)(a1 + 152) = *a2;
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a1 + 64);
  v7 = *a2;
  v8 = kPointCountsByElementType[v7];
  if ((_DWORD)v7 != 4)
  {
    v9 = 0;
    if (v8 <= 1)
      v8 = 1;
    v10 = 16 * v8;
    do
    {
      *(_OWORD *)(a1 + 176 + v9) = *(_OWORD *)(*((_QWORD *)a2 + 1) + v9);
      v9 += 16;
    }
    while (v10 != v9);
    v8 = kPointCountsByElementType[*a2];
  }
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(*((_QWORD *)a2 + 1) + 16 * (v8 - 1));
  *(_DWORD *)(a1 + 80) = v4 + 1;
  if ((v4 + 1) > 1)
  {
    v11 = gradientAtTFromTypeAndPoints(*(_DWORD *)(a1 + 84), (float64x2_t *)(a1 + 88));
    v13 = v12;
    v14 = gradientAtTFromTypeAndPoints(*(_DWORD *)(a1 + 152), (float64x2_t *)(a1 + 160));
    v16 = v15;
    v17 = TSDSubtractPoints(v11, v13, v14);
    v19 = TSDNormalizePoint(v17, v18);
    v21 = v20;
    v22 = -1.0 / TSDCrossPoints(v19, v20, v14, v16);
    if (v22 * v22 < *(double *)(a1 + 40) * *(double *)(a1 + 40))
    {
      v23 = TSDMultiplyPointScalar(v19, v21, v22 * *(double *)(a1 + 32));
      v24 = *(double *)(a1 + 160);
      v25 = *(double *)(a1 + 168);
      v26 = TSDAddPoints(v24, v25, v23);
      v28 = TSDGrowRectToPoint(*(CGFloat *)a1, *(CGFloat *)(a1 + 8), *(CGFloat *)(a1 + 16), *(CGFloat *)(a1 + 24), v26, v27);
      v30 = v29;
      v32 = v31;
      v34 = v33;
      v35 = TSDSubtractPoints(v24, v25, v23);
      *(double *)a1 = TSDGrowRectToPoint(v28, v30, v32, v34, v35, v36);
      *(_QWORD *)(a1 + 8) = v37;
      *(_QWORD *)(a1 + 16) = v38;
      *(_QWORD *)(a1 + 24) = v39;
    }
  }
}

double gradientAtTFromTypeAndPoints(int a1, float64x2_t *a2)
{
  float64x2_t v2;
  float64_t v4;
  void *v5;
  uint64_t v6;
  double v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v17;

  v2 = *(float64x2_t *)MEMORY[0x24BDBEFB0];
  switch(a1)
  {
    case 0:
      v17 = *(float64x2_t *)MEMORY[0x24BDBEFB0];
      v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGPoint gradientAtTFromTypeAndPoints(CGFloat, CGPathElementType, CGPoint *)");
      objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/CGPathAdditions.m"), 220, CFSTR("path gradient can't handle moveTo element"));
      v2 = v17;
      break;
    case 1:
    case 4:
      v2.f64[0] = TSDSubtractPoints(a2[1].f64[0], a2[1].f64[1], a2->f64[0]);
      v2.f64[1] = v4;
      break;
    case 2:
      TSUClamp();
      v8 = vmlaq_n_f64(vmulq_n_f64(vaddq_f64(a2[1], a2[1]), v7 * -2.0 + 1.0), vaddq_f64(*a2, *a2), v7 + -1.0);
      v9 = vaddq_f64(a2[2], a2[2]);
      goto LABEL_6;
    case 3:
      TSUClamp();
      __asm
      {
        FMOV            V4.2D, #-3.0
        FMOV            V5.2D, #3.0
      }
      v8 = vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmulq_f64(a2[1], _Q5), v7 * -4.0 + 1.0 + v7 * 3.0 * v7), vmulq_n_f64(vmulq_f64(*a2, _Q4), v7 + -1.0), v7 + -1.0), vmulq_n_f64(vmulq_f64(a2[2], _Q5), v7), v7 * -3.0 + 2.0);
      v9 = vmulq_n_f64(vmulq_f64(a2[3], _Q5), v7);
LABEL_6:
      v2 = vmlaq_n_f64(v8, v9, v7);
      break;
    default:
      return TSDNormalizePoint(v2.f64[0], v2.f64[1]);
  }
  return TSDNormalizePoint(v2.f64[0], v2.f64[1]);
}

__n128 processSegmentElement(uint64_t a1, unsigned int *a2)
{
  __n128 *v4;
  unsigned int v5;
  uint64_t v6;
  __int128 *v7;
  _OWORD *v8;
  __int128 v9;
  __n128 result;
  _QWORD v11[2];
  __int128 v12;
  _QWORD v13[8];

  v13[7] = *MEMORY[0x24BDAC8D0];
  v4 = (__n128 *)(a1 + 32);
  v12 = *(_OWORD *)(a1 + 32);
  v5 = *a2;
  if (*a2 != 4)
  {
    LODWORD(v6) = kPointCountsByElementType[v5];
    v7 = (__int128 *)*((_QWORD *)a2 + 1);
    if ((int)v6 <= 1)
      v6 = 1;
    else
      v6 = v6;
    v8 = v13;
    do
    {
      v9 = *v7++;
      *v8++ = v9;
      --v6;
    }
    while (v6);
  }
  v11[1] = &v12;
  v11[0] = v5;
  (*(void (**)(_QWORD, _QWORD *))(a1 + 8))(*(_QWORD *)a1, v11);
  result = *(__n128 *)(*((_QWORD *)a2 + 1) + 16 * kPointCountsByElementType[*a2] - 16);
  *v4 = result;
  ++*(_QWORD *)(a1 + 48);
  return result;
}

double TSDMetalLayerTimeWithHostTime(unint64_t a1)
{
  if (TSDMetalLayerTimeWithHostTime_onceToken != -1)
    dispatch_once(&TSDMetalLayerTimeWithHostTime_onceToken, &__block_literal_global_27);
  return *(double *)&__timeScale * (double)a1;
}

float64x2_t TSDBezierToBSpline(float64x2_t *a1, uint64_t a2)
{
  uint64_t v2;
  double *v3;
  float64x2_t result;

  v2 = 0;
  v3 = (double *)&qword_217C29448;
  do
  {
    result = a1[2];
    *(float64x2_t *)(a2 + v2) = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(a1[1], *(v3 - 4)), *a1, *(v3 - 8)), result, *v3), a1[3], v3[4]);
    v2 += 16;
    ++v3;
  }
  while (v2 != 64);
  return result;
}

float64x2_t TSDBSplineToBezier(float64x2_t *a1, uint64_t a2)
{
  uint64_t v2;
  double *v3;
  float64x2_t result;

  v2 = 0;
  v3 = (double *)&qword_217C294C8;
  do
  {
    result = a1[2];
    *(float64x2_t *)(a2 + v2) = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(a1[1], *(v3 - 4)), *a1, *(v3 - 8)), result, *v3), a1[3], v3[4]);
    v2 += 16;
    ++v3;
  }
  while (v2 != 64);
  return result;
}

double TSDPointOnCurve(float64x2_t *a1, double a2)
{
  double result;

  __asm { FMOV            V5.2D, #3.0 }
  *(_QWORD *)&result = *(_OWORD *)&vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmulq_n_f64(vmulq_n_f64(vmulq_f64(a1[1], _Q5), a2), 1.0 - a2), 1.0 - a2), vmulq_n_f64(vmulq_n_f64(*a1, 1.0 - a2), 1.0 - a2), 1.0 - a2), vmulq_n_f64(vmulq_n_f64(vmulq_f64(a1[2], _Q5), a2), a2), 1.0 - a2), vmulq_n_f64(vmulq_n_f64(a1[3], a2), a2), a2);
  return result;
}

double TSDPointOnQuadraticCurve(float64x2_t *a1, double a2)
{
  double result;

  *(_QWORD *)&result = *(_OWORD *)&vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmulq_n_f64(vaddq_f64(a1[1], a1[1]), a2), 1.0 - a2), vmulq_n_f64(*a1, 1.0 - a2), 1.0 - a2), vmulq_n_f64(a1[2], a2), a2);
  return result;
}

void TSDCurveBetween(float64x2_t *a1, uint64_t a2, double a3, double a4)
{
  double v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v8 = 1.0 - a3;
  *(double *)a2 = F(a1, 1.0 - a3, a3, 1.0 - a3, a3, 1.0 - a3, a3);
  *(_QWORD *)(a2 + 8) = v9;
  *(double *)(a2 + 16) = F(a1, v8, a3, v8, a3, 1.0 - a4, a4);
  *(_QWORD *)(a2 + 24) = v10;
  *(double *)(a2 + 32) = F(a1, v8, a3, 1.0 - a4, a4, 1.0 - a4, a4);
  *(_QWORD *)(a2 + 40) = v11;
  *(double *)(a2 + 48) = F(a1, 1.0 - a4, a4, 1.0 - a4, a4, 1.0 - a4, a4);
  *(_QWORD *)(a2 + 56) = v12;
}

void TSDDCurveBetween(float64x2_t *a1, uint64_t a2, double a3, double a4)
{
  double v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v8 = 1.0 - a3;
  *(double *)a2 = F(a1, 1.0 - a3, a3, 1.0 - a3, a3, 1.0 - a3, a3);
  *(_QWORD *)(a2 + 8) = v9;
  *(double *)(a2 + 16) = F(a1, v8, a3, v8, a3, 1.0 - a4, a4);
  *(_QWORD *)(a2 + 24) = v10;
  *(double *)(a2 + 32) = F(a1, v8, a3, 1.0 - a4, a4, 1.0 - a4, a4);
  *(_QWORD *)(a2 + 40) = v11;
  *(double *)(a2 + 48) = F(a1, 1.0 - a4, a4, 1.0 - a4, a4, 1.0 - a4, a4);
  *(_QWORD *)(a2 + 56) = v12;
}

uint64_t TSDIntersectionOfLines(double *a1, double *a2, double *a3, double *a4, double *a5)
{
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  BOOL v12;
  BOOL v13;
  double v14;
  BOOL v15;
  BOOL v16;
  double v17;

  v5 = a1[1];
  v6 = a1[2] - *a1;
  v7 = a1[3] - v5;
  v8 = a2[1];
  v9 = a2[2] - *a2;
  v10 = a2[3] - v8;
  v11 = (v7 * (*a2 - *a1) + (v5 - v8) * v6) / (v10 * v6 - v9 * v7);
  *a4 = v11;
  if (v11 >= 0.0)
  {
    v13 = v11 == 1.0;
    v12 = v11 >= 1.0;
  }
  else
  {
    v12 = 1;
    v13 = 0;
  }
  if (!v13 && v12)
    return 0;
  v14 = (v10 * (*a1 - *a2) + (a2[1] - a1[1]) * v9) / (v7 * v9 - v6 * v10);
  *a3 = v14;
  if (v14 >= 0.0)
  {
    v16 = v14 == 1.0;
    v15 = v14 >= 1.0;
  }
  else
  {
    v15 = 1;
    v16 = 0;
  }
  if (!v16 && v15)
    return 0;
  v17 = a1[1];
  *a5 = *a1 + v14 * v6;
  a5[1] = v17 + *a3 * v7;
  return 1;
}

double TSDDistanceToPointFromLine(double *a1, double a2, double a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  float v7;
  double v8;

  v4 = a1[2];
  v3 = a1[3];
  v5 = v3 - a1[1];
  v6 = v4 - *a1;
  v7 = v6 * v6 + v5 * v5;
  v8 = (float)(1.0 / sqrtf(v7));
  return a3 * -(v6 * v8) + v5 * v8 * a2 - (v3 * -(v6 * v8) + v5 * v8 * v4);
}

double TSDDDistanceToPointFromLine(double *a1, double a2, double a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  float v7;
  double v8;

  v4 = a1[2];
  v3 = a1[3];
  v5 = v3 - a1[1];
  v6 = v4 - *a1;
  v7 = v6 * v6 + v5 * v5;
  v8 = (float)(1.0 / sqrtf(v7));
  return a3 * -(v6 * v8) + v5 * v8 * a2 - (v3 * -(v6 * v8) + v5 * v8 * v4);
}

uint64_t TSDNearestPointOnLineToPoint(double *a1, double a2, double a3)
{
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;

  v4 = *a1;
  v5 = a1[1];
  v6 = TSDSubtractPoints(a2, a3, *a1);
  v8 = v7;
  v9 = a1[2];
  v10 = a1[3];
  v11 = TSDSubtractPoints(v9, v10, v4);
  TSDDotPoints(v6, v8, v11, v12);
  TSDDistanceSquared(v9, v10, v4, v5);
  return TSUClamp();
}

double TSDNearestPointOnCurveToPoint(float64x2_t *a1, double a2, double a3, double a4)
{
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v24;

  v24 = a4 * a4;
  v6 = 1.0;
  v7 = 0.0;
  while (1)
  {
    v8 = (v6 - v7) * 0.125;
    v9 = 0.0;
    if (v7 <= v6)
    {
      v10 = 3.40282347e38;
      v11 = v7;
      do
      {
        v12 = TSDPointOnCurve(a1, v11);
        v14 = TSDSubtractPoints(v12, v13, a2);
        v16 = TSDPointSquaredLength(v14, v15);
        if (v16 < v10)
        {
          v10 = v16;
          v9 = v11;
        }
        v11 = v8 + v11;
      }
      while (v11 <= v6);
    }
    v17 = TSDPointOnCurve(a1, v7);
    v19 = v18;
    v20 = TSDPointOnCurve(a1, v6);
    v21 = TSDSubtractPoints(v17, v19, v20);
    if (TSDPointSquaredLength(v21, v22) < v24)
      break;
    v7 = fmax(v9 - v8, 0.0);
    v6 = fmin(v8 + v9, 1.0);
  }
  return v9;
}

void TSDNearestPointOnCurveToLine(float64x2_t *a1, double *a2, uint64_t a3)
{
  double v5;
  double v6;
  double v7;
  double v8;
  float v9;
  double v10;
  double v11;
  double v12;
  double v13;
  float64_t v14;
  double v15;
  double v16;
  double v17;
  float v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  BOOL v27;
  BOOL v28;
  BOOL v29;
  uint64_t v30;
  float64x2_t v31;
  uint64_t v32;
  double v33;
  uint64_t v34;
  double v35;
  uint64_t v36;
  double v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v6 = a2[2];
  v5 = a2[3];
  v7 = v5 - a2[1];
  v8 = v6 - *a2;
  v9 = v8 * v8 + v7 * v7;
  v10 = (float)(1.0 / sqrtf(v9));
  v11 = v7 * v10;
  v12 = -(v8 * v10);
  v13 = v5 * v12 + v11 * v6;
  v14 = a1->f64[1] * v12 + v11 * a1->f64[0] - v13;
  v31.f64[0] = 0.0;
  v31.f64[1] = v14;
  v15 = a1[1].f64[1] * v12 + v11 * a1[1].f64[0] - v13;
  v32 = 0x3FD5555560000000;
  v33 = v15;
  v16 = a1[2].f64[1] * v12 + v11 * a1[2].f64[0] - v13;
  v34 = 0x3FE5555560000000;
  v35 = v16;
  v17 = v12 * a1[3].f64[1] + v11 * a1[3].f64[0] - v13;
  v36 = 0x3FF0000000000000;
  v37 = v17;
  *(float *)&v17 = v15 * 9.0 + v14 * -3.0 + v16 * -9.0 + v17 * 3.0;
  *(float *)&v16 = v15 * -12.0 + v14 * 6.0 + v16 * 6.0;
  *(float *)&v14 = v15 * 3.0 + v14 * -3.0;
  *(float *)&v14 = sqrtf((float)((float)(*(float *)&v17 * -4.0) * *(float *)&v14) + (float)(*(float *)&v16
                                                                                          * *(float *)&v16));
  *(float *)&v17 = *(float *)&v17 + *(float *)&v17;
  v18 = (float)((float)-*(float *)&v16 - *(float *)&v14) / *(float *)&v17;
  v19 = TSDPointOnCurve(&v31, (float)((float)(*(float *)&v14 - *(float *)&v16) / *(float *)&v17));
  v21 = v20;
  v22 = TSDPointOnCurve(&v31, v18);
  v23 = fabs(v21);
  v25 = fabs(v24);
  v27 = v22 > 1.0 || v22 < 0.0 || v23 < v25;
  if (v27 && (v19 >= 0.0 ? (v28 = v19 > 1.0) : (v28 = 1), !v28)
    || (v22 >= 0.0 ? (v29 = v22 > 1.0) : (v29 = 1), v19 = v22, !v29))
  {
    *(double *)a3 = TSDPointOnCurve(a1, v19);
    *(_QWORD *)(a3 + 8) = v30;
  }
}

double TSDPathGetElementLengthAtIndex(const CGPath *a1, uint64_t a2)
{
  _QWORD v3[3];
  double v4;

  v3[0] = a2;
  v3[1] = a2;
  v3[2] = 0;
  v4 = 0.0;
  CGPathApply(a1, v3, (CGPathApplierFunction)TSDPathGetLengthApplierFunction);
  return v4;
}

void TSDPathGetLengthApplierFunction(uint64_t a1, int *a2)
{
  uint64_t v3;
  int v4;
  double v5;
  double *v6;
  float v7;
  uint64_t v8;
  double v9;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 >= *(_QWORD *)a1 && v3 <= *(_QWORD *)(a1 + 8))
  {
    v4 = *a2;
    if (*a2 == 4)
      goto LABEL_6;
    if (v4 == 3)
    {
      v8 = *((_QWORD *)a2 + 1);
      v9 = 0.0;
      p_AddIfClose(v8, &v9);
      v5 = v9;
      goto LABEL_8;
    }
    v5 = 0.0;
    if (v4 == 1)
    {
LABEL_6:
      v6 = (double *)*((_QWORD *)a2 + 1);
      v7 = (v6[1] - v6[3]) * (v6[1] - v6[3]) + (*v6 - v6[2]) * (*v6 - v6[2]);
      v5 = sqrtf(v7);
    }
LABEL_8:
    *(double *)(a1 + 24) = v5 + *(double *)(a1 + 24);
  }
  *(_QWORD *)(a1 + 16) = v3 + 1;
}

double TSDPathGetLength(const CGPath *a1)
{
  __int128 v2;
  __int128 v3;

  v2 = xmmword_217C29508;
  v3 = unk_217C29518;
  CGPathApply(a1, &v2, (CGPathApplierFunction)TSDPathGetLengthApplierFunction);
  return *((double *)&v3 + 1);
}

double TSDPathGetLengthToElement(const CGPath *a1, uint64_t a2)
{
  _QWORD v3[2];
  __int128 v4;

  v3[0] = 0;
  v4 = 0u;
  v3[1] = a2;
  CGPathApply(a1, v3, (CGPathApplierFunction)TSDPathGetLengthApplierFunction);
  return *((double *)&v4 + 1);
}

double TSDPathGetLengthFromElement(const CGPath *a1, uint64_t a2)
{
  _QWORD v3[3];
  double v4;

  v3[0] = a2;
  v3[1] = 0x7FFFFFFFLL;
  v3[2] = 0;
  v4 = 0.0;
  CGPathApply(a1, v3, (CGPathApplierFunction)TSDPathGetLengthApplierFunction);
  return v4;
}

uint64_t TSDPathGetElementCount(const CGPath *a1)
{
  uint64_t info;

  info = 0;
  CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathGetElementCountApplierFunction);
  return info;
}

_QWORD *TSDPathGetElementCountApplierFunction(_QWORD *result)
{
  ++*result;
  return result;
}

uint64_t TSDPathGetElementTypeAtIndex(const CGPath *a1, uint64_t a2)
{
  uint64_t info;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v7 = 0u;
  v8 = 0u;
  v5 = 0u;
  v6 = 0u;
  v4 = 0u;
  info = a2;
  CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathGetElementApplierFunction);
  return DWORD2(v4);
}

uint64_t TSDPathGetElementApplierFunction(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  if (*(_QWORD *)result == v2)
  {
    *(_DWORD *)(result + 16) = *(_DWORD *)a2;
    *(_OWORD *)(result + 72) = *(_OWORD *)(*(_QWORD *)(a2 + 8) + 48);
    *(_OWORD *)(result + 56) = *(_OWORD *)(*(_QWORD *)(a2 + 8) + 32);
    *(_OWORD *)(result + 40) = *(_OWORD *)(*(_QWORD *)(a2 + 8) + 16);
    *(_OWORD *)(result + 24) = *(_OWORD *)*(_QWORD *)(a2 + 8);
  }
  *(_QWORD *)(result + 8) = v2 + 1;
  return result;
}

uint64_t TSDPathGetElementTypeAtIndexAndAllPoints(const CGPath *a1, uint64_t a2, _OWORD *a3)
{
  __int128 v4;
  __int128 v5;
  uint64_t info;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;

  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v8 = 0u;
  info = a2;
  CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathGetElementApplierFunction);
  v4 = v10;
  *a3 = v9;
  a3[1] = v4;
  v5 = v12;
  a3[2] = v11;
  a3[3] = v5;
  return DWORD2(v8);
}

uint64_t TSDPathGetElementTypeAtIndexAndAssociatedPoints(const CGPath *a1, uint64_t a2, _OWORD *a3)
{
  uint64_t result;
  __int128 v5;
  uint64_t info;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v7 = 0u;
  info = a2;
  CGPathApply(a1, &info, (CGPathApplierFunction)TSDPathGetElementApplierFunction);
  if (!a3)
    return DWORD2(v7);
  *a3 = v8;
  result = DWORD2(v7);
  if (DWORD2(v7) == 3)
  {
    v5 = v10;
    a3[1] = v9;
    a3[2] = v5;
  }
  return result;
}

void curveIntersectLine(double *a1, double *a2, uint64_t a3, uint64_t a4, int a5, void *a6)
{
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  float v21;
  double v22;
  double v23;
  double v24;
  double v25;
  id v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v42;
  double v43;
  double v44;
  double v45;
  TSDPathIntersection *v46;
  uint64_t v47;
  double v48;
  uint64_t v49;
  double v50;
  TSDPathIntersection *v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  float64x2_t v57;
  uint64_t v58;
  double v59;
  uint64_t v60;
  double v61;
  uint64_t v62;
  double v63;
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  v11 = *a1;
  v12 = a1[2];
  v13 = a1[4];
  v14 = a1[5];
  v15 = a1[6];
  v16 = a1[7];
  v18 = a2[2];
  v17 = a2[3];
  v19 = v17 - a2[1];
  v20 = v18 - *a2;
  v21 = v20 * v20 + v19 * v19;
  v22 = (float)(1.0 / sqrtf(v21));
  v23 = v19 * v22;
  v24 = -(v20 * v22);
  v25 = v17 * v24 + v23 * v18;
  v55 = a1[3];
  v56 = a1[1];
  v57.f64[0] = 0.0;
  v57.f64[1] = v56 * v24 + v23 * v11 - v25;
  v58 = 0x3FD5555555555555;
  v59 = v55 * v24 + v23 * v12 - v25;
  v53 = v16;
  v54 = v14;
  v60 = 0x3FE5555555555555;
  v61 = v14 * v24 + v23 * v13 - v25;
  v62 = 0x3FF0000000000000;
  v63 = v16 * v24 + v23 * v15 - v25;
  v26 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
  curveIntersectLineR(&v57, (uint64_t)&v57, v26, 1.0);
  v27 = objc_msgSend(v26, "count");
  if (v27 >= 1)
  {
    v28 = v27;
    v29 = 0;
    v52 = v13;
    do
    {
      objc_msgSend((id)objc_msgSend(v26, "objectAtIndex:", v29), "doubleValue");
      v31 = v30;
      v32 = 1.0 - v30;
      v33 = v31 * (v31 * (v15 * v31 + v32 * v13) + v32 * (v13 * v31 + v32 * v12))
          + v32 * (v31 * (v13 * v31 + v32 * v12) + v32 * (v12 * v31 + v32 * v11));
      v34 = a2[2] - *a2;
      v35 = v33 - *a2;
      if (v34 * v35 > -0.001)
      {
        v36 = v31 * (v31 * (v53 * v31 + v32 * v54) + v32 * (v54 * v31 + v32 * v55))
            + v32 * (v31 * (v54 * v31 + v32 * v55) + v32 * (v55 * v31 + v32 * v56));
        v37 = a2[1];
        v38 = a2[3] - v37;
        v39 = v38 * v38 + v34 * v34;
        v40 = (v36 - v37) * (v36 - v37) + v35 * v35;
        if (v38 * (v36 - v37) > -0.001 && v40 <= v39)
        {
          if (!a6)
            break;
          v42 = v12;
          v43 = v15;
          v44 = v11;
          v45 = sqrt(v40) / sqrt(v39);
          v46 = [TSDPathIntersection alloc];
          if (a5)
          {
            v47 = a4;
            v48 = v45;
            v49 = a3;
            v50 = v31;
          }
          else
          {
            v47 = a3;
            v48 = v31;
            v49 = a4;
            v50 = v45;
          }
          v51 = -[TSDPathIntersection initWithSegment:atT:onSegmentB:atT:atPoint:](v46, "initWithSegment:atT:onSegmentB:atT:atPoint:", v47, v49, v48, v50, v33, v36);
          objc_msgSend(a6, "addObject:", v51);

          v11 = v44;
          v15 = v43;
          v12 = v42;
          v13 = v52;
        }
      }
      ++v29;
    }
    while (v28 != v29);
  }

}

void lineIntersectsLine(double *a1, double *a2, uint64_t a3, uint64_t a4, void *a5)
{
  TSDPathIntersection *v8;
  TSDPathIntersection *v9;
  __int128 v10;
  double v11;
  double v12;

  v11 = 0.0;
  v12 = 0.0;
  v10 = *MEMORY[0x24BDBEFB0];
  if (TSDIntersectionOfLines(a1, a2, &v12, &v11, (double *)&v10))
  {
    v8 = [TSDPathIntersection alloc];
    v9 = -[TSDPathIntersection initWithSegment:atT:onSegmentB:atT:atPoint:](v8, "initWithSegment:atT:onSegmentB:atT:atPoint:", a3, a4, v12, v11, v10);
    objc_msgSend(a5, "addObject:", v9);

  }
}

void nearestAngleOnCurveToLine(float64x2_t *a1, double *a2, uint64_t a3)
{
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  BOOL v37;
  BOOL v38;
  BOOL v39;
  uint64_t v40;
  float64x2_t v41;
  uint64_t v42;
  double v43;
  uint64_t v44;
  double v45;
  uint64_t v46;
  double v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v5 = *a2;
  v6 = TSDSubtractPoints(a2[2], a2[3], *a2);
  v8 = TSDNormalizePoint(v6, v7);
  v10 = v9;
  v11 = TSDSubtractPoints(a1->f64[0], a1->f64[1], v5);
  v13 = TSDNormalizePoint(v11, v12);
  v41.f64[0] = 0.0;
  v41.f64[1] = TSDDotPoints(v8, v10, v13, v14);
  v15 = TSDSubtractPoints(a1[1].f64[0], a1[1].f64[1], v5);
  v17 = TSDNormalizePoint(v15, v16);
  v42 = 0x3FD5555555555555;
  v43 = TSDDotPoints(v8, v10, v17, v18);
  v19 = TSDSubtractPoints(a1[2].f64[0], a1[2].f64[1], v5);
  v21 = TSDNormalizePoint(v19, v20);
  v44 = 0x3FE5555555555555;
  v45 = TSDDotPoints(v8, v10, v21, v22);
  v23 = TSDSubtractPoints(a1[3].f64[0], a1[3].f64[1], v5);
  v25 = TSDNormalizePoint(v23, v24);
  v46 = 0x3FF0000000000000;
  v47 = TSDDotPoints(v8, v10, v25, v26);
  v27 = v43 * 9.0 + v41.f64[1] * -3.0 + v45 * -9.0 + v47 * 3.0;
  v28 = v43 * -12.0 + v41.f64[1] * 6.0 + v45 * 6.0;
  v29 = sqrt((v43 * 3.0 + v41.f64[1] * -3.0) * (v27 * -4.0) + v28 * v28);
  v30 = (-v28 - v29) / (v27 + v27);
  v31 = TSDPointOnCurve(&v41, (v29 - v28) / (v27 + v27));
  v33 = v32;
  v34 = TSDPointOnCurve(&v41, v30);
  v37 = v34 <= 1.0 && v34 >= 0.0 && v33 <= v35;
  if (!v37 && (v31 >= 0.0 ? (v38 = v31 > 1.0) : (v38 = 1), !v38)
    || (v34 >= 0.0 ? (v39 = v34 > 1.0) : (v39 = 1), v31 = v34, !v39))
  {
    *(double *)a3 = TSDPointOnCurve(a1, v31);
    *(_QWORD *)(a3 + 8) = v40;
  }
}

double F(float64x2_t *a1, double a2, double a3, double a4, double a5, double a6, double a7)
{
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  double result;

  v7 = a1[1];
  v8 = a1[2];
  v9 = vmlaq_n_f64(vmulq_n_f64(v8, a7), v7, a6);
  *(_QWORD *)&result = *(_OWORD *)&vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(a1[3], a7), v8, a6), a5), v9, a4), a3), vmlaq_n_f64(vmulq_n_f64(v9, a5), vmlaq_n_f64(vmulq_n_f64(v7, a7), *a1, a6), a4), a2);
  return result;
}

uint64_t recursiveSubdivideCurve(float64x2_t *a1, void *a2, uint64_t a3, uint64_t a4, void *a5, void *a6, int a7, uint64_t a8)
{
  float64_t v16;
  float64_t v17;
  double v18;
  float v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  float v26;
  double v27;
  double v28;
  float v29;
  float v30;
  float v31;
  double v32;
  float v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float64_t v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  float64_t v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  double v69;
  double v70;
  double v71;
  double v72;
  double v73;
  double v74;
  double v75;
  float v76;
  double v77;
  double v78;
  double v79;
  double v80;
  double v81;
  double v82;
  float v83;
  uint64_t v84;
  double v86;
  double v87;
  double v88;
  float v89;
  double v90;
  double v91;
  double v92;
  double v93;
  double v94;
  double v95;
  double v96;
  double v97;
  double v98;
  uint64_t v99;
  float v100;
  _BYTE v101[64];
  _BYTE v102[64];
  float64x2_t v103;
  double v104;
  double v105;
  double v106;
  double v107;
  double v108;
  double v109;
  uint64_t v110;

  v110 = *MEMORY[0x24BDAC8D0];
  v100 = 0.0;
  v99 = 0;
  objc_msgSend(a2, "transformedTotalCoordinate:betweenElement:andElement:withPressure:getElement:getPercentage:", a3, a4, a5, &v99, &v100, a1->f64[0], a1->f64[1]);
  v97 = v16;
  v98 = v17;
  v103.f64[0] = v16;
  v103.f64[1] = v17;
  objc_msgSend(a2, "curvatureAt:fromElement:", v99, v100);
  v19 = v18;
  *(float *)&v18 = v100;
  objc_msgSend(a2, "myGradientAt:fromElement:", v99, v18);
  v93 = v20;
  v91 = v21;
  objc_msgSend(a2, "transformedTotalCoordinate:betweenElement:andElement:withPressure:getElement:getPercentage:", a3, a4, a5, &v99, &v100, a1[3].f64[0], a1[3].f64[1]);
  v23 = v22;
  v96 = v24;
  v108 = v24;
  v109 = v22;
  objc_msgSend(a2, "curvatureAt:fromElement:", v99, v100);
  v26 = v25;
  *(float *)&v25 = v100;
  objc_msgSend(a2, "myGradientAt:fromElement:", v99, v25);
  v92 = v27;
  v90 = v28;
  v29 = 0.5;
  if (v19 <= 0.5)
    v30 = v19;
  else
    v30 = 0.5;
  if (v30 >= -0.5)
    v31 = v30;
  else
    v31 = -0.5;
  if (v26 <= 0.5)
    v29 = v26;
  if (v29 < -0.5)
    v29 = -0.5;
  v89 = v29;
  objc_msgSend(a2, "lineWidth");
  v33 = v32;
  v34 = a1->f64[1];
  v95 = v23;
  if (a5)
  {
    objc_msgSend(a5, "pressureAt:", a1->f64[0]);
    v36 = v33;
    v37 = v34 * v35 * v36;
    v38 = a1[1].f64[1];
    objc_msgSend(a5, "pressureAt:", a1[1].f64[0]);
    v40 = v38 * v39 * v36;
    v41 = a1[2].f64[1];
    objc_msgSend(a5, "pressureAt:", a1[2].f64[0]);
    v43 = v41 * v42 * v36;
    v44 = a1[3].f64[1];
    objc_msgSend(a5, "pressureAt:", a1[3].f64[0]);
  }
  else
  {
    v36 = v33;
    v37 = v34 * v36;
    v40 = a1[1].f64[1] * v36;
    v43 = a1[2].f64[1] * v36;
    v44 = a1[3].f64[1];
    v45 = 1.0;
  }
  v46 = v40;
  v47 = v37;
  v48 = v43;
  v49 = v36 * (v44 * v45);
  v50 = a1[1].f64[0] - a1->f64[0];
  v51 = (float)(v46 - v47);
  v52 = TSDMultiplyPointScalar(v93, v91, 1.0 - (float)(v31 * v47));
  v53 = TSDNormalizePoint(-v91, v93);
  v54 = TSDAddPoints(v97, v98, v53 * v51 + v50 * v52);
  v104 = v54;
  v105 = v55;
  v94 = v55;
  v56 = a1[2].f64[0] - a1[3].f64[0];
  v57 = TSDMultiplyPointScalar(v92, v90, 1.0 - (float)(v89 * v49));
  v58 = TSDNormalizePoint(-v90, v92);
  v59 = TSDAddPoints(v96, v95, v58 * (float)(v48 - v49) + v56 * v57);
  v61 = v60;
  v106 = v59;
  v107 = v60;
  if (a7)
  {
    if (a7 > 19)
      goto LABEL_19;
    v62 = TSDSubtractPoints(v96, v95, v97);
    if (TSDPointSquaredLength(v62, v63) <= 0.5)
      goto LABEL_19;
  }
  v64 = TSDPointOnCurve(&v103, 0.33);
  v66 = v65;
  objc_msgSend(a2, "transformedTotalCoordinate:betweenElement:andElement:withPressure:getElement:getPercentage:", a3, a4, a5, &v99, &v100, TSDPointOnCurve(a1, 0.33));
  v68 = TSDSubtractPoints(v64, v66, v67);
  *(float *)&v66 = TSDPointSquaredLength(v68, v69) + 0.0;
  v70 = TSDPointOnCurve(&v103, 0.5);
  v72 = v71;
  objc_msgSend(a2, "transformedTotalCoordinate:betweenElement:andElement:withPressure:getElement:getPercentage:", a3, a4, a5, &v99, &v100, TSDPointOnCurve(a1, 0.5));
  v74 = TSDSubtractPoints(v70, v72, v73);
  v76 = TSDPointSquaredLength(v74, v75) + *(float *)&v66;
  v77 = TSDPointOnCurve(&v103, 0.66);
  v79 = v78;
  objc_msgSend(a2, "transformedTotalCoordinate:betweenElement:andElement:withPressure:getElement:getPercentage:", a3, a4, a5, &v99, &v100, TSDPointOnCurve(a1, 0.66));
  v81 = TSDSubtractPoints(v77, v79, v80);
  v83 = TSDPointSquaredLength(v81, v82) + v76;
  if (v83 <= 0.2)
  {
LABEL_19:
    if ((_DWORD)a8)
    {
      objc_msgSend(a6, "moveToPoint:", v97, v98);
    }
    else
    {
      objc_msgSend(a6, "currentPoint");
      v87 = TSDSubtractPoints(v97, v98, v86);
      if (TSDPointSquaredLength(v87, v88) > 1.0)
        objc_msgSend(a6, "lineToPoint:", v97, v98);
    }
    return objc_msgSend(a6, "curveToPoint:controlPoint1:controlPoint2:", v96, v95, v54, v94, v59, v61);
  }
  else
  {
    TSDCurveBetween(a1, (uint64_t)v102, 0.0, 0.5);
    TSDCurveBetween(a1, (uint64_t)v101, 0.5, 1.0);
    v84 = (a7 + 1);
    recursiveSubdivideCurve(v102, a2, a3, a4, a5, a6, v84, a8);
    return recursiveSubdivideCurve(v101, a2, a3, a4, a5, a6, v84, 0);
  }
}

void recursiveSubdivideCurveSplit(float64x2_t *a1, void *a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  double v16;
  double v17;
  float v18;
  float v19;
  uint64_t v20;
  double v21;
  float v22;
  double v24;
  id v25;
  double v26;
  uint64_t v27;
  void *v28;
  TSDPathIntersection *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float v33;
  float v39;
  void *v40;
  float64x2_t v41;
  float64x2_t v42;
  double v43;
  float64x2_t v44;
  double v45;
  float64x2_t v46;
  float64x2_t v47;
  float64x2_t v48;
  float64x2_t v49;
  float64x2_t v50;
  double v51;
  double v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  void *v57;
  double v58;
  double v59;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  uint64_t v68;
  float v69;
  uint64_t v70;
  float v71;
  uint64_t v72;
  double v73;
  double v74;
  float v75;
  float v76;
  uint64_t v77;
  float64x2_t v78;
  float64x2_t v79;
  float64x2_t v80;
  float64x2_t v81;
  double *v82;
  float64x2_t v83;
  float64x2_t v84;
  float64x2_t v85;
  void *v86;
  void *v87;
  double v88;
  double v89;
  double v90;
  double v91;
  double v92;
  double v93;
  double v94;
  double v95;
  double v96;
  double v97;
  uint64_t v98;
  float64x2_t v99;
  float v100;
  uint64_t v101;
  float v102;
  uint64_t v103;
  double v104;
  double v105;
  float v106;
  float v107;
  uint64_t v108;
  float64x2_t v109;
  float64x2_t v110;
  float64x2_t v111;
  float64x2_t v112;
  double *f64;
  float64x2_t v116;
  float64x2_t v117;
  float64x2_t v118;
  uint64_t v119;
  float64x2_t v120;
  int8x16_t v121;
  float64x2_t v122;
  uint64_t v125;
  float64x2_t v126;
  id v127;
  id v128;
  float64x2_t v129;
  float64x2_t v130;
  float64x2_t v131;
  float64x2_t v132;
  uint64_t v133;
  float64x2x2_t v134;
  float64x2x2_t v135;

  v133 = *MEMORY[0x24BDAC8D0];
  v10 = objc_msgSend(a6, "count");
  v11 = v10 - 1;
  if ((unint64_t)(v10 - 1) < 2)
  {
    v28 = 0;
    v13 = 0;
LABEL_22:
    v14 = v11;
    goto LABEL_23;
  }
  v12 = v10;
  v125 = v10 - 1;
  v127 = 0;
  v13 = 0;
  v14 = 0;
  v15 = a1[1].f64[0];
  v16 = a1[2].f64[0];
  v17 = a1[3].f64[0];
  v18 = fmin(a1->f64[0], fmin(v15, fmin(v16, v17)));
  v19 = fmax(a1->f64[0], fmax(v15, fmax(v16, v17)));
  v20 = 2;
  do
  {
    objc_msgSend((id)objc_msgSend(a6, "objectAtIndex:", v20 - 1), "t");
    v22 = v21;
    if (v22 > v18 && v22 < v19)
    {
      v25 = v127;
      if (!v127)
        v25 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
      v24 = v22;
      v129.f64[0] = v24;
      v129.f64[1] = -100.0;
      v130.f64[0] = v24;
      v130.f64[1] = 100.0;
      v127 = v25;
      curveIntersectLine(a1->f64, v129.f64, v20 - 1, v20 - 1, 0, v25);
    }
    else
    {
      v24 = v22;
    }
    v26 = a1[3].f64[0];
    if (v26 > v24)
      v13 = v20 - 1;
    if (v26 < v24)
      v27 = v20 - 1;
    else
      v27 = 0;
    if (!v14)
      v14 = v27;
    ++v20;
  }
  while (v12 != v20);
  v28 = v127;
  v11 = v125;
  if (!v14)
    goto LABEL_22;
LABEL_23:
  v128 = v28;
  if (v28 && objc_msgSend(v28, "count"))
  {
    objc_msgSend(v128, "sortUsingSelector:", sel_compareT_);
    v29 = -[TSDPathIntersection initWithSegment:atT:atPoint:]([TSDPathIntersection alloc], "initWithSegment:atT:atPoint:", v13, 1.0, 1000.0, 0.0);
    objc_msgSend(v128, "addObject:", v29);

    v30 = objc_msgSend(v128, "count");
    if (v30)
    {
      v31 = v30;
      v32 = 0;
      v119 = v30 - 1;
      v33 = 0.0;
      __asm { FMOV            V0.2D, #0.5 }
      v121 = _Q0;
      v122 = (float64x2_t)vdupq_n_s64(0x7FF0000000000000uLL);
      __asm { FMOV            V0.2D, #1.0 }
      v120 = _Q0;
      do
      {
        v39 = v33;
        v40 = (void *)objc_msgSend(v128, "objectAtIndex:", v32);
        objc_msgSend(v40, "t");
        v41 = a1[1];
        v129 = *a1;
        v130 = v41;
        v42 = a1[3];
        v131 = a1[2];
        v132 = v42;
        v33 = v43;
        v42.f64[0] = 1.0 - v39;
        v44 = vmlaq_n_f64(vmulq_n_f64(v131, v39), v130, v42.f64[0]);
        v126 = vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(v132, v39), v131, v42.f64[0]), v39), v44, v42.f64[0]), v39), vmlaq_n_f64(vmulq_n_f64(v44, v39), vmlaq_n_f64(vmulq_n_f64(v130, v39), v129, v42.f64[0]), v42.f64[0]), v42.f64[0]);
        v45 = 1.0 - v33;
        v46 = vmlaq_n_f64(vmulq_n_f64(v130, v33), v129, v45);
        v47 = vmlaq_n_f64(vmulq_n_f64(v131, v33), v130, v45);
        v48 = vmlaq_n_f64(vmulq_n_f64(v132, v33), v131, v45);
        v129 = v126;
        v130 = vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(v48, v39), v47, v42.f64[0]), v39), vmlaq_n_f64(vmulq_n_f64(v47, v39), v46, v42.f64[0]), v42.f64[0]);
        v49 = vmlaq_n_f64(vmulq_n_f64(v47, v33), v46, v45);
        v50 = vmlaq_n_f64(vmulq_n_f64(v48, v33), v47, v45);
        v131 = vmlaq_n_f64(vmulq_n_f64(v50, v39), v49, v42.f64[0]);
        v132 = vmlaq_n_f64(vmulq_n_f64(v50, v33), v49, v45);
        objc_msgSend(v40, "point");
        v52 = v51;
        v53 = objc_msgSend(v40, "segment");
        v54 = objc_msgSend(v40, "segment");
        if (v126.f64[0] <= v52)
        {
          if (v32 == v119)
            v55 = v54 + 1;
          else
            v55 = v54;
          v53 -= v32 != v119;
        }
        else
        {
          v55 = v54 + 1;
        }
        v56 = (void *)objc_msgSend(a6, "objectAtIndex:", v53, v126.f64[0]);
        v57 = (void *)objc_msgSend(a6, "objectAtIndex:", v55);
        objc_msgSend(v56, "t");
        v59 = v58;
        objc_msgSend(v57, "t");
        v61 = v60;
        objc_msgSend(v56, "skew");
        v63 = v62;
        objc_msgSend(v57, "skew");
        v65 = v64;
        objc_msgSend(a2, "lineWidth");
        v67 = v66;
        objc_msgSend(a2, "length");
        v68 = 0;
        v69 = v63;
        *(double *)&v70 = (float)-v69;
        v71 = v65;
        *(double *)&v72 = (float)(v69 + v71);
        *(float *)&v73 = v67 / v73;
        v74 = *(float *)&v73;
        v75 = v61;
        v76 = v59;
        *(double *)&v77 = (float)(v75 - v76);
        v78 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v76), 0);
        v79 = (float64x2_t)vdupq_lane_s64(v77, 0);
        v80 = (float64x2_t)vdupq_lane_s64(v72, 0);
        v81 = (float64x2_t)vdupq_lane_s64(v70, 0);
        do
        {
          v82 = &v129.f64[v68];
          v134 = vld2q_f64(v82);
          v83 = vdivq_f64(vsubq_f64(v134.val[0], v78), v79);
          v84 = vabsq_f64(v83);
          v85 = vminnmq_f64((float64x2_t)vbslq_s8(vorrq_s8((int8x16_t)vcgtq_f64(v122, v84), (int8x16_t)vcgtq_f64(v84, v122)), (int8x16_t)v83, v121), v120);
          v134.val[0] = vmlaq_f64(v134.val[0], v134.val[1], vmulq_n_f64(vmlaq_f64(v81, v80, (float64x2_t)vbicq_s8((int8x16_t)v85, (int8x16_t)vcltzq_f64(v85))), v74));
          *v82 = v134.val[0].f64[0];
          *(float64_t *)((char *)&v129 + v68 * 8 + 16) = v134.val[0].f64[1];
          v68 += 4;
        }
        while (v68 != 8);
        recursiveSubdivideCurve(&v129, a2, objc_msgSend(v56, "segment") + 1, objc_msgSend(v57, "segment"), a3, a4, 0, a5 & 1);
        LOBYTE(a5) = 0;
        ++v32;
      }
      while (v32 != v31);
    }
  }
  else
  {
    v86 = (void *)objc_msgSend(a6, "objectAtIndex:", v13);
    v87 = (void *)objc_msgSend(a6, "objectAtIndex:", v14);
    objc_msgSend(v86, "t");
    v89 = v88;
    objc_msgSend(v87, "t");
    v91 = v90;
    objc_msgSend(v86, "skew");
    v93 = v92;
    objc_msgSend(v87, "skew");
    v95 = v94;
    objc_msgSend(a2, "lineWidth");
    v97 = v96;
    objc_msgSend(a2, "length");
    v98 = 0;
    v99 = (float64x2_t)vdupq_n_s64(0x7FF0000000000000uLL);
    v100 = v93;
    *(double *)&v101 = (float)-v100;
    v102 = v95;
    *(double *)&v103 = (float)(v100 + v102);
    *(float *)&v104 = v97 / v104;
    v105 = *(float *)&v104;
    v106 = v91;
    v107 = v89;
    *(double *)&v108 = (float)(v106 - v107);
    v109 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v107), 0);
    v110 = (float64x2_t)vdupq_lane_s64(v108, 0);
    v111 = (float64x2_t)vdupq_lane_s64(v103, 0);
    v112 = (float64x2_t)vdupq_lane_s64(v101, 0);
    __asm
    {
      FMOV            V6.2D, #0.5
      FMOV            V7.2D, #1.0
    }
    do
    {
      f64 = a1[v98].f64;
      v135 = vld2q_f64(f64);
      v116 = vdivq_f64(vsubq_f64(v135.val[0], v109), v110);
      v117 = vabsq_f64(v116);
      v118 = vminnmq_f64((float64x2_t)vbslq_s8(vorrq_s8((int8x16_t)vcgtq_f64(v99, v117), (int8x16_t)vcgtq_f64(v117, v99)), (int8x16_t)v116, _Q6), _Q7);
      v135.val[0] = vmlaq_f64(v135.val[0], v135.val[1], vmulq_n_f64(vmlaq_f64(v112, v111, (float64x2_t)vbicq_s8((int8x16_t)v118, (int8x16_t)vcltzq_f64(v118))), v105));
      *f64 = v135.val[0].f64[0];
      a1[v98 + 1].f64[0] = v135.val[0].f64[1];
      v98 += 2;
    }
    while (v98 != 4);
    recursiveSubdivideCurve(a1, a2, objc_msgSend(v86, "segment") + 1, objc_msgSend(v87, "segment"), a3, a4, 0, a5);
  }

}

double TSDPathNearestAngleOnPathToLine(const CGPath *a1, double *a2)
{
  double v4;
  double v5;
  double v6;
  uint64_t v7;
  _QWORD v9[2];
  __int128 v10;
  double v11;
  uint64_t v12;

  v4 = TSDSubtractPoints(a2[2], a2[3], *a2);
  v6 = TSDNormalizePoint(v4, v5);
  v9[0] = a2;
  v9[1] = 0xC000000000000000;
  v10 = *MEMORY[0x24BDBEFB0];
  v11 = v6;
  v12 = v7;
  TSDPathApplyToSegments(a1, (uint64_t)v9, (uint64_t)TSDPathNearestAngleOnPathToLineApplier);
  return *(double *)&v10;
}

void TSDPathNearestAngleOnPathToLineApplier(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  double v5;
  double v6;
  float64x2_t *v7;
  double v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  __int128 v17;

  if (*(_DWORD *)a2 == 3)
  {
    v7 = *(float64x2_t **)(a2 + 8);
    v5 = v7[3].f64[0];
    v6 = v7[3].f64[1];
    v17 = *MEMORY[0x24BDBEFB0];
    nearestAngleOnCurveToLine(v7, *(double **)a1, (uint64_t)&v17);
    if (v8 > *(double *)(a1 + 8))
    {
      *(_OWORD *)(a1 + 16) = v17;
      *(double *)(a1 + 8) = v8;
    }
  }
  else if (*(_DWORD *)a2 == 1)
  {
    v4 = *(_QWORD *)(a2 + 8);
    v5 = *(double *)(v4 + 16);
    v6 = *(double *)(v4 + 24);
  }
  else
  {
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSDPathNearestAngleOnPathToLineApplier(void *, const TSDPathSegment *)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDPathDistortion.m"), 2182, CFSTR("TSDPathAddIntersectionsWithLine doesn't handle quad curves or some other element type"));
    v11 = *(_QWORD *)(a2 + 8);
    v5 = *(double *)(v11 + 32);
    v6 = *(double *)(v11 + 40);
  }
  v12 = TSDSubtractPoints(v5, v6, **(double **)a1);
  v14 = TSDNormalizePoint(v12, v13);
  v16 = TSDDotPoints(*(double *)(a1 + 32), *(double *)(a1 + 40), v14, v15);
  if (v16 > *(double *)(a1 + 8))
  {
    *(double *)(a1 + 16) = v5;
    *(double *)(a1 + 24) = v6;
    *(double *)(a1 + 8) = v16;
  }
}

void p_AddIfClose(uint64_t a1, double *a2)
{
  uint64_t v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD *v21;
  uint64_t v22;
  float64x2_t v23;
  float64x2_t *v24;
  float64x2_t v25;
  uint64_t v26;
  __int128 *v27;
  __int128 v28;
  _OWORD *v29;
  uint64_t v30;
  uint64_t v31;
  _BYTE v32[64];
  _BYTE v33[64];
  _OWORD v34[16];
  uint64_t v35;

  v4 = 0;
  v35 = *MEMORY[0x24BDAC8D0];
  v5 = *(double *)a1;
  v6 = *(double *)(a1 + 8);
  v7 = 0.0;
  v8 = v6;
  v9 = *(double *)a1;
  do
  {
    v10 = *(double *)(a1 + v4 + 16);
    v11 = *(double *)(a1 + v4 + 24);
    v7 = v7 + TSDDistance(v9, v8, v10, v11);
    v4 += 16;
    v8 = v11;
    v9 = v10;
  }
  while (v4 != 48);
  if (v7 - TSDDistance(v5, v6, *(double *)(a1 + 48), *(double *)(a1 + 56)) <= 0.100000001)
  {
    *a2 = v7 + *a2;
  }
  else
  {
    v12 = *(_OWORD *)(a1 + 16);
    v34[0] = *(_OWORD *)a1;
    v34[1] = v12;
    v13 = *(_OWORD *)(a1 + 48);
    v34[2] = *(_OWORD *)(a1 + 32);
    v34[3] = v13;
    v14 = 1;
    v15 = 3;
    __asm { FMOV            V0.2D, #0.5 }
    v21 = v34;
    do
    {
      v22 = 0;
      v23 = (float64x2_t)v34[4 * v14 - 4];
      do
      {
        v24 = (float64x2_t *)&v21[v22];
        v25 = v24[1];
        v24[4] = vmlaq_f64(vmulq_f64(v25, _Q0), _Q0, v23);
        ++v22;
        v23 = v25;
      }
      while (v15 != v22);
      ++v14;
      --v15;
      v21 += 4;
    }
    while (v14 != 4);
    v26 = 0;
    v27 = v34;
    do
    {
      v28 = *v27;
      v27 += 4;
      *(_OWORD *)&v33[v26] = v28;
      v26 += 16;
    }
    while (v26 != 64);
    v29 = v32;
    v30 = 3;
    v31 = 12;
    do
    {
      *v29++ = v34[v31];
      --v30;
      v31 -= 3;
    }
    while (v30 != -1);
    p_AddIfClose(v33, a2);
    p_AddIfClose(v32, a2);
  }
}

void curveIntersectCurveR(float64x2_t *a1, double *a2, uint64_t a3, uint64_t a4, int a5, void *a6, double a7, double a8, double a9, double a10)
{
  double v20;
  double v21;
  double v22;
  TSDPathIntersection *v23;
  uint64_t v24;
  double v25;
  uint64_t v26;
  double v27;
  double v28;
  uint64_t v29;
  double *v30;
  double v31;
  double v32;
  double v33;
  uint64_t v34;
  uint64_t v35;
  double v36;
  uint64_t v37;
  TSDPathIntersection *v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43[9];

  v43[8] = *(double *)MEMORY[0x24BDAC8D0];
  v41 = 0.0;
  v42 = 0.0;
  clipToFatCurve(a1->f64, a2, &v42, &v41);
  v20 = v42;
  if (v42 <= 1.0)
  {
    v21 = v41;
    if (v41 >= 0.0)
    {
      if ((v41 - v42) * a7 >= 0.0001)
      {
        if (v41 - v42 >= 0.8)
        {
          v36 = (v42 + v41) * 0.5;
          TSDDCurveBetween(a1, (uint64_t)v43, v42, v36);
          v37 = a5 ^ 1u;
          curveIntersectCurveR(a2, v43, a4, a3, v37, a6, a9, a10, (v21 - v36) * a7, a8 + v20 * a7);
          TSDDCurveBetween(a1, (uint64_t)v43, (v20 + v21) * 0.5, v21);
          v28 = a8 + v36 * a7;
          v30 = a2;
          v31 = a9;
          v32 = a10;
          v33 = (v21 - v36) * a7;
          v34 = a4;
          v35 = a3;
          v29 = v37;
        }
        else
        {
          TSDDCurveBetween(a1, (uint64_t)v43, v42, v41);
          v28 = a8 + v20 * a7;
          v29 = a5 ^ 1u;
          v30 = a2;
          v31 = a9;
          v32 = a10;
          v33 = (v21 - v20) * a7;
          v34 = a4;
          v35 = a3;
        }
        curveIntersectCurveR(v30, v43, v34, v35, v29, a6, v31, v32, v33, v28);
      }
      else
      {
        v39 = 0.0;
        v40 = 0.0;
        TSDDCurveBetween(a1, (uint64_t)v43, v42, v41);
        clipToFatCurve(a2, v43, &v40, &v39);
        if ((v39 - v40) * a9 < 0.1)
        {
          v22 = (v39 + v40) * a9 * 0.5 + a10;
          v23 = [TSDPathIntersection alloc];
          if ((a5 & 1) != 0)
          {
            v24 = a4;
            v25 = v22;
            v26 = a3;
            v27 = (v20 + v21) * a7 * 0.5 + a8;
          }
          else
          {
            v24 = a3;
            v25 = (v20 + v21) * a7 * 0.5 + a8;
            v26 = a4;
            v27 = v22;
          }
          v38 = -[TSDPathIntersection initWithSegment:atT:onSegmentB:atT:atPoint:](v23, "initWithSegment:atT:onSegmentB:atT:atPoint:", v24, v26, v25, v27, *MEMORY[0x24BDBEFB0], *(double *)(MEMORY[0x24BDBEFB0] + 8));
          objc_msgSend(a6, "addObject:", v38);

        }
      }
    }
  }
}

double *clipToFatCurve(double *a1, double *a2, double *a3, double *a4)
{
  double v6;
  double v7;
  double v8;
  double v9;
  float v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double *result;
  uint64_t i;
  double v25;
  double v27;
  _QWORD v28[9];

  v28[8] = *MEMORY[0x24BDAC8D0];
  v6 = a2[6];
  v7 = a2[7];
  v8 = v7 - a2[1];
  v9 = v6 - *a2;
  v10 = v9 * v9 + v8 * v8;
  v11 = (float)(1.0 / sqrtf(v10));
  v12 = v8 * v11;
  v13 = -(v9 * v11);
  v14 = v7 * v13 + v12 * v6;
  v15 = a1[1] * v13 + v12 * *a1 - v14;
  v28[0] = 0;
  *(double *)&v28[1] = v15;
  v16 = a1[3] * v13 + v12 * a1[2] - v14;
  v28[2] = 0x3FD5555555555555;
  *(double *)&v28[3] = v16;
  v17 = v13 * a1[5] + v12 * a1[4] - v14;
  v28[4] = 0x3FE5555555555555;
  *(double *)&v28[5] = v17;
  v18 = v13 * a1[7] + v12 * a1[6] - v14;
  v28[6] = 0x3FF0000000000000;
  *(double *)&v28[7] = v18;
  v19 = v13 * a2[3] + v12 * a2[2] - v14;
  v20 = v13 * a2[5] + v12 * a2[4] - v14;
  v21 = fmin(v19, fmin(v20, 0.0));
  v22 = fmax(v19, fmax(v20, 0.0));
  *a3 = 2.0;
  *a4 = -1.0;
  shrinkIntervalWithIntersectionsFromCurve(a3, a4, (uint64_t)v28, v21);
  result = shrinkIntervalWithIntersectionsFromCurve(a3, a4, (uint64_t)v28, v22);
  for (i = 0; i != 8; i += 2)
  {
    v25 = *(double *)&v28[i + 1];
    if (v25 > v21 && v25 < v22)
    {
      v27 = *(double *)&v28[i];
      *a3 = fmin(*a3, v27);
      *a4 = fmax(*a4, v27);
    }
  }
  return result;
}

double *shrinkIntervalWithIntersectionsFromCurve(double *result, double *a2, uint64_t a3, double a4)
{
  unint64_t v4;
  double *v5;
  uint64_t v6;
  double *v7;
  double *v8;
  double *v9;
  uint64_t v10;
  double v11;
  double v12;
  double v13;

  v4 = 0;
  v5 = (double *)(a3 + 24);
  v6 = 3;
  do
  {
    if (v4 <= 2)
    {
      v7 = (double *)(a3 + 16 * v4);
      v8 = v7 + 1;
      v9 = v5;
      v10 = v6;
      do
      {
        v11 = *v8;
        if ((*v8 <= a4 || *v9 <= a4) && (v11 >= a4 || *v9 >= a4))
        {
          v12 = *v7;
          v13 = *(v9 - 1) - *v7;
          if (v13 != 0.0)
            v12 = v13 * (a4 - (v11 - v12 * (*v9 - v11) / v13)) / (*v9 - v11);
          if (v12 < *result)
            *result = v12;
          if (v12 > *a2)
            *a2 = v12;
        }
        v9 += 2;
        --v10;
      }
      while (v10);
    }
    ++v4;
    --v6;
    v5 += 2;
  }
  while (v4 != 4);
  return result;
}

double *curveIntersectLineR(float64x2_t *a1, uint64_t a2, void *a3, double a4)
{
  double *result;
  double v8;
  double v9;
  float64x2_t *v10;
  double v11;
  double v12;
  double v13;
  double v14;
  _BYTE v15[64];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v13 = -1.0;
  v14 = 2.0;
  result = shrinkIntervalWithIntersectionsFromCurve(&v14, &v13, a2, 0.0);
  v8 = v14;
  if (v14 <= 1.0)
  {
    v9 = v13;
    if (v13 >= 0.0)
    {
      if (v13 - v14 >= 0.00005)
      {
        if (v13 - v14 >= a4 * 0.8)
        {
          v12 = (v14 + v13) * 0.5;
          TSDDCurveBetween(a1, (uint64_t)v15, v14, v12);
          curveIntersectLineR(a1, v15, a3, v12 - v8);
          TSDDCurveBetween(a1, (uint64_t)v15, (v8 + v9) * 0.5, v9);
          v11 = v9 - v12;
          v10 = a1;
        }
        else
        {
          TSDDCurveBetween(a1, (uint64_t)v15, v14, v13);
          v10 = a1;
          v11 = v9 - v8;
        }
        return (double *)curveIntersectLineR(v10, v15, a3, v11);
      }
      else
      {
        return (double *)objc_msgSend(a3, "addObject:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", (v14 + v13) * 0.5));
      }
    }
  }
  return result;
}

uint64_t TSDAdjustGeometryForAlignPathSourceToOrigin(void *a1, void *a2)
{
  double v4;
  CGFloat v5;
  double v6;
  CGFloat v7;
  double v8;
  CGFloat v9;
  double v10;
  CGFloat v11;
  CGFloat x;
  CGFloat y;
  double width;
  double height;
  __int128 v16;
  double v17;
  double v18;
  double v19;
  double v20;
  int v21;
  double v22;
  double v23;
  double v24;
  double v25;
  CGAffineTransform v27;
  CGAffineTransform t2;
  CGAffineTransform t1;
  CGAffineTransform v30;
  CGAffineTransform v31;
  CGRect BoundingBox;
  CGRect v33;
  CGRect v34;
  CGRect v35;

  objc_msgSend(a1, "transformedBounds");
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  BoundingBox = CGPathGetBoundingBox((CGPathRef)objc_msgSend(a2, "pathWithoutFlips"));
  x = BoundingBox.origin.x;
  y = BoundingBox.origin.y;
  width = BoundingBox.size.width;
  height = BoundingBox.size.height;
  memset(&v31, 0, sizeof(v31));
  if (a2)
    objc_msgSend(a2, "pathFlipTransform");
  v16 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  *(_OWORD *)&v30.a = *MEMORY[0x24BDBD8B8];
  *(_OWORD *)&v30.c = v16;
  *(_OWORD *)&v30.tx = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
  *(_OWORD *)&t1.a = *(_OWORD *)&v30.a;
  *(_OWORD *)&t1.c = v16;
  *(_OWORD *)&t1.tx = *(_OWORD *)&v30.tx;
  t2 = v31;
  CGAffineTransformConcat(&v30, &t1, &t2);
  if (a1)
    objc_msgSend(a1, "transform");
  else
    memset(&v27, 0, sizeof(v27));
  t2 = v30;
  CGAffineTransformConcat(&t1, &t2, &v27);
  v30 = t1;
  v33.origin.x = v5;
  v33.origin.y = v7;
  v33.size.width = v9;
  v33.size.height = v11;
  *(_QWORD *)&v17 = (unint64_t)CGRectApplyAffineTransform(v33, &t1);
  t1 = v30;
  v34.origin.x = x;
  v34.origin.y = y;
  v34.size.width = width;
  v34.size.height = height;
  v35 = CGRectApplyAffineTransform(v34, &t1);
  v18 = TSDSubtractPoints(v35.origin.x, v35.origin.y, v17);
  objc_msgSend(a1, "center");
  objc_msgSend(a1, "setCenter:", TSDAddPoints(v19, v20, v18));
  v21 = objc_msgSend((id)objc_msgSend(a2, "bezierPath"), "isLineSegment");
  if (width >= 1.0)
    v22 = width;
  else
    v22 = 1.0;
  if (height >= 1.0)
    v23 = height;
  else
    v23 = 1.0;
  if (v21)
    v24 = width;
  else
    v24 = v22;
  if (v21)
    v25 = height;
  else
    v25 = v23;
  return objc_msgSend(a1, "setSize:", v24, v25, v23, *(_OWORD *)&v27.a, *(_OWORD *)&v27.c, *(_OWORD *)&v27.tx);
}

void sub_2179ED9F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSDSpatialDrawableComparator_block_invoke()
{
  void *v0;
  void *v1;
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;

  v0 = (void *)TSUProtocolCast();
  v1 = (void *)TSUProtocolCast();
  objc_msgSend((id)objc_msgSend(v0, "geometry"), "position");
  v3 = v2;
  v5 = v4;
  objc_msgSend((id)objc_msgSend(v1, "geometry"), "position");
  if (v5 < v7)
    return -1;
  if (v5 > v7)
    return 1;
  if (v3 >= v6)
    return v3 > v6;
  else
    return -1;
}

uint64_t TSDMaskForKnob(char a1)
{
  return 1 << a1;
}

uint64_t TSDKnobTagByRotating270Degrees(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;

  v1 = a1 - 1;
  if ((unint64_t)(a1 - 1) < 9 && ((0x1EFu >> v1) & 1) != 0)
    return qword_217C29618[v1];
  v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSDKnobTag TSDKnobTagByRotating270Degrees(TSDKnobTag)");
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDKnob.m"), 58, CFSTR("Unexpected knob tag"));
  return 0;
}

uint64_t TSDKnobTagByRotating180Degrees(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 0xA)
    return 0;
  else
    return qword_217C296A8[a1 - 1];
}

uint64_t TSDOppositeKnobTag(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 0xA)
    return 0;
  else
    return qword_217C296A8[a1 - 1];
}

uint64_t TSDKnobTagByRotating90Degrees(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;

  v1 = a1 - 1;
  if ((unint64_t)(a1 - 1) < 9 && ((0x1EFu >> v1) & 1) != 0)
    return qword_217C29660[v1];
  v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSDKnobTag TSDKnobTagByRotating90Degrees(TSDKnobTag)");
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDKnob.m"), 89, CFSTR("Unexpected knob tag"));
  return 0;
}

uint64_t TSDKnobTagForAngle(double a1)
{
  if (a1 > 22.5 && a1 <= 67.5)
    return 7;
  if (a1 > 67.5 && a1 <= 112.5)
    return 4;
  if (a1 > 112.5 && a1 <= 157.5)
    return 1;
  if (a1 > 157.5 && a1 <= 202.5)
    return 2;
  if (a1 > 202.5 && a1 <= 247.5)
    return 3;
  if (a1 > 247.5 && a1 <= 292.5)
    return 6;
  if (a1 > 292.5 && a1 <= 337.5)
    return 9;
  if (a1 >= 22.5 && a1 <= 337.5)
    return 0;
  else
    return 8;
}

uint64_t TSDKnobTagByRotatingKnobByAngle(uint64_t a1)
{
  double v2;
  double v3;

  TSURound();
  TSDNormalizeAngleInDegrees(v2 * 90.0);
  if (fabs(v3 + -90.0) < 0.00999999978)
    return TSDKnobTagByRotating90Degrees(a1);
  if (fabs(v3 + -180.0) >= 0.00999999978)
  {
    if (fabs(v3 + -270.0) < 0.00999999978)
      return TSDKnobTagByRotating270Degrees(a1);
  }
  else if ((unint64_t)(a1 - 1) >= 0xB)
  {
    return 0;
  }
  else
  {
    return qword_217C296A8[a1 - 1];
  }
  return a1;
}

double TSDPositionOfKnobOnRectangle(uint64_t a1, double a2, double a3, double a4, double a5)
{
  uint64_t v9;
  uint64_t v10;
  double v11;

  if ((unint64_t)(a1 - 1) > 8)
    return *MEMORY[0x24BDBEFB0];
  v9 = 2 - (a1 - 1) % 3u;
  if (a4 >= 0.0)
    v9 = (a1 - 1) % 3u;
  if (a5 >= 0.0)
    v10 = (a1 - 1) / 3u;
  else
    v10 = 2 - (a1 - 1) / 3u;
  v11 = qword_24D82BB58[v9]();
  qword_24D82BB70[v10](a2, a3, a4, a5);
  return v11;
}

BOOL TSDKnobTagIsCorner(char a1)
{
  return ((1 << a1) & 0x28A) != 0;
}

uint64_t TSDKnobTagWithFlip(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  void *v4;
  uint64_t v5;

  v2 = a1 - 1;
  result = 3;
  switch(v2)
  {
    case 0:
      return result;
    case 1:
    case 7:
    case 11:
      return a1;
    case 2:
      return 1;
    case 3:
      return 6;
    case 4:
    case 9:
    case 10:
      goto LABEL_4;
    case 5:
      return 4;
    case 6:
      return 9;
    case 8:
      return 7;
    default:
      if (a1 != 31)
      {
LABEL_4:
        v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSDKnobTag TSDKnobTagWithFlip(TSDKnobTag)");
        objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDKnob.m"), 246, CFSTR("don't know how to flip knob tag %lu"), a1);
      }
      return a1;
  }
}

void sub_2179FA144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_2179FBB84(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose(&STACK[0x280], 8);
  _Block_object_dispose((const void *)(v1 - 256), 8);
  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Unwind_Resume(a1);
}

void sub_2179FBEA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_2179FC118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_2179FCB6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2179FD8C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 192), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__12(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__12(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_2179FFF9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_217A02860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_217A03E04(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A03EC4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A03F48(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t p_bezierPathFittingPointsCallback(uint64_t a1, double *a2, void *a3)
{
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;

  v4 = *a2;
  v5 = a2[1];
  v6 = a2[2];
  v7 = a2[3];
  v8 = a2[4];
  v9 = a2[5];
  v10 = a2[6];
  v11 = a2[7];
  if (!objc_msgSend(a3, "elementCount"))
    objc_msgSend(a3, "moveToPoint:", v4, v5);
  return objc_msgSend(a3, "curveToPoint:controlPoint1:controlPoint2:", v10, v11, v6, v7, v8, v9);
}

double TSDCurveFitterPointOnCurve(uint64_t a1, double a2)
{
  return BezierII(3, a1, a2);
}

double BezierII(int a1, uint64_t a2, double a3)
{
  float64x2_t *v5;
  uint64_t v6;
  float64x2_t v7;
  int v8;
  unsigned int v9;
  float64x2_t v10;
  uint64_t v11;
  float64x2_t *v12;
  float64x2_t v13;
  double v15;

  v5 = (float64x2_t *)malloc_type_malloc((16 * a1 + 16), 0x522F83A0uLL);
  if ((a1 & 0x80000000) == 0)
  {
    v6 = 0;
    do
    {
      v5[v6] = *(float64x2_t *)(a2 + v6 * 16);
      ++v6;
    }
    while (a1 + 1 != v6);
    if (a1 >= 1)
    {
      v7 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(1.0 - a3), 0);
      v8 = 1;
      v9 = a1;
      do
      {
        if (v8 <= a1)
        {
          v10 = *v5;
          v11 = v9;
          v12 = v5 + 1;
          do
          {
            v13 = *v12;
            v12[-1] = vmlaq_f64(vmulq_n_f64(*v12, a3), v10, v7);
            ++v12;
            v10 = v13;
            --v11;
          }
          while (v11);
        }
        --v9;
      }
      while (v8++ != a1);
    }
  }
  v15 = v5->f64[0];
  free(v5);
  return v15;
}

double TSDCurvePointToCGPoint(double a1)
{
  return (float)a1;
}

void FitCubic(uint64_t a1, uint64_t a2, uint64_t a3, double ***a4, __n128 a5, __n128 a6, __n128 a7, __n128 a8, double a9)
{
  double ***v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double *v13;
  double *v14;
  double v15;
  float64x2_t *v16;
  float64x2_t *v17;
  double v18;
  float64x2_t v19;
  double v20;
  float64x2_t v21;
  __n128 v22;
  double v23;
  double *v24;
  double *v25;
  double *v26;
  double v27;
  double *v28;
  uint64_t v29;
  double *v30;
  uint64_t v31;
  uint64_t v32;
  float64x2_t *v33;
  __n128 v34;
  double *v35;
  int v36;
  double *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  double *v47;
  uint64_t v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  uint64_t v55;
  float64x2_t v56;
  float64x2_t v57;
  uint64_t v58;
  char v59;
  float64x2_t v60;
  char v61;
  float64x2_t v62;
  float64x2_t v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  double v69;
  uint64_t v70;
  uint64_t v71;
  __n128 v72;
  uint64_t v73;
  __n128 v75;
  double v76;
  uint64_t v77;
  double v78;
  double ***v79;
  uint64_t size;
  int v81;
  __n128 v82;
  __n128 v83;
  __n128 v84;
  __n128 v85;
  float64x2_t v86;
  uint64_t v87;
  __n128 v88;
  uint64_t v89;
  _OWORD v90[2];
  float64x2_t v91[3];
  uint64_t v92;

  while (1)
  {
    v9 = a4;
    v82 = a8;
    v83 = a7;
    v10 = a3;
    v11 = a1;
    v92 = *MEMORY[0x24BDAC8D0];
    v12 = a3 - a2;
    v84 = a6;
    v85 = a5;
    if (a3 - a2 == 1)
      break;
    v23 = a9;
    size = 8 * v12 + 8;
    v87 = a2;
    v24 = (double *)malloc_type_malloc(size & 0x7FFFFFFF8, 0x100004000313F17uLL);
    v25 = v24;
    *v24 = 0.0;
    if (v10 > v87)
    {
      v26 = v24 + 1;
      v27 = *v24;
      v28 = (double *)(v11 + 16 * v87 + 16);
      v29 = v12;
      do
      {
        v27 = v27 + sqrt((v28[1] - *(v28 - 1)) * (v28[1] - *(v28 - 1)) + (*v28 - *(v28 - 2)) * (*v28 - *(v28 - 2)));
        *v26++ = v27;
        v28 += 2;
        --v29;
      }
      while (v29);
      v30 = v24 + 1;
      v31 = v12;
      do
      {
        *v30 = *v30 / v24[v12];
        ++v30;
        --v31;
      }
      while (v31);
    }
    v89 = 0;
    GenerateBezier(v11, v87, v10, v24, v9, v85.n128_f64[0], v84.n128_f64[0], v83.n128_f64[0], v82.n128_f64[0]);
    v33 = (float64x2_t *)v32;
    v34.n128_f64[0] = ComputeMaxError(v11, v87, v10, v32, (uint64_t)v25, &v89, (uint64_t)v9);
    if (v34.n128_f64[0] < v23)
    {
      DrawBezierCurve((uint64_t)v33, (uint64_t)v9, v34);
      v35 = v25;
LABEL_34:
      free(v35);
      free(v33);
      return;
    }
    v79 = v9;
    if (v34.n128_f64[0] < v23 * v23)
    {
      v36 = 0;
      __asm { FMOV            V0.2D, #3.0 }
      v86 = _Q0;
      while (1)
      {
        v81 = v36;
        v42 = (double *)malloc_type_malloc(size, 0x100004000313F17uLL);
        v43 = v10;
        v44 = v87;
        if (v10 >= v87)
        {
          v45 = v87;
          do
          {
            v46 = v11;
            v47 = (double *)(v11 + 16 * v45);
            v48 = v45 - v44;
            v49 = v25[v45 - v44];
            v50 = *v47;
            v51 = v47[1];
            v52 = BezierII(3, (uint64_t)v33, v49);
            v54 = v53;
            v55 = 0;
            v56 = *v33;
            do
            {
              v57 = v33[v55 + 1];
              v91[v55++] = vmulq_f64(vsubq_f64(v57, v56), v86);
              v56 = v57;
            }
            while (v55 != 3);
            v58 = 0;
            v59 = 1;
            v60 = v91[0];
            do
            {
              v61 = v59;
              v62 = v91[v58 + 1];
              v63 = vsubq_f64(v62, v60);
              v90[v58] = vaddq_f64(v63, v63);
              v58 = 1;
              v60 = v62;
              v59 = 0;
            }
            while ((v61 & 1) != 0);
            v64 = BezierII(2, (uint64_t)v91, v49);
            v66 = v65;
            v67 = BezierII(1, (uint64_t)v90, v49);
            v69 = v66 * v66 + v64 * v64 + (v52 - v50) * v67 + (v54 - v51) * v68;
            if (v69 != 0.0)
              v49 = v49 - ((v54 - v51) * v66 + (v52 - v50) * v64) / v69;
            v44 = v87;
            v42[v48] = v49;
            _ZF = v45++ == v43;
            v11 = v46;
          }
          while (!_ZF);
        }
        v70 = v44;
        free(v33);
        v10 = v43;
        GenerateBezier(v11, v70, v43, v42, v79, v85.n128_f64[0], v84.n128_f64[0], v83.n128_f64[0], v82.n128_f64[0]);
        v33 = (float64x2_t *)v71;
        v72.n128_f64[0] = ComputeMaxError(v11, v70, v43, v71, (uint64_t)v42, &v89, (uint64_t)v79);
        if (v72.n128_f64[0] < v23)
          break;
        free(v25);
        v36 = v81 + 1;
        v25 = v42;
        if (v81 == 3)
          goto LABEL_30;
      }
      DrawBezierCurve((uint64_t)v33, (uint64_t)v79, v72);
      free(v25);
      v35 = v42;
      goto LABEL_34;
    }
    v42 = v25;
LABEL_30:
    free(v42);
    free(v33);
    v73 = v89;
    __asm { FMOV            V1.2D, #0.5 }
    v75 = (__n128)vmulq_f64(vaddq_f64(vsubq_f64(*(float64x2_t *)(v11 + 16 * v89 - 16), *(float64x2_t *)(v11 + 16 * v89)), vsubq_f64(*(float64x2_t *)(v11 + 16 * v89), *(float64x2_t *)(v11 + 16 * v89 + 16))), _Q1);
    v76 = sqrt(vmlad_n_f64(COERCE_DOUBLE(*(_QWORD *)&vmulq_f64(*(float64x2_t *)&v75, *(float64x2_t *)&v75).f64[1]), v75.n128_f64[0], v75.n128_f64[0]));
    if (v76 != 0.0)
      v75 = (__n128)vdivq_f64((float64x2_t)v75, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v76, 0));
    v77 = v87;
    v78 = v75.n128_f64[1];
    v88 = v75;
    FitCubic(v11, v77, v89, v79, v85, v84, v75, v75.n128_f64[1], v23);
    a5.n128_u64[1] = v88.n128_u64[1];
    a5.n128_f64[0] = -v88.n128_f64[0];
    a6.n128_f64[0] = -v78;
    a1 = v11;
    a2 = v73;
    a3 = v10;
    a8 = v82;
    a7 = v83;
    a9 = v23;
    a4 = v79;
  }
  v13 = (double *)(a1 + 16 * a3);
  v14 = (double *)(a1 + 16 * a2);
  v15 = sqrt((v13[1] - v14[1]) * (v13[1] - v14[1]) + (*v13 - *v14) * (*v13 - *v14)) / 3.0;
  v16 = (float64x2_t *)malloc_type_malloc(0x40uLL, 0x1000040451B5BE8uLL);
  v17 = v16;
  *v16 = *(float64x2_t *)v14;
  v16[3] = *(float64x2_t *)v13;
  *(_QWORD *)&v19.f64[0] = v85.n128_u64[0];
  v18 = sqrt(v84.n128_f64[0] * v84.n128_f64[0] + v19.f64[0] * v19.f64[0]);
  *(_QWORD *)&v19.f64[1] = v84.n128_u64[0];
  if (v18 != 0.0)
    v19 = vmulq_n_f64(v19, v15 / v18);
  v16[1] = vaddq_f64(v19, *v16);
  *(_QWORD *)&v21.f64[0] = v83.n128_u64[0];
  v20 = sqrt(v82.n128_f64[0] * v82.n128_f64[0] + v21.f64[0] * v21.f64[0]);
  *(_QWORD *)&v21.f64[1] = v82.n128_u64[0];
  if (v20 != 0.0)
    v21 = vmulq_n_f64(v21, v15 / v20);
  v22 = (__n128)vaddq_f64(v21, v16[3]);
  v16[2] = (float64x2_t)v22;
  DrawBezierCurve((uint64_t)v16, (uint64_t)v9, v22);
  free(v17);
}

uint64_t DrawBezierCurve(uint64_t a1, uint64_t a2, __n128 a3)
{
  a3.n128_u64[0] = *(_QWORD *)(a1 + 56);
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, __n128))(a2 + 24))(3, a1, *(_QWORD *)(a2 + 32), a3);
}

double GenerateBezier(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, double ***a5, double a6, double a7, double a8, double a9)
{
  double **v15;
  float64x2_t *v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  double *v25;
  double **v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double *v36;
  uint64_t v37;
  double *v38;
  double v39;
  double v40;
  double *v41;
  double *v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  float64x2_t v61;
  double v62;
  double *v63;
  double *v64;
  double v65;
  double v66;
  double v67;
  double v68;
  double result;
  double v70;

  v15 = *a5;
  v16 = (float64x2_t *)malloc_type_malloc(0x40uLL, 0x1000040451B5BE8uLL);
  v17 = 0.0;
  v18 = 0.0;
  v19 = 0.0;
  v20 = 0.0;
  v21 = 0.0;
  if (a3 >= a2)
  {
    v22 = sqrt(a7 * a7 + a6 * a6);
    v23 = a3 - a2 + 1;
    v24 = v23;
    v25 = a4;
    v26 = v15;
    v27 = sqrt(a9 * a9 + a8 * a8);
    do
    {
      v28 = 1.0 - *v25;
      v29 = *v25 * 3.0;
      v30 = a6;
      v31 = a7;
      if (v22 != 0.0)
      {
        v32 = v29 * (v28 * v28) / v22;
        v30 = a6 * v32;
        v31 = a7 * v32;
      }
      v33 = a8;
      v34 = a9;
      if (v27 != 0.0)
      {
        v35 = v28 * (*v25 * v29) / v27;
        v33 = a8 * v35;
        v34 = a9 * v35;
      }
      v36 = *v26++;
      *v36 = v30;
      v36[1] = v31;
      v36[2] = v33;
      v36[3] = v34;
      ++v25;
      --v24;
    }
    while (v24);
    v37 = a1 + 16 * a2;
    v39 = *(double *)(v37 + 8);
    v38 = (double *)(v37 + 8);
    v40 = v39;
    v41 = (double *)(a1 + 16 * a3);
    v21 = 0.0;
    v20 = 0.0;
    v19 = 0.0;
    v18 = 0.0;
    v17 = 0.0;
    do
    {
      v42 = *v15++;
      v43 = *v42;
      v44 = v42[1];
      v45 = v42[2];
      v46 = v42[3];
      v47 = v44 * v46 + *v42 * v45;
      v48 = *a4++;
      v49 = 1.0 - v48;
      v50 = v49 * (v49 * v49);
      v51 = v48 * 3.0 * (v49 * v49);
      v19 = v19 + v44 * v44 + v43 * v43;
      v52 = (1.0 - v48) * (v48 * (v48 * 3.0));
      v20 = v20 + v47;
      v53 = v48 * (v48 * v48);
      v21 = v21 + v46 * v46 + v45 * v45;
      v54 = *(v38 - 1) - (*(double *)(a1 + 16 * a2) * v50 + *(double *)(a1 + 16 * a2) * v51 + *v41 * v52 + v53 * *v41);
      v55 = *v38 - (v40 * v50 + v40 * v51 + v52 * v41[1] + v53 * v41[1]);
      v17 = v17 + v44 * v55 + v43 * v54;
      v18 = v18 + v46 * v55 + v45 * v54;
      v38 += 2;
      --v23;
    }
    while (v23);
  }
  v56 = v19 * v21 - v20 * v20;
  v57 = v17 * v21 - v18 * v20;
  v58 = v19 * v21 * 1.0e-11;
  if (v56 == 0.0)
    v56 = v58;
  if (v57 / v56 < 0.000001 || (v59 = (v19 * v18 - v20 * v17) / v56, v59 < 0.000001))
  {
    v63 = (double *)(a1 + 16 * a3);
    v64 = (double *)(a1 + 16 * a2);
    v65 = v63[1] - v64[1];
    v59 = sqrt(v65 * v65 + (*v63 - *v64) * (*v63 - *v64)) / 3.0;
    *v16 = *(float64x2_t *)v64;
    v16[3] = *(float64x2_t *)v63;
    v61.f64[0] = a6;
    v66 = sqrt(a7 * a7 + v61.f64[0] * v61.f64[0]);
    v61.f64[1] = a7;
    if (v66 == 0.0)
      goto LABEL_19;
    v62 = v59 / v66;
  }
  else
  {
    *v16 = *(float64x2_t *)(a1 + 16 * a2);
    v16[3] = *(float64x2_t *)(a1 + 16 * a3);
    v61.f64[0] = a6;
    v60 = sqrt(a7 * a7 + v61.f64[0] * v61.f64[0]);
    v61.f64[1] = a7;
    if (v60 == 0.0)
      goto LABEL_19;
    v62 = v57 / v56 / v60;
  }
  v61 = vmulq_n_f64(v61, v62);
LABEL_19:
  v16[1] = vaddq_f64(v61, *v16);
  v67 = sqrt(a9 * a9 + a8 * a8);
  if (v67 != 0.0)
  {
    v68 = v59 / v67;
    a8 = a8 * v68;
    a9 = a9 * v68;
  }
  result = a8 + v16[3].f64[0];
  v70 = a9 + v16[3].f64[1];
  v16[2].f64[0] = result;
  v16[2].f64[1] = v70;
  return result;
}

double ComputeMaxError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  double v9;
  double v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double *v17;
  double *v18;
  double v19;
  int v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  uint64_t v32;

  if (a3 - a2 + 1 >= 0)
    v7 = a3 - a2 + 1;
  else
    v7 = a3 - a2 + 2;
  *a6 = v7 >> 1;
  v8 = a2 + 1;
  v9 = 0.0;
  if (a2 + 1 < a3)
  {
    v13 = *(double *)(a7 + 16);
    v14 = a2;
    do
    {
      v32 = v8;
      if (v13 <= 0.0)
      {
        v21 = 0.0;
      }
      else
      {
        v15 = v8 - a2;
        v16 = v8 - a2 - 1;
        v17 = (double *)(a1 + 16 * v8);
        v18 = (double *)(a1 + 16 * v14);
        v19 = 0.0;
        v20 = 1;
        v21 = 0.0;
        do
        {
          v22 = 1.0 - v19 / v13;
          v23 = *v18 + (*v17 - *v18) * v22;
          v24 = v18[1] + (v17[1] - v18[1]) * v22;
          v25 = BezierII(3, a4, *(double *)(a5 + 8 * v16) + (*(double *)(a5 + 8 * v15) - *(double *)(a5 + 8 * v16)) * v22);
          v21 = v21 + (v26 - v24) * (v26 - v24) + (v25 - v23) * (v25 - v23);
          v19 = (double)v20;
          v13 = *(double *)(a7 + 16);
          ++v20;
        }
        while (v13 > v19);
      }
      if (v21 / v13 >= v9)
      {
        *a6 = v32;
        v9 = v21 / v13;
      }
      v8 = v32 + 1;
      v14 = v32;
    }
    while (v32 + 1 != a3);
  }
  return v9;
}

void _SFRSetLineWidth(CGContextRef c, CGFloat a2)
{
  CGAffineTransform v3;
  CGAffineTransform v4;

  if (a2 == 0.0)
  {
    NSLog((NSString *)CFSTR("BOGUS - lineWidth is 0."));
    CGContextGetCTM(&v3, c);
    CGAffineTransformInvert(&v4, &v3);
    a2 = v4.a + v4.c;
  }
  CGContextSetLineWidth(c, a2);
}

void *pBuildBezierPath(void *result, uint64_t a2)
{
  void *v3;
  void *v4;
  uint64_t v5;
  double *v6;

  v3 = result;
  switch(*(_DWORD *)a2)
  {
    case 0:
      result = (void *)objc_msgSend(result, "moveToPoint:", **(double **)(a2 + 8), *(double *)(*(_QWORD *)(a2 + 8) + 8));
      break;
    case 1:
      goto LABEL_4;
    case 2:
      v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void pBuildBezierPath(void *, const CGPathElement *)");
      objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPath.m"), 203, CFSTR("kCGPathElementAddQuadCurveToPoint not supported yet"));
LABEL_4:
      result = (void *)objc_msgSend(v3, "lineToPoint:", **(double **)(a2 + 8), *(double *)(*(_QWORD *)(a2 + 8) + 8));
      break;
    case 3:
      v6 = *(double **)(a2 + 8);
      result = (void *)objc_msgSend(result, "curveToPoint:controlPoint1:controlPoint2:", v6[4], v6[5], *v6, v6[1], v6[2], v6[3]);
      break;
    case 4:
      result = (void *)objc_msgSend(result, "closePath");
      break;
    default:
      return result;
  }
  return result;
}

void addifclose(uint64_t a1, float *a2)
{
  uint64_t v4;
  double v5;
  double v6;
  float v7;
  double v8;
  double v9;
  double v10;
  double v11;
  float v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD *v22;
  uint64_t v23;
  float64x2_t v24;
  float64x2_t *v25;
  float64x2_t v26;
  uint64_t v27;
  __int128 *v28;
  __int128 v29;
  _OWORD *v30;
  uint64_t v31;
  uint64_t v32;
  _BYTE v33[64];
  _BYTE v34[64];
  _OWORD v35[16];
  uint64_t v36;

  v4 = 0;
  v36 = *MEMORY[0x24BDAC8D0];
  v5 = *(double *)a1;
  v6 = *(double *)(a1 + 8);
  v7 = 0.0;
  v8 = v6;
  v9 = *(double *)a1;
  do
  {
    v10 = *(double *)(a1 + v4 + 16);
    v11 = *(double *)(a1 + v4 + 24);
    v7 = TSDDistance(v9, v8, v10, v11) + v7;
    v4 += 16;
    v8 = v11;
    v9 = v10;
  }
  while (v4 != 48);
  v12 = TSDDistance(v5, v6, *(double *)(a1 + 48), *(double *)(a1 + 56));
  if ((float)(v7 - v12) <= 0.1)
  {
    *a2 = *a2 + v7;
  }
  else
  {
    v13 = *(_OWORD *)(a1 + 16);
    v35[0] = *(_OWORD *)a1;
    v35[1] = v13;
    v14 = *(_OWORD *)(a1 + 48);
    v35[2] = *(_OWORD *)(a1 + 32);
    v35[3] = v14;
    v15 = 3;
    v16 = 1;
    __asm { FMOV            V0.2D, #0.5 }
    v22 = v35;
    do
    {
      v23 = 0;
      v24 = (float64x2_t)v35[4 * v16 - 4];
      do
      {
        v25 = (float64x2_t *)&v22[v23];
        v26 = v25[1];
        v25[4] = vmlaq_f64(vmulq_f64(v26, _Q0), _Q0, v24);
        ++v23;
        v24 = v26;
      }
      while (v15 != v23);
      ++v16;
      --v15;
      v22 += 4;
    }
    while (v16 != 4);
    v27 = 0;
    v28 = v35;
    do
    {
      v29 = *v28;
      v28 += 4;
      *(_OWORD *)&v34[v27] = v29;
      v27 += 16;
    }
    while (v27 != 64);
    v30 = v33;
    v31 = 3;
    v32 = 12;
    do
    {
      *v30++ = v35[v32];
      --v31;
      v32 -= 3;
    }
    while (v31 != -1);
    addifclose(v34, a2);
    addifclose(v33, a2);
  }
}

double p_getMaxMinTailSize(double *a1, double *a2, double *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v18;
  double v19;
  double v20;
  double v21;
  double result;

  v18 = TSDSubtractPoints(a4, a5, a8);
  v20 = TSDDotPoints(a6, a7, v18, v19);
  v21 = TSDDistanceToPointFromLine(a1, a4, a5) * a10 / v20;
  *a2 = fmax(*a2, v21);
  result = fmin(*a3, v21);
  *a3 = result;
  return result;
}

void TSDEllipseParametricAngleWithPolarAngle(double a1, double a2, double a3)
{
  double v5;
  double i;
  void *v7;
  uint64_t v8;
  __double2 v9;
  double j;
  void *v11;
  uint64_t v12;

  if (a2 != 0.0 && a3 != 0.0)
  {
    v5 = a1;
    for (i = 0.0; v5 >= 360.0; v5 = v5 + -360.0)
      i = i + 1.0;
    for (; v5 < 0.0; v5 = v5 + 360.0)
      i = i + -1.0;
    if (v5 < 0.0 || v5 >= 360.0)
    {
      v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSDEllipseParametricAngleWithPolarAngle(CGFloat, CGFloat, CGFloat)");
      objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 714, CFSTR("Angle out of range"));
    }
    if (v5 / 90.0 - floor(v5 / 90.0) >= 0.01 && ceil(v5 / 90.0) - v5 / 90.0 >= 0.01)
    {
      v9 = __sincos_stret(v5 * 3.14159265 / 180.0);
      for (j = atan2(v9.__sinval / a3, v9.__cosval / a2) * 180.0 / 3.14159265; j < 0.0; j = j + 360.0)
        ;
      for (; j >= 360.0; j = j + -360.0)
        ;
      if (j < 0.0 || j >= 360.0)
      {
        v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSDEllipseParametricAngleWithPolarAngle(CGFloat, CGFloat, CGFloat)");
        objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 736, CFSTR("Angle out of range"));
      }
    }
  }
}

double TSDEllipsePolarAngleWithParametricAngle(double a1, double a2, double a3)
{
  double result;

  if (a2 == 0.0 || a3 == 0.0)
    return 0.0;
  TSDEllipseParametricAngleWithPolarAngle(a1, 1.0 / a2, 1.0 / a3);
  return result;
}

BOOL triangleIsClockwise(CGPoint a1, CGPoint a2, CGPoint a3)
{
  float v3;
  float v4;
  float v5;

  v3 = a1.x * a2.y - a1.y * a2.x + 0.0;
  v4 = a2.x * a3.y - a2.y * a3.x + v3;
  v5 = a3.x * a1.y - a3.y * a1.x + v4;
  return v5 >= 0.0;
}

void sub_217A13148(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x219A153B8](v1, 0x1030C402473FF45);
  _Unwind_Resume(a1);
}

void sub_217A1335C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x219A153B8](v1, 0x1030C4099B07130);
  _Unwind_Resume(a1);
}

void sub_217A13808(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x219A153B8](v1, 0x1030C4099B07130);
  _Unwind_Resume(a1);
}

void sub_217A1404C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x219A153B8](v1, 0x1030C4099B07130);
  _Unwind_Resume(a1);
}

int *polygonFromBezier(void *a1)
{
  void *v1;
  size_t v2;
  int *v3;
  uint64_t v4;
  int v5;
  double v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  double v17[7];
  uint64_t v18;

  v1 = a1;
  v18 = *MEMORY[0x24BDAC8D0];
  if ((objc_msgSend(a1, "isFlat") & 1) == 0)
    v1 = (void *)objc_msgSend(v1, "bezierPathByFlatteningPath");
  v2 = objc_msgSend(v1, "elementCount");
  if (v2 == (int)v2)
  {
    v3 = (int *)malloc_type_calloc(1uLL, 0x18uLL, 0x1030040B05087B7uLL);
    if (v3 && (_DWORD)v2)
    {
      LODWORD(v15) = v2;
      v16 = malloc_type_calloc(0x10uLL, v2, 0x2D833B6EuLL);
      if ((int)v2 >= 1)
      {
        v4 = 0;
        v5 = 0;
        v6 = INFINITY;
        v7 = INFINITY;
        while (2)
        {
          switch(objc_msgSend(v1, "elementAtIndex:associatedPoints:", v4, v17, v15))
          {
            case 0:
              if (v5 >= 2)
              {
                LODWORD(v15) = v5;
                TSDgpc_add_contour(v3, (int *)&v15, 0);
                v5 = 0;
              }
              *((_OWORD *)v16 + v5) = *(_OWORD *)v17;
              v8 = *(_QWORD *)&v17[1];
              v9 = *(_QWORD *)&v17[0];
              goto LABEL_17;
            case 1:
              v8 = *(_QWORD *)&v17[1];
              v9 = *(_QWORD *)&v17[0];
              if (vabdd_f64(v17[0], v6) <= 0.699999988 && vabdd_f64(v17[1], v7) <= 0.699999988)
              {
                v11 = v5 - 1;
                v8 = *(_QWORD *)&v7;
                v9 = *(_QWORD *)&v6;
              }
              else
              {
                v10 = (char *)v16 + 16 * v5;
                *v10 = *(_QWORD *)&v17[0];
                v10[1] = v8;
LABEL_17:
                v11 = v5;
              }
LABEL_20:
              ++v4;
              v5 = v11 + 1;
              v6 = *(double *)&v9;
              v7 = *(double *)&v8;
              if (v2 != v4)
                continue;
              if (v11 >= 1)
              {
                LODWORD(v15) = v11 + 1;
                TSDgpc_add_contour(v3, (int *)&v15, 0);
              }
              break;
            case 2:
              NSLog((NSString *)CFSTR("Warning: Path should be flat. Illegal NSCurveToBezierPathElement."));
              goto LABEL_16;
            case 3:
              LODWORD(v15) = v5;
              TSDgpc_add_contour(v3, (int *)&v15, 0);
              v11 = -1;
              v8 = 0x7FF0000000000000;
              v9 = 0x7FF0000000000000;
              goto LABEL_20;
            default:
LABEL_16:
              v8 = *(_QWORD *)&v7;
              v9 = *(_QWORD *)&v6;
              goto LABEL_17;
          }
          break;
        }
      }
      free(v16);
    }
  }
  else
  {
    v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "gpc_polygon *polygonFromBezier(TSDBezierPath *)");
    objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2545, CFSTR("Out-of-bounds type assignment failed"));
    return 0;
  }
  return v3;
}

id bezierFromPolygon(int *a1)
{
  id v2;
  uint64_t v3;
  uint64_t v4;
  double **v5;
  double v6;
  double v7;

  v2 = +[TSDBezierPath bezierPath](TSDBezierPath, "bezierPath");
  if (*a1 >= 1)
  {
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = (double **)(*((_QWORD *)a1 + 2) + v3);
      boundsForVertexList((uint64_t)v5);
      if (v7 > 0.00999999978 && v6 > 0.00999999978)
        addVertexListToPath(v5, v2);
      ++v4;
      v3 += 16;
    }
    while (v4 < *a1);
  }
  return v2;
}

double boundsForVertexList(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  int v4;
  void *v5;
  uint64_t v6;
  double *v7;
  float v8;
  float v9;
  uint64_t v10;
  double *v11;
  uint64_t v12;
  float v13;
  float v14;
  double v15;
  double v16;
  double v17;
  float v18;

  if (!a1)
  {
    v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGRect boundsForVertexList(gpc_vertex_list *)");
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2647, CFSTR("Bad list ptr"));
  }
  v4 = *(_DWORD *)a1;
  if (*(int *)a1 < 1)
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGRect boundsForVertexList(gpc_vertex_list *)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2648, CFSTR("Bad vertex count"));
    v4 = *(_DWORD *)a1;
  }
  v7 = *(double **)(a1 + 8);
  v8 = *v7;
  v9 = v7[1];
  if (v4 <= 1)
  {
    return (float)*v7;
  }
  else
  {
    v10 = v4;
    v11 = v7 + 3;
    v12 = v10 - 1;
    v13 = v9;
    v14 = v8;
    do
    {
      v15 = *(v11 - 1);
      if (v15 <= v14)
        v14 = v15;
      if (v15 >= v8)
        v8 = v15;
      v16 = *v11;
      v11 += 2;
      v17 = v16;
      v18 = v16;
      if (v16 <= v13)
        v13 = v18;
      if (v17 >= v9)
        v9 = v18;
      --v12;
    }
    while (v12);
  }
  return v14;
}

uint64_t addVertexListToPath(double **a1, void *a2)
{
  uint64_t v4;
  uint64_t v5;

  objc_msgSend(a2, "moveToPoint:", *a1[1], a1[1][1]);
  if (*(int *)a1 >= 2)
  {
    v4 = 0;
    v5 = 1;
    do
    {
      objc_msgSend(a2, "lineToPoint:", a1[1][v4 + 2], a1[1][v4 + 3]);
      ++v5;
      v4 += 2;
    }
    while (v5 < *(int *)a1);
  }
  return objc_msgSend(a2, "closePath");
}

int *copyPolygon(int *a1)
{
  int *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = (int *)malloc_type_calloc(1uLL, 0x18uLL, 0x1030040B05087B7uLL);
  if (*a1 >= 1)
  {
    v3 = 0;
    v4 = 0;
    do
    {
      TSDgpc_add_contour(v2, (int *)(*((_QWORD *)a1 + 2) + v3), *(_DWORD *)(*((_QWORD *)a1 + 1) + 4 * v4++));
      v3 += 16;
    }
    while (v4 < *a1);
  }
  return v2;
}

int *validatePolygon(int *result, double a2)
{
  int *v2;
  void *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;

  v2 = result;
  if (*result <= 0)
  {
    v3 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v4 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void validatePolygon(gpc_polygon *)");
    result = (int *)objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2678, CFSTR("Bad contour count"));
  }
  if (!*((_QWORD *)v2 + 1))
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void validatePolygon(gpc_polygon *)");
    result = (int *)objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2679, CFSTR("Missing hole"));
  }
  if (!*((_QWORD *)v2 + 2))
  {
    v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void validatePolygon(gpc_polygon *)");
    result = (int *)objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2680, CFSTR("Bad contour ptr"));
  }
  if (*v2 >= 1)
  {
    v9 = 0;
    do
    {
      v10 = (int *)(*((_QWORD *)v2 + 2) + 16 * v9);
      if (*v10 <= 0)
      {
        v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void validatePolygon(gpc_polygon *)");
        result = (int *)objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2685, CFSTR("Bad vertex count"));
      }
      if (!*((_QWORD *)v10 + 1))
      {
        v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void validatePolygon(gpc_polygon *)");
        result = (int *)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2686, CFSTR("Bad vertex list"));
      }
      if (*v10 >= 1)
      {
        v15 = 0;
        v16 = 0;
        do
        {
          a2 = *(double *)(*((_QWORD *)v10 + 1) + v15 + 8);
          ++v16;
          v15 += 16;
        }
        while (v16 < *v10);
      }
      if (*(_DWORD *)(*((_QWORD *)v2 + 1) + 4 * v9) >= 2u)
      {
        v17 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler", a2);
        v18 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void validatePolygon(gpc_polygon *)");
        result = (int *)objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBezierPathAdditions.mm"), 2693, CFSTR("Bad flags"));
      }
      ++v9;
    }
    while (v9 < *v2);
  }
  return result;
}

void *gpc_malloc(size_t a1)
{
  void *v2;

  pthread_once(&gpc_malloc_once, (void (*)(void))initialize_blocks);
  pthread_mutex_lock(&gpc_malloc_lock);
  if (a1 <= 0x20 && first_free_block)
  {
    v2 = (void *)(first_free_block + 8);
    first_free_block = *(_QWORD *)first_free_block;
    pthread_mutex_unlock(&gpc_malloc_lock);
  }
  else
  {
    v2 = malloc_type_malloc(a1, 0x8E34E3BuLL);
    pthread_mutex_unlock(&gpc_malloc_lock);
    if (!v2)
      NSLog((NSString *)CFSTR("gpc_malloc allocation failure"));
  }
  return v2;
}

uint64_t initialize_blocks()
{
  uint64_t result;
  uint64_t v1;

  result = pthread_mutex_init(&gpc_malloc_lock, 0);
  if (!blocks)
  {
    result = (uint64_t)malloc_type_malloc(0x28000uLL, 0x102004065753CD5uLL);
    v1 = 0;
    blocks = result;
    first_free_block = result;
    do
    {
      *(_QWORD *)(result + v1) = result + v1 + 40;
      v1 += 40;
    }
    while (v1 != 163840);
    *(_QWORD *)(result + 163800) = 0;
  }
  return result;
}

void gpc_free(_QWORD *a1)
{
  if (a1)
  {
    if (blocks <= (unint64_t)a1 && blocks + 163840 > (unint64_t)a1)
    {
      pthread_mutex_lock(&gpc_malloc_lock);
      *(a1 - 1) = first_free_block;
      first_free_block = (uint64_t)(a1 - 1);
      pthread_mutex_unlock(&gpc_malloc_lock);
    }
    else
    {
      free(a1);
    }
  }
}

void AVLTree::AVLTree(AVLTree *this)
{
  uint64_t v1;

  DblLinked::DblLinked(this);
  *(_QWORD *)(v1 + 16) = 0;
  *(_QWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  *(_QWORD *)(v1 + 32) = 0;
}

{
  uint64_t v1;

  DblLinked::DblLinked(this);
  *(_QWORD *)(v1 + 16) = 0;
  *(_QWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  *(_QWORD *)(v1 + 32) = 0;
}

_QWORD *AVLTree::MakeNew(AVLTree *this)
{
  _QWORD *result;

  result = DblLinked::MakeNew(this);
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_QWORD *)this + 4) = 0;
  return result;
}

AVLTree *AVLTree::Leftmost(AVLTree *this)
{
  AVLTree *v1;

  do
  {
    v1 = this;
    this = (AVLTree *)*((_QWORD *)this + 3);
  }
  while (this);
  return v1;
}

AVLTree *AVLTree::LeftLeaf(AVLTree *this, AVLTree *a2, char a3)
{
  AVLTree *result;

  do
  {
    while (1)
    {
      while (1)
      {
        result = this;
        if ((a3 & 1) == 0)
          break;
        this = (AVLTree *)*((_QWORD *)this + 3);
        a3 = 1;
        a2 = result;
        if (!this)
          return result;
      }
      this = (AVLTree *)*((_QWORD *)this + 3);
      if (*((AVLTree **)result + 4) != a2)
        break;
      a3 = 1;
      a2 = result;
      if (!this)
        goto LABEL_6;
    }
    if (this != a2)
      return 0;
LABEL_6:
    a3 = 0;
    this = (AVLTree *)*((_QWORD *)result + 2);
    a2 = result;
  }
  while (this);
  return 0;
}

AVLTree *AVLTree::RightLeaf(AVLTree **this, AVLTree *a2, char a3)
{
  AVLTree *result;
  AVLTree *v5;

  do
  {
    while (1)
    {
      while (1)
      {
        result = (AVLTree *)this;
        if ((a3 & 1) == 0)
          break;
        this = (AVLTree **)this[4];
        a3 = 1;
        a2 = result;
        if (!this)
          return result;
      }
      v5 = this[3];
      this = (AVLTree **)this[4];
      if (v5 != a2)
        break;
      a3 = 1;
      a2 = result;
      if (!this)
        goto LABEL_6;
    }
    if (this != (AVLTree **)a2)
      return 0;
LABEL_6:
    a3 = 0;
    this = (AVLTree **)*((_QWORD *)result + 2);
    a2 = result;
  }
  while (this);
  return 0;
}

uint64_t AVLTree::RestoreBalances(uint64_t this, AVLTree *a2, AVLTree **a3)
{
  AVLTree *v3;
  int v4;
  AVLTree *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  AVLTree *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;

  while (1)
  {
    v3 = (AVLTree *)this;
    if (a2)
      break;
LABEL_7:
    this = *(_QWORD *)(this + 16);
    a2 = v3;
    if (!this)
      return this;
  }
  v4 = *(_DWORD *)(this + 40);
  if (!v4)
  {
    if (*(AVLTree **)(this + 24) == a2)
      *(_DWORD *)(this + 40) = 1;
    if (*(AVLTree **)(this + 32) == a2)
      *(_DWORD *)(this + 40) = -1;
    goto LABEL_7;
  }
  if (v4 < 1)
  {
    v10 = *(AVLTree **)(this + 24);
    if (v10 != a2)
    {
      v6 = *(_QWORD *)(this + 32);
      if (v6)
      {
        v11 = *(_QWORD *)(v6 + 24);
        v12 = *(_QWORD *)(v6 + 32);
        v13 = *(_QWORD *)(this + 16);
        if ((*(_DWORD *)(v6 + 40) & 0x80000000) != 0)
        {
          *(_QWORD *)(v6 + 24) = this;
          *(_QWORD *)(this + 16) = v6;
          *(_QWORD *)(this + 24) = v10;
          if (v10)
            *((_QWORD *)v10 + 2) = this;
          *(_QWORD *)(this + 32) = v11;
          if (v11)
            *(_QWORD *)(v11 + 16) = this;
          *(_QWORD *)(v6 + 32) = v12;
          if (v12)
            *(_QWORD *)(v12 + 16) = v6;
          *(_QWORD *)(v6 + 16) = v13;
          if (v13)
          {
            if (*(_QWORD *)(v13 + 24) == this)
              *(_QWORD *)(v13 + 24) = v6;
            if (*(_QWORD *)(v13 + 32) == this)
              *(_QWORD *)(v13 + 32) = v6;
          }
LABEL_78:
          if (*a3 == (AVLTree *)this)
            *a3 = (AVLTree *)v6;
          goto LABEL_80;
        }
        if (v11)
        {
          v15 = *(_QWORD *)(v11 + 24);
          v14 = *(_QWORD *)(v11 + 32);
          *(_QWORD *)(this + 16) = v11;
          *(_QWORD *)(v6 + 16) = v11;
          *(_QWORD *)(v11 + 24) = this;
          *(_QWORD *)(v11 + 32) = v6;
          *(_QWORD *)(this + 32) = v15;
          if (v15)
            *(_QWORD *)(v15 + 16) = this;
          *(_QWORD *)(this + 24) = v10;
          if (v10)
            *((_QWORD *)v10 + 2) = this;
          *(_QWORD *)(v6 + 32) = v12;
          if (v12)
            *(_QWORD *)(v12 + 16) = v6;
          *(_QWORD *)(v6 + 24) = v14;
          if (v14)
            *(_QWORD *)(v14 + 16) = v6;
          *(_QWORD *)(v11 + 16) = v13;
          if (v13)
          {
            if (*(_QWORD *)(v13 + 24) == this)
              *(_QWORD *)(v13 + 24) = v11;
            if (*(_QWORD *)(v13 + 32) == this)
              *(_QWORD *)(v13 + 32) = v11;
          }
          if (*a3 == (AVLTree *)this)
            *a3 = (AVLTree *)v11;
          v16 = *(_DWORD *)(v11 + 40);
          *(_DWORD *)(v11 + 40) = 0;
          if (v16)
          {
            if (v16 >= 1)
            {
              this = 0;
              *((_DWORD *)v3 + 10) = 0;
              v17 = -1;
              goto LABEL_85;
            }
            this = 0;
            v22 = 1;
LABEL_83:
            *((_DWORD *)v3 + 10) = v22;
            goto LABEL_81;
          }
LABEL_80:
          this = 0;
          *((_DWORD *)v3 + 10) = 0;
LABEL_81:
          *(_DWORD *)(v6 + 40) = 0;
          return this;
        }
      }
      return 1;
    }
LABEL_46:
    this = 0;
    *((_DWORD *)v3 + 10) = 0;
    return this;
  }
  v5 = *(AVLTree **)(this + 32);
  if (v5 == a2)
    goto LABEL_46;
  v6 = *(_QWORD *)(this + 24);
  if (!v6)
    return 1;
  v8 = *(_QWORD *)(v6 + 24);
  v7 = *(_QWORD *)(v6 + 32);
  if (*(int *)(v6 + 40) >= 1)
  {
    v9 = *(_QWORD *)(this + 16);
    *(_QWORD *)(this + 16) = v6;
    *(_QWORD *)(v6 + 32) = this;
    *(_QWORD *)(this + 32) = v5;
    if (v5)
      *((_QWORD *)v5 + 2) = this;
    *(_QWORD *)(this + 24) = v7;
    if (v7)
      *(_QWORD *)(v7 + 16) = this;
    *(_QWORD *)(v6 + 24) = v8;
    if (v8)
      *(_QWORD *)(v8 + 16) = v6;
    *(_QWORD *)(v6 + 16) = v9;
    if (v9)
    {
      if (*(_QWORD *)(v9 + 24) == this)
        *(_QWORD *)(v9 + 24) = v6;
      if (*(_QWORD *)(v9 + 32) == this)
        *(_QWORD *)(v9 + 32) = v6;
    }
    goto LABEL_78;
  }
  if (!v7)
    return 1;
  v18 = *(_QWORD *)(v7 + 24);
  v19 = *(_QWORD *)(v7 + 32);
  v20 = *(_QWORD *)(this + 16);
  *(_QWORD *)(v7 + 24) = v6;
  *(_QWORD *)(v7 + 32) = this;
  *(_QWORD *)(this + 16) = v7;
  *(_QWORD *)(v6 + 16) = v7;
  *(_QWORD *)(this + 24) = v19;
  if (v19)
    *(_QWORD *)(v19 + 16) = this;
  *(_QWORD *)(this + 32) = v5;
  if (v5)
    *((_QWORD *)v5 + 2) = this;
  *(_QWORD *)(v6 + 24) = v8;
  if (v8)
    *(_QWORD *)(v8 + 16) = v6;
  *(_QWORD *)(v6 + 32) = v18;
  if (v18)
    *(_QWORD *)(v18 + 16) = v6;
  *(_QWORD *)(v7 + 16) = v20;
  if (v20)
  {
    if (*(_QWORD *)(v20 + 24) == this)
      *(_QWORD *)(v20 + 24) = v7;
    if (*(_QWORD *)(v20 + 32) == this)
      *(_QWORD *)(v20 + 32) = v7;
  }
  if (*a3 == (AVLTree *)this)
    *a3 = (AVLTree *)v7;
  v21 = *(_DWORD *)(v7 + 40);
  *(_DWORD *)(v7 + 40) = 0;
  if (!v21)
    goto LABEL_80;
  if (v21 >= 1)
  {
    this = 0;
    v22 = -1;
    goto LABEL_83;
  }
  this = 0;
  *((_DWORD *)v3 + 10) = 0;
  v17 = 1;
LABEL_85:
  *(_DWORD *)(v6 + 40) = v17;
  return this;
}

uint64_t AVLTree::RestoreBalances(uint64_t this, int a2, AVLTree **a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  int v19;

  while (1)
  {
    while (1)
    {
      v3 = this;
      v4 = *(_DWORD *)(this + 40);
      if (v4 < 1)
        break;
      if (a2 < 0)
      {
LABEL_26:
        *(_DWORD *)(this + 40) = 0;
        this = *(_QWORD *)(this + 16);
        if (!this)
          return this;
        a2 = 1;
        if (*(_QWORD *)(this + 32) != v3)
        {
          v5 = *(_QWORD *)(this + 24);
          goto LABEL_29;
        }
      }
      else
      {
        if (!a2)
          return 0;
        v5 = *(_QWORD *)(this + 24);
        if (!v5)
          return 1;
        this = *(_QWORD *)(this + 16);
        v6 = *(_QWORD *)(v3 + 32);
        v8 = *(_QWORD *)(v5 + 24);
        v7 = *(_QWORD *)(v5 + 32);
        v9 = *(_DWORD *)(v5 + 40);
        if (v9 < 1)
        {
          if (!v9)
          {
            *(_QWORD *)(v5 + 32) = v3;
            *(_QWORD *)(v3 + 24) = v7;
            *(_QWORD *)(v3 + 32) = v6;
            *(_QWORD *)(v3 + 16) = v5;
            if (v8)
              *(_QWORD *)(v8 + 16) = v5;
            if (v6)
              *(_QWORD *)(v6 + 16) = v3;
            if (v7)
              *(_QWORD *)(v7 + 16) = v3;
            *(_QWORD *)(v5 + 16) = this;
            if (this)
            {
              if (*(_QWORD *)(this + 24) == v3)
                *(_QWORD *)(this + 24) = v5;
              if (*(_QWORD *)(this + 32) == v3)
                *(_QWORD *)(this + 32) = v5;
            }
            if (*a3 == (AVLTree *)v3)
              *a3 = (AVLTree *)v5;
            *(_DWORD *)(v5 + 40) = -1;
LABEL_97:
            v19 = 1;
            goto LABEL_113;
          }
          if (!v7)
            return 1;
          v10 = *(_QWORD *)(v7 + 24);
          v11 = *(_QWORD *)(v7 + 32);
          *(_QWORD *)(v7 + 24) = v5;
          *(_QWORD *)(v7 + 32) = v3;
          *(_QWORD *)(v3 + 24) = v11;
          *(_QWORD *)(v3 + 32) = v6;
          *(_QWORD *)(v5 + 24) = v8;
          *(_QWORD *)(v5 + 32) = v10;
          if (v6)
            *(_QWORD *)(v6 + 16) = v3;
          if (v11)
            *(_QWORD *)(v11 + 16) = v3;
          if (v8)
            *(_QWORD *)(v8 + 16) = v5;
          if (v10)
            *(_QWORD *)(v10 + 16) = v5;
          *(_QWORD *)(v3 + 16) = v7;
          *(_QWORD *)(v5 + 16) = v7;
          *(_QWORD *)(v7 + 16) = this;
          if (this)
          {
            if (*(_QWORD *)(this + 24) == v3)
              *(_QWORD *)(this + 24) = v7;
            if (*(_QWORD *)(this + 32) == v3)
              *(_QWORD *)(this + 32) = v7;
          }
          if (*a3 == (AVLTree *)v3)
            *a3 = (AVLTree *)v7;
          v12 = *(_DWORD *)(v7 + 40);
          *(_DWORD *)(v7 + 40) = 0;
          if (v12 < 1)
          {
            v13 = v12 != 0;
            *(_DWORD *)(v3 + 40) = 0;
          }
          else
          {
            v13 = 0;
            *(_DWORD *)(v3 + 40) = -1;
          }
          goto LABEL_75;
        }
        *(_QWORD *)(v5 + 32) = v3;
        *(_QWORD *)(v3 + 24) = v7;
        *(_QWORD *)(v3 + 32) = v6;
LABEL_7:
        *(_QWORD *)(v3 + 16) = v5;
        if (v8)
          *(_QWORD *)(v8 + 16) = v5;
        if (v6)
          *(_QWORD *)(v6 + 16) = v3;
        if (v7)
          *(_QWORD *)(v7 + 16) = v3;
        *(_QWORD *)(v5 + 16) = this;
        if (this)
        {
          if (*(_QWORD *)(this + 24) == v3)
            *(_QWORD *)(this + 24) = v5;
          if (*(_QWORD *)(this + 32) == v3)
            *(_QWORD *)(this + 32) = v5;
        }
        if (*a3 == (AVLTree *)v3)
          *a3 = (AVLTree *)v5;
        *(_DWORD *)(v5 + 40) = 0;
        *(_DWORD *)(v3 + 40) = 0;
        if (!this)
          return this;
        a2 = 1;
        if (v5 != *(_QWORD *)(this + 32))
        {
          v3 = *(_QWORD *)(this + 24);
LABEL_29:
          a2 = -1;
          if (v5 != v3)
            return 0;
        }
      }
    }
    if (!v4)
      break;
    if ((a2 & 0x80000000) == 0)
    {
      if (!a2)
        return 0;
      goto LABEL_26;
    }
    v5 = *(_QWORD *)(this + 32);
    if (!v5)
      return 1;
    this = *(_QWORD *)(this + 16);
    v6 = *(_QWORD *)(v3 + 24);
    v7 = *(_QWORD *)(v5 + 24);
    v8 = *(_QWORD *)(v5 + 32);
    v14 = *(_DWORD *)(v5 + 40);
    if (v14 < 0)
    {
      *(_QWORD *)(v5 + 24) = v3;
      *(_QWORD *)(v3 + 24) = v6;
      *(_QWORD *)(v3 + 32) = v7;
      goto LABEL_7;
    }
    if (!v14)
    {
      *(_QWORD *)(v5 + 24) = v3;
      *(_QWORD *)(v3 + 24) = v6;
      *(_QWORD *)(v3 + 32) = v7;
      *(_QWORD *)(v3 + 16) = v5;
      if (v8)
        *(_QWORD *)(v8 + 16) = v5;
      if (v6)
        *(_QWORD *)(v6 + 16) = v3;
      if (v7)
        *(_QWORD *)(v7 + 16) = v3;
      *(_QWORD *)(v5 + 16) = this;
      if (this)
      {
        if (*(_QWORD *)(this + 24) == v3)
          *(_QWORD *)(this + 24) = v5;
        if (*(_QWORD *)(this + 32) == v3)
          *(_QWORD *)(this + 32) = v5;
      }
      if (*a3 == (AVLTree *)v3)
        *a3 = (AVLTree *)v5;
      *(_DWORD *)(v5 + 40) = 1;
      goto LABEL_112;
    }
    if (!v7)
      return 1;
    v16 = *(_QWORD *)(v7 + 24);
    v15 = *(_QWORD *)(v7 + 32);
    *(_QWORD *)(v7 + 24) = v3;
    *(_QWORD *)(v7 + 32) = v5;
    *(_QWORD *)(v3 + 24) = v6;
    *(_QWORD *)(v3 + 32) = v16;
    *(_QWORD *)(v5 + 24) = v15;
    *(_QWORD *)(v5 + 32) = v8;
    if (v6)
      *(_QWORD *)(v6 + 16) = v3;
    if (v16)
      *(_QWORD *)(v16 + 16) = v3;
    if (v8)
      *(_QWORD *)(v8 + 16) = v5;
    if (v15)
      *(_QWORD *)(v15 + 16) = v5;
    *(_QWORD *)(v3 + 16) = v7;
    *(_QWORD *)(v5 + 16) = v7;
    *(_QWORD *)(v7 + 16) = this;
    if (this)
    {
      if (*(_QWORD *)(this + 24) == v3)
        *(_QWORD *)(this + 24) = v7;
      if (*(_QWORD *)(this + 32) == v3)
        *(_QWORD *)(this + 32) = v7;
    }
    if (*a3 == (AVLTree *)v3)
      *a3 = (AVLTree *)v7;
    v17 = *(_DWORD *)(v7 + 40);
    *(_DWORD *)(v7 + 40) = 0;
    v18 = v17 >> 31;
    if (v17 <= 0)
      v13 = 0;
    else
      v13 = -1;
    *(_DWORD *)(v3 + 40) = v18;
LABEL_75:
    *(_DWORD *)(v5 + 40) = v13;
    if (!this)
      return this;
    a2 = 1;
    if (v7 != *(_QWORD *)(this + 32))
    {
      a2 = -1;
      if (v7 != *(_QWORD *)(this + 24))
        return 0;
    }
  }
  if ((a2 & 0x80000000) == 0)
  {
    if (!a2)
      return 0;
    goto LABEL_97;
  }
LABEL_112:
  v19 = -1;
LABEL_113:
  this = 0;
  *(_DWORD *)(v3 + 40) = v19;
  return this;
}

uint64_t AVLTree::Remove(AVLTree *this, AVLTree **a2, int a3)
{
  uint64_t result;
  int v6;
  AVLTree *v7;

  v7 = 0;
  v6 = 0;
  result = AVLTree::Remove(this, a2, &v7, &v6);
  if (!(_DWORD)result && a3)
  {
    if (v7)
      return AVLTree::RestoreBalances((uint64_t)v7, v6, a2);
  }
  return result;
}

uint64_t AVLTree::Remove(AVLTree *this, AVLTree **a2, AVLTree **a3, int *a4)
{
  uint64_t v8;
  AVLTree *v9;
  uint64_t v10;
  uint64_t v11;
  AVLTree *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  AVLTree *v18;
  AVLTree *v19;
  AVLTree *v20;
  AVLTree *v21;
  uint64_t v22;
  AVLTree *v23;
  AVLTree *v24;

  DblLinked::Extract((uint64_t *)this);
  v9 = (AVLTree *)*((_QWORD *)this + 3);
  v8 = *((_QWORD *)this + 4);
  if (v9)
  {
    if (v8)
    {
      v10 = *((_QWORD *)this + 3);
      do
      {
        v11 = v10;
        v10 = *(_QWORD *)(v10 + 32);
      }
      while (v10);
      if ((AVLTree *)v11 == v9)
      {
        *a3 = v9;
        *a4 = -1;
        *(_QWORD *)(v11 + 32) = *((_QWORD *)this + 4);
        *(_QWORD *)(*((_QWORD *)this + 4) + 16) = v9;
        *((_QWORD *)v9 + 2) = *((_QWORD *)this + 2);
        v22 = *((_QWORD *)this + 2);
        if (v22)
        {
          if (*(AVLTree **)(v22 + 24) == this)
            *(_QWORD *)(v22 + 24) = v9;
          if (*(AVLTree **)(v22 + 32) == this)
            *(_QWORD *)(v22 + 32) = v9;
        }
      }
      else
      {
        v12 = *(AVLTree **)(v11 + 16);
        *a3 = v12;
        *a4 = 1;
        v13 = *(_QWORD *)(v11 + 24);
        *((_QWORD *)v12 + 4) = v13;
        if (v13)
          *(_QWORD *)(v13 + 16) = v12;
        *(_OWORD *)(v11 + 16) = *((_OWORD *)this + 1);
        *(_QWORD *)(v11 + 32) = *((_QWORD *)this + 4);
        v14 = *((_QWORD *)this + 2);
        if (v14)
        {
          if (*(AVLTree **)(v14 + 24) == this)
            *(_QWORD *)(v14 + 24) = v11;
          if (*(AVLTree **)(v14 + 32) == this)
            *(_QWORD *)(v14 + 32) = v11;
        }
        v15 = *((_QWORD *)this + 3);
        if (v15)
          *(_QWORD *)(v15 + 16) = v11;
        v16 = *((_QWORD *)this + 4);
        if (v16)
          *(_QWORD *)(v16 + 16) = v11;
      }
      *(_DWORD *)(v11 + 40) = *((_DWORD *)this + 10);
      goto LABEL_57;
    }
    *a3 = (AVLTree *)*((_QWORD *)this + 2);
    *a4 = 0;
    v17 = *((_QWORD *)this + 2);
    if (v17)
    {
      v20 = *(AVLTree **)(v17 + 24);
      if (v20 == this)
        *a4 = -1;
      v21 = *(AVLTree **)(v17 + 32);
      if (v21 == this)
        *a4 = 1;
      if (v20 == this)
        *(_QWORD *)(v17 + 24) = *((_QWORD *)this + 3);
      v11 = *((_QWORD *)this + 3);
      if (v21 == this)
        *(_QWORD *)(v17 + 32) = v11;
    }
    else
    {
      v11 = *((_QWORD *)this + 3);
    }
LABEL_55:
    if (*(AVLTree **)(v11 + 16) == this)
      *(_QWORD *)(v11 + 16) = v17;
LABEL_57:
    if (*a2 == this)
      goto LABEL_58;
    goto LABEL_59;
  }
  *a3 = (AVLTree *)*((_QWORD *)this + 2);
  *a4 = 0;
  v17 = *((_QWORD *)this + 2);
  if (v8)
  {
    if (v17)
    {
      v18 = *(AVLTree **)(v17 + 24);
      if (v18 == this)
        *a4 = -1;
      v19 = *(AVLTree **)(v17 + 32);
      if (v19 == this)
        *a4 = 1;
      if (v18 == this)
        *(_QWORD *)(v17 + 24) = *((_QWORD *)this + 4);
      if (v19 == this)
        *(_QWORD *)(v17 + 32) = *((_QWORD *)this + 4);
    }
    v11 = *((_QWORD *)this + 4);
    goto LABEL_55;
  }
  if (v17)
  {
    v23 = *(AVLTree **)(v17 + 24);
    if (v23 == this)
      *a4 = -1;
    v24 = *(AVLTree **)(v17 + 32);
    if (v24 == this)
      *a4 = 1;
    if (v23 == this)
      *(_QWORD *)(v17 + 24) = 0;
    if (v24 == this)
      *(_QWORD *)(v17 + 32) = 0;
  }
  if (*a2 == this)
  {
    v11 = 0;
LABEL_58:
    *a2 = (AVLTree *)v11;
  }
LABEL_59:
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_QWORD *)this + 4) = 0;
  return 0;
}

uint64_t AVLTree::Insert(AVLTree *this, AVLTree **a2, int a3, AVLTree *a4, AVLTree *a5, int a6)
{
  uint64_t result;

  result = AVLTree::Insert(this, a2, a3, a4, a5);
  if (!(_DWORD)result)
  {
    if (a6)
      return AVLTree::RestoreBalances((uint64_t)this, 0, a2);
  }
  return result;
}

uint64_t AVLTree::Insert(AVLTree *this, AVLTree **a2, int a3, AVLTree *a4, AVLTree *a5)
{
  uint64_t v5;
  AVLTree *v6;
  AVLTree *v7;
  DblLinked *v8;
  char *v9;
  AVLTree *v10;

  v5 = (uint64_t)*a2;
  if (*a2)
  {
    switch(a3)
    {
      case 1:
        if (!a4)
          return 3;
        v6 = (AVLTree *)*((_QWORD *)a4 + 4);
        if (v6)
        {
          do
          {
            v7 = v6;
            v6 = (AVLTree *)*((_QWORD *)v6 + 3);
          }
          while (v6);
          *((_QWORD *)v7 + 3) = this;
          *((_QWORD *)this + 2) = v7;
          v8 = *(DblLinked **)v7;
        }
        else
        {
          *((_QWORD *)a4 + 4) = this;
          *((_QWORD *)this + 2) = a4;
          v7 = (AVLTree *)*((_QWORD *)a4 + 1);
          v8 = a4;
        }
        goto LABEL_23;
      case 2:
        if (!a5 || *((_QWORD *)a5 + 3))
          return 3;
        *((_QWORD *)a5 + 3) = this;
        *((_QWORD *)this + 2) = a5;
        DblLinked::InsertOnLeft((uint64_t)this, a5);
        goto LABEL_24;
      case 3:
        if (!a4 || *((_QWORD *)a4 + 4))
          return 3;
        *((_QWORD *)a4 + 4) = this;
        *((_QWORD *)this + 2) = a4;
        DblLinked::InsertOnRight(this, a4);
        goto LABEL_24;
      case 4:
        v5 = 3;
        if (!a4 || !a5)
          return v5;
        v9 = (char *)a5 + 24;
        if (*((_QWORD *)a5 + 3))
        {
          v9 = (char *)a4 + 32;
          if (*((_QWORD *)a4 + 4))
            return 3;
          v10 = a4;
        }
        else
        {
          v10 = a5;
        }
        *(_QWORD *)v9 = this;
        *((_QWORD *)this + 2) = v10;
        v8 = a4;
        v7 = a5;
LABEL_23:
        DblLinked::InsertBetween(this, v8, v7);
LABEL_24:
        v5 = 0;
        break;
      default:
        return 3;
    }
  }
  else
  {
    *a2 = this;
  }
  return v5;
}

uint64_t *AVLTree::Relocate(AVLTree *this, AVLTree *a2)
{
  uint64_t *result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = DblLinked::Relocate((uint64_t *)this, a2);
  v5 = *((_QWORD *)this + 2);
  if (v5)
  {
    if (*(AVLTree **)(v5 + 24) == this)
      *(_QWORD *)(v5 + 24) = a2;
    if (*(AVLTree **)(v5 + 32) == this)
      *(_QWORD *)(v5 + 32) = a2;
  }
  v6 = *((_QWORD *)this + 4);
  if (v6)
    *(_QWORD *)(v6 + 16) = a2;
  v7 = *((_QWORD *)this + 3);
  if (v7)
    *(_QWORD *)(v7 + 16) = a2;
  v8 = *((_QWORD *)this + 2);
  *((_QWORD *)a2 + 3) = v7;
  *((_QWORD *)a2 + 4) = v6;
  *((_QWORD *)a2 + 2) = v8;
  return result;
}

void DblLinked::DblLinked(DblLinked *this)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
}

{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
}

_QWORD *DblLinked::MakeNew(_QWORD *this)
{
  *this = 0;
  this[1] = 0;
  return this;
}

void DblLinked::~DblLinked(DblLinked *this)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = *(_QWORD *)this;
  if (*(_QWORD *)this)
    *(_QWORD *)(v1 + 8) = *((_QWORD *)this + 1);
  v2 = (_QWORD *)*((_QWORD *)this + 1);
  if (v2)
    *v2 = v1;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
}

{
  uint64_t v1;
  _QWORD *v2;

  v1 = *(_QWORD *)this;
  if (*(_QWORD *)this)
    *(_QWORD *)(v1 + 8) = *((_QWORD *)this + 1);
  v2 = (_QWORD *)*((_QWORD *)this + 1);
  if (v2)
    *v2 = v1;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
}

uint64_t *DblLinked::MakeDelete(uint64_t *this)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = *this;
  if (*this)
    *(_QWORD *)(v1 + 8) = this[1];
  v2 = (_QWORD *)this[1];
  if (v2)
    *v2 = v1;
  *this = 0;
  this[1] = 0;
  return this;
}

uint64_t *DblLinked::Extract(uint64_t *this)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = *this;
  if (*this)
    *(_QWORD *)(v1 + 8) = this[1];
  v2 = (_QWORD *)this[1];
  if (v2)
    *v2 = v1;
  *this = 0;
  this[1] = 0;
  return this;
}

uint64_t DblLinked::InsertOnLeft(uint64_t this, DblLinked *a2)
{
  *(_QWORD *)(this + 8) = a2;
  if (a2)
    *(_QWORD *)a2 = this;
  return this;
}

_QWORD *DblLinked::InsertOnRight(_QWORD *this, DblLinked *a2)
{
  *this = a2;
  if (a2)
    *((_QWORD *)a2 + 1) = this;
  return this;
}

_QWORD *DblLinked::InsertBetween(_QWORD *this, DblLinked *a2, DblLinked *a3)
{
  if (a2)
    *((_QWORD *)a2 + 1) = this;
  if (a3)
    *(_QWORD *)a3 = this;
  *this = a2;
  this[1] = a3;
  return this;
}

uint64_t *DblLinked::Relocate(uint64_t *this, DblLinked *a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *this;
  if (*this)
    *(_QWORD *)(v2 + 8) = a2;
  v3 = (_QWORD *)this[1];
  if (v3)
  {
    *v3 = a2;
    v2 = *this;
  }
  *(_QWORD *)a2 = v2;
  *((_QWORD *)a2 + 1) = v3;
  return this;
}

void FloatLigne::FloatLigne(FloatLigne *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_QWORD *)this + 4) = -1;
  *((_QWORD *)this + 5) = -1;
}

{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_QWORD *)this + 4) = -1;
  *((_QWORD *)this + 5) = -1;
}

void FloatLigne::~FloatLigne(void **this)
{
  if (*((int *)this + 1) >= 1)
  {
    free(this[1]);
    *this = 0;
    this[1] = 0;
  }
  if (*((int *)this + 5) >= 1)
  {
    free(this[3]);
    this[2] = 0;
    this[3] = 0;
  }
}

uint64_t FloatLigne::Reset(uint64_t this)
{
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 32) = -1;
  *(_QWORD *)(this + 40) = -1;
  return this;
}

uint64_t FloatLigne::AddBord(FloatLigne *this, float a2, float a3, float a4, float a5, signed int a6)
{
  signed int v12;
  int v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  float v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  float v22;

  if (a2 >= a4)
    return 0xFFFFFFFFLL;
  v12 = *(_DWORD *)this;
  v13 = *(_DWORD *)this + 1;
  if (v13 >= *((_DWORD *)this + 1))
  {
    v16 = 2 * v12 + 2;
    *((_DWORD *)this + 1) = v16;
    v14 = (char *)malloc_type_realloc(*((void **)this + 1), 44 * v16, 0x10000402DEC8469uLL);
    *((_QWORD *)this + 1) = v14;
    v12 = *(_DWORD *)this;
    v13 = *(_DWORD *)this + 1;
  }
  else
  {
    v14 = (char *)*((_QWORD *)this + 1);
  }
  *(_DWORD *)this = v13;
  v17 = &v14[44 * v12];
  *(float *)v17 = a2;
  v17[4] = 1;
  *((_DWORD *)v17 + 4) = v13;
  v18 = (float)(a5 - a3) / (float)(a4 - a2);
  if (v12 <= a6)
    v19 = -1;
  else
    v19 = a6;
  *((float *)v17 + 2) = a3;
  *((float *)v17 + 3) = v18;
  *(_QWORD *)(v17 + 20) = -1;
  *(_QWORD *)(v17 + 28) = -1;
  FloatLigne::InsertBord((uint64_t)this, v12, v18, v19);
  v15 = *(int *)this;
  *(_DWORD *)this = v15 + 1;
  v20 = *((_QWORD *)this + 1);
  v21 = v20 + 44 * (int)v15;
  *(float *)v21 = a4;
  *(_BYTE *)(v21 + 4) = 0;
  *(_DWORD *)(v21 + 16) = v15 - 1;
  v22 = *(float *)(v20 + 44 * ((int)v15 - 1) + 12);
  *(float *)(v21 + 8) = a5;
  *(float *)(v21 + 12) = v22;
  *(_QWORD *)(v21 + 20) = -1;
  *(_QWORD *)(v21 + 28) = -1;
  FloatLigne::InsertBord((uint64_t)this, v15, v22, v15 - 1);
  return v15;
}

uint64_t FloatLigne::InsertBord(uint64_t this, unsigned int a2, float a3, unsigned int a4)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  float v8;
  float v9;
  uint64_t v10;
  float v11;
  float v12;
  BOOL v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  float v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  float v24;
  BOOL v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  unsigned int *v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int v34;

  if ((a2 & 0x80000000) != 0)
    return this;
  v4 = *(_DWORD *)this;
  if (*(_DWORD *)this <= (signed int)a2)
    return this;
  v5 = *(_DWORD *)(this + 40);
  if ((v5 & 0x80000000) != 0)
  {
    *(_DWORD *)(this + 40) = a2;
    *(_DWORD *)(this + 44) = a2;
    *(_QWORD *)(*(_QWORD *)(this + 8) + 44 * a2 + 28) = -1;
    return this;
  }
  v6 = a4;
  if ((a4 & 0x80000000) != 0 || v4 <= (int)a4)
  {
    while ((int)v5 < v4)
    {
      v10 = *(_QWORD *)(this + 8);
      v11 = *(float *)(v10 + 44 * v5);
      v12 = *(float *)(v10 + 44 * a2);
      if (v11 == v12)
      {
        if (*(_BYTE *)(v10 + 44 * v5 + 4))
          v13 = 1;
        else
          v13 = *(_BYTE *)(v10 + 44 * a2 + 4) == 0;
        if (v13)
        {
LABEL_33:
          v19 = *(_QWORD *)(this + 8);
          v20 = v19 + 44 * v5;
          v23 = *(_DWORD *)(v20 + 28);
          v21 = (unsigned int *)(v20 + 28);
          v22 = v23;
          *(_DWORD *)(v19 + 44 * a2 + 28) = v23;
          if ((v23 & 0x80000000) != 0)
            *(_DWORD *)(this + 40) = a2;
          else
            *(_DWORD *)(v19 + 44 * v22 + 32) = a2;
          *(_DWORD *)(v19 + 44 * a2 + 32) = v5;
          *v21 = a2;
          return this;
        }
      }
      else if (v11 >= v12)
      {
        goto LABEL_33;
      }
      v5 = *(_DWORD *)(v10 + 44 * v5 + 32);
      if ((v5 & 0x80000000) != 0)
        break;
    }
    v14 = *(_DWORD *)(this + 44);
    v15 = *(_QWORD *)(this + 8);
    *(_DWORD *)(v15 + 44 * a2 + 28) = v14;
    v16 = v15 + 44 * v14;
LABEL_47:
    *(_DWORD *)(v16 + 32) = a2;
    *(_DWORD *)(this + 44) = a2;
    return this;
  }
  v7 = *(_QWORD *)(this + 8);
  v8 = *(float *)(v7 + 44 * a4);
  v9 = *(float *)(v7 + 44 * a2);
  if (v8 != v9)
  {
    if (v8 >= v9)
      goto LABEL_23;
LABEL_36:
    while ((int)v6 < v4)
    {
      v24 = *(float *)(v7 + 44 * v6);
      if (v24 == v9)
      {
        if (*(_BYTE *)(v7 + 44 * v6 + 4))
          v25 = 1;
        else
          v25 = *(_BYTE *)(v7 + 44 * a2 + 4) == 0;
        if (v25)
        {
LABEL_55:
          v27 = v7 + 44 * v6;
          goto LABEL_56;
        }
      }
      else if (v24 >= v9)
      {
        goto LABEL_55;
      }
      v6 = *(unsigned int *)(v7 + 44 * v6 + 32);
      if ((v6 & 0x80000000) != 0)
        break;
    }
    v26 = *(_DWORD *)(this + 44);
    *(_DWORD *)(v7 + 44 * a2 + 28) = v26;
    v16 = v7 + 44 * v26;
    goto LABEL_47;
  }
  if (*(_BYTE *)(v7 + 44 * a4 + 4))
  {
    if (!*(_BYTE *)(v7 + 44 * a2 + 4))
    {
      while (1)
      {
LABEL_23:
        if ((int)v6 >= v4)
        {
LABEL_32:
          *(_DWORD *)(v7 + 44 * a2 + 32) = v5;
          *(_DWORD *)(v7 + 44 * (int)v5 + 28) = a2;
          *(_DWORD *)(this + 40) = a2;
          return this;
        }
        v17 = *(float *)(v7 + 44 * v6);
        if (v17 == v9)
        {
          if (*(_BYTE *)(v7 + 44 * v6 + 4))
            v18 = *(_BYTE *)(v7 + 44 * a2 + 4) == 0;
          else
            v18 = 0;
          if (!v18)
          {
LABEL_50:
            v28 = v7 + 44 * v6;
            v29 = *(_DWORD *)(v28 + 32);
            v30 = v7 + 44 * a2;
            *(_DWORD *)(v30 + 32) = v29;
            v31 = (unsigned int *)(v7 + 44 * v29 + 28);
            if (v29 < 0)
              v31 = (unsigned int *)(this + 44);
            *v31 = a2;
            *(_DWORD *)(v30 + 28) = v6;
            *(_DWORD *)(v28 + 32) = a2;
            return this;
          }
        }
        else if (v17 < v9)
        {
          goto LABEL_50;
        }
        v6 = *(unsigned int *)(v7 + 44 * v6 + 28);
        if ((v6 & 0x80000000) != 0)
          goto LABEL_32;
      }
    }
  }
  else if (*(_BYTE *)(v7 + 44 * a2 + 4))
  {
    goto LABEL_36;
  }
  v27 = v7 + 44 * a4;
LABEL_56:
  v34 = *(_DWORD *)(v27 + 28);
  v32 = (unsigned int *)(v27 + 28);
  v33 = v34;
  *(_DWORD *)(v7 + 44 * a2 + 28) = v34;
  if ((v34 & 0x80000000) != 0)
    *(_DWORD *)(this + 40) = a2;
  else
    *(_DWORD *)(v7 + 44 * v33 + 32) = a2;
  *(_DWORD *)(v7 + 44 * a2 + 32) = v6;
  *v32 = a2;
  return this;
}

uint64_t FloatLigne::AddBord(FloatLigne *this, float a2, float a3, float a4, float a5, float a6, signed int a7)
{
  signed int v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  unsigned int v19;
  char *v20;
  float v21;

  if (a2 >= a4)
    return 0xFFFFFFFFLL;
  v14 = *(_DWORD *)this;
  v15 = (*(_DWORD *)this + 1);
  if ((int)v15 >= *((_DWORD *)this + 1))
  {
    v17 = 2 * v14 + 2;
    *((_DWORD *)this + 1) = v17;
    v16 = (char *)malloc_type_realloc(*((void **)this + 1), 44 * v17, 0x10000402DEC8469uLL);
    *((_QWORD *)this + 1) = v16;
    v14 = *(_DWORD *)this;
    v15 = (*(_DWORD *)this + 1);
  }
  else
  {
    v16 = (char *)*((_QWORD *)this + 1);
  }
  v18 = &v16[44 * v14];
  *(float *)v18 = a2;
  v18[4] = 1;
  if (v14 <= a7)
    v19 = -1;
  else
    v19 = a7;
  *((_DWORD *)v18 + 4) = v15;
  *((float *)v18 + 2) = a3;
  *((float *)v18 + 3) = a6;
  *(_QWORD *)(v18 + 20) = -1;
  *(_QWORD *)(v18 + 28) = -1;
  *(_DWORD *)this = v14 + 2;
  v20 = &v16[44 * (int)v15];
  *(float *)v20 = a4;
  v20[4] = 0;
  *((_DWORD *)v20 + 4) = v14;
  *((float *)v20 + 2) = a5;
  *((float *)v20 + 3) = a6;
  *(_QWORD *)(v20 + 20) = -1;
  *(_QWORD *)(v20 + 28) = -1;
  FloatLigne::InsertBord((uint64_t)this, v14, a2, v19);
  FloatLigne::InsertBord((uint64_t)this, v15, v21, v14);
  return v15;
}

uint64_t FloatLigne::AddBordR(FloatLigne *this, float a2, float a3, float a4, float a5, float a6, int a7)
{
  uint64_t v14;
  signed int v15;
  char *v16;
  uint64_t v17;
  char *v18;
  unsigned int v19;
  char *v20;
  float v21;

  if (a2 >= a4)
    return 0xFFFFFFFFLL;
  v14 = *(unsigned int *)this;
  v15 = v14 + 1;
  if ((int)v14 + 1 >= *((_DWORD *)this + 1))
  {
    v17 = 2 * (int)v14 + 2;
    *((_DWORD *)this + 1) = v17;
    v16 = (char *)malloc_type_realloc(*((void **)this + 1), 44 * v17, 0x10000402DEC8469uLL);
    *((_QWORD *)this + 1) = v16;
    v14 = *(unsigned int *)this;
    v15 = v14 + 1;
  }
  else
  {
    v16 = (char *)*((_QWORD *)this + 1);
  }
  v18 = &v16[44 * (int)v14];
  *(float *)v18 = a2;
  v18[4] = 1;
  if ((int)v14 <= a7)
    v19 = -1;
  else
    v19 = a7;
  *((_DWORD *)v18 + 4) = v15;
  *((float *)v18 + 2) = a3;
  *((float *)v18 + 3) = a6;
  *(_QWORD *)(v18 + 20) = -1;
  *(_QWORD *)(v18 + 28) = -1;
  *(_DWORD *)this = v14 + 2;
  v20 = &v16[44 * v15];
  *(float *)v20 = a4;
  v20[4] = 0;
  *((_DWORD *)v20 + 4) = v14;
  *((float *)v20 + 2) = a5;
  *((float *)v20 + 3) = a6;
  *(_QWORD *)(v20 + 20) = -1;
  *(_QWORD *)(v20 + 28) = -1;
  FloatLigne::InsertBord((uint64_t)this, v15, a2, v19);
  FloatLigne::InsertBord((uint64_t)this, v14, v21, v15);
  return v14;
}

uint64_t FloatLigne::AppendBord(FloatLigne *this, float a2, float a3, float a4, float a5, float a6)
{
  int v12;
  int v13;
  uint64_t result;
  _DWORD *v15;
  uint64_t v16;
  char *v17;
  int v18;
  char *v19;

  if (a2 >= a4)
    return 0xFFFFFFFFLL;
  v13 = *(_DWORD *)this;
  v12 = *((_DWORD *)this + 1);
  result = (*(_DWORD *)this + 1);
  if ((int)result >= v12)
  {
    v16 = 2 * v13 + 2;
    *((_DWORD *)this + 1) = v16;
    v15 = malloc_type_realloc(*((void **)this + 1), 44 * v16, 0x10000402DEC8469uLL);
    *((_QWORD *)this + 1) = v15;
    v13 = *(_DWORD *)this;
    result = (*(_DWORD *)this + 1);
  }
  else
  {
    v15 = (_DWORD *)*((_QWORD *)this + 1);
  }
  v17 = (char *)&v15[11 * v13];
  *(float *)v17 = a2;
  v17[4] = 1;
  *((_DWORD *)v17 + 4) = result;
  *((float *)v17 + 2) = a3;
  *((float *)v17 + 3) = a6;
  *(_QWORD *)(v17 + 20) = -1;
  v18 = *((_DWORD *)this + 11);
  *((_DWORD *)v17 + 7) = v18;
  *((_DWORD *)v17 + 8) = result;
  if ((v18 & 0x80000000) == 0)
    v15[11 * v18 + 8] = v13;
  if ((*((_DWORD *)this + 10) & 0x80000000) != 0)
    *((_DWORD *)this + 10) = v13;
  *(_DWORD *)this = v13 + 2;
  v19 = (char *)&v15[11 * (int)result];
  *(float *)v19 = a4;
  v19[4] = 0;
  *((_DWORD *)v19 + 4) = v13;
  *((float *)v19 + 2) = a5;
  *((float *)v19 + 3) = a6;
  *(_QWORD *)(v19 + 20) = -1;
  *((_DWORD *)v19 + 7) = v13;
  *((_DWORD *)v19 + 8) = -1;
  *((_DWORD *)this + 11) = result;
  return result;
}

float FloatLigne::RemainingValAt(FloatLigne *this, float a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  int *v5;
  float v6;
  int v7;

  if (a3 < 1)
    return 0.0;
  v3 = *((_QWORD *)this + 1);
  v4 = a3;
  v5 = (int *)(v3 + 36);
  v6 = 0.0;
  do
  {
    v7 = *v5;
    v5 += 11;
    v6 = v6
       + (float)(*(float *)(v3 + 44 * v7 + 8)
               + (float)((float)(a2 - *(float *)(v3 + 44 * v7)) * *(float *)(v3 + 44 * v7 + 12)));
    --v4;
  }
  while (v4);
  return v6;
}

uint64_t FloatLigne::Flatten(uint64_t this)
{
  FloatLigne *v1;
  uint64_t v2;
  int v3;
  BOOL v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  int v10;
  uint64_t v11;
  float v12;
  float v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  float v18;
  _DWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  int v24;

  v1 = (FloatLigne *)this;
  if (*(int *)this > 1)
  {
    *(_DWORD *)(this + 16) = 0;
    *(_QWORD *)(this + 32) = -1;
    v2 = *(unsigned int *)(this + 40);
    if ((v2 & 0x80000000) == 0)
    {
      v3 = 0;
      v4 = 0;
      v5 = **(float **)(this + 8);
      v6 = 0.0;
      v7 = 0.0;
      v8 = 0.0;
      v9 = 0.0;
      do
      {
        v10 = *(_DWORD *)v1;
        if ((int)v2 >= *(_DWORD *)v1)
          break;
        v11 = *((_QWORD *)v1 + 1);
        v12 = *(float *)(v11 + 44 * v2);
        v13 = 0.0;
        do
        {
          if (*(float *)(v11 + 44 * v2) != v12 || *(_BYTE *)(v11 + 44 * v2 + 4))
            break;
          v14 = v11 + 44 * v2;
          v15 = *(_DWORD *)(v14 + 16);
          if ((v15 & 0x80000000) == 0 && v15 < v10)
          {
            v16 = *(_DWORD *)(v11 + 44 * v15 + 40);
            if ((v16 & 0x80000000) == 0 && v16 < v3)
            {
              v17 = *(_DWORD *)(v11 + 44 * (v3 - 1) + 36);
              *(_DWORD *)(v11 + 44 * v16 + 36) = v17;
              *(_DWORD *)(v11 + 44 * v17 + 40) = v16;
            }
          }
          v13 = v13 + *(float *)(v14 + 12);
          --v3;
          v2 = *(unsigned int *)(v11 + 44 * v2 + 32);
          if ((v2 & 0x80000000) != 0)
            break;
        }
        while ((int)v2 < v10);
        v18 = 0.0;
        if ((v2 & 0x80000000) == 0 && (int)v2 < v10)
        {
          v19 = (_DWORD *)(v11 + 44 * v3 + 36);
          do
          {
            if (*(float *)(v11 + 44 * v2) != v12)
              break;
            if (!*(_BYTE *)(v11 + 44 * v2 + 4))
              break;
            v20 = v11 + 44 * v2;
            v18 = v18 + *(float *)(v20 + 12);
            *v19 = v2;
            v19 += 11;
            *(_DWORD *)(v20 + 40) = v3;
            v2 = *(unsigned int *)(v20 + 32);
            ++v3;
            if ((v2 & 0x80000000) != 0)
              break;
          }
          while ((int)v2 < v10);
        }
        if (v4)
          this = FloatLigne::AddRun(v1, v7, v12, v6, v8 + (float)(v9 * (float)(v12 - v5)), v9);
        v4 = v3 > 0;
        if (v3 < 1)
        {
          v8 = 0.0;
        }
        else
        {
          v21 = *((_QWORD *)v1 + 1);
          v22 = v3;
          v23 = (int *)(v21 + 36);
          v8 = 0.0;
          do
          {
            v24 = *v23;
            v23 += 11;
            v8 = v8
               + (float)(*(float *)(v21 + 44 * v24 + 8)
                       + (float)((float)(v12 - *(float *)(v21 + 44 * v24)) * *(float *)(v21 + 44 * v24 + 12)));
            --v22;
          }
          while (v22);
          v7 = v12;
          v6 = v8;
        }
        v9 = v9 + (float)(v18 - v13);
        v5 = v12;
      }
      while ((v2 & 0x80000000) == 0);
    }
  }
  else
  {
    *(_DWORD *)this = 0;
    *(_DWORD *)(this + 16) = 0;
    *(_QWORD *)(this + 32) = -1;
    *(_QWORD *)(this + 40) = -1;
  }
  return this;
}

uint64_t FloatLigne::AddRun(FloatLigne *this, float a2, float a3, float a4, float a5, float a6)
{
  uint64_t result;
  char *v13;
  uint64_t v14;
  float *v15;

  if (a2 >= a3)
    return 0xFFFFFFFFLL;
  result = *((unsigned int *)this + 4);
  if ((int)result >= *((_DWORD *)this + 5))
  {
    v14 = (2 * (int)result) | 1;
    *((_DWORD *)this + 5) = v14;
    v13 = (char *)malloc_type_realloc(*((void **)this + 3), 20 * v14, 0x1000040A86A77D5uLL);
    *((_QWORD *)this + 3) = v13;
    result = *((unsigned int *)this + 4);
  }
  else
  {
    v13 = (char *)*((_QWORD *)this + 3);
  }
  *((_DWORD *)this + 4) = result + 1;
  v15 = (float *)&v13[20 * (int)result];
  *v15 = a2;
  v15[1] = a3;
  v15[2] = a4;
  v15[3] = a5;
  v15[4] = a6;
  return result;
}

uint64_t FloatLigne::Affiche(FloatLigne *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  printf("%i : \n", *(_DWORD *)this);
  if (*(int *)this >= 1)
  {
    v2 = 0;
    v3 = 0;
    do
    {
      printf("(%f %f %f %i) ", *(float *)(*((_QWORD *)this + 1) + v2), *(float *)(*((_QWORD *)this + 1) + v2 + 8), *(float *)(*((_QWORD *)this + 1) + v2 + 12), *(unsigned __int8 *)(*((_QWORD *)this + 1) + v2 + 4));
      ++v3;
      v2 += 44;
    }
    while (v3 < *(int *)this);
  }
  putchar(10);
  printf("%i : \n", *((_DWORD *)this + 4));
  if (*((int *)this + 4) >= 1)
  {
    v4 = 0;
    v5 = 0;
    do
    {
      printf("(%f %f -> %f %f) ", *(float *)(*((_QWORD *)this + 3) + v4), *(float *)(*((_QWORD *)this + 3) + v4 + 8), *(float *)(*((_QWORD *)this + 3) + v4 + 4), *(float *)(*((_QWORD *)this + 3) + v4 + 12));
      ++v5;
      v4 += 20;
    }
    while (v5 < *((int *)this + 4));
  }
  return putchar(10);
}

float FloatLigne::AddRun(FloatLigne *this, float result, float a3, float a4, float a5)
{
  float v8;
  int v10;
  char *v11;
  uint64_t v12;
  float *v13;

  if (result < a3)
  {
    v8 = result;
    v10 = *((_DWORD *)this + 4);
    if (v10 >= *((_DWORD *)this + 5))
    {
      v12 = (2 * v10) | 1;
      *((_DWORD *)this + 5) = v12;
      v11 = (char *)malloc_type_realloc(*((void **)this + 3), 20 * v12, 0x1000040A86A77D5uLL);
      *((_QWORD *)this + 3) = v11;
      v10 = *((_DWORD *)this + 4);
    }
    else
    {
      v11 = (char *)*((_QWORD *)this + 3);
    }
    *((_DWORD *)this + 4) = v10 + 1;
    v13 = (float *)&v11[20 * v10];
    *v13 = v8;
    v13[1] = a3;
    v13[2] = a4;
    v13[3] = a5;
    result = (float)(a5 - a4) / (float)(a3 - v8);
    v13[4] = result;
  }
  return result;
}

void **FloatLigne::Copy(void **this, const void **a2)
{
  void **v2;
  uint64_t v3;
  void *v5;

  v2 = this;
  v3 = *((unsigned int *)a2 + 4);
  *(_DWORD *)this = 0;
  if ((int)v3 <= 0)
  {
    *((_DWORD *)this + 4) = 0;
    this[4] = (void *)-1;
    this[5] = (void *)-1;
  }
  else
  {
    *((_DWORD *)this + 4) = v3;
    if ((int)v3 <= *((_DWORD *)this + 5))
    {
      v5 = this[3];
    }
    else
    {
      *((_DWORD *)this + 5) = v3;
      v5 = malloc_type_realloc(this[3], 20 * v3, 0x1000040A86A77D5uLL);
      v2[3] = v5;
      LODWORD(v3) = *((_DWORD *)v2 + 4);
    }
    return (void **)memcpy(v5, a2[3], 20 * (int)v3);
  }
  return this;
}

void **FloatLigne::Copy(void **result, uint64_t a2)
{
  void **v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t v7;

  v2 = result;
  v3 = *(unsigned int *)(a2 + 16);
  *(_DWORD *)result = 0;
  if ((int)v3 <= 0)
  {
    *((_DWORD *)result + 4) = 0;
    result[4] = (void *)-1;
    result[5] = (void *)-1;
  }
  else
  {
    *((_DWORD *)result + 4) = v3;
    if ((int)v3 <= *((_DWORD *)result + 5)
      || (*((_DWORD *)result + 5) = 2 * v3,
          result = (void **)malloc_type_realloc(result[3], 40 * v3, 0x1000040A86A77D5uLL),
          v2[3] = result,
          LODWORD(v3) = *((_DWORD *)v2 + 4),
          (int)v3 >= 1))
    {
      v3 = v3;
      v5 = (char *)v2[3] + 8;
      v6 = (uint64_t *)(*(_QWORD *)(a2 + 24) + 8);
      do
      {
        *(v5 - 1) = vcvt_f32_s32((int32x2_t)*(v6 - 1));
        v7 = *v6;
        v6 += 2;
        *v5 = v7;
        v5 = (_QWORD *)((char *)v5 + 20);
        --v3;
      }
      while (v3);
    }
  }
  return result;
}

void FloatLigne::Booleen(uint64_t a1, uint64_t a2, FloatLigne *a3, unsigned int a4)
{
  FloatLigne *v5;
  int v6;
  int v7;
  float *v9;
  float *v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  float *v17;
  float v18;
  float v19;
  float *v20;
  float v21;
  float v22;
  _BOOL4 v23;
  _BOOL4 v24;
  _BOOL4 v25;
  float v26;
  _BOOL4 v27;
  _BOOL4 v28;
  float v29;
  _BOOL4 v30;
  int v31;
  _BOOL4 v32;
  _BOOL4 v33;
  _BOOL4 v34;
  float v35;
  int v36;
  _BOOL4 v37;
  float v38;
  int v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  uint64_t v46;
  uint64_t v47;
  float v48;
  float *v49;
  float v50;
  float v51;
  float v52;
  _BOOL4 v53;
  float v54;
  float v55;
  float v56;
  float v57;
  FloatLigne *v58;
  float v59;
  float v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  float v64;
  float *v65;
  float v66;
  float v67;
  float v68;
  _BOOL4 v69;
  float v70;
  float v71;
  float v72;
  float v73;
  FloatLigne *v74;
  float v75;
  float v76;
  int v77;
  uint64_t v78;
  uint64_t v80;

  v5 = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 32) = -1;
  *(_QWORD *)(a1 + 40) = -1;
  v6 = *(_DWORD *)(a2 + 16);
  v7 = *((_DWORD *)a3 + 4);
  if (v6 <= 0)
  {
    if (v7 < 1 || a4 && a4 != 3)
      return;
LABEL_115:
    FloatLigne::Copy((void **)a1, (const void **)v5);
    return;
  }
  if (v7 <= 0)
  {
    if (a4 > 3)
      return;
    v5 = (FloatLigne *)a2;
    if (a4 == 1)
      return;
    goto LABEL_115;
  }
  v9 = *(float **)(a2 + 24);
  v10 = (float *)*((_QWORD *)a3 + 3);
  if (*v9 >= *v10)
    v11 = *v10;
  else
    v11 = *v9;
  v12 = 0.0;
  v13 = 0.0;
  if (v11 == *v9)
    v13 = v9[2];
  if (v11 == *v10)
    v12 = v10[2];
  if (*((int *)a3 + 4) < 1)
  {
    LODWORD(v14) = 0;
    LODWORD(v15) = 0;
  }
  else
  {
    v14 = 0;
    LODWORD(v15) = 0;
    v16 = v11;
    do
    {
      v17 = (float *)(*(_QWORD *)(a2 + 24) + 20 * (int)v15);
      v18 = *v17;
      v19 = v17[1];
      v20 = (float *)(*((_QWORD *)v5 + 3) + 20 * (int)v14);
      v21 = *v20;
      v22 = v20[1];
      v23 = v16 < v19 && v16 >= *v17;
      v24 = v16 < v22 && v16 >= v21;
      v80 = v14;
      if (v16 >= v18)
      {
        if (v16 >= v21)
        {
          v34 = v19 == v22;
          if (v19 == v22)
            v35 = v17[1];
          else
            v35 = v20[1];
          if (v19 >= v22)
          {
            v36 = 1;
          }
          else
          {
            v34 = 1;
            v36 = 0;
          }
          if (v19 < v22)
            v35 = v17[1];
          v37 = v19 == v22;
          if (v19 == v22)
            v38 = v17[1];
          else
            v38 = v20[1];
          if (v19 >= v22)
          {
            v39 = 1;
          }
          else
          {
            v37 = 1;
            v39 = 0;
          }
          if (v19 < v22)
            v38 = v17[1];
          if (v16 == v21)
            v30 = v37;
          else
            v30 = v34;
          if (v16 == v21)
            v31 = v39;
          else
            v31 = v36;
          v32 = 0;
          v33 = 0;
          if (v16 == v21)
            v11 = v38;
          else
            v11 = v35;
        }
        else
        {
          v30 = v19 < v21 || v19 == v21;
          v31 = 0;
          v32 = v19 >= v21;
          v33 = 0;
          if (v19 >= v21)
            v11 = *v20;
          else
            v11 = v17[1];
        }
      }
      else
      {
        v25 = v18 == v22;
        if (v18 == v22)
          v26 = *v17;
        else
          v26 = v20[1];
        v27 = v18 >= v22;
        if (v18 < v22)
        {
          v25 = 1;
          v26 = *v17;
        }
        if (v16 < v21)
        {
          v27 = 0;
          v25 = 0;
          v26 = v16;
        }
        v28 = v18 == v21;
        if (v18 == v21)
          v29 = *v17;
        else
          v29 = *v20;
        if (v18 < v21)
        {
          v28 = 1;
          v29 = *v17;
        }
        v30 = 0;
        v31 = v16 >= v21 && v27;
        v32 = v16 < v21 && v18 >= v21;
        if (v16 < v21)
          v33 = v28;
        else
          v33 = v25;
        if (v16 < v21)
          v11 = v29;
        else
          v11 = v26;
      }
      v40 = v17[2];
      v41 = 0.0;
      v42 = 0.0;
      if (v23)
        v42 = (float)((float)(v40 * (float)(v19 - v11)) + (float)((float)(v11 - v18) * v17[3])) / (float)(v19 - v18);
      v43 = v20[2];
      if (v24)
        v41 = (float)((float)(v43 * (float)(v22 - v11)) + (float)((float)(v11 - v21) * v20[3])) / (float)(v22 - v21);
      switch(a4)
      {
        case 0u:
          if (v23 || v24)
          {
            v44 = v12 + v13;
            v45 = v42 + v41;
            goto LABEL_90;
          }
          break;
        case 1u:
          if (v23 && v24)
          {
            v44 = v12 * v13;
            v45 = v42 * v41;
            goto LABEL_90;
          }
          break;
        case 2u:
          if (v23)
          {
            v44 = v13 - v12;
            v45 = v42 - v41;
            goto LABEL_90;
          }
          break;
        case 3u:
          if (!v24 && v23)
            FloatLigne::AddRun((FloatLigne *)a1, v16, v11, v13 - v12, v42 - v41);
          if (!v23 && v24)
          {
            v44 = v12 - v13;
            v45 = v41 - v42;
LABEL_90:
            FloatLigne::AddRun((FloatLigne *)a1, v16, v11, v44, v45);
          }
          break;
        default:
          break;
      }
      if (v33)
        v13 = v40;
      else
        v13 = v42;
      if (v32)
        v12 = v43;
      else
        v12 = v41;
      if (v30)
      {
        v15 = (int)v15 + 1;
        v13 = 0.0;
        v14 = v80;
        if ((int)v15 < *(_DWORD *)(a2 + 16))
        {
          v46 = *(_QWORD *)(a2 + 24);
          if (*(float *)(v46 + 20 * v15) == v11)
            v13 = *(float *)(v46 + 20 * v15 + 8);
        }
      }
      else
      {
        v14 = v80;
      }
      if (v31)
      {
        v14 = (int)v14 + 1;
        v12 = 0.0;
        if ((int)v14 < *((_DWORD *)v5 + 4))
        {
          v47 = *((_QWORD *)v5 + 3);
          if (*(float *)(v47 + 20 * v14) == v11)
            v12 = *(float *)(v47 + 20 * v14 + 8);
        }
      }
      v6 = *(_DWORD *)(a2 + 16);
      if ((int)v15 >= v6)
        break;
      v16 = v11;
    }
    while ((int)v14 < *((_DWORD *)v5 + 4));
  }
  if ((int)v15 < v6)
  {
    do
    {
      v48 = v11;
      v49 = (float *)(*(_QWORD *)(a2 + 24) + 20 * (int)v15);
      v51 = *v49;
      v50 = v49[1];
      v52 = v49[2];
      v53 = v11 >= *v49;
      if (v11 < *v49)
        v54 = *v49;
      else
        v54 = v11;
      if (v11 < *v49)
        v11 = v54;
      else
        v11 = v49[1];
      if (v48 >= v50)
        v53 = 0;
      v55 = 0.0;
      if (v53)
        v55 = (float)((float)(v52 * (float)(v50 - v11)) + (float)((float)(v11 - v51) * v49[3])) / (float)(v50 - v51);
      if (a4 == 3 || a4 == 2)
      {
        if (v53)
        {
          v56 = v13 - v12;
          v58 = (FloatLigne *)a1;
          v59 = v48;
          v60 = v11;
          v57 = v55;
          goto LABEL_135;
        }
      }
      else if (!a4 && v53)
      {
        v56 = v12 + v13;
        v57 = v55 + 0.0;
        v58 = (FloatLigne *)a1;
        v59 = v48;
        v60 = v11;
LABEL_135:
        FloatLigne::AddRun(v58, v59, v60, v56, v57);
      }
      if (v48 < v51)
        v13 = v52;
      else
        v13 = v55;
      v61 = *(_DWORD *)(a2 + 16);
      if (v48 >= v51)
      {
        v15 = (int)v15 + 1;
        v13 = 0.0;
        if ((int)v15 < v61)
        {
          v62 = *(_QWORD *)(a2 + 24);
          if (*(float *)(v62 + 20 * v15) == v50)
            v13 = *(float *)(v62 + 20 * v15 + 8);
        }
      }
      v12 = 0.0;
    }
    while ((int)v15 < v61);
  }
  if ((int)v14 < *((_DWORD *)v5 + 4))
  {
    LODWORD(v63) = v14;
    do
    {
      v64 = v11;
      v65 = (float *)(*((_QWORD *)v5 + 3) + 20 * (int)v63);
      v67 = *v65;
      v66 = v65[1];
      v68 = v65[2];
      v69 = v11 >= *v65;
      if (v11 < *v65)
        v70 = *v65;
      else
        v70 = v11;
      if (v11 < *v65)
        v11 = v70;
      else
        v11 = v65[1];
      if (v64 >= v66)
        v69 = 0;
      v71 = 0.0;
      if (v69)
        v71 = (float)((float)(v68 * (float)(v66 - v11)) + (float)((float)(v11 - v67) * v65[3])) / (float)(v66 - v67);
      if (a4 == 3)
      {
        if (v69)
        {
          v72 = v12 - v13;
          v74 = (FloatLigne *)a1;
          v75 = v64;
          v76 = v11;
          v73 = v71;
          goto LABEL_162;
        }
      }
      else if (!a4 && v69)
      {
        v72 = v12 + v13;
        v73 = v71 + 0.0;
        v74 = (FloatLigne *)a1;
        v75 = v64;
        v76 = v11;
LABEL_162:
        FloatLigne::AddRun(v74, v75, v76, v72, v73);
      }
      if (v64 < v67)
        v12 = v68;
      else
        v12 = v71;
      v77 = *((_DWORD *)v5 + 4);
      if (v64 >= v67)
      {
        v63 = (int)v63 + 1;
        v12 = 0.0;
        if ((int)v63 < v77)
        {
          v78 = *((_QWORD *)v5 + 3);
          if (*(float *)(v78 + 20 * v63) == v66)
            v12 = *(float *)(v78 + 20 * v63 + 8);
        }
      }
      v13 = 0.0;
    }
    while ((int)v63 < v77);
  }
}

void FloatLigne::Min(FloatLigne *this, FloatLigne *a2, float a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  float v11;
  float v12;
  float *v13;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  FloatLigne *v19;
  float v20;
  float v21;
  float v22;
  float v23;
  double v24;
  float v25;
  FloatLigne *v27;
  float v28;

  *(_DWORD *)this = 0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 4) = -1;
  *((_QWORD *)this + 5) = -1;
  if (*((int *)a2 + 4) >= 1)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0.0;
    v12 = 0.0;
    while (1)
    {
      v13 = (float *)(*((_QWORD *)a2 + 3) + v8);
      v15 = *v13;
      v14 = v13[1];
      v17 = v13[2];
      v16 = v13[3];
      if (v17 > a3)
        break;
      if (v16 > a3)
      {
        v23 = (float)((float)(v14 * (float)(v17 - a3)) + (float)(v15 * (float)(a3 - v16))) / (float)(v17 - v16);
        if ((v10 & 1) != 0)
        {
          if (v15 + -0.00001 > v12)
          {
            if (a4)
            {
              FloatLigne::AddRun(this, v11, v12, a3, a3);
              goto LABEL_27;
            }
LABEL_31:
            v19 = this;
            v20 = v23;
            v21 = v14;
            v22 = a3;
LABEL_32:
            FloatLigne::AddRun(v19, v20, v21, v22, v16);
            v10 = 0;
            goto LABEL_34;
          }
          if (!a4)
            goto LABEL_31;
          v27 = this;
          v28 = v11;
        }
        else
        {
          if (!a4)
            goto LABEL_31;
LABEL_27:
          v27 = this;
          v28 = v15;
        }
        FloatLigne::AddRun(v27, v28, v23, a3, a3);
        goto LABEL_31;
      }
      if ((v10 & 1) == 0)
        goto LABEL_33;
      v24 = v15 + -0.00001;
      if (v24 <= v12)
        v25 = v11;
      else
        v25 = *v13;
      if (v24 > v12 && a4 != 0)
      {
        FloatLigne::AddRun(this, v11, v12, a3, a3);
LABEL_33:
        v10 = 1;
        v12 = v14;
        v11 = v15;
        goto LABEL_34;
      }
      v10 = 1;
      v12 = v13[1];
      v11 = v25;
LABEL_34:
      ++v9;
      v8 += 20;
      if (v9 >= *((int *)a2 + 4))
      {
        if ((v10 & a4 & 1) != 0)
          FloatLigne::AddRun(this, v11, v12, a3, a3);
        return;
      }
    }
    v18 = v10 & a4;
    if (v16 <= a3)
    {
      if (v18 == 1)
        FloatLigne::AddRun(this, v11, v12, a3, a3);
      v11 = (float)((float)(v14 * (float)(a3 - v17)) + (float)(v15 * (float)(v16 - a3))) / (float)(v16 - v17);
      FloatLigne::AddRun(this, v15, v11, v17, a3);
      v10 = 1;
      v12 = v14;
      goto LABEL_34;
    }
    if (v18 == 1)
      FloatLigne::AddRun(this, v11, v12, a3, a3);
    v19 = this;
    v20 = v15;
    v21 = v14;
    v22 = v17;
    goto LABEL_32;
  }
}

void FloatLigne::Split(FloatLigne *this, FloatLigne *a2, float a3, FloatLigne *a4)
{
  uint64_t v8;
  uint64_t i;
  float *v10;
  float v11;
  float v12;
  float v13;
  float v14;
  FloatLigne *v15;
  float v16;
  float v17;
  float v18;

  *(_DWORD *)this = 0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 4) = -1;
  *((_QWORD *)this + 5) = -1;
  if (*((int *)a2 + 4) >= 1)
  {
    v8 = 0;
    for (i = 0; i < *((int *)a2 + 4); ++i)
    {
      v10 = (float *)(*((_QWORD *)a2 + 3) + v8);
      v11 = *v10;
      v12 = v10[1];
      v13 = v10[2];
      v14 = v10[3];
      if (v13 >= a3)
      {
        if (v14 < a3)
        {
          v16 = (float)(v12 * (float)(v13 - a3)) + (float)(v11 * (float)(a3 - v14));
          v17 = v16 / (float)(v13 - v14);
          if (a4)
            FloatLigne::AddRun(a4, v11, v16 / (float)(v13 - v14), v13, a3);
          v15 = this;
LABEL_12:
          v11 = v17;
          v18 = v12;
          v13 = a3;
LABEL_16:
          FloatLigne::AddRun(v15, v11, v18, v13, v14);
          goto LABEL_17;
        }
        if (a4)
        {
          v15 = a4;
LABEL_15:
          v18 = v10[1];
          goto LABEL_16;
        }
      }
      else
      {
        if (v14 < a3)
        {
          v15 = this;
          goto LABEL_15;
        }
        v17 = (float)((float)(v12 * (float)(a3 - v13)) + (float)(v11 * (float)(v14 - a3))) / (float)(v14 - v13);
        FloatLigne::AddRun(this, v11, v17, v13, a3);
        if (a4)
        {
          v15 = a4;
          goto LABEL_12;
        }
      }
LABEL_17:
      v8 += 20;
    }
  }
}

void FloatLigne::Max(FloatLigne *this, FloatLigne *a2, float a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  float v11;
  float v12;
  float *v13;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  FloatLigne *v19;
  float v20;
  float v21;
  float v22;
  float v23;
  double v24;
  float v25;
  FloatLigne *v27;
  float v28;

  *(_DWORD *)this = 0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 4) = -1;
  *((_QWORD *)this + 5) = -1;
  if (*((int *)a2 + 4) >= 1)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0.0;
    v12 = 0.0;
    while (1)
    {
      v13 = (float *)(*((_QWORD *)a2 + 3) + v8);
      v15 = *v13;
      v14 = v13[1];
      v17 = v13[2];
      v16 = v13[3];
      if (v17 < a3)
        break;
      if (v16 < a3)
      {
        v23 = (float)((float)(v14 * (float)(v17 - a3)) + (float)(v15 * (float)(a3 - v16))) / (float)(v17 - v16);
        if ((v10 & 1) != 0)
        {
          if (v15 + -0.00001 > v12)
          {
            if (a4)
            {
              FloatLigne::AddRun(this, v11, v12, a3, a3);
              goto LABEL_27;
            }
LABEL_31:
            v19 = this;
            v20 = v23;
            v21 = v14;
            v22 = a3;
LABEL_32:
            FloatLigne::AddRun(v19, v20, v21, v22, v16);
            v10 = 0;
            goto LABEL_34;
          }
          if (!a4)
            goto LABEL_31;
          v27 = this;
          v28 = v11;
        }
        else
        {
          if (!a4)
            goto LABEL_31;
LABEL_27:
          v27 = this;
          v28 = v15;
        }
        FloatLigne::AddRun(v27, v28, v23, a3, a3);
        goto LABEL_31;
      }
      if ((v10 & 1) == 0)
        goto LABEL_33;
      v24 = v15 + -0.00001;
      if (v24 <= v12)
        v25 = v11;
      else
        v25 = *v13;
      if (v24 > v12 && a4 != 0)
      {
        FloatLigne::AddRun(this, v11, v12, a3, a3);
LABEL_33:
        v10 = 1;
        v12 = v14;
        v11 = v15;
        goto LABEL_34;
      }
      v10 = 1;
      v12 = v13[1];
      v11 = v25;
LABEL_34:
      ++v9;
      v8 += 20;
      if (v9 >= *((int *)a2 + 4))
      {
        if ((v10 & a4 & 1) != 0)
          FloatLigne::AddRun(this, v11, v12, a3, a3);
        return;
      }
    }
    v18 = v10 & a4;
    if (v16 >= a3)
    {
      if (v18 == 1)
        FloatLigne::AddRun(this, v11, v12, a3, a3);
      v11 = (float)((float)(v14 * (float)(a3 - v17)) + (float)(v15 * (float)(v16 - a3))) / (float)(v16 - v17);
      FloatLigne::AddRun(this, v15, v11, v17, a3);
      v10 = 1;
      v12 = v14;
      goto LABEL_34;
    }
    if (v18 == 1)
      FloatLigne::AddRun(this, v11, v12, a3, a3);
    v19 = this;
    v20 = v15;
    v21 = v14;
    v22 = v17;
    goto LABEL_32;
  }
}

void FloatLigne::Over(FloatLigne *this, FloatLigne *a2, float a3)
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  float v9;
  float v10;
  float *v11;
  float v12;
  float v13;
  float v14;
  float v15;
  FloatLigne *v16;
  float v17;
  float v18;
  float v19;

  *(_DWORD *)this = 0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 4) = -1;
  *((_QWORD *)this + 5) = -1;
  if (*((int *)a2 + 4) >= 1)
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0.0;
    v10 = 0.0;
    while (1)
    {
      v11 = (float *)(*((_QWORD *)a2 + 3) + v6);
      v12 = *v11;
      v13 = v11[1];
      v14 = v11[2];
      v15 = v11[3];
      if (v14 >= a3)
      {
        if (v15 < a3)
        {
          v19 = (float)((float)(v13 * (float)(v14 - a3)) + (float)(v12 * (float)(a3 - v15))) / (float)(v14 - v15);
          if ((v8 & 1) == 0)
            goto LABEL_11;
          v16 = this;
          if (v12 + -0.00001 <= v10)
          {
            v17 = v9;
          }
          else
          {
            FloatLigne::AddRun(this, v9, v10, a3, a3);
LABEL_11:
            v16 = this;
            v17 = v12;
          }
          v18 = v19;
LABEL_20:
          FloatLigne::AddRun(v16, v17, v18, a3, a3);
LABEL_21:
          v8 = 0;
          goto LABEL_22;
        }
        if ((v8 & 1) != 0)
        {
          if (v12 + -0.00001 <= v10)
          {
            v8 = 1;
            v10 = v11[1];
            goto LABEL_22;
          }
LABEL_16:
          FloatLigne::AddRun(this, v9, v10, a3, a3);
        }
      }
      else
      {
        if (v15 < a3)
        {
          if ((v8 & 1) != 0)
          {
            v16 = this;
            v17 = v9;
            v18 = v10;
            goto LABEL_20;
          }
          goto LABEL_21;
        }
        v12 = (float)((float)(v13 * (float)(a3 - v14)) + (float)(v12 * (float)(v15 - a3))) / (float)(v15 - v14);
        if ((v8 & 1) != 0)
          goto LABEL_16;
      }
      v8 = 1;
      v10 = v13;
      v9 = v12;
LABEL_22:
      ++v7;
      v6 += 20;
      if (v7 >= *((int *)a2 + 4))
      {
        if ((v8 & 1) != 0)
          FloatLigne::AddRun(this, v9, v10, a3, a3);
        return;
      }
    }
  }
}

double FloatLigne::Enqueue(FloatLigne *this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  double result;

  if ((*((_DWORD *)this + 8) & 0x80000000) != 0)
  {
    *((_DWORD *)this + 8) = a2;
    *((_DWORD *)this + 9) = a2;
    result = NAN;
    *(_QWORD *)(*((_QWORD *)this + 1) + 44 * a2 + 20) = -1;
  }
  else
  {
    v2 = *((_QWORD *)this + 1);
    v3 = v2 + 44 * a2;
    v4 = *((_DWORD *)this + 9);
    *(_DWORD *)(v3 + 20) = v4;
    *(_DWORD *)(v3 + 24) = -1;
    *(_DWORD *)(v2 + 44 * v4 + 24) = a2;
    *((_DWORD *)this + 9) = a2;
  }
  return result;
}

double FloatLigne::Dequeue(FloatLigne *this, int a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  double result;

  v2 = *((_DWORD *)this + 9);
  if (*((_DWORD *)this + 8) == a2)
  {
    if (v2 == a2)
      *((_QWORD *)this + 4) = -1;
    else
      *((_DWORD *)this + 8) = *(_DWORD *)(*((_QWORD *)this + 1) + 44 * a2 + 24);
  }
  else if (v2 == a2)
  {
    *((_DWORD *)this + 9) = *(_DWORD *)(*((_QWORD *)this + 1) + 44 * a2 + 20);
  }
  v3 = *((_QWORD *)this + 1);
  v4 = v3 + 44 * a2;
  v7 = *(_DWORD *)(v4 + 20);
  v5 = (_QWORD *)(v4 + 20);
  v6 = v7;
  if ((v7 & 0x80000000) == 0)
    *(_DWORD *)(v3 + 44 * v6 + 24) = *(_DWORD *)(v3 + 44 * a2 + 24);
  v8 = *(_DWORD *)(v3 + 44 * a2 + 24);
  if ((v8 & 0x80000000) == 0)
    *(_DWORD *)(v3 + 44 * v8 + 20) = v6;
  result = NAN;
  *v5 = -1;
  return result;
}

void IntLigne::IntLigne(IntLigne *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_QWORD *)this + 4) = -1;
}

{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_QWORD *)this + 4) = -1;
}

void IntLigne::~IntLigne(void **this)
{
  if (*((int *)this + 1) >= 1)
  {
    free(this[1]);
    *this = 0;
    this[1] = 0;
  }
  if (*((int *)this + 5) >= 1)
  {
    free(this[3]);
    this[2] = 0;
    this[3] = 0;
  }
}

double IntLigne::Reset(IntLigne *this)
{
  double result;

  *(_DWORD *)this = 0;
  *((_DWORD *)this + 4) = 0;
  result = NAN;
  *((_QWORD *)this + 4) = -1;
  return result;
}

double IntLigne::AddBord(IntLigne *this, int a2, float a3, int a4, float a5)
{
  int v10;
  int v11;
  char *v12;
  uint64_t v13;
  float *v14;
  double result;
  float *v16;

  v10 = *(_DWORD *)this;
  v11 = v10 + 1;
  if (v10 + 1 >= *((_DWORD *)this + 1))
  {
    v13 = 2 * v10 + 2;
    *((_DWORD *)this + 1) = v13;
    v12 = (char *)malloc_type_realloc(*((void **)this + 1), 24 * v13, 0x1000040C4EE764BuLL);
    *((_QWORD *)this + 1) = v12;
    v10 = *(_DWORD *)this;
    v11 = *(_DWORD *)this + 1;
  }
  else
  {
    v12 = (char *)*((_QWORD *)this + 1);
  }
  v14 = (float *)&v12[24 * v10];
  *(_DWORD *)v14 = a2;
  v14[2] = a3;
  *((_BYTE *)v14 + 4) = 1;
  *((_DWORD *)v14 + 3) = v11;
  result = NAN;
  *((_QWORD *)v14 + 2) = -1;
  *(_DWORD *)this = v10 + 2;
  v16 = (float *)&v12[24 * v11];
  *(_DWORD *)v16 = a4;
  v16[2] = a5;
  *((_BYTE *)v16 + 4) = 0;
  *((_DWORD *)v16 + 3) = v10;
  *((_QWORD *)v16 + 2) = -1;
  return result;
}

float IntLigne::RemainingValAt(IntLigne *this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  float result;
  uint64_t v5;
  uint64_t v6;

  v2 = *((unsigned int *)this + 8);
  if ((v2 & 0x80000000) != 0)
    return 0.0;
  v3 = *((_QWORD *)this + 1);
  result = 0.0;
  do
  {
    v5 = v3 + 24 * v2;
    v6 = v3 + 24 * *(int *)(v5 + 12);
    result = result
           + (float)((float)((float)(*(float *)(v6 + 8) * (float)(*(_DWORD *)v5 - a2))
                           + (float)((float)(a2 - *(_DWORD *)v6) * *(float *)(v5 + 8)))
                   / (float)(*(_DWORD *)v5 - *(_DWORD *)v6));
    v2 = *(unsigned int *)(v5 + 20);
  }
  while ((v2 & 0x80000000) == 0);
  return result;
}

void IntLigne::Flatten(IntLigne *this)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  int v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  int v14;
  BOOL v15;
  int v16;
  float v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  float v22;
  int v23;
  float v24;
  float v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;

  v2 = *(unsigned int *)this;
  if ((int)v2 > 1)
  {
    v3 = 0;
    *((_DWORD *)this + 4) = 0;
    *((_QWORD *)this + 4) = -1;
    v4 = (char *)*((_QWORD *)this + 1);
    v5 = 16;
    do
    {
      *(_DWORD *)&v4[v5] = v3++;
      v5 += 24;
    }
    while (v2 != v3);
    qsort(v4, (int)v2, 0x18uLL, (int (__cdecl *)(const void *, const void *))IntLigne::CmpBord);
    v6 = *(unsigned int *)this;
    if ((int)v6 >= 1)
    {
      v7 = 0;
      v8 = *((_QWORD *)this + 1);
      v9 = (int *)(v8 + 16);
      do
      {
        v10 = *v9;
        v9 += 6;
        *(_DWORD *)(v8 + 24 * v10 + 20) = v7++;
      }
      while (v6 != v7);
      v11 = *((_QWORD *)this + 1);
      v12 = (int *)(v11 + 12);
      v13 = v6;
      do
      {
        *v12 = *(_DWORD *)(v11 + 24 * *v12 + 20);
        v12 += 6;
        --v13;
      }
      while (v13);
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0.0;
      do
      {
        v18 = *((_QWORD *)this + 1);
        v19 = *(_DWORD *)(v18 + 24 * v14);
        if (v14 >= (int)v6)
        {
          v22 = 0.0;
        }
        else
        {
          v20 = 24 * v14;
          v21 = v14 + 1;
          v22 = 0.0;
          while (!*(_BYTE *)(v18 + v20 + 4))
          {
            IntLigne::Dequeue(this, v14);
            v18 = *((_QWORD *)this + 1);
            v22 = v22 + *(float *)(v18 + v20 + 8);
            v6 = *(int *)this;
            if (v21 >= v6)
            {
              ++v14;
              break;
            }
            v23 = *(_DWORD *)(v18 + v20 + 24);
            ++v14;
            v20 += 24;
            ++v21;
            if (v23 != v19)
              break;
          }
        }
        v24 = IntLigne::RemainingValAt(this, v19);
        v25 = 0.0;
        if (v14 < (int)v6)
        {
          v26 = v14;
          v27 = *((_QWORD *)this + 1);
          if (*(_DWORD *)(v27 + 24 * v14) == v19)
          {
            v28 = 24 * v14;
            do
            {
              v29 = v27 + v28;
              if (!*(_BYTE *)(v29 + 4))
                break;
              v25 = v25 + *(float *)(v29 + 8);
              IntLigne::Enqueue(this, *(_DWORD *)(v29 + 12));
              ++v26;
              v6 = *(int *)this;
              if (v26 >= v6)
                break;
              v27 = *((_QWORD *)this + 1);
              v30 = *(_DWORD *)(v27 + v28 + 24);
              v28 += 24;
            }
            while (v30 == v19);
          }
          v14 = v26;
        }
        if (v15)
        {
          IntLigne::AddRun(this, v16, v19, v17, v22 + v24);
          LODWORD(v6) = *(_DWORD *)this;
        }
        v31 = *((_DWORD *)this + 8);
        v15 = v31 >= 0;
        if (v31 >= 0)
        {
          v16 = v19;
          v17 = v24 + v25;
        }
      }
      while (v14 < (int)v6);
    }
  }
  else
  {
    *(_DWORD *)this = 0;
    *((_DWORD *)this + 4) = 0;
    *((_QWORD *)this + 4) = -1;
  }
}

uint64_t IntLigne::CmpBord(IntLigne *this, _BYTE *a2, const void *a3)
{
  if (*(_DWORD *)this == *(_DWORD *)a2)
  {
    if (*((_BYTE *)this + 4))
    {
      if (!a2[4])
        return 1;
    }
    else if (a2[4])
    {
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  else if (*(_DWORD *)this < *(_DWORD *)a2)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

double IntLigne::Dequeue(IntLigne *this, int a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  double result;

  v2 = *((_DWORD *)this + 9);
  if (*((_DWORD *)this + 8) == a2)
  {
    if (v2 == a2)
      *((_QWORD *)this + 4) = -1;
    else
      *((_DWORD *)this + 8) = *(_DWORD *)(*((_QWORD *)this + 1) + 24 * a2 + 20);
  }
  else if (v2 == a2)
  {
    *((_DWORD *)this + 9) = *(_DWORD *)(*((_QWORD *)this + 1) + 24 * a2 + 16);
  }
  v3 = *((_QWORD *)this + 1);
  v4 = v3 + 24 * a2;
  v7 = *(_DWORD *)(v4 + 16);
  v5 = (_QWORD *)(v4 + 16);
  v6 = v7;
  if ((v7 & 0x80000000) == 0)
    *(_DWORD *)(v3 + 24 * v6 + 20) = *(_DWORD *)(v3 + 24 * a2 + 20);
  v8 = *(_DWORD *)(v3 + 24 * a2 + 20);
  if ((v8 & 0x80000000) == 0)
    *(_DWORD *)(v3 + 24 * v8 + 16) = v6;
  result = NAN;
  *v5 = -1;
  return result;
}

double IntLigne::Enqueue(IntLigne *this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  double result;

  if ((*((_DWORD *)this + 8) & 0x80000000) != 0)
  {
    *((_DWORD *)this + 8) = a2;
    *((_DWORD *)this + 9) = a2;
    result = NAN;
    *(_QWORD *)(*((_QWORD *)this + 1) + 24 * a2 + 16) = -1;
  }
  else
  {
    v2 = *((_QWORD *)this + 1);
    v3 = v2 + 24 * a2;
    v4 = *((_DWORD *)this + 9);
    *(_DWORD *)(v3 + 16) = v4;
    *(_DWORD *)(v3 + 20) = -1;
    *(_DWORD *)(v2 + 24 * v4 + 20) = a2;
    *((_DWORD *)this + 9) = a2;
  }
  return result;
}

uint64_t IntLigne::AddRun(IntLigne *this, int a2, int a3, float a4, float a5)
{
  uint64_t result;
  char *v11;
  int v12;
  char *v13;

  if (a2 >= a3)
    return 0xFFFFFFFFLL;
  result = *((unsigned int *)this + 4);
  if ((int)result >= *((_DWORD *)this + 5))
  {
    v12 = (2 * result) | 1;
    *((_DWORD *)this + 5) = v12;
    v11 = (char *)malloc_type_realloc(*((void **)this + 3), 16 * v12, 0x1000040451B5BE8uLL);
    *((_QWORD *)this + 3) = v11;
    result = *((unsigned int *)this + 4);
  }
  else
  {
    v11 = (char *)*((_QWORD *)this + 3);
  }
  *((_DWORD *)this + 4) = result + 1;
  v13 = &v11[16 * (int)result];
  *(_DWORD *)v13 = a2;
  *((_DWORD *)v13 + 1) = a3;
  *((float *)v13 + 2) = a4;
  *((float *)v13 + 3) = a5;
  return result;
}

uint64_t IntLigne::Affiche(IntLigne *this)
{
  uint64_t v2;
  uint64_t v3;

  printf("%i : \n", *((_DWORD *)this + 4));
  if (*((int *)this + 4) >= 1)
  {
    v2 = 0;
    v3 = 0;
    do
    {
      printf("(%i %f -> %i %f) ", *(_DWORD *)(*((_QWORD *)this + 3) + v2), *(float *)(*((_QWORD *)this + 3) + v2 + 8), *(_DWORD *)(*((_QWORD *)this + 3) + v2 + 4), *(float *)(*((_QWORD *)this + 3) + v2 + 12));
      ++v3;
      v2 += 16;
    }
    while (v3 < *((int *)this + 4));
  }
  return putchar(10);
}

uint64_t IntLigne::Booleen(uint64_t result, uint64_t a2, IntLigne *a3, unsigned int a4)
{
  IntLigne *v5;
  int v6;
  int v7;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  float v13;
  float v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  _BOOL4 v25;
  _BOOL4 v27;
  _BOOL4 v28;
  int v29;
  int v30;
  int v31;
  int v32;
  _BOOL4 v33;
  int v34;
  _BOOL4 v35;
  _BOOL4 v36;
  int v37;
  int v38;
  int v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  _BOOL4 v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  float v53;
  _BOOL4 v54;
  float v55;
  float v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  int v62;
  int v63;
  float v64;
  _BOOL4 v65;
  float v66;
  float v67;
  int v68;
  uint64_t v69;
  _BOOL4 v70;
  IntLigne *v72;
  uint64_t v73;

  v5 = a3;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 16) = 0;
  v72 = (IntLigne *)result;
  *(_QWORD *)(result + 32) = -1;
  v6 = *(_DWORD *)(a2 + 16);
  v7 = *((_DWORD *)a3 + 4);
  if (v6 <= 0)
  {
    if (v7 < 1 || a4 && a4 != 3)
      return result;
    return (uint64_t)IntLigne::Copy((void **)result, (const void **)v5);
  }
  if (v7 <= 0)
  {
    if (a4 > 3)
      return result;
    v5 = (IntLigne *)a2;
    if (a4 == 1)
      return result;
    return (uint64_t)IntLigne::Copy((void **)result, (const void **)v5);
  }
  v9 = *(_QWORD *)(a2 + 24);
  v10 = *(_DWORD *)v9;
  v11 = *((_QWORD *)a3 + 3);
  v12 = *(_DWORD *)v11;
  v13 = 0.0;
  v14 = 0.0;
  if (*(_DWORD *)v9 >= *(_DWORD *)v11)
    v15 = *(_DWORD *)v11;
  else
    v15 = *(_DWORD *)v9;
  if (v10 <= v12)
    v14 = *(float *)(v9 + 8);
  if (v12 <= v10)
    v13 = *(float *)(v11 + 8);
  if (*((int *)a3 + 4) < 1)
  {
    LODWORD(v16) = 0;
    LODWORD(v17) = 0;
  }
  else
  {
    v16 = 0;
    LODWORD(v17) = 0;
    v18 = v15;
    do
    {
      v19 = *(_QWORD *)(a2 + 24) + 16 * (int)v17;
      v20 = *(_DWORD *)v19;
      v21 = *(_DWORD *)(v19 + 4);
      v22 = *((_QWORD *)v5 + 3) + 16 * (int)v16;
      v23 = *(_DWORD *)v22;
      v24 = *(_DWORD *)(v22 + 4);
      v25 = v18 < v21 && v18 >= *(_DWORD *)v19;
      v27 = v18 >= v23 && v18 < v24;
      v73 = v16;
      if (v18 >= v20)
      {
        if (v18 >= v23)
        {
          v36 = v21 == v24;
          if (v21 >= v24)
          {
            v37 = 1;
          }
          else
          {
            v36 = 1;
            v37 = 0;
          }
          if (v21 >= v24)
            v38 = *(_DWORD *)(v22 + 4);
          else
            v38 = *(_DWORD *)(v19 + 4);
          result = v21 < v24 || v21 == v24;
          if (v21 >= v24)
            v39 = *(_DWORD *)(v22 + 4);
          else
            v39 = *(_DWORD *)(v19 + 4);
          v32 = 0;
          v33 = 0;
          if (v18 == v23)
            v34 = result;
          else
            v34 = v36;
          if (v18 == v23)
            v35 = v21 >= v24;
          else
            v35 = v37;
          if (v18 == v23)
            v15 = v39;
          else
            v15 = v38;
        }
        else
        {
          v32 = 0;
          v33 = v21 >= v23;
          v34 = v21 < v23 || v21 == v23;
          v35 = 0;
          if (v21 >= v23)
            v15 = *(_DWORD *)v22;
          else
            v15 = *(_DWORD *)(v19 + 4);
        }
      }
      else
      {
        v28 = v20 == v24;
        if (v20 >= v24)
        {
          v29 = 1;
        }
        else
        {
          v28 = 1;
          v29 = 0;
        }
        if (v20 >= v24)
          v30 = *(_DWORD *)(v22 + 4);
        else
          v30 = *(_DWORD *)v19;
        result = v20 < v23 || v20 == v23;
        if (v20 >= v23)
          v31 = *(_DWORD *)v22;
        else
          v31 = *(_DWORD *)v19;
        if (v18 < v23)
          v32 = result;
        else
          v32 = v28;
        v33 = v18 < v23 && v20 >= v23;
        v34 = 0;
        if (v18 < v23)
          v35 = 0;
        else
          v35 = v29;
        if (v18 < v23)
          v15 = v31;
        else
          v15 = v30;
      }
      v40 = *(float *)(v19 + 8);
      v41 = 0.0;
      v42 = 0.0;
      if (v25)
        v42 = (float)((float)(v40 * (float)(v21 - v15)) + (float)((float)(v15 - v20) * *(float *)(v19 + 12)))
            / (float)(v21 - v20);
      v43 = *(float *)(v22 + 8);
      if (v27)
        v41 = (float)((float)(v43 * (float)(v24 - v15)) + (float)((float)(v15 - v23) * *(float *)(v22 + 12)))
            / (float)(v24 - v23);
      switch(a4)
      {
        case 0u:
          if (v25 || v27)
          {
            v44 = v13 + v14;
            v45 = v42 + v41;
            goto LABEL_89;
          }
          break;
        case 1u:
          if (v25 && v27)
          {
            v44 = v13 * v14;
            v45 = v42 * v41;
            goto LABEL_89;
          }
          break;
        case 2u:
          if (v25)
          {
            v44 = v14 - v13;
            v45 = v42 - v41;
            goto LABEL_89;
          }
          break;
        case 3u:
          if (!v27 && v25)
          {
            v70 = v35;
            result = IntLigne::AddRun(v72, v18, v15, v14 - v13, v42 - v41);
            v35 = v70;
          }
          if (!v25 && v27)
          {
            v44 = v13 - v14;
            v45 = v41 - v42;
LABEL_89:
            v46 = v35;
            result = IntLigne::AddRun(v72, v18, v15, v44, v45);
            v35 = v46;
          }
          break;
        default:
          break;
      }
      if (v32)
        v14 = v40;
      else
        v14 = v42;
      if (v33)
        v13 = v43;
      else
        v13 = v41;
      if (v34)
      {
        v17 = (int)v17 + 1;
        v14 = 0.0;
        v5 = a3;
        v16 = v73;
        if ((int)v17 < *(_DWORD *)(a2 + 16))
        {
          v47 = *(_QWORD *)(a2 + 24);
          if (*(_DWORD *)(v47 + 16 * v17) == v15)
            v14 = *(float *)(v47 + 16 * v17 + 8);
        }
      }
      else
      {
        v5 = a3;
        v16 = v73;
      }
      if (v35)
      {
        v16 = (int)v16 + 1;
        v13 = 0.0;
        if ((int)v16 < *((_DWORD *)v5 + 4))
        {
          v48 = *((_QWORD *)v5 + 3);
          if (*(_DWORD *)(v48 + 16 * v16) == v15)
            v13 = *(float *)(v48 + 16 * v16 + 8);
        }
      }
      v6 = *(_DWORD *)(a2 + 16);
      if ((int)v17 >= v6)
        break;
      v18 = v15;
    }
    while ((int)v16 < *((_DWORD *)v5 + 4));
  }
  if ((int)v17 < v6)
  {
    while (1)
    {
      v49 = v15;
      v50 = *(_QWORD *)(a2 + 24) + 16 * (int)v17;
      v52 = *(_DWORD *)v50;
      v51 = *(_DWORD *)(v50 + 4);
      v53 = *(float *)(v50 + 8);
      v54 = v15 >= *(_DWORD *)v50;
      if (v15 >= *(_DWORD *)v50)
        v15 = *(_DWORD *)(v50 + 4);
      else
        v15 = *(_DWORD *)v50;
      if (v49 >= v51)
        v54 = 0;
      v55 = 0.0;
      if (v54)
        v55 = (float)((float)(v53 * (float)(v51 - v15)) + (float)((float)(v15 - v52) * *(float *)(v50 + 12)))
            / (float)(v51 - v52);
      if (a4 == 3 || a4 == 2)
      {
        if (!v54)
          goto LABEL_132;
        v56 = v14 - v13;
      }
      else
      {
        if (a4 || !v54)
          goto LABEL_132;
        v56 = v13 + v14;
        v55 = v55 + 0.0;
      }
      result = IntLigne::AddRun(v72, v49, v15, v56, v55);
LABEL_132:
      v57 = *(_DWORD *)(a2 + 16);
      if (v49 >= v52)
      {
        v17 = (int)v17 + 1;
        v53 = 0.0;
        if ((int)v17 < v57)
        {
          v58 = *(_QWORD *)(a2 + 24);
          if (*(_DWORD *)(v58 + 16 * v17) == v51)
            v53 = *(float *)(v58 + 16 * v17 + 8);
        }
      }
      v13 = 0.0;
      v14 = v53;
      if ((int)v17 >= v57)
        goto LABEL_139;
    }
  }
  v53 = v14;
LABEL_139:
  if ((int)v16 < *((_DWORD *)v5 + 4))
  {
    LODWORD(v59) = v16;
    do
    {
      v60 = v15;
      v61 = *((_QWORD *)v5 + 3) + 16 * (int)v59;
      v63 = *(_DWORD *)v61;
      v62 = *(_DWORD *)(v61 + 4);
      v64 = *(float *)(v61 + 8);
      v65 = v15 >= *(_DWORD *)v61;
      if (v15 >= *(_DWORD *)v61)
        v15 = *(_DWORD *)(v61 + 4);
      else
        v15 = *(_DWORD *)v61;
      if (v60 >= v62)
        v65 = 0;
      v66 = 0.0;
      if (v65)
        v66 = (float)((float)(v64 * (float)(v62 - v15)) + (float)((float)(v15 - v63) * *(float *)(v61 + 12)))
            / (float)(v62 - v63);
      if (a4 == 3)
      {
        if (!v65)
          goto LABEL_155;
        v67 = v13 - v53;
      }
      else
      {
        if (a4 || !v65)
          goto LABEL_155;
        v67 = v13 + v53;
        v66 = v66 + 0.0;
      }
      result = IntLigne::AddRun(v72, v60, v15, v67, v66);
LABEL_155:
      v68 = *((_DWORD *)v5 + 4);
      if (v60 >= v63)
      {
        v59 = (int)v59 + 1;
        v64 = 0.0;
        if ((int)v59 < v68)
        {
          v69 = *((_QWORD *)v5 + 3);
          if (*(_DWORD *)(v69 + 16 * v59) == v62)
            v64 = *(float *)(v69 + 16 * v59 + 8);
        }
      }
      v53 = 0.0;
      v13 = v64;
    }
    while ((int)v59 < v68);
  }
  return result;
}

void **IntLigne::Copy(void **this, const void **a2)
{
  void **v2;
  uint64_t v3;
  void *v5;

  v2 = this;
  v3 = *((unsigned int *)a2 + 4);
  *(_DWORD *)this = 0;
  if ((int)v3 <= 0)
  {
    *((_DWORD *)this + 4) = 0;
    this[4] = (void *)-1;
  }
  else
  {
    *((_DWORD *)this + 4) = v3;
    if ((int)v3 <= *((_DWORD *)this + 5))
    {
      v5 = this[3];
    }
    else
    {
      *((_DWORD *)this + 5) = v3;
      v5 = malloc_type_realloc(this[3], 16 * v3, 0x1000040451B5BE8uLL);
      v2[3] = v5;
      LODWORD(v3) = *((_DWORD *)v2 + 4);
    }
    return (void **)memcpy(v5, a2[3], 16 * (int)v3);
  }
  return this;
}

uint64_t IntLigne::Copy(uint64_t this, FloatLigne *a2)
{
  int v2;
  IntLigne *v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  int v8;
  float v9;
  float *v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  int v17;
  double v18;
  float v19;
  int v20;
  float v21;
  float v22;
  int v23;
  float v24;
  double v25;
  float *v26;
  double v27;
  double v28;
  double v29;
  double v30;

  v2 = *((_DWORD *)a2 + 4);
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 32) = -1;
  if (v2 >= 1)
  {
    v4 = (IntLigne *)this;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = (int)**((float **)a2 + 3) - 1;
    v9 = 0.0;
    while (1)
    {
      v10 = (float *)(*((_QWORD *)a2 + 3) + v5);
      v11 = *v10;
      v12 = v10[1];
      v13 = v10[2];
      v14 = v10[3];
      v15 = v10[4];
      v16 = floorf(*v10);
      v17 = vcvtms_s32_f32(*v10);
      v18 = (float)(*v10 - v16);
      v19 = v16 + 1.0;
      if (v18 < 0.00001)
        v20 = v17;
      else
        v20 = v17 + 1;
      if (v18 < 0.00001)
        v19 = v16;
      v21 = v10[2];
      if (v11 != (float)v20)
      {
        v21 = v10[3];
        if (v12 != (float)v20)
          v21 = v13 + (float)((float)(v19 - v11) * v15);
      }
      v22 = floorf(v12);
      v23 = vcvtms_s32_f32(v12);
      v24 = v10[2];
      if (v11 != (float)v23)
      {
        v24 = v10[3];
        if (v12 != (float)v23)
          v24 = v13 + (float)((float)(v22 - v11) * v15);
      }
      v25 = (float)(v12 - v22);
      if (v18 >= 0.00001)
      {
        if (v25 < 0.00001 || v23 > v17)
        {
          if ((v7 & 1) != 0)
          {
            if (v8 < v17)
            {
              IntLigne::AddRun(v4, v8, v8 + 1, v9, v9);
              v26 = (float *)(*((_QWORD *)a2 + 3) + v5);
              v27 = (float)(v21 + v26[2]) * 0.5;
              v28 = v16 + 1.0 - *v26;
              goto LABEL_21;
            }
            v29 = v9 + (float)(v21 + v13) * 0.5 * (v16 + 1.0 - v11);
          }
          else
          {
            v28 = (float)(v21 + v13) * 0.5;
            v27 = v16 + 1.0 - v11;
LABEL_21:
            v29 = v27 * v28;
          }
          v9 = v29;
          this = IntLigne::AddRun(v4, v17, v17 + 1, v9, v9);
          v7 = 0;
          goto LABEL_27;
        }
        if ((v7 & 1) == 0)
        {
          v30 = (float)(v14 + v13) * 0.5 * (float)(v12 - v11);
          goto LABEL_41;
        }
        if (v8 < v17)
        {
          this = IntLigne::AddRun(v4, v8, v8 + 1, v9, v9);
          v30 = (float)(*(float *)(*((_QWORD *)a2 + 3) + v5 + 12) + *(float *)(*((_QWORD *)a2 + 3) + v5 + 8))
              * 0.5
              * (float)(*(float *)(*((_QWORD *)a2 + 3) + v5 + 4) - *(float *)(*((_QWORD *)a2 + 3) + v5));
LABEL_41:
          v9 = v30;
          v7 = 1;
          v8 = v17;
          goto LABEL_27;
        }
        v9 = v9 + (float)(v14 + v13) * 0.5 * (float)(v12 - v11);
        v7 = 1;
      }
LABEL_27:
      if (v20 < v23)
      {
        if ((v7 & (v8 < v20)) == 1)
          IntLigne::AddRun(v4, v8, v8 + 1, v9, v9);
        this = IntLigne::AddRun(v4, v20, v23, v21, v24);
        v7 = 0;
      }
      if (v25 < 0.00001)
        goto LABEL_38;
      if (v23 > v17)
        goto LABEL_37;
      if (v18 < 0.00001)
      {
        if ((v7 & 1) != 0)
          this = IntLigne::AddRun(v4, v8, v8 + 1, v9, v9);
        v24 = v21;
LABEL_37:
        v9 = (float)(v24 + *(float *)(*((_QWORD *)a2 + 3) + v5 + 12))
           * 0.5
           * (float)(*(float *)(*((_QWORD *)a2 + 3) + v5 + 4) - v22);
        v7 = 1;
        v8 = v23;
      }
LABEL_38:
      ++v6;
      v5 += 20;
      if (v6 >= *((int *)a2 + 4))
      {
        if ((v7 & 1) != 0)
          return IntLigne::AddRun(v4, v8, v8 + 1, v9, v9);
        return this;
      }
    }
  }
  return this;
}

void Path::Path(Path *this)
{
  this->var2 = 0;
  *(_QWORD *)&this->var0 = 0;
  this->var3 = 0;
  *(_QWORD *)&this->var4 = -1;
  *(_WORD *)&this->var6 = 0;
  *(_QWORD *)&this->var10 = 0;
  *(_QWORD *)&this->var8 = 0;
  HIDWORD(this->var11) = 0;
}

{
  this->var2 = 0;
  *(_QWORD *)&this->var0 = 0;
  this->var3 = 0;
  *(_QWORD *)&this->var4 = -1;
  *(_WORD *)&this->var6 = 0;
  *(_QWORD *)&this->var10 = 0;
  *(_QWORD *)&this->var8 = 0;
  HIDWORD(this->var11) = 0;
}

void Path::~Path(Path *this)
{
  path_descr *var3;
  char *var11;

  var3 = this->var3;
  if (var3)
  {
    free(var3);
    this->var3 = 0;
  }
  var11 = this->var11;
  if (var11)
    free(var11);
  this->var1 = 0;
  this->var2 = 0;
  this->var3 = 0;
  *(_QWORD *)&this->var10 = 0;
  *(_QWORD *)&this->var8 = 0;
  HIDWORD(this->var11) = 0;
}

uint64_t Path::Affiche(Path *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  int v5;
  const char *v6;

  result = printf("path descr %i elems\n", this->var2);
  if (this->var2 >= 1)
  {
    v3 = 0;
    v4 = 0;
    do
    {
      printf("  ");
      result = printf("[ %i %f %f ] ", *(_DWORD *)((char *)this->var3 + v3 + 4), *(float *)((char *)this->var3 + v3 + 8), *(float *)((char *)this->var3 + v3 + 12));
      v5 = *(_DWORD *)((char *)this->var3 + v3);
      if ((v5 & 0x10) != 0)
      {
        result = printf(" w ");
        v5 = *(_DWORD *)((char *)this->var3 + v3);
      }
      switch(v5 & 0xF)
      {
        case 0:
          result = printf("M %f %f %i\n");
          break;
        case 1:
          result = printf("L %f %f\n");
          break;
        case 2:
          result = printf("C %f %f %f %f %f %f\n");
          break;
        case 3:
          result = printf("B %f %f %i\n");
          break;
        case 4:
          result = printf("A %f %f %f %f %i %i\n");
          break;
        case 5:
          v6 = "Z";
          goto LABEL_15;
        case 6:
          result = printf("I %f %f\n");
          break;
        case 7:
          v6 = "F";
LABEL_15:
          result = puts(v6);
          break;
        default:
          break;
      }
      ++v4;
      v3 += 44;
    }
    while (v4 < this->var2);
  }
  return result;
}

double Path::Reset(Path *this)
{
  double result;

  this->var2 = 0;
  result = NAN;
  *(_QWORD *)&this->var4 = -1;
  this->var0 = 0;
  return result;
}

void *Path::Copy(Path *this, Path *a2)
{
  int var2;
  int v5;

  Path::ResetPoints(this, 0);
  var2 = a2->var2;
  if (var2 > this->var1)
  {
    this->var1 = var2;
    this->var3 = (path_descr *)malloc_type_realloc(this->var3, 44 * var2, 0x1000040D4159EFEuLL);
  }
  Path::SetWeighted(this, a2->var6);
  v5 = a2->var2;
  this->var2 = v5;
  return memcpy(this->var3, a2->var3, 44 * v5);
}

Path *Path::ResetPoints(Path *this, int a2)
{
  int v2;
  int v3;
  int v4;
  Path *v5;

  this->var8 = 0;
  v2 = 12 * a2;
  if (this->var6)
  {
    v2 = 16 * a2;
    v3 = 24 * a2;
  }
  else
  {
    v3 = 20 * a2;
  }
  if (this->var7)
    v4 = v3;
  else
    v4 = v2;
  this->var10 = v4;
  if (v4 > this->var9)
  {
    v5 = this;
    this->var9 = v4;
    this = (Path *)malloc_type_realloc(this->var11, v4, 0x5CE81E30uLL);
    v5->var11 = (char *)this;
  }
  return this;
}

Path *Path::SetWeighted(Path *this, int a2)
{
  BOOL v2;

  if (a2)
  {
    if (this->var6)
      return this;
    v2 = 1;
  }
  else
  {
    if (!this->var6)
      return this;
    v2 = 0;
  }
  this->var6 = v2;
  return Path::ResetPoints(this, this->var8);
}

Path *Path::Alloue(Path *this, int a2)
{
  int var2;
  Path *v3;
  int v4;

  var2 = this->var2;
  if (var2 + a2 > this->var1)
  {
    v3 = this;
    v4 = a2 + 2 * var2;
    this->var1 = v4;
    this = (Path *)malloc_type_realloc(this->var3, 44 * v4, 0x1000040D4159EFEuLL);
    v3->var3 = (path_descr *)this;
  }
  return this;
}

Path *Path::CloseSubpath(Path *this, int a2)
{
  int var2;
  uint64_t v3;
  BOOL v4;
  path_descr *var3;
  char *v6;

  var2 = this->var2;
  v3 = 44 * var2;
  while (1)
  {
    v4 = __OFSUB__(var2--, 1);
    if (var2 < 0 != v4)
      break;
    var3 = this->var3;
    v6 = (char *)var3 + v3;
    ++a2;
    v3 -= 44;
    if ((*(v6 - 44) & 0xF) == 0)
    {
      *(_DWORD *)((char *)var3 + v3 + 24) = a2;
      break;
    }
  }
  this->var0 &= ~2u;
  this->var5 = -1;
  return this;
}

double Path::ForcePoint(Path *this)
{
  int var0;
  int var4;
  int var2;
  _QWORD *v5;
  double result;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    if ((var0 & 4) != 0)
    {
      var0 &= 0xFFFFFFFA;
      this->var0 = var0;
      var4 = this->var4;
      if ((var4 & 0x80000000) == 0)
      {
        this->var2 = var4;
        this->var4 = -1;
      }
    }
    else
    {
      this->var4 = -1;
      var0 &= 0xFFFFFFFA;
      this->var0 = var0;
    }
  }
  if ((var0 & 2) != 0)
  {
    Path::Alloue(this, 1);
    var2 = this->var2;
    v5 = (_QWORD *)((char *)this->var3 + 44 * var2);
    this->var2 = var2 + 1;
    result = 0.0078125;
    *v5 = 0xFFFFFFFF00000007;
    v5[1] = 0x3F80000000000000;
  }
  return result;
}

uint64_t Path::EndBezierTo(Path *this)
{
  int var0;
  int var4;

  var0 = this->var0;
  if ((this->var0 & 4) != 0)
  {
    this->var0 = var0 & 0xFFFFFFFA;
    var4 = this->var4;
    if ((var4 & 0x80000000) == 0)
    {
      this->var2 = var4;
      this->var4 = -1;
    }
  }
  else
  {
    this->var4 = -1;
    this->var0 = var0 & 0xFFFFFFFA;
  }
  return 0xFFFFFFFFLL;
}

uint64_t Path::Close(Path *this)
{
  int var0;
  int var4;
  uint64_t v4;
  uint64_t var2;
  _QWORD *v6;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    var0 &= 0xFFFFFFFA;
    this->var0 = var0;
    var4 = this->var4;
    if ((var4 & 0x80000000) == 0)
    {
      this->var2 = var4;
      this->var4 = -1;
    }
  }
  v4 = 0xFFFFFFFFLL;
  if ((var0 & 2) != 0)
  {
    Path::CloseSubpath(this, 1);
    Path::Alloue(this, 1);
    var2 = this->var2;
    v6 = (_QWORD *)((char *)this->var3 + 44 * (int)var2);
    this->var2 = var2 + 1;
    *v6 = -4294967291;
    v6[1] = 0x3F80000000000000;
    this->var0 &= ~2u;
    this->var5 = -1;
    return var2;
  }
  return v4;
}

Path *Path::CancelBezier(Path *this)
{
  int var4;

  this->var0 &= 0xFFFFFFFA;
  var4 = this->var4;
  if ((var4 & 0x80000000) == 0)
  {
    this->var2 = var4;
    this->var4 = -1;
  }
  return this;
}

uint64_t Path::MoveTo(Path *this, float a2, float a3)
{
  int var0;
  int var2;
  char *v8;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::EndBezierTo(this, a2, a3);
    var0 = this->var0;
  }
  if ((var0 & 2) != 0)
    Path::CloseSubpath(this, 0);
  this->var5 = this->var2;
  Path::Alloue(this, 1);
  var2 = this->var2;
  v8 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v8 = 0xFFFFFFFF00000000;
  *((_QWORD *)v8 + 1) = 0x3F80000000000000;
  *((float *)v8 + 4) = a2;
  *((float *)v8 + 5) = a3;
  *((_DWORD *)v8 + 6) = 0;
  this->var0 |= 2u;
  return (this->var2 - 1);
}

uint64_t Path::EndBezierTo(Path *this, float a2, float a3)
{
  int var0;
  path_descr *var3;
  int var4;

  var0 = this->var0;
  if ((this->var0 & 1) == 0)
    return Path::LineTo(this, a2, a3);
  if ((var0 & 2) == 0)
    return Path::MoveTo(this, a2, a3);
  if ((var0 & 4) != 0)
  {
    *((float *)this->var3 + 11 * this->var4 + 5) = a2;
    *((float *)this->var3 + 11 * this->var4 + 6) = a3;
    var3 = this->var3;
    var4 = this->var4;
    if ((*((_BYTE *)var3 + 44 * var4) & 0x10) != 0)
      *((_DWORD *)var3 + 11 * var4 + 7) = 1065353216;
    this->var4 = -1;
    var0 = this->var0;
  }
  else
  {
    this->var4 = -1;
  }
  this->var0 = var0 & 0xFFFFFFFA;
  return 0xFFFFFFFFLL;
}

uint64_t Path::MoveTo(Path *this, float a2, float a3, float a4)
{
  int var0;
  int var2;
  char *v10;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::EndBezierTo(this, a2, a3, a4);
    var0 = this->var0;
  }
  if ((var0 & 2) != 0)
    Path::CloseSubpath(this, 0);
  this->var5 = this->var2;
  Path::Alloue(this, 1);
  var2 = this->var2;
  v10 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v10 = 0xFFFFFFFF00000010;
  *((_QWORD *)v10 + 1) = 0x3F80000000000000;
  *((float *)v10 + 4) = a2;
  *((float *)v10 + 5) = a3;
  *((float *)v10 + 7) = a4;
  *((_DWORD *)v10 + 6) = 0;
  this->var0 |= 2u;
  return (this->var2 - 1);
}

uint64_t Path::EndBezierTo(Path *this, float a2, float a3, float a4)
{
  int var0;

  var0 = this->var0;
  if ((this->var0 & 1) == 0)
    return Path::LineTo(this, a2, a3, a4);
  if ((var0 & 2) == 0)
    return Path::MoveTo(this, a2, a3, a4);
  if ((var0 & 4) != 0)
  {
    *((float *)this->var3 + 11 * this->var4 + 5) = a2;
    *((float *)this->var3 + 11 * this->var4 + 6) = a3;
    *((float *)this->var3 + 11 * this->var4 + 7) = a4;
    this->var4 = -1;
    var0 = this->var0;
  }
  else
  {
    this->var4 = -1;
  }
  this->var0 = var0 & 0xFFFFFFFA;
  return 0xFFFFFFFFLL;
}

uint64_t Path::LineTo(Path *this, float a2, float a3)
{
  int var0;
  int var2;
  char *v9;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::EndBezierTo(this, a2, a3);
    var0 = this->var0;
  }
  if ((var0 & 2) == 0)
    return Path::MoveTo(this, a2, a3);
  Path::Alloue(this, 1);
  var2 = this->var2;
  v9 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v9 = 0xFFFFFFFF00000001;
  *((_QWORD *)v9 + 1) = 0x3F80000000000000;
  *((float *)v9 + 4) = a2;
  *((float *)v9 + 5) = a3;
  return (this->var2 - 1);
}

uint64_t Path::LineTo(Path *this, float a2, float a3, float a4)
{
  int var0;
  int var2;
  char *v11;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::EndBezierTo(this, a2, a3, a4);
    var0 = this->var0;
  }
  if ((var0 & 2) == 0)
    return Path::MoveTo(this, a2, a3, a4);
  Path::Alloue(this, 1);
  var2 = this->var2;
  v11 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v11 = -4294967279;
  *((_QWORD *)v11 + 1) = 0x3F80000000000000;
  *((float *)v11 + 4) = a2;
  *((float *)v11 + 5) = a3;
  *((float *)v11 + 6) = a4;
  return (this->var2 - 1);
}

uint64_t Path::CubicTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7)
{
  int var0;
  int var2;
  char *v17;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::EndBezierTo(this, a2, a3);
    var0 = this->var0;
  }
  if ((var0 & 2) == 0)
    return Path::MoveTo(this, a2, a3);
  Path::Alloue(this, 1);
  var2 = this->var2;
  v17 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v17 = 0xFFFFFFFF00000002;
  *((_QWORD *)v17 + 1) = 0x3F80000000000000;
  *((float *)v17 + 4) = a2;
  *((float *)v17 + 5) = a3;
  *((float *)v17 + 6) = a4;
  *((float *)v17 + 7) = a5;
  *((float *)v17 + 8) = a6;
  *((float *)v17 + 9) = a7;
  return (this->var2 - 1);
}

uint64_t Path::CubicTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  int var0;
  int var2;
  char *v19;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::EndBezierTo(this, a2, a3, a8);
    var0 = this->var0;
  }
  if ((var0 & 2) == 0)
    return Path::MoveTo(this, a2, a3, a8);
  Path::Alloue(this, 1);
  var2 = this->var2;
  v19 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v19 = -4294967278;
  *((_QWORD *)v19 + 1) = 0x3F80000000000000;
  *((float *)v19 + 4) = a2;
  *((float *)v19 + 5) = a3;
  *((float *)v19 + 9) = a7;
  *((float *)v19 + 10) = a8;
  *((float *)v19 + 6) = a4;
  *((float *)v19 + 7) = a5;
  *((float *)v19 + 8) = a6;
  return (this->var2 - 1);
}

uint64_t Path::ArcTo(Path *this, float a2, float a3, float a4, float a5, float a6, char a7, char a8)
{
  int var0;
  int var2;
  char *v19;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::EndBezierTo(this, a2, a3);
    var0 = this->var0;
  }
  if ((var0 & 2) == 0)
    return Path::MoveTo(this, a2, a3);
  Path::Alloue(this, 1);
  var2 = this->var2;
  v19 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v19 = 0xFFFFFFFF00000004;
  *((_QWORD *)v19 + 1) = 0x3F80000000000000;
  *((float *)v19 + 4) = a2;
  *((float *)v19 + 5) = a3;
  *((float *)v19 + 6) = a4;
  *((float *)v19 + 7) = a5;
  *((float *)v19 + 8) = a6;
  v19[36] = a7;
  v19[37] = a8;
  return (this->var2 - 1);
}

uint64_t Path::ArcTo(Path *this, float a2, float a3, float a4, float a5, float a6, char a7, char a8, float a9)
{
  int var0;
  int var2;
  char *v21;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::EndBezierTo(this, a2, a3, a9);
    var0 = this->var0;
  }
  if ((var0 & 2) == 0)
    return Path::MoveTo(this, a2, a3, a9);
  Path::Alloue(this, 1);
  var2 = this->var2;
  v21 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v21 = -4294967276;
  *((_QWORD *)v21 + 1) = 0x3F80000000000000;
  *((float *)v21 + 4) = a2;
  *((float *)v21 + 5) = a3;
  *((float *)v21 + 10) = a9;
  *((float *)v21 + 6) = a4;
  *((float *)v21 + 7) = a5;
  *((float *)v21 + 8) = a6;
  v21[36] = a7;
  v21[37] = a8;
  return (this->var2 - 1);
}

uint64_t Path::TempBezierTo(Path *this)
{
  int var0;
  int var4;
  int var2;
  char *v6;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    var0 &= 0xFFFFFFFA;
    this->var0 = var0;
    var4 = this->var4;
    if ((var4 & 0x80000000) == 0)
    {
      this->var2 = var4;
      this->var4 = -1;
    }
  }
  if ((var0 & 2) == 0)
    return 0xFFFFFFFFLL;
  this->var4 = this->var2;
  Path::Alloue(this, 1);
  var2 = this->var2;
  v6 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v6 = 0xFFFFFFFF00000003;
  *((_QWORD *)v6 + 1) = 0x3F80000000000000;
  *((_DWORD *)v6 + 4) = 0;
  this->var0 |= 5u;
  return (this->var2 - 1);
}

uint64_t Path::TempBezierToW(Path *this)
{
  int var0;
  int var4;
  int var2;
  char *v6;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    var0 &= 0xFFFFFFFA;
    this->var0 = var0;
    var4 = this->var4;
    if ((var4 & 0x80000000) == 0)
    {
      this->var2 = var4;
      this->var4 = -1;
    }
  }
  if ((var0 & 2) == 0)
    return 0xFFFFFFFFLL;
  this->var4 = this->var2;
  Path::Alloue(this, 1);
  var2 = this->var2;
  v6 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v6 = -4294967277;
  *((_QWORD *)v6 + 1) = 0x3F80000000000000;
  *((_DWORD *)v6 + 4) = 0;
  this->var0 |= 5u;
  return (this->var2 - 1);
}

uint64_t Path::IntermBezierTo(Path *this, float a2, float a3)
{
  int var2;
  char *v8;
  char *v9;

  if ((this->var0 & 1) == 0)
    return Path::LineTo(this, a2, a3);
  if ((this->var0 & 2) == 0)
    return Path::MoveTo(this, a2, a3);
  if ((*((_BYTE *)this->var3 + 44 * this->var4) & 0x10) != 0)
    return Path::IntermBezierTo(this, a2, a3, 1.0);
  Path::Alloue(this, 1);
  var2 = this->var2;
  v8 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v8 = -4294967290;
  *((_QWORD *)v8 + 1) = 0x3F80000000000000;
  *((float *)v8 + 4) = a2;
  *((float *)v8 + 5) = a3;
  v9 = (char *)this->var3 + 44 * this->var4;
  ++*((_DWORD *)v9 + 4);
  return (this->var2 - 1);
}

uint64_t Path::IntermBezierTo(Path *this, float a2, float a3, float a4)
{
  int var2;
  char *v10;
  char *v11;

  if ((this->var0 & 1) == 0)
    return Path::LineTo(this, a2, a3, a4);
  if ((this->var0 & 2) == 0)
    return Path::MoveTo(this, a2, a3, a4);
  if ((*((_BYTE *)this->var3 + 44 * this->var4) & 0x10) == 0)
    return Path::IntermBezierTo(this, a2, a3);
  Path::Alloue(this, 1);
  var2 = this->var2;
  v10 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v10 = -4294967274;
  *((_QWORD *)v10 + 1) = 0x3F80000000000000;
  *((float *)v10 + 4) = a2;
  *((float *)v10 + 5) = a3;
  *((float *)v10 + 6) = a4;
  v11 = (char *)this->var3 + 44 * this->var4;
  ++*((_DWORD *)v11 + 4);
  return (this->var2 - 1);
}

uint64_t Path::BezierTo(Path *this, float a2, float a3)
{
  int var0;
  int var2;
  char *v9;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::EndBezierTo(this, a2, a3);
    var0 = this->var0;
  }
  if ((var0 & 2) == 0)
    return Path::MoveTo(this, a2, a3);
  this->var4 = this->var2;
  Path::Alloue(this, 1);
  var2 = this->var2;
  v9 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v9 = 0xFFFFFFFF00000003;
  *((_QWORD *)v9 + 1) = 0x3F80000000000000;
  *((_DWORD *)v9 + 4) = 0;
  *((float *)v9 + 5) = a2;
  *((float *)v9 + 6) = a3;
  this->var0 = this->var0 & 0xFFFFFFFA | 1;
  return (this->var2 - 1);
}

uint64_t Path::BezierTo(Path *this, float a2, float a3, float a4)
{
  int var0;
  int var2;
  char *v11;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::EndBezierTo(this, a2, a3, a4);
    var0 = this->var0;
  }
  if ((var0 & 2) == 0)
    return Path::MoveTo(this, a2, a3, a4);
  this->var4 = this->var2;
  Path::Alloue(this, 1);
  var2 = this->var2;
  v11 = (char *)this->var3 + 44 * var2;
  this->var2 = var2 + 1;
  *(_QWORD *)v11 = -4294967277;
  *((_QWORD *)v11 + 1) = 0x3F80000000000000;
  *((_DWORD *)v11 + 4) = 0;
  *((float *)v11 + 5) = a2;
  *((float *)v11 + 6) = a3;
  *((float *)v11 + 7) = a4;
  this->var0 = this->var0 & 0xFFFFFFFA | 1;
  return (this->var2 - 1);
}

Path *Path::SetBackData(Path *this, char a2)
{
  BOOL v2;

  if (this->var7)
  {
    if ((a2 & 1) != 0)
      return this;
    v2 = 0;
  }
  else
  {
    if ((a2 & 1) == 0)
      return this;
    v2 = 1;
  }
  this->var7 = v2;
  return Path::ResetPoints(this, this->var8);
}

uint64_t Path::AddPoint(Path *this, float a2, float a3, BOOL a4)
{
  uint64_t result;
  int var10;
  int v10;
  int v11;
  int var8;
  char *var11;
  int v14;
  char *v15;

  if (this->var7)
    return Path::AddPoint(this, a2, a3, -1, 0.0, a4);
  if (this->var6)
    return Path::AddPoint(this, a2, a3, 1.0, a4);
  var10 = this->var10;
  v10 = var10 + 12;
  if (var10 + 12 > this->var9)
  {
    v11 = 2 * var10 + 12;
    this->var9 = v11;
    this->var11 = (char *)malloc_type_realloc(this->var11, v11, 0x62A63B71uLL);
  }
  result = this->var8;
  var8 = this->var8;
  if (a4)
  {
    this->var8 = result + 1;
    this->var10 = v10;
    var11 = this->var11;
    *(_DWORD *)&var11[12 * var8] = 1;
  }
  else
  {
    var11 = this->var11;
    v14 = result - 1;
    if ((int)result >= 1 && *(float *)&var11[12 * v14 + 4] == a2 && *(float *)&var11[12 * v14 + 8] == a3)
      return 0xFFFFFFFFLL;
    this->var8 = result + 1;
    this->var10 = v10;
    *(_DWORD *)&var11[12 * var8] = 0;
  }
  v15 = &var11[12 * var8];
  *((float *)v15 + 1) = a2;
  *((float *)v15 + 2) = a3;
  return result;
}

uint64_t Path::AddPoint(Path *this, float a2, float a3, int a4, float a5, BOOL a6)
{
  uint64_t result;
  int var10;
  int v14;
  int v15;
  int var8;
  char *var11;
  char *v18;
  char *v19;

  if (!this->var7)
    return Path::AddPoint(this, a2, a3, a6);
  if (this->var6)
    return Path::AddPoint(this, a2, a3, 1.0, a4, a5, a6);
  var10 = this->var10;
  v14 = var10 + 20;
  if (var10 + 20 > this->var9)
  {
    v15 = 2 * var10 + 20;
    this->var9 = v15;
    this->var11 = (char *)malloc_type_realloc(this->var11, v15, 0x6D330906uLL);
  }
  result = this->var8;
  var8 = this->var8;
  if (a6)
  {
    this->var8 = result + 1;
    this->var10 = v14;
    var11 = this->var11;
    *(_DWORD *)&var11[20 * var8] = 1;
  }
  else
  {
    var11 = this->var11;
    if ((int)result >= 1)
    {
      v18 = &var11[20 * (result - 1)];
      if (*((float *)v18 + 1) == a2 && *((float *)v18 + 2) == a3)
        return 0xFFFFFFFFLL;
    }
    this->var8 = result + 1;
    this->var10 = v14;
    *(_DWORD *)&var11[20 * var8] = 0;
  }
  v19 = &var11[20 * var8];
  *((float *)v19 + 1) = a2;
  *((float *)v19 + 2) = a3;
  *((_DWORD *)v19 + 3) = a4;
  *((float *)v19 + 4) = a5;
  return result;
}

uint64_t Path::AddPoint(Path *this, float a2, float a3, float a4, BOOL a5)
{
  uint64_t result;
  int var10;
  int v12;
  int v13;
  char *var11;
  char *v15;
  float *v16;

  if (this->var7)
    return Path::AddPoint(this, a2, a3, a4, -1, 0.0, a5);
  if (!this->var6)
    return Path::AddPoint(this, a2, a3, a5);
  var10 = this->var10;
  v12 = var10 + 16;
  if (var10 + 16 > this->var9)
  {
    v13 = 2 * var10 + 16;
    this->var9 = v13;
    this->var11 = (char *)malloc_type_realloc(this->var11, v13, 0xA7B035DAuLL);
  }
  result = this->var8;
  if (a5)
  {
    this->var8 = result + 1;
    this->var10 = v12;
    var11 = this->var11;
    *(_DWORD *)&var11[16 * (int)result] = 1;
  }
  else
  {
    var11 = this->var11;
    if ((int)result >= 1)
    {
      v15 = &var11[16 * (result - 1)];
      if (*((float *)v15 + 1) == a2 && *((float *)v15 + 2) == a3)
        return 0xFFFFFFFFLL;
    }
    this->var8 = result + 1;
    this->var10 = v12;
    *(_DWORD *)&var11[16 * (int)result] = 0;
  }
  v16 = (float *)&var11[16 * (int)result];
  v16[1] = a2;
  v16[2] = a3;
  v16[3] = a4;
  return result;
}

uint64_t Path::AddPoint(Path *this, float a2, float a3, float a4, int a5, float a6, BOOL a7)
{
  int var10;
  int v15;
  int v16;
  uint64_t result;
  int var8;
  char *var11;
  char *v20;
  char *v21;

  if (!this->var7)
    return Path::AddPoint(this, a2, a3, a4, a7);
  if (!this->var6)
    return Path::AddPoint(this, a2, a3, a5, a6, a7);
  var10 = this->var10;
  v15 = var10 + 24;
  if (var10 + 24 > this->var9)
  {
    v16 = 2 * var10 + 24;
    this->var9 = v16;
    this->var11 = (char *)malloc_type_realloc(this->var11, v16, 0x30488573uLL);
  }
  result = this->var8;
  var8 = this->var8;
  if (a7)
  {
    this->var8 = result + 1;
    this->var10 = v15;
    var11 = this->var11;
    *(_DWORD *)&var11[24 * var8] = 1;
  }
  else
  {
    var11 = this->var11;
    if ((int)result >= 1)
    {
      v20 = &var11[24 * (result - 1)];
      if (*((float *)v20 + 1) == a2 && *((float *)v20 + 2) == a3)
        return 0xFFFFFFFFLL;
    }
    this->var8 = result + 1;
    this->var10 = v15;
    *(_DWORD *)&var11[24 * var8] = 0;
  }
  v21 = &var11[24 * var8];
  *((float *)v21 + 1) = a2;
  *((float *)v21 + 2) = a3;
  *((float *)v21 + 3) = a4;
  *((_DWORD *)v21 + 4) = a5;
  *((float *)v21 + 5) = a6;
  return result;
}

double Path::AddForcedPoint(Path *this, double result, float a3)
{
  int var10;
  int v5;
  int v6;
  int var8;
  int v8;
  char *var11;
  char *v10;

  if (this->var7)
  {
    Path::AddForcedPoint(this, *(float *)&result, a3, -1, 0.0);
  }
  else if (this->var6)
  {
    *(float *)&result = Path::AddForcedPoint(this, *(float *)&result, a3, 1.0);
  }
  else
  {
    var10 = this->var10;
    v5 = var10 + 12;
    if (var10 + 12 > this->var9)
    {
      v6 = 2 * var10 + 12;
      this->var9 = v6;
      this->var11 = (char *)malloc_type_realloc(this->var11, v6, 0x39144A8uLL);
    }
    var8 = this->var8;
    v8 = var8 - 1;
    if (var8 >= 1)
    {
      var11 = this->var11;
      if (!*(_DWORD *)&var11[12 * v8])
      {
        this->var8 = var8 + 1;
        this->var10 = v5;
        v10 = &var11[12 * var8];
        *(_DWORD *)v10 = 2;
        result = *(double *)&var11[12 * v8 + 4];
        *(double *)(v10 + 4) = result;
      }
    }
  }
  return result;
}

float Path::AddForcedPoint(Path *this, double a2, float a3, int a4, float a5)
{
  int var10;
  int v7;
  int v8;
  int var8;
  int v10;
  char *var11;
  char *v12;
  char *v13;

  if (this->var7)
  {
    if (this->var6)
    {
      *(float *)&a2 = Path::AddForcedPoint(this, *(float *)&a2, a3, 1.0, a4, a5);
    }
    else
    {
      var10 = this->var10;
      v7 = var10 + 20;
      if (var10 + 20 > this->var9)
      {
        v8 = 2 * var10 + 20;
        this->var9 = v8;
        this->var11 = (char *)malloc_type_realloc(this->var11, v8, 0x431BE692uLL);
      }
      var8 = this->var8;
      v10 = var8 - 1;
      if (var8 >= 1)
      {
        var11 = this->var11;
        if (!*(_DWORD *)&var11[20 * v10])
        {
          this->var8 = var8 + 1;
          this->var10 = v7;
          v12 = &var11[20 * var8];
          *(_DWORD *)v12 = 2;
          v13 = &var11[20 * v10];
          *(_QWORD *)(v12 + 4) = *(_QWORD *)(v13 + 4);
          *((_DWORD *)v12 + 3) = *((_DWORD *)v13 + 3);
          LODWORD(a2) = *((_DWORD *)v13 + 4);
          *((_DWORD *)v12 + 4) = LODWORD(a2);
        }
      }
    }
  }
  else
  {
    a2 = Path::AddForcedPoint(this, a2, a3);
  }
  return *(float *)&a2;
}

float Path::AddForcedPoint(Path *this, float result, float a3, float a4)
{
  int var10;
  int v6;
  int v7;
  uint64_t var8;
  char *var11;
  char *v10;
  char *v11;

  if (this->var7)
    return Path::AddForcedPoint(this, result, a3, a4, -1, 0.0);
  if (this->var6)
  {
    var10 = this->var10;
    v6 = var10 + 16;
    if (var10 + 16 > this->var9)
    {
      v7 = 2 * var10 + 16;
      this->var9 = v7;
      this->var11 = (char *)malloc_type_realloc(this->var11, v7, 0x300662EFuLL);
    }
    var8 = this->var8;
    if ((int)var8 >= 1)
    {
      var11 = this->var11;
      if (!*(_DWORD *)&var11[16 * (var8 - 1)])
      {
        this->var8 = var8 + 1;
        this->var10 = v6;
        v10 = &var11[16 * var8];
        *(_DWORD *)v10 = 2;
        v11 = &var11[16 * (var8 - 1)];
        *(_QWORD *)(v10 + 4) = *(_QWORD *)(v11 + 4);
        result = *((float *)v11 + 3);
        *((float *)v10 + 3) = result;
      }
    }
  }
  else
  {
    Path::AddForcedPoint(this, result, a3);
  }
  return result;
}

float Path::AddForcedPoint(Path *this, float result, float a3, float a4, int a5, float a6)
{
  int var10;
  int v8;
  int v9;
  int var8;
  int v11;
  char *var11;
  char *v13;
  char *v14;

  if (this->var7)
  {
    if (this->var6)
    {
      var10 = this->var10;
      v8 = var10 + 24;
      if (var10 + 24 > this->var9)
      {
        v9 = 2 * var10 + 24;
        this->var9 = v9;
        this->var11 = (char *)malloc_type_realloc(this->var11, v9, 0x9E2B540AuLL);
      }
      var8 = this->var8;
      v11 = var8 - 1;
      if (var8 >= 1)
      {
        var11 = this->var11;
        if (!*(_DWORD *)&var11[12 * v11])
        {
          this->var8 = var8 + 1;
          this->var10 = v8;
          v13 = &var11[24 * var8];
          *(_DWORD *)v13 = 2;
          v14 = &var11[24 * v11];
          *(_QWORD *)(v13 + 4) = *(_QWORD *)(v14 + 4);
          *((_DWORD *)v13 + 3) = *((_DWORD *)v14 + 3);
          *((_DWORD *)v13 + 4) = *((_DWORD *)v14 + 4);
          result = *((float *)v14 + 5);
          *((float *)v13 + 5) = result;
        }
      }
    }
    else
    {
      Path::AddForcedPoint(this, result, a3, a5, a6);
    }
  }
  else
  {
    Path::AddForcedPoint(this, result, a3, a4);
  }
  return result;
}

uint64_t Path::Winding(Path *this)
{
  int var8;
  uint64_t v3;
  char *var11;
  float *v5;
  float v6;
  uint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  char *v12;
  float *v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  float v18;

  var8 = this->var8;
  if (var8 < 2)
    return 0;
  v3 = (var8 - 1);
  var11 = this->var11;
  if (this->var6)
  {
    v5 = (float *)(var11 + 24);
    v6 = 0.0;
    v7 = v3;
    v8 = *((float *)var11 + 2);
    v9 = *((float *)var11 + 1);
    do
    {
      v10 = *(v5 - 1);
      v11 = *v5;
      v6 = v6 + (float)((float)(v9 + v10) * (float)(*v5 - v8));
      v5 += 4;
      v8 = v11;
      v9 = v10;
      --v7;
    }
    while (v7);
    v12 = &var11[16 * (int)v3];
  }
  else
  {
    v13 = (float *)(var11 + 20);
    v6 = 0.0;
    v14 = v3;
    v15 = *((float *)var11 + 2);
    v16 = *((float *)var11 + 1);
    do
    {
      v17 = *(v13 - 1);
      v18 = *v13;
      v6 = v6 + (float)((float)(v16 + v17) * (float)(*v13 - v15));
      v13 += 3;
      v15 = v18;
      v16 = v17;
      --v14;
    }
    while (v14);
    v12 = &var11[12 * (int)v3];
  }
  if ((float)(v6
             + (float)((float)(*((float *)v12 + 1) + *((float *)var11 + 1))
                     * (float)(*((float *)var11 + 2) - *((float *)v12 + 2)))) > 0.0)
    return 1;
  else
    return 0xFFFFFFFFLL;
}

void Path::PointAt(Path *a1, int a2, float32x2_t *a3, float a4)
{
  path_descr *var3;
  _OWORD *v9;
  __n128 v10;
  __int128 v11;
  uint64_t v12;
  int v13;
  unsigned int v15;
  char *v16;
  int *v17;
  int v18;
  int v19;
  float32_t v21;
  path_descr *v22;
  float32x2_t *v23;
  float32x2_t v24;
  path_descr *v25;
  float32x2_t *v26;
  float v27;
  float *v28;
  float *v29;
  float *v30;
  float *v31;
  float *v32;
  float v33;
  float v34;
  float *v35;
  int v36;
  float v37;
  float v38;
  int v39;
  float v40[2];
  int v41;
  float v42;
  float v43;
  __int128 v44;
  float32x2_t v45[4];

  if (a2 < 0 || a1->var2 <= a2)
  {
    *a3 = 0;
    return;
  }
  var3 = a1->var3;
  v9 = (_OWORD *)((char *)var3 + 44 * a2);
  v10 = *(__n128 *)((char *)v9 + 28);
  v11 = v9[1];
  v44 = *v9;
  *(_OWORD *)v45[0].f32 = v11;
  *(__n128 *)&v45[1].i32[1] = v10;
  if ((v44 & 0xF) == 0)
  {
    v12 = (a2 + 1);
    v10.n128_u32[0] = 0;
    goto LABEL_8;
  }
  if ((v44 & 0xD) != 5)
  {
    switch(v44 & 0xF)
    {
      case 1:
        Path::PrevPoint(a1, a2 - 1, (float *)&v36, &v37);
        v40[0] = 0.0;
        Path::TangentOnSegAt((float *)v45, (float *)a3, &v42, v40, a4, *(float *)&v36, v37);
        return;
      case 2:
        Path::PrevPoint(a1, a2 - 1, (float *)&v36, &v37);
        v40[0] = 0.0;
        v41 = 0;
        v24.i32[0] = v36;
        Path::TangentOnCubAt(v45, 0, a3, (uint64_t)&v42, v40, (float *)&v41, a4, v24, v37);
        return;
      case 3:
      case 6:
        v13 = 0;
        do
        {
          v15 = a2 + v13;
          if (a2 + v13 < 0)
            goto LABEL_5;
          --v13;
        }
        while ((*((_DWORD *)var3 + 11 * v15) & 0xF) != 3);
        v16 = (char *)var3 + 44 * v15;
        v19 = *((_DWORD *)v16 + 4);
        v17 = (int *)(v16 + 16);
        v18 = v19;
        if (a2 + v13 + v19 + 1 < a2)
          break;
        if (v18 == 1 || ~v13 <= 0)
        {
          Path::PrevPoint(a1, a2 + v13, (float *)&v36, &v37);
          v40[0] = 0.0;
          v41 = 0;
          LODWORD(v11) = v36;
          v21 = v37;
          v22 = a1->var3;
          v23 = (float32x2_t *)((char *)v22 + 44 * (a2 + v13 + 2) + 16);
          v17 = (int *)((char *)v22 + 44 * v15 + 16);
        }
        else
        {
          if (v13 == -2)
          {
            Path::PrevPoint(a1, a2 - 2, &v42, &v43);
            v41 = 0;
            v39 = 0;
            v36 = 1;
            v25 = a1->var3;
            v26 = (float32x2_t *)((char *)v25 + 44 * a2);
            v27 = v26[2].f32[0];
            v23 = v26 + 2;
            v28 = (float *)((char *)v25 + 44 * (a2 + 1));
            v37 = (float)(v27 + v28[4]) * 0.5;
            v38 = (float)(v23->f32[1] + v28[5]) * 0.5;
            *(float *)&v11 = v42;
            v21 = v43;
            v17 = &v36;
            v29 = v40;
            v30 = (float *)&v41;
            v31 = (float *)&v39;
LABEL_29:
            Path::TangentOnBezAt(v23, (uint64_t)v17, 0, a3, (uint64_t)v29, v30, v31, a4, *(float32x2_t *)&v11, v21);
            return;
          }
          v23 = (float32x2_t *)((char *)var3 + 44 * a2 + 16);
          v32 = (float *)((char *)var3 + 44 * a2 - 28);
          if (v18 + v13 == -1)
          {
            v42 = 0.0;
            v40[0] = 0.0;
            *(float *)&v11 = (float)(v23->f32[0] + *v32) * 0.5;
            v21 = (float)(*((float *)var3 + 11 * a2 + 5) + *((float *)var3 + 11 * a2 - 6)) * 0.5;
            v29 = (float *)&v36;
            v30 = &v42;
            v31 = v40;
            goto LABEL_29;
          }
          v40[0] = 0.0;
          v41 = 0;
          v33 = v23->f32[0];
          v34 = *((float *)var3 + 11 * a2 + 5);
          *(float *)&v11 = (float)(v23->f32[0] + *v32) * 0.5;
          v21 = (float)(v34 + *((float *)var3 + 11 * a2 - 6)) * 0.5;
          v36 = 1;
          v35 = (float *)((char *)var3 + 44 * a2);
          v37 = (float)(v33 + v35[15]) * 0.5;
          v38 = (float)(v34 + v35[16]) * 0.5;
          v17 = &v36;
        }
        v29 = &v42;
        v30 = v40;
        v31 = (float *)&v41;
        goto LABEL_29;
      case 4:
        Path::PrevPoint(a1, a2 - 1, (float *)&v36, &v37);
        v40[0] = 0.0;
        v41 = 0;
        Path::TangentOnArcAt((uint64_t)v45, (float *)a3, (uint64_t)&v42, v40, (float *)&v41, a4, *(float *)&v36, v37);
        return;
      default:
        return;
    }
  }
LABEL_5:
  v12 = (a2 - 1);
  v10.n128_u32[0] = 1.0;
LABEL_8:
  Path::PointAt(a1, v12, a3, v10);
}

void Path::PointAndTangentAt(Path *a1, int a2, float32x2_t *a3, float *a4, float a5)
{
  path_descr *var3;
  _OWORD *v11;
  __n128 v12;
  __int128 v13;
  uint64_t v14;
  int v15;
  unsigned int v17;
  char *v18;
  float *v19;
  int v20;
  int v21;
  float32_t v23;
  path_descr *v24;
  float32x2_t *v25;
  float32x2_t v26;
  path_descr *v27;
  float32x2_t *v28;
  float v29;
  float *v30;
  float *v31;
  float *v32;
  float *v33;
  float v34;
  float v35;
  float *v36;
  float v37;
  float v38;
  float v39;
  int v40;
  float v41;
  float v42;
  int v43;
  __int128 v44;
  float32x2_t v45[4];

  if (a2 < 0 || a1->var2 <= a2)
  {
    *a3 = 0;
    *(_QWORD *)a4 = 0;
    return;
  }
  var3 = a1->var3;
  v11 = (_OWORD *)((char *)var3 + 44 * a2);
  v12 = *(__n128 *)((char *)v11 + 28);
  v13 = v11[1];
  v44 = *v11;
  *(_OWORD *)v45[0].f32 = v13;
  *(__n128 *)&v45[1].i32[1] = v12;
  if ((v44 & 0xF) == 0)
  {
    v14 = (a2 + 1);
    v12.n128_u32[0] = 0;
    goto LABEL_8;
  }
  if ((v44 & 0xD) != 5)
  {
    switch(v44 & 0xF)
    {
      case 1:
        Path::PrevPoint(a1, a2 - 1, &v37, &v38);
        v41 = 0.0;
        Path::TangentOnSegAt((float *)v45, (float *)a3, a4, &v41, a5, v37, v38);
        return;
      case 2:
        Path::PrevPoint(a1, a2 - 1, &v37, &v38);
        v41 = 0.0;
        v43 = 0;
        v26.f32[0] = v37;
        Path::TangentOnCubAt(v45, 0, a3, (uint64_t)a4, &v41, (float *)&v43, a5, v26, v38);
        return;
      case 3:
      case 6:
        v15 = 0;
        do
        {
          v17 = a2 + v15;
          if (a2 + v15 < 0)
            goto LABEL_5;
          --v15;
        }
        while ((*((_DWORD *)var3 + 11 * v17) & 0xF) != 3);
        v18 = (char *)var3 + 44 * v17;
        v21 = *((_DWORD *)v18 + 4);
        v19 = (float *)(v18 + 16);
        v20 = v21;
        if (a2 + v15 + v21 + 1 < a2)
          break;
        if (v20 == 1 || ~v15 <= 0)
        {
          Path::PrevPoint(a1, a2 + v15, &v37, &v38);
          v41 = 0.0;
          v43 = 0;
          *(float *)&v13 = v37;
          v23 = v38;
          v24 = a1->var3;
          v25 = (float32x2_t *)((char *)v24 + 44 * (a2 + v15 + 2) + 16);
          v19 = (float *)((char *)v24 + 44 * v17 + 16);
        }
        else
        {
          if (v15 == -2)
          {
            Path::PrevPoint(a1, a2 - 2, &v41, &v42);
            v43 = 0;
            v40 = 0;
            LODWORD(v37) = 1;
            v27 = a1->var3;
            v28 = (float32x2_t *)((char *)v27 + 44 * a2);
            v29 = v28[2].f32[0];
            v25 = v28 + 2;
            v30 = (float *)((char *)v27 + 44 * (a2 + 1));
            v38 = (float)(v29 + v30[4]) * 0.5;
            v39 = (float)(v25->f32[1] + v30[5]) * 0.5;
            *(float *)&v13 = v41;
            v23 = v42;
            v19 = &v37;
            v31 = (float *)&v43;
            v32 = (float *)&v40;
LABEL_29:
            Path::TangentOnBezAt(v25, (uint64_t)v19, 0, a3, (uint64_t)a4, v31, v32, a5, *(float32x2_t *)&v13, v23);
            return;
          }
          v25 = (float32x2_t *)((char *)var3 + 44 * a2 + 16);
          v33 = (float *)((char *)var3 + 44 * a2 - 28);
          if (v20 + v15 == -1)
          {
            v37 = 0.0;
            v41 = 0.0;
            *(float *)&v13 = (float)(v25->f32[0] + *v33) * 0.5;
            v23 = (float)(*((float *)var3 + 11 * a2 + 5) + *((float *)var3 + 11 * a2 - 6)) * 0.5;
            v31 = &v37;
            v32 = &v41;
            goto LABEL_29;
          }
          v41 = 0.0;
          v43 = 0;
          v34 = v25->f32[0];
          v35 = *((float *)var3 + 11 * a2 + 5);
          *(float *)&v13 = (float)(v25->f32[0] + *v33) * 0.5;
          v23 = (float)(v35 + *((float *)var3 + 11 * a2 - 6)) * 0.5;
          LODWORD(v37) = 1;
          v36 = (float *)((char *)var3 + 44 * a2);
          v38 = (float)(v34 + v36[15]) * 0.5;
          v39 = (float)(v35 + v36[16]) * 0.5;
          v19 = &v37;
        }
        v31 = &v41;
        v32 = (float *)&v43;
        goto LABEL_29;
      case 4:
        Path::PrevPoint(a1, a2 - 1, &v37, &v38);
        v41 = 0.0;
        v43 = 0;
        Path::TangentOnArcAt((uint64_t)v45, (float *)a3, (uint64_t)a4, &v41, (float *)&v43, a5, v37, v38);
        return;
      default:
        return;
    }
  }
LABEL_5:
  v14 = (a2 - 1);
  v12.n128_u32[0] = 1.0;
LABEL_8:
  Path::PointAndTangentAt(a1, v14, a3, a4, v12);
}

void Path::ConvertWithBackData(Path *this, float a2)
{
  int var0;
  path_descr *var3;
  float v5;
  float v6;
  float v7;
  uint64_t v8;
  double v9;
  uint64_t v10;
  float v11;
  int v12;
  path_descr *v13;
  int v14;
  float v15;
  float v16;
  float v17;
  float *v18;
  char *v19;
  float v20;
  uint64_t v21;
  float *v22;
  char *v23;
  float v24;
  float *v25;
  float *v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  char *v32;
  float *v33;
  int v34;
  int v35;
  uint64_t v36;
  float *v37;
  float v38;
  float *v39;
  char *v40;
  float v41;
  float v42;
  float v43;
  float v44;
  _BOOL4 v45;
  _BOOL4 v46;
  char *var11;
  float *v48;
  float *v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  int v56;
  float *v57;
  int v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  int v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  char *v77;
  float v78;
  float v79;
  float v80;
  float v81;
  int v82;
  float v83;
  float v84;
  int v85;
  float v86;
  uint64_t v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v93;
  float v94;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::CancelBezier(this);
    var0 = this->var0;
  }
  if ((var0 & 2) != 0)
    Path::CloseSubpath(this, 0);
  Path::SetBackData(this, 1);
  Path::ResetPoints(this, this->var2);
  if (this->var2 >= 1)
  {
    var3 = this->var3;
    v5 = 1.0;
    if ((*(_BYTE *)var3 & 0x10) != 0)
      v5 = *((float *)var3 + 7);
    v7 = *((float *)var3 + 4);
    v6 = *((float *)var3 + 5);
    if (this->var6)
      v8 = Path::AddPoint(this, v7, v6, v5, 0, 0.0, 1);
    else
      v8 = Path::AddPoint(this, v7, v6, 0, 0.0, 1);
    v10 = v8;
    if (this->var2 >= 2)
    {
      v11 = 0.5;
      v12 = 1;
      while (2)
      {
        v13 = this->var3;
        v14 = *((_DWORD *)v13 + 11 * v12);
        v15 = 0.0;
        v16 = 0.0;
        v17 = 0.0;
        switch(v14 & 0xF)
        {
          case 0:
            v18 = (float *)((char *)v13 + 44 * v12);
            v20 = v18[4];
            v19 = (char *)(v18 + 4);
            v15 = v20;
            v17 = 1.0;
            if ((v14 & 0x10) != 0)
              v17 = *((float *)v19 + 3);
            v16 = *((float *)v19 + 1);
            if (this->var6)
              v21 = Path::AddPoint(this, v15, v16, v17, v12, 0.0, 1);
            else
              v21 = Path::AddPoint(this, v15, v16, v12, 0.0, 1);
            v11 = 0.5;
            v10 = v21;
            goto LABEL_62;
          case 1:
            v22 = (float *)((char *)v13 + 44 * v12);
            v24 = v22[4];
            v23 = (char *)(v22 + 4);
            v15 = v24;
            v17 = 1.0;
            if ((v14 & 0x10) != 0)
              v17 = *((float *)v23 + 2);
            v16 = *((float *)v23 + 1);
            if (!this->var6)
              goto LABEL_60;
            goto LABEL_35;
          case 2:
            v25 = (float *)((char *)v13 + 44 * v12);
            v27 = v25[4];
            v26 = v25 + 4;
            v15 = v27;
            v17 = 1.0;
            if ((v14 & 0x10) != 0)
              v17 = v26[6];
            v16 = v26[1];
            v28 = v26[2];
            v29 = v26[3];
            v30 = v26[4];
            v31 = v26[5];
            if (this->var6)
            {
              Path::RecCubicTo(this, v7, v6, v5, v28, v29, v15, v16, v17, 8, v12, v30, v31, a2, 0.0, 1.0);
              goto LABEL_35;
            }
            Path::RecCubicTo(this, v7, v6, v28, v29, v15, v16, v30, v31, 8, v12, a2, 0.0, 1.0);
            goto LABEL_60;
          case 3:
            v32 = (char *)v13 + 44 * v12;
            v35 = *((_DWORD *)v32 + 4);
            v33 = (float *)(v32 + 16);
            v34 = v35;
            v15 = v33[1];
            v16 = v33[2];
            if ((v14 & 0x10) != 0)
            {
              v91 = v33[3];
              if (v34 <= 0)
                goto LABEL_77;
              v89 = v33[2];
              v90 = v33[1];
              v36 = v12 + 1;
              v49 = (float *)((char *)v13 + 44 * v36);
              v37 = v49 + 4;
              v38 = v49[6];
            }
            else
            {
              if (v34 <= 0)
              {
                v91 = 1.0;
                goto LABEL_77;
              }
              v89 = v33[2];
              v90 = v33[1];
              v36 = v12 + 1;
              v37 = (float *)((char *)v13 + 44 * v36 + 16);
              v91 = 1.0;
              v38 = 1.0;
            }
            v50 = *v37;
            v51 = *((float *)v13 + 11 * v36 + 5);
            v52 = -(float)(*v37 - (float)(v7 * 2.0));
            v53 = 2.0;
            v54 = -(float)(v51 - (float)(v6 * 2.0));
            v55 = -(float)(v38 - (float)(v5 * 2.0));
            if (v34 < 2)
            {
              v74 = -v50;
              v75 = -v51;
              v76 = -v38;
            }
            else
            {
              v87 = v10;
              v56 = 0;
              v57 = (float *)((char *)v13 + 44 * v36 + 68);
              v58 = v12;
              do
              {
                v59 = v50;
                v60 = v51;
                v61 = v38;
                v62 = 1.0;
                if ((v14 & 0x10) != 0)
                  v62 = *v57;
                v50 = *(v57 - 2);
                v51 = *(v57 - 1);
                v63 = (float)(v52 + v59) * v11;
                v64 = v54 + v60;
                v65 = v64 * v11;
                v66 = (float)(v55 + v38) * v11;
                if (v56)
                {
                  v67 = v58 - 1;
                  v93 = *(v57 - 1);
                  v68 = *(v57 - 2);
                  v69 = v62;
                  v70 = (float)(v55 + v38) * v11;
                  if (this->var6)
                    Path::AddPoint(this, v63, v65, v66, v67, 1.0, 0);
                  else
                    Path::AddPoint(this, (float)(v52 + v59) * v11, v64 * v11, v67, 1.0, 0);
                  v66 = v70;
                  v62 = v69;
                  v50 = v68;
                  v51 = v93;
                  v11 = 0.5;
                }
                v71 = (float)(v59 + v50) * v11;
                v72 = (float)(v60 + v51) * v11;
                v73 = v62;
                if (this->var6)
                  Path::RecBezierTo(this, v59, v60, v61, v63, v65, v66, v71, v72, 8, v58, (float)(v61 + v62) * v11, a2, 0.0, 1.0);
                else
                  Path::RecBezierTo(this, v59, v60, v63, v65, v71, v72, a2, 8, 0.0, v58, 1.0);
                v38 = v73;
                v11 = 0.5;
                --v56;
                ++v58;
                v57 += 11;
                v55 = v61;
                v54 = v60;
                v52 = v59;
              }
              while (1 - v34 != v56);
              v74 = -v50;
              v75 = -v51;
              v76 = -v73;
              v52 = v59;
              v54 = v60;
              v55 = v61;
              v53 = 2.0;
              v10 = v87;
            }
            v78 = v52 + v50;
            v79 = v78 * v11;
            v80 = (float)(v54 + v51) * v11;
            v81 = (float)(v55 + v38) * v11;
            if (v34 > 1)
            {
              v88 = v76;
              v94 = v38;
              v82 = v12 + v34 - 2;
              if (this->var6)
                Path::AddPoint(this, v79, v80, v81, v82, 1.0, 0);
              else
                Path::AddPoint(this, v78 * v11, (float)(v54 + v51) * v11, v82, 1.0, 0);
              v11 = 0.5;
              v38 = v94;
              v76 = v88;
            }
            v83 = (float)(v50 + (float)(v74 + (float)(v90 * v53))) * v11;
            v84 = (float)(v51 + (float)(v75 + (float)(v89 * v53))) * v11;
            if (this->var6)
              Path::RecBezierTo(this, v50, v51, v38, v79, v80, v81, v83, v84, 8, v12 + v34 - 1, (float)(v38 + (float)(v76 + (float)(v91 * v53))) * v11, a2, 0.0, 1.0);
            else
              Path::RecBezierTo(this, v50, v51, v79, v80, v83, v84, a2, 8, 0.0, v12 + v34 - 1, 1.0);
            v16 = v89;
            v15 = v90;
LABEL_77:
            v85 = v12 + v34 - 1;
            if (this->var6)
            {
              v17 = v91;
              Path::AddPoint(this, v15, v16, v91, v85, 1.0, 0);
              v11 = 0.5;
            }
            else
            {
              Path::AddPoint(this, v15, v16, v85, 1.0, 0);
              v11 = 0.5;
              v17 = v91;
            }
            v12 += v34 + 1;
            goto LABEL_63;
          case 4:
            v39 = (float *)((char *)v13 + 44 * v12);
            v41 = v39[4];
            v40 = (char *)(v39 + 4);
            v15 = v41;
            v17 = 1.0;
            if ((v14 & 0x10) != 0)
              v17 = *((float *)v40 + 6);
            v16 = *((float *)v40 + 1);
            v42 = *((float *)v40 + 2);
            v43 = *((float *)v40 + 3);
            v44 = *((float *)v40 + 4);
            v45 = v40[21] != 0;
            v46 = v40[20] != 0;
            if (this->var6)
            {
              Path::DoArc(this, v7, v6, v5, v15, v16, v17, v42, v43, v46, v45, v12, v44, v86);
              goto LABEL_35;
            }
            Path::DoArc(this, v7, v6, v15, v16, v42, v43, v44, v46, v45, v43, v12);
            goto LABEL_60;
          case 5:
            var11 = this->var11;
            if (this->var6)
            {
              v48 = (float *)&var11[24 * (int)v10];
              v15 = v48[1];
              v16 = v48[2];
              v17 = v48[3];
LABEL_35:
              Path::AddPoint(this, v15, v16, v17, v12, 1.0, 0);
            }
            else
            {
              v77 = &var11[20 * (int)v10];
              v15 = *((float *)v77 + 1);
              v16 = *((float *)v77 + 2);
LABEL_60:
              Path::AddPoint(this, v15, v16, v12, 1.0, 0);
            }
LABEL_61:
            v11 = 0.5;
LABEL_62:
            ++v12;
LABEL_63:
            v5 = v17;
            v6 = v16;
            v7 = v15;
            if (v12 >= this->var2)
              return;
            continue;
          case 6:
            goto LABEL_63;
          case 7:
            if (this->var6)
            {
              Path::AddForcedPoint(this, v7, v6, v5, v12, 1.0);
            }
            else
            {
              *(float *)&v9 = v7;
              Path::AddForcedPoint(this, v9, v6, v12, 1.0);
            }
            goto LABEL_61;
          default:
            v15 = 0.0;
            v16 = 0.0;
            v17 = 0.0;
            goto LABEL_63;
        }
      }
    }
  }
}

Path *Path::RecCubicTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, int a11, float a12, float a13, float a14, float a15, float a16)
{
  Path *v20;
  float v24;
  float v25;
  float v26;
  float v27;
  float v29;
  float v30;
  float v31;
  BOOL v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v38;
  float v39;

  v20 = this;
  while (1)
  {
    v24 = a7 - a2;
    v25 = a8 - a3;
    v26 = sqrtf((float)(v25 * v25) + (float)(v24 * v24));
    if (v26 >= 0.01)
      break;
    v27 = a14;
    if ((float)((float)(a5 * a5) + (float)(a6 * a6)) >= a14)
    {
      if (a10 < 1)
        return this;
    }
    else if ((float)((float)(a12 * a12) + (float)(a13 * a13)) < a14 || a10 < 1)
    {
      return this;
    }
LABEL_20:
    v33 = (float)(a4 + a9) * 0.5;
    v34 = (float)((float)(a2 + a7) * 0.5) + (float)((float)(a5 - a12) * 0.125);
    v35 = (float)((float)(a3 + a8) * 0.5) + (float)((float)(a6 - a13) * 0.125);
    v38 = (float)((float)(v24 * 3.0) * 0.25) - (float)((float)(a5 + a12) * 0.125);
    v39 = (float)((float)(v25 * 3.0) * 0.25) - (float)((float)(a6 + a13) * 0.125);
    v36 = (float)(a15 + a16) * 0.5;
    Path::RecCubicTo(v20, a2, a3, a4, a5 * 0.5, a6 * 0.5, v34, v35, v33, v38, v39, v27, --a10, a15, v36, a11);
    this = (Path *)Path::AddPoint(v20, v34, v35, v33, a11, v36, 0);
    a12 = a12 * 0.5;
    a2 = v34;
    a3 = v35;
    a13 = a13 * 0.5;
    a4 = v33;
    a5 = v38;
    a6 = v39;
    a15 = v36;
  }
  v29 = (float)(v24 * a6) - (float)(v25 * a5);
  v30 = -v29;
  if (v29 >= 0.0)
    v30 = (float)(v24 * a6) - (float)(v25 * a5);
  v31 = -(float)((float)(v24 * a13) - (float)(v25 * a12));
  if ((float)((float)(v24 * a13) - (float)(v25 * a12)) >= 0.0)
    v31 = (float)(v24 * a13) - (float)(v25 * a12);
  v27 = a14;
  v32 = (float)(v30 / v26) < a14;
  if ((float)(v31 / v26) >= a14)
    v32 = 0;
  if (a10 >= 1 && !v32)
    goto LABEL_20;
  return this;
}

Path *Path::RecCubicTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, int a11, float a12, float a13, float a14)
{
  Path *v20;
  float v22;
  float v23;
  float v24;
  float v25;
  float v27;
  float v28;
  float v29;
  BOOL v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;

  v20 = this;
  while (1)
  {
    v22 = a6 - a2;
    v23 = a7 - a3;
    v24 = sqrtf((float)(v23 * v23) + (float)(v22 * v22));
    if (v24 >= 0.01)
      break;
    v25 = a12;
    if ((float)((float)(a4 * a4) + (float)(a5 * a5)) >= a12)
    {
      if (a10 < 1)
        return this;
    }
    else if ((float)((float)(a8 * a8) + (float)(a9 * a9)) < a12 || a10 < 1)
    {
      return this;
    }
LABEL_20:
    v31 = (float)((float)(a2 + a6) * 0.5) + (float)((float)(a4 - a8) * 0.125);
    v32 = (float)((float)(a3 + a7) * 0.5) + (float)((float)(a5 - a9) * 0.125);
    v34 = (float)((float)(v23 * 3.0) * 0.25) - (float)((float)(a5 + a9) * 0.125);
    v35 = (float)((float)(v22 * 3.0) * 0.25) - (float)((float)(a4 + a8) * 0.125);
    v33 = (float)(a13 + a14) * 0.5;
    Path::RecCubicTo(v20, a2, a3, a4 * 0.5, a5 * 0.5, v31, v32, v35, v34, v25, --a10, a13, v33, a11);
    this = (Path *)Path::AddPoint(v20, v31, v32, a11, v33, 0);
    a8 = a8 * 0.5;
    a2 = v31;
    a9 = a9 * 0.5;
    a3 = v32;
    a5 = v34;
    a4 = v35;
    a13 = v33;
  }
  v27 = (float)(v22 * a5) - (float)(v23 * a4);
  v28 = -v27;
  if (v27 >= 0.0)
    v28 = (float)(v22 * a5) - (float)(v23 * a4);
  v29 = -(float)((float)(v22 * a9) - (float)(v23 * a8));
  if ((float)((float)(v22 * a9) - (float)(v23 * a8)) >= 0.0)
    v29 = (float)(v22 * a9) - (float)(v23 * a8);
  v25 = a12;
  v30 = (float)(v28 / v24) < a12;
  if ((float)(v29 / v24) >= a12)
    v30 = 0;
  if (a10 >= 1 && !v30)
    goto LABEL_20;
  return this;
}

void Path::DoArc(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, int a11, int a12, float a13, float a14)
{
  float v20;
  float v21;
  __float2 v22;
  float cosval;
  float sinval;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  __float2 v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  __float2 v75;
  float v77;
  float v78;
  float v80;
  float v81;
  float v83;
  float v84;
  float v86;
  float v87;

  if (a8 > 0.0001 && a9 > 0.0001)
  {
    v20 = a5 - a2;
    v21 = a6 - a3;
    v22 = __sincosf_stret(a13);
    cosval = v22.__cosval;
    sinval = v22.__sinval;
    v77 = a8;
    v78 = a9;
    v25 = (float)((float)(v21 * v22.__sinval) + (float)(v22.__cosval * v20)) / a8;
    v26 = (float)((float)(v21 * v22.__cosval) - (float)(v22.__sinval * v20)) / a9;
    v27 = 4.0;
    if ((float)((float)(v26 * v26) + (float)(v25 * v25)) < 4.0)
      v27 = (float)(v26 * v26) + (float)(v25 * v25);
    v28 = (float)(v27 * -0.25) + 1.0;
    if (v28 < 0.0)
      v28 = 0.0;
    v29 = sqrtf(v28);
    v30 = sqrtf(v27);
    v31 = (float)-v25 / v30;
    v32 = (float)(v26 / v30) * v29;
    v33 = v25 * 0.5;
    v34 = (float)-v32 - (float)(v25 * 0.5);
    v35 = v26 * 0.5;
    v36 = 3.1416;
    v37 = 3.1416;
    if (v34 >= -1.0)
    {
      v37 = 0.0;
      if (v34 <= 1.0)
      {
        v38 = acosf(v34);
        sinval = v22.__sinval;
        v37 = v38;
        cosval = v22.__cosval;
        if ((float)((float)-(float)(v31 * v29) - v35) < 0.0)
          v37 = 6.28318531 - v38;
      }
    }
    v39 = v31 * v29;
    v40 = -sinval;
    v41 = v33 - v32;
    if ((float)(v33 - v32) >= -1.0)
    {
      v36 = 0.0;
      if (v41 <= 1.0)
      {
        v42 = v35 - v39;
        v43 = cosval;
        v44 = sinval;
        v45 = acosf(v41);
        sinval = v44;
        cosval = v43;
        v36 = v45;
        if (v42 < 0.0)
          v36 = 6.28318531 - v45;
      }
    }
    v46 = (float)((float)(v39 * v78) * v40) + (float)(cosval * (float)(v32 * v77));
    v47 = (float)(cosval * (float)(v39 * v78)) + (float)(sinval * (float)(v32 * v77));
    if (a11)
    {
      if (a10)
      {
        v46 = -v46;
        v47 = -v47;
        v48 = v37 + 3.14159265;
        v49 = v36 + 3.14159265;
        if (v48 >= 6.28318531)
        {
          v50 = v48 + -6.28318531;
          v36 = v50;
        }
        else
        {
          v36 = v37 + 3.14159265;
        }
        if (v49 >= 6.28318531)
        {
          v51 = v49 + -6.28318531;
          v37 = v51;
        }
        else
        {
          v37 = v49;
        }
      }
      v52 = a6;
      v53 = v37 + 6.28318531;
      if (v37 >= v36)
        v53 = v37;
      v86 = v53;
      v54 = v53 + -0.1;
      if (v36 < v54)
      {
        v55 = (float)((float)(a2 + a5) * 0.5) + v46;
        v80 = (float)((float)(a3 + v52) * 0.5) + v47;
        v83 = v55;
        v56 = cosval * v77;
        v57 = v40 * v78;
        v58 = sinval * v77;
        v59 = cosval * v78;
        v60 = v53 - v36;
        do
        {
          v61 = __sincosf_stret(v54);
          Path::AddPoint(this, (float)(v83 + (float)(v56 * v61.__cosval)) + (float)(v57 * v61.__sinval), (float)(v80 + (float)(v58 * v61.__cosval)) + (float)(v59 * v61.__sinval), (float)((float)((float)(v86 - v54) * a7) + (float)(a4 * (float)(v54 - v36))) / v60, a12, (float)(v86 - v54) / v60, 0);
          v54 = v54 + -0.1;
        }
        while (v36 < v54);
      }
    }
    else
    {
      if ((a10 & 1) == 0)
      {
        v46 = -v46;
        v47 = -v47;
        v62 = v37 + 3.14159265;
        v63 = v36 + 3.14159265;
        if (v62 >= 6.28318531)
        {
          v64 = v62 + -6.28318531;
          v36 = v64;
        }
        else
        {
          v36 = v37 + 3.14159265;
        }
        if (v63 >= 6.28318531)
        {
          v65 = v63 + -6.28318531;
          v37 = v65;
        }
        else
        {
          v37 = v63;
        }
      }
      v66 = a6;
      v67 = v37 + -6.28318531;
      if (v37 <= v36)
        v67 = v37;
      v87 = v67;
      v68 = v67 + 0.1;
      if (v36 > v68)
      {
        v69 = (float)((float)(a2 + a5) * 0.5) + v46;
        v81 = (float)((float)(a3 + v66) * 0.5) + v47;
        v84 = v69;
        v70 = cosval * v77;
        v71 = v40 * v78;
        v72 = sinval * v77;
        v73 = cosval * v78;
        v74 = v36 - v67;
        do
        {
          v75 = __sincosf_stret(v68);
          Path::AddPoint(this, (float)(v84 + (float)(v70 * v75.__cosval)) + (float)(v71 * v75.__sinval), (float)(v81 + (float)(v72 * v75.__cosval)) + (float)(v73 * v75.__sinval), (float)((float)((float)(v68 - v87) * a7) + (float)(a4 * (float)(v36 - v68))) / v74, a12, (float)(v68 - v87) / v74, 0);
          v68 = v68 + 0.1;
        }
        while (v36 > v68);
      }
    }
  }
}

void Path::DoArc(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, int a9, int a10, float a11, int a12)
{
  float v18;
  float v19;
  __float2 v20;
  float cosval;
  float sinval;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  __float2 v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  __float2 v77;
  float v78;
  float v79;
  float v82;
  float v83;
  float v85;
  float v86;
  float v88;
  float v89;

  if (a6 > 0.0001 && a7 > 0.0001)
  {
    v18 = a4 - a2;
    v19 = a5 - a3;
    v20 = __sincosf_stret(a8);
    cosval = v20.__cosval;
    sinval = v20.__sinval;
    v79 = a6;
    v23 = (float)((float)(v19 * v20.__sinval) + (float)(v20.__cosval * v18)) / a6;
    v24 = (float)((float)(v19 * v20.__cosval) - (float)(v20.__sinval * v18)) / a7;
    v25 = 4.0;
    if ((float)((float)(v24 * v24) + (float)(v23 * v23)) < 4.0)
      v25 = (float)(v24 * v24) + (float)(v23 * v23);
    v26 = (float)(v25 * -0.25) + 1.0;
    if (v26 < 0.0)
      v26 = 0.0;
    v27 = sqrtf(v26);
    v28 = sqrtf(v25);
    v29 = (float)-v23 / v28;
    v30 = (float)(v24 / v28) * v27;
    v31 = v23 * 0.5;
    v32 = (float)-v30 - (float)(v23 * 0.5);
    v33 = v24 * 0.5;
    v34 = 3.1416;
    v35 = 3.1416;
    if (v32 >= -1.0)
    {
      v35 = 0.0;
      if (v32 <= 1.0)
      {
        v78 = (float)-(float)(v29 * v27) - v33;
        v36 = v33;
        v37 = acosf(v32);
        v33 = v36;
        v34 = 3.1416;
        sinval = v20.__sinval;
        cosval = v20.__cosval;
        v35 = v37;
        if (v78 < 0.0)
          v35 = 6.28318531 - v37;
      }
    }
    v38 = v29 * v27;
    v39 = -sinval;
    v40 = v31 - v30;
    if ((float)(v31 - v30) >= -1.0)
    {
      v34 = 0.0;
      if (v40 <= 1.0)
      {
        v41 = v33 - v38;
        v42 = cosval;
        v43 = sinval;
        v44 = -sinval;
        v45 = acosf(v40);
        v39 = v44;
        sinval = v43;
        cosval = v42;
        v34 = v45;
        if (v41 < 0.0)
          v34 = 6.28318531 - v45;
      }
    }
    v46 = (float)((float)(v38 * a7) * v39) + (float)(cosval * (float)(v30 * v79));
    v47 = (float)(cosval * (float)(v38 * a7)) + (float)(sinval * (float)(v30 * v79));
    if (a10)
    {
      if (a9)
      {
        v46 = -v46;
        v47 = -v47;
        v48 = v35 + 3.14159265;
        v49 = v34 + 3.14159265;
        v34 = v48 + -6.28318531;
        if (v48 < 6.28318531)
          v34 = v35 + 3.14159265;
        if (v49 >= 6.28318531)
        {
          v50 = v49 + -6.28318531;
          v35 = v50;
        }
        else
        {
          v35 = v49;
        }
      }
      v51 = a5;
      v52 = v35 + 6.28318531;
      if (v35 >= v34)
        v52 = v35;
      v88 = v52;
      v53 = v52 + -0.1;
      if (v34 < v53)
      {
        v54 = (float)((float)(a2 + a4) * 0.5) + v46;
        v82 = (float)((float)(a3 + v51) * 0.5) + v47;
        v85 = v54;
        v55 = cosval * v79;
        v56 = v39 * a7;
        v57 = a7;
        v58 = sinval * v79;
        v59 = cosval * v57;
        v60 = v52 - v34;
        do
        {
          v61 = v34;
          v62 = __sincosf_stret(v53);
          Path::AddPoint(this, (float)(v85 + (float)(v55 * v62.__cosval)) + (float)(v56 * v62.__sinval), (float)(v82 + (float)(v58 * v62.__cosval)) + (float)(v59 * v62.__sinval), a12, (float)(v88 - v53) / v60, 0);
          v34 = v61;
          v53 = v53 + -0.1;
        }
        while (v61 < v53);
      }
    }
    else
    {
      if ((a9 & 1) == 0)
      {
        v46 = -v46;
        v47 = -v47;
        v63 = v35 + 3.14159265;
        v64 = v34 + 3.14159265;
        v34 = v63 + -6.28318531;
        if (v63 < 6.28318531)
          v34 = v35 + 3.14159265;
        if (v64 >= 6.28318531)
        {
          v65 = v64 + -6.28318531;
          v35 = v65;
        }
        else
        {
          v35 = v64;
        }
      }
      v66 = a5;
      v67 = v35 + -6.28318531;
      if (v35 <= v34)
        v67 = v35;
      v89 = v67;
      v68 = v67 + 0.1;
      if (v34 > v68)
      {
        v69 = (float)((float)(a2 + a4) * 0.5) + v46;
        v83 = (float)((float)(a3 + v66) * 0.5) + v47;
        v86 = v69;
        v70 = cosval * v79;
        v71 = v39 * a7;
        v72 = a7;
        v73 = sinval * v79;
        v74 = cosval * v72;
        v75 = v34 - v67;
        do
        {
          v76 = v34;
          v77 = __sincosf_stret(v68);
          Path::AddPoint(this, (float)(v86 + (float)(v70 * v77.__cosval)) + (float)(v71 * v77.__sinval), (float)(v83 + (float)(v73 * v77.__cosval)) + (float)(v74 * v77.__sinval), a12, (float)(v68 - v89) / v75, 0);
          v34 = v76;
          v68 = v68 + 0.1;
        }
        while (v76 > v68);
      }
    }
  }
}

Path *Path::RecBezierTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, int a11, float a12, float a13, float a14, float a15)
{
  Path *v21;
  int v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;

  if (a10 >= 1)
  {
    v21 = this;
    v23 = a10 + 1;
    do
    {
      v24 = (float)((float)(a5 - a2) * (float)(a9 - a3)) - (float)((float)(a6 - a3) * (float)(a8 - a2));
      v25 = -v24;
      if (v24 >= 0.0)
        v25 = (float)((float)(a5 - a2) * (float)(a9 - a3)) - (float)((float)(a6 - a3) * (float)(a8 - a2));
      if (v25 < a13)
        break;
      v26 = (float)((float)(a5 + a8) + (float)(a2 * 2.0)) * 0.25;
      v27 = (float)((float)(a6 + a9) + (float)(a3 * 2.0)) * 0.25;
      v30 = (float)((float)(a7 + a12) + (float)(a4 * 2.0)) * 0.25;
      v28 = (float)(a14 + a15) * 0.5;
      v29 = a4;
      Path::RecBezierTo(v21, (float)(a2 + a5) * 0.5, (float)(a3 + a6) * 0.5, (float)(a4 + a7) * 0.5, a5, a6, a7, v26, v27, v30, a13, v23 - 2, a14, v28, a11);
      this = (Path *)Path::AddPoint(v21, v26, v27, v30, a11, v28, 0);
      a2 = (float)(a2 + a8) * 0.5;
      a3 = (float)(a3 + a9) * 0.5;
      a5 = v26;
      --v23;
      a14 = v28;
      a4 = (float)(v29 + a12) * 0.5;
      a7 = v30;
      a6 = v27;
    }
    while (v23 > 1);
  }
  return this;
}

Path *Path::RecBezierTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, int a9, float a10, int a11, float a12)
{
  Path *v18;
  int v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;

  if (a9 >= 1)
  {
    v18 = this;
    v19 = a9 + 1;
    do
    {
      v20 = (float)((float)(a4 - a2) * (float)(a7 - a3)) - (float)((float)(a5 - a3) * (float)(a6 - a2));
      v21 = -v20;
      if (v20 >= 0.0)
        v21 = (float)((float)(a4 - a2) * (float)(a7 - a3)) - (float)((float)(a5 - a3) * (float)(a6 - a2));
      if (v21 < a8)
        break;
      v22 = (float)((float)(a4 + a6) + (float)(a2 * 2.0)) * 0.25;
      v23 = (float)((float)(a5 + a7) + (float)(a3 * 2.0)) * 0.25;
      v24 = (float)(a10 + a12) * 0.5;
      Path::RecBezierTo(v18, (float)(a2 + a4) * 0.5, (float)(a3 + a5) * 0.5, a4, a5, v22, v23, a8, v19 - 2, a10, v24, a11);
      this = (Path *)Path::AddPoint(v18, v22, v23, a11, v24, 0);
      a2 = (float)(a2 + a6) * 0.5;
      --v19;
      a3 = (float)(a3 + a7) * 0.5;
      a10 = v24;
      a5 = v23;
      a4 = v22;
    }
    while (v19 > 1);
  }
  return this;
}

void Path::ConvertForOffset(Path *this, float a2, Path *a3, float a4)
{
  int var0;
  path_descr *var3;
  float v9;
  float v10;
  int v11;
  double v12;
  double v13;
  float v14;
  int v15;
  uint64_t v16;
  float v17;
  path_descr *v18;
  float v19;
  float v20;
  float *v21;
  float *v22;
  float *v23;
  float v24;
  float v25;
  float v26;
  float v27;
  char *v28;
  int v29;
  uint64_t v30;
  float *v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float *v38;
  float v39;
  float v40;
  float v41;
  _BOOL4 v42;
  _BOOL4 v43;
  char *v44;
  int v45;
  _QWORD *v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  uint64_t v54;
  float v55;
  float v56;
  char *v57;
  float v58;
  float v59;
  int v60;
  float v61;
  Path *v63;
  int v64;
  uint64_t v65;
  float v66;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::CancelBezier(this);
    var0 = this->var0;
  }
  if ((var0 & 2) != 0)
    Path::CloseSubpath(this, 0);
  Path::SetBackData(this, 1);
  Path::ResetPoints(this, this->var2);
  if (this->var2 >= 1)
  {
    var3 = this->var3;
    v10 = *((float *)var3 + 4);
    v9 = *((float *)var3 + 5);
    v11 = Path::AddPoint(this, v10, v9, 0, 0.0, 1);
    v63 = a3;
    v66 = a4;
    if (this->var2 >= 2)
    {
      v15 = v11;
      v16 = 1;
      v17 = 2.0;
      do
      {
        v18 = this->var3;
        v19 = 0.0;
        v20 = 0.0;
        switch(*((_DWORD *)v18 + 11 * (int)v16) & 0xF)
        {
          case 0:
            v21 = (float *)((char *)v18 + 44 * (int)v16);
            v19 = v21[4];
            v20 = v21[5];
            v15 = Path::AddPoint(this, v19, v20, v16, 0.0, 1);
            goto LABEL_25;
          case 1:
            v22 = (float *)((char *)v18 + 44 * (int)v16);
            v19 = v22[4];
            v20 = v22[5];
            goto LABEL_24;
          case 2:
            v23 = (float *)((char *)v18 + 44 * (int)v16);
            v19 = v23[4];
            v20 = v23[5];
            v64 = *((_DWORD *)v23 + 1);
            v65 = *((_QWORD *)v23 + 1);
            v24 = v23[6];
            v25 = v23[7];
            v26 = v23[8];
            v27 = v23[9];
            if (v64 < 0)
              Path::RecCubicTo(this, v10, v9, v24, v25, v19, v20, v26, v27, 8, v16, a2, 0.0, 1.0);
            else
              Path::RecCubicTo(this, 8, v16, (uint64_t)&v63, v10, v9, v24, v25, v19, v20, v26, v27, a2, 0.0, 1.0);
            goto LABEL_24;
          case 3:
            v28 = (char *)v18 + 44 * (int)v16;
            v29 = *((_DWORD *)v28 + 4);
            v19 = *((float *)v28 + 5);
            v20 = *((float *)v28 + 6);
            v30 = (int)v16 + 1;
            if (v29 <= 0)
            {
              LODWORD(v16) = v16 + v29 - 1;
            }
            else
            {
              v31 = (float *)((char *)v18 + 44 * v30);
              v32 = v31[4];
              v33 = v31[5];
              v34 = -(float)(v32 - (float)(v10 * v17));
              v35 = -(float)(v33 - (float)(v9 * v17));
              if (v29 == 1)
              {
                v36 = -v32;
                v37 = -v33;
              }
              else
              {
                v60 = v15;
                v45 = 0;
                v46 = (_QWORD *)((char *)v18 + 44 * v30 + 96);
                v47 = 0.5;
                do
                {
                  v48 = v34;
                  v49 = v35;
                  v34 = v32;
                  v35 = v33;
                  v32 = *((float *)v46 - 9);
                  v33 = *((float *)v46 - 8);
                  v50 = (float)(v48 + v34) * v47;
                  v51 = (float)(v49 + v35) * 0.5;
                  if (v45)
                    Path::AddPoint(this, v50, v51, v16 - 1 + v45, 1.0, 0);
                  v64 = *((_DWORD *)v46 - 1);
                  v65 = *v46;
                  v52 = (float)(v34 + v32) * 0.5;
                  v53 = (float)(v35 + v33) * 0.5;
                  v54 = (v16 + v45);
                  if (v64 < 0)
                  {
                    Path::RecBezierTo(this, v34, v35, v50, v51, v52, v53, a2, 8, 0.0, v54, 1.0);
                  }
                  else
                  {
                    *(float *)&v13 = v35;
                    Path::RecBezierTo(this, 8, v54, (uint64_t)&v63, v34, v13, v50, v51, v52, v53, a2, 0.0, 1.0);
                  }
                  v47 = 0.5;
                  ++v45;
                  v46 = (_QWORD *)((char *)v46 + 44);
                }
                while (v29 - 1 != v45);
                v36 = -v32;
                v37 = -v33;
                v15 = v60;
              }
              v55 = (float)(v34 + v32) * 0.5;
              v56 = (float)(v35 + v33) * 0.5;
              if (v29 >= 2)
              {
                v61 = v37;
                Path::AddPoint(this, v55, (float)(v35 + v33) * 0.5, v16 + v29 - 2, 1.0, 0);
                v37 = v61;
                v56 = (float)(v35 + v33) * 0.5;
                v55 = (float)(v34 + v32) * 0.5;
              }
              v17 = 2.0;
              v57 = (char *)v18 + 44 * v30;
              v64 = *((_DWORD *)v57 + 1);
              v65 = *((_QWORD *)v57 + 1);
              v58 = (float)(v32 + (float)(v36 + (float)(v19 * 2.0))) * 0.5;
              v59 = (float)(v33 + (float)(v37 + (float)(v20 * 2.0))) * 0.5;
              v16 = (v16 + v29 - 1);
              if (v64 < 0)
              {
                Path::RecBezierTo(this, v32, v33, v55, v56, v58, v59, a2, 8, 0.0, v16, 1.0);
              }
              else
              {
                *(float *)&v13 = v33;
                Path::RecBezierTo(this, 8, v16, (uint64_t)&v63, v32, v13, v55, v56, v58, v59, a2, 0.0, 1.0);
              }
            }
            Path::AddPoint(this, v19, v20, v16, 1.0, 0);
            v16 = (v30 + v29);
            break;
          case 4:
            v38 = (float *)((char *)v18 + 44 * (int)v16);
            v19 = v38[4];
            v20 = v38[5];
            v64 = *((_DWORD *)v38 + 1);
            v65 = *((_QWORD *)v38 + 1);
            v39 = v38[6];
            v40 = v38[7];
            v41 = v38[8];
            v42 = *((unsigned __int8 *)v38 + 37) != 0;
            v43 = *((unsigned __int8 *)v38 + 36) != 0;
            if (v64 < 0)
              Path::DoArc(this, v10, v9, v19, v20, v39, v40, v41, v43, v42, v14, v16);
            else
              Path::DoArc(this, v43, v42, v16, v10, v9, v19, v20, v39, v40, v41);
            goto LABEL_24;
          case 5:
            v44 = &this->var11[20 * v15];
            v19 = *((float *)v44 + 1);
            v20 = *((float *)v44 + 2);
LABEL_24:
            Path::AddPoint(this, v19, v20, v16, 1.0, 0);
            goto LABEL_25;
          case 6:
            break;
          case 7:
            *(float *)&v12 = v10;
            Path::AddForcedPoint(this, v12, v9, v16, 1.0);
LABEL_25:
            v16 = (v16 + 1);
            break;
          default:
            v19 = 0.0;
            v20 = 0.0;
            break;
        }
        v9 = v20;
        v10 = v19;
      }
      while ((int)v16 < this->var2);
    }
  }
}

void Path::RecCubicTo(Path *a1, int a2, uint64_t a3, uint64_t a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13, float a14, float a15)
{
  float v26;
  float v27;
  float v28;
  _BOOL4 v29;
  float v30;
  float v31;
  float v32;
  int v33;
  double v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  int v47;
  float v48;
  float v49;
  float v50;
  float v56;
  float v57;
  float32x2_t v58;
  float v59[2];
  float32x2_t v60;
  float v61;
  float v62;
  float32x2_t v63;

  v26 = a9 - a5;
  v27 = a10 - a6;
  v28 = sqrtf((float)(v27 * v27) + (float)(v26 * v26));
  if (v28 >= 0.01)
  {
    v30 = (float)(v26 * a8) - (float)(v27 * a7);
    v31 = -v30;
    if (v30 >= 0.0)
      v31 = v30;
    v32 = -(float)((float)(v26 * a12) - (float)(v27 * a11));
    if ((float)((float)(v26 * a12) - (float)(v27 * a11)) >= 0.0)
      v32 = (float)(v26 * a12) - (float)(v27 * a11);
    v29 = (float)(v31 / v28) < a13;
    if ((float)(v32 / v28) >= a13)
      v29 = 0;
  }
  else
  {
    v29 = (float)((float)(a7 * a7) + (float)(a8 * a8)) < a13 && (float)((float)(a11 * a11) + (float)(a12 * a12)) < a13;
  }
  v33 = a2 < 1 || v29;
  Path::PointAndTangentAt(*(Path **)a4, *(_DWORD *)(a4 + 8), &v63, &v61, (float)(*(float *)(a4 + 16) * a14) + (float)(*(float *)(a4 + 12) * (float)(1.0 - a14)));
  v34 = a14 * 0.5 + a15 * 0.5;
  *(float *)&v34 = v34 * *(float *)(a4 + 16) + *(float *)(a4 + 12) * (1.0 - v34);
  Path::PointAndTangentAt(*(Path **)a4, *(_DWORD *)(a4 + 8), &v58, &v56, *(float *)&v34);
  Path::PointAndTangentAt(*(Path **)a4, *(_DWORD *)(a4 + 8), &v60, v59, (float)(*(float *)(a4 + 16) * a15) + (float)(*(float *)(a4 + 12) * (float)(1.0 - a15)));
  v35 = *(float *)(a4 + 20);
  v36 = v58.f32[0] - (float)(v35 * v57);
  v37 = v58.f32[1] + (float)(v35 * v56);
  v38 = v36 - (float)(v63.f32[0] - (float)(v35 * v62));
  v39 = v37 - (float)(v63.f32[1] + (float)(v35 * v61));
  v40 = (float)(v60.f32[0] - (float)(v35 * v59[1])) - v36;
  v41 = (float)(v60.f32[1] + (float)(v35 * v59[0])) - v37;
  v42 = (float)(v39 * v39) + (float)(v38 * v38);
  if (v42 > 0.0001)
  {
    v43 = sqrtf(v42);
    v38 = v38 / v43;
    v39 = v39 / v43;
  }
  v44 = (float)(v41 * v41) + (float)(v40 * v40);
  if (v44 > 0.0001)
  {
    v45 = sqrtf(v44);
    v40 = v40 / v45;
    v41 = v41 / v45;
  }
  v46 = (float)((float)(v57 - v62) * (float)(v41 - v39)) + (float)((float)(v56 - v61) * (float)(v40 - v38));
  if (v46 < 0.0)
    v47 = v33;
  else
    v47 = 0;
  if (v47 == 1)
  {
    Path::AddPoint(a1, v63.f32[0], v63.f32[1], -1, 0.0, 0);
    Path::AddPoint(a1, a9, a10, a3, a15, 0);
    Path::AddPoint(a1, a5, a6, a3, a14, 0);
    Path::AddPoint(a1, v60.f32[0], v60.f32[1], -1, 0.0, 0);
    return;
  }
  if (v46 >= 0.0)
  {
    if ((v33 & 1) != 0)
      return;
  }
  else if (a2 < 1)
  {
    return;
  }
  v50 = a10;
  v48 = (float)((float)(a5 + a9) * 0.5) + (float)((float)(a7 - a11) * 0.125);
  v49 = (float)((float)(a6 + a10) * 0.5) + (float)((float)(a8 - a12) * 0.125);
  Path::RecCubicTo(a1, (a2 - 1), a3, a4, a5, a6, a7 * 0.5, a8 * 0.5, v48, v49);
  Path::AddPoint(a1, v48, v49, a3, (float)(a14 + a15) * 0.5, 0);
  Path::RecCubicTo(a1, (a2 - 1), a3, a4, v48, v49, (float)((float)(v26 * 3.0) * 0.25) - (float)((float)(a7 + a11) * 0.125), (float)((float)(v27 * 3.0) * 0.25) - (float)((float)(a8 + a12) * 0.125), a9, v50);
}

void Path::DoArc(Path *a1, int a2, int a3, int a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11)
{
  float v17;
  float v18;
  __float2 v19;
  float cosval;
  float sinval;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  __float2 v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  __float2 v76;
  float v77;
  float v78;
  float v81;
  float v82;
  float v84;
  float v85;
  float v87;
  float v88;

  if (a9 > 0.0001 && a10 > 0.0001)
  {
    v17 = a7 - a5;
    v18 = a8 - a6;
    v19 = __sincosf_stret(a11);
    cosval = v19.__cosval;
    sinval = v19.__sinval;
    v78 = a9;
    v22 = (float)((float)(v18 * v19.__sinval) + (float)(v19.__cosval * v17)) / a9;
    v23 = (float)((float)(v18 * v19.__cosval) - (float)(v19.__sinval * v17)) / a10;
    v24 = 4.0;
    if ((float)((float)(v23 * v23) + (float)(v22 * v22)) < 4.0)
      v24 = (float)(v23 * v23) + (float)(v22 * v22);
    v25 = (float)(v24 * -0.25) + 1.0;
    if (v25 < 0.0)
      v25 = 0.0;
    v26 = sqrtf(v25);
    v27 = sqrtf(v24);
    v28 = (float)-v22 / v27;
    v29 = (float)(v23 / v27) * v26;
    v30 = v22 * 0.5;
    v31 = (float)-v29 - (float)(v22 * 0.5);
    v32 = v23 * 0.5;
    v33 = 3.1416;
    v34 = 3.1416;
    if (v31 >= -1.0)
    {
      v34 = 0.0;
      if (v31 <= 1.0)
      {
        v77 = (float)-(float)(v28 * v26) - v32;
        v35 = v32;
        v36 = acosf(v31);
        v32 = v35;
        v33 = 3.1416;
        sinval = v19.__sinval;
        cosval = v19.__cosval;
        v34 = v36;
        if (v77 < 0.0)
          v34 = 6.28318531 - v36;
      }
    }
    v37 = v28 * v26;
    v38 = -sinval;
    v39 = v30 - v29;
    if ((float)(v30 - v29) >= -1.0)
    {
      v33 = 0.0;
      if (v39 <= 1.0)
      {
        v40 = v32 - v37;
        v41 = cosval;
        v42 = sinval;
        v43 = -sinval;
        v44 = acosf(v39);
        v38 = v43;
        sinval = v42;
        cosval = v41;
        v33 = v44;
        if (v40 < 0.0)
          v33 = 6.28318531 - v44;
      }
    }
    v45 = (float)((float)(v37 * a10) * v38) + (float)(cosval * (float)(v29 * v78));
    v46 = (float)(cosval * (float)(v37 * a10)) + (float)(sinval * (float)(v29 * v78));
    if (a3)
    {
      if (a2)
      {
        v45 = -v45;
        v46 = -v46;
        v47 = v34 + 3.14159265;
        v48 = v33 + 3.14159265;
        v33 = v47 + -6.28318531;
        if (v47 < 6.28318531)
          v33 = v34 + 3.14159265;
        if (v48 >= 6.28318531)
        {
          v49 = v48 + -6.28318531;
          v34 = v49;
        }
        else
        {
          v34 = v48;
        }
      }
      v50 = a8;
      v51 = v34 + 6.28318531;
      if (v34 >= v33)
        v51 = v34;
      v87 = v51;
      v52 = v51 + -0.1;
      if (v33 < v52)
      {
        v53 = (float)((float)(a5 + a7) * 0.5) + v45;
        v81 = (float)((float)(a6 + v50) * 0.5) + v46;
        v84 = v53;
        v54 = cosval * v78;
        v55 = v38 * a10;
        v56 = a10;
        v57 = sinval * v78;
        v58 = cosval * v56;
        v59 = v51 - v33;
        do
        {
          v60 = v33;
          v61 = __sincosf_stret(v52);
          Path::AddPoint(a1, (float)(v84 + (float)(v54 * v61.__cosval)) + (float)(v55 * v61.__sinval), (float)(v81 + (float)(v57 * v61.__cosval)) + (float)(v58 * v61.__sinval), a4, (float)(v87 - v52) / v59, 0);
          v33 = v60;
          v52 = v52 + -0.1;
        }
        while (v60 < v52);
      }
    }
    else
    {
      if ((a2 & 1) == 0)
      {
        v45 = -v45;
        v46 = -v46;
        v62 = v34 + 3.14159265;
        v63 = v33 + 3.14159265;
        v33 = v62 + -6.28318531;
        if (v62 < 6.28318531)
          v33 = v34 + 3.14159265;
        if (v63 >= 6.28318531)
        {
          v64 = v63 + -6.28318531;
          v34 = v64;
        }
        else
        {
          v34 = v63;
        }
      }
      v65 = a8;
      v66 = v34 + -6.28318531;
      if (v34 <= v33)
        v66 = v34;
      v88 = v66;
      v67 = v66 + 0.1;
      if (v33 > v67)
      {
        v68 = (float)((float)(a5 + a7) * 0.5) + v45;
        v82 = (float)((float)(a6 + v65) * 0.5) + v46;
        v85 = v68;
        v69 = cosval * v78;
        v70 = v38 * a10;
        v71 = a10;
        v72 = sinval * v78;
        v73 = cosval * v71;
        v74 = v33 - v66;
        do
        {
          v75 = v33;
          v76 = __sincosf_stret(v67);
          Path::AddPoint(a1, (float)(v85 + (float)(v69 * v76.__cosval)) + (float)(v70 * v76.__sinval), (float)(v82 + (float)(v72 * v76.__cosval)) + (float)(v73 * v76.__sinval), a4, (float)(v67 - v88) / v74, 0);
          v33 = v75;
          v67 = v67 + 0.1;
        }
        while (v75 > v67);
      }
    }
  }
}

void Path::RecBezierTo(Path *a1, int a2, uint64_t a3, uint64_t a4, float a5, double a6, float a7, float32_t a8, float a9, float a10, float a11, float a12, float a13)
{
  float v19;
  float v21;
  float v22;
  uint64_t v23;
  float v28;
  float32x2_t v29;
  float v30;
  float v31;
  float v32;
  _DWORD v36[3];
  unint64_t v37;
  uint64_t v38;
  float32x2_t v39;
  float v40;
  float v41;
  float v42[2];
  float32x2_t v43;
  float v44[2];
  float32x2_t v45;

  v19 = *(float *)&a6;
  v21 = (float)((float)(a7 - a5) * (float)(a10 - *(float *)&a6))
      - (float)((float)(a8 - *(float *)&a6) * (float)(a9 - a5));
  v22 = -v21;
  if (v21 >= 0.0)
    v22 = v21;
  v23 = (a2 - 1);
  if (a2 >= 1)
  {
    v32 = v22;
    v38 = 0;
    v37 = __PAIR64__(LODWORD(a6), LODWORD(a5));
    v36[0] = 1;
    *(float *)&v36[1] = a9;
    *(float *)&v36[2] = a10;
    *(float *)&a6 = a7;
    Path::TangentOnBezAt((float32x2_t *)&v37, (uint64_t)v36, 0, &v39, (uint64_t)&v40, (float *)&v38 + 1, (float *)&v38, 0.0, *(float32x2_t *)&a6, a8);
    Path::PointAndTangentAt(*(Path **)a4, *(_DWORD *)(a4 + 8), &v45, v44, (float)(*(float *)(a4 + 16) * a12) + (float)(*(float *)(a4 + 12) * (float)(1.0 - a12)));
    v28 = (float)(v41 * v44[1]) + (float)(v40 * v44[0]);
    v29.f32[0] = a7;
    Path::TangentOnBezAt((float32x2_t *)&v37, (uint64_t)v36, 0, &v39, (uint64_t)&v40, (float *)&v38 + 1, (float *)&v38, 1.0, v29, a8);
    Path::PointAndTangentAt(*(Path **)a4, *(_DWORD *)(a4 + 8), &v43, v42, (float)(*(float *)(a4 + 16) * a13) + (float)(*(float *)(a4 + 12) * (float)(1.0 - a13)));
    v30 = (float)(v41 * v42[1]) + (float)(v40 * v42[0]);
    if (v28 >= 0.0 || v30 >= 0.0)
    {
      if (v32 >= a11 || v28 < 0.0 || v30 < 0.0)
      {
        v31 = (float)((float)(a8 + a10) + (float)(v19 * 2.0)) * 0.25;
        Path::RecBezierTo(a1, v23, a3, a4, (float)(a5 + a7) * 0.5, (float)(v19 + a8) * 0.5, a7, a8);
        Path::AddPoint(a1, (float)((float)(a7 + a9) + (float)(a5 * 2.0)) * 0.25, v31, a3, (float)(a12 + a13) * 0.5, 0);
        Path::RecBezierTo(a1, v23, a3, a4, (float)(a5 + a9) * 0.5, (float)(v19 + a10) * 0.5, (float)((float)(a7 + a9) + (float)(a5 * 2.0)) * 0.25, v31);
      }
    }
    else
    {
      Path::AddPoint(a1, v45.f32[0], v45.f32[1], -1, 0.0, 0);
      Path::AddPoint(a1, a9, a10, a3, a13, 0);
      Path::AddPoint(a1, a7, a8, a3, a12, 0);
      Path::AddPoint(a1, v43.f32[0], v43.f32[1], -1, 0.0, 0);
    }
  }
}

void Path::Convert(Path *this, float a2)
{
  int var0;
  path_descr *var3;
  float v5;
  float v6;
  float v7;
  int v8;
  double v9;
  int v10;
  float v11;
  path_descr *v12;
  int *v13;
  int v14;
  float v15;
  uint64_t v16;
  float v17;
  float v18;
  float *v19;
  char *v20;
  float v21;
  int v22;
  float *v23;
  char *v24;
  float v25;
  int v26;
  float *v27;
  float *v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  _DWORD *v34;
  int v35;
  int v36;
  char *v37;
  float *v38;
  int v39;
  int v40;
  uint64_t v41;
  float *v42;
  char *v43;
  float v44;
  float v45;
  int v46;
  float v47;
  float *v48;
  char *v49;
  float v50;
  float v51;
  float v52;
  float v53;
  _BOOL4 v54;
  _BOOL4 v55;
  int v56;
  char *var11;
  float *v58;
  int v59;
  int v60;
  char *v61;
  _DWORD *v62;
  int v63;
  char *v64;
  char *v65;
  float v66;
  int v67;
  float v68;
  float v69;
  float v70;
  float *v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  int v83;
  int v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  int v92;
  float v93;
  int v94;
  float v95;
  float v96;
  int v97;
  char *v98;
  _DWORD *v99;
  int v100;
  float v101;
  int v102;
  float v103;
  float v104;
  float v105;
  int v106;
  float v108;
  float v109;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::CancelBezier(this);
    var0 = this->var0;
  }
  if ((var0 & 2) != 0)
    Path::CloseSubpath(this, 0);
  Path::SetBackData(this, 0);
  Path::ResetPoints(this, this->var2);
  if (this->var2 >= 1)
  {
    var3 = this->var3;
    v5 = 1.0;
    if ((*(_BYTE *)var3 & 0x10) != 0)
      v5 = *((float *)var3 + 7);
    v7 = *((float *)var3 + 4);
    v6 = *((float *)var3 + 5);
    if (this->var6)
      v8 = Path::AddPoint(this, v7, v6, v5, 1);
    else
      v8 = Path::AddPoint(this, v7, v6, 1);
    v106 = v8;
    *((_DWORD *)this->var3 + 1) = v8;
    if (this->var2 >= 2)
    {
      v10 = 1;
      v11 = 2.0;
      while (2)
      {
        v12 = this->var3;
        v13 = (int *)((char *)v12 + 44 * v10);
        v14 = *v13;
        v15 = 0.0;
        v16 = v10;
        v17 = 0.0;
        v18 = 0.0;
        switch(*v13 & 0xF)
        {
          case 0:
            v19 = (float *)((char *)v12 + 44 * v10);
            v21 = v19[4];
            v20 = (char *)(v19 + 4);
            v15 = v21;
            v18 = 1.0;
            if ((v14 & 0x10) != 0)
              v18 = *((float *)v20 + 3);
            v17 = *((float *)v20 + 1);
            if (this->var6)
              v22 = Path::AddPoint(this, v15, v17, v18, 1);
            else
              v22 = Path::AddPoint(this, v15, v17, 1);
            v106 = v22;
            *((_DWORD *)v12 + 11 * v10 + 1) = v22;
            goto LABEL_65;
          case 1:
            v23 = (float *)((char *)v12 + 44 * v10);
            v25 = v23[4];
            v24 = (char *)(v23 + 4);
            v15 = v25;
            v18 = 1.0;
            if ((v14 & 0x10) != 0)
              v18 = *((float *)v24 + 2);
            v17 = *((float *)v24 + 1);
            if (this->var6)
              v26 = Path::AddPoint(this, v15, v17, v18, 0);
            else
              v26 = Path::AddPoint(this, v15, v17, 0);
            v61 = (char *)v12 + 44 * v10;
            *((_DWORD *)v61 + 1) = v26;
            v62 = v61 + 4;
            if ((v26 & 0x80000000) == 0)
              goto LABEL_65;
            if (v10)
              goto LABEL_61;
            v63 = 0;
            goto LABEL_62;
          case 2:
            v27 = (float *)((char *)v12 + 44 * v10);
            v29 = v27[4];
            v28 = v27 + 4;
            v15 = v29;
            v18 = 1.0;
            if ((v14 & 0x10) != 0)
              v18 = v28[6];
            v17 = v28[1];
            v30 = v28[2];
            v31 = v28[3];
            v32 = v28[4];
            v33 = v28[5];
            v34 = (_DWORD *)((char *)v12 + 44 * v10 + 4);
            if (!this->var6)
            {
              Path::RecCubicTo(this, v7, v6, v30, v31, v15, v17, v32, v33, 8, a2, -1.0);
              goto LABEL_53;
            }
            Path::RecCubicTo(this, v7, v6, v5, v30, v31, v15, v17, v18, 8, v32, v33, a2, -1.0);
            v35 = Path::AddPoint(this, v15, v17, v18, 0);
            *v34 = v35;
            if ((v35 & 0x80000000) == 0)
              goto LABEL_65;
            if (!v10)
              goto LABEL_27;
            goto LABEL_56;
          case 3:
            v37 = (char *)v12 + 44 * v10;
            v40 = *((_DWORD *)v37 + 4);
            v38 = (float *)(v37 + 16);
            v39 = v40;
            v18 = 1.0;
            if ((v14 & 0x10) != 0)
              v18 = v38[3];
            v15 = v38[1];
            v17 = v38[2];
            v41 = v16 + 1;
            if (v39 >= 1)
            {
              v42 = (float *)((char *)v12 + 44 * v41);
              v45 = v42[4];
              v44 = v42[5];
              v43 = (char *)(v42 + 4);
              v46 = v39 - 1;
              if (v39 == 1)
              {
                v47 = 1.0;
                if ((v14 & 0x10) != 0)
                  v47 = *((float *)v43 + 2);
                if (this->var6)
                  Path::RecBezierTo(this, v45, v44, v47, v7, v6, v5, v15, v17, 8, v18, a2, -1.0);
                else
                  Path::RecBezierTo(this, v45, v44, v7, v6, v15, v17, a2, 8, -1.0);
              }
              else
              {
                v102 = v39;
                v104 = v15;
                v105 = v17;
                v103 = v18;
                v66 = 1.0;
                if ((v14 & 0x10) != 0)
                  v66 = *((float *)v43 + 2);
                v67 = 0;
                v68 = -(float)(v45 - (float)(v7 * v11));
                v69 = -(float)(v44 - (float)(v6 * v11));
                v70 = -(float)(v66 - (float)(v5 * v11));
                v71 = (float *)((char *)v12 + 44 * v41 + 68);
                do
                {
                  v72 = v45;
                  v73 = v44;
                  v74 = v66;
                  v75 = 1.0;
                  if ((v14 & 0x10) != 0)
                    v75 = *v71;
                  v77 = *(v71 - 2);
                  v76 = *(v71 - 1);
                  v78 = v68 + v72;
                  v79 = v78 * 0.5;
                  v80 = (float)(v69 + v44) * 0.5;
                  v81 = (float)(v70 + v74) * 0.5;
                  v82 = v76;
                  v108 = v75;
                  v109 = v77;
                  if (v67)
                  {
                    v83 = this->var6
                        ? Path::AddPoint(this, v78 * 0.5, (float)(v69 + v44) * 0.5, v81, 0)
                        : Path::AddPoint(this, v78 * 0.5, (float)(v69 + v44) * 0.5, 0);
                    *((_DWORD *)v71 - 16) = v83;
                    v76 = v82;
                    v75 = v108;
                    v77 = v109;
                    if (v83 < 0)
                    {
                      if ((_DWORD)v16 == -1)
                        v84 = 0;
                      else
                        v84 = *((_DWORD *)v71 - 27);
                      *((_DWORD *)v71 - 16) = v84;
                    }
                  }
                  v85 = (float)(v72 + v77) * 0.5;
                  v86 = (float)(v73 + v76) * 0.5;
                  if (this->var6)
                  {
                    v87 = v79;
                    v88 = v81;
                    v89 = v85;
                    v90 = (float)(v73 + v76) * 0.5;
                    Path::RecBezierTo(this, v72, v73, v74, v87, v80, v88, v85, v86, 8, (float)(v74 + v75) * 0.5, a2, -1.0);
                  }
                  else
                  {
                    v91 = v79;
                    v89 = (float)(v72 + v77) * 0.5;
                    v90 = (float)(v73 + v76) * 0.5;
                    Path::RecBezierTo(this, v72, v73, v91, v80, v89, v86, a2, 8, -1.0);
                  }
                  v66 = v108;
                  v45 = v109;
                  v44 = v82;
                  ++v67;
                  v71 += 11;
                  v70 = v74;
                  v69 = v73;
                  v68 = v72;
                }
                while (v46 != v67);
                if (this->var6)
                  v92 = Path::AddPoint(this, v89, v90, (float)(v74 + v108) * 0.5, 0);
                else
                  v92 = Path::AddPoint(this, v89, v90, 0);
                v18 = v103;
                v15 = v104;
                v39 = v102;
                *((_DWORD *)v71 - 16) = v92;
                v93 = v82;
                if (v92 < 0)
                {
                  if ((_DWORD)v16 == -1)
                    v94 = 0;
                  else
                    v94 = *((_DWORD *)v71 - 27);
                  *((_DWORD *)v71 - 16) = v94;
                }
                v95 = v109 - (float)(v109 - (float)(v104 * 2.0));
                v96 = (float)(v82 - (float)(v82 - (float)(v105 * 2.0))) * 0.5;
                v11 = 2.0;
                if (this->var6)
                  Path::RecBezierTo(this, v109, v93, v108, v89, v90, (float)(v74 + v108) * 0.5, v95 * 0.5, v96, 8, (float)(v108 - (float)(v108 - (float)(v103 * 2.0))) * 0.5, a2, -1.0);
                else
                  Path::RecBezierTo(this, v109, v93, v89, v90, v95 * 0.5, v96, a2, 8, -1.0);
                v17 = v105;
              }
            }
            if (this->var6)
              v97 = Path::AddPoint(this, v15, v17, v18, 0);
            else
              v97 = Path::AddPoint(this, v15, v17, 0);
            v98 = (char *)v12 + 44 * (int)v16;
            *((_DWORD *)v98 + 1) = v97;
            v99 = v98 + 4;
            if (v97 < 0)
            {
              if ((_DWORD)v16 == -1)
                v100 = 0;
              else
                v100 = *(v13 - 10);
              *v99 = v100;
            }
            v10 = v39 + v41;
            goto LABEL_66;
          case 4:
            v48 = (float *)((char *)v12 + 44 * v10);
            v50 = v48[4];
            v49 = (char *)(v48 + 4);
            v15 = v50;
            v18 = 1.0;
            if ((v14 & 0x10) != 0)
              v18 = *((float *)v49 + 6);
            v17 = *((float *)v49 + 1);
            v51 = *((float *)v49 + 2);
            v52 = *((float *)v49 + 3);
            v53 = *((float *)v49 + 4);
            v34 = (_DWORD *)((char *)v12 + 44 * v10 + 4);
            v54 = v49[21] != 0;
            v55 = v49[20] != 0;
            if (this->var6)
            {
              Path::DoArc(this, v7, v6, v5, v15, v17, v18, v51, v52, v55, v54, v53, v101);
              v56 = Path::AddPoint(this, v15, v17, v18, 0);
            }
            else
            {
              Path::DoArc(this, v7, v6, v15, v17, v51, v52, v53, v55, v54, v52);
LABEL_53:
              v56 = Path::AddPoint(this, v15, v17, 0);
            }
            *v34 = v56;
            if ((v56 & 0x80000000) == 0)
              goto LABEL_65;
            if (v10)
LABEL_56:
              v36 = *(v13 - 10);
            else
LABEL_27:
              v36 = 0;
            *v34 = v36;
LABEL_65:
            ++v10;
LABEL_66:
            v5 = v18;
            v6 = v17;
            v7 = v15;
            if (v10 >= this->var2)
              return;
            continue;
          case 5:
            var11 = this->var11;
            if (this->var6)
            {
              v58 = (float *)&var11[16 * v106];
              v15 = v58[1];
              v17 = v58[2];
              v18 = v58[3];
              v59 = Path::AddPoint(this, v15, v17, v18, 0);
            }
            else
            {
              v64 = &var11[12 * v106];
              v15 = *((float *)v64 + 1);
              v17 = *((float *)v64 + 2);
              v59 = Path::AddPoint(this, v15, v17, 0);
            }
            v65 = (char *)v12 + 44 * v10;
            *((_DWORD *)v65 + 1) = v59;
            v62 = v65 + 4;
            if ((v59 & 0x80000000) == 0)
              goto LABEL_65;
            if (v10)
            {
LABEL_61:
              v63 = *(v13 - 10);
LABEL_62:
              *v62 = v63;
            }
            else
            {
              *v62 = 0;
            }
            goto LABEL_65;
          case 6:
            goto LABEL_66;
          case 7:
            if (this->var6)
            {
              Path::AddForcedPoint(this, v7, v6, v5);
            }
            else
            {
              *(float *)&v9 = v7;
              v9 = Path::AddForcedPoint(this, v9, v6);
            }
            *((_DWORD *)v12 + 11 * v10 + 1) = v60;
            goto LABEL_65;
          default:
            v17 = 0.0;
            v18 = 0.0;
            goto LABEL_66;
        }
      }
    }
  }
}

Path *Path::RecCubicTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, float a11, float a12, float a13, float a14)
{
  Path *v17;
  float v18;
  float v19;
  float i;
  float v23;
  float v24;
  float v25;
  float v27;
  float v28;
  float v29;
  float v30;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v43;
  float v44;
  float v45;
  float v47;
  float v48;
  float v49;
  float v50;

  v17 = this;
  v19 = a13;
  v18 = a14;
  for (i = 0.5; ; i = 0.5)
  {
    v23 = a7 - a2;
    v24 = a8 - a3;
    v25 = sqrtf((float)(v24 * v24) + (float)(v23 * v23));
    if (v25 < 0.01)
    {
      if ((float)((float)(a5 * a5) + (float)(a6 * a6)) >= v19)
      {
LABEL_18:
        if (a10 < 1)
          return this;
      }
      else if ((float)((float)(a11 * a11) + (float)(a12 * a12)) < v19 || a10 < 1)
      {
        return this;
      }
      v32 = (float)(a4 + a9) * i;
      v33 = (float)((float)(a2 + a7) * i) + (float)((float)(a5 - a11) * 0.125);
      v34 = a8;
      v35 = (float)((float)(a3 + a8) * i) + (float)((float)(a6 - a12) * 0.125);
      v36 = (float)((float)(v23 * 3.0) * 0.25) - (float)((float)(a5 + a11) * 0.125);
      v37 = (float)(a6 + a12) * 0.125;
      v47 = a11;
      v49 = a12;
      v38 = a7;
      v39 = v34;
      v40 = (float)((float)(v24 * 3.0) * 0.25) - v37;
      --a10;
      v41 = 0.5;
      Path::RecCubicTo(v17, a2, a3, a4, a5 * i, a6 * i, v33, v35, v32, v36, v40, v19, a10, v18);
      this = (Path *)Path::AddPoint(v17, v33, v35, v32, 0);
      a2 = v33;
      a3 = v35;
      a4 = v32;
      a5 = v36;
      a6 = v40;
      a8 = v39;
      a7 = v38;
      a11 = v47;
      a12 = v49;
      goto LABEL_26;
    }
    v27 = (float)(v23 * a6) - (float)(v24 * a5);
    v28 = -v27;
    if (v27 >= 0.0)
      v28 = (float)(v23 * a6) - (float)(v24 * a5);
    v29 = -(float)((float)(v23 * a12) - (float)(v24 * a11));
    if ((float)((float)(v23 * a12) - (float)(v24 * a11)) >= 0.0)
      v29 = (float)(v23 * a12) - (float)(v24 * a11);
    v30 = v29 / v25;
    if ((float)(v28 / v25) >= v19 || v30 >= v19)
      goto LABEL_18;
    if (v18 <= 0.0)
      break;
    if (v25 <= v18 || a10 < 1)
      break;
    v43 = (float)(a4 + a9) * i;
    v44 = (float)((float)(a2 + a7) * i) + (float)((float)(a5 - a11) * 0.125);
    v45 = (float)((float)(a3 + a8) * i) + (float)((float)(a6 - a12) * 0.125);
    v48 = (float)((float)(v23 * 3.0) * 0.25) - (float)((float)(a5 + a11) * 0.125);
    v50 = (float)((float)(v24 * 3.0) * 0.25) - (float)((float)(a6 + a12) * 0.125);
    --a10;
    v41 = 0.5;
    Path::RecCubicTo(v17, a2, a3, a4, a5 * i, a6 * i, v44, v45, v43, v48, v50, v19, a10, v18);
    this = (Path *)Path::AddPoint(v17, v44, v45, v43, 0);
    a2 = v44;
    a3 = v45;
    a4 = v43;
    a5 = v48;
    a6 = v50;
LABEL_26:
    a12 = a12 * v41;
    a11 = a11 * v41;
    v19 = a13;
    v18 = a14;
  }
  return this;
}

Path *Path::RecCubicTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, float a11, float a12)
{
  Path *v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v21;
  float v22;
  float v23;
  float v24;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;

  v15 = this;
  v16 = a12;
  v31 = a6;
  v32 = a7;
  while (1)
  {
    v17 = a6 - a2;
    v18 = a7 - a3;
    v19 = sqrtf((float)(v18 * v18) + (float)(v17 * v17));
    if (v19 >= 0.01)
      break;
    if ((float)((float)(a4 * a4) + (float)(a5 * a5)) >= a11)
      goto LABEL_18;
    if ((float)((float)(a8 * a8) + (float)(a9 * a9)) < a11 || a10 < 1)
      return this;
LABEL_25:
    v27 = (float)((float)(a2 + a6) * 0.5) + (float)((float)(a4 - a8) * 0.125);
    v28 = (float)((float)(a3 + a7) * 0.5) + (float)((float)(a5 - a9) * 0.125);
    v29 = (float)((float)(v17 * 3.0) * 0.25) - (float)((float)(a4 + a8) * 0.125);
    v30 = (float)((float)(v18 * 3.0) * 0.25) - (float)((float)(a5 + a9) * 0.125);
    Path::RecCubicTo(v15, a2, a3, a4 * 0.5, a5 * 0.5, v27, v28, v29, v30, a11, --a10, v16);
    this = (Path *)Path::AddPoint(v15, v27, v28, 0);
    a2 = v27;
    a3 = v28;
    a4 = v29;
    a5 = v30;
    a9 = a9 * 0.5;
    a8 = a8 * 0.5;
    a6 = v31;
    a7 = v32;
    v16 = a12;
  }
  v21 = (float)(v17 * a5) - (float)(v18 * a4);
  v22 = -v21;
  if (v21 >= 0.0)
    v22 = (float)(v17 * a5) - (float)(v18 * a4);
  v23 = -(float)((float)(v17 * a9) - (float)(v18 * a8));
  if ((float)((float)(v17 * a9) - (float)(v18 * a8)) >= 0.0)
    v23 = (float)(v17 * a9) - (float)(v18 * a8);
  v24 = v23 / v19;
  if ((float)(v22 / v19) >= a11 || v24 >= a11)
  {
LABEL_18:
    if (a10 < 1)
      return this;
    goto LABEL_25;
  }
  if (v16 > 0.0 && v19 > v16 && a10 >= 1)
    goto LABEL_25;
  return this;
}

void Path::DoArc(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, int a11, float a12, float a13)
{
  float v18;
  float v19;
  __float2 v20;
  float cosval;
  float sinval;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  __float2 v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  __float2 v73;
  float v74;
  float v75;
  float v77;
  float v78;
  float v80;
  float v81;
  float v83;
  float v84;
  float v86;
  float v87;

  if (a8 > 0.0001 && a9 > 0.0001)
  {
    v18 = a5 - a2;
    v19 = a6 - a3;
    v20 = __sincosf_stret(a12);
    cosval = v20.__cosval;
    sinval = v20.__sinval;
    v77 = a8;
    v78 = a9;
    v23 = (float)((float)(v19 * v20.__sinval) + (float)(v20.__cosval * v18)) / a8;
    v24 = (float)((float)(v19 * v20.__cosval) - (float)(v20.__sinval * v18)) / a9;
    v25 = 4.0;
    if ((float)((float)(v24 * v24) + (float)(v23 * v23)) < 4.0)
      v25 = (float)(v24 * v24) + (float)(v23 * v23);
    v26 = (float)(v25 * -0.25) + 1.0;
    if (v26 < 0.0)
      v26 = 0.0;
    v27 = sqrtf(v26);
    v28 = sqrtf(v25);
    v29 = (float)-v23 / v28;
    v30 = (float)(v24 / v28) * v27;
    v31 = v23 * 0.5;
    v32 = (float)-v30 - (float)(v23 * 0.5);
    v33 = v24 * 0.5;
    v34 = 3.1416;
    v35 = 3.1416;
    if (v32 >= -1.0)
    {
      v35 = 0.0;
      if (v32 <= 1.0)
      {
        v74 = (float)-(float)(v29 * v27) - v33;
        v75 = v33;
        v36 = acosf(v32);
        sinval = v20.__sinval;
        cosval = v20.__cosval;
        v35 = v36;
        v33 = v75;
        if (v74 < 0.0)
          v35 = 6.28318531 - v36;
      }
    }
    v37 = v29 * v27;
    v38 = -sinval;
    v39 = v31 - v30;
    if ((float)(v31 - v30) >= -1.0)
    {
      v34 = 0.0;
      if (v39 <= 1.0)
      {
        v40 = v33 - v37;
        v41 = cosval;
        v42 = sinval;
        v43 = acosf(v39);
        sinval = v42;
        cosval = v41;
        v34 = v43;
        if (v40 < 0.0)
          v34 = 6.28318531 - v43;
      }
    }
    v44 = (float)((float)(v37 * v78) * v38) + (float)(cosval * (float)(v30 * v77));
    v45 = (float)(cosval * (float)(v37 * v78)) + (float)(sinval * (float)(v30 * v77));
    if (a11)
    {
      if (a10)
      {
        v44 = -v44;
        v45 = -v45;
        v46 = v35 + 3.14159265;
        v47 = v34 + 3.14159265;
        if (v46 >= 6.28318531)
        {
          v48 = v46 + -6.28318531;
          v34 = v48;
        }
        else
        {
          v34 = v35 + 3.14159265;
        }
        if (v47 >= 6.28318531)
        {
          v49 = v47 + -6.28318531;
          v35 = v49;
        }
        else
        {
          v35 = v47;
        }
      }
      v50 = a6;
      v51 = v35 + 6.28318531;
      if (v35 >= v34)
        v51 = v35;
      v86 = v51;
      v52 = v51 + -0.1;
      if (v34 < v52)
      {
        v53 = (float)((float)(a2 + a5) * 0.5) + v44;
        v80 = (float)((float)(a3 + v50) * 0.5) + v45;
        v83 = v53;
        v54 = cosval * v77;
        v55 = v38 * v78;
        v56 = sinval * v77;
        v57 = cosval * v78;
        v58 = v51 - v34;
        do
        {
          v59 = __sincosf_stret(v52);
          Path::AddPoint(this, (float)(v83 + (float)(v54 * v59.__cosval)) + (float)(v55 * v59.__sinval), (float)(v80 + (float)(v56 * v59.__cosval)) + (float)(v57 * v59.__sinval), (float)((float)((float)(v86 - v52) * a7) + (float)(a4 * (float)(v52 - v34))) / v58, 0);
          v52 = v52 + -0.1;
        }
        while (v34 < v52);
      }
    }
    else
    {
      if ((a10 & 1) == 0)
      {
        v44 = -v44;
        v45 = -v45;
        v60 = v35 + 3.14159265;
        v61 = v34 + 3.14159265;
        if (v60 >= 6.28318531)
        {
          v62 = v60 + -6.28318531;
          v34 = v62;
        }
        else
        {
          v34 = v35 + 3.14159265;
        }
        if (v61 >= 6.28318531)
        {
          v63 = v61 + -6.28318531;
          v35 = v63;
        }
        else
        {
          v35 = v61;
        }
      }
      v64 = a6;
      v65 = v35 + -6.28318531;
      if (v35 <= v34)
        v65 = v35;
      v87 = v65;
      v66 = v65 + 0.1;
      if (v34 > v66)
      {
        v67 = (float)((float)(a2 + a5) * 0.5) + v44;
        v81 = (float)((float)(a3 + v64) * 0.5) + v45;
        v84 = v67;
        v68 = cosval * v77;
        v69 = v38 * v78;
        v70 = sinval * v77;
        v71 = cosval * v78;
        v72 = v34 - v65;
        do
        {
          v73 = __sincosf_stret(v66);
          Path::AddPoint(this, (float)(v84 + (float)(v68 * v73.__cosval)) + (float)(v69 * v73.__sinval), (float)(v81 + (float)(v70 * v73.__cosval)) + (float)(v71 * v73.__sinval), (float)((float)((float)(v66 - v87) * a7) + (float)(a4 * (float)(v34 - v66))) / v72, 0);
          v66 = v66 + 0.1;
        }
        while (v34 > v66);
      }
    }
  }
}

void Path::DoArc(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, int a9, int a10, float a11)
{
  float v15;
  float v17;
  float cosval;
  float sinval;
  __float2 v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  __float2 v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  __float2 v75;
  float v76;
  float v80;
  float v82;
  float v83;

  if (a6 > 0.0001 && a7 > 0.0001)
  {
    v15 = a4 - a2;
    v17 = a5 - a3;
    v20 = __sincosf_stret(a8);
    cosval = v20.__cosval;
    sinval = v20.__sinval;
    v21 = (float)(v17 * v20.__sinval) + (float)(v20.__cosval * v15);
    v22 = v17 * v20.__cosval;
    v23 = a7;
    v80 = a6;
    v24 = v21 / a6;
    v25 = (float)(v22 - (float)(v20.__sinval * v15)) / a7;
    v26 = 4.0;
    if ((float)((float)(v25 * v25) + (float)(v24 * v24)) < 4.0)
      v26 = (float)(v25 * v25) + (float)(v24 * v24);
    v27 = (float)(v26 * -0.25) + 1.0;
    if (v27 < 0.0)
      v27 = 0.0;
    v28 = sqrtf(v27);
    v29 = sqrtf(v26);
    v30 = (float)-v24 / v29;
    v31 = (float)(v25 / v29) * v28;
    v32 = v24 * 0.5;
    v33 = (float)-v31 - (float)(v24 * 0.5);
    v34 = v25 * 0.5;
    v35 = 3.1416;
    v36 = 3.1416;
    if (v33 >= -1.0)
    {
      v36 = 0.0;
      if (v33 <= 1.0)
      {
        v76 = (float)-(float)(v30 * v28) - v34;
        v37 = v34;
        v38 = acosf(v33);
        v34 = v37;
        cosval = v20.__cosval;
        v35 = 3.1416;
        sinval = v20.__sinval;
        v36 = v38;
        v23 = a7;
        if (v76 < 0.0)
          v36 = 6.28318531 - v38;
      }
    }
    v39 = v30 * v28;
    v40 = -sinval;
    v41 = v32 - v31;
    if ((float)(v32 - v31) >= -1.0)
    {
      v35 = 0.0;
      if (v41 <= 1.0)
      {
        v42 = v34 - v39;
        v43 = cosval;
        v44 = sinval;
        v45 = acosf(v41);
        sinval = v44;
        cosval = v43;
        v35 = v45;
        if (v42 < 0.0)
          v35 = 6.28318531 - v45;
      }
    }
    v46 = (float)((float)(v39 * v23) * v40) + (float)(cosval * (float)(v31 * v80));
    v47 = (float)(cosval * (float)(v39 * v23)) + (float)(sinval * (float)(v31 * v80));
    if (a10)
    {
      if (a9)
      {
        v46 = -v46;
        v47 = -v47;
        v48 = v36 + 3.14159265;
        v49 = v35 + 3.14159265;
        if (v48 >= 6.28318531)
        {
          v50 = v48 + -6.28318531;
          v35 = v50;
        }
        else
        {
          v35 = v36 + 3.14159265;
        }
        if (v49 >= 6.28318531)
        {
          v51 = v49 + -6.28318531;
          v36 = v51;
        }
        else
        {
          v36 = v49;
        }
      }
      v52 = a5;
      v53 = v36 + 6.28318531;
      if (v36 >= v35)
        v53 = v36;
      v54 = v53 + -0.1;
      if (v35 < v54)
      {
        v82 = (float)((float)(a2 + a4) * 0.5) + v46;
        v55 = (float)((float)(a3 + v52) * 0.5) + v47;
        v56 = cosval * v80;
        v57 = v40 * v23;
        v58 = sinval * v80;
        v59 = cosval * v23;
        do
        {
          v60 = v35;
          v61 = __sincosf_stret(v54);
          Path::AddPoint(this, (float)(v82 + (float)(v56 * v61.__cosval)) + (float)(v57 * v61.__sinval), (float)(v55 + (float)(v58 * v61.__cosval)) + (float)(v59 * v61.__sinval), 0);
          v35 = v60;
          v54 = v54 + -0.1;
        }
        while (v60 < v54);
      }
    }
    else
    {
      if ((a9 & 1) == 0)
      {
        v46 = -v46;
        v47 = -v47;
        v62 = v36 + 3.14159265;
        v63 = v35 + 3.14159265;
        if (v62 >= 6.28318531)
        {
          v64 = v62 + -6.28318531;
          v35 = v64;
        }
        else
        {
          v35 = v36 + 3.14159265;
        }
        if (v63 >= 6.28318531)
        {
          v65 = v63 + -6.28318531;
          v36 = v65;
        }
        else
        {
          v36 = v63;
        }
      }
      v66 = a5;
      v67 = v36 + -6.28318531;
      if (v36 <= v35)
        v67 = v36;
      v68 = v67 + 0.1;
      if (v35 > v68)
      {
        v83 = (float)((float)(a2 + a4) * 0.5) + v46;
        v69 = (float)((float)(a3 + v66) * 0.5) + v47;
        v70 = cosval * v80;
        v71 = v40 * v23;
        v72 = sinval * v80;
        v73 = cosval * v23;
        do
        {
          v74 = v35;
          v75 = __sincosf_stret(v68);
          Path::AddPoint(this, (float)(v83 + (float)(v70 * v75.__cosval)) + (float)(v71 * v75.__sinval), (float)(v69 + (float)(v72 * v75.__cosval)) + (float)(v73 * v75.__sinval), 0);
          v35 = v74;
          v68 = v68 + 0.1;
        }
        while (v74 > v68);
      }
    }
  }
}

Path *Path::RecBezierTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, int a10, float a11, float a12, float a13)
{
  int v13;
  Path *v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;

  if (a10 >= 1)
  {
    v13 = a10;
    v19 = this;
    v20 = a12;
    v21 = a13;
    v22 = 0.5;
    do
    {
      v23 = (float)((float)(a5 - a2) * (float)(a9 - a3)) - (float)((float)(a6 - a3) * (float)(a8 - a2));
      v24 = -v23;
      if (v23 >= 0.0)
        v24 = (float)((float)(a5 - a2) * (float)(a9 - a3)) - (float)((float)(a6 - a3) * (float)(a8 - a2));
      v29 = a4;
      if (v24 < v20
        && (v21 <= 0.0
         || sqrtf((float)((float)(a9 - a6) * (float)(a9 - a6)) + (float)((float)(a8 - a5) * (float)(a8 - a5))) <= v21))
      {
        break;
      }
      v25 = (float)((float)(a5 + a8) + (float)(a2 * 2.0)) * 0.25;
      v26 = (float)((float)(a6 + a9) + (float)(a3 * 2.0)) * 0.25;
      v28 = (float)((float)(a7 + a11) + (float)(a4 * 2.0)) * 0.25;
      Path::RecBezierTo(v19, (float)(a2 + a5) * v22, (float)(a3 + a6) * v22, (float)(a4 + a7) * v22, a5, a6, a7, v25, v26, v28, v20, --v13, v21);
      this = (Path *)Path::AddPoint(v19, v25, v26, v28, 0);
      a5 = v25;
      a6 = v27;
      a7 = v28;
      v21 = a13;
      a4 = (float)(v29 + a11) * 0.5;
      a3 = (float)(a3 + a9) * 0.5;
      a2 = (float)(a2 + a8) * 0.5;
      v22 = 0.5;
      v20 = a12;
    }
    while (v13 >= 1);
  }
  return this;
}

Path *Path::RecBezierTo(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, int a9, float a10)
{
  int v10;
  Path *v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;

  if (a9 >= 1)
  {
    v10 = a9;
    v16 = this;
    v21 = a10;
    do
    {
      v17 = (float)((float)(a4 - a2) * (float)(a7 - a3)) - (float)((float)(a5 - a3) * (float)(a6 - a2));
      v18 = -v17;
      if (v17 >= 0.0)
        v18 = (float)((float)(a4 - a2) * (float)(a7 - a3)) - (float)((float)(a5 - a3) * (float)(a6 - a2));
      if (v18 < a8
        && (a10 <= 0.0
         || sqrtf((float)((float)(a7 - a5) * (float)(a7 - a5)) + (float)((float)(a6 - a4) * (float)(a6 - a4))) <= a10))
      {
        break;
      }
      v19 = (float)((float)(a4 + a6) + (float)(a2 * 2.0)) * 0.25;
      v20 = (float)((float)(a5 + a7) + (float)(a3 * 2.0)) * 0.25;
      Path::RecBezierTo(v16, (float)(a2 + a4) * 0.5, (float)(a3 + a5) * 0.5, a4, a5, v19, v20, a8, --v10, a10);
      this = (Path *)Path::AddPoint(v16, v19, v20, 0);
      a4 = v19;
      a5 = v20;
      a3 = (float)(a3 + a7) * 0.5;
      a2 = (float)(a2 + a6) * 0.5;
      a10 = v21;
    }
    while (v10 >= 1);
  }
  return this;
}

void Path::ConvertEvenLines(Path *this, float a2)
{
  int var0;
  path_descr *var3;
  float v5;
  float v6;
  float v7;
  float v8;
  uint64_t v9;
  double v10;
  float v11;
  uint64_t v12;
  int v13;
  float v14;
  path_descr *v15;
  int *v16;
  int v17;
  float v18;
  uint64_t v19;
  float v20;
  float v21;
  float *v22;
  char *v23;
  float v24;
  float v25;
  uint64_t v26;
  float v27;
  float *v28;
  char *v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  int v36;
  char *v37;
  _DWORD *v38;
  float *v39;
  float *v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  _DWORD *v46;
  float v47;
  int v48;
  int v49;
  char *v50;
  float *v51;
  int v52;
  int v53;
  float v54;
  uint64_t v55;
  float *v56;
  char *v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float *v62;
  char *v63;
  float v64;
  float v65;
  float v66;
  float v67;
  _BOOL4 v68;
  _BOOL4 v69;
  float v70;
  int v71;
  char *var11;
  float *v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  int v87;
  char *v88;
  _DWORD *v89;
  float v90;
  int v91;
  float v92;
  float v93;
  float v94;
  float v95;
  int v96;
  char *v97;
  char *v98;
  float v99;
  float v100;
  float v101;
  float v102;
  int v103;
  char *v104;
  _DWORD *v105;
  float v106;
  int v107;
  float v108;
  float v109;
  float v110;
  float *v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  int v124;
  int v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  float v132;
  int v133;
  float v134;
  int v135;
  float v136;
  float v137;
  int v138;
  char *v139;
  _DWORD *v140;
  int v141;
  float v142;
  float v143;
  float v144;
  float v145;
  uint64_t v146;
  float v147;
  float v148;
  float v149;
  float v151;
  float v152;
  float v153;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::CancelBezier(this);
    var0 = this->var0;
  }
  if ((var0 & 2) != 0)
    Path::CloseSubpath(this, 0);
  Path::SetBackData(this, 0);
  Path::ResetPoints(this, this->var2);
  if (this->var2 >= 1)
  {
    var3 = this->var3;
    v5 = 1.0;
    if ((*(_BYTE *)var3 & 0x10) != 0)
      v5 = *((float *)var3 + 7);
    v7 = *((float *)var3 + 4);
    v6 = *((float *)var3 + 5);
    v8 = v6;
    v9 = this->var6 ? Path::AddPoint(this, v7, v6, v5, 1) : Path::AddPoint(this, v7, v6, 1);
    v11 = v8;
    v12 = v9;
    *((_DWORD *)this->var3 + 1) = v9;
    if (this->var2 >= 2)
    {
      v151 = a2 * 4.0;
      v13 = 1;
      v14 = 2.0;
      while (1)
      {
        v15 = this->var3;
        v16 = (int *)((char *)v15 + 44 * v13);
        v17 = *v16;
        v18 = 0.0;
        v19 = v13;
        v20 = 0.0;
        v21 = 0.0;
        switch(*v16 & 0xF)
        {
          case 0:
            v22 = (float *)((char *)v15 + 44 * v13);
            v24 = v22[4];
            v23 = (char *)(v22 + 4);
            v18 = v24;
            v21 = 1.0;
            if ((v17 & 0x10) != 0)
              v21 = *((float *)v23 + 3);
            v20 = *((float *)v23 + 1);
            v25 = v11;
            if (this->var6)
              v26 = Path::AddPoint(this, v18, v20, v21, 1);
            else
              v26 = Path::AddPoint(this, v18, v20, 1);
            v11 = v25;
            v12 = v26;
            *((_DWORD *)v15 + 11 * v13 + 1) = v26;
            goto LABEL_113;
          case 1:
            v27 = v7;
            v28 = (float *)((char *)v15 + 44 * v13);
            v30 = v28[4];
            v29 = (char *)(v28 + 4);
            v31 = v30;
            v32 = 1.0;
            if ((v17 & 0x10) != 0)
              v32 = *((float *)v29 + 2);
            v33 = sqrtf((float)((float)(*((float *)v29 + 1) - v11) * (float)(*((float *)v29 + 1) - v11))+ (float)((float)(v31 - v27) * (float)(v31 - v27)));
            if (this->var6)
            {
              v147 = v11;
              v18 = v31;
              v20 = *((float *)v29 + 1);
              if (v33 > v151)
              {
                v34 = fmaxf(v151, v33 / 100.0);
                if (v34 < v33)
                {
                  v35 = v34;
                  do
                  {
                    Path::AddPoint(this, (float)((float)(v18 * v35) + (float)((float)(v33 - v35) * v27)) / v33, (float)((float)(v20 * v35) + (float)((float)(v33 - v35) * v147)) / v33, (float)((float)(v32 * v35) + (float)((float)(v33 - v35) * v5)) / v33, 0);
                    v35 = v34 + v35;
                  }
                  while (v35 < v33);
                }
              }
              v36 = Path::AddPoint(this, v18, v20, v32, 0);
              v37 = (char *)v15 + 44 * v13;
              *((_DWORD *)v37 + 1) = v36;
              v38 = v37 + 4;
              v14 = 2.0;
              v21 = v32;
              v7 = v27;
              v11 = v147;
              if (v36 < 0)
              {
                if (v13)
                  goto LABEL_27;
LABEL_65:
                *v38 = 0;
              }
            }
            else
            {
              v92 = v11;
              v93 = *((float *)v29 + 1);
              if (v33 > v151)
              {
                v94 = fmaxf(v151, v33 / 100.0);
                if (v94 < v33)
                {
                  v95 = v94;
                  do
                  {
                    Path::AddPoint(this, (float)((float)(v31 * v95) + (float)((float)(v33 - v95) * v27)) / v33, (float)((float)(v93 * v95) + (float)((float)(v33 - v95) * v92)) / v33, 0);
                    v95 = v94 + v95;
                  }
                  while (v95 < v33);
                }
              }
              v96 = Path::AddPoint(this, v31, v93, 0);
              v97 = (char *)v15 + 44 * v13;
              *((_DWORD *)v97 + 1) = v96;
              v38 = v97 + 4;
              v14 = 2.0;
              v21 = v32;
              v7 = v27;
              v11 = v92;
              v18 = v31;
              v20 = v93;
              if (v96 < 0)
              {
                if (v13)
                {
LABEL_27:
                  *v38 = *(v16 - 10);
                  goto LABEL_113;
                }
                goto LABEL_65;
              }
            }
LABEL_113:
            ++v13;
LABEL_114:
            v10 = vabds_f32(v7, v18);
            if (v10 > 0.00001 || (v10 = vabds_f32(v11, v20), v10 > 0.00001))
            {
              v7 = v18;
              v11 = v20;
            }
            v5 = v21;
            if (v13 >= this->var2)
              return;
            break;
          case 2:
            v39 = (float *)((char *)v15 + 44 * v13);
            v41 = v39[4];
            v40 = v39 + 4;
            v18 = v41;
            v21 = 1.0;
            if ((v17 & 0x10) != 0)
              v21 = v40[6];
            v20 = v40[1];
            v42 = v40[2];
            v43 = v40[3];
            v44 = v40[4];
            v45 = v40[5];
            v46 = (_DWORD *)((char *)v15 + 44 * v13 + 4);
            if (!this->var6)
            {
              v70 = v11;
              Path::RecCubicTo(this, v7, v11, v42, v43, v18, v20, v44, v45, 8, a2, v151);
              goto LABEL_68;
            }
            v47 = v11;
            Path::RecCubicTo(this, v7, v11, v5, v42, v43, v18, v20, v21, 8, v44, v45, a2, v151);
            v48 = Path::AddPoint(this, v18, v20, v21, 0);
            v11 = v47;
            *v46 = v48;
            if ((v48 & 0x80000000) == 0)
              goto LABEL_113;
            if (!v13)
              goto LABEL_33;
            goto LABEL_71;
          case 3:
            v148 = v11;
            v146 = v12;
            v50 = (char *)v15 + 44 * v13;
            v53 = *((_DWORD *)v50 + 4);
            v51 = (float *)(v50 + 16);
            v52 = v53;
            v21 = 1.0;
            if ((v17 & 0x10) != 0)
              v21 = v51[3];
            v54 = v51[1];
            v20 = v51[2];
            v55 = v19 + 1;
            if (v52 >= 1)
            {
              v56 = (float *)((char *)v15 + 44 * v55);
              v59 = v56[4];
              v58 = v56[5];
              v57 = (char *)(v56 + 4);
              if (v52 == 1)
              {
                v60 = 1.0;
                if ((v17 & 0x10) != 0)
                  v60 = *((float *)v57 + 2);
                v61 = v54;
                if (this->var6)
                  Path::RecBezierTo(this, v59, v58, v60, v7, v11, v5, v54, v20, 8, v21, a2, v151);
                else
                  Path::RecBezierTo(this, v59, v58, v7, v11, v54, v20, a2, 8, v151);
                v54 = v61;
              }
              else
              {
                v143 = v21;
                v106 = 1.0;
                if ((v17 & 0x10) != 0)
                  v106 = *((float *)v57 + 2);
                v107 = 0;
                v144 = v7;
                v145 = v54;
                v108 = -(float)(v59 - (float)(v7 * v14));
                v109 = -(float)(v58 - (float)(v11 * v14));
                v110 = -(float)(v106 - (float)(v5 * v14));
                v111 = (float *)((char *)v15 + 44 * v55 + 68);
                v149 = v20;
                do
                {
                  v112 = v59;
                  v113 = v58;
                  v114 = v106;
                  v115 = 1.0;
                  if ((v17 & 0x10) != 0)
                    v115 = *v111;
                  v117 = *(v111 - 2);
                  v116 = *(v111 - 1);
                  v118 = v108 + v59;
                  v119 = v118 * 0.5;
                  v120 = (float)(v109 + v58) * 0.5;
                  v121 = (float)(v110 + v114) * 0.5;
                  v122 = v116;
                  v123 = v117;
                  v153 = v115;
                  if (v107)
                  {
                    v124 = this->var6
                         ? Path::AddPoint(this, v118 * 0.5, (float)(v109 + v58) * 0.5, v121, 0)
                         : Path::AddPoint(this, v118 * 0.5, (float)(v109 + v58) * 0.5, 0);
                    *((_DWORD *)v111 - 16) = v124;
                    v116 = v122;
                    v117 = v123;
                    v115 = v153;
                    if (v124 < 0)
                    {
                      if ((_DWORD)v19 == -1)
                        v125 = 0;
                      else
                        v125 = *((_DWORD *)v111 - 27);
                      *((_DWORD *)v111 - 16) = v125;
                    }
                  }
                  v126 = (float)(v112 + v117) * 0.5;
                  if (this->var6)
                  {
                    v127 = v119;
                    v128 = v120;
                    v129 = v126;
                    v130 = (float)(v113 + v116) * 0.5;
                    Path::RecBezierTo(this, v112, v113, v114, v127, v128, v121, v126, v130, 8, (float)(v114 + v115) * 0.5, a2, v151);
                  }
                  else
                  {
                    v131 = v119;
                    v132 = v120;
                    v129 = v126;
                    v130 = (float)(v113 + v116) * 0.5;
                    Path::RecBezierTo(this, v112, v113, v131, v132, v126, v130, a2, 8, v151);
                  }
                  v106 = v153;
                  v59 = v123;
                  v58 = v122;
                  v20 = v149;
                  ++v107;
                  v111 += 11;
                  v110 = v114;
                  v109 = v113;
                  v108 = v112;
                }
                while (v52 - 1 != v107);
                if (this->var6)
                  v133 = Path::AddPoint(this, v129, v130, (float)(v114 + v153) * 0.5, 0);
                else
                  v133 = Path::AddPoint(this, v129, v130, 0);
                *((_DWORD *)v111 - 16) = v133;
                v7 = v144;
                v134 = v123;
                if (v133 < 0)
                {
                  if ((_DWORD)v19 == -1)
                    v135 = 0;
                  else
                    v135 = *((_DWORD *)v111 - 27);
                  *((_DWORD *)v111 - 16) = v135;
                }
                v136 = (float)(v123 - (float)(v123 - (float)(v145 * 2.0))) * 0.5;
                v137 = (float)(v122 - (float)(v122 - (float)(v149 * 2.0))) * 0.5;
                v14 = 2.0;
                if (this->var6)
                {
                  v21 = v143;
                  Path::RecBezierTo(this, v134, v122, v153, v129, v130, (float)(v114 + v153) * 0.5, v136, v137, 8, (float)(v153 - (float)(v153 - (float)(v143 * 2.0))) * 0.5, a2, v151);
                }
                else
                {
                  Path::RecBezierTo(this, v134, v122, v129, v130, v136, v137, a2, 8, v151);
                  v21 = v143;
                }
                v54 = v145;
              }
            }
            v18 = v54;
            if (this->var6)
              v138 = Path::AddPoint(this, v54, v20, v21, 0);
            else
              v138 = Path::AddPoint(this, v54, v20, 0);
            v11 = v148;
            v139 = (char *)v15 + 44 * (int)v19;
            *((_DWORD *)v139 + 1) = v138;
            v140 = v139 + 4;
            if (v138 < 0)
            {
              if ((_DWORD)v19 == -1)
                v141 = 0;
              else
                v141 = *(v16 - 10);
              *v140 = v141;
            }
            v13 = v52 + v55;
            v12 = v146;
            goto LABEL_114;
          case 4:
            v62 = (float *)((char *)v15 + 44 * v13);
            v64 = v62[4];
            v63 = (char *)(v62 + 4);
            v18 = v64;
            v21 = 1.0;
            if ((v17 & 0x10) != 0)
              v21 = *((float *)v63 + 6);
            v20 = *((float *)v63 + 1);
            v65 = *((float *)v63 + 2);
            v66 = *((float *)v63 + 3);
            v67 = *((float *)v63 + 4);
            v46 = (_DWORD *)((char *)v15 + 44 * v13 + 4);
            v68 = v63[21] != 0;
            v69 = v63[20] != 0;
            if (this->var6)
            {
              v70 = v11;
              Path::DoArc(this, v7, v11, v5, v18, v20, v21, v65, v66, v69, v68, v67, v142);
              v71 = Path::AddPoint(this, v18, v20, v21, 0);
            }
            else
            {
              v70 = v11;
              Path::DoArc(this, v7, v11, v18, v20, v65, v66, v67, v69, v68, v66);
LABEL_68:
              v71 = Path::AddPoint(this, v18, v20, 0);
            }
            v11 = v70;
            *v46 = v71;
            if ((v71 & 0x80000000) == 0)
              goto LABEL_113;
            if (v13)
LABEL_71:
              v49 = *(v16 - 10);
            else
LABEL_33:
              v49 = 0;
            *v46 = v49;
            goto LABEL_113;
          case 5:
            var11 = this->var11;
            if (!this->var6)
            {
              v98 = &var11[12 * (int)v12];
              v99 = *((float *)v98 + 1);
              v20 = *((float *)v98 + 2);
              v100 = sqrtf((float)((float)(v20 - v11) * (float)(v20 - v11)) + (float)((float)(v99 - v7)
                                                                                    * (float)(v99 - v7)));
              v86 = v11;
              v18 = v99;
              if (v100 > v151)
              {
                v101 = fmaxf(v151, v100 / 100.0);
                if (v101 < v100)
                {
                  v102 = v101;
                  do
                  {
                    Path::AddPoint(this, (float)((float)(v99 * v102) + (float)((float)(v100 - v102) * v7)) / v100, (float)((float)(v20 * v102) + (float)((float)(v100 - v102) * v86)) / v100, 0);
                    v99 = v18;
                    v102 = v101 + v102;
                  }
                  while (v102 < v100);
                }
              }
              v103 = Path::AddPoint(this, v99, v20, 0);
              v104 = (char *)v15 + 44 * v13;
              *((_DWORD *)v104 + 1) = v103;
              v105 = v104 + 4;
              v21 = 0.0;
              if (v103 < 0)
              {
                if (v13)
                  *v105 = *(v16 - 10);
                else
                  *v105 = 0;
              }
LABEL_112:
              v14 = 2.0;
              v11 = v86;
              goto LABEL_113;
            }
            v73 = (float *)&var11[16 * (int)v12];
            v74 = v73[1];
            v20 = v73[2];
            v75 = v11;
            v76 = v7;
            v77 = v73[3];
            v78 = sqrtf((float)((float)(v20 - v11) * (float)(v20 - v11)) + (float)((float)(v74 - v7) * (float)(v74 - v7)));
            if (v78 > v151)
            {
              v152 = fmaxf(v151, v78 / 100.0);
              if (v152 < v78)
              {
                v79 = v5;
                v80 = v152;
                do
                {
                  v81 = (float)((float)(v20 * v80) + (float)((float)(v78 - v80) * v75)) / v78;
                  v82 = v20;
                  v83 = v77;
                  v84 = v76;
                  v85 = v79;
                  Path::AddPoint(this, (float)((float)(v74 * v80) + (float)((float)(v78 - v80) * v76)) / v78, v81, (float)((float)(v77 * v80) + (float)((float)(v78 - v80) * v79)) / v78, 0);
                  v76 = v84;
                  v79 = v85;
                  v77 = v83;
                  v20 = v82;
                  v80 = v152 + v80;
                }
                while (v80 < v78);
              }
            }
            v86 = v75;
            v7 = v76;
            v18 = v74;
            v21 = v77;
            v87 = Path::AddPoint(this, v74, v20, v77, 0);
            v88 = (char *)v15 + 44 * v13;
            *((_DWORD *)v88 + 1) = v87;
            v89 = v88 + 4;
            if ((v87 & 0x80000000) == 0)
              goto LABEL_112;
            if (v13)
              *v89 = *(v16 - 10);
            else
              *v89 = 0;
            v11 = v86;
            v14 = 2.0;
            goto LABEL_113;
          case 6:
            goto LABEL_114;
          case 7:
            if (this->var6)
            {
              v90 = v11;
              Path::AddForcedPoint(this, v7, v11, v5);
            }
            else
            {
              *(float *)&v10 = v7;
              v90 = v11;
              Path::AddForcedPoint(this, v10, v11);
            }
            v11 = v90;
            *((_DWORD *)v15 + 11 * v13++ + 1) = v91;
            goto LABEL_82;
          default:
            v20 = 0.0;
LABEL_82:
            v21 = 0.0;
            goto LABEL_114;
        }
      }
    }
  }
}

float Path::PrevPoint(Path *this, unsigned int a2, float *a3, float *a4)
{
  float *v4;
  uint64_t v5;
  float result;

  if ((a2 & 0x80000000) == 0)
  {
    v4 = (float *)((char *)this->var3 + 44 * a2 + 24);
    v5 = a2 + 1;
    while ((*(_DWORD *)(v4 - 6) & 0xFu) - 5 < 3)
    {
      v4 -= 11;
      if (--v5 < 1)
        return result;
    }
    switch(*(_DWORD *)(v4 - 6) & 0xF)
    {
      case 0:
      case 1:
      case 2:
      case 4:
        *a3 = *(v4 - 2);
        --v4;
        goto LABEL_10;
      case 3:
        *a3 = *(v4 - 1);
LABEL_10:
        result = *v4;
        *a4 = *v4;
        break;
      default:
        return result;
    }
  }
  return result;
}

float Path::QuadraticPoint(Path *this, float a2, float *a3, float *a4, float a5, float a6, float a7, float a8, float a9, float a10)
{
  float result;

  *(float *)&this->var0 = (float)((float)((float)((float)(a5 * -2.0) + (float)(a7 * 2.0)) * a2)
                                + (float)((float)((float)((float)(a9 + (float)(a7 * -2.0)) + a5) * a2) * a2))
                        + a5;
  result = (float)((float)((float)((float)(a6 * -2.0) + (float)(a8 * 2.0)) * a2)
                 + (float)((float)((float)((float)(a10 + (float)(a8 * -2.0)) + a6) * a2) * a2))
         + a6;
  *a3 = result;
  return result;
}

float Path::CubicTangent(Path *this, float a2, float *a3, float *a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  float v12;
  float v13;
  float v14;
  float v15;
  float result;

  v12 = (float)((float)(a11 + (float)(a9 * -2.0)) + (float)(a5 * 2.0)) + a7;
  v13 = (float)((float)(a7 * -2.0) - (float)(a11 - (float)(a9 * 3.0))) + (float)(a5 * -3.0);
  v14 = (float)((float)(a12 + (float)(a10 * -2.0)) + (float)(a6 * 2.0)) + a8;
  v15 = (float)((float)(a8 * -2.0) - (float)(a12 - (float)(a10 * 3.0))) + (float)(a6 * -3.0);
  *(float *)&this->var0 = (float)((float)((float)(v13 + v13) * a2) + (float)((float)((float)(v12 * 3.0) * a2) * a2))
                        + a7;
  result = (float)((float)((float)(v15 + v15) * a2) + (float)((float)((float)(v14 * 3.0) * a2) * a2)) + a8;
  *a3 = result;
  return result;
}

void Path::ArcAngles(Path *this, float a2, float a3, float a4, float a5, float a6, float a7, float a8, int a9, float *a10, float *a11, float *a12)
{
  int v15;
  float v18;
  float v19;
  __float2 v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  double v37;
  float v38;
  double v39;
  float v40;

  v15 = (int)this;
  v18 = a4 - a2;
  v19 = a5 - a3;
  v20 = __sincosf_stret(a8);
  v21 = (float)((float)(v19 * v20.__sinval) + (float)(v20.__cosval * v18)) / a6;
  v22 = (float)((float)(v19 * v20.__cosval) - (float)(v20.__sinval * v18)) / a7;
  v23 = (float)(v22 * v22) + (float)(v21 * v21);
  v24 = (float)(v23 * -0.25) + 1.0;
  v25 = 0.0;
  if (v24 < 0.0)
    v24 = 0.0;
  v26 = sqrtf(v24);
  v27 = sqrtf(v23);
  v28 = (float)-v21 / v27;
  v29 = (float)(v22 / v27) * v26;
  v30 = v21 * 0.5;
  v31 = (float)-v29 - (float)(v21 * 0.5);
  v32 = v22 * 0.5;
  if (v31 >= -1.0)
  {
    if (v31 <= 1.0)
    {
      v33 = acosf(v31);
      *a10 = v33;
      if ((float)((float)-(float)(v28 * v26) - v32) >= 0.0)
        goto LABEL_9;
      v25 = 6.28318531 - v33;
    }
  }
  else
  {
    v25 = 3.1416;
  }
  *a10 = v25;
LABEL_9:
  if ((float)(v30 - v29) >= -1.0)
  {
    v34 = 0.0;
    if ((float)(v30 - v29) <= 1.0)
    {
      v34 = acosf(v30 - v29);
      *a11 = v34;
      if ((float)(v32 - (float)(v28 * v26)) >= 0.0)
        goto LABEL_15;
      v34 = 6.28318531 - v34;
    }
  }
  else
  {
    v34 = 3.1416;
  }
  *a11 = v34;
LABEL_15:
  if (a9)
  {
    if (!v15)
      return;
  }
  else if ((v15 & 1) != 0)
  {
    return;
  }
  *a11 = *a10;
  *a10 = v34;
  v35 = *a11 + 3.14159265;
  *a11 = v35;
  v36 = *a10 + 3.14159265;
  *a10 = v36;
  v37 = *a11;
  if (v37 >= 6.28318531)
  {
    v38 = v37 + -6.28318531;
    *a11 = v38;
    v36 = *a10;
  }
  v39 = v36;
  if (v39 >= 6.28318531)
  {
    v40 = v39 + -6.28318531;
    *a10 = v40;
  }
}

void Path::Fill(Path *this, void **a2, int a3, char a4, int a5, char a6)
{
  int v11;
  int var8;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  unsigned int v25;
  _DWORD *v26;
  _DWORD *v27;
  int v28;
  float v29;
  char *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  char *var11;
  char *v43;
  unsigned int v44;
  char *v45;
  char *v46;
  int v47;
  char *v48;
  unsigned int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  BOOL v56;
  int v57;
  uint64_t v58;
  char *v59;
  char *v60;
  char *v61;
  unsigned int v62;
  char *v63;
  char *v64;
  int v65;
  int v66;
  int v67;
  char *v68;
  char *v69;
  uint64_t v70;
  int v71;
  unsigned int v72;
  unsigned int v73;
  int v74;
  Shape *v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  BOOL v81;
  int v82;
  int v83;
  uint64_t v84;
  char *v85;
  char *v86;
  unsigned int v87;
  char *v88;
  unsigned int v89;
  int v90;
  int v91;

  if (!a2)
    return;
  if ((a4 & 1) == 0)
    Shape::Reset(a2, this->var8);
  if (this->var8 < 2)
    return;
  v11 = *((_DWORD *)a2 + 4);
  if (this->var7)
    Shape::MakeBackData((Shape *)a2, 1);
  if ((a6 & 1) != 0)
    return;
  var8 = this->var8;
  v91 = a5;
  if (!this->var7)
  {
    if (this->var6)
    {
      if (var8 >= 1)
      {
        v33 = 0;
        v34 = 0;
        do
        {
          Shape::AddPoint((Shape *)a2, *(float *)&this->var11[v33 + 4], *(float *)&this->var11[v33 + 8]);
          ++v34;
          v35 = this->var8;
          v33 += 16;
        }
        while (v34 < v35);
        if ((int)v35 >= 2)
        {
          v36 = 0;
          v37 = 0;
          v38 = 0;
          v39 = 0;
          v40 = -1;
          v41 = 1;
          while (1)
          {
            var11 = this->var11;
            v43 = &var11[v36];
            if (*(_DWORD *)&var11[v36 + 16] == 1)
            {
              if ((v91 & 1) != 0)
              {
                v44 = v39 + v11;
                if (v37 && v40 >= 0)
                {
                  Shape::DisconnectEnd((uint64_t)a2, v40);
                  Shape::ConnectEnd((uint64_t)a2, v44, v40);
                }
                else
                {
                  Shape::AddEdge((Shape *)a2, v38 + v11, v44);
                }
              }
              v37 = 0;
              v40 = -1;
              v39 = v41;
            }
            else
            {
              v45 = &var11[16 * v38];
              if (vabds_f32(*((float *)v43 + 5), *((float *)v45 + 1)) < 0.00001
                && vabds_f32(*(float *)&var11[v36 + 24], *((float *)v45 + 2)) < 0.00001)
              {
                goto LABEL_58;
              }
              v46 = &var11[16 * v39];
              v40 = Shape::AddEdge((Shape *)a2, v38 + v11, v11 + (int)v41);
              v37 = vabds_f32(*((float *)v43 + 5), *((float *)v46 + 1)) < 0.00001
                 && vabds_f32(*(float *)&var11[v36 + 24], *((float *)v46 + 2)) < 0.00001;
            }
            v38 = v41;
LABEL_58:
            ++v41;
            v36 += 16;
            if (v41 >= this->var8)
              goto LABEL_93;
          }
        }
      }
      v39 = 0;
      v38 = 0;
      v37 = 0;
      v40 = -1;
LABEL_93:
      if (!v91)
        return;
      v72 = v39 + v11;
      if (!v37 || v40 < 0)
      {
        v73 = v38 + v11;
LABEL_129:
        Shape::AddEdge((Shape *)a2, v73, v72);
        return;
      }
      goto LABEL_123;
    }
    if (var8 < 1)
      goto LABEL_120;
    v77 = 0;
    v78 = 0;
    do
    {
      Shape::AddPoint((Shape *)a2, *(float *)&this->var11[v77 + 4], *(float *)&this->var11[v77 + 8]);
      ++v78;
      v79 = this->var8;
      v77 += 12;
    }
    while (v78 < v79);
    if ((int)v79 < 2)
    {
LABEL_120:
      v83 = 0;
      v82 = 0;
      v81 = 0;
      v40 = -1;
LABEL_121:
      if (!v91)
        return;
      v72 = v83 + v11;
      if (!v81 || v40 < 0)
      {
        v73 = v82 + v11;
        goto LABEL_129;
      }
LABEL_123:
      Shape::DisconnectEnd((uint64_t)a2, v40);
      v75 = (Shape *)a2;
      v74 = v72;
      v76 = v40;
      goto LABEL_124;
    }
    v80 = 0;
    v81 = 0;
    v82 = 0;
    v83 = 0;
    v40 = -1;
    v84 = 1;
    while (1)
    {
      v85 = this->var11;
      v86 = &v85[v80];
      if (*(_DWORD *)&v85[v80 + 12] == 1)
      {
        if ((v91 & 1) != 0)
        {
          v87 = v83 + v11;
          if (v81 && v40 >= 0)
          {
            Shape::DisconnectEnd((uint64_t)a2, v40);
            Shape::ConnectEnd((uint64_t)a2, v87, v40);
          }
          else
          {
            Shape::AddEdge((Shape *)a2, v82 + v11, v87);
          }
        }
        v81 = 0;
        v40 = -1;
        v83 = v84;
      }
      else
      {
        if (vabds_f32(*((float *)v86 + 4), *(float *)&v85[12 * v82 + 4]) < 0.00001
          && vabds_f32(*(float *)&v85[v80 + 20], *(float *)&v85[12 * v82 + 8]) < 0.00001)
        {
          goto LABEL_118;
        }
        v40 = Shape::AddEdge((Shape *)a2, v82 + v11, v11 + (int)v84);
        v81 = vabds_f32(*((float *)v86 + 4), *(float *)&v85[12 * v83 + 4]) < 0.00001
           && vabds_f32(*(float *)&v85[v80 + 20], *(float *)&v85[12 * v83 + 8]) < 0.00001;
      }
      v82 = v84;
LABEL_118:
      ++v84;
      v80 += 12;
      if (v84 >= this->var8)
        goto LABEL_121;
    }
  }
  v90 = a3;
  if (this->var6)
  {
    if (var8 >= 1)
    {
      v13 = 0;
      v14 = 0;
      do
      {
        Shape::AddPoint((Shape *)a2, *(float *)&this->var11[v13 + 4], *(float *)&this->var11[v13 + 8]);
        ++v14;
        v15 = this->var8;
        v13 += 24;
      }
      while (v14 < v15);
      if ((int)v15 >= 2)
      {
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v19 = 0;
        v20 = -1;
        v21 = 1;
        while (1)
        {
          v22 = this->var11;
          v23 = &v22[v16];
          if (*(_DWORD *)&v22[v16 + 24] != 1)
            break;
          if ((v91 & 1) == 0)
          {
            v17 = 0;
            goto LABEL_26;
          }
          if (v17 && v20 >= 0)
          {
            Shape::DisconnectEnd((uint64_t)a2, v20);
            Shape::ConnectEnd((uint64_t)a2, v19 + v11, v20);
          }
          else
          {
            Shape::AddEdge((Shape *)a2, v18 + v11, v19 + v11);
            if ((v20 & 0x80000000) == 0)
            {
              v17 = 0;
              v31 = (uint64_t)a2[12] + 16 * v20;
              v32 = *(_DWORD *)&v22[24 * v19 + 16];
              *(_DWORD *)v31 = v90;
              *(_DWORD *)(v31 + 4) = v32;
              *(_QWORD *)(v31 + 8) = 0x3F80000000000000;
LABEL_26:
              v20 = -1;
              v19 = v21;
LABEL_35:
              v18 = v21;
              goto LABEL_36;
            }
          }
          v17 = 0;
          v20 = -1;
          v19 = v21;
          v18 = v21;
LABEL_36:
          ++v21;
          v16 += 24;
          if (v21 >= this->var8)
            goto LABEL_61;
        }
        v24 = &v22[24 * v18];
        if (vabds_f32(*((float *)v23 + 7), *((float *)v24 + 1)) < 0.00001
          && vabds_f32(*(float *)&v22[v16 + 32], *((float *)v24 + 2)) < 0.00001)
        {
          goto LABEL_36;
        }
        v25 = Shape::AddEdge((Shape *)a2, v18 + v11, v11 + (int)v21);
        v20 = v25;
        if ((v25 & 0x80000000) == 0)
        {
          v26 = a2[12];
          v27 = &v26[4 * v25];
          v28 = *(_DWORD *)&v22[v16 + 40];
          *v27 = v90;
          v27[1] = v28;
          if (v28 == *(_DWORD *)&v22[24 * v18 + 16])
          {
            v26[4 * v25 + 2] = *(_DWORD *)&v22[24 * v18 + 20];
            v29 = *(float *)&v22[v16 + 44];
          }
          else
          {
            v26[4 * v25 + 2] = 0;
            v29 = 1.0;
          }
          *(float *)&v26[4 * v25 + 3] = v29;
        }
        v30 = &v22[24 * v19];
        v17 = vabds_f32(*((float *)v23 + 7), *((float *)v30 + 1)) < 0.00001
           && vabds_f32(*(float *)&v22[v16 + 32], *((float *)v30 + 2)) < 0.00001;
        goto LABEL_35;
      }
    }
    v19 = 0;
    v18 = 0;
    v17 = 0;
    v20 = -1;
LABEL_61:
    v47 = v90;
    if (v91)
    {
      if (!v17 || v20 < 0)
      {
        v48 = this->var11;
        v49 = Shape::AddEdge((Shape *)a2, v18 + v11, v19 + v11);
        if ((v49 & 0x80000000) != 0)
          return;
        v50 = (uint64_t)a2[12] + 16 * v49;
        v51 = *(_DWORD *)&v48[24 * v19 + 16];
        goto LABEL_127;
      }
LABEL_99:
      Shape::DisconnectEnd((uint64_t)a2, v20);
      v74 = v19 + v11;
      v75 = (Shape *)a2;
      v76 = v20;
LABEL_124:
      Shape::ConnectEnd((uint64_t)v75, v74, v76);
      return;
    }
    return;
  }
  if (var8 >= 1)
  {
    v52 = 0;
    v53 = 0;
    do
    {
      Shape::AddPoint((Shape *)a2, *(float *)&this->var11[v52 + 4], *(float *)&this->var11[v52 + 8]);
      ++v53;
      v54 = this->var8;
      v52 += 20;
    }
    while (v53 < v54);
    if ((int)v54 >= 2)
    {
      v55 = 0;
      v56 = 0;
      v57 = 0;
      v19 = 0;
      v20 = -1;
      v58 = 1;
      while (1)
      {
        v59 = this->var11;
        v60 = &v59[v55];
        if (*(_DWORD *)&v59[v55 + 20] != 1)
        {
          v61 = &v59[20 * v57];
          if (vabds_f32(*((float *)v60 + 6), *((float *)v61 + 1)) < 0.00001
            && vabds_f32(*(float *)&v59[v55 + 28], *((float *)v61 + 2)) < 0.00001)
          {
            goto LABEL_87;
          }
          v62 = Shape::AddEdge((Shape *)a2, v57 + v11, v11 + (int)v58);
          v20 = v62;
          if ((v62 & 0x80000000) == 0)
          {
            v63 = (char *)a2[12];
            v64 = &v63[16 * v62];
            v65 = *(_DWORD *)&v59[v55 + 32];
            *(_DWORD *)v64 = v90;
            *((_DWORD *)v64 + 1) = v65;
            v66 = 0;
            if (v65 == *(_DWORD *)&v59[20 * v57 + 12])
              v66 = *(_DWORD *)&v59[20 * v57 + 16];
            v67 = *(_DWORD *)&v59[v55 + 36];
            v68 = &v63[16 * v62];
            *((_DWORD *)v68 + 2) = v66;
            *((_DWORD *)v68 + 3) = v67;
          }
          v69 = &v59[20 * v19];
          v56 = vabds_f32(*((float *)v60 + 6), *((float *)v69 + 1)) < 0.00001
             && vabds_f32(*(float *)&v59[v55 + 28], *((float *)v69 + 2)) < 0.00001;
          goto LABEL_86;
        }
        if ((v91 & 1) != 0)
        {
          if (!v56 || v20 < 0)
          {
            Shape::AddEdge((Shape *)a2, v57 + v11, v19 + v11);
            v56 = 0;
            if (v20 < 0)
            {
              v20 = -1;
              v19 = v58;
              v57 = v58;
              goto LABEL_87;
            }
            v70 = (uint64_t)a2[12] + 16 * v20;
            v71 = *(_DWORD *)&v59[20 * v19 + 12];
            *(_DWORD *)v70 = v90;
            *(_DWORD *)(v70 + 4) = v71;
            *(_QWORD *)(v70 + 8) = 0x3F80000000000000;
            goto LABEL_75;
          }
          Shape::DisconnectEnd((uint64_t)a2, v20);
          Shape::ConnectEnd((uint64_t)a2, v19 + v11, v20);
        }
        v56 = 0;
LABEL_75:
        v20 = -1;
        v19 = v58;
LABEL_86:
        v57 = v58;
LABEL_87:
        ++v58;
        v55 += 20;
        if (v58 >= this->var8)
          goto LABEL_97;
      }
    }
  }
  v19 = 0;
  v57 = 0;
  v56 = 0;
  v20 = -1;
LABEL_97:
  v47 = v90;
  if (v91)
  {
    if (!v56 || v20 < 0)
    {
      v88 = this->var11;
      v89 = Shape::AddEdge((Shape *)a2, v57 + v11, v19 + v11);
      if ((v89 & 0x80000000) != 0)
        return;
      v50 = (uint64_t)a2[12] + 16 * v89;
      v51 = *(_DWORD *)&v88[20 * v19 + 12];
LABEL_127:
      *(_DWORD *)v50 = v47;
      *(_DWORD *)(v50 + 4) = v51;
      *(_QWORD *)(v50 + 8) = 0x3F80000000000000;
      return;
    }
    goto LABEL_99;
  }
}

uint64_t directionForVector(CGPoint a1)
{
  CGFloat x;
  CGFloat y;
  void *v6;
  uint64_t v7;

  x = a1.x;
  if (a1.x == 0.0 && a1.y == -1.0)
    return 0;
  y = a1.y;
  if (a1.x == 1.0 && a1.y == -1.0)
    return 1;
  if (a1.x == 1.0 && a1.y == 0.0)
    return 2;
  if (a1.x == 1.0 && a1.y == 1.0)
    return 3;
  if (a1.x == 0.0 && a1.y == 1.0)
    return 4;
  if (a1.x == -1.0 && a1.y == 1.0)
    return 5;
  if (a1.x == -1.0 && a1.y == 0.0)
    return 6;
  if (a1.x == -1.0 && a1.y == -1.0)
    return 7;
  v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSDDirection directionForVector(CGPoint)");
  objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDImageTracer.mm"), 81, CFSTR("can't find direction for invalid vector (%f, %f)"), *(_QWORD *)&x, *(_QWORD *)&y);
  return 8;
}

__n128 nextPivotAndBlackVectors(CGPoint a1, CGPoint a2, CGPoint *a3, CGPoint *a4)
{
  double v4;
  double v5;
  void *v10;
  uint64_t v11;
  __n128 result;
  __int128 *v13;

  v4 = a2.x - a1.x;
  v5 = a2.y - a1.y;
  if (v4 == -0.5 && v5 == -0.5)
  {
  }
  else if (v4 == 0.5 && v5 == -0.5)
  {
  }
  else if (v4 == 0.5 && v5 == 0.5)
  {
  }
  else
  {
    if (v4 != -0.5 || v5 != 0.5)
    {
      v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler", v5);
      v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void nextPivotAndBlackVectors(CGPoint, CGPoint, CGPoint &, CGPoint &)");
      objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDImageTracer.mm"), 124, CFSTR("unexpected pivot and black points while tracing"));
      return result;
    }
  }
  result = (__n128)*v13;
  *a4 = (CGPoint)*v13;
  return result;
}

void buildSimplifiedPathFromPoints(void *a1, __int128 **a2, double a3)
{
  __int128 *v5;
  __int128 *v6;
  unint64_t v7;
  double v8;
  double v9;
  double v10;
  CGFloat v11;
  unint64_t v12;
  CGFloat *v13;
  double *v15;
  uint64_t v16;
  __int128 v17;
  double *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  __int128 *v22;
  double *v23;
  double v24;
  double v25;
  double *v26;
  unint64_t v27;
  double *v28;
  double v29;
  double v30;
  double v31;
  double *v32;
  unint64_t v33;
  double v34;
  double v35;
  float v36;
  _BOOL4 v37;
  __int128 *v38;
  __int128 v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  char *v43;
  __int128 v44;
  double *v45;
  double *v46;
  __int128 v47;
  double *v48;
  uint64_t v49;
  unint64_t v50;
  double v51;
  double v52;
  void *v54;
  uint64_t v55;
  unint64_t v56;
  void *v57;
  char *v59;
  double *__p;
  double *v61;
  char *v62;

  v6 = *a2;
  v5 = a2[1];
  v7 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)*a2) >> 3);
  if (v7 > 0x31)
    goto LABEL_12;
  v8 = *(double *)(MEMORY[0x24BDBF070] + 16);
  v9 = *(double *)(MEMORY[0x24BDBF070] + 24);
  if (v5 != v6)
  {
    v10 = *MEMORY[0x24BDBF070];
    v11 = *(double *)(MEMORY[0x24BDBF070] + 8);
    if (v7 <= 1)
      v12 = 1;
    else
      v12 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)v6) >> 3);
    v13 = (CGFloat *)v6 + 1;
    do
    {
      v10 = TSDGrowRectToPoint(v10, v11, v8, v9, *(v13 - 1), *v13);
      v13 += 3;
      --v12;
    }
    while (v12);
  }
  if (v8 >= 5.0 && v9 >= 5.0)
  {
LABEL_12:
    v62 = 0;
    v15 = (double *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)&v62, 1uLL);
    v57 = a1;
    v17 = *v6;
    v15[2] = *((double *)v6 + 2);
    *(_OWORD *)v15 = v17;
    v18 = v15 + 3;
    __p = v15;
    v62 = (char *)&v15[3 * v16];
    v61 = v15 + 3;
    if (v7 != 1)
    {
      v19 = 0;
      do
      {
        v59 = (char *)v18;
        v20 = v19;
        v21 = v19 + 1;
        v22 = *a2;
        if (v19 + 1 < v7)
        {
          v23 = (double *)v22 + 3 * v19;
          v24 = *v23;
          v25 = v23[1];
          v26 = v23 + 4;
          v27 = v19 + 1;
          do
          {
            v19 = v27++;
            if (v20 >= v19)
            {
              v37 = 1;
            }
            else
            {
              v28 = (double *)v22 + 3 * v27;
              v30 = *v28;
              v29 = v28[1];
              v31 = *v28 - v24;
              v32 = v26;
              v33 = v21;
              do
              {
                v34 = (v29 - v25) * (*(v32 - 1) - v24);
                v35 = v31 * (*v32 - v25);
                if (v34 == v35)
                {
                  v37 = 1;
                }
                else
                {
                  v36 = vabdd_f64(v34, v35) / TSDDistance(v30, v29, v24, v25);
                  v37 = v36 <= a3;
                }
                if (v33 >= v19)
                  break;
                ++v33;
                v32 += 3;
              }
              while (v37);
            }
          }
          while (v27 < v7 && v37);
        }
        v38 = (__int128 *)((char *)v22 + 24 * v19);
        if (v59 >= v62)
        {
          v40 = 0xAAAAAAAAAAAAAAABLL * ((v59 - (char *)__p) >> 3) + 1;
          if (v40 > 0xAAAAAAAAAAAAAAALL)
            abort();
          if (0x5555555555555556 * ((v62 - (char *)__p) >> 3) > v40)
            v40 = 0x5555555555555556 * ((v62 - (char *)__p) >> 3);
          if (0xAAAAAAAAAAAAAAABLL * ((v62 - (char *)__p) >> 3) >= 0x555555555555555)
            v41 = 0xAAAAAAAAAAAAAAALL;
          else
            v41 = v40;
          if (v41)
            v42 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)&v62, v41);
          else
            v42 = 0;
          v43 = &v42[8 * ((v59 - (char *)__p) >> 3)];
          v44 = *v38;
          *((_QWORD *)v43 + 2) = *((_QWORD *)v38 + 2);
          *(_OWORD *)v43 = v44;
          v45 = v61;
          v46 = (double *)v43;
          if (v61 != __p)
          {
            do
            {
              v47 = *(_OWORD *)(v45 - 3);
              *(v46 - 1) = *(v45 - 1);
              *(_OWORD *)(v46 - 3) = v47;
              v46 -= 3;
              v45 -= 3;
            }
            while (v45 != __p);
            v45 = __p;
          }
          v18 = (double *)(v43 + 24);
          __p = v46;
          v62 = &v42[24 * v41];
          if (v45)
            operator delete(v45);
        }
        else
        {
          v39 = *v38;
          *((_QWORD *)v59 + 2) = *((_QWORD *)v38 + 2);
          *(_OWORD *)v59 = v39;
          v18 = (double *)(v59 + 24);
        }
        v61 = v18;
      }
      while (v19 < v7 - 1);
    }
    v48 = __p;
    v49 = (char *)v18 - (char *)__p;
    v50 = 0xAAAAAAAAAAAAAAABLL * (v18 - __p);
    if (v50 >= 3)
    {
      v51 = *__p;
      v52 = __p[1];
      if (v49 == 72 && v51 == __p[6] && v52 == __p[7])
      {
LABEL_54:
        operator delete(v48);
        return;
      }
      v54 = v57;
      objc_msgSend(v57, "moveToPoint:", v51, v52, v57);
      v55 = 0;
      v56 = v50 - 1;
      do
      {
        objc_msgSend(v54, "lineToPoint:", __p[v55 + 3], __p[v55 + 4]);
        v55 += 3;
        --v56;
      }
      while (v56);
      objc_msgSend(v54, "closePath");
      v48 = __p;
    }
    if (!v48)
      return;
    goto LABEL_54;
  }
}

void sub_217A20E10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_217A21494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,char a31,_QWORD *a32)
{
  if (__p)
    operator delete(__p);
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy((uint64_t)&a31, a32);
  _Unwind_Resume(a1);
}

void sub_217A21AD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,char a23,_QWORD *a24)
{
  if (__p)
    operator delete(__p);
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy((uint64_t)&a23, a24);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<CGPoint>::__emplace_unique_key_args<CGPoint,CGPoint>(uint64_t **a1, double *a2, _OWORD *a3)
{
  void **v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t v9;

  v5 = (void **)std::__tree<CGPoint>::__find_equal<CGPoint>((uint64_t)a1, &v9, a2);
  v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v6 + 2) = *a3;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

_QWORD *std::__tree<CGPoint>::__find_equal<CGPoint>(uint64_t a1, _QWORD *a2, double *a3)
{
  _QWORD *result;
  uint64_t *v4;
  uint64_t *v5;
  double v6;
  double v7;
  _QWORD *v8;
  double v9;
  double v10;

  v5 = *(uint64_t **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    v7 = *a3;
    v6 = a3[1];
    while (1)
    {
      while (1)
      {
        v8 = v4;
        v9 = *((double *)v4 + 5);
        if (v6 >= v9)
          break;
LABEL_6:
        v4 = (uint64_t *)*v4;
        result = v8;
        if (!*v8)
          goto LABEL_18;
      }
      if (v6 == v9)
      {
        v10 = *((double *)v4 + 4);
        if (v7 < v10)
          goto LABEL_6;
        if (v9 >= v6 && v10 >= v7)
          goto LABEL_18;
      }
      else if (v9 >= v6)
      {
        goto LABEL_18;
      }
      result = v4 + 1;
      v4 = (uint64_t *)v4[1];
      if (!v4)
        goto LABEL_18;
    }
  }
  v8 = result;
LABEL_18:
  *a2 = v8;
  return result;
}

uint64_t std::__tree<CGPoint>::__erase_unique<CGPoint>(uint64_t **a1, double *a2)
{
  uint64_t *v3;
  uint64_t *v4;

  v3 = (uint64_t *)std::__tree<CGPoint>::find<CGPoint>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  v4 = v3;
  std::__tree<std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,EQKit::Config::Operator::Form>>>::__remove_node_pointer(a1, v3);
  operator delete(v4);
  return 1;
}

double *std::__tree<CGPoint>::find<CGPoint>(uint64_t a1, double *a2)
{
  double *v2;
  double *v3;
  double *v4;
  double v5;
  double v6;
  double *v7;
  double v8;
  double v9;

  v4 = *(double **)(a1 + 8);
  v2 = (double *)(a1 + 8);
  v3 = v4;
  if (!v4)
    return v2;
  v5 = *a2;
  v6 = a2[1];
  v7 = v2;
  do
  {
    v8 = v3[5];
    if (v8 >= v6)
    {
      if (v8 == v6)
      {
        if (v3[4] < v5)
          ++v3;
        else
          v7 = v3;
      }
      else
      {
        v7 = v3;
      }
    }
    else
    {
      ++v3;
    }
    v3 = *(double **)v3;
  }
  while (v3);
  if (v7 == v2)
    return v2;
  v9 = v7[5];
  if (v6 < v9 || v6 == v9 && v5 < v7[4])
    return v2;
  return v7;
}

BOOL TSDMetalPixelFormatIsWideGamut(uint64_t a1)
{
  return a1 == 115 || a1 == 552;
}

uint64_t TSDMetalBytesPerRowFromPixelFormatAndWidth(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  char v3;

  v2 = a1 == 552 || a1 == 115;
  v3 = 2;
  if (v2)
    v3 = 3;
  return a2 << v3;
}

double TSDUnpackPackedFloat16FromUint64(int a1)
{
  return *(float *)&a1;
}

float32x2_t TSDMetalColor4fWithUIntAndFormat(unint64_t a1, uint64_t a2)
{
  float32x2_t result;

  if (a2 == 552)
  {
    return vcvt_f32_f64(vmlaq_f64((float64x2_t)vdupq_n_s64(0xBFE81817B95A2941), (float64x2_t)vdupq_n_s64(0x3F600811FE510404uLL), vcvtq_f64_u64((uint64x2_t)vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)vdupq_n_s64(a1), (uint64x2_t)xmmword_217C299E0), (int8x16_t)vdupq_n_s64(0x3FFuLL)))));
  }
  else
  {
    result.i32[0] = (unsigned __int16)a1;
    if (a2 != 115)
      result.f32[0] = 0.0;
  }
  return result;
}

float TSDMetalColor4fWithUIntAndFormatOnlyAlpha()
{
  return 0.0;
}

float TSDMetalColor4fWith32BitUIntAndFormat(int a1, uint64_t a2)
{
  unsigned __int8 v2;

  if (a2 == 70)
    v2 = a1;
  else
    v2 = BYTE2(a1);
  return (double)v2 * 0.00390640259;
}

unint64_t *TSDMetalThreadgroupSizeToCoverRect@<X0>(unint64_t *result@<X0>, double *a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, unint64_t *a5@<X8>, double a6@<D2>, double a7@<D3>)
{
  double v7;
  double v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  BOOL v17;
  unint64_t v18;

  if (a6 == 0.0 || a7 == 0.0)
  {
    *a5 = 0;
    a5[1] = 0;
    a5[2] = 0;
  }
  else
  {
    if (a4)
      v7 = a6;
    else
      v7 = a7;
    if (a4)
      v8 = a7;
    else
      v8 = a6;
    v9 = (unint64_t)v7;
    v10 = 1;
    if ((unint64_t)v8 > a3)
    {
      v11 = (unint64_t)v8;
      do
      {
        v11 >>= 1;
        v10 *= 2;
      }
      while (v11 > a3);
    }
    v12 = (unint64_t)v8 / v10;
    v13 = a3 / v12;
    if (v12 < a3 / v12)
      v13 = (unint64_t)v8 / v10;
    if (v13 <= 1)
      v13 = 1;
    v14 = (v9 + v13 - 1) / v13;
    v15 = 1;
    if (v14 >= 0x29)
    {
      v16 = (v9 + v13 - 1) / v13;
      do
      {
        v14 = v16 >> 1;
        v15 *= 2;
        v17 = v16 > 0x51;
        v16 >>= 1;
      }
      while (v17);
    }
    v18 = v15 * v14 * (v13 - 1);
    while (v18 > v9)
    {
      v18 -= v15 * v14;
      --v13;
    }
    *result = v14;
    if (a4)
    {
      *a2 = (double)v15;
      a2[1] = (double)v10;
      *a5 = v13;
      a5[1] = v12;
    }
    else
    {
      *a2 = (double)v10;
      a2[1] = (double)v15;
      *a5 = v12;
      a5[1] = v13;
    }
    a5[2] = 1;
  }
  return result;
}

id TSDMetalDevice()
{
  if (TSDMetalDevice_s_onceToken != -1)
    dispatch_once(&TSDMetalDevice_s_onceToken, &__block_literal_global_34);
  return (id)TSDMetalDevice_s_metalDevice;
}

id TSDMetalDevicePreferringLowPower()
{
  if (TSDMetalDevicePreferringLowPower_s_onceToken != -1)
    dispatch_once(&TSDMetalDevicePreferringLowPower_s_onceToken, &__block_literal_global_9);
  return (id)TSDMetalDevicePreferringLowPower_s_metalDevice;
}

CGImageRef TSDMetalCreateCGImageFromTexture(void *a1)
{
  id v1;
  size_t v2;
  uint64_t v3;
  size_t v4;
  void *v5;
  size_t v6;
  CGBitmapInfo v7;
  CGDataProvider *v8;
  CGColorSpace *DeviceRGB;
  CGImageRef v10;
  _QWORD v12[6];

  v1 = a1;
  if (objc_msgSend(v1, "pixelFormat") == 110
    || objc_msgSend(v1, "pixelFormat") == 112
    || objc_msgSend(v1, "pixelFormat") == 113
    || objc_msgSend(v1, "pixelFormat") == 114)
  {
    v2 = 16;
  }
  else if (objc_msgSend(v1, "pixelFormat") == 115)
  {
    v2 = 16;
  }
  else
  {
    v2 = 8;
  }
  v3 = objc_msgSend(v1, "height");
  v4 = (v2 >> 1) * v3 * objc_msgSend(v1, "width");
  v5 = malloc_type_malloc(v4, 0x91277B6CuLL);
  v6 = objc_msgSend(v1, "width") * (v2 >> 1);
  memset(v12, 0, 24);
  v12[3] = objc_msgSend(v1, "width");
  v12[4] = objc_msgSend(v1, "height");
  v12[5] = 1;
  objc_msgSend(v1, "getBytes:bytesPerRow:fromRegion:mipmapLevel:", v5, v6, v12, 0);
  if (objc_msgSend(v1, "pixelFormat") == 80
    || objc_msgSend(v1, "pixelFormat") == 81
    || objc_msgSend(v1, "pixelFormat") == 552
    || objc_msgSend(v1, "pixelFormat") == 553)
  {
    v7 = 8194;
  }
  else
  {
    v7 = 16385;
  }
  v8 = CGDataProviderCreateWithData(0, v5, v4, (CGDataProviderReleaseDataCallback)p_freeImageData);
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  v10 = CGImageCreate(objc_msgSend(v1, "width"), objc_msgSend(v1, "height"), v2, 4 * v2, v6, DeviceRGB, v7, v8, 0, 0, kCGRenderingIntentDefault);
  CGDataProviderRelease(v8);
  CGColorSpaceRelease(DeviceRGB);

  return v10;
}

void p_freeImageData(int a1, void *a2)
{
  free(a2);
}

id TSDMetalCommandQueueForRenderingDrawables(void *a1)
{
  id v1;
  NSObject *v2;
  id v3;
  id v4;
  _QWORD v6[4];
  id v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, uint64_t);
  void (*v13)(uint64_t);
  id v14;

  v1 = a1;
  if (TSDMetalCommandQueueForRenderingDrawables_sOnceToken != -1)
    dispatch_once(&TSDMetalCommandQueueForRenderingDrawables_sOnceToken, &__block_literal_global_10);
  v9 = 0;
  v10 = &v9;
  v11 = 0x3032000000;
  v12 = __Block_byref_object_copy__13;
  v13 = __Block_byref_object_dispose__13;
  v14 = 0;
  v2 = TSDMetalCommandQueueForRenderingDrawables_sCommandQueueAcessingQueue;
  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 3221225472;
  v6[2] = __TSDMetalCommandQueueForRenderingDrawables_block_invoke_13;
  v6[3] = &unk_24D82BE60;
  v7 = v1;
  v8 = &v9;
  v3 = v1;
  dispatch_sync(v2, v6);
  v4 = (id)v10[5];

  _Block_object_dispose(&v9, 8);
  return v4;
}

uint64_t __Block_byref_object_copy__13(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__13(uint64_t a1)
{

}

Path *Path::Outline(Path *this, Path *a2, int a3, int a4, float a5, float a6)
{
  Path *v10;
  path_descr *var3;
  int var2;
  Path *v13;
  Path *v14;
  int v15;
  int v16;
  unsigned __int32 v17;
  float v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  signed int v35;
  Path *v36;
  uint64_t v37;
  __n128 v38;
  double v39;
  double v40;
  double v41;
  __n128 v42;
  int v43;
  signed int v44;
  float *v45;
  signed int v46;
  int v47;
  uint64_t v48;
  char *v49;
  signed int v50;
  int v51;
  Path *v52;
  signed int v53;
  uint64_t v54;
  float *v55;
  __n128 v56;
  uint64_t v57;
  double v58;
  double v59;
  double v60;
  __n128 v61;
  __n128 v62;
  uint64_t v63;
  double v64;
  double v65;
  double v66;
  __n128 v67;
  uint64_t v68;
  float v69;
  uint64_t v70;
  __n128 v71;
  double v72;
  double v73;
  double v74;
  __n128 v75;
  float32x2_t v76;
  float v77;
  Path *v78;
  float v79;
  float v80;
  float32x2_t v81;
  uint64_t v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  Path *v88;
  float v89;
  float v90;
  unsigned __int32 v91;
  float v92;
  float v93;
  float v94;
  int v95;
  float v96;
  float v97;
  int v98;
  int v99;
  path_descr *v100;
  int v102;
  int v103;
  Path *v104;
  Path *v105;
  int v106;
  unsigned __int32 v107;
  uint64_t v108;
  uint64_t v109;
  float32x2_t v110;
  uint64_t v111;
  _QWORD v112[4];

  v10 = this;
  if ((this->var0 & 1) == 0)
  {
    if ((this->var0 & 2) == 0)
      goto LABEL_3;
LABEL_6:
    this = Path::CloseSubpath(v10, 0);
    if (!a2)
      return this;
    goto LABEL_7;
  }
  this = Path::CancelBezier(this);
  if ((v10->var0 & 2) != 0)
    goto LABEL_6;
LABEL_3:
  if (a2)
  {
LABEL_7:
    if (v10->var2 < 2)
      return this;
    Path::Reset(a2);
    Path::SetWeighted(a2, 0);
    Path::SetBackData(a2, 0);
    v112[0] = Path::StdCubicTo;
    v112[1] = Path::StdBezierTo;
    v112[2] = Path::StdArcTo;
    var3 = v10->var3;
    var2 = v10->var2;
    v13 = (Path *)operator new();
    Path::Path(v13);
    v105 = v14;
    Path::SetWeighted(v14, 0);
    v15 = var2;
    v16 = 0;
    *(float *)&v17 = a5 * 0.0025 * a5;
    v96 = -a5;
    v18 = a5 * 1.0001;
    v97 = v18;
    v19 = var2;
    v20 = (char *)var3 - 44;
    v104 = v10;
    v98 = a4;
    v99 = var2;
    v100 = (path_descr *)a2;
    while (1)
    {
      v21 = 0;
      v22 = v16;
      v23 = v16;
      v24 = v16 + 1;
      v25 = 44 * v16;
      if (v15 <= v16 + 1)
        ++v16;
      else
        v16 = v15;
      v26 = v25 + 44;
      v27 = v23 + 1;
      while (1)
      {
        v28 = v27 + v21;
        if (v27 + v21 >= v19)
          break;
        ++v21;
        v29 = *((_BYTE *)var3 + v26);
        v26 += 44;
        if ((v29 & 0xF) == 0)
        {
          v16 = v22 + v21;
          break;
        }
      }
      if (v16 >= v15)
        v30 = v15;
      else
        v30 = v16;
      if (v30 <= v24)
        goto LABEL_68;
      v108 = 0;
      v109 = 0;
      v31 = *((_DWORD *)var3 + 11 * v30 - 11) & 0xF;
      v32 = v30;
      v33 = 44 * v30 - 44;
      while ((*(_DWORD *)((char *)var3 + v33) & 0xF) == 5)
      {
        v34 = v32 - 2;
        --v32;
        v33 -= 44;
        if (v34 <= v23)
          goto LABEL_68;
      }
      v102 = v31;
      v103 = v16;
      v35 = v32 - 1;
      v10->var3 = var3;
      v10->var2 = v15;
      v106 = v22;
      Path::PrevPoint(v10, v32 - 1, (float *)&v109 + 1, (float *)&v109);
      v36 = v105;
      Path::Reset(v105);
      Path::MoveTo(v105, *((float *)&v109 + 1), *(float *)&v109);
      v43 = v106;
      if (v106 < (int)v32 - 1)
      {
        do
        {
          v44 = v35;
          switch(*((_DWORD *)var3 + 11 * v35) & 0xF)
          {
            case 1:
            case 3:
              Path::PrevPoint(v10, --v35, (float *)&v108 + 1, (float *)&v108);
              Path::LineTo(v36, *((float *)&v108 + 1), *(float *)&v108);
              goto LABEL_30;
            case 2:
              Path::PrevPoint(v10, --v35, (float *)&v108 + 1, (float *)&v108);
              Path::CubicTo(v36, *((float *)&v108 + 1), *(float *)&v108, -*((float *)var3 + 11 * v44 + 8), -*((float *)var3 + 11 * v44 + 9), -*((float *)var3 + 11 * v44 + 6), -*((float *)var3 + 11 * v44 + 7));
              goto LABEL_30;
            case 4:
              Path::PrevPoint(v10, --v35, (float *)&v108 + 1, (float *)&v108);
              v45 = (float *)((char *)var3 + 44 * v44);
              Path::ArcTo(v36, *((float *)&v108 + 1), *(float *)&v108, v45[6], v45[7], v45[8], *((_BYTE *)v45 + 36), *((_BYTE *)v45 + 37) == 0);
LABEL_30:
              v43 = v106;
              v109 = v108;
              continue;
            case 6:
              v46 = v35 - 1;
              if ((int)v23 < v35 - 1)
                v46 = v23;
              v47 = v46 + 1;
              v48 = v35 - 1;
              v49 = &v20[44 * v35];
              v50 = v35;
              break;
            default:
              --v35;
              continue;
          }
          while (v48 > v23)
          {
            v51 = *(_DWORD *)v49;
            v49 -= 44;
            --v50;
            --v48;
            if ((v51 & 0xF) == 3)
            {
              v47 = v50 + 1;
              goto LABEL_38;
            }
          }
          v50 = v46;
LABEL_38:
          if ((*((_DWORD *)var3 + 11 * v50) & 0xF) == 3)
          {
            v52 = v10;
            v53 = v47 - 2;
            Path::PrevPoint(v52, v47 - 2, (float *)&v108 + 1, (float *)&v108);
            Path::BezierTo(v105, *((float *)&v108 + 1), *(float *)&v108);
            if (v35 >= v47)
            {
              v54 = v35 + 1;
              v55 = (float *)((char *)var3 + 44 * v35 + 20);
              do
              {
                Path::IntermBezierTo(v105, *(v55 - 1), *v55);
                --v54;
                v55 -= 11;
              }
              while (v54 > v47);
            }
            Path::EndBezierTo(v105);
            v36 = v105;
            v20 = (char *)var3 - 44;
          }
          else
          {
            Path::PrevPoint(v10, v50, (float *)&v108 + 1, (float *)&v108);
            Path::LineTo(v105, *((float *)&v108 + 1), *(float *)&v108);
            v53 = v47 - 2;
            v36 = v105;
          }
          v109 = v108;
          v35 = v53;
          v10 = v104;
          v43 = v106;
        }
        while (v35 > v43);
      }
      if (v102 != 5)
        break;
      Path::Close(v36);
      v56.n128_u32[0] = v17;
      Path::SubContractOutline((uint64_t)v36, v100, (uint64_t)v112, a3, v56, a5, a6, v58, v59, v60, v61, v57, 1, 0, &v110, &v111);
      v10->var3 = (path_descr *)((char *)var3 + 44 * (int)v23);
      v10->var2 = v32 - v23 + 1;
      v62.n128_u32[0] = v17;
      Path::SubContractOutline((uint64_t)v10, v100, (uint64_t)v112, a3, v62, a5, a6, v64, v65, v66, v67, v63, 1, 0, &v110, &v111);
LABEL_67:
      v15 = v99;
      v16 = v103;
LABEL_68:
      if (v28 >= v19)
      {
        v95 = v15;
        Path::~Path(v105);
        this = (Path *)MEMORY[0x219A153B8]();
        v10->var3 = var3;
        v10->var2 = v95;
        return this;
      }
    }
    v38.n128_u32[0] = v17;
    Path::SubContractOutline((uint64_t)v36, v100, (uint64_t)v112, a3, v38, a5, a6, v39, v40, v41, v42, v37, 0, 0, &v110, &v111);
    v68 = v111;
    v69 = -*(float *)&v111;
    switch(v98)
    {
      case 2:
        Path::ArcTo((Path *)v100, v110.f32[0] + (float)(a5 * *((float *)&v111 + 1)), v110.f32[1] + (float)(a5 * v69), v97, v97, 0.0, 1, 1);
        goto LABEL_57;
      case 3:
        v81 = v110;
        Path::LineTo((Path *)v100, v110.f32[0] + (float)(a5 * *(float *)&v111), v110.f32[1] + (float)(a5 * *((float *)&v111 + 1)));
        v79 = v81.f32[0] + (float)(a5 * *((float *)&v68 + 1));
        v80 = v81.f32[1] + (float)(a5 * v69);
        break;
      case 1:
        v76 = v110;
        Path::LineTo((Path *)v100, (float)(v110.f32[0] + (float)(v96 * *((float *)&v111 + 1))) + (float)(a5 * *(float *)&v111), (float)(v110.f32[1] + (float)(a5 * *(float *)&v111)) + (float)(a5 * *((float *)&v111 + 1)));
        v77 = v76.f32[1] + (float)(a5 * v69);
        Path::LineTo((Path *)v100, (float)(v76.f32[0] + (float)(a5 * *((float *)&v68 + 1))) + (float)(a5 * *(float *)&v68), v77 + (float)(a5 * *((float *)&v68 + 1)));
        v78 = (Path *)v100;
        v79 = v76.f32[0] + (float)(a5 * *((float *)&v68 + 1));
        v80 = v77;
LABEL_56:
        Path::LineTo(v78, v79, v80);
LABEL_57:
        v10->var3 = (path_descr *)((char *)var3 + 44 * (int)v23);
        v10->var2 = v32 - v106;
        v71.n128_u32[0] = v17;
        Path::SubContractOutline((uint64_t)v10, v100, (uint64_t)v112, a3, v71, a5, a6, v72, v73, v74, v75, v70, 0, 1, &v110, &v111);
        v82 = v111;
        v83 = -*(float *)&v111;
        switch(v98)
        {
          case 2:
            Path::ArcTo((Path *)v100, v110.f32[0] + (float)(a5 * *((float *)&v111 + 1)), v110.f32[1] + (float)(a5 * v83), v97, v97, 0.0, 1, 1);
LABEL_66:
            Path::Close((Path *)v100);
            goto LABEL_67;
          case 3:
            v91 = v17;
            v92 = a6;
            v94 = v110.f32[1];
            v93 = v110.f32[0];
            Path::LineTo((Path *)v100, v110.f32[0] + (float)(a5 * *(float *)&v111), v110.f32[1] + (float)(a5 * *((float *)&v111 + 1)));
            v89 = v93 + (float)(a5 * *((float *)&v82 + 1));
            a6 = v92;
            v17 = v91;
            v90 = v94 + (float)(a5 * v83);
            break;
          case 1:
            v107 = v17;
            v84 = a6;
            v85 = v110.f32[1];
            v86 = v110.f32[0];
            Path::LineTo((Path *)v100, (float)(v110.f32[0] + (float)(v96 * *((float *)&v111 + 1))) + (float)(a5 * *(float *)&v111), (float)(v110.f32[1] + (float)(a5 * *(float *)&v111)) + (float)(a5 * *((float *)&v111 + 1)));
            v87 = v85 + (float)(a5 * v83);
            a6 = v84;
            v17 = v107;
            Path::LineTo((Path *)v100, (float)(v86 + (float)(a5 * *((float *)&v82 + 1))) + (float)(a5 * *(float *)&v82), v87 + (float)(a5 * *((float *)&v82 + 1)));
            v88 = (Path *)v100;
            v89 = v86 + (float)(a5 * *((float *)&v82 + 1));
            v90 = v87;
LABEL_65:
            Path::LineTo(v88, v89, v90);
            goto LABEL_66;
          default:
            v89 = v110.f32[0] + (float)(a5 * *((float *)&v111 + 1));
            v90 = v110.f32[1] + (float)(a5 * v83);
            break;
        }
        v88 = (Path *)v100;
        goto LABEL_65;
      default:
        v79 = v110.f32[0] + (float)(a5 * *((float *)&v111 + 1));
        v80 = v110.f32[1] + (float)(a5 * v69);
        break;
    }
    v78 = (Path *)v100;
    goto LABEL_56;
  }
  return this;
}

uint64_t Path::StdCubicTo(__int128 *a1, float a2, double a3)
{
  return Path::RecStdCubicTo(a1, 8, a2, a3);
}

uint64_t Path::StdBezierTo(uint64_t a1, float a2, float32_t a3)
{
  float32x2_t v6;
  __int32 v7;
  float32_t v8;
  float32x2_t v9;
  int32x4_t v10;
  float32x4_t v11;
  uint64_t v13;
  float v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  int v21;
  uint64_t v22;

  v21 = 1;
  v6 = *(float32x2_t *)(a1 + 48);
  v22 = *(_QWORD *)(a1 + 40);
  v20 = v6;
  v13 = 0;
  v7 = *(_DWORD *)(a1 + 32);
  v8 = *(float *)(a1 + 36);
  v6.i32[0] = v7;
  Path::TangentOnBezAt(&v20, (uint64_t)&v21, 0, &v19, (uint64_t)&v17, (float *)&v13 + 1, &v15, 0.0, v6, v8);
  v9.i32[0] = v7;
  Path::TangentOnBezAt(&v20, (uint64_t)&v21, 1, &v18, (uint64_t)&v16, (float *)&v13, &v14, 1.0, v9, v8);
  v10.i64[0] = __PAIR64__(v13, HIDWORD(v13));
  v11.i64[0] = v17;
  v11.i64[1] = v16;
  *(float32x4_t *)(a1 + 48) = vmulq_f32((float32x4_t)vzip1q_s32(v10, v10), v11);
  v11.f32[0] = a3;
  return Path::RecStdCubicTo((__int128 *)a1, 8, a2, *(double *)v11.i64);
}

void Path::StdArcTo(uint64_t a1, float a2, float a3)
{
  *(_QWORD *)(a1 + 64) = 0x3F80000000000000;
  Path::RecStdArcTo((__int128 *)a1, 8, a2, a3);
}

uint64_t Path::SubContractOutline(uint64_t result, path_descr *a2, uint64_t a3, int a4, __n128 a5, float a6, float a7, double a8, double a9, double a10, __n128 a11, uint64_t a12, int a13, int a14, float32x2_t *a15, _QWORD *a16)
{
  int v18;
  Path *v19;
  uint64_t v20;
  uint64_t v21;
  float v22;
  __int32 v23;
  int v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  char v29;
  float v30;
  float v31;
  float v32;
  uint64_t v33;
  float v34;
  float v35;
  float v36;
  uint64_t v37;
  float32x2_t *v38;
  float32x2_t *v39;
  float32x2_t v40;
  float32x2_t v41;
  float v42;
  float v43;
  float v44;
  float v45;
  uint64_t *v46;
  uint64_t (**v47)(uint64_t *, float, float);
  unsigned __int32 v48;
  float v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  int v53;
  float32x2_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float *v71;
  int v72;
  float32x2_t *v73;
  int v74;
  float32x2_t *v75;
  float32x2_t *v76;
  float32x2_t v77;
  float32x2_t v78;
  int v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  uint64_t v85;
  float v86;
  float v87;
  float v88;
  uint64_t *v89;
  uint64_t v90;
  unsigned __int32 v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float *v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float *v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float v114;
  int v115;
  int v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float *v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  float v132;
  float v133;
  float v134;
  __n128 v135;
  float v136;
  float v137;
  float v138;
  float v139;
  float v140;
  float v141;
  uint64_t v142;
  float v143;
  float v144;
  float v145;
  float v146;
  uint64_t *v147;
  uint64_t v148;
  __int128 v149;
  float32x2_t v150;
  float v151;
  _QWORD *v152;
  float32x2_t v153;
  unsigned int v154;
  float32_t v155;
  unsigned int v156;
  __int128 v157;
  float v158;
  __int128 v159;
  float v160;
  float v161;
  int v164;
  int v165;
  int v166;
  float v167;
  float32x2_t v171;
  float v172;
  float v173;
  int v174;
  float v175;
  float32x2_t v176;
  __n128 v177;
  __n128 v178;
  __n128 v179;
  __n128 v180;
  __n128 v181;
  float32x2_t v182;
  float32x2_t v183;
  float v184;
  unsigned __int32 v185;
  float32x2_t v186;
  float32x2_t v187;
  float32x2_t v188;
  int v189;
  float32x2_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  float v194;
  float v195;
  float32x2_t v196;
  unint64_t v197;
  uint64_t v198;
  int v199;
  uint64_t v200;
  path_descr *v201;
  unint64_t v202;
  __int128 v203;
  __int32 v204;
  __int32 v205;

  v167 = a5.n128_f32[0];
  v198 = result;
  v201 = a2;
  if (*(int *)(result + 8) >= 2)
  {
    v18 = a4;
    v19 = (Path *)a2;
    v20 = result;
    v21 = *(_QWORD *)(result + 16);
    v23 = *(_DWORD *)(v21 + 16);
    v22 = *(float *)(v21 + 20);
    v166 = a13 ^ 1;
    a5.n128_u32[1] = 1058682594;
    v24 = 1;
    v25 = 0.0;
    v26 = 0.0;
    v27 = 0.0;
    v171.i32[0] = 0;
    v175 = 0.0;
    v184 = 0.0;
    v174 = 1;
    while (1)
    {
      v28 = *(_QWORD *)(v20 + 16);
      result = v28 + 44 * v24;
      v29 = *(_DWORD *)result;
      v191 = 0;
      v192 = 0;
      v30 = 0.0;
      v31 = 0.0;
      v32 = 0.0;
      a11.n128_u32[0] = 0;
      switch(v29 & 0xF)
      {
        case 0:
          v33 = v28 + 44 * v24;
          a11.n128_u32[0] = *(_DWORD *)(v33 + 16);
          v32 = *(float *)(v33 + 20);
          if (((v174 | v166) & 1) == 0)
          {
            v177 = a11;
            if (vabds_f32(*(float *)&v23, v171.f32[0]) >= 0.0001 || vabds_f32(v22, v27) >= 0.0001)
            {
              v92 = v171.f32[0] - *(float *)&v23;
              v93 = v27 - v22;
              v94 = sqrtf((float)(v93 * v93) + (float)(v92 * v92));
              if (v94 <= 0.000001)
              {
                v196.f32[1] = v22;
                v95 = 0.0;
                LODWORD(v96) = v23;
                v97 = v22;
                v94 = 0.0;
                v98 = *(float *)&v23;
                v99 = 0.0;
                v100 = (float *)&v193 + 1;
              }
              else
              {
                v31 = v92 / v94;
                v95 = v93 / v94;
                v96 = (float)(v171.f32[0] * 0.0) + *(float *)&v23;
                v97 = (float)(v27 * 0.0) + v22;
                *((float *)&v193 + 1) = v95;
                v98 = v171.f32[0] + (float)(*(float *)&v23 * 0.0);
                v99 = v27 + (float)(v22 * 0.0);
                v100 = (float *)&v196 + 1;
              }
              v172 = v98;
              v194 = v31;
              v195 = v95;
              v197 = __PAIR64__(LODWORD(v97), LODWORD(v96));
              *(float *)&v191 = v94;
              *((float *)&v191 + 1) = v94;
              *(float *)&v193 = v31;
              v196.f32[0] = v98;
              *v100 = v99;
              v126 = -v95;
              v127 = *((float *)&v193 + 1);
              v30 = -*((float *)&v193 + 1);
              v128 = *(float *)&v23;
              v129 = v22;
              v35 = a7;
              v36 = a6;
              Path::OutlineJoin(v19, v18, v128, v129, v26, v25, v126, v31, a6, a7);
              v130 = v172 - (float)(a6 * v127);
              v27 = v196.f32[1];
              Path::LineTo(v19, v130, v196.f32[1] + (float)(a6 * v31));
              v34 = v172;
              v26 = v30;
              v25 = v31;
            }
            else
            {
              v34 = v171.f32[0];
              v35 = a7;
              v36 = a6;
            }
            Path::OutlineJoin(v19, v18, v34, v27, v26, v25, v184, v175, v36, v35);
            result = Path::Close(v19);
            a11 = v177;
          }
          ++v24;
          v171.i32[0] = a11.n128_u32[0];
          v27 = v32;
          goto LABEL_90;
        case 1:
          v37 = v28 + 44 * v24;
          a5.n128_u32[0] = *(_DWORD *)(v37 + 16);
          v32 = *(float *)(v37 + 20);
          v178 = a5;
          result = Path::IsNulCurve((Path *)result, a2, *(float *)&v23, v22);
          if ((_DWORD)result)
          {
            ++v24;
            v30 = v26;
            v31 = v25;
            v32 = v22;
            a11.n128_u32[0] = v23;
          }
          else
          {
            v62 = v178.n128_f32[0] - *(float *)&v23;
            v63 = v32 - v22;
            v64 = sqrtf((float)(v63 * v63) + (float)(v62 * v62));
            v65 = v178.n128_f32[0];
            v173 = v27;
            if (v64 <= 0.000001)
            {
              v196.f32[1] = v22;
              v66 = 0.0;
              LODWORD(v67) = v23;
              v68 = v22;
              v64 = 0.0;
              v69 = *(float *)&v23;
              v70 = 0.0;
              v71 = (float *)&v193 + 1;
            }
            else
            {
              v31 = v62 / v64;
              v66 = v63 / v64;
              v67 = *(float *)&v23 + (float)(v178.n128_f32[0] * 0.0);
              v68 = v22 + (float)(v32 * 0.0);
              *((float *)&v193 + 1) = v63 / v64;
              v69 = v178.n128_f32[0] + (float)(*(float *)&v23 * 0.0);
              v70 = v32 + (float)(v22 * 0.0);
              v71 = (float *)&v196 + 1;
            }
            v194 = v31;
            v195 = v66;
            v197 = __PAIR64__(LODWORD(v68), LODWORD(v67));
            *(float *)&v191 = v64;
            *((float *)&v191 + 1) = v64;
            *(float *)&v193 = v31;
            v196.f32[0] = v69;
            *v71 = v70;
            v109 = -v66;
            v110 = *((float *)&v193 + 1);
            *a15 = v196;
            *a16 = v193;
            if ((v174 & 1) != 0)
            {
              if ((a14 & 1) != 0)
              {
                a14 = 0;
                v184 = -v66;
                v175 = v31;
                v171.f32[0] = v67;
                v27 = v68;
                v111 = a6;
              }
              else
              {
                v111 = a6;
                v139 = v110;
                v140 = v22 + (float)(a6 * v31);
                v141 = v67;
                Path::MoveTo(v19, *(float *)&v23 + (float)(a6 * v109), v140);
                v110 = v139;
                v65 = v178.n128_f32[0];
                a14 = 0;
                v184 = v109;
                v175 = v31;
                v171.f32[0] = v141;
                v27 = v68;
              }
            }
            else
            {
              v113 = v110;
              v114 = v26;
              v111 = a6;
              Path::OutlineJoin(v19, v18, *(float *)&v23, v22, v114, v25, v109, v31, a6, a7);
              v110 = v113;
              v65 = v178.n128_f32[0];
              v27 = v173;
            }
            v30 = -v110;
            result = Path::LineTo(v19, v65 + (float)(v111 * (float)-v110), v32 + (float)(v111 * v31));
            if ((result & 0x80000000) == 0)
            {
              v142 = (uint64_t)v19->var3 + 44 * result;
              *(_DWORD *)(v142 + 4) = v24;
              a5.n128_u32[1] = 1065353216;
              *(_QWORD *)(v142 + 8) = 0x3F80000000000000;
            }
            v174 = 0;
            ++v24;
            a11 = v178;
          }
          goto LABEL_90;
        case 2:
          v38 = (float32x2_t *)(v28 + 44 * v24);
          a5.n128_u32[0] = v38[2].u32[0];
          v32 = v38[2].f32[1];
          v39 = v38 + 2;
          v179 = a5;
          result = Path::IsNulCurve((Path *)result, a2, *(float *)&v23, v22);
          if ((_DWORD)result)
            goto LABEL_17;
          v171.f32[1] = v27;
          v40.i32[0] = v23;
          Path::TangentOnCubAt(v39, 0, (float32x2_t *)&v197, (uint64_t)&v194, (float *)&v191 + 1, (float *)&v192 + 1, 0.0, v40, v22);
          v41.i32[0] = v23;
          Path::TangentOnCubAt(v39, 1, &v196, (uint64_t)&v193, (float *)&v191, (float *)&v192, 1.0, v41, v22);
          v42 = v194;
          v43 = -v195;
          v44 = *((float *)&v193 + 1);
          v31 = *(float *)&v193;
          *a15 = v196;
          *a16 = v193;
          if ((v174 & 1) != 0)
          {
            v171 = (float32x2_t)v197;
            if ((a14 & 1) != 0)
            {
              a14 = 0;
              v45 = a6;
              v46 = &qword_217C29000;
              v47 = (uint64_t (**)(uint64_t *, float, float))a3;
              v48 = v179.n128_u32[0];
              v49 = v42;
LABEL_63:
              v30 = -v44;
              v199 = v24;
              v200 = v46[283];
              v202 = __PAIR64__(LODWORD(v22), v23);
              *(_QWORD *)&v203 = __PAIR64__(LODWORD(v32), v48);
              *((float32x2_t *)&v203 + 1) = v39[1];
              v204 = v39[2].i32[0];
              v205 = v39[2].i32[1];
              result = (*v47)(&v198, v167, v45);
              goto LABEL_67;
            }
            v45 = a6;
            v49 = v42;
            Path::MoveTo(v19, *(float *)&v23 + (float)(a6 * v43), v22 + (float)(a6 * v42));
            a14 = 0;
          }
          else
          {
            v108 = v26;
            v45 = a6;
            Path::OutlineJoin(v19, v18, *(float *)&v23, v22, v108, v25, v43, v42, a6, a7);
            v43 = v184;
            v49 = v175;
          }
          v46 = &qword_217C29000;
          v47 = (uint64_t (**)(uint64_t *, float, float))a3;
          v48 = v179.n128_u32[0];
          goto LABEL_63;
        case 3:
          v50 = v28 + 44 * v24;
          v53 = *(_DWORD *)(v50 + 16);
          v52 = v50 + 16;
          v51 = v53;
          a5.n128_u64[0] = *(_QWORD *)(v52 + 4);
          v180 = a5;
          result = Path::IsNulCurve((Path *)result, a2, *(float *)&v23, v22);
          v55 = v24 + 1;
          if ((_DWORD)result)
          {
            v24 = v55 + v51;
            v30 = v26;
            v31 = v25;
            v32 = v22;
            a11.n128_u32[0] = v23;
            goto LABEL_90;
          }
          v72 = v51;
          if (v51 <= 0)
          {
            v115 = v24 + 1;
            v116 = v72;
            v171.f32[1] = v27;
            v117 = v180.n128_f32[0];
            v118 = v180.n128_f32[0] - *(float *)&v23;
            v119 = v180.n128_f32[1] - v22;
            v120 = sqrtf((float)(v119 * v119) + (float)(v118 * v118));
            if (v120 <= 0.000001)
            {
              v196.f32[1] = v22;
              v121 = 0.0;
              LODWORD(v122) = v23;
              v27 = v22;
              v120 = 0.0;
              v123 = *(float *)&v23;
              v124 = 0.0;
              v125 = (float *)&v193 + 1;
            }
            else
            {
              v31 = v118 / v120;
              v121 = v119 / v120;
              v122 = *(float *)&v23 + (float)(v180.n128_f32[0] * 0.0);
              v27 = v22 + (float)(v180.n128_f32[1] * 0.0);
              *((float *)&v193 + 1) = v119 / v120;
              v123 = v180.n128_f32[0] + (float)(*(float *)&v23 * 0.0);
              v124 = v180.n128_f32[1] + (float)(v22 * 0.0);
              v125 = (float *)&v196 + 1;
            }
            v194 = v31;
            v195 = v121;
            v197 = __PAIR64__(LODWORD(v27), LODWORD(v122));
            *(float *)&v191 = v120;
            *((float *)&v191 + 1) = v120;
            *(float *)&v193 = v31;
            v196.f32[0] = v123;
            *v125 = v124;
            v143 = -v121;
            v144 = *((float *)&v193 + 1);
            *a15 = v196;
            *a16 = v193;
            if ((v174 & 1) != 0)
            {
              v185 = LODWORD(v122);
              if ((a14 & 1) != 0)
              {
                a14 = 0;
                v175 = v31;
                v145 = a6;
                v83 = -v121;
              }
              else
              {
                v145 = a6;
                v83 = -v121;
                Path::MoveTo(v19, *(float *)&v23 + (float)(a6 * v143), v22 + (float)(a6 * v31));
                v117 = v180.n128_f32[0];
                a14 = 0;
                v175 = v31;
              }
            }
            else if (v120 <= 0.0)
            {
              v83 = v184;
              v27 = v171.f32[1];
              v185 = v171.i32[0];
              v145 = a6;
            }
            else
            {
              v146 = v26;
              v145 = a6;
              Path::OutlineJoin(v19, v18, *(float *)&v23, v22, v146, v25, v143, v31, a6, a7);
              v117 = v180.n128_f32[0];
              v83 = v184;
              v27 = v171.f32[1];
              v185 = v171.i32[0];
            }
            v30 = -v144;
            result = Path::LineTo(v19, v117 + (float)(v145 * v30), v180.n128_f32[1] + (float)(v145 * v31));
            if ((result & 0x80000000) == 0)
            {
              v148 = (uint64_t)v19->var3 + 44 * result;
              *(_DWORD *)(v148 + 4) = v24;
              a5.n128_u32[1] = 1065353216;
              *(_QWORD *)(v148 + 8) = 0x3F80000000000000;
            }
            a11 = v180;
            a5.n128_u32[0] = v185;
            goto LABEL_89;
          }
          v164 = a14;
          v165 = v51;
          v73 = a15;
          v74 = v24 + 1;
          v75 = (float32x2_t *)(v28 + 44 * v55);
          v77 = v75[2];
          v76 = v75 + 2;
          v182 = v77;
          v54.i32[0] = v23;
          Path::TangentOnBezAt(v76, v52, 0, (float32x2_t *)&v197, (uint64_t)&v194, (float *)&v191 + 1, (float *)&v192 + 1, 0.0, v54, v22);
          v79 = v165 - 1;
          if (v165 == 1)
          {
            v78.i32[0] = v23;
            Path::TangentOnBezAt(v76, v52, 1, &v196, (uint64_t)&v193, (float *)&v191, (float *)&v192, 1.0, v78, v22);
            v80 = v194;
            v81 = -v195;
            v82 = *((float *)&v193 + 1);
            v31 = *(float *)&v193;
            a15 = v73;
            *v73 = v196;
            *a16 = v193;
            if ((v174 & 1) != 0)
            {
              v83 = v81;
              v171 = (float32x2_t)v197;
              if ((a14 & 1) != 0)
              {
                a14 = 0;
                v18 = a4;
                v84 = a6;
                v85 = a3;
                v19 = (Path *)a2;
              }
              else
              {
                v84 = a6;
                v19 = (Path *)a2;
                Path::MoveTo((Path *)a2, *(float *)&v23 + (float)(a6 * v81), v22 + (float)(a6 * v80));
                a14 = 0;
                v18 = a4;
                v85 = a3;
              }
              v147 = &qword_217C29000;
            }
            else
            {
              v171.f32[1] = v27;
              v19 = (Path *)a2;
              v84 = a6;
              v18 = a4;
              Path::OutlineJoin((Path *)a2, a4, *(float *)&v23, v22, v26, v25, v81, v80, a6, a7);
              v83 = v184;
              v80 = v175;
              v85 = a3;
              v147 = &qword_217C29000;
            }
            v30 = -v82;
            v199 = v24 + 1;
            v200 = v147[283];
            v202 = __PAIR64__(LODWORD(v22), v23);
            *(_QWORD *)&v149 = v180.n128_u64[0];
            *((float32x2_t *)&v149 + 1) = v182;
            v203 = v149;
            result = (*(uint64_t (**)(uint64_t *, float, float))(v85 + 8))(&v198, v167, v84);
            a11 = v180;
            v175 = v80;
            v27 = v171.f32[1];
            a5.n128_u32[0] = v171.i32[0];
            v116 = 1;
            v115 = v24 + 1;
LABEL_89:
            v174 = 0;
            v24 = v116 + v115;
            v32 = a11.n128_f32[1];
            v184 = v83;
            v171.i32[0] = a5.n128_u32[0];
            goto LABEL_90;
          }
          if (*((float *)&v191 + 1) <= 0.0)
          {
            v171.f32[1] = v27;
            v160 = v175;
            v161 = v184;
            v137 = a6;
LABEL_93:
            v138 = v167;
            goto LABEL_94;
          }
          v136 = -v195;
          if ((v174 & 1) == 0)
          {
            v171.f32[1] = v27;
            v137 = a6;
            Path::OutlineJoin((Path *)a2, a4, *(float *)&v23, v22, v194, v195, v136, v194, a6, a7);
            v174 = 0;
            v161 = v184;
            v160 = v175;
            goto LABEL_93;
          }
          v171 = (float32x2_t)v197;
          v137 = a6;
          v138 = v167;
          v160 = v194;
          v161 = -v195;
          if ((a14 & 1) == 0)
            Path::MoveTo((Path *)a2, *(float *)&v23 + (float)(a6 * v136), v22 + (float)(a6 * v194));
          v174 = 0;
          v164 = 0;
LABEL_94:
          v150 = v182;
          v78.f32[0] = -(float)(v182.f32[0] - (float)(*(float *)&v23 * 2.0));
          v151 = -(float)(v182.f32[1] - (float)(v22 * 2.0));
          v152 = (_QWORD *)(v28 + 44 * (v24 + 1) + 60);
          do
          {
            v153 = *(float32x2_t *)v152;
            v152 = (_QWORD *)((char *)v152 + 44);
            v183 = v153;
            v186 = v150;
            v155 = v150.f32[1];
            *(float *)&v156 = (float)(v151 + v150.f32[1]) * 0.5;
            v189 = 1;
            v176 = vmul_f32(vadd_f32(v150, v153), (float32x2_t)0x3F0000003F000000);
            v190 = v176;
            v188 = v150;
            v78.f32[0] = (float)(v78.f32[0] + v150.f32[0]) * 0.5;
            v154 = v78.u32[0];
            Path::TangentOnBezAt(&v188, (uint64_t)&v189, 1, &v196, (uint64_t)&v193, (float *)&v191, (float *)&v192, 1.0, v78, *(float32_t *)&v156);
            *v73 = v196;
            *a16 = v193;
            v199 = v74;
            v200 = 0x3F80000000000000;
            v202 = __PAIR64__(v156, v154);
            *(float32x2_t *)&v157 = v176;
            *((float32x2_t *)&v157 + 1) = v186;
            v203 = v157;
            (*(void (**)(uint64_t *, float, float))(a3 + 8))(&v198, v138, v137);
            v150 = v153;
            v78 = v186;
            ++v74;
            v151 = v155;
            --v79;
          }
          while (v79);
          v189 = 1;
          v187 = vmul_f32(vadd_f32(v183, vmla_f32(vneg_f32(v183), (float32x2_t)0x4000000040000000, (float32x2_t)v180.n128_u64[0])), (float32x2_t)0x3F0000003F000000);
          v190 = v187;
          v188 = v183;
          Path::TangentOnBezAt(&v188, (uint64_t)&v189, 1, &v196, (uint64_t)&v193, (float *)&v191, (float *)&v192, 1.0, v176, v176.f32[1]);
          v30 = -*((float *)&v193 + 1);
          v158 = v138;
          v31 = *(float *)&v193;
          *v73 = v196;
          *a16 = v193;
          v199 = v165 + v24;
          v200 = 0x3F80000000000000;
          v202 = (unint64_t)v176;
          *(float32x2_t *)&v159 = v187;
          *((float32x2_t *)&v159 + 1) = v183;
          v203 = v159;
          result = (*(uint64_t (**)(uint64_t *, float, float))(a3 + 8))(&v198, v158, v137);
          a11 = v180;
          v19 = (Path *)a2;
          v24 += v165 + 1;
          v32 = v180.n128_f32[1];
          v184 = v161;
          v175 = v160;
          a14 = v164;
          a15 = v73;
          v18 = a4;
LABEL_68:
          v27 = v171.f32[1];
LABEL_90:
          v23 = a11.n128_u32[0];
          v22 = v32;
          v25 = v31;
          v26 = v30;
          if (v24 >= *(_DWORD *)(v20 + 8))
            return result;
          break;
        case 4:
          v56 = v28 + 44 * v24;
          a5.n128_u32[0] = *(_DWORD *)(v56 + 16);
          v32 = *(float *)(v56 + 20);
          v57 = v56 + 16;
          v179 = a5;
          result = Path::IsNulCurve((Path *)result, a2, *(float *)&v23, v22);
          if ((_DWORD)result)
          {
LABEL_17:
            ++v24;
            v30 = v26;
            v31 = v25;
            v32 = v22;
            a11.n128_u32[0] = v23;
            goto LABEL_90;
          }
          v171.f32[1] = v27;
          Path::TangentOnArcAt(v57, (float *)&v197, (uint64_t)&v194, (float *)&v191 + 1, (float *)&v192 + 1, 0.0, *(float *)&v23, v22);
          Path::TangentOnArcAt(v57, (float *)&v196, (uint64_t)&v193, (float *)&v191, (float *)&v192, 1.0, *(float *)&v23, v22);
          v86 = v194;
          v43 = -v195;
          v87 = *((float *)&v193 + 1);
          v31 = *(float *)&v193;
          *a15 = v196;
          *a16 = v193;
          if ((v174 & 1) != 0)
          {
            v171 = (float32x2_t)v197;
            if ((a14 & 1) != 0)
            {
              a14 = 0;
              v88 = a6;
              v89 = &qword_217C29000;
              v90 = a3;
              v91 = v179.n128_u32[0];
              v49 = v86;
              goto LABEL_66;
            }
            v88 = a6;
            v49 = v86;
            Path::MoveTo(v19, *(float *)&v23 + (float)(a6 * v43), v22 + (float)(a6 * v86));
            a14 = 0;
          }
          else
          {
            v112 = v26;
            v88 = a6;
            Path::OutlineJoin(v19, v18, *(float *)&v23, v22, v112, v25, v43, v86, a6, a7);
            v43 = v184;
            v49 = v175;
          }
          v89 = &qword_217C29000;
          v90 = a3;
          v91 = v179.n128_u32[0];
LABEL_66:
          v30 = -v87;
          v199 = v24;
          v200 = v89[283];
          v202 = __PAIR64__(LODWORD(v22), v23);
          *(_QWORD *)&v203 = __PAIR64__(LODWORD(v32), v91);
          *((_QWORD *)&v203 + 1) = *(_QWORD *)(v57 + 8);
          v204 = *(_DWORD *)(v57 + 16);
          LOBYTE(v205) = *(_BYTE *)(v57 + 21);
          BYTE1(v205) = *(_BYTE *)(v57 + 20);
          result = (*(uint64_t (**)(uint64_t *, float, float))(v90 + 16))(&v198, v167, v88);
LABEL_67:
          a11 = v179;
          v174 = 0;
          ++v24;
          v184 = v43;
          v175 = v49;
          goto LABEL_68;
        case 5:
          a11.n128_u32[0] = 0;
          if ((v174 & 1) == 0)
          {
            v58 = v171.f32[0];
            v171.f32[1] = v27;
            if (vabds_f32(*(float *)&v23, v171.f32[0]) >= 0.0001
              || (a5.n128_f64[0] = vabds_f32(v22, v27), a5.n128_f64[0] >= 0.0001))
            {
              v101 = v171.f32[0] - *(float *)&v23;
              v102 = v27 - v22;
              v103 = sqrtf((float)(v102 * v102) + (float)(v101 * v101));
              if (v103 <= 0.000001)
              {
                v196.f32[1] = v22;
                v104 = 0.0;
                v103 = 0.0;
                v105 = *(float *)&v23;
                v107 = (float *)&v193 + 1;
                v106 = 0.0;
              }
              else
              {
                v31 = v101 / v103;
                v104 = v102 / v103;
                v105 = v171.f32[0] + (float)(*(float *)&v23 * 0.0);
                *(float *)&v23 = (float)(v171.f32[0] * 0.0) + *(float *)&v23;
                v106 = v27 + (float)(v22 * 0.0);
                v22 = (float)(v27 * 0.0) + v22;
                *((float *)&v193 + 1) = v104;
                v107 = (float *)&v196 + 1;
              }
              v194 = v31;
              v195 = v104;
              v197 = __PAIR64__(LODWORD(v22), v23);
              *(float *)&v191 = v103;
              *((float *)&v191 + 1) = v103;
              *(float *)&v193 = v31;
              v196.f32[0] = v105;
              *v107 = v106;
              v131 = *((float *)&v193 + 1);
              v30 = -*((float *)&v193 + 1);
              v132 = *(float *)&v23;
              v133 = v26;
              v60 = a7;
              v61 = a6;
              v134 = v105;
              Path::OutlineJoin(v19, v18, v132, v22, v133, v25, -v104, v31, a6, a7);
              v59 = v196.f32[1];
              Path::LineTo(v19, v134 - (float)(v61 * v131), v196.f32[1] + (float)(v61 * v31));
              v58 = v134;
              v26 = v30;
              v25 = v31;
              v32 = v171.f32[1];
              v135.n128_u32[0] = v171.i32[0];
              v181 = v135;
            }
            else
            {
              v59 = v27;
              a5.n128_u32[0] = 0;
              v181 = a5;
              v60 = a7;
              v61 = a6;
            }
            Path::OutlineJoin(v19, v18, v58, v59, v26, v25, v184, v175, v61, v60);
            result = Path::Close(v19);
            v27 = v171.f32[1];
            a11 = v181;
          }
          ++v24;
          v174 = 1;
          goto LABEL_90;
        case 6:
          goto LABEL_90;
        case 7:
          ++v24;
          goto LABEL_24;
        default:
          v30 = 0.0;
          v31 = 0.0;
          v32 = 0.0;
LABEL_24:
          a11.n128_u32[0] = 0;
          goto LABEL_90;
      }
    }
  }
  return result;
}

Path *Path::OutsideOutline(Path *this, Path *a2, int a3, float a4, float a5)
{
  Path *v9;
  __n128 v10;
  uint64_t v11;
  double v12;
  double v13;
  double v14;
  __n128 v15;
  float32x2_t v16;
  uint64_t v17;
  _QWORD v18[3];

  v9 = this;
  if ((this->var0 & 1) != 0)
  {
    this = Path::CancelBezier(this);
    if ((v9->var0 & 2) == 0)
    {
LABEL_3:
      if (!a2)
        return this;
      goto LABEL_7;
    }
  }
  else if ((this->var0 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = Path::CloseSubpath(v9, 0);
  if (!a2)
    return this;
LABEL_7:
  if (v9->var2 >= 3)
  {
    Path::Reset(a2);
    Path::SetWeighted(a2, 0);
    Path::SetBackData(a2, 0);
    v18[0] = Path::StdCubicTo;
    v18[1] = Path::StdBezierTo;
    v18[2] = Path::StdArcTo;
    v10.n128_f64[0] = a4 * 0.0025 * a4;
    v10.n128_f32[0] = v10.n128_f64[0];
    return (Path *)Path::SubContractOutline((uint64_t)v9, (path_descr *)a2, (uint64_t)v18, a3, v10, a4, a5, v12, v13, v14, v15, v11, 1, 0, &v16, &v17);
  }
  return this;
}

Path *Path::InsideOutline(Path *this, Path *a2, int a3, float a4, float a5)
{
  Path *v7;
  int var0;
  path_descr *var3;
  int var2;
  Path *v11;
  Path *v12;
  signed int v13;
  signed int v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  signed int v18;
  uint64_t v19;
  signed int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  signed int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  signed int v30;
  float *v31;
  signed int v32;
  signed int v33;
  uint64_t v34;
  int *v35;
  signed int v36;
  int v37;
  Path *v38;
  signed int v39;
  uint64_t v40;
  float *v41;
  __n128 v42;
  uint64_t v43;
  double v44;
  double v45;
  double v46;
  __n128 v47;
  int v48;
  signed int v49;
  signed int v52;
  Path *v53;
  uint64_t v54;
  uint64_t v55;
  float32x2_t v56;
  uint64_t v57;
  _QWORD v58[4];

  v7 = this;
  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    this = Path::CancelBezier(this);
    var0 = v7->var0;
  }
  if ((var0 & 2) != 0)
    this = Path::CloseSubpath(v7, 0);
  if (a2 && v7->var2 >= 3)
  {
    Path::Reset(a2);
    Path::SetWeighted(a2, 0);
    Path::SetBackData(a2, 0);
    v58[0] = Path::StdCubicTo;
    v58[1] = Path::StdBezierTo;
    v58[2] = Path::StdArcTo;
    var3 = v7->var3;
    var2 = v7->var2;
    v11 = (Path *)operator new();
    Path::Path(v11);
    Path::SetWeighted(v12, 0);
    v13 = var2;
    v14 = 0;
    v16 = var2;
    v53 = v7;
    v49 = var2;
    do
    {
      v17 = 0;
      v18 = v14;
      v19 = v14;
      v20 = v14 + 1;
      v21 = 44 * v14;
      if (v13 <= v14 + 1)
        ++v14;
      else
        v14 = v13;
      v22 = v21 + 44;
      v23 = v19 + 1;
      while (1)
      {
        v24 = v23 + v17;
        if (v23 + v17 >= v16)
          break;
        ++v17;
        v25 = *((_BYTE *)var3 + v22);
        v22 += 44;
        if ((v25 & 0xF) == 0)
        {
          v14 = v18 + v17;
          break;
        }
      }
      if (v14 >= v13)
        v26 = v13;
      else
        v26 = v14;
      if (v26 > v20)
      {
        v54 = 0;
        v55 = 0;
        v27 = v26 - 1;
        v28 = 44 * v26 - 44;
        while (v27 > v19)
        {
          v29 = *(_DWORD *)((char *)var3 + v28) & 0xF;
          --v26;
          --v27;
          v28 -= 44;
          if (v29 != 5)
          {
            v52 = v14;
            v7->var3 = var3;
            v7->var2 = v13;
            Path::PrevPoint(v7, v26, (float *)&v55 + 1, (float *)&v55);
            Path::Reset(v11);
            Path::MoveTo(v11, *((float *)&v55 + 1), *(float *)&v55);
            do
            {
              v30 = v26;
              switch(*((_DWORD *)var3 + 11 * v26) & 0xF)
              {
                case 0:
                  Path::Close(v11);
                  goto LABEL_26;
                case 1:
                case 3:
                  Path::PrevPoint(v7, --v26, (float *)&v54 + 1, (float *)&v54);
                  Path::LineTo(v11, *((float *)&v54 + 1), *(float *)&v54);
                  goto LABEL_29;
                case 2:
                  Path::PrevPoint(v7, --v26, (float *)&v54 + 1, (float *)&v54);
                  Path::CubicTo(v11, *((float *)&v54 + 1), *(float *)&v54, -*((float *)var3 + 11 * v30 + 8), -*((float *)var3 + 11 * v30 + 9), -*((float *)var3 + 11 * v30 + 6), -*((float *)var3 + 11 * v30 + 7));
                  goto LABEL_29;
                case 4:
                  Path::PrevPoint(v7, --v26, (float *)&v54 + 1, (float *)&v54);
                  v31 = (float *)((char *)var3 + 44 * v30);
                  Path::ArcTo(v11, *((float *)&v54 + 1), *(float *)&v54, v31[6], v31[7], v31[8], *((_BYTE *)v31 + 36), *((_BYTE *)v31 + 37) == 0);
LABEL_29:
                  v55 = v54;
                  continue;
                case 6:
                  v32 = v26 - 1;
                  if ((int)v19 < v26 - 1)
                    v32 = v19;
                  v33 = v32 + 1;
                  v34 = v26 - 1;
                  v35 = (int *)((char *)var3 + 44 * v26 - 44);
                  v36 = v26;
                  break;
                default:
LABEL_26:
                  --v26;
                  continue;
              }
              while (v34 > v19)
              {
                v37 = *v35;
                v35 -= 11;
                --v36;
                --v34;
                if ((v37 & 0xF) == 3)
                {
                  v33 = v36 + 1;
                  goto LABEL_39;
                }
              }
              v36 = v32;
LABEL_39:
              if ((*((_DWORD *)var3 + 11 * v36) & 0xF) == 3)
              {
                v38 = v7;
                v39 = v33 - 2;
                Path::PrevPoint(v38, v33 - 2, (float *)&v54 + 1, (float *)&v54);
                Path::BezierTo(v11, *((float *)&v54 + 1), *(float *)&v54);
                if (v26 >= v33)
                {
                  v40 = v26 + 1;
                  v41 = (float *)((char *)var3 + 44 * v26 + 20);
                  do
                  {
                    Path::IntermBezierTo(v11, *(v41 - 1), *v41);
                    --v40;
                    v41 -= 11;
                  }
                  while (v40 > v33);
                }
                Path::EndBezierTo(v11);
              }
              else
              {
                Path::PrevPoint(v7, v36, (float *)&v54 + 1, (float *)&v54);
                Path::LineTo(v11, *((float *)&v54 + 1), *(float *)&v54);
                v39 = v33 - 2;
              }
              v55 = v54;
              v26 = v39;
              v7 = v53;
            }
            while (v26 > v18);
            Path::Close(v11);
            v15 = a4 * 0.0025 * a4;
            v42.n128_f32[0] = v15;
            Path::SubContractOutline((uint64_t)v11, (path_descr *)a2, (uint64_t)v58, a3, v42, a4, a5, v44, v45, v46, v47, v43, 1, 0, &v56, &v57);
            v13 = v49;
            v14 = v52;
            break;
          }
        }
      }
    }
    while (v24 < v16);
    v48 = v13;
    Path::~Path(v11);
    this = (Path *)MEMORY[0x219A153B8]();
    v7->var3 = var3;
    v7->var2 = v48;
  }
  return this;
}

Path *Path::OutlineJoin(Path *this, int a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10)
{
  float v13;
  Path *v15;
  double v16;
  double v17;
  float v18;
  float v19;
  double v20;
  float v21;
  float v22;
  char v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;

  v13 = a4;
  v15 = this;
  v16 = (float)((float)(a5 * a8) - (float)(a6 * a7));
  if (a9 >= 0.0 && v16 > -0.001 || a9 < 0.0 && v16 < 0.001)
  {
    v17 = (float)((float)(a6 * a8) + (float)(a5 * a7));
    if (v17 > 0.999)
      return this;
    if (v17 < -0.999)
      return (Path *)Path::LineTo(v15, a3 + (float)(a9 * a7), v13 + (float)(a9 * a8));
    v18 = a3;
LABEL_8:
    Path::LineTo(this, v18, a4);
    return (Path *)Path::LineTo(v15, a3 + (float)(a9 * a7), v13 + (float)(a9 * a8));
  }
  if (a2 == 2)
  {
    v24 = a5 + a7;
    v25 = sqrtf((float)((float)(a6 + a8) * (float)(a6 + a8)) + (float)(v24 * v24));
    v26 = v24 / v25;
    v27 = (float)(a6 + a8) / v25;
    v28 = a9 / (float)((float)(a8 * v27) + (float)(v26 * a7));
    if ((float)(v28 / a9) > a10)
      return (Path *)Path::LineTo(v15, a3 + (float)(a9 * a7), v13 + (float)(a9 * a8));
    v18 = a3 + (float)(v28 * v26);
    a4 = v13 + (float)(v28 * v27);
    goto LABEL_8;
  }
  if (a2 != 1)
    return (Path *)Path::LineTo(v15, a3 + (float)(a9 * a7), v13 + (float)(a9 * a8));
  v19 = a4 + (float)(a9 * a8);
  v20 = a9;
  if (a9 <= 0.0)
  {
    v21 = v20 * -1.0001;
    v22 = v21;
    v23 = 0;
  }
  else
  {
    v21 = v20 * 1.0001;
    v22 = v21;
    v23 = 1;
  }
  return (Path *)Path::ArcTo(this, a3 + (float)(a9 * a7), v19, v21, v22, 0.0, 0, v23);
}

float *Path::TangentOnSegAt(float *result, float *a2, float *a3, float *a4, float a5, float a6, float a7)
{
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;

  v8 = *result;
  v7 = result[1];
  v9 = *result - a6;
  v10 = v7 - a7;
  v11 = sqrtf((float)(v10 * v10) + (float)(v9 * v9));
  if (v11 <= 0.000001)
  {
    *a2 = a6;
    a2[1] = a7;
    v12 = 0.0;
    v11 = 0.0;
    *a3 = 0.0;
  }
  else
  {
    *a3 = v9 / v11;
    a3[1] = v10 / v11;
    *a2 = (float)(v8 * a5) + (float)((float)(1.0 - a5) * a6);
    v12 = (float)(v7 * a5) + (float)((float)(1.0 - a5) * a7);
    a3 = a2;
  }
  a3[1] = v12;
  *a4 = v11;
  return result;
}

BOOL Path::IsNulCurve(Path *this, path_descr *a2, float a3, float a4)
{
  int var3_high;
  uint64_t var3_low;
  double v6;
  double v7;
  float v8;
  float v9;
  int var4;
  float v11;
  float v12;
  int var5;
  int var8;
  float v15;
  _BOOL8 result;
  float *p_var2;

  switch(this->var0 & 0xF)
  {
    case 1:
      if (vabds_f32(*(float *)&this->var3, a3) >= 0.00001)
        return 0;
      var3_high = HIDWORD(this->var3);
      goto LABEL_25;
    case 2:
      var4 = this->var4;
      v11 = *(float *)&this->var6;
      v12 = *(float *)&this->var3;
      v7 = 0.0001;
      if (fabsf((float)((float)(*(float *)&var4 + v11) + (float)(a3 * 2.0)) + (float)(v12 * -2.0)) >= 0.0001)
        return 0;
      if (vabds_f32((float)((float)(a3 * -3.0) + (float)(v12 * 3.0)) + (float)(*(float *)&var4 * -2.0), v11) >= 0.0001)
        return 0;
      if (fabsf(*(float *)&var4) >= 0.0001)
        return 0;
      var5 = this->var5;
      var8 = this->var8;
      v15 = *((float *)&this->var3 + 1);
      if (fabsf((float)((float)(*(float *)&var5 + *(float *)&var8) + (float)(a4 * 2.0)) + (float)(v15 * -2.0)) >= 0.0001
        || fabsf((float)((float)((float)(a4 * -3.0) + (float)(v15 * 3.0)) + (float)(*(float *)&var5 * -2.0))- *(float *)&var8) >= 0.0001)
      {
        return 0;
      }
      v8 = fabsf(*(float *)&var5);
      return v8 < v7;
    case 3:
      var3_low = LODWORD(this->var3);
      if ((int)var3_low <= 0)
      {
        if (vabds_f32(*((float *)&this->var3 + 1), a3) >= 0.00001)
          return 0;
        var3_high = this->var4;
LABEL_25:
        v9 = vabds_f32(*(float *)&var3_high, a4);
        return v9 < 0.00001;
      }
      v6 = vabds_f32(*((float *)&this->var3 + 1), a3);
      if ((_DWORD)var3_low == 1)
      {
        v7 = 0.00001;
        if (v6 >= 0.00001
          || vabds_f32(*(float *)&this->var4, a4) >= 0.00001
          || vabds_f32(*(float *)&this[1].var1, a3) >= 0.00001)
        {
          return 0;
        }
        v8 = vabds_f32(*(float *)&this[1].var2, a4);
        return v8 < v7;
      }
      if (v6 < 0.00001 && vabds_f32(*(float *)&this->var4, a4) < 0.00001)
      {
        p_var2 = (float *)&this[1].var2;
        result = 1;
        while (vabds_f32(*(p_var2 - 1), a3) <= 0.00001 && vabds_f32(*p_var2, a4) <= 0.00001)
        {
          p_var2 += 11;
          if (!--var3_low)
            return result;
        }
      }
      return 0;
    case 4:
      if (vabds_f32(*(float *)&this->var3, a3) >= 0.00001 || vabds_f32(*((float *)&this->var3 + 1), a4) >= 0.00001)
        return 0;
      if (!LOBYTE(this->var8) || fabsf(*(float *)&this->var4) < 0.00001)
        return 1;
      v9 = fabsf(*(float *)&this->var5);
      return v9 < 0.00001;
    default:
      return 1;
  }
}

float32x2_t *Path::TangentOnCubAt(float32x2_t *result, int a2, float32x2_t *a3, uint64_t a4, float *a5, float *a6, float a7, float32x2_t a8, float32_t a9)
{
  float v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v21;
  float32x2_t v23;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;

  a8.f32[1] = a9;
  __asm { FMOV            V2.2S, #-6.0 }
  v14 = a7 + -0.5;
  v16 = result[1];
  v15 = result[2];
  v17 = *result;
  *(_QWORD *)a4 = 0;
  *a6 = 0.0;
  v18 = vmla_f32(vmla_f32(vadd_f32(v15, v16), (float32x2_t)0xC0000000C0000000, v17), (float32x2_t)0x4000000040000000, a8);
  v19 = vmul_f32(vsub_f32(v15, v16), (float32x2_t)0x3F0000003F000000);
  __asm { FMOV            V16.2S, #6.0 }
  v21 = vsub_f32(vsub_f32(vmla_f32(vmul_f32(a8, _D2), _D16, v17), v16), v15);
  __asm { FMOV            V16.2S, #0.25 }
  v23 = vmul_f32(v21, _D16);
  __asm { FMOV            V16.2S, #4.0 }
  *a3 = vadd_f32(vmul_f32(vadd_f32(vsub_f32(vmla_f32(vmul_f32(v17, _D16), _D16, a8), v15), v16), (float32x2_t)0x3E0000003E000000), vmla_n_f32(vmla_n_f32(vmul_n_f32(vmul_n_f32(v19, v14), v14), vmul_n_f32(vmul_n_f32(v18, v14), v14), v14), v23, v14));
  v25 = v23.f32[0]
      + (float)((float)(v14 * (float)(v19.f32[0] + v19.f32[0])) + (float)((float)(v14 * (float)(3.0 * v18.f32[0])) * v14));
  v26 = v23.f32[1]
      + (float)((float)(v14 * (float)(v19.f32[1] + v19.f32[1]))
              + (float)((float)(v14 * vmuls_lane_f32(3.0, v18, 1)) * v14));
  v27 = 6.0 * v18.f32[0];
  v28 = (float)(v19.f32[0] + v19.f32[0]) + (float)((float)(6.0 * v18.f32[0]) * v14);
  v29 = vmuls_lane_f32(6.0, v18, 1);
  v30 = (float)(v19.f32[1] + v19.f32[1]) + (float)(v29 * v14);
  v31 = (float)(v26 * v26) + (float)(v25 * v25);
  v32 = sqrtf(v31);
  if (v32 > 0.0001)
  {
    *a5 = v32;
    *a6 = (float)-(float)(v32 * v31) / (float)((float)(v25 * v30) - (float)(v26 * v28));
    *(float *)a4 = v25 / v32;
    v33 = v26 / v32;
LABEL_10:
    *(float *)(a4 + 4) = v33;
    return result;
  }
  *a5 = 0.0;
  v34 = (float)(v30 * v30) + (float)(v28 * v28);
  v35 = sqrtf(v34);
  if (v35 > 0.0001)
  {
    *a6 = (float)-(float)(v35 * v34) / (float)((float)(v28 * v29) - (float)(v30 * v27));
    v36 = v30 / v35;
    *(float *)a4 = v28 / v35;
    *(float *)(a4 + 4) = v36;
    if (!a2)
      return result;
    v37 = -(float)(v28 / v35);
    goto LABEL_9;
  }
  v38 = sqrtf((float)(v29 * v29) + (float)(v27 * v27));
  if (v38 > 0.0001)
  {
    *a6 = 100000000.0;
    v39 = v27 / v38;
    v36 = v29 / v38;
    *(float *)a4 = v39;
    *(float *)(a4 + 4) = v36;
    if (a2)
    {
      v37 = -v39;
LABEL_9:
      *(float *)a4 = v37;
      v33 = -v36;
      goto LABEL_10;
    }
  }
  return result;
}

void Path::TangentOnArcAt(uint64_t a1, float *a2, uint64_t a3, float *a4, float *a5, float a6, float a7, float a8)
{
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  int v16;
  int v17;
  float cosval;
  __float2 v23;
  float sinval;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  __float2 v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;

  v12 = *(float *)a1;
  v11 = *(float *)(a1 + 4);
  v14 = *(float *)(a1 + 8);
  v13 = *(float *)(a1 + 12);
  v15 = *(float *)(a1 + 16);
  v16 = *(unsigned __int8 *)(a1 + 20);
  v17 = *(unsigned __int8 *)(a1 + 21);
  *a2 = a7;
  a2[1] = a8;
  *(_QWORD *)a3 = 0;
  if (v14 > 0.0001 && v13 > 0.0001)
  {
    v72 = v13;
    v23 = __sincosf_stret(v15);
    cosval = v23.__cosval;
    sinval = v23.__sinval;
    v25 = (float)((float)((float)(v11 - a8) * v23.__sinval) + (float)(v23.__cosval * (float)(v12 - a7))) / v14;
    v26 = (float)((float)((float)(v11 - a8) * v23.__cosval) - (float)(v23.__sinval * (float)(v12 - a7))) / v72;
    v27 = (float)(v26 * v26) + (float)(v25 * v25);
    if (v27 < 4.0)
    {
      v28 = v12;
      v29 = v11;
      v71 = a6;
      v30 = (float)(v27 * -0.25) + 1.0;
      if (v30 < 0.0)
        v30 = 0.0;
      v31 = sqrtf(v30);
      v32 = sqrtf(v27);
      v33 = (float)-v25 / v32;
      v34 = (float)(v26 / v32) * v31;
      v35 = v25 * 0.5;
      v36 = (float)-v34 - (float)(v25 * 0.5);
      v37 = v26 * 0.5;
      v38 = 3.1416;
      v39 = -1.0;
      v40 = 3.1416;
      if (v36 >= -1.0)
      {
        v40 = 0.0;
        if (v36 <= 1.0)
        {
          v66 = (float)-(float)(v33 * v31) - v37;
          v67 = v33;
          v68 = v26 * 0.5;
          v41 = v34;
          v42 = acosf(v36);
          v39 = -1.0;
          v33 = v67;
          v37 = v68;
          v34 = v41;
          v38 = 3.1416;
          v28 = v12;
          cosval = v23.__cosval;
          sinval = v23.__sinval;
          v29 = v11;
          v40 = v42;
          if (v66 < 0.0)
            v40 = 6.28318531 - v42;
        }
      }
      v43 = v33 * v31;
      v70 = -sinval;
      v44 = v35 - v34;
      if ((float)(v35 - v34) >= v39)
      {
        v38 = 0.0;
        if (v44 <= 1.0)
        {
          v69 = v37 - v43;
          v45 = v34;
          v46 = acosf(v44);
          v34 = v45;
          v28 = v12;
          cosval = v23.__cosval;
          sinval = v23.__sinval;
          v29 = v11;
          v38 = v46;
          if (v69 < 0.0)
            v38 = 6.28318531 - v46;
        }
      }
      v47 = v14 * v34;
      v48 = (float)((float)(v72 * v43) * v70) + (float)(cosval * (float)(v14 * v34));
      v49 = (float)(cosval * (float)(v72 * v43)) + (float)(sinval * v47);
      if (v17)
      {
        if (v16)
        {
          v48 = -v48;
          v49 = -v49;
          v50 = v40 + 3.14159265;
          v51 = v38 + 3.14159265;
          if (v50 >= 6.28318531)
          {
            v52 = v50 + -6.28318531;
            v38 = v52;
          }
          else
          {
            v38 = v40 + 3.14159265;
          }
          if (v51 >= 6.28318531)
          {
            v53 = v51 + -6.28318531;
            v40 = v53;
          }
          else
          {
            v40 = v51;
          }
        }
        v54 = (float)((float)(v28 + a7) * 0.5) + v48;
        v55 = (float)((float)(v29 + a8) * 0.5) + v49;
        v56 = v40 + 6.28318531;
        if (v40 >= v38)
          v56 = v40;
      }
      else
      {
        if (!v16)
        {
          v48 = -v48;
          v49 = -v49;
          v57 = v40 + 3.14159265;
          v58 = v38 + 3.14159265;
          if (v57 >= 6.28318531)
          {
            v59 = v57 + -6.28318531;
            v38 = v59;
          }
          else
          {
            v38 = v40 + 3.14159265;
          }
          if (v58 >= 6.28318531)
          {
            v60 = v58 + -6.28318531;
            v40 = v60;
          }
          else
          {
            v40 = v58;
          }
        }
        v54 = (float)((float)(v28 + a7) * 0.5) + v48;
        v55 = (float)((float)(v29 + a8) * 0.5) + v49;
        v56 = v40 + -6.28318531;
        if (v40 <= v38)
          v56 = v40;
      }
      v61 = __sincosf_stret((float)(v38 * v71) + (float)(v56 * (float)(1.0 - v71)));
      *a2 = (float)(v54 + (float)((float)(v14 * v23.__cosval) * v61.__cosval))
          - (float)((float)(v72 * v23.__sinval) * v61.__sinval);
      a2[1] = (float)(v55 + (float)((float)(v14 * v23.__sinval) * v61.__cosval))
            + (float)((float)(v72 * v23.__cosval) * v61.__sinval);
      v62 = (float)((float)(v72 * v23.__sinval) * v61.__cosval) + (float)((float)(v14 * v23.__cosval) * v61.__sinval);
      v63 = (float)((float)(v14 * v23.__sinval) * v61.__sinval) - (float)((float)(v72 * v23.__cosval) * v61.__cosval);
      *(float *)a3 = v62;
      *(float *)(a3 + 4) = v63;
      v64 = sqrtf((float)(v63 * v63) + (float)(v62 * v62));
      *a4 = v64;
      *a5 = (float)(v64
                  * (float)((float)(*(float *)(a3 + 4) * *(float *)(a3 + 4)) + (float)(*(float *)a3 * *(float *)a3)))
          / (float)((float)(*(float *)a3
                          * (float)((float)((float)(v14 * v70) * v61.__cosval)
                                  - (float)((float)(v72 * v23.__cosval) * v61.__sinval)))
                  - (float)(*(float *)(a3 + 4)
                          * (float)((float)((float)(v72 * v23.__sinval) * v61.__sinval)
                                  + (float)((float)-(float)(v23.__cosval * v14) * v61.__cosval))));
      v65 = *(float *)(a3 + 4);
      *(float *)a3 = *(float *)a3 / *a4;
      *(float *)(a3 + 4) = v65 / *a4;
    }
  }
}

float32x2_t *Path::TangentOnBezAt(float32x2_t *result, uint64_t a2, int a3, float32x2_t *a4, uint64_t a5, float *a6, float *a7, float a8, float32x2_t a9, float32_t a10)
{
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;

  a9.f32[1] = a10;
  v10 = *(float32x2_t *)(a2 + 4);
  v11 = *result;
  *(_QWORD *)a5 = 0;
  *a7 = 0.0;
  v12 = vmla_f32(vadd_f32(v10, a9), (float32x2_t)0xC0000000C0000000, v11);
  v13 = vmla_f32(vmul_f32(a9, (float32x2_t)0xC0000000C0000000), (float32x2_t)0x4000000040000000, v11);
  *a4 = vadd_f32(vmla_n_f32(vmul_n_f32(v13, a8), vmul_n_f32(v12, a8), a8), a9);
  v14 = v12.f32[0] + v12.f32[0];
  v15 = v13.f32[0] + (float)((float)(v12.f32[0] + v12.f32[0]) * a8);
  v16 = v12.f32[1] + v12.f32[1];
  v17 = v13.f32[1] + (float)((float)(v12.f32[1] + v12.f32[1]) * a8);
  v18 = (float)(v17 * v17) + (float)(v15 * v15);
  v19 = sqrtf(v18);
  if (v19 > 0.0001)
  {
    *a6 = v19;
    *a7 = (float)-(float)(v19 * v18) / (float)((float)(v15 * v16) - (float)(v17 * v14));
    *(float *)a5 = v15 / v19;
    v20 = v17 / v19;
LABEL_6:
    *(float *)(a5 + 4) = v20;
    return result;
  }
  *a6 = 0.0;
  v21 = sqrtf((float)(v16 * v16) + (float)(v14 * v14));
  if (v21 > 0.0001)
  {
    *a7 = 100000000.0;
    v22 = v14 / v21;
    v23 = v16 / v21;
    *(float *)a5 = v22;
    *(float *)(a5 + 4) = v23;
    if (a3)
    {
      *(float *)a5 = -v22;
      v20 = -v23;
      goto LABEL_6;
    }
  }
  return result;
}

uint64_t Path::RecStdCubicTo(__int128 *a1, int a2, float a3, double a4)
{
  float v5;
  __int32 v8;
  float32_t v9;
  float32x2_t v10;
  float v11;
  float32x2_t v12;
  BOOL v13;
  double v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  __int128 v22;
  float32x4_t v23;
  uint64_t v24;
  float64x2_t v30;
  float v31;
  uint64_t result;
  Path *v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  uint64_t v40;
  float32x2_t v41;
  float32x2_t v42;
  float32x2_t v43;
  uint64_t v44;
  float32x2_t v45;
  unsigned int v46;
  __int32 v47;
  __int32 v48;
  float v49;
  float32x4_t v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  float32x4_t v54;
  uint64_t v55;
  char v56[8];
  float v57;
  float v58;
  float32x2_t v59;
  uint64_t v60;
  uint64_t v61;
  float v62;
  float v63;
  float32x2_t v64;
  float32x2_t v65;
  float32x2_t v66;
  float32x2_t v67;
  float32x2_t v68;
  float32x2_t v69;

  v5 = *(float *)&a4;
  v63 = 0.0;
  v60 = 0;
  v61 = 0;
  v51 = *(__int128 *)((char *)a1 + 40);
  *(_QWORD *)&v52 = *((_QWORD *)a1 + 7);
  v8 = *((_DWORD *)a1 + 8);
  v9 = *((float32_t *)a1 + 9);
  LODWORD(a4) = v8;
  Path::TangentOnCubAt((float32x2_t *)&v51, 0, &v69, (uint64_t)&v66, (float *)&v61, &v63, 0.0, *(float32x2_t *)&a4, v9);
  v10.i32[0] = v8;
  Path::TangentOnCubAt((float32x2_t *)&v51, 0, &v68, (uint64_t)&v64, (float *)&v60 + 1, &v62, 0.5, v10, v9);
  v11 = 1.0;
  v12.i32[0] = v8;
  Path::TangentOnCubAt((float32x2_t *)&v51, 1, &v67, (uint64_t)&v65, (float *)&v60, (float *)&v61 + 1, 1.0, v12, v9);
  v14 = fabsf(v63);
  v13 = v14 <= 0.01;
  LODWORD(v14) = 1.0;
  if (!v13)
    *(float *)&v14 = (float)(v5 / v63) + 1.0;
  if (fabsf(*((float *)&v61 + 1)) > 0.01)
    v11 = (float)(v5 / *((float *)&v61 + 1)) + 1.0;
  v15 = -v65.f32[1];
  v16 = *(float *)&v61;
  v17 = *(float *)&v14 * *(float *)&v61;
  v18 = v11 * *(float *)&v60;
  if (a2 <= 0)
  {
    v33 = (Path *)*((_QWORD *)a1 + 3);
    v34 = v67.f32[0] + (float)(v5 * v15);
    v35 = vmlas_n_f32(v67.f32[1], v5, v65.f32[0]);
    v36 = v17 * v66.f32[0];
    v37 = v66.f32[1] * v17;
    v38 = v18 * v65.f32[0];
    v39 = v65.f32[1] * v18;
  }
  else
  {
    v46 = v60;
    v48 = v68.i32[0];
    v49 = v68.f32[0] + (float)(v5 * (float)-v64.f32[1]);
    v19 = v67.f32[0] + (float)(v5 * v15);
    *(float *)&v14 = v69.f32[0] + (float)(v5 * (float)-v66.f32[1]);
    v47 = v68.i32[1];
    v20 = vmlas_n_f32(v68.f32[1], v5, v64.f32[0]);
    v21 = vmlas_n_f32(v67.f32[1], v5, v65.f32[0]);
    *(float *)&v51 = v19;
    *((float *)&v51 + 1) = v21;
    v42 = vmul_n_f32(v66, v17);
    v43 = v65;
    *((float32x2_t *)&v51 + 1) = v42;
    *(float32x2_t *)&v52 = vmul_n_f32(v65, v18);
    v44 = v52;
    v45 = v64;
    v41 = v66;
    Path::TangentOnCubAt((float32x2_t *)&v51, 0, &v59, (uint64_t)v56, &v58, &v57, 0.5, *(float32x2_t *)&v14, vmlas_n_f32(v69.f32[1], v5, v66.f32[0]));
    if ((float)((float)((float)(v20 - v59.f32[1]) * (float)(v20 - v59.f32[1]))
               + (float)((float)(v49 - v59.f32[0]) * (float)(v49 - v59.f32[0]))) > (float)(a3 * a3))
    {
      v22 = a1[1];
      v51 = *a1;
      v52 = v22;
      v23 = (float32x4_t)a1[3];
      v53 = a1[2];
      v54 = v23;
      v55 = *((_QWORD *)a1 + 8);
      v23.f32[0] = (float)(*((float *)a1 + 3) + *((float *)a1 + 4)) * 0.5;
      HIDWORD(v51) = *((_DWORD *)a1 + 3);
      LODWORD(v52) = v23.i32[0];
      *(_QWORD *)&v53 = __PAIR64__(LODWORD(v9), v8);
      *((_QWORD *)&v53 + 1) = __PAIR64__(v47, v48);
      v24 = (a2 - 1);
      __asm { FMOV            V4.2D, #0.5 }
      v30 = vmulq_f64(vcvtq_f64_f32((float32x2_t)__PAIR64__(v46, HIDWORD(v60))), _Q4);
      *(float32x2_t *)v54.f32 = vcvt_f32_f64(vmulq_n_f64(vcvtq_f64_f32(v41), v16 * 0.5));
      *(float32x2_t *)&v54.u32[2] = vcvt_f32_f64(vmulq_n_f64(vcvtq_f64_f32(v45), v30.f64[0]));
      v50 = vcvt_hight_f32_f64(*(int32x2_t *)&v54.u32[2], vmulq_laneq_f64(vcvtq_f64_f32(v43), v30, 1));
      Path::RecStdCubicTo(&v51, v24, a3, v5);
      v31 = *((float *)a1 + 4);
      *((float *)&v51 + 3) = (float)(*((float *)a1 + 3) + v31) * 0.5;
      *(float *)&v52 = v31;
      *(_QWORD *)&v53 = __PAIR64__(v47, v48);
      *((_QWORD *)&v53 + 1) = *((_QWORD *)a1 + 5);
      v54 = v50;
      return Path::RecStdCubicTo(&v51, v24, a3, v5);
    }
    v33 = (Path *)*((_QWORD *)a1 + 3);
    v37 = v42.f32[1];
    v36 = v42.f32[0];
    v39 = *((float *)&v44 + 1);
    v38 = *(float *)&v44;
    v34 = v19;
    v35 = v21;
  }
  result = Path::CubicTo(v33, v34, v35, v36, v37, v38, v39);
  if ((result & 0x80000000) == 0)
  {
    v40 = *(_QWORD *)(*((_QWORD *)a1 + 3) + 16) + 44 * result;
    *(_DWORD *)(v40 + 4) = *((_DWORD *)a1 + 2);
    *(_QWORD *)(v40 + 8) = *(_QWORD *)((char *)a1 + 12);
  }
  return result;
}

void Path::RecStdArcTo(__int128 *a1, int a2, float a3, float a4)
{
  float v7;
  int v8;
  int v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  double v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  float v34;
  Path *v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  unsigned int v42;
  _DWORD *v43;
  float v44;
  float v45;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  float v64;
  float v65;
  _BYTE v66[8];
  float v67;
  float v68;
  float32x2_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  float v73;
  float v74;
  _DWORD v75[2];
  float v76;
  float v77;
  _DWORD v78[2];
  float v79;
  float v80;
  float v81[2];
  float v82[2];

  v74 = 0.0;
  v71 = 0;
  v72 = 0;
  v56 = *((float *)a1 + 11);
  v58 = *((float *)a1 + 10);
  *(_QWORD *)&v60 = __PAIR64__(LODWORD(v56), LODWORD(v58));
  v52 = *((float *)a1 + 13);
  v54 = *((float *)a1 + 12);
  *((_QWORD *)&v60 + 1) = __PAIR64__(LODWORD(v52), LODWORD(v54));
  v7 = *((float *)a1 + 14);
  *(float *)&v61 = v7;
  v8 = *((unsigned __int8 *)a1 + 60);
  BYTE5(v61) = *((_BYTE *)a1 + 60);
  v9 = *((unsigned __int8 *)a1 + 61);
  BYTE4(v61) = *((_BYTE *)a1 + 61);
  v10 = *((float *)a1 + 16);
  v12 = *((float *)a1 + 8);
  v11 = *((float *)a1 + 9);
  Path::TangentOnArcAt((uint64_t)&v60, v82, (uint64_t)v78, (float *)&v72, &v74, v10, v12, v11);
  v13 = *((float *)a1 + 17);
  Path::TangentOnArcAt((uint64_t)&v60, v81, (uint64_t)v75, (float *)&v71 + 1, &v73, (float)(v10 + v13) * 0.5, v12, v11);
  Path::TangentOnArcAt((uint64_t)&v60, &v79, (uint64_t)&v76, (float *)&v71, (float *)&v72 + 1, v13, v12, v11);
  v15 = v77;
  v49 = *(float *)&v78[1];
  v51 = *(float *)v78;
  v16 = v76;
  v44 = *(float *)&v75[1];
  v45 = *(float *)v75;
  v47 = -v77;
  v17 = (float)(a4 / v74) + 1.0;
  if (fabsf(v74) <= 0.01)
    v17 = 1.0;
  v18 = (float)(a4 / *((float *)&v72 + 1)) + 1.0;
  if (fabsf(*((float *)&v72 + 1)) <= 0.01)
    v18 = 1.0;
  v19 = v17 * *(float *)&v72;
  v20 = v18 * *(float *)&v71;
  v70 = 0;
  Path::ArcAngles((Path *)(v9 != 0), v12, v11, v58, v56, v54, v52, v7, v8 == 0, (float *)&v70 + 1, (float *)&v70, v14);
  v21 = *(float *)&v70 - *((float *)&v70 + 1);
  if ((float)(*(float *)&v70 - *((float *)&v70 + 1)) < 0.0)
  {
    v22 = (float)(*(float *)&v70 - *((float *)&v70 + 1)) + 6.28318531;
    v21 = v22;
  }
  v23 = v21;
  if (v21 > 6.28318531)
  {
    v24 = v21 + -6.28318531;
    v21 = v24;
  }
  v25 = *((float *)a1 + 16);
  v26 = *((float *)a1 + 17);
  v27 = (float)(v26 - v25) * v21;
  if (a2 <= 0)
  {
    v35 = (Path *)*((_QWORD *)a1 + 3);
    v36 = v79 + (float)(a4 * v47);
    v37 = v80 + (float)(a4 * v16);
    v38 = (float)(v51 * v19) * v27;
    v39 = (float)(v49 * v19) * v27;
    v40 = (float)(v16 * v20) * v27;
    v41 = (float)(v15 * v20) * v27;
  }
  else
  {
    v28 = -v49;
    v57 = v81[1] + (float)(a4 * v45);
    v59 = v81[0] + (float)(a4 * (float)-v44);
    v53 = v79 + (float)(a4 * v47);
    v55 = v80 + (float)(a4 * v16);
    *(float *)&v60 = v53;
    *((float *)&v60 + 1) = v55;
    v48 = (float)(v49 * v19) * v27;
    v50 = (float)(v51 * v19) * v27;
    *((float *)&v60 + 2) = v50;
    *((float *)&v60 + 3) = v48;
    v29 = (float)(v16 * v20) * v27;
    v30 = (float)(v15 * v20) * v27;
    *(float *)&v61 = v29;
    *((float *)&v61 + 1) = v30;
    *(float *)&v23 = v82[0] + (float)(a4 * v28);
    Path::TangentOnCubAt((float32x2_t *)&v60, 0, &v69, (uint64_t)v66, &v68, &v67, 0.5, *(float32x2_t *)&v23, v82[1] + (float)(a4 * v51));
    if ((float)((float)((float)(v57 - v69.f32[1]) * (float)(v57 - v69.f32[1]))
               + (float)((float)(v59 - v69.f32[0]) * (float)(v59 - v69.f32[0]))) > (float)(a3 * a3))
    {
      v31 = a1[1];
      v60 = *a1;
      v61 = v31;
      v32 = a1[3];
      v62 = a1[2];
      v63 = v32;
      v64 = v25;
      v65 = (float)(v26 + v25) * 0.5;
      v33 = (a2 - 1);
      Path::RecStdArcTo(&v60, v33, a3, a4);
      v34 = *((float *)a1 + 17);
      v64 = (float)(*((float *)a1 + 16) + v34) * 0.5;
      v65 = v34;
      Path::RecStdArcTo(&v60, v33, a3, a4);
      return;
    }
    v35 = (Path *)*((_QWORD *)a1 + 3);
    v36 = v53;
    v37 = v55;
    v39 = v48;
    v38 = v50;
    v40 = v29;
    v41 = v30;
  }
  v42 = Path::CubicTo(v35, v36, v37, v38, v39, v40, v41);
  if ((v42 & 0x80000000) == 0)
  {
    v43 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 3) + 16) + 44 * v42);
    v43[1] = *((_DWORD *)a1 + 2);
    v43[2] = *((_DWORD *)a1 + 16);
    v43[3] = *((_DWORD *)a1 + 17);
  }
}

void Path::Simplify(Path *this, float a2)
{
  char *var11;
  uint64_t var8;
  int v6;
  int v7;
  uint64_t v8;
  char *v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  uint64_t v14;
  char *v15;
  int v16;
  uint64_t v17;
  char *v18;
  int v19;
  char *v20;

  if (this->var8 >= 2)
  {
    Path::Reset(this);
    var11 = this->var11;
    var8 = this->var8;
    if ((int)var8 >= 1)
    {
      v6 = 0;
      do
      {
        v7 = v6 + 1;
        if (this->var7)
        {
          if (this->var6)
          {
            if (v7 < (int)var8)
            {
              v8 = v7;
              v9 = &var11[24 * v7];
              while (1)
              {
                v10 = *(_DWORD *)v9;
                v9 += 24;
                if ((v10 | 2) != 2)
                  break;
                if (var8 == ++v8)
                {
                  v7 = var8;
                  goto LABEL_28;
                }
              }
              v7 = v8;
            }
LABEL_28:
            v20 = &var11[24 * v6];
          }
          else
          {
            if (v7 < (int)var8)
            {
              v14 = v7;
              v15 = &var11[20 * v7];
              while (1)
              {
                v16 = *(_DWORD *)v15;
                v15 += 20;
                if ((v16 | 2) != 2)
                  break;
                if (var8 == ++v14)
                {
                  v7 = var8;
                  goto LABEL_32;
                }
              }
              v7 = v14;
            }
LABEL_32:
            v20 = &var11[20 * v6];
          }
        }
        else if (this->var6)
        {
          if (v7 < (int)var8)
          {
            v11 = v7;
            v12 = &var11[16 * v7];
            while (1)
            {
              v13 = *(_DWORD *)v12;
              v12 += 16;
              if ((v13 | 2) != 2)
                break;
              if (var8 == ++v11)
              {
                v7 = var8;
                goto LABEL_30;
              }
            }
            v7 = v11;
          }
LABEL_30:
          v20 = &var11[16 * v6];
        }
        else
        {
          if (v7 < (int)var8)
          {
            v17 = v7;
            v18 = &var11[12 * v7];
            while (1)
            {
              v19 = *(_DWORD *)v18;
              v18 += 12;
              if ((v19 | 2) != 2)
                break;
              if (var8 == ++v17)
              {
                v7 = var8;
                goto LABEL_34;
              }
            }
            v7 = v17;
          }
LABEL_34:
          v20 = &var11[12 * v6];
        }
        this->var11 = v20;
        this->var8 = v7 - v6;
        Path::DoSimplify(this, a2);
        v6 = v7;
      }
      while (v7 < (int)var8);
    }
    this->var11 = var11;
    this->var8 = var8;
  }
}

Path *Path::DoSimplify(Path *this, float a2)
{
  uint64_t var8;
  Path *v4;
  char *var11;
  float v6;
  float v7;
  int v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL4 var7;
  char *v20;
  int v21;
  int v22;
  char v24;
  char *v25;
  float *v26;
  float *v27;
  char *v28;
  float *v29;
  float *v30;
  char *v31;
  float *v32;
  float *v33;
  char *v34;
  float *v35;
  float *v36;
  float *v37;
  BOOL v38;
  float *v39;
  float *v40;
  float v41;
  float v42;
  float v43[6];

  var8 = this->var8;
  if ((int)var8 >= 2)
  {
    v4 = this;
    var11 = this->var11;
    v7 = *((float *)var11 + 1);
    v6 = *((float *)var11 + 2);
    Path::MoveTo(this, v7, v6);
    v8 = 0;
    do
    {
      v4->var8 = 2;
      if (v4->var7)
      {
        v9 = &var11[20 * v8];
        v10 = &var11[24 * v8];
      }
      else
      {
        v9 = &var11[12 * v8];
        v10 = &var11[16 * v8];
      }
      if (v4->var6)
        v11 = v10;
      else
        v11 = v9;
      v12 = (v8 + 1);
      v4->var11 = v11;
      v13 = (int)v12;
      v14 = v12 << 32;
      v15 = &var11[12 * (int)v12];
      v16 = (int)v12 + 1;
      while (1)
      {
        v17 = v13;
        v18 = v14;
        var7 = v4->var7;
        if (v4->var7)
          v20 = v4->var6 ? &var11[24 * v13] : &var11[20 * v13];
        else
          v20 = v4->var6 ? &var11[16 * v13] : v15;
        v21 = *(_DWORD *)v20;
        v22 = v4->var8 + 1;
        v4->var8 = v22;
        if (v21 == 2 || v16 >= var8)
          break;
        v24 = Path::AttemptSimplify((uint64_t)v4, v43, a2);
        v14 = v18 + 0x100000000;
        v13 = v17 + 1;
        v15 += 12;
        ++v16;
        if ((v24 & 1) == 0)
        {
          v22 = v4->var8;
          var7 = v4->var7;
          break;
        }
      }
      v4->var8 = v22 - 1;
      v25 = &var11[12 * SHIDWORD(v18)];
      v26 = (float *)(v25 + 4);
      v27 = (float *)(v25 + 8);
      v28 = &var11[16 * (v18 >> 32)];
      v29 = (float *)(v28 + 4);
      v30 = (float *)(v28 + 8);
      if (v4->var6)
      {
        v26 = v29;
        v27 = v30;
      }
      v31 = &var11[20 * SHIDWORD(v18)];
      v32 = (float *)(v31 + 4);
      v33 = (float *)(v31 + 8);
      v34 = &var11[24 * SHIDWORD(v18)];
      v35 = (float *)(v34 + 4);
      v36 = (float *)(v34 + 8);
      if (v4->var6)
        v37 = v35;
      else
        v37 = v32;
      if (!v4->var6)
        v36 = v33;
      v38 = !var7;
      if (var7)
        v39 = v37;
      else
        v39 = v26;
      if (v38)
        v40 = v27;
      else
        v40 = v36;
      v41 = *v40;
      v42 = *v39;
      if (v22 > 3)
        this = (Path *)Path::CubicTo(v4, *v39, *v40, v43[2], v43[3], v43[4], v43[5]);
      else
        this = (Path *)Path::LineTo(v4, *v39, *v40);
      v8 = v17;
    }
    while ((int)var8 - 1 > (int)v17);
    if (vabds_f32(v42, v7) < 0.00001 && vabds_f32(v41, v6) < 0.00001)
      this = (Path *)Path::Close(v4);
    v4->var11 = var11;
    v4->var8 = var8;
  }
  return this;
}

uint64_t Path::AttemptSimplify(uint64_t a1, float *a2, float a3)
{
  uint64_t v3;
  int v6;
  int v7;
  float *v8;
  uint64_t v9;
  float *v10;
  float *v11;
  float *v12;
  float *v13;
  float *v14;
  float *v15;
  float *v16;
  float *v17;
  float *v18;
  float *v19;
  float *v20;
  float *v21;
  float *v22;
  float *v23;
  BOOL v24;
  float *v25;
  float *v26;
  float *v27;
  BOOL v28;
  float *v29;
  float *v30;
  float *v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  double *v40;
  double *v41;
  double *v42;
  double *v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  float *v47;
  double *v48;
  float *v49;
  int v50;
  float *v51;
  float *v52;
  float *v53;
  float v54;
  float v55;
  float v56;
  double v57;
  double v58;
  float v59;
  float v60;
  double *v61;
  double v62;
  uint64_t v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double *v68;
  uint64_t v69;
  uint64_t v70;
  double *v71;
  double v72;
  double v73;
  double v74;
  double v75;
  double v76;
  double v77;
  double v78;
  double v79;
  double v80;
  double v81;
  double v82;
  double v83;
  double v84;
  double v85;
  double v86;
  double v87;
  uint64_t v88;
  double v89;
  double *v90;
  double *v91;
  uint64_t v92;
  double v93;
  double v94;
  double v95;
  double v96;
  double v97;
  double v98;
  double v99;
  double v100;
  double v101;
  uint64_t v102;
  double v103;
  double *v104;
  double *v105;
  uint64_t v106;
  double v107;
  double v108;
  double v109;
  double v110;
  double v111;
  double v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  double *v118;
  double *v119;
  double *v120;
  uint64_t v121;
  double v122;
  double v123;
  double v124;
  double v125;
  double v126;
  float v127;
  double v128;
  double v129;
  double v130;
  double v131;
  double v132;
  double v133;
  double v134;
  double v135;
  double v136;
  double v137;
  double *v138;
  double v139;
  double *v140;
  double *v141;
  uint64_t v142;
  uint64_t v143;
  double v144;
  float v145;
  double v146;
  float v147;
  float v148;
  float v149;
  float v150;
  float v151;
  float v152;
  double v153;
  double *v154;
  double v155;
  double v156;
  double v157;
  double v158;
  double v159;
  double v160;
  double v161;
  double v162;
  double v163;
  double v164;
  double v165;
  double v166;
  uint64_t v167;
  double v168;
  double *v169;
  double *v170;
  uint64_t v171;
  double v172;
  double v173;
  double v174;
  double v175;
  double v176;
  double v177;
  double v178;
  double v179;
  double v180;
  uint64_t v181;
  double v182;
  double *v183;
  double *v184;
  uint64_t v185;
  double v186;
  double v187;
  double v188;
  double v189;
  double v190;
  double v191;
  float v192;
  float v193;
  float v194;
  float v195;
  double v196;
  double *v197;
  double *v198;
  double *v199;
  uint64_t v200;
  float v201;
  double v202;
  double v203;
  double v204;
  double v205;
  double v206;
  float v207;
  double v208;
  double v209;
  double v210;
  double v211;
  double v212;
  double v213;
  double v214;
  double v215;
  int v216;
  float *v217;
  float v218;
  float v219;

  v3 = *(int *)(a1 + 36);
  if ((_DWORD)v3 == 2)
    return 1;
  v6 = *(unsigned __int8 *)(a1 + 33);
  v7 = *(unsigned __int8 *)(a1 + 32);
  v8 = *(float **)(a1 + 48);
  v9 = v3 - 1;
  v10 = v8 + 4;
  v11 = v8 + 5;
  v12 = &v8[3 * v3 - 3];
  v13 = v12 + 1;
  v14 = v12 + 2;
  v15 = &v8[4 * v3 - 4];
  v16 = v15 + 1;
  v17 = v15 + 2;
  if (v7)
  {
    v10 = v8 + 5;
    v11 = v8 + 6;
    v13 = v16;
    v14 = v17;
  }
  v18 = &v8[5 * v9];
  v19 = v18 + 1;
  v20 = v18 + 2;
  v21 = &v8[6 * v9];
  v22 = v21 + 1;
  v23 = v21 + 2;
  v24 = v7 == 0;
  if (v7)
    v25 = v8 + 7;
  else
    v25 = v8 + 6;
  if (v24)
    v26 = v8 + 7;
  else
    v26 = v8 + 8;
  if (v24)
    v27 = v19;
  else
    v27 = v22;
  if (v24)
    v23 = v20;
  v28 = v6 == 0;
  if (v6)
    v29 = v25;
  else
    v29 = v10;
  if (v28)
    v30 = v11;
  else
    v30 = v26;
  if (v28)
    v31 = v13;
  else
    v31 = v27;
  if (v28)
    v23 = v14;
  v33 = v8[1];
  v32 = v8[2];
  v34 = *v23;
  v35 = *v31;
  if ((_DWORD)v3 == 3)
  {
    v36 = *v30;
    v37 = *v29;
    *a2 = v35;
    a2[1] = v34;
    a2[2] = v37 - v33;
    a2[3] = v36 - v32;
    a2[4] = v35 - v37;
    a2[5] = v34 - v36;
    return 1;
  }
  v40 = (double *)malloc_type_malloc(8 * v3, 0x100004000313F17uLL);
  v41 = (double *)malloc_type_malloc(8 * *(int *)(a1 + 36), 0x100004000313F17uLL);
  v42 = (double *)malloc_type_malloc(8 * *(int *)(a1 + 36), 0x100004000313F17uLL);
  v43 = (double *)malloc_type_malloc(8 * *(int *)(a1 + 36), 0x100004000313F17uLL);
  *v40 = 0.0;
  v44 = *(unsigned int *)(a1 + 36);
  if ((int)v44 >= 2)
  {
    v45 = 0;
    v46 = *(unsigned __int8 *)(a1 + 33);
    v47 = *(float **)(a1 + 48);
    v48 = v42 + 1;
    v49 = v47 + 5;
    v50 = *(unsigned __int8 *)(a1 + 32);
    v51 = v47 + 8;
    v52 = v47 + 7;
    v53 = v47 + 6;
    v54 = v32;
    v55 = v33;
    do
    {
      if (v46)
      {
        if (v50)
        {
          v48[v45 / 8] = *(v51 - 1);
          v56 = *v51;
        }
        else
        {
          v48[v45 / 8] = *(v52 - 1);
          v56 = *v52;
        }
      }
      else if (v50)
      {
        v48[v45 / 8] = *(v53 - 1);
        v56 = *v53;
      }
      else
      {
        v48[v45 / 8] = *(v49 - 1);
        v56 = *v49;
      }
      v57 = v56;
      v43[v45 / 8 + 1] = v57;
      v58 = v48[v45 / 8];
      v59 = v58 - v55;
      v60 = v57 - v54;
      v55 = v58;
      v54 = v57;
      v61 = &v40[v45 / 8];
      v62 = v40[v45 / 8];
      v45 += 8;
      v49 += 3;
      v61[1] = v62 + sqrtf((float)(v60 * v60) + (float)(v59 * v59));
      v51 += 6;
      v52 += 5;
      v53 += 4;
    }
    while (8 * v44 - 8 != v45);
  }
  if (v40[(int)v44 - 1] < 0.00001)
    goto LABEL_69;
  v63 = (int)v44 - 1;
  v64 = 0.0;
  v65 = 0.0;
  v66 = 0.0;
  v67 = 0.0;
  if ((int)v44 >= 3)
  {
    v68 = v40 + 1;
    v69 = (v44 - 1) - 1;
    v70 = v69;
    do
    {
      *v68 = *v68 / v40[v63];
      ++v68;
      --v70;
    }
    while (v70);
    v71 = v40 + 1;
    v67 = 0.0;
    v66 = 0.0;
    v65 = 0.0;
    v64 = 0.0;
    do
    {
      v72 = *v71++;
      v73 = (1.0 - v72) * (v72 * 3.0 * (1.0 - v72));
      v64 = v64 + v73 * v73;
      v74 = (1.0 - v72) * (v72 * (v72 * 3.0));
      v65 = v65 + v74 * v73;
      v66 = v66 + v73 * v74;
      v67 = v67 + v74 * v74;
      --v69;
    }
    while (v69);
  }
  v75 = v64 * v67 - v65 * v66;
  if (fabs(v75) < 0.000001)
    goto LABEL_69;
  v76 = -v66;
  v77 = v67 / v75;
  v78 = -v65 / v75;
  v79 = v33;
  *v42 = v33;
  v80 = v32;
  *v43 = v32;
  v81 = v35;
  v42[v63] = v35;
  v82 = v34;
  v43[v63] = v34;
  v83 = v76 / v75;
  v84 = 0.0;
  v85 = 0.0;
  v86 = v64 / v75;
  v87 = 0.0;
  if ((int)v44 >= 3)
  {
    v88 = 1;
    do
    {
      v89 = v40[v88];
      v41[v88] = v42[v88] + (1.0 - v89) * -((1.0 - v89) * (1.0 - v89)) * *v42 + v89 * -(v89 * v89) * v42[v63];
      ++v88;
    }
    while ((v44 - 1) != v88);
    v90 = v41 + 1;
    v91 = v40 + 1;
    v92 = (v44 - 1) - 1;
    v87 = 0.0;
    v85 = 0.0;
    do
    {
      v93 = *v91++;
      v94 = v93;
      v95 = v93 * 3.0;
      v96 = 1.0 - v93;
      v97 = v93 * 3.0 * (1.0 - v93);
      v98 = *v90++;
      v85 = v85 + v96 * v97 * v98;
      v87 = v87 + v96 * (v94 * v95) * v98;
      --v92;
    }
    while (v92);
  }
  v99 = v78 * v87 + v77 * v85;
  v100 = v86 * v87 + v83 * v85;
  v101 = 0.0;
  if ((int)v44 >= 3)
  {
    v102 = 1;
    do
    {
      v103 = v40[v102];
      v41[v102] = v43[v102] + (1.0 - v103) * -((1.0 - v103) * (1.0 - v103)) * *v43 + v103 * -(v103 * v103) * v43[v63];
      ++v102;
    }
    while ((v44 - 1) != v102);
    v104 = v41 + 1;
    v105 = v40 + 1;
    v106 = (v44 - 1) - 1;
    v101 = 0.0;
    v84 = 0.0;
    do
    {
      v107 = *v105++;
      v108 = v107;
      v109 = v107 * 3.0;
      v110 = 1.0 - v107;
      v111 = v107 * 3.0 * (1.0 - v107);
      v112 = *v104++;
      v84 = v84 + v110 * v111 * v112;
      v101 = v101 + v110 * (v108 * v109) * v112;
      --v106;
    }
    while (v106);
  }
  v218 = v32;
  v113 = v99;
  v114 = v100;
  v115 = v78 * v101 + v77 * v84;
  v116 = v86 * v101 + v83 * v84;
  v117 = 0.0;
  if ((int)v44 >= 3)
  {
    v118 = v43 + 1;
    v119 = v42 + 1;
    v120 = v40 + 1;
    v121 = (v44 - 1) - 1;
    do
    {
      v122 = *v120++;
      v123 = v122;
      v124 = 1.0 - v122;
      v125 = (1.0 - v122) * (v122 * 3.0 * (1.0 - v122));
      v126 = (1.0 - v122) * (v122 * (v122 * 3.0));
      v127 = v126 * v114 + v125 * v113;
      v128 = *v119++;
      v129 = v124 * -(v124 * v124);
      *(float *)&v126 = v126 * v116 + v125 * v115;
      v130 = v123 * -(v123 * v123);
      v131 = v127 - (v128 + v129 * *v42 + v130 * v42[v63]);
      v132 = *v118++;
      v133 = v132 + v129 * *v43 + v130 * v43[v63];
      *(float *)&v129 = v131;
      *(float *)&v133 = *(float *)&v126 - v133;
      v117 = v117 + (float)((float)(*(float *)&v133 * *(float *)&v133) + (float)(*(float *)&v129 * *(float *)&v129));
      --v121;
    }
    while (v121);
  }
  if (v117 >= (float)(a3 * a3))
  {
LABEL_69:
    free(v40);
    free(v41);
    free(v42);
    free(v43);
  }
  else
  {
    a2[2] = (float)(v113 - v33) * 3.0;
    a2[3] = (float)(v115 - v218) * 3.0;
    a2[4] = (float)(v114 - v35) * -3.0;
    a2[5] = (float)(v116 - v34) * -3.0;
    *a2 = v35;
    a2[1] = v34;
    v134 = 0.0;
    v135 = 0.0;
    v136 = 0.0;
    v137 = 0.0;
    v219 = v33;
    if ((int)v44 >= 3)
    {
      v214 = v80;
      v215 = v33;
      v216 = v44;
      v217 = a2;
      v138 = v40 + 1;
      v139 = *v40;
      v140 = v43 + 1;
      v141 = v42 + 1;
      v142 = (v44 - 1) - 1;
      v143 = v142;
      do
      {
        v144 = *v141++;
        v145 = v144;
        v146 = *v140++;
        v147 = v146;
        v148 = *v138;
        v149 = v115;
        v150 = v116;
        v151 = v113;
        v152 = Path::RaffineTk(v145, v147, v219, v218, v113, v115, v114, v116, v35, v34, v148);
        v113 = v151;
        v116 = v150;
        v115 = v149;
        v153 = v152;
        if (v139 <= v153)
          v139 = v153;
        *v138++ = v139;
        --v143;
      }
      while (v143);
      v154 = v40 + 1;
      v137 = 0.0;
      v136 = 0.0;
      v135 = 0.0;
      v134 = 0.0;
      LODWORD(v44) = v216;
      a2 = v217;
      v79 = v215;
      v81 = v35;
      v80 = v214;
      v82 = v34;
      do
      {
        v155 = *v154++;
        v156 = (1.0 - v155) * (v155 * 3.0 * (1.0 - v155));
        v134 = v134 + v156 * v156;
        v157 = (1.0 - v155) * (v155 * (v155 * 3.0));
        v135 = v135 + v157 * v156;
        v136 = v136 + v156 * v157;
        v137 = v137 + v157 * v157;
        --v142;
      }
      while (v142);
    }
    v158 = v134 * v137 - v135 * v136;
    if (fabs(v158) < 0.000001)
    {
      free(v40);
      free(v41);
      free(v42);
      free(v43);
      return 1;
    }
    v159 = -v136;
    v160 = v137 / v158;
    v161 = -v135 / v158;
    *v42 = v79;
    *v43 = v80;
    v42[v63] = v81;
    v43[v63] = v82;
    v162 = v159 / v158;
    v163 = 0.0;
    v164 = 0.0;
    v165 = 0.0;
    v166 = v134 / v158;
    if ((int)v44 >= 3)
    {
      v167 = 1;
      do
      {
        v168 = v40[v167];
        v41[v167] = v42[v167] + (1.0 - v168) * -((1.0 - v168) * (1.0 - v168)) * *v42 + v168 * -(v168 * v168) * v42[v63];
        ++v167;
      }
      while (v63 != v167);
      v169 = v41 + 1;
      v170 = v40 + 1;
      v171 = v63 - 1;
      v165 = 0.0;
      v164 = 0.0;
      do
      {
        v172 = *v170++;
        v173 = v172;
        v174 = v172 * 3.0;
        v175 = 1.0 - v172;
        v176 = v172 * 3.0 * (1.0 - v172);
        v177 = *v169++;
        v164 = v164 + v175 * v176 * v177;
        v165 = v165 + v175 * (v173 * v174) * v177;
        --v171;
      }
      while (v171);
    }
    v178 = v161 * v165 + v160 * v164;
    v179 = v166 * v165 + v162 * v164;
    v180 = 0.0;
    if ((int)v44 >= 3)
    {
      v181 = 1;
      do
      {
        v182 = v40[v181];
        v41[v181] = v43[v181] + (1.0 - v182) * -((1.0 - v182) * (1.0 - v182)) * *v43 + v182 * -(v182 * v182) * v43[v63];
        ++v181;
      }
      while (v63 != v181);
      v183 = v41 + 1;
      v184 = v40 + 1;
      v185 = v63 - 1;
      v180 = 0.0;
      v163 = 0.0;
      do
      {
        v186 = *v184++;
        v187 = v186;
        v188 = v186 * 3.0;
        v189 = 1.0 - v186;
        v190 = v186 * 3.0 * (1.0 - v186);
        v191 = *v183++;
        v163 = v163 + v189 * v190 * v191;
        v180 = v180 + v189 * (v187 * v188) * v191;
        --v185;
      }
      while (v185);
    }
    v192 = v178;
    v193 = v179;
    v194 = v161 * v180 + v160 * v163;
    v195 = v166 * v180 + v162 * v163;
    v196 = 0.0;
    if ((int)v44 >= 3)
    {
      v197 = v43 + 1;
      v198 = v42 + 1;
      v199 = v40 + 1;
      v200 = v63 - 1;
      v201 = 0.0;
      do
      {
        v202 = *v199++;
        v203 = v202;
        v204 = 1.0 - v202;
        v205 = (1.0 - v202) * (v202 * 3.0 * (1.0 - v202));
        v206 = (1.0 - v202) * (v202 * (v202 * 3.0));
        v207 = v206 * v193 + v205 * v192;
        v208 = *v198++;
        v209 = v204 * -(v204 * v204);
        *(float *)&v206 = v206 * v195 + v205 * v194;
        v210 = v203 * -(v203 * v203);
        v211 = v207 - (v208 + v209 * *v42 + v210 * v42[v63]);
        v212 = *v197++;
        v213 = v212 + v209 * *v43 + v210 * v43[v63];
        *(float *)&v209 = v211;
        *(float *)&v213 = *(float *)&v206 - v213;
        v201 = v201 + (float)((float)(*(float *)&v213 * *(float *)&v213) + (float)(*(float *)&v209 * *(float *)&v209));
        --v200;
      }
      while (v200);
      v196 = v201;
    }
    free(v40);
    free(v41);
    free(v42);
    free(v43);
    if (v117 + 0.00001 > v196)
    {
      a2[2] = (float)(v192 - v219) * 3.0;
      a2[3] = (float)(v194 - v218) * 3.0;
      a2[4] = (float)(v193 - v35) * -3.0;
      a2[5] = (float)(v195 - v34) * -3.0;
      *a2 = v35;
      a2[1] = v34;
      return 1;
    }
  }
  return 0;
}

float Path::RaffineTk(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11)
{
  float result;
  double v21;
  double v22;
  double v23;
  double v24;
  float v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;

  result = a11;
  v21 = 1.0 - a11;
  v22 = v21 * (v21 * v21);
  v23 = v21 * (v21 * (float)(a11 * 3.0));
  v24 = v21 * (float)((float)(a11 * 3.0) * a11);
  v25 = (float)(result * result) * result;
  v26 = a1 - a3 * v22 - a5 * v23 - a7 * v24 - (float)(a9 * v25);
  v27 = v21 * (float)(result + result);
  v28 = v27 * (float)(a7 - a5) + (float)(a5 - a3) * (v21 * v21) + (float)((float)(a9 - a7) * (float)(result * result));
  v29 = (float)((float)(a5 + (float)(a9 + (float)(a7 * -2.0))) * a11)
      + (float)((float)(a3 + (float)(a5 * -2.0)) + a7) * v21;
  v30 = a2 - a4 * v22 - a6 * v23 - a8 * v24 - (float)(a10 * v25);
  v31 = v27 * (float)(a8 - a6) + (float)(a6 - a4) * (v21 * v21) + (float)((float)(a10 - a8) * (float)(result * result));
  v32 = (((float)((float)(a6 + (float)(a10 + (float)(a8 * -2.0))) * a11)
        + (float)((float)(a4 + (float)(a6 * -2.0)) + a8) * v21)
       * v30
       + v26 * v29)
      * -12.0
      + (v31 * v31 + v28 * v28) * 18.0;
  if (fabs(v32) > 0.0000001)
    return (v31 * v30 + v26 * v28) * 6.0 / v32 + a11;
  return result;
}

void Path::Coalesce(Path *this, float a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int var0;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  float v19;
  path_descr *var3;
  char *v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  char *var11;
  uint64_t v28;
  int *v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int128 *v39;
  _OWORD *v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  int v46;
  char *v47;
  path_descr *v48;
  char *v49;
  __int128 *v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  int v57;
  uint64_t v58;
  path_descr *v59;
  char *v60;
  char *v61;
  _OWORD *v62;
  __int128 v63;
  __int128 v64;
  char *v65;
  char *v66;
  float v67;
  int var8;
  uint64_t v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;

  var0 = this->var0;
  if ((this->var0 & 1) != 0)
  {
    Path::CancelBezier(this);
    var0 = this->var0;
  }
  if ((var0 & 2) != 0)
    Path::CloseSubpath(this, 0);
  if (this->var2 >= 3)
  {
    Path::SetWeighted(this, 0);
    Path::SetBackData(this, 0);
    Path::ConvertEvenLines(this, a2);
    if (this->var2 < 1)
    {
      v17 = 0;
    }
    else
    {
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v18 = *((unsigned int *)this->var3 + 1);
      v19 = a2 * 0.1;
      v67 = v19;
      do
      {
        var3 = this->var3;
        v21 = (char *)var3 + 44 * v13;
        v22 = *(_DWORD *)v21;
        switch(*(_DWORD *)v21 & 0xF)
        {
          case 0:
            if (v14)
            {
              v30 = (char *)var3 + 44 * v17++;
              *(_DWORD *)v30 = v14;
              *((_DWORD *)v30 + 1) = v15;
              *((_QWORD *)v30 + 1) = v12;
              *((_DWORD *)v30 + 4) = v2;
              *((_DWORD *)v30 + 5) = v3;
              *((_DWORD *)v30 + 6) = v5;
              *((_DWORD *)v30 + 7) = v6;
              *((_DWORD *)v30 + 8) = v7;
              *((_DWORD *)v30 + 9) = v8;
              *((_DWORD *)v30 + 10) = v4;
              var3 = this->var3;
              v22 = *((_DWORD *)var3 + 11 * v13);
            }
            v31 = (char *)var3 + 44 * v13;
            v15 = *((unsigned int *)v31 + 1);
            v12 = *((_QWORD *)v31 + 1);
            v2 = *((_DWORD *)v31 + 4);
            v3 = *((_DWORD *)v31 + 5);
            v5 = *((_DWORD *)v31 + 6);
            v6 = *((_DWORD *)v31 + 7);
            v7 = *((_DWORD *)v31 + 8);
            v8 = *((_DWORD *)v31 + 9);
            v4 = *((_DWORD *)v31 + 10);
            v32 = (char *)var3 + 44 * v17++;
            *(_DWORD *)v32 = v22;
            *((_DWORD *)v32 + 1) = v15;
            *((_QWORD *)v32 + 1) = v12;
            *((_DWORD *)v32 + 4) = v2;
            *((_DWORD *)v32 + 5) = v3;
            *((_DWORD *)v32 + 6) = v5;
            *((_DWORD *)v32 + 7) = v6;
            *((_DWORD *)v32 + 8) = v7;
            *((_DWORD *)v32 + 9) = v8;
            *((_DWORD *)v32 + 10) = v4;
            v18 = *((unsigned int *)this->var3 + 11 * v13 + 1);
            v16 = v13;
            goto LABEL_16;
          case 1:
          case 2:
          case 4:
            if (v14)
            {
              v23 = v16;
              v24 = v12;
              v25 = v15;
              v26 = *((_DWORD *)var3 + 11 * v13 + 1);
              var11 = this->var11;
              var8 = this->var8;
              this->var11 = &var11[12 * (int)v18];
              this->var8 = v26 - v18 + 1;
              v28 = v18;
              if (Path::AttemptSimplify((uint64_t)this, (float *)&v71, a2))
              {
                v3 = v72;
                v5 = v73;
                v6 = v74;
                v7 = v75;
                v14 = 2;
                v29 = &v71;
                v15 = v28;
                v8 = v76;
                v12 = v24;
                v18 = v28;
              }
              else
              {
                v59 = this->var3;
                v18 = *((unsigned int *)v59 + 11 * v23 + 1);
                v60 = (char *)v59 + 44 * v17++;
                *(_DWORD *)v60 = v14;
                *((_DWORD *)v60 + 1) = v25;
                *((_QWORD *)v60 + 1) = v24;
                *((_DWORD *)v60 + 4) = v2;
                *((_DWORD *)v60 + 5) = v3;
                *((_DWORD *)v60 + 6) = v5;
                *((_DWORD *)v60 + 7) = v6;
                *((_DWORD *)v60 + 8) = v7;
                *((_DWORD *)v60 + 9) = v8;
                *((_DWORD *)v60 + 10) = v4;
                v61 = (char *)this->var3 + 44 * v13;
                v14 = *(_DWORD *)v61;
                v15 = *((unsigned int *)v61 + 1);
                v12 = *((_QWORD *)v61 + 1);
                v29 = (int *)(v61 + 16);
                v3 = *((_DWORD *)v61 + 5);
                v5 = *((_DWORD *)v61 + 6);
                v6 = *((_DWORD *)v61 + 7);
                v7 = *((_DWORD *)v61 + 8);
                v8 = *((_DWORD *)v61 + 9);
                v4 = *((_DWORD *)v61 + 10);
              }
              v2 = *v29;
              this->var11 = var11;
              v16 = v13;
              this->var8 = var8;
            }
            else
            {
              v18 = *((unsigned int *)var3 + 11 * v13 - 10);
              v15 = *((unsigned int *)v21 + 1);
              v12 = *((_QWORD *)v21 + 1);
              v2 = *((_DWORD *)v21 + 4);
              v3 = *((_DWORD *)v21 + 5);
              v5 = *((_DWORD *)v21 + 6);
              v6 = *((_DWORD *)v21 + 7);
              v7 = *((_DWORD *)v21 + 8);
              v8 = *((_DWORD *)v21 + 9);
              v4 = *((_DWORD *)v21 + 10);
LABEL_16:
              v14 = v22;
            }
            break;
          case 3:
            if (v14)
            {
              v33 = (char *)var3 + 44 * v17++;
              *(_DWORD *)v33 = v14;
              *((_DWORD *)v33 + 1) = v15;
              *((_QWORD *)v33 + 1) = v12;
              *((_DWORD *)v33 + 4) = v2;
              *((_DWORD *)v33 + 5) = v3;
              *((_DWORD *)v33 + 6) = v5;
              *((_DWORD *)v33 + 7) = v6;
              *((_DWORD *)v33 + 8) = v7;
              *((_DWORD *)v33 + 9) = v8;
              *((_DWORD *)v33 + 10) = v4;
              var3 = this->var3;
            }
            v34 = (char *)var3 + 44 * v13;
            v18 = *((unsigned int *)v34 + 1);
            LODWORD(v35) = *((_DWORD *)v34 + 4);
            if ((int)v35 >= 1)
            {
              v36 = 0;
              v37 = 44 * v17;
              v38 = 44 * v13 + 44;
              do
              {
                v39 = (__int128 *)((char *)var3 + v38);
                v40 = (_OWORD *)((char *)var3 + v37);
                v41 = *v39;
                v42 = v39[1];
                *(_OWORD *)((char *)v40 + 28) = *(__int128 *)((char *)v39 + 28);
                *v40 = v41;
                v40[1] = v42;
                var3 = this->var3;
                v35 = *((int *)var3 + 11 * v13 + 4);
                v37 += 44;
                ++v36;
                v38 += 44;
              }
              while (v36 < v35);
              v17 += v36;
            }
            v14 = 0;
            v16 = v13;
            v13 += v35;
            break;
          case 5:
            v43 = *((unsigned int *)var3 + 11 * v13 + 1);
            if (v14)
            {
              v69 = v12;
              v44 = v15;
              v45 = this->var11;
              v46 = this->var8;
              this->var11 = &v45[12 * (int)v18];
              this->var8 = v43 - v18 + 1;
              if (Path::AttemptSimplify((uint64_t)this, (float *)&v71, a2))
              {
                v2 = v71;
                v3 = v72;
                v5 = v73;
                v6 = v74;
                v14 = 2;
                v7 = v75;
                v8 = v76;
              }
              v47 = (char *)this->var3 + 44 * v17;
              *(_DWORD *)v47 = v14;
              *((_DWORD *)v47 + 1) = v44;
              v15 = v44;
              v12 = v69;
              *((_QWORD *)v47 + 1) = v69;
              *((_DWORD *)v47 + 4) = v2;
              *((_DWORD *)v47 + 5) = v3;
              *((_DWORD *)v47 + 6) = v5;
              *((_DWORD *)v47 + 7) = v6;
              *((_DWORD *)v47 + 8) = v7;
              *((_DWORD *)v47 + 9) = v8;
              *((_DWORD *)v47 + 10) = v4;
              v48 = this->var3;
              v49 = (char *)v48 + 44 * v17++;
              v50 = (__int128 *)((char *)v48 + 44 * v13);
              v51 = *v50;
              v52 = v50[1];
              *(_OWORD *)(v49 + 72) = *(__int128 *)((char *)v50 + 28);
              *(_OWORD *)(v49 + 60) = v52;
              *(_OWORD *)(v49 + 44) = v51;
              this->var11 = v45;
              this->var8 = v46;
            }
            else
            {
              v62 = (_OWORD *)((char *)var3 + 44 * v17);
              v63 = *(_OWORD *)v21;
              v64 = *((_OWORD *)v21 + 1);
              *(_OWORD *)((char *)v62 + 28) = *(_OWORD *)(v21 + 28);
              *v62 = v63;
              v62[1] = v64;
            }
            v14 = 0;
            ++v17;
            v18 = v43;
            v16 = v13;
            break;
          case 7:
            if (v14)
            {
              v70 = v16;
              v53 = v12;
              v54 = v15;
              v55 = *((unsigned int *)var3 + 11 * v13 + 1);
              v56 = this->var11;
              v57 = this->var8;
              this->var11 = &v56[12 * (int)v18];
              this->var8 = v55 - v18 + 1;
              v58 = v18;
              if ((Path::AttemptSimplify((uint64_t)this, (float *)&v71, v67) & 1) != 0)
              {
                v15 = v54;
                v12 = v53;
                v18 = v58;
                v16 = v70;
              }
              else
              {
                v65 = (char *)this->var3 + 44 * v17++;
                *(_DWORD *)v65 = v14;
                *((_DWORD *)v65 + 1) = v54;
                v15 = v54;
                v12 = v53;
                *((_QWORD *)v65 + 1) = v53;
                *((_DWORD *)v65 + 4) = v2;
                *((_DWORD *)v65 + 5) = v3;
                *((_DWORD *)v65 + 6) = v5;
                *((_DWORD *)v65 + 7) = v6;
                *((_DWORD *)v65 + 8) = v7;
                *((_DWORD *)v65 + 9) = v8;
                *((_DWORD *)v65 + 10) = v4;
                v18 = v55;
                v16 = v13;
                v14 = 0;
              }
              this->var11 = v56;
              this->var8 = v57;
            }
            break;
          default:
            break;
        }
        ++v13;
      }
      while (v13 < this->var2);
      if (v14)
      {
        v66 = (char *)this->var3 + 44 * v17++;
        *(_DWORD *)v66 = v14;
        *((_DWORD *)v66 + 1) = v15;
        *((_QWORD *)v66 + 1) = v12;
        *((_DWORD *)v66 + 4) = v2;
        *((_DWORD *)v66 + 5) = v3;
        *((_DWORD *)v66 + 6) = v5;
        *((_DWORD *)v66 + 7) = v6;
        *((_DWORD *)v66 + 8) = v7;
        *((_DWORD *)v66 + 9) = v8;
        *((_DWORD *)v66 + 10) = v4;
      }
    }
    this->var2 = v17;
  }
}

void Path::Stroke(uint64_t a1, void **this, int a3, int a4, int a5, char a6, float a7, float a8)
{
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int *v22;
  int v23;
  uint64_t v24;
  int *v25;
  int v26;
  uint64_t v27;
  int *v28;
  int v29;
  uint64_t v30;
  int *v31;
  int v32;
  uint64_t v33;

  if (this)
  {
    if ((a6 & 1) == 0)
      Shape::Reset(this, 3 * *(_DWORD *)(a1 + 36));
    if (*(int *)(a1 + 36) >= 2)
    {
      Shape::MakeBackData((Shape *)this, 0);
      v17 = *(_QWORD *)(a1 + 48);
      v18 = *(unsigned int *)(a1 + 36);
      if ((int)v18 >= 1)
      {
        v19 = 0;
        do
        {
          v20 = v19 + 1;
          if (*(_BYTE *)(a1 + 33))
          {
            if (*(_BYTE *)(a1 + 32))
            {
              if (v20 < (int)v18)
              {
                v21 = v20;
                v22 = (int *)(v17 + 24 * v20);
                while (1)
                {
                  v23 = *v22;
                  v22 += 6;
                  if ((v23 | 2) != 2)
                    break;
                  if (v18 == ++v21)
                  {
                    v20 = v18;
                    goto LABEL_31;
                  }
                }
                v20 = v21;
              }
LABEL_31:
              v33 = v17 + 24 * v19;
            }
            else
            {
              if (v20 < (int)v18)
              {
                v27 = v20;
                v28 = (int *)(v17 + 20 * v20);
                while (1)
                {
                  v29 = *v28;
                  v28 += 5;
                  if ((v29 | 2) != 2)
                    break;
                  if (v18 == ++v27)
                  {
                    v20 = v18;
                    goto LABEL_35;
                  }
                }
                v20 = v27;
              }
LABEL_35:
              v33 = v17 + 20 * v19;
            }
          }
          else if (*(_BYTE *)(a1 + 32))
          {
            if (v20 < (int)v18)
            {
              v24 = v20;
              v25 = (int *)(v17 + 16 * v20);
              while (1)
              {
                v26 = *v25;
                v25 += 4;
                if ((v26 | 2) != 2)
                  break;
                if (v18 == ++v24)
                {
                  v20 = v18;
                  goto LABEL_33;
                }
              }
              v20 = v24;
            }
LABEL_33:
            v33 = v17 + 16 * v19;
          }
          else
          {
            if (v20 < (int)v18)
            {
              v30 = v20;
              v31 = (int *)(v17 + 12 * v20);
              while (1)
              {
                v32 = *v31;
                v31 += 3;
                if ((v32 | 2) != 2)
                  break;
                if (v18 == ++v30)
                {
                  v20 = v18;
                  goto LABEL_37;
                }
              }
              v20 = v30;
            }
LABEL_37:
            v33 = v17 + 12 * v19;
          }
          *(_QWORD *)(a1 + 48) = v33;
          *(_DWORD *)(a1 + 36) = v20 - v19;
          Path::DoStroke(a1, (Shape *)this, a3, a4, a5, a7, a8, 0, v15, v16);
          v19 = v20;
        }
        while (v20 < (int)v18);
      }
      *(_QWORD *)(a1 + 48) = v17;
      *(_DWORD *)(a1 + 36) = v18;
    }
  }
}

uint64_t Path::DoStroke(uint64_t result, Shape *this, int a3, int a4, int a5, float a6, float a7, uint64_t a8, int a9, int a10)
{
  int v10;
  uint64_t v13;
  float *v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  float v19;
  float v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float *v30;
  float v31;
  float v32;
  float v33;
  int v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  int v46;
  int v47;
  int v48;
  int v49;
  float v50;
  float v51;
  float v52;
  unsigned int v53;
  unsigned int v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  float v60;
  float v61;
  float v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  Shape *v78;
  unsigned int v79;
  unsigned int v84;
  unsigned int v85;
  int v86[2];
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  int v90;

  v10 = *(_DWORD *)(result + 36);
  if (v10 >= 2)
  {
    v13 = result;
    v14 = *(float **)(result + 48);
    if (*(_BYTE *)(result + 32))
      v15 = v14[3];
    else
      v15 = 1.0;
    v16 = v14[1];
    v17 = v14[2];
    v18 = (v10 - 1);
    v19 = v16;
    v20 = v17;
    if (a3)
    {
      v21 = 12 * v18;
      if (*(_BYTE *)(result + 32))
        v21 = 16 * v18;
      v22 = 24 * v18;
      if (!*(_BYTE *)(result + 32))
        v22 = 20 * v18;
      if (*(_BYTE *)(result + 33))
        v21 = v22;
      v23 = -24;
      if (!*(_BYTE *)(result + 32))
        v23 = -20;
      v24 = -16;
      if (!*(_BYTE *)(result + 32))
        v24 = -12;
      if (!*(_BYTE *)(result + 33))
        v23 = v24;
      v25 = (float *)((char *)v14 + v21 + 8);
      while (1)
      {
        v19 = *(v25 - 1);
        v20 = *v25;
        if ((float)((float)((float)(v17 - *v25) * (float)(v17 - *v25))
                   + (float)((float)(v16 - v19) * (float)(v16 - v19))) > 0.001)
          break;
        --v10;
        v25 = (float *)((char *)v25 + v23);
        if (v10 <= 1)
          return result;
      }
      LODWORD(v18) = v10 - 1;
    }
    v26 = 0;
    v27 = 24;
    if (!*(_BYTE *)(result + 32))
      v27 = 20;
    v28 = 16;
    if (!*(_BYTE *)(result + 32))
      v28 = 12;
    if (*(_BYTE *)(result + 33))
      v29 = v27;
    else
      v29 = v28;
    v30 = (float *)((char *)v14 + v29 + 12);
    while (1)
    {
      v31 = *(_BYTE *)(result + 32) ? *v30 : 1.0;
      v32 = *(v30 - 2);
      v33 = *(v30 - 1);
      if ((float)((float)((float)(v17 - v33) * (float)(v17 - v33)) + (float)((float)(v16 - v32) * (float)(v16 - v32))) > 0.001)
        break;
      ++v26;
      v30 = (float *)((char *)v30 + v29);
      if ((_DWORD)v18 == v26)
      {
        v34 = v18 + 1;
        goto LABEL_38;
      }
    }
    v34 = v26 + 1;
LABEL_38:
    if (v34 <= (int)v18)
    {
      v89 = -1;
      v90 = -1;
      v87 = -1;
      v88 = -1;
      v35 = v16 - v19;
      v36 = v17 - v20;
      v37 = v32 - v16;
      v38 = v33 - v17;
      v39 = (float)(v36 * v36) + (float)(v35 * v35);
      v40 = sqrtf(v39);
      v41 = (float)(v38 * v38) + (float)(v37 * v37);
      if (v39 > 0.0001)
      {
        v35 = v35 / v40;
        v36 = v36 / v40;
      }
      v42 = sqrtf(v41);
      if (v41 > 0.0001)
      {
        v37 = v37 / v42;
        v38 = v38 / v42;
      }
      v43 = v37;
      v44 = v38;
      v45 = v31;
      v46 = LODWORD(v42);
      if (a3)
        Path::DoJoin(this, a4, (unsigned int *)&v90, &v88, &v89, &v87, a9, a10, v15 * a6, v16, v17, v35, v36, v37, v38, a7, SLODWORD(v40), SLODWORD(v42));
      else
        Path::DoButt(this, a5, &v87, &v88, v15 * a6, v16, v17, -v37, -v38);
      v49 = v46;
      v50 = v45;
      v51 = v44;
      v52 = v43;
      v53 = v87;
      v54 = v88;
      while (1)
      {
        v55 = v34 + 1;
        v56 = *(_QWORD *)(v13 + 48);
        if (*(_BYTE *)(v13 + 33))
        {
          v57 = 20 * v55;
          v58 = 24 * v55;
        }
        else
        {
          v57 = 12 * v55;
          v58 = 16 * v55;
        }
        if (*(_BYTE *)(v13 + 32))
        {
          v59 = 0;
        }
        else
        {
          v58 = v57;
          v59 = 1;
        }
        v60 = v50;
        v61 = v32;
        v62 = v33;
        if (v34 < (int)v18)
        {
          v63 = 24;
          if (v59)
            v63 = 20;
          v64 = 16;
          if (v59)
            v64 = 12;
          if (*(_BYTE *)(v13 + 33))
            v65 = v63;
          else
            v65 = v64;
          v66 = v56 + v58 + 8;
          while (1)
          {
            v60 = 1.0;
            if ((v59 & 1) == 0)
              v60 = *(float *)(v66 + 4);
            v61 = *(float *)(v66 - 4);
            v62 = *(float *)v66;
            if ((float)((float)((float)(v33 - *(float *)v66) * (float)(v33 - *(float *)v66))
                       + (float)((float)(v32 - v61) * (float)(v32 - v61))) > 0.001)
              break;
            ++v34;
            v66 += v65;
            if ((_DWORD)v18 == v34)
            {
              v55 = v18 + 1;
              goto LABEL_68;
            }
          }
          v55 = v34 + 1;
        }
LABEL_68:
        if (v55 > (int)v18)
          break;
        v67 = v61 - v32;
        v68 = v62 - v33;
        v69 = (float)(v68 * v68) + (float)(v67 * v67);
        v70 = sqrtf(v69);
        if (v69 > 0.0001)
        {
          v67 = v67 / v70;
          v68 = v68 / v70;
        }
        v86[0] = -1;
        v86[1] = -1;
        v84 = -1;
        v85 = -1;
        Path::DoJoin(this, a4, (unsigned int *)&v86[1], &v85, (unsigned int *)v86, &v84, v47, v48, v50 * a6, v32, v33, v52, v51, v67, v68, a7, v49, SLODWORD(v70));
        Shape::AddEdge(this, v86[1], v54);
        v54 = v85;
        Shape::AddEdge(this, v53, v86[0]);
        v49 = LODWORD(v70);
        v52 = v67;
        v53 = v84;
        v51 = v68;
        v34 = v55;
        v50 = v60;
        v32 = v61;
        v33 = v62;
      }
      if (a3)
      {
        v71 = *(float *)(v56 + 4) - v32;
        v72 = *(float *)(v56 + 8) - v33;
        v73 = (float)(v72 * v72) + (float)(v71 * v71);
        v74 = sqrtf(v73);
        if (v73 > 0.0001)
        {
          v71 = v71 / v74;
          v72 = v72 / v74;
        }
        v86[0] = -1;
        v86[1] = -1;
        v84 = -1;
        v85 = -1;
        Path::DoJoin(this, a4, (unsigned int *)&v86[1], &v85, (unsigned int *)v86, &v84, v47, v48, v50 * a6, v32, v33, v52, v51, v71, v72, a7, v49, SLODWORD(v74));
        Shape::AddEdge(this, v86[1], v54);
        v75 = v85;
        Shape::AddEdge(this, v53, v86[0]);
        v76 = v84;
        Shape::AddEdge(this, v90, v75);
        v77 = v89;
        v78 = this;
        v79 = v76;
      }
      else
      {
        *(_QWORD *)v86 = 0;
        Path::DoButt(this, a5, (unsigned int *)v86, (unsigned int *)&v86[1], v50 * a6, v32, v33, v52, v51);
        Shape::AddEdge(this, v86[0], v54);
        v77 = v86[1];
        v78 = this;
        v79 = v53;
      }
      return Shape::AddEdge(v78, v79, v77);
    }
  }
  return result;
}

uint64_t Path::DoJoin(Shape *this, int a2, unsigned int *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6, int a7, int a8, float a9, float a10, float a11, float a12, float a13, float a14, float a15, float a16, int a17, int a18)
{
  float v31;
  float v32;
  double v33;
  unsigned int v34;
  float v35;
  float v36;
  uint64_t result;
  float v38;
  float v39;
  float v40;
  double v41;
  float v42;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  float v48;
  unsigned int v50;
  unsigned int v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  uint64_t v78;
  float v79;
  Path *v80;
  Shape *v81;
  float v82;
  float v83;
  float v84;
  float v85;
  unsigned int v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  unsigned int v97;
  unsigned int v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  uint64_t v109;
  Shape *v110;
  float v111;
  float v112;
  unsigned int v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v121;
  float v122;
  float v123;

  v31 = -a12;
  v32 = (float)(a12 * a15) - (float)(a13 * a14);
  if (v32 > -0.0001 && v32 < 0.0001)
  {
    v33 = (float)((float)(a13 * a15) + (float)(a12 * a14));
    v34 = Shape::AddPoint(this, a10 + (float)(a9 * a13), a11 + (float)(a9 * v31));
    v35 = a10 - (float)(a9 * a13);
    v36 = a11 + (float)(a9 * a12);
    if (v33 > 0.9999)
    {
      *a4 = v34;
      *a3 = v34;
      result = Shape::AddPoint(this, v35, v36);
      *a6 = result;
      *a5 = result;
      return result;
    }
    *a6 = v34;
    *a3 = v34;
    v45 = Shape::AddPoint(this, v35, v36);
    *a4 = v45;
    *a5 = v45;
    Shape::AddEdge(this, *a4, *a3);
    v46 = *a5;
    v47 = *a6;
    goto LABEL_45;
  }
  v38 = a14 - a12;
  v39 = a15 - a13;
  v40 = (float)(a13 * (float)(a15 - a13)) + (float)((float)(a14 - a12) * a12);
  v41 = *(float *)&a17 * 0.5;
  v123 = -a14;
  if (v32 >= 0.0)
  {
    v48 = a9 / (float)((float)(a14 * v39) - (float)(a15 * v38));
    if (v41 < (float)-(float)(v48 * v40)
      || *(float *)&a18 * 0.5 < (float)((float)((float)(a15 * v39) + (float)(v38 * a14)) * v48))
    {
      *a5 = Shape::AddPoint(this, a10 - (float)(a9 * a13), a11 + (float)(a9 * a12));
      v50 = Shape::AddPoint(this, a10 - (float)(a9 * a15), a11 + (float)(a9 * a14));
      *a6 = v50;
      Shape::AddEdge(this, *a5, v50);
    }
    else
    {
      v86 = Shape::AddPoint(this, a10 + (float)(v48 * v38), a11 + (float)(v48 * v39));
      *a5 = v86;
      *a6 = v86;
    }
    if (a2 != 1)
    {
      if (a2 == 2)
      {
        *a3 = Shape::AddPoint(this, a10 + (float)(a9 * a13), a11 + (float)(a9 * v31));
        *a4 = Shape::AddPoint(this, a10 + (float)(a9 * a15), a11 + (float)(a9 * v123));
        v87 = a13 + a15;
        v88 = v123 - a12;
        v89 = (float)(v88 * v88) + (float)(v87 * v87);
        if (v89 > 0.0001)
        {
          v90 = sqrtf(v89);
          v87 = v87 / v90;
          v88 = v88 / v90;
        }
        v91 = (float)(v88 * v123) + (float)(v87 * a15);
        v92 = a9 / v91;
        v93 = v91 * a9;
        if ((float)(v91 * a9) < a16)
          v93 = a16;
        if (v92 <= v93)
        {
          v98 = Shape::AddPoint(this, a10 + (float)(v92 * v87), a11 + (float)(v92 * v88));
          v97 = v98;
        }
        else
        {
          v94 = (float)(v91 * (float)(v92 - v93)) / (float)((float)(v87 * v123) - (float)(v88 * a15));
          v95 = a10 + (float)(v93 * v87);
          v96 = a11 + (float)(v93 * v88);
          v97 = Shape::AddPoint(this, v95 + (float)(v94 * v88), v96 - (float)(v94 * v87));
          v98 = Shape::AddPoint(this, v95 - (float)(v94 * v88), v96 + (float)(v94 * v87));
        }
        v113 = v98;
        Shape::AddEdge(this, *a4, v98);
        Shape::AddEdge(this, v113, v97);
        v47 = *a3;
        v110 = this;
        v46 = v97;
        return Shape::AddEdge(v110, v46, v47);
      }
      *a3 = Shape::AddPoint(this, a10 + (float)(a9 * a13), a11 + (float)(a9 * v31));
      v46 = Shape::AddPoint(this, a10 + (float)(a9 * a15), a11 + (float)(a9 * v123));
      *a4 = v46;
      v47 = *a3;
      goto LABEL_45;
    }
    v115 = a11 + (float)(a9 * v31);
    v117 = a10 + (float)(a9 * a13);
    *a3 = Shape::AddPoint(this, v117, v115);
    v119 = a11 + (float)(a9 * v123);
    v122 = a10 + (float)(a9 * a15);
    v81 = (Shape *)Shape::AddPoint(this, v122, v119);
    *a4 = v81;
    v99 = a13 + a15;
    v100 = v123 - a12;
    v101 = (float)(v100 * v100) + (float)(v99 * v99);
    if (v101 > 0.0001)
    {
      v102 = sqrtf(v101);
      v99 = v99 / v102;
      v100 = v100 / v102;
    }
    v103 = (float)(v100 * v123) + (float)(v99 * a15);
    v104 = a9 / v103;
    if ((float)((float)(a12 * a14) + (float)(a13 * a15)) >= 0.0)
    {
      v82 = a10 + (float)(v104 * v99);
      v83 = a11 + (float)(v104 * v100);
      v64 = *a3;
      v79 = 5.0;
      v80 = (Path *)this;
      v85 = a11 + (float)(a9 * v123);
      v84 = a10 + (float)(a9 * a15);
    }
    else
    {
      v105 = (float)(v103 * (float)(v104 - a9)) / (float)((float)(v99 * v123) - (float)(v100 * a15));
      v106 = a10 + (float)(a9 * v99);
      v107 = a11 + (float)(a9 * v100);
      v108 = v99;
      v109 = Shape::AddPoint(this, v106, v107);
      Path::RecRound((Path *)this, (Shape *)*a4, v109, 8, v106 - (float)(v105 * v100), v107 + (float)(v105 * v108), v122, v119, v106, v107, 5.0);
      v64 = *a3;
      v79 = 5.0;
      v80 = (Path *)this;
      v81 = (Shape *)v109;
      v82 = v106 + (float)(v105 * v100);
      v83 = v107 - (float)(v105 * v108);
      v84 = v106;
      v85 = v107;
    }
    v111 = v117;
    v112 = v115;
  }
  else
  {
    v42 = a9 / (float)((float)(v38 * a15) - (float)(v39 * a14));
    if (v41 < (float)-(float)(v42 * v40)
      || *(float *)&a18 * 0.5 < (float)((float)((float)(a15 * v39) + (float)(v38 * a14)) * v42))
    {
      *a3 = Shape::AddPoint(this, a10 + (float)(a9 * a13), a11 + (float)(a9 * v31));
      v44 = Shape::AddPoint(this, a10 + (float)(a9 * a15), a11 + (float)(a9 * (float)-a14));
      *a4 = v44;
      Shape::AddEdge(this, v44, *a3);
    }
    else
    {
      v51 = Shape::AddPoint(this, a10 + (float)(v42 * v38), a11 + (float)(v42 * v39));
      *a3 = v51;
      *a4 = v51;
    }
    if (a2 != 1)
    {
      if (a2 == 2)
      {
        *a5 = Shape::AddPoint(this, a10 - (float)(a9 * a13), a11 + (float)(a9 * a12));
        *a6 = Shape::AddPoint(this, a10 - (float)(a9 * a15), a11 + (float)(a9 * a14));
        v52 = a13 + a15;
        v53 = v123 - a12;
        v54 = (float)(v53 * v53) + (float)(v52 * v52);
        if (v54 > 0.0001)
        {
          v55 = sqrtf(v54);
          v52 = v52 / v55;
          v53 = v53 / v55;
        }
        v56 = (float)(v53 * v123) + (float)(v52 * a15);
        v57 = a9 / v56;
        v58 = v56 * a9;
        if ((float)(v56 * a9) < a16)
          v58 = a16;
        if (v57 <= v58)
        {
          v63 = Shape::AddPoint(this, a10 - (float)(v57 * v52), a11 - (float)(v57 * v53));
          v62 = v63;
        }
        else
        {
          v59 = (float)(v56 * (float)(v57 - v58)) / (float)((float)(v52 * v123) - (float)(v53 * a15));
          v60 = a10 - (float)(v58 * v52);
          v61 = a11 - (float)(v58 * v53);
          v62 = Shape::AddPoint(this, v60 - (float)(v59 * v53), v61 + (float)(v59 * v52));
          v63 = Shape::AddPoint(this, v60 + (float)(v59 * v53), v61 - (float)(v59 * v52));
        }
        Shape::AddEdge(this, *a5, v62);
        Shape::AddEdge(this, v62, v63);
        v47 = *a6;
        v110 = this;
        v46 = v63;
        return Shape::AddEdge(v110, v46, v47);
      }
      *a5 = Shape::AddPoint(this, a10 - (float)(a9 * a13), a11 + (float)(a9 * a12));
      v47 = Shape::AddPoint(this, a10 - (float)(a9 * a15), a11 + (float)(a9 * a14));
      *a6 = v47;
      v46 = *a5;
LABEL_45:
      v110 = this;
      return Shape::AddEdge(v110, v46, v47);
    }
    v116 = a11 + (float)(a9 * a12);
    v118 = a10 - (float)(a9 * a13);
    *a5 = Shape::AddPoint(this, v118, v116);
    v114 = a10 - (float)(a9 * a15);
    v121 = a11 + (float)(a9 * a14);
    v64 = Shape::AddPoint(this, v114, v121);
    *a6 = v64;
    v65 = a13 + a15;
    v66 = v123 - a12;
    v67 = (float)(v66 * v66) + (float)(v65 * v65);
    if (v67 > 0.0001)
    {
      v68 = sqrtf(v67);
      v65 = v65 / v68;
      v66 = v66 / v68;
    }
    v69 = (float)(v66 * v123) + (float)(v65 * a15);
    v70 = a9 / v69;
    if ((float)((float)(a12 * a14) + (float)(a13 * a15)) >= 0.0)
    {
      v82 = a10 - (float)(v70 * v65);
      v83 = a11 - (float)(v70 * v66);
      v81 = (Shape *)*a5;
      v79 = 5.0;
      v80 = (Path *)this;
      v85 = a11 + (float)(a9 * a12);
      v84 = a10 - (float)(a9 * a13);
    }
    else
    {
      v71 = (float)(v69 * (float)(v70 - a9)) / (float)((float)(v65 * v123) - (float)(v66 * a15));
      v72 = a10 + (float)((float)-a9 * v65);
      v73 = v72 - (float)(v71 * v66);
      v74 = a11 + (float)((float)-a9 * v66);
      v75 = v74 + (float)(v71 * v65);
      v76 = v72 + (float)(v71 * v66);
      v77 = v74 - (float)(v71 * v65);
      v78 = Shape::AddPoint(this, v72, v74);
      Path::RecRound((Path *)this, (Shape *)*a5, v78, 8, v73, v75, v118, v116, v72, v74, 5.0);
      v64 = *a6;
      v79 = 5.0;
      v80 = (Path *)this;
      v81 = (Shape *)v78;
      v82 = v76;
      v83 = v77;
      v84 = v72;
      v85 = v74;
    }
    v111 = v114;
    v112 = v121;
  }
  return Path::RecRound(v80, v81, v64, 8, v82, v83, v84, v85, v111, v112, v79);
}

uint64_t Path::DoButt(Shape *this, int a2, unsigned int *a3, unsigned int *a4, float a5, float a6, float a7, float a8, float a9)
{
  float v17;
  float v18;
  float v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  Shape *v23;
  unsigned int v24;
  unsigned int v25;
  Shape *v26;
  unsigned int v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  Shape *v33;
  float v35;

  v17 = -a8;
  switch(a2)
  {
    case 3:
      *a3 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v17));
      *a4 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
      v20 = Shape::AddPoint(this, a6 + (float)(a5 * a8), a7 + (float)(a5 * a9));
      v24 = *a4;
      v23 = this;
      break;
    case 2:
      v35 = a6 + (float)(a5 * a9);
      v28 = a7 + (float)(a5 * v17);
      v29 = a6 - (float)(a5 * a9);
      v30 = a7 + (float)(a5 * a8);
      v31 = a6 + (float)(a5 * a8);
      v32 = a7 + (float)(a5 * a9);
      *a3 = Shape::AddPoint(this, v35, v28);
      *a4 = Shape::AddPoint(this, v29, v30);
      v33 = (Shape *)Shape::AddPoint(this, v31, v32);
      Path::RecRound((Path *)this, (Shape *)*a4, v33, 8, v29 + (float)(a5 * a8), v30 + (float)(a5 * a9), v29, v30, v31, v32, 5.0);
      return Path::RecRound((Path *)this, v33, *a3, 8, v35 + (float)(a5 * a8), v28 + (float)(a5 * a9), v31, v32, v35, v28, 5.0);
    case 1:
      v18 = a6 + (float)(a5 * a8);
      v19 = a7 + (float)(a5 * a9);
      v20 = Shape::AddPoint(this, v18 + (float)(a5 * a9), v19 + (float)(a5 * v17));
      v21 = Shape::AddPoint(this, v18 - (float)(a5 * a9), v19 + (float)(a5 * a8));
      *a3 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v17));
      v22 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
      *a4 = v22;
      Shape::AddEdge(this, v22, v21);
      v23 = this;
      v24 = v21;
      break;
    default:
      *a3 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v17));
      v27 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
      *a4 = v27;
      v25 = *a3;
      v26 = this;
      return Shape::AddEdge(v26, v27, v25);
  }
  Shape::AddEdge(v23, v24, v20);
  v25 = *a3;
  v26 = this;
  v27 = v20;
  return Shape::AddEdge(v26, v27, v25);
}

uint64_t Path::RecRound(Path *this, Shape *a2, unsigned int a3, int a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11)
{
  int v19;
  float v20;
  float v21;
  float v22;
  float v23;
  Shape *v24;
  int v25;
  float v27;
  float v28;

  if (a4 >= 1)
  {
    v19 = a4 + 1;
    v27 = a9;
    v28 = a10;
    while (1)
    {
      v20 = (float)((float)(a7 - a5) * (float)(a10 - a6)) - (float)((float)(a8 - a6) * (float)(a9 - a5));
      v21 = -v20;
      if (v20 >= 0.0)
        v21 = (float)((float)(a7 - a5) * (float)(a10 - a6)) - (float)((float)(a8 - a6) * (float)(a9 - a5));
      if (v21 < a11)
        break;
      v22 = (float)((float)(a7 + a9) + (float)(a5 * 2.0)) * 0.25;
      v23 = (float)((float)(a8 + a10) + (float)(a6 * 2.0)) * 0.25;
      v24 = (Shape *)Shape::AddPoint((Shape *)this, v22, v23);
      Path::RecRound(this, a2, (int)v24, v19 - 2, (float)(a5 + a7) * 0.5, (float)(a6 + a8) * 0.5, a7, a8, v22, v23, a11, v25);
      a9 = v27;
      a10 = v28;
      a5 = (float)(a5 + v27) * 0.5;
      --v19;
      a6 = (float)(a6 + v28) * 0.5;
      a8 = v23;
      a7 = v22;
      a2 = v24;
      if (v19 <= 1)
        return Shape::AddEdge((Shape *)this, v24, a3);
    }
  }
  LODWORD(v24) = (_DWORD)a2;
  return Shape::AddEdge((Shape *)this, v24, a3);
}

uint64_t Path::DoLeftJoin(Shape *this, int a2, unsigned int *a3, unsigned int *a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  float v23;
  float v24;
  double v25;
  uint64_t result;
  Shape *v27;
  float v28;
  float v29;
  unsigned int v30;
  unsigned int v31;
  Shape *v32;
  unsigned int v33;
  unsigned int v34;
  Shape *v35;
  unsigned int v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  unsigned int v50;
  uint64_t v51;
  float v52;
  Shape *v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  uint64_t v64;
  unsigned int v65;
  float v66;
  Path *v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;

  v23 = -a8;
  v24 = (float)(a8 * a11) - (float)(a9 * a10);
  if (v24 > -0.0001 && v24 < 0.0001)
  {
    v25 = (float)((float)(a9 * a11) + (float)(a8 * a10));
    result = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v23));
    *a3 = result;
    if (v25 > 0.9999)
    {
      *a4 = result;
      return result;
    }
    v37 = a6 - (float)(a5 * a9);
    v38 = a7 + (float)(a5 * a8);
    goto LABEL_23;
  }
  if (v24 < 0.0)
  {
    *a3 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v23));
    *a4 = Shape::AddPoint(this, a6 + (float)(a5 * a11), a7 + (float)(a5 * (float)-a10));
    v27 = this;
    v28 = a6;
    v29 = a7;
    goto LABEL_7;
  }
  if (a2 != 1)
  {
    v39 = -a10;
    if (a2 != 2)
    {
      *a3 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v23));
      v37 = a6 + (float)(a5 * a11);
      v38 = a7 + (float)(a5 * v39);
LABEL_23:
      v36 = Shape::AddPoint(this, v37, v38);
      *a4 = v36;
      v34 = *a3;
      v35 = this;
      return Shape::AddEdge(v35, v36, v34);
    }
    *a3 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * v23));
    *a4 = Shape::AddPoint(this, a6 + (float)(a5 * a11), a7 + (float)(a5 * v39));
    v40 = a9 + a11;
    v41 = v39 - a8;
    v42 = (float)(v41 * v41) + (float)(v40 * v40);
    if (v42 > 0.0001)
    {
      v43 = sqrtf(v42);
      v40 = v40 / v43;
      v41 = v41 / v43;
    }
    v44 = (float)(v41 * v39) + (float)(v40 * a11);
    v45 = a5 / v44;
    v46 = v44 * a5;
    if ((float)(v44 * a5) < a12)
      v46 = a12;
    if (v45 > v46)
    {
      v47 = (float)(v44 * (float)(v45 - v46)) / (float)((float)(v40 * v39) - (float)(v41 * a11));
      v48 = a6 + (float)(v46 * v40);
      v49 = a7 + (float)(v46 * v41);
      v30 = Shape::AddPoint(this, v48 + (float)(v47 * v41), v49 - (float)(v47 * v40));
      v50 = Shape::AddPoint(this, v48 - (float)(v47 * v41), v49 + (float)(v47 * v40));
      Shape::AddEdge(this, v50, v30);
      v31 = *a4;
      v32 = this;
      v33 = v50;
      goto LABEL_8;
    }
    v28 = a6 + (float)(v45 * v40);
    v29 = a7 + (float)(v45 * v41);
    v27 = this;
LABEL_7:
    v30 = Shape::AddPoint(v27, v28, v29);
    v31 = *a4;
    v32 = this;
    v33 = v30;
LABEL_8:
    Shape::AddEdge(v32, v31, v33);
    v34 = *a3;
    v35 = this;
    v36 = v30;
    return Shape::AddEdge(v35, v36, v34);
  }
  v72 = a7 + (float)(a5 * v23);
  v73 = a6 + (float)(a5 * a9);
  *a3 = Shape::AddPoint(this, v73, v72);
  v74 = a7 + (float)(a5 * (float)-a10);
  v75 = a6 + (float)(a5 * a11);
  v51 = Shape::AddPoint(this, v75, v74);
  v52 = -a10;
  v53 = (Shape *)v51;
  *a4 = v51;
  v54 = a9 + a11;
  v55 = (float)-a10 - a8;
  v56 = (float)(v55 * v55) + (float)(v54 * v54);
  if (v56 > 0.0001)
  {
    v57 = sqrtf(v56);
    v54 = v54 / v57;
    v55 = v55 / v57;
  }
  v58 = (float)(v55 * v52) + (float)(v54 * a11);
  v59 = a5 / v58;
  if ((float)((float)(a8 * a10) + (float)(a9 * a11)) >= 0.0)
  {
    v68 = a6 + (float)(v59 * v54);
    v69 = a7 + (float)(v59 * v55);
    v65 = *a3;
    v66 = 5.0;
    v67 = (Path *)this;
    v71 = a7 + (float)(a5 * (float)-a10);
    v70 = a6 + (float)(a5 * a11);
  }
  else
  {
    v60 = (float)(v58 * (float)(v59 - a5)) / (float)((float)(v54 * v52) - (float)(v55 * a11));
    v61 = a6 + (float)(a5 * v54);
    v62 = a7 + (float)(a5 * v55);
    v63 = v54;
    v64 = Shape::AddPoint(this, v61, v62);
    Path::RecRound((Path *)this, (Shape *)*a4, v64, 8, v61 - (float)(v60 * v55), v62 + (float)(v60 * v63), v75, v74, v61, v62, 5.0);
    v65 = *a3;
    v66 = 5.0;
    v67 = (Path *)this;
    v53 = (Shape *)v64;
    v68 = v61 + (float)(v60 * v55);
    v69 = v62 - (float)(v60 * v63);
    v70 = v61;
    v71 = v62;
  }
  return Path::RecRound(v67, v53, v65, 8, v68, v69, v70, v71, v73, v72, v66);
}

uint64_t Path::DoRightJoin(Shape *this, int a2, unsigned int *a3, unsigned int *a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  float v23;
  uint64_t result;
  unsigned int v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  Shape *v40;
  unsigned int v41;
  Shape *v42;
  float v43;
  float v44;
  unsigned int v45;
  unsigned int v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  uint64_t v61;
  float v62;
  Path *v63;
  Shape *v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;

  v23 = (float)(a8 * a11) - (float)(a9 * a10);
  if (v23 > -0.0001 && v23 < 0.0001)
  {
    if ((float)((float)(a9 * a11) + (float)(a8 * a10)) > 0.9999)
    {
      result = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
      *a3 = result;
      *a4 = result;
      return result;
    }
    *a4 = Shape::AddPoint(this, a6 + (float)(a5 * a9), a7 + (float)(a5 * (float)-a8));
    v41 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
    *a3 = v41;
    v39 = *a4;
    goto LABEL_22;
  }
  if (v23 >= 0.0)
  {
    *a3 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
    *a4 = Shape::AddPoint(this, a6 - (float)(a5 * a11), a7 + (float)(a5 * a10));
    v42 = this;
    v43 = a6;
    v44 = a7;
    goto LABEL_16;
  }
  if (a2 != 1)
  {
    if (a2 != 2)
    {
      *a3 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
      v39 = Shape::AddPoint(this, a6 - (float)(a5 * a11), a7 + (float)(a5 * a10));
      *a4 = v39;
      v41 = *a3;
LABEL_22:
      v40 = this;
      return Shape::AddEdge(v40, v41, v39);
    }
    *a3 = Shape::AddPoint(this, a6 - (float)(a5 * a9), a7 + (float)(a5 * a8));
    v25 = Shape::AddPoint(this, a6 - (float)(a5 * a11), a7 + (float)(a5 * a10));
    v26 = -a10;
    *a4 = v25;
    v27 = a9 + a11;
    v28 = (float)-a10 - a8;
    v29 = (float)(v28 * v28) + (float)(v27 * v27);
    if (v29 > 0.0001)
    {
      v30 = sqrtf(v29);
      v27 = v27 / v30;
      v28 = v28 / v30;
    }
    v31 = (float)(v28 * v26) + (float)(v27 * a11);
    v32 = a5 / v31;
    v33 = v31 * a5;
    if ((float)(v31 * a5) < a12)
      v33 = a12;
    if (v32 > v33)
    {
      v34 = (float)(v31 * (float)(v32 - v33)) / (float)((float)(v27 * v26) - (float)(v28 * a11));
      v35 = a6 - (float)(v33 * v27);
      v36 = a7 - (float)(v33 * v28);
      v37 = Shape::AddPoint(this, v35 - (float)(v34 * v28), v36 + (float)(v34 * v27));
      v38 = Shape::AddPoint(this, v35 + (float)(v34 * v28), v36 - (float)(v34 * v27));
      Shape::AddEdge(this, *a3, v37);
      Shape::AddEdge(this, v37, v38);
      v39 = *a4;
      v40 = this;
      v41 = v38;
      return Shape::AddEdge(v40, v41, v39);
    }
    v43 = a6 - (float)(v32 * v27);
    v44 = a7 - (float)(v32 * v28);
    v42 = this;
LABEL_16:
    v45 = Shape::AddPoint(v42, v43, v44);
    Shape::AddEdge(this, *a3, v45);
    v39 = *a4;
    v40 = this;
    v41 = v45;
    return Shape::AddEdge(v40, v41, v39);
  }
  v71 = a7 + (float)(a5 * a8);
  v72 = a6 - (float)(a5 * a9);
  *a3 = Shape::AddPoint(this, v72, v71);
  v69 = a7 + (float)(a5 * a10);
  v70 = a6 - (float)(a5 * a11);
  v46 = Shape::AddPoint(this, v70, v69);
  *a4 = v46;
  v47 = a9 + a11;
  v48 = (float)-a10 - a8;
  v49 = (float)(v48 * v48) + (float)(v47 * v47);
  if (v49 > 0.0001)
  {
    v50 = sqrtf(v49);
    v47 = v47 / v50;
    v48 = v48 / v50;
  }
  v51 = (float)(v48 * (float)-a10) + (float)(v47 * a11);
  v52 = a5 / v51;
  if ((float)((float)(a8 * a10) + (float)(a9 * a11)) >= 0.0)
  {
    v65 = a6 - (float)(v52 * v47);
    v66 = a7 - (float)(v52 * v48);
    v64 = (Shape *)*a3;
    v62 = 5.0;
    v63 = (Path *)this;
    v68 = v71;
    v67 = v72;
  }
  else
  {
    v53 = -a5;
    v54 = (float)(v51 * (float)(v52 - a5)) / (float)((float)(v47 * (float)-a10) - (float)(v48 * a11));
    v55 = a6 + (float)((float)-a5 * v47);
    v56 = v55 - (float)(v54 * v48);
    v57 = a7 + (float)(v53 * v48);
    v58 = v57 + (float)(v54 * v47);
    v59 = v55 + (float)(v54 * v48);
    v60 = v57 - (float)(v54 * v47);
    v61 = Shape::AddPoint(this, v55, v57);
    Path::RecRound((Path *)this, (Shape *)*a3, v61, 8, v56, v58, v72, v71, v55, v57, 5.0);
    v46 = *a4;
    v62 = 5.0;
    v63 = (Path *)this;
    v64 = (Shape *)v61;
    v65 = v59;
    v66 = v60;
    v67 = v55;
    v68 = v57;
  }
  return Path::RecRound(v63, v64, v46, 8, v65, v66, v67, v68, v70, v69, v62);
}

void Path::Stroke(uint64_t a1, uint64_t a2, int a3, int a4, int a5, float a6, float a7)
{
  uint64_t v8;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int *v19;
  int v20;
  uint64_t v21;
  int *v22;
  int v23;
  uint64_t v24;
  int *v25;
  int v26;
  uint64_t v27;
  int *v28;
  int v29;
  uint64_t v30;

  if (a2)
  {
    v8 = *(unsigned int *)(a1 + 36);
    if ((int)v8 >= 2)
    {
      v15 = 0;
      v16 = *(_QWORD *)(a1 + 48);
      do
      {
        v17 = v15 + 1;
        if (*(_BYTE *)(a1 + 33))
        {
          if (*(_BYTE *)(a1 + 32))
          {
            if (v17 < (int)v8)
            {
              v18 = v17;
              v19 = (int *)(v16 + 24 * v17);
              while (1)
              {
                v20 = *v19;
                v19 += 6;
                if ((v20 | 2) != 2)
                  break;
                if (v8 == ++v18)
                {
                  v17 = v8;
                  goto LABEL_28;
                }
              }
              v17 = v18;
            }
LABEL_28:
            v30 = v16 + 24 * v15;
          }
          else
          {
            if (v17 < (int)v8)
            {
              v24 = v17;
              v25 = (int *)(v16 + 20 * v17);
              while (1)
              {
                v26 = *v25;
                v25 += 5;
                if ((v26 | 2) != 2)
                  break;
                if (v8 == ++v24)
                {
                  v17 = v8;
                  goto LABEL_32;
                }
              }
              v17 = v24;
            }
LABEL_32:
            v30 = v16 + 20 * v15;
          }
        }
        else if (*(_BYTE *)(a1 + 32))
        {
          if (v17 < (int)v8)
          {
            v21 = v17;
            v22 = (int *)(v16 + 16 * v17);
            while (1)
            {
              v23 = *v22;
              v22 += 4;
              if ((v23 | 2) != 2)
                break;
              if (v8 == ++v21)
              {
                v17 = v8;
                goto LABEL_30;
              }
            }
            v17 = v21;
          }
LABEL_30:
          v30 = v16 + 16 * v15;
        }
        else
        {
          if (v17 < (int)v8)
          {
            v27 = v17;
            v28 = (int *)(v16 + 12 * v17);
            while (1)
            {
              v29 = *v28;
              v28 += 3;
              if ((v29 | 2) != 2)
                break;
              if (v8 == ++v27)
              {
                v17 = v8;
                goto LABEL_34;
              }
            }
            v17 = v27;
          }
LABEL_34:
          v30 = v16 + 12 * v15;
        }
        *(_QWORD *)(a1 + 48) = v30;
        *(_DWORD *)(a1 + 36) = v17 - v15;
        Path::DoStroke(a1, a6, a7, a2, a3, a4, a5);
        v15 = v17;
      }
      while (v17 < (int)v8);
      *(_QWORD *)(a1 + 48) = v16;
      *(_DWORD *)(a1 + 36) = v8;
    }
  }
}

void Path::DoStroke(uint64_t a1, float a2, float a3, uint64_t a4, int a5, int a6, int a7)
{
  float v7;
  float v8;
  Shape *v13;
  Shape *v14;
  float *v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  uint64_t v20;
  float v21;
  float v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  float *v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  uint64_t v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  float *v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v69;

  v13 = (Shape *)operator new();
  Shape::Shape(v13);
  v15 = *(float **)(a1 + 48);
  if (*(_BYTE *)(a1 + 32))
    v16 = v15[3];
  else
    v16 = 1.0;
  v17 = v15[1];
  v18 = v15[2];
  v19 = *(int *)(a1 + 36);
  v20 = v19 - 1;
  v21 = v17;
  v22 = v18;
  if (a5)
  {
    v23 = 12 * v20;
    if (*(_BYTE *)(a1 + 32))
      v23 = 16 * v20;
    v24 = 24 * v20;
    if (!*(_BYTE *)(a1 + 32))
      v24 = 20 * v20;
    if (*(_BYTE *)(a1 + 33))
      v23 = v24;
    if ((int)v19 < 2)
      goto LABEL_41;
    v25 = -24;
    if (!*(_BYTE *)(a1 + 32))
      v25 = -20;
    v26 = -16;
    if (!*(_BYTE *)(a1 + 32))
      v26 = -12;
    if (!*(_BYTE *)(a1 + 33))
      v25 = v26;
    v27 = (float *)((char *)v15 + v23 + 8);
    while (1)
    {
      v21 = *(v27 - 1);
      v22 = *v27;
      if ((float)((float)((float)(v18 - *v27) * (float)(v18 - *v27)) + (float)((float)(v17 - v21) * (float)(v17 - v21))) > 0.001)
        break;
      LODWORD(v19) = v19 - 1;
      v27 = (float *)((char *)v27 + v25);
      if (v19 <= 1)
        goto LABEL_41;
    }
    LODWORD(v20) = v19 - 1;
  }
  if ((int)v20 < 1)
  {
    v34 = 0.0;
    v32 = 1;
  }
  else
  {
    v28 = 0;
    v29 = 16;
    if (!*(_BYTE *)(a1 + 32))
      v29 = 12;
    v30 = 24;
    if (!*(_BYTE *)(a1 + 32))
      v30 = 20;
    if (*(_BYTE *)(a1 + 33))
      v31 = v30;
    else
      v31 = v29;
    v32 = v20 + 1;
    v33 = (float *)((char *)v15 + v31 + 12);
    while (1)
    {
      v34 = *(_BYTE *)(a1 + 32) ? *v33 : 1.0;
      v8 = *(v33 - 2);
      v7 = *(v33 - 1);
      if ((float)((float)((float)(v18 - v7) * (float)(v18 - v7)) + (float)((float)(v17 - v8) * (float)(v17 - v8))) > 0.001)
        break;
      ++v28;
      v33 = (float *)((char *)v33 + v31);
      if ((_DWORD)v20 == v28)
        goto LABEL_40;
    }
    v32 = v28 + 1;
  }
LABEL_40:
  if (v32 <= (int)v20)
  {
    v35 = v17 - v21;
    v36 = v18 - v22;
    v37 = v8 - v17;
    v38 = v7 - v18;
    v39 = (float)(v36 * v36) + (float)(v35 * v35);
    v40 = (float)(v38 * v38) + (float)(v37 * v37);
    if (v39 > 0.0001)
    {
      v41 = sqrtf(v39);
      v35 = v35 / v41;
      v36 = v36 / v41;
    }
    if (v40 > 0.0001)
    {
      v42 = sqrtf(v40);
      v37 = v37 / v42;
      v38 = v38 / v42;
    }
    v69 = v17;
    if (a5)
      Path::DoJoin(v16 * a2, v17, v18, v35, v36, v37, v38, a3, (uint64_t)v14, a6);
    v43 = v38;
    v44 = v37;
    Path::DoButt(v16 * a2, v17, v18, -v37, -v38, (uint64_t)v14, a7);
    v46 = v44;
    v47 = v43;
    v48 = v7;
    v49 = v8;
    v50 = v34;
    v51 = v32 + 1;
    if (*(_BYTE *)(a1 + 33))
    {
      v52 = 20 * v51;
      v53 = 24 * v51;
    }
    else
    {
      v52 = 12 * v51;
      v53 = 16 * v51;
    }
    if (*(_BYTE *)(a1 + 32))
    {
      v54 = 0;
    }
    else
    {
      v53 = v52;
      v54 = 1;
    }
    if (v32 < (int)v20)
    {
      v55 = 24;
      if (v54)
      {
        v55 = 20;
        v56 = 12;
      }
      else
      {
        v56 = 16;
      }
      if (*(_BYTE *)(a1 + 33))
        v57 = v55;
      else
        v57 = v56;
      v58 = (float *)(*(_QWORD *)(a1 + 48) + v53 + 8);
      while (1)
      {
        v8 = *(v58 - 1);
        v7 = *v58;
        if ((float)((float)((float)(v48 - *v58) * (float)(v48 - *v58)) + (float)((float)(v49 - v8) * (float)(v49 - v8))) > 0.001)
          break;
        ++v32;
        v58 = (float *)((char *)v58 + v57);
        if ((_DWORD)v20 == v32)
        {
          v51 = v20 + 1;
          goto LABEL_66;
        }
      }
      v51 = v32 + 1;
    }
LABEL_66:
    if (v51 <= (int)v20)
    {
      v59 = v8 - v49;
      v60 = v7 - v48;
      v61 = (float)(v60 * v60) + (float)(v59 * v59);
      if (v61 > 0.0001)
      {
        v62 = sqrtf(v61);
        v59 = v59 / v62;
        v60 = v60 / v62;
      }
      Path::DoJoin(v50 * a2, v49, v48, v46, v47, v59, v60, a3, v45, a6);
    }
    v63 = v16;
    v64 = v50 * a2;
    v65 = v47;
    v66 = v46;
    Path::DoButt(v50 * a2, v49, v48, v46, v47, v45, a7);
    Path::DoSeg(v63 * a2, v69, v18, v64, v49, v48, v66, v65);
  }
LABEL_41:
  Shape::~Shape(v14);
  JUMPOUT(0x219A153B8);
}

void Path::DoJoin(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, uint64_t a9, int a10)
{
  int *v18;
  float v19;
  unsigned int v20;
  unsigned int v21;
  int v23[2];

  v18 = (int *)operator new();
  Shape::Shape((Shape *)v18);
  v19 = (float)(a4 * a7) - (float)(a5 * a6);
  if (v19 <= -0.0001 || v19 >= 0.0001)
  {
    v20 = Shape::AddPoint((Shape *)v18, a2, a3);
    *(_QWORD *)v23 = 0;
    if (v19 >= 0.0)
    {
      Path::DoLeftJoin((Shape *)v18, a10, (unsigned int *)&v23[1], (unsigned int *)v23, a1, a2, a3, a4, a5, a6, a7, a8);
      Shape::AddEdge((Shape *)v18, v23[1], v20);
      v21 = v23[0];
    }
    else
    {
      Path::DoRightJoin((Shape *)v18, a10, (unsigned int *)&v23[1], (unsigned int *)v23, a1, a2, a3, a4, a5, a6, a7, a8);
      Shape::AddEdge((Shape *)v18, v23[0], v20);
      v21 = v23[1];
    }
    Shape::AddEdge((Shape *)v18, v20, v21);
    if (v18[4] >= 3 && v18[8] >= 2)
      Shape::ForceToPolygon((uint64_t)v18);
  }
  Shape::~Shape((Shape *)v18);
  JUMPOUT(0x219A153B8);
}

void Path::DoButt(float a1, float a2, float a3, float a4, float a5, uint64_t a6, int a7)
{
  int *v13;
  Shape *v14;
  uint64_t v15;

  if (a7)
  {
    v13 = (int *)operator new();
    Shape::Shape((Shape *)v13);
    v15 = 0;
    Path::DoButt(v14, a7, (unsigned int *)&v15 + 1, (unsigned int *)&v15, a1, a2, a3, a4, a5);
    Shape::AddEdge((Shape *)v13, HIDWORD(v15), v15);
    if (v13[4] >= 3 && v13[8] >= 2)
      Shape::ForceToPolygon((uint64_t)v13);
    Shape::~Shape((Shape *)v13);
    MEMORY[0x219A153B8]();
  }
}

void Path::DoSeg(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  int *v16;
  Shape *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;

  v16 = (int *)operator new();
  Shape::Shape((Shape *)v16);
  v18 = Shape::AddPoint(v17, a2 - (float)(a1 * a8), a3 + (float)(a1 * a7));
  v19 = Shape::AddPoint((Shape *)v16, a2 + (float)(a1 * a8), a3 - (float)(a1 * a7));
  v20 = Shape::AddPoint((Shape *)v16, a5 - (float)(a4 * a8), a6 + (float)(a4 * a7));
  v21 = Shape::AddPoint((Shape *)v16, a5 + (float)(a4 * a8), a6 - (float)(a4 * a7));
  Shape::AddEdge((Shape *)v16, v19, v18);
  Shape::AddEdge((Shape *)v16, v18, v20);
  Shape::AddEdge((Shape *)v16, v20, v21);
  Shape::AddEdge((Shape *)v16, v21, v19);
  if (v16[4] >= 3 && v16[8] >= 2)
    Shape::ForceToPolygon((uint64_t)v16);
  Shape::~Shape((Shape *)v16);
  JUMPOUT(0x219A153B8);
}

void Path::Stroke(uint64_t a1, void **this, int a3, int a4, int a5, int a6, uint64_t a7, char a8, float a9, float a10)
{
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  int *v24;
  int v25;
  uint64_t v26;
  int *v27;
  int v28;
  uint64_t v29;
  int *v30;
  int v31;
  uint64_t v32;
  int *v33;
  int v34;
  int v35;
  uint64_t v36;

  if (a6 <= 0)
  {
    Path::Stroke(a1, this, a3, a4, a5, a8, a9, a10);
  }
  else if (this)
  {
    if ((a8 & 1) == 0)
      Shape::Reset(this, 3 * *(_DWORD *)(a1 + 36));
    if (*(int *)(a1 + 36) >= 2)
    {
      Shape::MakeBackData((Shape *)this, 0);
      v19 = *(_QWORD *)(a1 + 48);
      v20 = *(unsigned int *)(a1 + 36);
      if ((int)v20 >= 1)
      {
        v21 = 0;
        do
        {
          v22 = v21 + 1;
          if (*(_BYTE *)(a1 + 33))
          {
            if (*(_BYTE *)(a1 + 32))
            {
              if (v22 < (int)v20)
              {
                v23 = v22;
                v24 = (int *)(v19 + 24 * v22);
                while (1)
                {
                  v25 = *v24;
                  v24 += 6;
                  if ((v25 | 2) != 2)
                    break;
                  if (v20 == ++v23)
                  {
                    v22 = v20;
                    goto LABEL_32;
                  }
                }
                v22 = v23;
              }
LABEL_32:
              v35 = 24;
            }
            else
            {
              if (v22 < (int)v20)
              {
                v29 = v22;
                v30 = (int *)(v19 + 20 * v22);
                while (1)
                {
                  v31 = *v30;
                  v30 += 5;
                  if ((v31 | 2) != 2)
                    break;
                  if (v20 == ++v29)
                  {
                    v22 = v20;
                    goto LABEL_36;
                  }
                }
                v22 = v29;
              }
LABEL_36:
              v35 = 20;
            }
          }
          else
          {
            if (*(_BYTE *)(a1 + 32))
            {
              if (v22 < (int)v20)
              {
                v26 = v22;
                v27 = (int *)(v19 + 16 * v22);
                while (1)
                {
                  v28 = *v27;
                  v27 += 4;
                  if ((v28 | 2) != 2)
                    break;
                  if (v20 == ++v26)
                  {
                    v22 = v20;
                    goto LABEL_34;
                  }
                }
                v22 = v26;
              }
LABEL_34:
              v36 = v19 + 16 * v21;
              goto LABEL_40;
            }
            if (v22 < (int)v20)
            {
              v32 = v22;
              v33 = (int *)(v19 + 12 * v22);
              while (1)
              {
                v34 = *v33;
                v33 += 3;
                if ((v34 | 2) != 2)
                  break;
                if (v20 == ++v32)
                {
                  v22 = v20;
                  goto LABEL_38;
                }
              }
              v22 = v32;
            }
LABEL_38:
            v35 = 12;
          }
          v36 = v19 + v21 * (uint64_t)v35;
LABEL_40:
          *(_QWORD *)(a1 + 48) = v36;
          *(_DWORD *)(a1 + 36) = v22 - v21;
          Path::DoStroke(a1, (Shape *)this, a3, a4, a5, a6, a7, 0, a9, a10);
          v21 = v22;
        }
        while (v22 < (int)v20);
      }
      *(_QWORD *)(a1 + 48) = v19;
      *(_DWORD *)(a1 + 36) = v20;
    }
  }
}

uint64_t Path::DoStroke(uint64_t result, Shape *this, int a3, int a4, int a5, int a6, uint64_t a7, int a8, float a9, float a10)
{
  uint64_t v10;
  int v11;
  float *v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  float v20;
  float v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float *v31;
  float v32;
  float v33;
  float v34;
  int v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  BOOL v43;
  float v44;
  int v45;
  int v46;
  int v47;
  int v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  int v65;
  float *v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  int v79;
  int v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  int v90;
  int v91;
  unsigned int v92;
  float v93;
  float v94;
  unsigned int v95;
  int v97;
  float v102;
  float v103;
  float v104;
  float v105;
  int v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  int v113;
  int v114;
  int v115;
  int v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float v125;
  char v126;
  int v127;
  int v128;
  unsigned int v129;
  int v130;
  int v131;
  int v132;
  float v133[3];

  if (this)
  {
    v10 = result;
    v11 = *(_DWORD *)(result + 36);
    if (v11 >= 2)
    {
      v132 = 0;
      v15 = *(float **)(result + 48);
      if (*(_BYTE *)(result + 32))
        v16 = v15[3];
      else
        v16 = 1.0;
      v17 = v15[1];
      v18 = v15[2];
      v19 = (v11 - 1);
      v20 = v17;
      v21 = v18;
      if (a3)
      {
        v22 = 12 * v19;
        if (*(_BYTE *)(result + 32))
          v22 = 16 * v19;
        v23 = 24 * v19;
        if (!*(_BYTE *)(result + 32))
          v23 = 20 * v19;
        if (*(_BYTE *)(result + 33))
          v22 = v23;
        v24 = -24;
        if (!*(_BYTE *)(result + 32))
          v24 = -20;
        v25 = -16;
        if (!*(_BYTE *)(result + 32))
          v25 = -12;
        if (!*(_BYTE *)(result + 33))
          v24 = v25;
        v26 = (float *)((char *)v15 + v22 + 8);
        while (1)
        {
          v20 = *(v26 - 1);
          v21 = *v26;
          if ((float)((float)((float)(v18 - *v26) * (float)(v18 - *v26))
                     + (float)((float)(v17 - v20) * (float)(v17 - v20))) > 0.001)
            break;
          --v11;
          v26 = (float *)((char *)v26 + v24);
          if (v11 <= 1)
            return result;
        }
        LODWORD(v19) = v11 - 1;
      }
      v27 = 0;
      v28 = 24;
      if (!*(_BYTE *)(result + 32))
        v28 = 20;
      v29 = 16;
      if (!*(_BYTE *)(result + 32))
        v29 = 12;
      v30 = *(_BYTE *)(result + 33) ? v28 : v29;
      v31 = (float *)((char *)v15 + v30 + 12);
      while (1)
      {
        v32 = *(_BYTE *)(result + 32) ? *v31 : 1.0;
        v34 = *(v31 - 2);
        v33 = *(v31 - 1);
        if ((float)((float)((float)(v18 - v33) * (float)(v18 - v33)) + (float)((float)(v17 - v34) * (float)(v17 - v34))) > 0.001)
          break;
        ++v27;
        v31 = (float *)((char *)v31 + v30);
        if ((_DWORD)v19 == v27)
        {
          v35 = v19 + 1;
          goto LABEL_39;
        }
      }
      v35 = v27 + 1;
LABEL_39:
      if (v35 <= (int)v19)
      {
        v129 = -1;
        v130 = -1;
        v127 = -1;
        v128 = -1;
        v36 = v17 - v20;
        v37 = v18 - v21;
        v38 = v34 - v17;
        v39 = v33 - v18;
        v40 = (float)(v37 * v37) + (float)(v36 * v36);
        v41 = (float)(v39 * v39) + (float)(v38 * v38);
        v42 = sqrtf(v40);
        if (v40 > 0.0001)
        {
          v36 = v36 / v42;
          v37 = v37 / v42;
        }
        v43 = v41 <= 0.0001;
        v44 = sqrtf(v41);
        if (!v43)
        {
          v38 = v38 / v44;
          v39 = v39 / v44;
        }
        v45 = 0;
        do
        {
          if ((float)(*(float *)(a7 + 8 * v45 + 4) + 0.0) > 0.0)
            break;
          v46 = v45 + 1;
          v47 = v46 >= a6 ? a6 : 0;
          v45 = v46 - v47;
        }
        while (v45);
        v131 = v45;
        v133[0] = 0.0;
        v48 = *(unsigned __int8 *)(a7 + 8 * v45);
        if (a3)
        {
          if (v48)
          {
            v97 = 0;
            v126 = 1;
LABEL_58:
            v59 = v44;
            while (1)
            {
              v60 = v33;
              v61 = v34;
              v62 = v32;
              v63 = v39;
              v64 = v38;
              v65 = v35 + 1;
              v66 = *(float **)(v10 + 48);
              if (*(_BYTE *)(v10 + 33))
              {
                v67 = 20 * v65;
                v68 = 24 * v65;
              }
              else
              {
                v67 = 12 * v65;
                v68 = 16 * v65;
              }
              if (*(_BYTE *)(v10 + 32))
              {
                v69 = 0;
              }
              else
              {
                v68 = v67;
                v69 = 1;
              }
              if (v35 < (int)v19)
              {
                v70 = 24;
                if (v69)
                  v70 = 20;
                v71 = 16;
                if (v69)
                  v71 = 12;
                if (*(_BYTE *)(v10 + 33))
                  v72 = v70;
                else
                  v72 = v71;
                v73 = (uint64_t)v66 + v68 + 8;
                while (1)
                {
                  v32 = 1.0;
                  if ((v69 & 1) == 0)
                    v32 = *(float *)(v73 + 4);
                  v34 = *(float *)(v73 - 4);
                  v33 = *(float *)v73;
                  if ((float)((float)((float)(v60 - *(float *)v73) * (float)(v60 - *(float *)v73))
                             + (float)((float)(v61 - v34) * (float)(v61 - v34))) > 0.001)
                    break;
                  ++v35;
                  v73 += v72;
                  if ((_DWORD)v19 == v35)
                  {
                    v65 = v19 + 1;
                    goto LABEL_80;
                  }
                }
                v65 = v35 + 1;
              }
LABEL_80:
              v106 = LODWORD(v44);
              if (v65 > (int)v19)
                break;
              v74 = v34 - v61;
              v75 = v33 - v60;
              v76 = (float)(v75 * v75) + (float)(v74 * v74);
              v77 = sqrtf(v76);
              if (v76 > 0.0001)
              {
                v74 = v74 / v77;
                v75 = v75 / v77;
              }
              v107 = v75;
              v111 = v74;
              v78 = v59 + v77;
              v117 = v59;
              v118 = v17;
              v119 = v18;
              v120 = v61;
              v121 = v60;
              v122 = v64;
              v123 = v63;
              v124 = v16 * a9;
              v103 = v63;
              v125 = v62 * a9;
              v102 = v64;
              Path::DashTo((uint64_t)this, &v117, (float *)&v132, &v131, v133, &v126, (unsigned int *)&v128, (unsigned int *)&v127, a6, a7);
              v44 = v77;
              v59 = v78;
              v35 = v65;
              v16 = v62;
              v17 = v61;
              v18 = v60;
              v39 = v107;
              v38 = v111;
              if (!v126)
              {
                v115 = -1;
                v116 = -1;
                v113 = -1;
                v114 = -1;
                Path::DoJoin(this, a4, (unsigned int *)&v116, (unsigned int *)&v114, (unsigned int *)&v115, (unsigned int *)&v113, v79, v80, v62 * a9, v61, v60, v102, v103, v111, v107, a10, v106, SLODWORD(v77));
                Shape::AddEdge(this, v116, v128);
                v128 = v114;
                Shape::AddEdge(this, v127, v115);
                v44 = v77;
                v39 = v107;
                v38 = v111;
                v59 = v78;
                v127 = v113;
                v35 = v65;
                v16 = v62;
                v17 = v61;
                v18 = v60;
              }
            }
            if (!a3)
            {
              v117 = v59;
              v118 = v17;
              v119 = v18;
              v120 = v61;
              v121 = v60;
              v122 = v38;
              v123 = v39;
              v124 = v16 * a9;
              v125 = v62 * a9;
              v93 = v39;
              v94 = v38;
              result = Path::DashTo((uint64_t)this, &v117, (float *)&v132, &v131, v133, &v126, (unsigned int *)&v128, (unsigned int *)&v127, a6, a7);
              if (v126)
                return result;
              v115 = 0;
              v116 = 0;
              Path::DoButt(this, a5, (unsigned int *)&v115, (unsigned int *)&v116, v62 * a9, v61, v60, v94, v93);
              Shape::AddEdge(this, v115, v128);
              v92 = v127;
              v95 = v116;
              return Shape::AddEdge(this, v92, v95);
            }
            v81 = v62;
            v82 = 1.0;
            if ((v69 & 1) == 0)
              v82 = v66[3];
            v108 = v66[1];
            v112 = v82;
            v83 = v108 - v61;
            v84 = v66[2] - v60;
            v85 = (float)(v84 * v84) + (float)(v83 * v83);
            v86 = sqrtf(v85);
            v105 = v66[2];
            if (v85 > 0.0001)
            {
              v83 = v83 / v86;
              v84 = v84 / v86;
            }
            v104 = v59 + v86;
            v117 = v59;
            v118 = v17;
            v119 = v18;
            v120 = v61;
            v121 = v60;
            v122 = v38;
            v123 = v39;
            v124 = v16 * a9;
            v87 = v81 * a9;
            v125 = v81 * a9;
            v88 = v39;
            v89 = v38;
            Path::DashTo((uint64_t)this, &v117, (float *)&v132, &v131, v133, &v126, (unsigned int *)&v128, (unsigned int *)&v127, a6, a7);
            if (!v126)
            {
              v115 = -1;
              v116 = -1;
              v113 = -1;
              v114 = -1;
              Path::DoJoin(this, a4, (unsigned int *)&v116, (unsigned int *)&v114, (unsigned int *)&v115, (unsigned int *)&v113, v90, v91, v87, v61, v60, v89, v88, v83, v84, a10, v106, SLODWORD(v86));
              Shape::AddEdge(this, v116, v128);
              v128 = v114;
              Shape::AddEdge(this, v127, v115);
              v127 = v113;
            }
            v117 = v104;
            v118 = v61;
            v119 = v60;
            v120 = v108;
            v121 = v105;
            v122 = v83;
            v123 = v84;
            v124 = v87;
            v125 = v112 * a9;
            result = Path::DashTo((uint64_t)this, &v117, (float *)&v132, &v131, v133, &v126, (unsigned int *)&v128, (unsigned int *)&v127, a6, a7);
            if (v126)
            {
              if (!v97)
                return result;
              v92 = v130;
            }
            else
            {
              v95 = v128;
              if (!v97)
              {
                v92 = v127;
                return Shape::AddEdge(this, v92, v95);
              }
              Shape::AddEdge(this, v130, v128);
              v92 = v127;
            }
            v95 = v129;
            return Shape::AddEdge(this, v92, v95);
          }
          v109 = v16;
          v49 = v17;
          v50 = v18;
          v51 = v38;
          v52 = v39;
          v53 = v44;
          Path::DoJoin(this, a4, (unsigned int *)&v130, (unsigned int *)&v128, &v129, (unsigned int *)&v127, a7, a8, v16 * a9, v17, v18, v36, v37, v38, v39, a10, SLODWORD(v42), SLODWORD(v44));
          v44 = v53;
          v39 = v52;
          v38 = v51;
          v18 = v50;
          v17 = v49;
          v16 = v109;
        }
        else
        {
          if (v48)
          {
            v97 = 1;
            v126 = 1;
            goto LABEL_58;
          }
          v54 = v16;
          v55 = v17;
          v56 = v18;
          v57 = v38;
          v58 = v39;
          v110 = v44;
          Path::DoButt(this, a5, (unsigned int *)&v127, (unsigned int *)&v128, v16 * a9, v17, v18, -v38, -v39);
          v44 = v110;
          v39 = v58;
          v38 = v57;
          v18 = v56;
          v17 = v55;
          v16 = v54;
        }
        v126 = 0;
        v97 = 1;
        goto LABEL_58;
      }
    }
  }
  return result;
}

uint64_t Path::DashTo(uint64_t result, float *a2, float *a3, _DWORD *a4, float *a5, char *a6, unsigned int *a7, unsigned int *a8, int a9, uint64_t a10)
{
  float v10;
  uint64_t v11;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  float v20;
  float v21;
  int v22;
  int v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  unsigned int v31;
  unsigned int v32;
  char v33;
  unsigned int v34;
  unsigned int v35;
  float v36;
  float *v37;
  char *v38;
  Shape *v39;

  v39 = (Shape *)result;
  v10 = *a3;
  v11 = *a4;
  if (*a3 < *a2)
  {
    v17 = a2[5];
    v16 = a2[6];
    v18 = -v17;
    v37 = a3;
    v38 = a6;
    while (1)
    {
      v19 = v11;
      while (1)
      {
        v20 = *(float *)(a10 + 8 * (int)v19 + 4) - *a5;
        v21 = *a2 - *a3;
        if (v20 > v21)
          break;
        v22 = v19 + 1;
        *a4 = v22;
        *a5 = 0.0;
        if (v22 >= a9)
        {
          *a4 = v22 - a9;
          v22 -= a9;
        }
        v23 = v11;
        if (v22 != (_DWORD)v11)
        {
          while (*(float *)(a10 + 8 * v22 + 4) <= 0.0)
          {
            *a4 = ++v22;
            *a5 = 0.0;
            if (v22 >= a9)
            {
              *a4 = v22 - a9;
              v22 -= a9;
            }
            if (v22 == (_DWORD)v11)
            {
              v23 = v11;
              goto LABEL_14;
            }
          }
          v23 = v22;
        }
LABEL_14:
        if (*(float *)(a10 + 8 * v23 + 4) <= 0.0)
          goto LABEL_21;
        v24 = v20 + *a3;
        *a3 = v24;
        v25 = *a2 - v24;
        v26 = v24 - v10;
        v27 = *a2 - v10;
        v28 = (float)((float)(v26 * a2[3]) + (float)(a2[1] * v25)) / v27;
        v29 = (float)((float)(v26 * a2[4]) + (float)(a2[2] * v25)) / v27;
        v30 = (float)((float)(v26 * a2[8]) + (float)(a2[7] * v25)) / v27;
        if (*a6)
        {
          if (!*(_BYTE *)(a10 + 8 * v23))
          {
            v31 = Shape::AddPoint(v39, v28 + (float)(v30 * v16), v29 + (float)(v30 * v18));
            v32 = Shape::AddPoint(v39, v28 - (float)(v30 * v16), v29 + (float)(v30 * v17));
            result = Shape::AddEdge(v39, v31, v32);
            v33 = 0;
LABEL_20:
            *a7 = v31;
            *a8 = v32;
            a3 = v37;
            a6 = v38;
            *v38 = v33;
          }
        }
        else if (*(_BYTE *)(a10 + 8 * v23))
        {
          v34 = Shape::AddPoint(v39, v28 + (float)(v30 * v16), v29 + (float)(v30 * v18));
          v35 = Shape::AddPoint(v39, v28 - (float)(v30 * v16), v29 + (float)(v30 * v17));
          Shape::AddEdge(v39, v35, v34);
          Shape::AddEdge(v39, *a8, v35);
          result = Shape::AddEdge(v39, v34, *a7);
          v33 = 1;
          v31 = -1;
          v32 = -1;
          goto LABEL_20;
        }
LABEL_21:
        v19 = *a4;
        if ((_DWORD)v19 == (_DWORD)v11)
        {
          v36 = *a3;
          goto LABEL_24;
        }
      }
      *a5 = *a5 + v21;
      v36 = *a2;
      *a3 = *a2;
      v11 = v19;
LABEL_24:
      if (v36 >= *a2)
      {
        LODWORD(v11) = *a4;
        break;
      }
    }
  }
  *a6 = *(_BYTE *)(a10 + 8 * (int)v11);
  return result;
}

double TSDMetalEdgeDistanceFieldTextureAdjustmentMix()
{
  double v0;
  double v1;

  TSUMix();
  v1 = v0;
  TSUMix();
  TSUMix();
  return v1;
}

float halfToFloat(unsigned int a1)
{
  float result;

  LODWORD(result) = ((a1 << 16) & 0x80000000 | (((a1 >> 10) & 0x1F) << 23) | ((a1 & 0x3FF) << 13)) + 939524096;
  return result;
}

BOOL TSDMetalEdgeDistanceFieldBufferPixelIsInsideTexture(double a1, double a2, double a3, double a4)
{
  _BOOL8 result;

  result = 0;
  if (a1 >= 0.0 && a2 >= 0.0 && a1 < a3)
    return a2 < a4;
  return result;
}

uint64_t TSDMetalEdgeDistanceFieldBufferIndexFromPixel(double a1, double a2, double a3)
{
  return (uint64_t)(a1 + a3 * a2);
}

double TSDMetalEdgeDistanceFieldBufferPixelFromIndex(uint64_t a1, double a2)
{
  return (double)(a1 % (uint64_t)a2);
}

uint64_t TSDMetalEdgeDistanceFieldBufferOffsetFromPixel(double a1, double a2, double a3)
{
  return 4 * (uint64_t)(a1 + a3 * a2);
}

double TSDMetalEdgeDistanceFieldBufferValueAtPixel(uint64_t a1, double a2, double a3, double a4)
{
  return *(float *)(a1 + 4 * (uint64_t)(a2 + a4 * a3));
}

double TSDMetalEdgeDistanceFieldBufferGradientAtPixel(uint64_t a1, double a2, double a3, double a4)
{
  return *(float *)(a1 + 16 * (uint64_t)(a2 + a4 * a3) + 4) + -0.5;
}

float TSDMetalEdgeDistanceFieldBufferColorValueAtPixel(uint64_t a1, double a2, double a3, double a4)
{
  return *(float *)(a1 + 16 * (uint64_t)(a2 + a4 * a3)) + -0.5;
}

BOOL TSDMetalEdgeDistanceFieldBufferPixelIsLocalMaximum(uint64_t a1, double a2, double a3, double a4, double a5)
{
  uint64_t v10;
  float v11;
  int v12;
  int v13;
  double v14;
  double v15;
  double v16;
  double v17;
  BOOL v18;
  double v20;
  double v21;
  BOOL v22;
  double v24;
  float v25;
  float v26;
  _BOOL8 result;

  v10 = 0;
  v11 = fabsf(*(float *)(a1 + 4 * (uint64_t)(a2 + a4 * a3)));
  v12 = 1;
  while (1)
  {
    while (1)
    {
      v13 = v12;
      v14 = TSDAddPoints(a2, a3, *(double *)&kNeighboring8Points[2 * v10]);
      if (v14 >= 0.0)
      {
        v16 = v14;
        v17 = v15;
        v18 = v15 >= 0.0 && v14 < a4;
        if (v18 && v15 < a5)
        {
          v20 = TSDAddPoints(a2, a3, *(double *)((char *)kNeighboring8Points + ((16 * v10) | 0x10)));
          if (v20 >= 0.0)
          {
            v22 = v21 >= 0.0 && v20 < a4;
            if (v22 && v21 < a5)
              break;
          }
        }
      }
      v12 = 0;
      result = 0;
      v10 = 2;
      if ((v13 & 1) == 0)
        return result;
    }
    v24 = v20 + a4 * v21;
    v25 = fabsf(*(float *)(a1 + 4 * (uint64_t)(v16 + a4 * v17)));
    v26 = fabsf(*(float *)(a1 + 4 * (uint64_t)v24));
    if (v25 <= v11 && v26 < v11)
      break;
    result = v26 <= v11 && v25 < v11;
    if (!result)
    {
      v12 = 0;
      v10 = 2;
      if (((v13 ^ 1) & 1) == 0)
        continue;
    }
    return result;
  }
  return 1;
}

BOOL TSDMetalEdgeDistanceFieldBufferTracePixelContainsData(uint64_t a1, double a2, double a3, double a4)
{
  return *(_BYTE *)(a1 + 4 * (uint64_t)(a2 + a4 * a3) + 3) != 0;
}

uint64_t TSDMetalEdgeDistanceFieldBufferTracePixelValue(uint64_t a1, int a2, double a3, double a4, double a5)
{
  double v5;

  v5 = a3 + a5 * a4;
  if (a2)
    return *(unsigned __int16 *)(a1 + 4 * (uint64_t)v5);
  else
    return *(unsigned __int16 *)(a1 + 4 * (uint64_t)v5) - 0x8000;
}

double TSDMetalEdgeDistanceFieldBufferSetTracePixelValue(uint64_t a1, uint64_t a2, int a3, double a4, double a5, double a6)
{
  uint64_t v6;
  __int16 v7;
  double result;
  _BYTE *v9;

  v6 = a2 + 0x8000;
  if (a3)
    v6 = a2;
  v7 = v6 + 255;
  if (v6 >= 0)
    HIBYTE(v7) = BYTE1(v6);
  result = a4 + a6 * a5;
  v9 = (_BYTE *)(a1 + 4 * (uint64_t)result);
  *v9 = v6;
  v9[1] = HIBYTE(v7);
  v9[3] = -1;
  return result;
}

uint64_t TSDMetalEdgeDistanceFieldBufferSurroundingTracePixelValueClosestToZero(uint64_t a1, int a2, double a3, double a4, double a5, double a6)
{
  char v6;
  uint64_t v12;
  uint64_t v13;
  double v14;
  double v15;
  BOOL v16;
  unsigned __int16 *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;

  v6 = a2;
  v12 = 0;
  if (a2)
    v13 = 0x8000000000000000;
  else
    v13 = 0x7FFFFFFFFFFFFFFFLL;
  do
  {
    v14 = TSDAddPoints(a3, a4, *(double *)&kNeighboring8Points[v12]);
    if (v14 >= 0.0)
    {
      v16 = v15 >= 0.0 && v14 < a5;
      if (v16 && v15 < a6)
      {
        v18 = (unsigned __int16 *)(a1 + 4 * (uint64_t)(v14 + a5 * v15));
        if (*((_BYTE *)v18 + 3))
        {
          v19 = *v18;
          v20 = v19 - 0x8000;
          v16 = v19 - 0x8000 < 0;
          v21 = 0x8000 - v19;
          if (!v16)
            v21 = v20;
          if (v13 >= 0)
            v22 = v13;
          else
            v22 = -v13;
          if ((v6 & 1) == 0)
          {
            if (v21 >= v22)
              goto LABEL_24;
LABEL_23:
            v13 = v20;
            goto LABEL_24;
          }
          if (v21 > v22)
            goto LABEL_23;
        }
      }
    }
LABEL_24:
    v12 += 2;
  }
  while (v12 != 8);
  return v13;
}

uint64_t TSDMetalEdgeDistanceFieldBufferNeighborPixelsClosestToZero(uint64_t a1, int64_t a2, _OWORD *a3, double a4, double a5, double a6, double a7)
{
  uint64_t v14;
  int64_t v15;
  double v16;
  double v17;
  BOOL v18;
  double *v20;
  uint64_t v21;
  __int128 *v22;
  __int128 v23;
  _BYTE __base[192];
  _QWORD v26[24];

  v14 = 0;
  v15 = 0;
  v26[23] = *MEMORY[0x24BDAC8D0];
  do
  {
    v16 = TSDAddPoints(a4, a5, *(double *)&kNeighboring8Points[v14]);
    if (v16 >= 0.0)
    {
      v18 = v17 >= 0.0 && v16 < a6;
      if (v18 && v17 < a7)
      {
        v20 = (double *)&__base[24 * v15++];
        *v20 = *(float *)(a1 + 4 * (uint64_t)(v16 + a6 * v17));
        v20[1] = v16;
        v20[2] = v17;
      }
    }
    v14 += 2;
  }
  while (v14 != 16);
  if (v15 >= a2)
    v21 = a2;
  else
    v21 = v15;
  if (v21 > 0)
  {
    qsort_b(__base, v15, 0x18uLL, &__block_literal_global_35);
    if (a3)
    {
      v22 = (__int128 *)v26;
      do
      {
        v23 = *v22;
        v22 = (__int128 *)((char *)v22 + 24);
        *a3++ = v23;
        --a2;
      }
      while (a2);
    }
  }
  return v21;
}

uint64_t TSDMetalEdgeDistanceFieldBufferNeighborPixelIsZero(uint64_t a1, double a2, double a3, double a4, double a5)
{
  uint64_t v10;
  float v11;
  double v12;
  double v13;
  BOOL v14;
  BOOL v15;

  v10 = 0;
  v11 = fabsf(*(float *)(a1 + 4 * (uint64_t)(a2 + a4 * a3)));
  while (1)
  {
    v12 = TSDAddPoints(a2, a3, *(double *)&kNeighboring8Points[v10]);
    if (v12 >= 0.0)
    {
      v14 = v13 >= 0.0 && v12 < a4;
      v15 = v14 && v13 < a5;
      if (v15 && fabsf(*(float *)(a1 + 4 * (uint64_t)(v12 + a4 * v13))) < v11)
        break;
    }
    v10 += 2;
    if (v10 == 16)
      return 1;
  }
  return 0;
}

BOOL TSDMetalEdgeDistanceFieldValueIsGreaterThanStrokeWidth(double a1, double a2, double a3, double a4)
{
  double v4;

  v4 = fabs(a1);
  if (a3 <= a4)
    a3 = a4;
  return v4 > a2 / a3;
}

void Shape::Shape(Shape *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((_QWORD *)this + 6) = 1;
  *((_QWORD *)this + 16) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
}

{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((_QWORD *)this + 6) = 1;
  *((_QWORD *)this + 16) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
}

void Shape::~Shape(void **this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  if (*((int *)this + 5) >= 1)
    free(this[3]);
  this[2] = 0;
  this[3] = 0;
  if (*((int *)this + 9) >= 1)
    free(this[5]);
  this[4] = 0;
  this[5] = 0;
  v2 = this[7];
  if (v2)
    free(v2);
  v3 = this[12];
  if (v3)
    free(v3);
  v4 = this[8];
  if (v4)
    free(v4);
  v5 = this[9];
  if (v5)
    free(v5);
  v6 = this[10];
  if (v6)
    free(v6);
  v7 = this[16];
  if (v7)
    free(v7);
  v8 = this[11];
  if (v8)
    free(v8);
  v9 = this[13];
  if (v9)
    free(v9);
  v10 = this[14];
  if (v10)
    free(v10);
}

void Shape::MakePointData(Shape *this, int a2)
{
  int v3;
  void *v4;
  void *v5;

  v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 4) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 4;
      v4 = (void *)*((_QWORD *)this + 11);
      if (v4)
        free(v4);
      *((_QWORD *)this + 11) = malloc_type_malloc(48 * *((int *)this + 5), 0x102004023ED6C3AuLL);
    }
  }
  else if ((v3 & 4) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFFFB;
    v5 = (void *)*((_QWORD *)this + 11);
    if (v5)
    {
      free(v5);
      *((_QWORD *)this + 11) = 0;
    }
  }
}

void Shape::MakeEdgeData(Shape *this, int a2)
{
  int v3;
  void *v4;
  void *v5;

  v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 8) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 8;
      v4 = (void *)*((_QWORD *)this + 7);
      if (v4)
        free(v4);
      *((_QWORD *)this + 7) = malloc_type_malloc((uint64_t)*((int *)this + 9) << 6, 0x100004094D12286uLL);
    }
  }
  else if ((v3 & 8) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFFF7;
    v5 = (void *)*((_QWORD *)this + 7);
    if (v5)
    {
      free(v5);
      *((_QWORD *)this + 7) = 0;
    }
  }
}

void Shape::MakeRasterData(Shape *this, int a2)
{
  int v3;
  void *v4;
  void *v5;

  v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 0x80) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 0x80;
      v4 = (void *)*((_QWORD *)this + 10);
      if (v4)
        free(v4);
      *((_QWORD *)this + 10) = malloc_type_malloc(48 * *((int *)this + 9), 0x10200403C9B7522uLL);
    }
  }
  else if ((v3 & 0x80) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFF7F;
    v5 = (void *)*((_QWORD *)this + 10);
    if (v5)
    {
      free(v5);
      *((_QWORD *)this + 10) = 0;
    }
  }
}

void Shape::MakeQuickRasterData(Shape *this, int a2)
{
  int v3;
  void *v4;
  void *v5;

  v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 0x100) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 0x100;
      v4 = (void *)*((_QWORD *)this + 16);
      if (v4)
        free(v4);
      *((_QWORD *)this + 16) = malloc_type_malloc(16 * *((int *)this + 9), 0x10000408B6DE1C6uLL);
    }
  }
  else if ((v3 & 0x100) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFEFF;
    v5 = (void *)*((_QWORD *)this + 16);
    if (v5)
    {
      free(v5);
      *((_QWORD *)this + 16) = 0;
    }
  }
}

void Shape::MakeSweepSrcData(Shape *this, int a2)
{
  int v3;
  void *v4;
  void *v5;

  v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 0x10) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 0x10;
      v4 = (void *)*((_QWORD *)this + 8);
      if (v4)
        free(v4);
      *((_QWORD *)this + 8) = malloc_type_malloc(56 * *((int *)this + 9), 0x10A0040A41B8C3EuLL);
    }
  }
  else if ((v3 & 0x10) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFFEF;
    v5 = (void *)*((_QWORD *)this + 8);
    if (v5)
    {
      free(v5);
      *((_QWORD *)this + 8) = 0;
    }
  }
}

void Shape::MakeSweepDestData(Shape *this, int a2)
{
  int v3;
  void *v4;
  void *v5;

  v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 0x20) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 0x20;
      v4 = (void *)*((_QWORD *)this + 9);
      if (v4)
        free(v4);
      *((_QWORD *)this + 9) = malloc_type_malloc(32 * *((int *)this + 9), 0x1080040DCAC275BuLL);
    }
  }
  else if ((v3 & 0x20) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFFDF;
    v5 = (void *)*((_QWORD *)this + 9);
    if (v5)
    {
      free(v5);
      *((_QWORD *)this + 9) = 0;
    }
  }
}

void Shape::MakeBackData(Shape *this, int a2)
{
  int v3;
  void *v4;
  void *v5;

  v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 0x200) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 0x200;
      v4 = (void *)*((_QWORD *)this + 12);
      if (v4)
        free(v4);
      *((_QWORD *)this + 12) = malloc_type_malloc(16 * *((int *)this + 9), 0x1000040451B5BE8uLL);
    }
  }
  else if ((v3 & 0x200) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFDFF;
    v5 = (void *)*((_QWORD *)this + 12);
    if (v5)
    {
      free(v5);
      *((_QWORD *)this + 12) = 0;
    }
  }
}

void Shape::MakeVoronoiData(Shape *this, int a2)
{
  int v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v3 = *((_DWORD *)this + 13);
  if (a2)
  {
    if ((v3 & 0x400) == 0)
    {
      *((_DWORD *)this + 13) = v3 | 0x400;
      v4 = (void *)*((_QWORD *)this + 13);
      if (v4)
        free(v4);
      v5 = (void *)*((_QWORD *)this + 14);
      if (v5)
        free(v5);
      *((_QWORD *)this + 13) = malloc_type_malloc(8 * *((int *)this + 5), 0x100004000313F17uLL);
      *((_QWORD *)this + 14) = malloc_type_malloc(40 * *((int *)this + 9), 0x10000400A747E1EuLL);
    }
  }
  else if ((v3 & 0x400) != 0)
  {
    *((_DWORD *)this + 13) = v3 & 0xFFFFFBFF;
    v6 = (void *)*((_QWORD *)this + 13);
    if (v6)
    {
      free(v6);
      *((_QWORD *)this + 13) = 0;
    }
    v7 = (void *)*((_QWORD *)this + 14);
    if (v7)
    {
      free(v7);
      *((_QWORD *)this + 14) = 0;
    }
  }
}

void **Shape::Copy(void **this, Shape *a2)
{
  int v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  int v12;
  uint64_t v13;
  int v14;

  if (!a2)
    return Shape::Reset(this, 0);
  v4 = *((_DWORD *)this + 13);
  if ((v4 & 4) != 0)
  {
    v4 &= ~4u;
    *((_DWORD *)this + 13) = v4;
    v5 = this[11];
    if (v5)
    {
      free(v5);
      this[11] = 0;
      v4 = *((_DWORD *)this + 13);
    }
  }
  if ((v4 & 8) != 0)
  {
    v4 &= ~8u;
    *((_DWORD *)this + 13) = v4;
    v6 = this[7];
    if (v6)
    {
      free(v6);
      this[7] = 0;
      v4 = *((_DWORD *)this + 13);
    }
  }
  if ((v4 & 0x10) != 0)
  {
    v4 &= ~0x10u;
    *((_DWORD *)this + 13) = v4;
    v7 = this[8];
    if (v7)
    {
      free(v7);
      this[8] = 0;
      v4 = *((_DWORD *)this + 13);
    }
  }
  if ((v4 & 0x20) != 0)
  {
    v4 &= ~0x20u;
    *((_DWORD *)this + 13) = v4;
    v8 = this[9];
    if (v8)
    {
      free(v8);
      this[9] = 0;
      v4 = *((_DWORD *)this + 13);
    }
  }
  if ((v4 & 0x80) != 0)
  {
    v4 &= ~0x80u;
    *((_DWORD *)this + 13) = v4;
    v9 = this[10];
    if (v9)
    {
      free(v9);
      this[10] = 0;
      v4 = *((_DWORD *)this + 13);
    }
  }
  if ((v4 & 0x100) != 0)
  {
    v4 &= ~0x100u;
    *((_DWORD *)this + 13) = v4;
    v10 = this[16];
    if (v10)
    {
      free(v10);
      this[16] = 0;
      v4 = *((_DWORD *)this + 13);
    }
  }
  if ((v4 & 0x200) != 0)
  {
    v4 &= ~0x200u;
    *((_DWORD *)this + 13) = v4;
    v11 = this[12];
    if (v11)
    {
      free(v11);
      this[12] = 0;
      v4 = *((_DWORD *)this + 13);
    }
  }
  if ((v4 & 0x40) != 0)
  {
    SweepTree::DestroyList(this + 21);
    SweepEvent::DestroyQueue(this + 24);
    v12 = *((_DWORD *)this + 13);
    if ((v12 & 0x40) != 0)
      *((_DWORD *)this + 13) = v12 & 0xFFFFFFBF;
  }
  Shape::Reset(this, *((_DWORD *)a2 + 4));
  v13 = *((int *)a2 + 4);
  *((_DWORD *)this + 4) = v13;
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  v14 = *((_DWORD *)a2 + 13) & 3;
  *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
  *((_DWORD *)this + 13) = v14;
  memcpy(this[3], *((const void **)a2 + 3), 28 * v13);
  return (void **)memcpy(this[5], *((const void **)a2 + 5), 32 * *((int *)this + 8));
}

void **Shape::Reset(void **this, int a2)
{
  void **v3;
  int v4;
  int v5;

  v3 = this;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 12) = 1;
  if (*((_DWORD *)this + 5) < a2)
  {
    *((_DWORD *)this + 5) = a2;
    this = (void **)malloc_type_realloc(this[3], 28 * a2, 0x100004027586B93uLL);
    v3[3] = this;
    v4 = *((_DWORD *)v3 + 13);
    if ((v4 & 4) != 0)
    {
      this = (void **)malloc_type_realloc(v3[11], 48 * *((int *)v3 + 5), 0x102004023ED6C3AuLL);
      v3[11] = this;
      v4 = *((_DWORD *)v3 + 13);
    }
    if ((v4 & 0x400) != 0)
    {
      this = (void **)malloc_type_realloc(v3[13], 8 * *((int *)v3 + 5), 0x100004000313F17uLL);
      v3[13] = this;
    }
  }
  if (*((_DWORD *)v3 + 9) >= a2)
    goto LABEL_13;
  *((_DWORD *)v3 + 9) = a2;
  this = (void **)malloc_type_realloc(v3[5], 32 * a2, 0x1000040E0EAB150uLL);
  v3[5] = this;
  v5 = *((_DWORD *)v3 + 13);
  if ((v5 & 8) != 0)
  {
    this = (void **)malloc_type_realloc(v3[7], (uint64_t)*((int *)v3 + 9) << 6, 0x100004094D12286uLL);
    v3[7] = this;
    v5 = *((_DWORD *)v3 + 13);
    if ((v5 & 0x20) == 0)
    {
LABEL_9:
      if ((v5 & 0x10) == 0)
        goto LABEL_10;
LABEL_18:
      this = (void **)malloc_type_realloc(v3[8], 56 * *((int *)v3 + 9), 0x10A0040A41B8C3EuLL);
      v3[8] = this;
      v5 = *((_DWORD *)v3 + 13);
      if ((v5 & 0x200) == 0)
      {
LABEL_11:
        if ((v5 & 0x400) == 0)
          goto LABEL_13;
        goto LABEL_12;
      }
      goto LABEL_19;
    }
  }
  else if ((v5 & 0x20) == 0)
  {
    goto LABEL_9;
  }
  this = (void **)malloc_type_realloc(v3[9], 32 * *((int *)v3 + 9), 0x1080040DCAC275BuLL);
  v3[9] = this;
  v5 = *((_DWORD *)v3 + 13);
  if ((v5 & 0x10) != 0)
    goto LABEL_18;
LABEL_10:
  if ((v5 & 0x200) == 0)
    goto LABEL_11;
LABEL_19:
  this = (void **)malloc_type_realloc(v3[12], 16 * *((int *)v3 + 9), 0x1000040451B5BE8uLL);
  v3[12] = this;
  if ((*((_DWORD *)v3 + 13) & 0x400) != 0)
  {
LABEL_12:
    this = (void **)malloc_type_realloc(v3[14], 40 * *((int *)v3 + 9), 0x10000400A747E1EuLL);
    v3[14] = this;
  }
LABEL_13:
  if ((*((_DWORD *)v3 + 13) & 3) != 0)
    *((_DWORD *)v3 + 13) &= *((_DWORD *)v3 + 13) & 2 ^ 0xFFFFFFFE;
  return this;
}

BOOL Shape::GetFlag(Shape *this, int a2)
{
  return (*((_DWORD *)this + 13) & a2) != 0;
}

uint64_t Shape::SetFlag(Shape *this, int a2, int a3)
{
  int v3;
  int v4;
  int v5;

  v3 = *((_DWORD *)this + 13);
  v4 = v3 & a2;
  if (a3)
  {
    if (!v4)
    {
      v5 = v3 | a2;
LABEL_6:
      *((_DWORD *)this + 13) = v5;
      return 1;
    }
  }
  else if (v4)
  {
    v5 = v3 & ~a2;
    goto LABEL_6;
  }
  return 0;
}

uint64_t Shape::AddPoint(Shape *this, float a2, float a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t result;
  uint64_t v10;
  int v11;
  uint64_t v12;

  v6 = *((int *)this + 4);
  if ((int)v6 >= *((_DWORD *)this + 5))
  {
    v7 = (2 * v6) | 1;
    *((_DWORD *)this + 5) = v7;
    *((_QWORD *)this + 3) = malloc_type_realloc(*((void **)this + 3), 28 * v7, 0x100004027586B93uLL);
    v8 = *((_DWORD *)this + 13);
    if ((v8 & 4) != 0)
    {
      *((_QWORD *)this + 11) = malloc_type_realloc(*((void **)this + 11), 48 * *((int *)this + 5), 0x102004023ED6C3AuLL);
      v8 = *((_DWORD *)this + 13);
    }
    if ((v8 & 0x400) != 0)
      *((_QWORD *)this + 13) = malloc_type_realloc(*((void **)this + 13), 8 * *((int *)this + 5), 0x100004000313F17uLL);
  }
  result = *((int *)this + 4);
  *((_DWORD *)this + 4) = result + 1;
  v10 = *((_QWORD *)this + 3) + 28 * (int)result;
  *(float *)v10 = a2;
  *(float *)(v10 + 4) = a3;
  *(_OWORD *)(v10 + 8) = xmmword_217C29B30;
  v11 = *((_DWORD *)this + 13);
  if ((v11 & 4) != 0)
  {
    v12 = *((_QWORD *)this + 11) + 48 * (int)result;
    *(_QWORD *)(v12 + 8) = 0xFFFFFFFF00000000;
    *(_DWORD *)(v12 + 16) = -1;
    *(_QWORD *)(v12 + 24) = 0;
    *(_DWORD *)(v12 + 32) = -1;
    if ((v11 & 0x400) == 0)
    {
LABEL_8:
      if ((v11 & 1) != 0)
        return result;
      goto LABEL_9;
    }
  }
  else if ((v11 & 0x400) == 0)
  {
    goto LABEL_8;
  }
  *(_QWORD *)(*((_QWORD *)this + 13) + 8 * result) = 0xFFFFFFFE00000000;
  if ((v11 & 1) != 0)
    return result;
LABEL_9:
  *((_DWORD *)this + 13) = v11 | 1;
  return result;
}

uint64_t Shape::SubPoint(uint64_t this, int a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  _DWORD *v11;
  _DWORD *v12;
  _DWORD *v13;
  _DWORD *v14;
  _DWORD *v15;
  int v16;
  uint64_t v17;
  int v18;

  if ((a2 & 0x80000000) == 0)
  {
    v2 = this;
    v3 = *(_DWORD *)(this + 16);
    if (v3 > a2)
    {
      v4 = *(_DWORD *)(this + 52);
      if ((v4 & 1) == 0)
        *(_DWORD *)(this + 52) = v4 | 1;
      v5 = *(_QWORD *)(this + 24) + 28 * a2;
      v8 = *(_DWORD *)(v5 + 16);
      v6 = (_QWORD *)(v5 + 16);
      v7 = v8;
      if ((v8 & 0x80000000) == 0)
      {
        v9 = *(_DWORD *)(this + 32);
        do
        {
          if ((int)v7 >= v9)
            break;
          v10 = *(_QWORD *)(this + 40);
          v11 = (_DWORD *)(v10 + 32 * v7);
          v12 = v11 + 2;
          if (v11[2] == a2)
          {
            v13 = v11 + 4;
            v14 = v11 + 5;
          }
          else
          {
            v16 = v11[3];
            v15 = v11 + 3;
            if (v16 != a2)
              break;
            v17 = v10 + 32 * v7;
            v13 = (_DWORD *)(v17 + 24);
            v14 = (_DWORD *)(v17 + 28);
            v12 = v15;
          }
          v7 = *v13;
          *v14 = -1;
          *v13 = -1;
          *v12 = -1;
        }
        while ((v7 & 0x80000000) == 0);
      }
      *v6 = -1;
      v18 = v3 - 1;
      if (v3 - 1 > a2)
      {
        this = Shape::SwapPoints(this, a2, v18);
        v18 = *(_DWORD *)(v2 + 16) - 1;
      }
      *(_DWORD *)(v2 + 16) = v18;
    }
  }
  return this;
}

uint64_t Shape::SwapPoints(uint64_t this, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  _DWORD *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  _DWORD *v15;
  _DWORD *v16;
  int v17;
  uint64_t v18;
  _DWORD *v19;
  _DWORD *v20;
  int v21;
  uint64_t v22;
  _DWORD *v23;
  _DWORD *v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  _DWORD *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _DWORD *v39;
  _DWORD *v40;
  int v41;
  int v42;
  uint64_t v43;
  _DWORD *v44;
  _DWORD *v45;
  int v46;
  _OWORD *v47;
  _OWORD *v48;
  __int128 v49;
  _OWORD *v50;
  int v51;
  uint64_t v52;
  __int128 *v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 *v57;
  __int128 v58;
  __int128 v59;
  _OWORD *v60;
  uint64_t v61;
  uint64_t v62;
  _BYTE v63[28];

  if (a2 == a3)
    return this;
  v3 = *(_QWORD *)(this + 24);
  if (*(_DWORD *)(v3 + 28 * a2 + 12) + *(_DWORD *)(v3 + 28 * a2 + 8) == 2
    && *(_DWORD *)(v3 + 28 * a3 + 12) + *(_DWORD *)(v3 + 28 * a3 + 8) == 2)
  {
    v4 = a3;
    v5 = *(int *)(v3 + 28 * a2 + 16);
    v6 = *(_QWORD *)(this + 40);
    v7 = v6 + 32 * v5;
    v8 = (_DWORD *)(v7 + 8);
    v9 = (_DWORD *)(v7 + 8);
    if (*(_DWORD *)(v7 + 8) != a2)
    {
      v11 = *(_DWORD *)(v7 + 12);
      v10 = (_DWORD *)(v7 + 12);
      if (v11 != a2)
        goto LABEL_8;
      v9 = v10;
    }
    *v9 = *(_DWORD *)(this + 16);
LABEL_8:
    v12 = *(int *)(v3 + 28 * a2 + 20);
    v13 = v6 + 32 * v12;
    v14 = (_DWORD *)(v13 + 8);
    v15 = (_DWORD *)(v13 + 8);
    if (*(_DWORD *)(v13 + 8) != a2)
    {
      v17 = *(_DWORD *)(v13 + 12);
      v16 = (_DWORD *)(v13 + 12);
      if (v17 != a2)
        goto LABEL_12;
      v15 = v16;
    }
    *v15 = *(_DWORD *)(this + 16);
LABEL_12:
    v18 = v6 + 32 * *(int *)(v3 + 28 * a3 + 16);
    v19 = (_DWORD *)(v18 + 8);
    if (*(_DWORD *)(v18 + 8) != a3)
    {
      v21 = *(_DWORD *)(v18 + 12);
      v20 = (_DWORD *)(v18 + 12);
      if (v21 != a3)
        goto LABEL_16;
      v19 = v20;
    }
    *v19 = a2;
LABEL_16:
    v22 = v6 + 32 * *(int *)(v3 + 28 * a3 + 20);
    v23 = (_DWORD *)(v22 + 8);
    if (*(_DWORD *)(v22 + 8) != a3)
    {
      v25 = *(_DWORD *)(v22 + 12);
      v24 = (_DWORD *)(v22 + 12);
      if (v25 != a3)
        goto LABEL_20;
      v23 = v24;
    }
    *v23 = a2;
LABEL_20:
    v26 = *(_DWORD *)(this + 16);
    if (*v8 == v26 || (v27 = v6 + 32 * v5, v28 = *(_DWORD *)(v27 + 12), v8 = (_DWORD *)(v27 + 12), v28 == v26))
      *v8 = a3;
    if (*v14 == v26 || (v29 = v6 + 32 * v12, v30 = *(_DWORD *)(v29 + 12), v14 = (_DWORD *)(v29 + 12), v30 == v26))
      *v14 = a3;
    goto LABEL_56;
  }
  v31 = *(unsigned int *)(v3 + 28 * a2 + 16);
  if ((v31 & 0x80000000) == 0)
  {
    v32 = *(_QWORD *)(this + 40);
    v33 = *(unsigned int *)(v3 + 28 * a2 + 16);
    do
    {
      v34 = (_DWORD *)(v32 + 32 * v33);
      if (v34[2] == a2)
      {
        v33 = v34[4];
        v35 = v34 + 2;
      }
      else
      {
        v36 = v34[3];
        v35 = v34 + 3;
        if (v36 == a2)
          v33 = *(unsigned int *)(v32 + 32 * v33 + 24);
        else
          v33 = 0xFFFFFFFFLL;
        if (*v35 != a2)
          continue;
      }
      *v35 = *(_DWORD *)(this + 16);
    }
    while ((v33 & 0x80000000) == 0);
  }
  v4 = a3;
  v37 = *(unsigned int *)(v3 + 28 * a3 + 16);
  if ((v37 & 0x80000000) == 0)
  {
    v38 = *(_QWORD *)(this + 40);
    do
    {
      v39 = (_DWORD *)(v38 + 32 * v37);
      if (v39[2] == a3)
      {
        v37 = v39[4];
        v40 = v39 + 2;
      }
      else
      {
        v41 = v39[3];
        v40 = v39 + 3;
        if (v41 == a3)
          v37 = *(unsigned int *)(v38 + 32 * v37 + 24);
        else
          v37 = 0xFFFFFFFFLL;
        if (*v40 != a3)
          continue;
      }
      *v40 = a2;
    }
    while ((v37 & 0x80000000) == 0);
  }
  if ((v31 & 0x80000000) == 0)
  {
    v42 = *(_DWORD *)(this + 16);
    v43 = *(_QWORD *)(this + 40);
    do
    {
      v44 = (_DWORD *)(v43 + 32 * v31);
      if (v44[2] == v42)
      {
        v31 = v44[4];
        v45 = v44 + 2;
      }
      else
      {
        v46 = v44[3];
        v45 = v44 + 3;
        if (v46 == v42)
          v31 = *(unsigned int *)(v43 + 32 * v31 + 24);
        else
          v31 = 0xFFFFFFFFLL;
        if (*v45 != v42)
          continue;
      }
      *v45 = a3;
    }
    while ((v31 & 0x80000000) == 0);
  }
LABEL_56:
  v47 = (_OWORD *)(v3 + 28 * a2);
  *(_OWORD *)v63 = *v47;
  *(_OWORD *)&v63[12] = *(_OWORD *)((char *)v47 + 12);
  v48 = (_OWORD *)(v3 + 28 * v4);
  v49 = *(_OWORD *)((char *)v48 + 12);
  *v47 = *v48;
  *(_OWORD *)((char *)v47 + 12) = v49;
  v50 = (_OWORD *)(*(_QWORD *)(this + 24) + 28 * v4);
  *v50 = *(_OWORD *)v63;
  *(_OWORD *)((char *)v50 + 12) = *(_OWORD *)&v63[12];
  v51 = *(_DWORD *)(this + 52);
  if ((v51 & 4) != 0)
  {
    v52 = *(_QWORD *)(this + 88);
    v53 = (__int128 *)(v52 + 48 * a2);
    v55 = v53[1];
    v54 = v53[2];
    v56 = *v53;
    v57 = (__int128 *)(v52 + 48 * v4);
    v59 = v57[1];
    v58 = v57[2];
    *v53 = *v57;
    v53[1] = v59;
    v53[2] = v58;
    v60 = (_OWORD *)(*(_QWORD *)(this + 88) + 48 * v4);
    *v60 = v56;
    v60[1] = v55;
    v60[2] = v54;
    v51 = *(_DWORD *)(this + 52);
  }
  if ((v51 & 0x400) != 0)
  {
    v61 = *(_QWORD *)(this + 104);
    v62 = *(_QWORD *)(v61 + 8 * a2);
    *(_QWORD *)(v61 + 8 * a2) = *(_QWORD *)(v61 + 8 * v4);
    *(_QWORD *)(*(_QWORD *)(this + 104) + 8 * v4) = v62;
  }
  return this;
}

uint64_t Shape::SwapPoints(uint64_t this, int a2, int a3, int a4)
{
  uint64_t v6;

  if (a2 != a4 && a2 != a3 && a3 != a4)
  {
    v6 = this;
    Shape::SwapPoints(this, a2, a3);
    return Shape::SwapPoints(v6, a3, a4);
  }
  return this;
}

Shape *Shape::SortPoints(Shape *this)
{
  int v1;
  Shape *v2;
  int v3;

  v1 = *((_DWORD *)this + 13);
  if ((v1 & 1) != 0)
  {
    v2 = this;
    v3 = *((_DWORD *)this + 4);
    if (v3 < 1 || (this = Shape::SortPoints(this, 0, v3 - 1), v1 = *((_DWORD *)v2 + 13), (v1 & 1) != 0))
      *((_DWORD *)v2 + 13) = v1 & 0xFFFFFFFE;
  }
  return this;
}

Shape *Shape::SortPoints(Shape *this, int a2, int a3)
{
  int v4;
  Shape *v5;
  int v6;
  int v7;
  float *v8;
  float v9;
  float v10;
  BOOL v11;
  BOOL v12;
  int v13;
  int v14;
  int v15;
  float *v16;
  float v17;
  float *v18;
  float v19;
  uint64_t v20;
  float *v21;
  float v22;
  float *v23;
  float v24;

  if (a2 < a3)
  {
    v4 = a2;
    v5 = this;
    while (v4 + 1 != a3)
    {
      v6 = v4 + a3;
      if (v4 + a3 < 0 != __OFADD__(v4, a3))
        ++v6;
      v7 = v6 >> 1;
      v8 = (float *)(*((_QWORD *)v5 + 3) + 28 * (v6 >> 1));
      v9 = *v8;
      v10 = v8[1];
      v11 = v6 >> 1 < a3;
      v12 = v4 < v6 >> 1;
      if (v12 || v7 < a3)
      {
        v14 = a3;
        v15 = v4;
        v13 = v7;
        do
        {
          if (v12)
          {
            do
            {
              v16 = (float *)(*((_QWORD *)v5 + 3) + 28 * v15);
              v17 = v16[1];
              if (v17 > v10)
                break;
              if (v17 != v10)
                goto LABEL_19;
              if (*v16 > v9)
                break;
              if (*v16 == v9)
              {
                if (v15 >= v13 - 1)
                {
                  if (v15 == v13 - 1)
                    --v13;
                  if (v11)
                  {
                    while (1)
                    {
LABEL_22:
                      v18 = (float *)(*((_QWORD *)v5 + 3) + 28 * v14);
                      v19 = v18[1];
                      if (v19 > v10)
                        goto LABEL_25;
                      if (v19 != v10)
                        goto LABEL_30;
                      if (*v18 <= v9)
                      {
                        if (*v18 != v9)
                          goto LABEL_30;
                        if (v14 <= v7 + 1)
                        {
                          if (v14 == v7 + 1)
                            ++v7;
                          goto LABEL_30;
                        }
                        Shape::SwapPoints((uint64_t)v5, v14, v7 + 1, v7);
                        ++v7;
                      }
                      else
                      {
LABEL_25:
                        --v14;
                      }
                      if (v14 <= v7)
                        goto LABEL_30;
                    }
                  }
                  goto LABEL_30;
                }
                Shape::SwapPoints((uint64_t)v5, v15, v13 - 1, v13);
                --v13;
              }
              else
              {
LABEL_19:
                ++v15;
              }
            }
            while (v15 < v13);
          }
          if (v11)
            goto LABEL_22;
LABEL_30:
          if (v15 >= v13)
          {
            if (v14 <= v7 + 1)
            {
              if (v14 != v7 + 1)
                break;
              Shape::SwapPoints((uint64_t)v5, v13++, v14);
              v7 = v14;
            }
            else
            {
              Shape::SwapPoints((uint64_t)v5, ++v7, v13++, v14);
            }
          }
          else if (v14 <= v7)
          {
            if (v15 >= v13 - 1)
            {
              if (v15 == v13 - 1)
              {
                Shape::SwapPoints((uint64_t)v5, v7--, v15);
                v13 = v15;
              }
            }
            else
            {
              Shape::SwapPoints((uint64_t)v5, --v13, v7--, v15);
            }
          }
          else
          {
            Shape::SwapPoints((uint64_t)v5, v15++, v14--);
          }
          v11 = v14 > v7;
          v12 = v15 < v13;
        }
        while (v15 < v13 || v14 > v7);
      }
      else
      {
        v13 = v7;
      }
      this = (Shape *)Shape::SortPoints(v5, v4, v13 - 1);
      v4 = v7 + 1;
      if (v7 + 1 >= a3)
        return this;
    }
    v20 = *((_QWORD *)v5 + 3);
    v21 = (float *)(v20 + 28 * v4);
    v22 = v21[1];
    v23 = (float *)(v20 + 28 * a3);
    v24 = v23[1];
    if (v22 > v24 || v22 == v24 && *v21 > *v23)
      return (Shape *)Shape::SwapPoints((uint64_t)v5, v4, a3);
  }
  return this;
}

Shape *Shape::SortPointsRounded(Shape *this)
{
  int v1;

  v1 = *((_DWORD *)this + 4);
  if (v1 >= 1)
    return Shape::SortPointsRounded(this, 0, v1 - 1);
  return this;
}

Shape *Shape::SortPointsRounded(Shape *this, int a2, int a3)
{
  int v4;
  Shape *v5;
  int v6;
  int v7;
  uint64_t v8;
  float v9;
  float v10;
  BOOL v11;
  BOOL v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  float v17;
  float v18;
  uint64_t v19;
  float v20;
  float v21;
  uint64_t v22;
  float v23;
  float v24;

  if (a2 < a3)
  {
    v4 = a2;
    v5 = this;
    while (v4 + 1 != a3)
    {
      v6 = v4 + a3;
      if (v4 + a3 < 0 != __OFADD__(v4, a3))
        ++v6;
      v7 = v6 >> 1;
      v8 = *((_QWORD *)v5 + 11) + 48 * (v6 >> 1);
      v9 = *(float *)(v8 + 36);
      v10 = *(float *)(v8 + 40);
      v11 = v6 >> 1 < a3;
      v12 = v4 < v6 >> 1;
      if (v12 || v7 < a3)
      {
        v14 = a3;
        v15 = v4;
        v13 = v7;
        do
        {
          if (v12)
          {
            do
            {
              v16 = *((_QWORD *)v5 + 11);
              v17 = *(float *)(v16 + 48 * v15 + 40);
              if (v17 > v10)
                break;
              if (v17 != v10)
                goto LABEL_19;
              v18 = *(float *)(v16 + 48 * v15 + 36);
              if (v18 > v9)
                break;
              if (v18 == v9)
              {
                if (v15 >= v13 - 1)
                {
                  if (v15 == v13 - 1)
                    --v13;
                  if (v11)
                  {
                    while (1)
                    {
LABEL_22:
                      v19 = *((_QWORD *)v5 + 11);
                      v20 = *(float *)(v19 + 48 * v14 + 40);
                      if (v20 > v10)
                        goto LABEL_25;
                      if (v20 != v10)
                        goto LABEL_30;
                      v21 = *(float *)(v19 + 48 * v14 + 36);
                      if (v21 <= v9)
                      {
                        if (v21 != v9)
                          goto LABEL_30;
                        if (v14 <= v7 + 1)
                        {
                          if (v14 == v7 + 1)
                            ++v7;
                          goto LABEL_30;
                        }
                        Shape::SwapPoints((uint64_t)v5, v14, v7 + 1, v7);
                        ++v7;
                      }
                      else
                      {
LABEL_25:
                        --v14;
                      }
                      if (v14 <= v7)
                        goto LABEL_30;
                    }
                  }
                  goto LABEL_30;
                }
                Shape::SwapPoints((uint64_t)v5, v15, v13 - 1, v13);
                --v13;
              }
              else
              {
LABEL_19:
                ++v15;
              }
            }
            while (v15 < v13);
          }
          if (v11)
            goto LABEL_22;
LABEL_30:
          if (v15 >= v13)
          {
            if (v14 <= v7 + 1)
            {
              if (v14 != v7 + 1)
                break;
              Shape::SwapPoints((uint64_t)v5, v13++, v14);
              v7 = v14;
            }
            else
            {
              Shape::SwapPoints((uint64_t)v5, ++v7, v13++, v14);
            }
          }
          else if (v14 <= v7)
          {
            if (v15 >= v13 - 1)
            {
              if (v15 == v13 - 1)
              {
                Shape::SwapPoints((uint64_t)v5, v7--, v15);
                v13 = v15;
              }
            }
            else
            {
              Shape::SwapPoints((uint64_t)v5, --v13, v7--, v15);
            }
          }
          else
          {
            Shape::SwapPoints((uint64_t)v5, v15++, v14--);
          }
          v11 = v14 > v7;
          v12 = v15 < v13;
        }
        while (v15 < v13 || v14 > v7);
      }
      else
      {
        v13 = v7;
      }
      this = (Shape *)Shape::SortPointsRounded(v5, v4, v13 - 1);
      v4 = v7 + 1;
      if (v7 + 1 >= a3)
        return this;
    }
    v22 = *((_QWORD *)v5 + 11);
    v23 = *(float *)(v22 + 48 * v4 + 40);
    v24 = *(float *)(v22 + 48 * a3 + 40);
    if (v23 > v24 || v23 == v24 && *(float *)(v22 + 48 * v4 + 36) > *(float *)(v22 + 48 * a3 + 36))
      return (Shape *)Shape::SwapPoints((uint64_t)v5, v4, a3);
  }
  return this;
}

Shape *Shape::SortPointsByOldInd(Shape *this, int a2, int a3)
{
  Shape *v3;
  int v4;
  int v5;
  float *v6;
  float v7;
  float v8;
  int v9;
  BOOL v10;
  BOOL v11;
  int v12;
  int v13;
  int v14;
  float *v15;
  float v16;
  int v17;
  float *v18;
  float v19;
  int v20;
  uint64_t v21;
  float *v22;
  float v23;
  float *v24;
  float v25;
  int v26;
  int v27;

  if (a2 < a3)
  {
    v3 = this;
    v26 = a3;
    while (a2 + 1 != a3)
    {
      v4 = a2 + a3;
      if (a2 + a3 < 0 != __OFADD__(a2, a3))
        ++v4;
      v5 = v4 >> 1;
      v6 = (float *)(*((_QWORD *)v3 + 3) + 28 * (v4 >> 1));
      v7 = *v6;
      v8 = v6[1];
      v9 = *(_DWORD *)(*((_QWORD *)v3 + 11) + 48 * (v4 >> 1));
      v10 = v4 >> 1 < a3;
      v11 = a2 < v4 >> 1;
      v27 = a2;
      if (v11 || v5 < a3)
      {
        v13 = a3;
        v14 = a2;
        v12 = v5;
        do
        {
          if (v11)
          {
            do
            {
              v15 = (float *)(*((_QWORD *)v3 + 3) + 28 * v14);
              v16 = v15[1];
              if (v16 > v8)
                break;
              if (v16 != v8)
                goto LABEL_19;
              if (*v15 > v7)
                break;
              if (*v15 != v7)
                goto LABEL_19;
              v17 = *(_DWORD *)(*((_QWORD *)v3 + 11) + 48 * v14);
              if (v17 > v9)
                break;
              if (v17 == v9)
              {
                if (v14 >= v12 - 1)
                {
                  if (v14 == v12 - 1)
                    --v12;
                  if (v10)
                  {
                    while (1)
                    {
LABEL_22:
                      v18 = (float *)(*((_QWORD *)v3 + 3) + 28 * v13);
                      v19 = v18[1];
                      if (v19 > v8)
                        goto LABEL_27;
                      if (v19 != v8)
                        goto LABEL_39;
                      if (*v18 > v7)
                        goto LABEL_27;
                      if (*v18 != v7)
                        goto LABEL_39;
                      v20 = *(_DWORD *)(*((_QWORD *)v3 + 11) + 48 * v13);
                      if (v20 <= v9)
                      {
                        if (v20 != v9)
                          goto LABEL_39;
                        if (v13 <= v5 + 1)
                        {
                          if (v13 == v5 + 1)
                            ++v5;
                          goto LABEL_39;
                        }
                        Shape::SwapPoints((uint64_t)v3, v13, v5 + 1, v5);
                        ++v5;
                      }
                      else
                      {
LABEL_27:
                        --v13;
                      }
                      if (v13 <= v5)
                        goto LABEL_39;
                    }
                  }
                  goto LABEL_39;
                }
                Shape::SwapPoints((uint64_t)v3, v14, v12 - 1, v12);
                --v12;
              }
              else
              {
LABEL_19:
                ++v14;
              }
            }
            while (v14 < v12);
          }
          if (v10)
            goto LABEL_22;
LABEL_39:
          if (v14 >= v12)
          {
            if (v13 <= v5 + 1)
            {
              if (v13 != v5 + 1)
                break;
              Shape::SwapPoints((uint64_t)v3, v12++, v13);
              v5 = v13;
            }
            else
            {
              Shape::SwapPoints((uint64_t)v3, ++v5, v12++, v13);
            }
          }
          else if (v13 <= v5)
          {
            if (v14 >= v12 - 1)
            {
              if (v14 == v12 - 1)
              {
                Shape::SwapPoints((uint64_t)v3, v5--, v14);
                v12 = v14;
              }
            }
            else
            {
              Shape::SwapPoints((uint64_t)v3, --v12, v5--, v14);
            }
          }
          else
          {
            Shape::SwapPoints((uint64_t)v3, v14++, v13--);
          }
          v10 = v13 > v5;
          v11 = v14 < v12;
        }
        while (v14 < v12 || v13 > v5);
      }
      else
      {
        v12 = v5;
      }
      this = (Shape *)Shape::SortPointsByOldInd(v3, v27, v12 - 1);
      a2 = v5 + 1;
      a3 = v26;
      if (v5 + 1 >= v26)
        return this;
    }
    v21 = *((_QWORD *)v3 + 3);
    v22 = (float *)(v21 + 28 * a2);
    v23 = v22[1];
    v24 = (float *)(v21 + 28 * a3);
    v25 = v24[1];
    if (v23 > v25
      || v23 == v25
      && (*v22 > *v24
       || *v22 == *v24 && *(_DWORD *)(*((_QWORD *)v3 + 11) + 48 * a2) > *(_DWORD *)(*((_QWORD *)v3 + 11) + 48 * a3)))
    {
      return (Shape *)Shape::SwapPoints((uint64_t)v3, a2, a3);
    }
  }
  return this;
}

uint64_t Shape::AddEdge(Shape *this, unsigned int a2, unsigned int a3)
{
  uint64_t v3;
  int v7;
  int v8;
  int v9;
  float32x2_t *v10;
  int v11;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;

  v3 = 0xFFFFFFFFLL;
  if (a2 == a3 || ((a3 | a2) & 0x80000000) != 0)
    return v3;
  *((_DWORD *)this + 12) = 0;
  v7 = *((_DWORD *)this + 8);
  if (v7 < *((_DWORD *)this + 9))
    goto LABEL_11;
  v8 = (2 * v7) | 1;
  *((_DWORD *)this + 9) = v8;
  *((_QWORD *)this + 5) = malloc_type_realloc(*((void **)this + 5), 32 * v8, 0x1000040E0EAB150uLL);
  v9 = *((_DWORD *)this + 13);
  if ((v9 & 8) != 0)
  {
    *((_QWORD *)this + 7) = malloc_type_realloc(*((void **)this + 7), (uint64_t)*((int *)this + 9) << 6, 0x100004094D12286uLL);
    v9 = *((_DWORD *)this + 13);
    if ((v9 & 0x10) == 0)
    {
LABEL_6:
      if ((v9 & 0x20) == 0)
        goto LABEL_7;
      goto LABEL_25;
    }
  }
  else if ((v9 & 0x10) == 0)
  {
    goto LABEL_6;
  }
  *((_QWORD *)this + 8) = malloc_type_realloc(*((void **)this + 8), 56 * *((int *)this + 9), 0x10A0040A41B8C3EuLL);
  v9 = *((_DWORD *)this + 13);
  if ((v9 & 0x20) == 0)
  {
LABEL_7:
    if ((v9 & 0x80) == 0)
      goto LABEL_8;
LABEL_26:
    *((_QWORD *)this + 10) = malloc_type_realloc(*((void **)this + 10), 48 * *((int *)this + 9), 0x10200403C9B7522uLL);
    v9 = *((_DWORD *)this + 13);
    if ((v9 & 0x200) == 0)
    {
LABEL_9:
      if ((v9 & 0x400) == 0)
        goto LABEL_11;
      goto LABEL_10;
    }
    goto LABEL_27;
  }
LABEL_25:
  *((_QWORD *)this + 9) = malloc_type_realloc(*((void **)this + 9), 32 * *((int *)this + 9), 0x1080040DCAC275BuLL);
  v9 = *((_DWORD *)this + 13);
  if ((v9 & 0x80) != 0)
    goto LABEL_26;
LABEL_8:
  if ((v9 & 0x200) == 0)
    goto LABEL_9;
LABEL_27:
  *((_QWORD *)this + 12) = malloc_type_realloc(*((void **)this + 12), 16 * *((int *)this + 9), 0x1000040451B5BE8uLL);
  if ((*((_DWORD *)this + 13) & 0x400) != 0)
LABEL_10:
    *((_QWORD *)this + 14) = malloc_type_realloc(*((void **)this + 14), 40 * *((int *)this + 9), 0x10000400A747E1EuLL);
LABEL_11:
  v3 = *((unsigned int *)this + 8);
  *((_DWORD *)this + 8) = v3 + 1;
  v10 = (float32x2_t *)(*((_QWORD *)this + 5) + 32 * (int)v3);
  v10[2] = (float32x2_t)-1;
  v10[3] = (float32x2_t)-1;
  v10[1] = (float32x2_t)-1;
  *v10 = vsub_f32(*(float32x2_t *)(*((_QWORD *)this + 3) + 28 * a3), *(float32x2_t *)(*((_QWORD *)this + 3) + 28 * a2));
  Shape::ConnectStart((uint64_t)this, a2, v3);
  Shape::ConnectEnd((uint64_t)this, a3, v3);
  v11 = *((_DWORD *)this + 13);
  if ((v11 & 8) != 0)
  {
    v13 = *((_QWORD *)this + 7) + ((uint64_t)(int)v3 << 6);
    *(_DWORD *)v13 = 1;
    *(_QWORD *)(v13 + 4) = *(_QWORD *)(*((_QWORD *)this + 5) + 32 * (int)v3);
    if ((v11 & 0x10) == 0)
    {
LABEL_13:
      if ((v11 & 0x200) == 0)
        goto LABEL_14;
      goto LABEL_20;
    }
  }
  else if ((v11 & 0x10) == 0)
  {
    goto LABEL_13;
  }
  v14 = *((_QWORD *)this + 8) + 56 * (int)v3;
  *(_QWORD *)v14 = 0;
  *(_DWORD *)(v14 + 8) = -1;
  if ((v11 & 0x200) == 0)
  {
LABEL_14:
    if ((v11 & 0x400) == 0)
      goto LABEL_15;
LABEL_21:
    *(_QWORD *)(*((_QWORD *)this + 14) + 40 * (int)v3) = -1;
    if ((v11 & 2) != 0)
      return v3;
    goto LABEL_16;
  }
LABEL_20:
  v15 = (_QWORD *)(*((_QWORD *)this + 12) + 16 * (int)v3);
  *v15 = -1;
  v15[1] = 0;
  if ((v11 & 0x400) != 0)
    goto LABEL_21;
LABEL_15:
  if ((v11 & 2) == 0)
LABEL_16:
    *((_DWORD *)this + 13) = v11 | 2;
  return v3;
}

uint64_t Shape::ConnectStart(uint64_t this, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  unsigned int v13;
  _DWORD *v14;
  int *v15;
  uint64_t v16;
  int *v17;
  int v18;

  v5 = this;
  v6 = *(_QWORD *)(this + 40);
  v7 = a3;
  if ((*(_DWORD *)(v6 + 32 * a3 + 8) & 0x80000000) == 0)
  {
    this = Shape::DisconnectStart(this, a3);
    v6 = *(_QWORD *)(v5 + 40);
  }
  v8 = (_DWORD *)(v6 + 32 * v7);
  v8[2] = a2;
  v9 = *(_QWORD *)(v5 + 24);
  v10 = v9 + 28 * a2;
  v13 = *(_DWORD *)(v10 + 20);
  v11 = (int *)(v10 + 20);
  v12 = v13;
  ++*(v11 - 2);
  v8[4] = -1;
  v8[5] = v13;
  if ((v13 & 0x80000000) == 0)
  {
    v14 = (_DWORD *)(v6 + 32 * v12);
    if (v14[2] == a2)
    {
      v15 = v14 + 4;
    }
    else
    {
      if (v14[3] != a2)
        goto LABEL_9;
      v15 = (int *)(v6 + 32 * v12 + 24);
    }
    *v15 = a3;
  }
LABEL_9:
  *v11 = a3;
  v16 = v9 + 28 * a2;
  v18 = *(_DWORD *)(v16 + 16);
  v17 = (int *)(v16 + 16);
  if (v18 < 0)
    *v17 = a3;
  return this;
}

uint64_t Shape::ConnectEnd(uint64_t this, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  unsigned int v13;
  _DWORD *v14;
  int *v15;
  uint64_t v16;
  int *v17;
  int v18;

  v5 = this;
  v6 = *(_QWORD *)(this + 40);
  v7 = a3;
  if ((*(_DWORD *)(v6 + 32 * a3 + 12) & 0x80000000) == 0)
  {
    this = Shape::DisconnectEnd(this, a3);
    v6 = *(_QWORD *)(v5 + 40);
  }
  v8 = (_DWORD *)(v6 + 32 * v7);
  v8[3] = a2;
  v9 = *(_QWORD *)(v5 + 24);
  v10 = v9 + 28 * a2;
  v13 = *(_DWORD *)(v10 + 20);
  v11 = (int *)(v10 + 20);
  v12 = v13;
  ++*(v11 - 3);
  v8[6] = -1;
  v8[7] = v13;
  if ((v13 & 0x80000000) == 0)
  {
    v14 = (_DWORD *)(v6 + 32 * v12);
    if (v14[2] == a2)
    {
      v15 = v14 + 4;
    }
    else
    {
      if (v14[3] != a2)
        goto LABEL_9;
      v15 = (int *)(v6 + 32 * v12 + 24);
    }
    *v15 = a3;
  }
LABEL_9:
  *v11 = a3;
  v16 = v9 + 28 * a2;
  v18 = *(_DWORD *)(v16 + 16);
  v17 = (int *)(v16 + 16);
  if (v18 < 0)
    *v17 = a3;
  return this;
}

uint64_t Shape::AddEdge(Shape *this, unsigned int a2, unsigned int a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  _DWORD *v15;
  unsigned int *v16;
  int v18;
  int v19;
  int v20;
  float32x2_t *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  _DWORD *v26;

  v5 = 0xFFFFFFFFLL;
  if (a2 == a3 || ((a3 | a2) & 0x80000000) != 0)
    return v5;
  v11 = *(unsigned int *)(*((_QWORD *)this + 3) + 28 * a2 + 16);
  if ((v11 & 0x80000000) != 0)
  {
LABEL_14:
    *((_DWORD *)this + 12) = 0;
    v18 = *((_DWORD *)this + 8);
    if (v18 < *((_DWORD *)this + 9))
      goto LABEL_22;
    v19 = (2 * v18) | 1;
    *((_DWORD *)this + 9) = v19;
    *((_QWORD *)this + 5) = malloc_type_realloc(*((void **)this + 5), 32 * v19, 0x1000040E0EAB150uLL);
    v20 = *((_DWORD *)this + 13);
    if ((v20 & 8) != 0)
    {
      *((_QWORD *)this + 7) = malloc_type_realloc(*((void **)this + 7), (uint64_t)*((int *)this + 9) << 6, 0x100004094D12286uLL);
      v20 = *((_DWORD *)this + 13);
      if ((v20 & 0x10) == 0)
      {
LABEL_17:
        if ((v20 & 0x20) == 0)
          goto LABEL_18;
        goto LABEL_37;
      }
    }
    else if ((v20 & 0x10) == 0)
    {
      goto LABEL_17;
    }
    *((_QWORD *)this + 8) = malloc_type_realloc(*((void **)this + 8), 56 * *((int *)this + 9), 0x10A0040A41B8C3EuLL);
    v20 = *((_DWORD *)this + 13);
    if ((v20 & 0x20) == 0)
    {
LABEL_18:
      if ((v20 & 0x80) == 0)
        goto LABEL_19;
      goto LABEL_38;
    }
LABEL_37:
    *((_QWORD *)this + 9) = malloc_type_realloc(*((void **)this + 9), 32 * *((int *)this + 9), 0x1080040DCAC275BuLL);
    v20 = *((_DWORD *)this + 13);
    if ((v20 & 0x80) == 0)
    {
LABEL_19:
      if ((v20 & 0x200) == 0)
        goto LABEL_20;
      goto LABEL_39;
    }
LABEL_38:
    *((_QWORD *)this + 10) = malloc_type_realloc(*((void **)this + 10), 48 * *((int *)this + 9), 0x10200403C9B7522uLL);
    v20 = *((_DWORD *)this + 13);
    if ((v20 & 0x200) == 0)
    {
LABEL_20:
      if ((v20 & 0x400) == 0)
        goto LABEL_22;
      goto LABEL_21;
    }
LABEL_39:
    *((_QWORD *)this + 12) = malloc_type_realloc(*((void **)this + 12), 16 * *((int *)this + 9), 0x1000040451B5BE8uLL);
    if ((*((_DWORD *)this + 13) & 0x400) == 0)
    {
LABEL_22:
      v5 = *((unsigned int *)this + 8);
      *((_DWORD *)this + 8) = v5 + 1;
      v21 = (float32x2_t *)(*((_QWORD *)this + 5) + 32 * (int)v5);
      v21[2] = (float32x2_t)-1;
      v21[3] = (float32x2_t)-1;
      v21[1] = (float32x2_t)-1;
      *v21 = vsub_f32(*(float32x2_t *)(*((_QWORD *)this + 3) + 28 * a3), *(float32x2_t *)(*((_QWORD *)this + 3) + 28 * a2));
      Shape::ConnectStart((uint64_t)this, a2, v5);
      Shape::ConnectEnd((uint64_t)this, a3, v5);
      v22 = *((_DWORD *)this + 13);
      if ((v22 & 8) != 0)
      {
        v23 = *((_QWORD *)this + 7) + ((uint64_t)(int)v5 << 6);
        *(_DWORD *)v23 = 1;
        *(_QWORD *)(v23 + 4) = *(_QWORD *)(*((_QWORD *)this + 5) + 32 * (int)v5);
        if ((v22 & 0x10) == 0)
        {
LABEL_24:
          if ((v22 & 0x200) == 0)
            goto LABEL_25;
          goto LABEL_30;
        }
      }
      else if ((v22 & 0x10) == 0)
      {
        goto LABEL_24;
      }
      v24 = *((_QWORD *)this + 8) + 56 * (int)v5;
      *(_QWORD *)v24 = 0;
      *(_DWORD *)(v24 + 8) = -1;
      if ((v22 & 0x200) == 0)
      {
LABEL_25:
        if ((v22 & 0x400) == 0)
          goto LABEL_26;
        goto LABEL_31;
      }
LABEL_30:
      v25 = (_QWORD *)(*((_QWORD *)this + 12) + 16 * (int)v5);
      *v25 = -1;
      v25[1] = 0;
      if ((v22 & 0x400) == 0)
      {
LABEL_26:
        if ((v22 & 2) != 0)
          return v5;
        goto LABEL_32;
      }
LABEL_31:
      v26 = (_DWORD *)(*((_QWORD *)this + 14) + 40 * (int)v5);
      *v26 = a4;
      v26[1] = a5;
      if ((v22 & 2) != 0)
        return v5;
LABEL_32:
      *((_DWORD *)this + 13) = v22 | 2;
      return v5;
    }
LABEL_21:
    *((_QWORD *)this + 14) = malloc_type_realloc(*((void **)this + 14), 40 * *((int *)this + 9), 0x10000400A747E1EuLL);
    goto LABEL_22;
  }
  v12 = *((_QWORD *)this + 5);
  while (1)
  {
    v13 = v12 + 32 * v11;
    v14 = *(_DWORD *)(v13 + 8);
    if (v14 == a2 && *(_DWORD *)(v13 + 12) == a3)
      return 0xFFFFFFFFLL;
    if (v14 == a3 && *(_DWORD *)(v12 + 32 * v11 + 12) == a2)
      return 0xFFFFFFFFLL;
    v15 = (_DWORD *)(v12 + 32 * v11);
    if (v14 == a2)
    {
      v16 = v15 + 4;
    }
    else
    {
      if (v15[3] != a2)
        goto LABEL_14;
      v16 = v15 + 6;
    }
    v11 = *v16;
    if ((v11 & 0x80000000) != 0)
      goto LABEL_14;
  }
}

void Shape::SubEdge(Shape *this, int a2)
{
  int v4;
  int v5;

  if ((a2 & 0x80000000) == 0 && *((_DWORD *)this + 8) > a2)
  {
    *((_DWORD *)this + 12) = 0;
    Shape::DisconnectStart((uint64_t)this, a2);
    Shape::DisconnectEnd((uint64_t)this, a2);
    v4 = *((_DWORD *)this + 8) - 1;
    if (v4 > a2)
    {
      Shape::SwapEdges(this, a2, v4);
      v4 = *((_DWORD *)this + 8) - 1;
    }
    *((_DWORD *)this + 8) = v4;
    v5 = *((_DWORD *)this + 13);
    if ((v5 & 2) == 0)
      *((_DWORD *)this + 13) = v5 | 2;
  }
}

uint64_t Shape::DisconnectStart(uint64_t this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD *v4;
  unsigned int v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  _DWORD *v12;
  _DWORD *v13;
  uint64_t v14;
  _DWORD *v15;
  int v16;
  uint64_t v17;
  _DWORD *v18;
  int v19;

  v2 = *(_QWORD *)(this + 40);
  v3 = v2 + 32 * a2;
  v4 = (_DWORD *)(v3 + 8);
  v5 = *(_DWORD *)(v3 + 8);
  if ((v5 & 0x80000000) != 0)
    return this;
  v6 = *(_QWORD *)(this + 24);
  --*(_DWORD *)(v6 + 28 * v5 + 12);
  v9 = *(_DWORD *)(v3 + 20);
  v7 = (_DWORD *)(v3 + 20);
  v8 = v9;
  if ((v9 & 0x80000000) == 0)
  {
    v10 = (_DWORD *)(v2 + 32 * v8);
    if (v10[2] == v5)
    {
      v10[4] = *(_DWORD *)(v2 + 32 * a2 + 16);
    }
    else if (v10[3] == v5)
    {
      *(_DWORD *)(v2 + 32 * v8 + 24) = *(_DWORD *)(v2 + 32 * a2 + 16);
    }
  }
  v11 = *(unsigned int *)(v2 + 32 * a2 + 16);
  if ((v11 & 0x80000000) == 0)
  {
    v12 = (_DWORD *)(v2 + 32 * v11);
    if (v12[2] == v5)
    {
      v13 = v12 + 5;
LABEL_12:
      *v13 = v8;
      goto LABEL_13;
    }
    if (v12[3] == v5)
    {
      v13 = (_DWORD *)(v2 + 32 * v11 + 28);
      goto LABEL_12;
    }
  }
LABEL_13:
  v14 = v6 + 28 * v5;
  v16 = *(_DWORD *)(v14 + 16);
  v15 = (_DWORD *)(v14 + 16);
  if (v16 == a2)
    *v15 = v11;
  v17 = v6 + 28 * v5;
  v19 = *(_DWORD *)(v17 + 20);
  v18 = (_DWORD *)(v17 + 20);
  if (v19 == a2)
    *v18 = *v7;
  *v4 = -1;
  return this;
}

uint64_t Shape::DisconnectEnd(uint64_t this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD *v4;
  unsigned int v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  _DWORD *v12;
  _DWORD *v13;
  uint64_t v14;
  _DWORD *v15;
  int v16;
  uint64_t v17;
  _DWORD *v18;
  int v19;

  v2 = *(_QWORD *)(this + 40);
  v3 = v2 + 32 * a2;
  v4 = (_DWORD *)(v3 + 12);
  v5 = *(_DWORD *)(v3 + 12);
  if ((v5 & 0x80000000) != 0)
    return this;
  v6 = *(_QWORD *)(this + 24);
  --*(_DWORD *)(v6 + 28 * v5 + 8);
  v9 = *(_DWORD *)(v3 + 28);
  v7 = (_DWORD *)(v3 + 28);
  v8 = v9;
  if ((v9 & 0x80000000) == 0)
  {
    v10 = (_DWORD *)(v2 + 32 * v8);
    if (v10[2] == v5)
    {
      v10[4] = *(_DWORD *)(v2 + 32 * a2 + 24);
    }
    else if (v10[3] == v5)
    {
      *(_DWORD *)(v2 + 32 * v8 + 24) = *(_DWORD *)(v2 + 32 * a2 + 24);
    }
  }
  v11 = *(unsigned int *)(v2 + 32 * a2 + 24);
  if ((v11 & 0x80000000) == 0)
  {
    v12 = (_DWORD *)(v2 + 32 * v11);
    if (v12[2] == v5)
    {
      v13 = v12 + 5;
LABEL_12:
      *v13 = v8;
      goto LABEL_13;
    }
    if (v12[3] == v5)
    {
      v13 = (_DWORD *)(v2 + 32 * v11 + 28);
      goto LABEL_12;
    }
  }
LABEL_13:
  v14 = v6 + 28 * v5;
  v16 = *(_DWORD *)(v14 + 16);
  v15 = (_DWORD *)(v14 + 16);
  if (v16 == a2)
    *v15 = v11;
  v17 = v6 + 28 * v5;
  v19 = *(_DWORD *)(v17 + 20);
  v18 = (_DWORD *)(v17 + 20);
  if (v19 == a2)
    *v18 = *v7;
  *v4 = -1;
  return this;
}

__n128 Shape::SwapEdges(Shape *this, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  _DWORD *v9;
  _DWORD *v10;
  uint64_t v11;
  unsigned int v12;
  _DWORD *v13;
  int v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  _DWORD *v19;
  int v20;
  _DWORD *v21;
  uint64_t v22;
  _DWORD *v23;
  unsigned int v24;
  _DWORD *v25;
  int v26;
  _DWORD *v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  int v33;
  uint64_t v34;
  _DWORD *v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  _DWORD *v40;
  int v41;
  uint64_t v42;
  _DWORD *v43;
  int v44;
  uint64_t v45;
  _DWORD *v46;
  uint64_t v47;
  _DWORD *v48;
  int v49;
  _DWORD *v50;
  uint64_t v51;
  _DWORD *v52;
  unsigned int v53;
  _DWORD *v54;
  int v55;
  _DWORD *v56;
  uint64_t v57;
  _DWORD *v58;
  uint64_t v59;
  _DWORD *v60;
  int v61;
  _DWORD *v62;
  _DWORD *v63;
  uint64_t v64;
  unsigned int v65;
  _DWORD *v66;
  int v67;
  _DWORD *v68;
  uint64_t v69;
  unsigned int v70;
  uint64_t v71;
  uint64_t v72;
  _DWORD *v73;
  int v74;
  uint64_t v75;
  _DWORD *v76;
  int v77;
  unsigned int v78;
  uint64_t v79;
  uint64_t v80;
  _DWORD *v81;
  int v82;
  uint64_t v83;
  _DWORD *v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  _DWORD *v88;
  int v89;
  int v90;
  uint64_t v91;
  _DWORD *v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  _DWORD *v96;
  int v97;
  int v98;
  uint64_t v99;
  _DWORD *v100;
  int v101;
  uint64_t v102;
  __n128 result;
  _OWORD *v104;
  __int128 v105;
  uint64_t v106;
  int v107;
  uint64_t v108;
  __int128 *v109;
  uint64_t v110;
  __int128 v111;
  __int128 *v112;
  uint64_t v113;
  __int128 v114;
  uint64_t v115;
  uint64_t v116;
  __n128 *v117;
  __n128 *v118;
  __n128 v119;
  __n128 v120;
  __n128 v121;
  __n128 *v122;
  uint64_t v123;
  __int128 *v124;
  __int128 *v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  uint64_t v129;
  uint64_t v130;
  __int128 *v131;
  __int128 v132;
  __int128 *v133;
  __int128 v134;
  uint64_t v135;
  uint64_t v136;
  __int128 *v137;
  __int128 v138;
  __int128 v139;
  __int128 *v140;
  __int128 v141;
  __int128 v142;
  uint64_t v143;
  uint64_t v144;
  __n128 v145;
  __int128 v146;
  __n128 v147;
  __int128 v148;
  __n128 v149;
  __n128 v150;
  __n128 v151;
  uint64_t v152;
  __int128 v153;

  if (a2 != a3)
  {
    v3 = *((_QWORD *)this + 5);
    v4 = v3 + 32 * a2;
    v5 = (_DWORD *)(v4 + 20);
    v6 = *(unsigned int *)(v4 + 20);
    if ((*(_DWORD *)(v4 + 20) & 0x80000000) == 0 && (_DWORD)v6 != a3)
    {
      v7 = (_DWORD *)(v3 + 32 * v6);
      v8 = *(_DWORD *)(v3 + 32 * a2 + 8);
      if (v7[2] == v8)
      {
        v9 = v7 + 4;
LABEL_8:
        *v9 = a3;
        goto LABEL_9;
      }
      if (v7[3] == v8)
      {
        v9 = (_DWORD *)(v3 + 32 * v6 + 24);
        goto LABEL_8;
      }
    }
LABEL_9:
    v12 = *(_DWORD *)(v4 + 16);
    v10 = (_DWORD *)(v4 + 16);
    v11 = v12;
    if ((v12 & 0x80000000) == 0 && (_DWORD)v11 != a3)
    {
      v13 = (_DWORD *)(v3 + 32 * v11);
      v14 = *(_DWORD *)(v3 + 32 * a2 + 8);
      if (v13[2] == v14)
      {
        v15 = v13 + 5;
LABEL_15:
        *v15 = a3;
        goto LABEL_16;
      }
      if (v13[3] == v14)
      {
        v15 = (_DWORD *)(v3 + 32 * v11 + 28);
        goto LABEL_15;
      }
    }
LABEL_16:
    v16 = v3 + 32 * a2;
    v18 = (_DWORD *)(v16 + 28);
    v17 = *(unsigned int *)(v16 + 28);
    if ((*(_DWORD *)(v16 + 28) & 0x80000000) == 0 && (_DWORD)v17 != a3)
    {
      v19 = (_DWORD *)(v3 + 32 * v17);
      v20 = *(_DWORD *)(v3 + 32 * a2 + 12);
      if (v19[2] == v20)
      {
        v21 = v19 + 4;
LABEL_22:
        *v21 = a3;
        goto LABEL_23;
      }
      if (v19[3] == v20)
      {
        v21 = (_DWORD *)(v3 + 32 * v17 + 24);
        goto LABEL_22;
      }
    }
LABEL_23:
    v24 = *(_DWORD *)(v16 + 24);
    v23 = (_DWORD *)(v16 + 24);
    v22 = v24;
    if ((v24 & 0x80000000) == 0 && (_DWORD)v22 != a3)
    {
      v25 = (_DWORD *)(v3 + 32 * v22);
      v26 = *(_DWORD *)(v3 + 32 * a2 + 12);
      if (v25[2] == v26)
      {
        v27 = v25 + 5;
      }
      else
      {
        if (v25[3] != v26)
          goto LABEL_30;
        v27 = (_DWORD *)(v3 + 32 * v22 + 28);
      }
      *v27 = a3;
    }
LABEL_30:
    v28 = v3 + 32 * a2;
    v29 = *(_DWORD *)(v28 + 8);
    if ((v29 & 0x80000000) == 0)
    {
      v30 = *((_QWORD *)this + 3);
      v31 = v30 + 28 * v29;
      v33 = *(_DWORD *)(v31 + 16);
      v32 = (_DWORD *)(v31 + 16);
      if (v33 == a2)
        *v32 = *((_DWORD *)this + 8);
      v34 = v30 + 28 * v29;
      v36 = *(_DWORD *)(v34 + 20);
      v35 = (_DWORD *)(v34 + 20);
      if (v36 == a2)
        *v35 = *((_DWORD *)this + 8);
    }
    v37 = *(_DWORD *)(v28 + 12);
    if ((v37 & 0x80000000) == 0)
    {
      v38 = *((_QWORD *)this + 3);
      v39 = v38 + 28 * v37;
      v41 = *(_DWORD *)(v39 + 16);
      v40 = (_DWORD *)(v39 + 16);
      if (v41 == a2)
        *v40 = *((_DWORD *)this + 8);
      v42 = v38 + 28 * v37;
      v44 = *(_DWORD *)(v42 + 20);
      v43 = (_DWORD *)(v42 + 20);
      if (v44 == a2)
        *v43 = *((_DWORD *)this + 8);
    }
    v45 = v3 + 32 * a3;
    v46 = (_DWORD *)(v45 + 20);
    v47 = *(unsigned int *)(v45 + 20);
    if ((*(_DWORD *)(v45 + 20) & 0x80000000) == 0 && (_DWORD)v47 != a2)
    {
      v48 = (_DWORD *)(v3 + 32 * v47);
      v49 = *(_DWORD *)(v3 + 32 * a3 + 8);
      if (v48[2] == v49)
      {
        v50 = v48 + 4;
LABEL_46:
        *v50 = a2;
        goto LABEL_47;
      }
      if (v48[3] == v49)
      {
        v50 = (_DWORD *)(v3 + 32 * v47 + 24);
        goto LABEL_46;
      }
    }
LABEL_47:
    v53 = *(_DWORD *)(v45 + 16);
    v52 = (_DWORD *)(v45 + 16);
    v51 = v53;
    if ((v53 & 0x80000000) == 0 && (_DWORD)v51 != a2)
    {
      v54 = (_DWORD *)(v3 + 32 * v51);
      v55 = *(_DWORD *)(v3 + 32 * a3 + 8);
      if (v54[2] == v55)
      {
        v56 = v54 + 5;
LABEL_53:
        *v56 = a2;
        goto LABEL_54;
      }
      if (v54[3] == v55)
      {
        v56 = (_DWORD *)(v3 + 32 * v51 + 28);
        goto LABEL_53;
      }
    }
LABEL_54:
    v57 = v3 + 32 * a3;
    v58 = (_DWORD *)(v57 + 28);
    v59 = *(unsigned int *)(v57 + 28);
    if ((*(_DWORD *)(v57 + 28) & 0x80000000) == 0 && (_DWORD)v59 != a2)
    {
      v60 = (_DWORD *)(v3 + 32 * v59);
      v61 = *(_DWORD *)(v3 + 32 * a3 + 12);
      if (v60[2] == v61)
      {
        v62 = v60 + 4;
LABEL_60:
        *v62 = a2;
        goto LABEL_61;
      }
      if (v60[3] == v61)
      {
        v62 = (_DWORD *)(v3 + 32 * v59 + 24);
        goto LABEL_60;
      }
    }
LABEL_61:
    v65 = *(_DWORD *)(v57 + 24);
    v63 = (_DWORD *)(v57 + 24);
    v64 = v65;
    if ((v65 & 0x80000000) == 0 && (_DWORD)v64 != a2)
    {
      v66 = (_DWORD *)(v3 + 32 * v64);
      v67 = *(_DWORD *)(v3 + 32 * a3 + 12);
      if (v66[2] == v67)
      {
        v68 = v66 + 5;
      }
      else
      {
        if (v66[3] != v67)
          goto LABEL_68;
        v68 = (_DWORD *)(v3 + 32 * v64 + 28);
      }
      *v68 = a2;
    }
LABEL_68:
    v69 = v3 + 32 * a3;
    v70 = *(_DWORD *)(v69 + 8);
    if ((v70 & 0x80000000) == 0)
    {
      v71 = *((_QWORD *)this + 3);
      v72 = v71 + 28 * v70;
      v74 = *(_DWORD *)(v72 + 16);
      v73 = (_DWORD *)(v72 + 16);
      if (v74 == a3)
        *v73 = a2;
      v75 = v71 + 28 * v70;
      v77 = *(_DWORD *)(v75 + 20);
      v76 = (_DWORD *)(v75 + 20);
      if (v77 == a3)
        *v76 = a2;
    }
    v78 = *(_DWORD *)(v69 + 12);
    if ((v78 & 0x80000000) == 0)
    {
      v79 = *((_QWORD *)this + 3);
      v80 = v79 + 28 * v78;
      v82 = *(_DWORD *)(v80 + 16);
      v81 = (_DWORD *)(v80 + 16);
      if (v82 == a3)
        *v81 = a2;
      v83 = v79 + 28 * v78;
      v85 = *(_DWORD *)(v83 + 20);
      v84 = (_DWORD *)(v83 + 20);
      if (v85 == a3)
        *v84 = a2;
    }
    if ((v29 & 0x80000000) == 0)
    {
      v86 = *((_QWORD *)this + 3);
      v87 = v86 + 28 * v29;
      v89 = *(_DWORD *)(v87 + 16);
      v88 = (_DWORD *)(v87 + 16);
      v90 = *((_DWORD *)this + 8);
      if (v89 == v90)
        *v88 = a3;
      v91 = v86 + 28 * v29;
      v93 = *(_DWORD *)(v91 + 20);
      v92 = (_DWORD *)(v91 + 20);
      if (v93 == v90)
        *v92 = a3;
    }
    if ((v37 & 0x80000000) == 0)
    {
      v94 = *((_QWORD *)this + 3);
      v95 = v94 + 28 * v37;
      v97 = *(_DWORD *)(v95 + 16);
      v96 = (_DWORD *)(v95 + 16);
      v98 = *((_DWORD *)this + 8);
      if (v97 == v98)
        *v96 = a3;
      v99 = v94 + 28 * v37;
      v101 = *(_DWORD *)(v99 + 20);
      v100 = (_DWORD *)(v99 + 20);
      if (v101 == v98)
        *v100 = a3;
    }
    if (*v5 == a3)
      *v5 = a2;
    if (*v18 == a3)
      *v18 = a2;
    if (*v10 == a3)
      *v10 = a2;
    if (*v23 == a3)
      *v23 = a2;
    if (*v46 == a2)
      *v5 = a3;
    if (*v58 == a2)
      *v18 = a3;
    if (*v52 == a2)
      *v10 = a3;
    if (*v63 == a2)
      *v23 = a3;
    v102 = v3 + 32 * a2;
    result = *(__n128 *)v102;
    v153 = *(_OWORD *)(v102 + 16);
    v104 = (_OWORD *)(v3 + 32 * a3);
    v105 = v104[1];
    *(_OWORD *)v102 = *v104;
    *(_OWORD *)(v102 + 16) = v105;
    v106 = *((_QWORD *)this + 5) + 32 * a3;
    *(__n128 *)v106 = result;
    *(_OWORD *)(v106 + 16) = v153;
    v107 = *((_DWORD *)this + 13);
    if ((v107 & 8) != 0)
    {
      v116 = *((_QWORD *)this + 7);
      v117 = (__n128 *)(v116 + ((uint64_t)a2 << 6));
      v145 = *v117;
      v147 = v117[1];
      v149 = v117[2];
      v151 = v117[3];
      v118 = (__n128 *)(v116 + ((uint64_t)a3 << 6));
      v119 = v118[3];
      v121 = *v118;
      v120 = v118[1];
      v117[2] = v118[2];
      v117[3] = v119;
      *v117 = v121;
      v117[1] = v120;
      v122 = (__n128 *)(*((_QWORD *)this + 7) + ((uint64_t)a3 << 6));
      *v122 = v145;
      v122[1] = v147;
      result = v149;
      v122[2] = v149;
      v122[3] = v151;
      v107 = *((_DWORD *)this + 13);
      if ((v107 & 0x10) == 0)
      {
LABEL_106:
        if ((v107 & 0x20) == 0)
          goto LABEL_107;
        goto LABEL_114;
      }
    }
    else if ((v107 & 0x10) == 0)
    {
      goto LABEL_106;
    }
    v123 = *((_QWORD *)this + 8);
    v124 = (__int128 *)(v123 + 56 * a2);
    v146 = *v124;
    v148 = v124[1];
    v150 = (__n128)v124[2];
    v152 = *((_QWORD *)v124 + 6);
    v125 = (__int128 *)(v123 + 56 * a3);
    v127 = v125[1];
    v126 = v125[2];
    v128 = *v125;
    *((_QWORD *)v124 + 6) = *((_QWORD *)v125 + 6);
    v124[1] = v127;
    v124[2] = v126;
    *v124 = v128;
    v129 = *((_QWORD *)this + 8) + 56 * a3;
    *(_OWORD *)v129 = v146;
    *(_OWORD *)(v129 + 16) = v148;
    result = v150;
    *(__n128 *)(v129 + 32) = v150;
    *(_QWORD *)(v129 + 48) = v152;
    v107 = *((_DWORD *)this + 13);
    if ((v107 & 0x20) == 0)
    {
LABEL_107:
      if ((v107 & 0x80) == 0)
        goto LABEL_108;
      goto LABEL_115;
    }
LABEL_114:
    v130 = *((_QWORD *)this + 9);
    v131 = (__int128 *)(v130 + 32 * a2);
    v132 = *v131;
    result = (__n128)v131[1];
    v133 = (__int128 *)(v130 + 32 * a3);
    v134 = v133[1];
    *v131 = *v133;
    v131[1] = v134;
    v135 = *((_QWORD *)this + 9) + 32 * a3;
    *(_OWORD *)v135 = v132;
    *(__n128 *)(v135 + 16) = result;
    v107 = *((_DWORD *)this + 13);
    if ((v107 & 0x80) == 0)
    {
LABEL_108:
      if ((v107 & 0x200) == 0)
        goto LABEL_109;
      goto LABEL_116;
    }
LABEL_115:
    v136 = *((_QWORD *)this + 10);
    v137 = (__int128 *)(v136 + 48 * a2);
    v138 = v137[1];
    result = (__n128)v137[2];
    v139 = *v137;
    v140 = (__int128 *)(v136 + 48 * a3);
    v142 = v140[1];
    v141 = v140[2];
    *v137 = *v140;
    v137[1] = v142;
    v137[2] = v141;
    v143 = *((_QWORD *)this + 10) + 48 * a3;
    *(_OWORD *)v143 = v139;
    *(_OWORD *)(v143 + 16) = v138;
    *(__n128 *)(v143 + 32) = result;
    v107 = *((_DWORD *)this + 13);
    if ((v107 & 0x200) == 0)
    {
LABEL_109:
      if ((v107 & 0x400) == 0)
        return result;
      goto LABEL_110;
    }
LABEL_116:
    v144 = *((_QWORD *)this + 12);
    result = *(__n128 *)(v144 + 16 * a2);
    *(_OWORD *)(v144 + 16 * a2) = *(_OWORD *)(v144 + 16 * a3);
    *(__n128 *)(*((_QWORD *)this + 12) + 16 * a3) = result;
    if ((*((_DWORD *)this + 13) & 0x400) == 0)
      return result;
LABEL_110:
    v108 = *((_QWORD *)this + 14);
    v109 = (__int128 *)(v108 + 40 * a2);
    v110 = *((_QWORD *)v109 + 4);
    v111 = *v109;
    result = (__n128)v109[1];
    v112 = (__int128 *)(v108 + 40 * a3);
    v113 = *((_QWORD *)v112 + 4);
    v114 = v112[1];
    *v109 = *v112;
    v109[1] = v114;
    *((_QWORD *)v109 + 4) = v113;
    v115 = *((_QWORD *)this + 14) + 40 * a3;
    *(_OWORD *)v115 = v111;
    *(__n128 *)(v115 + 16) = result;
    *(_QWORD *)(v115 + 32) = v110;
  }
  return result;
}

double Shape::SwapEdges(Shape *this, int a2, int a3, int a4)
{
  double result;

  if (a2 != a4 && a2 != a3 && a3 != a4)
  {
    Shape::SwapEdges(this, a2, a3);
    *(_QWORD *)&result = Shape::SwapEdges(this, a3, a4).n128_u64[0];
  }
  return result;
}

void Shape::SortEdges(Shape *this)
{
  int v1;
  _DWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  float *v9;
  int v10;
  uint64_t v11;
  float v12;
  float v13;
  char v14;
  _DWORD *v15;
  unsigned int *v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  _DWORD *v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;

  v1 = *((_DWORD *)this + 13);
  if ((v1 & 2) != 0)
  {
    *((_DWORD *)this + 13) = v1 & 0xFFFFFFFD;
    v3 = malloc_type_malloc(16 * *((int *)this + 8), 0x1000040A517B1A3uLL);
    if (*((int *)this + 4) >= 1)
    {
      v4 = 0;
      v5 = *((_QWORD *)this + 3);
      do
      {
        if (*(_DWORD *)(v5 + 28 * v4 + 12) + *(_DWORD *)(v5 + 28 * v4 + 8) >= 2)
        {
          v6 = *(unsigned int *)(v5 + 28 * v4 + 16);
          if ((v6 & 0x80000000) != 0)
          {
            v10 = 0;
          }
          else
          {
            v7 = *((_QWORD *)this + 5);
            v8 = 1;
            v9 = (float *)(v3 + 2);
            do
            {
              v10 = v8;
              *((_DWORD *)v9 - 2) = v6;
              v11 = v7 + 32 * v6;
              v12 = *(float *)v11;
              if (v4 == *(_DWORD *)(v11 + 8))
              {
                v13 = *(float *)(v11 + 4);
                v14 = 1;
              }
              else
              {
                v14 = 0;
                v12 = -v12;
                v13 = -*(float *)(v11 + 4);
              }
              *v9 = v12;
              v9[1] = v13;
              *((_BYTE *)v9 - 4) = v14;
              v15 = (_DWORD *)(v7 + 32 * v6);
              if (v4 == *(_DWORD *)(v11 + 8))
              {
                v16 = v15 + 4;
              }
              else
              {
                if (v4 != v15[3])
                  break;
                v16 = v15 + 6;
              }
              v6 = *v16;
              v9 += 4;
              ++v8;
            }
            while ((v6 & 0x80000000) == 0);
          }
          v17 = v10 - 1;
          Shape::SortEdgesList(this, (uint64_t)v3, 0, (v10 - 1));
          v5 = *((_QWORD *)this + 3);
          v18 = v5 + 28 * v4;
          v19 = v3[4 * v10 - 4];
          *(_DWORD *)(v18 + 16) = *v3;
          *(_DWORD *)(v18 + 20) = v19;
          if (v10)
          {
            v20 = 0;
            v21 = v3 + 4;
            do
            {
              if (*((_BYTE *)v21 - 12))
              {
                if (v20)
                  v22 = v3[4 * (v20 - 1)];
                else
                  v22 = -1;
                v24 = *((_QWORD *)this + 5) + 32 * (int)*(v21 - 4);
                *(_DWORD *)(v24 + 20) = v22;
                if (v20 >= v17)
                  *(_DWORD *)(v24 + 16) = -1;
                else
                  *(_DWORD *)(v24 + 16) = *v21;
              }
              else
              {
                if (v20)
                  v23 = v3[4 * (v20 - 1)];
                else
                  v23 = -1;
                v25 = *((_QWORD *)this + 5) + 32 * (int)*(v21 - 4);
                *(_DWORD *)(v25 + 28) = v23;
                if (v20 >= v17)
                  *(_DWORD *)(v25 + 24) = -1;
                else
                  *(_DWORD *)(v25 + 24) = *v21;
              }
              ++v20;
              v21 += 4;
            }
            while (v10 != v20);
          }
        }
        ++v4;
      }
      while (v4 < *((int *)this + 4));
    }
    free(v3);
  }
}

Shape *Shape::SortEdgesList(Shape *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  int v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  BOOL v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float *v17;
  _BOOL4 v18;
  uint64_t v19;
  __int128 v20;
  BOOL v21;
  float *v22;
  _BOOL4 v23;
  uint64_t v24;
  __int128 v25;
  BOOL v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  Shape *v33;

  v33 = result;
  if ((int)a3 >= (int)a4)
    return result;
  v5 = a3;
LABEL_3:
  if ((_DWORD)v5 + 1 != (_DWORD)a4)
  {
    v7 = v5 + a4;
    if ((int)v5 + (int)a4 < 0 != __OFADD__((_DWORD)v5, (_DWORD)a4))
      ++v7;
    v8 = (v7 >> 1);
    v9 = a2 + 16 * (int)v8;
    v10 = *(float *)(v9 + 8);
    v11 = *(float *)(v9 + 12);
    v12 = (int)v8 < (int)a4;
    v13 = (int)v5 < v7 >> 1;
    if (!v13 && (int)v8 >= (int)a4)
    {
      LODWORD(v14) = v8;
      goto LABEL_58;
    }
    v15 = a4;
    v16 = v5;
    v14 = v8;
    while (1)
    {
      if (!v13)
      {
        v19 = v14;
LABEL_24:
        if (v12)
          goto LABEL_25;
LABEL_39:
        v24 = v8;
        goto LABEL_43;
      }
      while (1)
      {
        v17 = (float *)(a2 + 16 * (int)v16);
        result = (Shape *)Shape::CmpToVert(result, v10, v11, v17[2], v17[3]);
        if ((_DWORD)result)
        {
          v18 = (int)result < 1;
          if ((int)result >= 1)
            v16 = v16;
          else
            v16 = (v16 + 1);
          v19 = v14;
          goto LABEL_18;
        }
        v19 = (int)v14 - 1;
        if ((int)v16 >= (int)v19)
          break;
        v20 = *(_OWORD *)v17;
        *(_OWORD *)v17 = *(_OWORD *)(a2 + 16 * v19);
        *(_OWORD *)(a2 + 16 * v19) = *(_OWORD *)(a2 + 16 * (int)v14);
        *(_OWORD *)(a2 + 16 * (int)v14) = v20;
        v18 = 1;
LABEL_18:
        v21 = v18 && (int)v16 < (int)v19;
        v14 = v19;
        if (!v21)
          goto LABEL_24;
      }
      if ((_DWORD)v16 == (_DWORD)v19)
        v19 = v19;
      else
        v19 = v14;
      if (!v12)
        goto LABEL_39;
LABEL_25:
      while (2)
      {
        v22 = (float *)(a2 + 16 * (int)v15);
        result = (Shape *)Shape::CmpToVert(result, v10, v11, v22[2], v22[3]);
        if ((_DWORD)result)
        {
          v23 = (int)result >= 0;
          v15 = (v15 - v23);
          v24 = v8;
          goto LABEL_29;
        }
        v24 = (int)v8 + 1;
        if ((int)v15 > (int)v24)
        {
          v25 = *(_OWORD *)v22;
          *(_OWORD *)v22 = *(_OWORD *)(a2 + 16 * v24);
          *(_OWORD *)(a2 + 16 * v24) = *(_OWORD *)(a2 + 16 * (int)v8);
          *(_OWORD *)(a2 + 16 * (int)v8) = v25;
          v23 = 1;
LABEL_29:
          v26 = !v23 || (int)v15 <= (int)v24;
          v8 = v24;
          if (v26)
            goto LABEL_43;
          continue;
        }
        break;
      }
      if ((_DWORD)v15 == (_DWORD)v24)
        v24 = v24;
      else
        v24 = v8;
LABEL_43:
      if ((int)v16 >= (int)v19)
      {
        v8 = (int)v24 + 1;
        if ((int)v15 > (int)v8)
        {
          v28 = *(_OWORD *)(a2 + 16 * v8);
          *(_OWORD *)(a2 + 16 * v8) = *(_OWORD *)(a2 + 16 * (int)v19);
          *(_OWORD *)(a2 + 16 * (int)v19) = *(_OWORD *)(a2 + 16 * (int)v15);
          *(_OWORD *)(a2 + 16 * (int)v15) = v28;
          v14 = (v19 + 1);
          goto LABEL_54;
        }
        if ((_DWORD)v15 == (_DWORD)v8)
        {
          v30 = *(_OWORD *)(a2 + 16 * (int)v19);
          *(_OWORD *)(a2 + 16 * (int)v19) = *(_OWORD *)(a2 + 16 * (int)v15);
          *(_OWORD *)(a2 + 16 * (int)v15) = v30;
          v14 = (v19 + 1);
          v8 = v15;
          goto LABEL_54;
        }
        goto LABEL_57;
      }
      if ((int)v15 <= (int)v24)
      {
        v14 = (int)v19 - 1;
        if ((int)v16 < (int)v14)
        {
          v29 = *(_OWORD *)(a2 + 16 * v14);
          *(_OWORD *)(a2 + 16 * v14) = *(_OWORD *)(a2 + 16 * (int)v24);
          *(_OWORD *)(a2 + 16 * (int)v24) = *(_OWORD *)(a2 + 16 * (int)v16);
          *(_OWORD *)(a2 + 16 * (int)v16) = v29;
          v8 = (v24 - 1);
          goto LABEL_54;
        }
        if ((_DWORD)v16 == (_DWORD)v14)
        {
          v31 = *(_OWORD *)(a2 + 16 * (int)v24);
          *(_OWORD *)(a2 + 16 * (int)v24) = *(_OWORD *)(a2 + 16 * (int)v16);
          *(_OWORD *)(a2 + 16 * (int)v16) = v31;
          v8 = (v24 - 1);
          v14 = v16;
          goto LABEL_54;
        }
LABEL_57:
        LODWORD(v14) = v19;
        LODWORD(v8) = v24;
        goto LABEL_58;
      }
      v27 = *(_OWORD *)(a2 + 16 * (int)v16);
      *(_OWORD *)(a2 + 16 * (int)v16) = *(_OWORD *)(a2 + 16 * (int)v15);
      *(_OWORD *)(a2 + 16 * (int)v15) = v27;
      v16 = (v16 + 1);
      v15 = (v15 - 1);
      v14 = v19;
      v8 = v24;
LABEL_54:
      v12 = (int)v15 > (int)v8;
      v13 = (int)v16 < (int)v14;
      if ((int)v16 >= (int)v14 && (int)v15 <= (int)v8)
      {
LABEL_58:
        result = (Shape *)Shape::SortEdgesList(v33, a2, v5, (v14 - 1));
        v5 = (v8 + 1);
        if ((int)v5 >= (int)a4)
          return result;
        goto LABEL_3;
      }
    }
  }
  result = (Shape *)Shape::CmpToVert(result, *(float *)(a2 + 16 * (int)a4 + 8), *(float *)(a2 + 16 * (int)a4 + 12), *(float *)(a2 + 16 * (int)v5 + 8), *(float *)(a2 + 16 * (int)v5 + 12));
  if ((int)result >= 1)
  {
    v32 = *(_OWORD *)(a2 + 16 * (int)v5);
    *(_OWORD *)(a2 + 16 * (int)v5) = *(_OWORD *)(a2 + 16 * (int)a4);
    *(_OWORD *)(a2 + 16 * (int)a4) = v32;
  }
  return result;
}

uint64_t Shape::CmpToVert(Shape *this, float a2, float a3, float a4, float a5)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  float v15;

  if (a2 >= 0.0)
  {
    if (a3 > 0.0)
      v7 = 3;
    else
      v7 = 2;
    if (a3 >= 0.0)
      v6 = v7;
    else
      v6 = 1;
    if (a3 <= 0.0)
      v8 = -1;
    else
      v8 = 4;
    if (a3 < 0.0)
      v8 = 0;
    if (a2 <= 0.0)
      v6 = v8;
  }
  else
  {
    if (a3 > 0.0)
      v5 = 5;
    else
      v5 = 6;
    if (a3 >= 0.0)
      v6 = v5;
    else
      v6 = 7;
  }
  if (a5 > 0.0)
    v9 = 3;
  else
    v9 = 2;
  if (a5 >= 0.0)
    v10 = v9;
  else
    v10 = 1;
  if (a5 <= 0.0)
    v11 = -1;
  else
    v11 = 4;
  if (a5 < 0.0)
    v11 = 0;
  if (a4 <= 0.0)
    v10 = v11;
  if (a5 > 0.0)
    v12 = 5;
  else
    v12 = 6;
  if (a5 >= 0.0)
    v13 = v12;
  else
    v13 = 7;
  if (a4 < 0.0)
    v10 = v13;
  if (v6 < v10)
    return 1;
  if (v6 > v10)
    return 0xFFFFFFFFLL;
  v15 = (float)(a2 * a5) - (float)(a3 * a4);
  if (v15 < 0.0)
    return 0xFFFFFFFFLL;
  else
    return v15 > 0.0;
}

BOOL Shape::Eulerian(Shape *this, char a2)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;
  int v6;
  BOOL v7;
  char v8;
  _BOOL8 result;
  uint64_t v10;
  _DWORD *v11;
  unsigned int v12;
  char v13;

  v2 = *((unsigned int *)this + 4);
  if ((a2 & 1) != 0)
  {
    if ((int)v2 >= 1)
    {
      v3 = v2 - 1;
      v4 = (int *)(*((_QWORD *)this + 3) + 12);
      do
      {
        v5 = *(v4 - 1);
        v6 = *v4;
        v7 = v3-- != 0;
        v8 = v7;
        result = v5 == v6;
        if (v5 != v6)
          break;
        v4 += 7;
      }
      while ((v8 & 1) != 0);
      return result;
    }
    return 1;
  }
  if ((int)v2 < 1)
    return 1;
  v10 = v2 - 1;
  v11 = (_DWORD *)(*((_QWORD *)this + 3) + 12);
  do
  {
    v12 = (*v11 + *(v11 - 1)) & 0x80000001;
    v7 = v10-- != 0;
    v13 = v7;
    result = v12 != 1;
    if (v12 == 1)
      break;
    v11 += 7;
  }
  while ((v13 & 1) != 0);
  return result;
}

float32x2_t Shape::Inverse(Shape *this, int a2)
{
  float32x2_t *v2;
  unsigned __int32 v3;
  unsigned __int32 v4;
  float32x2_t v5;
  __int128 v6;
  float32x2_t result;
  int32x2_t *v8;
  int32x2_t *v9;
  int v10;
  int32x2_t *v11;
  int32x2_t *v12;
  uint64_t v13;
  uint64_t v14;

  v2 = (float32x2_t *)(*((_QWORD *)this + 5) + 32 * a2);
  v3 = v2[1].u32[0];
  v4 = v2[1].u32[1];
  v5 = v2[3];
  v2[3] = v2[2];
  *(_QWORD *)&v6 = __PAIR64__(v3, v4);
  *((float32x2_t *)&v6 + 1) = v5;
  *(_OWORD *)v2[1].f32 = v6;
  result = vneg_f32(*v2);
  *v2 = result;
  if ((v4 & 0x80000000) == 0)
  {
    v8 = (int32x2_t *)(*((_QWORD *)this + 3) + 28 * v4);
    result = (float32x2_t)vadd_s32(v8[1], (int32x2_t)0x1FFFFFFFFLL);
    v8[1] = (int32x2_t)result;
  }
  if ((v3 & 0x80000000) == 0)
  {
    v9 = (int32x2_t *)(*((_QWORD *)this + 3) + 28 * v3);
    result = (float32x2_t)vadd_s32(v9[1], (int32x2_t)0xFFFFFFFF00000001);
    v9[1] = (int32x2_t)result;
  }
  v10 = *((_DWORD *)this + 13);
  if ((v10 & 8) != 0)
  {
    *(_DWORD *)(*((_QWORD *)this + 7) + ((uint64_t)a2 << 6)) = -*(_DWORD *)(*((_QWORD *)this + 7) + ((uint64_t)a2 << 6));
    if ((v10 & 0x20) == 0)
    {
LABEL_7:
      if ((v10 & 0x200) == 0)
        goto LABEL_8;
      goto LABEL_12;
    }
  }
  else if ((v10 & 0x20) == 0)
  {
    goto LABEL_7;
  }
  v11 = (int32x2_t *)(*((_QWORD *)this + 9) + 32 * a2);
  result = (float32x2_t)vrev64_s32(v11[2]);
  v11[2] = (int32x2_t)result;
  if ((v10 & 0x200) == 0)
  {
LABEL_8:
    if ((v10 & 0x400) == 0)
      return result;
LABEL_13:
    v13 = *((_QWORD *)this + 14);
    v14 = 40 * a2;
    result = (float32x2_t)vrev64_s32(*(int32x2_t *)(v13 + v14));
    *(float32x2_t *)(v13 + v14) = result;
    return result;
  }
LABEL_12:
  v12 = (int32x2_t *)(*((_QWORD *)this + 12) + 16 * a2);
  result = (float32x2_t)vrev64_s32(v12[1]);
  v12[1] = (int32x2_t)result;
  if ((v10 & 0x400) != 0)
    goto LABEL_13;
  return result;
}

uint64_t Shape::CalcBBox(uint64_t this)
{
  uint64_t v1;
  float *v2;
  float v3;
  float v4;
  float *v5;
  uint64_t v6;
  float v7;
  float v8;
  float v9;
  float v10;

  v1 = *(unsigned int *)(this + 16);
  if ((int)v1 <= 0)
  {
    *(_QWORD *)this = 0;
    *(_QWORD *)(this + 8) = 0;
  }
  else
  {
    v2 = *(float **)(this + 24);
    v3 = *v2;
    v4 = v2[1];
    *(float *)(this + 8) = *v2;
    *(float *)(this + 12) = v4;
    *(float *)this = v3;
    *(float *)(this + 4) = v4;
    if ((_DWORD)v1 != 1)
    {
      v5 = v2 + 8;
      v6 = v1 - 1;
      v7 = v4;
      v8 = v3;
      do
      {
        v9 = *(v5 - 1);
        if (v9 < v8)
        {
          *(float *)this = v9;
          v8 = v9;
        }
        if (v9 > v3)
        {
          *(float *)(this + 8) = v9;
          v3 = v9;
        }
        v10 = *v5;
        if (*v5 < v7)
        {
          *(float *)(this + 4) = v10;
          v7 = v10;
        }
        if (v10 > v4)
        {
          *(float *)(this + 12) = v10;
          v4 = v10;
        }
        v5 += 7;
        --v6;
      }
      while (v6);
    }
  }
  return this;
}

const CGPath *TSDCreatePathFromSVGString(uint64_t a1)
{
  const CGPath *Mutable;
  void *v3;
  unsigned __int16 v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  int v10;
  unsigned __int16 v11;
  CGPoint v12;
  CGPath *v13;
  uint64_t ElementCount;
  const CGPath *v15;
  const CGPath *v16;
  uint64_t v17;
  CGPoint CurrentPoint;
  CGPath *v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double y;
  double v27;
  CGPoint v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  CGPoint v35;
  double v36;
  CGFloat v37;
  double v38;
  double v39;
  double v40;
  double v41;
  CGPath *v42;
  CGFloat v43;
  double v44;
  CGPoint v45;
  double v46;
  double v47;
  CGPoint v48;
  CGPoint v49;
  CGPoint v50;
  CGPoint v51;
  double v52;
  double v53;
  CGPoint v54;
  CGPoint v55;
  __int16 v56;
  double v57;
  double v58;
  double v59;
  CGFloat v60;
  CGPoint v61;
  double x;
  CGPoint v63;
  CGPoint v64;
  CGFloat v66;
  double v67;
  double v68;
  double v69;
  double v70;
  double v71;
  double v72;
  double v73;
  uint64_t v74;
  uint64_t v75;
  id v76;
  double v77;
  double v78;
  uint64_t v79;
  int v80;
  uint64_t v81;

  v81 = *MEMORY[0x24BDAC8D0];
  Mutable = CGPathCreateMutable();
  v77 = 0.0;
  v78 = 0.0;
  v3 = (void *)objc_msgSend(MEMORY[0x24BDD17A8], "scannerWithString:", a1);
  v79 = *(_QWORD *)asc_217C29B98;
  v80 = 2883717;
  objc_msgSend(v3, "setCharactersToBeSkipped:", objc_msgSend(MEMORY[0x24BDD14A8], "characterSetWithCharactersInString:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithCharacters:length:", &v79, 6)));
  v76 = 0;
  if (objc_msgSend(v3, "scanCharactersFromSet:intoString:", objc_msgSend(MEMORY[0x24BDD14A8], "letterCharacterSet"), &v76))
  {
    v4 = 0;
    v5 = *MEMORY[0x24BDBEFB0];
    v6 = *(double *)(MEMORY[0x24BDBEFB0] + 8);
    v7 = 3.0;
    v8 = *MEMORY[0x24BDBEFB0];
    v9 = v6;
    do
    {
      v10 = objc_msgSend(v76, "characterAtIndex:", 0);
      v11 = v10;
      if (v10 > 96)
      {
        switch(v10)
        {
          case 'a':
            CurrentPoint = CGPathGetCurrentPoint(Mutable);
            v70 = 0.0;
            v68 = 0.0;
            v66 = 0.0;
            v74 = 0;
            v75 = 0;
            v72 = 0.0;
            v73 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v66);
            objc_msgSend(v3, "scanInteger:", &v75);
            objc_msgSend(v3, "scanInteger:", &v74);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v73);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v72);
            v72 = CurrentPoint.y + v72;
            v73 = CurrentPoint.x + v73;
            v13 = TSDCreatePathByComputingArc(v75 != 0, v74 != 0, CurrentPoint.x, CurrentPoint.y, v70, v68, v66, v73, v72);
            ElementCount = TSDPathGetElementCount(v13);
            v15 = Mutable;
            v16 = v13;
            v17 = 1;
LABEL_8:
            v19 = TSDCreatePathByAppendingPathFromElementToElement(v15, v16, v17, ElementCount);
            CGPathRelease(v13);
            CGPathRelease(Mutable);
            Mutable = CGPathCreateMutableCopy(v19);
            CGPathRelease(v19);
            break;
          case 'b':
          case 'd':
          case 'e':
          case 'f':
          case 'g':
          case 'i':
          case 'j':
          case 'k':
          case 'n':
          case 'o':
          case 'p':
          case 'r':
          case 'u':
            goto LABEL_10;
          case 'c':
            v48 = CGPathGetCurrentPoint(Mutable);
            v70 = 0.0;
            v71 = 0.0;
            v68 = 0.0;
            v69 = 0.0;
            v66 = 0.0;
            v67 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v69);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v66);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v67);
            v20 = v48.x + v70;
            v22 = v48.x + v68;
            v24 = v48.x + v66;
            v21 = v48.y + v71;
            v70 = v48.x + v70;
            v71 = v48.y + v71;
            v23 = v48.y + v69;
            v68 = v48.x + v68;
            v69 = v48.y + v69;
            v25 = v48.y + v67;
            v66 = v48.x + v66;
            v67 = v48.y + v67;
LABEL_31:
            CGPathAddCurveToPoint(Mutable, 0, v20, v21, v22, v23, v24, v25);
            v5 = v68;
            v6 = v69;
            break;
          case 'h':
            objc_msgSend(v3, "tsu_scanCGFloat:", &v77);
            v49 = CGPathGetCurrentPoint(Mutable);
            y = v49.y;
            v27 = v77 - v49.x;
            goto LABEL_52;
          case 'l':
            if (objc_msgSend(v3, "tsu_scanCGFloat:", &v77))
            {
              do
              {
                objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
                v50 = CGPathGetCurrentPoint(Mutable);
                CGPathAddLineToPoint(Mutable, 0, v77 - v50.x, v78 - v50.y);
              }
              while ((objc_msgSend(v3, "tsu_scanCGFloat:", &v77) & 1) != 0);
            }
            break;
          case 'm':
            v51 = CGPathGetCurrentPoint(Mutable);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v77);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
            if (TSDPathGetElementCount(Mutable) < 1)
            {
              v52 = v77;
              v53 = v78;
            }
            else
            {
              v52 = v77 - v51.x;
              v53 = v78 - v51.y;
            }
            CGPathMoveToPoint(Mutable, 0, v52, v53);
            if (objc_msgSend(v3, "tsu_scanCGFloat:", &v77))
            {
              do
              {
                objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
                v64 = CGPathGetCurrentPoint(Mutable);
                CGPathAddLineToPoint(Mutable, 0, v77 - v64.x, v78 - v64.y);
              }
              while ((objc_msgSend(v3, "tsu_scanCGFloat:", &v77) & 1) != 0);
            }
            break;
          case 'q':
            v54 = CGPathGetCurrentPoint(Mutable);
            v70 = 0.0;
            v71 = 0.0;
            v68 = 0.0;
            v69 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v69);
            v29 = v54.x + v70;
            v30 = v54.y + v71;
            v70 = v29;
            v71 = v30;
            v33 = v54.x + v68;
            v34 = v54.y + v69;
            v68 = v54.x + v68;
            v69 = v54.y + v69;
            v31 = v54.x + (v29 - v54.x + v29 - v54.x) / v7;
            v32 = v54.y + (v30 - v54.y + v30 - v54.y) / v7;
LABEL_39:
            CGPathAddCurveToPoint(Mutable, 0, v31, v32, v29 + (v33 - v29) / v7, v30 + (v34 - v30) / v7, v33, v34);
            v8 = v70;
            v9 = v71;
            break;
          case 's':
            v55 = CGPathGetCurrentPoint(Mutable);
            v56 = (unsigned __int16)(v4 - 67) >> 4;
            v57 = v55.x - v5;
            if (v56 & 0xFFFC | (unsigned __int16)((v4 - 67) << 12))
              v57 = -0.0;
            v58 = v55.x + v57;
            if (v56 & 0xFFFC | (unsigned __int16)((v4 - 67) << 12))
              v59 = -0.0;
            else
              v59 = v55.y - v6;
            v70 = 0.0;
            v71 = 0.0;
            v60 = v55.y + v59;
            v68 = 0.0;
            v69 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v69);
            v38 = v55.x + v70;
            v39 = v55.y + v71;
            v70 = v55.x + v70;
            v71 = v55.y + v71;
            v40 = v55.x + v68;
            v41 = v55.y + v69;
            v68 = v55.x + v68;
            v69 = v55.y + v69;
            v42 = Mutable;
            v43 = v58;
            v44 = v60;
LABEL_46:
            CGPathAddCurveToPoint(v42, 0, v43, v44, v38, v39, v40, v41);
            v5 = v70;
            v6 = v71;
            break;
          case 't':
            v61 = CGPathGetCurrentPoint(Mutable);
            if (v4 - 81 > 0x23)
            {
              x = v61.x;
              v9 = v61.y;
            }
            else
            {
              x = v61.x;
              v9 = v61.y;
              if (((1 << (v4 - 81)) & 0x900000009) != 0)
              {
                x = v61.x + v61.x - v8;
                v9 = v61.y + v61.y - v61.y;
              }
            }
            v70 = 0.0;
            v71 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            v70 = v61.x + v70;
            v71 = v61.y + v71;
            CGPathAddCurveToPoint(Mutable, 0, x, v61.y + (v9 - v61.y + v9 - v61.y) / v7, x + (v70 - x) / v7, v9 + (v71 - v9) / v7, v70, v71);
            v8 = x;
            break;
          case 'v':
            objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
            v63 = CGPathGetCurrentPoint(Mutable);
            v27 = v63.x;
            y = v78 - v63.y;
LABEL_52:
            CGPathAddLineToPoint(Mutable, 0, v27, y);
            break;
          default:
            if (v10 == 122)
LABEL_12:
              CGPathCloseSubpath(Mutable);
            else
LABEL_10:
              NSLog((NSString *)CFSTR("Cannot process path of type '%@'"), v76);
            break;
        }
      }
      else
      {
        switch(v10)
        {
          case 'A':
            v12 = CGPathGetCurrentPoint(Mutable);
            v70 = 0.0;
            v68 = 0.0;
            v66 = 0.0;
            v74 = 0;
            v75 = 0;
            v72 = 0.0;
            v73 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v66);
            objc_msgSend(v3, "scanInteger:", &v75);
            objc_msgSend(v3, "scanInteger:", &v74);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v73);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v72);
            v13 = TSDCreatePathByComputingArc(v75 != 0, v74 != 0, v12.x, v12.y, v70, v68, v66, v73, v72);
            ElementCount = TSDPathGetElementCount(v13);
            v15 = Mutable;
            v16 = v13;
            v17 = 2;
            goto LABEL_8;
          case 'B':
          case 'D':
          case 'E':
          case 'F':
          case 'G':
          case 'I':
          case 'J':
          case 'K':
          case 'N':
          case 'O':
          case 'P':
          case 'R':
          case 'U':
            goto LABEL_10;
          case 'C':
            v70 = 0.0;
            v71 = 0.0;
            v68 = 0.0;
            v69 = 0.0;
            v66 = 0.0;
            v67 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v69);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v66);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v67);
            v20 = v70;
            v21 = v71;
            v22 = v68;
            v23 = v69;
            v24 = v66;
            v25 = v67;
            goto LABEL_31;
          case 'H':
            objc_msgSend(v3, "tsu_scanCGFloat:", &v77);
            y = CGPathGetCurrentPoint(Mutable).y;
            v27 = v77;
            goto LABEL_52;
          case 'L':
            if (objc_msgSend(v3, "tsu_scanCGFloat:", &v77))
            {
              do
              {
                objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
                CGPathAddLineToPoint(Mutable, 0, v77, v78);
              }
              while ((objc_msgSend(v3, "tsu_scanCGFloat:", &v77) & 1) != 0);
            }
            break;
          case 'M':
            objc_msgSend(v3, "tsu_scanCGFloat:", &v77);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
            CGPathMoveToPoint(Mutable, 0, v77, v78);
            if (objc_msgSend(v3, "tsu_scanCGFloat:", &v77))
            {
              do
              {
                objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
                CGPathAddLineToPoint(Mutable, 0, v77, v78);
              }
              while ((objc_msgSend(v3, "tsu_scanCGFloat:", &v77) & 1) != 0);
            }
            break;
          case 'Q':
            v28 = CGPathGetCurrentPoint(Mutable);
            v70 = 0.0;
            v71 = 0.0;
            v68 = 0.0;
            v69 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v69);
            v29 = v70;
            v30 = v71;
            v31 = v28.x + (v70 - v28.x + v70 - v28.x) / v7;
            v32 = v28.y + (v71 - v28.y + v71 - v28.y) / v7;
            v33 = v68;
            v34 = v69;
            goto LABEL_39;
          case 'S':
            v35 = CGPathGetCurrentPoint(Mutable);
            v36 = v35.x - v5;
            if (((unsigned __int16)(v4 - 67) >> 4) & 0xFFFC | (unsigned __int16)((v4 - 67) << 12))
              v36 = -0.0;
            v37 = v35.x + v36;
            v70 = 0.0;
            v71 = 0.0;
            v68 = 0.0;
            v69 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v68);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v69);
            v38 = v70;
            v39 = v71;
            v40 = v68;
            v41 = v69;
            v42 = Mutable;
            v43 = v37;
            v44 = v35.y + v35.x;
            goto LABEL_46;
          case 'T':
            v45 = CGPathGetCurrentPoint(Mutable);
            if (v4 - 81 > 0x23)
            {
              v46 = v45.x;
              v47 = v45.y;
            }
            else
            {
              v46 = v45.x;
              v47 = v45.y;
              if (((1 << (v4 - 81)) & 0x900000009) != 0)
              {
                v46 = v45.x + v45.x - v8;
                v47 = v45.y + v45.y - v9;
              }
            }
            v70 = 0.0;
            v71 = 0.0;
            objc_msgSend(v3, "tsu_scanCGFloat:", &v70);
            objc_msgSend(v3, "tsu_scanCGFloat:", &v71);
            v7 = 3.0;
            CGPathAddCurveToPoint(Mutable, 0, v45.x + (v46 - v45.x + v46 - v45.x) / 3.0, v45.y + (v47 - v45.y + v47 - v45.y) / 3.0, v46 + (v70 - v46) / 3.0, v47 + (v71 - v47) / 3.0, v70, v71);
            v9 = v47;
            v8 = v46;
            break;
          case 'V':
            objc_msgSend(v3, "tsu_scanCGFloat:", &v78);
            *(_QWORD *)&v27 = *(_OWORD *)&CGPathGetCurrentPoint(Mutable);
            y = v78;
            goto LABEL_52;
          default:
            if (v10 != 90)
              goto LABEL_10;
            goto LABEL_12;
        }
      }
      v4 = v11;
    }
    while ((objc_msgSend(v3, "scanCharactersFromSet:intoString:", objc_msgSend(MEMORY[0x24BDD14A8], "letterCharacterSet"), &v76) & 1) != 0);
  }
  return Mutable;
}

void Shape::ConvertToForme(Shape *this, Path *a2)
{
  uint64_t v4;
  float *v5;
  float *v6;
  float v7;
  float v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  float32x2_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  _QWORD *v28;
  char v29;
  unsigned int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  _DWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  float *v39;
  int v40;

  if (*((int *)this + 4) >= 2 && *((int *)this + 8) >= 2 && Shape::Eulerian(this, 1))
  {
    Path::Reset(a2);
    Path::SetWeighted(a2, 0);
    Shape::MakePointData(this, 1);
    Shape::MakeEdgeData(this, 1);
    Shape::MakeSweepDestData(this, 1);
    v4 = *((unsigned int *)this + 4);
    if ((int)v4 >= 1)
    {
      v5 = (float *)(*((_QWORD *)this + 3) + 4);
      v6 = (float *)(*((_QWORD *)this + 11) + 40);
      do
      {
        v7 = ldexpf(*(v5 - 1), 5);
        *(v6 - 1) = ldexpf(roundf(v7), -5);
        v8 = *v5;
        v5 += 7;
        v9 = ldexpf(v8, 5);
        *v6 = ldexpf(roundf(v9), -5);
        v6 += 12;
        --v4;
      }
      while (v4);
    }
    v10 = *((unsigned int *)this + 8);
    if ((int)v10 >= 1)
    {
      v11 = *((_QWORD *)this + 11);
      v12 = (int *)(*((_QWORD *)this + 5) + 12);
      v13 = (float32x2_t *)(*((_QWORD *)this + 7) + 4);
      do
      {
        *v13 = vsub_f32(*(float32x2_t *)(v11 + 48 * *v12 + 36), *(float32x2_t *)(v11 + 48 * *(v12 - 1) + 36));
        v13 += 8;
        v12 += 8;
        --v10;
      }
      while (v10);
    }
    Shape::SortEdges(this);
    v14 = *((unsigned int *)this + 8);
    if ((int)v14 >= 1)
    {
      v15 = (_QWORD *)(*((_QWORD *)this + 9) + 8);
      do
      {
        *(v15 - 1) = 0;
        *v15 = -1;
        v15 += 4;
        --v14;
      }
      while (v14);
    }
    v40 = 0;
    v16 = 0;
    v17 = *((_DWORD *)this + 4);
    while (1)
    {
      if ((int)v16 >= v17)
        goto LABEL_20;
      v18 = *((_QWORD *)this + 3);
      v19 = v16 << 32;
      v20 = (unsigned int *)(v18 + 28 * (int)v16 + 16);
      while (1)
      {
        v22 = *v20;
        v20 += 7;
        v21 = v22;
        if ((v22 & 0x80000000) == 0 && !*(_QWORD *)(*((_QWORD *)this + 9) + 32 * v21))
          break;
        v19 += 0x100000000;
        LODWORD(v16) = v16 + 1;
        if (v17 == (_DWORD)v16)
        {
          LODWORD(v16) = v17;
          goto LABEL_20;
        }
      }
      v23 = *(_DWORD *)(v18 + 28 * SHIDWORD(v19) + 16);
      if ((v23 & 0x80000000) == 0)
        break;
LABEL_20:
      v16 = (v16 + 1);
      if ((int)v16 >= v17)
      {
        Shape::MakePointData(this, 0);
        Shape::MakeEdgeData(this, 0);
        Shape::MakeSweepDestData(this, 0);
        return;
      }
    }
    v24 = *((_QWORD *)this + 5);
    while (1)
    {
      v25 = v24 + 32 * v23;
      v26 = *(_DWORD *)(v25 + 8);
      v27 = *(_DWORD *)(v25 + 12);
      if (v26 == (_DWORD)v16)
        break;
      if (v27 == (_DWORD)v16)
      {
        v23 = *(_DWORD *)(v24 + 32 * v23 + 24);
        if ((v23 & 0x80000000) == 0)
          continue;
      }
      goto LABEL_20;
    }
    Path::MoveTo(a2, *(float *)(v18 + 28 * v27), *(float *)(v18 + 28 * v27 + 4));
    v28 = (_QWORD *)(*((_QWORD *)this + 9) + 32 * v23);
    *v28 = 1;
    v28[1] = -1;
LABEL_29:
    v29 = 0;
    v30 = v23;
LABEL_30:
    v31 = *((_QWORD *)this + 5);
    v32 = *(_DWORD *)(v31 + 32 * v30 + 12);
    LODWORD(v33) = v30;
    while (1)
    {
      v34 = v33;
      v35 = (_DWORD *)(v31 + 32 * (int)v33);
      if (v35[2] != v32)
        break;
      v23 = v35[4];
      if ((v23 & 0x80000000) != 0)
        goto LABEL_33;
LABEL_34:
      if (v23 == (_DWORD)v33)
        v33 = 0xFFFFFFFFLL;
      else
        v33 = v23;
      if (v23 == v34
        || (v23 & 0x80000000) != 0
        || v23 == v30
        || !*(_QWORD *)(*((_QWORD *)this + 9) + 32 * (int)v33) && *(_DWORD *)(v31 + 32 * (int)v33 + 8) == v32)
      {
        if ((v33 & 0x80000000) == 0 && (_DWORD)v33 != v30)
        {
          v36 = *((_QWORD *)this + 3);
          if ((v29 & 1) != 0)
          {
            Path::MoveTo(a2, *(float *)(v36 + 28 * v32), *(float *)(v36 + 28 * v32 + 4));
            v36 = *((_QWORD *)this + 3);
            v31 = *((_QWORD *)this + 5);
          }
          v37 = *((_QWORD *)this + 9);
          v38 = v37 + 32 * v33;
          *(_QWORD *)v38 = 1;
          *(_DWORD *)(v38 + 24) = v40;
          *(_DWORD *)(v38 + 12) = v30;
          *(_DWORD *)(v37 + 32 * v30 + 8) = v33;
          v39 = (float *)(v36 + 28 * *(int *)(v31 + 32 * v33 + 12));
          Path::LineTo(a2, *v39, v39[1]);
          ++v40;
          goto LABEL_29;
        }
LABEL_48:
        if ((v29 & 1) == 0)
          Path::Close(a2);
        v30 = *(_DWORD *)(*((_QWORD *)this + 9) + 32 * v30 + 12);
        v29 = 1;
        if ((v30 & 0x80000000) != 0)
        {
          v17 = *((_DWORD *)this + 4);
          goto LABEL_20;
        }
        goto LABEL_30;
      }
    }
    if (v35[3] != v32)
      goto LABEL_48;
    v23 = *(_DWORD *)(v31 + 32 * (int)v33 + 24);
    if ((v23 & 0x80000000) == 0)
      goto LABEL_34;
LABEL_33:
    v23 = *(_DWORD *)(*((_QWORD *)this + 3) + 28 * v32 + 16);
    goto LABEL_34;
  }
}

void Shape::ConvertToForme(Shape *this, Path *a2, int a3, Path **a4)
{
  uint64_t v6;
  float *v7;
  float *v8;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  float32x2_t *v15;
  uint64_t v16;
  _QWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  _QWORD *v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  int v35;
  _DWORD *v36;
  unsigned int v37;
  uint64_t v38;
  Path *v39;
  int v40;

  if (*((int *)this + 4) >= 2 && *((int *)this + 8) >= 2 && Shape::Eulerian(this, 1))
  {
    if ((*((_BYTE *)this + 53) & 2) == 0)
    {
      Shape::ConvertToForme(this, a2);
      return;
    }
    Path::Reset(a2);
    v39 = a2;
    Path::SetWeighted(a2, 0);
    Shape::MakePointData(this, 1);
    Shape::MakeEdgeData(this, 1);
    Shape::MakeSweepDestData(this, 1);
    v6 = *((unsigned int *)this + 4);
    if ((int)v6 >= 1)
    {
      v7 = (float *)(*((_QWORD *)this + 3) + 4);
      v8 = (float *)(*((_QWORD *)this + 11) + 40);
      do
      {
        v9 = ldexpf(*(v7 - 1), 5);
        *(v8 - 1) = ldexpf(roundf(v9), -5);
        v10 = *v7;
        v7 += 7;
        v11 = ldexpf(v10, 5);
        *v8 = ldexpf(roundf(v11), -5);
        v8 += 12;
        --v6;
      }
      while (v6);
    }
    v12 = *((unsigned int *)this + 8);
    if ((int)v12 >= 1)
    {
      v13 = *((_QWORD *)this + 11);
      v14 = (int *)(*((_QWORD *)this + 5) + 12);
      v15 = (float32x2_t *)(*((_QWORD *)this + 7) + 4);
      do
      {
        *v15 = vsub_f32(*(float32x2_t *)(v13 + 48 * *v14 + 36), *(float32x2_t *)(v13 + 48 * *(v14 - 1) + 36));
        v15 += 8;
        v14 += 8;
        --v12;
      }
      while (v12);
    }
    Shape::SortEdges(this);
    v16 = *((unsigned int *)this + 8);
    if ((int)v16 >= 1)
    {
      v17 = (_QWORD *)(*((_QWORD *)this + 9) + 8);
      do
      {
        *(v17 - 1) = 0;
        *v17 = -1;
        v17 += 4;
        --v16;
      }
      while (v16);
    }
    v18 = 0;
    v19 = 0;
    v20 = *((_DWORD *)this + 4);
    while (1)
    {
      if ((int)v19 >= v20)
        goto LABEL_23;
      v21 = *((_QWORD *)this + 3);
      v22 = v19 << 32;
      v23 = (unsigned int *)(v21 + 28 * (int)v19 + 16);
      while (1)
      {
        v25 = *v23;
        v23 += 7;
        v24 = v25;
        if ((v25 & 0x80000000) == 0)
        {
          v26 = *((_QWORD *)this + 9);
          if (!*(_QWORD *)(v26 + 32 * v24))
            break;
        }
        v22 += 0x100000000;
        LODWORD(v19) = v19 + 1;
        if (v20 == (_DWORD)v19)
        {
          LODWORD(v19) = v20;
          goto LABEL_23;
        }
      }
      v27 = *(_DWORD *)(v21 + 28 * SHIDWORD(v22) + 16);
      if ((v27 & 0x80000000) == 0)
        break;
LABEL_23:
      v19 = (v19 + 1);
      if ((int)v19 >= v20)
      {
        Shape::MakePointData(this, 0);
        Shape::MakeEdgeData(this, 0);
        Shape::MakeSweepDestData(this, 0);
        return;
      }
    }
    v28 = *((_QWORD *)this + 5);
    while (1)
    {
      v29 = v28 + 32 * v27;
      if (*(_DWORD *)(v29 + 8) == (_DWORD)v19)
        break;
      if (*(_DWORD *)(v29 + 12) == (_DWORD)v19)
      {
        v27 = *(_DWORD *)(v28 + 32 * v27 + 24);
        if ((v27 & 0x80000000) == 0)
          continue;
      }
      goto LABEL_23;
    }
    v30 = 0;
    v31 = (_QWORD *)(v26 + 32 * v27);
    *v31 = 1;
    v31[1] = -1;
    v32 = v27;
    v40 = v19;
LABEL_32:
    v33 = *(_DWORD *)(v28 + 32 * v32 + 12);
    LODWORD(v34) = v32;
    while (1)
    {
      v35 = v34;
      v36 = (_DWORD *)(v28 + 32 * (int)v34);
      if (v36[2] != v33)
        break;
      v37 = v36[4];
      if ((v37 & 0x80000000) != 0)
        goto LABEL_35;
LABEL_36:
      if (v37 == (_DWORD)v34)
        v34 = 0xFFFFFFFFLL;
      else
        v34 = v37;
      if (v37 == v35
        || (v37 & 0x80000000) != 0
        || v37 == v32
        || !*(_QWORD *)(v26 + 32 * (int)v34) && *(_DWORD *)(v28 + 32 * (int)v34 + 8) == v33)
      {
        if ((v34 & 0x80000000) == 0 && (_DWORD)v34 != v32)
        {
          if ((v30 & 1) != 0)
          {
            v40 = *(_DWORD *)(v28 + 32 * v34 + 8);
            goto LABEL_60;
          }
          if (v33 == v40)
          {
            *(_DWORD *)(v26 + 32 * v32 + 8) = -1;
            Shape::AddContour(this, v39, a3, a4, v27);
            v26 = *((_QWORD *)this + 9);
LABEL_60:
            v27 = v37;
          }
          v30 = 0;
          v38 = v26 + 32 * v34;
          *(_QWORD *)v38 = 1;
          *(_DWORD *)(v38 + 24) = v18++;
          *(_DWORD *)(v38 + 12) = v32;
          *(_DWORD *)(v26 + 32 * v32 + 8) = v34;
LABEL_62:
          v28 = *((_QWORD *)this + 5);
          v32 = v37;
          goto LABEL_32;
        }
LABEL_52:
        if ((v30 & 1) == 0 && v32 != v27 && (v32 & 0x80000000) == 0)
        {
          *(_DWORD *)(v26 + 32 * v32 + 8) = -1;
          Shape::AddContour(this, v39, a3, a4, v27);
          v26 = *((_QWORD *)this + 9);
        }
        v37 = *(_DWORD *)(v26 + 32 * v32 + 12);
        if ((v37 & 0x80000000) == 0)
        {
          v30 = 1;
          goto LABEL_62;
        }
        v20 = *((_DWORD *)this + 4);
        goto LABEL_23;
      }
    }
    if (v36[3] != v33)
      goto LABEL_52;
    v37 = *(_DWORD *)(v28 + 32 * (int)v34 + 24);
    if ((v37 & 0x80000000) == 0)
      goto LABEL_36;
LABEL_35:
    v37 = *(_DWORD *)(*((_QWORD *)this + 3) + 28 * v33 + 16);
    goto LABEL_36;
  }
}

uint64_t Shape::AddContour(Shape *this, Path *a2, int a3, Path **a4, signed int a5)
{
  unsigned int v5;
  float *v10;
  int v11;
  unsigned int *v12;
  uint64_t v13;
  Path *v14;
  unsigned int v15;
  path_descr *var3;
  int v17;
  float *v19;
  float *v20;
  unsigned int v21;
  uint64_t v22;

  v5 = a5;
  v10 = (float *)(*((_QWORD *)this + 3) + 28 * *(int *)(*((_QWORD *)this + 5) + 32 * a5 + 8));
  Path::MoveTo(a2, *v10, v10[1]);
  while ((v5 & 0x80000000) == 0)
  {
    while (1)
    {
      v12 = (unsigned int *)(*((_QWORD *)this + 12) + 16 * v5);
      v13 = *v12;
      if ((v13 & 0x80000000) == 0 && (int)v13 < a3)
      {
        v14 = a4[v13];
        if (v14)
        {
          v15 = v12[1];
          if ((v15 & 0x80000000) == 0 && (signed int)v15 < v14->var2)
            break;
        }
      }
      v20 = (float *)(*((_QWORD *)this + 3) + 28 * *(int *)(*((_QWORD *)this + 5) + 32 * v5 + 12));
      Path::LineTo(a2, *v20, v20[1]);
      v5 = *(_DWORD *)(*((_QWORD *)this + 9) + 32 * v5 + 8);
      if ((v5 & 0x80000000) != 0)
        return Path::Close(a2);
    }
    var3 = v14->var3;
    v17 = *((_DWORD *)var3 + 11 * v15) & 0xF;
    if ((*((_DWORD *)var3 + 11 * v15) & 0xD) == 5 || v17 == 0)
    {
LABEL_12:
      v19 = (float *)(*((_QWORD *)this + 3) + 28 * *(int *)(*((_QWORD *)this + 5) + 32 * v5 + 12));
      Path::LineTo(a2, *v19, v19[1]);
      v5 = *(_DWORD *)(*((_QWORD *)this + 9) + 32 * v5 + 8);
      if ((v5 & 0x80000000) != 0)
        return Path::Close(a2);
    }
    else
    {
      switch(v17)
      {
        case 1:
          goto LABEL_20;
        case 2:
          v21 = Shape::ReFormeCubicTo(this, v5, v11, a2, v14);
          break;
        case 3:
          if (*((_DWORD *)var3 + 11 * v15 + 4))
            goto LABEL_19;
LABEL_20:
          v21 = Shape::ReFormeLineTo(this, v5, v11, a2, v14);
          break;
        case 4:
          v21 = Shape::ReFormeArcTo(this, v5, v11, a2, v14);
          break;
        case 6:
LABEL_19:
          v21 = Shape::ReFormeBezierTo(this, v5, v11, a2, v14);
          break;
        default:
          goto LABEL_12;
      }
      v5 = v21;
      if ((v21 & 0x80000000) != 0)
        return Path::Close(a2);
    }
    v22 = *((_QWORD *)this + 3) + 28 * *(int *)(*((_QWORD *)this + 5) + 32 * v5 + 8);
    if (*(_DWORD *)(v22 + 12) + *(_DWORD *)(v22 + 8) >= 3)
      Path::ForcePoint(a2);
  }
  return Path::Close(a2);
}

uint64_t Shape::MakeOffset(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  int v10;
  int v11;
  int v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  int v20;
  int v21;
  int *v22;
  int v23;
  float *v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float *v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float *v34;
  float v35;
  float v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  Shape::Reset((void **)a1, 0);
  Shape::MakeBackData((Shape *)a1, 0);
  v10 = *(_DWORD *)(a2 + 16);
  if (a4 == 0.0)
  {
    *(_DWORD *)(a1 + 16) = v10;
    if (v10 > *(_DWORD *)(a1 + 20))
    {
      *(_DWORD *)(a1 + 20) = v10;
      *(_QWORD *)(a1 + 24) = malloc_type_realloc(*(void **)(a1 + 24), 28 * v10, 0x100004027586B93uLL);
      if ((*(_BYTE *)(a1 + 52) & 4) != 0)
        *(_QWORD *)(a1 + 88) = malloc_type_realloc(*(void **)(a1 + 88), 48 * *(int *)(a1 + 20), 0x102004023ED6C3AuLL);
    }
    memcpy(*(void **)(a1 + 24), *(const void **)(a2 + 24), 28 * *(int *)(a1 + 16));
    v11 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 32) = v11;
    if (v11 <= *(_DWORD *)(a1 + 36))
      goto LABEL_11;
    *(_DWORD *)(a1 + 36) = v11;
    *(_QWORD *)(a1 + 40) = malloc_type_realloc(*(void **)(a1 + 40), 32 * v11, 0x1000040E0EAB150uLL);
    v12 = *(_DWORD *)(a1 + 52);
    if ((v12 & 8) != 0)
    {
      *(_QWORD *)(a1 + 56) = malloc_type_realloc(*(void **)(a1 + 56), (uint64_t)*(int *)(a1 + 36) << 6, 0x100004094D12286uLL);
      v12 = *(_DWORD *)(a1 + 52);
      if ((v12 & 0x10) == 0)
      {
LABEL_8:
        if ((v12 & 0x20) == 0)
          goto LABEL_9;
        goto LABEL_44;
      }
    }
    else if ((v12 & 0x10) == 0)
    {
      goto LABEL_8;
    }
    *(_QWORD *)(a1 + 64) = malloc_type_realloc(*(void **)(a1 + 64), 56 * *(int *)(a1 + 36), 0x10A0040A41B8C3EuLL);
    v12 = *(_DWORD *)(a1 + 52);
    if ((v12 & 0x20) == 0)
    {
LABEL_9:
      if ((v12 & 0x80) == 0)
      {
LABEL_11:
        memcpy(*(void **)(a1 + 40), *(const void **)(a2 + 40), 32 * *(int *)(a1 + 32));
        return 0;
      }
LABEL_10:
      *(_QWORD *)(a1 + 80) = malloc_type_realloc(*(void **)(a1 + 80), 48 * *(int *)(a1 + 36), 0x10200403C9B7522uLL);
      goto LABEL_11;
    }
LABEL_44:
    *(_QWORD *)(a1 + 72) = malloc_type_realloc(*(void **)(a1 + 72), 32 * *(int *)(a1 + 36), 0x1080040DCAC275BuLL);
    if ((*(_DWORD *)(a1 + 52) & 0x80) == 0)
      goto LABEL_11;
    goto LABEL_10;
  }
  if (v10 >= 2 && *(int *)(a2 + 32) >= 2 && *(_DWORD *)(a2 + 48) == 1)
  {
    Shape::SortEdges((Shape *)a2);
    Shape::MakeSweepDestData((Shape *)a2, 1);
    Shape::MakeSweepSrcData((Shape *)a2, 1);
    LODWORD(v14) = *(_DWORD *)(a2 + 32);
    if ((int)v14 < 1)
    {
LABEL_32:
      if (a4 < 0.0 && *(int *)(a1 + 32) >= 1)
      {
        v38 = 0;
        do
          Shape::Inverse((Shape *)a1, v38++);
        while (v38 < *(_DWORD *)(a1 + 32));
        LODWORD(v14) = *(_DWORD *)(a2 + 32);
      }
      if ((int)v14 >= 1)
      {
        v39 = 0;
        v40 = 0;
        do
        {
          Shape::AddEdge((Shape *)a1, *(_DWORD *)(*(_QWORD *)(a2 + 64) + v39 + 12), *(_DWORD *)(*(_QWORD *)(a2 + 64) + v39 + 16));
          ++v40;
          v39 += 56;
        }
        while (v40 < *(int *)(a2 + 32));
      }
      Shape::MakeSweepSrcData((Shape *)a2, 0);
      Shape::MakeSweepDestData((Shape *)a2, 0);
      return 0;
    }
    v15 = 0;
    v16 = 0;
    v17 = 12;
    while (1)
    {
      v18 = *(_QWORD *)(a2 + 40);
      v19 = (int *)(v18 + v15);
      v20 = *(_DWORD *)(v18 + v15 + 8);
      if (a4 <= 0.0)
      {
        v21 = v19[5];
        if (v21 < 0)
        {
          v22 = (int *)(*(_QWORD *)(a2 + 24) + 28 * v20 + 20);
          goto LABEL_23;
        }
      }
      else
      {
        v21 = v19[4];
        if (v21 < 0)
        {
          v22 = (int *)(*(_QWORD *)(a2 + 24) + 28 * v20 + 16);
LABEL_23:
          v21 = *v22;
        }
      }
      v23 = v21;
      v24 = (float *)(v18 + 32 * v21);
      v25 = *v24;
      v26 = v24[1];
      v27 = (float)(v26 * v26) + (float)(v25 * v25);
      v28 = sqrtf(v27);
      if (v27 > 0.0001)
      {
        v25 = v25 / v28;
        v26 = v26 / v28;
      }
      v29 = (float *)(v18 + v15);
      v30 = *v29;
      v31 = v29[1];
      v32 = (float)(v31 * v31) + (float)(v30 * v30);
      v33 = sqrtf(v32);
      if (v32 > 0.0001)
      {
        v30 = v30 / v33;
        v31 = v31 / v33;
      }
      v41 = 0;
      v34 = (float *)(*(_QWORD *)(a2 + 24) + 28 * v19[2]);
      v35 = *v34;
      v36 = v34[1];
      if (a4 <= 0.0)
        Path::DoLeftJoin((Shape *)a1, a3, (unsigned int *)&v41 + 1, (unsigned int *)&v41, -a4, v35, v36, v25, v26, v30, v31, a5);
      else
        Path::DoRightJoin((Shape *)a1, a3, (unsigned int *)&v41 + 1, (unsigned int *)&v41, a4, v35, v36, v25, v26, v30, v31, a5);
      v37 = *(_QWORD *)(a2 + 64);
      *(_DWORD *)(v37 + v17) = v41;
      *(_DWORD *)(v37 + 56 * v23 + 16) = HIDWORD(v41);
      ++v16;
      v14 = *(int *)(a2 + 32);
      v17 += 56;
      v15 += 32;
      if (v16 >= v14)
        goto LABEL_32;
    }
  }
  return 5;
}

uint64_t Shape::ReFormeLineTo(Shape *this, int a2, int a3, Path *a4, Path *a5)
{
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  float *v14;

  v5 = *((_QWORD *)this + 12);
  v6 = a2;
  v7 = (int *)(v5 + 16 * a2);
  v9 = *v7;
  v8 = v7[1];
  v10 = *((_QWORD *)this + 3);
  v11 = *((_QWORD *)this + 5);
  do
  {
    v12 = v6;
    v6 = *(unsigned int *)(*((_QWORD *)this + 9) + 32 * v6 + 8);
    if ((v6 & 0x80000000) != 0)
      break;
    v13 = *(_DWORD *)(v11 + 32 * v6 + 8);
    if (*(_DWORD *)(v10 + 28 * v13 + 12) + *(_DWORD *)(v10 + 28 * v13 + 8) > 2)
      break;
  }
  while (*(int *)(v10 + 28 * v13 + 24) <= 2
       && *(_DWORD *)(v5 + 16 * v6 + 4) == v8
       && *(_DWORD *)(v5 + 16 * v6) == v9
       && vabds_f32(*(float *)(v5 + 16 * v12 + 12), *(float *)(v5 + 16 * v6 + 8)) <= 0.0001);
  v14 = (float *)(v10 + 28 * *(int *)(v11 + 32 * v12 + 12));
  Path::LineTo(a4, *v14, v14[1]);
  return v6;
}

uint64_t Shape::ReFormeArcTo(Shape *this, int a2, int a3, Path *a4, Path *a5)
{
  uint64_t v7;
  uint64_t v8;
  float *v9;
  float v10;
  int v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float v17;
  int v18;
  float *v19;
  float v20;
  float v21;
  char *v22;
  Path *v23;
  int v24;
  BOOL v25;
  float *v26;
  float *v27;
  float v28;
  double v29;
  double v30;
  char v31;
  float v32;
  float v33;
  float *v34;
  uint64_t v36;
  uint64_t v37;

  v7 = *((_QWORD *)this + 12);
  v8 = a2;
  v9 = (float *)(v7 + 16 * a2);
  v10 = *v9;
  v11 = *((_DWORD *)v9 + 1);
  v12 = v9[2];
  v13 = *((_QWORD *)this + 3);
  v14 = *((_QWORD *)this + 5);
  do
  {
    v15 = v8;
    v16 = v7 + 16 * v8;
    v8 = *(unsigned int *)(*((_QWORD *)this + 9) + 32 * v8 + 8);
    v17 = *(float *)(v16 + 12);
    if ((v8 & 0x80000000) != 0)
      break;
    v18 = *(_DWORD *)(v14 + 32 * v8 + 8);
    if (*(_DWORD *)(v13 + 28 * v18 + 12) + *(_DWORD *)(v13 + 28 * v18 + 8) > 2)
      break;
  }
  while (*(int *)(v13 + 28 * v18 + 24) <= 2
       && *(_DWORD *)(v7 + 16 * v8 + 4) == v11
       && *(_DWORD *)(v7 + 16 * v8) == LODWORD(v10)
       && vabds_f32(v17, *(float *)(v7 + 16 * v8 + 8)) <= 0.0001);
  v19 = (float *)(v13 + 28 * *(int *)(v14 + 32 * v15 + 12));
  v21 = *v19;
  v20 = v19[1];
  v37 = 0;
  v22 = (char *)a5->var3 + 44 * v11;
  v23 = (Path *)v22[36];
  v24 = v22[37];
  v25 = v22[37] != 0;
  v36 = 0;
  Path::PrevPoint(a5, v11 - 1, (float *)&v36 + 1, (float *)&v36);
  v26 = (float *)((char *)a5->var3 + 44 * v11);
  Path::ArcAngles(v23, *((float *)&v36 + 1), *(float *)&v36, v26[4], v26[5], v26[6], v26[7], v26[8], v24, (float *)&v37 + 1, (float *)&v37, v27);
  v28 = *((float *)&v37 + 1);
  if (v24)
  {
    if (*((float *)&v37 + 1) >= *(float *)&v37)
      goto LABEL_14;
    v29 = *((float *)&v37 + 1);
    v30 = 6.28318531;
  }
  else
  {
    if (*((float *)&v37 + 1) <= *(float *)&v37)
      goto LABEL_14;
    v29 = *((float *)&v37 + 1);
    v30 = -6.28318531;
  }
  v28 = v29 + v30;
  *((float *)&v37 + 1) = v28;
LABEL_14:
  if (v12 > v17)
    v31 = v24 == 0;
  else
    v31 = v25;
  v32 = (float)(v17 - v12) * (float)(*(float *)&v37 - v28);
  v33 = -v32;
  if (v32 >= 0.0)
    v33 = (float)(v17 - v12) * (float)(*(float *)&v37 - v28);
  v34 = (float *)((char *)a5->var3 + 44 * v11);
  Path::ArcTo(a4, v21, v20, v34[6], v34[7], v34[8], v33 > 3.14159265, v31);
  return v8;
}

uint64_t Shape::ReFormeCubicTo(Shape *this, int a2, int a3, Path *a4, Path *a5)
{
  uint64_t v7;
  uint64_t v8;
  float *v9;
  float v10;
  int v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  int v17;
  float *v18;
  float v19;
  float v20;
  float *v21;
  float *v22;
  float *v23;
  float *v24;
  Path v26;

  v7 = *((_QWORD *)this + 12);
  v8 = a2;
  v9 = (float *)(v7 + 16 * a2);
  v10 = *v9;
  v11 = *((_DWORD *)v9 + 1);
  v12 = v9[2];
  v13 = *((_QWORD *)this + 3);
  v14 = *((_QWORD *)this + 5);
  do
  {
    v15 = v8;
    v16 = *(float *)(v7 + 16 * v8 + 12);
    v8 = *(unsigned int *)(*((_QWORD *)this + 9) + 32 * v8 + 8);
    if ((v8 & 0x80000000) != 0)
      break;
    v17 = *(_DWORD *)(v14 + 32 * v8 + 8);
    if (*(_DWORD *)(v13 + 28 * v17 + 12) + *(_DWORD *)(v13 + 28 * v17 + 8) > 2)
      break;
  }
  while (*(int *)(v13 + 28 * v17 + 24) <= 2
       && *(_DWORD *)(v7 + 16 * v8 + 4) == v11
       && *(_DWORD *)(v7 + 16 * v8) == LODWORD(v10)
       && vabds_f32(v16, *(float *)(v7 + 16 * v8 + 8)) <= 0.0001);
  v18 = (float *)(v13 + 28 * *(int *)(v14 + 32 * v15 + 12));
  v20 = *v18;
  v19 = v18[1];
  v26.var3 = 0;
  Path::PrevPoint(a5, v11 - 1, (float *)&v26.var3 + 1, (float *)&v26.var3);
  *(_QWORD *)&v26.var0 = 0;
  *(_QWORD *)&v26.var2 = 0;
  v21 = (float *)((char *)a5->var3 + 44 * v11);
  Path::CubicTangent((Path *)(&v26.var2 + 1), v12, (float *)&v26.var2, v22, *((float *)&v26.var3 + 1), *(float *)&v26.var3, v21[6], v21[7], v21[4], v21[5], v21[8], v21[9]);
  v23 = (float *)((char *)a5->var3 + 44 * v11);
  Path::CubicTangent((Path *)&v26.var1, v16, (float *)&v26.var0, v24, *((float *)&v26.var3 + 1), *(float *)&v26.var3, v23[6], v23[7], v23[4], v23[5], v23[8], v23[9]);
  Path::CubicTo(a4, v20, v19, (float)(v16 - v12) * *((float *)&v26.var2 + 1), (float)(v16 - v12) * *(float *)&v26.var2, (float)(v16 - v12) * *(float *)&v26.var1, (float)(v16 - v12) * *(float *)&v26.var0);
  return v8;
}

uint64_t Shape::ReFormeBezierTo(Shape *this, int a2, int a3, Path *a4, Path *a5)
{
  uint64_t v7;
  float *v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float *v17;
  float v18;
  float v19;
  float *v20;
  float v21;
  float v22;
  path_descr *var3;
  int v24;
  uint64_t v25;
  int *v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  Shape *v33;
  int v34;
  float v35;
  float v36;
  float v37;
  float v38;
  Path *v39;
  int v40;
  int v41;
  Path *v42;
  int v43;
  float v44;
  path_descr *v45;
  double v46;
  double v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  float v53;
  double v54;
  float *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  float *v64;
  float v65;
  float v66;
  uint64_t v67;
  uint64_t v68;
  float *v69;
  uint64_t v70;
  path_descr *v71;
  float *v72;
  float *v73;
  uint64_t v74;
  float *v75;
  uint64_t v76;
  uint64_t v78;

  v7 = *((_QWORD *)this + 12);
  v8 = (float *)(v7 + 16 * a2);
  v9 = *v8;
  v10 = *((unsigned int *)v8 + 1);
  v11 = (int)v10;
  v13 = v8[2];
  v12 = v8[3];
  v14 = *((_QWORD *)this + 3);
  v15 = *((_QWORD *)this + 5);
  v16 = v15 + 32 * a2;
  v17 = (float *)(v14 + 28 * *(int *)(v16 + 8));
  v19 = *v17;
  v18 = v17[1];
  v20 = (float *)(v14 + 28 * *(int *)(v16 + 12));
  v22 = *v20;
  v21 = v20[1];
  var3 = a5->var3;
  v24 = v10;
  v25 = (int)v10;
  if ((*((_DWORD *)var3 + 11 * (int)v10) & 0xF) == 3)
  {
LABEL_6:
    v28 = *((_DWORD *)var3 + 11 * v25 + 4);
    v29 = *((_QWORD *)this + 9);
    v30 = *(unsigned int *)(v29 + 32 * a2 + 8);
    if ((v30 & 0x80000000) != 0
      || (v31 = *(int *)(v15 + 32 * v30 + 8),
          *(_DWORD *)(v14 + 28 * (int)v31 + 12) + *(_DWORD *)(v14 + 28 * (int)v31 + 8) > 2))
    {
      v32 = v10;
    }
    else
    {
      v32 = v10;
      do
      {
        if (*(int *)(v14 + 28 * v31 + 24) > 2 || *(_DWORD *)(v7 + 16 * v30) != LODWORD(v9))
          break;
        v50 = v7 + 16 * v30;
        v51 = *(_DWORD *)(v50 + 4);
        if (v51 < v24 || v51 >= v28 + v24)
          break;
        v53 = *(float *)(v50 + 8);
        if (v51 == v32)
        {
          if (vabds_f32(v12, v53) > 0.0001)
            break;
        }
        else
        {
          v54 = v53;
          if (v54 > 0.0001 && v54 < 0.9999 || v12 > 0.0001 && v12 < 0.9999)
            break;
        }
        v55 = (float *)(v14 + 28 * *(int *)(v15 + 32 * v30 + 12));
        v22 = *v55;
        v21 = v55[1];
        v12 = *(float *)(v7 + 16 * v30 + 12);
        v30 = *(unsigned int *)(v29 + 32 * v30 + 8);
        if ((v30 & 0x80000000) != 0)
        {
          v32 = v51;
          break;
        }
        v31 = *(int *)(v15 + 32 * v30 + 8);
        v32 = v51;
      }
      while (*(_DWORD *)(v14 + 28 * (int)v31 + 12) + *(_DWORD *)(v14 + 28 * (int)v31 + 8) <= 2);
    }
    v78 = 0;
    Path::PrevPoint(a5, v24 - 1, (float *)&v78 + 1, (float *)&v78);
    v34 = v32 - v10;
    if (v32 == (_DWORD)v10)
    {
      v35 = v19;
      v36 = v18;
      v37 = v22;
      v38 = v21;
      v39 = a4;
      v40 = v24;
      v41 = v28;
      v42 = a5;
      v43 = v10;
      v44 = v13;
LABEL_63:
      Shape::ReFormeBezierChunk(v33, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v12);
      return v30;
    }
    v45 = a5->var3;
    v46 = v13;
    v47 = v12;
    if (v32 <= (int)v10)
    {
      if (v46 <= 0.9999)
      {
        v60 = (int)v10 + 1;
        Shape::ReFormeBezierChunk(v33, v19, v18, (float)(*((float *)v45 + 11 * v60 + 4) + *((float *)v45 + 11 * (int)v10 + 4)) * 0.5, (float)(*((float *)v45 + 11 * v60 + 5) + *((float *)v45 + 11 * (int)v10 + 5)) * 0.5, a4, v24, v28, a5, v10, v13, 0.0);
        if (v47 < 0.0001)
        {
          Path::BezierTo(a4, v22, v21);
          v61 = v32;
          v62 = (int)v10 + 2;
          v63 = 44 * v60;
          do
          {
            Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v63 + 16), *(float *)((char *)a5->var3 + v63 + 20));
            --v62;
            v63 -= 44;
          }
          while (v62 > v61);
          goto LABEL_48;
        }
        v75 = (float *)((char *)a5->var3 + 44 * v32);
        v65 = (float)(v75[15] + v75[26]) * 0.5;
        v66 = (float)(v75[16] + v75[27]) * 0.5;
        Path::BezierTo(a4, v65, v66);
        v76 = 44 * v60;
        do
        {
          Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v76 + 16), *(float *)((char *)a5->var3 + v76 + 20));
          --v60;
          v76 -= 44;
        }
        while (v60 > v32);
      }
      else
      {
        if (v47 < 0.0001)
        {
          Path::BezierTo(a4, v22, v21);
          v56 = v32;
          v57 = (int)v10 + 1;
          v58 = 44 * (int)v10;
          do
          {
            Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v58 + 60), *(float *)((char *)a5->var3 + v58 + 64));
            --v57;
            v58 -= 44;
          }
          while (v57 > v56);
          goto LABEL_48;
        }
        v69 = (float *)((char *)v45 + 44 * v32);
        v65 = (float)(v69[15] + v69[26]) * 0.5;
        v66 = (float)(v69[16] + v69[27]) * 0.5;
        Path::BezierTo(a4, v65, v66);
        if (v32 < (int)v10)
        {
          v70 = 44 * (int)v10;
          do
          {
            Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v70 + 60), *(float *)((char *)a5->var3 + v70 + 64));
            --v11;
            v70 -= 44;
          }
          while (v11 > v32);
        }
      }
      v33 = (Shape *)Path::EndBezierTo(a4);
      v44 = 1.0;
    }
    else
    {
      if (v46 >= 0.0001)
      {
        Shape::ReFormeBezierChunk(v33, v19, v18, (float)(*((float *)v45 + 11 * (int)v10 + 15) + *((float *)v45 + 11 * (int)v10 + 26)) * 0.5, (float)(*((float *)v45 + 11 * (int)v10 + 16) + *((float *)v45 + 11 * (int)v10 + 27)) * 0.5, a4, v24, v28, a5, v10, v13, 1.0);
        if (v47 > 0.9999)
        {
          Path::BezierTo(a4, v22, v21);
          v59 = 44 * (int)v10;
          do
          {
            Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v59 + 104), *(float *)((char *)a5->var3 + v59 + 108));
            v59 += 44;
            --v34;
          }
          while (v34);
          goto LABEL_48;
        }
        v71 = a5->var3;
        v72 = (float *)((char *)v71 + 44 * v32 + 44);
        v73 = (float *)((char *)v71 + 44 * v32);
        v65 = (float)(v72[4] + v73[4]) * 0.5;
        v66 = (float)(v72[5] + v73[5]) * 0.5;
        Path::BezierTo(a4, v65, v66);
        v74 = 44 * (int)v10;
        do
        {
          Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v74 + 104), *(float *)((char *)a5->var3 + v74 + 108));
          LODWORD(v10) = v10 + 1;
          v74 += 44;
        }
        while (v32 != (_DWORD)v10);
      }
      else
      {
        if (v47 > 0.9999)
        {
          Path::BezierTo(a4, v22, v21);
          v48 = v32 + 1 - (uint64_t)(int)v10;
          v49 = 44 * (int)v10;
          do
          {
            Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v49 + 60), *(float *)((char *)a5->var3 + v49 + 64));
            v49 += 44;
            --v48;
          }
          while (v48);
LABEL_48:
          Path::EndBezierTo(a4);
          return v30;
        }
        v64 = (float *)((char *)v45 + 44 * v32);
        v65 = (float)(v64[15] + v64[4]) * 0.5;
        v66 = (float)(v64[16] + v64[5]) * 0.5;
        Path::BezierTo(a4, v65, v66);
        v67 = v32 - (uint64_t)(int)v10;
        v68 = 44 * (int)v11;
        do
        {
          Path::IntermBezierTo(a4, *(float *)((char *)a5->var3 + v68 + 60), *(float *)((char *)a5->var3 + v68 + 64));
          v68 += 44;
          --v67;
        }
        while (v67);
      }
      v33 = (Shape *)Path::EndBezierTo(a4);
      v44 = 0.0;
    }
    v35 = v65;
    v36 = v66;
    v37 = v22;
    v38 = v21;
    v39 = a4;
    v40 = v24;
    v41 = v28;
    v42 = a5;
    v43 = v32;
    goto LABEL_63;
  }
  v26 = (int *)((char *)var3 + 44 * v10 - 44);
  v25 = v10;
  while ((int)v25 >= 2)
  {
    --v25;
    v27 = *v26;
    v26 -= 11;
    if ((v27 & 0xF) == 3)
    {
      v24 = v25;
      goto LABEL_6;
    }
  }
  v30 = *(unsigned int *)(*((_QWORD *)this + 9) + 32 * a2 + 8);
  Path::LineTo(a4, v22, v21);
  return v30;
}

uint64_t Shape::ReFormeBezierChunk(Shape *this, float a2, float a3, float a4, float a5, Path *a6, int a7, int a8, Path *a9, int a10, float a11, float a12)
{
  float *v23;
  path_descr *var3;
  float32x2_t v25;
  float32x2_t v26;
  char *v27;
  float v28;
  Path v30;

  *(_QWORD *)&v30.var2 = 0;
  Path::PrevPoint(a9, a7 - 1, (float *)&v30.var2 + 1, (float *)&v30.var2);
  var3 = a9->var3;
  v25 = *(float32x2_t *)((char *)var3 + 44 * a7 + 20);
  if (a10 == a7)
  {
    v26 = *(float32x2_t *)((char *)var3 + 44 * a7 + 60);
    if (a8 >= 2)
    {
      v27 = (char *)var3 + 44 * a7;
LABEL_7:
      v25 = vmul_f32(vadd_f32(v26, *(float32x2_t *)(v27 + 104)), (float32x2_t)0x3F0000003F000000);
    }
  }
  else
  {
    v28 = *((float *)var3 + 11 * a10 + 4);
    if (a8 + a7 - 1 != a10)
    {
      v27 = (char *)var3 + 44 * a10;
      v26 = *(float32x2_t *)(v27 + 60);
      *((float *)&v30.var2 + 1) = (float)(v26.f32[0] + v28) * 0.5;
      *(float *)&v30.var2 = (float)(v26.f32[1] + *((float *)v27 + 5)) * 0.5;
      goto LABEL_7;
    }
    v26 = *(float32x2_t *)((char *)var3 + 44 * a8 + 44 * a7 + 16);
    *((float *)&v30.var2 + 1) = (float)(v26.f32[0] + v28) * 0.5;
    *(float *)&v30.var2 = (float)(v26.f32[1] + *((float *)var3 + 11 * a10 + 5)) * 0.5;
  }
  *(_QWORD *)&v30.var0 = 0;
  Path::QuadraticPoint((Path *)&v30.var1, (float)(a11 + a12) * 0.5, (float *)&v30.var0, v23, *((float *)&v30.var2 + 1), *(float *)&v30.var2, v26.f32[0], v26.f32[1], v25.f32[0], v25.f32[1]);
  *(float *)&v30.var0 = (float)((float)(a3 + a5) * -0.5) + (float)(*(float *)&v30.var0 * 2.0);
  *(float *)&v30.var1 = (float)((float)(a2 + a4) * -0.5) + (float)(*(float *)&v30.var1 * 2.0);
  Path::BezierTo(a6, a4, a5);
  Path::IntermBezierTo(a6, *(float *)&v30.var1, *(float *)&v30.var0);
  return Path::EndBezierTo(a6);
}

void Shape::ResetSweep(Shape *this)
{
  Shape::MakePointData(this, 1);
  Shape::MakeEdgeData(this, 1);
  Shape::MakeSweepSrcData(this, 1);
}

void Shape::CleanupSweep(Shape *this)
{
  Shape::MakePointData(this, 0);
  Shape::MakeEdgeData(this, 0);
  Shape::MakeSweepSrcData(this, 0);
}

uint64_t Shape::ForceToPolygon(uint64_t this)
{
  *(_DWORD *)(this + 48) = 1;
  return this;
}

uint64_t Shape::Reoriente(void **this, Shape *a2)
{
  uint64_t result;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  float *v9;
  float *v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  _DWORD *v16;
  uint64_t v17;
  char *v18;
  int *v19;
  float32x2_t *v20;
  float32x2_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int i;
  uint64_t v26;
  int *v27;
  int v28;
  int v29;
  int v30;
  int *v31;
  int v32;
  _DWORD *v33;

  Shape::Reset(this, 0);
  result = 0;
  if (*((int *)a2 + 4) < 2)
    return result;
  if (*((int *)a2 + 8) < 2)
    return 0;
  if (!Shape::Eulerian(a2, 1))
    return 5;
  v5 = *((_DWORD *)a2 + 4);
  *((_DWORD *)this + 4) = v5;
  if (v5 > *((_DWORD *)this + 5))
  {
    *((_DWORD *)this + 5) = v5;
    this[3] = reallocf(this[3], 28 * v5);
    if ((*((_BYTE *)this + 52) & 4) != 0)
      this[11] = reallocf(this[11], 48 * *((int *)this + 5));
  }
  memcpy(this[3], *((const void **)a2 + 3), 28 * *((int *)this + 4));
  v6 = *((_DWORD *)a2 + 8);
  *((_DWORD *)this + 8) = v6;
  if (v6 <= *((_DWORD *)this + 9))
    goto LABEL_14;
  *((_DWORD *)this + 9) = v6;
  this[5] = malloc_type_realloc(this[5], 32 * v6, 0x1000040E0EAB150uLL);
  v7 = *((_DWORD *)this + 13);
  if ((v7 & 8) != 0)
  {
    this[7] = reallocf(this[7], (uint64_t)*((int *)this + 9) << 6);
    v7 = *((_DWORD *)this + 13);
    if ((v7 & 0x10) == 0)
    {
LABEL_11:
      if ((v7 & 0x20) == 0)
        goto LABEL_12;
LABEL_50:
      this[9] = reallocf(this[9], 32 * *((int *)this + 9));
      if ((*((_DWORD *)this + 13) & 0x80) == 0)
        goto LABEL_14;
      goto LABEL_13;
    }
  }
  else if ((v7 & 0x10) == 0)
  {
    goto LABEL_11;
  }
  this[8] = reallocf(this[8], 56 * *((int *)this + 9));
  v7 = *((_DWORD *)this + 13);
  if ((v7 & 0x20) != 0)
    goto LABEL_50;
LABEL_12:
  if ((v7 & 0x80) != 0)
LABEL_13:
    this[10] = reallocf(this[10], 48 * *((int *)this + 9));
LABEL_14:
  memcpy(this[5], *((const void **)a2 + 5), 32 * *((int *)this + 8));
  Shape::MakePointData((Shape *)this, 1);
  Shape::MakeEdgeData((Shape *)this, 1);
  Shape::MakeSweepDestData((Shape *)this, 1);
  v8 = *((unsigned int *)this + 4);
  if ((int)v8 >= 1)
  {
    v9 = (float *)((char *)this[11] + 40);
    v10 = (float *)((char *)this[3] + 4);
    v11 = *((unsigned int *)this + 4);
    do
    {
      *((_QWORD *)v9 - 4) = 0xFFFFFFFF00000000;
      *(v9 - 6) = NAN;
      v12 = ldexpf(*(v10 - 1), 5);
      v13 = ldexpf(roundf(v12), -5);
      *(v9 - 1) = v13;
      v14 = ldexpf(*v10, 5);
      v15 = ldexpf(roundf(v14), -5);
      *v9 = v15;
      v9 += 12;
      *(v10 - 1) = v13;
      *v10 = v15;
      v10 += 7;
      --v11;
    }
    while (v11);
    v16 = (char *)this[3] + 12;
    do
    {
      v16[3] = *v16 + *(v16 - 1);
      v16 += 7;
      --v8;
    }
    while (v8);
  }
  v17 = *((unsigned int *)a2 + 8);
  if ((int)v17 >= 1)
  {
    v18 = (char *)this[11];
    v19 = (int *)((char *)this[5] + 12);
    v20 = (float32x2_t *)((char *)this[7] + 4);
    do
    {
      v21 = vsub_f32(*(float32x2_t *)&v18[48 * *v19 + 36], *(float32x2_t *)&v18[48 * *(v19 - 1) + 36]);
      *v20 = v21;
      v20[-1].i32[1] = 1;
      *(float32x2_t *)(v19 - 3) = v21;
      v19 += 8;
      v20 += 8;
      --v17;
    }
    while (v17);
  }
  Shape::SortPointsRounded((Shape *)this);
  Shape::SetFlag((Shape *)this, 2, 1);
  Shape::GetWindings((Shape *)this, v22, v23, v24, 1);
  if (*((int *)this + 8) >= 1)
  {
    for (i = 0; i < *((_DWORD *)this + 8); ++i)
    {
      v26 = (uint64_t)this[9] + 32 * i;
      v28 = *(_DWORD *)(v26 + 16);
      v27 = (int *)(v26 + 16);
      v29 = v28 & 1;
      if (v28 >= 0)
        v30 = v29;
      else
        v30 = -v29;
      *v27 = v30;
      v31 = v27 + 1;
      if (v27[1] >= 0)
        v32 = v27[1] & 1;
      else
        v32 = -(v27[1] & 1);
      *v31 = v32;
      if (v30 < 0)
      {
        *v27 = -v30;
        v30 = 1;
        if ((v32 & 0x80000000) == 0)
        {
LABEL_32:
          if (v30)
            goto LABEL_33;
          goto LABEL_37;
        }
      }
      else if ((v32 & 0x80000000) == 0)
      {
        goto LABEL_32;
      }
      *v31 = -v32;
      v32 = 1;
      if (v30)
      {
LABEL_33:
        v33 = this[7];
        if (v32)
          goto LABEL_41;
        goto LABEL_39;
      }
LABEL_37:
      if (!v32)
      {
        v33 = this[7];
LABEL_41:
        v33[16 * (uint64_t)i] = 0;
        Shape::SubEdge((Shape *)this, i--);
        continue;
      }
      Shape::Inverse((Shape *)this, i);
      v33 = this[7];
LABEL_39:
      v33[16 * (uint64_t)i] = 1;
    }
  }
  Shape::MakePointData((Shape *)this, 0);
  Shape::MakeEdgeData((Shape *)this, 0);
  Shape::MakeSweepDestData((Shape *)this, 0);
  if (Shape::Eulerian((Shape *)this, 1))
  {
    result = 0;
    *((_DWORD *)this + 12) = 1;
  }
  else
  {
    *((_DWORD *)this + 8) = 0;
    *((_DWORD *)this + 4) = 0;
    return 4;
  }
  return result;
}

void Shape::GetWindings(Shape *this, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  int v43;
  BOOL v44;
  _BOOL4 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  BOOL v53;
  int v54;

  v6 = *((unsigned int *)this + 8);
  if ((int)v6 >= 1)
  {
    v7 = (_QWORD *)(*((_QWORD *)this + 9) + 8);
    do
    {
      *(v7 - 1) = 0;
      *v7 = -1;
      v7 += 4;
      --v6;
    }
    while (v6);
  }
  Shape::SortEdges(this);
  v8 = 0;
  v9 = 0;
  v10 = *((_DWORD *)this + 4);
  do
  {
    if ((int)v9 >= v10)
      goto LABEL_64;
    v11 = *((_QWORD *)this + 3);
    v12 = v9 << 32;
    v13 = (unsigned int *)(v11 + 28 * (int)v9 + 16);
    while (1)
    {
      v15 = *v13;
      v13 += 7;
      v14 = v15;
      if ((v15 & 0x80000000) == 0)
      {
        v16 = *((_QWORD *)this + 9);
        if (!*(_QWORD *)(v16 + 32 * v14))
          break;
      }
      v12 += 0x100000000;
      LODWORD(v9) = v9 + 1;
      if (v10 == (_DWORD)v9)
      {
        LODWORD(v9) = v10;
        goto LABEL_64;
      }
    }
    v17 = v12 >> 32;
    v18 = v11 + 28 * SHIDWORD(v12);
    v19 = *(unsigned int *)(v18 + 16);
    if ((v19 & 0x80000000) == 0)
    {
      if ((_DWORD)v9)
      {
        if (a5)
        {
          v20 = v8;
          v21 = Shape::Winding(this, *(float *)v18, *(float *)(v11 + 28 * (int)v17 + 4));
          v8 = v20;
          v22 = v21;
          goto LABEL_19;
        }
        v23 = *(unsigned int *)(*((_QWORD *)this + 11) + 48 * (int)v17 + 32);
        if ((v23 & 0x80000000) == 0)
        {
          v24 = *((_QWORD *)this + 5) + 32 * v23;
          v25 = v16 + 32 * v23;
          if (*(_DWORD *)(v24 + 8) >= *(_DWORD *)(v24 + 12))
            v22 = *(_DWORD *)(v25 + 20);
          else
            v22 = *(_DWORD *)(v25 + 16);
LABEL_19:
          v26 = *((_QWORD *)this + 5);
          if (*(_DWORD *)(v11 + 28 * (int)v17 + 12) + *(_DWORD *)(v11 + 28 * (int)v17 + 8) == 1
            && *(_DWORD *)(v26 + 32 * v19 + 12) == (_DWORD)v9)
          {
            if (*(_DWORD *)(*((_QWORD *)this + 7) + (v19 << 6)))
            {
              *(_DWORD *)(*((_QWORD *)this + 11) + 48 * *(int *)(v26 + 32 * v19 + 8) + 32) = *(_DWORD *)(*((_QWORD *)this + 11) + 48 * (int)v17 + 32);
            }
            else
            {
              v27 = v8;
              Shape::Inverse(this, v19);
              v8 = v27;
              v26 = *((_QWORD *)this + 5);
            }
          }
          v28 = *((_QWORD *)this + 7);
          v29 = *(_DWORD *)(v28 + (v19 << 6));
          if (*(_DWORD *)(v26 + 32 * v19 + 12) == (_DWORD)v9)
            v30 = *(_DWORD *)(v28 + (v19 << 6));
          else
            v30 = 0;
          v31 = v22 + v30;
          v32 = *((_QWORD *)this + 9);
          v33 = v32 + 32 * v19;
          v34 = 1;
          *(_QWORD *)v33 = 1;
          *(_DWORD *)(v33 + 16) = v31;
          *(_DWORD *)(v33 + 20) = v31 - v29;
          *(_QWORD *)(v33 + 8) = -1;
LABEL_29:
          LODWORD(v35) = v19;
LABEL_30:
          if (v34)
            v36 = 12;
          else
            v36 = 8;
          v37 = *(_DWORD *)(*((_QWORD *)this + 5) + 32 * v35 + v36);
          LODWORD(v19) = v35;
          while (1)
          {
            v38 = v19;
            v39 = v26 + 32 * (int)v19;
            v41 = *(_DWORD *)(v39 + 8);
            v40 = *(_DWORD *)(v39 + 12);
            v42 = v32 + 32 * (int)v19;
            if (v40 == v37)
              break;
            v43 = *(_DWORD *)(v42 + 16);
            if (v41 == v37)
              goto LABEL_39;
            LODWORD(v19) = -1;
LABEL_42:
            if ((_DWORD)v19 == v38)
              goto LABEL_52;
            v44 = (int)v19 < 0 || (_DWORD)v19 == (_DWORD)v35;
            v45 = v44;
            if (v44)
              goto LABEL_52;
            if (!*(_QWORD *)(v32 + 32 * v19))
            {
              if (!v45)
              {
                v49 = v32 + 32 * v19;
                *(_QWORD *)v49 = 1;
                v50 = v26 + 32 * v19;
                v51 = *(_DWORD *)(v50 + 8);
                v52 = *(_DWORD *)(v28 + ((unint64_t)v19 << 6));
                v53 = v37 == v51;
                if (v37 == v51)
                  v54 = 0;
                else
                  v54 = *(_DWORD *)(v28 + ((unint64_t)v19 << 6));
                if (!v53)
                  v52 = 0;
                *(_DWORD *)(v49 + 20) = v43 - v54;
                *(_DWORD *)(v49 + 24) = v8;
                *(_DWORD *)(v49 + 12) = v35;
                *(_DWORD *)(v49 + 16) = v43 + v52;
                *(_DWORD *)(v32 + 32 * (int)v35 + 8) = v19;
                v34 = v37 != *(_DWORD *)(v50 + 12);
                v8 = (v8 + 1);
                goto LABEL_29;
              }
LABEL_52:
              v46 = (int)v35;
              v35 = *(unsigned int *)(v32 + 32 * (int)v35 + 12);
              if ((v35 & 0x80000000) == 0)
              {
                v47 = v26 + 32 * v46;
                if (v34)
                  v48 = 8;
                else
                  v48 = 12;
                v34 = *(_DWORD *)(v47 + v48) == *(_DWORD *)(v26 + 32 * v35 + 12);
                goto LABEL_30;
              }
              v10 = *((_DWORD *)this + 4);
              goto LABEL_64;
            }
          }
          v43 = *(_DWORD *)(v42 + 20);
          if (v41 == v37)
          {
LABEL_39:
            LODWORD(v19) = *(_DWORD *)(v26 + 32 * (int)v19 + 20);
            if ((v19 & 0x80000000) == 0)
              goto LABEL_42;
          }
          else
          {
            LODWORD(v19) = *(_DWORD *)(v26 + 32 * (int)v19 + 28);
            if ((v19 & 0x80000000) == 0)
              goto LABEL_42;
          }
          LODWORD(v19) = *(_DWORD *)(*((_QWORD *)this + 3) + 28 * v37 + 20);
          goto LABEL_42;
        }
      }
      v22 = 0;
      goto LABEL_19;
    }
LABEL_64:
    v9 = (v9 + 1);
  }
  while ((int)v9 < v10);
}

uint64_t Shape::ConvertToShape(void **a1, uint64_t a2, int a3, char a4)
{
  uint64_t result;
  uint64_t v9;
  float *v10;
  float *v11;
  float v12;
  float v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  float32x2_t v23;
  double v24;
  double v25;
  int8x16_t v26;
  double v27;
  float64x2_t v28;
  uint64_t v29;
  int v30;
  int v31;
  float v32;
  int *v33;
  _BOOL4 v34;
  uint64_t v35;
  uint64_t v36;
  float *v37;
  float v38;
  float v39;
  uint64_t v40;
  float v41;
  BOOL v42;
  uint64_t v43;
  int v44;
  float v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  float v49;
  float v50;
  float v51;
  float v52;
  uint64_t v53;
  signed int v54;
  uint64_t v55;
  int v56;
  Shape *v57;
  int *v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  Shape *v63;
  uint64_t v64;
  int *v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int *v71;
  int v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  signed int v78;
  int v79;
  uint64_t v80;
  __int128 *v81;
  _OWORD *v82;
  __int128 v83;
  uint64_t v84;
  __int128 *v85;
  _OWORD *v86;
  __int128 v87;
  __int128 v88;
  unsigned int v89;
  unsigned int v90;
  int v91;
  unsigned int v92;
  unsigned int v93;
  unsigned int v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  BOOL v99;
  BOOL v100;
  _BOOL4 v101;
  _BOOL4 v102;
  int v103;
  unsigned int *v104;
  unsigned int v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  uint64_t *v113;
  int v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  double v119;
  double v120;
  double v121;
  int32x4_t v122;
  int32x4_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  _DWORD *v127;
  unsigned int *v128;
  uint64_t v129;
  uint64_t v130;
  char v131;
  int v132;
  double v133;
  double v134;
  double v135;
  int32x4_t v136;
  int32x4_t v137;
  double v138;
  double v139;
  double v140;
  int32x4_t v141;
  int32x4_t v142;
  int v143;
  double v144;
  double v145;
  double v146;
  int32x4_t v147;
  int32x4_t v148;
  double v149;
  double v150;
  double v151;
  int32x4_t v152;
  int32x4_t v153;
  int v154;
  SweepTree *v155;
  double v156;
  double v157;
  double v158;
  int32x4_t v159;
  int32x4_t v160;
  uint64_t v161;
  uint64_t v162;
  double v163;
  double v164;
  double v165;
  int32x4_t v166;
  int32x4_t v167;
  unsigned int v168;
  int v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  int v173;
  int v174;
  uint64_t v178;
  double v179;
  double v180;
  double v181;
  int32x4_t v182;
  int32x4_t v183;
  uint64_t v184;
  uint64_t v185;
  int v186;
  int v187;
  double v188;
  double v189;
  double v190;
  int32x4_t v191;
  int32x4_t v192;
  _DWORD *v193;
  unsigned int *v194;
  int v195;
  Shape *v196;
  signed int v197;
  int *v198;
  uint64_t v199;
  int v200;
  uint64_t v201;
  uint64_t v202;
  Shape *v203;
  uint64_t v204;
  int *v205;
  uint64_t v206;
  int v207;
  uint64_t v208;
  uint64_t v209;
  int *v210;
  int v211;
  int v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  void *v217;
  void *v218;
  uint64_t v219;
  _DWORD *v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  int v224;
  uint64_t v225;
  int *v226;
  int v227;
  int v228;
  int v229;
  int *v230;
  int v231;
  uint64_t v232;
  int v233;
  int v234;
  uint64_t v235;
  int v236;
  uint64_t v237;
  int v238;
  int v239;
  uint64_t v240;
  int v241;
  int v242;
  uint64_t v243;
  int v244;
  uint64_t v245;
  int v246;
  uint64_t v247;
  int v248;
  uint64_t v249;
  int v250;
  int v251;
  uint64_t v252;
  char v253;
  int v254;
  uint64_t v255;
  _QWORD *v256;
  int v257;
  unsigned int v258;
  SweepTree *v259;
  Shape *v260;
  int v261;
  int *v262;
  int v263;
  int v264;
  int *v265;
  SweepTree *v266;
  SweepTree *v267;
  uint64_t v268;
  float v269;
  float v270;
  Shape *v271;
  int v272[3];

  Shape::Reset(a1, 0);
  result = 0;
  if (*(int *)(a2 + 16) < 2)
    return result;
  if (*(int *)(a2 + 32) < 2)
    return 0;
  if (!Shape::Eulerian((Shape *)a2, 1))
    return 5;
  v254 = a3;
  v253 = a4;
  Shape::ResetSweep((Shape *)a2);
  if (!Shape::GetFlag((Shape *)a1, 64))
  {
    SweepTree::CreateList((uint64_t)(a1 + 21), *(_DWORD *)(a2 + 32));
    SweepEvent::CreateQueue((uint64_t)(a1 + 24), *(_DWORD *)(a2 + 32));
    Shape::SetFlag((Shape *)a1, 64, 1);
  }
  Shape::MakePointData((Shape *)a1, 1);
  Shape::MakeEdgeData((Shape *)a1, 1);
  Shape::MakeSweepSrcData((Shape *)a1, 1);
  Shape::MakeSweepDestData((Shape *)a1, 1);
  v260 = (Shape *)a1;
  Shape::MakeBackData((Shape *)a1, (*(_DWORD *)(a2 + 52) >> 9) & 1);
  v9 = *(unsigned int *)(a2 + 16);
  if ((int)v9 >= 1)
  {
    v10 = (float *)(*(_QWORD *)(a2 + 88) + 40);
    v11 = (float *)(*(_QWORD *)(a2 + 24) + 4);
    do
    {
      *((_QWORD *)v10 - 4) = 0xFFFFFFFF00000000;
      *(v10 - 6) = NAN;
      v12 = ldexpf(*(v11 - 1), 5);
      *(v10 - 1) = ldexpf(roundf(v12), -5);
      v13 = *v11;
      v11 += 7;
      v14 = ldexpf(v13, 5);
      *v10 = ldexpf(roundf(v14), -5);
      v10 += 12;
      --v9;
    }
    while (v9);
  }
  v15 = *(unsigned int *)(a2 + 32);
  v16 = (uint64_t)v260;
  if ((int)v15 >= 1)
  {
    v17 = 0;
    v18 = *(_QWORD *)(a2 + 88);
    v19 = *(_QWORD *)(a2 + 64);
    v20 = 56 * v15;
    v21 = (int *)(*(_QWORD *)(a2 + 40) + 12);
    v22 = *(_QWORD *)(a2 + 56) + 32;
    do
    {
      v23 = vsub_f32(*(float32x2_t *)(v18 + 48 * *v21 + 36), *(float32x2_t *)(v18 + 48 * *(v21 - 1) + 36));
      *(float32x2_t *)(v22 - 28) = v23;
      v24 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v23, v23).i32[1]), v23.f32[0], v23.f32[0]);
      v25 = sqrt(v24);
      *(double *)(v22 - 16) = v24;
      *(double *)(v22 - 8) = v25;
      *(double *)v22 = 1.0 / v24;
      *(double *)(v22 + 8) = 1.0 / v25;
      v26 = (int8x16_t)vmulq_n_f64(vcvtq_f64_f32(v23), 1.0 / v25);
      v27 = *(double *)&v26.i64[1];
      v28 = (float64x2_t)vextq_s8(v26, v26, 8uLL);
      *(float64x2_t *)(v22 + 16) = v28;
      if (v27 < 0.0)
        *(float64x2_t *)(v22 + 16) = vnegq_f64(v28);
      v29 = v19 + v17;
      *(_QWORD *)v29 = 0;
      v21 += 8;
      *(_DWORD *)(v29 + 16) = -1;
      *(_QWORD *)(v29 + 8) = -1;
      *(_QWORD *)(v29 + 24) = -1;
      *(_QWORD *)(v29 + 32) = 0;
      *(_QWORD *)(v29 + 40) = -1;
      v17 += 56;
      v22 += 64;
      *(_DWORD *)(v29 + 48) = -1;
    }
    while (v20 != v17);
  }
  Shape::SortPointsRounded((Shape *)a2);
  v30 = 0;
  v31 = 0;
  *((_QWORD *)v260 + 17) = 0;
  v256 = (_QWORD *)((char *)v260 + 136);
  *((_QWORD *)v260 + 18) = 0;
  v32 = *(float *)(*(_QWORD *)(a2 + 88) + 40) + -1.0;
  v272[0] = -1;
  *((_QWORD *)v260 + 19) = 0;
  v33 = (int *)((char *)v260 + 192);
  v271 = 0;
  v262 = (int *)((char *)v260 + 168);
  *((_QWORD *)v260 + 20) = 0;
  v265 = (int *)((char *)v260 + 192);
  v255 = a2;
  while (v30 < *(_DWORD *)(a2 + 16) || *v33 >= 1)
  {
    v270 = 0.0;
    v269 = 0.0;
    v267 = 0;
    v268 = 0;
    v266 = 0;
    v34 = SweepEvent::PeekInQueue(&v267, &v266, &v270, &v269, (_DWORD *)&v268 + 1, &v268, (uint64_t)v33);
    v35 = *(_QWORD *)(a2 + 88);
    if (v34)
    {
      if (*(int *)(v35 + 48 * v30 + 8) > 0
        || (v36 = v35 + 48 * v30, v38 = *(float *)(v36 + 40), v37 = (float *)(v36 + 40), v39 = v38, v38 > v269)
        || ((v40 = v35 + 48 * v30, v41 = *(float *)(v40 + 36), v39 == v269) ? (v42 = v41 <= v270) : (v42 = 1), !v42))
      {
        SweepEvent::ExtractFromQueue(&v267, &v266, &v270, &v269, (_DWORD *)&v268 + 1, &v268, (uint64_t)v33);
        v48 = 0;
        v41 = v270;
        v47 = 1;
        v45 = v269;
        v263 = v30;
        v30 = -1;
LABEL_32:
        v49 = ldexpf(v41, 5);
        v50 = ldexpf(roundf(v49), -5);
        v51 = ldexpf(v45, 5);
        v52 = ldexpf(roundf(v51), -5);
        v53 = Shape::AddPoint((Shape *)v16, v50, v52);
        v54 = v53;
        v55 = *(_QWORD *)(v16 + 88) + 48 * (int)v53;
        *(float *)(v55 + 36) = v50;
        *(float *)(v55 + 40) = v52;
        if (v52 <= v32)
        {
          v79 = v53;
          if (v47)
            goto LABEL_124;
LABEL_53:
          v89 = *(_DWORD *)(*(_QWORD *)(v48 + 24) + 28 * v30 + 16);
          if ((v89 & 0x80000000) == 0)
          {
            v90 = 0;
            v91 = 0;
            v92 = -1;
            v93 = -1;
            v94 = *(_DWORD *)(*(_QWORD *)(v48 + 24) + 28 * v30 + 16);
            do
            {
              if ((signed int)v94 >= *(_DWORD *)(v48 + 32))
                break;
              v95 = *(_QWORD *)(v48 + 40);
              v96 = v95 + 32 * v94;
              v98 = *(_DWORD *)(v96 + 8);
              v97 = *(_DWORD *)(v96 + 12);
              v99 = v98 < v97 && v30 == v97;
              if (v99 || (v30 == v98 ? (v100 = v98 <= v97) : (v100 = 1), !v100))
              {
                ++v91;
                v93 = v94;
              }
              v101 = v30 == v98;
              v102 = v98 > v97;
              if (v98 >= v97)
                v101 = 0;
              if (v30 != v97)
                v102 = 0;
              v103 = v102 || v101;
              if (v103)
                v92 = v94;
              v90 += v103;
              if (v30 == v98)
              {
                v104 = (unsigned int *)(v95 + 32 * v94 + 16);
              }
              else
              {
                if (v30 != v97)
                  break;
                v104 = (unsigned int *)(v95 + 32 * v94 + 24);
              }
              v94 = *v104;
            }
            while ((v94 & 0x80000000) == 0);
            v105 = -1;
            v264 = v31;
            if (v90 && (v93 & 0x80000000) == 0)
            {
              if (*(_QWORD *)(*(_QWORD *)(v48 + 64) + 56 * v93))
                v105 = v93;
              else
                v105 = -1;
            }
            v261 = v79;
            if (v91 >= 1)
            {
              v258 = v105;
              do
              {
                if ((signed int)v89 >= *(_DWORD *)(v48 + 32))
                  break;
                v106 = v89;
                v107 = *(_QWORD *)(v48 + 40) + 32 * v89;
                v108 = *(_DWORD *)(v107 + 8);
                v109 = *(_DWORD *)(v107 + 12);
                if (v108 < v109 && v30 == v109)
                {
                  if (v89 != v105)
                    goto LABEL_98;
                }
                else if (v30 == v108 && v108 > v109 && v89 != v105)
                {
LABEL_98:
                  v113 = *(uint64_t **)(*(_QWORD *)(v48 + 64) + 56 * v89);
                  if (v113)
                  {
                    v114 = -1;
                    Shape::AddChgt(v260, v79, v264, &v271, v272, 1, (Shape *)v113[8], *((_DWORD *)v113 + 18), 0, -1);
                    *(_QWORD *)(*(_QWORD *)(v48 + 64) + 56 * v106) = 0;
                    v115 = *v113;
                    if (*v113)
                    {
                      v114 = *(_DWORD *)(v115 + 72);
                      v116 = *(_QWORD *)(v115 + 64);
                    }
                    else
                    {
                      v116 = 0;
                    }
                    v117 = v113[1];
                    if (v117)
                    {
                      v257 = *(_DWORD *)(v117 + 72);
                      v118 = *(_QWORD *)(v117 + 64);
                    }
                    else
                    {
                      v118 = 0;
                      v257 = -1;
                    }
                    SweepTree::Remove((AVLTree *)v113, (uint64_t)v262, v265, 1);
                    v79 = v261;
                    v105 = v258;
                    if (v116)
                    {
                      if (v118)
                      {
                        if (v116 != v48
                          || (v124 = *(_QWORD *)(v48 + 40) + 32 * v114, *(_DWORD *)(v124 + 12) != v30)
                          && *(_DWORD *)(v124 + 8) != v30)
                        {
                          if (v118 != v48
                            || (v125 = *(_QWORD *)(v48 + 40) + 32 * v257, *(_DWORD *)(v125 + 12) != v30)
                            && *(_DWORD *)(v125 + 8) != v30)
                          {
                            Shape::TesteIntersection((uint64_t)v260, *(SweepTree **)(*(_QWORD *)(v116 + 64) + 56 * v114), 0, 0, v119, v120, v121, v122, v123);
                            v105 = v258;
                            v79 = v261;
                          }
                        }
                      }
                    }
                  }
                }
                v126 = *(_QWORD *)(v48 + 40);
                v127 = (_DWORD *)(v126 + 32 * v106);
                if (v127[2] == v30)
                {
                  v128 = v127 + 4;
                }
                else
                {
                  if (v127[3] != v30)
                    break;
                  v128 = (unsigned int *)(v126 + 32 * v106 + 24);
                }
                v89 = *v128;
              }
              while ((v89 & 0x80000000) == 0);
            }
            v16 = (uint64_t)v260;
            if ((v92 & 0x80000000) != 0)
            {
              v259 = 0;
              v131 = 1;
              v31 = v264;
            }
            else if ((v105 & 0x80000000) != 0)
            {
              v154 = v79;
              v155 = (SweepTree *)SweepTree::AddInList(v48, v92, 1, v79, v262);
              *(_QWORD *)(*(_QWORD *)(v48 + 64) + 56 * v92) = v155;
              SweepTree::Insert(v155, (uint64_t)v262, v265, (uint64_t)v260, v154, 1, 1);
              v259 = v155;
              v161 = *(_QWORD *)v155;
              if (*(_QWORD *)v155)
              {
                v162 = *((_QWORD *)v260 + 11) + 48 * v154;
                *(_QWORD *)(v162 + 24) = *(_QWORD *)(v161 + 64);
                *(_DWORD *)(v162 + 32) = *(_DWORD *)(v161 + 72);
              }
              else
              {
                *(_DWORD *)(*((_QWORD *)v260 + 11) + 48 * v154 + 32) = -1;
              }
              v31 = v264;
              Shape::TesteIntersection((uint64_t)v260, v259, 0, 0, v156, v157, v158, v159, v160);
              Shape::TesteIntersection((uint64_t)v260, v259, 1, 0, v163, v164, v165, v166, v167);
              *(_DWORD *)(*(_QWORD *)(v48 + 64) + 56 * v92 + 44) = v154;
              Shape::AddChgt(v260, v154, v264, &v271, v272, 0, *((Shape **)v259 + 8), *((_DWORD *)v259 + 18), 0, -1);
              v131 = 0;
            }
            else
            {
              v129 = 56 * v105;
              v130 = *(_QWORD *)(*(_QWORD *)(v48 + 64) + v129);
              v131 = 1;
              v132 = v79;
              Shape::AddChgt(v260, v79, v264, &v271, v272, 1, *(Shape **)(v130 + 64), *(_DWORD *)(v130 + 72), 0, -1);
              *(_QWORD *)(*(_QWORD *)(v48 + 64) + v129) = 0;
              v31 = v264;
              SweepTree::RemoveEvents(v130, v265);
              SweepTree::ConvertTo(v130, (Shape *)v48, v92, 1, v132);
              *(_QWORD *)(*(_QWORD *)(v48 + 64) + 56 * v92) = v130;
              Shape::TesteIntersection((uint64_t)v260, (SweepTree *)v130, 0, 0, v133, v134, v135, v136, v137);
              Shape::TesteIntersection((uint64_t)v260, (SweepTree *)v130, 1, 0, v138, v139, v140, v141, v142);
              *(_DWORD *)(*(_QWORD *)(v48 + 64) + 56 * v92 + 44) = v132;
              v259 = (SweepTree *)v130;
              Shape::AddChgt(v260, v132, v264, &v271, v272, 0, *(Shape **)(v130 + 64), *(_DWORD *)(v130 + 72), 0, -1);
            }
            if (v90 < 2)
            {
LABEL_160:
              a2 = v255;
              v33 = (int *)((char *)v260 + 192);
            }
            else
            {
              v168 = *(_DWORD *)(*(_QWORD *)(v48 + 24) + 28 * v30 + 16);
              if ((v168 & 0x80000000) == 0)
              {
                v169 = v261;
                do
                {
                  if ((signed int)v168 >= *(_DWORD *)(v48 + 32))
                    break;
                  v170 = *(_QWORD *)(v48 + 40);
                  v171 = v168;
                  v172 = v170 + 32 * v168;
                  v173 = *(_DWORD *)(v172 + 8);
                  v174 = *(_DWORD *)(v172 + 12);
                  if (v173 > v174 && v30 == v174)
                  {
                    if (v168 != v92)
                      goto LABEL_148;
                  }
                  else if (v30 == v173 && v173 < v174 && v168 != v92)
                  {
LABEL_148:
                    v178 = SweepTree::AddInList(v48, v168, 1, v169, v262);
                    *(_QWORD *)(*(_QWORD *)(v48 + 64) + 56 * v171) = v178;
                    v31 = v264;
                    SweepTree::InsertAt((AVLTree *)v178, (uint64_t)v262, v265, (int)v260, (AVLTree **)v259, v30, 1, 1);
                    if ((v131 & 1) != 0)
                    {
                      v184 = *(_QWORD *)v178;
                      v185 = *((_QWORD *)v260 + 11);
                      if (*(_QWORD *)v178)
                      {
                        v186 = v261;
                        *(_QWORD *)(v185 + 48 * v261 + 24) = *(_QWORD *)(v184 + 64);
                        v187 = *(_DWORD *)(v184 + 72);
                      }
                      else
                      {
                        v187 = -1;
                        v186 = v261;
                      }
                      *(_DWORD *)(v185 + 48 * v186 + 32) = v187;
                      v169 = v261;
                    }
                    Shape::TesteIntersection((uint64_t)v260, (SweepTree *)v178, 0, 0, v179, v180, v181, v182, v183);
                    Shape::TesteIntersection((uint64_t)v260, (SweepTree *)v178, 1, 0, v188, v189, v190, v191, v192);
                    *(_DWORD *)(*(_QWORD *)(v48 + 64) + 56 * v171 + 44) = v169;
                    Shape::AddChgt(v260, v169, v264, &v271, v272, 0, *(Shape **)(v178 + 64), *(_DWORD *)(v178 + 72), 0, -1);
                    v131 = 0;
                    v170 = *(_QWORD *)(v48 + 40);
                    v173 = *(_DWORD *)(v170 + 32 * v171 + 8);
                  }
                  v193 = (_DWORD *)(v170 + 32 * v171);
                  if (v173 == v30)
                  {
                    v194 = v193 + 4;
                  }
                  else
                  {
                    if (v193[3] != v30)
                      goto LABEL_160;
                    v194 = v193 + 6;
                  }
                  v168 = *v194;
                }
                while ((*v194 & 0x80000000) == 0);
              }
              a2 = v255;
              v33 = (int *)((char *)v260 + 192);
            }
          }
        }
        else
        {
          v56 = Shape::AssemblePoints((Shape *)v16, v31, v53);
          if (v31 < v56)
          {
            v58 = (int *)(*(_QWORD *)(v16 + 88) + 48 * v31 + 32);
            v59 = v56 - (uint64_t)v31;
            v60 = v31;
            do
            {
              v61 = *((_QWORD *)v58 - 1);
              if (v61)
              {
                v62 = *(_QWORD *)(v61 + 64) + 56 * *v58;
                *(v58 - 4) = *(_DWORD *)(v62 + 8);
                *(_DWORD *)(v62 + 8) = v60;
              }
              ++v60;
              v58 += 12;
              --v59;
            }
            while (v59);
          }
          v63 = v271;
          if (v271)
          {
            v64 = *(_QWORD *)(v16 + 88);
            v65 = v272;
            do
            {
              v66 = *((_QWORD *)v63 + 8) + 56 * *v65;
              v67 = *(_DWORD *)(v66 + 28);
              *(_DWORD *)(v66 + 24) = *(_DWORD *)(v64 + 48 * *(int *)(v66 + 24) + 4);
              *(_DWORD *)(v66 + 28) = *(_DWORD *)(v64 + 48 * v67 + 4);
              v65 = (int *)(v66 + 40);
              v63 = *(Shape **)(v66 + 32);
            }
            while (v63);
          }
          v68 = a2;
          v69 = *(unsigned int *)v256;
          if ((int)v69 >= 1)
          {
            v70 = *(_QWORD *)(v16 + 88);
            v71 = (int *)(*(_QWORD *)(v16 + 144) + 8);
            while (1)
            {
              v72 = *(v71 - 2);
              v73 = *(_DWORD *)(v70 + 48 * *(v71 - 1) + 4);
              *(v71 - 1) = v73;
              if (v72 == 1)
                break;
              if (!v72)
              {
                v74 = v71[2];
                v75 = *(_QWORD *)(*(_QWORD *)v71 + 40) + 32 * v74;
                v76 = *(_QWORD *)(*(_QWORD *)v71 + 64);
                if (*(_DWORD *)(v75 + 8) >= *(_DWORD *)(v75 + 12))
                  goto LABEL_48;
LABEL_46:
                *(_DWORD *)(v76 + 56 * (int)v74 + 12) = v73;
              }
LABEL_49:
              v71 += 18;
              if (!--v69)
                goto LABEL_50;
            }
            v74 = v71[2];
            v77 = *(_QWORD *)(*(_QWORD *)v71 + 40) + 32 * v74;
            v76 = *(_QWORD *)(*(_QWORD *)v71 + 64);
            if (*(_DWORD *)(v77 + 8) <= *(_DWORD *)(v77 + 12))
            {
LABEL_48:
              *(_DWORD *)(v76 + 56 * (int)v74 + 16) = v73;
              goto LABEL_49;
            }
            goto LABEL_46;
          }
LABEL_50:
          v78 = v56;
          Shape::CheckAdjacencies(v16, v56, v31, v57);
          Shape::CheckEdges(v16, v78, v31, v68, 0, 0);
          v79 = v78;
          if (v78 < v54)
          {
            v80 = *(_QWORD *)(v16 + 24);
            v81 = (__int128 *)(v80 + 28 * v54);
            v82 = (_OWORD *)(v80 + 28 * v78);
            v83 = *v81;
            *(_OWORD *)((char *)v82 + 12) = *(__int128 *)((char *)v81 + 12);
            *v82 = v83;
            v84 = *(_QWORD *)(v16 + 88);
            v85 = (__int128 *)(v84 + 48 * v54);
            v86 = (_OWORD *)(v84 + 48 * v78);
            v87 = *v85;
            v88 = v85[2];
            v86[1] = v85[1];
            v86[2] = v88;
            *v86 = v87;
          }
          *(_DWORD *)(v16 + 16) = v78 + 1;
          *(_DWORD *)(v16 + 136) = 0;
          v272[0] = -1;
          v271 = 0;
          v31 = v78;
          v32 = v52;
          a2 = v68;
          v33 = (int *)((char *)v260 + 192);
          if (!v47)
            goto LABEL_53;
LABEL_124:
          v143 = v79;
          SweepTree::RemoveEvent((uint64_t)v267, v33, 1);
          SweepTree::RemoveEvent((uint64_t)v266, v33, 0);
          Shape::AddChgt((Shape *)v16, v143, v31, &v271, v272, 2, *((Shape **)v267 + 8), *((_DWORD *)v267 + 18), *((Shape **)v266 + 8), *((_DWORD *)v266 + 18));
          SweepTree::SwapWithRight((uint64_t)v267);
          Shape::TesteIntersection(v16, v267, 1, 0, v144, v145, v146, v147, v148);
          Shape::TesteIntersection(v16, v266, 0, 0, v149, v150, v151, v152, v153);
        }
        v44 = v263;
        goto LABEL_162;
      }
      v270 = *(float *)(v40 + 36);
    }
    else
    {
      v43 = v35 + 48 * v30;
      v41 = *(float *)(v43 + 36);
      v270 = v41;
      v37 = (float *)(v43 + 40);
    }
    v44 = v30 + 1;
    v45 = *v37;
    v269 = *v37;
    v46 = *(_QWORD *)(a2 + 24);
    if (*(_DWORD *)(v46 + 28 * v30 + 8) || *(_DWORD *)(v46 + 28 * v30 + 12))
    {
      v263 = v30 + 1;
      v47 = 0;
      v48 = a2;
      goto LABEL_32;
    }
LABEL_162:
    v30 = v44;
  }
  v195 = Shape::AssemblePoints((Shape *)v16, v31, *(unsigned int *)(v16 + 16));
  v197 = v195;
  if (v31 < v195)
  {
    v198 = (int *)(*(_QWORD *)(v16 + 88) + 48 * v31 + 32);
    v199 = v195 - (uint64_t)v31;
    v200 = v31;
    do
    {
      v201 = *((_QWORD *)v198 - 1);
      if (v201)
      {
        v202 = *(_QWORD *)(v201 + 64) + 56 * *v198;
        *(v198 - 4) = *(_DWORD *)(v202 + 8);
        *(_DWORD *)(v202 + 8) = v200;
      }
      ++v200;
      v198 += 12;
      --v199;
    }
    while (v199);
  }
  v203 = v271;
  if (v271)
  {
    v204 = *(_QWORD *)(v16 + 88);
    v205 = v272;
    do
    {
      v206 = *((_QWORD *)v203 + 8) + 56 * *v205;
      v207 = *(_DWORD *)(v206 + 28);
      *(_DWORD *)(v206 + 24) = *(_DWORD *)(v204 + 48 * *(int *)(v206 + 24) + 4);
      *(_DWORD *)(v206 + 28) = *(_DWORD *)(v204 + 48 * v207 + 4);
      v205 = (int *)(v206 + 40);
      v203 = *(Shape **)(v206 + 32);
    }
    while (v203);
  }
  v208 = *(unsigned int *)v256;
  if ((int)v208 >= 1)
  {
    v209 = *(_QWORD *)(v16 + 88);
    v210 = (int *)(*(_QWORD *)(v16 + 144) + 8);
    while (1)
    {
      v211 = *(v210 - 2);
      v212 = *(_DWORD *)(v209 + 48 * *(v210 - 1) + 4);
      *(v210 - 1) = v212;
      if (v211 == 1)
        break;
      if (!v211)
      {
        v213 = v210[2];
        v214 = *(_QWORD *)(*(_QWORD *)v210 + 40) + 32 * v213;
        v215 = *(_QWORD *)(*(_QWORD *)v210 + 64);
        if (*(_DWORD *)(v214 + 8) >= *(_DWORD *)(v214 + 12))
          goto LABEL_179;
LABEL_177:
        *(_DWORD *)(v215 + 56 * (int)v213 + 12) = v212;
      }
LABEL_180:
      v210 += 18;
      if (!--v208)
        goto LABEL_181;
    }
    v213 = v210[2];
    v216 = *(_QWORD *)(*(_QWORD *)v210 + 40) + 32 * v213;
    v215 = *(_QWORD *)(*(_QWORD *)v210 + 64);
    if (*(_DWORD *)(v216 + 8) <= *(_DWORD *)(v216 + 12))
    {
LABEL_179:
      *(_DWORD *)(v215 + 56 * (int)v213 + 16) = v212;
      goto LABEL_180;
    }
    goto LABEL_177;
  }
LABEL_181:
  Shape::CheckAdjacencies(v16, v195, v31, v196);
  Shape::CheckEdges(v16, v197, v31, a2, 0, 0);
  *(_DWORD *)(v16 + 16) = v197;
  v272[0] = -1;
  v271 = 0;
  v217 = *(void **)(v16 + 144);
  if (v217)
    free(v217);
  *v256 = 0;
  *((_QWORD *)v260 + 18) = 0;
  v218 = *(void **)(v16 + 160);
  if (v218)
    free(v218);
  *((_QWORD *)v260 + 19) = 0;
  *((_QWORD *)v260 + 20) = 0;
  Shape::AssembleAretes((Shape *)v16);
  v219 = *(unsigned int *)(v16 + 16);
  if ((int)v219 >= 1)
  {
    v220 = (_DWORD *)(*(_QWORD *)(v16 + 24) + 12);
    do
    {
      v220[3] = *v220 + *(v220 - 1);
      v220 += 7;
      --v219;
    }
    while (v219);
  }
  Shape::SetFlag((Shape *)v16, 2, 1);
  Shape::GetWindings((Shape *)v16, v221, v222, v223, 0);
  if (v254 == 2)
  {
    v233 = *(_DWORD *)(v16 + 32);
    if ((v253 & 1) != 0)
    {
      if (v233 < 1)
        goto LABEL_266;
      v234 = 0;
      while (1)
      {
        v235 = *(_QWORD *)(v16 + 72) + 32 * v234;
        v236 = *(_DWORD *)(v235 + 20);
        if ((*(_DWORD *)(v235 + 16) & 0x80000000) != 0)
        {
          v237 = *(_QWORD *)(v16 + 56);
          if ((v236 & 0x80000000) == 0)
            goto LABEL_222;
        }
        else
        {
          if (v236 < 0)
          {
            Shape::Inverse((Shape *)v16, v234);
            v237 = *(_QWORD *)(v16 + 56);
LABEL_222:
            *(_DWORD *)(v237 + ((uint64_t)v234 << 6)) = 1;
            goto LABEL_223;
          }
          v237 = *(_QWORD *)(v16 + 56);
        }
        *(_DWORD *)(v237 + ((uint64_t)v234 << 6)) = 0;
        Shape::SubEdge((Shape *)v16, v234--);
LABEL_223:
        if (++v234 >= *(_DWORD *)(v16 + 32))
          goto LABEL_266;
      }
    }
    if (v233 < 1)
      goto LABEL_266;
    v244 = 0;
    while (1)
    {
      v245 = *(_QWORD *)(v16 + 72) + 32 * v244;
      v246 = *(_DWORD *)(v245 + 20);
      if (*(int *)(v245 + 16) < 1)
      {
        if (v246 <= 0)
        {
          v247 = *(_QWORD *)(v16 + 56);
LABEL_249:
          *(_DWORD *)(v247 + ((uint64_t)v244 << 6)) = 0;
          Shape::SubEdge((Shape *)v16, v244--);
          goto LABEL_250;
        }
        Shape::Inverse((Shape *)v16, v244);
        v247 = *(_QWORD *)(v16 + 56);
      }
      else
      {
        v247 = *(_QWORD *)(v16 + 56);
        if (v246 > 0)
          goto LABEL_249;
      }
      *(_DWORD *)(v247 + ((uint64_t)v244 << 6)) = 1;
LABEL_250:
      if (++v244 >= *(_DWORD *)(v16 + 32))
        goto LABEL_266;
    }
  }
  if (v254 != 1)
  {
    if (!v254 && *(int *)(v16 + 32) >= 1)
    {
      v224 = 0;
      while (1)
      {
        v225 = *(_QWORD *)(v16 + 72) + 32 * v224;
        v227 = *(_DWORD *)(v225 + 16);
        v226 = (int *)(v225 + 16);
        v228 = v227 & 1;
        if (v227 >= 0)
          v229 = v228;
        else
          v229 = -v228;
        *v226 = v229;
        v230 = v226 + 1;
        if (v226[1] >= 0)
          v231 = v226[1] & 1;
        else
          v231 = -(v226[1] & 1);
        *v230 = v231;
        if (v229 < 0)
        {
          *v226 = -v229;
          v229 = 1;
          if ((v231 & 0x80000000) == 0)
          {
LABEL_201:
            if (v229)
              goto LABEL_202;
            goto LABEL_206;
          }
        }
        else if ((v231 & 0x80000000) == 0)
        {
          goto LABEL_201;
        }
        *v230 = -v231;
        v231 = 1;
        if (v229)
        {
LABEL_202:
          v232 = *(_QWORD *)(v16 + 56);
          if (v231)
            goto LABEL_210;
          goto LABEL_208;
        }
LABEL_206:
        if (!v231)
        {
          v232 = *(_QWORD *)(v16 + 56);
LABEL_210:
          *(_DWORD *)(v232 + ((uint64_t)v224 << 6)) = 0;
          Shape::SubEdge((Shape *)v16, v224--);
          goto LABEL_211;
        }
        Shape::Inverse((Shape *)v16, v224);
        v232 = *(_QWORD *)(v16 + 56);
LABEL_208:
        *(_DWORD *)(v232 + ((uint64_t)v224 << 6)) = 1;
LABEL_211:
        if (++v224 >= *(_DWORD *)(v16 + 32))
          goto LABEL_266;
      }
    }
    goto LABEL_266;
  }
  v238 = *(_DWORD *)(v16 + 32);
  if ((v253 & 1) == 0)
  {
    if (v238 < 1)
      goto LABEL_266;
    v248 = 0;
    while (1)
    {
      v249 = *(_QWORD *)(v16 + 72) + 32 * v248;
      v250 = *(_DWORD *)(v249 + 16);
      if (v250 >= 1)
        break;
      v251 = *(_DWORD *)(v249 + 20);
      if (v250 < 0)
        goto LABEL_256;
      if (v251 >= 1 || v251 < 0)
      {
        Shape::Inverse((Shape *)v16, v248);
        v252 = *(_QWORD *)(v16 + 56);
LABEL_261:
        *(_DWORD *)(v252 + ((uint64_t)v248 << 6)) = 1;
        goto LABEL_262;
      }
      v252 = *(_QWORD *)(v16 + 56);
LABEL_257:
      *(_DWORD *)(v252 + ((uint64_t)v248 << 6)) = 0;
      Shape::SubEdge((Shape *)v16, v248--);
LABEL_262:
      if (++v248 >= *(_DWORD *)(v16 + 32))
        goto LABEL_266;
    }
    v251 = *(_DWORD *)(v249 + 20);
LABEL_256:
    v252 = *(_QWORD *)(v16 + 56);
    if (!v251)
      goto LABEL_261;
    goto LABEL_257;
  }
  if (v238 >= 1)
  {
    v239 = 0;
    while (1)
    {
      v240 = *(_QWORD *)(v16 + 72) + 32 * v239;
      v241 = *(_DWORD *)(v240 + 16);
      if (v241 < 0)
        break;
      v242 = *(_DWORD *)(v240 + 20);
      if (v241)
        goto LABEL_234;
      if (v242 < 0 || v242)
      {
        Shape::Inverse((Shape *)v16, v239);
        v243 = *(_QWORD *)(v16 + 56);
LABEL_236:
        *(_DWORD *)(v243 + ((uint64_t)v239 << 6)) = 1;
        goto LABEL_237;
      }
      v243 = *(_QWORD *)(v16 + 56);
LABEL_235:
      *(_DWORD *)(v243 + ((uint64_t)v239 << 6)) = 0;
      Shape::SubEdge((Shape *)v16, v239--);
LABEL_237:
      if (++v239 >= *(_DWORD *)(v16 + 32))
        goto LABEL_266;
    }
    v242 = *(_DWORD *)(v240 + 20);
LABEL_234:
    v243 = *(_QWORD *)(v16 + 56);
    if (!v242)
      goto LABEL_236;
    goto LABEL_235;
  }
LABEL_266:
  if (Shape::GetFlag((Shape *)v16, 64))
  {
    SweepTree::DestroyList(v262);
    SweepEvent::DestroyQueue(v265);
    Shape::SetFlag((Shape *)v16, 64, 0);
  }
  Shape::MakePointData((Shape *)v16, 0);
  Shape::MakeEdgeData((Shape *)v16, 0);
  Shape::MakeSweepSrcData((Shape *)v16, 0);
  Shape::MakeSweepDestData((Shape *)v16, 0);
  Shape::CleanupSweep((Shape *)a2);
  if (Shape::Eulerian((Shape *)v16, 1))
  {
    result = 0;
    *(_DWORD *)(v16 + 48) = 1;
  }
  else
  {
    *(_DWORD *)(v16 + 32) = 0;
    *(_DWORD *)(v16 + 16) = 0;
    return 4;
  }
  return result;
}

uint64_t Shape::AssemblePoints(Shape *this, int a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  float *v18;
  int v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;

  if ((int)a3 > a2)
  {
    v4 = 0;
    v5 = a2;
    v6 = a2;
    v7 = (int)a3;
    v8 = (_DWORD *)(*((_QWORD *)this + 11) + 48 * a2);
    do
    {
      *v8 = a2 + v4;
      v8 += 12;
      ++v4;
    }
    while ((int)a3 - (uint64_t)a2 != v4);
    Shape::SortPointsByOldInd(this, a2, a3 - 1);
    v9 = 0;
    v10 = *((_QWORD *)this + 11);
    v11 = (int *)(v10 + 48 * (int)v6);
    v12 = v7 - v6;
    do
    {
      v13 = *v11;
      v11 += 12;
      *(_DWORD *)(v10 + 48 * v13 + 4) = v5 + v9++;
    }
    while (v12 != v9);
    v14 = *((_QWORD *)this + 11);
    v15 = (_DWORD *)(v14 + 48 * (int)v6 + 32);
    v16 = 28 * v6;
    v17 = v6;
    a3 = v5;
    while (1)
    {
      *(v15 - 6) = a3;
      if (v17 <= v6)
        break;
      v18 = (float *)(*((_QWORD *)this + 3) + v16);
      if (*(v18 - 7) != *v18 || *(v18 - 6) != v18[1])
        break;
      v19 = *(v15 - 18);
      *(v15 - 6) = v19;
      v20 = v14 + 48 * v19;
      v22 = *(_QWORD *)(v20 + 24);
      v21 = (_QWORD *)(v20 + 24);
      if (!v22)
      {
        *v21 = *((_QWORD *)v15 - 1);
LABEL_14:
        *(_DWORD *)(v14 + 48 * v19 + 32) = *v15;
      }
LABEL_16:
      ++v17;
      v15 += 12;
      v16 += 28;
      if (v7 == v17)
      {
        v25 = *((_QWORD *)this + 11);
        v26 = (int *)(v25 + 48 * (int)v6 + 4);
        do
        {
          *v26 = *(_DWORD *)(v25 + 48 * *v26 + 8);
          v26 += 12;
          --v12;
        }
        while (v12);
        return a3;
      }
    }
    if (v17 <= (int)a3)
    {
      a3 = (a3 + 1);
      goto LABEL_16;
    }
    v19 = a3;
    v23 = *((_QWORD *)this + 3);
    *(_QWORD *)(v23 + 28 * (int)a3) = *(_QWORD *)(v23 + v16);
    v24 = v14 + 48 * (int)a3;
    *(_QWORD *)(v24 + 36) = *(_QWORD *)(v23 + v16);
    *(_QWORD *)(v24 + 24) = *((_QWORD *)v15 - 1);
    a3 = (a3 + 1);
    goto LABEL_14;
  }
  return a3;
}

uint64_t Shape::CheckAdjacencies(uint64_t this, int a2, int a3, Shape *a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  Shape *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  Shape *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  Shape *v33;
  int v34;
  char v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int *v41;
  uint64_t v42;
  uint64_t v43;
  int *v44;
  uint64_t v45;
  uint64_t v46;
  int v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int *v55;
  uint64_t v56;
  uint64_t v57;
  int *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  Shape *v63;
  int v64;
  uint64_t v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  int *v72;
  uint64_t v73;
  uint64_t v74;
  int *v75;
  uint64_t v76;
  uint64_t v77;
  float *v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  _DWORD *v85;
  uint64_t v86;
  uint64_t v87;
  _DWORD *v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  uint64_t v94;
  int v96;
  int v97;
  int v98;
  int v99;

  if (*(int *)(this + 136) >= 1)
  {
    v4 = a2;
    v5 = this;
    v6 = 0;
    v93 = 2 - a2;
    while (1)
    {
      v7 = *(_QWORD *)(v5 + 144);
      v8 = v7 + 72 * v6;
      v9 = *(_DWORD *)(v8 + 4);
      v10 = *(Shape **)(v8 + 8);
      if (v10)
      {
        v11 = *(_DWORD *)(v7 + 72 * v6 + 16);
        v12 = *((_QWORD *)v10 + 8) + 56 * v11;
        v14 = *(int *)(v12 + 24);
        v13 = *(int *)(v12 + 28);
        if ((int)v14 >= v9)
          v15 = *(_DWORD *)(v8 + 4);
        else
          v15 = *(_DWORD *)(v12 + 24);
        if ((int)v13 > v9)
          v9 = v13;
        v96 = v9;
        v99 = v15;
        if ((int)v14 > a3)
        {
          v16 = v14 - 1;
          v17 = 28 * v14;
          do
          {
            this = Shape::TesteAdjacency((Shape *)v5, v10, v11, *(float *)(*(_QWORD *)(v5 + 24) + v17 - 28), *(float *)(*(_QWORD *)(v5 + 24) + v17 - 24), v16, 0);
            if (!(_DWORD)this)
              break;
            --v14;
            *(_DWORD *)(*((_QWORD *)v10 + 8) + 56 * v11 + 24) = v16--;
            v17 -= 28;
          }
          while (v14 > a3);
        }
        v18 = v13 + 1;
        if ((int)v13 + 1 < v4)
        {
          v19 = 28 * v18;
          do
          {
            this = Shape::TesteAdjacency((Shape *)v5, v10, v11, *(float *)(*(_QWORD *)(v5 + 24) + v19), *(float *)(*(_QWORD *)(v5 + 24) + v19 + 4), v18, 0);
            if (!(_DWORD)this)
              break;
            *(_DWORD *)(*((_QWORD *)v10 + 8) + 56 * v11 + 28) = v18;
            v19 += 28;
            LODWORD(v18) = v18 + 1;
          }
          while (v4 != (_DWORD)v18);
        }
        v9 = v96;
      }
      else
      {
        v99 = *(_DWORD *)(v8 + 4);
      }
      v20 = *(_QWORD *)(v5 + 144);
      v21 = *(Shape **)(v20 + 72 * v6 + 24);
      if (v21)
      {
        v22 = *(_DWORD *)(v20 + 72 * v6 + 32);
        v23 = *((_QWORD *)v21 + 8) + 56 * v22;
        v25 = *(int *)(v23 + 24);
        v24 = *(int *)(v23 + 28);
        if ((int)v25 >= v99)
          v26 = v99;
        else
          v26 = *(_DWORD *)(v23 + 24);
        if ((int)v24 > v9)
          v9 = v24;
        v97 = v9;
        v99 = v26;
        if ((int)v25 > a3)
        {
          v27 = v25 - 1;
          v28 = 28 * v25;
          do
          {
            this = Shape::TesteAdjacency((Shape *)v5, v21, v22, *(float *)(*(_QWORD *)(v5 + 24) + v28 - 28), *(float *)(*(_QWORD *)(v5 + 24) + v28 - 24), v27, 0);
            if (!(_DWORD)this)
              break;
            --v25;
            *(_DWORD *)(*((_QWORD *)v21 + 8) + 56 * v22 + 24) = v27--;
            v28 -= 28;
          }
          while (v25 > a3);
        }
        v29 = v24 + 1;
        if ((int)v24 + 1 < v4)
        {
          v30 = 28 * v29;
          do
          {
            this = Shape::TesteAdjacency((Shape *)v5, v21, v22, *(float *)(*(_QWORD *)(v5 + 24) + v30), *(float *)(*(_QWORD *)(v5 + 24) + v30 + 4), v29, 0);
            if (!(_DWORD)this)
              break;
            *(_DWORD *)(*((_QWORD *)v21 + 8) + 56 * v22 + 28) = v29;
            v30 += 28;
            LODWORD(v29) = v29 + 1;
          }
          while (v4 != (_DWORD)v29);
        }
        v9 = v97;
      }
      v31 = v99;
      v98 = v9;
      v32 = *(_QWORD *)(v5 + 144);
      v33 = *(Shape **)(v32 + 72 * v6 + 40);
      v94 = v6;
      if (v33)
      {
        v34 = *(_DWORD *)(v32 + 72 * v6 + 48);
        if (*(_DWORD *)(*((_QWORD *)v33 + 8) + 56 * v34 + 24) < a3)
        {
          while (v98 < v31)
          {
            v35 = 0;
LABEL_49:
            v31 = v99;
            if (v99 > a3)
            {
              this = Shape::TesteAdjacency((Shape *)v5, v33, v34, *(float *)(*(_QWORD *)(v5 + 24) + 28 * (v99 - 1)), *(float *)(*(_QWORD *)(v5 + 24) + 28 * (v99 - 1) + 4), v99 - 1, 0);
              if ((_DWORD)this)
              {
                v48 = v34;
                v49 = 28 * v99;
                v50 = v99;
                v51 = v99 - 1;
                while (1)
                {
                  v52 = v50 - 1;
                  v53 = *((_QWORD *)v33 + 8);
                  v54 = v53 + 56 * v34;
                  v57 = *(int *)(v54 + 24);
                  v55 = (int *)(v54 + 24);
                  v56 = v57;
                  if ((int)v57 >= a3)
                  {
                    if (v50 <= v56)
                      *v55 = v51;
                    v59 = v53 + 56 * v34;
                    v60 = *(int *)(v59 + 28);
                    v58 = (int *)(v59 + 28);
                    if (v52 <= v60)
                      goto LABEL_58;
                  }
                  else
                  {
                    *v55 = v51;
                    v58 = (int *)(v53 + 56 * v34 + 28);
                  }
                  *v58 = v51;
LABEL_58:
                  if (v52 <= a3)
                    goto LABEL_63;
                  this = Shape::TesteAdjacency((Shape *)v5, v33, v34, *(float *)(*(_QWORD *)(v5 + 24) + v49 - 56), *(float *)(*(_QWORD *)(v5 + 24) + v49 - 52), --v51, 0);
                  v49 -= 28;
                  v50 = v52;
                  if (!(_DWORD)this)
                    goto LABEL_62;
                }
              }
            }
            if ((v35 & 1) == 0)
              goto LABEL_66;
LABEL_62:
            v53 = *((_QWORD *)v33 + 8);
            v48 = v34;
LABEL_63:
            v61 = *(uint64_t **)(v53 + 56 * v48);
            if (v61)
            {
              v62 = *v61;
              if (v62)
              {
                v33 = *(Shape **)(v62 + 64);
                v34 = *(_DWORD *)(v62 + 72);
                if (*(_DWORD *)(*((_QWORD *)v33 + 8) + 56 * v34 + 24) < a3)
                  continue;
              }
            }
LABEL_66:
            v32 = *(_QWORD *)(v5 + 144);
            v4 = a2;
            goto LABEL_67;
          }
          v35 = 0;
          v36 = 28 * v98;
          v37 = v98;
          v38 = v98;
          while (1)
          {
            this = Shape::TesteAdjacency((Shape *)v5, v33, v34, *(float *)(*(_QWORD *)(v5 + 24) + v36), *(float *)(*(_QWORD *)(v5 + 24) + v36 + 4), v37, 0);
            if ((_DWORD)this)
              break;
LABEL_47:
            --v37;
            v36 -= 28;
            if (v38-- <= v99)
              goto LABEL_49;
          }
          v39 = *((_QWORD *)v33 + 8);
          v40 = v39 + 56 * v34;
          v43 = *(int *)(v40 + 24);
          v41 = (int *)(v40 + 24);
          v42 = v43;
          if ((int)v43 >= a3)
          {
            if (v38 < v42)
              *v41 = v37;
            v45 = v39 + 56 * v34;
            v46 = *(int *)(v45 + 28);
            v44 = (int *)(v45 + 28);
            if (v38 <= v46)
              goto LABEL_46;
          }
          else
          {
            *v41 = v37;
            v44 = (int *)(v39 + 56 * v34 + 28);
          }
          *v44 = v37;
LABEL_46:
          v35 = 1;
          goto LABEL_47;
        }
      }
LABEL_67:
      v63 = *(Shape **)(v32 + 72 * v6 + 56);
      if (v63)
      {
        v64 = *(_DWORD *)(v32 + 72 * v6 + 64);
        if (*(_DWORD *)(*((_QWORD *)v63 + 8) + 56 * v64 + 24) < a3)
          break;
      }
LABEL_99:
      v6 = v94 + 1;
      if (v94 + 1 >= *(int *)(v5 + 136))
        return this;
    }
    v65 = v98 + 1;
    while (v99 > v98)
    {
      v66 = 0;
LABEL_82:
      v4 = a2;
      if ((int)v65 < a2)
      {
        v78 = (float *)(*(_QWORD *)(v5 + 24) + 28 * (int)v65);
        this = Shape::TesteAdjacency((Shape *)v5, v63, v64, *v78, v78[1], v65, 0);
        if ((_DWORD)this)
        {
          v79 = 0;
          v80 = v64;
          v81 = 28 * v65;
          while (1)
          {
            v82 = v98 + v79 + 1;
            v83 = *((_QWORD *)v63 + 8);
            v84 = v83 + 56 * v64;
            v87 = *(int *)(v84 + 24);
            v85 = (_DWORD *)(v84 + 24);
            v86 = v87;
            if ((int)v87 >= a3)
            {
              if (v65 + v79 < v86)
                *v85 = v82;
              v89 = v83 + 56 * v64;
              v90 = *(_DWORD *)(v89 + 28);
              v88 = (_DWORD *)(v89 + 28);
              if (v98 + (int)v79 < v90)
                goto LABEL_91;
            }
            else
            {
              *v85 = v82;
              v88 = (_DWORD *)(v83 + 56 * v64 + 28);
            }
            *v88 = v82;
LABEL_91:
            if (!(v93 + v98 + (_DWORD)v79))
              goto LABEL_96;
            this = Shape::TesteAdjacency((Shape *)v5, v63, v64, *(float *)(*(_QWORD *)(v5 + 24) + v81 + 28), *(float *)(*(_QWORD *)(v5 + 24) + v81 + 32), v98 + v79++ + 2, 0);
            v81 += 28;
            if (!(_DWORD)this)
              goto LABEL_95;
          }
        }
      }
      if ((v66 & 1) == 0)
        goto LABEL_99;
LABEL_95:
      v83 = *((_QWORD *)v63 + 8);
      v80 = v64;
LABEL_96:
      v91 = *(_QWORD *)(v83 + 56 * v80);
      if (v91)
      {
        v92 = *(_QWORD *)(v91 + 8);
        if (v92)
        {
          v63 = *(Shape **)(v92 + 64);
          v64 = *(_DWORD *)(v92 + 72);
          if (*(_DWORD *)(*((_QWORD *)v63 + 8) + 56 * v64 + 24) < a3)
            continue;
        }
      }
      goto LABEL_99;
    }
    v66 = 0;
    v68 = 28 * v99;
    v67 = v99;
    v69 = v99;
    while (1)
    {
      this = Shape::TesteAdjacency((Shape *)v5, v63, v64, *(float *)(*(_QWORD *)(v5 + 24) + v68), *(float *)(*(_QWORD *)(v5 + 24) + v68 + 4), v69, 0);
      if ((_DWORD)this)
        break;
LABEL_81:
      ++v67;
      ++v69;
      v68 += 28;
      if ((_DWORD)v65 == v69)
        goto LABEL_82;
    }
    v70 = *((_QWORD *)v63 + 8);
    v71 = v70 + 56 * v64;
    v74 = *(int *)(v71 + 24);
    v72 = (int *)(v71 + 24);
    v73 = v74;
    if ((int)v74 >= a3)
    {
      if (v67 < v73)
        *v72 = v69;
      v76 = v70 + 56 * v64;
      v77 = *(int *)(v76 + 28);
      v75 = (int *)(v76 + 28);
      if (v67 <= v77)
        goto LABEL_80;
    }
    else
    {
      *v72 = v69;
      v75 = (int *)(v70 + 56 * v64 + 28);
    }
    *v75 = v69;
LABEL_80:
    v66 = 1;
    goto LABEL_81;
  }
  return this;
}

void Shape::CheckEdges(uint64_t a1, signed int a2, int a3, uint64_t a4, Shape *a5, uint64_t a6)
{
  uint64_t v6;
  int v7;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  Shape *v15;
  Shape *v16;
  Shape *v17;
  int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  Shape *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v6 = *(unsigned int *)(a1 + 136);
  if ((int)v6 >= 1)
  {
    v7 = a6;
    v12 = (int *)(*(_QWORD *)(a1 + 144) + 8);
    do
    {
      if (!*(v12 - 2))
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v12 + 64) + 56 * v12[2] + 44) = *(v12 - 1);
      v12 += 18;
      --v6;
    }
    while (v6);
    v13 = 0;
    do
    {
      v14 = *(_QWORD *)(a1 + 144);
      v15 = *(Shape **)(v14 + 72 * v13 + 8);
      if (v15)
      {
        Shape::Avance(a1, a2, a3, v15, *(_DWORD *)(v14 + 72 * v13 + 16), a6, a5, v7);
        v14 = *(_QWORD *)(a1 + 144);
      }
      v16 = *(Shape **)(v14 + 72 * v13 + 24);
      if (v16)
      {
        Shape::Avance(a1, a2, a3, v16, *(_DWORD *)(v14 + 72 * v13 + 32), a6, a5, v7);
        v14 = *(_QWORD *)(a1 + 144);
      }
      v17 = *(Shape **)(v14 + 72 * v13 + 40);
      if (v17)
      {
        v18 = *(_DWORD *)(v14 + 72 * v13 + 48);
        if (*(_DWORD *)(*((_QWORD *)v17 + 8) + 56 * v18 + 24) >= a3)
        {
          v19 = v18;
          do
          {
            Shape::Avance(a1, a2, a3, v17, v18, a6, a5, v7);
            v20 = *(uint64_t **)(*((_QWORD *)v17 + 8) + 56 * v19);
            if (!v20)
              break;
            v21 = *v20;
            if (!v21)
              break;
            v17 = *(Shape **)(v21 + 64);
            v18 = *(_DWORD *)(v21 + 72);
            v19 = v18;
          }
          while (*(_DWORD *)(*((_QWORD *)v17 + 8) + 56 * v18 + 24) >= a3);
          v14 = *(_QWORD *)(a1 + 144);
        }
      }
      v22 = *(Shape **)(v14 + 72 * v13 + 56);
      if (v22)
      {
        v23 = *(_DWORD *)(v14 + 72 * v13 + 64);
        if (*(_DWORD *)(*((_QWORD *)v22 + 8) + 56 * v23 + 28) >= a3)
        {
          v24 = v23;
          do
          {
            Shape::Avance(a1, a2, a3, v22, v23, a6, a5, v7);
            v25 = *(_QWORD *)(*((_QWORD *)v22 + 8) + 56 * v24);
            if (!v25)
              break;
            v26 = *(_QWORD *)(v25 + 8);
            if (!v26)
              break;
            v22 = *(Shape **)(v26 + 64);
            v23 = *(_DWORD *)(v26 + 72);
            v24 = v23;
          }
          while (*(_DWORD *)(*((_QWORD *)v22 + 8) + 56 * v23 + 28) >= a3);
        }
      }
      ++v13;
    }
    while (v13 < *(int *)(a1 + 136));
  }
}

_QWORD *Shape::AddChgt(Shape *this, int a2, int a3, Shape **a4, int *a5, int a6, Shape *a7, int a8, Shape *a9, int a10)
{
  int v18;
  _QWORD *result;
  uint64_t v20;
  int v21;
  char *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  _DWORD *v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  _DWORD *v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  _DWORD *v51;
  int v52;
  int v53;

  v18 = *((_DWORD *)this + 34);
  if (v18 >= *((_DWORD *)this + 35))
  {
    v20 = (2 * v18) | 1;
    *((_DWORD *)this + 35) = v20;
    result = malloc_type_realloc(*((void **)this + 18), 72 * v20, 0x10200400F996F24uLL);
    *((_QWORD *)this + 18) = result;
    v18 = *((_DWORD *)this + 34);
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)this + 18);
  }
  *((_DWORD *)this + 34) = v18 + 1;
  v21 = v18;
  v22 = (char *)&result[9 * v18];
  *(_DWORD *)v22 = a6;
  *((_DWORD *)v22 + 1) = a2;
  *((_QWORD *)v22 + 1) = a7;
  *((_DWORD *)v22 + 4) = a8;
  *((_QWORD *)v22 + 3) = a9;
  *((_DWORD *)v22 + 8) = a10;
  if (a7)
  {
    v23 = *((_QWORD *)a7 + 8);
    v24 = *(uint64_t **)(v23 + 56 * a8);
    if (v24 && (v25 = *v24) != 0)
    {
      result[9 * v21 + 5] = *(_QWORD *)(v25 + 64);
      v26 = *(_DWORD *)(v25 + 72);
    }
    else
    {
      result[9 * v21 + 5] = 0;
      v26 = -1;
    }
    LODWORD(result[9 * v21 + 6]) = v26;
    v27 = v23 + 56 * a8;
    v30 = *(_DWORD *)(v27 + 24);
    v28 = (_DWORD *)(v27 + 24);
    v29 = v30;
    if (v30 >= a3)
    {
      if (*(float *)(*((_QWORD *)this + 3) + 28 * v29) > *(float *)(*((_QWORD *)this + 3) + 28 * a2))
        *v28 = a2;
    }
    else
    {
      *v28 = a2;
      v31 = v23 + 56 * a8;
      *(_QWORD *)(v31 + 32) = *a4;
      *(_DWORD *)(v31 + 40) = *a5;
      *a5 = a8;
      *a4 = a7;
      v23 = *((_QWORD *)a7 + 8);
    }
    v32 = v23 + 56 * a8;
    v35 = *(_DWORD *)(v32 + 28);
    v33 = (_DWORD *)(v32 + 28);
    v34 = v35;
    if (v35 < a3 || *(float *)(*((_QWORD *)this + 3) + 28 * v34) < *(float *)(*((_QWORD *)this + 3) + 28 * a2))
      *v33 = a2;
  }
  if (!a9)
  {
    v40 = *(_QWORD *)(*((_QWORD *)a7 + 8) + 56 * a8);
    if (v40)
    {
      v41 = *(_QWORD *)(v40 + 8);
      v42 = *((_QWORD *)this + 18);
      if (v41)
      {
        v43 = v42 + 72 * v21;
        *(_QWORD *)(v43 + 56) = *(_QWORD *)(v41 + 64);
        v44 = *(_DWORD *)(v41 + 72);
LABEL_32:
        *(_DWORD *)(v43 + 64) = v44;
        return result;
      }
    }
    else
    {
      v42 = *((_QWORD *)this + 18);
    }
    v43 = v42 + 72 * v21;
    *(_QWORD *)(v43 + 56) = 0;
    v44 = -1;
    goto LABEL_32;
  }
  v36 = *((_QWORD *)a9 + 8);
  v37 = *(_QWORD *)(*(_QWORD *)(v36 + 56 * a10) + 8);
  v38 = *((_QWORD *)this + 18);
  if (v37)
  {
    *(_QWORD *)(v38 + 72 * v21 + 56) = *(_QWORD *)(v37 + 64);
    v39 = *(_DWORD *)(v37 + 72);
  }
  else
  {
    *(_QWORD *)(v38 + 72 * v21 + 56) = 0;
    v39 = -1;
  }
  *(_DWORD *)(v38 + 72 * v21 + 64) = v39;
  v45 = v36 + 56 * a10;
  v48 = *(_DWORD *)(v45 + 24);
  v46 = (_DWORD *)(v45 + 24);
  v47 = v48;
  if (v48 >= a3)
  {
    if (*(float *)(*((_QWORD *)this + 3) + 28 * v47) > *(float *)(*((_QWORD *)this + 3) + 28 * a2))
      *v46 = a2;
  }
  else
  {
    *v46 = a2;
    v49 = v36 + 56 * a10;
    *(_QWORD *)(v49 + 32) = *a4;
    *(_DWORD *)(v49 + 40) = *a5;
    *a5 = a10;
    *a4 = a9;
    v36 = *((_QWORD *)a9 + 8);
  }
  v50 = v36 + 56 * a10;
  v53 = *(_DWORD *)(v50 + 28);
  v51 = (_DWORD *)(v50 + 28);
  v52 = v53;
  if (v53 < a3 || *(float *)(*((_QWORD *)this + 3) + 28 * v52) < *(float *)(*((_QWORD *)this + 3) + 28 * a2))
    *v51 = a2;
  return result;
}

uint64_t Shape::TesteIntersection(uint64_t this, SweepTree *a2, int a3, char a4, double a5, double a6, double a7, int32x4_t a8, int32x4_t a9)
{
  uint64_t v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  uint64_t v16;
  SweepTree *v17;
  SweepTree *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v10 = this;
  if (a3)
  {
    v11 = *(_QWORD *)a2;
    if (*(_QWORD *)a2)
    {
      v20 = 0;
      v21 = 0;
      this = Shape::TesteIntersection(a5, a6, a7, a8, a9, this, v11, (uint64_t)a2, (float *)&v21 + 1, (float *)&v21, (float *)&v20 + 1, (float *)&v20, a4);
      if ((_DWORD)this)
      {
        v12 = *((float *)&v21 + 1);
        v13 = *(float *)&v21;
        v14 = *((float *)&v20 + 1);
        v15 = *(float *)&v20;
        v16 = v10 + 192;
        v17 = (SweepTree *)v11;
        v18 = a2;
        return SweepEvent::AddInQueue((uint64_t)v17, (uint64_t)v18, v16, v12, v13, v14, v15);
      }
    }
  }
  else
  {
    v19 = *((_QWORD *)a2 + 1);
    if (v19)
    {
      v20 = 0;
      v21 = 0;
      this = Shape::TesteIntersection(a5, a6, a7, a8, a9, this, (uint64_t)a2, v19, (float *)&v21 + 1, (float *)&v21, (float *)&v20 + 1, (float *)&v20, a4);
      if ((_DWORD)this)
      {
        v12 = *((float *)&v21 + 1);
        v13 = *(float *)&v21;
        v14 = *((float *)&v20 + 1);
        v15 = *(float *)&v20;
        v16 = v10 + 192;
        v17 = a2;
        v18 = (SweepTree *)v19;
        return SweepEvent::AddInQueue((uint64_t)v17, (uint64_t)v18, v16, v12, v13, v14, v15);
      }
    }
  }
  return this;
}

void Shape::AssembleAretes(Shape *this)
{
  uint64_t i;
  uint64_t v3;
  _DWORD *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _DWORD *v42;
  unsigned int *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _DWORD *v53;
  uint64_t v54;
  unsigned int v55;
  uint64_t v56;
  unsigned int v57;
  int v58;
  unsigned int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  uint64_t j;

  if (*((int *)this + 4) >= 1)
  {
    for (i = 0; i < *((int *)this + 4); ++i)
    {
      v3 = *((_QWORD *)this + 3);
      v4 = (_DWORD *)(v3 + 28 * i);
      v5 = v4[4];
      if (v4[3] + v4[2] == 2)
      {
        v6 = *(_DWORD *)(v3 + 28 * i + 20);
        v7 = *((_QWORD *)this + 5);
        v8 = v7 + 32 * (int)v5;
        v9 = *(_DWORD *)(v8 + 8);
        v10 = v7 + 32 * v6;
        v11 = *(_DWORD *)(v10 + 8);
        if (v9 == v11)
        {
          v12 = *(_DWORD *)(v8 + 12);
          v13 = *(_DWORD *)(v10 + 12);
          if (v12 == v13)
            goto LABEL_58;
        }
        else
        {
          v13 = *(_DWORD *)(v10 + 12);
        }
        if (v9 == v13 && *(_DWORD *)(v7 + 32 * (int)v5 + 12) == v9)
        {
          if (v9 == v11)
          {
LABEL_58:
            v44 = *((_QWORD *)this + 7);
            v45 = (uint64_t)(int)v5 << 6;
            v46 = *(_DWORD *)(v44 + v45) + *(_DWORD *)(v44 + ((uint64_t)v6 << 6));
          }
          else
          {
            v44 = *((_QWORD *)this + 7);
            v45 = (uint64_t)(int)v5 << 6;
            v46 = *(_DWORD *)(v44 + v45) - *(_DWORD *)(v44 + ((uint64_t)v6 << 6));
          }
          *(_DWORD *)(v44 + v45) = v46;
          *(_DWORD *)(v44 + ((uint64_t)v6 << 6)) = 0;
          v47 = *((_QWORD *)this + 8);
          v48 = *(_DWORD *)(v47 + 56 * v6 + 8);
          if ((v48 & 0x80000000) == 0)
          {
            v49 = *((_QWORD *)this + 11);
            v50 = *(unsigned int *)(v47 + 56 * v6 + 8);
            do
            {
              v51 = v49 + 48 * v50;
              *(_DWORD *)(v51 + 32) = v5;
              v50 = *(unsigned int *)(v51 + 16);
            }
            while ((v50 & 0x80000000) == 0);
            v52 = v47 + 56 * (int)v5;
            v55 = *(_DWORD *)(v52 + 8);
            v53 = (_DWORD *)(v52 + 8);
            v54 = v55;
            if ((v55 & 0x80000000) == 0)
            {
              do
              {
                v56 = v49 + 48 * v54;
                v57 = *(_DWORD *)(v56 + 16);
                v53 = (_DWORD *)(v56 + 16);
                v54 = v57;
              }
              while ((v57 & 0x80000000) == 0);
            }
            *v53 = v48;
          }
          Shape::DisconnectStart((uint64_t)this, v6);
          Shape::DisconnectEnd((uint64_t)this, v6);
          v58 = *((_DWORD *)this + 8);
          v59 = v58 - 1;
          if (v58 > 1)
          {
            v60 = *(unsigned int *)(*((_QWORD *)this + 8) + 56 * v59 + 8);
            if ((v60 & 0x80000000) == 0)
            {
              v61 = *((_QWORD *)this + 11);
              do
              {
                v62 = v61 + 48 * v60;
                *(_DWORD *)(v62 + 32) = v6;
                v60 = *(unsigned int *)(v62 + 16);
              }
              while ((v60 & 0x80000000) == 0);
            }
          }
          Shape::SwapEdges(this, v6, v59);
          --*((_DWORD *)this + 8);
        }
      }
      else if ((v5 & 0x80000000) == 0)
      {
        v14 = *((_DWORD *)this + 8);
        while (1)
        {
          if ((int)v5 >= v14)
            goto LABEL_71;
          v15 = *((_QWORD *)this + 5);
          v16 = v15 + 32 * v5;
          v17 = *(unsigned int *)(v16 + 8);
          if (i == v17)
            LODWORD(v17) = *(_DWORD *)(v16 + 12);
          v18 = *(unsigned int *)(*((_QWORD *)this + 3) + 28 * i + 16);
          if ((v18 & 0x80000000) == 0)
            break;
LABEL_48:
          v42 = (_DWORD *)(v15 + 32 * (int)v5);
          if (i == v42[2])
          {
            v43 = v42 + 4;
          }
          else
          {
            if (i != v42[3])
              goto LABEL_71;
            v43 = (unsigned int *)(v15 + 32 * (int)v5 + 24);
          }
          v5 = *v43;
          if ((v5 & 0x80000000) != 0)
            goto LABEL_71;
        }
        while (2)
        {
          v15 = *((_QWORD *)this + 5);
          if ((int)v18 >= v14)
            goto LABEL_48;
          v19 = (unsigned int *)(v15 + 32 * v18);
          v20 = v19[2];
          if (i == v20)
          {
            v21 = v19[4];
            if ((_DWORD)v18 != (_DWORD)v5)
            {
              v22 = *(_DWORD *)(v15 + 32 * v18 + 12);
              goto LABEL_22;
            }
          }
          else if (i == v19[3])
          {
            v21 = *(unsigned int *)(v15 + 32 * v18 + 24);
            v22 = v19[2];
            if ((_DWORD)v18 != (_DWORD)v5)
              goto LABEL_22;
          }
          else
          {
            if ((_DWORD)v18 == (_DWORD)v5)
            {
              LODWORD(v5) = v18;
LABEL_47:
              v15 = *((_QWORD *)this + 5);
              goto LABEL_48;
            }
            v21 = 0xFFFFFFFFLL;
            v22 = v19[2];
LABEL_22:
            if (v22 == (_DWORD)v17)
            {
              v24 = *((_QWORD *)this + 7);
              v23 = *((_QWORD *)this + 8);
              if (*(_DWORD *)(v15 + 32 * v5 + 8) == (_DWORD)v20)
                v25 = *(_DWORD *)(v24 + ((unint64_t)v18 << 6));
              else
                v25 = -*(_DWORD *)(v24 + ((unint64_t)v18 << 6));
              *(_DWORD *)(v24 + ((unint64_t)v5 << 6)) += v25;
              *(_DWORD *)(v24 + ((unint64_t)v18 << 6)) = 0;
              v26 = *(_DWORD *)(v23 + 56 * v18 + 8);
              if ((v26 & 0x80000000) == 0)
              {
                v27 = *((_QWORD *)this + 11);
                v28 = *(unsigned int *)(v23 + 56 * v18 + 8);
                do
                {
                  v29 = v27 + 48 * v28;
                  *(_DWORD *)(v29 + 32) = v5;
                  v28 = *(unsigned int *)(v29 + 16);
                }
                while ((v28 & 0x80000000) == 0);
                v30 = v23 + 56 * v5;
                v33 = *(_DWORD *)(v30 + 8);
                v31 = (_DWORD *)(v30 + 8);
                v32 = v33;
                if ((v33 & 0x80000000) == 0)
                {
                  do
                  {
                    v34 = v27 + 48 * v32;
                    v35 = *(_DWORD *)(v34 + 16);
                    v31 = (_DWORD *)(v34 + 16);
                    v32 = v35;
                  }
                  while ((v35 & 0x80000000) == 0);
                }
                *v31 = v26;
              }
              Shape::DisconnectStart((uint64_t)this, v18);
              Shape::DisconnectEnd((uint64_t)this, v18);
              v36 = *((_DWORD *)this + 8);
              v37 = v36 - 1;
              if (v36 > 1)
              {
                v38 = *(unsigned int *)(*((_QWORD *)this + 8) + 56 * v37 + 8);
                if ((v38 & 0x80000000) == 0)
                {
                  v39 = *((_QWORD *)this + 11);
                  do
                  {
                    v40 = v39 + 48 * v38;
                    *(_DWORD *)(v40 + 32) = v18;
                    v38 = *(unsigned int *)(v40 + 16);
                  }
                  while ((v38 & 0x80000000) == 0);
                }
              }
              Shape::SwapEdges(this, v18, v37);
              v14 = *((_DWORD *)this + 8) - 1;
              if ((_DWORD)v5 == v14)
                v41 = v18;
              else
                v41 = v5;
              if ((_DWORD)v21 == v14)
                v21 = v18;
              else
                v21 = v21;
              *((_DWORD *)this + 8) = v14;
              v18 = v41;
            }
            else
            {
              v18 = v5;
            }
          }
          v5 = v18;
          v18 = v21;
          if ((v21 & 0x80000000) != 0)
            goto LABEL_47;
          continue;
        }
      }
LABEL_71:
      ;
    }
  }
  v63 = *((_DWORD *)this + 8);
  if (v63 >= 1)
  {
    v64 = 0;
    for (j = 0; j < v63; ++j)
    {
      if ((*(_DWORD *)(*((_QWORD *)this + 7) + v64) & 0x80000000) != 0)
      {
        Shape::Inverse(this, j);
        v63 = *((_DWORD *)this + 8);
      }
      v64 += 64;
    }
  }
}

uint64_t Shape::Booleen(void **this, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t result;
  uint64_t v7;
  _BOOL4 v9;
  uint64_t v10;
  float *v11;
  float *v12;
  float v13;
  float v14;
  float v15;
  uint64_t v16;
  float *v17;
  float *v18;
  float v19;
  float v20;
  float v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  uint64_t v29;
  float32x2_t v30;
  double v31;
  double v32;
  int8x16_t v33;
  double v34;
  float64x2_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int *v42;
  uint64_t v43;
  float32x2_t v44;
  double v45;
  double v46;
  int8x16_t v47;
  double v48;
  float64x2_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  float v54;
  float v55;
  _BOOL4 v56;
  int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  _DWORD *v61;
  float v62;
  float v63;
  uint64_t v64;
  uint64_t v65;
  _DWORD *v66;
  float v67;
  float v68;
  BOOL v69;
  float v70;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  float v75;
  uint64_t v76;
  float v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  int *v85;
  float v86;
  float v87;
  float v88;
  BOOL v89;
  uint64_t v90;
  float v91;
  float v92;
  float v93;
  uint64_t v95;
  float v97;
  float v98;
  float v99;
  float v100;
  uint64_t v101;
  signed int v102;
  uint64_t v103;
  int v104;
  Shape *v105;
  signed int v106;
  int *v107;
  uint64_t v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  Shape *v112;
  _DWORD *v113;
  int *v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  _DWORD *v118;
  int *v119;
  int v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  int v126;
  char *v127;
  char *v128;
  char *v129;
  __int128 v130;
  char *v131;
  char *v132;
  char *v133;
  __int128 v134;
  __int128 v135;
  int v136;
  double v137;
  double v138;
  double v139;
  int32x4_t v140;
  int32x4_t v141;
  double v142;
  double v143;
  double v144;
  int32x4_t v145;
  int32x4_t v146;
  unsigned int v147;
  unsigned int v148;
  int v149;
  unsigned int v150;
  unsigned int v151;
  unsigned int v152;
  uint64_t v153;
  uint64_t v154;
  int v155;
  int v156;
  BOOL v157;
  BOOL v158;
  _BOOL4 v159;
  _BOOL4 v160;
  int v161;
  unsigned int *v162;
  unsigned int v163;
  uint64_t v164;
  uint64_t v165;
  int v166;
  int v167;
  uint64_t *v171;
  int v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  double v177;
  double v178;
  double v179;
  int32x4_t v180;
  int32x4_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  _DWORD *v185;
  unsigned int *v186;
  uint64_t v187;
  uint64_t v188;
  char v189;
  int v190;
  double v191;
  double v192;
  double v193;
  int32x4_t v194;
  int32x4_t v195;
  double v196;
  double v197;
  double v198;
  int32x4_t v199;
  int32x4_t v200;
  int v201;
  double v202;
  double v203;
  double v204;
  int32x4_t v205;
  int32x4_t v206;
  uint64_t v207;
  uint64_t v208;
  double v209;
  double v210;
  double v211;
  int32x4_t v212;
  int32x4_t v213;
  unsigned int v214;
  int v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  int v219;
  int v220;
  uint64_t v224;
  double v225;
  double v226;
  double v227;
  int32x4_t v228;
  int32x4_t v229;
  uint64_t v230;
  uint64_t v231;
  int v232;
  int v233;
  double v234;
  double v235;
  double v236;
  int32x4_t v237;
  int32x4_t v238;
  _DWORD *v239;
  unsigned int *v240;
  int v241;
  Shape *v242;
  signed int v243;
  int *v244;
  uint64_t v245;
  int v246;
  uint64_t v247;
  uint64_t v248;
  Shape *v249;
  _DWORD *v250;
  int *v251;
  uint64_t v252;
  int v253;
  uint64_t v254;
  _DWORD *v255;
  int *v256;
  int v257;
  int v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  void *v263;
  void *v264;
  uint64_t v265;
  _DWORD *v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  int v270;
  uint64_t v271;
  int v272;
  _DWORD *v273;
  int v274;
  int v275;
  _DWORD *v276;
  int v277;
  int i;
  uint64_t v279;
  int v280;
  _DWORD *v281;
  int v282;
  uint64_t v283;
  int v284;
  _DWORD *v285;
  int v286;
  uint64_t v287;
  int v288;
  _DWORD *v289;
  _QWORD *v290;
  Shape *v291;
  _QWORD *v292;
  unsigned int v293;
  int v294;
  Shape *v295;
  Shape *v296;
  int *v297;
  uint64_t v298;
  uint64_t v299;
  int v300;
  int v301;
  int *v302;
  SweepTree *v303;
  SweepTree *v304;
  int v305;
  int v306;
  uint64_t v307;
  Shape *v308;
  int v309[3];

  result = 5;
  if (!a3)
    return result;
  if (!a2)
    return result;
  v7 = a3;
  if (a2 == a3)
    return result;
  Shape::Reset(this, 0);
  result = 0;
  if (*(int *)(a2 + 16) < 2)
    return result;
  if (*(int *)(a2 + 32) < 2 || *(int *)(v7 + 16) < 2 || *(int *)(v7 + 32) < 2)
    return 0;
  if (*(_DWORD *)(a2 + 48) != 1 || *(_DWORD *)(v7 + 48) != 1)
    return 5;
  Shape::ResetSweep((Shape *)a2);
  Shape::ResetSweep((Shape *)v7);
  if (!Shape::GetFlag((Shape *)this, 64))
  {
    SweepTree::CreateList((uint64_t)(this + 21), *(_DWORD *)(v7 + 32) + *(_DWORD *)(a2 + 32));
    SweepEvent::CreateQueue((uint64_t)(this + 24), *(_DWORD *)(v7 + 32) + *(_DWORD *)(a2 + 32));
    Shape::SetFlag((Shape *)this, 64, 1);
  }
  Shape::MakePointData((Shape *)this, 1);
  Shape::MakeEdgeData((Shape *)this, 1);
  Shape::MakeSweepSrcData((Shape *)this, 1);
  Shape::MakeSweepDestData((Shape *)this, 1);
  v293 = a4;
  v9 = (*(_BYTE *)(a2 + 53) & 2) != 0 && (*(_BYTE *)(v7 + 53) & 2) != 0;
  Shape::MakeBackData((Shape *)this, v9);
  v291 = (Shape *)a2;
  v10 = *(unsigned int *)(a2 + 16);
  if ((int)v10 >= 1)
  {
    v11 = (float *)(*((_QWORD *)v291 + 11) + 40);
    v12 = (float *)(*((_QWORD *)v291 + 3) + 4);
    do
    {
      *((_QWORD *)v11 - 4) = 0xFFFFFFFF00000000;
      *(v11 - 6) = NAN;
      v13 = ldexpf(*(v12 - 1), 5);
      *(v11 - 1) = ldexpf(roundf(v13), -5);
      v14 = *v12;
      v12 += 7;
      v15 = ldexpf(v14, 5);
      *v11 = ldexpf(roundf(v15), -5);
      v11 += 12;
      --v10;
    }
    while (v10);
  }
  v16 = *(unsigned int *)(v7 + 16);
  if ((int)v16 >= 1)
  {
    v17 = (float *)(*(_QWORD *)(v7 + 88) + 40);
    v18 = (float *)(*(_QWORD *)(v7 + 24) + 4);
    do
    {
      *((_QWORD *)v17 - 4) = 0xFFFFFFFF00000000;
      *(v17 - 6) = NAN;
      v19 = ldexpf(*(v18 - 1), 5);
      *(v17 - 1) = ldexpf(roundf(v19), -5);
      v20 = *v18;
      v18 += 7;
      v21 = ldexpf(v20, 5);
      *v17 = ldexpf(roundf(v21), -5);
      v17 += 12;
      --v16;
    }
    while (v16);
  }
  v22 = (uint64_t)v291;
  v23 = *((unsigned int *)v291 + 8);
  if ((int)v23 >= 1)
  {
    v24 = 0;
    v25 = *((_QWORD *)v291 + 11);
    v26 = *((_QWORD *)v291 + 8);
    v27 = 56 * v23;
    v28 = (int *)(*((_QWORD *)v291 + 5) + 12);
    v29 = *((_QWORD *)v291 + 7) + 32;
    do
    {
      v30 = vsub_f32(*(float32x2_t *)(v25 + 48 * *v28 + 36), *(float32x2_t *)(v25 + 48 * *(v28 - 1) + 36));
      *(float32x2_t *)(v29 - 28) = v30;
      v31 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v30, v30).i32[1]), v30.f32[0], v30.f32[0]);
      v32 = sqrt(v31);
      *(double *)(v29 - 16) = v31;
      *(double *)(v29 - 8) = v32;
      *(double *)v29 = 1.0 / v31;
      *(double *)(v29 + 8) = 1.0 / v32;
      v33 = (int8x16_t)vmulq_n_f64(vcvtq_f64_f32(v30), 1.0 / v32);
      v34 = *(double *)&v33.i64[1];
      v35 = (float64x2_t)vextq_s8(v33, v33, 8uLL);
      *(float64x2_t *)(v29 + 16) = v35;
      if (v34 < 0.0)
        *(float64x2_t *)(v29 + 16) = vnegq_f64(v35);
      v36 = v26 + v24;
      *(_QWORD *)v36 = 0;
      v28 += 8;
      *(_DWORD *)(v36 + 16) = -1;
      *(_QWORD *)(v36 + 8) = -1;
      *(_QWORD *)(v36 + 24) = -1;
      *(_QWORD *)(v36 + 32) = 0;
      *(_QWORD *)(v36 + 40) = -1;
      v24 += 56;
      v29 += 64;
      *(_DWORD *)(v36 + 48) = -1;
    }
    while (v27 != v24);
  }
  v37 = *(unsigned int *)(v7 + 32);
  if ((int)v37 >= 1)
  {
    v38 = 0;
    v39 = *(_QWORD *)(v7 + 88);
    v40 = *(_QWORD *)(v7 + 64);
    v41 = 56 * v37;
    v42 = (int *)(*(_QWORD *)(v7 + 40) + 12);
    v43 = *(_QWORD *)(v7 + 56) + 32;
    do
    {
      v44 = vsub_f32(*(float32x2_t *)(v39 + 48 * *v42 + 36), *(float32x2_t *)(v39 + 48 * *(v42 - 1) + 36));
      *(float32x2_t *)(v43 - 28) = v44;
      v45 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v44, v44).i32[1]), v44.f32[0], v44.f32[0]);
      v46 = sqrt(v45);
      *(double *)(v43 - 16) = v45;
      *(double *)(v43 - 8) = v46;
      *(double *)v43 = 1.0 / v45;
      *(double *)(v43 + 8) = 1.0 / v46;
      v47 = (int8x16_t)vmulq_n_f64(vcvtq_f64_f32(v44), 1.0 / v46);
      v48 = *(double *)&v47.i64[1];
      v49 = (float64x2_t)vextq_s8(v47, v47, 8uLL);
      *(float64x2_t *)(v43 + 16) = v49;
      if (v48 < 0.0)
        *(float64x2_t *)(v43 + 16) = vnegq_f64(v49);
      v50 = v40 + v38;
      *(_QWORD *)v50 = 0;
      v42 += 8;
      *(_DWORD *)(v50 + 16) = -1;
      *(_QWORD *)(v50 + 8) = -1;
      *(_QWORD *)(v50 + 24) = -1;
      *(_QWORD *)(v50 + 32) = 0;
      *(_QWORD *)(v50 + 40) = -1;
      v38 += 56;
      v43 += 64;
      *(_DWORD *)(v50 + 48) = -1;
    }
    while (v41 != v38);
  }
  Shape::SortPointsRounded(v291);
  Shape::SortPointsRounded((Shape *)v7);
  v51 = 0;
  v52 = 0;
  v53 = 0;
  this[17] = 0;
  v292 = this + 17;
  this[18] = 0;
  v54 = *(float *)(*((_QWORD *)v291 + 11) + 40);
  if (v54 >= *(float *)(*(_QWORD *)(v7 + 88) + 40))
    v54 = *(float *)(*(_QWORD *)(v7 + 88) + 40);
  v55 = v54 + -1.0;
  v309[0] = -1;
  this[19] = 0;
  v302 = (int *)(this + 24);
  v308 = 0;
  v296 = (Shape *)v7;
  v297 = (int *)(this + 21);
  v290 = this + 19;
  this[20] = 0;
  v295 = (Shape *)this;
  while ((int)v52 < *(_DWORD *)(v22 + 16) || (int)v51 < *(_DWORD *)(v7 + 16) || *v302 >= 1)
  {
    v307 = 0;
    v306 = 0;
    v305 = 0;
    v303 = 0;
    v304 = 0;
    v56 = SweepEvent::PeekInQueue(&v304, &v303, (_DWORD *)&v307 + 1, &v307, &v306, &v305, (uint64_t)v302);
    v57 = *(_DWORD *)(v22 + 16);
    if (!v56)
    {
      if ((int)v52 < v57
        && ((int)v51 >= *(_DWORD *)(v7 + 16)
         || (v74 = *(_QWORD *)(v22 + 88),
             v75 = *(float *)(v74 + 48 * (int)v52 + 40),
             v76 = *(_QWORD *)(v7 + 88),
             v77 = *(float *)(v76 + 48 * (int)v51 + 40),
             v75 < v77)
         || v75 == v77 && *(float *)(v74 + 48 * (int)v52 + 36) < *(float *)(v76 + 48 * (int)v51 + 36)))
      {
        v72 = v51;
        LODWORD(v51) = v52;
        v78 = v22;
        v7 = v22;
        v52 = (v52 + 1);
      }
      else
      {
        v78 = v22;
        v72 = (v51 + 1);
      }
      v59 = v51;
      v79 = *(_QWORD *)(v7 + 88) + 48 * (int)v51;
      HIDWORD(v307) = *(_DWORD *)(v79 + 36);
      v80 = *(_DWORD *)(v79 + 40);
LABEL_64:
      LODWORD(v307) = v80;
      goto LABEL_65;
    }
    if ((int)v52 >= v57)
    {
      v83 = *(_QWORD *)(v7 + 88);
      if (*(int *)(v83 + 48 * (int)v51 + 8) > 0
        || (v59 = v51,
            v84 = v83 + 48 * (int)v51,
            v86 = *(float *)(v84 + 40),
            v85 = (int *)(v84 + 40),
            v87 = v86,
            v86 > *(float *)&v307)
        || ((v88 = *(float *)(v83 + 48 * (int)v51 + 36), v87 == *(float *)&v307)
          ? (v89 = v88 <= *((float *)&v307 + 1))
          : (v89 = 1),
            !v89))
      {
LABEL_94:
        v78 = v22;
        v298 = v51;
        v299 = v52;
        SweepEvent::ExtractFromQueue(&v304, &v303, (_DWORD *)&v307 + 1, &v307, &v306, &v305, (uint64_t)v302);
        v7 = 0;
        LODWORD(v51) = -1;
        v82 = 1;
        goto LABEL_95;
      }
      v78 = v22;
      v72 = (v51 + 1);
      *((float *)&v307 + 1) = v88;
      v80 = *v85;
      goto LABEL_64;
    }
    v58 = *(_QWORD *)(v22 + 88);
    v59 = v52;
    if ((int)v51 >= *(_DWORD *)(v7 + 16))
    {
      if (*(int *)(v58 + 48 * (int)v52 + 8) > 0)
        goto LABEL_94;
      v90 = v58 + 48 * (int)v52;
      v91 = *(float *)(v90 + 40);
      v61 = (_DWORD *)(v90 + 40);
      v92 = v91;
      if (v91 > *(float *)&v307)
        goto LABEL_94;
      v93 = *(float *)(v58 + 48 * (int)v52 + 36);
      if (v92 == *(float *)&v307 && v93 > *((float *)&v307 + 1))
        goto LABEL_94;
      v72 = v51;
      LODWORD(v51) = v52;
      v73 = (v52 + 1);
      *((float *)&v307 + 1) = v93;
      goto LABEL_84;
    }
    v60 = v58 + 48 * (int)v52;
    v62 = *(float *)(v60 + 40);
    v61 = (_DWORD *)(v60 + 40);
    v63 = v62;
    v64 = *(_QWORD *)(v7 + 88);
    v65 = v64 + 48 * (int)v51;
    v67 = *(float *)(v65 + 40);
    v66 = (_DWORD *)(v65 + 40);
    v68 = v67;
    v69 = v63 == v67;
    if (v63 < v67 || v69 && *(float *)(v58 + 48 * (int)v52 + 36) < *(float *)(v64 + 48 * (int)v51 + 36))
    {
      if (*(int *)(v58 + 48 * (int)v52 + 8) > 0 || v63 > *(float *)&v307)
        goto LABEL_94;
      v70 = *(float *)(v58 + 48 * (int)v52 + 36);
      if (v63 == *(float *)&v307 && v70 > *((float *)&v307 + 1))
        goto LABEL_94;
      v72 = v51;
      LODWORD(v51) = v52;
      v73 = (v52 + 1);
      *((float *)&v307 + 1) = v70;
LABEL_84:
      LODWORD(v307) = *v61;
      v78 = v22;
      v7 = v22;
      v52 = v73;
      goto LABEL_65;
    }
    if (*(int *)(v64 + 48 * (int)v51 + 8) > 0 || v68 > *(float *)&v307)
      goto LABEL_94;
    v95 = v64 + 48 * (int)v51;
    if (v68 == *(float *)&v307 && *(float *)(v95 + 36) > *((float *)&v307 + 1))
      goto LABEL_94;
    v78 = v22;
    v72 = (v51 + 1);
    HIDWORD(v307) = *(_DWORD *)(v95 + 36);
    LODWORD(v307) = *v66;
    v59 = v51;
LABEL_65:
    v81 = *(_QWORD *)(v7 + 24);
    if (!*(_DWORD *)(v81 + 28 * v59 + 8) && !*(_DWORD *)(v81 + 28 * v59 + 12))
    {
      v51 = v72;
      goto LABEL_189;
    }
    v299 = v52;
    v82 = 0;
    v298 = v72;
LABEL_95:
    v97 = ldexpf(*((float *)&v307 + 1), 5);
    v98 = ldexpf(roundf(v97), -5);
    v99 = ldexpf(*(float *)&v307, 5);
    v100 = ldexpf(roundf(v99), -5);
    v101 = Shape::AddPoint((Shape *)this, v98, v100);
    v102 = v101;
    v103 = (uint64_t)this[11] + 48 * (int)v101;
    *(float *)(v103 + 36) = v98;
    *(float *)(v103 + 40) = v100;
    if (v100 <= v55)
    {
      v126 = v101;
    }
    else
    {
      v104 = Shape::AssemblePoints((Shape *)this, v53, v101);
      v106 = v104;
      if (v53 < v104)
      {
        v107 = (int *)((char *)this[11] + 48 * v53 + 32);
        v108 = v104 - (uint64_t)v53;
        v109 = v53;
        do
        {
          v110 = *((_QWORD *)v107 - 1);
          if (v110)
          {
            v111 = *(_QWORD *)(v110 + 64) + 56 * *v107;
            *(v107 - 4) = *(_DWORD *)(v111 + 8);
            *(_DWORD *)(v111 + 8) = v109;
          }
          ++v109;
          v107 += 12;
          --v108;
        }
        while (v108);
      }
      v112 = v308;
      if (v308)
      {
        v113 = this[11];
        v114 = v309;
        do
        {
          v115 = *((_QWORD *)v112 + 8) + 56 * *v114;
          v116 = *(_DWORD *)(v115 + 28);
          *(_DWORD *)(v115 + 24) = v113[12 * *(int *)(v115 + 24) + 1];
          *(_DWORD *)(v115 + 28) = v113[12 * v116 + 1];
          v114 = (int *)(v115 + 40);
          v112 = *(Shape **)(v115 + 32);
        }
        while (v112);
      }
      v117 = *(unsigned int *)v292;
      if ((int)v117 >= 1)
      {
        v118 = this[11];
        v119 = (int *)((char *)this[18] + 8);
        while (1)
        {
          v120 = *(v119 - 2);
          v121 = v118[12 * *(v119 - 1) + 1];
          *(v119 - 1) = v121;
          if (v120 == 1)
            break;
          if (!v120)
          {
            v122 = v119[2];
            v123 = *(_QWORD *)(*(_QWORD *)v119 + 40) + 32 * v122;
            v124 = *(_QWORD *)(*(_QWORD *)v119 + 64);
            if (*(_DWORD *)(v123 + 8) >= *(_DWORD *)(v123 + 12))
              goto LABEL_111;
LABEL_109:
            *(_DWORD *)(v124 + 56 * (int)v122 + 12) = v121;
          }
LABEL_112:
          v119 += 18;
          if (!--v117)
            goto LABEL_113;
        }
        v122 = v119[2];
        v125 = *(_QWORD *)(*(_QWORD *)v119 + 40) + 32 * v122;
        v124 = *(_QWORD *)(*(_QWORD *)v119 + 64);
        if (*(_DWORD *)(v125 + 8) <= *(_DWORD *)(v125 + 12))
        {
LABEL_111:
          *(_DWORD *)(v124 + 56 * (int)v122 + 16) = v121;
          goto LABEL_112;
        }
        goto LABEL_109;
      }
LABEL_113:
      Shape::CheckAdjacencies((uint64_t)this, v104, v53, v105);
      Shape::CheckEdges((uint64_t)this, v106, v53, v78, v296, v293);
      v126 = v106;
      if (v106 < v102)
      {
        v127 = (char *)this[3];
        v128 = &v127[28 * v102];
        v129 = &v127[28 * v106];
        v130 = *(_OWORD *)v128;
        *(_OWORD *)(v129 + 12) = *(_OWORD *)(v128 + 12);
        *(_OWORD *)v129 = v130;
        v131 = (char *)this[11];
        v132 = &v131[48 * v102];
        v133 = &v131[48 * v106];
        v134 = *(_OWORD *)v132;
        v135 = *((_OWORD *)v132 + 2);
        *((_OWORD *)v133 + 1) = *((_OWORD *)v132 + 1);
        *((_OWORD *)v133 + 2) = v135;
        *(_OWORD *)v133 = v134;
      }
      *((_DWORD *)this + 4) = v106 + 1;
      *((_DWORD *)this + 34) = 0;
      v309[0] = -1;
      v308 = 0;
      v53 = v106;
      v55 = v100;
    }
    if (v82)
    {
      v136 = v126;
      SweepTree::RemoveEvent((uint64_t)v304, v302, 1);
      SweepTree::RemoveEvent((uint64_t)v303, v302, 0);
      Shape::AddChgt((Shape *)this, v136, v53, &v308, v309, 2, *((Shape **)v304 + 8), *((_DWORD *)v304 + 18), *((Shape **)v303 + 8), *((_DWORD *)v303 + 18));
      SweepTree::SwapWithRight((uint64_t)v304);
      Shape::TesteIntersection((uint64_t)this, v304, 1, 1, v137, v138, v139, v140, v141);
      Shape::TesteIntersection((uint64_t)this, v303, 0, 1, v142, v143, v144, v145, v146);
    }
    else
    {
      v147 = *(_DWORD *)(*(_QWORD *)(v7 + 24) + 28 * (int)v51 + 16);
      if ((v147 & 0x80000000) == 0)
      {
        v148 = 0;
        v149 = 0;
        v150 = -1;
        v151 = -1;
        v152 = *(_DWORD *)(*(_QWORD *)(v7 + 24) + 28 * (int)v51 + 16);
        do
        {
          if ((signed int)v152 >= *(_DWORD *)(v7 + 32))
            break;
          v153 = *(_QWORD *)(v7 + 40);
          v154 = v153 + 32 * v152;
          v156 = *(_DWORD *)(v154 + 8);
          v155 = *(_DWORD *)(v154 + 12);
          v157 = v156 < v155 && (_DWORD)v51 == v155;
          if (v157 || ((_DWORD)v51 == v156 ? (v158 = v156 <= v155) : (v158 = 1), !v158))
          {
            ++v149;
            v151 = v152;
          }
          v159 = v51 == v156;
          v160 = v156 > v155;
          if (v156 >= v155)
            v159 = 0;
          if ((_DWORD)v51 != v155)
            v160 = 0;
          v161 = v160 || v159;
          if (v161)
            v150 = v152;
          v148 += v161;
          if ((_DWORD)v51 == v156)
          {
            v162 = (unsigned int *)(v153 + 32 * v152 + 16);
          }
          else
          {
            if ((_DWORD)v51 != v155)
              break;
            v162 = (unsigned int *)(v153 + 32 * v152 + 24);
          }
          v152 = *v162;
        }
        while ((v152 & 0x80000000) == 0);
        v163 = -1;
        v301 = v53;
        if (v148 && (v151 & 0x80000000) == 0)
        {
          if (*(_QWORD *)(*(_QWORD *)(v7 + 64) + 56 * v151))
            v163 = v151;
          else
            v163 = -1;
        }
        v300 = v126;
        if (v149 >= 1)
        {
          while ((signed int)v147 < *(_DWORD *)(v7 + 32))
          {
            v164 = v147;
            v165 = *(_QWORD *)(v7 + 40) + 32 * v147;
            v166 = *(_DWORD *)(v165 + 8);
            v167 = *(_DWORD *)(v165 + 12);
            if (v166 < v167 && (_DWORD)v51 == v167)
            {
              if (v147 != v163)
              {
LABEL_163:
                v171 = *(uint64_t **)(*(_QWORD *)(v7 + 64) + 56 * v147);
                if (v171)
                {
                  v172 = -1;
                  Shape::AddChgt(v295, v126, v301, &v308, v309, 1, (Shape *)v171[8], *((_DWORD *)v171 + 18), 0, -1);
                  *(_QWORD *)(*(_QWORD *)(v7 + 64) + 56 * v164) = 0;
                  v173 = *v171;
                  if (*v171)
                  {
                    v172 = *(_DWORD *)(v173 + 72);
                    v174 = *(_QWORD *)(v173 + 64);
                  }
                  else
                  {
                    v174 = 0;
                  }
                  v175 = v171[1];
                  if (v175)
                  {
                    v294 = *(_DWORD *)(v175 + 72);
                    v176 = *(_QWORD *)(v175 + 64);
                  }
                  else
                  {
                    v176 = 0;
                    v294 = -1;
                  }
                  SweepTree::Remove((AVLTree *)v171, (uint64_t)v297, v302, 1);
                  v126 = v300;
                  if (v174)
                  {
                    if (v176)
                    {
                      if (v174 != v7
                        || (v182 = *(_QWORD *)(v7 + 40) + 32 * v172, *(_DWORD *)(v182 + 12) != (_DWORD)v51)
                        && *(_DWORD *)(v182 + 8) != (_DWORD)v51)
                      {
                        if (v176 != v7
                          || (v183 = *(_QWORD *)(v7 + 40) + 32 * v294, *(_DWORD *)(v183 + 12) != (_DWORD)v51)
                          && *(_DWORD *)(v183 + 8) != (_DWORD)v51)
                        {
                          Shape::TesteIntersection((uint64_t)v295, *(SweepTree **)(*(_QWORD *)(v174 + 64) + 56 * v172), 0, 1, v177, v178, v179, v180, v181);
                          v126 = v300;
                        }
                      }
                    }
                  }
                }
              }
            }
            else if ((_DWORD)v51 == v166 && v166 > v167 && v147 != v163)
            {
              goto LABEL_163;
            }
            v184 = *(_QWORD *)(v7 + 40);
            v185 = (_DWORD *)(v184 + 32 * v164);
            if (v185[2] == (_DWORD)v51)
            {
              v186 = v185 + 4;
            }
            else
            {
              if (v185[3] != (_DWORD)v51)
                break;
              v186 = (unsigned int *)(v184 + 32 * v164 + 24);
            }
            v147 = *v186;
            if ((v147 & 0x80000000) != 0)
              break;
            continue;
          }
        }
        this = (void **)v295;
        v53 = v301;
        if ((v150 & 0x80000000) != 0)
        {
          v188 = 0;
          v189 = 1;
        }
        else if ((v163 & 0x80000000) != 0)
        {
          v201 = v126;
          v188 = SweepTree::AddInList(v7, v150, 1, v126, v297);
          *(_QWORD *)(*(_QWORD *)(v7 + 64) + 56 * v150) = v188;
          SweepTree::Insert((SweepTree *)v188, (uint64_t)v297, v302, (uint64_t)v295, v201, 1, 1);
          v207 = *(_QWORD *)v188;
          if (*(_QWORD *)v188)
          {
            v208 = *((_QWORD *)v295 + 11) + 48 * v201;
            *(_QWORD *)(v208 + 24) = *(_QWORD *)(v207 + 64);
            *(_DWORD *)(v208 + 32) = *(_DWORD *)(v207 + 72);
          }
          else
          {
            *(_DWORD *)(*((_QWORD *)v295 + 11) + 48 * v201 + 32) = -1;
          }
          Shape::TesteIntersection((uint64_t)v295, (SweepTree *)v188, 0, 1, v202, v203, v204, v205, v206);
          Shape::TesteIntersection((uint64_t)v295, (SweepTree *)v188, 1, 1, v209, v210, v211, v212, v213);
          *(_DWORD *)(*(_QWORD *)(v7 + 64) + 56 * v150 + 44) = v201;
          Shape::AddChgt(v295, v201, v301, &v308, v309, 0, *(Shape **)(v188 + 64), *(_DWORD *)(v188 + 72), 0, -1);
          v189 = 0;
        }
        else
        {
          v187 = 56 * v163;
          v188 = *(_QWORD *)(*(_QWORD *)(v7 + 64) + v187);
          v189 = 1;
          v190 = v126;
          Shape::AddChgt(v295, v126, v301, &v308, v309, 1, *(Shape **)(v188 + 64), *(_DWORD *)(v188 + 72), 0, -1);
          *(_QWORD *)(*(_QWORD *)(v7 + 64) + v187) = 0;
          SweepTree::RemoveEvents(v188, v302);
          SweepTree::ConvertTo(v188, (Shape *)v7, v150, 1, v190);
          *(_QWORD *)(*(_QWORD *)(v7 + 64) + 56 * v150) = v188;
          Shape::TesteIntersection((uint64_t)v295, (SweepTree *)v188, 0, 1, v191, v192, v193, v194, v195);
          Shape::TesteIntersection((uint64_t)v295, (SweepTree *)v188, 1, 1, v196, v197, v198, v199, v200);
          v53 = v301;
          *(_DWORD *)(*(_QWORD *)(v7 + 64) + 56 * v150 + 44) = v190;
          Shape::AddChgt(v295, v190, v301, &v308, v309, 0, *(Shape **)(v188 + 64), *(_DWORD *)(v188 + 72), 0, -1);
        }
        if (v148 < 2 || (v214 = *(_DWORD *)(*(_QWORD *)(v7 + 24) + 28 * (int)v51 + 16), (v214 & 0x80000000) != 0))
        {
LABEL_225:
          v7 = (uint64_t)v296;
          v22 = (uint64_t)v291;
          v51 = v298;
          v52 = v299;
          continue;
        }
        v215 = v300;
LABEL_198:
        if ((signed int)v214 >= *(_DWORD *)(v7 + 32))
        {
LABEL_224:
          v7 = (uint64_t)v296;
          v22 = (uint64_t)v291;
          v51 = v298;
          v52 = v299;
          continue;
        }
        v216 = *(_QWORD *)(v7 + 40);
        v217 = v214;
        v218 = v216 + 32 * v214;
        v219 = *(_DWORD *)(v218 + 8);
        v220 = *(_DWORD *)(v218 + 12);
        if (v219 > v220 && (_DWORD)v51 == v220)
        {
          if (v214 != v150)
            goto LABEL_213;
        }
        else if ((_DWORD)v51 == v219 && v219 < v220 && v214 != v150)
        {
LABEL_213:
          v224 = SweepTree::AddInList(v7, v214, 1, v215, v297);
          *(_QWORD *)(*(_QWORD *)(v7 + 64) + 56 * v217) = v224;
          SweepTree::InsertAt((AVLTree *)v224, (uint64_t)v297, v302, (int)v295, (AVLTree **)v188, v51, 1, 1);
          if ((v189 & 1) != 0)
          {
            v230 = *(_QWORD *)v224;
            v231 = *((_QWORD *)v295 + 11);
            if (*(_QWORD *)v224)
            {
              v232 = v300;
              *(_QWORD *)(v231 + 48 * v300 + 24) = *(_QWORD *)(v230 + 64);
              v233 = *(_DWORD *)(v230 + 72);
            }
            else
            {
              v233 = -1;
              v232 = v300;
            }
            *(_DWORD *)(v231 + 48 * v232 + 32) = v233;
          }
          Shape::TesteIntersection((uint64_t)v295, (SweepTree *)v224, 0, 1, v225, v226, v227, v228, v229);
          Shape::TesteIntersection((uint64_t)v295, (SweepTree *)v224, 1, 1, v234, v235, v236, v237, v238);
          *(_DWORD *)(*(_QWORD *)(v7 + 64) + 56 * v217 + 44) = v300;
          v53 = v301;
          Shape::AddChgt(v295, v300, v301, &v308, v309, 0, *(Shape **)(v224 + 64), *(_DWORD *)(v224 + 72), 0, -1);
          v215 = v300;
          v189 = 0;
          v216 = *(_QWORD *)(v7 + 40);
          v219 = *(_DWORD *)(v216 + 32 * v217 + 8);
LABEL_219:
          v239 = (_DWORD *)(v216 + 32 * v217);
          if (v219 == (_DWORD)v51)
          {
            v240 = v239 + 4;
          }
          else
          {
            if (v239[3] != (_DWORD)v51)
              goto LABEL_225;
            v240 = v239 + 6;
          }
          v214 = *v240;
          if ((*v240 & 0x80000000) != 0)
            goto LABEL_224;
          goto LABEL_198;
        }
        v53 = v301;
        goto LABEL_219;
      }
    }
    v51 = v298;
    v52 = v299;
LABEL_189:
    v22 = v78;
    v7 = (uint64_t)v296;
  }
  v241 = Shape::AssemblePoints((Shape *)this, v53, *((unsigned int *)this + 4));
  v243 = v241;
  if (v53 < v241)
  {
    v244 = (int *)((char *)this[11] + 48 * v53 + 32);
    v245 = v241 - (uint64_t)v53;
    v246 = v53;
    do
    {
      v247 = *((_QWORD *)v244 - 1);
      if (v247)
      {
        v248 = *(_QWORD *)(v247 + 64) + 56 * *v244;
        *(v244 - 4) = *(_DWORD *)(v248 + 8);
        *(_DWORD *)(v248 + 8) = v246;
      }
      ++v246;
      v244 += 12;
      --v245;
    }
    while (v245);
  }
  v249 = v308;
  if (v308)
  {
    v250 = this[11];
    v251 = v309;
    do
    {
      v252 = *((_QWORD *)v249 + 8) + 56 * *v251;
      v253 = *(_DWORD *)(v252 + 28);
      *(_DWORD *)(v252 + 24) = v250[12 * *(int *)(v252 + 24) + 1];
      *(_DWORD *)(v252 + 28) = v250[12 * v253 + 1];
      v251 = (int *)(v252 + 40);
      v249 = *(Shape **)(v252 + 32);
    }
    while (v249);
  }
  v254 = *(unsigned int *)v292;
  if ((int)v254 >= 1)
  {
    v255 = this[11];
    v256 = (int *)((char *)this[18] + 8);
    while (1)
    {
      v257 = *(v256 - 2);
      v258 = v255[12 * *(v256 - 1) + 1];
      *(v256 - 1) = v258;
      if (v257 == 1)
        break;
      if (!v257)
      {
        v259 = v256[2];
        v260 = *(_QWORD *)(*(_QWORD *)v256 + 40) + 32 * v259;
        v261 = *(_QWORD *)(*(_QWORD *)v256 + 64);
        if (*(_DWORD *)(v260 + 8) >= *(_DWORD *)(v260 + 12))
          goto LABEL_241;
LABEL_239:
        *(_DWORD *)(v261 + 56 * (int)v259 + 12) = v258;
      }
LABEL_242:
      v256 += 18;
      if (!--v254)
        goto LABEL_243;
    }
    v259 = v256[2];
    v262 = *(_QWORD *)(*(_QWORD *)v256 + 40) + 32 * v259;
    v261 = *(_QWORD *)(*(_QWORD *)v256 + 64);
    if (*(_DWORD *)(v262 + 8) <= *(_DWORD *)(v262 + 12))
    {
LABEL_241:
      *(_DWORD *)(v261 + 56 * (int)v259 + 16) = v258;
      goto LABEL_242;
    }
    goto LABEL_239;
  }
LABEL_243:
  Shape::CheckAdjacencies((uint64_t)this, v241, v53, v242);
  Shape::CheckEdges((uint64_t)this, v243, v53, v22, (Shape *)v7, v293);
  *((_DWORD *)this + 4) = v243;
  v263 = this[18];
  if (v263)
    free(v263);
  *v292 = 0;
  v292[1] = 0;
  v264 = this[20];
  if (v264)
    free(v264);
  *v290 = 0;
  v290[1] = 0;
  Shape::AssembleAretes((Shape *)this);
  v265 = *((unsigned int *)this + 4);
  if ((int)v265 >= 1)
  {
    v266 = (char *)this[3] + 12;
    do
    {
      v266[3] = *v266 + *(v266 - 1);
      v266 += 7;
      --v265;
    }
    while (v265);
  }
  Shape::SetFlag((Shape *)this, 2, 1);
  Shape::GetWindings((Shape *)this, v267, v268, v269, 0);
  if (v293 == 3)
  {
    if (*((int *)this + 8) >= 1)
    {
      v270 = 0;
      while (1)
      {
        v271 = (uint64_t)this[9] + 32 * v270;
        v274 = *(_DWORD *)(v271 + 20);
        v273 = (_DWORD *)(v271 + 20);
        v272 = v274;
        v275 = *(v273 - 1) & 1;
        *(v273 - 1) = v275;
        if (v274 < 0)
        {
          *v273 = -v272;
          v272 = 1;
        }
        if (v275)
        {
          v276 = this[7];
          if (v272)
            goto LABEL_261;
          v276[16 * (uint64_t)v270] = 1;
        }
        else
        {
          if (!v272)
          {
            v276 = this[7];
LABEL_261:
            v276[16 * (uint64_t)v270] = 0;
            Shape::SubEdge((Shape *)this, v270--);
            goto LABEL_262;
          }
          Shape::Inverse((Shape *)this, v270);
          *((_DWORD *)this[7] + 16 * (uint64_t)v270) = 1;
        }
LABEL_262:
        if (++v270 >= *((_DWORD *)this + 8))
          goto LABEL_301;
      }
    }
    goto LABEL_301;
  }
  if ((v293 & 0xFFFFFFFD) == 0)
  {
    if (*((int *)this + 8) < 1)
      goto LABEL_301;
    v282 = 0;
    while (1)
    {
      v283 = (uint64_t)this[9] + 32 * v282;
      v284 = *(_DWORD *)(v283 + 20);
      if (*(int *)(v283 + 16) < 1)
      {
        if (v284 <= 0)
        {
          v285 = this[7];
LABEL_287:
          v285[16 * (uint64_t)v282] = 0;
          Shape::SubEdge((Shape *)this, v282--);
          goto LABEL_288;
        }
        Shape::Inverse((Shape *)this, v282);
        v285 = this[7];
      }
      else
      {
        v285 = this[7];
        if (v284 > 0)
          goto LABEL_287;
      }
      v285[16 * (uint64_t)v282] = 1;
LABEL_288:
      if (++v282 >= *((_DWORD *)this + 8))
        goto LABEL_301;
    }
  }
  v277 = *((_DWORD *)this + 8);
  if (v293 != 1)
  {
    if (v277 < 1)
      goto LABEL_301;
    v286 = 0;
    while (1)
    {
      v287 = (uint64_t)this[9] + 32 * v286;
      v288 = *(_DWORD *)(v287 + 20);
      if (*(int *)(v287 + 16) < 1)
      {
        if (v288 <= 0)
        {
          v289 = this[7];
LABEL_299:
          v289[16 * (uint64_t)v286] = 0;
          Shape::SubEdge((Shape *)this, v286--);
          goto LABEL_300;
        }
        Shape::Inverse((Shape *)this, v286);
        v289 = this[7];
      }
      else
      {
        v289 = this[7];
        if (v288 > 0)
          goto LABEL_299;
      }
      v289[16 * (uint64_t)v286] = 1;
LABEL_300:
      if (++v286 >= *((_DWORD *)this + 8))
        goto LABEL_301;
    }
  }
  if (v277 >= 1)
  {
    for (i = 0; i < *((_DWORD *)this + 8); ++i)
    {
      v279 = (uint64_t)this[9] + 32 * i;
      v280 = *(_DWORD *)(v279 + 20);
      if (*(int *)(v279 + 16) < 2)
      {
        if (v280 <= 1)
        {
          v281 = this[7];
LABEL_275:
          v281[16 * (uint64_t)i] = 0;
          Shape::SubEdge((Shape *)this, i--);
          continue;
        }
        Shape::Inverse((Shape *)this, i);
        v281 = this[7];
      }
      else
      {
        v281 = this[7];
        if (v280 > 1)
          goto LABEL_275;
      }
      v281[16 * (uint64_t)i] = 1;
    }
  }
LABEL_301:
  if (Shape::GetFlag((Shape *)this, 64))
  {
    SweepTree::DestroyList(v297);
    SweepEvent::DestroyQueue(v302);
    Shape::SetFlag((Shape *)this, 64, 0);
  }
  Shape::MakePointData((Shape *)this, 0);
  Shape::MakeEdgeData((Shape *)this, 0);
  Shape::MakeSweepSrcData((Shape *)this, 0);
  Shape::MakeSweepDestData((Shape *)this, 0);
  Shape::CleanupSweep(v291);
  Shape::CleanupSweep((Shape *)v7);
  if (Shape::Eulerian((Shape *)this, 1))
  {
    result = 0;
    *((_DWORD *)this + 12) = 1;
  }
  else
  {
    *((_DWORD *)this + 8) = 0;
    *((_DWORD *)this + 4) = 0;
    return 4;
  }
  return result;
}

uint64_t Shape::TesteIntersection(double a1, double a2, double a3, int32x4_t a4, int32x4_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float *a9, float *a10, float *a11, float *a12, char a13)
{
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  signed __int32 v16;
  signed __int32 v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  __int32 v21;
  __int32 v22;
  uint64_t v23;
  uint64_t v24;
  signed __int32 v25;
  signed __int32 v26;
  __int32 v27;
  __int32 v28;
  uint64_t v29;
  float v30;
  float v31;
  uint64_t v32;
  float v33;
  float v34;
  float64x2_t v39;
  float64x2_t v40;
  int8x16_t v41;
  int32x4_t v42;
  int8x16_t v43;
  int8x16_t v44;
  double v45;
  uint64_t result;
  uint64_t v48;
  float *v49;
  float v50;
  float v51;
  float v52;
  uint64_t v53;
  float *v54;
  float v55;
  float v56;
  float v57;
  double v58;
  uint64_t v59;
  float *v60;
  float v61;
  float v62;
  double v63;
  double v64;
  double v65;
  uint64_t v66;
  float *v67;
  float v68;
  float v69;
  double v70;
  double v71;
  double v72;
  float v73;
  float v75;
  double v76;
  float v77;
  double v78;
  double v79;
  float v80;
  float v81;
  float v82;

  v13 = *(_QWORD **)(a7 + 64);
  v14 = *(int *)(a7 + 72);
  v15 = v13[5] + 32 * v14;
  v16 = *(_DWORD *)(v15 + 8);
  v17 = *(_DWORD *)(v15 + 12);
  v18 = *(_QWORD **)(a8 + 64);
  v19 = *(int *)(a8 + 72);
  v20 = v18[5] + 32 * v19;
  v21 = *(_DWORD *)(v20 + 8);
  v22 = *(_DWORD *)(v20 + 12);
  v23 = v13[7];
  v24 = v18[7];
  if (v16 >= v17)
    v25 = v16;
  else
    v25 = v17;
  if (v16 >= v17)
    v26 = v17;
  else
    v26 = v16;
  if (v21 >= v22)
    v27 = v21;
  else
    v27 = v22;
  if (v21 >= v22)
    v28 = v22;
  else
    v28 = v21;
  v29 = v13[11];
  v30 = *(float *)(v29 + 48 * v26 + 36);
  v31 = *(float *)(v29 + 48 * v25 + 36);
  v32 = v18[11];
  v33 = *(float *)(v32 + 48 * v28 + 36);
  v34 = *(float *)(v32 + 48 * v27 + 36);
  if (v30 >= v31)
  {
    if (v33 >= v34)
    {
      if (v31 > v33 || v30 < v34)
        return 0;
    }
    else if (v30 < v33 || v31 > v34)
    {
      return 0;
    }
  }
  else if (v33 >= v34)
  {
    if (v30 > v33 || v31 < v34)
      return 0;
  }
  else if (v31 < v33 || v30 > v34)
  {
    return 0;
  }
  v39 = vcvtq_f64_f32(*(float32x2_t *)(v23 + (v14 << 6) + 4));
  v40 = vcvtq_f64_f32(*(float32x2_t *)(v24 + (v19 << 6) + 4));
  a4.i32[0] = v16;
  a5.i32[0] = v17;
  v41 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a5, a4), 0);
  v42 = (int32x4_t)vnegq_f64(v39);
  v43 = vbslq_s8(v41, (int8x16_t)v39, (int8x16_t)v42);
  LODWORD(v39.f64[0]) = v21;
  v42.i32[0] = v22;
  v44 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v42, (int32x4_t)v39), 0), (int8x16_t)v40, (int8x16_t)vnegq_f64(v40));
  v45 = -*(double *)&v43.i64[1];
  if (vmlad_n_f64(-*(double *)&v43.i64[1] * *(double *)v44.i64, *(double *)&v44.i64[1], *(double *)v43.i64) <= 0.0)
    return 0;
  if (v13 == v18 && v26 == v28)
  {
    if (v25 != v27)
    {
      *a9 = v30;
      *a10 = *(float *)(v29 + 48 * v26 + 40);
      *a11 = -1.0;
      *a12 = -1.0;
      return 1;
    }
    return 0;
  }
  if (v25 == v27)
    a13 = 1;
  if (v13 == v18 && (a13 & 1) != 0)
    return 0;
  v48 = v29 + 48 * v16;
  v50 = *(float *)(v48 + 40);
  v49 = (float *)(v48 + 40);
  v51 = v50;
  v52 = *(v49 - 1);
  v53 = v32 + 48 * v21;
  v55 = *(float *)(v53 + 40);
  v54 = (float *)(v53 + 40);
  v56 = v55;
  v57 = *(v54 - 1);
  v58 = (float)(v51 - v55);
  v59 = v29 + 48 * v17;
  v61 = *(float *)(v59 + 40);
  v60 = (float *)(v59 + 40);
  v62 = *(v60 - 1);
  v63 = *(double *)v44.i64 * v58 - *(double *)&v44.i64[1] * (float)(v52 - v57);
  v64 = *(double *)v44.i64 * (float)(v61 - v56) - *(double *)&v44.i64[1] * (float)(v62 - v57);
  v65 = (float)(v56 - v51);
  v66 = v32 + 48 * v22;
  v68 = *(float *)(v66 + 40);
  v67 = (float *)(v66 + 40);
  v69 = *(v67 - 1);
  v70 = v45 * (float)(v57 - v52) + *(double *)v43.i64 * v65;
  v71 = v45 * (float)(v69 - v52) + *(double *)v43.i64 * (float)(v68 - v51);
  if ((v63 < 0.0 || v64 < 0.0) && (v63 > 0.0 || v64 > 0.0))
  {
    if ((v70 < 0.0 || v71 < 0.0) && (v70 > 0.0 || v71 > 0.0))
    {
      if (*(double *)(v23 + (v14 << 6) + 48) <= *(double *)(v24 + (v19 << 6) + 48))
      {
        v79 = v63 - v64;
        v80 = (v63 * v62 - v64 * v52) / (v63 - v64);
        *a9 = v80;
        v78 = (v63 * *v60 - v64 * *v49) / (v63 - v64);
        v76 = v70 - v71;
      }
      else
      {
        v76 = v70 - v71;
        v77 = (v70 * v69 - v71 * v57) / (v70 - v71);
        *a9 = v77;
        v78 = (v70 * *v67 - v71 * *v54) / (v70 - v71);
        v79 = v63 - v64;
      }
      v81 = v78;
      *a10 = v81;
      v82 = v63 / v79;
      *a11 = v82;
      v72 = v70 / v76;
      goto LABEL_59;
    }
    if (v70 == 0.0)
    {
LABEL_66:
      if (v21 >= v22)
        return 0;
      goto LABEL_67;
    }
    if (v71 == 0.0)
    {
      if (v21 <= v22)
        return 0;
      goto LABEL_79;
    }
    if (v16 < v17 && v70 > 0.0 && v71 > 0.0)
    {
      if (v70 >= v71)
      {
        if (v22 < v21)
          goto LABEL_79;
      }
      else if (v21 < v22)
      {
LABEL_67:
        *a9 = v57;
        *a10 = *v54;
        *a12 = 0.0;
LABEL_80:
        v75 = v63 / (v63 - v64);
        *a11 = v75;
        return 1;
      }
    }
    result = 0;
    if (v17 >= v16 || v70 >= 0.0 || v71 >= 0.0)
      return result;
    if (v70 > v71)
      goto LABEL_66;
    if (v22 >= v21)
      return 0;
LABEL_79:
    *a9 = v69;
    *a10 = *v67;
    *a12 = 1.0;
    goto LABEL_80;
  }
  if (v63 == 0.0)
    goto LABEL_53;
  if (v64 == 0.0)
  {
    if (v16 <= v17)
      return 0;
    goto LABEL_57;
  }
  if (v63 > 0.0 && v64 > 0.0 && v22 < v21)
  {
    if (v63 >= v64)
    {
      if (v17 < v16)
        goto LABEL_57;
    }
    else if (v16 < v17)
    {
LABEL_54:
      *a9 = v52;
      *a10 = *v49;
      *a11 = 0.0;
LABEL_58:
      v72 = v70 / (v70 - v71);
LABEL_59:
      v73 = v72;
      *a12 = v73;
      return 1;
    }
  }
  result = 0;
  if (v21 < v22 && v63 < 0.0 && v64 < 0.0)
  {
    if (v63 > v64)
    {
LABEL_53:
      if (v16 >= v17)
        return 0;
      goto LABEL_54;
    }
    if (v17 >= v16)
      return 0;
LABEL_57:
    *a9 = v62;
    *a10 = *v60;
    *a11 = 1.0;
    goto LABEL_58;
  }
  return result;
}

uint64_t Shape::PushIncidence(Shape *this, Shape *a2, int a3, int a4, float a5)
{
  uint64_t result;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;

  if (a5 < 0.0 || a5 > 1.0)
    return 0xFFFFFFFFLL;
  result = *((unsigned int *)this + 38);
  if ((int)result >= *((_DWORD *)this + 39))
  {
    v13 = (2 * (int)result) | 1;
    *((_DWORD *)this + 39) = v13;
    v12 = (char *)malloc_type_realloc(*((void **)this + 20), 12 * v13, 0x10000403E1C8BA9uLL);
    *((_QWORD *)this + 20) = v12;
    result = *((unsigned int *)this + 38);
  }
  else
  {
    v12 = (char *)*((_QWORD *)this + 20);
  }
  *((_DWORD *)this + 38) = result + 1;
  v14 = *((_QWORD *)a2 + 8) + 56 * a3;
  v15 = &v12[12 * (int)result];
  *(_DWORD *)v15 = *(_DWORD *)(v14 + 8);
  *((_DWORD *)v15 + 1) = a4;
  *((float *)v15 + 2) = a5;
  *(_DWORD *)(v14 + 8) = result;
  return result;
}

uint64_t Shape::CreateIncidence(Shape *this, Shape *a2, int a3, int a4)
{
  uint64_t v4;
  float *v5;
  uint64_t v6;
  float v7;

  v4 = *((_QWORD *)a2 + 7) + ((uint64_t)a3 << 6);
  v5 = (float *)(*((_QWORD *)this + 3) + 28 * a4);
  v6 = *((_QWORD *)a2 + 11) + 48 * *(int *)(*((_QWORD *)a2 + 5) + 32 * a3 + 8);
  v7 = *(double *)(v4 + 32)
     * (*(float *)(v4 + 8) * (float)(v5[1] - *(float *)(v6 + 40))
      + (float)(*v5 - *(float *)(v6 + 36)) * *(float *)(v4 + 4));
  return Shape::PushIncidence(this, a2, a3, a4, v7);
}

uint64_t Shape::Winding(Shape *this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(unsigned int *)(*((_QWORD *)this + 11) + 48 * a2 + 32);
  if ((v2 & 0x80000000) != 0)
    return 0;
  v3 = *((_QWORD *)this + 5) + 32 * v2;
  v4 = *((_QWORD *)this + 9) + 32 * v2;
  if (*(_DWORD *)(v3 + 8) >= *(_DWORD *)(v3 + 12))
    return *(unsigned int *)(v4 + 20);
  else
    return *(unsigned int *)(v4 + 16);
}

uint64_t Shape::Winding(Shape *this, float a2, float a3)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  float *v8;
  int *v9;
  uint64_t v10;
  float v11;
  float v12;
  uint64_t v13;
  float v14;
  float v15;
  int v16;
  int v20;
  int v21;
  double v22;
  int v23;

  v3 = *((unsigned int *)this + 8);
  if ((int)v3 < 1)
    return 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = *((_QWORD *)this + 11);
  v8 = (float *)(*((_QWORD *)this + 7) + 8);
  v9 = (int *)(*((_QWORD *)this + 5) + 12);
  do
  {
    v10 = v7 + 48 * *(v9 - 1);
    v11 = *(float *)(v10 + 36);
    v12 = *(float *)(v10 + 40);
    v13 = v7 + 48 * *v9;
    v15 = *(float *)(v13 + 36);
    v14 = *(float *)(v13 + 40);
    v16 = *((_DWORD *)v8 - 2);
    if (v11 >= v15)
    {
      if (v11 < a2 || v15 > a2)
        goto LABEL_39;
    }
    else if (v11 > a2 || v15 < a2)
    {
      goto LABEL_39;
    }
    if (v11 == a2)
    {
      if (v12 < a3 && v15 != a2)
      {
        if (v15 >= a2)
          v20 = *((_DWORD *)v8 - 2);
        else
          v20 = 0;
        if (v15 >= a2)
          v16 = 0;
        v6 -= v20;
        v5 += v16;
      }
    }
    else if (v15 == a2)
    {
      if (v14 < a3)
      {
        if (v11 >= a2)
          v21 = *((_DWORD *)v8 - 2);
        else
          v21 = 0;
        v6 += v21;
        if (v11 >= a2)
          v16 = 0;
        v5 -= v16;
      }
    }
    else
    {
      if (v12 >= v14)
      {
        if (v14 >= a3)
          goto LABEL_39;
      }
      else if (v12 >= a3)
      {
        goto LABEL_39;
      }
      v22 = *(v8 - 1) * (a3 - v12) - (a2 - v11) * *v8;
      if (v22 != 0.0)
      {
        if (v22 >= 0.0)
        {
          if (v11 < a2)
            v4 -= v16;
        }
        else if (v11 > a2)
        {
          v4 += v16;
        }
      }
    }
LABEL_39:
    v8 += 16;
    v9 += 8;
    --v3;
  }
  while (v3);
  v23 = v5 + v6;
  if (v5 + v6 < 0 != __OFADD__(v5, v6))
    ++v23;
  return (v4 + (v23 >> 1));
}

unsigned int *Shape::AssemblePoints(unsigned int *this, Shape *a2)
{
  uint64_t v2;
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;

  v2 = this[4];
  if ((int)v2 >= 1)
  {
    v4 = this;
    this = (unsigned int *)Shape::AssemblePoints((Shape *)this, 0, v2);
    v5 = *((unsigned int *)a2 + 8);
    if ((int)v5 >= 1)
    {
      v6 = *((_QWORD *)v4 + 11);
      v7 = (int *)(*((_QWORD *)a2 + 8) + 16);
      do
      {
        *(v7 - 1) = *(_DWORD *)(v6 + 48 * *(v7 - 1) + 4);
        *v7 = *(_DWORD *)(v6 + 48 * *v7 + 4);
        v7 += 14;
        --v5;
      }
      while (v5);
    }
    v8 = v4[38];
    if ((int)v8 >= 1)
    {
      v9 = *((_QWORD *)v4 + 11);
      v10 = (int *)(*((_QWORD *)v4 + 20) + 4);
      do
      {
        *v10 = *(_DWORD *)(v9 + 48 * *v10 + 4);
        v10 += 3;
        --v8;
      }
      while (v8);
    }
    v4[4] = this;
  }
  return this;
}

uint64_t Shape::TesteIntersection(Shape *this, Shape *a2, Shape *a3, int a4, int a5, float *a6, float *a7, float *a8, float *a9, BOOL a10)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v16;
  uint64_t v18;
  uint64_t v19;
  float32x2_t v20;
  uint64_t v21;
  float32x2_t v22;
  uint64_t v23;
  uint64_t v24;
  float32x2_t v25;
  uint64_t v26;
  float32x2_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int32x4_t v30;
  int8x8_t v31;
  int8x16_t v32;
  int8x16_t v33;
  uint64_t v34;
  float v35;
  float v36;
  uint64_t v37;
  double v38;
  double v39;
  float32x2_t v40;
  double v41;
  double v42;
  double v43;
  double v44;
  float32x2_t v45;
  double v46;
  double v47;
  double v49;
  double v50;
  double v51;
  double v52;
  float *v53;
  float *v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  float v60;
  float v61;
  float v62;
  float v63;

  v10 = *((_QWORD *)a2 + 5) + 32 * a4;
  v11 = *(_DWORD *)(v10 + 8);
  v12 = *((_QWORD *)a3 + 5) + 32 * a5;
  v13 = *(_DWORD *)(v12 + 8);
  v14 = *(_DWORD *)(v12 + 12);
  if (v11 == v13 || v11 == v14)
    return 0;
  v16 = *(_DWORD *)(v10 + 12);
  if (v16 == v13 || v16 == v14)
    return 0;
  v18 = *((_QWORD *)a2 + 11);
  v19 = v18 + 48 * v11;
  v20 = *(float32x2_t *)(v19 + 36);
  v21 = v18 + 48 * v16;
  v22 = *(float32x2_t *)(v21 + 36);
  v23 = *((_QWORD *)a3 + 11);
  v24 = v23 + 48 * v13;
  v25 = *(float32x2_t *)(v24 + 36);
  v26 = v23 + 48 * v14;
  v27 = *(float32x2_t *)(v26 + 36);
  *(float32x2_t *)v28.f32 = v20;
  *(float32x2_t *)&v28.u32[2] = v25;
  *(float32x2_t *)v29.f32 = v22;
  *(float32x2_t *)&v29.u32[2] = v27;
  v30 = vcgtq_f32(v28, v29);
  v31 = (int8x8_t)vmovn_s32(v30);
  *(float32x2_t *)v32.i8 = v27;
  v32.u64[1] = (unint64_t)v22;
  *(float32x2_t *)v33.i8 = v25;
  v33.u64[1] = (unint64_t)v20;
  if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vcgtq_f32((float32x4_t)vbslq_s8((int8x16_t)vmovl_s16((int16x4_t)vext_s8(v31, v31, 4uLL)), v32, v33), (float32x4_t)vbslq_s8((int8x16_t)v30, (int8x16_t)v28, (int8x16_t)v29))), 0xFuLL))) & 1) != 0)return 0;
  v34 = *((_QWORD *)a2 + 7) + ((uint64_t)a4 << 6);
  v35 = *(float *)(v34 + 4);
  v36 = *(float *)(v34 + 8);
  v37 = *((_QWORD *)a3 + 7) + ((uint64_t)a5 << 6);
  v38 = *(float *)(v37 + 8);
  v39 = *(float *)(v37 + 4);
  v40 = vsub_f32(v22, v25);
  v41 = v39 * (float)(v20.f32[1] - v25.f32[1]) - v38 * vsub_f32(v20, v25).f32[0];
  v42 = v39 * v40.f32[1] - v38 * v40.f32[0];
  if (v41 >= 0.0 && v42 >= 0.0)
    return 0;
  if (v41 <= 0.0 && v42 <= 0.0)
    return 0;
  v43 = v35;
  v44 = v36;
  v45 = vsub_f32(v27, v20);
  v46 = v35 * (float)(v25.f32[1] - v20.f32[1]) - v44 * vsub_f32(v25, v20).f32[0];
  v47 = v43 * v45.f32[1] - v44 * v45.f32[0];
  if (v46 >= 0.0 && v47 >= 0.0)
    return 0;
  if (v46 <= 0.0 && v47 <= 0.0)
    return 0;
  v49 = v46 - v47;
  v50 = v41 - v42;
  v51 = -(v46 - v47);
  if (v46 - v47 >= 0.0)
    v51 = v46 - v47;
  v52 = -v50;
  if (v50 >= 0.0)
    v52 = v41 - v42;
  if (v51 <= v52)
  {
    v53 = (float *)(v19 + 40);
    v54 = (float *)(v21 + 40);
    v59 = v20.f32[0];
    v55 = -v42;
    v56 = (v41 * v22.f32[0] - v42 * v59) / v50;
    v57 = v41;
    v58 = v41 - v42;
  }
  else
  {
    v53 = (float *)(v24 + 40);
    v54 = (float *)(v26 + 40);
    v55 = -v47;
    v56 = (v46 * v27.f32[0] - v47 * v25.f32[0]) / v49;
    v57 = v46;
    v58 = v46 - v47;
  }
  v60 = v56;
  *a6 = v60;
  v61 = (v55 * *v53 + v57 * *v54) / v58;
  *a7 = v61;
  v62 = v41 / v50;
  *a8 = v62;
  v63 = v46 / v49;
  *a9 = v63;
  return 1;
}

BOOL Shape::TesteAdjacency(Shape *this, Shape *a2, int a3, float a4, float a5, int a6, int a7)
{
  uint64_t v7;
  uint64_t v13;
  uint64_t v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  float v21;
  float v22;
  _BOOL8 result;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  _BOOL4 v37;
  float v38;

  v7 = *((_QWORD *)a2 + 8);
  if (*(_DWORD *)(v7 + 56 * a3 + 12) == a6 || *(_DWORD *)(v7 + 56 * a3 + 16) == a6)
    return 0;
  v13 = *((_QWORD *)a2 + 11) + 48 * *(int *)(*((_QWORD *)a2 + 5) + 32 * a3 + 8);
  v14 = *((_QWORD *)a2 + 7) + ((uint64_t)a3 << 6);
  v15 = *(float *)(v14 + 4);
  v16 = *(float *)(v14 + 8);
  v17 = *(double *)(v14 + 16);
  v18 = a4 - *(float *)(v13 + 36);
  v19 = a5 - *(float *)(v13 + 40);
  v20 = *(double *)(v14 + 32);
  v21 = (v15 * v19 - v18 * v16) * *(double *)(v14 + 40);
  v22 = ldexpf(v21, 5);
  if (v22 <= -3.0 || v22 >= 3.0)
    return 0;
  v25 = ldexpf(0.505, -5);
  v26 = v18 - v25;
  v27 = v19 - v25;
  v28 = v18 + v25;
  v29 = v19 + v25;
  v30 = -(v26 * v16);
  v31 = v30 + v15 * v27;
  v32 = -(v28 * v16);
  v33 = v32 + v15 * v29;
  if (v31 < 0.0 && v33 > 0.0
    || v31 > 0.0 && v33 < 0.0
    || (v34 = v32 + v15 * v27, v35 = v30 + v15 * v29, v34 < 0.0) && v35 > 0.0
    || (result = 0, v34 > 0.0) && v35 < 0.0)
  {
    v36 = v19 * v16 + v18 * v15;
    v37 = v36 <= 0.0;
    if (v36 >= v17)
      v37 = 1;
    result = !v37;
    if (!v37)
    {
      if (a7)
      {
        v38 = v20 * v36;
        Shape::PushIncidence(this, a2, a3, a6, v38);
        return 1;
      }
    }
  }
  return result;
}

uint64_t Shape::Validate(uint64_t this)
{
  Shape *v1;
  uint64_t v2;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  int v6;
  uint64_t *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  float v14;
  float v15;
  uint64_t v16;

  v1 = (Shape *)this;
  v2 = *(unsigned int *)(this + 16);
  if ((int)v2 >= 1)
  {
    v3 = *(uint64_t **)(this + 24);
    v4 = (_QWORD *)(*(_QWORD *)(this + 88) + 36);
    do
    {
      v5 = *v3;
      v3 = (uint64_t *)((char *)v3 + 28);
      *v4 = v5;
      v4 += 6;
      --v2;
    }
    while (v2);
  }
  v6 = *(_DWORD *)(this + 32);
  if (v6 >= 1)
  {
    v7 = *(uint64_t **)(this + 40);
    v8 = (_QWORD *)(*(_QWORD *)(this + 56) + 4);
    v9 = *(unsigned int *)(this + 32);
    do
    {
      v10 = *v7;
      v7 += 4;
      *v8 = v10;
      v8 += 8;
      --v9;
    }
    while (v9);
    v11 = 0;
    do
    {
      v12 = v11++;
      if (v11 < v6)
      {
        v13 = v11;
        do
        {
          v16 = 0;
          this = Shape::TesteIntersection((Shape *)this, v1, v1, v12, v13, (float *)&v16 + 1, (float *)&v16, &v15, &v14, 0);
          if ((_DWORD)this)
          {
            this = printf("%i %i  %f %f \n", v12, v13, *((float *)&v16 + 1), *(float *)&v16);
            v6 = *((_DWORD *)v1 + 8);
          }
          ++v13;
        }
        while (v13 < v6);
      }
    }
    while (v11 < v6);
  }
  return this;
}

void Shape::Avance(uint64_t a1, signed int a2, int a3, Shape *a4, int a5, uint64_t a6, Shape *a7, int a8)
{
  float v15;
  _BOOL4 v17;
  uint64_t v18;
  int v19;
  _DWORD *v20;
  float v21;
  signed int v22;
  int v23;
  unsigned int v24;
  _BOOL4 v25;
  uint64_t v26;
  float v27;
  BOOL v28;
  int v29;
  float v30;
  int v31;
  signed int v32;
  _BOOL4 v33;
  uint64_t v34;
  float v35;
  BOOL v36;
  Shape *v37;
  Shape *v38;
  int v39;
  unsigned int v40;
  int v41;
  BOOL v43;
  signed int v44;
  _BOOL4 v45;
  uint64_t v46;
  float v47;
  Shape *v48;
  Shape *v49;
  int v50;
  unsigned int v51;
  int v52;
  BOOL v54;
  signed int v55;
  _BOOL4 v56;
  uint64_t v57;
  float v58;
  Shape *v59;
  Shape *v60;
  int v61;
  unsigned int v62;
  int v63;
  signed int v64;
  signed int v65;
  _BOOL4 v66;
  uint64_t v67;
  float v68;
  BOOL v69;
  Shape *v70;
  Shape *v71;
  int v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  signed int v76;
  BOOL v77;
  BOOL v78;
  signed int v79;

  v15 = ldexpf(1.0, -5);
  v17 = a4 != a7 || (a8 & 0xFFFFFFFE) != 2;
  v18 = *((_QWORD *)a4 + 8);
  v19 = a5;
  v20 = (_DWORD *)(v18 + 56 * a5);
  if (v20[12] < a3)
  {
    v21 = v15;
    v23 = v20[6];
    v22 = v20[7];
    v24 = *(_DWORD *)(v18 + 56 * a5 + 44);
    v25 = (v24 & 0x80000000) == 0
       && (float)(v15 + *(float *)(*(_QWORD *)(a1 + 24) + 28 * v24 + 4)) == *(float *)(*(_QWORD *)(a1 + 24)
                                                                                       + 28 * a3
                                                                                       + 4);
    v26 = *((_QWORD *)a4 + 7) + ((uint64_t)a5 << 6);
    v27 = *(float *)(v26 + 8);
    v28 = v27 <= 0.0;
    if (v27 == 0.0)
    {
      if (*(float *)(v26 + 4) >= 0.0)
      {
        v19 = a5;
        if (v23 <= v22)
        {
          v29 = a5;
          do
            Shape::DoEdgeTo((Shape *)a1, a4, a5, v23++, v17, 1);
          while (v22 + 1 != v23);
          goto LABEL_41;
        }
      }
      else
      {
        v19 = a5;
        if (v23 <= v22)
        {
          v29 = a5;
          do
            Shape::DoEdgeTo((Shape *)a1, a4, a5, v23++, v17, 0);
          while (v22 + 1 != v23);
LABEL_41:
          v24 = v22;
          v19 = v29;
        }
      }
LABEL_103:
      v18 = *((_QWORD *)a4 + 8);
      *(_DWORD *)(v18 + 56 * v19 + 44) = v24;
      goto LABEL_104;
    }
    v30 = *(float *)(v26 + 4);
    if (v28)
    {
      if (v30 >= 0.0)
      {
        if (v22 >= v23)
        {
          v76 = a2;
          v63 = 0;
          v64 = v22 + 1;
          do
          {
            v65 = v24;
            v24 = v22 + v63;
            if (v63)
              v66 = 0;
            else
              v66 = v25;
            if (v66
              && (v67 = *(_QWORD *)(a1 + 24),
                  v68 = *(float *)(v67 + 28 * v65),
                  *(float *)(v67 + 28 * v22) == (float)(v68 - v21)))
            {
              v69 = v22 < *(_DWORD *)(a1 + 16) && v64 < a2;
              if (v69 && *(float *)(v67 + 28 * v64) == v68)
                Shape::DoEdgeTo((Shape *)a1, a4, a5, v22 + 1, v17, 0);
              v70 = (Shape *)a1;
              v71 = a4;
              v72 = a5;
              v73 = v22;
            }
            else
            {
              v70 = (Shape *)a1;
              v71 = a4;
              v72 = a5;
              v73 = v22 + v63;
            }
            Shape::DoEdgeTo(v70, v71, v72, v73, v17, 0);
            v64 = v22 + 1;
            --v63;
          }
          while (v22 + v63 + 1 > v23);
          goto LABEL_100;
        }
LABEL_102:
        v19 = a5;
        goto LABEL_103;
      }
      if (v23 > v22)
        goto LABEL_102;
      v76 = a2;
      v41 = 0;
      v74 = v23 - 1;
      v43 = v23 < 1 || v23 <= a3;
      v77 = v43;
      do
      {
        v44 = v24;
        v24 = v23 + v41;
        if (v41)
          v45 = 0;
        else
          v45 = v25;
        if (v45
          && (v46 = *(_QWORD *)(a1 + 24),
              v47 = *(float *)(v46 + 28 * v44),
              *(float *)(v46 + 28 * v23) == (float)(v21 + v47)))
        {
          if (!v77 && *(float *)(v46 + 28 * v74) == v47)
            Shape::DoEdgeTo((Shape *)a1, a4, a5, v74, v17, 0);
          v48 = (Shape *)a1;
          v49 = a4;
          v50 = a5;
          v51 = v23;
        }
        else
        {
          v48 = (Shape *)a1;
          v49 = a4;
          v50 = a5;
          v51 = v23 + v41;
        }
        Shape::DoEdgeTo(v48, v49, v50, v51, v17, 0);
        ++v41;
      }
      while (v22 - v23 + 1 != v41);
    }
    else
    {
      if (v30 < 0.0)
      {
        if (v22 >= v23)
        {
          v76 = a2;
          v31 = 0;
          v79 = v22 + 1;
          do
          {
            v32 = v24;
            v24 = v22 + v31;
            if (v31)
              v33 = 0;
            else
              v33 = v25;
            if (v33
              && (v34 = *(_QWORD *)(a1 + 24),
                  v35 = *(float *)(v34 + 28 * v32),
                  *(float *)(v34 + 28 * v22) == (float)(v35 - v21)))
            {
              v36 = v22 < *(_DWORD *)(a1 + 16) && v79 < a2;
              if (v36 && *(float *)(v34 + 28 * v79) == v35)
                Shape::DoEdgeTo((Shape *)a1, a4, a5, v79, v17, 1);
              v37 = (Shape *)a1;
              v38 = a4;
              v39 = a5;
              v40 = v22;
            }
            else
            {
              v37 = (Shape *)a1;
              v38 = a4;
              v39 = a5;
              v40 = v22 + v31;
            }
            Shape::DoEdgeTo(v37, v38, v39, v40, v17, 1);
            --v31;
          }
          while (v22 + v31 + 1 > v23);
LABEL_100:
          v24 = v23;
          goto LABEL_101;
        }
        goto LABEL_102;
      }
      if (v23 > v22)
        goto LABEL_102;
      v76 = a2;
      v52 = 0;
      v75 = v23 - 1;
      v54 = v23 < 1 || v23 <= a3;
      v78 = v54;
      do
      {
        v55 = v24;
        v24 = v23 + v52;
        if (v52)
          v56 = 0;
        else
          v56 = v25;
        if (v56
          && (v57 = *(_QWORD *)(a1 + 24),
              v58 = *(float *)(v57 + 28 * v55),
              *(float *)(v57 + 28 * v23) == (float)(v21 + v58)))
        {
          if (!v78 && *(float *)(v57 + 28 * v75) == v58)
            Shape::DoEdgeTo((Shape *)a1, a4, a5, v75, v17, 1);
          v59 = (Shape *)a1;
          v60 = a4;
          v61 = a5;
          v62 = v23;
        }
        else
        {
          v59 = (Shape *)a1;
          v60 = a4;
          v61 = a5;
          v62 = v23 + v52;
        }
        Shape::DoEdgeTo(v59, v60, v61, v62, v17, 1);
        ++v52;
      }
      while (v22 - v23 + 1 != v52);
    }
    v24 = v22;
LABEL_101:
    a2 = v76;
    goto LABEL_102;
  }
LABEL_104:
  *(_DWORD *)(v18 + 56 * v19 + 48) = a2 - 1;
}

uint64_t Shape::DoEdgeTo(Shape *this, Shape *a2, int a3, unsigned int a4, int a5, int a6)
{
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t result;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const float *v18;
  float32x2_t v19;
  float v20;
  uint64_t v21;
  float v22;
  float v23;
  float v24;
  float v25;
  uint64_t v26;
  uint64_t v27;
  float *v28;
  float *v29;
  float v30;
  float v31;
  uint64_t v32;
  float v33;
  float v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;

  v9 = a3;
  v10 = *((_QWORD *)a2 + 8) + 56 * a3;
  v11 = *(_DWORD *)(v10 + 44);
  if (a6)
  {
    if (!a5)
    {
LABEL_3:
      v12 = a4;
      goto LABEL_6;
    }
  }
  else if (a5)
  {
    goto LABEL_3;
  }
  v12 = *(_DWORD *)(v10 + 44);
  v11 = a4;
LABEL_6:
  result = Shape::AddEdge(this, v12, v11);
  if ((result & 0x80000000) != 0)
  {
    *(_DWORD *)(*((_QWORD *)a2 + 8) + 56 * (int)v9 + 44) = a4;
  }
  else
  {
    if ((*((_BYTE *)this + 53) & 2) != 0)
    {
      v15 = *((_QWORD *)a2 + 12);
      v16 = *((_QWORD *)this + 12);
      v14 = result;
      *(_QWORD *)(v16 + 16 * result) = *(_QWORD *)(v15 + 16 * v9);
      v17 = *((_QWORD *)a2 + 7) + (v9 << 6);
      if (*(double *)(v17 + 16) >= 0.00001)
      {
        v20 = *(double *)(v17 + 32);
        v21 = *((_QWORD *)a2 + 11) + 48 * *(int *)(*((_QWORD *)a2 + 5) + 32 * v9 + 8);
        v22 = *(float *)(v21 + 36);
        v23 = *(float *)(v21 + 40);
        v24 = *(float *)(v17 + 4);
        v25 = *(float *)(v17 + 8);
        v26 = *((_QWORD *)this + 3);
        v27 = *((_QWORD *)this + 5) + 32 * result;
        v28 = (float *)(v26 + 28 * *(int *)(v27 + 8));
        v29 = (float *)(v26 + 28 * *(int *)(v27 + 12));
        v30 = (float)((float)(v25 * (float)(v28[1] - v23)) + (float)((float)(*v28 - v22) * v24)) * v20;
        v31 = (float)((float)(v25 * (float)(v29[1] - v23)) + (float)((float)(*v29 - v22) * v24)) * v20;
        v32 = v15 + 16 * v9;
        v33 = *(float *)(v32 + 8);
        v34 = *(float *)(v32 + 12);
        v35 = v16 + 16 * result;
        *(float *)(v35 + 8) = (float)(v30 * v34) + (float)(v33 * (float)(1.0 - v30));
        *(float *)(v35 + 12) = (float)(v34 * v31) + (float)(v33 * (float)(1.0 - v31));
      }
      else
      {
        v18 = (const float *)(v15 + 16 * v9 + 8);
        v19 = vld1_dup_f32(v18);
        *(float32x2_t *)(v16 + 16 * result + 8) = v19;
      }
    }
    else
    {
      v14 = result;
    }
    v36 = *((_QWORD *)a2 + 8) + 56 * (int)v9;
    v39 = *(_DWORD *)(v36 + 8);
    v37 = (_DWORD *)(v36 + 8);
    v38 = v39;
    v37[9] = a4;
    *(_DWORD *)(*((_QWORD *)this + 8) + 56 * v14 + 8) = v39;
    if ((v39 & 0x80000000) == 0)
    {
      v40 = *((_QWORD *)this + 11);
      do
      {
        v41 = v40 + 48 * v38;
        *(_DWORD *)(v41 + 32) = result;
        v38 = *(unsigned int *)(v41 + 16);
      }
      while ((v38 & 0x80000000) == 0);
    }
    *v37 = -1;
  }
  return result;
}

void SweepEvent::~SweepEvent(SweepEvent *this)
{
  SweepEvent::MakeDelete((uint64_t *)this);
}

{
  SweepEvent::MakeDelete((uint64_t *)this);
}

uint64_t *SweepEvent::MakeDelete(uint64_t *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;

  v1 = *this;
  if (*this)
  {
    v2 = *(_QWORD *)(v1 + 64);
    v3 = *(_QWORD *)(v2 + 40) + 32 * *(int *)(v1 + 72);
    v5 = *(_DWORD *)(v3 + 8);
    v4 = *(_DWORD *)(v3 + 12);
    v6 = *(_QWORD *)(v2 + 88);
    if (v5 > v4)
      v4 = v5;
    --*(_DWORD *)(v6 + 48 * v4 + 8);
    *(_QWORD *)(v1 + 56) = 0;
  }
  v7 = this[1];
  if (v7)
  {
    v8 = *(_QWORD *)(v7 + 64);
    v9 = *(_QWORD *)(v8 + 40) + 32 * *(int *)(v7 + 72);
    v11 = *(_DWORD *)(v9 + 8);
    v10 = *(_DWORD *)(v9 + 12);
    v12 = *(_QWORD *)(v8 + 88);
    if (v11 > v10)
      v10 = v11;
    --*(_DWORD *)(v12 + 48 * v10 + 8);
    *(_QWORD *)(v7 + 48) = 0;
  }
  *this = 0;
  this[1] = 0;
  return this;
}

uint64_t SweepEvent::MakeNew(uint64_t result, uint64_t a2, uint64_t a3, float a4, float a5, float a6, float a7)
{
  *(_DWORD *)(result + 32) = -1;
  *(float *)(result + 16) = a4;
  *(float *)(result + 20) = a5;
  *(float *)(result + 24) = a6;
  *(float *)(result + 28) = a7;
  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = a3;
  *(_QWORD *)(a2 + 56) = result;
  *(_QWORD *)(a3 + 48) = result;
  return result;
}

void *SweepEvent::CreateQueue(uint64_t a1, int a2)
{
  void *result;

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = a2;
  *(_QWORD *)(a1 + 16) = malloc_type_malloc(40 * a2, 0x1020040EF90260EuLL);
  result = malloc_type_malloc(4 * *(int *)(a1 + 4), 0x100004052888210uLL);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

void SweepEvent::DestroyQueue(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[2];
  if (v2)
    free(v2);
  v3 = (void *)a1[1];
  if (v3)
    free(v3);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t SweepEvent::AddInQueue(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5, float a6, float a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  float v25;

  v7 = *(_DWORD *)a3;
  if (*(_DWORD *)a3 >= *(_DWORD *)(a3 + 4))
    return 0;
  *(_DWORD *)a3 = v7 + 1;
  v9 = *(_QWORD *)(a3 + 8);
  v8 = *(_QWORD *)(a3 + 16);
  v10 = v8 + 40 * v7;
  *(float *)(v10 + 16) = a4;
  *(float *)(v10 + 20) = a5;
  *(float *)(v10 + 24) = a6;
  *(float *)(v10 + 28) = a7;
  *(_QWORD *)v10 = a1;
  *(_QWORD *)(v10 + 8) = a2;
  *(_QWORD *)(a1 + 56) = v10;
  *(_QWORD *)(a2 + 48) = v10;
  v11 = *(_QWORD *)(a1 + 64);
  v12 = *(_QWORD *)(v11 + 40) + 32 * *(int *)(a1 + 72);
  v14 = *(_DWORD *)(v12 + 8);
  v13 = *(_DWORD *)(v12 + 12);
  v15 = *(_QWORD *)(v11 + 88);
  if (v14 > v13)
    v13 = v14;
  ++*(_DWORD *)(v15 + 48 * v13 + 8);
  *(_DWORD *)(v10 + 32) = v7;
  v16 = *(_QWORD *)(a2 + 64);
  v17 = *(_QWORD *)(v16 + 40) + 32 * *(int *)(a2 + 72);
  v18 = *(_DWORD *)(v17 + 8);
  v19 = *(_DWORD *)(v17 + 12);
  if (v18 > v19)
    v19 = v18;
  v20 = *(_QWORD *)(v16 + 88) + 48 * v19;
  ++*(_DWORD *)(v20 + 8);
  *(_DWORD *)(v9 + 4 * v7) = v7;
  if (v7 >= 1)
  {
    v21 = v7;
    do
    {
      v22 = v21 - 1;
      v23 = (v21 - 1) >> 1;
      v24 = *(_DWORD *)(v9 + 4 * v23);
      v25 = *(float *)(v8 + 40 * v24 + 20);
      if (v25 <= a5 && (v25 != a5 || *(float *)(v8 + 40 * v24 + 16) <= a4))
        break;
      *(_DWORD *)(v10 + 32) = v23;
      *(_DWORD *)(v8 + 40 * v24 + 32) = v21;
      *(_DWORD *)(v9 + 4 * v23) = v7;
      *(_DWORD *)(v9 + 4 * v21) = v24;
      v21 = v22 >> 1;
    }
    while (v22 > 1);
  }
  return v10;
}

void SweepEvent::SupprFromQueue(uint64_t a1, int *a2)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int *v12;
  float v13;
  float v14;
  char i;
  unsigned int v16;
  uint64_t v17;
  int v18;
  float v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int *v24;
  int v25;
  int v26;
  float v27;
  int *v28;
  int v29;
  float v30;
  float v31;
  int v32;

  if (*a2 <= 1)
  {
    SweepEvent::MakeDelete((uint64_t *)a1);
    *a2 = 0;
    return;
  }
  v3 = *(_DWORD *)(a1 + 32);
  v4 = *(_DWORD *)(*((_QWORD *)a2 + 1) + 4 * v3);
  SweepEvent::MakeDelete((uint64_t *)a1);
  v5 = *((_QWORD *)a2 + 2);
  v6 = *a2 - 1;
  *a2 = v6;
  SweepEvent::Relocate((__n128 *)(v5 + 40 * v6), (uint64_t)a2, v4);
  v7 = *a2;
  if ((_DWORD)v7 != v3)
  {
    v8 = *((_QWORD *)a2 + 1);
    v9 = *((_QWORD *)a2 + 2);
    v10 = *(_DWORD *)(v8 + 4 * v7);
    v11 = v9 + 40 * v10;
    *(_DWORD *)(v11 + 32) = v3;
    v12 = (int *)(v11 + 32);
    *(_DWORD *)(v8 + 4 * v3) = v10;
    v13 = *((float *)v12 - 4);
    v14 = *((float *)v12 - 3);
    if (v3 >= 1)
    {
      for (i = 0; ; i = 1)
      {
        v16 = v3 - 1;
        v17 = (v3 - 1) >> 1;
        v18 = *(_DWORD *)(v8 + 4 * v17);
        v19 = *(float *)(v9 + 40 * v18 + 20);
        if (v14 >= v19 && (v14 != v19 || v13 >= *(float *)(v9 + 40 * v18 + 16)))
          break;
        *v12 = v17;
        *(_DWORD *)(v9 + 40 * v18 + 32) = v3;
        *(_DWORD *)(v8 + 4 * v17) = v10;
        *(_DWORD *)(v8 + 4 * v3) = v18;
        v3 = v16 >> 1;
        if (v16 < 2)
          return;
      }
      if ((i & 1) != 0)
        return;
    }
    v20 = (2 * v3) | 1;
    v21 = *a2;
    if (v20 >= *a2)
      return;
    v22 = 2 * v3;
    while (1)
    {
      v23 = v22 + 2;
      v24 = (int *)(v8 + 4 * v20);
      v25 = *v24;
      v26 = *v24;
      v27 = *(float *)(v9 + 40 * *v24 + 20);
      if (v23 >= v21)
      {
        if (v14 > v27 || v14 == v27 && v13 > *(float *)(v9 + 40 * v26 + 16))
        {
          *v12 = v20;
          *(_DWORD *)(v9 + 40 * v26 + 32) = v3;
          *v24 = v10;
          *(_DWORD *)(v8 + 4 * v3) = v25;
        }
        return;
      }
      v28 = (int *)(v8 + 4 * v23);
      v29 = *v28;
      if (v14 > v27 || v14 == v27 && v13 > *(float *)(v9 + 40 * v26 + 16))
        break;
      v31 = *(float *)(v9 + 40 * v29 + 20);
      if (v14 > v31)
        goto LABEL_23;
      if (v14 != v31)
        return;
      v20 = v23;
      v26 = *v28;
      v24 = (int *)(v8 + 4 * v23);
      v25 = *v28;
      if (v13 <= *(float *)(v9 + 40 * *v28 + 16))
        return;
LABEL_26:
      v32 = v20;
      *v12 = v20;
      *(_DWORD *)(v9 + 40 * v26 + 32) = v3;
      *v24 = v10;
      *(_DWORD *)(v8 + 4 * v3) = v25;
      v22 = 2 * v20;
      v20 = (2 * v20) | 1;
      v21 = *a2;
      v3 = v32;
      if (v20 >= *a2)
        return;
    }
    v30 = *(float *)(v9 + 40 * v29 + 20);
    if (v30 > v27 || v30 == v27 && *(float *)(v9 + 40 * v29 + 16) > *(float *)(v9 + 40 * v26 + 16))
      goto LABEL_26;
LABEL_23:
    v20 = v23;
    v26 = *v28;
    v24 = (int *)(v8 + 4 * v23);
    v25 = *v28;
    goto LABEL_26;
  }
}

__n128 SweepEvent::Relocate(__n128 *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __n128 result;
  unint64_t v7;

  v3 = *(_QWORD *)(a2 + 8);
  v4 = a1[2].n128_i32[0];
  if (*(_DWORD *)(v3 + 4 * v4) != a3)
  {
    v5 = *(_QWORD *)(a2 + 16) + 40 * a3;
    result = a1[1];
    *(__n128 *)v5 = *a1;
    *(__n128 *)(v5 + 16) = result;
    v7 = a1->n128_u64[1];
    *(_QWORD *)(a1->n128_u64[0] + 56) = v5;
    *(_QWORD *)(v7 + 48) = v5;
    *(_DWORD *)(v5 + 32) = v4;
    *(_DWORD *)(v3 + 4 * a1[2].n128_i32[0]) = a3;
  }
  return result;
}

BOOL SweepEvent::PeekInQueue(_QWORD *a1, _QWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, uint64_t a7)
{
  int v7;
  _DWORD *v8;

  v7 = *(_DWORD *)a7;
  if (*(int *)a7 >= 1)
  {
    *a1 = *(_QWORD *)(*(_QWORD *)(a7 + 16) + 40 * **(int **)(a7 + 8));
    *a2 = *(_QWORD *)(*(_QWORD *)(a7 + 16) + 40 * **(int **)(a7 + 8) + 8);
    v8 = (_DWORD *)(*(_QWORD *)(a7 + 16) + 40 * **(int **)(a7 + 8));
    *a3 = v8[4];
    *a4 = v8[5];
    *a5 = v8[6];
    *a6 = v8[7];
  }
  return v7 > 0;
}

BOOL SweepEvent::ExtractFromQueue(_QWORD *a1, _QWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, uint64_t a7)
{
  int v7;
  _DWORD *v8;

  v7 = *(_DWORD *)a7;
  if (*(int *)a7 >= 1)
  {
    *a1 = *(_QWORD *)(*(_QWORD *)(a7 + 16) + 40 * **(int **)(a7 + 8));
    *a2 = *(_QWORD *)(*(_QWORD *)(a7 + 16) + 40 * **(int **)(a7 + 8) + 8);
    v8 = (_DWORD *)(*(_QWORD *)(a7 + 16) + 40 * **(int **)(a7 + 8));
    *a3 = v8[4];
    *a4 = v8[5];
    *a5 = v8[6];
    *a6 = v8[7];
    SweepEvent::SupprFromQueue((uint64_t)v8, (int *)a7);
  }
  return v7 > 0;
}

void SweepTree::SweepTree(SweepTree *this)
{
  uint64_t v1;

  AVLTree::AVLTree(this);
  *(_DWORD *)(v1 + 72) = -1;
  *(_DWORD *)(v1 + 80) = -1;
  *(_QWORD *)(v1 + 56) = 0;
  *(_QWORD *)(v1 + 64) = 0;
  *(_QWORD *)(v1 + 48) = 0;
  *(_BYTE *)(v1 + 76) = 1;
}

{
  uint64_t v1;

  AVLTree::AVLTree(this);
  *(_DWORD *)(v1 + 72) = -1;
  *(_DWORD *)(v1 + 80) = -1;
  *(_QWORD *)(v1 + 56) = 0;
  *(_QWORD *)(v1 + 64) = 0;
  *(_QWORD *)(v1 + 48) = 0;
  *(_BYTE *)(v1 + 76) = 1;
}

void SweepTree::~SweepTree(SweepTree *this)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *((_QWORD *)this + 6);
  if (v2)
    *(_QWORD *)(v2 + 8) = 0;
  v3 = (_QWORD *)*((_QWORD *)this + 7);
  if (v3)
    *v3 = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  AVLTree::MakeDelete(this);
  AVLTree::~AVLTree(this);
}

uint64_t SweepTree::MakeDelete(SweepTree *this)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = *((_QWORD *)this + 6);
  if (v1)
    *(_QWORD *)(v1 + 8) = 0;
  v2 = (_QWORD *)*((_QWORD *)this + 7);
  if (v2)
    *v2 = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  return AVLTree::MakeDelete(this);
}

_QWORD *SweepTree::MakeNew(SweepTree *this, Shape *a2, int a3, int a4, int a5)
{
  _QWORD *result;
  uint64_t v11;

  result = AVLTree::MakeNew(this);
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = a2;
  *((_DWORD *)this + 18) = a3;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 20) = a5;
  v11 = *((_QWORD *)a2 + 5) + 32 * a3;
  *((_BYTE *)this + 76) = (a4 >= 0) ^ (*(_DWORD *)(v11 + 8) >= *(_DWORD *)(v11 + 12));
  return result;
}

uint64_t SweepTree::ConvertTo(uint64_t this, Shape *a2, int a3, int a4, int a5)
{
  uint64_t v5;

  *(_QWORD *)(this + 56) = 0;
  *(_QWORD *)(this + 64) = a2;
  *(_DWORD *)(this + 72) = a3;
  *(_QWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 80) = a5;
  v5 = *((_QWORD *)a2 + 5) + 32 * a3;
  *(_BYTE *)(this + 76) = (a4 >= 0) ^ (*(_DWORD *)(v5 + 8) >= *(_DWORD *)(v5 + 12));
  return this;
}

void *SweepTree::CreateList(uint64_t a1, int a2)
{
  void *result;

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = a2;
  result = malloc_type_malloc(88 * a2, 0x1020040EB7F0E25uLL);
  *(_QWORD *)(a1 + 8) = result;
  *(_QWORD *)(a1 + 16) = 0;
  return result;
}

void SweepTree::DestroyList(_QWORD *a1)
{
  void *v2;

  v2 = (void *)a1[1];
  if (v2)
    free(v2);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t SweepTree::AddInList(uint64_t a1, int a2, int a3, int a4, int *a5)
{
  int v5;
  uint64_t v11;
  uint64_t v12;

  v5 = *a5;
  if (*a5 >= a5[1])
    return 0;
  *a5 = v5 + 1;
  v11 = *((_QWORD *)a5 + 1) + 88 * v5;
  AVLTree::MakeNew((AVLTree *)v11);
  *(_QWORD *)(v11 + 56) = 0;
  *(_QWORD *)(v11 + 64) = a1;
  *(_DWORD *)(v11 + 72) = a2;
  *(_QWORD *)(v11 + 48) = 0;
  *(_DWORD *)(v11 + 80) = a4;
  v12 = *(_QWORD *)(a1 + 40) + 32 * a2;
  *(_BYTE *)(v11 + 76) = (a3 >= 0) ^ (*(_DWORD *)(v12 + 8) >= *(_DWORD *)(v12 + 12));
  return *((_QWORD *)a5 + 1) + 88 * v5;
}

uint64_t SweepTree::Find(SweepTree *this, float a2, float a3, SweepTree *a4, SweepTree **a5, SweepTree **a6, int a7)
{
  double v7;
  double v8;
  SweepTree *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  double v17;
  double v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  float v23;
  double v24;
  double v25;
  SweepTree *v26;
  SweepTree *v28;

  v7 = a2;
  v8 = a3;
  do
  {
    while (1)
    {
      v9 = this;
      v10 = (_QWORD *)*((_QWORD *)this + 8);
      v11 = *((int *)this + 18);
      v12 = v10[5] + 32 * v11;
      v13 = *(_DWORD *)(v12 + 8);
      v14 = v10[11] + 48 * v13;
      v15 = v10[7] + (v11 << 6);
      v16 = *(float *)(v15 + 4);
      v17 = *(float *)(v15 + 8);
      if (v13 <= *(_DWORD *)(v12 + 12))
        v16 = -v16;
      else
        v17 = -v17;
      v18 = v16;
      v19 = (v8 - *(float *)(v14 + 40)) * v18 + v17 * (v7 - *(float *)(v14 + 36));
      if (fabs(v19) < 0.000001)
      {
        v20 = *((_QWORD *)a4 + 8);
        v21 = *((int *)a4 + 18);
        v22 = *(_QWORD *)(v20 + 56) + (v21 << 6);
        v23 = *(float *)(v22 + 4);
        v24 = *(float *)(v22 + 8);
        if (*(_DWORD *)(*(_QWORD *)(v20 + 40) + 32 * v21 + 8) <= *(_DWORD *)(*(_QWORD *)(v20 + 40) + 32 * v21 + 12))
          v23 = -v23;
        else
          v24 = -v24;
        v25 = v23;
        v19 = a7 ? v17 * v25 - v24 * v18 : v24 * v18 - v17 * v25;
        if (v19 == 0.0)
        {
          v19 = v18 * v25 + v17 * v24;
          if (v19 == 0.0)
          {
            *a5 = this;
            *a6 = (SweepTree *)*((_QWORD *)this + 1);
            return 1;
          }
        }
      }
      if (v19 >= 0.0)
        break;
      this = (SweepTree *)*((_QWORD *)this + 3);
      if (!this)
      {
        *a6 = v9;
        v28 = *(SweepTree **)v9;
        *a5 = v28;
        if (v28)
          return 4;
        else
          return 2;
      }
    }
    this = (SweepTree *)*((_QWORD *)this + 4);
  }
  while (this);
  *a5 = v9;
  v26 = (SweepTree *)*((_QWORD *)v9 + 1);
  *a6 = v26;
  if (v26)
    return 4;
  else
    return 3;
}

uint64_t SweepTree::Find(SweepTree *this, float a2, float a3, SweepTree **a4, SweepTree **a5)
{
  double v5;
  double v6;
  SweepTree *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  double v15;
  double v16;
  SweepTree *v17;
  SweepTree *v19;

  v5 = a2;
  v6 = a3;
  do
  {
    while (1)
    {
      v7 = this;
      v8 = (_QWORD *)*((_QWORD *)this + 8);
      v9 = *((int *)this + 18);
      v10 = v8[5] + 32 * v9;
      v11 = *(_DWORD *)(v10 + 8);
      v12 = v8[11] + 48 * v11;
      v13 = v8[7] + (v9 << 6);
      v14 = *(float *)(v13 + 4);
      v15 = *(float *)(v13 + 8);
      if (v11 <= *(_DWORD *)(v10 + 12))
        v14 = -v14;
      else
        v15 = -v15;
      v16 = (v6 - *(float *)(v12 + 40)) * v14 + v15 * (v5 - *(float *)(v12 + 36));
      if (fabs(v16) < 0.000001)
      {
        *a4 = this;
        *a5 = (SweepTree *)*((_QWORD *)this + 1);
        return 1;
      }
      if (v16 >= 0.0)
        break;
      this = (SweepTree *)*((_QWORD *)this + 3);
      if (!this)
      {
        *a5 = v7;
        v19 = *(SweepTree **)v7;
        *a4 = *(SweepTree **)v7;
        if (v19)
          return 4;
        else
          return 2;
      }
    }
    this = (SweepTree *)*((_QWORD *)this + 4);
  }
  while (this);
  *a4 = v7;
  v17 = (SweepTree *)*((_QWORD *)v7 + 1);
  *a5 = v17;
  if (v17)
    return 4;
  else
    return 3;
}

void SweepTree::RemoveEvents(uint64_t a1, int *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(a1 + 48);
  if (v4)
    SweepEvent::SupprFromQueue(v4, a2);
  *(_QWORD *)(a1 + 48) = 0;
  v5 = *(_QWORD *)(a1 + 56);
  if (v5)
    SweepEvent::SupprFromQueue(v5, a2);
  *(_QWORD *)(a1 + 56) = 0;
}

void SweepTree::RemoveEvent(uint64_t a1, int *a2, int a3)
{
  uint64_t v3;
  _QWORD *v4;

  if (a3)
  {
    v4 = (_QWORD *)(a1 + 48);
    v3 = *(_QWORD *)(a1 + 48);
    if (!v3)
      goto LABEL_6;
    goto LABEL_5;
  }
  v4 = (_QWORD *)(a1 + 56);
  v3 = *(_QWORD *)(a1 + 56);
  if (v3)
LABEL_5:
    SweepEvent::SupprFromQueue(v3, a2);
LABEL_6:
  *v4 = 0;
}

uint64_t SweepTree::Remove(AVLTree *a1, uint64_t a2, int *a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  unsigned int v10;
  uint64_t *v11;
  AVLTree *v13;

  SweepTree::RemoveEvents((uint64_t)a1, a3);
  v13 = *(AVLTree **)(a2 + 16);
  v7 = AVLTree::Remove(a1, &v13, a4);
  *(_QWORD *)(a2 + 16) = v13;
  v8 = *((_QWORD *)a1 + 6);
  if (v8)
    *(_QWORD *)(v8 + 8) = 0;
  v9 = (_QWORD *)*((_QWORD *)a1 + 7);
  if (v9)
    *v9 = 0;
  *((_QWORD *)a1 + 6) = 0;
  *((_QWORD *)a1 + 7) = 0;
  AVLTree::MakeDelete(a1);
  v10 = *(_DWORD *)a2 - 1;
  if (*(int *)a2 > 1)
  {
    v11 = (uint64_t *)(*(_QWORD *)(a2 + 8) + 88 * v10);
    if (*(uint64_t **)(a2 + 16) == v11)
      *(_QWORD *)(a2 + 16) = a1;
    *(_DWORD *)a2 = v10;
    SweepTree::Relocate(v11, a1);
  }
  else
  {
    *(_DWORD *)a2 = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  return v7;
}

uint64_t *SweepTree::Relocate(uint64_t *this, SweepTree *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  if (this != (uint64_t *)a2)
  {
    v3 = this;
    this = AVLTree::Relocate((AVLTree *)this, a2);
    *((_QWORD *)a2 + 8) = v3[8];
    *((_DWORD *)a2 + 18) = *((_DWORD *)v3 + 18);
    *((_BYTE *)a2 + 76) = *((_BYTE *)v3 + 76);
    *((_OWORD *)a2 + 3) = *((_OWORD *)v3 + 3);
    *((_DWORD *)a2 + 20) = *((_DWORD *)v3 + 20);
    v4 = v3[8];
    v5 = *(_QWORD *)(v4 + 64);
    if (v5)
      *(_QWORD *)(v5 + 56 * *((int *)v3 + 18)) = a2;
    v6 = *(_QWORD *)(v4 + 80);
    if (v6)
      *(_QWORD *)(v6 + 48 * *((int *)v3 + 18)) = a2;
    v7 = v3[6];
    if (v7)
      *(_QWORD *)(v7 + 8) = a2;
    v8 = (_QWORD *)v3[7];
    if (v8)
      *v8 = a2;
  }
  return this;
}

SweepTree *SweepTree::Insert(SweepTree *a1, uint64_t a2, int *a3, uint64_t a4, int a5, int a6, int a7)
{
  SweepTree *result;
  float *v12;
  int v13;
  int v14;
  SweepTree *v15;
  uint64_t v16;
  SweepTree *v17;
  SweepTree *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  AVLTree *v23;
  SweepTree *v24;
  SweepTree *v25;

  result = *(SweepTree **)(a2 + 16);
  if (!result)
  {
    *(_QWORD *)(a2 + 16) = a1;
    return result;
  }
  v24 = 0;
  v25 = 0;
  v12 = (float *)(*(_QWORD *)(a4 + 24) + 28 * a5);
  v13 = SweepTree::Find(result, *v12, v12[1], a1, &v25, &v24, a7);
  v14 = v13;
  if ((v13 & 6) != 2)
  {
    if (v13 == 4)
    {
      v18 = v24;
      v19 = *((_QWORD *)v24 + 6);
      if (v19)
        SweepEvent::SupprFromQueue(v19, a3);
      *((_QWORD *)v18 + 6) = 0;
      v17 = v25;
    }
    else
    {
      if (v13 != 1)
        goto LABEL_18;
      v15 = v24;
      if (v24)
      {
        v16 = *((_QWORD *)v24 + 6);
        if (v16)
          SweepEvent::SupprFromQueue(v16, a3);
        *((_QWORD *)v15 + 6) = 0;
      }
      v17 = v25;
      if (!v25)
        goto LABEL_18;
    }
    v22 = *((_QWORD *)v17 + 7);
    v21 = (_QWORD *)((char *)v17 + 56);
    v20 = v22;
    if (v22)
      SweepEvent::SupprFromQueue(v20, a3);
    *v21 = 0;
  }
LABEL_18:
  v23 = *(AVLTree **)(a2 + 16);
  result = (SweepTree *)AVLTree::Insert(a1, &v23, v14, v25, v24, a6);
  *(_QWORD *)(a2 + 16) = v23;
  return result;
}

uint64_t SweepTree::InsertAt(AVLTree *this, uint64_t a2, int *a3, int a4, AVLTree **a5, int a6, int a7, int a8)
{
  AVLTree *v10;
  AVLTree *v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  double v18;
  double v19;
  double v20;
  uint64_t v21;
  double v22;
  double v23;
  double v24;
  AVLTree *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t result;
  uint64_t v30;
  float v31;
  float v32;
  AVLTree *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  double v42;
  double v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  double v52;
  double v53;
  int v54;
  AVLTree *v55;

  v10 = *(AVLTree **)(a2 + 16);
  if (v10)
  {
    v12 = (AVLTree *)a5;
    v14 = *((_QWORD *)this + 8);
    v15 = *(_QWORD *)(v14 + 40);
    v16 = v15 + 32 * *((int *)this + 18);
    v17 = *(float *)(v16 + 4);
    v18 = -*(float *)v16;
    if (*(_DWORD *)(v16 + 8) <= *(_DWORD *)(v16 + 12))
      v18 = *(float *)v16;
    else
      v17 = -v17;
    v19 = -v17;
    if (a8)
    {
      v19 = v17;
      v20 = v18;
    }
    else
    {
      v20 = -v18;
    }
    v21 = *((_QWORD *)a5[8] + 5) + 32 * *((int *)a5 + 18);
    v22 = *(float *)v21;
    v23 = *(float *)(v21 + 4);
    if (*(_DWORD *)(v21 + 8) <= *(_DWORD *)(v21 + 12))
      v23 = -v23;
    else
      v22 = -v22;
    v24 = v20 * v23 + v22 * v19;
    if (v24 == 0.0)
    {
      v25 = a5[1];
LABEL_13:
      if (v25)
        v26 = 4;
      else
        v26 = 3;
      if (v25)
      {
        v27 = *((_QWORD *)v25 + 6);
        if (v27)
          SweepEvent::SupprFromQueue(v27, a3);
        *((_QWORD *)v25 + 6) = 0;
        v28 = *((_QWORD *)v12 + 7);
        if (v28)
          SweepEvent::SupprFromQueue(v28, a3);
        *((_QWORD *)v12 + 7) = 0;
        v10 = *(AVLTree **)(a2 + 16);
      }
    }
    else
    {
      v30 = *(_QWORD *)(v14 + 88) + 48 * a6;
      v31 = *(float *)(v30 + 36);
      v32 = *(float *)(v30 + 40);
      if (v24 > 0.0)
      {
        v25 = a5[1];
        while (1)
        {
          v33 = v12;
          v34 = *((_QWORD *)v12 + 8);
          if (v34 == v14)
          {
            v35 = *((int *)v12 + 18);
            v40 = v15 + 32 * v35;
            if (*(_DWORD *)(v40 + 8) != a6 && *(_DWORD *)(v40 + 12) != a6)
              goto LABEL_13;
          }
          else
          {
            v35 = *((int *)v12 + 18);
            v36 = *(_QWORD *)(v34 + 40) + 32 * v35;
            v38 = *(_DWORD *)(v36 + 8);
            v37 = *(_DWORD *)(v36 + 12);
            v39 = *(_QWORD *)(v34 + 88);
            if ((*(float *)(v39 + 48 * v38 + 36) != v31 || *(float *)(v39 + 48 * v38 + 40) != v32)
              && (*(float *)(v39 + 48 * v37 + 36) != v31 || *(float *)(v39 + 48 * v37 + 40) != v32))
            {
              goto LABEL_13;
            }
          }
          v41 = *(_QWORD *)(v34 + 40) + 32 * v35;
          v42 = *(float *)v41;
          v43 = *(float *)(v41 + 4);
          if (*(_DWORD *)(v41 + 8) <= *(_DWORD *)(v41 + 12))
            v43 = -v43;
          else
            v42 = -v42;
          if (v20 * v43 + v42 * v19 <= 0.0)
            goto LABEL_13;
          v12 = *(AVLTree **)v12;
          v25 = v33;
          if (!*(_QWORD *)v33)
            goto LABEL_58;
        }
      }
      if (v24 >= 0.0)
      {
        v12 = 0;
      }
      else
      {
        v25 = (AVLTree *)a5;
        while (1)
        {
          v12 = v25;
          v25 = (AVLTree *)*((_QWORD *)v25 + 1);
          if (!v25)
            break;
          v44 = *((_QWORD *)v25 + 8);
          if (v44 == v14)
          {
            v45 = *((int *)v25 + 18);
            v50 = v15 + 32 * v45;
            if (*(_DWORD *)(v50 + 8) != a6 && *(_DWORD *)(v50 + 12) != a6)
              goto LABEL_13;
          }
          else
          {
            v45 = *((int *)v25 + 18);
            v46 = *(_QWORD *)(v44 + 40) + 32 * v45;
            v48 = *(_DWORD *)(v46 + 8);
            v47 = *(_DWORD *)(v46 + 12);
            v49 = *(_QWORD *)(v44 + 88);
            if ((*(float *)(v49 + 48 * v48 + 36) != v31 || *(float *)(v49 + 48 * v48 + 40) != v32)
              && (*(float *)(v49 + 48 * v47 + 36) != v31 || *(float *)(v49 + 48 * v47 + 40) != v32))
            {
              goto LABEL_13;
            }
          }
          v51 = *(_QWORD *)(v44 + 40) + 32 * v45;
          v52 = *(float *)v51;
          v53 = *(float *)(v51 + 4);
          if (*(_DWORD *)(v51 + 8) <= *(_DWORD *)(v51 + 12))
            v53 = -v53;
          else
            v52 = -v52;
          if (v20 * v53 + v52 * v19 > 0.0)
            goto LABEL_13;
        }
      }
      v33 = 0;
LABEL_58:
      if (v12)
        v54 = 4;
      else
        v54 = 2;
      if (v33)
        v26 = v54;
      else
        v26 = 3;
      v25 = v33;
    }
    v55 = v10;
    result = AVLTree::Insert(this, &v55, v26, v12, v25, a7);
    *(_QWORD *)(a2 + 16) = v55;
  }
  else
  {
    result = 0;
    *(_QWORD *)(a2 + 16) = this;
  }
  return result;
}

uint64_t SweepTree::SwapWithRight(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;

  v1 = *(_QWORD *)(result + 8);
  v2 = *(_QWORD *)(result + 64);
  v3 = *(_DWORD *)(result + 72);
  *(_QWORD *)(*(_QWORD *)(v2 + 64) + 56 * v3) = v1;
  v4 = *(_QWORD *)(v1 + 64);
  v5 = *(_DWORD *)(v1 + 72);
  *(_QWORD *)(*(_QWORD *)(v4 + 64) + 56 * v5) = result;
  *(_QWORD *)(result + 64) = v4;
  *(_QWORD *)(v1 + 64) = v2;
  *(_DWORD *)(result + 72) = v5;
  *(_DWORD *)(v1 + 72) = v3;
  LODWORD(v2) = *(_DWORD *)(result + 80);
  *(_DWORD *)(result + 80) = *(_DWORD *)(v1 + 80);
  *(_DWORD *)(v1 + 80) = v2;
  LOBYTE(v2) = *(_BYTE *)(result + 76);
  *(_BYTE *)(result + 76) = *(_BYTE *)(v1 + 76);
  *(_BYTE *)(v1 + 76) = v2;
  return result;
}

void sub_217A3CBE8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A3CCF8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A3CE5C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A3D0C0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A3D294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_217A3E0C4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A3F59C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A3F658(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A3F714(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

const __CFString *TSDImageStylePackageString()
{
  return CFSTR("image");
}

uint64_t TSDImageStyleIdentifierString(uint64_t a1)
{
  return String((uint64_t)CFSTR("image"), a1, (uint64_t)CFSTR("imageStyle"));
}

const __CFString *TSDMovieStylePackageString()
{
  return CFSTR("movie");
}

uint64_t TSDMovieStyleIdentifierString(uint64_t a1)
{
  return String((uint64_t)CFSTR("movie"), a1, (uint64_t)CFSTR("movieStyle"));
}

void sub_217A43B9C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A43EF0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A440C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void TSDColorFill_DrawClearColorRepresentation(CGContext *a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  CGPath *Mutable;
  CGFloat MinX;
  CGFloat MaxY;
  CGFloat MaxX;
  CGFloat MinY;
  CGRect v15;
  CGRect v16;
  CGRect v17;
  CGRect v18;
  CGRect v19;

  if (!CGRectIsNull(*(CGRect *)&a2))
  {
    CGContextSaveGState(a1);
    CGContextSetFillColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend(MEMORY[0x24BEB3C40], "whiteColor"), "CGColor"));
    v15.origin.x = a2;
    v15.origin.y = a3;
    v15.size.width = a4;
    v15.size.height = a5;
    CGContextFillRect(a1, v15);
    CGContextSetLineWidth(a1, 1.0);
    CGContextSetStrokeColorWithColor(a1, (CGColorRef)objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x24BEB3C40], "redColor"), "colorWithAlphaComponent:", 0.38), "CGColor"));
    Mutable = CGPathCreateMutable();
    v16.origin.x = a2;
    v16.origin.y = a3;
    v16.size.width = a4;
    v16.size.height = a5;
    MinX = CGRectGetMinX(v16);
    v17.origin.x = a2;
    v17.origin.y = a3;
    v17.size.width = a4;
    v17.size.height = a5;
    MaxY = CGRectGetMaxY(v17);
    CGPathMoveToPoint(Mutable, 0, MinX, MaxY);
    v18.origin.x = a2;
    v18.origin.y = a3;
    v18.size.width = a4;
    v18.size.height = a5;
    MaxX = CGRectGetMaxX(v18);
    v19.origin.x = a2;
    v19.origin.y = a3;
    v19.size.width = a4;
    v19.size.height = a5;
    MinY = CGRectGetMinY(v19);
    CGPathAddLineToPoint(Mutable, 0, MaxX, MinY);
    CGContextAddPath(a1, Mutable);
    CGContextStrokePath(a1);
    CGPathRelease(Mutable);
    CGContextRestoreGState(a1);
  }
}

void sub_217A486C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_217A4B0C8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A4B1F0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A4B674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_217A4B8BC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A4BA40(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A4BC34(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A4BD80(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A4BE14(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A4C12C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_217A4C35C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A4C824(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A4CA9C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t TSDTextInputResponderClass()
{
  TSUSupportsTextInteraction();
  return objc_opt_class();
}

__CFString *UI_GRANULARITY_NAME(unint64_t a1)
{
  if (a1 >= 6)
    return (__CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("unknown granularity: %ld"), a1);
  else
    return off_24D82C0A8[a1];
}

__CFString *UI_DIRECTION_NAME(unint64_t a1)
{
  if (a1 >= 6)
    return (__CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("unknown direction: %ld"), a1);
  else
    return off_24D82C0D8[a1];
}

const __CFString *BOOL_NAME(int a1)
{
  if (a1)
    return CFSTR("YES");
  else
    return CFSTR("NO");
}

void sub_217A4F130(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_217A4F17C(void *a1)
{
  objc_end_catch();
  objc_begin_catch(a1);
  JUMPOUT(0x217A4F0E4);
}

void sub_217A4F2D4()
{
  __break(1u);
}

void sub_217A4F324()
{
  objc_end_catch();
  JUMPOUT(0x217A4F304);
}

void sub_217A4F380()
{
  __break(1u);
}

void sub_217A4F3D0()
{
  objc_end_catch();
  JUMPOUT(0x217A4F3B0);
}

void sub_217A4F710()
{
  __break(1u);
}

void sub_217A4F770()
{
  objc_end_catch();
  JUMPOUT(0x217A4F750);
}

void sub_217A508EC()
{
  __break(1u);
}

void sub_217A50968(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x217A50948);
  }
  JUMPOUT(0x217A50914);
}

uint64_t p_reflectionMask(void)
{
  uint64_t result;
  char *v1;
  CGColorSpace *DeviceRGB;
  CGContext *v3;
  uint64_t v4;
  int32x4_t v5;
  int32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  int64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  int32x4_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  int8x16_t v26;
  int8x16_t v27;
  char *v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t __x;
  long double v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  float64x2_t v41;
  float64x2_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t v45;
  float64x2_t v46;
  int32x4_t v47;
  int32x4_t v48;
  int32x4_t v49;
  int32x4_t v50;
  int8x16x4_t v51;

  result = s_reflectionMaskImageRef;
  if (!s_reflectionMaskImageRef)
  {
    v1 = (char *)malloc_type_calloc(4uLL, 0x40uLL, 0xA21791E2uLL);
    DeviceRGB = CGColorSpaceCreateDeviceRGB();
    v3 = CGBitmapContextCreate(v1, 1uLL, 0x40uLL, 8uLL, 4uLL, DeviceRGB, 2u);
    CGColorSpaceRelease(DeviceRGB);
    v4 = 0;
    v5 = (int32x4_t)xmmword_217C2A080;
    v6 = (int32x4_t)xmmword_217C2A090;
    v7 = (int32x4_t)xmmword_217C2A0A0;
    v8 = (int32x4_t)xmmword_217C2A0B0;
    v30 = (float64x2_t)vdupq_n_s64(0x404F800000000000uLL);
    v29 = (float64x2_t)vdupq_n_s64(0x406FFFF7CED91687uLL);
    do
    {
      v47 = v8;
      v48 = v6;
      v49 = v7;
      v50 = v5;
      v9.i64[0] = v8.i32[2];
      v9.i64[1] = v8.i32[3];
      v10 = vcvtq_f64_s64(v9);
      v9.i64[0] = v8.i32[0];
      v9.i64[1] = v8.i32[1];
      v11 = vcvtq_f64_s64(v9);
      v9.i64[0] = v49.i32[2];
      v9.i64[1] = v49.i32[3];
      v12 = vcvtq_f64_s64(v9);
      v13 = v5;
      v9.i64[0] = v49.i32[0];
      v9.i64[1] = v49.i32[1];
      v14 = vcvtq_f64_s64(v9);
      v9.i64[0] = v6.i32[2];
      v9.i64[1] = v6.i32[3];
      v15 = vcvtq_f64_s64(v9);
      v9.i64[0] = v6.i32[0];
      v9.i64[1] = v6.i32[1];
      v16 = vcvtq_f64_s64(v9);
      v9.i64[0] = v13.i32[2];
      v9.i64[1] = v13.i32[3];
      v17 = vcvtq_f64_s64(v9);
      v9.i64[0] = v13.i32[0];
      v9.i64[1] = v13.i32[1];
      v46 = vdivq_f64(vcvtq_f64_s64(v9), v30);
      v42 = vdivq_f64(v16, v30);
      v44 = vdivq_f64(v17, v30);
      v38 = vdivq_f64(v14, v30);
      v40 = vdivq_f64(v15, v30);
      v34 = vdivq_f64(v11, v30);
      v36 = vdivq_f64(v12, v30);
      __x = vdivq_f64(v10, v30);
      v32 = pow(__x.f64[1], 1.8);
      v18.f64[0] = pow(__x.f64[0], 1.8);
      v18.f64[1] = v32;
      v33 = v18;
      __x.f64[0] = pow(v34.f64[1], 1.8);
      v19.f64[0] = pow(v34.f64[0], 1.8);
      v19.f64[1] = __x.f64[0];
      v35 = v19;
      __x.f64[0] = pow(v36.f64[1], 1.8);
      v20.f64[0] = pow(v36.f64[0], 1.8);
      v20.f64[1] = __x.f64[0];
      v37 = v20;
      __x.f64[0] = pow(v38.f64[1], 1.8);
      v21.f64[0] = pow(v38.f64[0], 1.8);
      v21.f64[1] = __x.f64[0];
      v39 = v21;
      __x.f64[0] = pow(v40.f64[1], 1.8);
      v22.f64[0] = pow(v40.f64[0], 1.8);
      v22.f64[1] = __x.f64[0];
      v41 = v22;
      __x.f64[0] = pow(v42.f64[1], 1.8);
      v23.f64[0] = pow(v42.f64[0], 1.8);
      v23.f64[1] = __x.f64[0];
      v43 = v23;
      __x.f64[0] = pow(v44.f64[1], 1.8);
      v24.f64[0] = pow(v44.f64[0], 1.8);
      v24.f64[1] = __x.f64[0];
      v45 = v24;
      __x.f64[0] = pow(v46.f64[1], 1.8);
      v25.f64[0] = pow(v46.f64[0], 1.8);
      v25.f64[1] = __x.f64[0];
      *(int16x4_t *)v26.i8 = vuzp1_s16((int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v35, v29))), (int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v33, v29))));
      v26.u64[1] = (unint64_t)vuzp1_s16((int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v39, v29))), (int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v37, v29))));
      *(int16x4_t *)v27.i8 = vuzp1_s16((int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v43, v29))), (int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v41, v29))));
      v27.u64[1] = (unint64_t)vuzp1_s16((int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v25, v29))), (int16x4_t)vmovn_s64(vcvtq_s64_f64(vmulq_f64(v45, v29))));
      v51.val[0] = vuzp1q_s8(v26, v27);
      v51.val[1] = v51.val[0];
      v51.val[2] = v51.val[0];
      v51.val[3] = v51.val[0];
      v28 = &v1[v4];
      vst4q_s8(v28, v51);
      v51.val[2].i64[0] = 0x1000000010;
      v51.val[2].i64[1] = 0x1000000010;
      v8 = vaddq_s32(v47, (int32x4_t)v51.val[2]);
      v7 = vaddq_s32(v49, (int32x4_t)v51.val[2]);
      v6 = vaddq_s32(v48, (int32x4_t)v51.val[2]);
      v5 = vaddq_s32(v50, (int32x4_t)v51.val[2]);
      v4 += 64;
    }
    while (v4 != 256);
    s_reflectionMaskImageRef = (uint64_t)CGBitmapContextCreateImage(v3);
    CGContextRelease(v3);
    return s_reflectionMaskImageRef;
  }
  return result;
}

const __CFString *TSDStringFromTextureType(int a1)
{
  const __CFString *result;
  void *v2;
  void *v3;
  void *v4;

  switch(a1)
  {
    case 0:
      result = CFSTR("unknown");
      break;
    case 1:
      result = CFSTR("background");
      break;
    case 2:
      result = CFSTR("shadow");
      break;
    case 3:
      result = CFSTR("contact shadow");
      break;
    case 4:
      result = CFSTR("grouped shadow");
      break;
    case 5:
      result = CFSTR("object");
      break;
    case 6:
      result = CFSTR("text");
      break;
    case 7:
      result = CFSTR("parameterizedStroke");
      break;
    case 8:
      result = CFSTR("stroke");
      break;
    case 9:
      result = CFSTR("reflection");
      break;
    case 10:
      objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v2 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString * _Nonnull TSDStringFromTextureType(TSDTextureType)");
      v3 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDTexturedRectangle.m");
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, v4, 57, CFSTR("Invalid texture type"));

      result = CFSTR("ERROR");
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

void sub_217A5B580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  void *v18;

  objc_sync_exit(v18);
  _Unwind_Resume(a1);
}

void *TSDTopmostInfoFromInfo(void *a1)
{
  void *v1;
  uint64_t v2;
  void *i;
  uint64_t v4;

  v1 = a1;
  v2 = objc_msgSend(a1, "parentInfo");
  if (v2)
  {
    for (i = (void *)v2; (objc_msgSend(i, "conformsToProtocol:", &unk_254FD9468) & 1) == 0; i = (void *)v4)
    {
      v1 = i;
      v4 = objc_msgSend(i, "parentInfo");
      if (!v4)
        break;
    }
  }
  return v1;
}

uint64_t TSDTopmostOwningAttachmentFromInfo(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v2 = objc_msgSend(a1, "owningAttachment");
  v3 = objc_msgSend(a1, "parentInfo");
  if (v3)
  {
    v4 = (void *)v3;
    do
    {
      if ((objc_msgSend(v4, "conformsToProtocol:", &unk_254FD9468) & 1) != 0)
        break;
      if (objc_msgSend(v4, "owningAttachment"))
        v2 = objc_msgSend(v4, "owningAttachment");
      v4 = (void *)objc_msgSend(v4, "parentInfo");
    }
    while (v4);
  }
  return v2;
}

void p_calculateDerivedValuesFromFrameSpecAndAssetScale(void *a1, double *a2, double *a3, double *a4, double *a5, uint64_t a6, double a7)
{
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  uint64_t v25;

  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  if (objc_msgSend(a1, "i_hasImages"))
  {
    objc_msgSend(a1, "i_leftWidth");
    *(float *)&v18 = v18 * a7;
    v17 = ceilf(*(float *)&v18);
    objc_msgSend(a1, "i_rightWidth");
    *(float *)&v19 = v19 * a7;
    v16 = ceilf(*(float *)&v19);
    objc_msgSend(a1, "i_topHeight");
    *(float *)&v20 = v20 * a7;
    v15 = ceilf(*(float *)&v20);
    objc_msgSend(a1, "i_bottomHeight");
    *(float *)&v21 = v21 * a7;
    v14 = ceilf(*(float *)&v21);
  }
  if (!objc_msgSend(a1, "i_hasAdornment"))
  {
    v24 = *MEMORY[0x24BDBF148];
    v25 = *(_QWORD *)(MEMORY[0x24BDBF148] + 8);
    if (!a2)
      goto LABEL_8;
    goto LABEL_7;
  }
  objc_msgSend(a1, "i_adornmentSize");
  v24 = TSDMultiplySizeScalar(v22, v23, a7);
  if (a2)
LABEL_7:
    *a2 = v17;
LABEL_8:
  if (a3)
    *a3 = v16;
  if (a4)
    *a4 = v15;
  if (a5)
    *a5 = v14;
  if (a6)
  {
    *(double *)a6 = v24;
    *(_QWORD *)(a6 + 8) = v25;
  }
}

void sub_217A6AA24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  uint64_t v35;

  _Block_object_dispose(&a29, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose((const void *)(v35 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_217A6B520(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A6D060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__14(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__14(uint64_t a1)
{

}

uint64_t TSDMaxSingleTileDimension()
{
  return objc_msgSend(+[TSDCapabilities currentCapabilities](TSDCapabilities, "currentCapabilities"), "maximumTextureSize");
}

double TSDDefaultTileDimension()
{
  double v0;

  objc_msgSend(+[TSDCapabilities currentCapabilities](TSDCapabilities, "currentCapabilities"), "maximumTextureSize");
  *(float *)&v0 = v0 * 0.25;
  return fmaxf(*(float *)&v0, 640.0);
}

void sub_217A743F0(void *a1)
{
  uint64_t v1;

  objc_begin_catch(a1);
  *(_BYTE *)(v1 + 120) = 0;
  objc_exception_rethrow();
}

void sub_217A74408(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

uint64_t TSDMetalMotionBlurEffect_WriteRGBATexture2DToPNG()
{
  return 0;
}

void sub_217A78B34(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A78D84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_217A79228(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A79450(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A795E8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A79760(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t do_line_segments_intersect(float *a1, float *a2, float *a3, float *a4)
{
  float v4;
  double v5;
  double v6;
  float v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  BOOL v14;
  BOOL v15;
  double v16;

  v4 = a1[1];
  v5 = (float)(*a2 - *a1);
  v6 = (float)(a2[1] - v4);
  v7 = a3[1];
  v8 = (float)(*a3 - *a4);
  v9 = (float)(v7 - a4[1]);
  v10 = (float)(*a1 - *a3);
  v11 = (float)(v4 - v7);
  v12 = v6 * v8 - v5 * v9;
  v13 = v9 * v10 - v8 * v11;
  if (v12 > 0.0 && (v13 >= 0.0 ? (v14 = v13 > v12) : (v14 = 1), !v14)
    || v12 < 0.0 && (v13 <= 0.0 ? (v15 = v13 < v12) : (v15 = 1), !v15))
  {
    v16 = v5 * v11 - v6 * v10;
    if (v12 > 0.0)
    {
      if (v16 > 0.0 && v16 < v12)
        return 1;
    }
    else if (v16 < 0.0 && v16 > v12)
    {
      return 1;
    }
  }
  return 0;
}

BOOL get_line_segment_intersection(const CGPoint *a1, const CGPoint *a2, const CGPoint *a3, const CGPoint *a4, CGPoint *a5)
{
  double x;
  double y;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  _BOOL4 v20;
  _BOOL8 result;

  x = a1->x;
  y = a1->y;
  v10 = TSDSubtractPoints(a2->x, a2->y, a1->x);
  v12 = v11;
  v13 = a3->x;
  v14 = a3->y;
  v15 = TSDSubtractPoints(a4->x, a4->y, a3->x);
  v17 = v10 * v16 - v15 * v12;
  v18 = (v10 * (y - v14) - v12 * (x - v13)) / v17;
  v19 = (v15 * (y - v14) - v16 * (x - v13)) / v17;
  v20 = v18 >= 0.0;
  if (v18 > 1.0)
    v20 = 0;
  if (v19 < 0.0)
    v20 = 0;
  result = v19 <= 1.0 && v20;
  if (a5)
  {
    if (result)
    {
      a5->x = x + v19 * v10;
      a5->y = y + v19 * v12;
    }
  }
  return result;
}

BOOL is_point_in_triangle(float *a1, float *a2)
{
  float v2;
  float v3;
  float v4;
  double v5;
  double v6;
  double v7;
  float v8;
  float v9;

  v3 = a2[2];
  v2 = a2[3];
  v4 = a2[1];
  v5 = *a1;
  v6 = a1[1];
  v7 = -((float)-(float)(v3 - *a2) * v4)
     - (float)(v2 - v4) * *a2
     + (float)-(float)(v3 - *a2) * v6
     + (float)(v2 - v4) * v5;
  v9 = a2[4];
  v8 = a2[5];
  return v7
       * (v6 * (float)-(float)(v9 - v3)
        + (float)(v8 - v2) * v5
        + -((float)-(float)(v9 - v3) * v2)
        - (float)(v8 - v2) * v3) > 0.0
      && v7
       * (v6 * (float)-(float)(*a2 - v9)
        + (float)(v4 - v8) * v5
        + -((float)-(float)(*a2 - v9) * v8)
        - (float)(v4 - v8) * v9) > 0.0;
}

BOOL do_triangles_intersect(float *a1, float *a2)
{
  uint64_t v4;
  uint64_t v5;
  float *v6;
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;
  uint64_t v11;
  char v13;

  v4 = 0;
  while (2)
  {
    v5 = v4;
    v6 = &a1[2 * v4++];
    if (v4 == 3)
      v7 = 0;
    else
      v7 = v5 + 1;
    v8 = &a1[2 * v7];
    v9 = -3;
    v10 = a2;
    while (v9)
    {
      v11 = v9 + 4;
      if (__CFADD__(v9++, 1))
        v11 = 0;
      v13 = do_line_segments_intersect(v6, v8, v10, &a2[2 * v11]);
      v10 += 2;
      if ((v13 & 1) != 0)
        return 1;
    }
    if (v4 != 3)
      continue;
    break;
  }
  if (is_point_in_triangle(a1, a2))
    return 1;
  return is_point_in_triangle(a2, a1);
}

BOOL clip_points_to_rect(CGPoint *a1, CGPoint *a2, const CGRect *a3)
{
  double x;
  double y;
  double width;
  double height;
  _BOOL8 result;
  CGFloat MinX;
  CGFloat MaxX;
  CGFloat v13;
  CGFloat v14;
  unint64_t v15;
  CGPoint *v16;
  CGPoint v17;
  double v18;
  double v19;
  double v20;
  double v21;
  BOOL v22;
  BOOL v23;
  CGPoint v24;
  CGPoint v25;
  CGPoint v26;
  _QWORD v27[9];
  CGRect v28;
  CGRect v29;
  CGRect v30;
  CGRect v31;
  CGRect v32;

  v27[8] = *MEMORY[0x24BDAC8D0];
  x = a3->origin.x;
  y = a3->origin.y;
  width = a3->size.width;
  height = a3->size.height;
  if (!TSDPointInRectInclusive(a1->x, a1->y, a3->origin.x, y, width, height)
    || !(result = TSDPointInRectInclusive(a2->x, a2->y, x, y, width, height)))
  {
    v28.origin.x = x;
    v28.origin.y = y;
    v28.size.width = width;
    v28.size.height = height;
    MinX = CGRectGetMinX(v28);
    v29 = *a3;
    *(CGFloat *)v27 = MinX;
    v27[1] = CGRectGetMinY(v29);
    MaxX = CGRectGetMaxX(*a3);
    v30 = *a3;
    *(CGFloat *)&v27[2] = MaxX;
    v27[3] = CGRectGetMinY(v30);
    v13 = CGRectGetMaxX(*a3);
    v31 = *a3;
    *(CGFloat *)&v27[4] = v13;
    v27[5] = CGRectGetMaxY(v31);
    v14 = CGRectGetMinX(*a3);
    v32 = *a3;
    v15 = 0;
    *(CGFloat *)&v27[6] = v14;
    v27[7] = CGRectGetMaxY(v32);
    v16 = (CGPoint *)v27;
    while (1)
    {
      v17 = *v16;
      v24 = *(CGPoint *)&v27[2 * ((v15 + 1) & 3)];
      v25 = v17;
      result = get_line_segment_intersection(a1, a2, &v25, &v24, &v26);
      if (result)
      {
        v18 = a3->origin.x;
        v19 = a3->origin.y;
        v20 = a3->size.width;
        v21 = a3->size.height;
        v22 = TSDPointInRectInclusive(a1->x, a1->y, a3->origin.x, v19, v20, v21);
        if (!v22)
        {
          *a1 = v26;
          v18 = a3->origin.x;
          v19 = a3->origin.y;
          v20 = a3->size.width;
          v21 = a3->size.height;
        }
        result = TSDPointInRectInclusive(a2->x, a2->y, v18, v19, v20, v21);
        if (!result)
        {
          *a2 = v26;
          return result;
        }
        v23 = !v22;
      }
      else
      {
        v23 = 0;
      }
      if (v15 <= 2)
      {
        ++v16;
        ++v15;
        if (!v23)
          continue;
      }
      return result;
    }
  }
  return result;
}

CGFloat segment_from_edge_clipped_to_rect@<D0>(uint64_t a1@<X0>, CGPoint *a2@<X8>, CGFloat a3@<D0>, CGFloat a4@<D1>, CGFloat a5@<D2>, CGFloat a6@<D3>)
{
  CGPoint v7;
  CGFloat result;
  CGPoint v9;
  CGPoint v10;
  CGPoint v11;
  CGRect v12;

  v12.origin.x = a3;
  v12.origin.y = a4;
  v12.size.width = a5;
  v12.size.height = a6;
  v7 = *(CGPoint *)*(_QWORD *)(a1 + 8);
  v10 = *(CGPoint *)*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v11 = v7;
  clip_points_to_rect(&v11, &v10, &v12);
  v9 = v10;
  result = v11.x;
  *a2 = v11;
  a2[1] = v9;
  return result;
}

double area_of_cell(double **a1)
{
  double *v1;
  double *v2;
  double result;

  v1 = *a1;
  v2 = a1[1];
  result = 0.0;
  if (*a1 != v2)
  {
    do
    {
      result = result + (v1[2] - *v1) * ((v1[1] + v1[3]) * 0.5);
      v1 += 4;
    }
    while (v1 != v2);
  }
  return result;
}

void sub_217A7CCF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_217A7DD08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,void *__p,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62,uint64_t a63)
{
  void *a65;
  uint64_t a66;

  a41 = &a38;
  std::vector<std::vector<boost::polygon::segment_data<double>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a41);
  a41 = &a45;
  std::vector<std::vector<boost::polygon::segment_data<double>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a41);
  if (__p)
  {
    a49 = (uint64_t)__p;
    operator delete(__p);
  }
  boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::~voronoi_diagram((uint64_t)&a51);
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy((uint64_t)&a62, (_QWORD *)a63);
  if (a65)
  {
    a66 = (uint64_t)a65;
    operator delete(a65);
  }
  _Unwind_Resume(a1);
}

void boost::polygon::construct_voronoi<std::__wrap_iter<boost::polygon::point_data<double> *>,std::__wrap_iter<boost::polygon::segment_data<double> *>,boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t a1, double *a2, double *a3, double *a4, void **a5)
{
  uint64_t v8;
  void *v9[2];
  __int128 v10;
  void *v11[4];
  void *__p;
  void *v13;
  uint64_t v14;
  __int16 v15;
  _QWORD v16[3];
  _QWORD **v17;
  _QWORD *v18[2];
  __int16 v19;
  uint64_t v20;

  __p = 0;
  v13 = 0;
  v15 = 0;
  v14 = 0;
  *(_OWORD *)v9 = 0u;
  v10 = 0u;
  memset(v11, 0, 25);
  v16[0] = v16;
  v16[1] = v16;
  v18[0] = 0;
  v18[1] = 0;
  v19 = 0;
  v16[2] = 0;
  v17 = v18;
  v20 = 0;
  boost::polygon::insert<std::__wrap_iter<boost::polygon::point_data<double> *>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>>(a1, a2, &v8);
  while (a3 != a4)
  {
    boost::polygon::insert<boost::polygon::segment_data<double>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>>(a3, &v8);
    a3 += 4;
  }
  boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::construct<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(&v8, a5);
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy((uint64_t)&v17, v18[0]);
  std::__list_imp<EQKit::StemStretch::FeatureRange::Span>::clear(v16);
  if (__p)
  {
    v13 = __p;
    operator delete(__p);
  }
  if (v11[0])
  {
    v11[1] = v11[0];
    operator delete(v11[0]);
  }
  if (v9[0])
  {
    v9[1] = v9[0];
    operator delete(v9[0]);
  }
}

void sub_217A7DF48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::~voronoi_builder((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<boost::polygon::segment_data<double>>::insert(_QWORD *a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  void *__p;
  char *v23;
  char *v24;
  char *v25;
  _QWORD *v26;

  v4 = (_QWORD *)a2;
  v6 = a1[1];
  v8 = (uint64_t)(a1 + 2);
  v7 = a1[2];
  if (v6 >= v7)
  {
    v9 = (_QWORD *)*a1;
    v10 = ((uint64_t)(v6 - *a1) >> 5) + 1;
    if (v10 >> 59)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v11 = a2 - (_QWORD)v9;
    v12 = (a2 - (uint64_t)v9) >> 5;
    v13 = v7 - (_QWORD)v9;
    if (v13 >> 4 > v10)
      v10 = v13 >> 4;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFE0)
      v14 = 0x7FFFFFFFFFFFFFFLL;
    else
      v14 = v10;
    v26 = a1 + 2;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>((uint64_t)(a1 + 2), v14);
    else
      v15 = 0;
    v16 = &v15[32 * v12];
    __p = v15;
    v23 = v16;
    v24 = v16;
    v25 = &v15[32 * v14];
    if (v12 == v14)
    {
      if (v11 < 1)
      {
        if (v9 == v4)
          v18 = 1;
        else
          v18 = v11 >> 4;
        v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>(v8, v18);
        v16 = &v19[32 * (v18 >> 2)];
        __p = v19;
        v23 = v16;
        v25 = &v19[32 * v20];
        if (v15)
          operator delete(v15);
      }
      else
      {
        v17 = v12 + 2;
        if (v12 >= -1)
          v17 = v12 + 1;
        v16 -= 32 * (v17 >> 1);
        v23 = v16;
      }
    }
    *(_OWORD *)v16 = 0u;
    *((_OWORD *)v16 + 1) = 0u;
    *(_QWORD *)v16 = *a3;
    *((_QWORD *)v16 + 1) = a3[1];
    *((_QWORD *)v16 + 2) = a3[2];
    *((_QWORD *)v16 + 3) = a3[3];
    v24 = v16 + 32;
    v4 = std::vector<boost::polygon::segment_data<double>>::__swap_out_circular_buffer(a1, &__p, v4);
    if (v24 != v23)
      v24 += (v23 - v24 + 31) & 0xFFFFFFFFFFFFFFE0;
    if (__p)
      operator delete(__p);
  }
  else if (a2 == v6)
  {
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_QWORD *)a2 = *a3;
    *(_QWORD *)(a2 + 8) = a3[1];
    *(_QWORD *)(a2 + 16) = a3[2];
    *(_QWORD *)(a2 + 24) = a3[3];
    a1[1] = a2 + 32;
  }
  else
  {
    std::vector<boost::polygon::segment_data<double>>::__move_range((uint64_t)a1, a2, v6, a2 + 32);
    if (v4 <= a3)
      a3 += 4 * (a1[1] > (unint64_t)a3);
    *v4 = *a3;
    v4[1] = a3[1];
    v4[2] = a3[2];
    v4[3] = a3[3];
  }
  return v4;
}

void sub_217A7E194(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::~voronoi_diagram(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v3;
    operator delete(v3);
  }
  v4 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v4;
    operator delete(v4);
  }
  return a1;
}

char *std::vector<boost::polygon::segment_data<double>>::__init_with_size[abi:ne180100]<boost::polygon::segment_data<double>*,boost::polygon::segment_data<double>*>(char *result, _QWORD *a2, _QWORD *a3, unint64_t a4)
{
  char *v6;
  uint64_t i;

  if (a4)
  {
    v6 = result;
    result = std::vector<boost::polygon::segment_data<double>>::__vallocate[abi:ne180100](result, a4);
    for (i = *((_QWORD *)v6 + 1); a2 != a3; a2 += 4)
    {
      *(_OWORD *)i = 0uLL;
      *(_OWORD *)(i + 16) = 0uLL;
      *(_QWORD *)i = *a2;
      *(_QWORD *)(i + 8) = a2[1];
      *(_QWORD *)(i + 16) = a2[2];
      *(_QWORD *)(i + 24) = a2[3];
      i += 32;
    }
    *((_QWORD *)v6 + 1) = i;
  }
  return result;
}

void sub_217A7E5B4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<boost::polygon::segment_data<double>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 59)
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(32 * a2);
}

uint64_t *std::__tree<boost::polygon::point_data<double>>::__emplace_unique_key_args<boost::polygon::point_data<double>,boost::polygon::point_data<double> const&>(uint64_t **a1, double *a2, _OWORD *a3)
{
  void **v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t v9;

  v5 = (void **)std::__tree<boost::polygon::point_data<double>>::__find_equal<boost::polygon::point_data<double>>((uint64_t)a1, &v9, a2);
  v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v6 + 2) = *a3;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

_QWORD *std::__tree<boost::polygon::point_data<double>>::__find_equal<boost::polygon::point_data<double>>(uint64_t a1, _QWORD *a2, double *a3)
{
  _QWORD *result;
  uint64_t *v4;
  uint64_t *v5;
  double v6;
  double v7;
  _QWORD *v8;
  double v9;
  double v10;

  v5 = *(uint64_t **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    v6 = *a3;
    v7 = a3[1];
    while (1)
    {
      while (1)
      {
        v8 = v4;
        v9 = *((double *)v4 + 4);
        if (v6 >= v9)
          break;
LABEL_6:
        v4 = (uint64_t *)*v4;
        result = v8;
        if (!*v8)
          goto LABEL_18;
      }
      if (v6 == v9)
      {
        v10 = *((double *)v4 + 5);
        if (v7 < v10)
          goto LABEL_6;
        if (v9 >= v6 && v10 >= v7)
          goto LABEL_18;
      }
      else if (v9 >= v6)
      {
        goto LABEL_18;
      }
      result = v4 + 1;
      v4 = (uint64_t *)v4[1];
      if (!v4)
        goto LABEL_18;
    }
  }
  v8 = result;
LABEL_18:
  *a2 = v8;
  return result;
}

double *std::__tree<boost::polygon::point_data<double>>::find<boost::polygon::point_data<double>>(uint64_t a1, double *a2)
{
  double *v2;
  double *v3;
  double *v4;
  double v5;
  double v6;
  double *v7;
  double v8;
  double v9;

  v4 = *(double **)(a1 + 8);
  v2 = (double *)(a1 + 8);
  v3 = v4;
  if (!v4)
    return v2;
  v6 = *a2;
  v5 = a2[1];
  v7 = v2;
  do
  {
    v8 = v3[4];
    if (v8 >= v6)
    {
      if (v8 == v6)
      {
        if (v3[5] < v5)
          ++v3;
        else
          v7 = v3;
      }
      else
      {
        v7 = v3;
      }
    }
    else
    {
      ++v3;
    }
    v3 = *(double **)v3;
  }
  while (v3);
  if (v7 == v2)
    return v2;
  v9 = v7[4];
  if (v6 < v9 || v6 == v9 && v5 < v7[5])
    return v2;
  return v7;
}

uint64_t boost::polygon::insert<std::__wrap_iter<boost::polygon::point_data<double> *>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>>(uint64_t result, double *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  double *v7;
  double v8;
  double v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;

  if ((double *)result != a2)
  {
    v12 = v3;
    v13 = v4;
    v7 = (double *)result;
    do
    {
      v8 = *v7;
      v9 = v7[1];
      v7 += 2;
      v10 = (int)v9;
      v11 = (int)v8;
      result = boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_point(a3, &v11, &v10);
    }
    while (v7 != a2);
  }
  return result;
}

void boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::construct<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t *a1, void **a2)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int *v7;
  _QWORD *v8;
  _QWORD *v9;
  _BYTE v10[2];

  boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_reserve(a2, -858993459 * ((unint64_t)(a1[2] - a1[1]) >> 3));
  boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::init_sites_queue((uint64_t)a1);
  boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::init_beach_line<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(a1, a2);
  v4 = a1[9];
  v5 = a1[10];
LABEL_2:
  while (1)
  {
    v6 = (int *)a1[2];
    v7 = (int *)a1[4];
    if (v4 == v5)
      break;
    if (v7 == v6
      || !boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()((uint64_t)v10, v7, *(_QWORD *)v4 + 16))
    {
      boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::process_circle_event<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>((uint64_t)a1, a2);
      goto LABEL_8;
    }
LABEL_7:
    boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::process_site_event<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>((uint64_t)a1, (char **)a2);
LABEL_8:
    v4 = a1[9];
    v5 = v4;
    if (v4 != a1[10])
    {
      v5 = a1[10];
      if (!*(_BYTE *)(*(_QWORD *)v4 + 40))
      {
        while (1)
        {
          boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::pop((uint64_t)(a1 + 9));
          v4 = a1[9];
          v5 = a1[10];
          if (v4 == v5)
            break;
          if (*(_BYTE *)(*(_QWORD *)v4 + 40))
            goto LABEL_2;
        }
        v5 = a1[9];
      }
    }
  }
  if (v7 != v6)
    goto LABEL_7;
  v9 = (_QWORD *)a1[17];
  v8 = a1 + 17;
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy((uint64_t)(v8 - 1), v9);
  *(v8 - 1) = v8;
  *v8 = 0;
  v8[1] = 0;
  boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_build((uint64_t *)a2);
}

uint64_t boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::~voronoi_builder(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy(a1 + 128, *(_QWORD **)(a1 + 136));
  std::__list_imp<EQKit::StemStretch::FeatureRange::Span>::clear((_QWORD *)(a1 + 104));
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 40);
  if (v3)
  {
    *(_QWORD *)(a1 + 48) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(a1 + 8);
  if (v4)
  {
    *(_QWORD *)(a1 + 16) = v4;
    operator delete(v4);
  }
  return a1;
}

uint64_t boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_point(_QWORD *a1, int *a2, int *a3)
{
  uint64_t v4;
  unint64_t v5;
  int v6;
  int v7;
  char *v8;
  char *v9;
  void **v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  __int128 v20;
  uint64_t result;

  v4 = (uint64_t)(a1 + 3);
  v5 = a1[3];
  v6 = *a2;
  v7 = *a3;
  v8 = (char *)a1[2];
  if ((unint64_t)v8 >= v5)
  {
    v10 = (void **)(a1 + 1);
    v11 = (char *)a1[1];
    v12 = 0xCCCCCCCCCCCCCCCDLL * ((v8 - v11) >> 3);
    v13 = v12 + 1;
    if (v12 + 1 > 0x666666666666666)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v14 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - (_QWORD)v11) >> 3);
    if (2 * v14 > v13)
      v13 = 2 * v14;
    if (v14 >= 0x333333333333333)
      v15 = 0x666666666666666;
    else
      v15 = v13;
    if (v15)
    {
      v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::detail::site_event<int>>>(v4, v15);
      v11 = (char *)a1[1];
      v8 = (char *)a1[2];
    }
    else
    {
      v16 = 0;
    }
    v17 = &v16[40 * v12];
    *(_DWORD *)v17 = v6;
    *((_DWORD *)v17 + 1) = v7;
    *((_DWORD *)v17 + 2) = v6;
    *((_DWORD *)v17 + 3) = v7;
    v18 = &v16[40 * v15];
    *((_QWORD *)v17 + 2) = 0;
    *((_QWORD *)v17 + 4) = 0;
    v9 = v17 + 40;
    if (v8 != v11)
    {
      do
      {
        v19 = *(_OWORD *)(v8 - 40);
        v20 = *(_OWORD *)(v8 - 24);
        *((_QWORD *)v17 - 1) = *((_QWORD *)v8 - 1);
        *(_OWORD *)(v17 - 24) = v20;
        *(_OWORD *)(v17 - 40) = v19;
        v17 -= 40;
        v8 -= 40;
      }
      while (v8 != v11);
      v11 = (char *)*v10;
    }
    a1[1] = v17;
    a1[2] = v9;
    a1[3] = v18;
    if (v11)
      operator delete(v11);
  }
  else
  {
    *(_DWORD *)v8 = v6;
    *((_DWORD *)v8 + 1) = v7;
    *((_DWORD *)v8 + 2) = v6;
    *((_DWORD *)v8 + 3) = v7;
    *((_QWORD *)v8 + 2) = 0;
    v9 = v8 + 40;
    *((_QWORD *)v8 + 4) = 0;
  }
  a1[2] = v9;
  result = a1[347];
  *((_QWORD *)v9 - 2) = result;
  a1[347] = result + 1;
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::detail::site_event<int>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(40 * a2);
}

uint64_t boost::polygon::insert<boost::polygon::segment_data<double>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>>(double *a1, _QWORD *a2)
{
  double v2;
  int v3;
  double v4;
  int v6;
  int v7;
  int v8;
  int v9;

  v2 = a1[1];
  v9 = (int)*a1;
  v3 = (int)v2;
  v4 = a1[3];
  v7 = (int)a1[2];
  v8 = v3;
  v6 = (int)v4;
  return boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_segment(a2, (unsigned int *)&v9, (unsigned int *)&v8, (unsigned int *)&v7, (unsigned int *)&v6);
}

uint64_t boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_segment(_QWORD *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  char **v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t *v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  _BOOL4 v45;
  unint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  char *v59;
  char *v60;
  char *v61;
  char *v62;
  __int128 v63;
  __int128 v64;
  char *v65;
  char *v66;
  char *v67;
  char *v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;
  uint64_t result;
  char **v73;

  v8 = *a2;
  v9 = *a3;
  v11 = (uint64_t)(a1 + 3);
  v10 = a1[3];
  v12 = (char **)(a1 + 1);
  v13 = v8 | (v9 << 32);
  v14 = (uint64_t *)a1[2];
  v73 = (char **)(a1 + 1);
  if ((unint64_t)v14 >= v10)
  {
    v16 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v14 - *v12) >> 3);
    v17 = v16 + 1;
    if (v16 + 1 > 0x666666666666666)
      goto LABEL_72;
    v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - (_QWORD)*v12) >> 3);
    if (2 * v18 > v17)
      v17 = 2 * v18;
    if (v18 >= 0x333333333333333)
      v19 = 0x666666666666666;
    else
      v19 = v17;
    if (v19)
    {
      v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::detail::site_event<int>>>((uint64_t)(a1 + 3), v19);
      v12 = v73;
    }
    else
    {
      v20 = 0;
    }
    v21 = &v20[40 * v16];
    v22 = &v20[40 * v19];
    *(_QWORD *)v21 = v13;
    *((_QWORD *)v21 + 1) = v13;
    *((_QWORD *)v21 + 2) = 0;
    *((_QWORD *)v21 + 4) = 0;
    v15 = (uint64_t *)(v21 + 40);
    v24 = (char *)a1[1];
    v23 = (char *)a1[2];
    if (v23 != v24)
    {
      do
      {
        v25 = *(_OWORD *)(v23 - 40);
        v26 = *(_OWORD *)(v23 - 24);
        *((_QWORD *)v21 - 1) = *((_QWORD *)v23 - 1);
        *(_OWORD *)(v21 - 24) = v26;
        *(_OWORD *)(v21 - 40) = v25;
        v21 -= 40;
        v23 -= 40;
      }
      while (v23 != v24);
      v23 = *v12;
    }
    a1[1] = v21;
    a1[2] = v15;
    a1[3] = v22;
    if (v23)
    {
      operator delete(v23);
      v12 = v73;
    }
  }
  else
  {
    *v14 = v13;
    v14[1] = v13;
    v14[2] = 0;
    v15 = v14 + 5;
    v14[4] = 0;
  }
  a1[2] = v15;
  v27 = *(v15 - 1) | 1;
  *(v15 - 2) = a1[347];
  *(v15 - 1) = v27;
  v28 = *a4;
  v29 = *a5;
  v30 = v28 | (v29 << 32);
  v31 = a1[3];
  if ((unint64_t)v15 >= v31)
  {
    v33 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v15 - *v12) >> 3);
    if (v33 + 1 > 0x666666666666666)
      goto LABEL_72;
    v34 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v31 - (_QWORD)*v12) >> 3);
    v35 = 2 * v34;
    if (2 * v34 <= v33 + 1)
      v35 = v33 + 1;
    if (v34 >= 0x333333333333333)
      v36 = 0x666666666666666;
    else
      v36 = v35;
    if (v36)
    {
      v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::detail::site_event<int>>>(v11, v36);
      v12 = v73;
    }
    else
    {
      v37 = 0;
    }
    v38 = &v37[40 * v33];
    v39 = &v37[40 * v36];
    *(_QWORD *)v38 = v30;
    *((_QWORD *)v38 + 1) = v30;
    *((_QWORD *)v38 + 2) = 0;
    *((_QWORD *)v38 + 4) = 0;
    v32 = (uint64_t *)(v38 + 40);
    v41 = (char *)a1[1];
    v40 = (char *)a1[2];
    if (v40 != v41)
    {
      do
      {
        v42 = *(_OWORD *)(v40 - 40);
        v43 = *(_OWORD *)(v40 - 24);
        *((_QWORD *)v38 - 1) = *((_QWORD *)v40 - 1);
        *(_OWORD *)(v38 - 24) = v43;
        *(_OWORD *)(v38 - 40) = v42;
        v38 -= 40;
        v40 -= 40;
      }
      while (v40 != v41);
      v40 = *v12;
    }
    a1[1] = v38;
    a1[2] = v32;
    a1[3] = v39;
    if (v40)
    {
      operator delete(v40);
      v12 = v73;
    }
  }
  else
  {
    *v15 = v30;
    v15[1] = v30;
    v15[2] = 0;
    v32 = v15 + 5;
    v15[4] = 0;
  }
  a1[2] = v32;
  v44 = *(v32 - 1) | 2;
  *(v32 - 2) = a1[347];
  *(v32 - 1) = v44;
  v45 = (int)v8 < (int)v28;
  if ((_DWORD)v8 == (_DWORD)v28)
    v45 = (int)v9 < (int)v29;
  v46 = a1[3];
  if (v45)
  {
    if ((unint64_t)v32 < v46)
    {
      *v32 = v13;
      v32[1] = v30;
      v32[2] = 0;
      v47 = v32 + 5;
      v48 = 8;
LABEL_40:
      v32[4] = 0;
      goto LABEL_71;
    }
    v49 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v32 - *v12) >> 3);
    if (v49 + 1 <= 0x666666666666666)
    {
      v50 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v46 - (_QWORD)*v12) >> 3);
      v51 = 2 * v50;
      if (2 * v50 <= v49 + 1)
        v51 = v49 + 1;
      if (v50 >= 0x333333333333333)
        v52 = 0x666666666666666;
      else
        v52 = v51;
      if (v52)
      {
        v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::detail::site_event<int>>>(v11, v52);
        v12 = v73;
      }
      else
      {
        v53 = 0;
      }
      v59 = &v53[40 * v49];
      v60 = &v53[40 * v52];
      *(_QWORD *)v59 = v13;
      *((_QWORD *)v59 + 1) = v30;
      *((_QWORD *)v59 + 2) = 0;
      *((_QWORD *)v59 + 4) = 0;
      v47 = v59 + 40;
      v62 = (char *)a1[1];
      v61 = (char *)a1[2];
      if (v61 != v62)
      {
        do
        {
          v63 = *(_OWORD *)(v61 - 40);
          v64 = *(_OWORD *)(v61 - 24);
          *((_QWORD *)v59 - 1) = *((_QWORD *)v61 - 1);
          *(_OWORD *)(v59 - 24) = v64;
          *(_OWORD *)(v59 - 40) = v63;
          v59 -= 40;
          v61 -= 40;
        }
        while (v61 != v62);
        v61 = *v12;
      }
      a1[1] = v59;
      a1[2] = v47;
      a1[3] = v60;
      if (v61)
        operator delete(v61);
      v48 = 8;
      goto LABEL_71;
    }
LABEL_72:
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  }
  if ((unint64_t)v32 < v46)
  {
    *v32 = v30;
    v32[1] = v13;
    v32[2] = 0;
    v47 = v32 + 5;
    v48 = 9;
    goto LABEL_40;
  }
  v54 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v32 - *v12) >> 3);
  if (v54 + 1 > 0x666666666666666)
    goto LABEL_72;
  v55 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v46 - (_QWORD)*v12) >> 3);
  v56 = 2 * v55;
  if (2 * v55 <= v54 + 1)
    v56 = v54 + 1;
  if (v55 >= 0x333333333333333)
    v57 = 0x666666666666666;
  else
    v57 = v56;
  if (v57)
  {
    v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::detail::site_event<int>>>(v11, v57);
    v12 = v73;
  }
  else
  {
    v58 = 0;
  }
  v65 = &v58[40 * v54];
  v66 = &v58[40 * v57];
  *(_QWORD *)v65 = v30;
  *((_QWORD *)v65 + 1) = v13;
  *((_QWORD *)v65 + 2) = 0;
  *((_QWORD *)v65 + 4) = 0;
  v47 = v65 + 40;
  v68 = (char *)a1[1];
  v67 = (char *)a1[2];
  if (v67 != v68)
  {
    do
    {
      v69 = *(_OWORD *)(v67 - 40);
      v70 = *(_OWORD *)(v67 - 24);
      *((_QWORD *)v65 - 1) = *((_QWORD *)v67 - 1);
      *(_OWORD *)(v65 - 24) = v70;
      *(_OWORD *)(v65 - 40) = v69;
      v65 -= 40;
      v67 -= 40;
    }
    while (v67 != v68);
    v67 = *v12;
  }
  a1[1] = v65;
  a1[2] = v47;
  a1[3] = v66;
  if (v67)
    operator delete(v67);
  v48 = 9;
LABEL_71:
  a1[2] = v47;
  v71 = *(v47 - 1);
  result = a1[347];
  *(v47 - 2) = result;
  *(v47 - 1) = v71 | v48;
  a1[347] = result + 1;
  return result;
}

void boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_reserve(void **a1, int a2)
{
  std::vector<boost::polygon::voronoi_cell<double>>::reserve(a1, a2);
  std::vector<boost::polygon::voronoi_vertex<double>>::reserve(a1 + 3, 2 * a2);
  std::vector<boost::polygon::voronoi_edge<double>>::reserve(a1 + 6, 6 * a2);
}

unsigned int *boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::init_sites_queue(uint64_t a1)
{
  uint64_t v2;
  int *v3;
  unint64_t v4;
  uint64_t v5;
  unsigned int *result;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  __int16 v11;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(int **)(a1 + 16);
  v4 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v3 - v2) >> 3));
  v11 = 0;
  if (v3 == (int *)v2)
    v5 = 0;
  else
    v5 = v4;
  std::__introsort<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*,false>(v2, v3, (uint64_t)&v11, v5, 1);
  result = std::__unique[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__equal_to &>(*(unsigned int **)(a1 + 8), *(unsigned int **)(a1 + 16));
  v7 = *(_QWORD *)(a1 + 8);
  if (*(unsigned int **)(a1 + 16) != result)
    *(_QWORD *)(a1 + 16) = result;
  if (result != (unsigned int *)v7)
  {
    v8 = 0;
    v9 = ((uint64_t)result - v7) / 40;
    if (v9 <= 1)
      v9 = 1;
    v10 = (_QWORD *)(v7 + 16);
    do
    {
      *v10 = v8;
      v10 += 5;
      ++v8;
    }
    while (v9 != v8);
  }
  *(_QWORD *)(a1 + 32) = v7;
  return result;
}

void boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::init_beach_line<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t *a1, void **a2)
{
  __int128 *v3;
  __int128 *v4;
  __int128 *v6;
  int v7;
  int v8;

  v3 = (__int128 *)a1[1];
  v4 = (__int128 *)a1[2];
  if (v3 != v4)
  {
    if ((char *)v4 - (char *)v3 == 40)
    {
      boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_process_single_site<int>(a2, (uint64_t)v3);
    }
    else
    {
      v6 = (__int128 *)a1[4];
      if (v6 == v4)
        goto LABEL_13;
      v7 = 0;
      v8 = *(_DWORD *)v3;
      do
      {
        if (*(_DWORD *)v6 != v8)
          break;
        if (v8 != *((_DWORD *)v6 + 2))
          break;
        v6 = (__int128 *)((char *)v6 + 40);
        a1[4] = (uint64_t)v6;
        ++v7;
      }
      while (v6 != v4);
      if (v7 != 1)
      {
LABEL_13:
        boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::init_beach_line_collinear_sites<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(a1, (char **)a2);
        return;
      }
      boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_new_arc<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>((uint64_t)a1, v3, (uint64_t)v3, (uint64_t)v3 + 40, a1 + 17, (char **)a2);
    }
    a1[4] += 40;
  }
}

void boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::process_site_event<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t a1, char **a2)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  int *v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  _QWORD *v14;
  int *v15;
  int v16;
  int v17;
  BOOL v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _QWORD *v23;
  uint64_t *v24;
  uint64_t *v25;
  int v26;
  _QWORD *v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  int *v34;
  int *v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int *v40;
  int *v41;
  _OWORD v42[2];
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 32);
  v6 = *(_OWORD *)(v4 + 16);
  v47 = *(_OWORD *)v4;
  v48 = v6;
  v49 = v5;
  v7 = (int *)(v4 + 40);
  v8 = v47;
  if ((_DWORD)v47 == DWORD2(v47) && (v9 = DWORD1(v47), DWORD1(v47) == HIDWORD(v47)))
  {
    v10 = *(_QWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 48);
    if (v10 != v11)
    {
      do
      {
        if (*(_DWORD *)v10 != v8 || *(_DWORD *)(v10 + 4) != v9)
          break;
        v12 = *(uint64_t **)(v10 + 8);
        LOBYTE(v42[0]) = *(_BYTE *)(a1 + 64);
        if (v11 - v10 >= 17)
        {
          v13 = *(_QWORD *)v10;
          v14 = (_QWORD *)std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::end_point_comparison &,std::__wrap_iter<std::pair<boost::polygon::detail::point_2d<int>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>> *>>((_QWORD *)v10, (uint64_t)v42, (unint64_t)(v11 - v10) >> 4);
          if ((_QWORD *)(v11 - 16) == v14)
          {
            *v14 = v13;
            v14[1] = v12;
          }
          else
          {
            *v14 = *(_QWORD *)(v11 - 16);
            v14[1] = *(_QWORD *)(v11 - 8);
            *(_QWORD *)(v11 - 16) = v13;
            *(_QWORD *)(v11 - 8) = v12;
            std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::end_point_comparison &,std::__wrap_iter<std::pair<boost::polygon::detail::point_2d<int>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>> *>>(v10, (uint64_t)(v14 + 2), (uint64_t)v42, ((uint64_t)v14 - v10 + 16) >> 4);
          }
        }
        *(_QWORD *)(a1 + 48) -= 16;
        std::__tree<std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,EQKit::Config::Operator::Form>>>::__remove_node_pointer((uint64_t **)(a1 + 128), v12);
        operator delete(v12);
        v10 = *(_QWORD *)(a1 + 40);
        v11 = *(_QWORD *)(a1 + 48);
      }
      while (v10 != v11);
      v4 = *(_QWORD *)(a1 + 32);
    }
  }
  else
  {
    v15 = *(int **)(a1 + 16);
    if (v7 != v15)
    {
      do
      {
        v16 = *v7;
        if (*v7 == v7[2])
        {
          v17 = v7[1];
          v18 = v16 != (_DWORD)v47 || v17 == v7[3];
          if (v18)
            goto LABEL_25;
        }
        else
        {
          if (v16 != (_DWORD)v47)
            goto LABEL_25;
          v17 = v7[1];
        }
        if (v17 != DWORD1(v47))
          goto LABEL_25;
        v7 += 10;
      }
      while (v7 != v15);
      v7 = *(int **)(a1 + 16);
    }
  }
LABEL_25:
  v19 = *(_OWORD *)v4;
  v20 = *(_OWORD *)(v4 + 16);
  v43 = *(_QWORD *)(v4 + 32);
  v42[0] = v19;
  v42[1] = v20;
  v21 = *(_OWORD *)v4;
  v22 = *(_OWORD *)(v4 + 16);
  v46 = *(_QWORD *)(v4 + 32);
  v45 = v22;
  v44 = v21;
  v24 = (uint64_t *)(a1 + 136);
  v23 = *(_QWORD **)(a1 + 136);
  v25 = (uint64_t *)(a1 + 136);
  if (v23)
  {
    v25 = (uint64_t *)(a1 + 136);
    do
    {
      v26 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()(a1 + 152, (uint64_t)(v23 + 4), (uint64_t)v42);
      v27 = v23 + 1;
      if (!v26)
      {
        v27 = v23;
        v25 = v23;
      }
      v23 = (_QWORD *)*v27;
    }
    while (*v27);
    v4 = *(_QWORD *)(a1 + 32);
  }
  while ((int *)v4 != v7)
  {
    v28 = *(_OWORD *)v4;
    v29 = *(_OWORD *)(v4 + 16);
    v49 = *(_QWORD *)(v4 + 32);
    v47 = v28;
    v48 = v29;
    if (v25 == v24)
    {
      v37 = *v24;
      v38 = a1 + 136;
      if (*v24)
      {
        do
        {
          v39 = v37;
          v37 = *(_QWORD *)(v37 + 8);
        }
        while (v37);
      }
      else
      {
        do
        {
          v39 = *(_QWORD *)(v38 + 16);
          v18 = *(_QWORD *)v39 == v38;
          v38 = v39;
        }
        while (v18);
      }
      v40 = (int *)(v39 + 32);
      v41 = (int *)(v39 + 72);
      v25 = boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_new_arc<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(a1, (__int128 *)(v39 + 72), v39 + 72, (uint64_t)&v47, v25, a2);
      boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::activate_circle_event(a1, v40, v41, (int *)&v47, (uint64_t)v25);
    }
    else
    {
      if (v25 == *(uint64_t **)(a1 + 128))
      {
        v36 = boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_new_arc<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(a1, (__int128 *)v25 + 2, (uint64_t)(v25 + 4), (uint64_t)&v47, v25, a2);
      }
      else
      {
        v30 = v25[14];
        if (v30)
        {
          *(_BYTE *)(v30 + 24) = 0;
          v25[14] = 0;
        }
        v31 = *v25;
        v32 = v25;
        if (*v25)
        {
          do
          {
            v33 = v31;
            v31 = *(_QWORD *)(v31 + 8);
          }
          while (v31);
        }
        else
        {
          do
          {
            v33 = v32[2];
            v18 = *(_QWORD *)v33 == (_QWORD)v32;
            v32 = (uint64_t *)v33;
          }
          while (v18);
        }
        v34 = (int *)(v33 + 32);
        v35 = (int *)(v33 + 72);
        v36 = boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_new_arc<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(a1, (__int128 *)(v33 + 72), (uint64_t)(v25 + 4), (uint64_t)&v47, v25, a2);
        boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::activate_circle_event(a1, v34, v35, (int *)&v47, (uint64_t)v36);
      }
      if ((_QWORD)v47 != *((_QWORD *)&v47 + 1))
        v49 ^= 0x20uLL;
      boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::activate_circle_event(a1, (int *)&v47, (int *)v25 + 8, (int *)v25 + 18, (uint64_t)v25);
      v25 = v36;
    }
    v4 = *(_QWORD *)(a1 + 32) + 40;
    *(_QWORD *)(a1 + 32) = v4;
  }
}

void boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::process_circle_event<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  __int128 v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  _QWORD *v13;
  __int128 v14;
  int v15;
  _DWORD *v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD v25[2];
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v3 = a1 + 72;
  v4 = **(_QWORD **)(a1 + 72);
  v5 = (uint64_t *)(v4 + 16);
  v6 = *(_QWORD *)(v4 + 48);
  v7 = *(_OWORD *)(v6 + 88);
  v27 = *(_OWORD *)(v6 + 72);
  v28 = v7;
  v29 = *(_QWORD *)(v6 + 104);
  v8 = *(_QWORD **)(v6 + 120);
  v9 = *(_QWORD *)v6;
  if (*(_QWORD *)v6)
  {
    do
    {
      v10 = v9;
      v9 = *(_QWORD *)(v9 + 8);
    }
    while (v9);
  }
  else
  {
    v11 = v6;
    do
    {
      v10 = *(_QWORD *)(v11 + 16);
      v12 = *(_QWORD *)v10 == v11;
      v11 = v10;
    }
    while (v12);
  }
  v13 = *(_QWORD **)(v10 + 120);
  v14 = *(_OWORD *)(v10 + 48);
  v25[0] = *(_OWORD *)(v10 + 32);
  v25[1] = v14;
  v26 = *(_QWORD *)(v10 + 64);
  if (*(_QWORD *)&v25[0] == *((_QWORD *)&v25[0] + 1))
  {
    v15 = v27;
    if ((_QWORD)v27 != *((_QWORD *)&v27 + 1))
    {
      if ((v29 & 0x20) == 0)
        v15 = DWORD2(v27);
      if (v15 == LODWORD(v25[0]))
      {
        v16 = (_DWORD *)&v27 + 1;
        if ((v29 & 0x20) == 0)
          v16 = (_DWORD *)((unint64_t)&v27 | 0xC);
        if (*v16 == DWORD1(v25[0]))
          v29 ^= 0x20uLL;
      }
    }
  }
  v17 = v28;
  *(_OWORD *)(v10 + 72) = v27;
  *(_OWORD *)(v10 + 88) = v17;
  *(_QWORD *)(v10 + 104) = v29;
  *(_QWORD *)(v10 + 120) = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_insert_new_edge<int,double>(a2, (uint64_t)v25, (uint64_t)&v27, v5, v13, v8);
  std::__tree<std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,EQKit::Config::Operator::Form>>>::__remove_node_pointer((uint64_t **)(a1 + 128), (uint64_t *)v6);
  operator delete((void *)v6);
  boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::pop(v3);
  if (v10 != *(_QWORD *)(a1 + 128))
  {
    v18 = *(_QWORD *)(v10 + 112);
    if (v18)
    {
      *(_BYTE *)(v18 + 24) = 0;
      *(_QWORD *)(v10 + 112) = 0;
    }
    v19 = *(_QWORD *)v10;
    if (*(_QWORD *)v10)
    {
      do
      {
        v20 = v19;
        v19 = *(_QWORD *)(v19 + 8);
      }
      while (v19);
    }
    else
    {
      v21 = v10;
      do
      {
        v20 = *(_QWORD *)(v21 + 16);
        v12 = *(_QWORD *)v20 == v21;
        v21 = v20;
      }
      while (v12);
    }
    boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::activate_circle_event(a1, (int *)(v20 + 32), (int *)v25, (int *)&v27, v10);
  }
  v22 = *(_QWORD **)(v10 + 8);
  if (v22)
  {
    do
    {
      v23 = (uint64_t)v22;
      v22 = (_QWORD *)*v22;
    }
    while (v22);
  }
  else
  {
    do
    {
      v23 = *(_QWORD *)(v10 + 16);
      v12 = *(_QWORD *)v23 == v10;
      v10 = v23;
    }
    while (!v12);
  }
  if (v23 != a1 + 136)
  {
    v24 = *(_QWORD *)(v23 + 112);
    if (v24)
    {
      *(_BYTE *)(v24 + 24) = 0;
      *(_QWORD *)(v23 + 112) = 0;
    }
    boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::activate_circle_event(a1, (int *)v25, (int *)&v27, (int *)(v23 + 72), v23);
  }
}

BOOL boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(uint64_t a1, int *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  double v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  double v10;
  unint64_t v11;
  int v12;

  v3 = *a2;
  v4 = *(_QWORD *)(a3 + 16);
  if (*a2 >= 0)
    *(_QWORD *)&v5 = 0x8000000000000000 - COERCE__INT64((double)v3);
  else
    v5 = (double)v3;
  if (v4 >= 0)
    v4 = 0x8000000000000000 - v4;
  if ((unint64_t)(*(_QWORD *)&v5 - v4) <= 0x40)
    v6 = 0;
  else
    v6 = -1;
  if (*(_QWORD *)&v5 > (unint64_t)v4)
    v7 = v6;
  else
    v7 = (unint64_t)(v4 - *(_QWORD *)&v5) > 0x40;
  if (!v7)
  {
    v8 = a2[1];
    v9 = *(_QWORD *)(a3 + 8);
    if (v8 >= 0)
      *(_QWORD *)&v10 = 0x8000000000000000 - COERCE__INT64((double)v8);
    else
      v10 = (double)v8;
    v11 = 0x8000000000000000 - v9;
    if (v9 < 0)
      v11 = *(_QWORD *)(a3 + 8);
    if (*(_QWORD *)&v10 - v11 <= 0x40)
      v12 = 0;
    else
      v12 = -1;
    if (*(_QWORD *)&v10 > v11)
      v7 = v12;
    else
      v7 = v11 - *(_QWORD *)&v10 > 0x40;
  }
  return v7 == -1;
}

void boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::pop(uint64_t a1)
{
  uint64_t **v2;
  uint64_t v3;
  uint64_t *v4;
  _QWORD *v5;
  uint64_t **v6;
  uint64_t v7;
  __int16 v8;

  v2 = *(uint64_t ***)a1;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = **(uint64_t ***)a1;
  v8 = *(_WORD *)(a1 + 24);
  if (v3 - (uint64_t)v2 >= 9)
  {
    v5 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::comparison &,std::__wrap_iter<std::__list_iterator<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,void *> *>>(v2, (uint64_t)&v8, (unint64_t)(v3 - (_QWORD)v2) >> 3);
    v6 = (uint64_t **)(v3 - 8);
    if ((_QWORD *)(v3 - 8) == v5)
    {
      *v5 = v4;
    }
    else
    {
      *v5 = *v6;
      *v6 = v4;
      std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::comparison &,std::__wrap_iter<std::__list_iterator<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,void *> *>>((_BOOL8)v2, (uint64_t)(v5 + 1), (uint64_t)&v8, (uint64_t **)(v5 + 1) - v2);
    }
  }
  *(_QWORD *)(a1 + 8) -= 8;
  v7 = *v4;
  *(_QWORD *)(v7 + 8) = v4[1];
  *(_QWORD *)v4[1] = v7;
  --*(_QWORD *)(a1 + 48);
  operator delete(v4);
}

void boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_build(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  unint64_t *v5;
  uint64_t *v6;
  BOOL v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  size_t v17;
  uint64_t v18;
  _OWORD *v19;
  _OWORD *v20;
  _OWORD *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *i;
  _QWORD *v35;
  _QWORD *v36;

  v2 = a1[6];
  if (v2 != a1[7])
  {
    v3 = -v2;
    v4 = (char *)a1[6];
    do
    {
      v5 = (unint64_t *)*((_QWORD *)v4 + 1);
      v6 = *(uint64_t **)(*((_QWORD *)v4 + 2) + 8);
      if (v5)
        v7 = v6 == 0;
      else
        v7 = 1;
      if (v7
        || !boost::polygon::voronoi_diagram_traits<double>::vertex_equality_predicate_type::operator()((uint64_t)(a1 + 9), v5, v6))
      {
        if (v4 != (char *)v2)
        {
          v8 = *(_OWORD *)v4;
          v9 = *((_OWORD *)v4 + 2);
          *(_OWORD *)(v2 + 16) = *((_OWORD *)v4 + 1);
          *(_OWORD *)(v2 + 32) = v9;
          *(_OWORD *)v2 = v8;
          v10 = v2 + 48;
          v11 = *((_OWORD *)v4 + 5);
          v12 = *((_OWORD *)v4 + 3);
          *(_OWORD *)(v2 + 64) = *((_OWORD *)v4 + 4);
          *(_OWORD *)(v2 + 80) = v11;
          *(_OWORD *)(v2 + 48) = v12;
          *(_QWORD *)(v2 + 16) = v2 + 48;
          *(_QWORD *)(v2 + 64) = v2;
          v13 = *(_QWORD *)(v2 + 32);
          if (v13)
          {
            *(_QWORD *)(v13 + 24) = v2;
            *(_QWORD *)(*(_QWORD *)(v2 + 72) + 32) = v10;
          }
          if (*(_QWORD *)(v2 + 80))
          {
            *(_QWORD *)(*(_QWORD *)(v2 + 24) + 32) = v2;
            *(_QWORD *)(*(_QWORD *)(v2 + 80) + 24) = v10;
          }
        }
        v2 += 96;
      }
      else
      {
        boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::remove_edge((uint64_t)a1, v4);
      }
      v4 += 96;
      v3 -= 96;
    }
    while (v4 != (char *)a1[7]);
    v14 = (char *)a1[6];
    if (v4 != (char *)v2)
    {
      v15 = &v14[48 * ((v2 - (uint64_t)v14) / 48)];
      v16 = &v15[-v2 - v3];
      v17 = -v3 - (_QWORD)v16;
      if (v4 != v16)
      {
        memmove(v15, v16, v17);
        v14 = (char *)a1[6];
      }
      v4 = &v15[v17];
      a1[7] = (uint64_t)&v15[v17];
    }
    while (v14 != v4)
    {
      v18 = *((_QWORD *)v14 + 1);
      *(_QWORD *)(*(_QWORD *)v14 + 8) = v14;
      if (v18)
        *(_QWORD *)(v18 + 16) = v14;
      v14 += 48;
    }
  }
  v20 = (_OWORD *)a1[3];
  v19 = (_OWORD *)a1[4];
  if (v20 == v19)
    goto LABEL_46;
  v21 = (_OWORD *)a1[3];
  do
  {
    if (*((_QWORD *)v21 + 2))
    {
      if (v21 != v20)
      {
        v22 = v21[1];
        *v20 = *v21;
        v20[1] = v22;
        v23 = *((_QWORD *)v20 + 2);
        v24 = v23;
        do
        {
          *(_QWORD *)(v24 + 8) = v20;
          v24 = *(_QWORD *)(*(_QWORD *)(v24 + 32) + 16);
        }
        while (v24 != v23);
        v19 = (_OWORD *)a1[4];
      }
      v20 += 2;
    }
    v21 += 2;
  }
  while (v21 != v19);
  v25 = (_OWORD *)a1[3];
  if (v20 != v19)
  {
    v19 = v20;
    a1[4] = (uint64_t)v20;
  }
  if (v25 == v19)
  {
LABEL_46:
    v32 = (_QWORD *)a1[6];
    v33 = (_QWORD *)a1[7];
    if (v32 != v33)
    {
      v32[3] = v32;
      v32[4] = v32;
      for (i = v32 + 12; i != v33; i = v35 + 24)
      {
        v35 = v32;
        v36 = v32 + 6;
        v32 += 12;
        v35[9] = v32;
        v35[10] = v32;
        v35[15] = v36;
        v35[16] = v36;
      }
      v32[9] = v32 + 6;
      v32[10] = v32 + 6;
    }
  }
  else
  {
    v26 = *a1;
    v27 = a1[1];
    while (v26 != v27)
    {
      v28 = *(_QWORD *)(v26 + 8);
      if (v28)
      {
        v29 = *(_QWORD *)(v26 + 8);
        while (1)
        {
          v30 = *(_QWORD *)(v29 + 32);
          if (!v30)
            break;
          v29 = *(_QWORD *)(v29 + 32);
          if (v30 == v28)
          {
            v29 = *(_QWORD *)(v26 + 8);
            if (*(_QWORD *)(v28 + 32))
              goto LABEL_45;
            goto LABEL_43;
          }
        }
        do
        {
LABEL_43:
          v31 = v28;
          v28 = *(_QWORD *)(v28 + 24);
        }
        while (v28);
        *(_QWORD *)(v29 + 32) = v31;
        *(_QWORD *)(v31 + 24) = v29;
      }
LABEL_45:
      v26 += 24;
    }
  }
}

void std::vector<boost::polygon::voronoi_cell<double>>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (_BYTE *)*a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v5 = ((_BYTE *)a1[1] - (_BYTE *)*a1) / 24;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_cell<double>>>(v3, a2);
    v7 = &v6[24 * v5];
    v9 = &v6[24 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *(_OWORD *)(v10 - 24);
        *((_QWORD *)v12 - 1) = *((_QWORD *)v10 - 1);
        *(_OWORD *)(v12 - 24) = v13;
        v12 -= 24;
        v10 -= 24;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void std::vector<boost::polygon::voronoi_vertex<double>>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 5)
  {
    if (a2 >> 59)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFE0];
    v9 = &v6[32 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v13;
        v12 -= 32;
        v10 -= 32;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void std::vector<boost::polygon::voronoi_edge<double>>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;
  __int128 v14;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (_BYTE *)*a1) >> 4) < a2)
  {
    if (a2 >= 0x555555555555556)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v5 = ((_BYTE *)a1[1] - (_BYTE *)*a1) / 48;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_edge<double>>>(v3, a2);
    v7 = &v6[48 * v5];
    v9 = &v6[48 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_OWORD *)v10 - 3);
        v14 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v14;
        *((_OWORD *)v12 - 3) = v13;
        v12 -= 48;
        v10 -= 48;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_cell<double>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_edge<double>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(48 * a2);
}

void std::__introsort<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*,false>(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, char a5)
{
  int *v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int *v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  char v24;
  BOOL v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(uint64_t a1, int *a2, int *a3)
{
  int v3;
  BOOL v4;
  int v5;
  int v6;
  int v7;
  _BOOL4 v8;
  unsigned int v9;
  int v11;
  int v12;

  v3 = *a2;
  v4 = *a2 < *a3;
  if (*a2 != *a3)
    return v4;
  if (v3 != a2[2])
  {
    if (v3 == a3[2])
      return 0;
    v11 = a2[1];
    v12 = a3[1];
    v4 = v11 < v12;
    if (v11 == v12)
      return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(a2 + 2, a2, a3 + 2) == 1;
    return v4;
  }
  v5 = a2[1];
  v6 = a3[2];
  if (v5 != a2[3])
  {
    if (v3 != v6)
      return 1;
    return v5 < a3[1];
  }
  if (v3 != v6)
    return 1;
  v7 = a3[1];
  v4 = v5 < v7;
  v8 = v5 <= v7;
  v9 = v4;
  if (v7 == a3[3])
    return v9;
  else
    return v8;
}

uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  int *v7;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  if (result != a2)
  {
    v21 = v3;
    v22 = v4;
    v6 = result;
    v7 = (int *)(result + 40);
    if (result + 40 != a2)
    {
      v9 = 0;
      v10 = result;
      do
      {
        v11 = (int *)v10;
        v10 = (uint64_t)v7;
        result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, v7, v11);
        if ((_DWORD)result)
        {
          v12 = *(_OWORD *)(v10 + 16);
          v18 = *(_OWORD *)v10;
          v19 = v12;
          v20 = *(_QWORD *)(v10 + 32);
          v13 = v9;
          while (1)
          {
            v14 = v6 + v13;
            v15 = *(_OWORD *)(v6 + v13 + 16);
            *(_OWORD *)(v14 + 40) = *(_OWORD *)(v6 + v13);
            *(_OWORD *)(v14 + 56) = v15;
            *(_QWORD *)(v14 + 72) = *(_QWORD *)(v6 + v13 + 32);
            if (!v13)
              break;
            v13 -= 40;
            result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v18, (int *)(v13 + v6));
            if ((result & 1) == 0)
            {
              v16 = v6 + v13 + 40;
              goto LABEL_10;
            }
          }
          v16 = v6;
LABEL_10:
          v17 = v19;
          *(_OWORD *)v16 = v18;
          *(_OWORD *)(v16 + 16) = v17;
          *(_QWORD *)(v16 + 32) = v20;
        }
        v7 = (int *)(v10 + 40);
        v9 += 40;
      }
      while (v10 + 40 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  int *v7;
  uint64_t v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (result != a2)
  {
    v18 = v3;
    v19 = v4;
    v6 = result;
    v7 = (int *)(result + 40);
    if (result + 40 != a2)
    {
      v9 = result - 40;
      do
      {
        v10 = (int *)v6;
        v6 = (uint64_t)v7;
        result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, v7, v10);
        if ((_DWORD)result)
        {
          v11 = *(_OWORD *)(v6 + 16);
          v15 = *(_OWORD *)v6;
          v16 = v11;
          v17 = *(_QWORD *)(v6 + 32);
          v12 = v9;
          do
          {
            v13 = *(_OWORD *)(v12 + 56);
            *(_OWORD *)(v12 + 80) = *(_OWORD *)(v12 + 40);
            *(_OWORD *)(v12 + 96) = v13;
            *(_QWORD *)(v12 + 112) = *(_QWORD *)(v12 + 72);
            result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v15, (int *)v12);
            v12 -= 40;
          }
          while ((result & 1) != 0);
          v14 = v16;
          *(_OWORD *)(v12 + 80) = v15;
          *(_OWORD *)(v12 + 96) = v14;
          *(_QWORD *)(v12 + 112) = v17;
        }
        v7 = (int *)(v6 + 40);
        v9 += 40;
      }
      while (v6 + 40 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(int *a1, int *a2, int *a3, uint64_t a4)
{
  char v8;
  uint64_t result;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;

  v8 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a4, a2, a1);
  result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a4, a3, a2);
  if ((v8 & 1) != 0)
  {
    if ((_DWORD)result)
    {
      v10 = *(_OWORD *)a1;
      v11 = *((_OWORD *)a1 + 1);
      v12 = *((_QWORD *)a1 + 4);
      v13 = *((_QWORD *)a3 + 4);
      v14 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *((_OWORD *)a1 + 1) = v14;
      *((_QWORD *)a1 + 4) = v13;
      *((_QWORD *)a3 + 4) = v12;
      result = 1;
LABEL_9:
      *(_OWORD *)a3 = v10;
      *((_OWORD *)a3 + 1) = v11;
      return result;
    }
    v25 = *(_OWORD *)a1;
    v26 = *((_OWORD *)a1 + 1);
    v27 = *((_QWORD *)a1 + 4);
    v28 = *((_QWORD *)a2 + 4);
    v29 = *((_OWORD *)a2 + 1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *((_OWORD *)a1 + 1) = v29;
    *((_QWORD *)a1 + 4) = v28;
    *((_QWORD *)a2 + 4) = v27;
    *(_OWORD *)a2 = v25;
    *((_OWORD *)a2 + 1) = v26;
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a4, a3, a2))
    {
      v10 = *(_OWORD *)a2;
      v11 = *((_OWORD *)a2 + 1);
      v30 = *((_QWORD *)a2 + 4);
      v31 = *((_QWORD *)a3 + 4);
      v32 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v32;
      *((_QWORD *)a2 + 4) = v31;
      *((_QWORD *)a3 + 4) = v30;
      result = 2;
      goto LABEL_9;
    }
  }
  else
  {
    if (!(_DWORD)result)
      return result;
    v15 = *(_OWORD *)a2;
    v16 = *((_OWORD *)a2 + 1);
    v17 = *((_QWORD *)a2 + 4);
    v18 = *((_QWORD *)a3 + 4);
    v19 = *((_OWORD *)a3 + 1);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *((_OWORD *)a2 + 1) = v19;
    *((_QWORD *)a2 + 4) = v18;
    *((_QWORD *)a3 + 4) = v17;
    *(_OWORD *)a3 = v15;
    *((_OWORD *)a3 + 1) = v16;
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a4, a2, a1))
    {
      v20 = *(_OWORD *)a1;
      v21 = *((_OWORD *)a1 + 1);
      v22 = *((_QWORD *)a1 + 4);
      v23 = *((_QWORD *)a2 + 4);
      v24 = *((_OWORD *)a2 + 1);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *((_OWORD *)a1 + 1) = v24;
      *((_QWORD *)a1 + 4) = v23;
      *((_QWORD *)a2 + 4) = v22;
      result = 2;
      *(_OWORD *)a2 = v20;
      *((_OWORD *)a2 + 1) = v21;
      return result;
    }
  }
  return 1;
}

int *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::site_event<int> *,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &>(int *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4;
  __int128 v6;
  int *v7;
  int *v8;
  int v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  int *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v4 = a2;
  v6 = *((_OWORD *)a1 + 1);
  v22 = *(_OWORD *)a1;
  v23 = v6;
  v24 = *((_QWORD *)a1 + 4);
  if ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v22, (int *)(a2 - 40)) & 1) != 0)
  {
    v7 = a1;
    do
      v7 += 10;
    while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v22, v7) & 1) == 0);
  }
  else
  {
    v8 = a1 + 10;
    do
    {
      v7 = v8;
      if ((unint64_t)v8 >= v4)
        break;
      v9 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v22, v8);
      v8 = v7 + 10;
    }
    while (!v9);
  }
  if ((unint64_t)v7 < v4)
  {
    do
      v4 -= 40;
    while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v22, (int *)v4) & 1) != 0);
  }
  while ((unint64_t)v7 < v4)
  {
    v10 = *(_OWORD *)v7;
    v11 = *((_OWORD *)v7 + 1);
    v27 = *((_QWORD *)v7 + 4);
    v25 = v10;
    v26 = v11;
    v12 = *(_OWORD *)v4;
    v13 = *(_OWORD *)(v4 + 16);
    *((_QWORD *)v7 + 4) = *(_QWORD *)(v4 + 32);
    *(_OWORD *)v7 = v12;
    *((_OWORD *)v7 + 1) = v13;
    v14 = v25;
    v15 = v26;
    *(_QWORD *)(v4 + 32) = v27;
    *(_OWORD *)v4 = v14;
    *(_OWORD *)(v4 + 16) = v15;
    do
      v7 += 10;
    while (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v22, v7));
    do
      v4 -= 40;
    while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v22, (int *)v4) & 1) != 0);
  }
  v16 = v7 - 10;
  if (v7 - 10 != a1)
  {
    v17 = *(_OWORD *)v16;
    v18 = *(_OWORD *)(v7 - 6);
    *((_QWORD *)a1 + 4) = *((_QWORD *)v7 - 1);
    *(_OWORD *)a1 = v17;
    *((_OWORD *)a1 + 1) = v18;
  }
  v19 = v22;
  v20 = v23;
  *((_QWORD *)v7 - 1) = v24;
  *(_OWORD *)v16 = v19;
  *(_OWORD *)(v7 - 6) = v20;
  return v7;
}

uint64_t std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::site_event<int> *,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &>(__int128 *a1, int *a2, uint64_t a3)
{
  uint64_t v6;
  __int128 v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int *v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v6 = 0;
  v7 = a1[1];
  v22 = *a1;
  v23 = v7;
  v24 = *((_QWORD *)a1 + 4);
  do
    v6 += 40;
  while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)((char *)a1 + v6), (int *)&v22) & 1) != 0);
  v8 = (unint64_t)a1 + v6;
  v9 = (uint64_t)a1 + v6 - 40;
  if (v6 == 40)
  {
    do
    {
      if (v8 >= (unint64_t)a2)
        break;
      a2 -= 10;
    }
    while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, a2, (int *)&v22) & 1) == 0);
  }
  else
  {
    do
      a2 -= 10;
    while (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, a2, (int *)&v22));
  }
  if (v8 < (unint64_t)a2)
  {
    v10 = (unint64_t)a1 + v6;
    v11 = a2;
    do
    {
      v13 = *(_OWORD *)(v10 + 16);
      v25 = *(_OWORD *)v10;
      v12 = v25;
      v26 = v13;
      v27 = *(_QWORD *)(v10 + 32);
      v14 = v27;
      v16 = *(_OWORD *)v11;
      v15 = *((_OWORD *)v11 + 1);
      *(_QWORD *)(v10 + 32) = *((_QWORD *)v11 + 4);
      *(_OWORD *)v10 = v16;
      *(_OWORD *)(v10 + 16) = v15;
      *((_QWORD *)v11 + 4) = v14;
      *(_OWORD *)v11 = v12;
      *((_OWORD *)v11 + 1) = v13;
      do
        v10 += 40;
      while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)v10, (int *)&v22) & 1) != 0);
      do
        v11 -= 10;
      while (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, v11, (int *)&v22));
    }
    while (v10 < (unint64_t)v11);
    v9 = v10 - 40;
  }
  if ((__int128 *)v9 != a1)
  {
    v17 = *(_OWORD *)v9;
    v18 = *(_OWORD *)(v9 + 16);
    *((_QWORD *)a1 + 4) = *(_QWORD *)(v9 + 32);
    *a1 = v17;
    a1[1] = v18;
  }
  v19 = v22;
  v20 = v23;
  *(_QWORD *)(v9 + 32) = v24;
  *(_OWORD *)v9 = v19;
  *(_OWORD *)(v9 + 16) = v20;
  return v9;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v6 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v8 = a2 - 40;
      if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)(a2 - 40), (int *)a1))return 1;
      v9 = *(_OWORD *)a1;
      v10 = *(_OWORD *)(a1 + 16);
      v11 = *(_QWORD *)(a1 + 32);
      v12 = *(_QWORD *)(v8 + 32);
      v13 = *(_OWORD *)(v8 + 16);
      *(_OWORD *)a1 = *(_OWORD *)v8;
      *(_OWORD *)(a1 + 16) = v13;
      *(_QWORD *)(a1 + 32) = v12;
      *(_QWORD *)(v8 + 32) = v11;
      result = 1;
      *(_OWORD *)v8 = v9;
      *(_OWORD *)(v8 + 16) = v10;
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>((int *)a1, (int *)(a1 + 40), (int *)(a2 - 40), a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, (int *)(a1 + 40), (int *)(a1 + 80), (__int128 *)(a2 - 40), a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, (int *)(a1 + 40), (int *)(a1 + 80), (__int128 *)(a1 + 120), (__int128 *)(a2 - 40), a3);
      return 1;
    default:
      v14 = (int *)(a1 + 80);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>((int *)a1, (int *)(a1 + 40), (int *)(a1 + 80), a3);
      v15 = a1 + 120;
      if (a1 + 120 == a2)
        return 1;
      v16 = 0;
      v17 = 0;
      break;
  }
  while (1)
  {
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)v15, v14))
    {
      v18 = *(_OWORD *)(v15 + 16);
      v24 = *(_OWORD *)v15;
      v25 = v18;
      v26 = *(_QWORD *)(v15 + 32);
      v19 = v16;
      while (1)
      {
        v20 = a1 + v19;
        v21 = *(_OWORD *)(a1 + v19 + 96);
        *(_OWORD *)(v20 + 120) = *(_OWORD *)(a1 + v19 + 80);
        *(_OWORD *)(v20 + 136) = v21;
        *(_QWORD *)(v20 + 152) = *(_QWORD *)(a1 + v19 + 112);
        if (v19 == -80)
          break;
        v19 -= 40;
        if ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)&v24, (int *)(v20 + 40)) & 1) == 0)
        {
          v22 = a1 + v19 + 120;
          goto LABEL_12;
        }
      }
      v22 = a1;
LABEL_12:
      v23 = v25;
      *(_OWORD *)v22 = v24;
      *(_OWORD *)(v22 + 16) = v23;
      *(_QWORD *)(v22 + 32) = v26;
      if (++v17 == 8)
        return v15 + 40 == a2;
    }
    v14 = (int *)v15;
    v16 += 40;
    v15 += 40;
    if (v15 == a2)
      return 1;
  }
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(int *a1, int *a2, int *a3)
{
  double v3;
  unsigned int v4;

  v3 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*a1 - (uint64_t)*a2, a1[1] - (uint64_t)a2[1], *a2 - (uint64_t)*a3, a2[1] - (uint64_t)a3[1]);
  if (v3 >= 0.0)
    v4 = 1;
  else
    v4 = -1;
  if (v3 == 0.0)
    return 0;
  else
    return v4;
}

double boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  double result;
  double v12;

  if (a1 >= 0)
    v4 = a1;
  else
    v4 = -a1;
  if (a2 >= 0)
    v5 = a2;
  else
    v5 = -a2;
  if (a3 >= 0)
    v6 = a3;
  else
    v6 = -a3;
  if (a4 >= 0)
    v7 = a4;
  else
    v7 = -a4;
  v8 = v7 * v4;
  v9 = v6 * v5;
  v10 = a2 ^ a3;
  result = (double)(v8 - v9);
  v12 = (double)(v9 - v8);
  if (v8 < v9)
    result = -v12;
  if (v10 < 0)
    result = (double)(v8 + v9);
  if (v8 > v9)
    v12 = -(double)(v8 - v9);
  if (v10 >= 0)
    v12 = -(double)(v8 + v9);
  if ((a4 ^ a1) < 0)
    return v12;
  return result;
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t a1, int *a2, int *a3, __int128 *a4, uint64_t a5)
{
  __n128 result;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>((int *)a1, a2, a3, a5);
  if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a5, (int *)a4, a3))
  {
    v11 = *(_OWORD *)a3;
    v12 = *((_OWORD *)a3 + 1);
    v13 = *((_QWORD *)a3 + 4);
    v14 = *((_QWORD *)a4 + 4);
    v15 = a4[1];
    *(_OWORD *)a3 = *a4;
    *((_OWORD *)a3 + 1) = v15;
    *((_QWORD *)a3 + 4) = v14;
    *((_QWORD *)a4 + 4) = v13;
    *a4 = v11;
    a4[1] = v12;
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a5, a3, a2))
    {
      v16 = *(_OWORD *)a2;
      v17 = *((_OWORD *)a2 + 1);
      v18 = *((_QWORD *)a2 + 4);
      v19 = *((_QWORD *)a3 + 4);
      v20 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v20;
      *((_QWORD *)a2 + 4) = v19;
      *((_QWORD *)a3 + 4) = v18;
      *(_OWORD *)a3 = v16;
      *((_OWORD *)a3 + 1) = v17;
      if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a5, a2, (int *)a1))
      {
        result = *(__n128 *)a1;
        v21 = *(_OWORD *)(a1 + 16);
        v22 = *(_QWORD *)(a1 + 32);
        v23 = *((_QWORD *)a2 + 4);
        v24 = *((_OWORD *)a2 + 1);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v24;
        *(_QWORD *)(a1 + 32) = v23;
        *((_QWORD *)a2 + 4) = v22;
        *(__n128 *)a2 = result;
        *((_OWORD *)a2 + 1) = v21;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t a1, int *a2, int *a3, __int128 *a4, __int128 *a5, uint64_t a6)
{
  __n128 result;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;

  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, a2, a3, a4, a6);
  if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a6, (int *)a5, (int *)a4))
  {
    v13 = *a4;
    v14 = a4[1];
    v15 = *((_QWORD *)a4 + 4);
    v16 = *((_QWORD *)a5 + 4);
    v17 = a5[1];
    *a4 = *a5;
    a4[1] = v17;
    *((_QWORD *)a4 + 4) = v16;
    *((_QWORD *)a5 + 4) = v15;
    *a5 = v13;
    a5[1] = v14;
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a6, (int *)a4, a3))
    {
      v18 = *(_OWORD *)a3;
      v19 = *((_OWORD *)a3 + 1);
      v20 = *((_QWORD *)a3 + 4);
      v21 = *((_QWORD *)a4 + 4);
      v22 = a4[1];
      *(_OWORD *)a3 = *a4;
      *((_OWORD *)a3 + 1) = v22;
      *((_QWORD *)a3 + 4) = v21;
      *((_QWORD *)a4 + 4) = v20;
      *a4 = v18;
      a4[1] = v19;
      if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a6, a3, a2))
      {
        v23 = *(_OWORD *)a2;
        v24 = *((_OWORD *)a2 + 1);
        v25 = *((_QWORD *)a2 + 4);
        v26 = *((_QWORD *)a3 + 4);
        v27 = *((_OWORD *)a3 + 1);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *((_OWORD *)a2 + 1) = v27;
        *((_QWORD *)a2 + 4) = v26;
        *((_QWORD *)a3 + 4) = v25;
        *(_OWORD *)a3 = v23;
        *((_OWORD *)a3 + 1) = v24;
        if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a6, a2, (int *)a1))
        {
          result = *(__n128 *)a1;
          v28 = *(_OWORD *)(a1 + 16);
          v29 = *(_QWORD *)(a1 + 32);
          v30 = *((_QWORD *)a2 + 4);
          v31 = *((_OWORD *)a2 + 1);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v31;
          *(_QWORD *)(a1 + 32) = v30;
          *((_QWORD *)a2 + 4) = v29;
          *(__n128 *)a2 = result;
          *((_OWORD *)a2 + 1) = v28;
        }
      }
    }
  }
  return result;
}

__int128 *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*,boost::polygon::detail::site_event<int>*>(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __n128 *v12;
  __int128 *v13;
  __int128 *v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  int64_t v20;
  uint64_t v21;
  uint64_t v22;
  __n128 v23;
  __int128 v24;
  __n128 v27;
  __int128 v28;
  uint64_t v29;

  if ((__int128 *)a1 != a2)
  {
    v8 = (uint64_t)a2 - a1;
    v9 = ((uint64_t)a2 - a1) / 40;
    if ((uint64_t)a2 - a1 >= 41)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = (__n128 *)(a1 + 40 * v10);
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, a4, v9, v12);
        v12 = (__n128 *)((char *)v12 - 40);
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != a3)
    {
      v14 = a2;
      do
      {
        if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a4, (int *)v14, (int *)a1))
        {
          v15 = *v14;
          v16 = v14[1];
          v17 = *((_QWORD *)v14 + 4);
          v18 = *(_QWORD *)(a1 + 32);
          v19 = *(_OWORD *)(a1 + 16);
          *v14 = *(_OWORD *)a1;
          v14[1] = v19;
          *((_QWORD *)v14 + 4) = v18;
          *(_QWORD *)(a1 + 32) = v17;
          *(_OWORD *)a1 = v15;
          *(_OWORD *)(a1 + 16) = v16;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, a4, v9, (__n128 *)a1);
        }
        v14 = (__int128 *)((char *)v14 + 40);
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 41)
    {
      v20 = v8 / 0x28uLL;
      v21 = (uint64_t)a2 - 40;
      do
      {
        v27 = *(__n128 *)a1;
        v28 = *(_OWORD *)(a1 + 16);
        v29 = *(_QWORD *)(a1 + 32);
        v22 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, a4, v20);
        if (v21 == v22)
        {
          *(__n128 *)v22 = v27;
          *(_OWORD *)(v22 + 16) = v28;
          *(_QWORD *)(v22 + 32) = v29;
        }
        else
        {
          v23 = *(__n128 *)v21;
          v24 = *(_OWORD *)(v21 + 16);
          *(_QWORD *)(v22 + 32) = *(_QWORD *)(v21 + 32);
          *(__n128 *)v22 = v23;
          *(_OWORD *)(v22 + 16) = v24;
          *(_QWORD *)(v21 + 32) = v29;
          *(__n128 *)v21 = v27;
          *(_OWORD *)(v21 + 16) = v28;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(a1, v22 + 40, a4, 0xCCCCCCCCCCCCCCCDLL * ((v22 + 40 - a1) >> 3));
        }
        v21 -= 40;
      }
      while (v20-- > 2);
    }
    return v13;
  }
  return a3;
}

__n128 std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  __n128 *v7;
  int64_t v9;
  int64_t v12;
  __int128 *v13;
  int64_t v14;
  __n128 result;
  __n128 v16;
  __n128 *v17;
  __n128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  __n128 v22;
  __n128 v23;
  __n128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v6 = a3 - 2;
  if (a3 >= 2)
  {
    v26 = v4;
    v27 = v5;
    v7 = a4;
    v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)a4 - a1) >> 3)))
    {
      v12 = (0x999999999999999ALL * (((uint64_t)a4 - a1) >> 3)) | 1;
      v13 = (__int128 *)(a1 + 40 * v12);
      v14 = 0x999999999999999ALL * (((uint64_t)a4 - a1) >> 3) + 2;
      if (v14 < a3
        && boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a2, (int *)(a1 + 40 * v12), (int *)v13 + 10))
      {
        v13 = (__int128 *)((char *)v13 + 40);
        v12 = v14;
      }
      if ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a2, (int *)v13, (int *)v7) & 1) == 0)
      {
        v16 = v7[1];
        v23 = *v7;
        v24 = v16;
        v25 = v7[2].n128_i64[0];
        do
        {
          v17 = (__n128 *)v13;
          v18 = (__n128)*v13;
          v19 = v13[1];
          v7[2].n128_u64[0] = *((_QWORD *)v13 + 4);
          *v7 = v18;
          v7[1] = (__n128)v19;
          if (v9 < v12)
            break;
          v20 = (2 * v12) | 1;
          v13 = (__int128 *)(a1 + 40 * v20);
          v21 = 2 * v12 + 2;
          if (v21 < a3)
          {
            if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a2, (int *)(a1 + 40 * v20), (int *)v13 + 10))
            {
              v13 = (__int128 *)((char *)v13 + 40);
              v20 = v21;
            }
          }
          v7 = v17;
          v12 = v20;
        }
        while (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a2, (int *)v13, (int *)&v23));
        result = v23;
        v22 = v24;
        v17[2].n128_u64[0] = v25;
        *v17 = result;
        v17[1] = v22;
      }
    }
  }
  return result;
}

uint64_t std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;

  v6 = 0;
  v7 = a3 - 2;
  if (a3 < 2)
    v7 = a3 - 1;
  v8 = v7 >> 1;
  do
  {
    v9 = a1 + 40 * v6 + 40;
    v10 = (2 * v6) | 1;
    v11 = 2 * v6 + 2;
    if (v11 < a3
      && boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a2, (int *)(a1 + 40 * v6 + 40), (int *)(a1 + 40 * v6 + 80)))
    {
      v9 += 40;
      v10 = v11;
    }
    v12 = *(_OWORD *)v9;
    v13 = *(_OWORD *)(v9 + 16);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(v9 + 32);
    *(_OWORD *)a1 = v12;
    *(_OWORD *)(a1 + 16) = v13;
    a1 = v9;
    v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

double std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>> &,boost::polygon::detail::site_event<int>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v8;
  __int128 *v9;
  __int128 *v10;
  double result;
  __int128 v12;
  __int128 *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  if (a4 >= 2)
  {
    v20 = v4;
    v21 = v5;
    v8 = (unint64_t)(a4 - 2) >> 1;
    v9 = (__int128 *)(a1 + 40 * v8);
    v10 = (__int128 *)(a2 - 40);
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)v9, (int *)(a2 - 40)))
    {
      v12 = v10[1];
      v17 = *v10;
      v18 = v12;
      v19 = *((_QWORD *)v10 + 4);
      do
      {
        v13 = v9;
        v14 = *v9;
        v15 = v9[1];
        *((_QWORD *)v10 + 4) = *((_QWORD *)v9 + 4);
        *v10 = v14;
        v10[1] = v15;
        if (!v8)
          break;
        v8 = (v8 - 1) >> 1;
        v9 = (__int128 *)(a1 + 40 * v8);
        v10 = v13;
      }
      while ((boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, (int *)v9, (int *)&v17) & 1) != 0);
      result = *(double *)&v17;
      v16 = v18;
      *v13 = v17;
      v13[1] = v16;
      *((_QWORD *)v13 + 4) = v19;
    }
  }
  return result;
}

unsigned int *std::__unique[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__equal_to &>(unsigned int *a1, unsigned int *a2)
{
  unsigned int *result;
  unsigned int *i;
  __int128 v5;
  __int128 v6;

  result = std::__adjacent_find[abi:ne180100]<std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__equal_to &>(a1, a2);
  if (result != a2)
  {
    for (i = result + 20; i != a2; i += 10)
    {
      if (*result != *i || result[1] != i[1] || result[2] != i[2] || result[3] != i[3])
      {
        v5 = *(_OWORD *)i;
        v6 = *((_OWORD *)i + 1);
        *((_QWORD *)result + 9) = *((_QWORD *)i + 4);
        *(_OWORD *)(result + 14) = v6;
        *(_OWORD *)(result + 10) = v5;
        result += 10;
      }
    }
    result += 10;
  }
  return result;
}

unsigned int *std::__adjacent_find[abi:ne180100]<std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__wrap_iter<boost::polygon::detail::site_event<int> *>,std::__equal_to &>(unsigned int *result, unsigned int *a2)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  if (result != a2)
  {
    v2 = result + 10;
    if (result + 10 == a2)
    {
      return a2;
    }
    else
    {
      v3 = *result;
      while (1)
      {
        v4 = v3;
        v3 = *v2;
        if (__PAIR64__(*(v2 - 9), v4) == *(_QWORD *)v2 && *(v2 - 8) == v2[2] && *(v2 - 7) == v2[3])
          break;
        v2 += 10;
        if (v2 == a2)
          return a2;
      }
      return v2 - 10;
    }
  }
  return result;
}

void boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_process_single_site<int>(void **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;

  v3 = *(_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 32) & 0x1FLL;
  v7 = (unint64_t)a1[2];
  v5 = (uint64_t)(a1 + 2);
  v6 = v7;
  v8 = *(_QWORD **)(v5 - 8);
  if ((unint64_t)v8 >= v7)
  {
    v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v8 - (_BYTE *)*a1) >> 3);
    v11 = v10 + 1;
    if (v10 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - (_QWORD)*a1) >> 3);
    if (2 * v12 > v11)
      v11 = 2 * v12;
    if (v12 >= 0x555555555555555)
      v13 = 0xAAAAAAAAAAAAAAALL;
    else
      v13 = v11;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_cell<double>>>(v5, v13);
    else
      v14 = 0;
    v15 = &v14[24 * v10];
    v16 = &v14[24 * v13];
    *(_QWORD *)v15 = v3;
    *((_QWORD *)v15 + 1) = 0;
    *((_QWORD *)v15 + 2) = v4;
    v9 = v15 + 24;
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *(_OWORD *)(v17 - 24);
        *((_QWORD *)v15 - 1) = *((_QWORD *)v17 - 1);
        *(_OWORD *)(v15 - 24) = v19;
        v15 -= 24;
        v17 -= 24;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v15;
    a1[1] = v9;
    a1[2] = v16;
    if (v17)
      operator delete(v17);
  }
  else
  {
    *v8 = v3;
    v8[1] = 0;
    v9 = v8 + 3;
    v8[2] = v4;
  }
  a1[1] = v9;
}

uint64_t *boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::init_beach_line_collinear_sites<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t *result, char **a2)
{
  uint64_t v2;
  uint64_t *v4;
  uint64_t **v5;
  _QWORD *v6;
  __int128 v7;
  __int128 v8;
  char *inserted;
  uint64_t v10;
  _OWORD v11[5];
  uint64_t v12;
  char *v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[48];

  v2 = result[1];
  if (v2 + 40 != result[4])
  {
    v4 = result;
    v5 = (uint64_t **)(result + 16);
    v6 = result + 17;
    do
    {
      v7 = *(_OWORD *)(v2 + 16);
      v14 = *(_OWORD *)v2;
      v15 = v7;
      *(_QWORD *)v16 = *(_QWORD *)(v2 + 32);
      v8 = *(_OWORD *)(v2 + 56);
      *(_OWORD *)&v16[8] = *(_OWORD *)(v2 + 40);
      *(_OWORD *)&v16[24] = v8;
      *(_QWORD *)&v16[40] = *(_QWORD *)(v2 + 72);
      inserted = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_insert_new_edge<int>(a2, v2, v2 + 40);
      v11[2] = *(_OWORD *)v16;
      v11[3] = *(_OWORD *)&v16[16];
      v11[4] = *(_OWORD *)&v16[32];
      v11[0] = v14;
      v11[1] = v15;
      v12 = 0;
      v13 = inserted;
      result = std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__emplace_hint_unique_key_args<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::pair<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>(v5, v6, (uint64_t)v11, v11);
      v10 = v2 + 80;
      v2 += 40;
    }
    while (v10 != v4[4]);
  }
  return result;
}

uint64_t *boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::insert_new_arc<boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>>(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, _QWORD *a5, char **a6)
{
  __int128 v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  char *inserted;
  char *v16;
  uint64_t *v17;
  __int128 v18;
  __int128 v19;
  unint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  __int128 v36;
  __int128 v37;
  _BYTE v38[48];
  uint64_t v39;
  char *v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  _BYTE v48[48];
  __int128 v49;
  __int128 v50;
  _BYTE v51[40];
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v9 = a2[1];
  v46 = *a2;
  v47 = v9;
  v10 = *((_QWORD *)a2 + 4);
  v11 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)&v48[8] = *(_OWORD *)a4;
  *(_OWORD *)&v48[24] = *(_OWORD *)(a4 + 16);
  v12 = *(_QWORD *)(a4 + 32);
  *(_QWORD *)v48 = v10;
  *(_QWORD *)&v48[40] = v12;
  v44 = *(_OWORD *)a4;
  v45 = v11;
  v13 = *(_QWORD *)(a4 + 32);
  v14 = *(_OWORD *)(a3 + 16);
  v41 = *(_OWORD *)a3;
  v42 = v14;
  v43 = *(_QWORD *)(a3 + 32);
  if (*(_DWORD *)a4 != *(_DWORD *)(a4 + 8) || *(_DWORD *)(a4 + 4) != *(_DWORD *)(a4 + 12))
    v13 ^= 0x20uLL;
  inserted = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_insert_new_edge<int>(a6, a3, a4);
  v36 = v44;
  v37 = v45;
  *(_OWORD *)&v38[8] = v41;
  *(_QWORD *)v38 = v13;
  *(_OWORD *)&v38[24] = v42;
  *(_QWORD *)&v38[40] = v43;
  v39 = 0;
  v40 = v16;
  v17 = std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__emplace_hint_unique_key_args<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::pair<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>> const,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>((uint64_t **)(a1 + 128), a5, (uint64_t)&v36, &v36);
  if (*(_DWORD *)a4 != *(_DWORD *)(a4 + 8) || *(_DWORD *)(a4 + 4) != *(_DWORD *)(a4 + 12))
  {
    v18 = *(_OWORD *)a4;
    v19 = *(_OWORD *)(a4 + 16);
    *(_QWORD *)v51 = *(_QWORD *)(a4 + 32);
    *(_OWORD *)&v51[24] = v19;
    *(_OWORD *)&v51[8] = v18;
    *(_OWORD *)v38 = *(_OWORD *)v51;
    *(_OWORD *)&v38[16] = *(_OWORD *)&v51[16];
    v49 = v18;
    v50 = v19;
    v36 = v18;
    v37 = v19;
    *(_QWORD *)&v38[32] = *((_QWORD *)&v19 + 1);
    *(_QWORD *)&v38[40] = *(_QWORD *)v51 ^ 0x20;
    v39 = 0;
    v40 = 0;
    v17 = std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__emplace_hint_unique_key_args<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::pair<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>> const,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>((uint64_t **)(a1 + 128), v17, (uint64_t)&v36, &v36);
    v20 = *(_QWORD *)(a1 + 56);
    v21 = *(_QWORD *)(a4 + 8);
    v22 = *(_QWORD **)(a1 + 48);
    if ((unint64_t)v22 >= v20)
    {
      v24 = *(_QWORD *)(a1 + 40);
      v25 = ((uint64_t)v22 - v24) >> 4;
      v26 = v25 + 1;
      if ((unint64_t)(v25 + 1) >> 60)
        std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
      v27 = v20 - v24;
      if (v27 >> 3 > v26)
        v26 = v27 >> 3;
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0)
        v28 = 0xFFFFFFFFFFFFFFFLL;
      else
        v28 = v26;
      if (v28)
        v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CGPoint>>(a1 + 56, v28);
      else
        v29 = 0;
      v30 = &v29[16 * v25];
      v31 = &v29[16 * v28];
      *(_QWORD *)v30 = v21;
      *((_QWORD *)v30 + 1) = v17;
      v23 = (uint64_t)(v30 + 16);
      v33 = *(char **)(a1 + 40);
      v32 = *(char **)(a1 + 48);
      if (v32 != v33)
      {
        do
        {
          *((_OWORD *)v30 - 1) = *((_OWORD *)v32 - 1);
          v30 -= 16;
          v32 -= 16;
        }
        while (v32 != v33);
        v32 = *(char **)(a1 + 40);
      }
      *(_QWORD *)(a1 + 40) = v30;
      *(_QWORD *)(a1 + 48) = v23;
      *(_QWORD *)(a1 + 56) = v31;
      if (v32)
        operator delete(v32);
    }
    else
    {
      *v22 = v21;
      v22[1] = v17;
      v23 = (uint64_t)(v22 + 2);
    }
    *(_QWORD *)(a1 + 48) = v23;
    v34 = *(_QWORD *)(a1 + 40);
    LOBYTE(v36) = *(_BYTE *)(a1 + 64);
    std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::end_point_comparison &,std::__wrap_iter<std::pair<boost::polygon::detail::point_2d<int>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>> *>>(v34, v23, (uint64_t)&v36, (v23 - v34) >> 4);
  }
  *(_OWORD *)v38 = *(_OWORD *)v48;
  *(_OWORD *)&v38[16] = *(_OWORD *)&v48[16];
  *(_OWORD *)&v38[32] = *(_OWORD *)&v48[32];
  v36 = v46;
  v37 = v47;
  v39 = 0;
  v40 = inserted;
  return std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__emplace_hint_unique_key_args<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::pair<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>> const,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>((uint64_t **)(a1 + 128), v17, (uint64_t)&v36, &v36);
}

char *boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_insert_new_edge<int>(char **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;
  int v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  __int128 v24;
  __int128 v25;
  unint64_t v26;
  char *v27;
  int v28;
  int v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  __int128 v38;
  __int128 v39;
  char *v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  __int128 v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  char *v65;
  char *v66;
  __int128 v67;
  char *v68;
  char *v69;
  char *v70;

  v6 = *(_QWORD *)(a2 + 16);
  v7 = *(_QWORD *)(a3 + 16);
  v8 = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_linear_edge<boost::polygon::detail::site_event<int>>((uint64_t)a1, (int *)a2, (int *)a3);
  v9 = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_primary_edge<boost::polygon::detail::site_event<int>>((uint64_t)a1, (int *)a2, (int *)a3);
  v10 = (unint64_t)a1[8];
  v11 = a1 + 6;
  if (v9)
    v12 = v8 | 2;
  else
    v12 = v8;
  v13 = (unint64_t)a1[7];
  if (v13 >= v10)
  {
    v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - *v11) >> 4);
    v16 = v15 + 1;
    if (v15 + 1 > 0x555555555555555)
      goto LABEL_67;
    v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - *v11) >> 4);
    if (2 * v17 > v16)
      v16 = 2 * v17;
    if (v17 >= 0x2AAAAAAAAAAAAAALL)
      v18 = 0x555555555555555;
    else
      v18 = v16;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_edge<double>>>((uint64_t)(a1 + 8), v18);
    else
      v19 = 0;
    v20 = &v19[48 * v15];
    v21 = &v19[48 * v18];
    *(_OWORD *)v20 = 0u;
    *((_OWORD *)v20 + 1) = 0u;
    *((_QWORD *)v20 + 4) = 0;
    *((_QWORD *)v20 + 5) = v12;
    v14 = v20 + 48;
    v23 = a1[6];
    v22 = a1[7];
    if (v22 != v23)
    {
      do
      {
        v24 = *((_OWORD *)v22 - 3);
        v25 = *((_OWORD *)v22 - 1);
        *((_OWORD *)v20 - 2) = *((_OWORD *)v22 - 2);
        *((_OWORD *)v20 - 1) = v25;
        *((_OWORD *)v20 - 3) = v24;
        v20 -= 48;
        v22 -= 48;
      }
      while (v22 != v23);
      v22 = (char *)*v11;
    }
    a1[6] = v20;
    a1[7] = v14;
    a1[8] = v21;
    if (v22)
      operator delete(v22);
  }
  else
  {
    *(_OWORD *)v13 = 0u;
    *(_OWORD *)(v13 + 16) = 0u;
    *(_QWORD *)(v13 + 32) = 0;
    *(_QWORD *)(v13 + 40) = v12;
    v14 = (char *)(v13 + 48);
  }
  a1[7] = v14;
  v26 = (unint64_t)a1[8];
  if ((unint64_t)v14 < v26)
  {
    *(_OWORD *)v14 = 0u;
    *((_OWORD *)v14 + 1) = 0u;
    *((_QWORD *)v14 + 4) = 0;
    *((_QWORD *)v14 + 5) = v12;
    v27 = v14 + 48;
    goto LABEL_36;
  }
  v28 = v6;
  v29 = v7;
  v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*v11] >> 4);
  if (v7 + 1 > 0x555555555555555)
LABEL_67:
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - *v11) >> 4);
  v31 = 2 * v30;
  if (2 * v30 <= v7 + 1)
    v31 = v7 + 1;
  if (v30 >= 0x2AAAAAAAAAAAAAALL)
    v32 = 0x555555555555555;
  else
    v32 = v31;
  if (v32)
    v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_edge<double>>>((uint64_t)(a1 + 8), v32);
  else
    v33 = 0;
  v34 = &v33[48 * v7];
  v35 = &v33[48 * v32];
  *(_OWORD *)v34 = 0u;
  *((_OWORD *)v34 + 1) = 0u;
  *((_QWORD *)v34 + 4) = 0;
  *((_QWORD *)v34 + 5) = v12;
  v27 = v34 + 48;
  v37 = a1[6];
  v36 = a1[7];
  LODWORD(v7) = v29;
  if (v36 != v37)
  {
    do
    {
      v38 = *((_OWORD *)v36 - 3);
      v39 = *((_OWORD *)v36 - 1);
      *((_OWORD *)v34 - 2) = *((_OWORD *)v36 - 2);
      *((_OWORD *)v34 - 1) = v39;
      *((_OWORD *)v34 - 3) = v38;
      v34 -= 48;
      v36 -= 48;
    }
    while (v36 != v37);
    v36 = (char *)*v11;
  }
  LODWORD(v6) = v28;
  a1[6] = v34;
  a1[7] = v27;
  a1[8] = v35;
  if (v36)
    operator delete(v36);
LABEL_36:
  a1[7] = v27;
  v40 = *a1;
  v41 = a1[1];
  if (*a1 == v41)
  {
    v42 = *(_QWORD *)(a2 + 24);
    v43 = *(_QWORD *)(a2 + 32) & 0x1FLL;
    v44 = (unint64_t)a1[2];
    if ((unint64_t)v40 >= v44)
    {
      v45 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v44 - (_QWORD)v40) >> 3);
      v46 = 2 * v45;
      if (2 * v45 <= 1)
        v46 = 1;
      if (v45 >= 0x555555555555555)
        v47 = 0xAAAAAAAAAAAAAAALL;
      else
        v47 = v46;
      v48 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_cell<double>>>((uint64_t)(a1 + 2), v47);
      v50 = &v48[24 * v49];
      *(_QWORD *)v48 = v42;
      *((_QWORD *)v48 + 1) = 0;
      *((_QWORD *)v48 + 2) = v43;
      v41 = v48 + 24;
      v52 = *a1;
      v51 = a1[1];
      if (v51 != *a1)
      {
        do
        {
          v53 = *(_OWORD *)(v51 - 24);
          *((_QWORD *)v48 - 1) = *((_QWORD *)v51 - 1);
          *(_OWORD *)(v48 - 24) = v53;
          v48 -= 24;
          v51 -= 24;
        }
        while (v51 != v52);
        v51 = *a1;
      }
      *a1 = v48;
      a1[1] = v41;
      a1[2] = v50;
      if (v51)
        operator delete(v51);
    }
    else
    {
      *(_QWORD *)v40 = v42;
      *((_QWORD *)v40 + 1) = 0;
      v41 = v40 + 24;
      *((_QWORD *)v40 + 2) = v43;
    }
    a1[1] = v41;
  }
  v54 = *(_QWORD *)(a3 + 24);
  v55 = *(_QWORD *)(a3 + 32) & 0x1FLL;
  v56 = (unint64_t)a1[2];
  if ((unint64_t)v41 >= v56)
  {
    v58 = 0xAAAAAAAAAAAAAAABLL * ((v41 - *a1) >> 3);
    if (v58 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v59 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v56 - (_QWORD)*a1) >> 3);
    v60 = 2 * v59;
    if (2 * v59 <= v58 + 1)
      v60 = v58 + 1;
    if (v59 >= 0x555555555555555)
      v61 = 0xAAAAAAAAAAAAAAALL;
    else
      v61 = v60;
    if (v61)
      v62 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_cell<double>>>((uint64_t)(a1 + 2), v61);
    else
      v62 = 0;
    v63 = &v62[24 * v58];
    v64 = &v62[24 * v61];
    *(_QWORD *)v63 = v54;
    *((_QWORD *)v63 + 1) = 0;
    *((_QWORD *)v63 + 2) = v55;
    v57 = v63 + 24;
    v66 = *a1;
    v65 = a1[1];
    if (v65 != *a1)
    {
      do
      {
        v67 = *(_OWORD *)(v65 - 24);
        *((_QWORD *)v63 - 1) = *((_QWORD *)v65 - 1);
        *(_OWORD *)(v63 - 24) = v67;
        v63 -= 24;
        v65 -= 24;
      }
      while (v65 != v66);
      v65 = *a1;
    }
    *a1 = v63;
    a1[1] = v57;
    a1[2] = v64;
    if (v65)
      operator delete(v65);
  }
  else
  {
    *(_QWORD *)v41 = v54;
    *((_QWORD *)v41 + 1) = 0;
    v57 = v41 + 24;
    *((_QWORD *)v41 + 2) = v55;
  }
  a1[1] = v57;
  v68 = *a1;
  *((_QWORD *)v14 - 6) = &(*a1)[24 * (int)v6];
  v69 = v14 - 48;
  *((_QWORD *)v27 - 6) = &v68[24 * (int)v7];
  v70 = v27 - 48;
  *((_QWORD *)v69 + 2) = v70;
  *((_QWORD *)v70 + 2) = v69;
  return v69;
}

uint64_t boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_linear_edge<boost::polygon::detail::site_event<int>>(uint64_t a1, int *a2, int *a3)
{
  _BOOL4 v6;
  _BOOL4 v8;

  if (!boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_primary_edge<boost::polygon::detail::site_event<int>>(a1, a2, a3))return 1;
  v6 = *a2 != a2[2] || a2[1] != a2[3];
  v8 = *a3 != a3[2] || a3[1] != a3[3];
  return v6 ^ v8 ^ 1u;
}

uint64_t boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_primary_edge<boost::polygon::detail::site_event<int>>(uint64_t a1, int *a2, int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  _BOOL4 v8;
  int v9;
  int v10;
  int v11;
  int v12;
  _BOOL4 v13;
  _BOOL4 v16;

  v4 = *a2;
  v3 = a2[1];
  v6 = a2[2];
  v5 = a2[3];
  v8 = *a2 != v6 || v3 != v5;
  v9 = *a3;
  v10 = a3[2];
  if (*a3 == v10)
  {
    v11 = a3[1];
    v12 = a3[3];
    v13 = v11 != v12;
    if (v8 && v11 == v12)
    {
      v16 = v6 != v9 || v5 != v11;
      return (v4 != v9 || v3 != v11) && v16;
    }
  }
  else
  {
    v13 = 1;
  }
  if (v8 || !v13)
    return 1;
  if (v9 == v4 && a3[1] == v3)
    return 0;
  if (v10 != v4)
    return 1;
  return a3[3] != v3;
}

uint64_t *std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__emplace_hint_unique_key_args<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::pair<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>> const,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>(uint64_t **a1, _QWORD *a2, uint64_t a3, _OWORD *a4)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t **v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v13;
  uint64_t v14;

  v6 = std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__find_equal<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>(a1, a2, &v14, &v13, a3);
  v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = (uint64_t *)operator new(0x80uLL);
    v9 = a4[3];
    *((_OWORD *)v7 + 4) = a4[2];
    *((_OWORD *)v7 + 5) = v9;
    v10 = a4[5];
    *((_OWORD *)v7 + 6) = a4[4];
    *((_OWORD *)v7 + 7) = v10;
    v11 = a4[1];
    *((_OWORD *)v7 + 2) = *a4;
    *((_OWORD *)v7 + 3) = v11;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, v14, v8, v7);
  }
  return v7;
}

uint64_t *std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__find_equal<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>(_QWORD *a1, _QWORD *a2, _QWORD *a3, uint64_t *a4, uint64_t a5)
{
  _QWORD *v9;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  BOOL v17;
  _QWORD *v18;

  v9 = a1 + 1;
  if (a1 + 1 == a2
    || boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()((uint64_t)(a1 + 3), a5, (uint64_t)(a2 + 4)))
  {
    if ((_QWORD *)*a1 == a2)
    {
      v12 = a2;
LABEL_16:
      if (*a2)
      {
        *a3 = v12;
        return v12 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    v11 = (_QWORD *)*a2;
    if (*a2)
    {
      do
      {
        v12 = v11;
        v11 = (_QWORD *)v11[1];
      }
      while (v11);
    }
    else
    {
      v16 = a2;
      do
      {
        v12 = (_QWORD *)v16[2];
        v17 = *v12 == (_QWORD)v16;
        v16 = v12;
      }
      while (v17);
    }
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()((uint64_t)(a1 + 3), (uint64_t)(v12 + 4), a5))goto LABEL_16;
    return std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__find_equal<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>((uint64_t)a1, a3, a5);
  }
  if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()((uint64_t)(a1 + 3), (uint64_t)(a2 + 4), a5))
  {
    a4 = a2 + 1;
    v13 = a2[1];
    if (v13)
    {
      v14 = (_QWORD *)a2[1];
      do
      {
        v15 = v14;
        v14 = (_QWORD *)*v14;
      }
      while (v14);
    }
    else
    {
      v18 = a2;
      do
      {
        v15 = (_QWORD *)v18[2];
        v17 = *v15 == (_QWORD)v18;
        v18 = v15;
      }
      while (!v17);
    }
    if (v15 != v9)
    {
      if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()((uint64_t)(a1 + 3), a5, (uint64_t)(v15 + 4)))return std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__find_equal<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>((uint64_t)a1, a3, a5);
      v13 = *a4;
    }
    if (v13)
    {
      *a3 = v15;
      return v15;
    }
    else
    {
      *a3 = a2;
    }
    return a4;
  }
  *a3 = a2;
  *a4 = (uint64_t)a2;
  return a4;
}

_QWORD *std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__find_equal<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 24;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = (uint64_t)(v4 + 4);
        if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()(v7, a3, (uint64_t)(v4 + 4)))break;
        v4 = (_QWORD *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()(v7, v9, a3))break;
      v5 = v8 + 1;
      v4 = (_QWORD *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  int64_t v18;
  unint64_t v19;
  unint64_t v20;
  BOOL v21;
  int *v22;
  int v23;
  _BOOL4 v24;
  int *v25;
  int v26;
  unint64_t comparison_y;
  _BOOL4 v28;
  unint64_t v29;
  BOOL v30;
  unsigned int v31;

  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a2 + 56);
  v6 = 40;
  if (v4 <= v5)
    v7 = 40;
  else
    v7 = 0;
  if (v4 <= v5)
    v8 = a2 + 40;
  else
    v8 = a2;
  v9 = *(_QWORD *)(a3 + 16);
  v10 = *(_QWORD *)(a3 + 56);
  if (v9 <= v10)
  {
    v11 = a3 + 40;
  }
  else
  {
    v6 = 0;
    v11 = a3;
  }
  v12 = *(_DWORD *)(a2 + v7);
  v13 = *(_DWORD *)(a3 + v6);
  if (v12 < v13)
    return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::operator()(a1, (int *)a2, (int *)(a2 + 40), (int *)v11);
  if (v12 > v13)
    return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::operator()(a1, (int *)a3, (int *)(a3 + 40), (int *)v8) ^ 1;
  v15 = *(_QWORD *)(v8 + 16);
  v16 = *(_QWORD *)(v11 + 16);
  if (v15 == v16)
  {
    if (v4 == v5)
    {
      v17 = *(unsigned int *)(a2 + 4);
    }
    else if (v4 > v5)
    {
      v17 = *(unsigned int *)(a2 + 4) | 0x100000000;
    }
    else
    {
      v17 = *(unsigned int *)(a2 + 44) | 0xFFFFFFFF00000000;
    }
    if (v9 == v10)
    {
      v29 = *(unsigned int *)(a3 + 4);
    }
    else if (v9 > v10)
    {
      v29 = *(unsigned int *)(a3 + 4) | 0x100000000;
    }
    else
    {
      v29 = *(unsigned int *)(a3 + 44) | 0xFFFFFFFF00000000;
    }
    v30 = (int)v29 >= (int)v17 && SHIDWORD(v17) < SHIDWORD(v29);
    v31 = v30;
    if ((int)v17 >= (int)v29)
      return v31;
    else
      return 1;
  }
  else if (v15 >= v16)
  {
    v25 = (int *)(a2 + 44);
    if (v4 > v5)
      v25 = (int *)(a2 + 4);
    if (v4 == v5)
      v25 = (int *)(a2 + 4);
    v26 = *v25;
    comparison_y = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::get_comparison_y(a1, a3, 0);
    if (v26 == (_DWORD)comparison_y)
    {
      v28 = *(_DWORD *)v11 != *(_DWORD *)(v11 + 8) || *(_DWORD *)(v11 + 4) != *(_DWORD *)(v11 + 12);
      return SHIDWORD(comparison_y) > 0 || v28;
    }
    else
    {
      return v26 < (int)comparison_y;
    }
  }
  else
  {
    v18 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::get_comparison_y(a1, a2, 0);
    v19 = *(_QWORD *)(a3 + 16);
    v20 = *(_QWORD *)(a3 + 56);
    v21 = v19 == v20;
    v30 = v19 > v20;
    v22 = (int *)(a3 + 44);
    if (v30)
      v22 = (int *)(a3 + 4);
    if (v21)
      v22 = (int *)(a3 + 4);
    v23 = *v22;
    if (v23 == (_DWORD)v18)
    {
      v24 = *(_DWORD *)v8 == *(_DWORD *)(v8 + 8) && *(_DWORD *)(v8 + 4) == *(_DWORD *)(v8 + 12);
      return v18 < 0 && v24;
    }
    else
    {
      return v23 > (int)v18;
    }
  }
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::operator()(uint64_t a1, int *a2, int *a3, int *a4)
{
  int *v4;
  int v6;

  v4 = a2;
  if (*a2 == a2[2] && a2[1] == a2[3])
  {
    if (*a3 == a3[2] && a3[1] == a3[3])
      return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::pp(a1, a2, a3, a4);
    v6 = 0;
    return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::ps(a1, a2, a3, a4, v6);
  }
  if (*a3 == a3[2] && a3[1] == a3[3])
  {
    a2 = a3;
    a3 = v4;
    v6 = 1;
    return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::ps(a1, a2, a3, a4, v6);
  }
  return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::ss(a1, a2, a3, a4);
}

unint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>::get_comparison_y(uint64_t a1, uint64_t a2, char a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v6;

  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a2 + 56);
  if (v3 == v4)
    return *(unsigned int *)(a2 + 4);
  if (v3 <= v4)
    return *(unsigned int *)(a2 + 44) | 0xFFFFFFFF00000000;
  if ((a3 & 1) != 0
    || *(_DWORD *)a2 != *(_DWORD *)(a2 + 8)
    || (v6 = *(unsigned int *)(a2 + 12), *(_DWORD *)(a2 + 4) == (_DWORD)v6))
  {
    v6 = *(unsigned int *)(a2 + 4);
  }
  return v6 | 0x100000000;
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::pp(uint64_t a1, int *a2, int *a3, int *a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  double v9;
  int v10;

  v4 = *a2;
  v5 = *a3;
  if (*a2 <= *a3)
  {
    if (v4 >= v5)
      return a3[1] + (uint64_t)a2[1] < 2 * a4[1];
    v6 = a4[1];
    v8 = a3[1];
    if (v6 < v8)
    {
      v7 = a2[1];
      goto LABEL_8;
    }
    return 1;
  }
  else
  {
    v6 = a4[1];
    v7 = a2[1];
    if (v6 > v7)
    {
      v8 = a3[1];
LABEL_8:
      v9 = (double)v4;
      v10 = *a4;
      return (((double)v7 - (double)v6) * ((double)v7 - (double)v6) + (v9 - (double)v10) * (v9 - (double)v10))
           / (v9 - (double)v10 + v9 - (double)v10) < (((double)v8 - (double)v6) * ((double)v8 - (double)v6)
                                                    + ((double)v5 - (double)v10) * ((double)v5 - (double)v10))
                                                   / ((double)v5 - (double)v10 + (double)v5 - (double)v10);
    }
    return 0;
  }
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::ps(uint64_t a1, int *a2, int *a3, int *a4, int a5)
{
  int v10;
  double v12;
  double v13;
  double v14;

  v10 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::fast_ps(a1, a2, (uint64_t)a3, a4, a5);
  if (v10)
    return v10 == -1;
  v12 = (double)*a2 - (double)*a4;
  v13 = (((double)a2[1] - (double)a4[1]) * ((double)a2[1] - (double)a4[1]) + v12 * v12) / (v12 + v12);
  boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::find_distance_to_segment_arc(a1, a3, a4);
  return (v13 < v14) ^ a5;
}

BOOL boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::ss(uint64_t a1, int *a2, int *a3, int *a4)
{
  double v8;
  double v9;
  double v10;

  if (*a2 == *a3 && a2[1] == a3[1] && a2[2] == a3[2] && a2[3] == a3[3])
    return boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(a2, a2 + 2, a4) == 1;
  boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::find_distance_to_segment_arc(a1, a2, a4);
  v9 = v8;
  boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::find_distance_to_segment_arc(a1, a3, a4);
  return v9 < v10;
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::fast_ps(uint64_t a1, int *a2, uint64_t a3, int *a4, int a5)
{
  unint64_t v9;
  int *v10;
  int *v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  int v29;
  _BOOL4 v30;
  _BOOL4 v31;
  int v32;
  unsigned int v33;

  v9 = *(_QWORD *)(a3 + 32);
  if ((v9 & 0x20) != 0)
    v10 = (int *)(a3 + 8);
  else
    v10 = (int *)a3;
  if ((v9 & 0x20) != 0)
    v11 = (int *)a3;
  else
    v11 = (int *)(a3 + 8);
  if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(v10, v11, a4) == -1)
  {
    v13 = a4[1];
    v14 = a2[1];
    if (*(_DWORD *)a3 == *(_DWORD *)(a3 + 8))
    {
      if ((int)v13 >= (int)v14 || a5)
      {
        if ((int)v13 > (int)v14)
          v22 = a5;
        else
          v22 = 0;
        return (v22 << 31 >> 31);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      v15 = (v9 >> 2) & 8;
      v16 = *a4;
      v17 = *a2;
      v18 = *(int *)(a3 + 8 * ((v9 & 0x20) == 0));
      v19 = *(int *)(a3 + v15);
      v20 = v11[1];
      v21 = v10[1];
      if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v18 - v19, v20 - v21, v16 - v17, v13 - v14) <= 0.0)
      {
        v23 = (double)(int)v16 - (double)(int)v17;
        v24 = (double)(int)v13 - (double)(int)v14;
        v25 = (v24 - v23) * ((v23 + v24) * ((double)(int)v18 - (double)(int)v19));
        v26 = v24 * (v23 * ((double)(int)v20 - (double)(int)v21 + (double)(int)v20 - (double)(int)v21));
        v27 = v25;
        v28 = v26;
        if (v25 >= 0.0)
          *(_QWORD *)&v27 = 0x8000000000000000 - *(_QWORD *)&v25;
        if (v26 >= 0.0)
          *(_QWORD *)&v28 = 0x8000000000000000 - *(_QWORD *)&v26;
        if (*(_QWORD *)&v27 - *(_QWORD *)&v28 <= 4uLL)
          v29 = 0;
        else
          v29 = -1;
        if (*(_QWORD *)&v27 > *(_QWORD *)&v28)
          v30 = v29;
        else
          v30 = *(_QWORD *)&v28 - *(_QWORD *)&v27 > 4uLL;
        v31 = v30;
        v32 = v30 ^ a5;
        if (a5)
          v33 = -1;
        else
          v33 = 1;
        if ((v31 & v32) != 0)
          return v33;
        else
          return 0;
      }
      else if ((*(_BYTE *)(a3 + 32) & 0x20) != 0)
      {
        return a5 ^ 1u;
      }
      else
      {
        return (a5 << 31 >> 31);
      }
    }
  }
  else if ((*(_BYTE *)(a3 + 32) & 0x20) != 0)
  {
    return 1;
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::distance_predicate<boost::polygon::detail::site_event<int>>::find_distance_to_segment_arc(uint64_t a1, int *a2, int *a3)
{
  int *v3;
  int v4;
  int v5;
  int *v6;

  v3 = a2 + 2;
  v4 = *a2;
  if (*a2 != a2[2])
  {
    if ((*((_QWORD *)a2 + 4) & 0x20) != 0)
      v5 = a2[2];
    else
      v5 = *a2;
    if ((*((_QWORD *)a2 + 4) & 0x20) != 0)
      v6 = a2 + 2;
    else
      v6 = a2;
    if ((*((_QWORD *)a2 + 4) & 0x20) != 0)
      v3 = a2;
    else
      v4 = a2[2];
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v4 - (uint64_t)v5, v3[1] - (uint64_t)v6[1], *a3 - (uint64_t)v5, a3[1] - (uint64_t)v6[1]);
  }
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::end_point_comparison &,std::__wrap_iter<std::pair<boost::polygon::detail::point_2d<int>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>> *>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  _OWORD *v6;
  int v7;
  int v8;
  _BOOL4 v9;
  BOOL v10;
  _BOOL4 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  BOOL v16;

  if (a4 >= 2)
  {
    v4 = (unint64_t)(a4 - 2) >> 1;
    v5 = result + 16 * v4;
    v7 = *(_DWORD *)(a2 - 16);
    v8 = *(_DWORD *)(a2 - 12);
    v6 = (_OWORD *)(a2 - 16);
    v9 = v8 < *(_DWORD *)(v5 + 4);
    v10 = v7 == *(_DWORD *)v5;
    v11 = v7 < *(_DWORD *)v5;
    if (v10)
      v11 = v9;
    if (v11)
    {
      v12 = *v6;
      v13 = *(_QWORD *)v6;
      v14 = HIDWORD(*(_QWORD *)v6);
      do
      {
        v15 = v6;
        v6 = (_OWORD *)v5;
        *v15 = *(_QWORD *)v5;
        v15[1] = *(_QWORD *)(v5 + 8);
        if (!v4)
          break;
        v4 = (v4 - 1) >> 1;
        v5 = result + 16 * v4;
        v16 = *(_DWORD *)v5 > (int)v13;
        if (*(_DWORD *)v5 == (_DWORD)v13)
          v16 = *(_DWORD *)(v5 + 4) > (int)v14;
      }
      while (v16);
      *v6 = v12;
    }
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__emplace_hint_unique_key_args<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::pair<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>(uint64_t **a1, _QWORD *a2, uint64_t a3, _OWORD *a4)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t **v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v13;
  uint64_t v14;

  v6 = std::__tree<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__map_value_compare<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::node_comparison_predicate<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>,false>,std::allocator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>>>::__find_equal<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>>(a1, a2, &v14, &v13, a3);
  v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = (uint64_t *)operator new(0x80uLL);
    v9 = a4[3];
    *((_OWORD *)v7 + 4) = a4[2];
    *((_OWORD *)v7 + 5) = v9;
    v10 = a4[1];
    *((_OWORD *)v7 + 2) = *a4;
    *((_OWORD *)v7 + 3) = v10;
    v11 = a4[5];
    *((_OWORD *)v7 + 6) = a4[4];
    *((_OWORD *)v7 + 7) = v11;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, v14, v8, v7);
  }
  return v7;
}

uint64_t boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::activate_circle_event(uint64_t a1, int *a2, int *a3, int *a4, uint64_t a5)
{
  uint64_t result;
  _OWORD v8[2];
  uint64_t v9;
  __int128 v10;
  __int128 v11;

  BYTE8(v11) = 1;
  result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_formation_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>>::operator()(a1 + 160, a2, a3, a4, (uint64_t)&v10);
  if ((_DWORD)result)
  {
    v8[0] = v10;
    v8[1] = v11;
    v9 = a5;
    result = boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::push((char **)(a1 + 72), (uint64_t)v8);
    *(_QWORD *)(a5 + 112) = result;
  }
  return result;
}

uint64_t std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::end_point_comparison &,std::__wrap_iter<std::pair<boost::polygon::detail::point_2d<int>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>> *>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  _BOOL4 v11;

  v3 = 0;
  v4 = a3 - 2;
  if (a3 < 2)
    v4 = a3 - 1;
  v5 = v4 >> 1;
  do
  {
    v6 = (uint64_t)&a1[2 * v3 + 2];
    v7 = (2 * v3) | 1;
    v8 = 2 * v3 + 2;
    if (v8 < a3)
    {
      v9 = *(_DWORD *)(v6 + 16);
      v10 = v9 == *(_DWORD *)v6;
      v11 = v9 < *(_DWORD *)v6;
      if (v10)
        v11 = *(_DWORD *)(v6 + 20) < *(_DWORD *)(v6 + 4);
      if (v11)
      {
        v6 += 16;
        v7 = v8;
      }
    }
    *a1 = *(_QWORD *)v6;
    a1[1] = *(_QWORD *)(v6 + 8);
    a1 = (_QWORD *)v6;
    v3 = v7;
  }
  while (v7 <= v5);
  return v6;
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_formation_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>>::operator()(uint64_t a1, int *a2, int *a3, int *a4, uint64_t a5)
{
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int *v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;

  v10 = a2[2];
  if (*a2 == v10 && a2[1] == a2[3])
  {
    v11 = a3[2];
    if (*a3 == v11 && a3[1] == a3[3])
    {
      if (*a4 == a4[2] && a4[1] == a4[3])
      {
        if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(a2, a3, a4) == -1)
        {
          boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::ppp(a1 + 4, a2, a3, a4, a5);
          return 1;
        }
        return 0;
      }
      if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::pps(a1, a2, a3, (uint64_t)a4, 3))return 0;
      v21 = a1 + 4;
      v22 = a2;
      v23 = a3;
      v24 = (uint64_t)a4;
      v25 = 3;
    }
    else
    {
      v20 = a4[2];
      if (*a4 != v20 || a4[1] != a4[3])
      {
        if (*a3 != *a4 || v11 != v20 || a3[1] != a4[1] || a3[3] != a4[3])
        {
          v14 = 1;
          boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pss(a1 + 4, a2, (uint64_t)a3, (uint64_t)a4, 1, a5);
          return v14;
        }
        return 0;
      }
      if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::pps(a1, a2, a4, (uint64_t)a3, 2))return 0;
      v21 = a1 + 4;
      v22 = a2;
      v23 = a4;
      v24 = (uint64_t)a3;
      v25 = 2;
    }
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pps(v21, v22, v23, v24, v25, a5);
    return 1;
  }
  v12 = a3[2];
  if (*a3 != v12 || a3[1] != a3[3])
  {
    if (*a4 != a4[2] || a4[1] != a4[3])
    {
      if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::sss(a1, a2, a3, a4))
      {
        boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sss(a1 + 4, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, a5);
        return 1;
      }
      return 0;
    }
    if (*a2 == *a3 && v10 == v12 && a2[1] == a3[1] && a2[3] == a3[3])
      return 0;
    v15 = a1 + 4;
    v16 = a4;
    v17 = (uint64_t)a2;
    v18 = (uint64_t)a3;
    v19 = 3;
LABEL_30:
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pss(v15, v16, v17, v18, v19, a5);
    return 1;
  }
  if (*a4 != a4[2] || a4[1] != a4[3])
  {
    if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::pss(a1, a3, (uint64_t)a2, (uint64_t)a4, 2))return 0;
    v15 = a1 + 4;
    v16 = a3;
    v17 = (uint64_t)a2;
    v18 = (uint64_t)a4;
    v19 = 2;
    goto LABEL_30;
  }
  if (!boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::pps(a1, a3, a4, (uint64_t)a2, 1))return 0;
  v13 = a1 + 4;
  v14 = 1;
  boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pps(v13, a3, a4, (uint64_t)a2, 1, a5);
  return v14;
}

uint64_t boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::push(char **a1, uint64_t a2)
{
  char **v4;
  _OWORD *v5;
  __int128 v6;
  char *v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  __int16 v23;

  v4 = a1 + 4;
  v5 = operator new(0x38uLL);
  v6 = *(_OWORD *)(a2 + 16);
  v5[1] = *(_OWORD *)a2;
  v5[2] = v6;
  *((_QWORD *)v5 + 6) = *(_QWORD *)(a2 + 32);
  v7 = a1[5];
  *(_QWORD *)v5 = v4;
  *((_QWORD *)v5 + 1) = v7;
  *(_QWORD *)v7 = v5;
  v8 = (unint64_t)a1[2];
  a1[5] = (char *)v5;
  ++a1[6];
  v9 = a1[1];
  if ((unint64_t)v9 >= v8)
  {
    v11 = (v9 - *a1) >> 3;
    if ((unint64_t)(v11 + 1) >> 61)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v12 = v8 - (_QWORD)*a1;
    v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1))
      v13 = v11 + 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v13;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>((uint64_t)(a1 + 2), v14);
    else
      v15 = 0;
    v16 = &v15[8 * v11];
    v17 = &v15[8 * v14];
    *(_QWORD *)v16 = v5;
    v10 = (uint64_t)(v16 + 8);
    v19 = *a1;
    v18 = a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *((_QWORD *)v18 - 1);
        v18 -= 8;
        *((_QWORD *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      v18 = *a1;
    }
    *a1 = v16;
    a1[1] = (char *)v10;
    a1[2] = v17;
    if (v18)
      operator delete(v18);
  }
  else
  {
    *(_QWORD *)v9 = v5;
    v10 = (uint64_t)(v9 + 8);
  }
  a1[1] = (char *)v10;
  v21 = *a1;
  v23 = *((_WORD *)a1 + 12);
  std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::comparison &,std::__wrap_iter<std::__list_iterator<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,void *> *>>((_BOOL8)v21, v10, (uint64_t)&v23, (v10 - (uint64_t)v21) >> 3);
  return (uint64_t)(a1[5] + 16);
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::ppp(uint64_t a1, int *a2, int *a3, int *a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46[2];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;

  v9 = *a2;
  v10 = a2[1];
  v11 = *a3;
  v12 = a3[1];
  v13 = (double)(int)v9 - (double)(int)v11;
  v14 = *a4;
  v15 = a4[1];
  v16 = (double)(int)v11 - (double)(int)v14;
  v17 = (double)(int)v10 - (double)(int)v12;
  v18 = (double)(int)v12 - (double)(int)v15;
  v19 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v9 - v11, v11 - v14, v10 - v12, v12 - v15);
  v20 = (double)*a2;
  v21 = (double)*a3;
  v22 = (double)*a4;
  v23 = 0.5 / v19;
  v24 = v20 + v21;
  v25 = v21 + v22;
  v26 = (double)a2[1];
  v27 = (double)a3[1];
  v28 = (double)a4[1];
  v29 = v26 + v27;
  v30 = v27 + v28;
  v44 = v20 - v22;
  v45 = v23;
  v43 = v26 - v28;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v31 = v13 * v24;
  *(double *)&v47 = v18 * (v13 * v24);
  *((_QWORD *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v51, (double *)&v47);
  v32 = v17 * v29;
  *(double *)&v47 = v18 * v32;
  *((_QWORD *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v51, (double *)&v47);
  v33 = v16 * v25;
  *(double *)&v47 = v17 * v33;
  *((_QWORD *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v51, (double *)&v47);
  v34 = v18 * v30;
  *(double *)&v47 = v17 * v34;
  *((_QWORD *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v51, (double *)&v47);
  *(double *)&v47 = v13 * v33;
  *((_QWORD *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v49, (double *)&v47);
  *(double *)&v47 = v13 * v34;
  *((_QWORD *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v49, (double *)&v47);
  *(double *)&v47 = v16 * v31;
  *((_QWORD *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v49, (double *)&v47);
  *(double *)&v47 = v16 * v32;
  *((_QWORD *)&v47 + 1) = 0x4000000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v49, (double *)&v47);
  v47 = v51;
  v48 = v52;
  v46[0] = sqrt((v17 * v17 + v13 * v13) * (v18 * v18 + v16 * v16) * (v43 * v43 + v44 * v44));
  v46[1] = 5.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v47, v46);
  v35 = v45 * boost::polygon::detail::robust_fpt<double>::operator-((double *)&v51, (double *)&v52);
  v36 = v45 * boost::polygon::detail::robust_fpt<double>::operator-((double *)&v49, (double *)&v50);
  v37 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v47, (double *)&v48);
  *(double *)a5 = v35;
  *(double *)(a5 + 8) = v36;
  *(double *)(a5 + 16) = v45 * v37;
  *(_BYTE *)(a5 + 24) = 1;
  boost::polygon::detail::robust_fpt<double>::operator-((double *)&v51, (double *)&v52);
  v39 = v38;
  boost::polygon::detail::robust_fpt<double>::operator-((double *)&v49, (double *)&v50);
  v41 = v40;
  boost::polygon::detail::robust_fpt<double>::operator-((double *)&v47, (double *)&v48);
  if (v39 > 64.0 || v41 > 64.0 || v42 > 64.0)
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::ppp();
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::pps(uint64_t a1, int *a2, int *a3, uint64_t a4, int a5)
{
  uint64_t v8;
  int *v9;
  int *v10;
  uint64_t v11;
  int v13;
  int *v14;
  int v15;

  v8 = *(_QWORD *)(a4 + 32);
  v9 = (int *)(a4 + 8);
  if ((v8 & 0x20) != 0)
    v10 = (int *)(a4 + 8);
  else
    v10 = (int *)a4;
  if (a5 == 2)
  {
    if (*v10 != *a2 || v10[1] != a2[1])
      return 1;
    v11 = (v8 & 0x20) != 0 ? a4 : a4 + 8;
    return *(_DWORD *)(a4 + 8 * ((*(_QWORD *)(a4 + 32) & 0x20) == 0)) != *a3 || *(_DWORD *)(v11 + 4) != a3[1];
  }
  v13 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(a2, a3, v10);
  if ((*(_QWORD *)(a4 + 32) & 0x20) != 0)
    v14 = (int *)a4;
  else
    v14 = v9;
  v15 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(a2, a3, v14);
  if (a5 == 3)
  {
    if (*a3 >= *a2)
      return v15 == -1;
    return v13 == -1 || v15 == -1;
  }
  if (a5 != 1 || *a2 < *a3)
    return v13 == -1 || v15 == -1;
  return v13 == -1;
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pps(uint64_t a1, int *a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  double v26;
  double v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  double v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  double v42;
  BOOL v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  int v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  double v69;
  double v70;
  double v71;
  double v72;
  double v73;
  __int128 v74;
  double v75;
  double v76;
  double v77;
  double v78;
  double v79;
  double v80;
  double v81;
  double v82;
  double v83;
  double v84;
  double v85;
  double v86;
  double v87;
  double v88;
  double v89;
  double v90;
  double v91;
  double v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  double v102[3];
  double v103[2];
  double v104[3];

  v12 = (*(_QWORD *)(a4 + 32) & 0x20) == 0;
  v13 = a4 + 8;
  if (v12)
    v14 = a4 + 8;
  else
    v14 = a4;
  v15 = *(int *)(v14 + 4);
  if (v12)
    v16 = a4;
  else
    v16 = a4 + 8;
  v17 = *(int *)(a4 + ((*(_QWORD *)(a4 + 32) >> 2) & 8));
  v18 = (double)(int)v17;
  v19 = *(int *)(a4 + 8 * v12);
  v20 = *(int *)(v16 + 4);
  v22 = *a3;
  v21 = a3[1];
  v24 = *a2;
  v23 = a2[1];
  v25 = (double)(int)v21 - (double)(int)v23;
  v87 = (double)(int)v24;
  v88 = (double)(int)v19;
  v26 = (double)(int)v22;
  v27 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v15 - v20, v17 - v19, v22 - v24, v21 - v23);
  v28 = (*(_QWORD *)(a4 + 32) & 0x20) == 0;
  if (v28)
    v29 = v13;
  else
    v29 = a4;
  v30 = *(int *)(v29 + 4);
  if (v28)
    v31 = a4;
  else
    v31 = v13;
  v32 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v30 - *(int *)(v31 + 4), *(int *)(a4 + ((*(_QWORD *)(a4 + 32) >> 2) & 8)) - (uint64_t)*(int *)(a4 + 8 * v28), *(int *)(a4 + 12) - (uint64_t)a2[1], *a2 - (uint64_t)*(int *)(a4 + 8));
  v104[0] = v32;
  v33 = (*(_QWORD *)(a4 + 32) & 0x20) == 0;
  if (v33)
    v34 = v13;
  else
    v34 = a4;
  v35 = *(int *)(v34 + 4);
  if (v33)
    v36 = a4;
  else
    v36 = v13;
  v37 = v35 - *(int *)(v36 + 4);
  v38 = *(int *)(a4 + ((*(_QWORD *)(a4 + 32) >> 2) & 8)) - (uint64_t)*(int *)(a4 + 8 * v33);
  v39 = *a3;
  v40 = *(int *)(a4 + 8);
  v41 = *(int *)(a4 + 12) - (uint64_t)a3[1];
  v104[1] = 1.0;
  v42 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v37, v38, v41, v39 - v40);
  v103[0] = v42;
  v103[1] = 1.0;
  v43 = (*(_QWORD *)(a4 + 32) & 0x20) == 0;
  if (v43)
    v44 = v13;
  else
    v44 = a4;
  v45 = *(int *)(v44 + 4);
  if (v43)
    v46 = a4;
  else
    v46 = v13;
  v47 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(a3[1] - (uint64_t)a2[1], *a2 - (uint64_t)*a3, v45 - *(int *)(v46 + 4), *(int *)(a4 + ((*(_QWORD *)(a4 + 32) >> 2) & 8)) - (uint64_t)*(int *)(a4 + 8 * v43));
  v48 = 1.0;
  v101 = 0u;
  *(_OWORD *)v102 = 0u;
  if (v47 == 0.0)
  {
    *(double *)&v99 = v27 / (v32 * 8.0);
    *((_QWORD *)&v99 + 1) = 0x4010000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v101, (double *)&v99);
    *(double *)&v99 = v32 / (v27 + v27);
    *((_QWORD *)&v99 + 1) = 0x4010000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v101, (double *)&v99);
  }
  else
  {
    *(double *)&v99 = v27 * v27;
    *((_QWORD *)&v99 + 1) = 0x4008000000000000;
    *(double *)&v97 = v47 * v47;
    *((_QWORD *)&v97 + 1) = 0x4008000000000000;
    v48 = 1.0;
    *(double *)&v99 = sqrt(boost::polygon::detail::robust_fpt<double>::operator+((double *)&v99, (double *)&v97)* v32* v42)/ (v47* v47);
    *((double *)&v99 + 1) = (v49 + 1.0 + 1.0 + 1.0 + 1.0) * 0.5 + 1.0 + 3.0 + 1.0;
    if ((_DWORD)a5 == 2)
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v101, (double *)&v99);
    else
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v101, (double *)&v99);
    *(double *)&v99 = v27 * boost::polygon::detail::robust_fpt<double>::operator+(v104, v103) / (v47 * (v47 + v47));
    *((double *)&v99 + 1) = v50 + 1.0 + 1.0 + 4.0 + 1.0;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v101, (double *)&v99);
  }
  v51 = v18 - v88;
  v52 = v87 - v26;
  v99 = 0u;
  v100 = 0u;
  v53 = (double)*a2;
  v54 = *a3;
  v97 = 0u;
  v98 = 0u;
  v95 = COERCE_UNSIGNED_INT64((v53 + (double)v54) * 0.5);
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v99, (double *)&v95);
  if (v25 >= 0.0)
  {
    v55 = *((double *)&v101 + 1);
    v56 = v25 * *(double *)&v101;
    v57 = v102[1];
    v58 = v25 * v102[0];
  }
  else
  {
    v55 = v102[1];
    v56 = -(v25 * v102[0]);
    v57 = *((double *)&v101 + 1);
    v58 = -(v25 * *(double *)&v101);
  }
  v59 = (double)(int)v15 - (double)(int)v20;
  *(double *)&v95 = v56;
  *((double *)&v95 + 1) = v55 + 0.0 + 1.0;
  *(double *)&v96 = v58;
  *((double *)&v96 + 1) = v57 + 0.0 + 1.0;
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v99, (double *)&v95);
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v100, (double *)&v96);
  *(double *)&v95 = ((double)a2[1] + (double)a3[1]) * 0.5;
  *((_QWORD *)&v95 + 1) = 0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v97, (double *)&v95);
  if (v52 >= 0.0)
  {
    v60 = *((double *)&v101 + 1);
    v61 = v52 * *(double *)&v101;
    v62 = v102[1];
    v63 = v52 * v102[0];
  }
  else
  {
    v60 = v102[1];
    v61 = -(v52 * v102[0]);
    v62 = *((double *)&v101 + 1);
    v63 = -(v52 * *(double *)&v101);
  }
  *(double *)&v95 = v61;
  *((double *)&v95 + 1) = v60 + 0.0 + 1.0;
  *(double *)&v96 = v63;
  *((double *)&v96 + 1) = v62 + 0.0 + 1.0;
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v97, (double *)&v95);
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v98, (double *)&v96);
  v95 = 0u;
  v96 = 0u;
  v93 = v99;
  v94 = v100;
  v89 = v59 * (double)*(int *)a4;
  v90 = 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v95, &v89);
  v89 = v51 * (double)*(int *)(a4 + 4);
  v90 = 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v95, &v89);
  if (v59 >= 0.0)
  {
    v64 = *((double *)&v99 + 1);
    v65 = v59 * *(double *)&v99;
    v66 = *((double *)&v100 + 1);
    v67 = v59 * *(double *)&v100;
  }
  else
  {
    v64 = *((double *)&v100 + 1);
    v65 = -(v59 * *(double *)&v100);
    v66 = *((double *)&v99 + 1);
    v67 = -(v59 * *(double *)&v99);
  }
  v68 = sqrt(v51 * v51 + v59 * v59);
  v89 = v65;
  v90 = v64 + 0.0 + 1.0;
  v91 = v67;
  v92 = v66 + 0.0 + 1.0;
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v95, &v89);
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v96, &v91);
  if (v51 >= 0.0)
  {
    v69 = *((double *)&v97 + 1);
    v70 = v51 * *(double *)&v97;
    v71 = *((double *)&v98 + 1);
    v72 = v51 * *(double *)&v98;
  }
  else
  {
    v69 = *((double *)&v98 + 1);
    v70 = -(v51 * *(double *)&v98);
    v71 = *((double *)&v97 + 1);
    v72 = -(v51 * *(double *)&v97);
  }
  v73 = v48 / v68;
  v89 = v70;
  v90 = v69 + 0.0 + 1.0;
  v91 = v72;
  v92 = v71 + 0.0 + 1.0;
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v95, &v89);
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v96, &v91);
  v74 = v95;
  v76 = *((double *)&v96 + 1);
  v75 = *(double *)&v96;
  if (*(double *)&v95 >= *(double *)&v96)
  {
    v77 = *((double *)&v96 + 1);
    v78 = *(double *)&v96;
    v76 = *((double *)&v95 + 1);
    v75 = *(double *)&v95;
  }
  else
  {
    v95 = v96;
    v77 = *((double *)&v74 + 1);
    v78 = *(double *)&v74;
    v96 = v74;
  }
  v89 = v73 * v75;
  v90 = v76 + 3.0 + 1.0;
  v91 = v73 * v78;
  v92 = v77 + 3.0 + 1.0;
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v93, &v89);
  boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v94, &v91);
  v79 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v99, (double *)&v100);
  v80 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v97, (double *)&v98);
  v81 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v93, (double *)&v94);
  *(double *)a6 = v79;
  *(double *)(a6 + 8) = v80;
  *(double *)(a6 + 16) = v81;
  *(_BYTE *)(a6 + 24) = 1;
  boost::polygon::detail::robust_fpt<double>::operator-((double *)&v99, (double *)&v100);
  v83 = v82;
  boost::polygon::detail::robust_fpt<double>::operator-((double *)&v97, (double *)&v98);
  v85 = v84;
  boost::polygon::detail::robust_fpt<double>::operator-((double *)&v93, (double *)&v94);
  if (v83 > 64.0 || v85 > 64.0 || v86 > 64.0)
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pps(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, v83 > 64.0, v85 > 64.0, v86 > 64.0);
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::pss(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int *v8;

  if (*(_DWORD *)a3 == *(_DWORD *)a4
    && *(_DWORD *)(a3 + 4) == *(_DWORD *)(a4 + 4)
    && *(_DWORD *)(a3 + 8) == *(_DWORD *)(a4 + 8)
    && *(_DWORD *)(a3 + 12) == *(_DWORD *)(a4 + 12))
  {
    return 0;
  }
  if (a5 == 2)
  {
    v5 = *(_QWORD *)(a3 + 32);
    v6 = *(_QWORD *)(a4 + 32) & 0x20;
    if ((v5 & 0x20) != 0)
    {
      if (!v6)
        return 1;
    }
    else if (v6)
    {
      return 0;
    }
    if ((v5 & 0x20) != 0)
      v7 = (int *)(a3 + 8);
    else
      v7 = (int *)a3;
    if (v6)
      v8 = (int *)a4;
    else
      v8 = (int *)(a4 + 8);
    if (boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::orientation_test::eval<boost::polygon::detail::point_2d<int>>(v7, a2, v8) != -1)return 0;
  }
  return 1;
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pss(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  int *v10;
  int *v11;
  BOOL v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  int v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double *v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double *v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  double v69;
  double v70;
  double v71;
  double v72;
  double v73;
  double v74;
  double v75;
  double v76;
  double v77;
  double v78;
  double v79;
  double v80;
  double v81;
  double v82;
  double v83;
  double v84;
  double v85;
  double v86;
  double v87;
  double v88;
  double v89;
  double v90;
  double v91;
  double v92;
  double v93;
  double v94;
  double v95;
  double v96;
  double v97;
  double v98;
  double v99;
  double v100;
  double v101;
  float64_t v102;
  double v103;
  float64_t v104;
  double v105;
  double *v106;
  double v107;
  double v108;
  double v109;
  double v110;
  double v111;
  double v112;
  double v113;
  double v114;
  double v115;
  double v116;
  double v120;
  double v122;
  double v123;
  double v124;
  double v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  double v132;
  double v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  float64x2_t v140;
  float64x2_t v141;

  _ZF = (*(_QWORD *)(a3 + 32) & 0x20) == 0;
  v9 = 8 * _ZF;
  if (_ZF)
    v10 = (int *)(a3 + 8);
  else
    v10 = (int *)a3;
  if (_ZF)
    v11 = (int *)a3;
  else
    v11 = (int *)(a3 + 8);
  v12 = (*(_QWORD *)(a4 + 32) & 0x20) == 0;
  if (v12)
    v13 = (int *)a4;
  else
    v13 = (int *)(a4 + 8);
  v14 = *(int *)(a3 + ((*(_QWORD *)(a3 + 32) >> 2) & 8));
  v15 = *(int *)(a3 + v9);
  v16 = (double)(int)v14 - (double)(int)v15;
  v17 = v11[1];
  v18 = v10[1];
  if (v12)
    v19 = (int *)(a4 + 8);
  else
    v19 = (int *)a4;
  v20 = (double)(int)v17 - (double)(int)v18;
  v21 = *(int *)(a4 + 8 * v12);
  v22 = *(int *)(a4 + ((*(_QWORD *)(a4 + 32) >> 2) & 8));
  v23 = v19[1];
  v24 = v13[1];
  v25 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v17 - v18, v14 - v15, v23 - v24, v21 - v22);
  if (v25 == 0.0)
  {
    v26 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v11[1] - (uint64_t)v10[1], *v11 - (uint64_t)*v10, v13[1] - (uint64_t)v10[1], *v13 - (uint64_t)*v10);
    v27 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*v11 - (uint64_t)*v10, v11[1] - (uint64_t)v10[1], *a2 - (uint64_t)*v10, a2[1] - (uint64_t)v10[1]);
    v28 = v27
        * boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v11[1] - (uint64_t)v10[1], *v11 - (uint64_t)*v10, a2[1] - (uint64_t)v13[1], *a2 - (uint64_t)*v13);
    v140 = 0u;
    v141 = 0u;
    *(double *)&v138 = v16 * -((double)*a2 - ((double)*v10 + (double)*v13) * 0.5);
    *((_QWORD *)&v138 + 1) = 0x3FF0000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=(v140.f64, (double *)&v138);
    *(double *)&v138 = v20 * -((double)a2[1] - ((double)v10[1] + (double)v13[1]) * 0.5);
    *((_QWORD *)&v138 + 1) = 0x3FF0000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=(v140.f64, (double *)&v138);
    *(_QWORD *)&v138 = sqrt(v28);
    *((_QWORD *)&v138 + 1) = 0x4004000000000000;
    if ((_DWORD)a5 == 2)
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=(v140.f64, (double *)&v138);
    else
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=(v140.f64, (double *)&v138);
    __asm { FMOV            V0.2D, #3.0 }
    v35 = vaddq_f64(v140, _Q0);
    v36 = vaddq_f64(v141, _Q0);
    _Q0.f64[0] = v20 * v20 + v16 * v16;
    *(_QWORD *)&v37.f64[0] = *(_OWORD *)&vdivq_f64(v140, _Q0);
    v37.f64[1] = v35.f64[1];
    *(_QWORD *)&_Q0.f64[0] = *(_OWORD *)&vdivq_f64(v141, _Q0);
    _Q0.f64[1] = v36.f64[1];
    v140 = v37;
    v141 = _Q0;
    v138 = 0u;
    v139 = 0u;
    v37.f64[0] = (double)*v10;
    v38 = *v13;
    v136 = 0u;
    v137 = 0u;
    v134 = COERCE_UNSIGNED_INT64((v37.f64[0] + (double)v38) * 0.5);
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v138, (double *)&v134);
    if (v16 >= 0.0)
    {
      v39 = v140.f64[1];
      v40 = v16 * v140.f64[0];
      v41 = v141.f64[1];
      v42 = v16 * v141.f64[0];
    }
    else
    {
      v39 = v141.f64[1];
      v40 = -(v16 * v141.f64[0]);
      v41 = v140.f64[1];
      v42 = -(v16 * v140.f64[0]);
    }
    *(double *)&v134 = v40;
    *((double *)&v134 + 1) = v39 + 0.0 + 1.0;
    *(double *)&v135 = v42;
    *((double *)&v135 + 1) = v41 + 0.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v138, (double *)&v134);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v139, (double *)&v135);
    *(double *)&v134 = ((double)v10[1] + (double)v13[1]) * 0.5;
    *((_QWORD *)&v134 + 1) = 0;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v136, (double *)&v134);
    if (v20 >= 0.0)
    {
      v43 = v140.f64[1];
      v44 = v20 * v140.f64[0];
      v45 = v141.f64[1];
      v46 = v20 * v141.f64[0];
    }
    else
    {
      v43 = v141.f64[1];
      v44 = -(v20 * v141.f64[0]);
      v45 = v140.f64[1];
      v46 = -(v20 * v140.f64[0]);
    }
    *(double *)&v134 = v44;
    *((double *)&v134 + 1) = v43 + 0.0 + 1.0;
    *(double *)&v135 = v46;
    *((double *)&v135 + 1) = v45 + 0.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v136, (double *)&v134);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v137, (double *)&v135);
    v134 = v138;
    v135 = v139;
    *(double *)&v130 = v26 * 0.5 / sqrt(v20 * v20 + v16 * v16);
    *((_QWORD *)&v130 + 1) = 0x4014000000000000;
    if (v26 >= 0.0)
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v134, (double *)&v130);
    else
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v134, (double *)&v130);
    boost::polygon::detail::robust_fpt<double>::operator-((double *)&v138, (double *)&v139);
    v48 = v47;
    boost::polygon::detail::robust_fpt<double>::operator-((double *)&v136, (double *)&v137);
    v50 = v49;
    v51 = (double *)&v135;
    boost::polygon::detail::robust_fpt<double>::operator-((double *)&v134, (double *)&v135);
    v53 = v52;
    v54 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v138, (double *)&v139);
    v55 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v136, (double *)&v137);
    v56 = (double *)&v134;
  }
  else
  {
    v29 = (double)(int)v21 - (double)(int)v22;
    v116 = (double)(int)v23 - (double)(int)v24;
    v132 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*v11 - (uint64_t)*v10, v11[1] - (uint64_t)v10[1], v13[1] - (uint64_t)v19[1], *v19 - (uint64_t)*v13);
    v133 = 1.0;
    v120 = sqrt(v116 * v116 + v29 * v29);
    v114 = sqrt(v20 * v20 + v16 * v16);
    v140.f64[0] = v114 * v120;
    v140.f64[1] = 5.0;
    if (v132 < 0.0)
    {
      v132 = v25 * v25 / boost::polygon::detail::robust_fpt<double>::operator-(v140.f64, &v132);
      v133 = v30 + 3.0 + 1.0;
    }
    else
    {
      boost::polygon::detail::robust_fpt<double>::operator+=(&v132, v140.f64);
    }
    v112 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v11[1] - (uint64_t)v10[1], *v11 - (uint64_t)*v10, v11[1] - (uint64_t)a2[1], *v11 - (uint64_t)*a2);
    v113 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*v19 - (uint64_t)*v13, v19[1] - (uint64_t)v13[1], *v19 - (uint64_t)*a2, v19[1] - (uint64_t)a2[1]);
    v111 = v132;
    v57 = v133 + 0.0 + 1.0 + 1.0;
    v58 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v11[1] - (uint64_t)v10[1], *v11 - (uint64_t)*v10, v11[1], *v11);
    v59 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*v19 - (uint64_t)*v13, v19[1] - (uint64_t)v13[1], *v19, v19[1]);
    v115 = v25;
    v60 = 1.0 / v25;
    v140 = 0u;
    v141 = 0u;
    v138 = 0u;
    v139 = 0u;
    v136 = 0u;
    v137 = 0u;
    v134 = 0u;
    v135 = 0u;
    *(double *)&v130 = v60 * (v29 * v58);
    *((_QWORD *)&v130 + 1) = 0x4014000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v136, (double *)&v130);
    *(double *)&v130 = v60 * (v16 * v59);
    *((_QWORD *)&v130 + 1) = 0x4014000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v136, (double *)&v130);
    *(double *)&v130 = v60 * (v20 * v59);
    *((_QWORD *)&v130 + 1) = 0x4014000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v134, (double *)&v130);
    *(double *)&v130 = v60 * (v116 * v58);
    *((_QWORD *)&v130 + 1) = 0x4014000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v134, (double *)&v130);
    v61 = v16 * v120;
    if (v61 >= 0.0)
    {
      v62 = *((double *)&v136 + 1);
      v63 = *(double *)&v136;
      v64 = *((double *)&v137 + 1);
      v65 = *(double *)&v137;
    }
    else
    {
      v62 = *((double *)&v137 + 1);
      v63 = -*(double *)&v137;
      v64 = *((double *)&v136 + 1);
      v65 = -*(double *)&v136;
    }
    v66 = v57 + 1.0;
    *(double *)&v130 = v61 * v63;
    *((double *)&v130 + 1) = v62 + 3.0 + 1.0;
    *(double *)&v131 = v61 * v65;
    *((double *)&v131 + 1) = v64 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v138, (double *)&v130);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v139, (double *)&v131);
    v67 = v29 * v114;
    if (v29 * v114 >= 0.0)
    {
      v68 = *((double *)&v136 + 1);
      v69 = *(double *)&v136;
      v70 = *((double *)&v137 + 1);
      v71 = *(double *)&v137;
    }
    else
    {
      v68 = *((double *)&v137 + 1);
      v69 = -*(double *)&v137;
      v70 = *((double *)&v136 + 1);
      v71 = -*(double *)&v136;
    }
    v72 = v66 + 1.0;
    *(double *)&v130 = v67 * v69;
    *((double *)&v130 + 1) = v68 + 3.0 + 1.0;
    *(double *)&v131 = v67 * v71;
    *((double *)&v131 + 1) = v70 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v138, (double *)&v130);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v139, (double *)&v131);
    v73 = v20 * v120;
    if (v20 * v120 >= 0.0)
    {
      v74 = *((double *)&v134 + 1);
      v75 = *(double *)&v134;
      v76 = *((double *)&v135 + 1);
      v77 = *(double *)&v135;
    }
    else
    {
      v74 = *((double *)&v135 + 1);
      v75 = -*(double *)&v135;
      v76 = *((double *)&v134 + 1);
      v77 = -*(double *)&v134;
    }
    *(double *)&v130 = v73 * v75;
    *((double *)&v130 + 1) = v74 + 3.0 + 1.0;
    *(double *)&v131 = v73 * v77;
    *((double *)&v131 + 1) = v76 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v138, (double *)&v130);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v139, (double *)&v131);
    v78 = v114 * v116;
    if (v114 * v116 >= 0.0)
    {
      v79 = *((double *)&v134 + 1);
      v80 = *(double *)&v134;
      v81 = *((double *)&v135 + 1);
      v82 = *(double *)&v135;
    }
    else
    {
      v79 = *((double *)&v135 + 1);
      v80 = -*(double *)&v135;
      v81 = *((double *)&v134 + 1);
      v82 = -*(double *)&v134;
    }
    *(double *)&v130 = v78 * v80;
    *((double *)&v130 + 1) = v79 + 3.0 + 1.0;
    *(double *)&v131 = v78 * v82;
    *((double *)&v131 + 1) = v81 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v138, (double *)&v130);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v139, (double *)&v131);
    *(double *)&v130 = v114
                     * boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*v19 - (uint64_t)*v13, v19[1] - (uint64_t)v13[1], -(uint64_t)a2[1], *a2);
    *((_QWORD *)&v130 + 1) = 0x4010000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v138, (double *)&v130);
    *(double *)&v130 = v120
                     * boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(*v11 - (uint64_t)*v10, v11[1] - (uint64_t)v10[1], -(uint64_t)a2[1], *a2);
    *((_QWORD *)&v130 + 1) = 0x4010000000000000;
    boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v138, (double *)&v130);
    boost::polygon::detail::robust_fpt<double>::operator+=(v140.f64, (double *)&v139);
    boost::polygon::detail::robust_fpt<double>::operator+=(v141.f64, (double *)&v138);
    *(_QWORD *)&v130 = sqrt(v113 * (v112 * (v111 + v111)));
    *((double *)&v130 + 1) = (v72 + 1.0) * 0.5 + 1.0;
    if ((_DWORD)a5 == 2)
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=(v140.f64, (double *)&v130);
    else
      boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=(v140.f64, (double *)&v130);
    v83 = v133 + v133 + 1.0 + 1.0;
    v84 = v140.f64[1] + v83;
    v85 = v140.f64[0] / (v132 * v132);
    v140.f64[0] = v85;
    v140.f64[1] = v140.f64[1] + v83;
    v86 = v83 + v141.f64[1];
    v87 = v141.f64[0] / (v132 * v132);
    v141.f64[0] = v87;
    v141.f64[1] = v86;
    v130 = v136;
    v131 = v137;
    v128 = v134;
    v129 = v135;
    if (v61 >= 0.0)
    {
      v89 = v84;
      v84 = v86;
    }
    else
    {
      v88 = -v87;
      v87 = -v85;
      v85 = v88;
      v89 = v86;
    }
    *(double *)&v126 = v61 * v85;
    *((double *)&v126 + 1) = v89 + 3.0 + 1.0;
    *(double *)&v127 = v61 * v87;
    *((double *)&v127 + 1) = v84 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v130, (double *)&v126);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v131, (double *)&v127);
    if (v67 >= 0.0)
    {
      v90 = v140.f64[1];
      v91 = v140.f64[0];
      v92 = v141.f64[1];
      v93 = v141.f64[0];
    }
    else
    {
      v90 = v141.f64[1];
      v91 = -v141.f64[0];
      v92 = v140.f64[1];
      v93 = -v140.f64[0];
    }
    *(double *)&v126 = v67 * v91;
    *((double *)&v126 + 1) = v90 + 3.0 + 1.0;
    *(double *)&v127 = v67 * v93;
    *((double *)&v127 + 1) = v92 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v130, (double *)&v126);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v131, (double *)&v127);
    if (v73 >= 0.0)
    {
      v94 = v140.f64[1];
      v95 = v140.f64[0];
      v96 = v141.f64[1];
      v97 = v141.f64[0];
    }
    else
    {
      v94 = v141.f64[1];
      v95 = -v141.f64[0];
      v96 = v140.f64[1];
      v97 = -v140.f64[0];
    }
    *(double *)&v126 = v73 * v95;
    *((double *)&v126 + 1) = v94 + 3.0 + 1.0;
    *(double *)&v127 = v73 * v97;
    *((double *)&v127 + 1) = v96 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v128, (double *)&v126);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v129, (double *)&v127);
    if (v78 >= 0.0)
    {
      v98 = v140.f64[1];
      v99 = v140.f64[0];
      v100 = v141.f64[1];
      v101 = v141.f64[0];
    }
    else
    {
      v98 = v141.f64[1];
      v99 = -v141.f64[0];
      v100 = v140.f64[1];
      v101 = -v140.f64[0];
    }
    *(double *)&v126 = v78 * v99;
    *((double *)&v126 + 1) = v98 + 3.0 + 1.0;
    *(double *)&v127 = v78 * v101;
    *((double *)&v127 + 1) = v100 + 3.0 + 1.0;
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v128, (double *)&v126);
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v129, (double *)&v127);
    v102 = v140.f64[0];
    v103 = v141.f64[0];
    if (v140.f64[0] >= v141.f64[0])
    {
      v105 = v141.f64[0];
      v103 = v140.f64[0];
    }
    else
    {
      v104 = v140.f64[1];
      v140 = v141;
      v141.f64[0] = v102;
      v141.f64[1] = v104;
      v105 = v102;
    }
    v126 = v130;
    v127 = v131;
    if (v115 >= 0.0)
    {
      v122 = v115 * v103;
      v123 = v140.f64[1] + 1.0 + 1.0;
      v124 = v115 * v105;
      v125 = v141.f64[1] + 1.0 + 1.0;
      boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v126, &v122);
      v106 = &v124;
    }
    else
    {
      v122 = -(v105 * v115);
      v123 = v141.f64[1] + 1.0 + 1.0;
      v124 = -(v103 * v115);
      v125 = v140.f64[1] + 1.0 + 1.0;
      boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v126, &v124);
      v106 = &v122;
    }
    boost::polygon::detail::robust_fpt<double>::operator+=((double *)&v127, v106);
    boost::polygon::detail::robust_fpt<double>::operator-((double *)&v130, (double *)&v131);
    v48 = v107;
    boost::polygon::detail::robust_fpt<double>::operator-((double *)&v128, (double *)&v129);
    v50 = v108;
    v51 = (double *)&v127;
    boost::polygon::detail::robust_fpt<double>::operator-((double *)&v126, (double *)&v127);
    v53 = v109;
    v54 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v130, (double *)&v131);
    v55 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v128, (double *)&v129);
    v56 = (double *)&v126;
  }
  v110 = boost::polygon::detail::robust_fpt<double>::operator-(v56, v51);
  *(double *)a6 = v54;
  *(double *)(a6 + 8) = v55;
  *(double *)(a6 + 16) = v110;
  *(_BYTE *)(a6 + 24) = 1;
  if (v48 > 64.0 || v50 > 64.0 || v53 > 64.0)
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pss(a1, (uint64_t)a2, a3, a4, a5, a6, v48 > 64.0, v50 > 64.0, v53 > 64.0);
}

BOOL boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::circle_existence_predicate<boost::polygon::detail::site_event<int>>::sss(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  return (*a2 != *a3 || a2[1] != a3[1] || a2[2] != a3[2] || a2[3] != a3[3])
      && (*a3 != *a4 || a3[1] != a4[1] || a3[2] != a4[2] || a3[3] != a4[3]);
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::lazy_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sss(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8;
  int v9;
  double v10;
  double v11;
  int v12;
  int v13;
  double v14;
  double v15;
  int v16;
  int *v17;
  int v18;
  double v19;
  double v20;
  int v21;
  int v22;
  double v23;
  double v24;
  int v25;
  int *v26;
  int v27;
  double v28;
  double v29;
  int v30;
  int v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  int v43;
  int v44;
  int *v45;
  int *v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  uint64_t v51;
  int *v52;
  double v53;
  int v54;
  int v55;
  uint64_t v56;
  int *v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  uint64_t v62;
  int *v63;
  double v64;
  int v65;
  int v66;
  uint64_t v67;
  int *v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  int *v73;
  int *v74;
  double v75;
  double v76;
  double v77;
  double v78;
  double v79;
  double v80;
  double v81;
  double v82;
  double v83;
  double v84;
  double v85;
  double v86;
  double v87;
  double v88;
  double v89;
  double v90;
  double v91;
  int *v92;
  int *v93;
  double v94;
  double v95;
  double v96;
  double v97;
  double v98;
  double v99;
  double v101;
  double v102;
  double v103;
  double v104;
  int *v105;
  double v106;
  double v107;
  double v108;
  double v109[2];
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114[2];
  __int128 v115;
  __int128 v116;

  v8 = *(_DWORD *)(a2 + 8);
  v93 = (int *)(a2 + 8);
  if ((*(_QWORD *)(a2 + 32) & 0x20) != 0)
    v9 = *(_DWORD *)a2;
  else
    v9 = *(_DWORD *)(a2 + 8);
  v10 = (double)v9;
  if ((*(_QWORD *)(a2 + 32) & 0x20) == 0)
    v8 = *(_DWORD *)a2;
  v11 = (double)v8;
  v12 = *(_DWORD *)(a2 + 4);
  v92 = (int *)(a2 + 4);
  v105 = (int *)(a2 + 12);
  if ((*(_QWORD *)(a2 + 32) & 0x20) != 0)
    v13 = *(_DWORD *)(a2 + 4);
  else
    v13 = *(_DWORD *)(a2 + 12);
  if ((*(_QWORD *)(a2 + 32) & 0x20) != 0)
    v12 = *(_DWORD *)(a2 + 12);
  v14 = v10 - v11;
  v104 = v10 - v11;
  v15 = (double)v13 - (double)v12;
  v106 = v15;
  v97 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v8, v12, v9, v13);
  v17 = (int *)(a3 + 8);
  v16 = *(_DWORD *)(a3 + 8);
  if ((*(_QWORD *)(a3 + 32) & 0x20) != 0)
    v18 = *(_DWORD *)a3;
  else
    v18 = *(_DWORD *)(a3 + 8);
  v19 = (double)v18;
  if ((*(_QWORD *)(a3 + 32) & 0x20) == 0)
    v16 = *(_DWORD *)a3;
  v20 = (double)v16;
  v21 = *(_DWORD *)(a3 + 4);
  if ((*(_QWORD *)(a3 + 32) & 0x20) != 0)
    v22 = *(_DWORD *)(a3 + 4);
  else
    v22 = *(_DWORD *)(a3 + 12);
  if ((*(_QWORD *)(a3 + 32) & 0x20) != 0)
    v21 = *(_DWORD *)(a3 + 12);
  v23 = v19 - v20;
  v94 = v19 - v20;
  v24 = (double)v22 - (double)v21;
  v98 = v24;
  v96 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v16, v21, v18, v22);
  v26 = (int *)(a4 + 8);
  v25 = *(_DWORD *)(a4 + 8);
  if ((*(_QWORD *)(a4 + 32) & 0x20) != 0)
    v27 = *(_DWORD *)a4;
  else
    v27 = *(_DWORD *)(a4 + 8);
  v28 = (double)v27;
  if ((*(_QWORD *)(a4 + 32) & 0x20) == 0)
    v25 = *(_DWORD *)a4;
  v29 = (double)v25;
  v30 = *(_DWORD *)(a4 + 4);
  if ((*(_QWORD *)(a4 + 32) & 0x20) != 0)
    v31 = *(_DWORD *)(a4 + 4);
  else
    v31 = *(_DWORD *)(a4 + 12);
  if ((*(_QWORD *)(a4 + 32) & 0x20) != 0)
    v30 = *(_DWORD *)(a4 + 12);
  v32 = v28 - v29;
  v95 = v28 - v29;
  v33 = (double)v31 - (double)v30;
  v99 = v33;
  v103 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v25, v30, v27, v31);
  *(double *)&v115 = v14 * v14;
  *((_QWORD *)&v115 + 1) = 0x3FF0000000000000;
  *(double *)v114 = v15 * v15;
  *((_QWORD *)&v114[0] + 1) = 0x3FF0000000000000;
  v34 = boost::polygon::detail::robust_fpt<double>::operator+((double *)&v115, (double *)v114);
  v102 = v35 * 0.5 + 1.0;
  *(double *)&v115 = v23 * v23;
  *((_QWORD *)&v115 + 1) = 0x3FF0000000000000;
  *(double *)v114 = v24 * v24;
  *((_QWORD *)&v114[0] + 1) = 0x3FF0000000000000;
  v36 = sqrt(v34);
  v37 = boost::polygon::detail::robust_fpt<double>::operator+((double *)&v115, (double *)v114);
  *(double *)&v115 = v32 * v32;
  *((_QWORD *)&v115 + 1) = 0x3FF0000000000000;
  *(double *)v114 = v33 * v33;
  *((_QWORD *)&v114[0] + 1) = 0x3FF0000000000000;
  v39 = sqrt(v37);
  v101 = v38 * 0.5 + 1.0;
  v40 = sqrt(boost::polygon::detail::robust_fpt<double>::operator+((double *)&v115, (double *)v114));
  v42 = v41 * 0.5 + 1.0;
  v43 = *v93;
  if ((*(_QWORD *)(a2 + 32) & 0x20) != 0)
    v44 = *(_DWORD *)a2;
  else
    v44 = *v93;
  if ((*(_QWORD *)(a2 + 32) & 0x20) != 0)
  {
    v45 = v93;
  }
  else
  {
    v43 = *(_DWORD *)a2;
    v45 = (int *)a2;
  }
  v46 = v105;
  if ((*(_QWORD *)(a2 + 32) & 0x20) != 0)
    v46 = v92;
  v47 = v44 - (uint64_t)v43;
  v48 = *v46 - (uint64_t)v45[1];
  v49 = *v17;
  if ((*(_QWORD *)(a3 + 32) & 0x20) != 0)
    v50 = *(_DWORD *)a3;
  else
    v50 = *v17;
  if ((*(_QWORD *)(a3 + 32) & 0x20) != 0)
  {
    v51 = a3 + 8;
  }
  else
  {
    v49 = *(_DWORD *)a3;
    v51 = a3;
  }
  if ((*(_QWORD *)(a3 + 32) & 0x20) != 0)
    v52 = (int *)(a3 + 4);
  else
    v52 = (int *)(a3 + 12);
  v53 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v47, v48, v50 - (uint64_t)v49, *v52 - (uint64_t)*(int *)(v51 + 4));
  v54 = *v17;
  if ((*(_QWORD *)(a3 + 32) & 0x20) != 0)
    v55 = *(_DWORD *)a3;
  else
    v55 = *v17;
  if ((*(_QWORD *)(a3 + 32) & 0x20) != 0)
  {
    v56 = a3 + 8;
  }
  else
  {
    v54 = *(_DWORD *)a3;
    v56 = a3;
  }
  if ((*(_QWORD *)(a3 + 32) & 0x20) != 0)
    v57 = (int *)(a3 + 4);
  else
    v57 = (int *)(a3 + 12);
  v58 = v55 - (uint64_t)v54;
  v59 = *v57 - (uint64_t)*(int *)(v56 + 4);
  v60 = *v26;
  if ((*(_QWORD *)(a4 + 32) & 0x20) != 0)
    v61 = *(_DWORD *)a4;
  else
    v61 = *v26;
  if ((*(_QWORD *)(a4 + 32) & 0x20) != 0)
  {
    v62 = a4 + 8;
  }
  else
  {
    v60 = *(_DWORD *)a4;
    v62 = a4;
  }
  if ((*(_QWORD *)(a4 + 32) & 0x20) != 0)
    v63 = (int *)(a4 + 4);
  else
    v63 = (int *)(a4 + 12);
  v64 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v58, v59, v61 - (uint64_t)v60, *v63 - (uint64_t)*(int *)(v62 + 4));
  v65 = *v26;
  if ((*(_QWORD *)(a4 + 32) & 0x20) != 0)
    v66 = *(_DWORD *)a4;
  else
    v66 = *v26;
  if ((*(_QWORD *)(a4 + 32) & 0x20) != 0)
  {
    v67 = a4 + 8;
  }
  else
  {
    v65 = *(_DWORD *)a4;
    v67 = a4;
  }
  if ((*(_QWORD *)(a4 + 32) & 0x20) != 0)
    v68 = (int *)(a4 + 4);
  else
    v68 = (int *)(a4 + 12);
  v69 = v66 - (uint64_t)v65;
  v70 = *v68 - (uint64_t)*(int *)(v67 + 4);
  v71 = *v93;
  if ((*(_QWORD *)(a2 + 32) & 0x20) != 0)
    v72 = *(_DWORD *)a2;
  else
    v72 = *v93;
  if ((*(_QWORD *)(a2 + 32) & 0x20) != 0)
  {
    v73 = v93;
  }
  else
  {
    v71 = *(_DWORD *)a2;
    v73 = (int *)a2;
  }
  v74 = v105;
  if ((*(_QWORD *)(a2 + 32) & 0x20) != 0)
    v74 = v92;
  v75 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::robust_cross_product(v69, v70, v72 - (uint64_t)v71, *v74 - (uint64_t)v73[1]);
  v115 = 0u;
  v116 = 0u;
  *(double *)v114 = v40 * v53;
  *((double *)v114 + 1) = v42 + 1.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v115, (double *)v114);
  *(double *)v114 = v36 * v64;
  *((double *)v114 + 1) = v102 + 1.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v115, (double *)v114);
  *(double *)v114 = v39 * v75;
  *((double *)v114 + 1) = v101 + 1.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v115, (double *)v114);
  memset(v114, 0, sizeof(v114));
  *(double *)&v112 = v103 * v53;
  *((_QWORD *)&v112 + 1) = 0x4008000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)v114, (double *)&v112);
  *(double *)&v112 = v97 * v64;
  *((_QWORD *)&v112 + 1) = 0x4008000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)v114, (double *)&v112);
  *(double *)&v112 = v96 * v75;
  *((_QWORD *)&v112 + 1) = 0x4008000000000000;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)v114, (double *)&v112);
  v112 = 0u;
  v113 = 0u;
  *(double *)&v110 = v104 * v96 * v40;
  *((double *)&v110 + 1) = v42 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v112, (double *)&v110);
  *(double *)&v110 = v97 * v94 * v40;
  *((double *)&v110 + 1) = v42 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v112, (double *)&v110);
  *(double *)&v110 = v94 * v103 * v36;
  *((double *)&v110 + 1) = v102 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v112, (double *)&v110);
  *(double *)&v110 = v96 * v95 * v36;
  *((double *)&v110 + 1) = v102 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v112, (double *)&v110);
  *(double *)&v110 = v97 * v95 * v39;
  *((double *)&v110 + 1) = v101 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v112, (double *)&v110);
  *(double *)&v110 = v104 * v103 * v39;
  *((double *)&v110 + 1) = v101 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v112, (double *)&v110);
  v110 = 0u;
  v111 = 0u;
  v107 = v106 * v96 * v40;
  v108 = v42 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v110, &v107);
  v107 = v97 * v98 * v40;
  v108 = v42 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v110, &v107);
  v107 = v98 * v103 * v36;
  v108 = v102 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v110, &v107);
  v107 = v96 * v99 * v36;
  v108 = v102 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v110, &v107);
  v107 = v97 * v99 * v39;
  v108 = v101 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=((double *)&v110, &v107);
  v107 = v106 * v103 * v39;
  v108 = v101 + 2.0 + 1.0;
  boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=((double *)&v110, &v107);
  v107 = boost::polygon::detail::operator+<boost::polygon::detail::robust_fpt<double>>(&v112, v114);
  v108 = v76;
  v109[0] = v77;
  v109[1] = v78;
  v79 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v115, (double *)&v116);
  v81 = v80;
  v82 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v112, (double *)&v113);
  v84 = v81 + v83 + 1.0;
  v85 = v82 / v79;
  v86 = boost::polygon::detail::robust_fpt<double>::operator-((double *)&v110, (double *)&v111);
  v88 = v81 + v87 + 1.0;
  v89 = v86 / v79;
  v91 = boost::polygon::detail::robust_fpt<double>::operator-(&v107, v109) / v79;
  *(double *)a5 = v85;
  *(double *)(a5 + 8) = v89;
  *(double *)(a5 + 16) = v91;
  *(_BYTE *)(a5 + 24) = 1;
  if (v84 > 64.0 || v88 > 64.0 || v81 + v90 + 1.0 > 64.0)
    boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sss();
}

double *boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator+=(double *a1, double *a2)
{
  if (*a2 >= 0.0)
    boost::polygon::detail::robust_fpt<double>::operator+=(a1, a2);
  else
    boost::polygon::detail::robust_fpt<double>::operator-=(a1 + 2, a2);
  return a1;
}

double *boost::polygon::detail::robust_dif<boost::polygon::detail::robust_fpt<double>>::operator-=(double *a1, double *a2)
{
  if (*a2 >= 0.0)
    boost::polygon::detail::robust_fpt<double>::operator+=(a1 + 2, a2);
  else
    boost::polygon::detail::robust_fpt<double>::operator-=(a1, a2);
  return a1;
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::ppp()
{
  int *v0;
  int *v1;
  int *v2;
  int v3;
  int v4;
  int v5;
  int v6;
  char v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  double v37;
  double v38;
  long double v39;
  int v40;
  double v41;
  double v42;
  double v43;
  long double v44;
  int v45;
  double v46;
  double v47;
  long double v48;
  int v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  long double v55;
  int v56;
  double v57;
  double v58;
  double v59;
  long double v60;
  int v61;
  double v62;
  double v63;
  double v64;
  long double v65;
  int v66;
  _DWORD v67[65];
  _DWORD v68[65];
  _DWORD v69[65];
  _DWORD v70[65];
  _DWORD v71[65];
  _DWORD v72[65];
  _DWORD v73[65];
  _DWORD v74[65];
  unsigned int v75[65];
  unsigned int v76[65];
  int v77[65];
  unsigned int v78[65];
  unsigned int __src[65];
  unsigned int __dst[65];
  _QWORD v81[32];
  int v82;
  _QWORD v83[32];
  int v84;
  uint64_t v85[32];
  int v86;
  uint64_t v87[32];
  int v88;
  unsigned int v89[64];
  int v90;
  _QWORD v91[32];
  int v92;
  unsigned int v93[64];
  int v94;
  _QWORD v95[32];
  int v96;
  _QWORD v97[32];
  int v98;
  _QWORD v99[32];
  int v100;
  uint64_t v101;

  MEMORY[0x24BDAC7A8]();
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v101 = *MEMORY[0x24BDAC8D0];
  v11 = *v0;
  v12 = *v1;
  v13 = v11 - v12;
  if (v11 > v12)
  {
    v14 = 1;
LABEL_3:
    v95[0] = v13;
    goto LABEL_6;
  }
  if (v13 < 0)
  {
    v13 = v12 - v11;
    v14 = -1;
    goto LABEL_3;
  }
  v14 = 0;
LABEL_6:
  v96 = v14;
  v15 = *v2;
  v16 = v12 - v15;
  if (v12 > v15)
  {
    v17 = 1;
LABEL_8:
    v97[0] = v16;
    goto LABEL_11;
  }
  if (v16 < 0)
  {
    v16 = v15 - v12;
    v17 = -1;
    goto LABEL_8;
  }
  v17 = 0;
LABEL_11:
  v98 = v17;
  v18 = v11 - v15;
  if (v11 > v15)
  {
    v19 = 1;
LABEL_13:
    v99[0] = v18;
    goto LABEL_16;
  }
  if (v18 < 0)
  {
    v18 = v15 - v11;
    v19 = -1;
    goto LABEL_13;
  }
  v19 = 0;
LABEL_16:
  v100 = v19;
  v20 = v0[1];
  v21 = v1[1];
  v22 = v20 - v21;
  if (v20 > v21)
  {
    v23 = 1;
LABEL_18:
    *(_QWORD *)v89 = v22;
    goto LABEL_21;
  }
  if (v22 < 0)
  {
    v22 = v21 - v20;
    v23 = -1;
    goto LABEL_18;
  }
  v23 = 0;
LABEL_21:
  v90 = v23;
  v24 = v2[1];
  v25 = v21 - v24;
  if (v21 > v24)
  {
    v26 = 1;
LABEL_23:
    v91[0] = v25;
    goto LABEL_26;
  }
  if (v25 < 0)
  {
    v25 = v24 - v21;
    v26 = -1;
    goto LABEL_23;
  }
  v26 = 0;
LABEL_26:
  v92 = v26;
  v27 = v20 - v24;
  if (v20 > v24)
  {
    v28 = 1;
LABEL_28:
    *(_QWORD *)v93 = v27;
    goto LABEL_31;
  }
  if (v27 < 0)
  {
    v27 = v24 - v20;
    v28 = -1;
    goto LABEL_28;
  }
  v28 = 0;
LABEL_31:
  v94 = v28;
  v29 = v12 + v11;
  if (v29 < 1)
  {
    if (v29 < 0)
    {
      v85[0] = -v29;
      if ((unint64_t)-v29 >> 32)
        v30 = -2;
      else
        v30 = -1;
    }
    else
    {
      v30 = 0;
    }
  }
  else
  {
    v85[0] = v29;
    v30 = 1;
  }
  v86 = v30;
  v31 = v15 + v12;
  if (v31 < 1)
  {
    if (v31 < 0)
    {
      v87[0] = -v31;
      if ((unint64_t)-v31 >> 32)
        v32 = -2;
      else
        v32 = -1;
    }
    else
    {
      v32 = 0;
    }
  }
  else
  {
    v87[0] = v31;
    v32 = 1;
  }
  v88 = v32;
  v33 = v21 + v20;
  if (v21 + v20 < 1)
  {
    if (v33 < 0)
    {
      v81[0] = -v33;
      if ((unint64_t)-v33 >> 32)
        v34 = -2;
      else
        v34 = -1;
    }
    else
    {
      v34 = 0;
    }
  }
  else
  {
    v81[0] = v21 + v20;
    v34 = 1;
  }
  v82 = v34;
  v35 = v24 + v21;
  if (v24 + v21 < 1)
  {
    if (v35 < 0)
    {
      v83[0] = -v35;
      if ((unint64_t)-v35 >> 32)
        v36 = -2;
      else
        v36 = -1;
    }
    else
    {
      v36 = 0;
    }
  }
  else
  {
    v83[0] = v24 + v21;
    v36 = 1;
  }
  v84 = v36;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, (unsigned int *)v95, (uint64_t)v91);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v78, (unsigned int *)v97, (uint64_t)v89);
  boost::polygon::detail::extended_int<64ul>::dif (__dst, __src, (int *)v78);
  boost::polygon::detail::extended_int<64ul>::p(__dst, v37, v38);
  v41 = 0.5 / ldexp(v39, v40);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, (unsigned int *)v95, (uint64_t)v85);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v78, v89, (uint64_t)v81);
  boost::polygon::detail::extended_int<64ul>::add(__dst, __src, v78);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v78, (unsigned int *)v97, (uint64_t)v87);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v77, (unsigned int *)v91, (uint64_t)v83);
  boost::polygon::detail::extended_int<64ul>::add(__src, v78, v77);
  if ((v8 & 1) != 0 || v4)
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v77, __dst, (uint64_t)v91);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v76, __src, (uint64_t)v89);
    boost::polygon::detail::extended_int<64ul>::dif (v78, v77, (int *)v76);
    boost::polygon::detail::extended_int<64ul>::p(v78, v42, v43);
    *(long double *)v10 = v41 * ldexp(v44, v45);
    if (v4)
    {
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v74, (unsigned int *)v95, (uint64_t)v95);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v73, v89, (uint64_t)v89);
      boost::polygon::detail::extended_int<64ul>::add(v75, v74, v73);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v71, (unsigned int *)v97, (uint64_t)v97);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v70, (unsigned int *)v91, (uint64_t)v91);
      boost::polygon::detail::extended_int<64ul>::add(v72, v71, v70);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v76, v75, (uint64_t)v72);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v68, (unsigned int *)v99, (uint64_t)v99);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v67, v93, (uint64_t)v93);
      boost::polygon::detail::extended_int<64ul>::add(v69, v68, v67);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v77, v76, (uint64_t)v69);
      boost::polygon::detail::extended_int<64ul>::p(v77, v46, v47);
      v50 = ldexp(v48, v49);
      v51 = *(double *)v10;
      v52 = sqrt(v50);
      if (*(double *)v10 >= 0.0)
      {
        if (v41 >= 0.0)
          v62 = v51 + v52 * v41;
        else
          v62 = v51 - v52 * v41;
      }
      else
      {
        boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v75, v78, (uint64_t)v78);
        boost::polygon::detail::extended_int<64ul>::dif (v76, v75, v77);
        boost::polygon::detail::extended_int<64ul>::p(v76, v53, v54);
        v57 = ldexp(v55, v56);
        v58 = v41 * v57;
        boost::polygon::detail::extended_int<64ul>::p(v78, v57, v59);
        v62 = v58 / (v52 + ldexp(v60, v61));
      }
      *(double *)(v10 + 16) = v62;
    }
  }
  if (v6)
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v77, __src, (uint64_t)v95);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v76, __dst, (uint64_t)v97);
    boost::polygon::detail::extended_int<64ul>::dif (v78, v77, (int *)v76);
    boost::polygon::detail::extended_int<64ul>::p(v78, v63, v64);
    *(long double *)(v10 + 8) = v41 * ldexp(v65, v66);
  }
}

double *boost::polygon::detail::robust_fpt<double>::operator+=(double *result, double *a2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  BOOL v7;

  v2 = *result;
  v3 = *a2;
  v4 = *result + *a2;
  if ((*result < 0.0 || v3 < 0.0) && (v2 > 0.0 || v3 > 0.0))
  {
    v5 = (v2 * result[1] - v3 * a2[1]) / v4;
    v6 = -v5;
    v7 = v5 < 0.0;
  }
  else
  {
    v5 = result[1];
    v6 = a2[1];
    v7 = v5 < v6;
  }
  if (v7)
    v5 = v6;
  *result = v4;
  result[1] = v5 + 1.0;
  return result;
}

double *boost::polygon::detail::robust_fpt<double>::operator-=(double *result, double *a2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  BOOL v7;

  v2 = *result;
  v3 = *a2;
  v4 = *result - *a2;
  if ((*result < 0.0 || v3 > 0.0) && (v2 > 0.0 || v3 < 0.0))
  {
    v5 = (v3 * a2[1] + v2 * result[1]) / v4;
    v6 = -v5;
    v7 = v5 < 0.0;
  }
  else
  {
    v5 = result[1];
    v6 = a2[1];
    v7 = v5 < v6;
  }
  if (v7)
    v5 = v6;
  *result = v4;
  result[1] = v5 + 1.0;
  return result;
}

double boost::polygon::detail::robust_fpt<double>::operator-(double *a1, double *a2)
{
  return *a1 - *a2;
}

double boost::polygon::detail::extended_int<64ul>::p(_DWORD *a1, double result, double a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v4 = a1[64];
  if (v4 >= 0)
    v5 = v4;
  else
    v5 = -v4;
  if ((_DWORD)v5)
  {
    if (v5 == 1)
    {
      LODWORD(result) = *a1;
      result = (double)*(unint64_t *)&result;
    }
    else if (v5 == 2)
    {
      LODWORD(a3) = *a1;
      LODWORD(result) = a1[1];
      result = (double)*(unint64_t *)&a3 + (double)*(unint64_t *)&result * 4294967300.0;
    }
    else
    {
      v6 = 0;
      v7 = (uint64_t)&a1[v5 - 1];
      result = 0.0;
      do
      {
        HIDWORD(v8) = 1106247680;
        LODWORD(v8) = *(_DWORD *)(v7 + v6);
        result = result * 4294967300.0 + (double)v8;
        v6 -= 4;
      }
      while (v6 != -12);
    }
    if (v4 < 0)
      return -result;
  }
  return result;
}

uint64_t boost::polygon::detail::extended_int<64ul>::mul(uint64_t result, unsigned int *a2, uint64_t a3)
{
  uint64_t v3;
  int v4;
  int v6;
  uint64_t v8;
  unint64_t v9;

  v3 = result;
  v4 = a2[64];
  if (v4 && (v6 = *(_DWORD *)(a3 + 256)) != 0)
  {
    if (v4 >= 0)
      v8 = v4;
    else
      v8 = -v4;
    if (v6 >= 0)
      v9 = v6;
    else
      v9 = -v6;
    result = boost::polygon::detail::extended_int<64ul>::mul(result, a2, v8, a3, v9);
    if ((int)a2[64] > 0 != *(_DWORD *)(a3 + 256) > 0)
      *(_DWORD *)(v3 + 256) = -*(_DWORD *)(v3 + 256);
  }
  else
  {
    *(_DWORD *)(result + 256) = 0;
  }
  return result;
}

uint64_t boost::polygon::detail::extended_int<64ul>::mul(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int *v12;
  unint64_t v13;
  unint64_t v14;

  v5 = a3 - 1 + a5;
  if (v5 >= 0x40)
    v5 = 64;
  *(_DWORD *)(result + 256) = v5;
  if (v5)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      if (v6 >= a3 - 1)
        v8 = a3 - 1;
      else
        v8 = v6;
      if (a3)
      {
        v9 = 0;
        v10 = 0;
        v11 = ~v8;
        v12 = a2;
        do
        {
          if (v6 + v9 < a5)
          {
            v13 = *(unsigned int *)(a4 + 4 * v9) * (unint64_t)*v12;
            v7 += v13;
            v10 += HIDWORD(v13);
          }
          --v9;
          ++v12;
        }
        while (v11 != v9);
      }
      else
      {
        v10 = 0;
      }
      *(_DWORD *)(result + 4 * v6) = v7;
      v7 = v10 + HIDWORD(v7);
      ++v6;
      v14 = *(int *)(result + 256);
      a4 += 4;
    }
    while (v6 < v14);
    if (v7)
    {
      if ((_DWORD)v14 != 64)
      {
        *(_DWORD *)(result + 4 * v14) = v7;
        ++*(_DWORD *)(result + 256);
      }
    }
  }
  return result;
}

void *boost::polygon::detail::extended_int<64ul>::dif (_DWORD *__dst, _DWORD *__src, int *a3)
{
  int v5;
  int v7;
  unint64_t v8;
  unint64_t v9;
  void *result;

  v5 = __src[64];
  if (!v5)
  {
    result = memcpy(__dst, a3, 0x104uLL);
LABEL_15:
    __dst[64] = -__dst[64];
    return result;
  }
  v7 = a3[64];
  if (!v7)
    return memcpy(__dst, __src, 0x104uLL);
  if (v5 >= 0)
    v8 = v5;
  else
    v8 = -v5;
  if (v7 >= 0)
    v9 = v7;
  else
    v9 = -v7;
  if (v5 > 0 == v7 > 0)
    result = (void *)boost::polygon::detail::extended_int<64ul>::dif ((uint64_t)__dst, (uint64_t)__src, v8, (uint64_t)a3, v9, 0);
  else
    result = boost::polygon::detail::extended_int<64ul>::add(__dst, __src, v8, (unsigned int *)a3, v9);
  if ((__src[64] & 0x80000000) != 0)
    goto LABEL_15;
  return result;
}

_DWORD *boost::polygon::detail::extended_int<64ul>::add(_DWORD *result, unsigned int *a2, unint64_t a3, unsigned int *a4, unint64_t a5)
{
  unint64_t v5;
  unsigned int *v6;
  unint64_t v7;
  unsigned int *v8;
  _DWORD *v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  unint64_t v15;
  _DWORD *v16;
  unsigned int *v17;
  unsigned int v18;
  unint64_t v19;
  uint64_t v20;

  do
  {
    v5 = a5;
    v6 = a4;
    a5 = a3;
    a4 = a2;
    a2 = v6;
    a3 = v5;
  }
  while (a5 < v5);
  result[64] = a5;
  v7 = 0;
  if (v5)
  {
    v8 = a4;
    v9 = result;
    v10 = v5;
    do
    {
      v12 = *v8++;
      v11 = v12;
      v13 = *v6++;
      v14 = v7 + v11 + v13;
      *v9++ = v14;
      v7 = HIDWORD(v14);
      --v10;
    }
    while (v10);
  }
  v15 = a5 - v5;
  if (a5 > v5)
  {
    v16 = &result[v5];
    v17 = &a4[v5];
    do
    {
      v18 = *v17++;
      v19 = v7 + v18;
      *v16++ = v19;
      v7 = HIDWORD(v19);
      --v15;
    }
    while (v15);
  }
  if (v7)
  {
    v20 = (int)result[64];
    if ((_DWORD)v20 != 64)
    {
      result[v20] = 1;
      ++result[64];
    }
  }
  return result;
}

uint64_t boost::polygon::detail::extended_int<64ul>::dif (uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, char a6)
{
  unint64_t v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  _DWORD *v14;
  char v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  BOOL v19;
  unint64_t v20;
  _DWORD *v21;
  int *v22;
  int v23;
  uint64_t v24;

  v6 = a3;
  v8 = result;
  if (a3 >= a5)
  {
    if (a3 != a5 || (a6 & 1) != 0)
    {
      v14 = (_DWORD *)(result + 256);
      *(_DWORD *)(result + 256) = a3 - 1;
      if (a5)
      {
LABEL_15:
        v16 = 0;
        v15 = 0;
        do
        {
          *(_DWORD *)(result + 4 * v16) = *(_DWORD *)(a2 + 4 * v16) - (v15 & 1) - *(_DWORD *)(a4 + 4 * v16);
          v17 = *(_DWORD *)(a2 + 4 * v16);
          v18 = *(_DWORD *)(a4 + 4 * v16);
          v15 &= v17 == v18;
          if (v17 < v18)
            v15 = 1;
          ++v16;
        }
        while (a5 != v16);
      }
      else
      {
        v15 = 0;
      }
      v19 = v6 > a5;
      v20 = v6 - a5;
      if (v19)
      {
        v21 = (_DWORD *)(result + 4 * a5);
        v22 = (int *)(a2 + 4 * a5);
        do
        {
          *v21++ = *v22 - (v15 & 1);
          v23 = *v22++;
          v15 &= v23 == 0;
          --v20;
        }
        while (v20);
      }
      v24 = *(int *)(result + 256);
      if (*(_DWORD *)(result + 4 * v24))
        *v14 = v24 + 1;
    }
    else
    {
      while (1)
      {
        v11 = v6 - 1;
        v12 = *(_DWORD *)(a2 - 4 + 4 * v6);
        v13 = *(_DWORD *)(a4 - 4 + 4 * v6);
        if (v12 < v13)
        {
          v9 = a4;
          v10 = v6;
          goto LABEL_3;
        }
        if (v12 > v13)
          break;
        --v6;
        if (!v11)
          goto LABEL_25;
      }
      if (v6)
      {
        v14 = (_DWORD *)(result + 256);
        *(_DWORD *)(result + 256) = v6 - 1;
        a5 = v6;
        goto LABEL_15;
      }
LABEL_25:
      *(_DWORD *)(result + 256) = 0;
    }
  }
  else
  {
    v9 = a4;
    v10 = a5;
LABEL_3:
    result = boost::polygon::detail::extended_int<64ul>::dif (result, v9, v10, a2, v6, 1);
    *(_DWORD *)(v8 + 256) = -*(_DWORD *)(v8 + 256);
  }
  return result;
}

void *boost::polygon::detail::extended_int<64ul>::add(_DWORD *__dst, _DWORD *__src, _DWORD *a3)
{
  int v5;
  _DWORD *v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  void *result;

  v5 = __src[64];
  if (!v5)
  {
    __src = a3;
    return memcpy(__dst, __src, 0x104uLL);
  }
  v6 = __src;
  v7 = a3[64];
  if (!v7)
    return memcpy(__dst, __src, 0x104uLL);
  if (v5 >= 0)
    v8 = v5;
  else
    v8 = -v5;
  if (v7 >= 0)
    v9 = v7;
  else
    v9 = -v7;
  if (v5 > 0 == v7 > 0)
    result = boost::polygon::detail::extended_int<64ul>::add(__dst, __src, v8, a3, v9);
  else
    result = (void *)boost::polygon::detail::extended_int<64ul>::dif ((uint64_t)__dst, (uint64_t)__src, v8, (uint64_t)a3, v9, 0);
  if ((v6[64] & 0x80000000) != 0)
    __dst[64] = -__dst[64];
  return result;
}

double boost::polygon::detail::robust_fpt<double>::operator+(double *a1, double *a2)
{
  return *a1 + *a2;
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pps(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  int *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  double *v15;
  double *v16;
  int v17;
  int v18;
  int *v19;
  int *v20;
  int *v21;
  int *v22;
  int *v23;
  int *v24;
  int *v25;
  uint64_t v26;
  int *v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  double v65;
  double v66;
  long double v67;
  int v68;
  long double v69;
  double v70;
  int v71;
  double v72;
  double v73;
  uint64_t v74;
  int v75;
  int v76;
  double v77;
  double v78;
  uint64_t v79;
  int v80;
  int v81;
  double v82;
  double v83;
  uint64_t v84;
  int v85;
  double v86;
  double v87;
  double v88;
  double v89;
  long double v90;
  int v91;
  double v92;
  double v93;
  long double v94;
  int v95;
  long double v96;
  long double v97;
  int v98;
  long double v99;
  uint64_t v100;
  int v101;
  double v102;
  double v103;
  long double v104;
  int v105;
  unsigned int *v106;
  unsigned int v107[65];
  unsigned int v108[65];
  unsigned int v109[65];
  unsigned int v110[65];
  unsigned int v111[65];
  _DWORD v112[65];
  _DWORD v113[65];
  _QWORD v114[32];
  int v115;
  _QWORD v116[32];
  int v117;
  unsigned int v118[65];
  _OWORD __dst[16];
  int v120;
  _QWORD v121[32];
  int v122;
  unsigned int v123[64];
  int v124;
  _OWORD v125[16];
  int v126;
  _OWORD v127[16];
  int v128;
  _DWORD __src[65];
  _QWORD v130[32];
  int v131;
  unsigned int v132[64];
  int v133;
  unsigned int v134[65];
  _BYTE v135[260];
  unsigned int v136[65];
  unsigned int v137[65];
  int v138[64];
  int v139;
  _BYTE v140[260];
  unsigned int v141[64];
  int v142;
  _BYTE v143[260];
  unsigned int v144[65];
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  int v161;
  uint64_t v162;

  v9 = MEMORY[0x24BDAC7A8]();
  v12 = v11;
  v14 = v13;
  v16 = v15;
  v18 = v17;
  v19 = v10;
  v21 = v20;
  v23 = v22;
  v106 = (unsigned int *)v9;
  v162 = *MEMORY[0x24BDAC8D0];
  v24 = v10 + 2;
  if ((*((_QWORD *)v10 + 4) & 0x20) != 0)
    v25 = v10;
  else
    v25 = v10 + 2;
  v26 = v25[1];
  if ((*((_QWORD *)v10 + 4) & 0x20) != 0)
    v27 = v10 + 2;
  else
    v27 = v10;
  v28 = v27[1];
  v29 = v26 <= v28;
  v30 = v26 - v28;
  if (!v29)
  {
    v31 = 1;
LABEL_9:
    *(_QWORD *)v132 = v30;
    goto LABEL_12;
  }
  if (v30 < 0)
  {
    v30 = -v30;
    v31 = -1;
    goto LABEL_9;
  }
  v31 = 0;
LABEL_12:
  v133 = v31;
  v32 = *v27;
  v33 = *v25;
  v34 = __OFSUB__(v32, v33);
  v35 = v32 - v33;
  if (!((v35 < 0) ^ v34 | (v35 == 0)))
  {
    v36 = 1;
LABEL_14:
    v130[0] = v35;
    goto LABEL_17;
  }
  if (v35 < 0)
  {
    v35 = -v35;
    v36 = -1;
    goto LABEL_14;
  }
  v36 = 0;
LABEL_17:
  v131 = v36;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v141, v132, (uint64_t)v132);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v130, (uint64_t)v130);
  boost::polygon::detail::extended_int<64ul>::add(__src, v141, v136);
  v37 = v21[1];
  v38 = v23[1];
  v39 = v37 - v38;
  if (v37 > v38)
  {
    v40 = 1;
LABEL_19:
    *(_QWORD *)&v127[0] = v39;
    goto LABEL_22;
  }
  if (v39 < 0)
  {
    v39 = v38 - v37;
    v40 = -1;
    goto LABEL_19;
  }
  v40 = 0;
LABEL_22:
  v128 = v40;
  v41 = *v23;
  v42 = *v21;
  v43 = v41 - v42;
  if (v41 > v42)
  {
    v44 = 1;
LABEL_24:
    *(_QWORD *)&v125[0] = v43;
    goto LABEL_27;
  }
  if (v43 < 0)
  {
    v43 = v42 - v41;
    v44 = -1;
    goto LABEL_24;
  }
  v44 = 0;
LABEL_27:
  v126 = v44;
  v45 = v42 + v41;
  if (v45 < 1)
  {
    if (v45 < 0)
    {
      *(_QWORD *)v123 = -v45;
      if ((unint64_t)-v45 >> 32)
        v46 = -2;
      else
        v46 = -1;
    }
    else
    {
      v46 = 0;
    }
  }
  else
  {
    *(_QWORD *)v123 = v45;
    v46 = 1;
  }
  v124 = v46;
  v47 = v38 + v37;
  if (v47 < 1)
  {
    if (v47 < 0)
    {
      v121[0] = -v47;
      if ((unint64_t)-v47 >> 32)
        v48 = -2;
      else
        v48 = -1;
    }
    else
    {
      v48 = 0;
    }
  }
  else
  {
    v121[0] = v47;
    v48 = 1;
  }
  v122 = v48;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v141, v132, (uint64_t)v127);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v130, (uint64_t)v125);
  boost::polygon::detail::extended_int<64ul>::add(__dst, v141, v136);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v141, (unsigned int *)v127, (uint64_t)v130);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v125, (uint64_t)v132);
  boost::polygon::detail::extended_int<64ul>::dif (v118, v141, (int *)v136);
  v49 = v19[3];
  v50 = v23[1];
  v29 = v49 <= v50;
  v51 = v49 - v50;
  if (!v29)
  {
    v52 = 1;
LABEL_47:
    v116[0] = v51;
    goto LABEL_50;
  }
  if (v51 < 0)
  {
    v51 = -v51;
    v52 = -1;
    goto LABEL_47;
  }
  v52 = 0;
LABEL_50:
  v117 = v52;
  v53 = *v23;
  v54 = *v24;
  v29 = v53 <= v54;
  v55 = v53 - v54;
  if (!v29)
  {
    v56 = 1;
LABEL_52:
    v114[0] = v55;
    goto LABEL_55;
  }
  if (v55 < 0)
  {
    v55 = -v55;
    v56 = -1;
    goto LABEL_52;
  }
  v56 = 0;
LABEL_55:
  v115 = v56;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v141, v132, (uint64_t)v114);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v130, (uint64_t)v116);
  boost::polygon::detail::extended_int<64ul>::dif (v113, v141, (int *)v136);
  v57 = v19[3];
  v58 = v21[1];
  v29 = v57 <= v58;
  v59 = v57 - v58;
  if (!v29)
  {
    v60 = 1;
LABEL_57:
    v116[0] = v59;
    goto LABEL_60;
  }
  if (v59 < 0)
  {
    v59 = -v59;
    v60 = -1;
    goto LABEL_57;
  }
  v60 = 0;
LABEL_60:
  v117 = v60;
  v61 = *v21;
  v62 = *v24;
  v29 = v61 <= v62;
  v63 = v61 - v62;
  if (!v29)
  {
    v64 = 1;
LABEL_62:
    v114[0] = v63;
    goto LABEL_65;
  }
  if (v63 < 0)
  {
    v63 = -v63;
    v64 = -1;
    goto LABEL_62;
  }
  v64 = 0;
LABEL_65:
  v115 = v64;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v141, v132, (uint64_t)v114);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v130, (uint64_t)v116);
  boost::polygon::detail::extended_int<64ul>::dif (v112, v141, (int *)v136);
  boost::polygon::detail::extended_int<64ul>::add(v111, v113, v112);
  if (!v118[64])
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v141, (unsigned int *)__dst, (uint64_t)__dst);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, v111, (uint64_t)v111);
    boost::polygon::detail::extended_int<64ul>::dif (v135, v141, (int *)v136);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v110, (unsigned int *)__dst, (uint64_t)v111);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v134, v110, (uint64_t)v123);
    v141[0] = 2;
    v142 = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, v134, (uint64_t)v141);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, (unsigned int *)v135, (uint64_t)v127);
    boost::polygon::detail::extended_int<64ul>::add(v141, v136, v109);
    memcpy(v136, __src, sizeof(v136));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v108, v110, (uint64_t)v111);
    v134[0] = 2;
    v134[64] = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, v108, (uint64_t)v134);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v107, (unsigned int *)v135, (uint64_t)__dst);
    boost::polygon::detail::extended_int<64ul>::add(v134, v109, v107);
    memcpy(v143, v134, sizeof(v143));
    v137[0] = 1;
    v137[64] = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v108, v110, (uint64_t)v121);
    v134[0] = 2;
    v134[64] = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, v108, (uint64_t)v134);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v107, (unsigned int *)v135, (uint64_t)v125);
    boost::polygon::detail::extended_int<64ul>::add(v134, v109, v107);
    memcpy(v144, v134, sizeof(v144));
    boost::polygon::detail::extended_int<64ul>::p(v110, v88, v89);
    v92 = ldexp(v90, v91);
    v93 = 1.0;
    v70 = 1.0 / v92;
    if (v14)
    {
      boost::polygon::detail::extended_int<64ul>::p(v141, v92, 1.0);
      v96 = ldexp(v94, v95);
      v93 = 0.25;
      v92 = v70 * (v96 * 0.25);
      *v16 = v92;
      if (!v12)
      {
LABEL_84:
        if (!a9)
          return;
LABEL_88:
        v100 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v106, v141, v136, v92, v93);
        v86 = ldexp(*(long double *)&v100, v101);
        v87 = 0.25;
LABEL_89:
        v102 = v86 * v87;
        v103 = v70 * v102;
        boost::polygon::detail::extended_int<64ul>::p(__src, v102, v87);
        v16[2] = v103 / sqrt(ldexp(v104, v105));
        return;
      }
    }
    else if (!v12)
    {
      goto LABEL_84;
    }
    boost::polygon::detail::extended_int<64ul>::p(v144, v92, v93);
    v99 = ldexp(v97, v98);
    v93 = 0.25;
    v92 = v70 * (v99 * 0.25);
    v16[1] = v92;
    if (!a9)
      return;
    goto LABEL_88;
  }
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, (unsigned int *)__dst, (uint64_t)__dst);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v108, v118, (uint64_t)v118);
  boost::polygon::detail::extended_int<64ul>::add(v110, v109, v108);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v135, v110, (uint64_t)v113);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v135, (uint64_t)v112);
  v141[0] = 4;
  v142 = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v134, v136, (uint64_t)v141);
  boost::polygon::detail::extended_int<64ul>::p(v118, v65, v66);
  v69 = ldexp(v67, v68);
  v70 = 1.0 / v69 * (1.0 / v69);
  if ((v14 & 1) != 0 || a9)
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v135, v123, (uint64_t)v118);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v136, (unsigned int *)v135, (uint64_t)v118);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, (unsigned int *)__dst, (uint64_t)v111);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v110, v109, (uint64_t)v127);
    boost::polygon::detail::extended_int<64ul>::add(v141, v136, v110);
    v136[0] = 1;
    v136[64] = 1;
    *(_OWORD *)&v135[192] = v127[12];
    *(_OWORD *)&v135[208] = v127[13];
    *(_OWORD *)&v135[224] = v127[14];
    *(_OWORD *)&v135[240] = v127[15];
    *(_OWORD *)&v135[128] = v127[8];
    *(_OWORD *)&v135[144] = v127[9];
    *(_OWORD *)&v135[160] = v127[10];
    *(_OWORD *)&v135[176] = v127[11];
    *(_OWORD *)&v135[64] = v127[4];
    *(_OWORD *)&v135[80] = v127[5];
    *(_OWORD *)&v135[96] = v127[6];
    *(_OWORD *)&v135[112] = v127[7];
    *(_OWORD *)v135 = v127[0];
    *(_OWORD *)&v135[16] = v127[1];
    *(_OWORD *)&v135[32] = v127[2];
    *(_OWORD *)&v135[48] = v127[3];
    v71 = v128;
    if (v18 == 2)
      v71 = -v128;
    *(_OWORD *)&v143[192] = *(_OWORD *)&v135[192];
    *(_OWORD *)&v143[208] = *(_OWORD *)&v135[208];
    *(_OWORD *)&v143[224] = *(_OWORD *)&v135[224];
    *(_OWORD *)&v143[240] = *(_OWORD *)&v135[240];
    *(_OWORD *)&v143[128] = *(_OWORD *)&v135[128];
    *(_OWORD *)&v143[144] = *(_OWORD *)&v135[144];
    *(_OWORD *)&v143[160] = *(_OWORD *)&v135[160];
    *(_OWORD *)&v143[176] = *(_OWORD *)&v135[176];
    *(_OWORD *)&v143[64] = *(_OWORD *)&v135[64];
    *(_OWORD *)&v143[80] = *(_OWORD *)&v135[80];
    *(_OWORD *)&v143[96] = *(_OWORD *)&v135[96];
    *(_OWORD *)&v143[112] = *(_OWORD *)&v135[112];
    *(_OWORD *)v143 = *(_OWORD *)v135;
    *(_OWORD *)&v143[16] = *(_OWORD *)&v135[16];
    *(_OWORD *)&v143[32] = *(_OWORD *)&v135[32];
    *(_OWORD *)&v143[48] = *(_OWORD *)&v135[48];
    *(_DWORD *)&v143[256] = v71;
    memcpy(v137, v134, sizeof(v137));
    if (v14)
    {
      v74 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v106, v141, v136, v72, v73);
      *v16 = v70 * (ldexp(*(long double *)&v74, v75) * 0.5);
    }
  }
  if ((v12 & 1) != 0 || a9)
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, (unsigned int *)v121, (uint64_t)v118);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v110, v109, (uint64_t)v118);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v107, (unsigned int *)__dst, (uint64_t)v111);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v108, v107, (uint64_t)v125);
    boost::polygon::detail::extended_int<64ul>::add(v135, v110, v108);
    memcpy(v144, v135, sizeof(v144));
    v138[0] = 1;
    v139 = 1;
    *(_OWORD *)&v135[192] = v125[12];
    *(_OWORD *)&v135[208] = v125[13];
    *(_OWORD *)&v135[224] = v125[14];
    *(_OWORD *)&v135[240] = v125[15];
    *(_OWORD *)&v135[128] = v125[8];
    *(_OWORD *)&v135[144] = v125[9];
    *(_OWORD *)&v135[160] = v125[10];
    *(_OWORD *)&v135[176] = v125[11];
    *(_OWORD *)&v135[64] = v125[4];
    *(_OWORD *)&v135[80] = v125[5];
    *(_OWORD *)&v135[96] = v125[6];
    *(_OWORD *)&v135[112] = v125[7];
    *(_OWORD *)v135 = v125[0];
    *(_OWORD *)&v135[16] = v125[1];
    *(_OWORD *)&v135[32] = v125[2];
    *(_OWORD *)&v135[48] = v125[3];
    v76 = v126;
    if (v18 == 2)
      v76 = -v126;
    v157 = *(_OWORD *)&v135[192];
    v158 = *(_OWORD *)&v135[208];
    v159 = *(_OWORD *)&v135[224];
    v160 = *(_OWORD *)&v135[240];
    v153 = *(_OWORD *)&v135[128];
    v154 = *(_OWORD *)&v135[144];
    v155 = *(_OWORD *)&v135[160];
    v156 = *(_OWORD *)&v135[176];
    v149 = *(_OWORD *)&v135[64];
    v150 = *(_OWORD *)&v135[80];
    v151 = *(_OWORD *)&v135[96];
    v152 = *(_OWORD *)&v135[112];
    v145 = *(_OWORD *)v135;
    v146 = *(_OWORD *)&v135[16];
    v147 = *(_OWORD *)&v135[32];
    v148 = *(_OWORD *)&v135[48];
    v161 = v76;
    memcpy(v140, v134, sizeof(v140));
    if (v12)
    {
      v79 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v106, v144, v138, v77, v78);
      v16[1] = v70 * (ldexp(*(long double *)&v79, v80) * 0.5);
    }
  }
  if (a9)
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v135, v136, (uint64_t)__src);
    memcpy(v136, v135, sizeof(v136));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v135, v137, (uint64_t)__src);
    memcpy(v137, v135, sizeof(v137));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v109, v118, (uint64_t)v118);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v108, (unsigned int *)__dst, (uint64_t)__dst);
    boost::polygon::detail::extended_int<64ul>::add(v110, v109, v108);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v135, v111, (uint64_t)v110);
    memcpy(v144, v135, sizeof(v144));
    v138[0] = 1;
    v139 = 1;
    *(_OWORD *)&v135[192] = __dst[12];
    *(_OWORD *)&v135[208] = __dst[13];
    *(_OWORD *)&v135[224] = __dst[14];
    *(_OWORD *)&v135[240] = __dst[15];
    *(_OWORD *)&v135[128] = __dst[8];
    *(_OWORD *)&v135[144] = __dst[9];
    *(_OWORD *)&v135[160] = __dst[10];
    *(_OWORD *)&v135[176] = __dst[11];
    *(_OWORD *)&v135[64] = __dst[4];
    *(_OWORD *)&v135[80] = __dst[5];
    *(_OWORD *)&v135[96] = __dst[6];
    *(_OWORD *)&v135[112] = __dst[7];
    *(_OWORD *)v135 = __dst[0];
    *(_OWORD *)&v135[16] = __dst[1];
    *(_OWORD *)&v135[32] = __dst[2];
    *(_OWORD *)&v135[48] = __dst[3];
    v81 = v120;
    if (v18 == 2)
      v81 = -v120;
    v157 = *(_OWORD *)&v135[192];
    v158 = *(_OWORD *)&v135[208];
    v159 = *(_OWORD *)&v135[224];
    v160 = *(_OWORD *)&v135[240];
    v153 = *(_OWORD *)&v135[128];
    v154 = *(_OWORD *)&v135[144];
    v155 = *(_OWORD *)&v135[160];
    v156 = *(_OWORD *)&v135[176];
    v149 = *(_OWORD *)&v135[64];
    v150 = *(_OWORD *)&v135[80];
    v151 = *(_OWORD *)&v135[96];
    v152 = *(_OWORD *)&v135[112];
    v145 = *(_OWORD *)v135;
    v146 = *(_OWORD *)&v135[16];
    v147 = *(_OWORD *)&v135[32];
    v148 = *(_OWORD *)&v135[48];
    v161 = v81;
    memcpy(v140, v134, sizeof(v140));
    v84 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval4(v106, v141, v136, v82, v83);
    v86 = ldexp(*(long double *)&v84, v85);
    v87 = 0.5;
    goto LABEL_89;
  }
}

uint64_t boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2(uint64_t a1, unsigned int *a2, _DWORD *a3, double a4, double a5)
{
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  long double v14;
  double v16;
  double v17;
  long double v18;
  double v19;
  double v20;
  unsigned int v21[65];
  int v22[65];
  unsigned int v23[65];
  _DWORD __src[65];
  _DWORD __dst[65];
  long double v26[2];
  double v27[2];
  int v28;

  v8 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval1(a4, a5, a1, a2, a3);
  v10 = v9;
  v27[0] = v9;
  v27[1] = v11;
  boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval1(v8, v12, a1, a2 + 65, a3 + 65);
  v26[0] = v13;
  v26[1] = v14;
  if (v10 >= 0.0 && v13 >= 0.0 || v10 <= 0.0 && v13 <= 0.0)
    return boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(v27, v26);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v23, a2, (uint64_t)a2);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v23, (uint64_t)a3);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v21, a2 + 65, (uint64_t)(a2 + 65));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v22, v21, (uint64_t)(a3 + 65));
  boost::polygon::detail::extended_int<64ul>::dif (__dst, __src, v22);
  boost::polygon::detail::extended_int<64ul>::p(__dst, v16, v17);
  v19 = frexp(v18, &v28);
  v20 = COERCE_DOUBLE(boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator-(v27, (uint64_t)v26));
  return frexp(v19 / v20, &v28);
}

uint64_t boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval4(unsigned int *a1, unsigned int *a2, unsigned int *a3, double a4, double a5)
{
  double v8;
  uint64_t v9;
  double v10;
  double v11;
  double v12;
  long double v13;
  double v15;
  double v16;
  double v17;
  double v18;
  unsigned int v19[65];
  int v20[65];
  unsigned int v21[65];
  int v22[65];
  unsigned int v23[65];
  _DWORD v24[65];
  unsigned int v25[65];
  _DWORD v26[65];
  unsigned int __dst[65];
  _DWORD v28[65];
  long double v29[2];
  _QWORD v30[2];
  _QWORD __src[34];

  v8 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)a1, a2, a3, a4, a5));
  *(double *)v30 = v8;
  v30[1] = v9;
  v12 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)a1, a2 + 130, a3 + 130, v10, v11));
  v29[0] = v12;
  v29[1] = v13;
  if (v8 >= 0.0 && v12 >= 0.0 || v8 <= 0.0 && v12 <= 0.0)
    return boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(v30, v29);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v25, a2, (uint64_t)a2);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v26, v25, (uint64_t)a3);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v23, a2 + 65, (uint64_t)(a2 + 65));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v24, v23, (uint64_t)(a3 + 65));
  boost::polygon::detail::extended_int<64ul>::add(__dst, v26, v24);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v21, a2 + 130, (uint64_t)(a2 + 130));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v22, v21, (uint64_t)(a3 + 130));
  boost::polygon::detail::extended_int<64ul>::dif (v28, __dst, v22);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v19, a2 + 195, (uint64_t)(a2 + 195));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v20, v19, (uint64_t)(a3 + 195));
  boost::polygon::detail::extended_int<64ul>::dif (__src, v28, v20);
  memcpy(a1, __src, 0x104uLL);
  a1[325] = 1;
  a1[389] = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, a2, (uint64_t)(a2 + 65));
  LODWORD(__src[0]) = 2;
  LODWORD(__src[32]) = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v28, __dst, (uint64_t)__src);
  memcpy(a1 + 65, v28, 0x104uLL);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, a3, (uint64_t)(a3 + 65));
  memcpy(a1 + 390, __src, 0x104uLL);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, a2 + 130, (uint64_t)(a2 + 195));
  LODWORD(__src[0]) = 2;
  LODWORD(__src[32]) = -1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v28, __dst, (uint64_t)__src);
  memcpy(a1 + 130, v28, 0x104uLL);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, a3 + 130, (uint64_t)(a3 + 195));
  memcpy(a1 + 455, __src, 0x104uLL);
  v17 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(a1, a1, a1 + 325, v15, v16));
  v18 = COERCE_DOUBLE(boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator-(v30, (uint64_t)v29));
  return frexp(v17 / v18, (int *)&__src[1]);
}

long double boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval1(double a1, double a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  long double v6;
  double v7;
  double v8;
  int v9;
  long double v10;
  long double v11;
  double v12;
  _QWORD v14[2];
  uint64_t v15;

  boost::polygon::detail::extended_int<64ul>::p(a4, a1, a2);
  v7 = frexp(v6, (int *)&v15);
  boost::polygon::detail::extended_int<64ul>::p(a5, v7, v8);
  LODWORD(a5) = v9;
  v11 = frexp(v10, (int *)&v15);
  LODWORD(v15) = v15 + (_DWORD)a5;
  *(long double *)v14 = v11;
  v14[1] = v15;
  boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::sqrt((uint64_t)v14);
  return frexp(v7 * v12, (int *)&v15);
}

uint64_t boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(_DWORD *a1, long double *a2)
{
  long double v2;
  int v3;
  int v4;
  double v7;
  long double v9;
  int v10;
  long double v11;
  __int128 v12;

  v2 = *(double *)a1;
  if (*(double *)a1 == 0.0)
    return *(_OWORD *)a2;
  v3 = *((_DWORD *)a2 + 2);
  v4 = a1[2];
  if (v3 > v4 + 54)
    return *(_OWORD *)a2;
  v7 = *a2;
  if (*a2 == 0.0 || v4 > v3 + 54)
    return *(_OWORD *)a1;
  if (v4 >= v3)
  {
    v11 = ldexp(v2, v4 - v3);
    *(_QWORD *)&v12 = frexp(v7 + v11, (int *)&v12 + 2);
    v10 = DWORD2(v12) + v3;
  }
  else
  {
    v9 = ldexp(*a2, v3 - v4);
    *(_QWORD *)&v12 = frexp(v2 + v9, (int *)&v12 + 2);
    v10 = DWORD2(v12) + v4;
  }
  DWORD2(v12) = v10;
  return v12;
}

uint64_t boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator-(_DWORD *a1, uint64_t a2)
{
  long double v2;
  int v3;
  int v4;
  long double v5;
  double v6;
  int v7;
  double v9;
  long double v11;
  __int128 v12;

  v2 = *(double *)a1;
  v3 = *(_DWORD *)(a2 + 8);
  if (*(double *)a1 == 0.0 || (v4 = a1[2], v3 > v4 + 54))
  {
    v5 = -*(double *)a2;
    goto LABEL_4;
  }
  v9 = *(double *)a2;
  if (*(double *)a2 != 0.0 && v4 <= v3 + 54)
  {
    if (v4 < v3)
    {
      v11 = ldexp(-v9, v3 - v4);
      v6 = frexp(v2 + v11, (int *)&v12 + 2);
      v7 = DWORD2(v12) + v4;
      goto LABEL_5;
    }
    v5 = ldexp(v2, v4 - v3) - v9;
LABEL_4:
    v6 = frexp(v5, (int *)&v12 + 2);
    v7 = DWORD2(v12) + v3;
LABEL_5:
    DWORD2(v12) = v7;
    return *(_QWORD *)&v6;
  }
  return *(_OWORD *)a1;
}

long double boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::sqrt(uint64_t a1)
{
  double v1;
  uint64_t v3;

  v1 = *(double *)a1;
  if ((*(_DWORD *)(a1 + 8) & 1) != 0)
    v1 = v1 + v1;
  return frexp(sqrt(v1), (int *)&v3);
}

uint64_t boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(_DWORD *a1, unsigned int *a2, unsigned int *a3, double a4, double a5)
{
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  long double v13;
  double v15;
  double v16;
  double v17;
  double v18;
  unsigned int v19[65];
  int v20[65];
  unsigned int v21[65];
  _DWORD v22[65];
  unsigned int v23[65];
  unsigned int v24[65];
  _DWORD __dst[65];
  long double v26[2];
  double v27[2];
  _DWORD __src[66];

  v8 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)a1, a2, a3, a4, a5));
  v27[0] = v8;
  v27[1] = v9;
  boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval1(v10, v11, (uint64_t)a1, a2 + 130, a3 + 130);
  v26[0] = v12;
  v26[1] = v13;
  if (v8 >= 0.0 && v12 >= 0.0 || v8 <= 0.0 && v12 <= 0.0)
    return boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(v27, v26);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v23, a2, (uint64_t)a2);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v24, v23, (uint64_t)a3);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v21, a2 + 65, (uint64_t)(a2 + 65));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v22, v21, (uint64_t)(a3 + 65));
  boost::polygon::detail::extended_int<64ul>::add(__dst, v24, v22);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v19, a2 + 130, (uint64_t)(a2 + 130));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v20, v19, (uint64_t)(a3 + 130));
  boost::polygon::detail::extended_int<64ul>::dif (__src, __dst, v20);
  memcpy(a1 + 195, __src, 0x104uLL);
  a1[520] = 1;
  a1[584] = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v24, a2, (uint64_t)(a2 + 65));
  __src[0] = 2;
  __src[64] = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v24, (uint64_t)__src);
  memcpy(a1 + 260, __dst, 0x104uLL);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, a3, (uint64_t)(a3 + 65));
  memcpy(a1 + 585, __src, 0x104uLL);
  v17 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)a1, a1 + 195, a1 + 520, v15, v16));
  v18 = COERCE_DOUBLE(boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator-(v27, (uint64_t)v26));
  return frexp(v17 / v18, &__src[2]);
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::pss(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  int *v10;
  int *v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int *v19;
  int *v20;
  BOOL v21;
  int *v22;
  int *v23;
  uint64_t v24;
  int *v25;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  unsigned int v46;
  double v47;
  double v48;
  long double v49;
  int v50;
  long double v51;
  double v52;
  int v53;
  double v54;
  double v55;
  uint64_t v56;
  int v57;
  int v58;
  double v59;
  double v60;
  uint64_t v61;
  int v62;
  int v63;
  double v64;
  double v65;
  uint64_t v66;
  int v67;
  double v68;
  int v69;
  unsigned int v70;
  int v71;
  unsigned int v72;
  int v73;
  unsigned int v74;
  int v75;
  unsigned int v76;
  int v77;
  unsigned int v78;
  double v79;
  double v80;
  long double v81;
  int v82;
  double v83;
  double v84;
  long double v85;
  int v86;
  double v87;
  double v88;
  double v89;
  long double v90;
  int v91;
  long double v92;
  int v93;
  int v94;
  unsigned int v95;
  uint64_t v96;
  int v97;
  double v98;
  double v99;
  long double v100;
  int v101;
  double v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  int v106;
  int v107;
  uint64_t v108;
  int v109;
  int v110;
  _DWORD *v111;
  int v112[65];
  _DWORD v113[65];
  _DWORD v114[65];
  int v115[65];
  unsigned int v116[65];
  unsigned int v117[65];
  unsigned int __dst[65];
  int v119[65];
  unsigned int v120[65];
  unsigned int v121[65];
  unsigned int __src[65];
  unsigned int v123[65];
  unsigned int v124[65];
  unsigned int v125[64];
  int v126;
  unsigned int v127[65];
  _DWORD v128[65];
  _BYTE v129[260];
  _BYTE v130[260];
  unsigned int v131[65];
  _BYTE v132[260];
  _BYTE v133[260];
  _DWORD v134[65];
  _OWORD v135[16];
  int v136;
  _BYTE v137[260];
  unsigned int v138[64];
  int v139;
  _QWORD v140[32];
  int v141;
  unsigned int v142[64];
  int v143;
  _QWORD v144[32];
  int v145;
  _BYTE v146[260];
  uint64_t v147;

  v9 = MEMORY[0x24BDAC7A8]();
  v13 = v12;
  v110 = v14;
  v16 = v15;
  v18 = v17;
  v20 = v19;
  v111 = (_DWORD *)v9;
  v147 = *MEMORY[0x24BDAC8D0];
  v21 = (*((_QWORD *)v10 + 4) & 0x20) == 0;
  if (v21)
    v22 = v10 + 2;
  else
    v22 = v10;
  if (v21)
    v23 = v10;
  else
    v23 = v10 + 2;
  v24 = *((_QWORD *)v11 + 4);
  if ((v24 & 0x20) != 0)
    v25 = v11 + 2;
  else
    v25 = v11;
  if ((v24 & 0x20) != 0)
    v26 = v11;
  else
    v26 = v11 + 2;
  v27 = *(int *)((char *)v10 + ((*((_QWORD *)v10 + 4) >> 2) & 8));
  v28 = v10[2 * v21];
  v29 = __OFSUB__(v27, v28);
  v30 = v27 - v28;
  if (!((v30 < 0) ^ v29 | (v30 == 0)))
  {
    v31 = 1;
LABEL_15:
    *(_QWORD *)v142 = v30;
    goto LABEL_18;
  }
  if (v30 < 0)
  {
    v30 = -v30;
    v31 = -1;
    goto LABEL_15;
  }
  v31 = 0;
LABEL_18:
  v143 = v31;
  v32 = v23[1];
  v33 = v22[1];
  v34 = v32 <= v33;
  v35 = v32 - v33;
  if (!v34)
  {
    v36 = 1;
LABEL_20:
    *(_QWORD *)v138 = v35;
    goto LABEL_23;
  }
  if (v35 < 0)
  {
    v35 = -v35;
    v36 = -1;
    goto LABEL_20;
  }
  v36 = 0;
LABEL_23:
  v139 = v36;
  v37 = *v26;
  v38 = *v25;
  v34 = v37 <= v38;
  v39 = v37 - v38;
  if (!v34)
  {
    v40 = 1;
LABEL_25:
    v144[0] = v39;
    goto LABEL_28;
  }
  if (v39 < 0)
  {
    v39 = -v39;
    v40 = -1;
    goto LABEL_25;
  }
  v40 = 0;
LABEL_28:
  v145 = v40;
  v41 = v26[1];
  v42 = v25[1];
  v29 = __OFSUB__(v41, v42);
  v43 = v41 - v42;
  if (!((v43 < 0) ^ v29 | (v43 == 0)))
  {
    v44 = 1;
LABEL_30:
    v140[0] = v43;
    goto LABEL_33;
  }
  if (v43 < 0)
  {
    v43 = -v43;
    v44 = -1;
    goto LABEL_30;
  }
  v44 = 0;
LABEL_33:
  v141 = v44;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v131, (unsigned int *)v144, (uint64_t)v138);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, v142, (uint64_t)v140);
  boost::polygon::detail::extended_int<64ul>::dif (v125, v131, (int *)v127);
  if (v126)
  {
    v45 = *v23;
    if (*v23 <= 0)
    {
      if ((v45 & 0x80000000) == 0)
      {
        v46 = 0;
LABEL_56:
        v131[64] = v46;
        boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, v138, (uint64_t)v131);
        v69 = v23[1];
        if (v69 <= 0)
        {
          if ((v69 & 0x80000000) == 0)
          {
            v70 = 0;
LABEL_61:
            v131[64] = v70;
            boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v146, v142, (uint64_t)v131);
            boost::polygon::detail::extended_int<64ul>::dif (v135, v127, (int *)v146);
            v71 = v26[1];
            if (v71 <= 0)
            {
              if ((v71 & 0x80000000) == 0)
              {
                v72 = 0;
LABEL_66:
                v131[64] = v72;
                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, (unsigned int *)v144, (uint64_t)v131);
                v73 = *v26;
                if (*v26 <= 0)
                {
                  if ((v73 & 0x80000000) == 0)
                  {
                    v74 = 0;
LABEL_71:
                    v131[64] = v74;
                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v146, (unsigned int *)v140, (uint64_t)v131);
                    boost::polygon::detail::extended_int<64ul>::dif (v131, v127, (int *)v146);
                    memcpy(v137, v131, sizeof(v137));
                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v131, v142, (uint64_t)v137);
                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, (unsigned int *)v144, (uint64_t)v135);
                    boost::polygon::detail::extended_int<64ul>::add(v124, v131, v127);
                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v131, v138, (uint64_t)v137);
                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, (unsigned int *)v140, (uint64_t)v135);
                    boost::polygon::detail::extended_int<64ul>::add(v123, v131, v127);
                    v75 = *v20;
                    if (*v20 <= 0)
                    {
                      if ((v75 & 0x80000000) == 0)
                      {
                        v76 = 0;
LABEL_76:
                        v131[64] = v76;
                        boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, v125, (uint64_t)v131);
                        boost::polygon::detail::extended_int<64ul>::dif (__src, v124, (int *)v127);
                        v77 = v20[1];
                        if (v77 <= 0)
                        {
                          if ((v77 & 0x80000000) == 0)
                          {
                            v78 = 0;
LABEL_81:
                            v131[64] = v78;
                            boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, v125, (uint64_t)v131);
                            boost::polygon::detail::extended_int<64ul>::dif (v121, v123, (int *)v127);
                            if (!(__src[64] | v121[64]))
                            {
                              boost::polygon::detail::extended_int<64ul>::p(v125, v79, v80);
                              v83 = ldexp(v81, v82);
                              boost::polygon::detail::extended_int<64ul>::p(v124, v83, v84);
                              v87 = ldexp(v85, v86);
                              v88 = v87 / v83;
                              boost::polygon::detail::extended_int<64ul>::p(v123, v87, v89);
                              v92 = ldexp(v90, v91);
                              *(double *)v16 = v88;
                              *(long double *)(v16 + 8) = v92 / v83;
                              *(double *)(v16 + 16) = v88;
                              *(_BYTE *)(v16 + 24) = 1;
                              return;
                            }
                            if (v126 >= 0)
                              v93 = -1;
                            else
                              v93 = 1;
                            if (v18 == 2)
                              v94 = v93;
                            else
                              v94 = -v93;
                            v95 = 1;
                            if (v94 <= 0)
                            {
                              if ((v94 & 0x80000000) == 0)
                              {
                                v95 = 0;
LABEL_97:
                                v120[64] = v95;
                                memcpy(v146, __src, sizeof(v146));
                                *(_DWORD *)&v146[256] = -*(_DWORD *)&v146[256];
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, (unsigned int *)v144, (uint64_t)v146);
                                memcpy(__dst, v121, sizeof(__dst));
                                __dst[64] = -__dst[64];
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, (unsigned int *)v140, (uint64_t)__dst);
                                boost::polygon::detail::extended_int<64ul>::add(v131, v127, v119);
                                memcpy(v119, __src, sizeof(v119));
                                v119[64] = -v119[64];
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v146, v142, (uint64_t)v119);
                                memcpy(v117, v121, sizeof(v117));
                                v117[64] = -v117[64];
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v138, (uint64_t)v117);
                                boost::polygon::detail::extended_int<64ul>::add(v127, v146, __dst);
                                memcpy(v132, v127, sizeof(v132));
                                memcpy(v133, v120, sizeof(v133));
                                v134[64] = 0;
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v146, v142, (uint64_t)v142);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, v138, (uint64_t)v138);
                                boost::polygon::detail::extended_int<64ul>::add(v127, v146, v119);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, (unsigned int *)v144, (uint64_t)v144);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, (unsigned int *)v140, (uint64_t)v140);
                                boost::polygon::detail::extended_int<64ul>::add(v146, v119, __dst);
                                memcpy(v128, v146, sizeof(v128));
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, v142, (uint64_t)v144);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v138, (uint64_t)v140);
                                boost::polygon::detail::extended_int<64ul>::add(v146, v119, __dst);
                                memcpy(v129, v146, sizeof(v129));
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v142, (uint64_t)v121);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v115, v138, (uint64_t)__src);
                                boost::polygon::detail::extended_int<64ul>::dif (v117, v116, v115);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v113, (unsigned int *)v144, (uint64_t)v121);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v112, (unsigned int *)v140, (uint64_t)__src);
                                boost::polygon::detail::extended_int<64ul>::dif (v114, v113, v112);
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v117, (uint64_t)v114);
                                *(_DWORD *)v146 = 2;
                                *(_DWORD *)&v146[256] = -1;
                                boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, __dst, (uint64_t)v146);
                                memcpy(v130, v119, sizeof(v130));
                                v96 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss4<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>();
                                v98 = ldexp(*(long double *)&v96, v97);
                                boost::polygon::detail::extended_int<64ul>::p(v125, v98, v99);
                                v102 = v98 * ldexp(v100, v101);
                                if (v13)
                                {
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v117, __src, (uint64_t)__src);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v121, (uint64_t)v121);
                                  boost::polygon::detail::extended_int<64ul>::add(__dst, v117, v116);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, (unsigned int *)v140, (uint64_t)__dst);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v113, __src, (uint64_t)v144);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v112, v121, (uint64_t)v140);
                                  boost::polygon::detail::extended_int<64ul>::add(v114, v113, v112);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v115, v123, (uint64_t)v114);
                                  boost::polygon::detail::extended_int<64ul>::dif (v146, v119, v115);
                                  memcpy(v131, v146, sizeof(v131));
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v117, __src, (uint64_t)__src);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v121, (uint64_t)v121);
                                  boost::polygon::detail::extended_int<64ul>::add(__dst, v117, v116);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, v138, (uint64_t)__dst);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v113, __src, (uint64_t)v142);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v112, v121, (uint64_t)v138);
                                  boost::polygon::detail::extended_int<64ul>::add(v114, v113, v112);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v115, v123, (uint64_t)v114);
                                  boost::polygon::detail::extended_int<64ul>::dif (v146, v119, v115);
                                  memcpy(v132, v146, sizeof(v132));
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v146, v123, (uint64_t)v120);
                                  memcpy(v133, v146, sizeof(v133));
                                  v103 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss4<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>();
                                  *(long double *)(v16 + 8) = ldexp(*(long double *)&v103, v104) / v102;
                                }
                                if ((v110 & 1) != 0 || a9)
                                {
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v117, __src, (uint64_t)__src);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v121, (uint64_t)v121);
                                  boost::polygon::detail::extended_int<64ul>::add(__dst, v117, v116);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, (unsigned int *)v144, (uint64_t)__dst);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v113, __src, (uint64_t)v144);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v112, v121, (uint64_t)v140);
                                  boost::polygon::detail::extended_int<64ul>::add(v114, v113, v112);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v115, v124, (uint64_t)v114);
                                  boost::polygon::detail::extended_int<64ul>::dif (v146, v119, v115);
                                  memcpy(v131, v146, sizeof(v131));
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v117, __src, (uint64_t)__src);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v121, (uint64_t)v121);
                                  boost::polygon::detail::extended_int<64ul>::add(__dst, v117, v116);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, v142, (uint64_t)__dst);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v113, __src, (uint64_t)v142);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v112, v121, (uint64_t)v138);
                                  boost::polygon::detail::extended_int<64ul>::add(v114, v113, v112);
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v115, v124, (uint64_t)v114);
                                  boost::polygon::detail::extended_int<64ul>::dif (v146, v119, v115);
                                  memcpy(v132, v146, sizeof(v132));
                                  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v146, v124, (uint64_t)v120);
                                  memcpy(v133, v146, sizeof(v133));
                                  if (v110)
                                  {
                                    v105 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss4<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>();
                                    *(long double *)v16 = ldexp(*(long double *)&v105, v106) / v102;
                                  }
                                  if (a9)
                                  {
                                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, __src, (uint64_t)__src);
                                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v115, v121, (uint64_t)v121);
                                    boost::polygon::detail::extended_int<64ul>::add(v117, v116, v115);
                                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v125, (uint64_t)v117);
                                    if (v98 >= 0.0)
                                      v107 = 1;
                                    else
                                      v107 = -1;
                                    *(_DWORD *)v146 = 1;
                                    *(_DWORD *)&v146[256] = v107;
                                    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v119, __dst, (uint64_t)v146);
                                    memcpy(v134, v119, sizeof(v134));
                                    v108 = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss4<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>();
                                    v68 = ldexp(*(long double *)&v108, v109) / v102;
LABEL_108:
                                    *(double *)(v16 + 16) = v68;
                                    return;
                                  }
                                }
                                return;
                              }
                              v95 = -1;
                            }
                            v120[0] = 1;
                            goto LABEL_97;
                          }
                          v77 = -v77;
                          v78 = -1;
                        }
                        else
                        {
                          v78 = 1;
                        }
                        v131[0] = v77;
                        goto LABEL_81;
                      }
                      v75 = -v75;
                      v76 = -1;
                    }
                    else
                    {
                      v76 = 1;
                    }
                    v131[0] = v75;
                    goto LABEL_76;
                  }
                  v73 = -v73;
                  v74 = -1;
                }
                else
                {
                  v74 = 1;
                }
                v131[0] = v73;
                goto LABEL_71;
              }
              v71 = -v71;
              v72 = -1;
            }
            else
            {
              v72 = 1;
            }
            v131[0] = v71;
            goto LABEL_66;
          }
          v69 = -v69;
          v70 = -1;
        }
        else
        {
          v70 = 1;
        }
        v131[0] = v69;
        goto LABEL_61;
      }
      v45 = -v45;
      v46 = -1;
    }
    else
    {
      v46 = 1;
    }
    v131[0] = v45;
    goto LABEL_56;
  }
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, v142, (uint64_t)v142);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v135, v138, (uint64_t)v138);
  boost::polygon::detail::extended_int<64ul>::add(v131, v127, v135);
  boost::polygon::detail::extended_int<64ul>::p(v131, v47, v48);
  v51 = ldexp(v49, v50);
  v52 = v51 + v51;
  boost::polygon::detail::extended_int<64ul>::operator*(v138, *v25 - (uint64_t)*v22, (uint64_t)v131);
  boost::polygon::detail::extended_int<64ul>::operator*(v142, v25[1] - (uint64_t)v22[1], (uint64_t)v127);
  boost::polygon::detail::extended_int<64ul>::dif (v135, v131, (int *)v127);
  boost::polygon::detail::extended_int<64ul>::operator*(v142, v20[1] - (uint64_t)v22[1], (uint64_t)v131);
  boost::polygon::detail::extended_int<64ul>::operator*(v138, *v20 - (uint64_t)*v22, (uint64_t)v127);
  boost::polygon::detail::extended_int<64ul>::dif (v124, v131, (int *)v127);
  boost::polygon::detail::extended_int<64ul>::operator*(v138, *v20 - (uint64_t)*v25, (uint64_t)v131);
  boost::polygon::detail::extended_int<64ul>::operator*(v142, v20[1] - (uint64_t)v25[1], (uint64_t)v127);
  boost::polygon::detail::extended_int<64ul>::dif (v123, v131, (int *)v127);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v127, v124, (uint64_t)v123);
  v128[0] = 1;
  v128[64] = 1;
  if (v13)
  {
    if (v18 == 2)
      v53 = 1;
    else
      v53 = -1;
    *(_DWORD *)v146 = 2;
    *(_DWORD *)&v146[256] = v53;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v131, v138, (uint64_t)v146);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v120, v142, (uint64_t)v142);
    boost::polygon::detail::extended_int<64ul>::operator*(v120, v25[1] + (uint64_t)v22[1], (uint64_t)v121);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v142, (uint64_t)v138);
    boost::polygon::detail::extended_int<64ul>::operator*(__dst, *v25 + (uint64_t)*v22 - 2 * *v20, (uint64_t)v119);
    boost::polygon::detail::extended_int<64ul>::dif (__src, v121, v119);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v138, (uint64_t)v138);
    boost::polygon::detail::extended_int<64ul>::operator*(v116, 2 * v20[1], (uint64_t)v117);
    boost::polygon::detail::extended_int<64ul>::add(v146, __src, v117);
    memcpy(v132, v146, sizeof(v132));
    v56 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v111, v131, v127, v54, v55);
    *(long double *)(v16 + 8) = ldexp(*(long double *)&v56, v57) / v52;
  }
  if ((v110 & 1) != 0 || a9)
  {
    if (v18 == 2)
      v58 = 1;
    else
      v58 = -1;
    *(_DWORD *)v146 = 2;
    *(_DWORD *)&v146[256] = v58;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v142, (uint64_t)v146);
    memcpy(v131, __src, sizeof(v131));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v120, v138, (uint64_t)v138);
    boost::polygon::detail::extended_int<64ul>::operator*(v120, *v25 + (uint64_t)*v22, (uint64_t)v121);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, v142, (uint64_t)v138);
    boost::polygon::detail::extended_int<64ul>::operator*(__dst, v25[1] + (uint64_t)v22[1] - 2 * v20[1], (uint64_t)v119);
    boost::polygon::detail::extended_int<64ul>::dif (__src, v121, v119);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v116, v142, (uint64_t)v142);
    boost::polygon::detail::extended_int<64ul>::operator*(v116, 2 * *v20, (uint64_t)v117);
    boost::polygon::detail::extended_int<64ul>::add(v146, __src, v117);
    memcpy(v132, v146, sizeof(v132));
    if (v110)
    {
      v61 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v111, v131, v127, v59, v60);
      *(long double *)v16 = ldexp(*(long double *)&v61, v62) / v52;
    }
    if (a9)
    {
      *(_OWORD *)&v146[192] = v135[12];
      *(_OWORD *)&v146[208] = v135[13];
      *(_OWORD *)&v146[224] = v135[14];
      *(_OWORD *)&v146[240] = v135[15];
      *(_OWORD *)&v146[128] = v135[8];
      *(_OWORD *)&v146[144] = v135[9];
      *(_OWORD *)&v146[160] = v135[10];
      *(_OWORD *)&v146[176] = v135[11];
      *(_OWORD *)&v146[64] = v135[4];
      *(_OWORD *)&v146[80] = v135[5];
      *(_OWORD *)&v146[96] = v135[6];
      *(_OWORD *)&v146[112] = v135[7];
      *(_OWORD *)v146 = v135[0];
      *(_OWORD *)&v146[16] = v135[1];
      *(_OWORD *)&v146[32] = v135[2];
      *(_OWORD *)&v146[48] = v135[3];
      if (v136 >= 0)
        v63 = v136;
      else
        v63 = -v136;
      *(_OWORD *)&v133[192] = *(_OWORD *)&v146[192];
      *(_OWORD *)&v133[208] = *(_OWORD *)&v146[208];
      *(_OWORD *)&v133[224] = *(_OWORD *)&v146[224];
      *(_OWORD *)&v133[240] = *(_OWORD *)&v146[240];
      *(_OWORD *)&v133[128] = *(_OWORD *)&v146[128];
      *(_OWORD *)&v133[144] = *(_OWORD *)&v146[144];
      *(_OWORD *)&v133[160] = *(_OWORD *)&v146[160];
      *(_OWORD *)&v133[176] = *(_OWORD *)&v146[176];
      *(_OWORD *)&v133[64] = *(_OWORD *)&v146[64];
      *(_OWORD *)&v133[80] = *(_OWORD *)&v146[80];
      *(_OWORD *)&v133[96] = *(_OWORD *)&v146[96];
      *(_OWORD *)&v133[112] = *(_OWORD *)&v146[112];
      *(_OWORD *)v133 = *(_OWORD *)v146;
      *(_OWORD *)&v133[16] = *(_OWORD *)&v146[16];
      *(_OWORD *)&v133[32] = *(_OWORD *)&v146[32];
      *(_OWORD *)&v133[48] = *(_OWORD *)&v146[48];
      *(_DWORD *)&v133[256] = v63;
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v142, (uint64_t)v142);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v121, v138, (uint64_t)v138);
      boost::polygon::detail::extended_int<64ul>::add(v146, __src, v121);
      memcpy(v129, v146, sizeof(v129));
      v66 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(v111, v131, v127, v64, v65);
      v68 = ldexp(*(long double *)&v66, v67) / v52;
      goto LABEL_108;
    }
  }
}

uint64_t boost::polygon::detail::extended_int<64ul>::operator*@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v5;
  uint64_t v7[32];
  int v8;

  if (a2 < 1)
  {
    if (a2 < 0)
    {
      v7[0] = -a2;
      if ((unint64_t)-a2 >> 32)
        v5 = -2;
      else
        v5 = -1;
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    v7[0] = a2;
    if (HIDWORD(a2))
      v5 = 2;
    else
      v5 = 1;
  }
  v8 = v5;
  return boost::polygon::detail::extended_int<64ul>::mul(a3, a1, (uint64_t)v7);
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss4<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>()
{
  uint64_t v0;
  unsigned int *v1;
  unsigned int *v2;
  double v3;
  double v4;
  unsigned int *v5;
  unsigned int *v6;
  _DWORD *v7;
  double v8;
  double v9;
  double v10;
  int v11;
  int v12;
  double v13;
  double v14;
  double v15;
  uint64_t v16;
  double v17;
  int v18;
  int v19;
  double v20;
  double v21;
  double v22;
  double v23;
  uint64_t v24;
  _QWORD *v25;
  long double *v26;
  double v27;
  uint64_t v28;
  double v29;
  double v30;
  double v31;
  int v32;
  int v33;
  double v34;
  double v35;
  double v36;
  uint64_t v37;
  double v38;
  int v39;
  int v40;
  double v41;
  double v43;
  double v44;
  double v45;
  _QWORD *v46;
  _QWORD *v47;
  double v48;
  double v49;
  double v50;
  unsigned int *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD v54[33];
  _QWORD v55[33];
  _QWORD v56[2];
  _QWORD v57[2];
  unsigned int v58[65];
  unsigned int v59[65];
  unsigned int v60[65];
  unsigned int v61[65];
  unsigned int v62[65];
  unsigned int v63[65];
  unsigned int v64[65];
  _QWORD __src[33];
  _QWORD v66[33];
  unsigned int v67[65];
  _DWORD v68[130];
  _BYTE v69[260];
  unsigned int __dst[65];
  _BYTE v71[260];
  _BYTE v72[260];
  _BYTE v73[260];
  uint64_t v74;

  v0 = MEMORY[0x24BDAC7A8]();
  v5 = v2;
  v6 = v1;
  v7 = (_DWORD *)v0;
  v74 = *MEMORY[0x24BDAC8D0];
  if (v1[259])
  {
    __dst[0] = 1;
    __dst[64] = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v67, v2, (uint64_t)(v2 + 65));
    memcpy(v71, v5 + 130, sizeof(v71));
    v68[0] = 1;
    v68[64] = 1;
    v51 = v6 + 130;
    v52 = (uint64_t)(v5 + 195);
    v10 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval1(v8, v9, (uint64_t)v7, v6 + 130, v5 + 195);
    v12 = v11;
    v14 = v13;
    __src[0] = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v7, __dst, v67, v10, v15);
    __src[1] = v16;
    boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::sqrt((uint64_t)__src);
    v19 = v18 + v12;
    v20 = frexp(v14 * v17, (int *)&v66[1]);
    LODWORD(v66[1]) += v19;
    *(double *)v57 = v20;
    v57[1] = v66[1];
    memcpy(__dst, v6, sizeof(__dst));
    memcpy(v67, v5, sizeof(v67));
    memcpy(v71, v6 + 65, sizeof(v71));
    v53 = (uint64_t)(v5 + 65);
    memcpy(v68, v5 + 65, 0x104uLL);
    memcpy(v72, v6 + 195, sizeof(v72));
    v68[65] = 1;
    v68[129] = 1;
    v23 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(v7, __dst, v67, v21, v22));
    *(double *)v56 = v23;
    v56[1] = v24;
    if (v23 >= 0.0 && v20 >= 0.0 || v23 <= 0.0 && v20 <= 0.0)
    {
      v25 = v56;
      v26 = (long double *)v57;
      return boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(v25, v26);
    }
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v64, v6 + 195, (uint64_t)v6);
    LODWORD(v66[0]) = 2;
    LODWORD(v66[32]) = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v64, (uint64_t)v66);
    memcpy(__dst, __src, sizeof(__dst));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v64, v6 + 195, (uint64_t)(v6 + 65));
    LODWORD(v66[0]) = 2;
    LODWORD(v66[32]) = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v64, (uint64_t)v66);
    memcpy(v71, __src, sizeof(v71));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v62, v6, (uint64_t)v6);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v63, v62, (uint64_t)v5);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v60, v6 + 65, (uint64_t)(v6 + 65));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v61, v60, v53);
    boost::polygon::detail::extended_int<64ul>::add(v64, v63, v61);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v59, v6 + 195, (uint64_t)(v6 + 195));
    boost::polygon::detail::extended_int<64ul>::add(__src, v64, v59);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v54, v51, (uint64_t)v51);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v55, (unsigned int *)v54, (uint64_t)(v5 + 130));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v58, (unsigned int *)v55, v52);
    boost::polygon::detail::extended_int<64ul>::dif (v66, __src, (int *)v58);
    memcpy(v72, v66, sizeof(v72));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v64, v6, (uint64_t)(v6 + 65));
    LODWORD(v66[0]) = 2;
    LODWORD(v66[32]) = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v64, (uint64_t)v66);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v62, v51, (uint64_t)v51);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v63, v62, v52);
    boost::polygon::detail::extended_int<64ul>::dif (v66, __src, (int *)v63);
    memcpy(v73, v66, sizeof(v73));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v66, v5, v53);
    memcpy(v69, v66, sizeof(v69));
    v45 = COERCE_DOUBLE(boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss3<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>((uint64_t)v7, __dst, v67, v43, v44));
    v46 = v56;
    v47 = v57;
  }
  else
  {
    v27 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2(v0, v1, v2, v3, v4));
    *(double *)v55 = v27;
    v55[1] = v28;
    __dst[0] = 1;
    __dst[64] = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v67, v5, (uint64_t)(v5 + 65));
    memcpy(v71, v5 + 130, sizeof(v71));
    v68[0] = 1;
    v68[64] = 1;
    v31 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval1(v29, v30, (uint64_t)v7, v6 + 130, v5 + 195);
    v33 = v32;
    v35 = v34;
    __src[0] = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v7, __dst, v67, v31, v36);
    __src[1] = v37;
    boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::sqrt((uint64_t)__src);
    v40 = v39 + v33;
    v41 = frexp(v35 * v38, (int *)&v66[1]);
    LODWORD(v66[1]) += v40;
    *(double *)v54 = v41;
    v54[1] = v66[1];
    if (v27 >= 0.0 && v41 >= 0.0 || v27 <= 0.0 && v41 <= 0.0)
    {
      v25 = v55;
      v26 = (long double *)v54;
      return boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(v25, v26);
    }
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v63, v6, (uint64_t)v6);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v64, v63, (uint64_t)v5);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v61, v6 + 65, (uint64_t)(v6 + 65));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v62, v61, (uint64_t)(v5 + 65));
    boost::polygon::detail::extended_int<64ul>::add(__src, v64, v62);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v58, v6 + 130, (uint64_t)(v6 + 130));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v59, v58, (uint64_t)(v5 + 195));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v60, v59, (uint64_t)(v5 + 130));
    boost::polygon::detail::extended_int<64ul>::dif (v66, __src, (int *)v60);
    memcpy(__dst, v66, sizeof(__dst));
    v67[0] = 1;
    v67[64] = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v64, v6, (uint64_t)(v6 + 65));
    LODWORD(v66[0]) = 2;
    LODWORD(v66[32]) = 1;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v64, (uint64_t)v66);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v62, v6 + 130, (uint64_t)(v6 + 130));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v63, v62, (uint64_t)(v5 + 195));
    boost::polygon::detail::extended_int<64ul>::dif (v66, __src, (int *)v63);
    memcpy(v71, v66, sizeof(v71));
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v66, v5, (uint64_t)(v5 + 65));
    memcpy(v68, v66, 0x104uLL);
    v45 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2((uint64_t)v7, __dst, v67, v48, v49));
    v46 = v55;
    v47 = v54;
  }
  v50 = COERCE_DOUBLE(boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator-(v46, (uint64_t)v47));
  return frexp(v45 / v50, (int *)&v66[1]);
}

uint64_t boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sqrt_expr_evaluator_pss3<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>>(uint64_t a1, unsigned int *a2, _DWORD *a3, double a4, double a5)
{
  double v8;
  uint64_t v9;
  double v10;
  double v11;
  double v12;
  long double v13;
  double v15;
  double v16;
  double v17;
  double v18;
  unsigned int v19[65];
  unsigned int v20[65];
  int v21[65];
  int v22[65];
  unsigned int v23[65];
  _DWORD v24[65];
  unsigned int v25[65];
  _DWORD __src[65];
  long double v27[2];
  _QWORD v28[2];
  int __dst;
  int v30[62];
  int v31;
  _DWORD v32[65];
  _BYTE v33[260];
  unsigned int v34[65];
  _BYTE v35[260];
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v8 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2(a1, a2, a3, a4, a5));
  *(double *)v28 = v8;
  v28[1] = v9;
  v12 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2(a1, a2 + 130, a3 + 130, v10, v11));
  v27[0] = v12;
  v27[1] = v13;
  if (v8 >= 0.0 && v12 >= 0.0 || v8 <= 0.0 && v12 <= 0.0)
    return boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator+(v28, v27);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v25, a2, (uint64_t)a2);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v25, (uint64_t)a3);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v23, a2 + 65, (uint64_t)(a2 + 65));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v24, v23, (uint64_t)(a3 + 65));
  boost::polygon::detail::extended_int<64ul>::add(&__dst, __src, v24);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v22, a2 + 130, (uint64_t)(a2 + 130));
  boost::polygon::detail::extended_int<64ul>::dif (v32, &__dst, v22);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v19, a2 + 195, (uint64_t)(a2 + 195));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v20, v19, (uint64_t)a3);
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v21, v20, (uint64_t)(a3 + 65));
  boost::polygon::detail::extended_int<64ul>::dif (v34, v32, v21);
  v32[0] = 1;
  v32[64] = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v24, a2, (uint64_t)(a2 + 65));
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v23, a2 + 130, (uint64_t)(a2 + 195));
  boost::polygon::detail::extended_int<64ul>::dif (v25, v24, (int *)v23);
  __dst = 2;
  v31 = 1;
  boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__src, v25, (uint64_t)&__dst);
  memcpy(v35, __src, sizeof(v35));
  memcpy(v33, a3 + 195, sizeof(v33));
  v17 = COERCE_DOUBLE(boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval2(a1, v34, v32, v15, v16));
  v18 = COERCE_DOUBLE(boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>::operator-(v28, (uint64_t)v27));
  return frexp(v17 / v18, v30);
}

double boost::polygon::detail::operator+<boost::polygon::detail::robust_fpt<double>>(__int128 *a1, __int128 *a2)
{
  __int128 v4;
  double v5;
  __int128 v6;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  v4 = *a1;
  v10 = *a2;
  v11 = v4;
  v5 = boost::polygon::detail::robust_fpt<double>::operator+((double *)&v11, (double *)&v10);
  v6 = a1[1];
  v8 = a2[1];
  v9 = v6;
  boost::polygon::detail::robust_fpt<double>::operator+((double *)&v9, (double *)&v8);
  return v5;
}

void boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::mp_circle_formation_functor<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::sss()
{
  uint64_t v0;
  int *v1;
  int *v2;
  int *v3;
  int v4;
  int v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int *v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  int *v26;
  int *v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  int *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t i;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  double v59;
  double v60;
  uint64_t v61;
  int v62;
  double v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t j;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  double v71;
  double v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  double v82;
  double v83;
  uint64_t v84;
  int v85;
  uint64_t v86;
  int v87;
  int v88;
  uint64_t v89;
  char v90;
  unsigned int *v91;
  int v92;
  int v93[65];
  _DWORD v94[65];
  _DWORD __dst[65];
  unsigned int v96[260];
  unsigned int __src[195];
  _DWORD v98[65];
  _QWORD v99[32];
  int v100;
  uint64_t v101;
  int v102;
  uint64_t v103;
  int v104;
  _QWORD v105[32];
  int v106;
  uint64_t v107;
  int v108;
  uint64_t v109;
  int v110;
  _QWORD v111[32];
  int v112;
  uint64_t v113;
  int v114;
  uint64_t v115;
  int v116;
  uint64_t v117;

  v0 = MEMORY[0x24BDAC7A8]();
  v92 = v4;
  v88 = v5;
  v90 = v6;
  v89 = v7;
  v91 = (unsigned int *)v0;
  v117 = *MEMORY[0x24BDAC8D0];
  v8 = *((_QWORD *)v1 + 4);
  v9 = *v1;
  if ((v8 & 0x20) != 0)
    v10 = *v1;
  else
    v10 = v1[2];
  if ((v8 & 0x20) != 0)
  {
    v9 = v1[2];
    v11 = v1 + 2;
  }
  else
  {
    v11 = v1;
  }
  v12 = v10 - (uint64_t)v9;
  if (v12 > 0)
  {
    v13 = 1;
LABEL_9:
    v111[0] = v12;
    goto LABEL_12;
  }
  if (v12 < 0)
  {
    v12 = v9 - (uint64_t)v10;
    v13 = -1;
    goto LABEL_9;
  }
  v13 = 0;
LABEL_12:
  v112 = v13;
  v14 = *((_QWORD *)v2 + 4);
  v15 = v2[2];
  if ((v14 & 0x20) != 0)
    v16 = *v2;
  else
    v16 = v2[2];
  if ((v14 & 0x20) != 0)
  {
    v17 = v2 + 2;
  }
  else
  {
    v15 = *v2;
    v17 = v2;
  }
  v18 = v16 - (uint64_t)v15;
  if (v18 > 0)
  {
    v19 = 1;
LABEL_20:
    v113 = v18;
    goto LABEL_23;
  }
  if (v18 < 0)
  {
    v18 = v15 - (uint64_t)v16;
    v19 = -1;
    goto LABEL_20;
  }
  v19 = 0;
LABEL_23:
  v114 = v19;
  v20 = *((_QWORD *)v3 + 4);
  v21 = v3 + 2;
  v22 = v3[2];
  if ((v20 & 0x20) != 0)
    v23 = *v3;
  else
    v23 = v3[2];
  if ((v20 & 0x20) == 0)
  {
    v22 = *v3;
    v21 = v3;
  }
  v24 = v23 - (uint64_t)v22;
  if (v24 > 0)
  {
    v25 = 1;
LABEL_30:
    v115 = v24;
    goto LABEL_33;
  }
  if (v24 < 0)
  {
    v24 = v22 - (uint64_t)v23;
    v25 = -1;
    goto LABEL_30;
  }
  v25 = 0;
LABEL_33:
  v116 = v25;
  v26 = v1 + 1;
  v27 = v1 + 3;
  if ((v8 & 0x20) != 0)
    v28 = v26;
  else
    v28 = v27;
  v29 = *v28;
  v30 = v11[1];
  v31 = v29 - v30;
  if (v29 > v30)
  {
    v32 = 1;
LABEL_38:
    v105[0] = v31;
    goto LABEL_41;
  }
  if (v31 < 0)
  {
    v31 = v30 - v29;
    v32 = -1;
    goto LABEL_38;
  }
  v32 = 0;
LABEL_41:
  v33 = v9;
  v106 = v32;
  v34 = v2 + 1;
  if ((v14 & 0x20) == 0)
    v34 = v2 + 3;
  v35 = *v34;
  v36 = v17[1];
  v37 = v35 - v36;
  if (v35 > v36)
  {
    v38 = 1;
LABEL_45:
    v107 = v37;
    goto LABEL_48;
  }
  if (v37 < 0)
  {
    v37 = v36 - v35;
    v38 = -1;
    goto LABEL_45;
  }
  v38 = 0;
LABEL_48:
  v39 = v15;
  v108 = v38;
  v40 = v3 + 1;
  if ((v20 & 0x20) == 0)
    v40 = v3 + 3;
  v41 = *v40;
  v42 = v21[1];
  v43 = v41 - v42;
  if (v41 <= v42)
  {
    if ((v43 & 0x8000000000000000) == 0)
    {
      v44 = 0;
      goto LABEL_55;
    }
    v43 = v42 - v41;
    v44 = -1;
  }
  else
  {
    v44 = 1;
  }
  v109 = v43;
LABEL_55:
  v110 = v44;
  v45 = (int)v29 * (uint64_t)v33 - (int)v30 * (uint64_t)v10;
  if (v45 < 1)
  {
    if (v45 < 0)
    {
      v99[0] = -v45;
      if ((unint64_t)-v45 >> 32)
        v46 = -2;
      else
        v46 = -1;
    }
    else
    {
      v46 = 0;
    }
  }
  else
  {
    v99[0] = v45;
    if (HIDWORD(v45))
      v46 = 2;
    else
      v46 = 1;
  }
  v100 = v46;
  v47 = (int)v35 * (uint64_t)v39 - (int)v36 * (uint64_t)v16;
  if (v47 < 1)
  {
    if (v47 < 0)
    {
      v101 = -v47;
      if ((unint64_t)-v47 >> 32)
        v48 = -2;
      else
        v48 = -1;
    }
    else
    {
      v48 = 0;
    }
  }
  else
  {
    v101 = v47;
    if (HIDWORD(v47))
      v48 = 2;
    else
      v48 = 1;
  }
  v102 = v48;
  v49 = (int)v41 * (uint64_t)v22 - (int)v42 * (uint64_t)v23;
  if (v49 < 1)
  {
    if (v49 < 0)
    {
      v103 = (int)v42 * (uint64_t)v23 - (int)v41 * (uint64_t)v22;
      if (HIDWORD(v103))
        v50 = -2;
      else
        v50 = -1;
    }
    else
    {
      v50 = 0;
    }
  }
  else
  {
    v103 = (int)v41 * (uint64_t)v22 - (int)v42 * (uint64_t)v23;
    if (HIDWORD(v49))
      v50 = 2;
    else
      v50 = 1;
  }
  v51 = 0;
  v104 = v50;
  do
  {
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)__dst, (unsigned int *)((char *)v111 + v51), (uint64_t)v111 + v51);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v94, (unsigned int *)((char *)v105 + v51), (uint64_t)v105 + v51);
    boost::polygon::detail::extended_int<64ul>::add(__src, __dst, v94);
    memcpy(&v96[v51 / 4], __src, 0x104uLL);
    v51 += 260;
  }
  while (v51 != 780);
  v52 = 0;
  v53 = 0xFFFFFFFF00000000;
  for (i = 1; i != 4; ++i)
  {
    v55 = v53 >> 32;
    if (v52 == 130)
      v56 = 0;
    else
      v56 = i;
    v57 = 65 * v56;
    if (!(v52 * 4))
      v55 = 2;
    v58 = 65 * v55;
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v94, (unsigned int *)v111 + 65 * v56, (uint64_t)v105 + 260 * v55);
    boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v93, (unsigned int *)v111 + v58, (uint64_t)v105 + 4 * v57);
    boost::polygon::detail::extended_int<64ul>::dif (__dst, v94, v93);
    memcpy(&__src[v52], __dst, 0x104uLL);
    v53 += 0x100000000;
    v52 += 65;
  }
  v61 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(v91, __src, v96, v59, v60);
  v63 = ldexp(*(long double *)&v61, v62);
  if (v88)
  {
    v64 = 0;
    v65 = 0xFFFFFFFF00000000;
    for (j = 1; j != 4; ++j)
    {
      v67 = v65 >> 32;
      if (v64 == 130)
        v68 = 0;
      else
        v68 = j;
      v69 = 65 * v68;
      if (!(v64 * 4))
        v67 = 2;
      v70 = 65 * v67;
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v94, (unsigned int *)v105 + 65 * v68, (uint64_t)v99 + 260 * v67);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v93, (unsigned int *)v105 + v70, (uint64_t)v99 + 4 * v69);
      boost::polygon::detail::extended_int<64ul>::dif (__dst, v94, v93);
      memcpy(&__src[v64], __dst, 0x104uLL);
      v65 += 0x100000000;
      v64 += 65;
    }
    v73 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(v91, __src, v96, v71, v72);
    *(long double *)(v89 + 8) = ldexp(*(long double *)&v73, v74) / v63;
  }
  if ((v90 & 1) != 0 || v92)
  {
    v75 = 0;
    v98[64] = 0;
    v76 = 0xFFFFFFFF00000000;
    v77 = 1;
    do
    {
      v78 = v76 >> 32;
      if (v75 == 130)
        v79 = 0;
      else
        v79 = v77;
      v80 = 65 * v79;
      if (!(v75 * 4))
        v78 = 2;
      v81 = 65 * v78;
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v94, (unsigned int *)v111 + 65 * v79, (uint64_t)v99 + 260 * v78);
      boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v93, (unsigned int *)v111 + v81, (uint64_t)v99 + 4 * v80);
      boost::polygon::detail::extended_int<64ul>::dif (__dst, v94, v93);
      memcpy(&__src[v75], __dst, 0x104uLL);
      if (v92)
      {
        boost::polygon::detail::extended_int<64ul>::mul((uint64_t)v94, &__src[v75], (uint64_t)v105 + v75 * 4);
        boost::polygon::detail::extended_int<64ul>::add(__dst, v98, v94);
        memcpy(v98, __dst, sizeof(v98));
      }
      v76 += 0x100000000;
      v75 += 65;
      ++v77;
    }
    while (v75 != 195);
    if ((v90 & 1) != 0)
    {
      v84 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval3(v91, __src, v96, v82, v83);
      v82 = ldexp(*(long double *)&v84, v85) / v63;
      *(double *)v89 = v82;
    }
    if (v92)
    {
      v96[195] = 1;
      v96[259] = 1;
      v86 = boost::polygon::detail::robust_sqrt_expr<boost::polygon::detail::extended_int<64ul>,boost::polygon::detail::extended_exponent_fpt<double,boost::polygon::detail::extened_exponent_fpt_traits<double>>,boost::polygon::detail::type_converter_efpt>::eval4(v91, __src, v96, v82, v83);
      *(long double *)(v89 + 16) = ldexp(*(long double *)&v86, v87) / v63;
    }
  }
}

BOOL std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::comparison &,std::__wrap_iter<std::__list_iterator<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,void *> *>>(_BOOL8 result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _BOOL8 v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;

  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v6 = result;
    v7 = v4 >> 1;
    v8 = (_QWORD *)(result + 8 * (v4 >> 1));
    v9 = (_QWORD *)(a2 - 8);
    result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, *(_QWORD *)(a2 - 8) + 16, *v8 + 16);
    if (result)
    {
      v10 = *v9;
      v11 = *v9 + 16;
      do
      {
        v12 = v9;
        v9 = v8;
        *v12 = *v8;
        if (!v7)
          break;
        v7 = (v7 - 1) >> 1;
        v8 = (_QWORD *)(v6 + 8 * v7);
        result = boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a3, v11, *v8 + 16);
      }
      while (result);
      *v9 = v10;
    }
  }
  return result;
}

BOOL boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;

  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a3 + 16);
  if (v3 >= 0)
    v3 = 0x8000000000000000 - v3;
  if (v4 >= 0)
    v4 = 0x8000000000000000 - v4;
  if ((unint64_t)(v3 - v4) <= 0x80)
    v5 = 0;
  else
    v5 = -1;
  if (v3 > (unint64_t)v4)
    v6 = v5;
  else
    v6 = (unint64_t)(v4 - v3) > 0x80;
  if (!v6)
  {
    v7 = *(_QWORD *)(a2 + 8);
    v8 = *(_QWORD *)(a3 + 8);
    if (v7 >= 0)
      v7 = 0x8000000000000000 - v7;
    v9 = 0x8000000000000000 - v8;
    if (v8 < 0)
      v9 = *(_QWORD *)(a3 + 8);
    if (v7 - v9 <= 0x80)
      v10 = 0;
    else
      v10 = -1;
    if (v7 > v9)
      v6 = v10;
    else
      v6 = v9 - v7 > 0x80;
  }
  return v6 == -1;
}

char *boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::_insert_new_edge<int,double>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t v8;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void **v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  __int128 v30;
  _QWORD *v31;
  unsigned int v32;
  int v33;
  unint64_t v34;
  char **v35;
  uint64_t v36;
  unint64_t v37;
  char *v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  char *v46;
  char *v47;
  __int128 v48;
  __int128 v49;
  char *v50;
  unint64_t v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  char *v59;
  char *v60;
  char *v61;
  char *v62;
  char *v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  uint64_t v67;

  v8 = a3;
  v13 = a1[5];
  v11 = (uint64_t)(a1 + 5);
  v12 = v13;
  v15 = *a4;
  v14 = a4[1];
  v16 = *(_QWORD **)(v11 - 8);
  if ((unint64_t)v16 >= v13)
  {
    v19 = (void **)(v11 - 16);
    v20 = *(_QWORD *)(v11 - 16);
    v21 = ((uint64_t)v16 - v20) >> 5;
    v22 = v21 + 1;
    if ((unint64_t)(v21 + 1) >> 59)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v23 = v12 - v20;
    if (v23 >> 4 > v22)
      v22 = v23 >> 4;
    if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFE0)
      v24 = 0x7FFFFFFFFFFFFFFLL;
    else
      v24 = v22;
    if (v24)
      v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>(v11, v24);
    else
      v25 = 0;
    v26 = &v25[32 * v21];
    v27 = &v25[32 * v24];
    *(_QWORD *)v26 = v15;
    *((_QWORD *)v26 + 1) = v14;
    *((_QWORD *)v26 + 2) = 0;
    *((_QWORD *)v26 + 3) = 0;
    v17 = v26 + 32;
    v29 = (char *)a1[3];
    v28 = (char *)a1[4];
    v8 = a3;
    if (v28 != v29)
    {
      do
      {
        v30 = *((_OWORD *)v28 - 1);
        *((_OWORD *)v26 - 2) = *((_OWORD *)v28 - 2);
        *((_OWORD *)v26 - 1) = v30;
        v26 -= 32;
        v28 -= 32;
      }
      while (v28 != v29);
      v28 = (char *)*v19;
    }
    a1[3] = v26;
    a1[4] = v17;
    a1[5] = v27;
    if (v28)
      operator delete(v28);
  }
  else
  {
    *v16 = v15;
    v16[1] = v14;
    v17 = v16 + 4;
    v16[2] = 0;
    v16[3] = 0;
  }
  a1[4] = v17;
  v31 = v17 - 4;
  a5[1] = v17 - 4;
  a6[1] = v17 - 4;
  v32 = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_linear_edge<boost::polygon::detail::site_event<int>>((uint64_t)a1, (int *)a2, (int *)v8);
  v33 = boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::is_primary_edge<boost::polygon::detail::site_event<int>>((uint64_t)a1, (int *)a2, (int *)v8);
  v34 = a1[8];
  v35 = (char **)(a1 + 6);
  if (v33)
    v36 = v32 | 2;
  else
    v36 = v32;
  v37 = a1[7];
  if (v37 >= v34)
  {
    v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v37 - (_QWORD)*v35) >> 4);
    v40 = v39 + 1;
    if (v39 + 1 > 0x555555555555555)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v41 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v34 - (_QWORD)*v35) >> 4);
    if (2 * v41 > v40)
      v40 = 2 * v41;
    if (v41 >= 0x2AAAAAAAAAAAAAALL)
      v42 = 0x555555555555555;
    else
      v42 = v40;
    if (v42)
      v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_edge<double>>>((uint64_t)(a1 + 8), v42);
    else
      v43 = 0;
    v44 = &v43[48 * v39];
    v45 = &v43[48 * v42];
    *(_OWORD *)v44 = 0u;
    *((_OWORD *)v44 + 1) = 0u;
    *((_QWORD *)v44 + 4) = 0;
    *((_QWORD *)v44 + 5) = v36;
    v38 = v44 + 48;
    v47 = (char *)a1[6];
    v46 = (char *)a1[7];
    if (v46 != v47)
    {
      do
      {
        v48 = *((_OWORD *)v46 - 3);
        v49 = *((_OWORD *)v46 - 1);
        *((_OWORD *)v44 - 2) = *((_OWORD *)v46 - 2);
        *((_OWORD *)v44 - 1) = v49;
        *((_OWORD *)v44 - 3) = v48;
        v44 -= 48;
        v46 -= 48;
      }
      while (v46 != v47);
      v46 = *v35;
    }
    a1[6] = v44;
    a1[7] = v38;
    a1[8] = v45;
    if (v46)
      operator delete(v46);
  }
  else
  {
    *(_OWORD *)v37 = 0u;
    *(_OWORD *)(v37 + 16) = 0u;
    *(_QWORD *)(v37 + 32) = 0;
    *(_QWORD *)(v37 + 40) = v36;
    v38 = (char *)(v37 + 48);
  }
  a1[7] = v38;
  *((_QWORD *)v38 - 6) = *a1 + 24 * *(_QWORD *)(a2 + 16);
  v50 = v38 - 48;
  v51 = a1[8];
  if ((unint64_t)v38 >= v51)
  {
    v53 = v8;
    v54 = a1[6];
    v55 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v38[-v54] >> 4);
    if (v55 + 1 > 0x555555555555555)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v56 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v51 - v54) >> 4);
    v57 = 2 * v56;
    if (2 * v56 <= v55 + 1)
      v57 = v55 + 1;
    if (v56 >= 0x2AAAAAAAAAAAAAALL)
      v58 = 0x555555555555555;
    else
      v58 = v57;
    if (v58)
      v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_edge<double>>>((uint64_t)(a1 + 8), v58);
    else
      v59 = 0;
    v60 = &v59[48 * v55];
    v61 = &v59[48 * v58];
    *(_OWORD *)v60 = 0u;
    *((_OWORD *)v60 + 1) = 0u;
    *((_QWORD *)v60 + 4) = 0;
    *((_QWORD *)v60 + 5) = v36;
    v52 = v60 + 48;
    v63 = (char *)a1[6];
    v62 = (char *)a1[7];
    v8 = v53;
    if (v62 != v63)
    {
      do
      {
        v64 = *((_OWORD *)v62 - 3);
        v65 = *((_OWORD *)v62 - 1);
        *((_OWORD *)v60 - 2) = *((_OWORD *)v62 - 2);
        *((_OWORD *)v60 - 1) = v65;
        *((_OWORD *)v60 - 3) = v64;
        v60 -= 48;
        v62 -= 48;
      }
      while (v62 != v63);
      v62 = (char *)a1[6];
    }
    a1[6] = v60;
    a1[7] = v52;
    a1[8] = v61;
    if (v62)
      operator delete(v62);
  }
  else
  {
    *(_OWORD *)v38 = 0u;
    *((_OWORD *)v38 + 1) = 0u;
    *((_QWORD *)v38 + 4) = 0;
    *((_QWORD *)v38 + 5) = v36;
    v52 = v38 + 48;
  }
  a1[7] = v52;
  *((_QWORD *)v52 - 6) = *a1 + 24 * *(_QWORD *)(v8 + 16);
  *((_QWORD *)v38 - 4) = v52 - 48;
  *((_QWORD *)v52 - 5) = v31;
  *((_QWORD *)v52 - 4) = v50;
  a5[4] = v50;
  *((_QWORD *)v38 - 3) = a5;
  v66 = a5[2];
  *(_QWORD *)(v66 + 24) = a6;
  a6[4] = v66;
  v67 = a6[2];
  *(_QWORD *)(v67 + 24) = v52 - 48;
  *((_QWORD *)v52 - 2) = v67;
  return v38 - 48;
}

_QWORD *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,boost::polygon::detail::ordered_queue<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,boost::polygon::voronoi_builder<int,boost::polygon::detail::voronoi_ctype_traits<int>,boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>>::event_comparison_type>::comparison &,std::__wrap_iter<std::__list_iterator<std::pair<boost::polygon::detail::circle_event<double>,std::__map_iterator<std::__tree_iterator<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,std::__tree_node<std::__value_type<boost::polygon::detail::beach_line_node_key<boost::polygon::detail::site_event<int>>,boost::polygon::detail::beach_line_node_data<void,boost::polygon::detail::circle_event<double>>>,void *> *,long>>>,void *> *>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;

  v6 = 0;
  v7 = a3 - 2;
  if (a3 < 2)
    v7 = a3 - 1;
  v8 = v7 >> 1;
  do
  {
    v9 = &a1[v6 + 1];
    v10 = (2 * v6) | 1;
    v11 = 2 * v6 + 2;
    if (v11 < a3
      && boost::polygon::detail::voronoi_predicates<boost::polygon::detail::voronoi_ctype_traits<int>>::event_comparison_predicate<boost::polygon::detail::site_event<int>,boost::polygon::detail::circle_event<double>>::operator()(a2, a1[v6 + 2] + 16, *v9 + 16))
    {
      ++v9;
      v10 = v11;
    }
    *a1 = *v9;
    a1 = v9;
    v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

BOOL boost::polygon::voronoi_diagram_traits<double>::vertex_equality_predicate_type::operator()(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  unint64_t v3;
  uint64_t v4;
  int v5;
  _BOOL4 v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  _BOOL4 v12;

  v3 = *a2;
  v4 = *a3;
  if ((*a2 & 0x8000000000000000) == 0)
    v3 = 0x8000000000000000 - *a2;
  if (v4 >= 0)
    v4 = 0x8000000000000000 - v4;
  if (v3 - v4 <= 0x80)
    v5 = 0;
  else
    v5 = -1;
  if (v3 > v4)
    v6 = v5;
  else
    v6 = v4 - v3 > 0x80;
  if (v6)
    return 0;
  v8 = a2[1];
  v9 = a3[1];
  if (v8 >= 0)
    v8 = 0x8000000000000000 - v8;
  v10 = 0x8000000000000000 - v9;
  if (v9 < 0)
    v10 = a3[1];
  if (v8 - v10 <= 0x80)
    v11 = 0;
  else
    v11 = -1;
  if (v8 > v10)
    v12 = v11;
  else
    v12 = v10 - v8 > 0x80;
  return !v12;
}

void boost::polygon::voronoi_diagram<double,boost::polygon::voronoi_diagram_traits<double>>::remove_edge(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = (_QWORD *)a2[2];
  v3 = *(_QWORD **)(v2[4] + 16);
  if (v3 != v2)
  {
    v4 = a2[1];
    v5 = *(_QWORD **)(v2[4] + 16);
    do
    {
      v5[1] = v4;
      v5 = *(_QWORD **)(v5[4] + 16);
    }
    while (v5 != v2);
  }
  v6 = v2[3];
  v7 = *(_QWORD *)(v2[2] + 24);
  v8 = *(_QWORD *)(*(_QWORD *)(a2[4] + 16) + 16);
  *(_QWORD *)(v8 + 24) = v7;
  *(_QWORD *)(v7 + 32) = v8;
  v9 = v3[2];
  *(_QWORD *)(v6 + 32) = v9;
  *(_QWORD *)(v9 + 24) = v6;
}

void std::vector<std::vector<boost::polygon::segment_data<double>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<boost::polygon::segment_data<double>>>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::vector<boost::polygon::segment_data<double>>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(void **)(v4 - 24);
      v4 -= 24;
      v5 = v6;
      if (v6)
      {
        *(_QWORD *)(v2 - 16) = v5;
        operator delete(v5);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

uint64_t std::vector<boost::polygon::segment_data<double>>::__push_back_slow_path<boost::polygon::segment_data<double> const&>(uint64_t *a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  void *__p;
  char *v15;
  char *v16;
  char *v17;
  _QWORD *v18;

  v3 = *a1;
  v4 = (a1[1] - *a1) >> 5;
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59)
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = a1[2] - v3;
  if (v8 >> 4 > v5)
    v5 = v8 >> 4;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0)
    v9 = 0x7FFFFFFFFFFFFFFLL;
  else
    v9 = v5;
  v18 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[32 * v4];
  __p = v10;
  v15 = v11;
  v17 = &v10[32 * v9];
  *(_OWORD *)v11 = 0u;
  *((_OWORD *)v11 + 1) = 0u;
  *(_QWORD *)v11 = *a2;
  *((_QWORD *)v11 + 1) = a2[1];
  *((_QWORD *)v11 + 2) = a2[2];
  *((_QWORD *)v11 + 3) = a2[3];
  v16 = v11 + 32;
  std::vector<boost::polygon::segment_data<double>>::__swap_out_circular_buffer(a1, &__p);
  v12 = a1[1];
  if (v16 != v15)
    v16 += (v15 - v16 + 31) & 0xFFFFFFFFFFFFFFE0;
  if (__p)
    operator delete(__p);
  return v12;
}

void sub_217A89CB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<boost::polygon::segment_data<double>>::__swap_out_circular_buffer(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = (_QWORD *)*result;
  v2 = (_QWORD *)result[1];
  v4 = (_QWORD *)a2[1];
  if (v2 != (_QWORD *)*result)
  {
    do
    {
      *((_OWORD *)v4 - 2) = 0uLL;
      *((_OWORD *)v4 - 1) = 0uLL;
      v4 -= 4;
      v5 = *(v2 - 4);
      v2 -= 4;
      *v4 = v5;
      v4[1] = v2[1];
      v4[2] = v2[2];
      v4[3] = v2[3];
    }
    while (v2 != v3);
  }
  a2[1] = v4;
  v6 = (_QWORD *)*result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::vector<std::vector<boost::polygon::segment_data<double>>>::__push_back_slow_path<std::vector<boost::polygon::segment_data<double>> const&>(uint64_t *a1, _QWORD **a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _QWORD v14[2];
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_cell<double>>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v15 = v11;
  v16 = &v10[24 * v9];
  *(_QWORD *)v11 = 0;
  *((_QWORD *)v11 + 1) = 0;
  *((_QWORD *)v11 + 2) = 0;
  std::vector<boost::polygon::segment_data<double>>::__init_with_size[abi:ne180100]<boost::polygon::segment_data<double>*,boost::polygon::segment_data<double>*>(v11, *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 5);
  v15 += 24;
  std::vector<std::vector<boost::polygon::segment_data<double>>>::__swap_out_circular_buffer(a1, v14);
  v12 = a1[1];
  std::__split_buffer<std::vector<boost::polygon::segment_data<double>>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_217A89E6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<boost::polygon::segment_data<double>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<boost::polygon::segment_data<double>>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<boost::polygon::segment_data<double>>>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<boost::polygon::segment_data<double>>>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(_QWORD *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      v7 = *((_QWORD *)&v14 + 1) - 24;
      *((_QWORD *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<boost::polygon::segment_data<double>>>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<boost::polygon::segment_data<double>>>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<boost::polygon::segment_data<double>>>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<boost::polygon::segment_data<double>>>,std::reverse_iterator<std::vector<boost::polygon::segment_data<double>>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 24;
  }
}

uint64_t std::__split_buffer<std::vector<boost::polygon::segment_data<double>>>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<std::vector<boost::polygon::segment_data<double>>>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<std::vector<boost::polygon::segment_data<double>>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    v5 = *(void **)(v2 - 24);
    *(_QWORD *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

double std::vector<boost::polygon::segment_data<double>>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = (_QWORD *)(a2 + v4 - a4);
  if ((unint64_t)v5 >= a3)
  {
    v7 = *(_QWORD *)(a1 + 8);
  }
  else
  {
    v6 = 0uLL;
    v7 = *(_QWORD *)(a1 + 8);
    do
    {
      *(_OWORD *)v7 = 0uLL;
      *(_OWORD *)(v7 + 16) = 0uLL;
      *(_QWORD *)v7 = *v5;
      *(_QWORD *)(v7 + 8) = v5[1];
      *(_QWORD *)(v7 + 16) = v5[2];
      *(_QWORD *)(v7 + 24) = v5[3];
      v7 += 32;
      v5 += 4;
    }
    while ((unint64_t)v5 < a3);
  }
  *(_QWORD *)(a1 + 8) = v7;
  if (v4 != a4)
  {
    v8 = 32 * ((v4 - a4) >> 5);
    v9 = a2 - 16;
    v10 = (_QWORD *)(v4 - 16);
    do
    {
      *(v10 - 2) = *(_QWORD *)(v9 + v8 - 16);
      *(v10 - 1) = *(_QWORD *)(v9 + v8 - 8);
      *v10 = *(_QWORD *)(v9 + v8);
      *(_QWORD *)&v6 = *(_QWORD *)(v9 + v8 + 8);
      v10[1] = v6;
      v10 -= 4;
      v8 -= 32;
    }
    while (v8);
  }
  return *(double *)&v6;
}

_QWORD *std::vector<boost::polygon::segment_data<double>>::__swap_out_circular_buffer(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *result;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;

  result = (_QWORD *)a2[1];
  v5 = (_QWORD *)*a1;
  v6 = result;
  if ((_QWORD *)*a1 != a3)
  {
    v7 = a3;
    v6 = (_QWORD *)a2[1];
    do
    {
      *((_OWORD *)v6 - 2) = 0uLL;
      *((_OWORD *)v6 - 1) = 0uLL;
      v6 -= 4;
      v8 = *(v7 - 4);
      v7 -= 4;
      *v6 = v8;
      v6[1] = v7[1];
      v6[2] = v7[2];
      v6[3] = v7[3];
    }
    while (v7 != v5);
  }
  a2[1] = v6;
  v9 = (_QWORD *)a1[1];
  v10 = a2[2];
  if (v9 != a3)
  {
    do
    {
      *(_OWORD *)v10 = 0uLL;
      *(_OWORD *)(v10 + 16) = 0uLL;
      *(_QWORD *)v10 = *a3;
      *(_QWORD *)(v10 + 8) = a3[1];
      *(_QWORD *)(v10 + 16) = a3[2];
      *(_QWORD *)(v10 + 24) = a3[3];
      v10 += 32;
      a3 += 4;
    }
    while (a3 != v9);
    v6 = (_QWORD *)a2[1];
  }
  a2[2] = v10;
  v11 = (_QWORD *)*a1;
  *a1 = v6;
  a2[1] = v11;
  v12 = a1[1];
  a1[1] = a2[2];
  a2[2] = v12;
  v13 = a1[2];
  a1[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

void sub_217A8A4A0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A8A660(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A8A724(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217A8A904(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id PerformXPathQuery(xmlDoc *a1, void *a2)
{
  id v3;
  xmlXPathContext *v4;
  xmlXPathContext *v5;
  uint64_t v6;
  xmlXPathObject *v7;
  int *v8;
  void *v9;
  uint64_t v10;
  void *v11;

  v3 = a2;
  v4 = xmlXPathNewContext(a1);
  if (!v4)
  {
    NSLog((NSString *)CFSTR("Unable to create XPath context."));
LABEL_13:
    v9 = 0;
    goto LABEL_14;
  }
  v5 = v4;
  xmlXPathRegisterNs(v4, (const xmlChar *)"svg", (const xmlChar *)"http://www.w3.org/2000/svg");
  v6 = MEMORY[0x219A15F4C](objc_msgSend(objc_retainAutorelease(v3), "cStringUsingEncoding:", 4), v5);
  if (!v6)
  {
    NSLog((NSString *)CFSTR("Unable to evaluate XPath."));
    goto LABEL_13;
  }
  v7 = (xmlXPathObject *)v6;
  v8 = *(int **)(v6 + 8);
  if (!v8)
  {
    NSLog((NSString *)CFSTR("Nodes was nil."));
    goto LABEL_13;
  }
  objc_msgSend(MEMORY[0x24BDBCEB8], "array");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  if (*v8 >= 1)
  {
    v10 = 0;
    do
    {
      DictionaryForNode(*(_QWORD **)(*((_QWORD *)v8 + 1) + 8 * v10), 0);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      if (v11)
        objc_msgSend(v9, "addObject:", v11);

      ++v10;
    }
    while (v10 < *v8);
  }
  xmlXPathFreeObject(v7);
  xmlXPathFreeContext(v5);
LABEL_14:

  return v9;
}

id DictionaryForNode(_QWORD *a1, void *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  _QWORD *v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  id v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  id v18;
  void *v20;
  void *v21;
  int v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  id v27;
  void *v28;
  id v29;

  v3 = a2;
  objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = a1[2];
  if (v5)
  {
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithCString:encoding:", v5, 4);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "setObject:forKey:", v6, CFSTR("nodeName"));

  }
  if ((unint64_t)(a1[10] + 1) >= 2)
  {
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithCString:encoding:");
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "objectForKey:", CFSTR("nodeName"));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = objc_msgSend(v21, "isEqual:", CFSTR("text"));

    if (v3 && v22)
    {
      objc_msgSend(MEMORY[0x24BDD14A8], "whitespaceAndNewlineCharacterSet");
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v20, "stringByTrimmingCharactersInSet:", v23);
      v24 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(v3, "objectForKey:", CFSTR("nodeContent"));
      v25 = (void *)objc_claimAutoreleasedReturnValue();
      v26 = v25;
      if (v25)
      {
        objc_msgSend(v25, "stringByAppendingString:", v24);
        v27 = (id)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        v27 = v24;
      }
      v28 = v27;
      objc_msgSend(v3, "setObject:forKey:", v27, CFSTR("nodeContent"));

      v18 = 0;
      goto LABEL_22;
    }
    objc_msgSend(v4, "setObject:forKey:", v20, CFSTR("nodeContent"));

  }
  v7 = (_QWORD *)a1[11];
  if (v7)
  {
    v29 = v3;
    objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    do
    {
      objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithCString:encoding:", v7[2], 4);
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      v11 = v7[3];
      if (v11)
        v12 = (id)DictionaryForNode(v11, v9);
      if (v10)
      {
        objc_msgSend(v9, "objectForKey:", CFSTR("nodeContent"));
        v13 = (void *)objc_claimAutoreleasedReturnValue();

        if (v13)
        {
          objc_msgSend(v9, "objectForKey:", CFSTR("nodeContent"));
          v14 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v8, "setObject:forKey:", v14, v10);

        }
      }
      v7 = (_QWORD *)v7[6];

    }
    while (v7);
    objc_msgSend(v4, "setObject:forKey:", v8, CFSTR("nodeAttributes"));

    v3 = v29;
  }
  v15 = a1[3];
  if (v15)
  {
    objc_msgSend(MEMORY[0x24BDBCEB8], "array");
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    do
    {
      DictionaryForNode(v15, v4);
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      if (v17)
        objc_msgSend(v16, "addObject:", v17);
      v15 = *(_QWORD *)(v15 + 48);

    }
    while (v15);
    if (objc_msgSend(v16, "count"))
      objc_msgSend(v4, "setObject:forKey:", v16, CFSTR("nodeChildArray"));

  }
  v18 = v4;
LABEL_22:

  return v18;
}

id PerformXMLXPathQuery(void *a1, void *a2)
{
  id v3;
  id v4;
  unint64_t v5;
  xmlDoc *Memory;
  xmlDoc *v7;
  void *v8;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  v3 = a1;
  v4 = a2;
  v5 = objc_msgSend(v3, "length");
  if (v5 >> 31)
  {
    objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSArray * _Nullable PerformXMLXPathQuery(NSData * _Nonnull __strong, NSString * _Nonnull __strong)");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBrushStrokeLoader.m");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, v12, 689, CFSTR("Out-of-bounds type assignment failed"));

    objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSArray * _Nullable PerformXMLXPathQuery(NSData * _Nonnull __strong, NSString * _Nonnull __strong)");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDBrushStrokeLoader.m");
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, v15, 690, CFSTR("Document too long to load with xmlReadMemory."));

    goto LABEL_5;
  }
  Memory = xmlReadMemory((const char *)objc_msgSend(objc_retainAutorelease(v3), "bytes"), v5, "", 0, 1);
  if (!Memory)
  {
    NSLog((NSString *)CFSTR("Unable to parse."));
LABEL_5:
    v8 = 0;
    goto LABEL_6;
  }
  v7 = Memory;
  PerformXPathQuery(Memory, v4);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  xmlFreeDoc(v7);
LABEL_6:

  return v8;
}

uint64_t TSDGPUDataBufferDataTypeSize(uint64_t a1)
{
  uint64_t result;
  void *v2;
  void *v3;
  void *v4;

  switch(a1)
  {
    case 0:
      objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v2 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "size_t TSDGPUDataBufferDataTypeSize(TSDGPUDataBufferDataType)");
      v3 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m");
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, v4, 42, CFSTR("Unknown TSDGPUDataBufferDataType!"));

      result = 0;
      break;
    case 1:
    case 2:
      result = 1;
      break;
    case 3:
    case 4:
      result = 2;
      break;
    case 5:
      result = 4;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t TSDGPUUpdateDataPointerAtIndex(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return a1[3] + a1[4] + a1[5] * a2 + a1[10] * a3;
}

float TSDGPUDataBufferMetalfloatWithDataType(__int16 *a1, uint64_t a2, int a3, float a4)
{
  float v4;
  void *v5;
  void *v6;
  void *v7;
  float v8;
  int v9;
  float v10;
  float v11;

  v4 = -1.0;
  switch(a2)
  {
    case 0:
      objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "float TSDGPUDataBufferMetalfloatWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL)");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, v7, 71, CFSTR("Unknown data type!"));

      return v4;
    case 1:
      LOBYTE(a4) = *(_BYTE *)a1;
      v8 = (float)LODWORD(a4);
      v9 = 1123942400;
      goto LABEL_5;
    case 2:
      LOBYTE(a4) = *(_BYTE *)a1;
      v8 = (float)LODWORD(a4);
      v9 = 1132396544;
LABEL_5:
      v10 = *(float *)&v9;
      goto LABEL_8;
    case 3:
      v8 = (float)*a1;
      v10 = 32767.0;
      goto LABEL_8;
    case 4:
      LOWORD(a4) = *a1;
      v8 = (float)LODWORD(a4);
      v10 = 65535.0;
LABEL_8:
      v11 = v8 / v10;
      if (a3)
        v4 = v11;
      else
        v4 = v8;
      break;
    case 5:
      v4 = *(float *)a1;
      break;
    default:
      return v4;
  }
  return v4;
}

void TSDGPUDataBufferSetMetalfloatWithDataType(_BYTE *a1, uint64_t a2, int a3, float a4)
{
  void *v4;
  void *v5;
  float v6;
  float v7;
  float v8;
  id v9;

  switch(a2)
  {
    case 0:
      objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v9 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSDGPUDataBufferSetMetalfloatWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL, float)");
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v4, v5, 99, CFSTR("Unknown data type!"));

      return;
    case 1:
      v6 = 127.0;
      goto LABEL_5;
    case 2:
      v6 = 255.0;
LABEL_5:
      if (a3)
        a4 = a4 * v6;
      *a1 = llroundf(a4);
      return;
    case 3:
      v7 = 32767.0;
      goto LABEL_10;
    case 4:
      v7 = 65535.0;
LABEL_10:
      v8 = a4 * v7;
      if (a3)
        a4 = v8;
      *(_WORD *)a1 = llroundf(a4);
      break;
    case 5:
      *(float *)a1 = a4;
      break;
    default:
      return;
  }
}

float TSDGPUDataBufferMetalPoint2DWithDataType(__int16 *a1, uint64_t a2, int a3, float a4)
{
  float v4;
  void *v5;
  void *v6;
  void *v7;
  float v8;
  float v9;
  float v10;

  v4 = 0.0;
  switch(a2)
  {
    case 0:
      objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSDMetalPoint2D TSDGPUDataBufferMetalPoint2DWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL)");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, v7, 123, CFSTR("Unknown data type!"));

      break;
    case 1:
      LOBYTE(a4) = *(_BYTE *)a1;
      v8 = (float)LODWORD(a4);
      v9 = 127.0;
      goto LABEL_5;
    case 2:
      LOBYTE(a4) = *(_BYTE *)a1;
      v8 = (float)LODWORD(a4);
      v9 = 255.0;
LABEL_5:
      if (a3)
        v4 = v8 / v9;
      else
        v4 = v8;
      break;
    case 3:
      if (a3)
        v4 = (float)*a1 / 32767.0;
      else
        v4 = (float)*a1;
      break;
    case 4:
      LOWORD(a4) = *a1;
      v10 = (float)LODWORD(a4);
      if (a3)
        v4 = v10 / 65535.0;
      else
        v4 = v10;
      break;
    case 5:
      v4 = *(float *)a1;
      break;
    default:
      return v4;
  }
  return v4;
}

void TSDGPUDataBufferSetMetalPoint2DWithDataType(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  void *v5;
  void *v6;
  float v7;
  float v8;
  __int16 v9;
  float v10;
  unsigned __int16 v11;
  float v12;
  unsigned int v13;
  unsigned int v14;
  float v15;
  id v16;

  switch(a2)
  {
    case 0:
      objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v16 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSDGPUDataBufferSetMetalPoint2DWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL, TSDMetalPoint2D)");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v5, v6, 151, CFSTR("Unknown data type!"));

      return;
    case 1:
      v7 = 127.0;
      goto LABEL_5;
    case 2:
      v7 = 255.0;
LABEL_5:
      v8 = v7;
      if (a3)
        a4 = a4 * v7;
      v9 = llroundf(a4);
      v10 = a5 * v8;
      if (!a3)
        v10 = a5;
      *(_WORD *)a1 = v9 | ((unsigned __int16)llroundf(v10) << 8);
      return;
    case 3:
      if (a3)
        a4 = a4 * 32767.0;
      v11 = llroundf(a4);
      v12 = a5 * 32767.0;
      if (!a3)
        v12 = a5;
      v13 = v11 | ((unsigned __int16)llroundf(v12) << 16);
      goto LABEL_20;
    case 4:
      if (a3)
        a4 = a4 * 65535.0;
      v14 = llroundf(a4);
      v15 = a5 * 65535.0;
      if (!a3)
        v15 = a5;
      v13 = v14 | (llroundf(v15) << 16);
LABEL_20:
      *(_DWORD *)a1 = v13;
      break;
    case 5:
      *(float *)a1 = a4;
      *(float *)(a1 + 4) = a5;
      break;
    default:
      return;
  }
}

float TSDGPUDataBufferMetalPoint3DWithDataType(__int16 *a1, uint64_t a2, int a3, float a4)
{
  float v4;
  void *v5;
  void *v6;
  void *v7;
  float v8;
  float v9;
  float v10;

  v4 = 0.0;
  switch(a2)
  {
    case 0:
      objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSDMetalPoint3D TSDGPUDataBufferMetalPoint3DWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL)");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, v7, 175, CFSTR("Unknown data type!"));

      break;
    case 1:
      LOBYTE(a4) = *(_BYTE *)a1;
      v8 = (float)LODWORD(a4);
      v9 = 127.0;
      goto LABEL_5;
    case 2:
      LOBYTE(a4) = *(_BYTE *)a1;
      v8 = (float)LODWORD(a4);
      v9 = 255.0;
LABEL_5:
      if (a3)
        v4 = v8 / v9;
      else
        v4 = v8;
      break;
    case 3:
      if (a3)
        v4 = (float)*a1 / 32767.0;
      else
        v4 = (float)*a1;
      break;
    case 4:
      LOWORD(a4) = *a1;
      v10 = (float)LODWORD(a4);
      if (a3)
        v4 = v10 / 65535.0;
      else
        v4 = v10;
      break;
    case 5:
      v4 = *(float *)a1;
      break;
    default:
      return v4;
  }
  return v4;
}

void TSDGPUDataBufferSetMetalPoint3DWithDataType(uint64_t a1, uint64_t a2, int a3, float a4, float a5, float a6)
{
  void *v6;
  void *v7;
  float v8;
  float v9;
  __int16 v10;
  float v11;
  __int16 v12;
  float v13;
  unsigned __int16 v14;
  float v15;
  unsigned __int16 v16;
  float v17;
  __int16 v18;
  int v19;
  unsigned int v20;
  float v21;
  unsigned int v22;
  float v23;
  id v24;

  switch(a2)
  {
    case 0:
      objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v24 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSDGPUDataBufferSetMetalPoint3DWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL, TSDMetalPoint3D)");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v24, "handleFailureInFunction:file:lineNumber:description:", v6, v7, 203, CFSTR("Unknown data type!"));

      return;
    case 1:
      v8 = 127.0;
      goto LABEL_5;
    case 2:
      v8 = 255.0;
LABEL_5:
      v9 = v8;
      if (a3)
        a4 = a4 * v8;
      v10 = llroundf(a4);
      v11 = a5 * v9;
      if (!a3)
        v11 = a5;
      v12 = llroundf(v11);
      v13 = a6 * v9;
      if (!a3)
        v13 = a6;
      *(_BYTE *)(a1 + 2) = llroundf(v13);
      *(_WORD *)a1 = v10 | (v12 << 8);
      return;
    case 3:
      if (a3)
        a4 = a4 * 32767.0;
      v14 = llroundf(a4);
      v15 = a5 * 32767.0;
      if (!a3)
        v15 = a5;
      v16 = llroundf(v15);
      v17 = a6 * 32767.0;
      if (!a3)
        v17 = a6;
      v18 = llroundf(v17);
      v19 = v14 | (v16 << 16);
      goto LABEL_26;
    case 4:
      if (a3)
        a4 = a4 * 65535.0;
      v20 = llroundf(a4);
      v21 = a5 * 65535.0;
      if (!a3)
        v21 = a5;
      v22 = llroundf(v21);
      v23 = a6 * 65535.0;
      if (!a3)
        v23 = a6;
      v18 = llroundf(v23);
      v19 = v20 | (v22 << 16);
LABEL_26:
      *(_DWORD *)a1 = v19;
      *(_WORD *)(a1 + 4) = v18;
      break;
    case 5:
      *(float *)a1 = a4;
      *(float *)(a1 + 4) = a5;
      *(float *)(a1 + 8) = a6;
      break;
    default:
      return;
  }
}

int8x16_t TSDGPUDataBufferMetalPoint4DWithDataType(int16x4_t *a1, uint64_t a2, unsigned int a3)
{
  int8x16_t result;
  void *v4;
  void *v5;
  void *v6;
  float32x4_t v7;
  unsigned int v8;

  result = (int8x16_t)TSDMetalPoint4DZero;
  switch(a2)
  {
    case 0:
      objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSDMetalPoint4D TSDGPUDataBufferMetalPoint4DWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL)");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, v6, 227, CFSTR("Unknown data type!"));

      return (int8x16_t)TSDMetalPoint4DZero;
    case 1:
      result.i32[0] = a1->i32[0];
      v7 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)result.i8)));
      v8 = 1123942400;
      goto LABEL_7;
    case 2:
      result.i32[0] = a1->i32[0];
      v7 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)result.i8)));
      v8 = 1132396544;
      goto LABEL_7;
    case 3:
      v7 = vcvtq_f32_s32(vmovl_s16(*a1));
      v8 = 1191181824;
      goto LABEL_7;
    case 4:
      v7 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*a1));
      v8 = 1199570688;
LABEL_7:
      result = vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(a3)), 0x1FuLL)), (int8x16_t)vdivq_f32(v7, (float32x4_t)vdupq_n_s32(v8)), (int8x16_t)v7);
      break;
    case 5:
      result = *(int8x16_t *)a1->i8;
      break;
    default:
      return result;
  }
  return result;
}

void TSDGPUDataBufferSetMetalPoint4DWithDataType(uint64_t a1, uint64_t a2, int a3, float a4, float a5, float a6, float a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  float v12;
  float v13;
  unsigned int v14;
  float v15;
  unsigned int v16;
  float v17;
  unsigned int v18;
  float v19;
  unsigned __int16 v20;
  float v21;
  unsigned __int16 v22;
  float v23;
  unsigned __int16 v24;
  float v25;
  unint64_t v26;
  float v27;
  float v28;
  float v29;
  id v30;

  switch(a2)
  {
    case 0:
      objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v30 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSDGPUDataBufferSetMetalPoint4DWithDataType(uint8_t *, TSDGPUDataBufferDataType, BOOL, TSDMetalPoint4D)");
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUDataBuffer.m");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v30, "handleFailureInFunction:file:lineNumber:description:", v10, v11, 255, CFSTR("Unknown data type!"));

      break;
    case 1:
      v12 = 127.0;
      goto LABEL_5;
    case 2:
      v12 = 255.0;
LABEL_5:
      v13 = v12;
      if (a3)
        a4 = a4 * v12;
      v14 = llroundf(a4);
      v15 = a5 * v13;
      if (!a3)
        v15 = a5;
      v16 = llroundf(v15);
      v17 = a6 * v13;
      if (!a3)
        v17 = a6;
      v18 = llroundf(v17);
      v19 = a7 * v13;
      if (!a3)
        v19 = a7;
      *(_DWORD *)a1 = (v18 << 16) | (llroundf(v19) << 24) | (v16 << 8) | v14;
      break;
    case 3:
      if (a3)
        a4 = a4 * 32767.0;
      v20 = llroundf(a4);
      v21 = a5 * 32767.0;
      if (!a3)
        v21 = a5;
      v22 = llroundf(v21);
      v23 = a6 * 32767.0;
      if (!a3)
        v23 = a6;
      v24 = llroundf(v23);
      v25 = a7 * 32767.0;
      if (!a3)
        v25 = a7;
      LODWORD(v9) = llroundf(v25);
      *(_QWORD *)a1 = ((unint64_t)v24 << 32) | (v9 << 48) | ((unint64_t)v22 << 16) | v20;
      break;
    case 4:
      v26 = (unint64_t)&p_configureOrientationAndSizeFromImageSource_andImage____orientationMapping[2];
      if (a3)
        a4 = a4 * 65535.0;
      LODWORD(v26) = llroundf(a4);
      v27 = a5 * 65535.0;
      if (!a3)
        v27 = a5;
      LODWORD(v7) = llroundf(v27);
      v28 = a6 * 65535.0;
      if (!a3)
        v28 = a6;
      LODWORD(v8) = llroundf(v28);
      v29 = a7 * 65535.0;
      if (!a3)
        v29 = a7;
      LODWORD(v9) = llroundf(v29);
      *(_QWORD *)a1 = (v8 << 32) | (v9 << 48) | (v7 << 16) | v26;
      break;
    case 5:
      *(float *)a1 = a4;
      *(float *)(a1 + 4) = a5;
      *(float *)(a1 + 8) = a6;
      *(float *)(a1 + 12) = a7;
      break;
    default:
      return;
  }
}

void TSDGPUUpdateDataSetMetalFloatAtIndex(uint64_t a1, uint64_t a2, float a3)
{
  TSDGPUDataBufferSetMetalfloatWithDataType((_BYTE *)(*(_QWORD *)(a1 + 24) + *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 40) * a2), *(_QWORD *)a1, *(unsigned __int8 *)(a1 + 16), a3);
}

float TSDGPUUpdateDataMetalPoint2DAtIndex(uint64_t a1, uint64_t a2, float a3)
{
  return TSDGPUDataBufferMetalPoint2DWithDataType((__int16 *)(*(_QWORD *)(a1 + 24) + *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 40) * a2), *(_QWORD *)a1, *(unsigned __int8 *)(a1 + 16), a3);
}

void TSDGPUUpdateDataSetMetalPoint2DAtIndex(uint64_t a1, uint64_t a2, float a3, float a4)
{
  TSDGPUDataBufferSetMetalPoint2DWithDataType(*(_QWORD *)(a1 + 24) + *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 40) * a2, *(_QWORD *)a1, *(unsigned __int8 *)(a1 + 16), a3, a4);
}

float TSDGPUUpdateDataMetalPoint3DAtIndex(uint64_t a1, uint64_t a2, float a3)
{
  return TSDGPUDataBufferMetalPoint3DWithDataType((__int16 *)(*(_QWORD *)(a1 + 24) + *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 40) * a2), *(_QWORD *)a1, *(unsigned __int8 *)(a1 + 16), a3);
}

void TSDGPUUpdateDataSetMetalPoint3DAtIndex(uint64_t a1, uint64_t a2, float a3, float a4, float a5)
{
  TSDGPUDataBufferSetMetalPoint3DWithDataType(*(_QWORD *)(a1 + 24) + *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 40) * a2, *(_QWORD *)a1, *(unsigned __int8 *)(a1 + 16), a3, a4, a5);
}

void TSDGPUUpdateDataSetMetalPoint4DAtIndex(uint64_t a1, uint64_t a2, float a3, float a4, float a5, float a6)
{
  TSDGPUDataBufferSetMetalPoint4DWithDataType(*(_QWORD *)(a1 + 24) + *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 40) * a2, *(_QWORD *)a1, *(unsigned __int8 *)(a1 + 16), a3, a4, a5, a6);
}

uint64_t TSDGLGetRenderQueue()
{
  if (TSDGLGetRenderQueue_pred != -1)
    dispatch_once(&TSDGLGetRenderQueue_pred, &__block_literal_global_46);
  return TSDGLGetRenderQueue_renderQueue;
}

void TSDTransform3DMakeProjection(uint64_t a1@<X8>, double a2@<D0>, double a3@<D1>, double a4@<D2>, double a5@<D3>)
{
  long double v9;
  _OWORD *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  if (a2 <= 0.0)
  {
    v10 = (_OWORD *)MEMORY[0x24BDE5598];
    v11 = *(_OWORD *)(MEMORY[0x24BDE5598] + 80);
    *(_OWORD *)(a1 + 64) = *(_OWORD *)(MEMORY[0x24BDE5598] + 64);
    *(_OWORD *)(a1 + 80) = v11;
    v12 = v10[7];
    *(_OWORD *)(a1 + 96) = v10[6];
    *(_OWORD *)(a1 + 112) = v12;
    v13 = v10[1];
    *(_OWORD *)a1 = *v10;
    *(_OWORD *)(a1 + 16) = v13;
    v14 = v10[3];
    *(_OWORD *)(a1 + 32) = v10[2];
    *(_OWORD *)(a1 + 48) = v14;
  }
  else
  {
    v9 = 1.0 / tan(a2 * 0.5);
    *(long double *)a1 = v9 / a3;
    *(_OWORD *)(a1 + 8) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
    *(long double *)(a1 + 40) = v9;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(double *)(a1 + 80) = a5 / (a4 - a5);
    *(_QWORD *)(a1 + 96) = 0;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 88) = 0xBFF0000000000000;
    *(double *)(a1 + 112) = a4 * a5 / (a4 - a5);
    *(_QWORD *)(a1 + 120) = 0;
  }
}

CGFloat TSDTransform3DMakeProjectionWithSlideSubrect@<D0>(uint64_t a1@<X8>, CGFloat a2@<D0>, CGFloat a3@<D1>, CGFloat a4@<D2>, CGFloat a5@<D3>, double a6@<D4>, double a7@<D5>, CGFloat a8@<D6>, CGFloat a9@<D7>, double a10, double a11, double a12)
{
  double v17;
  double v18;
  CGFloat v19;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double MinX;
  double MaxX;
  double MinY;
  CGFloat MaxY;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  CGFloat result;
  __int128 v36;
  CGFloat v37;
  CGFloat v38;
  CATransform3D b;
  CATransform3D a;
  CATransform3D v41;
  CGRect v42;
  CGRect v43;
  CGRect v44;
  CGRect v45;

  v17 = TSDCenterOfRect(a2, a3, a4, a5);
  v18 = TSDSubtractPoints(a6, a7, v17);
  v37 = v19;
  v38 = v18;
  v42.origin.x = TSDMultiplyRectScalar(v18, v19, a8, a9, a10 / a12);
  x = v42.origin.x;
  y = v42.origin.y;
  width = v42.size.width;
  height = v42.size.height;
  MinX = CGRectGetMinX(v42);
  v43.origin.x = x;
  v43.origin.y = y;
  v43.size.width = width;
  v43.size.height = height;
  MaxX = CGRectGetMaxX(v43);
  v44.origin.x = x;
  v44.origin.y = y;
  v44.size.width = width;
  v44.size.height = height;
  MinY = CGRectGetMinY(v44);
  v45.origin.x = x;
  v45.origin.y = y;
  v45.size.width = width;
  v45.size.height = height;
  MaxY = CGRectGetMaxY(v45);
  *(double *)a1 = (a10 + a10) / (MaxX - MinX);
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(double *)(a1 + 40) = (a10 + a10) / (MaxY - MinY);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(double *)(a1 + 64) = (MinX + MaxX) / (MaxX - MinX);
  *(double *)(a1 + 72) = (MinY + MaxY) / (MaxY - MinY);
  *(double *)(a1 + 80) = (a10 + a11) / (a10 - a11);
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 88) = 0xBFF0000000000000;
  *(double *)(a1 + 112) = (a11 + a11) * a10 / (a10 - a11);
  *(_QWORD *)(a1 + 120) = 0;
  CATransform3DMakeTranslation(&a, v38, v37, 0.0);
  v28 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&b.m31 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&b.m33 = v28;
  v29 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)&b.m41 = *(_OWORD *)(a1 + 96);
  *(_OWORD *)&b.m43 = v29;
  v30 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&b.m11 = *(_OWORD *)a1;
  *(_OWORD *)&b.m13 = v30;
  v31 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&b.m21 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)&b.m23 = v31;
  CATransform3DConcat(&v41, &a, &b);
  v32 = *(_OWORD *)&v41.m33;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v41.m31;
  *(_OWORD *)(a1 + 80) = v32;
  v33 = *(_OWORD *)&v41.m43;
  *(_OWORD *)(a1 + 96) = *(_OWORD *)&v41.m41;
  *(_OWORD *)(a1 + 112) = v33;
  v34 = *(_OWORD *)&v41.m13;
  *(_OWORD *)a1 = *(_OWORD *)&v41.m11;
  *(_OWORD *)(a1 + 16) = v34;
  result = v41.m21;
  v36 = *(_OWORD *)&v41.m23;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v41.m21;
  *(_OWORD *)(a1 + 48) = v36;
  return result;
}

double TSDTransform3DMakeOrtho@<D0>(uint64_t a1@<X8>, double a2@<D0>, double a3@<D1>, double a4@<D2>, double a5@<D3>, double a6@<D4>, double a7@<D5>)
{
  double result;

  *(double *)a1 = 2.0 / (a3 - a2);
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(double *)(a1 + 40) = 2.0 / (a5 - a4);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(double *)(a1 + 80) = -2.0 / (a7 - a6);
  *(_QWORD *)(a1 + 88) = 0;
  *(double *)(a1 + 96) = -(a2 + a3) / (a3 - a2);
  *(double *)(a1 + 104) = -(a4 + a5) / (a5 - a4);
  result = -(a6 + a7) / (a7 - a6);
  *(double *)(a1 + 112) = result;
  *(_QWORD *)(a1 + 120) = 0x3FF0000000000000;
  return result;
}

uint64_t p_URLFromPathname(void *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;

  v2 = (void *)objc_msgSend(MEMORY[0x24BDD1580], "defaultManager");
  v3 = (void *)objc_msgSend(a1, "stringByDeletingPathExtension");
  v4 = objc_msgSend(v3, "stringByAppendingPathExtension:", CFSTR("png"));
  if (objc_msgSend(v2, "fileExistsAtPath:", v4)
    && objc_msgSend(v2, "fileExistsAtPath:", v4))
  {
    v5 = 1;
    do
    {
      v6 = (v5 + 1);
      v4 = objc_msgSend((id)objc_msgSend(v3, "stringByAppendingFormat:", CFSTR("-%d"), v5), "stringByAppendingPathExtension:", CFSTR("png"));
      v7 = objc_msgSend(v2, "fileExistsAtPath:", v4);
      v5 = v6;
    }
    while ((v7 & 1) != 0);
  }
  return objc_msgSend(MEMORY[0x24BDBCF48], "fileURLWithPath:isDirectory:", v4, 0);
}

uint64_t p_writeDataToPNG(const void *a1, uint64_t a2, CGFloat *a3, size_t a4, void *a5)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const __CFString *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  const __CFURL *v21;
  CGImageDestinationRef v22;
  CGImageDestination *v23;
  size_t v24;
  size_t v25;
  size_t v26;
  CGDataProviderRef v27;
  CGDataProvider *v28;
  CGColorSpace *v29;
  CGImage *v30;
  CGImage *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  CGFloat *decode;

  if (!a1)
  {
    v8 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *p_writeDataToPNG(uint8_t *, int32_t, int32_t, size_t, NSString *)");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUUtility.m");
    v11 = CFSTR("buffer is NULL!");
    v12 = (void *)v8;
    v13 = v9;
    v14 = 208;
LABEL_7:
    objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, v10, v14, v11, decode);
    return 0;
  }
  if ((a2 - 32769) <= 0xFFFF7FFF)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *p_writeDataToPNG(uint8_t *, int32_t, int32_t, size_t, NSString *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUUtility.m"), 212, CFSTR("width is invalid: %d"), a2);
    return 0;
  }
  if (((_DWORD)a3 - 32769) <= 0xFFFF7FFF)
  {
    v16 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v17 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *p_writeDataToPNG(uint8_t *, int32_t, int32_t, size_t, NSString *)");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUUtility.m");
    v11 = CFSTR("height is invalid: %d");
    decode = a3;
    v12 = (void *)v16;
    v13 = v17;
    v14 = 216;
    goto LABEL_7;
  }
  v21 = (const __CFURL *)p_URLFromPathname(a5);
  v22 = CGImageDestinationCreateWithURL(v21, (CFStringRef)objc_msgSend((id)*MEMORY[0x24BDF84F8], "identifier"), 1uLL, 0);
  if (v22)
  {
    v23 = v22;
    v24 = a2;
    v25 = ((a4 >> 1) & 0x1FFFFFFFFFFFFFFFLL) * a2;
    v26 = a3;
    v27 = CGDataProviderCreateWithData(0, a1, v25 * a3, 0);
    if (v27)
    {
      v28 = v27;
      v29 = (CGColorSpace *)TSUDeviceRGBColorSpace();
      v30 = CGImageCreate(v24, v26, a4, 4 * a4, v25, v29, 1u, v28, 0, 0, kCGRenderingIntentDefault);
      if (v30)
      {
        v31 = v30;
        CGImageDestinationAddImage(v23, v30, 0);
        CGImageDestinationFinalize(v23);
        CGImageRelease(v31);
      }
      else
      {
        v36 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v37 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *p_writeDataToPNG(uint8_t *, int32_t, int32_t, size_t, NSString *)");
        objc_msgSend(v36, "handleFailureInFunction:file:lineNumber:description:", v37, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUUtility.m"), 244, CFSTR("Couldn't create CGImage!"));
        v21 = 0;
      }
      CGDataProviderRelease(v28);
    }
    else
    {
      v34 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v35 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *p_writeDataToPNG(uint8_t *, int32_t, int32_t, size_t, NSString *)");
      objc_msgSend(v34, "handleFailureInFunction:file:lineNumber:description:", v35, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUUtility.m"), 234, CFSTR("Couldn't create CGDataProvider!"));
      v21 = 0;
    }
    CFRelease(v23);
  }
  else
  {
    v32 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v33 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *p_writeDataToPNG(uint8_t *, int32_t, int32_t, size_t, NSString *)");
    objc_msgSend(v32, "handleFailureInFunction:file:lineNumber:description:", v33, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDGPUUtility.m"), 223, CFSTR("Couldn't create CGImageDestination for URL %@!"), v21);
    v21 = 0;
  }
  return -[__CFURL path](v21, "path");
}

const __CFString *NSStringFromTSDGestureState(unsigned int a1)
{
  if (a1 < 5)
    return off_24D82C5D8[a1];
  if (a1 == 5)
    return CFSTR("TSDGestureStateFailed");
  return CFSTR("#Unknown TSDGestureState#");
}

void sub_217A9D7D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_217A9D960(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_217A9D9C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)TSDBrushStrokeDirectSurfaceRenderingContext;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_217A9DB54(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_217A9DC4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_217A9DCE8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_217A9DD88(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_217A9DE08(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_217A9DEC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_217A9DFA4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_217A9E048(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_217A9E158(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_217A9E2FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_217A9E3BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_217A9E4D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_217A9F158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30)
{
  void *v30;

  _Unwind_Resume(a1);
}

void sub_217A9FA7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,id a23)
{
  void *v23;
  void *v24;

  _Unwind_Resume(a1);
}

void sub_217A9FEAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_217AA00A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_217AA1974(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,void *__p,uint64_t a35)
{
  void *v35;
  void *v36;
  void *v37;
  void *v38;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_217AA3440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,void *a38,void *a39,void *a40,void *a41,void *a42,void *a43,void *a44,_Unwind_Exception *exception_objecta,uint64_t a46,void *a47,void *a48,uint64_t a49,uint64_t a50,void *a51,void *a52,void *a53)
{
  void *v53;

  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_ea8_56c60_ZTSNSt3__16vectorI18TSDBrushVertexDataNS_9allocatorIS1_EEEE(uint64_t a1, uint64_t a2)
{
  return std::vector<TSDBrushVertexData>::vector((_QWORD *)(a1 + 56), a2 + 56);
}

void __destroy_helper_block_ea8_56c60_ZTSNSt3__16vectorI18TSDBrushVertexDataNS_9allocatorIS1_EEEE(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(_QWORD *)(a1 + 64) = v2;
    operator delete(v2);
  }
}

void sub_217AA3D7C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_217AA3E84(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_217AA3FD4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_217AA40E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_217AA4184(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_217AA4284(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_217AA4494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  void *v22;

  _Block_object_dispose(&a17, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__15(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__15(uint64_t a1)
{

}

void sub_217AA47B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  v8 = v4;

  _Unwind_Resume(a1);
}

void sub_217AA4970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  void *v22;

  _Block_object_dispose(&a17, 8);

  _Unwind_Resume(a1);
}

void sub_217AA4B3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v10;

  _Unwind_Resume(a1);
}

void sub_217AA4C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  void *v22;

  _Block_object_dispose(&a17, 8);

  _Unwind_Resume(a1);
}

void sub_217AA4E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v10;

  _Unwind_Resume(a1);
}

void sub_217AA4FD8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t std::vector<TSDBrushVertexData>::vector<std::__wrap_iter<TSDBrushVertexData*>,0>(uint64_t a1, _BYTE *a2, _BYTE *a3)
{
  int64_t v4;
  uint64_t v7;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v4 = a3 - a2;
  if (a3 != a2)
  {
    std::vector<TSDBrushVertexData>::__vallocate[abi:nn180100]((_QWORD *)a1, v4 >> 5);
    v7 = *(_QWORD *)(a1 + 8);
    if (a3 != a2)
      memmove(*(void **)(a1 + 8), a2, v4);
    *(_QWORD *)(a1 + 8) = v7 + 32 * (v4 >> 5);
  }
  return a1;
}

char *std::vector<TSDBrushVertexData>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 59)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Edge::CGPointVector>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

_QWORD *std::vector<TSDBrushVertexData>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<TSDBrushVertexData>::__vallocate[abi:nn180100](a1, v5 >> 5);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

uint64_t TSDMixingTypeBestFromMixingTypes(uint64_t result, uint64_t a2)
{
  if (result >= a2)
    return a2;
  return result;
}

__CFString *TSDMixingTypeAsString(unint64_t a1)
{
  void *v3;
  uint64_t v4;

  if (a1 < 6)
    return off_24D82C880[a1];
  v3 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v4 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSDMixingTypeAsString(TSDMixingType)");
  objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDMagicMove.m"), 67, CFSTR("Unknown mixing type (%ld)!"), a1);
  return 0;
}

uint64_t TSDMixingTypeWithPossiblyNilObjects(unint64_t a1, unint64_t a2)
{
  void *v4;
  unint64_t v5;
  int v7;

  if (!(a1 | a2))
    return 5;
  if (!a1 || objc_msgSend(MEMORY[0x24BDBCEF8], "null") == a1)
  {
    objc_opt_class();
    if ((objc_opt_respondsToSelector() & 1) != 0)
      v7 = objc_msgSend((id)objc_opt_class(), "canMixWithNilObjects");
    else
      v7 = 0;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0 || v7)
    {
      v4 = (void *)a2;
      v5 = a1;
      return objc_msgSend(v4, "mixingTypeWithObject:", v5);
    }
    return 1;
  }
  if (!a2 || objc_msgSend(MEMORY[0x24BDBCEF8], "null") == a2)
  {
    objc_opt_class();
    if ((objc_opt_respondsToSelector() & 1) == 0
      || !objc_msgSend((id)objc_opt_class(), "canMixWithNilObjects"))
    {
      return 1;
    }
  }
  v4 = (void *)a1;
  v5 = a2;
  return objc_msgSend(v4, "mixingTypeWithObject:", v5);
}

uint64_t TSDMixedObjectWithPossiblyNilObjects(void *a1, void *a2, double a3)
{
  void *v6;
  double v7;
  void *v8;

  if (!a1 || (void *)objc_msgSend(MEMORY[0x24BDBCEF8], "null") == a1)
  {
    v7 = 1.0 - a3;
    v6 = a2;
    v8 = a1;
  }
  else
  {
    v6 = a1;
    v7 = a3;
    v8 = a2;
  }
  return objc_msgSend(v6, "mixedObjectWithFraction:ofObject:", v8, v7);
}

uint64_t TSDMixingTypeWithObjects(unint64_t a1, unint64_t a2)
{
  BOOL v3;
  uint64_t result;
  int v6;
  void *v7;
  unint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;

  v3 = (a1 | a2) == 0;
  result = 5;
  if (a1 != a2 && !v3)
  {
    if ((objc_msgSend((id)a1, "isEqual:", a2) & 1) != 0)
      return 5;
    if (!a1 || objc_msgSend(MEMORY[0x24BDBCEF8], "null") == a1)
    {
      if (objc_msgSend((id)a2, "conformsToProtocol:", &unk_254F6FDA0)
        && (objc_opt_class(), (objc_opt_respondsToSelector() & 1) != 0))
      {
        v6 = objc_msgSend((id)objc_opt_class(), "canMixWithNilObjects");
      }
      else
      {
        v6 = 0;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0 && !v6)
        return 1;
    }
    else
    {
      if (!a2 || objc_msgSend(MEMORY[0x24BDBCEF8], "null") == a2)
      {
        if (!objc_msgSend((id)a1, "conformsToProtocol:", &unk_254F6FDA0))
          return 1;
        objc_opt_class();
        if ((objc_opt_respondsToSelector() & 1) == 0
          || !objc_msgSend((id)objc_opt_class(), "canMixWithNilObjects"))
        {
          return 1;
        }
        goto LABEL_27;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          objc_opt_class();
          if ((objc_opt_respondsToSelector() & 1) == 0
            || (v11 = (void *)objc_msgSend((id)objc_opt_class(), "mixableObjectClasses"),
                (objc_msgSend(v11, "containsObject:", objc_opt_class()) & 1) == 0))
          {
            objc_opt_class();
            if ((objc_opt_respondsToSelector() & 1) == 0)
              return 1;
            v12 = (void *)objc_msgSend((id)objc_opt_class(), "mixableObjectClasses");
            if (!objc_msgSend(v12, "containsObject:", objc_opt_class()))
              return 1;
          }
        }
      }
      if (!objc_msgSend((id)a1, "conformsToProtocol:", &unk_254F6FDA0)
        || !objc_msgSend((id)a2, "conformsToProtocol:", &unk_254F6FDA0))
      {
        return 2;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
LABEL_27:
        v7 = (void *)a1;
        v8 = a2;
LABEL_22:
        result = objc_msgSend(v7, "mixingTypeWithObject:", v8);
        if (!result)
        {
          v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSDMixingType TSDMixingTypeWithObjects(NSObject<TSDMixing> *, NSObject<TSDMixing> *)");
          objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDMagicMove.m"), 168, CFSTR("TSDMixingType is Undefined!"));
          return 0;
        }
        return result;
      }
    }
    v7 = (void *)a2;
    v8 = a1;
    goto LABEL_22;
  }
  return result;
}

uint64_t TSDMixingTypeWithObject(unint64_t a1, unint64_t a2, uint64_t a3)
{
  BOOL v4;
  uint64_t result;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;

  v4 = (a1 | a2) == 0;
  result = 5;
  if (a1 == a2 || v4)
    return result;
  if ((objc_msgSend((id)a1, "isEqual:", a2) & 1) != 0)
    return 5;
  if (!a1 || objc_msgSend(MEMORY[0x24BDBCEF8], "null") == a1)
  {
    objc_opt_class();
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
LABEL_16:
      if ((objc_msgSend((id)objc_opt_class(), "canMixWithNilObjects") & 1) != 0)
        return 4;
    }
    return 1;
  }
  if (!a2 || objc_msgSend(MEMORY[0x24BDBCEF8], "null") == a2)
  {
    objc_opt_class();
    if ((objc_opt_respondsToSelector() & 1) != 0)
      goto LABEL_16;
    return 1;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      objc_opt_class();
      if ((objc_opt_respondsToSelector() & 1) == 0
        || (v10 = (void *)objc_msgSend((id)objc_opt_class(), "mixableObjectClasses"),
            (objc_msgSend(v10, "containsObject:", objc_opt_class()) & 1) == 0))
      {
        objc_opt_class();
        if ((objc_opt_respondsToSelector() & 1) == 0)
          return 1;
        v11 = (void *)objc_msgSend((id)objc_opt_class(), "mixableObjectClasses");
        if (!objc_msgSend(v11, "containsObject:", objc_opt_class()))
          return 1;
      }
    }
  }
  result = (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  if (!result)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSDMixingType TSDMixingTypeWithObject(NSObject<TSDMixing> *, NSObject<TSDMixing> *, TSDMixingType (^)(void))");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDMagicMove.m"), 222, CFSTR("TSDMixingType is Undefined!"));
    return 0;
  }
  return result;
}

uint64_t TSDMixingMixedObjectWithFraction(void *a1, void *a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;

  if (objc_msgSend(a1, "mixingTypeWithObject:", a2) == 1)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "id TSDMixingMixedObjectWithFraction(NSObject<TSDMixing> *, NSObject<TSDMixing> *, CGFloat, id (^)(void))");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDMagicMove.m"), 230, CFSTR("Cannot mix with object!"));
  }
  if (a1 == a2 || (objc_msgSend(a1, "isEqual:", a2) & 1) != 0)
    return (uint64_t)a1;
  else
    return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
}

uint64_t TSDMixingMixedObjectWithFractionEx(void *a1, unint64_t a2, double a3)
{
  void *v6;
  uint64_t v7;
  void *v9;
  double v10;
  void *v11;

  if (TSDMixingTypeWithObjects((unint64_t)a1, a2) == 1)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "id TSDMixingMixedObjectWithFractionEx(NSObject<TSDMixing> *, NSObject<TSDMixing> *, CGFloat)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDMagicMove.m"), 243, CFSTR("Cannot mix with object!"));
  }
  if (a1 == (void *)a2 || (objc_msgSend(a1, "isEqual:", a2) & 1) != 0)
    return (uint64_t)a1;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v9 = a1;
    v10 = a3;
    v11 = (void *)a2;
  }
  else
  {
    v10 = 1.0 - a3;
    v9 = (void *)a2;
    v11 = a1;
  }
  return objc_msgSend(v9, "mixedObjectWithFraction:ofObject:", v11, v10);
}

void sub_217AA7070(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217AA723C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217AA72EC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t TSKPlayerRepeatModeForMovieLoopOption(uint64_t a1)
{
  if (a1 == 1)
    return 1;
  else
    return 2 * (a1 == 2);
}

id universalReset(void *a1, const char *a2)
{
  objc_class *Class;
  objc_class *v5;
  objc_super v7;

  objc_msgSend((id)objc_msgSend(MEMORY[0x24BDD16D0], "defaultCenter"), "postNotificationName:object:", CFSTR("TSDControllingGRDidResetNotification"), a1);
  Class = object_getClass(a1);
  if (!-[NSString hasPrefix:](NSStringFromClass(Class), "hasPrefix:", CFSTR("__TSDResetNotifying")))
    return (id)objc_msgSend(a1, "reset");
  v7.receiver = a1;
  v5 = object_getClass(a1);
  v7.super_class = class_getSuperclass(v5);
  return objc_msgSendSuper(&v7, a2);
}

void sub_217AAE364(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217AAE498(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217AB1D90(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 216), 8);
  _Block_object_dispose((const void *)(v1 - 184), 8);
  _Unwind_Resume(a1);
}

void sub_217AB77C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__16(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__16(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_217ABAFF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_217AC5954(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Unwind_Resume(a1);
}

double calculateReflectionShadingValues(double *a1, double *a2, uint64_t a3)
{
  float v4;
  float v5;
  double result;

  v4 = 1.0 - *a2;
  v5 = a1[1];
  result = *a1 * powf(v4, v5);
  *(_QWORD *)a3 = 0;
  *(double *)(a3 + 8) = result;
  return result;
}

void sub_217ACFD48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__17(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__17(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t TSDCapabilitiesDeviceTypeFromHWModelString(void *a1)
{
  void *v1;
  uint64_t result;

  v1 = (void *)objc_msgSend((id)objc_msgSend(a1, "componentsSeparatedByCharactersInSet:", objc_msgSend(MEMORY[0x24BDD14A8], "decimalDigitCharacterSet")), "firstObject");
  result = objc_msgSend(v1, "length");
  if (result)
  {
    if ((objc_msgSend(v1, "isEqualToString:", CFSTR("iPad")) & 1) != 0)
    {
      return 1;
    }
    else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("iPhone")) & 1) != 0)
    {
      return 2;
    }
    else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("iPod")) & 1) != 0)
    {
      return 3;
    }
    else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("iMac")) & 1) != 0)
    {
      return 4;
    }
    else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("MacBook")) & 1) != 0)
    {
      return 5;
    }
    else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("MacBookAir")) & 1) != 0)
    {
      return 6;
    }
    else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("MacBookPro")) & 1) != 0)
    {
      return 7;
    }
    else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("Macmini")) & 1) != 0)
    {
      return 8;
    }
    else if (objc_msgSend(v1, "isEqualToString:", CFSTR("MacPro")))
    {
      return 9;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t TSDBundle()
{
  if (TSDBundle::onceToken != -1)
    dispatch_once(&TSDBundle::onceToken, &__block_literal_global_56);
  return TSDBundle::bundle;
}

const __CFString *KNAnimationTypeAsString(int a1)
{
  if ((a1 - 1) > 3)
    return CFSTR("None");
  else
    return off_24D82CF20[a1 - 1];
}

uint64_t KNAnimationTypeFromString(void *a1)
{
  if ((objc_msgSend(a1, "isEqualToString:", CFSTR("None")) & 1) != 0)
    return 0;
  if ((objc_msgSend(a1, "isEqualToString:", CFSTR("In")) & 1) != 0)
    return 1;
  if ((objc_msgSend(a1, "isEqualToString:", CFSTR("Out")) & 1) != 0)
    return 2;
  if ((objc_msgSend(a1, "isEqualToString:", CFSTR("Transition")) & 1) != 0)
    return 3;
  if (objc_msgSend(a1, "isEqualToString:", CFSTR("Action")))
    return 4;
  return 0;
}

uint64_t KNAnimationTypeAsNumber(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", a1);
}

uint64_t KNAnimationTypeFromNumber(void *a1)
{
  uint64_t result;

  LODWORD(result) = objc_msgSend(a1, "intValue");
  if (result >= 5)
    return 0;
  else
    return result;
}

uint64_t KNEffectIsEmphasisEffect(uint64_t a1)
{
  if (KNEffectIsEmphasisEffect_onceToken != -1)
    dispatch_once(&KNEffectIsEmphasisEffect_onceToken, &__block_literal_global_58);
  return objc_msgSend((id)KNEffectIsEmphasisEffect_sEmphasisEffectsSet, "containsObject:", a1);
}

uint64_t KNEffectIsActionEffect(uint64_t a1)
{
  if (KNEffectIsActionEffect_onceToken != -1)
    dispatch_once(&KNEffectIsActionEffect_onceToken, &__block_literal_global_23_0);
  if ((objc_msgSend((id)KNEffectIsActionEffect_sActionEffectsSet, "containsObject:", a1) & 1) != 0)
    return 1;
  else
    return KNEffectIsEmphasisEffect(a1);
}

void TSDgpc_free_polygon(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;

  v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    v3 = 0;
    v4 = *(_QWORD *)(a1 + 16);
    v5 = 8;
    do
    {
      v6 = *(_QWORD **)(v4 + v5);
      if (v6)
      {
        gpc_free(v6);
        v4 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(v4 + v5) = 0;
        v2 = *(_DWORD *)a1;
      }
      ++v3;
      v5 += 16;
    }
    while (v3 < v2);
  }
  v7 = *(_QWORD **)(a1 + 8);
  if (v7)
  {
    gpc_free(v7);
    *(_QWORD *)(a1 + 8) = 0;
  }
  v8 = *(_QWORD **)(a1 + 16);
  if (v8)
  {
    gpc_free(v8);
    *(_QWORD *)(a1 + 16) = 0;
  }
  *(_DWORD *)a1 = 0;
}

uint64_t TSDgpc_dump_polygon(char *a1, size_t a2, int a3, int *a4)
{
  uint64_t result;
  uint64_t v9;
  size_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double *v15;

  result = snprintf(a1, a2, "contours: %d\n", *a4);
  if ((_DWORD)result != -1 && a2 > (int)result && *a4 >= 1)
  {
    v9 = 0;
    v10 = a2 - (int)result;
    v11 = &a1[(int)result];
    v12 = *((_QWORD *)a4 + 2);
    do
    {
      result = snprintf(v11, v10, "vertices: %d\n", *(_DWORD *)(v12 + 16 * v9));
      if ((_DWORD)result == -1 || v10 <= (int)result)
        break;
      v11 += (int)result;
      v10 -= (int)result;
      if (a3)
      {
        result = snprintf(v11, v10, "flag: %d\n", *(_DWORD *)(*((_QWORD *)a4 + 1) + 4 * v9));
        if ((_DWORD)result == -1 || v10 <= (int)result)
          return result;
        v11 += (int)result;
        v10 -= (int)result;
      }
      v12 = *((_QWORD *)a4 + 2);
      if (*(int *)(v12 + 16 * v9) >= 1)
      {
        v13 = 0;
        v14 = 0;
        do
        {
          v15 = (double *)(*(_QWORD *)(v12 + 16 * v9 + 8) + v13);
          result = snprintf(v11, v10, "% .*f\t% .*f\n", 15, *v15, 15, v15[1]);
          if ((_DWORD)result == -1 || v10 <= (int)result)
            return result;
          v11 += (int)result;
          v10 -= (int)result;
          ++v14;
          v12 = *((_QWORD *)a4 + 2);
          v13 += 16;
        }
        while (v14 < *(int *)(v12 + 16 * v9));
      }
      ++v9;
    }
    while (v9 < *a4);
  }
  return result;
}

size_t TSDgpc_log_polygon(int *a1)
{
  return TSDgpc_write_polygon((FILE *)*MEMORY[0x24BDAC8D8], 1, a1);
}

size_t TSDgpc_write_polygon(FILE *a1, int a2, int *a3)
{
  size_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double *v11;

  result = fprintf(a1, "%d\n", *a3);
  if (!*((_QWORD *)a3 + 2))
    return fwrite("### NIL CONTOUR PTR\n", 0x14uLL, 1uLL, a1);
  if (*a3 >= 1)
  {
    v7 = 0;
    do
    {
      result = fprintf(a1, "%d\n", *(_DWORD *)(*((_QWORD *)a3 + 2) + 16 * v7));
      if (a2)
        result = fprintf(a1, "%d\n", *(_DWORD *)(*((_QWORD *)a3 + 1) + 4 * v7));
      v8 = *((_QWORD *)a3 + 2);
      if (*(_QWORD *)(v8 + 16 * v7 + 8))
      {
        if (*(int *)(v8 + 16 * v7) >= 1)
        {
          v9 = 0;
          v10 = 0;
          do
          {
            v11 = (double *)(*(_QWORD *)(v8 + 16 * v7 + 8) + v9);
            result = fprintf(a1, "% .*f % .*f\n", 15, *v11, 15, v11[1]);
            ++v10;
            v8 = *((_QWORD *)a3 + 2);
            v9 += 16;
          }
          while (v10 < *(int *)(v8 + 16 * v7));
        }
      }
      else
      {
        result = fwrite("### NIL VERTEX PTR\n", 0x13uLL, 1uLL, a1);
      }
      ++v7;
    }
    while (v7 < *a3);
  }
  return result;
}

void TSDgpc_add_contour(int *a1, int *a2, int a3)
{
  char *v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  char *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  if (*a1 == -1)
  {
    v6 = 0;
    v7 = 0;
LABEL_5:
    v8 = -1;
    goto LABEL_6;
  }
  v7 = gpc_malloc(4 * (*a1 + 1));
  if (*a1 == -1)
  {
    v6 = 0;
    goto LABEL_5;
  }
  v18 = (char *)gpc_malloc(16 * (*a1 + 1));
  v6 = v18;
  v8 = *a1;
  if (*a1 > 0)
  {
    v19 = 0;
    v20 = 0;
    do
    {
      v21 = *((_QWORD *)a1 + 2);
      v7[v20] = *(_DWORD *)(*((_QWORD *)a1 + 1) + 4 * v20);
      *(_OWORD *)&v18[v19] = *(_OWORD *)(v21 + v19);
      ++v20;
      v9 = *a1;
      v19 += 16;
    }
    while (v20 < v9);
    goto LABEL_7;
  }
LABEL_6:
  v9 = v8;
LABEL_7:
  v7[v9] = a3;
  *(_DWORD *)&v6[16 * v9] = *a2;
  v10 = *a2;
  if ((_DWORD)v10)
    v11 = gpc_malloc(16 * v10);
  else
    v11 = 0;
  v12 = &v6[16 * v9];
  *((_QWORD *)v12 + 1) = v11;
  v13 = v12 + 8;
  if (*a2 >= 1)
  {
    v14 = 0;
    v15 = 0;
    do
    {
      *(_OWORD *)(*v13 + v14) = *(_OWORD *)(*((_QWORD *)a2 + 1) + v14);
      ++v15;
      v14 += 16;
    }
    while (v15 < *a2);
  }
  v16 = (_QWORD *)*((_QWORD *)a1 + 2);
  if (v16)
  {
    gpc_free(v16);
    *((_QWORD *)a1 + 2) = 0;
  }
  v17 = (_QWORD *)*((_QWORD *)a1 + 1);
  if (v17)
    gpc_free(v17);
  ++*a1;
  *((_QWORD *)a1 + 1) = v7;
  *((_QWORD *)a1 + 2) = v6;
}

int *clean_polygon(int *result)
{
  int *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  _QWORD *v5;
  uint64_t v6;
  int v7;
  double *v8;
  int v9;
  int v10;

  if (*result >= 1)
  {
    v1 = result;
    v2 = 0;
    while (1)
    {
      v3 = *((_QWORD *)v1 + 2) + 16 * v2;
      v4 = *(_DWORD *)v3;
      v5 = *(_QWORD **)(v3 + 8);
      if (*(int *)v3 < 2)
        break;
      v6 = 0;
      v7 = v4 - 1;
      v8 = (double *)(v5 + 2);
      v9 = -1;
      do
      {
        result = (int *)(v8 - 2);
        if (vabdd_f64(*(v8 - 2), *v8) <= 2.22044605e-16 && vabdd_f64(*(v8 - 1), v8[1]) <= 2.22044605e-16)
        {
          result = (int *)memmove(result, v8, 16 * (v4 + v9));
          v4 = v7;
        }
        ++v6;
        v7 = v4 - 1;
        --v9;
        v8 += 2;
      }
      while (v6 < v4 - 1);
      if (v4 < 3)
        goto LABEL_12;
      v10 = *v1;
      ++v2;
LABEL_14:
      if (v2 >= v10)
        return result;
    }
    if (v5)
LABEL_12:
      gpc_free(v5);
    result = (int *)memmove((void *)(*((_QWORD *)v1 + 2) + 16 * v2), (const void *)(*((_QWORD *)v1 + 2) + 16 * (v2 + 1)), 16 * (*v1 + ~(_DWORD)v2));
    v10 = *v1 - 1;
    *v1 = v10;
    ++v2;
    goto LABEL_14;
  }
  return result;
}

uint64_t TSDprint_polygon(int *a1)
{
  uint64_t v2;
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  double *v6;

  puts("begin poly");
  if (*a1 >= 1)
  {
    v2 = 0;
    do
    {
      v3 = (unsigned int *)(*((_QWORD *)a1 + 2) + 16 * v2);
      v4 = *v3;
      v5 = *((_QWORD *)v3 + 1);
      puts("\tbegin contour");
      if ((int)v4 >= 1)
      {
        v6 = (double *)(v5 + 8);
        do
        {
          printf("\t\t%g, %g\n", *(v6 - 1), *v6);
          v6 += 2;
          --v4;
        }
        while (v4);
      }
      puts("\tend contour");
      ++v2;
    }
    while (v2 < *a1);
  }
  return puts("end poly\n");
}

void TSDgpc_polygon_clip(unsigned int a1, unsigned int *a2, int *a3, unsigned int *a4)
{
  uint64_t v4;
  int v7;
  int v8;
  int v9;
  double *v11;
  double *v12;
  int v13;
  double *v14;
  double *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  double v25;
  unsigned int v26;
  uint64_t v27;
  double v28;
  double *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  _BOOL4 v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  double v45;
  uint64_t v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  BOOL v54;
  int v57;
  int v58;
  BOOL v59;
  int v60;
  BOOL v61;
  BOOL v62;
  BOOL v64;
  int v66;
  int v67;
  BOOL v68;
  int v69;
  double v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  _QWORD *v76;
  double *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  double *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  double *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  double *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  double *v105;
  uint64_t v106;
  double *v107;
  uint64_t v108;
  uint64_t v109;
  double *v110;
  uint64_t v111;
  _QWORD *v112;
  double *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  double *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  double *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  double *v135;
  uint64_t v136;
  double *v137;
  uint64_t v138;
  double v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  double v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  _QWORD *v149;
  uint64_t v150;
  uint64_t v151;
  int v152;
  int v153;
  uint64_t *v154;
  uint64_t v155;
  uint64_t *v156;
  uint64_t v157;
  __int128 v158;
  int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  int v164;
  int v165;
  double v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  _QWORD *v172;
  double *v173;
  double *v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  double *v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  double *v184;
  uint64_t v185;
  double *v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  double *v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  double *v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  double *v201;
  uint64_t v202;
  double *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v215;
  double *v216;
  double *v217;
  _QWORD *v218;
  int v219;
  uint64_t v220;
  _QWORD *v221;
  unsigned int v222;
  uint64_t v223;
  _QWORD *v224;
  uint64_t v225;
  void *v226;
  int v227;
  _QWORD *v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  void *v232;
  uint64_t v233;
  _QWORD *v234;
  uint64_t v235;
  _QWORD *v236;
  _QWORD *v237;
  _QWORD *v238;
  _QWORD *v239;
  _QWORD *v240;
  int *v241;
  double *v242;
  double *v243;
  double *v244;
  int v245;
  double *v246;
  unsigned int v247;
  unsigned int v248;
  unsigned int v249;
  unsigned int v250;
  unsigned int v251;
  unsigned int v252;
  unsigned int v253;
  unsigned int v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  unsigned int v264;
  unsigned int v265;
  unsigned int v266;
  unsigned int v267;
  unsigned int v268;
  unsigned int v269;
  unsigned int v270;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  void *v276;
  uint64_t v277;
  void *v278;
  _QWORD *v279[2];

  v4 = (uint64_t)a4;
  v7 = a1;
  v278 = 0;
  v279[0] = 0;
  v276 = 0;
  v277 = 0;
  v275 = 0;
  v8 = *a2;
  v9 = *a3;
  if (!*a2)
  {
    if (a1 >= 2 && v9)
    {
      LODWORD(v274) = 0;
      goto LABEL_15;
    }
LABEL_18:
    if (a2 == a4)
      TSDgpc_free_polygon((uint64_t)a2);
    if (a3 == (int *)v4)
      TSDgpc_free_polygon(v4);
    *(_DWORD *)v4 = 0;
    *(_QWORD *)(v4 + 8) = 0;
    *(_QWORD *)(v4 + 16) = 0;
    return;
  }
  if (a1 == 1 && !v9)
    goto LABEL_18;
  LODWORD(v274) = a1 == 0;
  if (a1 <= 1 && v8 >= 1 && v9 >= 1)
  {
    minimax_test((uint64_t)a2, a3, a1);
    v7 = a1;
    v8 = *a2;
  }
  if (v8 >= 1)
  {
    v11 = build_lmt((double **)&v276, (double *)v279, &v275, a2, 1, v7);
    goto LABEL_16;
  }
LABEL_15:
  v11 = 0;
LABEL_16:
  if (*a3 < 1)
    v12 = 0;
  else
    v12 = build_lmt((double **)&v276, (double *)v279, &v275, (unsigned int *)a3, 0, a1);
  if (v276)
  {
    v246 = (double *)v276;
    v13 = v275;
    if ((_DWORD)v275)
      v14 = (double *)gpc_malloc(8 * (int)v275);
    else
      v14 = 0;
    v244 = v14;
    build_sbt((int *)&v275 + 1, (uint64_t)v14, (uint64_t)v279[0]);
    free_sbtree(v279);
    if (a2 == (unsigned int *)v4)
      TSDgpc_free_polygon((uint64_t)a2);
    v242 = v12;
    v243 = v11;
    if (a3 == (int *)v4)
      TSDgpc_free_polygon(v4);
    if (v13 <= 0)
    {
      *(_QWORD *)(v4 + 8) = 0;
      *(_QWORD *)(v4 + 16) = 0;
      v216 = v12;
      v217 = v11;
    }
    else
    {
      v241 = (int *)v4;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v245 = 0;
      HIDWORD(v274) = 0;
      v23 = 0;
      v263 = 0;
      v24 = 0.0;
      v25 = 0.0;
      v26 = a1;
      do
      {
        v27 = v18 + 1;
        HIDWORD(v275) = v27;
        v28 = v244[v18];
        if ((int)v27 < v13)
        {
          v25 = v244[v27];
          v24 = v25 - v28;
        }
        v29 = v246;
        if (v246 && *v246 == v28)
        {
          v30 = *((_QWORD *)v246 + 1);
          if (v30)
          {
            v31 = v19;
            v32 = v22;
            v33 = v20;
            v34 = v21;
            do
            {
              add_edge_to_aet(&v277, v30, 0);
              v30 = *(_QWORD *)(v30 + 160);
            }
            while (v30);
            v16 = v277;
            v26 = a1;
            v21 = v34;
            v20 = v33;
            v22 = v32;
            v19 = v31;
          }
          v29 = (double *)*((_QWORD *)v246 + 2);
          v17 = v16;
        }
        *(_DWORD *)(v17 + 76 + 4 * *(int *)(v17 + 72)) = *(double *)(v17 + 40) != v28;
        *(_DWORD *)(v17 + 76 + 4 * (*(_DWORD *)(v17 + 72) == 0)) = 0;
        *(_DWORD *)(v17 + 100) = 0;
        v35 = *(_QWORD *)(v17 + 136);
        v36 = v17;
        v246 = v29;
        if (!v35)
          goto LABEL_61;
        do
        {
          v37 = v35 + 76;
          *(_DWORD *)(v35 + 76 + 4 * *(int *)(v35 + 72)) = *(double *)(v35 + 40) != v28;
          v38 = *(int *)(v35 + 72);
          *(_DWORD *)(v35 + 76 + 4 * (*(_DWORD *)(v35 + 72) == 0)) = 0;
          *(_DWORD *)(v35 + 100) = 0;
          v39 = *(_DWORD *)(v35 + 76 + 4 * v38);
          if (v39)
          {
            v40 = v35;
            if (vabdd_f64(*(double *)(v36 + 48), *(double *)(v35 + 48)) <= 2.22044605e-16)
            {
              v40 = v35;
              if (vabdd_f64(*(double *)(v36 + 64), *(double *)(v35 + 64)) <= 2.22044605e-16)
              {
                v40 = v35;
                if (*(double *)(v36 + 40) != v28)
                {
                  *(_DWORD *)(v37 + 4 * v38) = *(_DWORD *)(v36 + 76 + 4 * v38) ^ v39;
                  v41 = *(_DWORD *)(v35 + 72) == 0;
                  v42 = *(_DWORD *)(v36 + 76 + 4 * (*(_DWORD *)(v35 + 72) == 0));
                  *(_DWORD *)(v35 + 100) = 1;
                  *(_DWORD *)(v37 + 4 * v41) = v42;
                  *(_DWORD *)(v36 + 76) = 0;
                  *(_DWORD *)(v36 + 80) = 0;
                  *(_DWORD *)(v36 + 100) = 2;
                  v40 = v35;
                }
              }
            }
          }
          else
          {
            v40 = v36;
          }
          v35 = *(_QWORD *)(v35 + 136);
          v36 = v40;
        }
        while (v35);
        if (v17)
        {
LABEL_61:
          v272 = v23;
          v43 = 0;
          v44 = 0;
          v45 = -1.79769313e308;
          v46 = v17;
          v47 = v245;
          while (1)
          {
            v49 = *(_DWORD *)(v46 + 76);
            v48 = *(_DWORD *)(v46 + 80);
            v51 = *(_DWORD *)(v46 + 84);
            v50 = *(_DWORD *)(v46 + 88);
            v52 = v49 + 2 * v51;
            v53 = v48 + 2 * v50;
            if (v52 | v53)
              break;
LABEL_172:
            v46 = *(_QWORD *)(v46 + 136);
            if (!v46)
            {
              v245 = v47;
              v23 = v272;
              do
              {
                v139 = *(double *)(v17 + 40);
                if (v139 == v28)
                {
                  v140 = *(_QWORD *)(v17 + 128);
                  v141 = *(_QWORD *)(v17 + 136);
                  v142 = v141;
                  if (v140)
                  {
                    *(_QWORD *)(v140 + 136) = v141;
                    v142 = v16;
                  }
                  if (v141)
                    *(_QWORD *)(v141 + 128) = v140;
                  if (v140)
                  {
                    if (*(_DWORD *)(v17 + 104) == 1 && *(_DWORD *)(v140 + 104) == 2)
                    {
                      *(_QWORD *)(v140 + 120) = *(_QWORD *)(v17 + 120);
                      *(_DWORD *)(v140 + 104) = 0;
                      v143 = *(_QWORD *)(v140 + 128);
                      if (v143)
                      {
                        if (*(_DWORD *)(v143 + 104) == 2)
                          *(_DWORD *)(v140 + 104) = 1;
                      }
                    }
                  }
                  v16 = v142;
                }
                else
                {
                  if (v139 == v25)
                    v144 = *(double *)(v17 + 32);
                  else
                    v144 = *(double *)(v17 + 16) + *(double *)(v17 + 64) * (v25 - *(double *)(v17 + 24));
                  *(double *)(v17 + 56) = v144;
                }
                v17 = *(_QWORD *)(v17 + 136);
              }
              while (v17);
              v277 = v16;
              v17 = v16;
              goto LABEL_192;
            }
          }
          *(_QWORD *)(v46 + 92) = v274;
          if (v26 >= 2)
          {
            if (v26 == 2)
            {
              v21 = HIDWORD(v274) ^ v274;
              v22 = v21 ^ v49 ^ v48;
              v19 = v274 ^ HIDWORD(v274) ^ (v43 != 0) ^ (v44 != 0);
              v20 = v19 ^ v51 ^ v50;
              v47 = 1;
            }
            else if (v26 == 3)
            {
              if (!v52 || (v47 = 1, HIDWORD(v274)) && !v44)
              {
                if (!v53 || (v47 = 1, (_DWORD)v274) && !v43)
                {
                  if (v52)
                    v54 = v53 == 0;
                  else
                    v54 = 1;
                  v47 = !v54 && (_DWORD)v274 == HIDWORD(v274);
                }
              }
              v21 = v274 != 0;
              v22 = (_DWORD)v274 != v49 || HIDWORD(v274) != v48;
              v57 = v274 ^ (v43 != 0);
              v58 = v44 != 0;
              if (v57)
                v59 = 0;
              else
                v59 = HIDWORD(v274) == v58;
              v19 = !v59;
              v60 = v50 ^ v58;
              v61 = v57 == v51 && v60 == HIDWORD(v274);
LABEL_132:
              v20 = !v61;
            }
            LODWORD(v274) = v49 ^ v274;
            if (v52)
              v43 = TSDnext_h_state[6 * v43 - 2 + 2 * v52 + (int)v274];
            HIDWORD(v274) ^= v48;
            if (v53)
              v44 = TSDnext_h_state[6 * v44 - 2 + 2 * v53 + HIDWORD(v274)];
            if (v47)
            {
              v47 = 1;
              v70 = *(double *)(v46 + 48);
              switch(4 * (_DWORD)v21 + 8 * (_DWORD)v22 + 2 * (_DWORD)v20 + (_DWORD)v19)
              {
                case 1:
                  v78 = v19;
                  v79 = v22;
                  v264 = v20;
                  v80 = v21;
                  if (v70 != v45)
                  {
                    v81 = (double *)gpc_malloc(0x18uLL);
                    *v81 = v70;
                    v81[1] = v28;
                    v82 = *(_QWORD *)(v272 + 32);
                    v81[2] = *(double *)(v82 + 8);
                    *(_QWORD *)(v82 + 8) = v81;
                    v45 = v70;
                  }
                  merge_right(v272, *(_QWORD *)(v46 + 120), v263);
                  v272 = 0;
                  goto LABEL_170;
                case 2:
                  v83 = *(_QWORD *)(v46 + 120);
                  v84 = v21;
                  v85 = v20;
                  v86 = v22;
                  v87 = v43;
                  v88 = v19;
                  v89 = (double *)gpc_malloc(0x18uLL);
                  v19 = v88;
                  v43 = v87;
                  v22 = v86;
                  v20 = v85;
                  v21 = v84;
                  v26 = a1;
                  *v89 = v70;
                  v89[1] = v28;
                  v90 = *(_QWORD *)(v83 + 32);
                  v89[2] = *(double *)(v90 + 8);
                  *(_QWORD *)(v90 + 8) = v89;
                  v272 = *(_QWORD *)(v46 + 120);
                  goto LABEL_166;
                case 4:
                  v91 = v272;
                  if (v70 == v45)
                    goto LABEL_164;
                  v92 = v21;
                  v93 = v20;
                  v94 = v22;
                  v95 = v43;
                  v96 = v19;
                  v97 = (double *)gpc_malloc(0x18uLL);
                  v19 = v96;
                  v43 = v95;
                  v22 = v94;
                  v20 = v93;
                  v21 = v92;
                  v26 = a1;
                  *v97 = v70;
                  v97[1] = v28;
                  v97[2] = 0.0;
                  v98 = *(_QWORD *)(v272 + 32);
                  *(_QWORD *)(*(_QWORD *)(v98 + 16) + 16) = v97;
                  *(_QWORD *)(v98 + 16) = v97;
                  goto LABEL_163;
                case 5:
                  if (*(double *)(v46 + 24) == v28)
                  {
                    v99 = *(_QWORD *)(v46 + 120);
                    v100 = v21;
                    v101 = v20;
                    v102 = v22;
                    v103 = v43;
                    v104 = v19;
                    v105 = (double *)gpc_malloc(0x18uLL);
                    v19 = v104;
                    v43 = v103;
                    v22 = v102;
                    v20 = v101;
                    v21 = v100;
                    v26 = a1;
                    *v105 = v70;
                    v105[1] = v28;
                    v105[2] = 0.0;
                    v106 = *(_QWORD *)(v99 + 32);
                    *(_QWORD *)(*(_QWORD *)(v106 + 16) + 16) = v105;
                    *(_QWORD *)(v106 + 16) = v105;
                  }
                  goto LABEL_160;
                case 6:
                  v78 = v19;
                  v79 = v22;
                  v264 = v20;
                  v251 = v21;
                  if (v70 != v45)
                  {
                    v107 = (double *)gpc_malloc(0x18uLL);
                    *v107 = v70;
                    v107[1] = v28;
                    v107[2] = 0.0;
                    v108 = *(_QWORD *)(v272 + 32);
                    *(_QWORD *)(*(_QWORD *)(v108 + 16) + 16) = v107;
                    *(_QWORD *)(v108 + 16) = v107;
                    v45 = v70;
                  }
                  v109 = v263;
                  merge_left(v272, *(_QWORD *)(v46 + 120), v263);
                  goto LABEL_157;
                case 7:
                case 8:
                  v71 = v21;
                  v72 = v20;
                  v73 = v22;
                  v74 = v43;
                  v75 = v19;
                  v76 = gpc_malloc(0x28uLL);
                  v77 = (double *)gpc_malloc(0x18uLL);
                  v19 = v75;
                  v43 = v74;
                  v22 = v73;
                  v20 = v72;
                  v21 = v71;
                  v26 = a1;
                  *v77 = v70;
                  v77[1] = v28;
                  v77[2] = 0.0;
                  v47 = 1;
                  *(_DWORD *)v76 = 1;
                  v76[3] = v263;
                  v76[4] = v76;
                  v76[1] = v77;
                  v76[2] = v77;
                  v263 = (uint64_t)v76;
                  v45 = v70;
                  v272 = (uint64_t)v76;
                  *(_QWORD *)(v46 + 112) = v76;
                  goto LABEL_172;
                case 9:
                  v78 = v19;
                  v79 = v22;
                  v264 = v20;
                  v251 = v21;
                  if (v70 != v45)
                  {
                    v110 = (double *)gpc_malloc(0x18uLL);
                    *v110 = v70;
                    v110[1] = v28;
                    v111 = *(_QWORD *)(v272 + 32);
                    v110[2] = *(double *)(v111 + 8);
                    *(_QWORD *)(v111 + 8) = v110;
                    v45 = v70;
                  }
                  v109 = v263;
                  merge_right(v272, *(_QWORD *)(v46 + 120), v263);
LABEL_157:
                  *(_QWORD *)(v46 + 120) = 0;
                  v112 = gpc_malloc(0x28uLL);
                  v113 = (double *)gpc_malloc(0x18uLL);
                  *v113 = v70;
                  v113[1] = v28;
                  v113[2] = 0.0;
                  v47 = 1;
                  *(_DWORD *)v112 = 1;
                  v112[3] = v109;
                  v112[4] = v112;
                  v112[1] = v113;
                  v112[2] = v113;
                  v263 = (uint64_t)v112;
                  v272 = (uint64_t)v112;
                  *(_QWORD *)(v46 + 112) = v112;
                  v26 = a1;
                  v21 = v251;
                  goto LABEL_171;
                case 10:
                  if (*(double *)(v46 + 24) == v28)
                  {
                    v114 = *(_QWORD *)(v46 + 120);
                    v115 = v21;
                    v116 = v20;
                    v117 = v22;
                    v118 = v43;
                    v119 = v19;
                    v120 = (double *)gpc_malloc(0x18uLL);
                    v19 = v119;
                    v43 = v118;
                    v22 = v117;
                    v20 = v116;
                    v21 = v115;
                    v26 = a1;
                    *v120 = v70;
                    v120[1] = v28;
                    v121 = *(_QWORD *)(v114 + 32);
                    v120[2] = *(double *)(v121 + 8);
                    *(_QWORD *)(v121 + 8) = v120;
                  }
LABEL_160:
                  *(_QWORD *)(v46 + 112) = *(_QWORD *)(v46 + 120);
                  goto LABEL_166;
                case 11:
                  v91 = v272;
                  if (v70 == v45)
                    goto LABEL_164;
                  v122 = v21;
                  v123 = v20;
                  v124 = v22;
                  v125 = v43;
                  v126 = v19;
                  v127 = (double *)gpc_malloc(0x18uLL);
                  v19 = v126;
                  v43 = v125;
                  v22 = v124;
                  v20 = v123;
                  v21 = v122;
                  v26 = a1;
                  *v127 = v70;
                  v127[1] = v28;
                  v128 = *(_QWORD *)(v272 + 32);
                  v127[2] = *(double *)(v128 + 8);
                  *(_QWORD *)(v128 + 8) = v127;
LABEL_163:
                  v45 = v70;
LABEL_164:
                  *(_QWORD *)(v46 + 112) = v91;
                  v47 = 1;
                  v272 = 0;
                  break;
                case 13:
                  v129 = *(_QWORD *)(v46 + 120);
                  v130 = v21;
                  v131 = v20;
                  v132 = v22;
                  v133 = v43;
                  v134 = v19;
                  v135 = (double *)gpc_malloc(0x18uLL);
                  v19 = v134;
                  v43 = v133;
                  v22 = v132;
                  v20 = v131;
                  v21 = v130;
                  v26 = a1;
                  *v135 = v70;
                  v135[1] = v28;
                  v135[2] = 0.0;
                  v136 = *(_QWORD *)(v129 + 32);
                  *(_QWORD *)(*(_QWORD *)(v136 + 16) + 16) = v135;
                  *(_QWORD *)(v136 + 16) = v135;
                  v272 = *(_QWORD *)(v46 + 120);
                  *(_QWORD *)(v46 + 120) = 0;
LABEL_166:
                  v47 = 1;
                  v45 = v70;
                  break;
                case 14:
                  v78 = v19;
                  v79 = v22;
                  v264 = v20;
                  v80 = v21;
                  if (v70 != v45)
                  {
                    v137 = (double *)gpc_malloc(0x18uLL);
                    *v137 = v70;
                    v137[1] = v28;
                    v137[2] = 0.0;
                    v138 = *(_QWORD *)(v272 + 32);
                    *(_QWORD *)(*(_QWORD *)(v138 + 16) + 16) = v137;
                    *(_QWORD *)(v138 + 16) = v137;
                    v45 = v70;
                  }
                  merge_left(v272, *(_QWORD *)(v46 + 120), v263);
                  v272 = 0;
                  *(_QWORD *)(v46 + 120) = 0;
LABEL_170:
                  v47 = 1;
                  v26 = a1;
                  v21 = v80;
LABEL_171:
                  v20 = v264;
                  v22 = v79;
                  v19 = v78;
                  break;
                default:
                  goto LABEL_172;
              }
            }
            goto LABEL_172;
          }
          if (!v52 || (v47 = 1, !HIDWORD(v274)) && !v44)
          {
            if (!v53 || (v47 = 1, !(_DWORD)v274) && !v43)
            {
              if (v52)
                v62 = v53 == 0;
              else
                v62 = 1;
              v47 = !v62 && (_DWORD)v274 == HIDWORD(v274);
            }
          }
          if ((_DWORD)v274)
            v64 = HIDWORD(v274) == 0;
          else
            v64 = 1;
          v21 = !v64;
          v22 = (_DWORD)v274 != v49 && HIDWORD(v274) != v48;
          v66 = v274 ^ (v43 != 0);
          v67 = v44 != 0;
          if (v66)
            v68 = HIDWORD(v274) == v67;
          else
            v68 = 1;
          v19 = !v68;
          v69 = v50 ^ v67;
          v61 = v66 == v51 || v69 == HIDWORD(v274);
          goto LABEL_132;
        }
LABEL_192:
        v13 = v275;
        v18 = HIDWORD(v275);
        if (SHIDWORD(v275) < (int)v275)
        {
          v145 = v19;
          v146 = v22;
          v147 = v20;
          v148 = v21;
          v273 = v23;
          build_intersection_table((double **)&v278, v16, v24);
          v149 = v278;
          if (v278)
          {
            v26 = a1;
            v21 = v148;
            v20 = v147;
            v22 = v146;
            v19 = v145;
            while (1)
            {
              v151 = *v149;
              v150 = v149[1];
              v152 = *(_DWORD *)(*v149 + 76);
              if (v152)
              {
                v153 = *(_DWORD *)(v150 + 76);
                if (v153)
                {
                  v154 = (uint64_t *)(v151 + 112);
                  v155 = *(_QWORD *)(v151 + 112);
                  v156 = (uint64_t *)(v150 + 112);
                  v157 = *(_QWORD *)(v150 + 112);
                  v158 = *((_OWORD *)v149 + 1);
                  if (*(_DWORD *)(v151 + 92))
                    goto LABEL_198;
                  v160 = 1;
                }
                else
                {
                  if (!*(_DWORD *)(v150 + 80))
                    goto LABEL_275;
                  v153 = 0;
                  v154 = (uint64_t *)(v151 + 112);
                  v155 = *(_QWORD *)(v151 + 112);
                  v156 = (uint64_t *)(v150 + 112);
                  v157 = *(_QWORD *)(v150 + 112);
                  v158 = *((_OWORD *)v149 + 1);
                  v160 = *(_DWORD *)(v151 + 92) == 0;
                }
              }
              else
              {
                if (!*(_DWORD *)(v151 + 80))
                  goto LABEL_275;
                v153 = *(_DWORD *)(v150 + 76);
                if (v153)
                {
                  v154 = (uint64_t *)(v151 + 112);
                  v155 = *(_QWORD *)(v151 + 112);
                  v156 = (uint64_t *)(v150 + 112);
                  v157 = *(_QWORD *)(v150 + 112);
                  v158 = *((_OWORD *)v149 + 1);
                  v159 = *(_DWORD *)(v150 + 92);
                  goto LABEL_202;
                }
                if (!*(_DWORD *)(v150 + 80))
                  goto LABEL_275;
                v154 = (uint64_t *)(v151 + 112);
                v155 = *(_QWORD *)(v151 + 112);
                v156 = (uint64_t *)(v150 + 112);
                v157 = *(_QWORD *)(v150 + 112);
                v158 = *((_OWORD *)v149 + 1);
                v153 = *(_DWORD *)(v151 + 92);
                if (v153)
                {
                  v153 = 0;
LABEL_198:
                  v159 = *(_DWORD *)(v150 + 92);
LABEL_202:
                  v160 = v159 != 0;
                  goto LABEL_206;
                }
                v160 = 0;
              }
LABEL_206:
              v161 = *(_DWORD *)(v151 + 80);
              if (v161)
              {
                if (!*(_DWORD *)(v151 + 96))
                {
                  v162 = 1;
                  goto LABEL_214;
                }
                v162 = *(_DWORD *)(v150 + 80);
                if (!v162)
                  goto LABEL_214;
              }
              else if (!*(_DWORD *)(v150 + 80))
              {
                v162 = *(_DWORD *)(v151 + 96);
                if (!v162)
                  goto LABEL_214;
              }
              v162 = *(_DWORD *)(v150 + 96) != 0;
LABEL_214:
              if (v26 < 2)
              {
                v20 = v153 != v160 && *(_DWORD *)(v150 + 80) != v162;
                v21 = v152 != v160 && v161 != v162;
                v22 = (v153 ^ v152) != v160 && (*(_DWORD *)(v150 + 80) ^ v161) != v162;
                v19 = v160 & v162;
              }
              else if (v26 == 2)
              {
                v19 = v162 ^ v160;
                v163 = v153 ^ v160;
                v164 = *(_DWORD *)(v150 + 80) ^ v162;
                v20 = v164 ^ v163;
                v165 = v161 ^ v152;
                v21 = v165 ^ v160 ^ v162;
                v22 = v165 ^ v163 ^ v164;
              }
              else if (v26 == 3)
              {
                v20 = v153 != v160 || *(_DWORD *)(v150 + 80) != v162;
                v21 = v152 != v160 || v161 != v162;
                v22 = (v153 ^ v152) != v160 || (*(_DWORD *)(v150 + 80) ^ v161) != v162;
                v19 = v160 | v162;
              }
              v168 = v28 + *((double *)&v158 + 1);
              switch(4 * (_DWORD)v21 + 8 * (_DWORD)v22 + 2 * (_DWORD)v20 + (_DWORD)v19)
              {
                case 1:
                  if (v155 && v157)
                  {
                    v249 = v22;
                    v253 = v21;
                    v265 = v20;
                    v247 = v19;
                    v256 = v158;
                    v174 = (double *)gpc_malloc(0x18uLL);
                    *(_QWORD *)v174 = v256;
                    v174[1] = v168;
                    v175 = *(_QWORD *)(v155 + 32);
                    v174[2] = *(double *)(v175 + 8);
                    *(_QWORD *)(v175 + 8) = v174;
                    merge_right(v155, v157, v263);
                    goto LABEL_273;
                  }
                  goto LABEL_275;
                case 2:
                  if (v157)
                  {
                    v176 = v21;
                    v266 = v20;
                    v177 = v22;
                    v178 = v19;
                    v257 = v158;
                    v179 = (double *)gpc_malloc(0x18uLL);
                    v19 = v178;
                    v22 = v177;
                    v20 = v266;
                    v26 = a1;
                    v21 = v176;
                    *(_QWORD *)v179 = v257;
                    v179[1] = v168;
                    v180 = *(_QWORD *)(v157 + 32);
                    v179[2] = *(double *)(v180 + 8);
                    *(_QWORD *)(v180 + 8) = v179;
                    goto LABEL_269;
                  }
                  goto LABEL_275;
                case 4:
                  if (v155)
                  {
                    v181 = v21;
                    v267 = v20;
                    v182 = v22;
                    v183 = v19;
                    v258 = v158;
                    v184 = (double *)gpc_malloc(0x18uLL);
                    v19 = v183;
                    v22 = v182;
                    v20 = v267;
                    v26 = a1;
                    v21 = v181;
                    *(_QWORD *)v184 = v258;
                    v184[1] = v168;
                    v184[2] = 0.0;
                    v185 = *(_QWORD *)(v155 + 32);
                    *(_QWORD *)(*(_QWORD *)(v185 + 16) + 16) = v184;
                    *(_QWORD *)(v185 + 16) = v184;
                    goto LABEL_266;
                  }
                  goto LABEL_275;
                case 6:
                  if (v155 && v157)
                  {
                    v250 = v22;
                    v254 = v21;
                    v268 = v20;
                    v248 = v19;
                    v259 = v158;
                    v186 = (double *)gpc_malloc(0x18uLL);
                    *(_QWORD *)v186 = v259;
                    v186[1] = v168;
                    v186[2] = 0.0;
                    v187 = *(_QWORD *)(v155 + 32);
                    *(_QWORD *)(*(_QWORD *)(v187 + 16) + 16) = v186;
                    *(_QWORD *)(v187 + 16) = v186;
                    v188 = v157;
                    v189 = v263;
                    merge_left(v155, v188, v263);
                    goto LABEL_262;
                  }
                  goto LABEL_275;
                case 7:
                case 8:
                  v252 = v21;
                  v169 = v20;
                  v170 = v22;
                  v171 = v19;
                  v255 = v158;
                  v172 = gpc_malloc(0x28uLL);
                  v173 = (double *)gpc_malloc(0x18uLL);
                  v19 = v171;
                  v22 = v170;
                  v20 = v169;
                  v21 = v252;
                  v26 = a1;
                  *(_QWORD *)v173 = v255;
                  v173[1] = v168;
                  v173[2] = 0.0;
                  *(_DWORD *)v172 = 1;
                  v172[3] = v263;
                  v172[4] = v172;
                  goto LABEL_263;
                case 9:
                  if (v155 && v157)
                  {
                    v250 = v22;
                    v254 = v21;
                    v268 = v20;
                    v248 = v19;
                    v259 = v158;
                    v190 = (double *)gpc_malloc(0x18uLL);
                    *(_QWORD *)v190 = v259;
                    v190[1] = v168;
                    v191 = *(_QWORD *)(v155 + 32);
                    v190[2] = *(double *)(v191 + 8);
                    *(_QWORD *)(v191 + 8) = v190;
                    v192 = v157;
                    v189 = v263;
                    merge_right(v155, v192, v263);
LABEL_262:
                    v172 = gpc_malloc(0x28uLL);
                    v173 = (double *)gpc_malloc(0x18uLL);
                    v19 = v248;
                    v22 = v250;
                    v20 = v268;
                    v26 = a1;
                    v21 = v254;
                    *(_QWORD *)v173 = v259;
                    v173[1] = v168;
                    v173[2] = 0.0;
                    *(_DWORD *)v172 = 1;
                    v172[3] = v189;
                    v172[4] = v172;
LABEL_263:
                    v172[1] = v173;
                    v172[2] = v173;
                    *v154 = (uint64_t)v172;
                    v263 = (uint64_t)v172;
                    *v156 = (uint64_t)v172;
                  }
                  goto LABEL_275;
                case 11:
                  if (v155)
                  {
                    v193 = v21;
                    v269 = v20;
                    v194 = v22;
                    v195 = v19;
                    v260 = v158;
                    v196 = (double *)gpc_malloc(0x18uLL);
                    v19 = v195;
                    v22 = v194;
                    v20 = v269;
                    v26 = a1;
                    v21 = v193;
                    *(_QWORD *)v196 = v260;
                    v196[1] = v168;
                    v197 = *(_QWORD *)(v155 + 32);
                    v196[2] = *(double *)(v197 + 8);
                    *(_QWORD *)(v197 + 8) = v196;
LABEL_266:
                    *v156 = v155;
                    *v154 = 0;
                  }
                  goto LABEL_275;
                case 13:
                  if (!v157)
                    goto LABEL_275;
                  v198 = v21;
                  v270 = v20;
                  v199 = v22;
                  v200 = v19;
                  v261 = v158;
                  v201 = (double *)gpc_malloc(0x18uLL);
                  v19 = v200;
                  v22 = v199;
                  v20 = v270;
                  v26 = a1;
                  v21 = v198;
                  *(_QWORD *)v201 = v261;
                  v201[1] = v168;
                  v201[2] = 0.0;
                  v202 = *(_QWORD *)(v157 + 32);
                  *(_QWORD *)(*(_QWORD *)(v202 + 16) + 16) = v201;
                  *(_QWORD *)(v202 + 16) = v201;
LABEL_269:
                  *v154 = v157;
                  break;
                case 14:
                  if (!v155 || !v157)
                    goto LABEL_275;
                  v249 = v22;
                  v253 = v21;
                  v265 = v20;
                  v247 = v19;
                  v262 = v158;
                  v203 = (double *)gpc_malloc(0x18uLL);
                  *(_QWORD *)v203 = v262;
                  v203[1] = v168;
                  v203[2] = 0.0;
                  v204 = *(_QWORD *)(v155 + 32);
                  *(_QWORD *)(*(_QWORD *)(v204 + 16) + 16) = v203;
                  *(_QWORD *)(v204 + 16) = v203;
                  merge_left(v155, v157, v263);
LABEL_273:
                  v19 = v247;
                  v22 = v249;
                  v20 = v265;
                  v26 = a1;
                  v21 = v253;
                  *v154 = 0;
                  break;
                default:
                  goto LABEL_275;
              }
              *v156 = 0;
LABEL_275:
              if (*(_DWORD *)(v151 + 76))
                *(_DWORD *)(v150 + 92) = *(_DWORD *)(v150 + 92) == 0;
              if (*(_DWORD *)(v150 + 76))
                *(_DWORD *)(v151 + 92) = *(_DWORD *)(v151 + 92) == 0;
              if (*(_DWORD *)(v151 + 80))
                *(_DWORD *)(v150 + 96) = *(_DWORD *)(v150 + 96) == 0;
              if (*(_DWORD *)(v150 + 80))
                *(_DWORD *)(v151 + 96) = *(_DWORD *)(v151 + 96) == 0;
              v205 = *(_QWORD *)(v151 + 128);
              v206 = *(_QWORD *)(v150 + 136);
              if (v206)
                *(_QWORD *)(v206 + 128) = v151;
              if (*(_DWORD *)(v151 + 100) == 1)
              {
                while (1)
                {
                  v205 = *(_QWORD *)(v205 + 128);
                  if (!v205)
                    break;
                  if (*(_DWORD *)(v205 + 100) != 2)
                    goto LABEL_290;
                }
LABEL_291:
                v205 = 0;
                *(_QWORD *)(v16 + 128) = v150;
                *(_QWORD *)(v150 + 136) = v16;
                v208 = *(_QWORD *)(v151 + 136);
                v209 = v16;
                v16 = v208;
                goto LABEL_292;
              }
              if (!v205)
                goto LABEL_291;
LABEL_290:
              v207 = *(_QWORD *)(v205 + 136);
              *(_QWORD *)(v207 + 128) = v150;
              *(_QWORD *)(v150 + 136) = v207;
              *(_QWORD *)(v205 + 136) = *(_QWORD *)(v151 + 136);
              v208 = *(_QWORD *)(v151 + 136);
              v209 = *(_QWORD *)(v150 + 136);
LABEL_292:
              *(_QWORD *)(v208 + 128) = v205;
              *(_QWORD *)(v209 + 128) = v150;
              *(_QWORD *)(v151 + 136) = v206;
              v149 = (_QWORD *)v149[4];
              if (!v149)
                goto LABEL_296;
            }
          }
          v26 = a1;
          v21 = v148;
          v20 = v147;
          v22 = v146;
          v19 = v145;
LABEL_296:
          if (v16)
          {
            v210 = v16;
            v23 = v273;
            do
            {
              v211 = *(_QWORD *)(v16 + 136);
              v212 = *(_QWORD *)(v16 + 152);
              v213 = *(_QWORD *)(v16 + 112);
              if (*(double *)(v16 + 40) != v25 || v212 == 0)
              {
                *(_QWORD *)(v16 + 120) = v213;
                *(_DWORD *)(v16 + 104) = *(_DWORD *)(v16 + 100);
                *(_QWORD *)(v16 + 84) = *(_QWORD *)(v16 + 76);
                *(_QWORD *)(v16 + 48) = *(_QWORD *)(v16 + 56);
                v17 = v210;
              }
              else
              {
                *(_QWORD *)(v212 + 120) = v213;
                *(_DWORD *)(v212 + 104) = *(_DWORD *)(v16 + 100);
                *(_DWORD *)(v212 + 84) = *(_DWORD *)(v16 + 76);
                *(_DWORD *)(v212 + 88) = *(_DWORD *)(v16 + 80);
                v215 = *(_QWORD *)(v16 + 128);
                v17 = v212;
                if (v215)
                {
                  *(_QWORD *)(v215 + 136) = v212;
                  v17 = v210;
                }
                if (v211)
                  *(_QWORD *)(v211 + 128) = v212;
                *(_QWORD *)(v212 + 128) = v215;
                *(_QWORD *)(v212 + 136) = v211;
                v210 = v17;
              }
              *(_QWORD *)(v16 + 112) = 0;
              v16 = v211;
            }
            while (v211);
          }
          else
          {
            v17 = 0;
            v23 = v273;
          }
          v277 = v17;
          v13 = v275;
          v18 = HIDWORD(v275);
          v16 = v17;
        }
      }
      while (v18 < v13);
      v4 = (uint64_t)v241;
      v216 = v242;
      *((_QWORD *)v241 + 1) = 0;
      *((_QWORD *)v241 + 2) = 0;
      v217 = v243;
      v218 = (_QWORD *)v263;
      if (v263)
      {
        v219 = 0;
        v220 = v263;
        while (1)
        {
          if (*(_DWORD *)v220)
          {
            v221 = *(_QWORD **)(*(_QWORD *)(v220 + 32) + 8);
            if (!v221)
              goto LABEL_323;
            v222 = -1;
            v223 = *(_QWORD *)(*(_QWORD *)(v220 + 32) + 8);
            do
            {
              v223 = *(_QWORD *)(v223 + 16);
              ++v222;
            }
            while (v223);
            if (v222 <= 1)
            {
              do
              {
                v224 = (_QWORD *)v221[2];
                gpc_free(v221);
                v221 = v224;
              }
              while (v224);
LABEL_323:
              *(_DWORD *)v220 = 0;
              goto LABEL_324;
            }
            *(_DWORD *)v220 = v222 + 1;
            ++v219;
          }
LABEL_324:
          v220 = *(_QWORD *)(v220 + 24);
          if (!v220)
          {
            *v241 = v219;
            if (v219 >= 1)
            {
              *((_QWORD *)v241 + 1) = gpc_malloc(4 * v219);
              v225 = *v241;
              if ((_DWORD)v225)
                v226 = gpc_malloc(16 * v225);
              else
                v226 = 0;
              v227 = 0;
              *((_QWORD *)v241 + 2) = v226;
              do
              {
                v228 = (_QWORD *)v218[3];
                if (*(_DWORD *)v218)
                {
                  v229 = v218[4];
                  *(_DWORD *)(*((_QWORD *)v241 + 1) + 4 * v227) = *(_DWORD *)(v229 + 4);
                  v230 = *(int *)v218;
                  v231 = *((_QWORD *)v241 + 2);
                  *(_DWORD *)(v231 + 16 * v227) = v230;
                  if ((_DWORD)v230)
                  {
                    v232 = gpc_malloc(16 * v230);
                    v233 = *((_QWORD *)v241 + 2) + 16 * v227;
                    *(_QWORD *)(v233 + 8) = v232;
                    LODWORD(v230) = *(_DWORD *)v233;
                    v229 = v218[4];
                  }
                  else
                  {
                    *(_QWORD *)(v231 + 16 * v227 + 8) = 0;
                  }
                  v234 = *(_QWORD **)(v229 + 8);
                  if (v234)
                  {
                    v235 = 16 * (int)v230 - 16;
                    do
                    {
                      v236 = (_QWORD *)v234[2];
                      *(_OWORD *)(*(_QWORD *)(*((_QWORD *)v241 + 2) + 16 * v227 + 8) + v235) = *(_OWORD *)v234;
                      gpc_free(v234);
                      v235 -= 16;
                      v234 = v236;
                    }
                    while (v236);
                  }
                  ++v227;
                }
                gpc_free(v218);
                v218 = v228;
              }
              while (v228);
            }
LABEL_341:
            clean_polygon((int *)v4);
            v237 = v278;
            if (v278)
            {
              do
              {
                v238 = (_QWORD *)v237[4];
                gpc_free(v237);
                v237 = v238;
              }
              while (v238);
            }
            v239 = v276;
            if (v276)
            {
              do
              {
                v240 = (_QWORD *)v239[2];
                gpc_free(v239);
                v239 = v240;
              }
              while (v240);
            }
            if (v216)
              gpc_free(v216);
            if (v217)
              gpc_free(v217);
            v15 = v244;
            if (v244)
LABEL_350:
              gpc_free(v15);
            return;
          }
        }
      }
    }
    *(_DWORD *)v4 = 0;
    goto LABEL_341;
  }
  if (a2 == (unsigned int *)v4)
    TSDgpc_free_polygon((uint64_t)a2);
  if (a3 == (int *)v4)
    TSDgpc_free_polygon(v4);
  *(_DWORD *)v4 = 0;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  if (v11)
    gpc_free(v11);
  if (v12)
  {
    v15 = v12;
    goto LABEL_350;
  }
}

void minimax_test(uint64_t a1, int *a2, int a3)
{
  char *contour_bboxes;
  char *v7;
  int v8;
  uint64_t v9;
  int v10;
  _QWORD *v11;
  uint64_t i;
  uint64_t v13;
  double *v14;
  double v15;
  double *v16;
  int v17;
  _BOOL4 v18;
  uint64_t v19;
  int *v20;
  int *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  int *v29;
  uint64_t v30;
  int v31;

  contour_bboxes = create_contour_bboxes((int *)a1);
  v7 = create_contour_bboxes(a2);
  v8 = *(_DWORD *)a1;
  LODWORD(v9) = *a2;
  v10 = *a2 * *(_DWORD *)a1;
  if (v10)
  {
    v11 = gpc_malloc(4 * v10);
    v8 = *(_DWORD *)a1;
    LODWORD(v9) = *a2;
  }
  else
  {
    v11 = 0;
  }
  if (v8 >= 1)
  {
    for (i = 0; i < v8; ++i)
    {
      if ((int)v9 >= 1)
      {
        v13 = 0;
        v14 = (double *)&contour_bboxes[32 * i];
        v15 = v14[2];
        v16 = (double *)(v7 + 16);
        do
        {
          if (v15 >= *(v16 - 2) && *v14 <= *v16)
          {
            v18 = v14[3] < *(v16 - 1) || v14[1] > v16[1];
            v17 = !v18;
          }
          else
          {
            v17 = 0;
          }
          *((_DWORD *)v11 + (int)i + *(_DWORD *)a1 * (int)v13++) = v17;
          v9 = *a2;
          v16 += 4;
        }
        while (v13 < v9);
        v8 = *(_DWORD *)a1;
      }
    }
  }
  if ((int)v9 >= 1)
  {
    v19 = 0;
    v20 = (int *)v11;
    do
    {
      v21 = v20;
      v22 = v8 & ~(v8 >> 31);
      while (v22)
      {
        v23 = *v21++;
        --v22;
        if (v23)
          goto LABEL_25;
      }
      *(_DWORD *)(*((_QWORD *)a2 + 2) + 16 * v19) = -*(_DWORD *)(*((_QWORD *)a2 + 2) + 16 * v19);
LABEL_25:
      ++v19;
      v20 += v8;
    }
    while (v19 != v9);
  }
  if (a3 == 1 && v8 >= 1)
  {
    v24 = 0;
    v25 = v8;
    v26 = (v9 & ~((int)v9 >> 31)) + 1;
    v27 = 4 * v8;
    v28 = (int *)v11;
    do
    {
      v29 = v28;
      v30 = v26;
      while (--v30)
      {
        v31 = *v29;
        v29 = (int *)((char *)v29 + v27);
        if (v31)
          goto LABEL_34;
      }
      *(_DWORD *)(*(_QWORD *)(a1 + 16) + 16 * v24) = -*(_DWORD *)(*(_QWORD *)(a1 + 16) + 16 * v24);
LABEL_34:
      ++v24;
      ++v28;
    }
    while (v24 != v25);
  }
  if (contour_bboxes)
    gpc_free(contour_bboxes);
  if (v7)
    gpc_free(v7);
  if (v11)
    gpc_free(v11);
}

double *build_lmt(double **a1, double *a2, _DWORD *a3, unsigned int *a4, int a5, int a6)
{
  uint64_t v6;
  int *v9;
  uint64_t v10;
  int v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double *v18;
  uint64_t v19;
  uint64_t v20;
  double *v21;
  uint64_t v22;
  int v23;
  _BOOL4 v24;
  __int128 v25;
  _DWORD *v26;
  uint64_t v27;
  _DWORD *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  double v33;
  double *v34;
  double *v35;
  double *v36;
  double *v37;
  int v38;
  uint64_t v39;
  int v40;
  double v41;
  double v42;
  int v43;
  uint64_t v44;
  double v45;
  uint64_t v46;
  BOOL v47;
  uint64_t v48;
  unint64_t v49;
  double *v50;
  double *v51;
  double v52;
  double v53;
  _BOOL4 v54;
  double *v55;
  double *v56;
  double v57;
  double v58;
  _DWORD *v59;
  BOOL v60;
  double *v61;
  uint64_t *v62;
  uint64_t v63;
  int v64;
  double v65;
  double v66;
  uint64_t v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  double *v73;
  double *v74;
  double v75;
  double v76;
  _BOOL4 v77;
  double *v78;
  double *v79;
  double v80;
  double v81;
  _DWORD *v82;
  double *v83;
  uint64_t *v84;
  int *v86;
  int v89;

  v6 = *a4;
  if ((int)v6 < 1)
    return 0;
  v9 = (int *)a4;
  v10 = 0;
  v11 = 0;
  do
  {
    v12 = (uint64_t *)(*((_QWORD *)a4 + 2) + 16 * v10);
    v13 = *v12;
    v14 = *v12 - 1;
    if ((int)*v12 < 1)
    {
      v16 = 0;
    }
    else
    {
      v15 = 0;
      v16 = 0;
      v17 = v12[1];
      v18 = (double *)(v17 + 8);
      do
      {
        v19 = v15 + 1;
        if (*(double *)(v17 + 16 * ((v14 + (int)v15) % (int)v13) + 8) != *v18
          || (v13 - 1 != v15 ? (v20 = v15 + 1) : (v20 = 0), *(double *)(v17 + 16 * v20 + 8) != *v18))
        {
          ++v16;
        }
        v18 += 2;
        v15 = v19;
      }
      while (v13 != v19);
    }
    v11 += v16;
    ++v10;
  }
  while (v10 != v6);
  if (v11)
  {
    v21 = (double *)gpc_malloc(168 * v11);
    LODWORD(v6) = *v9;
  }
  else
  {
    v21 = 0;
  }
  if ((int)v6 >= 1)
  {
    v22 = 0;
    v23 = 0;
    v24 = a6 == 0;
    v25 = 0uLL;
    v86 = v9;
    v26 = a3;
    do
    {
      v27 = *((_QWORD *)v9 + 2);
      v28 = (_DWORD *)(v27 + 16 * v22);
      LODWORD(v29) = *v28;
      v89 = v23;
      if ((*v28 & 0x80000000) != 0)
      {
        *v28 = -(int)v29;
      }
      else if ((_DWORD)v29)
      {
        v30 = 0;
        v31 = 0;
        do
        {
          v32 = *(_QWORD *)(v27 + 16 * v22 + 8);
          v33 = *(double *)(v32 + 16 * v30 + 8);
          if (*(double *)(v32 + 16 * (((int)v30 + (int)v29 - 1) % (int)v29) + 8) == v33
            && *(double *)(v32 + 16 * (((int)v30 + 1) % (int)v29) + 8) == v33)
          {
            ++v30;
          }
          else
          {
            v34 = &v21[21 * v31];
            *v34 = *(double *)(v32 + 16 * v30);
            v34[1] = v33;
            v35 = a2;
            while (1)
            {
              v36 = *(double **)v35;
              if (!*(_QWORD *)v35)
                break;
              if (*v36 <= v33)
              {
                if (*v36 >= v33)
                  goto LABEL_33;
                v35 = v36 + 2;
              }
              else
              {
                v35 = v36 + 1;
              }
            }
            v37 = (double *)gpc_malloc(0x18uLL);
            v25 = 0uLL;
            *(_QWORD *)v35 = v37;
            *v37 = v33;
            v37[1] = 0.0;
            *(_QWORD *)(*(_QWORD *)v35 + 16) = 0;
            ++*v26;
            v27 = *((_QWORD *)v9 + 2);
LABEL_33:
            ++v31;
            ++v30;
          }
          v29 = *(int *)(v27 + 16 * v22);
        }
        while (v30 < v29);
        v38 = v31 - 1;
        if (v31 >= 1)
        {
          v39 = 0;
          do
          {
            v40 = v39;
            v41 = v21[21 * ((v38 + (int)v39) % v31) + 1];
            v42 = v21[21 * v39++ + 1];
            if (v41 >= v42)
            {
              v43 = v39 == v31 ? 0 : v39;
              if (v21[21 * v43 + 1] > v42)
              {
                v44 = 0;
                v45 = v21[21 * v43 + 1];
                do
                {
                  v46 = v44;
                  v43 = (v43 + 1) % v31;
                  --v44;
                  v47 = v21[21 * v43 + 1] <= v45;
                  v45 = v21[21 * v43 + 1];
                }
                while (!v47);
                v48 = 0;
                v49 = 0;
                v50 = &v21[21 * v89];
                *((_DWORD *)v50 + 26) = 0;
                *((_DWORD *)v50 + 21) = 0;
                *((_DWORD *)v50 + 22) = 0;
                v51 = &v21[21 * v40];
                v53 = *v51;
                v52 = v51[1];
                do
                {
                  v54 = -(int)v44 > 1;
                  v55 = &v50[v48];
                  v55[6] = v53;
                  v55[2] = v53;
                  v55[3] = v52;
                  v40 = (v40 + 1) % v31;
                  v56 = &v21[21 * v40];
                  v57 = *v56;
                  v58 = v56[1];
                  v55[4] = *v56;
                  v55[5] = v58;
                  v55[8] = (v57 - v53) / (v58 - v52);
                  *((_DWORD *)v55 + 18) = a5;
                  LODWORD(v56) = v49++ < ~v44;
                  if ((v54 & v56) != 0)
                    v59 = v55 + 21;
                  else
                    v59 = 0;
                  *((_OWORD *)v55 + 7) = v25;
                  *((_OWORD *)v55 + 8) = v25;
                  v60 = !v54 || v48 == 0;
                  v61 = v55 - 21;
                  if (v60)
                    v61 = 0;
                  *((_QWORD *)v55 + 18) = v61;
                  *((_QWORD *)v55 + 19) = v59;
                  v55[20] = 0.0;
                  *((_DWORD *)v55 + 23) = v24;
                  *((_DWORD *)v55 + 24) = 0;
                  v48 += 21;
                  v52 = v58;
                  v53 = v57;
                }
                while (v46 + v49 != 1);
                v89 -= v44;
                v62 = (uint64_t *)bound_list(a1, v42);
                insert_bound(v62, (uint64_t)v50);
                v25 = 0uLL;
                v26 = a3;
              }
            }
          }
          while (v39 != v31);
          v63 = 0;
          do
          {
            v64 = (v38 + (int)v63) % v31;
            v65 = v21[21 * v64 + 1];
            v66 = v21[21 * v63 + 1];
            v67 = v63 + 1;
            if (v65 > v66)
            {
              v68 = v63 + 1;
              if (v67 == v31)
                v68 = 0;
              if (v21[21 * v68 + 1] >= v66)
              {
                v69 = 0;
                do
                {
                  v70 = v69;
                  v64 = (v38 + v64) % v31;
                  --v69;
                  v47 = v21[21 * v64 + 1] <= v65;
                  v65 = v21[21 * v64 + 1];
                }
                while (!v47);
                v71 = 0;
                v72 = 0;
                v73 = &v21[21 * v89];
                *((_DWORD *)v73 + 26) = 0;
                *((_DWORD *)v73 + 21) = 0;
                *((_DWORD *)v73 + 22) = 0;
                v74 = &v21[21 * (int)v63];
                v76 = *v74;
                v75 = v74[1];
                do
                {
                  v77 = -(int)v69 > 1;
                  v78 = &v73[v71];
                  v78[6] = v76;
                  v78[2] = v76;
                  v78[3] = v75;
                  LODWORD(v63) = (v38 + (int)v63) % v31;
                  v79 = &v21[21 * (int)v63];
                  v80 = *v79;
                  v81 = v79[1];
                  v78[4] = *v79;
                  v78[5] = v81;
                  v78[8] = (v80 - v76) / (v81 - v75);
                  *((_DWORD *)v78 + 18) = a5;
                  LODWORD(v79) = v72++ < ~v69;
                  if ((v77 & v79) != 0)
                    v82 = v78 + 21;
                  else
                    v82 = 0;
                  *((_OWORD *)v78 + 7) = v25;
                  *((_OWORD *)v78 + 8) = v25;
                  v60 = !v77 || v71 == 0;
                  v83 = v78 - 21;
                  if (v60)
                    v83 = 0;
                  *((_QWORD *)v78 + 18) = v83;
                  *((_QWORD *)v78 + 19) = v82;
                  v78[20] = 0.0;
                  *((_DWORD *)v78 + 23) = v24;
                  *((_DWORD *)v78 + 24) = 0;
                  v71 += 21;
                  v75 = v81;
                  v76 = v80;
                }
                while (v70 + v72 != 1);
                v89 -= v69;
                v84 = (uint64_t *)bound_list(a1, v66);
                insert_bound(v84, (uint64_t)v73);
                v25 = 0uLL;
                v26 = a3;
              }
            }
            v63 = v67;
          }
          while (v67 != v31);
        }
      }
      ++v22;
      v9 = v86;
      v23 = v89;
    }
    while (v22 < *v86);
  }
  return v21;
}

double build_sbt(int *a1, uint64_t a2, uint64_t a3)
{
  double result;
  uint64_t v7;

  do
  {
    if (*(_QWORD *)(a3 + 8))
      build_sbt(a1, a2);
    result = *(double *)a3;
    v7 = *a1;
    *(_QWORD *)(a2 + 8 * v7) = *(_QWORD *)a3;
    *a1 = v7 + 1;
    a3 = *(_QWORD *)(a3 + 16);
  }
  while (a3);
  return result;
}

void free_sbtree(_QWORD **a1)
{
  if (*a1)
  {
    free_sbtree(*a1 + 1);
    free_sbtree(*a1 + 2);
    if (*a1)
    {
      gpc_free(*a1);
      *a1 = 0;
    }
  }
}

uint64_t *add_edge_to_aet(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  double v4;
  double v5;
  uint64_t v6;

  v3 = *result;
  if (*result)
  {
    v4 = *(double *)(a2 + 48);
    while (1)
    {
      v5 = *(double *)(v3 + 48);
      if (v4 < v5)
        break;
      v6 = v3;
      if (v4 == v5 && *(double *)(a2 + 64) < *(double *)(v3 + 64))
        break;
      result = (uint64_t *)(v3 + 136);
      v3 = *(_QWORD *)(v3 + 136);
      a3 = v6;
      if (!v3)
        goto LABEL_9;
    }
    *(_QWORD *)(a2 + 128) = a3;
    *(_QWORD *)(a2 + 136) = *result;
    *(_QWORD *)(*result + 128) = a2;
    *result = a2;
  }
  else
  {
    v6 = a3;
LABEL_9:
    *result = a2;
    *(_QWORD *)(a2 + 128) = v6;
    *(_QWORD *)(a2 + 136) = 0;
  }
  return result;
}

uint64_t merge_right(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(_QWORD *)(a2 + 32);
  *(_DWORD *)(v3 + 4) = 0;
  v4 = *(_QWORD *)(result + 32);
  if (v4 != v3)
  {
    *(_QWORD *)(*(_QWORD *)(v3 + 16) + 16) = *(_QWORD *)(v4 + 8);
    *(_QWORD *)(v3 + 16) = *(_QWORD *)(v4 + 16);
    if (a3)
    {
      v5 = *(_QWORD *)(result + 32);
      do
      {
        if (*(_QWORD *)(a3 + 32) == v5)
        {
          *(_DWORD *)a3 = 0;
          *(_QWORD *)(a3 + 32) = *(_QWORD *)(a2 + 32);
        }
        a3 = *(_QWORD *)(a3 + 24);
      }
      while (a3);
    }
  }
  return result;
}

uint64_t merge_left(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(_QWORD *)(a2 + 32);
  *(_DWORD *)(v3 + 4) = 1;
  v4 = *(_QWORD *)(result + 32);
  if (v4 != v3)
  {
    *(_QWORD *)(*(_QWORD *)(v4 + 16) + 16) = *(_QWORD *)(v3 + 8);
    *(_QWORD *)(v3 + 8) = *(_QWORD *)(v4 + 8);
    if (a3)
    {
      v5 = *(_QWORD *)(result + 32);
      do
      {
        if (*(_QWORD *)(a3 + 32) == v5)
        {
          *(_DWORD *)a3 = 0;
          *(_QWORD *)(a3 + 32) = *(_QWORD *)(a2 + 32);
        }
        a3 = *(_QWORD *)(a3 + 24);
      }
      while (a3);
    }
  }
  return result;
}

double *build_intersection_table(double **a1, uint64_t a2, double a3)
{
  double *result;
  double *v7;
  double *v8;
  double *v9;
  void **v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  BOOL v18;
  double v19;
  double v20;
  double v21;
  double *v22;
  double **v23;
  double *v24;
  double *v25;
  double *v26;
  char *v27;
  double *v28;
  _QWORD *v29;
  double *v30;
  _QWORD *v31;
  double *v32;
  void *v33;

  result = *a1;
  if (result)
  {
    do
    {
      v7 = (double *)*((_QWORD *)result + 4);
      gpc_free(result);
      *a1 = v7;
      result = v7;
    }
    while (v7);
  }
  v33 = 0;
  if (a2)
  {
    while (1)
    {
      if (*(_DWORD *)(a2 + 100) == 1 || *(_DWORD *)(a2 + 76) || *(_DWORD *)(a2 + 80))
      {
        v8 = (double *)v33;
        if (v33)
        {
          v9 = (double *)(a2 + 64);
          v10 = &v33;
          while (1)
          {
            v11 = v8[2];
            v12 = *(double *)(a2 + 56);
            if (v12 >= v11
              || ((v13 = v8[1],
                   v14 = v11 - v13,
                   v15 = *(double *)(a2 + 48),
                   v16 = v14 - (v12 - v15),
                   v17 = fabs(v16),
                   *v9 != v8[3])
                ? (v18 = v17 > 2.22044605e-16)
                : (v18 = 0),
                  !v18))
            {
              v29 = gpc_malloc(0x28uLL);
              *v10 = v29;
              *v29 = a2;
              v30 = (double *)*v10;
              *(_OWORD *)((char *)*v10 + 8) = *(_OWORD *)(a2 + 48);
              goto LABEL_28;
            }
            v19 = (v15 - v13) / v16;
            v20 = v19 * a3;
            v21 = *v8;
            v22 = *a1;
            v23 = a1;
            if (!*a1)
              goto LABEL_22;
            v23 = a1;
            if (v22[3] <= v20)
              break;
LABEL_20:
            v25 = (double *)gpc_malloc(0x28uLL);
LABEL_23:
            *v23 = v25;
            *v25 = v21;
            *((_QWORD *)*v23 + 1) = a2;
            v26 = *v23;
            v26[2] = v13 + v19 * v14;
            v26[3] = v20;
            *((_QWORD *)v26 + 4) = v22;
            v27 = (char *)*v10;
            v28 = (double *)*((_QWORD *)v27 + 4);
            v10 = (void **)(v27 + 32);
            v8 = v28;
            if (!v28)
              goto LABEL_27;
          }
          while (1)
          {
            v24 = v22;
            v22 = (double *)*((_QWORD *)v22 + 4);
            if (!v22)
              break;
            if (v22[3] > v20)
            {
              v23 = (double **)(v24 + 4);
              goto LABEL_20;
            }
          }
          v23 = (double **)(v24 + 4);
LABEL_22:
          v25 = (double *)gpc_malloc(0x28uLL);
          v22 = 0;
          goto LABEL_23;
        }
        v10 = &v33;
LABEL_27:
        v31 = gpc_malloc(0x28uLL);
        v8 = 0;
        *v10 = v31;
        *v31 = a2;
        v30 = (double *)*v10;
        *(_OWORD *)((char *)*v10 + 8) = *(_OWORD *)(a2 + 48);
        v9 = (double *)(a2 + 64);
LABEL_28:
        v30[3] = *v9;
        *((_QWORD *)v30 + 4) = v8;
      }
      a2 = *(_QWORD *)(a2 + 136);
      if (!a2)
      {
        result = (double *)v33;
        if (v33)
        {
          do
          {
            v32 = (double *)*((_QWORD *)result + 4);
            gpc_free(result);
            result = v32;
          }
          while (v32);
        }
        return result;
      }
    }
  }
  return result;
}

void TSDgpc_free_tristrip(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;

  v2 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
  {
    v3 = 0;
    v4 = 8;
    do
    {
      v5 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + v4);
      if (v5)
      {
        gpc_free(v5);
        *(_QWORD *)(*(_QWORD *)(a1 + 8) + v4) = 0;
        v2 = *(_DWORD *)a1;
      }
      ++v3;
      v4 += 16;
    }
    while (v3 < v2);
  }
  v6 = *(_QWORD **)(a1 + 8);
  if (v6)
  {
    gpc_free(v6);
    *(_QWORD *)(a1 + 8) = 0;
  }
  *(_DWORD *)a1 = 0;
}

void TSDgpc_polygon_to_tristrip(unsigned int *a1, uint64_t a2)
{
  _QWORD v2[3];

  memset(v2, 0, sizeof(v2));
  TSDgpc_tristrip_clip(0, a1, (int *)v2, a2);
}

void TSDgpc_tristrip_clip(uint64_t a1, unsigned int *a2, int *a3, uint64_t a4)
{
  uint64_t v5;
  int v6;
  int v7;
  double *v10;
  double *v11;
  int v12;
  double *v13;
  double *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  double v23;
  double v24;
  uint64_t v25;
  double v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  _BOOL4 v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  BOOL v51;
  int v54;
  int v55;
  BOOL v56;
  int v57;
  BOOL v58;
  BOOL v59;
  BOOL v61;
  int v63;
  int v64;
  BOOL v65;
  int v66;
  double v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  double **v72;
  double **v73;
  double *v74;
  double *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  double **v79;
  double **v80;
  double *v81;
  double *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  double **v88;
  double **v89;
  double *v90;
  double *v91;
  double **v92;
  double **v93;
  double *v94;
  double *v95;
  uint64_t v96;
  uint64_t v97;
  double **v98;
  double **v99;
  double *v100;
  double *v101;
  double **v102;
  double **v103;
  double *v104;
  double *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  double **v109;
  uint64_t v110;
  uint64_t v111;
  double **v112;
  double *v113;
  double *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  double **v121;
  double **v122;
  double *v123;
  double *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  double **v132;
  double **v133;
  double *v134;
  double *v135;
  _DWORD *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  double **v141;
  double **v142;
  double *v143;
  double *v144;
  int v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  double **v154;
  uint64_t v155;
  uint64_t v156;
  double **v157;
  double *v158;
  double *v159;
  uint64_t v160;
  double **v161;
  double **v162;
  double *v163;
  double *v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  double **v168;
  double **v169;
  double *v170;
  double *v171;
  uint64_t v172;
  uint64_t v173;
  double **v174;
  double **v175;
  double *v176;
  double *v177;
  double **v178;
  double **v179;
  double *v180;
  double *v181;
  double **v182;
  uint64_t v183;
  uint64_t v184;
  double **v185;
  double *v186;
  double *v187;
  double **v188;
  double **v189;
  double *v190;
  double *v191;
  uint64_t v192;
  double v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  double v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t *v202;
  uint64_t v203;
  uint64_t v204;
  int v205;
  int v206;
  uint64_t v207;
  _DWORD **v208;
  uint64_t v209;
  _QWORD *v210;
  __int128 v211;
  int v212;
  int v213;
  int v214;
  int v215;
  int v216;
  int v217;
  int v218;
  double v221;
  uint64_t v222;
  double **v223;
  double **v224;
  double *v225;
  double *v226;
  uint64_t v227;
  double v228;
  double v229;
  double v230;
  double **v231;
  double **v232;
  double *v233;
  double *v234;
  double **v235;
  double **v236;
  double *v237;
  double v238;
  uint64_t v239;
  uint64_t v240;
  double **v241;
  double **v242;
  double *v243;
  double v244;
  double *v245;
  double **v246;
  double **v247;
  double *v248;
  double *v249;
  _DWORD *v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  double **v255;
  double **v256;
  double *v257;
  double *v258;
  double **v259;
  double **v260;
  double *v261;
  double *v262;
  uint64_t v263;
  uint64_t v264;
  double **v265;
  double **v266;
  double *v267;
  double v268;
  double *v269;
  double **v270;
  double **v271;
  double *v272;
  double *v273;
  double **v274;
  double **v275;
  double *v276;
  double *v277;
  uint64_t v278;
  uint64_t v279;
  double **v280;
  double **v281;
  double *v282;
  double v283;
  double *v284;
  uint64_t v285;
  uint64_t v286;
  double **v287;
  double **v288;
  double *v289;
  double v290;
  double *v291;
  uint64_t v292;
  double **v293;
  double **v294;
  double *v295;
  double *v296;
  uint64_t v297;
  double **v298;
  double **v299;
  double *v300;
  double *v301;
  uint64_t v302;
  uint64_t v303;
  double **v304;
  double **v305;
  double *v306;
  double v307;
  double *v308;
  uint64_t v309;
  double **v310;
  double **v311;
  double *v312;
  double v313;
  double *v314;
  uint64_t v315;
  double **v316;
  double **v317;
  double *v318;
  double *v319;
  uint64_t v320;
  double **v321;
  double **v322;
  double *v323;
  double **v324;
  double **v325;
  double *v326;
  double *v327;
  uint64_t v328;
  double **v329;
  double *v330;
  double *v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  double **v337;
  double **v338;
  double *v339;
  double *v340;
  double **v341;
  double **v342;
  double *v343;
  double *v344;
  uint64_t v345;
  uint64_t v346;
  double **v347;
  double **v348;
  double *v349;
  double v350;
  double *v351;
  uint64_t v352;
  uint64_t v353;
  double **v354;
  double **v355;
  double *v356;
  double v357;
  double *v358;
  uint64_t v359;
  double **v360;
  double **v361;
  double *v362;
  double *v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v370;
  int *v371;
  _DWORD *v372;
  unsigned int v373;
  int *v374;
  int v375;
  int *v376;
  uint64_t v377;
  unint64_t v378;
  unint64_t v379;
  BOOL v380;
  BOOL v381;
  int v382;
  _QWORD *v383;
  _QWORD *v384;
  _QWORD *v385;
  _QWORD *v386;
  _QWORD *v387;
  _QWORD *v388;
  _QWORD *v389;
  _QWORD *v390;
  _QWORD *v391;
  _QWORD *v392;
  double *v393;
  double *v394;
  uint64_t v395;
  double *v396;
  uint64_t v397;
  _QWORD *v398;
  unsigned int v399;
  int v400;
  unsigned int v401;
  unsigned int v402;
  unsigned int v403;
  unsigned int v404;
  unsigned int v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  double v409;
  uint64_t v410;
  double v411;
  double v412;
  uint64_t v413;
  uint64_t v414;
  unsigned int v415;
  unsigned int v416;
  unsigned int v417;
  unsigned int v418;
  unsigned int v419;
  unsigned int v420;
  unsigned int v421;
  unsigned int v422;
  unsigned int v423;
  unsigned int v424;
  unsigned int v425;
  unsigned int v426;
  unsigned int v427;
  uint64_t v428;
  uint64_t v429;
  int *v430;
  void *v431;
  uint64_t v432;
  void *v433;
  _QWORD *v434[2];

  v5 = a1;
  v433 = 0;
  v434[0] = 0;
  v431 = 0;
  v432 = 0;
  v429 = 0;
  v430 = 0;
  v6 = *a2;
  v7 = *a3;
  if (!*a2)
  {
    if (a1 >= 2 && v7)
    {
      v395 = a4;
      LODWORD(v428) = 0;
      goto LABEL_15;
    }
LABEL_18:
    *(_DWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    return;
  }
  if ((_DWORD)a1 == 1 && !v7)
    goto LABEL_18;
  v395 = a4;
  LODWORD(v428) = a1 == 0;
  if (a1 <= 1 && v6 >= 1 && v7 >= 1)
  {
    minimax_test((uint64_t)a2, a3, a1);
    v6 = *a2;
  }
  if (v6 >= 1)
  {
    v10 = build_lmt((double **)&v431, (double *)v434, &v429, a2, 1, v5);
    goto LABEL_16;
  }
LABEL_15:
  v10 = 0;
LABEL_16:
  if (*a3 < 1)
    v11 = 0;
  else
    v11 = build_lmt((double **)&v431, (double *)v434, &v429, (unsigned int *)a3, 0, v5);
  if (v431)
  {
    v398 = v431;
    v394 = v10;
    v12 = v429;
    if ((_DWORD)v429)
      v13 = (double *)gpc_malloc(8 * (int)v429);
    else
      v13 = 0;
    v396 = v13;
    build_sbt((int *)&v429 + 1, (uint64_t)v13, (uint64_t)v434[0]);
    free_sbtree(v434);
    v393 = v11;
    if (v12 <= 0)
    {
      v372 = (_DWORD *)v395;
      *(_QWORD *)(v395 + 8) = 0;
    }
    else
    {
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      HIDWORD(v428) = 0;
      v400 = 0;
      v401 = v5;
      v397 = 0;
      v23 = 0.0;
      v24 = 0.0;
      do
      {
        v25 = v17 + 1;
        HIDWORD(v429) = v25;
        v26 = v396[v17];
        if ((int)v25 < v12)
        {
          v24 = v396[v25];
          v23 = v24 - v26;
        }
        v27 = v398;
        if (v398)
        {
          if (*(double *)v398 == v26)
          {
            v28 = v398[1];
            if (v28)
            {
              v29 = v21;
              v30 = v22;
              v31 = v18;
              v32 = v19;
              v33 = v20;
              do
              {
                add_edge_to_aet(&v432, v28, 0);
                v28 = *(_QWORD *)(v28 + 160);
              }
              while (v28);
              v15 = v432;
              v27 = v398;
              v20 = v33;
              v19 = v32;
              v18 = v31;
              v22 = v30;
              v5 = v401;
              v21 = v29;
            }
            v398 = (_QWORD *)v27[2];
            v16 = v15;
          }
        }
        else
        {
          v398 = 0;
        }
        *(_DWORD *)(v16 + 76 + 4 * *(int *)(v16 + 72)) = *(double *)(v16 + 40) != v26;
        *(_DWORD *)(v16 + 76 + 4 * (*(_DWORD *)(v16 + 72) == 0)) = 0;
        *(_DWORD *)(v16 + 100) = 0;
        v34 = *(_QWORD *)(v16 + 136);
        v35 = v16;
        if (!v34)
          goto LABEL_50;
        do
        {
          v36 = v34 + 76;
          *(_DWORD *)(v34 + 76 + 4 * *(int *)(v34 + 72)) = *(double *)(v34 + 40) != v26;
          v37 = *(int *)(v34 + 72);
          *(_DWORD *)(v34 + 76 + 4 * (*(_DWORD *)(v34 + 72) == 0)) = 0;
          *(_DWORD *)(v34 + 100) = 0;
          v38 = *(_DWORD *)(v34 + 76 + 4 * v37);
          if (v38)
          {
            v39 = v34;
            if (vabdd_f64(*(double *)(v35 + 48), *(double *)(v34 + 48)) <= 2.22044605e-16)
            {
              v39 = v34;
              if (vabdd_f64(*(double *)(v35 + 64), *(double *)(v34 + 64)) <= 2.22044605e-16)
              {
                v39 = v34;
                if (*(double *)(v35 + 40) != v26)
                {
                  *(_DWORD *)(v36 + 4 * v37) = *(_DWORD *)(v35 + 76 + 4 * v37) ^ v38;
                  v40 = *(_DWORD *)(v34 + 72) == 0;
                  v41 = *(_DWORD *)(v35 + 76 + 4 * (*(_DWORD *)(v34 + 72) == 0));
                  *(_DWORD *)(v34 + 100) = 1;
                  *(_DWORD *)(v36 + 4 * v40) = v41;
                  *(_DWORD *)(v35 + 76) = 0;
                  *(_DWORD *)(v35 + 80) = 0;
                  *(_DWORD *)(v35 + 100) = 2;
                  v39 = v34;
                }
              }
            }
          }
          else
          {
            v39 = v35;
          }
          v34 = *(_QWORD *)(v34 + 136);
          v35 = v39;
        }
        while (v34);
        if (v16)
        {
LABEL_50:
          v42 = 0;
          v43 = 0;
          v44 = v397;
          while (1)
          {
            v46 = *(_DWORD *)(v16 + 76);
            v45 = *(_DWORD *)(v16 + 80);
            v48 = *(_DWORD *)(v16 + 84);
            v47 = *(_DWORD *)(v16 + 88);
            v49 = v46 + 2 * v48;
            v50 = v45 + 2 * v47;
            if (!(v49 | v50))
              goto LABEL_199;
            *(_QWORD *)(v16 + 92) = v428;
            if (v5 < 2)
            {
              if (!v49 || (v22 = 1, !HIDWORD(v428)) && !v43)
              {
                if (!v50 || (v22 = 1, !(_DWORD)v428) && !v42)
                {
                  if (v49)
                    v59 = v50 == 0;
                  else
                    v59 = 1;
                  v22 = !v59 && (_DWORD)v428 == HIDWORD(v428);
                }
              }
              if ((_DWORD)v428)
                v61 = HIDWORD(v428) == 0;
              else
                v61 = 1;
              v20 = !v61;
              v21 = (_DWORD)v428 != v46 && HIDWORD(v428) != v45;
              v63 = v428 ^ (v42 != 0);
              v64 = v43 != 0;
              if (v63)
                v65 = HIDWORD(v428) == v64;
              else
                v65 = 1;
              v18 = !v65;
              v66 = v47 ^ v64;
              v58 = v63 == v48 || v66 == HIDWORD(v428);
            }
            else
            {
              if ((_DWORD)v5 == 2)
              {
                v20 = HIDWORD(v428) ^ v428;
                v21 = v20 ^ v46 ^ v45;
                v18 = v428 ^ HIDWORD(v428) ^ (v42 != 0) ^ (v43 != 0);
                v19 = v18 ^ v48 ^ v47;
                v22 = 1;
                goto LABEL_125;
              }
              if ((_DWORD)v5 != 3)
                goto LABEL_125;
              if (!v49 || (v22 = 1, HIDWORD(v428)) && !v43)
              {
                if (!v50 || (v22 = 1, (_DWORD)v428) && !v42)
                {
                  if (v49)
                    v51 = v50 == 0;
                  else
                    v51 = 1;
                  v22 = !v51 && (_DWORD)v428 == HIDWORD(v428);
                }
              }
              v20 = v428 != 0;
              v21 = (_DWORD)v428 != v46 || HIDWORD(v428) != v45;
              v54 = v428 ^ (v42 != 0);
              v55 = v43 != 0;
              if (v54)
                v56 = 0;
              else
                v56 = HIDWORD(v428) == v55;
              v18 = !v56;
              v57 = v47 ^ v55;
              v58 = v54 == v48 && v57 == HIDWORD(v428);
            }
            v19 = !v58;
LABEL_125:
            LODWORD(v428) = v46 ^ v428;
            if (v49)
              v42 = TSDnext_h_state[6 * v42 - 2 + 2 * v49 + (int)v428];
            HIDWORD(v428) ^= v45;
            if (v50)
              v43 = TSDnext_h_state[6 * v43 - 2 + 2 * v50 + HIDWORD(v428)];
            if ((_DWORD)v22)
            {
              v22 = 1;
              v67 = *(double *)(v16 + 48);
              switch(4 * (_DWORD)v20 + 8 * (_DWORD)v21 + 2 * (_DWORD)v19 + (_DWORD)v18)
              {
                case 1:
                  if (v67 != *(double *)(v44 + 48))
                  {
                    v68 = v21;
                    v69 = v18;
                    v70 = v19;
                    v71 = v20;
                    v72 = (double **)(*(_QWORD *)(v16 + 120) + 16);
                    do
                    {
                      v73 = v72;
                      v74 = *v72;
                      v72 = (double **)(*v72 + 2);
                    }
                    while (v74);
                    v75 = (double *)gpc_malloc(0x18uLL);
                    *v73 = v75;
                    *v75 = v67;
                    v75[1] = v26;
                    v75[2] = 0.0;
                    ++**(_DWORD **)(v16 + 120);
                    v20 = v71;
                    v19 = v70;
                    v18 = v69;
                    v21 = v68;
                    v5 = v401;
                  }
                  v44 = 0;
                  *(_QWORD *)(v16 + 112) = 0;
                  v22 = 1;
                  break;
                case 2:
                  v425 = v21;
                  v76 = v18;
                  v77 = v19;
                  v78 = v20;
                  v79 = (double **)(*(_QWORD *)(v16 + 120) + 8);
                  do
                  {
                    v80 = v79;
                    v81 = *v79;
                    v79 = (double **)(*v79 + 2);
                  }
                  while (v81);
                  v82 = (double *)gpc_malloc(0x18uLL);
                  *v80 = v82;
                  *v82 = v67;
                  v82[1] = v26;
                  v82[2] = 0.0;
                  ++**(_DWORD **)(v16 + 120);
                  *(_QWORD *)(v16 + 112) = 0;
                  v44 = v16;
                  v20 = v78;
                  v19 = v77;
                  v18 = v76;
                  v22 = 1;
                  goto LABEL_198;
                case 4:
                  v83 = *(_QWORD *)(v44 + 112);
                  *(_QWORD *)(v16 + 112) = v83;
                  if (v67 == *(double *)(v44 + 48))
                  {
                    v44 = 0;
                    break;
                  }
                  v84 = v21;
                  v85 = v18;
                  v86 = v19;
                  v87 = v20;
                  v88 = (double **)(v83 + 16);
                  do
                  {
                    v89 = v88;
                    v90 = *v88;
                    v88 = (double **)(*v88 + 2);
                  }
                  while (v90);
                  v91 = (double *)gpc_malloc(0x18uLL);
                  v44 = 0;
                  *v89 = v91;
                  *v91 = v67;
                  v91[1] = v26;
                  v91[2] = 0.0;
                  ++**(_DWORD **)(v16 + 112);
                  goto LABEL_148;
                case 5:
                  *(_QWORD *)(v16 + 112) = *(_QWORD *)(v44 + 112);
                  if (v400 != 10)
                  {
                    v423 = v18;
                    v425 = v21;
                    v172 = v19;
                    v173 = v20;
                    v174 = (double **)(*(_QWORD *)(v16 + 120) + 16);
                    do
                    {
                      v175 = v174;
                      v176 = *v174;
                      v174 = (double **)(*v174 + 2);
                    }
                    while (v176);
                    v177 = (double *)gpc_malloc(0x18uLL);
                    *v175 = v177;
                    *v177 = v67;
                    v177[1] = v26;
                    v177[2] = 0.0;
                    ++**(_DWORD **)(v16 + 120);
                    v178 = (double **)(*(_QWORD *)(v16 + 112) + 16);
                    do
                    {
                      v179 = v178;
                      v180 = *v178;
                      v178 = (double **)(*v178 + 2);
                    }
                    while (v180);
                    v181 = (double *)gpc_malloc(0x18uLL);
                    v44 = 0;
                    *v179 = v181;
                    *v181 = v67;
                    v181[1] = v26;
                    v181[2] = 0.0;
                    ++**(_DWORD **)(v16 + 112);
                    v22 = 1;
LABEL_197:
                    v20 = v173;
                    v19 = v172;
                    v18 = v423;
LABEL_198:
                    v21 = v425;
                    break;
                  }
                  if (*(double *)(v44 + 24) != v26)
                  {
                    if (*(double *)(v16 + 24) != v26)
                    {
                      v44 = 0;
                      v400 = 10;
                      break;
                    }
                    v423 = v18;
                    v425 = v21;
                    v172 = v19;
                    v173 = v20;
                    v182 = (double **)(*(_QWORD *)(v44 + 120) + 8);
                    v183 = v44;
                    v184 = *(_QWORD *)(v44 + 48);
                    do
                    {
                      v185 = v182;
                      v186 = *v182;
                      v182 = (double **)(*v182 + 2);
                    }
                    while (v186);
                    v187 = (double *)gpc_malloc(0x18uLL);
                    *v185 = v187;
                    *(_QWORD *)v187 = v184;
                    v187[1] = v26;
                    v187[2] = 0.0;
                    ++**(_DWORD **)(v183 + 120);
                    v188 = (double **)(*(_QWORD *)(v16 + 120) + 16);
                    do
                    {
                      v189 = v188;
                      v190 = *v188;
                      v188 = (double **)(*v188 + 2);
                    }
                    while (v190);
                    v191 = (double *)gpc_malloc(0x18uLL);
                    v44 = 0;
                    *v189 = v191;
                    *v191 = v67;
                    v191[1] = v26;
                    v191[2] = 0.0;
                    ++**(_DWORD **)(v16 + 120);
                    v22 = 1;
                    v400 = 10;
                    goto LABEL_197;
                  }
                  v84 = v21;
                  v85 = v18;
                  v86 = v19;
                  v87 = v20;
                  v92 = (double **)(*(_QWORD *)(v16 + 120) + 16);
                  do
                  {
                    v93 = v92;
                    v94 = *v92;
                    v92 = (double **)(*v92 + 2);
                  }
                  while (v94);
                  v95 = (double *)gpc_malloc(0x18uLL);
                  v44 = 0;
                  *v93 = v95;
                  *v95 = v67;
                  v95[1] = v26;
                  v95[2] = 0.0;
                  ++**(_DWORD **)(v16 + 120);
                  v400 = 10;
LABEL_148:
                  v20 = v87;
                  v19 = v86;
                  v18 = v85;
LABEL_190:
                  v22 = 1;
LABEL_191:
                  v21 = v84;
                  v5 = v401;
                  break;
                case 6:
                  v96 = v44;
                  v415 = v19;
                  v420 = v18;
                  v97 = v20;
                  v98 = (double **)(*(_QWORD *)(v16 + 120) + 8);
                  do
                  {
                    v99 = v98;
                    v100 = *v98;
                    v98 = (double **)(*v98 + 2);
                  }
                  while (v100);
                  v101 = (double *)gpc_malloc(0x18uLL);
                  *v99 = v101;
                  *v101 = v67;
                  v101[1] = v26;
                  v101[2] = 0.0;
                  ++**(_DWORD **)(v16 + 120);
                  *(_QWORD *)(v16 + 112) = *(_QWORD *)(v96 + 112);
                  if (v67 != *(double *)(v96 + 48))
                  {
                    v102 = (double **)(*(_QWORD *)(v96 + 112) + 16);
                    do
                    {
                      v103 = v102;
                      v104 = *v102;
                      v102 = (double **)(*v102 + 2);
                    }
                    while (v104);
                    v105 = (double *)gpc_malloc(0x18uLL);
                    *v103 = v105;
                    *v105 = v67;
                    v105[1] = v26;
                    v105[2] = 0.0;
                    ++**(_DWORD **)(v96 + 112);
                  }
                  v22 = 1;
                  v44 = v16;
                  v20 = v97;
                  v19 = v415;
                  v18 = v420;
                  break;
                case 7:
                  v425 = v21;
                  if (v400 == 10)
                  {
                    v106 = v18;
                    v107 = v19;
                    v108 = v20;
                    if (*(double *)(v44 + 24) != v26)
                    {
                      v109 = (double **)(*(_QWORD *)(v44 + 120) + 8);
                      v110 = v44;
                      v111 = *(_QWORD *)(v44 + 48);
                      do
                      {
                        v112 = v109;
                        v113 = *v109;
                        v109 = (double **)(*v109 + 2);
                      }
                      while (v113);
                      v114 = (double *)gpc_malloc(0x18uLL);
                      *v112 = v114;
                      *(_QWORD *)v114 = v111;
                      v114[1] = v26;
                      v114[2] = 0.0;
                      v44 = v110;
                      ++**(_DWORD **)(v110 + 120);
                    }
                    v115 = v44;
                    new_tristrip(&v430, v44, *(double *)(v44 + 48), v26);
                    v44 = v115;
                    v20 = v108;
                    v19 = v107;
                    v18 = v106;
                  }
                  v116 = v18;
                  v117 = v19;
                  v118 = v20;
                  v119 = v44;
                  v120 = *(_QWORD *)(v44 + 112);
                  *(_QWORD *)(v16 + 112) = v120;
                  v121 = (double **)(v120 + 16);
                  do
                  {
                    v122 = v121;
                    v123 = *v121;
                    v121 = (double **)(*v121 + 2);
                  }
                  while (v123);
                  v124 = (double *)gpc_malloc(0x18uLL);
                  *v122 = v124;
                  *v124 = v67;
                  v124[1] = v26;
                  v124[2] = 0.0;
                  ++**(_DWORD **)(v16 + 112);
                  goto LABEL_186;
                case 8:
                  v125 = v20;
                  v126 = v19;
                  v127 = v5;
                  v128 = v21;
                  v129 = v18;
                  new_tristrip(&v430, v16, *(double *)(v16 + 48), v26);
                  v18 = v129;
                  v21 = v128;
                  v5 = v127;
                  v19 = v126;
                  v20 = v125;
                  v22 = 1;
                  goto LABEL_176;
                case 9:
                  v84 = v21;
                  v421 = v18;
                  v130 = v19;
                  v131 = v20;
                  v132 = (double **)(*(_QWORD *)(v16 + 120) + 16);
                  do
                  {
                    v133 = v132;
                    v134 = *v132;
                    v132 = (double **)(*v132 + 2);
                  }
                  while (v134);
                  v135 = (double *)gpc_malloc(0x18uLL);
                  *v133 = v135;
                  *v135 = v67;
                  v135[1] = v26;
                  v135[2] = 0.0;
                  ++**(_DWORD **)(v16 + 120);
                  *(_QWORD *)(v16 + 112) = 0;
                  new_tristrip(&v430, v16, v67, v26);
                  v22 = 1;
                  v44 = v16;
                  v20 = v131;
                  v19 = v130;
                  v18 = v421;
                  goto LABEL_191;
                case 10:
                  v136 = *(_DWORD **)(v16 + 120);
                  if (*(double *)(v16 + 24) == v26)
                  {
                    v137 = v21;
                    v138 = v18;
                    v139 = v19;
                    v140 = v20;
                    v141 = (double **)(v136 + 2);
                    do
                    {
                      v142 = v141;
                      v143 = *v141;
                      v141 = (double **)(*v141 + 2);
                    }
                    while (v143);
                    v144 = (double *)gpc_malloc(0x18uLL);
                    *v142 = v144;
                    *v144 = v67;
                    v144[1] = v26;
                    v144[2] = 0.0;
                    v136 = *(_DWORD **)(v16 + 120);
                    ++*v136;
                    v20 = v140;
                    v19 = v139;
                    v18 = v138;
                    v21 = v137;
                    v5 = v401;
                  }
                  *(_QWORD *)(v16 + 112) = v136;
                  v22 = 1;
                  v145 = 10;
                  goto LABEL_175;
                case 11:
                  v146 = v20;
                  v147 = v19;
                  v148 = v5;
                  v149 = v21;
                  v150 = v18;
                  new_tristrip(&v430, v16, *(double *)(v16 + 48), v26);
                  v18 = v150;
                  v21 = v149;
                  v5 = v148;
                  v19 = v147;
                  v20 = v146;
                  v22 = 1;
                  v145 = 11;
LABEL_175:
                  v400 = v145;
LABEL_176:
                  v44 = v16;
                  break;
                case 13:
                  v425 = v21;
                  if (v400 == 10)
                  {
                    v151 = v18;
                    v152 = v19;
                    v153 = v20;
                    if (*(double *)(v44 + 24) != v26)
                    {
                      v154 = (double **)(*(_QWORD *)(v44 + 120) + 8);
                      v155 = v44;
                      v156 = *(_QWORD *)(v44 + 48);
                      do
                      {
                        v157 = v154;
                        v158 = *v154;
                        v154 = (double **)(*v154 + 2);
                      }
                      while (v158);
                      v159 = (double *)gpc_malloc(0x18uLL);
                      *v157 = v159;
                      *(_QWORD *)v159 = v156;
                      v159[1] = v26;
                      v159[2] = 0.0;
                      v44 = v155;
                      ++**(_DWORD **)(v155 + 120);
                    }
                    v160 = v44;
                    new_tristrip(&v430, v44, *(double *)(v44 + 48), v26);
                    v44 = v160;
                    v20 = v153;
                    v19 = v152;
                    v18 = v151;
                  }
                  v119 = v44;
                  v116 = v18;
                  v117 = v19;
                  v118 = v20;
                  v161 = (double **)(*(_QWORD *)(v16 + 120) + 16);
                  do
                  {
                    v162 = v161;
                    v163 = *v161;
                    v161 = (double **)(*v161 + 2);
                  }
                  while (v163);
                  v164 = (double *)gpc_malloc(0x18uLL);
                  *v162 = v164;
                  *v164 = v67;
                  v164[1] = v26;
                  v164[2] = 0.0;
                  ++**(_DWORD **)(v16 + 120);
                  *(_QWORD *)(v16 + 112) = 0;
LABEL_186:
                  v20 = v118;
                  v19 = v117;
                  v18 = v116;
                  v22 = 1;
                  v44 = v119;
                  v5 = v401;
                  goto LABEL_198;
                case 14:
                  v84 = v21;
                  v165 = v44;
                  v422 = v18;
                  v166 = v19;
                  v167 = v20;
                  v168 = (double **)(*(_QWORD *)(v16 + 120) + 8);
                  do
                  {
                    v169 = v168;
                    v170 = *v168;
                    v168 = (double **)(*v168 + 2);
                  }
                  while (v170);
                  v171 = (double *)gpc_malloc(0x18uLL);
                  *v169 = v171;
                  *v171 = v67;
                  v171[1] = v26;
                  v171[2] = 0.0;
                  ++**(_DWORD **)(v16 + 120);
                  *(_QWORD *)(v16 + 112) = 0;
                  v400 = 14;
                  v20 = v167;
                  v19 = v166;
                  v18 = v422;
                  v44 = v165;
                  goto LABEL_190;
                default:
                  break;
              }
            }
LABEL_199:
            v16 = *(_QWORD *)(v16 + 136);
            if (!v16)
            {
              v397 = v44;
              v15 = v432;
              v192 = v432;
              if (v432)
              {
                do
                {
                  v193 = *(double *)(v192 + 40);
                  if (v193 == v26)
                  {
                    v194 = *(_QWORD *)(v192 + 128);
                    v195 = *(_QWORD *)(v192 + 136);
                    v196 = v195;
                    if (v194)
                    {
                      *(_QWORD *)(v194 + 136) = v195;
                      v196 = v15;
                    }
                    if (v195)
                      *(_QWORD *)(v195 + 128) = v194;
                    if (v194)
                    {
                      if (*(_DWORD *)(v192 + 104) == 1 && *(_DWORD *)(v194 + 104) == 2)
                      {
                        *(_QWORD *)(v194 + 120) = *(_QWORD *)(v192 + 120);
                        *(_DWORD *)(v194 + 104) = 0;
                        v197 = *(_QWORD *)(v194 + 128);
                        if (v197)
                        {
                          if (*(_DWORD *)(v197 + 104) == 2)
                            *(_DWORD *)(v194 + 104) = 1;
                        }
                      }
                    }
                    v15 = v196;
                  }
                  else
                  {
                    if (v193 == v24)
                      v198 = *(double *)(v192 + 32);
                    else
                      v198 = *(double *)(v192 + 16) + *(double *)(v192 + 64) * (v24 - *(double *)(v192 + 24));
                    *(double *)(v192 + 56) = v198;
                  }
                  v192 = *(_QWORD *)(v192 + 136);
                }
                while (v192);
                v432 = v15;
                v16 = v15;
              }
              else
              {
                v16 = 0;
              }
              break;
            }
          }
        }
        v12 = v429;
        v17 = HIDWORD(v429);
        if (SHIDWORD(v429) < (int)v429)
        {
          v399 = v22;
          v199 = v18;
          v200 = v19;
          v201 = v20;
          build_intersection_table((double **)&v433, v15, v23);
          v202 = (uint64_t *)v433;
          if (v433)
          {
            v20 = v201;
            v19 = v200;
            v18 = v199;
            v22 = v399;
            while (1)
            {
              v204 = *v202;
              v203 = v202[1];
              v205 = *(_DWORD *)(*v202 + 76);
              if (v205)
              {
                v206 = *(_DWORD *)(v203 + 76);
                if (v206)
                {
                  v208 = (_DWORD **)(v204 + 112);
                  v207 = *(_QWORD *)(v204 + 112);
                  v210 = (_QWORD *)(v203 + 112);
                  v209 = *(_QWORD *)(v203 + 112);
                  v211 = *((_OWORD *)v202 + 1);
                  if (*(_DWORD *)(v204 + 92))
                    goto LABEL_235;
                  v213 = 1;
                }
                else
                {
                  if (!*(_DWORD *)(v203 + 80))
                    goto LABEL_365;
                  v206 = 0;
                  v208 = (_DWORD **)(v204 + 112);
                  v207 = *(_QWORD *)(v204 + 112);
                  v210 = (_QWORD *)(v203 + 112);
                  v209 = *(_QWORD *)(v203 + 112);
                  v211 = *((_OWORD *)v202 + 1);
                  v213 = *(_DWORD *)(v204 + 92) == 0;
                }
              }
              else
              {
                if (!*(_DWORD *)(v204 + 80))
                  goto LABEL_365;
                v206 = *(_DWORD *)(v203 + 76);
                if (v206)
                {
                  v208 = (_DWORD **)(v204 + 112);
                  v207 = *(_QWORD *)(v204 + 112);
                  v210 = (_QWORD *)(v203 + 112);
                  v209 = *(_QWORD *)(v203 + 112);
                  v211 = *((_OWORD *)v202 + 1);
                  v212 = *(_DWORD *)(v203 + 92);
                  goto LABEL_239;
                }
                if (!*(_DWORD *)(v203 + 80))
                  goto LABEL_365;
                v208 = (_DWORD **)(v204 + 112);
                v207 = *(_QWORD *)(v204 + 112);
                v210 = (_QWORD *)(v203 + 112);
                v209 = *(_QWORD *)(v203 + 112);
                v211 = *((_OWORD *)v202 + 1);
                v206 = *(_DWORD *)(v204 + 92);
                if (v206)
                {
                  v206 = 0;
LABEL_235:
                  v212 = *(_DWORD *)(v203 + 92);
LABEL_239:
                  v213 = v212 != 0;
                  goto LABEL_243;
                }
                v213 = 0;
              }
LABEL_243:
              v214 = *(_DWORD *)(v204 + 80);
              if (v214)
              {
                if (!*(_DWORD *)(v204 + 96))
                {
                  v215 = 1;
                  goto LABEL_251;
                }
                v215 = *(_DWORD *)(v203 + 80);
                if (!v215)
                  goto LABEL_251;
              }
              else if (!*(_DWORD *)(v203 + 80))
              {
                v215 = *(_DWORD *)(v204 + 96);
                if (!v215)
                  goto LABEL_251;
              }
              v215 = *(_DWORD *)(v203 + 96) != 0;
LABEL_251:
              if (v5 < 2)
              {
                v19 = v206 != v213 && *(_DWORD *)(v203 + 80) != v215;
                v20 = v205 != v213 && v214 != v215;
                v21 = (v206 ^ v205) != v213 && (*(_DWORD *)(v203 + 80) ^ v214) != v215;
                v18 = v213 & v215;
              }
              else if ((_DWORD)v5 == 2)
              {
                v18 = v215 ^ v213;
                v216 = v206 ^ v213;
                v217 = *(_DWORD *)(v203 + 80) ^ v215;
                v19 = v217 ^ v216;
                v218 = v214 ^ v205;
                v20 = v218 ^ v213 ^ v215;
                v21 = v218 ^ v216 ^ v217;
              }
              else if ((_DWORD)v5 == 3)
              {
                v19 = v206 != v213 || *(_DWORD *)(v203 + 80) != v215;
                v20 = v205 != v213 || v214 != v215;
                v21 = (v206 ^ v205) != v213 || (*(_DWORD *)(v203 + 80) ^ v214) != v215;
                v18 = v213 | v215;
              }
              v221 = v26 + *((double *)&v211 + 1);
              switch(4 * (_DWORD)v20 + 8 * (_DWORD)v21 + 2 * (_DWORD)v19 + (_DWORD)v18)
              {
                case 1:
                  if (v207 && v209)
                  {
                    v406 = v211;
                    v222 = v18;
                    v416 = v19;
                    v402 = v20;
                    v223 = (double **)(v207 + 8);
                    do
                    {
                      v224 = v223;
                      v225 = *v223;
                      v223 = (double **)(*v223 + 2);
                    }
                    while (v225);
                    v226 = (double *)gpc_malloc(0x18uLL);
                    *v224 = v226;
                    *(_QWORD *)v226 = v406;
                    v226[1] = v221;
                    v226[2] = 0.0;
                    ++**v208;
                    *v208 = 0;
                    *v210 = 0;
                    v5 = v401;
                    v20 = v402;
                    v19 = v416;
                    v21 = v21;
                    goto LABEL_312;
                  }
                  goto LABEL_365;
                case 2:
                  if (v209)
                  {
                    v426 = v21;
                    v227 = v202[1];
                    do
                      v227 = *(_QWORD *)(v227 + 136);
                    while (!*(_QWORD *)(v227 + 112));
                    v407 = v211;
                    v417 = v19;
                    v424 = v18;
                    v403 = v20;
                    v228 = *(double *)(v227 + 64);
                    v229 = *(double *)(v227 + 16);
                    v230 = v221 - *(double *)(v227 + 24);
                    v231 = (double **)(v209 + 8);
                    do
                    {
                      v232 = v231;
                      v233 = *v231;
                      v231 = (double **)(*v231 + 2);
                    }
                    while (v233);
                    v234 = (double *)gpc_malloc(0x18uLL);
                    *v232 = v234;
                    *(_QWORD *)v234 = v407;
                    v234[1] = v221;
                    v234[2] = 0.0;
                    ++*(_DWORD *)*v210;
                    v235 = (double **)(*(_QWORD *)(v227 + 112) + 16);
                    do
                    {
                      v236 = v235;
                      v237 = *v235;
                      v235 = (double **)(*v235 + 2);
                    }
                    while (v237);
                    v238 = v229 + v228 * v230;
                    goto LABEL_363;
                  }
                  goto LABEL_365;
                case 4:
                  if (v207)
                  {
                    v408 = v211;
                    v426 = v21;
                    v239 = *v202;
                    do
                    {
                      v239 = *(_QWORD *)(v239 + 128);
                      v240 = *(_QWORD *)(v239 + 112);
                    }
                    while (!v240);
                    v417 = v19;
                    v424 = v18;
                    v403 = v20;
                    v241 = (double **)(v240 + 8);
                    do
                    {
                      v242 = v241;
                      v243 = *v241;
                      v241 = (double **)(*v241 + 2);
                    }
                    while (v243);
                    v244 = *(double *)(v239 + 16) + *(double *)(v239 + 64) * (v221 - *(double *)(v239 + 24));
                    v245 = (double *)gpc_malloc(0x18uLL);
                    *v242 = v245;
                    *v245 = v244;
                    v245[1] = v221;
                    v245[2] = 0.0;
                    ++**(_DWORD **)(v239 + 112);
                    v246 = (double **)(*v208 + 4);
                    do
                    {
                      v247 = v246;
                      v248 = *v246;
                      v246 = (double **)(*v246 + 2);
                    }
                    while (v248);
                    v249 = (double *)gpc_malloc(0x18uLL);
                    *v247 = v249;
                    *(_QWORD *)v249 = v408;
                    v249[1] = v221;
                    v249[2] = 0.0;
                    v250 = *v208;
                    ++**v208;
                    goto LABEL_321;
                  }
                  goto LABEL_365;
                case 6:
                  if (v207 && v209)
                  {
                    v411 = *(double *)&v211;
                    v424 = v18;
                    v426 = v21;
                    v417 = v19;
                    v403 = v20;
                    v270 = (double **)(v207 + 16);
                    do
                    {
                      v271 = v270;
                      v272 = *v270;
                      v270 = (double **)(*v270 + 2);
                    }
                    while (v272);
                    v273 = (double *)gpc_malloc(0x18uLL);
                    *v271 = v273;
                    *v273 = v411;
                    v273[1] = v221;
                    v273[2] = 0.0;
                    ++**v208;
                    v274 = (double **)(*v210 + 8);
                    do
                    {
                      v275 = v274;
                      v276 = *v274;
                      v274 = (double **)(*v274 + 2);
                    }
                    while (v276);
                    v277 = (double *)gpc_malloc(0x18uLL);
                    *v275 = v277;
                    *v277 = v411;
                    v277[1] = v221;
                    v277[2] = 0.0;
                    ++*(_DWORD *)*v210;
                    v278 = v204;
                    do
                    {
                      v278 = *(_QWORD *)(v278 + 128);
                      v279 = *(_QWORD *)(v278 + 112);
                    }
                    while (!v279);
                    v280 = (double **)(v279 + 8);
                    do
                    {
                      v281 = v280;
                      v282 = *v280;
                      v280 = (double **)(*v280 + 2);
                    }
                    while (v282);
                    v283 = *(double *)(v278 + 16) + *(double *)(v278 + 64) * (v221 - *(double *)(v278 + 24));
                    v284 = (double *)gpc_malloc(0x18uLL);
                    *v281 = v284;
                    *v284 = v283;
                    v284[1] = v221;
                    v284[2] = 0.0;
                    ++**(_DWORD **)(v278 + 112);
                    new_tristrip(&v430, v278, v283, v221);
                    v285 = v203;
                    do
                    {
                      v285 = *(_QWORD *)(v285 + 136);
                      v286 = *(_QWORD *)(v285 + 112);
                    }
                    while (!v286);
                    v287 = (double **)(v286 + 16);
                    do
                    {
                      v288 = v287;
                      v289 = *v287;
                      v287 = (double **)(*v287 + 2);
                    }
                    while (v289);
                    v290 = *(double *)(v285 + 16) + *(double *)(v285 + 64) * (v221 - *(double *)(v285 + 24));
                    v291 = (double *)gpc_malloc(0x18uLL);
                    *v288 = v291;
                    *v291 = v290;
                    v291[1] = v221;
                    v291[2] = 0.0;
                    ++**(_DWORD **)(v285 + 112);
                    v292 = *(_QWORD *)(v278 + 112);
                    *v210 = v292;
                    v293 = (double **)(v292 + 16);
                    do
                    {
                      v294 = v293;
                      v295 = *v293;
                      v293 = (double **)(*v293 + 2);
                    }
                    while (v295);
                    v296 = (double *)gpc_malloc(0x18uLL);
                    *v294 = v296;
                    *v296 = v411;
                    v296[1] = v221;
                    v296[2] = 0.0;
                    ++*(_DWORD *)*v210;
                    new_tristrip(&v430, v204, v411, v221);
                    v297 = *(_QWORD *)(v204 + 112);
                    *(_QWORD *)(v285 + 112) = v297;
                    v298 = (double **)(v297 + 16);
                    do
                    {
                      v299 = v298;
                      v300 = *v298;
                      v298 = (double **)(*v298 + 2);
                    }
                    while (v300);
                    v301 = (double *)gpc_malloc(0x18uLL);
                    *v299 = v301;
                    *v301 = v290;
                    goto LABEL_354;
                  }
                  goto LABEL_365;
                case 7:
                  v412 = *(double *)&v211;
                  v426 = v21;
                  v302 = *v202;
                  do
                  {
                    v302 = *(_QWORD *)(v302 + 128);
                    v303 = *(_QWORD *)(v302 + 112);
                  }
                  while (!v303);
                  v417 = v19;
                  v424 = v18;
                  v403 = v20;
                  v304 = (double **)(v303 + 8);
                  do
                  {
                    v305 = v304;
                    v306 = *v304;
                    v304 = (double **)(*v304 + 2);
                  }
                  while (v306);
                  v307 = *(double *)(v302 + 16) + *(double *)(v302 + 64) * (v221 - *(double *)(v302 + 24));
                  v308 = (double *)gpc_malloc(0x18uLL);
                  *v305 = v308;
                  *v308 = v307;
                  v308[1] = v221;
                  v308[2] = 0.0;
                  ++**(_DWORD **)(v302 + 112);
                  v285 = v203;
                  do
                  {
                    v285 = *(_QWORD *)(v285 + 136);
                    v309 = *(_QWORD *)(v285 + 112);
                  }
                  while (!v309);
                  v310 = (double **)(v309 + 16);
                  do
                  {
                    v311 = v310;
                    v312 = *v310;
                    v310 = (double **)(*v310 + 2);
                  }
                  while (v312);
                  v313 = *(double *)(v285 + 16) + *(double *)(v285 + 64) * (v221 - *(double *)(v285 + 24));
                  v314 = (double *)gpc_malloc(0x18uLL);
                  *v311 = v314;
                  *v314 = v313;
                  v314[1] = v221;
                  v314[2] = 0.0;
                  ++**(_DWORD **)(v285 + 112);
                  new_tristrip(&v430, v302, v307, v221);
                  v315 = *(_QWORD *)(v302 + 112);
                  *v210 = v315;
                  v316 = (double **)(v315 + 16);
                  do
                  {
                    v317 = v316;
                    v318 = *v316;
                    v316 = (double **)(*v316 + 2);
                  }
                  while (v318);
                  v319 = (double *)gpc_malloc(0x18uLL);
                  *v317 = v319;
                  *v319 = v412;
                  v319[1] = v221;
                  v319[2] = 0.0;
                  ++*(_DWORD *)*v210;
                  new_tristrip(&v430, v204, v412, v221);
                  v320 = *(_QWORD *)(v204 + 112);
                  *(_QWORD *)(v285 + 112) = v320;
                  v321 = (double **)(v320 + 16);
                  do
                  {
                    v322 = v321;
                    v323 = *v321;
                    v321 = (double **)(*v321 + 2);
                  }
                  while (v323);
                  v301 = (double *)gpc_malloc(0x18uLL);
                  *v322 = v301;
                  *v301 = v313;
LABEL_354:
                  v301[1] = v221;
                  v301[2] = 0.0;
                  ++**(_DWORD **)(v285 + 112);
                  break;
                case 8:
                  v251 = v20;
                  v252 = v5;
                  v253 = v19;
                  v254 = v18;
                  new_tristrip(&v430, v202[1], *(double *)&v211, v26 + *((double *)&v211 + 1));
                  v18 = v254;
                  v22 = v399;
                  v19 = v253;
                  v5 = v252;
                  v20 = v251;
                  *v208 = *(_DWORD **)(v203 + 112);
                  goto LABEL_365;
                case 9:
                  if (v207 && v209)
                  {
                    v409 = *(double *)&v211;
                    v222 = v18;
                    v418 = v19;
                    v404 = v20;
                    v255 = (double **)(v207 + 8);
                    do
                    {
                      v256 = v255;
                      v257 = *v255;
                      v255 = (double **)(*v255 + 2);
                    }
                    while (v257);
                    v258 = (double *)gpc_malloc(0x18uLL);
                    *v256 = v258;
                    *v258 = v409;
                    v258[1] = v221;
                    v258[2] = 0.0;
                    ++**v208;
                    new_tristrip(&v430, v203, v409, v221);
                    *v208 = *(_DWORD **)(v203 + 112);
                    v20 = v404;
                    v19 = v418;
LABEL_312:
                    v18 = v222;
                    v22 = v399;
                  }
                  goto LABEL_365;
                case 11:
                  if (!v207)
                    goto LABEL_365;
                  v410 = v211;
                  v424 = v18;
                  v426 = v21;
                  v417 = v19;
                  v403 = v20;
                  v259 = (double **)(v207 + 8);
                  do
                  {
                    v260 = v259;
                    v261 = *v259;
                    v259 = (double **)(*v259 + 2);
                  }
                  while (v261);
                  v262 = (double *)gpc_malloc(0x18uLL);
                  *v260 = v262;
                  *(_QWORD *)v262 = v410;
                  v262[1] = v221;
                  v262[2] = 0.0;
                  ++**v208;
                  v263 = v203;
                  do
                  {
                    v263 = *(_QWORD *)(v263 + 136);
                    v264 = *(_QWORD *)(v263 + 112);
                  }
                  while (!v264);
                  v265 = (double **)(v264 + 16);
                  do
                  {
                    v266 = v265;
                    v267 = *v265;
                    v265 = (double **)(*v265 + 2);
                  }
                  while (v267);
                  v268 = *(double *)(v263 + 16) + *(double *)(v263 + 64) * (v221 - *(double *)(v263 + 24));
                  v269 = (double *)gpc_malloc(0x18uLL);
                  *v266 = v269;
                  *v269 = v268;
                  v269[1] = v221;
                  v269[2] = 0.0;
                  ++**(_DWORD **)(v263 + 112);
                  v250 = *v208;
LABEL_321:
                  *v210 = v250;
                  *v208 = 0;
                  break;
                case 13:
                  if (!v209)
                    goto LABEL_365;
                  v413 = v211;
                  v424 = v18;
                  v426 = v21;
                  v417 = v19;
                  v403 = v20;
                  v324 = (double **)(v209 + 16);
                  do
                  {
                    v325 = v324;
                    v326 = *v324;
                    v324 = (double **)(*v324 + 2);
                  }
                  while (v326);
                  v327 = (double *)gpc_malloc(0x18uLL);
                  *v325 = v327;
                  *(_QWORD *)v327 = v413;
                  v327[1] = v221;
                  v327[2] = 0.0;
                  ++*(_DWORD *)*v210;
                  v227 = v204;
                  do
                  {
                    v227 = *(_QWORD *)(v227 + 128);
                    v328 = *(_QWORD *)(v227 + 112);
                  }
                  while (!v328);
                  v329 = (double **)(v328 + 8);
                  do
                  {
                    v236 = v329;
                    v330 = *v329;
                    v329 = (double **)(*v329 + 2);
                  }
                  while (v330);
                  v238 = *(double *)(v227 + 16) + *(double *)(v227 + 64) * (v221 - *(double *)(v227 + 24));
LABEL_363:
                  v331 = (double *)gpc_malloc(0x18uLL);
                  *v236 = v331;
                  *v331 = v238;
                  v331[1] = v221;
                  v331[2] = 0.0;
                  ++**(_DWORD **)(v227 + 112);
                  *v208 = (_DWORD *)*v210;
                  *v210 = 0;
                  break;
                case 14:
                  if (v207 && v209)
                  {
                    v414 = v211;
                    v336 = v18;
                    v427 = v21;
                    v419 = v19;
                    v405 = v20;
                    v337 = (double **)(v207 + 16);
                    do
                    {
                      v338 = v337;
                      v339 = *v337;
                      v337 = (double **)(*v337 + 2);
                    }
                    while (v339);
                    v340 = (double *)gpc_malloc(0x18uLL);
                    *v338 = v340;
                    *(_QWORD *)v340 = v414;
                    v340[1] = v221;
                    v340[2] = 0.0;
                    ++**v208;
                    v341 = (double **)(*v210 + 8);
                    do
                    {
                      v342 = v341;
                      v343 = *v341;
                      v341 = (double **)(*v341 + 2);
                    }
                    while (v343);
                    v344 = (double *)gpc_malloc(0x18uLL);
                    *v342 = v344;
                    *(_QWORD *)v344 = v414;
                    v344[1] = v221;
                    v344[2] = 0.0;
                    ++*(_DWORD *)*v210;
                    *v208 = 0;
                    *v210 = 0;
                    v345 = v204;
                    do
                    {
                      v345 = *(_QWORD *)(v345 + 128);
                      v346 = *(_QWORD *)(v345 + 112);
                    }
                    while (!v346);
                    v347 = (double **)(v346 + 8);
                    do
                    {
                      v348 = v347;
                      v349 = *v347;
                      v347 = (double **)(*v347 + 2);
                    }
                    while (v349);
                    v350 = *(double *)(v345 + 16) + *(double *)(v345 + 64) * (v221 - *(double *)(v345 + 24));
                    v351 = (double *)gpc_malloc(0x18uLL);
                    *v348 = v351;
                    *v351 = v350;
                    v351[1] = v221;
                    v351[2] = 0.0;
                    ++**(_DWORD **)(v345 + 112);
                    new_tristrip(&v430, v345, v350, v221);
                    v352 = v203;
                    do
                    {
                      v352 = *(_QWORD *)(v352 + 136);
                      v353 = *(_QWORD *)(v352 + 112);
                    }
                    while (!v353);
                    v354 = (double **)(v353 + 16);
                    do
                    {
                      v355 = v354;
                      v356 = *v354;
                      v354 = (double **)(*v354 + 2);
                    }
                    while (v356);
                    v357 = *(double *)(v352 + 16) + *(double *)(v352 + 64) * (v221 - *(double *)(v352 + 24));
                    v358 = (double *)gpc_malloc(0x18uLL);
                    *v355 = v358;
                    *v358 = v357;
                    v358[1] = v221;
                    v358[2] = 0.0;
                    ++**(_DWORD **)(v352 + 112);
                    v359 = *(_QWORD *)(v345 + 112);
                    *(_QWORD *)(v352 + 112) = v359;
                    v360 = (double **)(v359 + 16);
                    do
                    {
                      v361 = v360;
                      v362 = *v360;
                      v360 = (double **)(*v360 + 2);
                    }
                    while (v362);
                    v363 = (double *)gpc_malloc(0x18uLL);
                    *v361 = v363;
                    *v363 = v357;
                    v363[1] = v221;
                    v363[2] = 0.0;
                    ++**(_DWORD **)(v352 + 112);
                    v5 = v401;
                    v20 = v405;
                    v19 = v419;
                    v21 = v427;
                    v18 = v336;
                  }
                  goto LABEL_365;
                default:
                  goto LABEL_365;
              }
              v5 = v401;
              v20 = v403;
              v19 = v417;
              v18 = v424;
              v21 = v426;
LABEL_365:
              if (*(_DWORD *)(v204 + 76))
                *(_DWORD *)(v203 + 92) = *(_DWORD *)(v203 + 92) == 0;
              if (*(_DWORD *)(v203 + 76))
                *(_DWORD *)(v204 + 92) = *(_DWORD *)(v204 + 92) == 0;
              if (*(_DWORD *)(v204 + 80))
                *(_DWORD *)(v203 + 96) = *(_DWORD *)(v203 + 96) == 0;
              if (*(_DWORD *)(v203 + 80))
                *(_DWORD *)(v204 + 96) = *(_DWORD *)(v204 + 96) == 0;
              v332 = *(_QWORD *)(v204 + 128);
              v333 = *(_QWORD *)(v203 + 136);
              if (v333)
                *(_QWORD *)(v333 + 128) = v204;
              if (*(_DWORD *)(v204 + 100) == 1)
              {
                while (1)
                {
                  v332 = *(_QWORD *)(v332 + 128);
                  if (!v332)
                    break;
                  if (*(_DWORD *)(v332 + 76) || *(_DWORD *)(v332 + 80) || *(_DWORD *)(v332 + 100) == 1)
                    goto LABEL_382;
                }
LABEL_383:
                v332 = 0;
                v335 = v432;
                *(_QWORD *)(v203 + 136) = v432;
                v334 = *(_QWORD *)(v204 + 136);
                v432 = v334;
                goto LABEL_384;
              }
              if (!v332)
                goto LABEL_383;
LABEL_382:
              *(_QWORD *)(v203 + 136) = *(_QWORD *)(v332 + 136);
              *(_QWORD *)(v332 + 136) = *(_QWORD *)(v204 + 136);
              v334 = *(_QWORD *)(v204 + 136);
              v335 = *(_QWORD *)(v203 + 136);
LABEL_384:
              *(_QWORD *)(v334 + 128) = v332;
              *(_QWORD *)(v335 + 128) = v203;
              *(_QWORD *)(v204 + 136) = v333;
              v202 = (uint64_t *)v202[4];
              if (!v202)
                goto LABEL_405;
            }
          }
          v20 = v201;
          v19 = v200;
          v18 = v199;
          v22 = v399;
LABEL_405:
          v364 = v432;
          if (v432)
          {
            v365 = v432;
            do
            {
              v366 = *(_QWORD *)(v364 + 136);
              v367 = *(_QWORD *)(v364 + 152);
              v368 = *(_QWORD *)(v364 + 112);
              if (*(double *)(v364 + 40) != v24 || v367 == 0)
              {
                *(_QWORD *)(v364 + 120) = v368;
                *(_DWORD *)(v364 + 104) = *(_DWORD *)(v364 + 100);
                *(_QWORD *)(v364 + 84) = *(_QWORD *)(v364 + 76);
                *(_QWORD *)(v364 + 48) = *(_QWORD *)(v364 + 56);
                v15 = v365;
              }
              else
              {
                *(_QWORD *)(v367 + 120) = v368;
                *(_DWORD *)(v367 + 104) = *(_DWORD *)(v364 + 100);
                *(_DWORD *)(v367 + 84) = *(_DWORD *)(v364 + 76);
                *(_DWORD *)(v367 + 88) = *(_DWORD *)(v364 + 80);
                v370 = *(_QWORD *)(v364 + 128);
                v15 = v367;
                if (v370)
                {
                  *(_QWORD *)(v370 + 136) = v367;
                  v15 = v365;
                }
                if (v366)
                  *(_QWORD *)(v366 + 128) = v367;
                *(_QWORD *)(v367 + 128) = v370;
                *(_QWORD *)(v367 + 136) = v366;
                v365 = v15;
              }
              *(_QWORD *)(v364 + 112) = 0;
              v364 = v366;
            }
            while (v366);
          }
          else
          {
            v15 = 0;
          }
          v432 = v15;
          v12 = v429;
          v17 = HIDWORD(v429);
          v16 = v15;
        }
      }
      while (v17 < v12);
      v371 = v430;
      v372 = (_DWORD *)v395;
      *(_QWORD *)(v395 + 8) = 0;
      if (v371)
      {
        v373 = 0;
        v374 = v371;
        do
        {
          if (*v374 > 2)
            ++v373;
          v374 = (int *)*((_QWORD *)v374 + 3);
        }
        while (v374);
        *(_DWORD *)v395 = v373;
        if (v373)
        {
          v375 = 0;
          *(_QWORD *)(v395 + 8) = gpc_malloc(16 * v373);
          do
          {
            v376 = v371;
            v371 = (int *)*((_QWORD *)v371 + 3);
            v377 = *v376;
            if ((int)v377 < 3)
            {
              v385 = (_QWORD *)*((_QWORD *)v376 + 1);
              if (v385)
              {
                do
                {
                  v386 = (_QWORD *)v385[2];
                  gpc_free(v385);
                  v385 = v386;
                }
                while (v386);
              }
              v387 = (_QWORD *)*((_QWORD *)v376 + 2);
              if (v387)
              {
                do
                {
                  v388 = (_QWORD *)v387[2];
                  gpc_free(v387);
                  v387 = v388;
                }
                while (v388);
              }
            }
            else
            {
              *(_DWORD *)(*(_QWORD *)(v395 + 8) + 16 * v375) = v377;
              *(_QWORD *)(*(_QWORD *)(v395 + 8) + 16 * v375 + 8) = gpc_malloc(16 * v377);
              v378 = *((_QWORD *)v376 + 1);
              v379 = *((_QWORD *)v376 + 2);
              v380 = v378 != 0;
              v381 = v379 != 0;
              if (*(_OWORD *)(v376 + 2) != 0)
              {
                v382 = 0;
                do
                {
                  if (v380)
                  {
                    v383 = *(_QWORD **)(v378 + 16);
                    *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(v395 + 8) + 16 * v375 + 8) + 16 * v382++) = *(_OWORD *)v378;
                    gpc_free((_QWORD *)v378);
                    v378 = (unint64_t)v383;
                    if (v381)
                      goto LABEL_437;
                  }
                  else
                  {
                    v378 = 0;
                    if (v381)
                    {
LABEL_437:
                      v384 = *(_QWORD **)(v379 + 16);
                      *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(v395 + 8) + 16 * v375 + 8) + 16 * v382++) = *(_OWORD *)v379;
                      gpc_free((_QWORD *)v379);
                      v379 = (unint64_t)v384;
                      goto LABEL_438;
                    }
                  }
                  v379 = 0;
LABEL_438:
                  v380 = v378 != 0;
                  v381 = v379 != 0;
                }
                while (v378 | v379);
              }
              ++v375;
            }
            gpc_free(v376);
          }
          while (v371);
        }
LABEL_448:
        v389 = v433;
        if (v433)
        {
          do
          {
            v390 = (_QWORD *)v389[4];
            gpc_free(v389);
            v389 = v390;
          }
          while (v390);
        }
        v391 = v431;
        if (v431)
        {
          do
          {
            v392 = (_QWORD *)v391[2];
            gpc_free(v391);
            v391 = v392;
          }
          while (v392);
        }
        if (v393)
          gpc_free(v393);
        if (v394)
          gpc_free(v394);
        v14 = v396;
        if (v396)
          goto LABEL_457;
        return;
      }
    }
    *v372 = 0;
    goto LABEL_448;
  }
  *(_DWORD *)v395 = 0;
  *(_QWORD *)(v395 + 8) = 0;
  if (v10)
    gpc_free(v10);
  if (v11)
  {
    v14 = v11;
LABEL_457:
    gpc_free(v14);
  }
}

double *new_tristrip(_QWORD *a1, uint64_t a2, double a3, double a4)
{
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _DWORD *v10;
  double **v11;
  double **v12;
  double *v13;
  double *result;

  do
  {
    v7 = a1;
    v8 = *a1;
    a1 = (_QWORD *)(*a1 + 24);
  }
  while (v8);
  v9 = gpc_malloc(0x28uLL);
  *v7 = v9;
  v9[3] = 0;
  *(_QWORD *)(*v7 + 8) = 0;
  *(_QWORD *)(*v7 + 16) = 0;
  v10 = (_DWORD *)*v7;
  *v10 = 1;
  v11 = (double **)(v10 + 2);
  do
  {
    v12 = v11;
    v13 = *v11;
    v11 = (double **)(*v11 + 2);
  }
  while (v13);
  result = (double *)gpc_malloc(0x18uLL);
  *v12 = result;
  *result = a3;
  result[1] = a4;
  result[2] = 0.0;
  *(_QWORD *)(a2 + 112) = *v7;
  return result;
}

char *create_contour_bboxes(int *a1)
{
  uint64_t v1;
  char *result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int64x2_t v7;
  int64x2_t v8;
  int64x2_t *v9;
  uint64_t v10;
  double *v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;

  v1 = *a1;
  if (!(_DWORD)v1)
    return 0;
  result = (char *)gpc_malloc(32 * v1);
  v4 = *a1;
  if ((int)v4 >= 1)
  {
    v5 = 0;
    v6 = *((_QWORD *)a1 + 2);
    v7 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    v8 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    do
    {
      v9 = (int64x2_t *)&result[32 * v5];
      *v9 = v7;
      v9[1] = v8;
      v10 = *(unsigned int *)(v6 + 16 * v5);
      if ((int)v10 >= 1)
      {
        v11 = (double *)(*(_QWORD *)(v6 + 16 * v5 + 8) + 8);
        v12 = 1.79769313e308;
        v13 = -1.79769313e308;
        v14 = -1.79769313e308;
        v15 = 1.79769313e308;
        do
        {
          v16 = *(v11 - 1);
          if (v16 < v15)
          {
            *(double *)v9->i64 = v16;
            v15 = v16;
          }
          v17 = *v11;
          if (*v11 < v12)
          {
            *(double *)&v9->i64[1] = v17;
            v12 = v17;
          }
          if (v16 > v14)
          {
            *(double *)v9[1].i64 = v16;
            v14 = v16;
          }
          if (v17 > v13)
          {
            *(double *)&v9[1].i64[1] = v17;
            v13 = v17;
          }
          v11 += 2;
          --v10;
        }
        while (v10);
      }
      ++v5;
    }
    while (v5 != v4);
  }
  return result;
}

uint64_t *insert_bound(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  double v3;
  double v4;

  v2 = *result;
  if (*result)
  {
    v3 = *(double *)(a2 + 16);
    while (1)
    {
      v4 = *(double *)(v2 + 16);
      if (v3 < v4 || v3 == v4 && *(double *)(a2 + 64) < *(double *)(v2 + 64))
        break;
      result = (uint64_t *)(v2 + 160);
      v2 = *(_QWORD *)(v2 + 160);
      if (!v2)
        goto LABEL_7;
    }
    *result = a2;
    *(_QWORD *)(a2 + 160) = v2;
  }
  else
  {
LABEL_7:
    *result = a2;
  }
  return result;
}

double *bound_list(double **a1, double a2)
{
  double **v3;
  double *v4;
  double v5;
  double *v6;
  double *v7;

  v3 = a1;
  v4 = *a1;
  if (!*a1)
  {
LABEL_9:
    v7 = (double *)gpc_malloc(0x18uLL);
    v4 = 0;
    goto LABEL_10;
  }
  v5 = *v4;
  if (*v4 > a2)
  {
LABEL_7:
    v7 = (double *)gpc_malloc(0x18uLL);
LABEL_10:
    *v3 = v7;
    *v7 = a2;
    v7[1] = 0.0;
    *((_QWORD *)*v3 + 2) = v4;
    v6 = *v3;
    return v6 + 1;
  }
  while (1)
  {
    v6 = v4;
    if (v5 >= a2)
      return v6 + 1;
    v4 = (double *)*((_QWORD *)v4 + 2);
    if (!v4)
    {
      v3 = (double **)(v6 + 2);
      goto LABEL_9;
    }
    v5 = *v4;
    if (*v4 > a2)
    {
      v3 = (double **)(v6 + 2);
      goto LABEL_7;
    }
  }
}

void sub_217ADAB68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *a64;
  void *a65;

  _Unwind_Resume(a1);
}

void sub_217ADB648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *a58,void *a59)
{

  _Unwind_Resume(a1);
}

void sub_217ADB740(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30)
{

  _Unwind_Resume(a1);
}

void sub_217ADB864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,void *a29)
{

  _Unwind_Resume(a1);
}

void sub_217ADB9B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,void *a29)
{

  _Unwind_Resume(a1);
}

uint64_t TSDIntPointFromCGPoint(double a1)
{
  return (uint64_t)a1;
}

double TSDIntPointFromCGPointWithScale(double a1, double a2, double a3)
{
  return a2 * a3;
}

double CGPointFromIntPoint(uint64_t a1)
{
  return (double)a1;
}

BOOL TSDIntPointEquals(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 == a3 && a2 == a4;
}

double TSDIntPointMultiplyScalar(double a1, uint64_t a2, uint64_t a3)
{
  return (double)a3 * a1;
}

uint64_t TSDIntRectMake@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  *a5 = result;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return result;
}

CGFloat TSDIntRectFromCGRect@<D0>(uint64_t *a1@<X8>, CGFloat a2@<D0>, CGFloat a3@<D1>, CGFloat a4@<D2>, CGFloat a5@<D3>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CGFloat result;
  CGRect v14;

  v10 = (uint64_t)a2;
  v11 = (uint64_t)a3;
  v12 = (uint64_t)(CGRectGetMaxX(*(CGRect *)&a2) - (double)(uint64_t)a2);
  v14.origin.x = a2;
  v14.origin.y = a3;
  v14.size.width = a4;
  v14.size.height = a5;
  result = CGRectGetMaxY(v14) - (double)(uint64_t)a3;
  *a1 = v10;
  a1[1] = v11;
  a1[2] = v12;
  a1[3] = (uint64_t)result;
  return result;
}

CGFloat TSDIntRectFromCGRectWithScale@<D0>(uint64_t *a1@<X8>, double a2@<D0>, CGFloat a3@<D1>, CGFloat a4@<D2>, CGFloat a5@<D3>, double a6@<D4>)
{
  double v7;
  CGFloat v8;
  CGFloat v9;
  CGFloat v10;

  v7 = TSDMultiplyRectScalar(a2, a3, a4, a5, a6);
  return TSDIntRectFromCGRect(a1, v7, v8, v9, v10);
}

double CGRectFromIntRect(uint64_t *a1)
{
  return (double)*a1;
}

int64x2_t TSDIntRectMultiplyScalar@<Q0>(int64x2_t *a1@<X0>, int64x2_t *a2@<X8>, double a3@<D0>)
{
  int64x2_t v3;
  int64x2_t result;

  v3 = vcvtq_s64_f64(vmulq_n_f64(vcvtq_f64_s64(*a1), a3));
  result = vcvtq_s64_f64(vmulq_n_f64(vcvtq_f64_s64(a1[1]), a3));
  *a2 = v3;
  a2[1] = result;
  return result;
}

BOOL CGRectContainsIntPoint(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6)
{
  CGPoint v7;

  v7.x = (double)a1;
  v7.y = (double)a2;
  return CGRectContainsPoint(*(CGRect *)&a3, v7);
}

BOOL TSDIntRectContainsPointInclusive(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (a2 >= *a1 && a2 <= a1[2] + *a1 && (v3 = a1[1], a3 >= v3))
    return a3 <= a1[3] + v3;
  else
    return 0;
}

uint64_t TSDIntRectGetMinX(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t TSDIntRectGetMaxX(_QWORD *a1)
{
  return a1[2] + *a1;
}

uint64_t TSDIntRectGetMinY(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t TSDIntRectGetMaxY(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24) + *(_QWORD *)(a1 + 8);
}

BOOL TSDIntRectContainsPoint(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (a2 <= *a1)
    return 0;
  if (a2 >= a1[2] + *a1)
    return 0;
  v3 = a1[1];
  return a3 > v3 && a3 < a1[3] + v3;
}

BOOL TSDIntRectIsEmpty(uint64_t a1)
{
  return !*(_QWORD *)(a1 + 16) && *(_QWORD *)(a1 + 24) == 0;
}

int64x2_t TSDIntRectInset@<Q0>(int64x2_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int64x2_t *a4@<X8>)
{
  uint64_t v4;
  int64x2_t v5;
  int64x2_t result;

  v4 = a1->i64[1] + a3;
  v5.i64[0] = a2;
  v5.i64[1] = a3;
  a4->i64[0] = a1->i64[0] + a2;
  a4->i64[1] = v4;
  result = vsubq_s64(a1[1], vaddq_s64(v5, v5));
  a4[1] = result;
  return result;
}

uint64_t TSDIntRectCenter(_QWORD *a1)
{
  return *a1 + a1[2] / 2;
}

uint64_t TSDIntRectGetMidX(_QWORD *a1)
{
  return *a1 + a1[2] / 2;
}

uint64_t TSDIntRectGetMidY(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 24) / 2;
}

int64x2_t TSDIntRectGrowToPoint@<Q0>(int64x2_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int64x2_t *a4@<X8>)
{
  int64x2_t v4;
  int64x2_t v5;
  int64x2_t v6;
  int64x2_t result;

  v4.i64[0] = a2;
  v4.i64[1] = a3;
  v5 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v4, *a1), *(int8x16_t *)a1, (int8x16_t)v4);
  v6 = vaddq_s64(a1[1], *a1);
  result = vsubq_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v6, v4), (int8x16_t)v6, (int8x16_t)v4), v5);
  *a4 = v5;
  a4[1] = result;
  return result;
}

uint64_t TSDDirectionIntDelta(uint64_t a1)
{
  return TSDDirectionIntDelta_deltas[2 * a1];
}

uint64_t TSDIntAddPoints(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 + a1;
}

uint64_t TSDIntSubtractPoints(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a1 - a3;
}

uint64_t TSDIntDotPoints(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4 * a2 + a3 * a1;
}

uint64_t TSDIntOrthogonalDistance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a1 - a3;
  if (a1 - a3 < 0)
    v4 = a3 - a1;
  v5 = a2 - a4;
  if (a2 - a4 < 0)
    v5 = a4 - a2;
  return v4 + v5;
}

__n128 TSDExpandShapeRectToIncludePoint@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v7;
  __int128 v9;
  uint64_t MinX;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __n128 result;
  __int128 v16;
  _OWORD v17[2];
  _OWORD v18[2];
  _OWORD v19[2];
  _OWORD v20[2];

  v7 = *(_QWORD *)(a1 + 24);
  if (!v7)
  {
    if (!*(_QWORD *)(a1 + 16))
      goto LABEL_13;
    goto LABEL_9;
  }
  v9 = *(_OWORD *)(a1 + 16);
  v20[0] = *(_OWORD *)a1;
  v20[1] = v9;
  MinX = TSDIntRectGetMinX((uint64_t)v20);
  v11 = *(_QWORD *)(a1 + 16);
  if (a2 == MinX)
  {
    --*(_QWORD *)a1;
    *(_QWORD *)(a1 + 16) = ++v11;
  }
  v12 = *(_OWORD *)(a1 + 16);
  v19[0] = *(_OWORD *)a1;
  v19[1] = v12;
  if (a2 == TSDIntRectGetMaxX(v19))
    *(_QWORD *)(a1 + 16) = ++v11;
  if (v11)
  {
LABEL_9:
    v13 = *(_OWORD *)(a1 + 16);
    v18[0] = *(_OWORD *)a1;
    v18[1] = v13;
    if (a3 == TSDIntRectGetMinY((uint64_t)v18))
    {
      --*(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 24) = ++v7;
    }
    v14 = *(_OWORD *)(a1 + 16);
    v17[0] = *(_OWORD *)a1;
    v17[1] = v14;
    if (a3 == TSDIntRectGetMaxY((uint64_t)v17))
      *(_QWORD *)(a1 + 24) = v7 + 1;
  }
LABEL_13:
  result = *(__n128 *)a1;
  v16 = *(_OWORD *)(a1 + 16);
  *a4 = *(_OWORD *)a1;
  a4[1] = v16;
  return result;
}

void sub_217ADE524(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25)
{
  if (__p)
    operator delete(__p);
  if (a21)
    operator delete(a21);
  if (a24)
    operator delete(a24);
  _Unwind_Resume(exception_object);
}

void *routePath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  BOOL v24;
  double v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t **v35;
  char *v36;
  char *v37;
  uint64_t *v38;
  uint64_t *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  uint64_t *v57;
  uint64_t v58;
  unint64_t v59;
  _BYTE *v60;
  _OWORD *v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  unint64_t v65;
  int v66;
  int v67;
  int64x2_t v68;
  float64x2_t v69;
  double v70;
  BOOL v71;
  double v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  char *v78;
  char *v79;
  char *v80;
  char *v81;
  uint64_t v82;
  id v83;
  void *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  void *v91;
  void *v93;
  uint64_t v94;
  uint64_t Graph;
  uint64_t v96;
  unsigned int v97;
  uint64_t *__p;
  uint64_t *v99;
  uint64_t *v100;
  void *v101;
  char *v102;
  char *v103;
  uint64_t v104;
  _BYTE v105[48];
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  uint64_t v110;

  v104 = 0;
  Graph = createGraph(a1, a4, a2, a3, (uint64_t)&v104);
  v6 = 0;
  v101 = 0;
  v102 = 0;
  v103 = 0;
  v7 = *(_OWORD *)(a1 + 64);
  v8 = *(_OWORD *)(a1 + 96);
  v108 = *(_OWORD *)(a1 + 80);
  v109 = v8;
  v110 = *(_QWORD *)(a1 + 112);
  v9 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)v105 = *(_OWORD *)a1;
  *(_OWORD *)&v105[16] = v9;
  v10 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v105[32] = *(_OWORD *)(a1 + 32);
  v106 = v10;
  v107 = v7;
  v11 = *(_OWORD *)(a4 + 64);
  v12 = *(_OWORD *)(a4 + 80);
  v13 = *(_OWORD *)(a4 + 96);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a4 + 112);
  *(_OWORD *)(a1 + 80) = v12;
  *(_OWORD *)(a1 + 96) = v13;
  *(_OWORD *)(a1 + 64) = v11;
  v14 = *(_OWORD *)a4;
  v15 = *(_OWORD *)(a4 + 16);
  v16 = *(_OWORD *)(a4 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a4 + 32);
  *(_OWORD *)(a1 + 48) = v16;
  *(_OWORD *)a1 = v14;
  *(_OWORD *)(a1 + 16) = v15;
  v17 = v106;
  *(_OWORD *)(a4 + 32) = *(_OWORD *)&v105[32];
  *(_OWORD *)(a4 + 48) = v17;
  v18 = *(_OWORD *)&v105[16];
  *(_OWORD *)a4 = *(_OWORD *)v105;
  *(_OWORD *)(a4 + 16) = v18;
  *(_QWORD *)(a4 + 112) = v110;
  v19 = v109;
  *(_OWORD *)(a4 + 80) = v108;
  *(_OWORD *)(a4 + 96) = v19;
  *(_OWORD *)(a4 + 64) = v107;
  do
  {
    v20 = operator new();
    v21 = a1 + 8 * v6;
    *(_QWORD *)v20 = *(_QWORD *)(v21 + 56);
    *(_QWORD *)(v20 + 8) = v6;
    *(_BYTE *)(v20 + 16) = 0;
    *(_QWORD *)(v20 + 24) = 0;
    *(_BYTE *)(v20 + 176) &= 0xFCu;
    *(_OWORD *)(v20 + 32) = 0u;
    *(_OWORD *)(v20 + 48) = 0u;
    *(_OWORD *)(v20 + 64) = 0u;
    *(_OWORD *)(v20 + 80) = 0u;
    *(_OWORD *)(v20 + 96) = 0u;
    *(_OWORD *)(v20 + 112) = 0u;
    *(_OWORD *)(v20 + 128) = 0u;
    *(_OWORD *)(v20 + 144) = 0u;
    *(_OWORD *)(v20 + 160) = 0u;
    v22 = (uint64_t *)extendInDirection((_OWORD *)v20, v6, *(_QWORD *)(v21 + 88));
    v23 = v22;
    if (!v22)
    {
      if (v102 - (_BYTE *)v101 >= 1)
      {
        v28 = 0;
        if ((unint64_t)(v102 - (_BYTE *)v101) >> 3 <= 1)
          v29 = 1;
        else
          v29 = (unint64_t)(v102 - (_BYTE *)v101) >> 3;
        do
        {
          v30 = *((_QWORD *)v101 + v28);
          if (v30)
            MEMORY[0x219A153B8](v30, 0x1020C40B79036FALL);
          ++v28;
        }
        while (v29 != v28);
      }
      MEMORY[0x219A153B8](v20, 0x1020C40B79036FALL);
LABEL_94:
      v84 = 0;
      goto LABEL_113;
    }
    estimateCost(v22, v104, a4, v105);
    v24 = (*((unsigned __int8 *)v23 + 81) | v105[1]) != 0;
    v25 = *((double *)v23 + 15) + *(double *)&v105[40];
    *((_BYTE *)v23 + 128) = (*((unsigned __int8 *)v23 + 80) | v105[0]) != 0;
    *((_BYTE *)v23 + 129) = v24;
    *(int64x2_t *)(v23 + 17) = vaddq_s64(*(int64x2_t *)&v105[8], *(int64x2_t *)(v23 + 11));
    *(float64x2_t *)(v23 + 19) = vaddq_f64(*(float64x2_t *)(v23 + 13), *(float64x2_t *)&v105[24]);
    *((double *)v23 + 21) = v25;
    v26 = v102;
    if (v102 >= v103)
    {
      v31 = (v102 - (_BYTE *)v101) >> 3;
      if ((unint64_t)(v31 + 1) >> 61)
        abort();
      v32 = (v103 - (_BYTE *)v101) >> 2;
      if (v32 <= v31 + 1)
        v32 = v31 + 1;
      if ((unint64_t)(v103 - (_BYTE *)v101) >= 0x7FFFFFFFFFFFFFF8)
        v33 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v33 = v32;
      if (v33)
        v34 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>((uint64_t)&v103, v33);
      else
        v34 = 0;
      v35 = (uint64_t **)&v34[8 * v31];
      *v35 = v23;
      v27 = (char *)(v35 + 1);
      v37 = (char *)v101;
      v36 = v102;
      if (v102 != v101)
      {
        do
        {
          v38 = (uint64_t *)*((_QWORD *)v36 - 1);
          v36 -= 8;
          *--v35 = v38;
        }
        while (v36 != v37);
        v36 = (char *)v101;
      }
      v101 = v35;
      v102 = v27;
      v103 = &v34[8 * v33];
      if (v36)
        operator delete(v36);
    }
    else
    {
      *(_QWORD *)v102 = v23;
      v27 = v26 + 8;
    }
    v102 = v27;
    if (!v23)
      goto LABEL_94;
    ++v6;
  }
  while (v6 != 4);
  v39 = (uint64_t *)v101;
  v40 = v102;
  v41 = v102 - (_BYTE *)v101;
  if (v102 - (_BYTE *)v101 >= 9)
  {
    v42 = v41 >> 3;
    v43 = (unint64_t)((v41 >> 3) - 2) >> 1;
    v44 = v43 + 1;
    v45 = (unint64_t *)((char *)v101 + 8 * v43);
    do
    {
      std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<TSDOrthoPathNode **>>((uint64_t)v101, (uint64_t)v105, v42, v45--);
      --v44;
    }
    while (v44);
    v39 = (uint64_t *)v101;
    v40 = v102;
  }
  __p = 0;
  v99 = 0;
  v100 = 0;
  v46 = v40 - (char *)v39;
  if (v40 == (char *)v39)
  {
LABEL_89:
    v47 = 0;
  }
  else
  {
    v97 = 0;
    while (1)
    {
      v47 = *v39;
      *(_QWORD *)v105 = nodeCompare;
      if (v46 >= 9)
      {
        v48 = *v39;
        v49 = (char *)std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSDOrthoPathNode *,TSDOrthoPathNode *),std::__wrap_iter<TSDOrthoPathNode **>>(v39, (unsigned int (**)(_QWORD, _QWORD))v105, (unint64_t)v46 >> 3);
        v50 = (uint64_t *)(v40 - 8);
        if (v40 - 8 == v49)
        {
          *(_QWORD *)v49 = v48;
        }
        else
        {
          *(_QWORD *)v49 = *v50;
          *v50 = v48;
          std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSDOrthoPathNode *,TSDOrthoPathNode *),std::__wrap_iter<TSDOrthoPathNode **>>((uint64_t)v39, (uint64_t)(v49 + 8), (uint64_t (**)(uint64_t, uint64_t))v105, (v49 + 8 - (char *)v39) >> 3);
        }
      }
      v102 -= 8;
      if (v99 >= v100)
      {
        v52 = v99 - __p;
        if ((unint64_t)(v52 + 1) >> 61)
          abort();
        v53 = ((char *)v100 - (char *)__p) >> 2;
        if (v53 <= v52 + 1)
          v53 = v52 + 1;
        if ((unint64_t)((char *)v100 - (char *)__p) >= 0x7FFFFFFFFFFFFFF8)
          v54 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v54 = v53;
        if (v54)
          v55 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>((uint64_t)&v100, v54);
        else
          v55 = 0;
        v56 = (uint64_t *)&v55[8 * v52];
        *v56 = v47;
        v51 = v56 + 1;
        v57 = v99;
        if (v99 != __p)
        {
          do
          {
            v58 = *--v57;
            *--v56 = v58;
          }
          while (v57 != __p);
          v57 = __p;
        }
        __p = v56;
        v100 = (uint64_t *)&v55[8 * v54];
        if (v57)
          operator delete(v57);
      }
      else
      {
        *v99 = v47;
        v51 = v99 + 1;
      }
      v99 = v51;
      if ((*(_BYTE *)(v47 + 176) & 1) != 0)
        break;
      v59 = 0;
      ++v97;
      do
      {
        if (v59 != TSDDirectionOpposite(*(_QWORD *)(v47 + 8)))
        {
          v60 = pathByAddingGraphPoint(v47, *(_QWORD *)(*(_QWORD *)v47 + 8 * v59 + 16), v59, 0);
          v61 = v60;
          if (v60)
          {
            if (v60[16])
            {
              v62 = *(_QWORD *)v60;
              if ((*(_BYTE *)(*(_QWORD *)v60 + 80) & 4) != 0)
              {
                v63 = 0;
                v64 = (_QWORD *)(a4 + 88);
                while (v59 == v63 || v62 != *v64)
                {
                  ++v63;
                  ++v64;
                  if (v63 == 4)
                    goto LABEL_67;
                }
                v65 = TSDDirectionOpposite(v63);
                v61 = extendInDirection(v61, v65, *(v64 - 4));
                *((_BYTE *)v61 + 176) |= 1u;
              }
            }
LABEL_67:
            if ((v61[11] & 1) != 0)
            {
              v67 = 0;
              v66 = 0;
              v68 = 0uLL;
              v69 = 0uLL;
              v70 = 0.0;
            }
            else
            {
              estimateCost((uint64_t *)v61, v104, a4, v105);
              v66 = v105[0];
              v67 = v105[1];
              v68 = *(int64x2_t *)&v105[8];
              v69 = *(float64x2_t *)&v105[24];
              v70 = *(double *)&v105[40];
            }
            v71 = (*((unsigned __int8 *)v61 + 81) | v67) != 0;
            v72 = v70 + *((double *)v61 + 15);
            *((_BYTE *)v61 + 128) = (*((unsigned __int8 *)v61 + 80) | v66) != 0;
            *((_BYTE *)v61 + 129) = v71;
            *(int64x2_t *)((char *)v61 + 136) = vaddq_s64(*(int64x2_t *)((char *)v61 + 88), v68);
            *(float64x2_t *)((char *)v61 + 152) = vaddq_f64(v69, *(float64x2_t *)((char *)v61 + 104));
            *((double *)v61 + 21) = v72;
            v73 = v102;
            if (v102 >= v103)
            {
              v75 = (v102 - (_BYTE *)v101) >> 3;
              if ((unint64_t)(v75 + 1) >> 61)
                abort();
              v76 = (v103 - (_BYTE *)v101) >> 2;
              if (v76 <= v75 + 1)
                v76 = v75 + 1;
              if ((unint64_t)(v103 - (_BYTE *)v101) >= 0x7FFFFFFFFFFFFFF8)
                v77 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v77 = v76;
              if (v77)
                v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>((uint64_t)&v103, v77);
              else
                v78 = 0;
              v79 = &v78[8 * v75];
              *(_QWORD *)v79 = v61;
              v74 = (uint64_t)(v79 + 8);
              v81 = (char *)v101;
              v80 = v102;
              if (v102 != v101)
              {
                do
                {
                  v82 = *((_QWORD *)v80 - 1);
                  v80 -= 8;
                  *((_QWORD *)v79 - 1) = v82;
                  v79 -= 8;
                }
                while (v80 != v81);
                v80 = (char *)v101;
              }
              v101 = v79;
              v102 = (char *)v74;
              v103 = &v78[8 * v77];
              if (v80)
                operator delete(v80);
            }
            else
            {
              *(_QWORD *)v102 = v61;
              v74 = (uint64_t)(v73 + 8);
            }
            v102 = (char *)v74;
            *(_QWORD *)v105 = nodeCompare;
            std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSDOrthoPathNode *,TSDOrthoPathNode *),std::__wrap_iter<TSDOrthoPathNode **>>((uint64_t)v101, v74, (uint64_t (**)(uint64_t, uint64_t))v105, (v74 - (uint64_t)v101) >> 3);
          }
        }
        ++v59;
      }
      while (v59 != 4);
      v39 = (uint64_t *)v101;
      v40 = v102;
      v46 = v102 - (_BYTE *)v101;
      if (v102 == v101)
        goto LABEL_89;
    }
    if (v97 >= 0x63)
    {
      v93 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v94 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSDBezierPath *routePath(TSDOrthoShape &, TSDIntPoint, TSDOrthoShape &)");
      objc_msgSend(v93, "handleFailureInFunction:file:lineNumber:description:", v94, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/drawables/TSDConnectionLineOrthogonalLayout.mm"), 990, CFSTR("routePath should never search more than 100 nodes"));
    }
  }
  v83 = +[TSDBezierPath bezierPath](TSDBezierPath, "bezierPath", Graph);
  v84 = v83;
  if (v47)
  {
    objc_msgSend(v83, "moveToPoint:", (double)**(uint64_t **)v47, (double)*(uint64_t *)(*(_QWORD *)v47 + 8));
    while (1)
    {
      v47 = *(_QWORD *)(v47 + 24);
      if (!v47)
        break;
      objc_msgSend(v84, "lineToPoint:", (double)**(uint64_t **)v47, (double)*(uint64_t *)(*(_QWORD *)v47 + 8));
    }
  }
  if (v102 - (_BYTE *)v101 >= 1)
  {
    v85 = 0;
    if ((unint64_t)(v102 - (_BYTE *)v101) >> 3 <= 1)
      v86 = 1;
    else
      v86 = (unint64_t)(v102 - (_BYTE *)v101) >> 3;
    do
    {
      v87 = *((_QWORD *)v101 + v85);
      if (v87)
        MEMORY[0x219A153B8](v87, 0x1020C40B79036FALL);
      ++v85;
    }
    while (v86 != v85);
  }
  if ((char *)v99 - (char *)__p >= 1)
  {
    v88 = 0;
    if ((unint64_t)((char *)v99 - (char *)__p) >> 3 <= 1)
      v89 = 1;
    else
      v89 = (unint64_t)((char *)v99 - (char *)__p) >> 3;
    do
    {
      v90 = __p[v88];
      if (v90)
        MEMORY[0x219A153B8](v90, 0x1020C40B79036FALL);
      ++v88;
    }
    while (v89 != v88);
  }
  v91 = *(void **)v96;
  if (*(_QWORD *)v96)
  {
    *(_QWORD *)(v96 + 8) = v91;
    operator delete(v91);
  }
  MEMORY[0x219A153B8](v96, 0x20C40960023A9);
  if (__p)
    operator delete(__p);
LABEL_113:
  if (v101)
  {
    v102 = (char *)v101;
    operator delete(v101);
  }
  return v84;
}

void sub_217ADEDF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, void *a15, uint64_t a16)
{
  if (__p)
    operator delete(__p);
  if (a15)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void sub_217ADF6B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  uint64_t v29;
  void *v31;
  void *v32;

  if (__p)
    operator delete(__p);
  v31 = *(void **)(v29 - 160);
  if (v31)
  {
    *(_QWORD *)(v29 - 152) = v31;
    operator delete(v31);
  }
  v32 = *(void **)(v29 - 136);
  if (v32)
  {
    *(_QWORD *)(v29 - 128) = v32;
    operator delete(v32);
  }
  _Unwind_Resume(exception_object);
}

BOOL nodeCompare(uint64_t a1, uint64_t a2)
{
  return TSDOrthoPathCost::operator<((unsigned __int8 *)(a2 + 128), (unsigned __int8 *)(a1 + 128));
}

BOOL TSDOrthoPathCost::operator<(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  double v8;
  double v9;
  BOOL v10;
  double v11;
  double v12;
  double v14;
  double v15;

  v2 = *a1;
  if (v2 != *a2)
    return v2 == 0;
  v2 = a1[1];
  if (v2 != a2[1])
    return v2 == 0;
  v3 = *((_QWORD *)a1 + 1);
  v4 = *((_QWORD *)a2 + 1);
  v5 = v3 < v4;
  if (v3 != v4)
    return v5;
  v6 = *((_QWORD *)a1 + 2);
  v7 = *((_QWORD *)a2 + 2);
  v5 = v6 < v7;
  if (v6 != v7)
    return v5;
  v8 = *((double *)a1 + 3);
  v9 = *((double *)a2 + 3);
  v10 = v8 < v9;
  if (v8 != v9)
    return v10;
  v11 = *((double *)a1 + 4);
  v12 = *((double *)a2 + 4);
  v10 = v11 < v12;
  if (v11 != v12)
    return v10;
  v14 = *((double *)a1 + 5);
  v15 = *((double *)a2 + 5);
  return v14 == v15 || v14 < v15;
}

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> addPointToXYs(uint64_t a1, uint64_t a2, uint64_t **a3, uint64_t **a4)
{
  uint64_t v5;
  uint64_t v6;

  v5 = a2;
  std::__tree<long>::__emplace_unique_key_args<long,long const&>(a3, &v6, &v6);
  std::__tree<long>::__emplace_unique_key_args<long,long const&>(a4, &v5, &v5);
}

uint64_t shapeAnchorInDirection(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  __int128 v4;
  uint64_t MaxY;
  uint64_t result;
  __int128 v7;
  uint64_t v8;
  uint64_t MinX;
  __int128 v10;
  __int128 v11;
  _OWORD v12[2];
  _OWORD v13[2];
  _OWORD v14[2];
  _OWORD v15[2];

  switch(a2)
  {
    case 0:
      v3 = *(_QWORD *)(a1 + 32);
      v4 = *(_OWORD *)(a1 + 16);
      v15[0] = *(_OWORD *)a1;
      v15[1] = v4;
      MaxY = TSDIntRectGetMaxY((uint64_t)v15);
      goto LABEL_5;
    case 1:
      v3 = *(_QWORD *)(a1 + 32);
      v7 = *(_OWORD *)(a1 + 16);
      v14[0] = *(_OWORD *)a1;
      v14[1] = v7;
      MaxY = TSDIntRectGetMinY((uint64_t)v14);
LABEL_5:
      v8 = MaxY;
      MinX = v3;
      goto LABEL_9;
    case 2:
      v10 = *(_OWORD *)(a1 + 16);
      v13[0] = *(_OWORD *)a1;
      v13[1] = v10;
      MinX = TSDIntRectGetMinX((uint64_t)v13);
      goto LABEL_8;
    case 3:
      v11 = *(_OWORD *)(a1 + 16);
      v12[0] = *(_OWORD *)a1;
      v12[1] = v11;
      MinX = TSDIntRectGetMaxX(v12);
LABEL_8:
      v8 = *(_QWORD *)(a1 + 40);
LABEL_9:
      result = TSDIntPointMake(MinX, v8);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t insertShapeEdgeNodes(void **a1, uint64_t *a2, _OWORD *a3, int a4)
{
  char v4;
  uint64_t v8;
  char v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t *v35;
  uint64_t v36;
  char v37;
  __int128 v38;
  __int128 v39;

  v8 = 0;
  v36 = (uint64_t)(a1 + 2);
  if (a4)
    v9 = 66;
  else
    v9 = 2;
  v37 = v9;
  do
  {
    v10 = a3[1];
    v38 = *a3;
    v39 = v10;
    v11 = *a2;
    v12 = a2[1];
    v13 = a2;
    if (TSDIntRectContainsPoint(&v38, *a2, v12))
    {
      do
      {
        v13 = (uint64_t *)v13[v8 + 2];
        v14 = a3[1];
        v38 = *a3;
        v39 = v14;
      }
      while (TSDIntRectContainsPoint(&v38, *v13, v13[1]));
      v11 = *v13;
      v12 = v13[1];
    }
    else
    {
      v13 = a2;
    }
    v15 = shapeAnchorInDirection((uint64_t)a3, v8);
    v17 = v16;
    result = TSDIntPointEquals(v15, v16, v11, v12);
    if ((result & 1) == 0)
    {
      v4 &= 0x80u;
      v19 = (char *)a1[1];
      v20 = (char *)a1[2];
      if (v19 >= v20)
      {
        v22 = 0x2E8BA2E8BA2E8BA3 * ((v19 - (_BYTE *)*a1) >> 3);
        v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) > 0x2E8BA2E8BA2E8BALL)
          abort();
        v24 = 0x2E8BA2E8BA2E8BA3 * ((v20 - (_BYTE *)*a1) >> 3);
        if (2 * v24 > v23)
          v23 = 2 * v24;
        if (v24 >= 0x1745D1745D1745DLL)
          v25 = 0x2E8BA2E8BA2E8BALL;
        else
          v25 = v23;
        if (v25)
          v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TSDOrthoGraphPoint>>(v36, v25);
        else
          v26 = 0;
        v27 = &v26[88 * v22];
        *(_QWORD *)v27 = v15;
        *((_QWORD *)v27 + 1) = v17;
        *((_OWORD *)v27 + 1) = 0u;
        *((_OWORD *)v27 + 2) = 0u;
        *((_OWORD *)v27 + 3) = 0u;
        *((_OWORD *)v27 + 4) = 0u;
        v27[80] = v4;
        v29 = (char *)*a1;
        v28 = (char *)a1[1];
        v30 = v27;
        if (v28 != *a1)
        {
          do
          {
            v31 = *(_OWORD *)(v28 - 88);
            *(_OWORD *)(v30 - 72) = *(_OWORD *)(v28 - 72);
            *(_OWORD *)(v30 - 88) = v31;
            v32 = *(_OWORD *)(v28 - 56);
            v33 = *(_OWORD *)(v28 - 40);
            v34 = *(_OWORD *)(v28 - 24);
            *((_DWORD *)v30 - 2) = *((_DWORD *)v28 - 2);
            *(_OWORD *)(v30 - 24) = v34;
            *(_OWORD *)(v30 - 40) = v33;
            *(_OWORD *)(v30 - 56) = v32;
            v30 -= 88;
            v28 -= 88;
          }
          while (v28 != v29);
          v28 = (char *)*a1;
        }
        v21 = v27 + 88;
        *a1 = v30;
        a1[1] = v27 + 88;
        a1[2] = &v26[88 * v25];
        if (v28)
          operator delete(v28);
      }
      else
      {
        *(_QWORD *)v19 = v15;
        *((_QWORD *)v19 + 1) = v17;
        *((_OWORD *)v19 + 1) = 0u;
        *((_OWORD *)v19 + 2) = 0u;
        *((_OWORD *)v19 + 3) = 0u;
        *((_OWORD *)v19 + 4) = 0u;
        v21 = v19 + 88;
        v19[80] = v4;
      }
      a1[1] = v21;
      result = TSDDirectionOpposite(v8);
      *(_QWORD *)&v21[8 * v8 - 72] = v13;
      v35 = &v13[result];
      *(_QWORD *)&v21[8 * result - 72] = v35[2];
      *(_QWORD *)(v35[2] + 8 * v8 + 16) = v21 - 88;
      v35[2] = (uint64_t)(v21 - 88);
      v13 = (uint64_t *)(v21 - 88);
    }
    *((_BYTE *)v13 + 80) = v37 | v13[10] & 0xBD;
    *((_QWORD *)a3 + v8++ + 7) = v13;
  }
  while (v8 != 4);
  return result;
}

uint64_t createGraph(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  __int128 v11;
  uint64_t MinX;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t MinY;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  uint64_t MaxX;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  uint64_t MaxY;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  char *v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  char *v58;
  char *v59;
  char *v60;
  char *v61;
  char *v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t *v67;
  uint64_t *v68;
  BOOL v69;
  uint64_t *v70;
  uint64_t *v71;
  uint64_t v72;
  uint64_t v73;
  _QWORD **v74;
  uint64_t v75;
  _QWORD *v76;
  uint64_t v77;
  uint64_t v78;
  _QWORD **v79;
  uint64_t v80;
  uint64_t v81;
  _QWORD *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  _QWORD *v90;
  _QWORD *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t i;
  int64x2_t v97;
  int64x2_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  int v105;
  __int128 v106;
  _BOOL4 v107;
  __int128 v108;
  uint64_t *v109;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  _OWORD v115[2];
  _OWORD v116[2];
  _OWORD v117[2];
  _OWORD v118[2];
  int64x2_t v119[2];
  int64x2_t v120;
  __int128 v121;
  int64x2_t v122[2];
  int64x2_t v123;
  __int128 v124;
  void *__p;
  void *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  _OWORD v130[2];
  _OWORD v131[2];
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  _OWORD v136[2];
  _OWORD v137[2];
  uint64_t v138;
  uint64_t v139;
  _OWORD v140[2];
  _OWORD v141[2];
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  _OWORD v146[2];
  _OWORD v147[2];
  uint64_t v148;
  uint64_t v149;
  uint64_t *v150;
  _QWORD *v151;
  uint64_t v152;
  uint64_t *v153;
  _QWORD *v154;
  uint64_t v155;
  _QWORD v156[9];

  v156[7] = *MEMORY[0x24BDAC8D0];
  v10 = operator new();
  *(_QWORD *)(v10 + 8) = 0;
  *(_QWORD *)(v10 + 16) = 0;
  *(_QWORD *)v10 = 0;
  std::vector<TSDOrthoGraphPoint>::reserve((void **)v10, 0x48uLL);
  v154 = 0;
  v155 = 0;
  v152 = 0;
  v153 = (uint64_t *)&v154;
  v150 = (uint64_t *)&v151;
  v151 = 0;
  v11 = *(_OWORD *)(a1 + 16);
  v147[0] = *(_OWORD *)a1;
  v147[1] = v11;
  MinX = TSDIntRectGetMinX((uint64_t)v147);
  v13 = *(_QWORD *)(a1 + 48);
  v14 = MinX - v13;
  v15 = *(_OWORD *)(a1 + 16);
  v146[0] = *(_OWORD *)a1;
  v146[1] = v15;
  MinY = TSDIntRectGetMinY((uint64_t)v146);
  addPointToXYs(v14, MinY - v13, &v153, &v150);
  v148 = v14;
  v149 = v17;
  v18 = *(_QWORD *)(a1 + 32);
  addPointToXYs(v18, *(_QWORD *)(a1 + 40), &v153, &v150);
  v144 = v18;
  v145 = v19;
  v20 = *(_OWORD *)(a1 + 16);
  v141[0] = *(_OWORD *)a1;
  v141[1] = v20;
  MaxX = TSDIntRectGetMaxX(v141);
  v22 = *(_QWORD *)(a1 + 48);
  v23 = v22 + MaxX;
  v24 = *(_OWORD *)(a1 + 16);
  v140[0] = *(_OWORD *)a1;
  v140[1] = v24;
  MaxY = TSDIntRectGetMaxY((uint64_t)v140);
  addPointToXYs(v23, MaxY + v22, &v153, &v150);
  v142 = v23;
  v143 = v26;
  v27 = *(_OWORD *)(a2 + 16);
  v137[0] = *(_OWORD *)a2;
  v137[1] = v27;
  v28 = TSDIntRectGetMinX((uint64_t)v137);
  v29 = *(_QWORD *)(a2 + 48);
  v30 = v28 - v29;
  v31 = *(_OWORD *)(a2 + 16);
  v136[0] = *(_OWORD *)a2;
  v136[1] = v31;
  v32 = TSDIntRectGetMinY((uint64_t)v136);
  addPointToXYs(v30, v32 - v29, &v153, &v150);
  v138 = v30;
  v139 = v33;
  v34 = *(_QWORD *)(a2 + 32);
  addPointToXYs(v34, *(_QWORD *)(a2 + 40), &v153, &v150);
  v134 = v34;
  v135 = v35;
  v36 = *(_OWORD *)(a2 + 16);
  v131[0] = *(_OWORD *)a2;
  v131[1] = v36;
  v37 = TSDIntRectGetMaxX(v131);
  v38 = *(_QWORD *)(a2 + 48);
  v39 = v38 + v37;
  v40 = *(_OWORD *)(a2 + 16);
  v130[0] = *(_OWORD *)a2;
  v130[1] = v40;
  v41 = TSDIntRectGetMaxY((uint64_t)v130);
  addPointToXYs(v39, v41 + v38, &v153, &v150);
  v114 = a1;
  v132 = v39;
  v133 = v42;
  addPointToXYs(a3, a4, &v153, &v150);
  v128 = a3;
  v129 = v43;
  v44 = v155;
  __p = 0;
  v126 = 0;
  v127 = 0;
  v112 = v152;
  v113 = a2;
  std::vector<TSDOrthoGraphPoint *>::resize((uint64_t)&__p, v152 * v155);
  v111 = a5;
  v45 = v153;
  if (v153 != (uint64_t *)&v154)
  {
    v46 = 0;
    do
    {
      v47 = v150;
      if (v150 != (uint64_t *)&v151)
      {
        v48 = 0;
        LOBYTE(v38) = v38 & 0x80;
        do
        {
          v49 = v45[4];
          v50 = v47[4];
          v51 = *(_QWORD *)(v10 + 8);
          v52 = *(_QWORD *)(v10 + 16);
          if (v51 >= v52)
          {
            v54 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v51 - *(_QWORD *)v10) >> 3);
            v55 = v54 + 1;
            if ((unint64_t)(v54 + 1) > 0x2E8BA2E8BA2E8BALL)
              abort();
            v56 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v52 - *(_QWORD *)v10) >> 3);
            if (2 * v56 > v55)
              v55 = 2 * v56;
            if (v56 >= 0x1745D1745D1745DLL)
              v57 = 0x2E8BA2E8BA2E8BALL;
            else
              v57 = v55;
            if (v57)
              v58 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TSDOrthoGraphPoint>>(v10 + 16, v57);
            else
              v58 = 0;
            v59 = &v58[88 * v54];
            *(_QWORD *)v59 = v49;
            *((_QWORD *)v59 + 1) = v50;
            *((_OWORD *)v59 + 1) = 0u;
            *((_OWORD *)v59 + 2) = 0u;
            *((_OWORD *)v59 + 3) = 0u;
            *((_OWORD *)v59 + 4) = 0u;
            v59[80] = v38;
            v61 = *(char **)v10;
            v60 = *(char **)(v10 + 8);
            v62 = v59;
            if (v60 != *(char **)v10)
            {
              do
              {
                v63 = *(_OWORD *)(v60 - 88);
                *(_OWORD *)(v62 - 72) = *(_OWORD *)(v60 - 72);
                *(_OWORD *)(v62 - 88) = v63;
                v64 = *(_OWORD *)(v60 - 56);
                v65 = *(_OWORD *)(v60 - 40);
                v66 = *(_OWORD *)(v60 - 24);
                *((_DWORD *)v62 - 2) = *((_DWORD *)v60 - 2);
                *(_OWORD *)(v62 - 24) = v66;
                *(_OWORD *)(v62 - 40) = v65;
                *(_OWORD *)(v62 - 56) = v64;
                v62 -= 88;
                v60 -= 88;
              }
              while (v60 != v61);
              v60 = v61;
            }
            v53 = v59 + 88;
            *(_QWORD *)v10 = v62;
            *(_QWORD *)(v10 + 8) = v59 + 88;
            *(_QWORD *)(v10 + 16) = &v58[88 * v57];
            if (v60)
              operator delete(v60);
          }
          else
          {
            *(_QWORD *)v51 = v49;
            *(_QWORD *)(v51 + 8) = v50;
            *(_OWORD *)(v51 + 16) = 0u;
            *(_OWORD *)(v51 + 32) = 0u;
            *(_OWORD *)(v51 + 48) = 0u;
            *(_OWORD *)(v51 + 64) = 0u;
            v53 = (char *)(v51 + 88);
            *(_BYTE *)(v51 + 80) = v38;
          }
          *(_QWORD *)(v10 + 8) = v53;
          *((_QWORD *)__p + v46 + v48 * v44) = v53 - 88;
          v67 = (uint64_t *)v47[1];
          if (v67)
          {
            do
            {
              v68 = v67;
              v67 = (uint64_t *)*v67;
            }
            while (v67);
          }
          else
          {
            do
            {
              v68 = (uint64_t *)v47[2];
              v69 = *v68 == (_QWORD)v47;
              v47 = v68;
            }
            while (!v69);
          }
          ++v48;
          v47 = v68;
        }
        while (v68 != (uint64_t *)&v151);
      }
      v70 = (uint64_t *)v45[1];
      if (v70)
      {
        do
        {
          v71 = v70;
          v70 = (uint64_t *)*v70;
        }
        while (v70);
      }
      else
      {
        do
        {
          v71 = (uint64_t *)v45[2];
          v69 = *v71 == (_QWORD)v45;
          v45 = v71;
        }
        while (!v69);
      }
      ++v46;
      v45 = v71;
    }
    while (v71 != (uint64_t *)&v154);
  }
  v72 = 0;
  v156[0] = &v148;
  v156[1] = &v144;
  v156[2] = &v142;
  v156[3] = &v138;
  v156[4] = &v134;
  v156[5] = &v132;
  v156[6] = &v128;
  v73 = 8 * v44;
  v74 = (_QWORD **)__p;
  do
  {
    if (v44 >= 1)
    {
      v75 = 0;
      v76 = (_QWORD *)v156[v72];
      while (*v76 != *v74[v75])
      {
        if (v44 == ++v75)
          goto LABEL_40;
      }
      *v76 = v75;
    }
LABEL_40:
    if (v112 >= 1)
    {
      v77 = 0;
      v78 = v156[v72];
      v79 = v74;
      while (*(_QWORD *)(v78 + 8) != (*v79)[1])
      {
        ++v77;
        v79 = (_QWORD **)((char *)v79 + v73);
        if (v112 == v77)
          goto LABEL_46;
      }
      *(_QWORD *)(v78 + 8) = v77;
    }
LABEL_46:
    ++v72;
  }
  while (v72 != 7);
  v80 = v144;
  v81 = v145 * v44;
  v82 = __p;
  v83 = *((_QWORD *)__p + v145 * v44 + v144);
  v84 = v134;
  v85 = v135 * v44;
  v86 = *((_QWORD *)__p + v135 * v44 + v134);
  *(_QWORD *)v111 = *((_QWORD *)__p + v128 + v129 * v44);
  *(_BYTE *)(v83 + 80) |= 1u;
  *(_BYTE *)(v86 + 80) |= 1u;
  *(_BYTE *)(*(_QWORD *)v111 + 80) |= 8u;
  if (v44 >= 1)
  {
    v87 = 0;
    do
    {
      if (v112 <= 0)
      {
        v89 = v87 + 1;
      }
      else
      {
        v88 = 0;
        v89 = v87 + 1;
        v90 = v82;
        do
        {
          v91 = (_QWORD *)v90[v87];
          if (v44 - 1 > v87)
            v91[5] = v90[v87 + 1];
          if (v87)
            v91[4] = v90[(v87 - 1)];
          if (v112 - 1 > v88)
            v91[2] = v90[v87 + (unint64_t)v73 / 8];
          if (v88)
            v91[3] = v82[v87 + v44 * (v88 - 1)];
          ++v88;
          v90 = (_QWORD *)((char *)v90 + v73);
        }
        while (v112 != v88);
      }
      v87 = v89;
    }
    while (v89 != v44);
  }
  v92 = v142;
  *(_QWORD *)(v114 + 88) = v82[v80 + v143 * v44];
  v93 = v148;
  *(_QWORD *)(v114 + 96) = v82[v80 + v149 * v44];
  *(_QWORD *)(v114 + 104) = v82[v93 + v81];
  *(_QWORD *)(v114 + 112) = v82[v92 + v81];
  v94 = v132;
  *(_QWORD *)(v113 + 88) = v82[v84 + v133 * v44];
  v95 = v138;
  *(_QWORD *)(v113 + 96) = v82[v84 + v139 * v44];
  *(_QWORD *)(v113 + 104) = v82[v95 + v85];
  *(_QWORD *)(v113 + 112) = v82[v94 + v85];
  for (i = 88; i != 120; i += 8)
  {
    *(_BYTE *)(*(_QWORD *)(v114 + i) + 80) |= 4u;
    *(_BYTE *)(*(_QWORD *)(v113 + i) + 80) |= 4u;
  }
  insertShapeEdgeNodes((void **)v10, (uint64_t *)v83, (_OWORD *)v114, 0);
  insertShapeEdgeNodes((void **)v10, (uint64_t *)v86, (_OWORD *)v113, 1);
  v123 = 0u;
  v124 = 0u;
  v97 = *(int64x2_t *)(v114 + 16);
  v122[0] = *(int64x2_t *)v114;
  v122[1] = v97;
  TSDIntRectInset(v122, -*(_QWORD *)(v114 + 48), -*(_QWORD *)(v114 + 48), &v123);
  v120 = 0u;
  v121 = 0u;
  v98 = *(int64x2_t *)(v113 + 16);
  v119[0] = *(int64x2_t *)v113;
  v119[1] = v98;
  TSDIntRectInset(v119, -*(_QWORD *)(v113 + 48), -*(_QWORD *)(v113 + 48), &v120);
  v99 = *(_QWORD *)(v10 + 8) - *(_QWORD *)v10;
  if (v99)
  {
    v100 = 0;
    v101 = v99 / 88;
    if (v101 <= 1)
      v102 = 1;
    else
      v102 = v101;
    do
    {
      v103 = *(char **)v10;
      v104 = *(_QWORD *)v10 + v100;
      v105 = *(unsigned __int8 *)(v104 + 80);
      if ((v105 & 0x42) != 2)
      {
        v106 = *(_OWORD *)(v114 + 16);
        v118[0] = *(_OWORD *)v114;
        v118[1] = v106;
        if (TSDIntRectContainsPoint(v118, *(_QWORD *)v104, *(_QWORD *)(v104 + 8)))
          *(_BYTE *)(v104 + 80) |= 0x10u;
        v117[0] = v123;
        v117[1] = v124;
        v107 = TSDIntRectContainsPoint(v117, *(_QWORD *)v104, *(_QWORD *)(v104 + 8));
        v105 = *(unsigned __int8 *)(v104 + 80);
        if (v107)
        {
          v105 |= 0x20u;
          *(_BYTE *)(v104 + 80) = v105;
        }
      }
      if ((~v105 & 0x42) != 0)
      {
        v108 = *(_OWORD *)(v113 + 16);
        v116[0] = *(_OWORD *)v113;
        v116[1] = v108;
        v109 = (uint64_t *)&v103[v100];
        if (TSDIntRectContainsPoint(v116, *v109, v109[1]))
          *(_BYTE *)(v104 + 80) |= 0x10u;
        v115[0] = v120;
        v115[1] = v121;
        if (TSDIntRectContainsPoint(v115, *(_QWORD *)v104, v109[1]))
          *(_BYTE *)(v104 + 80) |= 0x20u;
      }
      v100 += 88;
      --v102;
    }
    while (v102);
  }
  if (__p)
  {
    v126 = __p;
    operator delete(__p);
  }
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy((uint64_t)&v150, v151);
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy((uint64_t)&v153, v154);
  return v10;
}

void sub_217AE03E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *__p,uint64_t a51)
{
  uint64_t v51;

  if (__p)
    operator delete(__p);
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy(v51 - 200, *(_QWORD **)(v51 - 192));
  std::__tree<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::__map_value_compare<std::pair<unsigned short,EQKit::Config::Operator::Form>,std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>,std::less<std::pair<unsigned short,EQKit::Config::Operator::Form>>,true>,std::allocator<std::__value_type<std::pair<unsigned short,EQKit::Config::Operator::Form>,EQKit::Config::Operator::Dictionary::Entry>>>::destroy(v51 - 176, *(_QWORD **)(v51 - 168));
  _Unwind_Resume(a1);
}

void std::vector<TSDOrthoGraphPoint>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (0x2E8BA2E8BA2E8BA3 * ((v4 - (_BYTE *)*a1) >> 3) < a2)
  {
    if (a2 >= 0x2E8BA2E8BA2E8BBLL)
      abort();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TSDOrthoGraphPoint>>(v3, a2);
    v7 = &v6[v5];
    v9 = &v6[88 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *(_OWORD *)(v10 - 88);
        *(_OWORD *)(v12 - 72) = *(_OWORD *)(v10 - 72);
        *(_OWORD *)(v12 - 88) = v13;
        v14 = *(_OWORD *)(v10 - 56);
        v15 = *(_OWORD *)(v10 - 40);
        v16 = *(_OWORD *)(v10 - 24);
        *((_DWORD *)v12 - 2) = *((_DWORD *)v10 - 2);
        *(_OWORD *)(v12 - 24) = v16;
        *(_OWORD *)(v12 - 40) = v15;
        *(_OWORD *)(v12 - 56) = v14;
        v12 -= 88;
        v10 -= 88;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void std::vector<TSDOrthoGraphPoint *>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<TSDOrthoGraphPoint *>::__append((void **)a1, a2 - v2);
  }
}

double othoPathOverlap(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *v3;
  double v4;
  double v5;
  double v6;
  double v7;
  char v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  double v13;
  double v14;
  double v15;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
  {
    v2 = a1;
    v3 = *(uint64_t **)a1;
    v4 = 0.0;
    v5 = 0.0;
    v6 = 0.0;
    v7 = 0.0;
    do
    {
      v8 = *(_BYTE *)(v2 + 176);
      v2 = v1;
      v9 = *(uint64_t **)v1;
      if ((v8 & 2) == 0 || (*(_BYTE *)(v1 + 176) & 2) == 0)
      {
        v10 = TSDIntSubtractPoints(*v3, v3[1], *v9);
        v12 = (double)v11;
        v13 = -0.0;
        if (v10 == 0 && v11 > 0)
          v14 = (double)v11;
        else
          v14 = -0.0;
        v4 = v4 + v14;
        if (v10 != 0 || v11 >= 0)
          v12 = 0.0;
        v5 = v5 - v12;
        v15 = (double)v10;
        if (v11 == 0 && v10 > 0)
          v13 = (double)v10;
        v7 = v7 + v13;
        if (v11 != 0 || v10 >= 0)
          v15 = 0.0;
        v6 = v6 - v15;
      }
      v1 = *(_QWORD *)(v2 + 24);
      v3 = v9;
    }
    while (v1);
  }
  else
  {
    v7 = 0.0;
    v6 = 0.0;
    v5 = 0.0;
    v4 = 0.0;
  }
  return fmin(v6, v7) + fmin(v4, v5);
}

double othoPathVariance(uint64_t a1)
{
  uint64_t **v1;
  uint64_t *v2;
  double *v3;
  double v4;
  double *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  double *v11;
  double *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t **v15;
  double *v16;
  double v17;
  double *v18;
  double v19;
  double *__p;
  double *v22;
  double *v23;

  __p = 0;
  v22 = 0;
  v23 = 0;
  v2 = (uint64_t *)(a1 + 24);
  v1 = *(uint64_t ***)(a1 + 24);
  if (v1)
  {
    v3 = 0;
    do
    {
      v4 = (double)TSDIntOrthogonalDistance(**(_QWORD **)a1, *(_QWORD *)(*(_QWORD *)a1 + 8), **v1, (*v1)[1]);
      if (v3 >= v23)
      {
        v5 = __p;
        v6 = v3 - __p;
        v7 = v6 + 1;
        if ((unint64_t)(v6 + 1) >> 61)
          abort();
        v8 = (char *)v23 - (char *)__p;
        if (((char *)v23 - (char *)__p) >> 2 > v7)
          v7 = v8 >> 2;
        if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
          v9 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v9 = v7;
        if (v9)
        {
          v10 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>((uint64_t)&v23, v9);
          v5 = __p;
          v3 = v22;
        }
        else
        {
          v10 = 0;
        }
        v11 = (double *)&v10[8 * v6];
        *v11 = v4;
        v12 = v11 + 1;
        while (v3 != v5)
        {
          v13 = *((_QWORD *)v3-- - 1);
          *((_QWORD *)v11-- - 1) = v13;
        }
        __p = v11;
        v23 = (double *)&v10[8 * v9];
        if (v5)
          operator delete(v5);
        v3 = v12;
      }
      else
      {
        *v3++ = v4;
      }
      v22 = v3;
      a1 = *v2;
      v14 = *v2;
      v15 = *(uint64_t ***)(v14 + 24);
      v2 = (uint64_t *)(v14 + 24);
      v1 = v15;
    }
    while (v15);
    v16 = __p;
    v17 = 0.0;
    if (__p != v3)
    {
      v18 = __p;
      do
      {
        v19 = *v18++;
        v17 = v17 + v19 * v19;
      }
      while (v18 != v3);
    }
    if (__p)
      operator delete(__p);
  }
  else
  {
    v3 = 0;
    v16 = 0;
    v17 = 0.0;
  }
  return v17 / (double)(unint64_t)(v3 - v16);
}

void sub_217AE07EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_OWORD *pathByAddingGraphPoint(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t *v8;
  double v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v14;
  double v15;
  BOOL v16;
  double v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  _QWORD *v23;
  _OWORD *v24;
  uint64_t v25;
  char v26;
  char v27;
  __int128 v28;
  int v30;
  __int16 v31;

  if (!a2)
    return 0;
  v8 = *(uint64_t **)a1;
  v9 = (double)TSDIntOrthogonalDistance(**(_QWORD **)a1, *(_QWORD *)(*(_QWORD *)a1 + 8), *(_QWORD *)a2, *(_QWORD *)(a2 + 8));
  v10 = *(_QWORD *)(a1 + 8);
  v11 = *(_BYTE *)(a1 + 32);
  v30 = *(_DWORD *)(a1 + 34);
  v31 = *(_WORD *)(a1 + 38);
  v12 = *(_QWORD *)(a1 + 40);
  v13 = *(unsigned __int8 *)(a2 + 80);
  v14 = v10 == a3 && a3 >= 2;
  v15 = *(double *)(a1 + 72) + 5.0;
  if (!v14)
    v15 = *(double *)(a1 + 72);
  if (*(_BYTE *)(a1 + 16))
    v16 = 1;
  else
    v16 = (v13 & 8) != 0;
  if (*(_BYTE *)(a1 + 16))
    v17 = *(double *)(a1 + 72);
  else
    v17 = v15;
  if ((v13 & 0x10) != 0)
    v18 = 1;
  else
    v18 = *(_BYTE *)(a1 + 33);
  v19 = (v13 >> 5) & 1;
  if (a4)
    v19 = 0;
  if (v10 != a3)
  {
    if ((v8[10] & 8) != 0)
      v17 = v17 + -20.0;
    ++v12;
  }
  v20 = *(_QWORD *)(a1 + 56);
  v21 = *(double *)(a1 + 64) + v9;
  v22 = v19 + *(_QWORD *)(a1 + 48);
  v23 = (_QWORD *)a1;
  while (*v23 != a2)
  {
    v23 = (_QWORD *)v23[3];
    if (!v23)
      goto LABEL_28;
  }
  v11 = 1;
LABEL_28:
  v25 = operator new();
  v24 = (_OWORD *)v25;
  *(_QWORD *)v25 = a2;
  *(_QWORD *)(v25 + 8) = a3;
  *(_BYTE *)(v25 + 16) = v16;
  *(_QWORD *)(v25 + 24) = a1;
  v26 = *(_BYTE *)(v25 + 176) & 0xFC;
  *(_OWORD *)(v25 + 128) = 0u;
  *(_OWORD *)(v25 + 144) = 0u;
  *(_OWORD *)(v25 + 160) = 0u;
  *(_BYTE *)(v25 + 32) = v11;
  *(_BYTE *)(v25 + 33) = v18;
  *(_DWORD *)(v25 + 34) = v30;
  *(_WORD *)(v25 + 38) = v31;
  *(_QWORD *)(v25 + 40) = v12;
  *(_QWORD *)(v25 + 48) = v22;
  *(_QWORD *)(v25 + 56) = v20;
  *(double *)(v25 + 64) = v21;
  *(double *)(v25 + 72) = v17;
  if (a4)
    v27 = 2;
  else
    v27 = 0;
  *(_BYTE *)(v25 + 176) = v26 | v27;
  *(_BYTE *)(v25 + 80) = v11;
  *(_BYTE *)(v25 + 81) = v18;
  *(_DWORD *)(v25 + 82) = v30;
  *(_WORD *)(v25 + 86) = v31;
  *(_QWORD *)(v25 + 88) = v12;
  *(_QWORD *)(v25 + 96) = v22;
  *(_QWORD *)(v25 + 104) = v20;
  *(double *)(v25 + 112) = v21;
  *(double *)(v25 + 120) = v17;
  *(double *)(v25 + 104) = othoPathOverlap(v25);
  v28 = v24[7];
  v24[9] = v24[6];
  v24[10] = v28;
  v24[8] = v24[5];
  return v24;
}

_OWORD *nodeInDirection(_QWORD *a1, unint64_t a2, int a3)
{
  return pathByAddingGraphPoint((uint64_t)a1, *(_QWORD *)(*a1 + 8 * a2 + 16), a2, a3);
}

_OWORD *extendInDirection(_OWORD *result, unint64_t a2, uint64_t a3)
{
  *((_BYTE *)result + 176) |= 2u;
  do
  {
    if (*(_QWORD *)result == a3)
      break;
    result = pathByAddingGraphPoint((uint64_t)result, *(_QWORD *)(*(_QWORD *)result + 8 * a2 + 16), a2, 1);
  }
  while (result);
  return result;
}

uint64_t estimateNumberOfCorners(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  unsigned int v13;
  BOOL v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  double v22;
  double v23;
  double v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v12 = TSDDirectionOpposite(a6);
  if (a1 == a4 && a2 == a5)
  {
    if (a3 == a6)
      v13 = 4;
    else
      v13 = 1;
    v14 = v12 == a3;
LABEL_7:
    if (v14)
      return 0;
    else
      return v13;
  }
  if (v12 == a3)
  {
    v16 = TSDDirectionIntDelta(a3);
    v18 = v17;
    v19 = TSDIntSubtractPoints(a4, a5, a1);
    if (TSDIntDotPoints(v16, v18, v19, v20) < 0)
      return 4;
    v21 = TSDDirectionDelta(a3);
    if (a1 == a4 && v21 == 0.0)
      return 0;
    v14 = a2 == a5 && v22 == 0.0;
    v13 = 2;
    goto LABEL_7;
  }
  if (a3 == a6)
  {
    v23 = TSDDirectionDelta(a6);
    result = 4;
    if (a1 != a4 || v23 != 0.0)
    {
      if (a2 == a5 && v24 == 0.0)
        return 4;
      else
        return 2;
    }
  }
  else
  {
    v26 = TSDDirectionIntDelta(a3);
    v28 = v27;
    v29 = TSDIntSubtractPoints(a4, a5, a1);
    v31 = TSDIntDotPoints(v26, v28, v29, v30);
    v32 = TSDDirectionIntDelta(a6);
    v34 = v33;
    v35 = TSDIntSubtractPoints(a1, a2, a4);
    if ((v31 | TSDIntDotPoints(v32, v34, v35, v36)) >= 0)
      return 1;
    else
      return 3;
  }
  return result;
}

uint64_t estimateCostToShape@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, double *a5@<X8>)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t result;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v30;
  int v31;
  double *v32;
  uint64_t v33;

  *((_OWORD *)a5 + 1) = 0u;
  *((_OWORD *)a5 + 2) = 0u;
  *(_OWORD *)a5 = 0u;
  v8 = *(uint64_t **)(a3 + 8 * a4 + 88);
  v9 = *a1;
  v31 = *((unsigned __int8 *)a1 + 16);
  v32 = a5;
  v30 = v8;
  if (*((_BYTE *)a1 + 16) || (*(_BYTE *)(v9 + 80) & 8) != 0)
  {
    v24 = *(_QWORD *)v9;
    v25 = *(_QWORD *)(v9 + 8);
    v26 = *v8;
    v27 = v8[1];
    a5[4] = (double)TSDIntOrthogonalDistance(*(_QWORD *)v9, v25, *v8, v27);
    result = estimateNumberOfCorners(v24, v25, a1[1], v26, v27, a4);
    v19 = a4;
    v20 = result;
  }
  else
  {
    v10 = *(_QWORD *)a2;
    v11 = *(_QWORD *)(a2 + 8);
    v33 = *(_QWORD *)v9;
    v12 = *(_QWORD *)(v9 + 8);
    v13 = (double)TSDIntOrthogonalDistance(*(_QWORD *)v9, v12, *(_QWORD *)a2, v11);
    v14 = v8;
    v15 = *v8;
    v16 = v14[1];
    v17 = 0;
    a5[4] = v13 + (double)TSDIntOrthogonalDistance(v10, v11, v15, v16);
    v18 = a1[1];
    v19 = a4;
    v20 = 0x7FFFFFFFFFFFFFFFLL;
    do
    {
      v21 = estimateNumberOfCorners(v33, v12, v18, v10, v11, v17);
      v22 = TSDDirectionOpposite(v17);
      result = estimateNumberOfCorners(v10, v11, v22, v15, v16, v19);
      if (v20 >= (result + v21))
        v20 = (result + v21);
      ++v17;
    }
    while (v17 != 4);
  }
  *((_QWORD *)v32 + 1) = v20;
  if (!v31 && (*(_BYTE *)(a2 + 80) & 0x10) != 0
    || (v30[10] & 0x10) != 0
    || (*(_BYTE *)(*(_QWORD *)(a3 + 8 * v19 + 56) + 80) & 0x10) != 0)
  {
    *((_BYTE *)v32 + 1) = 1;
  }
  return result;
}

double estimateCost@<D0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned __int8 *a4@<X8>)
{
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  double result;
  double v12[6];
  __int128 v13;
  __int128 v14;
  __int128 v15;

  v8 = 0;
  *(_OWORD *)a4 = xmmword_217C2AA40;
  *((_OWORD *)a4 + 1) = unk_217C2AA50;
  *((_OWORD *)a4 + 2) = xmmword_217C2AA60;
  do
  {
    estimateCostToShape(a1, a2, a3, v8, v12);
    if (TSDOrthoPathCost::operator<(a4, (unsigned __int8 *)v12))
    {
      v9 = *((_OWORD *)a4 + 1);
      v13 = *(_OWORD *)a4;
      v14 = v9;
      v15 = *((_OWORD *)a4 + 2);
    }
    else
    {
      estimateCostToShape(a1, a2, a3, v8, (double *)&v13);
    }
    v10 = v14;
    *(_OWORD *)a4 = v13;
    *((_OWORD *)a4 + 1) = v10;
    result = *(double *)&v15;
    *((_OWORD *)a4 + 2) = v15;
    ++v8;
  }
  while (v8 != 4);
  return result;
}

uint64_t *std::__tree<long>::__emplace_unique_key_args<long,long const&>(uint64_t **a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t v7;
  uint64_t **v8;
  uint64_t v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = v5[4];
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<TSDOrthoGraphPoint>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2E8BA2E8BA2E8BBLL)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(88 * a2);
}

void std::vector<TSDOrthoGraphPoint *>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 3);
    if (v9 >> 61)
      abort();
    v10 = v8 >> 3;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 2 > v9)
      v9 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[8 * v10];
    v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    v16 = &v14[8 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_QWORD *)v17 - 1);
        v17 -= 8;
        *((_QWORD *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<TSDOrthoPathNode **>>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      v6 = v4 >> 2;
      v7 = (v4 >> 2) | 1;
      v8 = (unint64_t *)(result + 8 * v7);
      v9 = v6 + 2;
      if (v9 >= a3)
      {
        v10 = *v8;
      }
      else
      {
        v10 = *v8;
        if (*v8 < v8[1])
        {
          v10 = v8[1];
          ++v8;
          v7 = v9;
        }
      }
      v11 = *a4;
      if (v10 >= *a4)
      {
        do
        {
          *a4 = v10;
          a4 = v8;
          if (v5 < v7)
            break;
          v12 = (2 * v7) | 1;
          v8 = (unint64_t *)(result + 8 * v12);
          v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            v10 = *v8;
            v7 = v12;
          }
          else
          {
            v10 = *v8;
            if (*v8 >= v8[1])
            {
              v7 = v12;
            }
            else
            {
              v10 = v8[1];
              ++v8;
            }
          }
        }
        while (v10 >= v11);
        *a4 = v11;
      }
    }
  }
  return result;
}

_QWORD *std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSDOrthoPathNode *,TSDOrthoPathNode *),std::__wrap_iter<TSDOrthoPathNode **>>(_QWORD *a1, unsigned int (**a2)(_QWORD, _QWORD), uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;

  v6 = 0;
  v7 = a3 - 2;
  if (a3 < 2)
    v7 = a3 - 1;
  v8 = v7 >> 1;
  do
  {
    v9 = &a1[v6 + 1];
    v10 = (2 * v6) | 1;
    v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)(a1[v6 + 1], a1[v6 + 2]))
    {
      ++v9;
      v10 = v11;
    }
    *a1 = *v9;
    a1 = v9;
    v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

uint64_t std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSDOrthoPathNode *,TSDOrthoPathNode *),std::__wrap_iter<TSDOrthoPathNode **>>(uint64_t result, uint64_t a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4)
{
  unint64_t v4;
  uint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;

  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v6 = result;
    v7 = v4 >> 1;
    v8 = (uint64_t *)(result + 8 * (v4 >> 1));
    v9 = (uint64_t *)(a2 - 8);
    result = (*a3)(*v8, *(_QWORD *)(a2 - 8));
    if ((_DWORD)result)
    {
      v10 = *v9;
      do
      {
        v11 = v8;
        *v9 = *v8;
        if (!v7)
          break;
        v7 = (v7 - 1) >> 1;
        v8 = (uint64_t *)(v6 + 8 * v7);
        result = (*a3)(*v8, v10);
        v9 = v11;
      }
      while ((result & 1) != 0);
      *v11 = v10;
    }
  }
  return result;
}

void sub_217AE7F5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__18(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__18(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_217AEDB08(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217AEDBD8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217AF2B10(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217AF2B68(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217AF2C70(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__tree<objc_object  {objcproto19TSWPStorageObserver}*>::__erase_unique<objc_object  {objcproto19TSWPStorageObserver}>(uint64_t a1, unint64_t *a2)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  BOOL v6;
  _QWORD *v7;

  v2 = *(_QWORD **)(a1 + 8);
  if (!v2)
    return 0;
  v3 = *a2;
  v4 = (uint64_t *)(a1 + 8);
  do
  {
    v5 = v2[4];
    v6 = v5 >= v3;
    if (v5 >= v3)
      v7 = v2;
    else
      v7 = v2 + 1;
    if (v6)
      v4 = v2;
    v2 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(a1 + 8) || v3 < v4[4])
    return 0;
  std::__tree<std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,EQKit::Config::Operator::Form>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,EQKit::Config::Operator::Form>>>::__remove_node_pointer((uint64_t **)a1, v4);
  operator delete(v4);
  return 1;
}

void sub_217AF303C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_217AF30F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_217AF3230(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_217AF32AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;

  a9.super_class = (Class)TSWPEditMenuController;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_217AF340C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_217AF39AC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217AF4A88(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x219A153B8](v1, 0x10E1C405C8FB0CCLL);
  _Unwind_Resume(a1);
}

void sub_217AF4C50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSWPLayoutColumnChore::TSWPLayoutColumnChore(uint64_t a1, void *a2, void *a3, void *a4, int a5, uint64_t a6, uint64_t a7, void *a8, TSWPTopicNumberHints *a9)
{
  TSWPTopicNumberHints *v13;
  TSWPTopicNumberHints *v14;

  v13 = (TSWPTopicNumberHints *)TSWPLayoutChore::TSWPLayoutChore(a1, a2, a3, a4, a6, a5, a6, a7, 0, 0);
  v13->_numbersForListStyle.__tree_.__begin_node_ = &off_24D82D198;
  v13->_styleProvider = (TSWPStyleProvider *)(a6 + a7);
  v13[1]._numbersForListStyle.__tree_.__begin_node_ = a8;
  v14 = v13 + 17;
  TSWPTopicNumberHints::operator=(v13 + 17, a9);
  TSWPTopicNumberHints::advanceToCharIndex(v14, *(_QWORD *)(a1 + 80), *(TSWPStorage **)(a1 + 8));
  TSWPTopicNumberHints::operator=((TSWPTopicNumberHints *)(a1 + 768), v14);
  return a1;
}

{
  return TSWPLayoutColumnChore::TSWPLayoutColumnChore(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

void sub_217AF839C(_Unwind_Exception *a1)
{
  TSWPLayoutChore *v1;

  TSWPLayoutChore::~TSWPLayoutChore(v1);
  _Unwind_Resume(a1);
}

void TSWPLayoutColumnChore::~TSWPLayoutColumnChore(TSWPLayoutColumnChore *this)
{
  TSWPLayoutChore::~TSWPLayoutChore(this);
  JUMPOUT(0x219A153B8);
}

uint64_t TSWPLayoutColumnChore::layoutColumnsIntoTarget(NSUInteger a1, void *a2, unint64_t a3, uint64_t a4, void *a5)
{
  void *v10;
  char v11;

  *(_QWORD *)(a1 + 2056) = a2;
  v10 = (void *)objc_msgSend((id)objc_msgSend(a2, "columns"), "objectAtIndexedSubscript:", a3);
  v11 = 0;
  if ((objc_opt_respondsToSelector() & 1) != 0)
    v11 = objc_msgSend(*(id *)(a1 + 16), "invalidateOnExactTextRangeLayout") != 0;
  TSWPLayoutChore::protectedSetupLayoutState(a1, a2, a3, objc_msgSend(v10, "startCharIndex"), a5);
  TSWPLayoutChore::protectedLayoutColumnsWithFlags(a1, v11, a3, a4, a2);
  return TSWPLayoutChore::pSetTargetColumnsTransform((id *)a1);
}

void sub_217AF869C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x219A153B8](v1, 0x20C40960023A9);
  _Unwind_Resume(a1);
}

void sub_217AF8A2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t compareAttachments(objc_object *a1, objc_object *a2, void *a3)
{
  unint64_t v4;
  unint64_t v5;

  v4 = objc_msgSend((id)-[objc_object objectAtIndexedSubscript:](a1, "objectAtIndexedSubscript:", 1), "unsignedIntegerValue");
  v5 = objc_msgSend((id)-[objc_object objectAtIndexedSubscript:](a2, "objectAtIndexedSubscript:", 1), "unsignedIntegerValue");
  if (v4 < v5)
    return -1;
  else
    return v4 > v5;
}

void TSWPLineStylingCTState::TSWPLineStylingCTState(TSWPLineStylingCTState *this, const TSWPLineStylingCTState *a2)
{
  __int128 v4;

  *(_QWORD *)this = *(id *)a2;
  v4 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)this + 24) = v4;
}

{
  __int128 v4;

  *(_QWORD *)this = *(id *)a2;
  v4 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)this + 24) = v4;
}

uint64_t TSWPLineStylingCTState::textProperties(id *this)
{
  return objc_msgSend((id)objc_msgSend(*this, "overrideCharacterStylePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties"));
}

TSWPCharacterStyle *TSWPLineStylingCTState::modifiedCharacterStyle(TSWPLineStylingCTState *this, TSSStylesheet *a2, TSWPCharacterStyle *a3)
{
  if ((*((_BYTE *)this + 8) & 1) == 0)
    return a3;
  if (a3)
    return (TSWPCharacterStyle *)-[TSSStylesheet variationOfStyle:propertyMap:](a2, "variationOfStyle:propertyMap:", a3, objc_msgSend((id)objc_msgSend(*(id *)this, "overrideCharacterStylePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties")));
  return -[TSSStyle initWithContext:name:overridePropertyMap:isVariation:]([TSWPCharacterStyle alloc], "initWithContext:name:overridePropertyMap:isVariation:", -[TSPObject context](a2, "context"), 0, objc_msgSend((id)objc_msgSend(*(id *)this, "overrideCharacterStylePropertyMap"), "propertyMapWithProperties:", +[TSWPCharacterStyle properties](TSWPCharacterStyle, "properties")), 0);
}

void TSWPLineStylingCTState::prepareForRelayout(void **a1, void *a2, void *a3)
{
  id v4[5];

  if (*a1 != a2)
  {
    TSWPLineStylingCTState::TSWPLineStylingCTState((uint64_t)v4, a2, a3);
    TSWPLineStylingCTState::operator=((uint64_t)a1, (uint64_t)v4);

  }
}

void sub_217AFA9B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void TSWPLineStylingLayoutState::TSWPLineStylingLayoutState(TSWPLineStylingLayoutState *this, id *a2)
{
  __int128 v4;
  __int128 v5;

  *((_QWORD *)this + 1) = a2[1];
  v4 = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 1) = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 2) = v4;
  *(_QWORD *)this = *a2;
  v5 = *((_OWORD *)a2 + 3);
  *((_QWORD *)this + 8) = a2[8];
  *((_OWORD *)this + 3) = v5;
}

void sub_217AFAA1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = 0;
  _Unwind_Resume(a1);
}

uint64_t TSWPLineStylingLayoutState::clearLayoutState(uint64_t this)
{
  *(_QWORD *)(this + 48) = 0;
  *(_BYTE *)(this + 64) &= ~1u;
  return this;
}

uint64_t TSWPLineStylingLayoutState::prepareForLayoutIteration(uint64_t this)
{
  *(_QWORD *)(this + 48) = 0;
  *(_BYTE *)(this + 64) &= ~1u;
  return this;
}

void TSWPLineStylingLayoutState::prepareForRelayout(void **a1, void *a2)
{
  TSWPLineStylingCTState::prepareForRelayout(a1 + 1, *a1, a2);
}

void sub_217AFBE34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__19(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__19(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

const char *TSWPHighlightAttributeArray::className(TSWPHighlightAttributeArray *this)
{
  return "TSWPHighlightAttributeArray";
}

void TSWPHighlightAttributeArray::~TSWPHighlightAttributeArray(TSWPAttributeArray *this)
{
  TSWPStyleAttributeArray::~TSWPStyleAttributeArray(this);
  JUMPOUT(0x219A153B8);
}

uint64_t TSWPAttributeArray::hasPairedData(TSWPAttributeArray *this)
{
  return 0;
}

uint64_t TSWPAttributeArray::hasSingleData(TSWPAttributeArray *this)
{
  return 0;
}

uint64_t TSWPAttributeArray::shouldInsertAttributesForMarkers(TSWPAttributeArray *this)
{
  return 0;
}

void TSWPEnumerateWordsInStringWithBlock(CFStringRef string, CFRange range, CFLocaleRef locale, uint64_t a4)
{
  __CFStringTokenizer *v5;
  __CFStringTokenizer *v6;
  CFStringTokenizerTokenType Token;
  CFStringTokenizerTokenType v8;

  v5 = CFStringTokenizerCreate(0, string, range, 4uLL, locale);
  if (v5)
  {
    v6 = v5;
    Token = CFStringTokenizerAdvanceToNextToken(v5);
    if (Token)
    {
      LOBYTE(v8) = Token;
      do
      {
        if ((v8 & 0x10) == 0)
          (*(void (**)(uint64_t, __CFStringTokenizer *))(a4 + 16))(a4, v6);
        v8 = CFStringTokenizerAdvanceToNextToken(v6);
      }
      while (v8);
    }
    CFRelease(v6);
  }
}

void sub_217AFD940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t TSWPParagraphAttributeArray::replaceParagraphDataForAttributeIndex(uint64_t result, _DWORD *a2, uint64_t a3)
{
  *(_DWORD *)(*(_QWORD *)(result + 32) + 16 * a3 + 8) = *a2;
  return result;
}

void TSWPParagraphAttributeArray::adoptStylesheetWithMapper(TSWPAttributeArray *a1, uint64_t a2, void *a3)
{
  unint64_t v6;
  uint64_t v7;
  void *v8;
  unint64_t var2;
  unint64_t v10;
  uint64_t v11;
  TSWPAttributeRecord *var4;
  uint64_t v13;
  objc_object *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  objc_class *v18;
  NSString *v19;
  objc_class *v20;

  if (a1->var1 == 8)
  {
    if (a1->var2)
    {
      v6 = 0;
      v7 = 8;
      do
      {
        v8 = *(void **)((char *)a1->var4 + v7);
        if (v8)
        {
          if ((objc_opt_respondsToSelector() & 1) != 0)
            objc_msgSend(v8, "adoptStylesheet:withMapper:", a2, a3);
        }
        ++v6;
        v7 += 16;
      }
      while (v6 < a1->var2);
    }
  }
  else if ((*((unsigned int (**)(TSWPAttributeArray *))a1->var0 + 3))(a1))
  {
    var2 = a1->var2;
    if (var2)
    {
      v10 = 0;
      v11 = 8;
      do
      {
        var4 = a1->var4;
        v13 = *(_QWORD *)((char *)var4 + v11);
        if (v13)
        {
          v14 = (objc_object *)objc_msgSend(a3, "mappedStyleForStyle:", *(_QWORD *)((char *)var4 + v11));
          if (!v14 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
          {
            v15 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v16 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "virtual void TSWPParagraphAttributeArray::adoptStylesheetWithMapper(TSSStylesheet *, id<TSKStyleMapper>)");
            v17 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphAttributeArray.mm");
            v18 = (objc_class *)objc_opt_class();
            v19 = NSStringFromClass(v18);
            v20 = (objc_class *)objc_opt_class();
            objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, v17, 103, CFSTR("Bad style mapping [%@ %p] -> [%@ %p]"), v19, v13, NSStringFromClass(v20), v14);
          }
          TSWPAttributeArray::replaceObjectForAttributeIndex(a1, v14, v10, 0, 0);
          var2 = a1->var2;
        }
        ++v10;
        v11 += 16;
      }
      while (v10 < var2);
    }
  }
}

uint64_t TSWPParagraphAttributeArray::deletingWholeParagraphs(TSWPParagraphAttributeArray *this, _NSRange a2, TSWPAttributeArray *a3)
{
  NSUInteger length;
  NSUInteger location;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t var2;
  _BOOL4 v10;
  _BOOL4 v12;

  if (!a3)
    return 0;
  length = a2.length;
  location = a2.location;
  v6 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(a3, a2.location);
  v7 = location + length;
  v8 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(a3, v7);
  var2 = a3->var2;
  if (v6 >= var2)
  {
    v10 = 0;
  }
  else
  {
    v10 = TSWPAttributeArray::charIndexForAttributeIndex(a3, v6) == location;
    var2 = a3->var2;
  }
  v12 = v8 < var2 && TSWPAttributeArray::charIndexForAttributeIndex(a3, v8) == v7;
  return v10 & v12;
}

void TSWPParagraphAttributeArray::assignAttributesAtFrontOfRange(TSWPParagraphAttributeArray *this, _NSRange a2, TSWPParagraphAttributeArray *a3, TSWPStorageTransaction *a4)
{
  NSUInteger length;
  NSUInteger location;
  NSUInteger v9;
  NSUInteger v10;
  NSUInteger v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  objc_object *v22;
  objc_object *v23;
  int v24;
  _NSRange v25;

  length = a2.length;
  location = a2.location;
  v9 = TSWPParagraphAttributeArray::paragraphRangeForCharRange(a3, a2);
  v11 = v10;
  v12 = (*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 3))(this);
  v13 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex((TSWPAttributeArray *)this, location + length);
  if (v12)
  {
    if (v13 != 0x7FFFFFFFFFFFFFFFLL)
    {
      v23 = (objc_object *)*((_QWORD *)this->var4 + 2 * v13 + 1);
      v22 = v23;
      v25.location = v9;
      v25.length = v11;
      TSWPParagraphAttributeArray::applyObjectToParagraphRange(this, v23, v25, a3, a4);

      return;
    }
    v14 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPParagraphAttributeArray::assignAttributesAtFrontOfRange(NSRange, TSWPParagraphAttributeArray *, TSWPStorageTransaction *)");
    v16 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphAttributeArray.mm");
    v17 = (void *)v14;
    v18 = v15;
    v19 = 150;
  }
  else
  {
    if (v13 != 0x7FFFFFFFFFFFFFFFLL)
    {
      v24 = *((_DWORD *)this->var4 + 4 * v13 + 2);
      TSWPParagraphAttributeArray::applyParagraphDataToParagraphRange(this, (unsigned __int16 *)&v24, v9, v11, (TSWPAttributeArray *)a3, a4);
      return;
    }
    v20 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v21 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPParagraphAttributeArray::assignAttributesAtFrontOfRange(NSRange, TSWPParagraphAttributeArray *, TSWPStorageTransaction *)");
    v16 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphAttributeArray.mm");
    v17 = (void *)v20;
    v18 = v21;
    v19 = 162;
  }
  objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, v16, v19, CFSTR("Bad attribute index in break table."));
}

uint64_t TSWPParagraphAttributeArray::applyParagraphDataToParagraphRange(TSWPParagraphAttributeArray *this, unsigned __int16 *a2, unint64_t a3, NSUInteger a4, TSWPAttributeArray *a5, TSWPStorageTransaction *a6)
{
  unint64_t v11;
  unint64_t var2;
  void *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  char v19;
  char v20;
  unint64_t v21;
  unsigned __int16 *v22;
  BOOL IsSame;
  int v24;
  unint64_t i;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  BOOL v30;
  int v31;
  NSUInteger v33;
  unint64_t v35;
  int v36;
  _NSRange v37;

  if (!a4 || !a5 || (v11 = a3 + a4, var2 = a5->var2, a3 + a4 > var2))
  {
    v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPParagraphAttributeArray::applyParagraphDataToParagraphRange(const TSWPParagraphData &, NSRange, TSWPParagraphAttributeArray *, TSWPStorageTransaction *)");
    objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphAttributeArray.mm"), 718, CFSTR("Bad par index range."));
    if (!a4)
    {
      v19 = 0;
      v20 = 0;
      v11 = a3;
      if (!a5)
        return v20 & 1;
      goto LABEL_16;
    }
    var2 = a5->var2;
    v11 = a3 + a4;
  }
  if (v11 < var2 && TSWPParagraphAttributeArray::isParagraphBreakSparse(this, v11, a5))
  {
    v15 = TSWPAttributeArray::charIndexForAttributeIndex(a5, v11);
    v16 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex((TSWPAttributeArray *)this, v15);
    if (v16 != 0x7FFFFFFFFFFFFFFFLL)
    {
      v21 = v16;
      v22 = (unsigned __int16 *)((char *)this->var4 + 16 * v16 + 8);
      IsSame = TSWPParagraphAttributeArray::dataIsSame((uint64_t)this, a2, v22);
      if (!IsSame)
      {
        v24 = *(_DWORD *)v22;
        v35 = v15;
        v36 = v24;
        TSWPAttributeArray::insertAttribute((TSWPAttributeArray *)this, (const TSWPAttributeRecord *)&v35, v21 + 1, 0, a6);
      }
      v19 = !IsSame;
      goto LABEL_16;
    }
    v17 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v18 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPParagraphAttributeArray::applyParagraphDataToParagraphRange(const TSWPParagraphData &, NSRange, TSWPParagraphAttributeArray *, TSWPStorageTransaction *)");
    objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphAttributeArray.mm"), 728, CFSTR("Bad attribute index."));
  }
  v19 = 0;
LABEL_16:
  if (v11 <= a5->var2)
  {
    v33 = a3;
    if (a3 < v11)
    {
      for (i = a3; v11 != i; ++i)
      {
        v26 = TSWPAttributeArray::charIndexForAttributeIndex(a5, i);
        v27 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex((TSWPAttributeArray *)this, v26);
        if (v27 == 0x7FFFFFFFFFFFFFFFLL)
          v28 = 0;
        else
          v28 = v27;
        v29 = TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)this, v28);
        v30 = TSWPParagraphAttributeArray::dataIsSame((uint64_t)this, a2, (unsigned __int16 *)this->var4 + 8 * v28 + 4);
        if (v29 == v26)
        {
          if (!v30)
          {
            if (!v28
              || !TSWPParagraphAttributeArray::dataIsSame((uint64_t)this, a2, (unsigned __int16 *)this->var4 + 8 * v28 - 4))
            {
              *((_DWORD *)this->var4 + 4 * v28 + 2) = *(_DWORD *)a2;
              goto LABEL_30;
            }
            v19 = 1;
            (*((void (**)(TSWPParagraphAttributeArray *, unint64_t, uint64_t, TSWPStorageTransaction *))this->var0
             + 7))(this, v28, 1, a6);
          }
        }
        else if (!v30)
        {
          v31 = *(_DWORD *)a2;
          v35 = v26;
          v36 = v31;
          TSWPAttributeArray::insertAttribute((TSWPAttributeArray *)this, (const TSWPAttributeRecord *)&v35, v28 + 1, 0, a6);
LABEL_30:
          v19 = 1;
        }
      }
    }
    v37.location = v33;
    v37.length = a4;
    TSWPParagraphAttributeArray::didApplyAttributes(this, v37, a5, a6);
  }
  v20 = v19;
  return v20 & 1;
}

BOOL TSWPParagraphAttributeArray::isParagraphBreakSparse(TSWPParagraphAttributeArray *this, unint64_t a2, TSWPAttributeArray *a3)
{
  unint64_t v5;
  unint64_t v7;

  if ((this->var1 | 8) == 8 || a3->var2 <= a2)
    return 0;
  v7 = 0x7FFFFFFFFFFFFFFFLL;
  TSWPParagraphAttributeArray::attributeIndexForParagraphIndex(this, a2, a3, &v7);
  v5 = v7;
  return v5 != TSWPAttributeArray::charIndexForAttributeIndex(a3, a2);
}

const char *TSWPParagraphAttributeArray::className(TSWPParagraphAttributeArray *this)
{
  return "TSWPParagraphAttributeArray";
}

BOOL TSWPParagraphAttributeArray::canCollapseAttributes(TSWPParagraphAttributeArray *this, const TSWPAttributeRecord *a2, const TSWPAttributeRecord *a3)
{
  int v6;
  unsigned __int16 *v7;

  v6 = (*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 3))(this);
  v7 = (unsigned __int16 *)((char *)a2 + 8);
  if (v6)
    return *(_QWORD *)v7 == *((_QWORD *)a3 + 1);
  else
    return TSWPParagraphAttributeArray::dataIsSame((uint64_t)this, v7, (unsigned __int16 *)a3 + 4);
}

BOOL TSWPParagraphAttributeArray::dataIsSame(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  void *v8;
  uint64_t v9;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1))
  {
    return *a2 == *a3 && a2[1] == a3[1];
  }
  else
  {
    if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1))
    {
      v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPParagraphAttributeArray::dataIsSame(const TSWPParagraphData &, const TSWPParagraphData &) const");
      objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphAttributeArray.mm"), 711, CFSTR("Do not call dataIsSame for this table."));
      return 0;
    }
    return *(_DWORD *)a2 == *(_DWORD *)a3;
  }
}

TSWPParagraphAttributeArray *TSWPParagraphAttributeArray::collapseAttributesAtAttributeIndex(TSWPParagraphAttributeArray *this, unint64_t a2, TSWPStorageTransaction *a3)
{
  TSWPAttributeArray *v5;
  unint64_t v6;

  v5 = (TSWPAttributeArray *)this;
  if (a2)
  {
    if (this->var2 > a2)
    {
      this = (TSWPParagraphAttributeArray *)(*((uint64_t (**)(TSWPParagraphAttributeArray *, char *, char *))this->var0
                                             + 26))(this, (char *)this->var4 + 16 * a2, (char *)this->var4 + 16 * a2 - 16);
      if ((this & 1) != 0)
        return (TSWPParagraphAttributeArray *)(*((uint64_t (**)(TSWPAttributeArray *, unint64_t, uint64_t, TSWPStorageTransaction *))v5->var0
                                               + 7))(v5, a2, 1, a3);
    }
  }
  if (v5->var2 - 1 == a2)
  {
    v6 = TSWPAttributeArray::charIndexForAttributeIndex(v5, a2);
    this = (TSWPParagraphAttributeArray *)TSWPAttributeArray::characterCount(v5);
    if (v6 > (unint64_t)this)
      return (TSWPParagraphAttributeArray *)(*((uint64_t (**)(TSWPAttributeArray *, unint64_t, uint64_t, TSWPStorageTransaction *))v5->var0
                                             + 7))(v5, a2, 1, a3);
  }
  return this;
}

void *TSWPParagraphAttributeArray::description(TSWPParagraphAttributeArray *this)
{
  signed int var1;
  void *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;

  var1 = this->var1;
  if (var1 > 10)
  {
    if (var1 == 11)
    {
      v3 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
      objc_msgSend(v3, "appendFormat:", CFSTR("%s <%p> %@: Count: %lu.\n"), (*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 22))(this), this, CFSTR("ParagraphListStarts"), this->var2);
      if (this->var2)
      {
        v10 = 0;
        v11 = 8;
        do
        {
          objc_msgSend(v3, "appendFormat:", CFSTR("\t%u) CharIndex: %lu, start %lu\n"), v10, TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)this, v10), *(unsigned int *)((char *)this->var4 + v11));
          ++v10;
          v11 += 16;
        }
        while (v10 < this->var2);
      }
      return v3;
    }
    if (var1 == 18)
    {
      v3 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
      objc_msgSend(v3, "appendFormat:", CFSTR("%s <%p> %@: Count: %lu.\n"), (*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 22))(this), this, CFSTR("ParagraphWritingDirection"), this->var2);
      if (this->var2)
      {
        v6 = 0;
        v7 = 8;
        do
        {
          objc_msgSend(v3, "appendFormat:", CFSTR("\t%u) CharIndex: %lu, direction %d\n"), v6, TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)this, v6), *(unsigned int *)((char *)this->var4 + v7));
          ++v6;
          v7 += 16;
        }
        while (v6 < this->var2);
      }
      return v3;
    }
  }
  else
  {
    if (var1 == 1)
    {
      v3 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
      objc_msgSend(v3, "appendFormat:", CFSTR("%s <%p> %@: Count: %lu.\n"), (*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 22))(this), this, CFSTR("ParagraphData"), this->var2);
      if (this->var2)
      {
        v8 = 0;
        v9 = 0;
        do
        {
          objc_msgSend(v3, "appendFormat:", CFSTR("\t%u) CharIndex: %lu, level %d flags %d\n"), v9, TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)this, v9), *(unsigned __int16 *)((char *)this->var4 + v8 + 8), *(unsigned __int16 *)((char *)this->var4 + v8 + 10));
          ++v9;
          v8 += 16;
        }
        while (v9 < this->var2);
      }
      return v3;
    }
    if (var1 == 10)
    {
      v3 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
      objc_msgSend(v3, "appendFormat:", CFSTR("%s <%p> %@: Count: %u.\n"), (*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 22))(this), this, CFSTR("CellData"), this->var2);
      if (this->var2)
      {
        v4 = 0;
        v5 = 0;
        do
        {
          objc_msgSend(v3, "appendFormat:", CFSTR("\t%u) CharIndex: %lu, row %d column %d\n"), v5, TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)this, v5), *(unsigned __int16 *)((char *)this->var4 + v4 + 8), *(unsigned __int16 *)((char *)this->var4 + v4 + 10));
          ++v5;
          v4 += 16;
        }
        while (v5 < this->var2);
      }
      return v3;
    }
  }
  return TSWPAttributeArray::description((TSWPAttributeArray *)this);
}

uint64_t TSWPParagraphAttributeArray::allowsNilObjects(TSWPParagraphAttributeArray *this)
{
  return 0;
}

uint64_t TSWPParagraphAttributeArray::attributeIndexForOrderedParagraphData(_QWORD *a1, int *a2)
{
  int v3;
  const void *v4;
  size_t v5;
  int (__cdecl *v6)(const void *, const void *);
  void *v7;
  uint64_t v9;
  int v10;

  v3 = *a2;
  v9 = 0;
  v10 = v3;
  v4 = (const void *)a1[4];
  v5 = a1[2];
  if ((*(unsigned int (**)(_QWORD *))(*a1 + 40))(a1))
    v6 = (int (__cdecl *)(const void *, const void *))singleComparator;
  else
    v6 = (int (__cdecl *)(const void *, const void *))pairedComparator;
  v7 = bsearch(&v9, v4, v5, 0x10uLL, v6);
  if (v7)
    return ((uint64_t)v7 - a1[4]) >> 4;
  else
    return 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t singleComparator(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = a1[2];
  v3 = a2[2];
  v4 = v2 >= v3;
  v5 = v2 != v3;
  if (v4)
    return v5;
  else
    return 0xFFFFFFFFLL;
}

uint64_t pairedComparator(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  _BOOL4 v8;

  v2 = a1[4];
  v3 = a2[4];
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  if (v2 != v3)
    return 1;
  v5 = a1[5];
  v6 = a2[5];
  v7 = v5 >= v6;
  v8 = v5 != v6;
  if (v7)
    return v8;
  else
    return 0xFFFFFFFFLL;
}

uint64_t TSWPParagraphAttributeArray::hasPairedData(TSWPParagraphAttributeArray *this)
{
  return (*((unsigned int (**)(TSWPParagraphAttributeArray *))this->var0 + 3))(this) ^ 1;
}

BOOL TSWPParagraphAttributeArray::hasSingleData(TSWPParagraphAttributeArray *this)
{
  unsigned int var1;

  if (((*((uint64_t (**)(TSWPParagraphAttributeArray *))this->var0 + 3))(this) & 1) != 0)
    return 0;
  var1 = this->var1;
  return var1 == 11 || var1 == 18;
}

BOOL TSWPTopicNumberHints::operator==(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;
  _QWORD *v10;
  _QWORD *v11;
  char v13;

  if (*(_QWORD *)(a1 + 24) == a2[3] && *(_QWORD *)(a1 + 16) == a2[2])
  {
    v4 = (_QWORD *)(a1 + 8);
    v5 = *(_QWORD **)a1;
    if (*(_QWORD *)a1 == a1 + 8)
      return *(_QWORD *)(a1 + 40) == a2[5];
    v6 = (_QWORD *)*a2;
    while (std::__equal_to::operator()[abi:nn180100]<std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>>,std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>>>((uint64_t)&v13, v5 + 4, v6 + 4))
    {
      v7 = (_QWORD *)v5[1];
      v8 = v5;
      if (v7)
      {
        do
        {
          v5 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v5 = (_QWORD *)v8[2];
          v9 = *v5 == (_QWORD)v8;
          v8 = v5;
        }
        while (!v9);
      }
      v10 = (_QWORD *)v6[1];
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v11 = (_QWORD *)v6[2];
          v9 = *v11 == (_QWORD)v6;
          v6 = v11;
        }
        while (!v9);
      }
      v6 = v11;
      if (v5 == v4)
        return *(_QWORD *)(a1 + 40) == a2[5];
    }
  }
  return 0;
}

BOOL TSWPTopicNumberHints::operator!=(uint64_t a1, _QWORD *a2)
{
  return !TSWPTopicNumberHints::operator==(a1, a2);
}

uint64_t TSWPTopicNumberHints::equivalentState(TSWPTopicNumberHints *this, const TSWPTopicNumberHints *a2)
{
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *p_pair1;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v3;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *begin_node;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v5;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v6;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *left;
  char v8;
  void *v9;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v10;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v11;
  void *v12;
  BOOL v13;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **v14;
  char *v15;
  char *v16;
  unint64_t v17;
  uint64_t *v18;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v24;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v25;
  BOOL v26;

  if (this->_numbersForListStyle.__tree_.__pair3_.__value_ != a2->_numbersForListStyle.__tree_.__pair3_.__value_)
    return 0;
  begin_node = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)this->_numbersForListStyle.__tree_.__begin_node_;
  p_pair1 = &this->_numbersForListStyle.__tree_.__pair1_;
  v3 = begin_node;
  if (begin_node == p_pair1)
  {
    v8 = 1;
  }
  else
  {
    left = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)a2->_numbersForListStyle.__tree_.__pair1_.__value_.__left_;
    v5 = &a2->_numbersForListStyle.__tree_.__pair1_;
    v6 = left;
    if (left)
    {
      v8 = 1;
      while (1)
      {
        v9 = v3[4].__value_.__left_;
        v10 = v5;
        v11 = v6;
        do
        {
          v12 = v11[4].__value_.__left_;
          v13 = v12 >= v9;
          if (v12 >= v9)
            v14 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)v11;
          else
            v14 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)&v11[1];
          if (v13)
            v10 = v11;
          v11 = *v14;
        }
        while (*v14);
        if (v10 == v5)
          break;
        if (v9 < v10[4].__value_.__left_)
          break;
        v15 = (char *)v3[5].__value_.__left_;
        v16 = (char *)v3[6].__value_.__left_;
        v17 = (v16 - v15) >> 4;
        v19 = v10 + 5;
        v18 = (uint64_t *)v10[5].__value_.__left_;
        if (v17 != ((char *)v19[1].__value_.__left_ - (char *)v18) >> 4)
          break;
        if ((v8 & 1) != 0 && v16 != v15)
        {
          v20 = 0;
          while (1)
          {
            v22 = *(_QWORD *)v15;
            v15 += 16;
            v21 = v22;
            v23 = *v18;
            v18 += 2;
            if (v21 != v23)
              break;
            if (++v20 >= v17)
              goto LABEL_23;
          }
          v8 = 0;
        }
LABEL_23:
        v24 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)v3[1].__value_.__left_;
        if (v24)
        {
          do
          {
            v25 = v24;
            v24 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)v24->__value_.__left_;
          }
          while (v24);
        }
        else
        {
          do
          {
            v25 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)v3[2].__value_.__left_;
            v26 = v25->__value_.__left_ == v3;
            v3 = v25;
          }
          while (!v26);
        }
        v3 = v25;
        if (v25 == p_pair1)
          return v8 & 1;
      }
    }
    v8 = 0;
  }
  return v8 & 1;
}

TSWPTopicNumberHints *TSWPTopicNumberHints::offsetCharIndex(TSWPTopicNumberHints *this, uint64_t a2, unint64_t a3)
{
  unint64_t charIndex;
  unint64_t validThroughCharIndex;
  BOOL v6;
  _QWORD *begin_node;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  TSWPTopicNumberHints *v12;
  TSWPTopicNumberHints *v13;
  unint64_t v15;
  unint64_t v16;

  charIndex = this->_charIndex;
  validThroughCharIndex = this->_validThroughCharIndex;
  v6 = charIndex < a3 || charIndex == 0x7FFFFFFFFFFFFFFFLL;
  if (!v6)
  {
    charIndex += a2;
    begin_node = this->_numbersForListStyle.__tree_.__begin_node_;
    if (this->_numbersForListStyle.__tree_.__begin_node_ != &this->_numbersForListStyle.__tree_.__pair1_)
    {
      do
      {
        v8 = begin_node[5];
        v9 = begin_node[6] - v8;
        if (v9)
        {
          v10 = v9 >> 4;
          if (v10 <= 1)
            v10 = 1;
          v11 = (unint64_t *)(v8 + 8);
          do
          {
            if (*v11 >= a3)
              *v11 += a2;
            v11 += 2;
            --v10;
          }
          while (v10);
        }
        v12 = (TSWPTopicNumberHints *)begin_node[1];
        if (v12)
        {
          do
          {
            v13 = v12;
            v12 = (TSWPTopicNumberHints *)v12->_numbersForListStyle.__tree_.__begin_node_;
          }
          while (v12);
        }
        else
        {
          do
          {
            v13 = (TSWPTopicNumberHints *)begin_node[2];
            v6 = v13->_numbersForListStyle.__tree_.__begin_node_ == begin_node;
            begin_node = &v13->_numbersForListStyle.__tree_.__begin_node_;
          }
          while (!v6);
        }
        begin_node = &v13->_numbersForListStyle.__tree_.__begin_node_;
      }
      while (v13 != (TSWPTopicNumberHints *)&this->_numbersForListStyle.__tree_.__pair1_);
    }
  }
  if (validThroughCharIndex == 0x7FFFFFFFFFFFFFFFLL || validThroughCharIndex < a3)
    a2 = 0;
  v15 = a2 + validThroughCharIndex;
  if (charIndex <= v15)
    v16 = v15;
  else
    v16 = charIndex;
  return TSWPTopicNumberHints::setCharIndexAndValidCharIndex(this, charIndex, v16);
}

uint64_t TSWPTopicNumberHints::nextTopicNumberForList(TSWPTopicNumberHints *this, TSWPListStyle *a2, unint64_t a3)
{
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  id v10;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v11;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *p_pair1;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *left;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v14;
  unint64_t v15;
  BOOL v16;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **v17;
  _QWORD *v18;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v19;

  if (!a2)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSUInteger TSWPTopicNumberHints::nextTopicNumberForList(TSWPListStyle *, TSWPParagraphLevel) const");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 159, CFSTR("invalid nil value for '%s'"), "listStyle");
  }
  if (a3 >= 9)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSUInteger TSWPTopicNumberHints::nextTopicNumberForList(TSWPListStyle *, TSWPParagraphLevel) const");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 160, CFSTR("Bad level value: %lu"), a3);
  }
  v10 = -[TSWPListStyle baseStyleForTopicNumbers](a2, "baseStyleForTopicNumbers");
  left = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)this->_numbersForListStyle.__tree_.__pair1_.__value_.__left_;
  p_pair1 = &this->_numbersForListStyle.__tree_.__pair1_;
  v11 = left;
  if (!left)
    return 1;
  v14 = p_pair1;
  do
  {
    v15 = (unint64_t)v11[4].__value_.__left_;
    v16 = v15 >= (unint64_t)v10;
    if (v15 >= (unint64_t)v10)
      v17 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)v11;
    else
      v17 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)&v11[1];
    if (v16)
      v14 = v11;
    v11 = *v17;
  }
  while (*v17);
  if (v14 == p_pair1)
    return 1;
  if (v10 < v14[4].__value_.__left_)
    return 1;
  v19 = v14 + 5;
  v18 = v14[5].__value_.__left_;
  if (a3 >= ((char *)v19[1].__value_.__left_ - (char *)v18) >> 4)
    return 1;
  else
    return v18[2 * a3] + 1;
}

uint64_t TSWPTopicNumberHints::previousCharIndexForList(TSWPTopicNumberHints *this, TSWPListStyle *a2, unint64_t a3)
{
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  id v10;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v11;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *p_pair1;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *left;
  id v14;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v15;
  unint64_t v16;
  BOOL v17;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **v18;
  uint64_t result;
  char *v20;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;

  if (!a2)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPCharIndex TSWPTopicNumberHints::previousCharIndexForList(TSWPListStyle *, TSWPParagraphLevel) const");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 186, CFSTR("invalid nil value for '%s'"), "listStyle");
  }
  if (a3 >= 9)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPCharIndex TSWPTopicNumberHints::previousCharIndexForList(TSWPListStyle *, TSWPParagraphLevel) const");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 187, CFSTR("Bad level value: %lu"), a3);
  }
  v10 = -[TSWPListStyle baseStyleForTopicNumbers](a2, "baseStyleForTopicNumbers");
  left = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)this->_numbersForListStyle.__tree_.__pair1_.__value_.__left_;
  p_pair1 = &this->_numbersForListStyle.__tree_.__pair1_;
  v11 = left;
  if (left)
  {
    v14 = v10;
    v15 = p_pair1;
    do
    {
      v16 = (unint64_t)v11[4].__value_.__left_;
      v17 = v16 >= (unint64_t)v10;
      if (v16 >= (unint64_t)v10)
        v18 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)v11;
      else
        v18 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)&v11[1];
      if (v17)
        v15 = v11;
      v11 = *v18;
    }
    while (*v18);
    if (v15 != p_pair1)
    {
      result = 0x7FFFFFFFFFFFFFFFLL;
      if (v14 < v15[4].__value_.__left_)
        return result;
      v21 = v15 + 5;
      v20 = (char *)v15[5].__value_.__left_;
      v22 = ((char *)v21[1].__value_.__left_ - (char *)v20) >> 4;
      if (v22 >= a3 + 1)
        v22 = a3 + 1;
      v23 = v22 + 1;
      v24 = (uint64_t *)&v20[16 * v22 - 8];
      while (--v23)
      {
        v26 = *v24;
        v24 -= 2;
        v25 = v26;
        if (v26 != 0x7FFFFFFFFFFFFFFFLL)
          return v25;
      }
    }
  }
  return 0x7FFFFFFFFFFFFFFFLL;
}

void TSWPTopicNumberHints::setTopicNumberForList(TSWPTopicNumberHints *this, TSWPListStyle *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  id v14;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *left;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *p_pair1;
  unint64_t v17;
  BOOL v18;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **v19;
  _BYTE *v20;
  __int128 *v21;
  unint64_t i;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  uint64_t v27;
  __int128 *v28;
  __int128 *v29;
  __int128 *j;
  __int128 v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t *v34;
  unint64_t validThroughCharIndex;
  void *v36;
  uint64_t v37;
  void *__p;
  __int128 *v39;
  __int128 *v40;
  id v41;
  unint64_t *v42;

  if (!a2)
  {
    v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPTopicNumberHints::setTopicNumberForList(TSWPListStyle *, TSWPParagraphLevel, NSUInteger, TSWPCharIndex)");
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 214, CFSTR("invalid nil value for '%s'"), "listStyle");
  }
  if (a3 >= 9)
  {
    v12 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v13 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPTopicNumberHints::setTopicNumberForList(TSWPListStyle *, TSWPParagraphLevel, NSUInteger, TSWPCharIndex)");
    objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 215, CFSTR("Bad level value: %lu"), a3);
  }
  if (a4 && -[TSWPListStyle labelTypeForLevel:](a2, "labelTypeForLevel:", a3) == 3)
  {
    v14 = -[TSWPListStyle baseStyleForTopicNumbers](a2, "baseStyleForTopicNumbers");
    v40 = 0;
    v41 = v14;
    __p = 0;
    v39 = 0;
    left = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> *)this->_numbersForListStyle.__tree_.__pair1_.__value_.__left_;
    if (!left)
      goto LABEL_20;
    p_pair1 = &this->_numbersForListStyle.__tree_.__pair1_;
    do
    {
      v17 = (unint64_t)left[4].__value_.__left_;
      v18 = v17 >= (unint64_t)v14;
      if (v17 >= (unint64_t)v14)
        v19 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)left;
      else
        v19 = (__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<const TSWPListStyle *, std::vector<TSWPTopicNumberEntry>>, void *>>> **)&left[1];
      if (v18)
        p_pair1 = left;
      left = *v19;
    }
    while (*v19);
    if (p_pair1 == &this->_numbersForListStyle.__tree_.__pair1_
      || v14 < p_pair1[4].__value_.__left_
      || &__p == (void **)&p_pair1[5])
    {
LABEL_20:
      v20 = 0;
      v21 = 0;
    }
    else
    {
      std::vector<TSWPTopicNumberEntry>::__assign_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>(&__p, (__int128 *)p_pair1[5].__value_.__left_, (__int128 *)p_pair1[6].__value_.__left_, ((char *)p_pair1[6].__value_.__left_ - (char *)p_pair1[5].__value_.__left_) >> 4);
      v20 = __p;
      v21 = v39;
    }
    for (i = ((char *)v21 - v20) >> 4; i <= a3; i = ((char *)v21 - (_BYTE *)__p) >> 4)
    {
      if (v21 >= v40)
      {
        if ((i + 1) >> 60)
          abort();
        v23 = (char *)v40 - v20;
        v24 = v23 >> 3;
        if (v23 >> 3 <= i + 1)
          v24 = i + 1;
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0)
          v25 = 0xFFFFFFFFFFFFFFFLL;
        else
          v25 = v24;
        v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)&v40, v25);
        v28 = (__int128 *)&v26[16 * i];
        *v28 = xmmword_217C2AC70;
        v21 = v28 + 1;
        v29 = (__int128 *)__p;
        for (j = v39; j != v29; --j)
        {
          v31 = *(j - 1);
          *--v28 = v31;
        }
        __p = v28;
        v39 = v21;
        v40 = (__int128 *)&v26[16 * v27];
        if (v29)
          operator delete(v29);
      }
      else
      {
        *v21++ = xmmword_217C2AC70;
      }
      v39 = v21;
      v20 = __p;
    }
    if (i > a3 + 1)
    {
      v32 = (char *)v21 - v20 - 16;
      do
      {
        --v21;
        v18 = a3 + 1 >= v32 >> 4;
        v32 -= 16;
      }
      while (!v18);
      v39 = v21;
    }
    v33 = &v20[16 * a3];
    *v33 = a4;
    v33[1] = a5;
    v42 = (unint64_t *)&v41;
    v34 = std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::__emplace_unique_key_args<TSWPListStyle const*,std::piecewise_construct_t const&,std::tuple<TSWPListStyle const* const&>,std::tuple<>>((uint64_t **)this, (unint64_t *)&v41, (uint64_t)&std::piecewise_construct, (uint64_t **)&v42)+ 5;
    if (v34 != (uint64_t *)&__p)
      std::vector<TSWPTopicNumberEntry>::__assign_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>(v34, (__int128 *)__p, v39, ((char *)v39 - (_BYTE *)__p) >> 4);
    validThroughCharIndex = this->_validThroughCharIndex;
    if (validThroughCharIndex != 0x7FFFFFFFFFFFFFFFLL && validThroughCharIndex > a5)
    {
      v36 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v37 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPTopicNumberHints::setTopicNumberForList(TSWPListStyle *, TSWPParagraphLevel, NSUInteger, TSWPCharIndex)");
      objc_msgSend(v36, "handleFailureInFunction:file:lineNumber:description:", v37, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPTopicNumberHints.mm"), 245, CFSTR("Bad char index relative to _validThroughCharIndex"));
    }
    TSWPTopicNumberHints::setCharIndexAndValidCharIndex(this, a5, a5);
    if (__p)
    {
      v39 = (__int128 *)__p;
      operator delete(__p);
    }
  }
}

void sub_217B00928(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *TSWPTopicNumberHints::unarchiveSetEntriesForListStyle(uint64_t **a1, unint64_t a2, __int128 **a3)
{
  uint64_t *result;
  unint64_t v5;
  unint64_t *v6;

  v5 = a2;
  v6 = &v5;
  result = std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::__emplace_unique_key_args<TSWPListStyle const*,std::piecewise_construct_t const&,std::tuple<TSWPListStyle const* const&>,std::tuple<>>(a1, &v5, (uint64_t)&std::piecewise_construct, (uint64_t **)&v6)+ 5;
  if (result != (uint64_t *)a3)
    return (uint64_t *)std::vector<TSWPTopicNumberEntry>::__assign_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>(result, *a3, a3[1], a3[1] - *a3);
  return result;
}

TSWPTopicNumberHints *TSWPTopicNumberHints::backUpByOneParagraph(TSWPTopicNumberHints *this, TSWPTopicNumberHints *a2, TSWPStorage *a3)
{
  NSUInteger charIndex;
  TSWPTopicNumberHints *v5;

  charIndex = this->_charIndex;
  if (charIndex != 0x7FFFFFFFFFFFFFFFLL)
  {
    v5 = TSWPTopicNumberHints::operator=(this, a2);
    return TSWPTopicNumberHints::advanceToCharIndex(v5, charIndex, a3);
  }
  return this;
}

id TSWPTopicNumberHints::resetWithStyleProvider(uint64_t a1, void *a2)
{
  _QWORD *v4;
  id result;

  *(int64x2_t *)(a1 + 24) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
  v4 = (_QWORD *)(a1 + 8);
  std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::destroy(a1, *(_QWORD **)(a1 + 8));
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + 16) = 0;
  *v4 = 0;

  result = a2;
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

uint64_t std::pair<TSWPListStyle const*&,std::vector<TSWPTopicNumberEntry> &>::operator=[abi:nn180100]<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>,(void *)0>(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;

  **(_QWORD **)a1 = *(_QWORD *)a2;
  v3 = *(_QWORD **)(a1 + 8);
  if (v3 != (_QWORD *)(a2 + 8))
    std::vector<TSWPTopicNumberEntry>::__assign_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>(v3, *(__int128 **)(a2 + 8), *(__int128 **)(a2 + 16), (uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 4);
  return a1;
}

uint64_t std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:nn180100](uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;

  std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::destroy(*(_QWORD *)a1, *(_QWORD **)(a1 + 16));
  v2 = *(_QWORD **)(a1 + 8);
  if (v2)
  {
    v3 = (_QWORD *)v2[2];
    if (v3)
    {
      do
      {
        v2 = v3;
        v3 = (_QWORD *)v3[2];
      }
      while (v3);
      *(_QWORD *)(a1 + 8) = v2;
    }
    std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::destroy(*(_QWORD *)a1, v2);
  }
  return a1;
}

uint64_t *std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::__emplace_multi<std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>> const&>(uint64_t a1, uint64_t a2)
{
  uint64_t **v3;
  uint64_t *v4;
  uint64_t **v5;
  uint64_t *v7;

  std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::__construct_node<std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>> const&>(a1, a2, (uint64_t)&v7);
  v3 = (uint64_t **)(a1 + 8);
  v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v3 = (uint64_t **)v4;
        if (v7[4] >= (unint64_t)v4[4])
          break;
        v4 = (uint64_t *)*v4;
        v5 = v3;
        if (!*v3)
          goto LABEL_8;
      }
      v4 = (uint64_t *)v4[1];
    }
    while (v4);
    v5 = v3 + 1;
  }
  else
  {
    v5 = (uint64_t **)(a1 + 8);
  }
LABEL_8:
  std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v3, v5, v7);
  return v7;
}

char *std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::__construct_node<std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  void *v6;
  __int128 *v7;
  char *result;

  v5 = a1 + 8;
  v6 = operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = *(__int128 **)(a2 + 8);
  *((_QWORD *)v6 + 4) = *(_QWORD *)a2;
  *((_QWORD *)v6 + 6) = 0;
  *((_QWORD *)v6 + 7) = 0;
  *((_QWORD *)v6 + 5) = 0;
  result = std::vector<TSWPTopicNumberEntry>::__init_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>((char *)v6 + 40, v7, *(__int128 **)(a2 + 16), (uint64_t)(*(_QWORD *)(a2 + 16) - (_QWORD)v7) >> 4);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_217B00BEC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,void *>>>::operator()[abi:nn180100](v3, v2);
  _Unwind_Resume(a1);
}

char *std::vector<TSWPTopicNumberEntry>::__init_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  char *v6;
  _OWORD *v7;
  __int128 v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CGPoint>::__vallocate[abi:nn180100](result, a4);
    v7 = (_OWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2++;
      *v7++ = v8;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,void *>>>::operator()[abi:nn180100](uint64_t a1, _QWORD *__p)
{
  void *v3;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = (void *)__p[5];
    if (v3)
    {
      __p[6] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

BOOL std::__equal_to::operator()[abi:nn180100]<std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>>,std::pair<TSWPListStyle const* const,std::vector<TSWPTopicNumberEntry>>>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  char *v3;
  char *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL8 result;

  if (*a2 != *a3)
    return 0;
  v4 = (char *)a2[1];
  v3 = (char *)a2[2];
  v5 = (uint64_t *)a3[1];
  if (v3 - v4 != a3[2] - (_QWORD)v5)
    return 0;
  if (v4 == v3)
    return 1;
  do
  {
    v6 = *(_QWORD *)v4;
    v7 = *((_QWORD *)v4 + 1);
    v4 += 16;
    v8 = *v5;
    v9 = v5[1];
    v5 += 2;
    result = v6 == v8 && v7 == v9;
  }
  while (result && v4 != v3);
  return result;
}

_OWORD *std::vector<TSWPTopicNumberEntry>::__assign_with_size[abi:nn180100]<TSWPTopicNumberEntry*,TSWPTopicNumberEntry*>(_QWORD *a1, __int128 *a2, __int128 *a3, unint64_t a4)
{
  __int128 *v6;
  uint64_t v8;
  _OWORD *result;
  uint64_t v10;
  unint64_t v11;
  _OWORD **v12;
  _OWORD *v13;
  char *v14;
  __int128 v15;
  _OWORD *v16;
  _OWORD *v17;
  unint64_t v18;
  __int128 *v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  _OWORD *v23;
  __int128 v24;
  int64_t v25;
  _OWORD *v26;
  __int128 v27;

  v6 = a2;
  v8 = a1[2];
  result = (_OWORD *)*a1;
  if (a4 > (v8 - (uint64_t)result) >> 4)
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 60)
      abort();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    std::vector<CGPoint>::__vallocate[abi:nn180100](a1, v11);
    v13 = (_OWORD *)a1[1];
    v12 = (_OWORD **)(a1 + 1);
    result = v13;
    v14 = (char *)v13;
    if (v6 != a3)
    {
      v14 = (char *)result;
      do
      {
        v15 = *v6++;
        *(_OWORD *)v14 = v15;
        v14 += 16;
      }
      while (v6 != a3);
    }
LABEL_26:
    v25 = v14 - (char *)result;
    goto LABEL_27;
  }
  v17 = (_OWORD *)a1[1];
  v12 = (_OWORD **)(a1 + 1);
  v16 = v17;
  v18 = v17 - result;
  if (v18 >= a4)
  {
    v14 = (char *)result;
    if (a2 != a3)
    {
      v26 = result;
      do
      {
        v27 = *v6++;
        *v26++ = v27;
        v14 += 16;
      }
      while (v6 != a3);
    }
    goto LABEL_26;
  }
  v19 = &a2[v18];
  if (v16 != result)
  {
    v20 = 16 * v18;
    do
    {
      v21 = *v6++;
      *result++ = v21;
      v20 -= 16;
    }
    while (v20);
    result = *v12;
  }
  v22 = (char *)result;
  if (v19 != a3)
  {
    v22 = (char *)result;
    v23 = result;
    do
    {
      v24 = *v19++;
      *v23++ = v24;
      v22 += 16;
    }
    while (v19 != a3);
  }
  v25 = v22 - (char *)result;
LABEL_27:
  *v12 = (_OWORD *)((char *)result + v25);
  return result;
}

uint64_t *std::__tree<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::__map_value_compare<TSWPListStyle const*,std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>,std::less<TSWPListStyle const*>,true>,std::allocator<std::__value_type<TSWPListStyle const*,std::vector<TSWPTopicNumberEntry>>>>::__emplace_unique_key_args<TSWPListStyle const*,std::piecewise_construct_t const&,std::tuple<TSWPListStyle const* const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t **v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t v12;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = v6[4];
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = (uint64_t *)operator new(0x40uLL);
    v12 = **a4;
    v11[6] = 0;
    v11[7] = 0;
    v11[4] = v12;
    v11[5] = 0;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void sub_217B010A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a9);
  _Unwind_Resume(a1);
}

void sub_217B01608(_Unwind_Exception *a1, uint64_t a2, TSWPTopicNumberHints *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  TSWPTopicNumberHints::~TSWPTopicNumberHints((TSWPTopicNumberHints *)&a11);
  _Unwind_Resume(a1);
}

void sub_217B01758(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x219A153B8](v1, 0x10E1C405C8FB0CCLL);
  _Unwind_Resume(a1);
}

void sub_217B02648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  MEMORY[0x219A153B8](a25, 0x10E1C405C8FB0CCLL);
  _Unwind_Resume(a1);
}

uint64_t TSWPAttributeEnumerator::TSWPAttributeEnumerator(uint64_t a1, void *a2, NSUInteger a3, NSUInteger a4, uint64_t a5)
{
  _NSRange v11;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = objc_msgSend(a2, "length");
  *(_QWORD *)(a1 + 24) = objc_msgSend(a2, "attributeArrayForKind:", a5);
  *(_BYTE *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0x7FFFFFFFFFFFFFFFLL;
  v11.location = a3;
  v11.length = a4;
  TSWPAttributeEnumerator::resetRange((TSWPAttributeEnumerator *)a1, v11);
  return a1;
}

{
  _NSRange v11;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = objc_msgSend(a2, "length");
  *(_QWORD *)(a1 + 24) = objc_msgSend(a2, "attributeArrayForKind:", a5);
  *(_BYTE *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0x7FFFFFFFFFFFFFFFLL;
  v11.location = a3;
  v11.length = a4;
  TSWPAttributeEnumerator::resetRange((TSWPAttributeEnumerator *)a1, v11);
  return a1;
}

TSWPAttributeArray *TSWPAttributeEnumerator::resetRange(TSWPAttributeEnumerator *this, _NSRange a2)
{
  TSWPAttributeArray *result;
  BOOL v4;

  *((_QWORD *)this + 2) = a2.location + a2.length;
  result = (TSWPAttributeArray *)*((_QWORD *)this + 3);
  if (result)
  {
    result = (TSWPAttributeArray *)TSWPAttributeArray::effectiveAttributeIndexForCharIndex(result, a2.location);
    *((_QWORD *)this + 5) = result;
    v4 = *((_QWORD *)this + 3) != 0;
  }
  else
  {
    v4 = 0;
  }
  *((_BYTE *)this + 32) = v4;
  return result;
}

uint64_t TSWPAttributeEnumerator::nextAttributeIndex(id *this, _NSRange *a2)
{
  void *v4;
  uint64_t v5;
  TSWPAttributeArray *v6;
  unint64_t v7;
  uint64_t v8;
  NSUInteger v9;
  unint64_t v10;
  TSWPAttributeArray *v11;
  unint64_t v12;
  uint64_t v13;
  id v14;
  NSUInteger v15;

  if ((id)objc_msgSend(*this, "length") != this[1])
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPAttributeRecord *TSWPAttributeEnumerator::nextAttributeIndex(NSRange *)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPAttributeEnumerator.mm"), 56, CFSTR("Storage was modified while enumerating attributes"));
  }
  if (*((_BYTE *)this + 32))
  {
    v6 = (TSWPAttributeArray *)this[3];
    v7 = (unint64_t)this[5];
    v8 = (uint64_t)v6->var4 + 16 * v7;
    v9 = TSWPAttributeArray::charIndexForAttributeIndex(v6, v7);
    v10 = (unint64_t)this[5] + 1;
    this[5] = (id)v10;
    v11 = (TSWPAttributeArray *)this[3];
    if (v10 >= v11->var2)
    {
      *((_BYTE *)this + 32) = 0;
      v13 = objc_msgSend(*this, "length");
      if (!a2)
        return v8;
      goto LABEL_16;
    }
    v12 = TSWPAttributeArray::charIndexForAttributeIndex(v11, v10);
    v13 = v12;
    v14 = this[2];
    if (v12 < (unint64_t)v14 || (id)v12 == v14 && v12 == objc_msgSend(*this, "length"))
    {
      *((_BYTE *)this + 32) = 1;
      if (!a2)
        return v8;
      goto LABEL_16;
    }
    *((_BYTE *)this + 32) = 0;
    if (a2)
    {
LABEL_16:
      v15 = v13 - v9;
      goto LABEL_17;
    }
  }
  else
  {
    if (a2)
    {
      v9 = objc_msgSend(*this, "length");
      v15 = 0;
      v8 = 0;
LABEL_17:
      a2->location = v9;
      a2->length = v15;
      return v8;
    }
    return 0;
  }
  return v8;
}

uint64_t TSWPCharacterStylePropertyEnumerator::TSWPCharacterStylePropertyEnumerator(uint64_t a1, void *a2, NSUInteger a3, NSUInteger a4, int a5)
{
  TSWPAttributeEnumerator *v9;
  NSUInteger v10;
  NSUInteger v11;
  NSUInteger v12;
  _NSRange v14;
  _NSRange v15;

  *(_DWORD *)a1 = a5;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = a2;
  v9 = (TSWPAttributeEnumerator *)(a1 + 24);
  *(_QWORD *)(a1 + 32) = objc_msgSend(a2, "length");
  *(_QWORD *)(a1 + 48) = objc_msgSend(a2, "attributeArrayForKind:", 0);
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0x7FFFFFFFFFFFFFFFLL;
  v14.location = a3;
  v14.length = a4;
  TSWPAttributeEnumerator::resetRange(v9, v14);
  *(_QWORD *)(a1 + 72) = TSWPAttributeEnumerator::nextAttributeIndex((id *)v9, (_NSRange *)(a1 + 80));
  v10 = TSUIntersectionRangeWithEdge();
  v12 = v11;
  *(_QWORD *)(a1 + 80) = v10;
  *(_QWORD *)(a1 + 88) = v11;
  *(_QWORD *)(a1 + 96) = a2;
  *(_QWORD *)(a1 + 104) = objc_msgSend(a2, "length");
  *(_QWORD *)(a1 + 120) = objc_msgSend(a2, "attributeArrayForKind:", 3);
  *(_BYTE *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0x7FFFFFFFFFFFFFFFLL;
  v15.location = v10;
  v15.length = v12;
  TSWPAttributeEnumerator::resetRange((TSWPAttributeEnumerator *)(a1 + 96), v15);
  *(_QWORD *)(a1 + 144) = TSWPAttributeEnumerator::nextAttributeIndex((id *)(a1 + 96), (_NSRange *)(a1 + 152));
  *(_QWORD *)(a1 + 168) = (id)TSWPCharacterStylePropertyEnumerator::pNextBoxedValue((TSWPCharacterStylePropertyEnumerator *)a1, (_NSRange *)(a1 + 176));
  return a1;
}

uint64_t TSWPCharacterStylePropertyEnumerator::pNextBoxedValue(TSWPCharacterStylePropertyEnumerator *this, _NSRange *a2)
{
  uint64_t v3;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  NSRange v9;
  NSUInteger location;
  NSUInteger length;
  uint64_t AttributeIndex;
  void *v13;
  NSUInteger v15;
  _NSRange v16;

  v3 = *((_QWORD *)this + 9);
  if (!v3)
  {
    length = 0;
    v7 = 0;
    location = 0x7FFFFFFFFFFFFFFFLL;
    goto LABEL_18;
  }
  v5 = *((_QWORD *)this + 18);
  if (!v5)
  {
    v13 = *(void **)(v3 + 8);
    if (!v13 || (v7 = objc_msgSend(v13, "boxedValueForProperty:", *(unsigned int *)this)) == 0)
      v7 = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
    location = *((_QWORD *)this + 10);
    length = *((_QWORD *)this + 11);
    goto LABEL_17;
  }
  v6 = *(void **)(v5 + 8);
  if (v6)
  {
    v7 = objc_msgSend(v6, "boxedValueForProperty:", *(unsigned int *)this);
    if (v7)
      goto LABEL_9;
    v3 = *((_QWORD *)this + 9);
  }
  v8 = *(void **)(v3 + 8);
  if (!v8 || (v7 = objc_msgSend(v8, "boxedValueForProperty:", *(unsigned int *)this)) == 0)
    v7 = objc_msgSend(MEMORY[0x24BDBCEF8], "null");
LABEL_9:
  v9 = NSIntersectionRange(*(NSRange *)((char *)this + 152), *((NSRange *)this + 5));
  location = v9.location;
  length = v9.length;
  AttributeIndex = TSWPAttributeEnumerator::nextAttributeIndex((id *)this + 12, (_NSRange *)((char *)this + 152));
  *((_QWORD *)this + 18) = AttributeIndex;
  if (!AttributeIndex)
  {
    v15 = *((_QWORD *)this + 10) - (v9.location + v9.length) + *((_QWORD *)this + 11);
    *((_QWORD *)this + 10) = v9.location + v9.length;
    *((_QWORD *)this + 11) = v15;
    if (v15)
      goto LABEL_18;
    goto LABEL_17;
  }
  if (!*((_QWORD *)this + 11))
  {
LABEL_17:
    *((_QWORD *)this + 9) = TSWPAttributeEnumerator::nextAttributeIndex((id *)this + 3, (_NSRange *)this + 5);
    v16 = NSIntersectionRange(*((NSRange *)this + 5), *(NSRange *)((char *)this + 8));
    *((NSRange *)this + 5) = v16;
    TSWPAttributeEnumerator::resetRange((TSWPCharacterStylePropertyEnumerator *)((char *)this + 96), v16);
    *((_QWORD *)this + 18) = TSWPAttributeEnumerator::nextAttributeIndex((id *)this + 12, (_NSRange *)((char *)this + 152));
  }
LABEL_18:
  a2->location = location;
  a2->length = length;
  return v7;
}

void TSWPCharacterStylePropertyEnumerator::~TSWPCharacterStylePropertyEnumerator(id *this)
{

}

{

}

id TSWPCharacterStylePropertyEnumerator::nextBoxedValue(NSRange *this, _NSRange *a2)
{
  void *length;
  id v5;
  NSUInteger location;
  NSUInteger i;
  id BoxedValue;
  NSRange v9;
  void *v10;
  id v11;
  NSRange v13;

  length = (void *)this[10].length;
  if (!length)
  {
    i = 0;
    v5 = 0;
    location = 0x7FFFFFFFFFFFFFFFLL;
    if (!a2)
      return v5;
    goto LABEL_12;
  }
  v5 = length;
  location = this[11].location;
  for (i = this[11].length; ; i = v9.length)
  {
    BoxedValue = (id)TSWPCharacterStylePropertyEnumerator::pNextBoxedValue((TSWPCharacterStylePropertyEnumerator *)this, this + 11);
    this[10].length = (NSUInteger)BoxedValue;
    if (!BoxedValue)
    {
      v10 = 0;
      goto LABEL_11;
    }
    if (BoxedValue != v5 && (objc_msgSend(BoxedValue, "isEqual:", v5) & 1) == 0)
      break;
    v13.location = location;
    v13.length = i;
    v9 = NSUnionRange(v13, this[11]);
    location = v9.location;
  }
  v10 = (void *)this[10].length;
LABEL_11:
  v11 = v10;
  if (a2)
  {
LABEL_12:
    a2->location = location;
    a2->length = i;
  }
  return v5;
}

void sub_217B02F34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_217B03C48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_217B04558(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217B04808(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217B04B18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_217B04FE8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217B05250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_217B05504(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_217B05604(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void TSWPParagraphEnumerator::TSWPParagraphEnumerator(TSWPParagraphEnumerator *this, const TSWPParagraphEnumerator *a2)
{
  *(_OWORD *)&this->var0 = *(_OWORD *)&a2->var0;
  *(_OWORD *)&this->var2 = *(_OWORD *)&a2->var2;
  *(_OWORD *)&this->var4 = *(_OWORD *)&a2->var4;
  this->var6 = 1;
}

{
  *(_OWORD *)&this->var0 = *(_OWORD *)&a2->var0;
  *(_OWORD *)&this->var2 = *(_OWORD *)&a2->var2;
  *(_OWORD *)&this->var4 = *(_OWORD *)&a2->var4;
  this->var6 = 1;
}

unint64_t TSWPParagraphEnumerator::firstValidParIndex(TSWPParagraphEnumerator *this)
{
  return this->var4;
}

_QWORD *TSWPParagraphEnumerator::operator--(_QWORD *result)
{
  uint64_t v1;

  v1 = result[4] - 1;
  result[4] = v1;
  result[5] = v1;
  result[2] = v1;
  return result;
}

_QWORD *TSWPParagraphEnumerator::operator++(_QWORD *result)
{
  uint64_t v1;

  v1 = result[5] + 1;
  result[4] = v1;
  result[5] = v1;
  result[2] = v1;
  return result;
}

BOOL TSWPParagraphEnumerator::operator==(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3] && a1[4] == a2[4] && a1[5] == a2[5];
}

BOOL TSWPParagraphEnumerator::operator!=(_QWORD *a1, _QWORD *a2)
{
  return !TSWPParagraphEnumerator::operator==(a1, a2);
}

__n128 TSWPParagraphEnumerator::previous@<Q0>(TSWPParagraphEnumerator *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  unint64_t var3;
  unint64_t var4;

  result = *(__n128 *)&this->var0;
  *(_OWORD *)a2 = *(_OWORD *)&this->var0;
  var3 = this->var3;
  var4 = this->var4;
  *(_BYTE *)(a2 + 48) = 1;
  *(_QWORD *)(a2 + 32) = --var4;
  *(_QWORD *)(a2 + 40) = var4;
  *(_QWORD *)(a2 + 16) = var4;
  *(_QWORD *)(a2 + 24) = var3;
  return result;
}

__n128 TSWPParagraphEnumerator::next@<Q0>(TSWPParagraphEnumerator *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  unint64_t var3;
  unint64_t var5;

  result = *(__n128 *)&this->var0;
  *(_OWORD *)a2 = *(_OWORD *)&this->var0;
  var3 = this->var3;
  var5 = this->var5;
  *(_BYTE *)(a2 + 48) = 1;
  *(_QWORD *)(a2 + 32) = ++var5;
  *(_QWORD *)(a2 + 40) = var5;
  *(_QWORD *)(a2 + 16) = var5;
  *(_QWORD *)(a2 + 24) = var3;
  return result;
}

uint64_t TSWPParagraphEnumerator::parTable(TSWPParagraphEnumerator *this)
{
  return objc_msgSend(this->var0, "attributeArrayForKind:", 0);
}

uint64_t TSWPParagraphEnumerator::listLabelParagraphStyleOverride(TSWPParagraphEnumerator *this)
{
  if (this->var2 < this->var3 && this->var1 && (objc_opt_respondsToSelector() & 1) != 0)
    return objc_msgSend(this->var1, "listLabelParagraphStyleOverrideAtParIndex:", this->var2);
  else
    return 0;
}

uint64_t TSWPParagraphEnumerator::paragraphString(TSWPParagraphEnumerator *this)
{
  NSUInteger v2;
  uint64_t v3;

  v2 = TSWPParagraphEnumerator::paragraphTextRange(this);
  return objc_msgSend(this->var0, "substringWithRange:", v2, v3);
}

uint64_t TSWPParagraphEnumerator::attachmentOrFootnoteAtCharIndex(TSWPParagraphEnumerator *this, uint64_t a2)
{
  NSUInteger v4;
  uint64_t v5;

  v4 = TSWPParagraphEnumerator::paragraphTextRange(this);
  if (v5)
    return objc_msgSend(this->var0, "attachmentOrFootnoteAtCharIndex:", v4 + a2);
  else
    return 0;
}

uint64_t TSWPParagraphEnumerator::paragraphListStart(TSWPParagraphEnumerator *this)
{
  return objc_msgSend(this->var0, "listStartAtCharIndex:", objc_msgSend(this->var0, "textRangeForParagraphAtIndex:", this->var2));
}

uint64_t TSWPParagraphEnumerator::paragraphListNumber(TSWPParagraphEnumerator *this, void *a2)
{
  if (this->var1 && (objc_opt_respondsToSelector() & 1) != 0)
    return objc_msgSend(this->var1, "listNumberAtParIndex:numberingData:", this->var2, a2);
  else
    return 0x7FFFFFFFFFFFFFFFLL;
}

void *TSWPParagraphEnumerator::paragraphHasListLabel(TSWPParagraphEnumerator *this)
{
  void *result;

  result = (void *)TSWPParagraphEnumerator::paragraphListStyle(this);
  if (result)
    return (void *)(objc_msgSend(result, "firstLabelType") != 0);
  return result;
}

BOOL TSWPParagraphEnumerator::isLastParagraph(TSWPParagraphEnumerator *this)
{
  return this->var5 + 1 >= this->var3;
}

void sub_217B0DF48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_217B0F0D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, TSWPParagraphEnumerator *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a25);
  _Unwind_Resume(a1);
}

void sub_217B11A78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__20(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__20(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_217B12424(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24)
{
  uint64_t v24;
  void *v26;

  if (__p)
    operator delete(__p);
  v26 = *(void **)(v24 - 120);
  if (v26)
  {
    *(_QWORD *)(v24 - 112) = v26;
    operator delete(v26);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<TSWPLFWritingDirectionRun>::push_back[abi:nn180100](void **a1, __int128 *a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  __int128 v18;
  __int128 v19;
  char *v20;
  char *v21;
  __int128 v22;
  __int128 v23;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= (unint64_t)v6)
  {
    v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - (_QWORD)*a1) >> 3);
    v12 = v11 + 1;
    if (v11 + 1 > 0x666666666666666)
      abort();
    v13 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (_BYTE *)*a1) >> 3);
    if (2 * v13 > v12)
      v12 = 2 * v13;
    if (v13 >= 0x333333333333333)
      v14 = 0x666666666666666;
    else
      v14 = v12;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<EQKit::StemStretch::Key,unsigned long>>>(v4, v14);
    else
      v15 = 0;
    v16 = &v15[40 * v11];
    v17 = &v15[40 * v14];
    v18 = *a2;
    v19 = a2[1];
    *((_QWORD *)v16 + 4) = *((_QWORD *)a2 + 4);
    *(_OWORD *)v16 = v18;
    *((_OWORD *)v16 + 1) = v19;
    v10 = v16 + 40;
    v21 = (char *)*a1;
    v20 = (char *)a1[1];
    if (v20 != *a1)
    {
      do
      {
        v22 = *(_OWORD *)(v20 - 40);
        v23 = *(_OWORD *)(v20 - 24);
        *((_QWORD *)v16 - 1) = *((_QWORD *)v20 - 1);
        *(_OWORD *)(v16 - 24) = v23;
        *(_OWORD *)(v16 - 40) = v22;
        v16 -= 40;
        v20 -= 40;
      }
      while (v20 != v21);
      v20 = (char *)*a1;
    }
    *a1 = v16;
    a1[1] = v10;
    a1[2] = v17;
    if (v20)
      operator delete(v20);
  }
  else
  {
    v8 = *a2;
    v9 = a2[1];
    *(_QWORD *)(v7 + 32) = *((_QWORD *)a2 + 4);
    *(_OWORD *)v7 = v8;
    *(_OWORD *)(v7 + 16) = v9;
    v10 = (char *)(v7 + 40);
  }
  a1[1] = v10;
}

void sub_217B12A10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_217B16290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a9);
  _Unwind_Resume(a1);
}

void sub_217B164D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double TSWPLineFragment::lowestBaselineInRange(TSWPLineFragment *this, _NSRange a2, TSWPColumn *a3)
{
  NSUInteger length;
  NSUInteger location;
  double v7;
  TSWPStorage *v8;
  NSUInteger v9;
  TSWPStorage *v10;
  double v11;
  double v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  double v16;
  void *v17;
  void *v18;
  int v19;
  int v20;
  const __CTFont *FontForStyle;
  CGFloat Size;
  const __CTFont *CopyWithAttributes;
  double Ascent;
  double Descent;
  void *v26;
  double v27;
  double v28;
  NSUInteger v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[3];

  length = a2.length;
  location = a2.location;
  v35[2] = *MEMORY[0x24BDAC8D0];
  v7 = *((double *)this + 4) + *((double *)this + 5);
  v8 = -[TSWPColumn storage](a3, "storage");
  v9 = location + length;
  if (location < v9)
  {
    v10 = v8;
    do
    {
      v11 = *((double *)this + 4);
      v12 = *((double *)this + 5);
      v13 = -[TSWPStorage characterStyleAtCharIndex:effectiveRange:](v10, "characterStyleAtCharIndex:effectiveRange:", location, &v33);
      if (!-[TSWPColumn styleProvider](a3, "styleProvider"))
      {
        v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSWPLineFragment::lowestBaselineInRange(NSRange, TSWPColumn *) const");
        objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 147, CFSTR("No style provider."));
      }
      v16 = v11 + v12;
      v17 = (void *)-[TSWPStyleProvider paragraphStyleAtParIndex:effectiveRange:](-[TSWPColumn styleProvider](a3, "styleProvider"), "paragraphStyleAtParIndex:effectiveRange:", -[TSWPStorage paragraphIndexAtCharIndex:](v10, "paragraphIndexAtCharIndex:", location), &v31);
      v35[0] = v13;
      v35[1] = v17;
      v18 = (void *)TSWPResolvePropertyForStyles((uint64_t)v35, 2uLL, 36, 0);
      if (v18)
      {
        v19 = objc_msgSend(v18, "intValue");
        if (v19)
        {
          v20 = v19;
          FontForStyle = TSWPFastCreateFontForStyle(v13, v17, -[TSWPColumn scaleTextPercent](a3, "scaleTextPercent"));
          Size = CTFontGetSize(FontForStyle);
          CopyWithAttributes = CTFontCreateCopyWithAttributes(FontForStyle, Size * 1.5, 0, 0);
          if (v20 == 2)
          {
            Descent = CTFontGetDescent(FontForStyle);
            v16 = v16 - (Descent + CTFontGetDescent(CopyWithAttributes));
          }
          else if (v20 == 1)
          {
            Ascent = CTFontGetAscent(FontForStyle);
            v16 = v16 + Ascent - CTFontGetAscent(CopyWithAttributes);
          }
          CFRelease(CopyWithAttributes);
          CFRelease(FontForStyle);
        }
      }
      v26 = (void *)TSWPResolvePropertyForStyles((uint64_t)v35, 2uLL, 33, 0);
      if (v26)
        objc_msgSend(v26, "doubleValue");
      else
        v27 = 0.0;
      v28 = v16 - v27;
      if (v28 > v7)
        v7 = v28;
      v29 = v34 + v33;
      if (v34 + v33 >= (unint64_t)(v32 + v31))
        v29 = v32 + v31;
      if (v34)
        location = v29;
      else
        location = v32 + v31;
    }
    while (location < v9);
  }
  return v7;
}

double TSWPLineFragment::baselineShiftFromRunAttributes(TSWPLineFragment *this, const __CFDictionary *a2)
{
  void *v3;
  double v4;
  double v5;
  void *v6;
  int v7;
  int v8;
  const __CTFont *v9;
  uint64_t v10;
  const __CTFont *v11;
  void *v12;
  const __CTLine *v13;
  const __CTRun *v14;
  void *v15;
  uint64_t v16;
  double Descent;
  double Ascent;

  v3 = (void *)-[TSWPLineFragment objectForKeyedSubscript:](this, "objectForKeyedSubscript:", CFSTR("TSWPBaselineShift"));
  if (v3)
  {
    objc_msgSend(v3, "doubleValue");
    v5 = v4;
  }
  else
  {
    v5 = 0.0;
  }
  v6 = (void *)-[TSWPLineFragment objectForKeyedSubscript:](this, "objectForKeyedSubscript:", CFSTR("TSWPSuperscript"));
  if (v6)
  {
    v7 = objc_msgSend(v6, "unsignedIntValue");
    if (v7)
    {
      v8 = v7;
      v9 = (const __CTFont *)-[TSWPLineFragment objectForKeyedSubscript:](this, "objectForKeyedSubscript:", CFSTR("TSWPUnadjustedFont"));
      v10 = *MEMORY[0x24BDC4C28];
      v11 = (const __CTFont *)-[TSWPLineFragment objectForKeyedSubscript:](this, "objectForKeyedSubscript:", *MEMORY[0x24BDC4C28]);
      v12 = (void *)-[TSWPLineFragment objectForKeyedSubscript:](this, "objectForKeyedSubscript:", kTSWPAttachmentMap);
      if (v12)
      {
        v13 = (const __CTLine *)objc_msgSend(v12, "lineRef");
        if (v13)
        {
          v14 = (const __CTRun *)-[__CFArray firstObject](CTLineGetGlyphRuns(v13), "firstObject");
          if (v14)
          {
            v11 = (const __CTFont *)-[__CFDictionary objectForKeyedSubscript:](CTRunGetAttributes(v14), "objectForKeyedSubscript:", v10);
          }
          else
          {
            v15 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v16 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "static CGFloat TSWPLineFragment::baselineShiftFromRunAttributes(const CFDictionaryRef)");
            objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 210, CFSTR("invalid nil value for '%s'"), "run");
          }
        }
      }
      if (v8 == 2)
      {
        Descent = CTFontGetDescent(v11);
        Ascent = CTFontGetDescent(v9);
        return v5 + Descent - Ascent;
      }
      if (v8 == 1)
      {
        Descent = CTFontGetAscent(v9);
        Ascent = CTFontGetAscent(v11);
        return v5 + Descent - Ascent;
      }
    }
  }
  return v5;
}

void TSWPLineFragment::rectsForVisualRange(TSWPLineFragment *this@<X0>, _NSRange a2@<0:X1, 8:X2>, unint64_t a3@<X3>, unint64_t a4@<X4>, char a5@<W5>, char a6@<W6>, int a7@<W7>, double **a8@<X8>, NSArray **a9)
{
  double y;
  CGFloat v10;
  CGFloat v11;
  CGFloat v12;
  NSUInteger length;
  NSUInteger location;
  void *v20;
  uint64_t v21;
  double v22;
  double v23;
  double v24;
  uint64_t v25;
  uint64_t v26;
  double v27;
  double TypographicBounds;
  CGFloat x;
  double v30;
  double height;
  double v32;
  double v33;
  CGFloat v34;
  _QWORD *CharIndexData;
  uint64_t v36;
  unint64_t v37;
  double *v38;
  CGFloat v39;
  CGFloat v40;
  double v41;
  double v42;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  int v46;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  unint64_t v55;
  int v57;
  double v58;
  double v59;
  double *v60;
  double *v61;
  double *v62;
  uint64_t v63;
  double *v64;
  double *v65;
  double *v66;
  __int128 v67;
  unint64_t v68;
  uint64_t v69;
  double width;
  double v71;
  CGFloat v73;
  char v74;
  double v75;
  CGFloat descent;
  CGFloat ascent;
  _QWORD v78[2];
  CGRect v79;
  CGRect v80;
  CGRect v81;
  CGRect v82;
  CGRect v83;
  CGRect v84;
  CGRect v85;

  length = a2.length;
  location = a2.location;
  v78[1] = *MEMORY[0x24BDAC8D0];
  if (a2.location < *(_QWORD *)this || a2.location + a2.length > *((_QWORD *)this + 1) + *(_QWORD *)this)
  {
    v74 = a6;
    v20 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v21 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGRectVector TSWPLineFragment::rectsForVisualRange(NSRange, NSUInteger, NSUInteger, BOOL, BOOL, BOOL, NSArray **) const");
    objc_msgSend(v20, "handleFailureInFunction:file:lineNumber:description:", v21, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 489, CFSTR("Bad range"));
    a6 = v74;
  }
  if ((a5 & 1) != 0)
    v22 = *((double *)this + 9);
  else
    v22 = *((double *)this + 14) + *((double *)this + 18) + *((double *)this + 16) + *((double *)this + 17);
  v23 = *((double *)this + 7);
  if ((a6 & 1) == 0)
  {
    v24 = *((double *)this + 14);
    v23 = v23 + v24;
    v22 = v22 - v24;
  }
  if (length)
  {
    width = *((double *)this + 8);
    v71 = *((double *)this + 6);
    v25 = *((_QWORD *)this + 24);
    if (*((_QWORD *)this + 25) != v25)
    {
      descent = 0.0;
      ascent = 0.0;
      if (a7)
      {
        if (*((_QWORD *)this + 29) != *((_QWORD *)this + 28))
        {
          CTLineGetTypographicBounds(*(CTLineRef *)v25, &ascent, &descent, 0);
          v26 = *((_QWORD *)this + 28);
          if (v26 != *((_QWORD *)this + 29))
          {
            v27 = *(double *)(v25 + 16) - ascent;
            do
            {
              TypographicBounds = CTLineGetTypographicBounds(*(CTLineRef *)v26, &ascent, &descent, 0);
              x = *(double *)(v26 + 8);
              height = ascent + descent;
              if (v26 == *((_QWORD *)this + 28))
              {
                y = *(double *)(v26 + 16) - ascent;
              }
              else
              {
                v79.origin.x = v12;
                v79.origin.y = y;
                v79.size.width = v11;
                v79.size.height = v10;
                v30 = *(double *)(v26 + 16) - ascent;
                v80 = CGRectUnion(v79, *(CGRect *)&x);
                x = v80.origin.x;
                y = v80.origin.y;
                TypographicBounds = v80.size.width;
                height = v80.size.height;
              }
              v26 += 48;
              v10 = height;
              v11 = TypographicBounds;
              v12 = x;
            }
            while (v26 != *((_QWORD *)this + 29));
            if (y < v27)
            {
              v32 = v27 - y - *((double *)this + 18);
              v23 = v23 - v32;
              v22 = v22 + v32;
            }
          }
        }
      }
      v33 = *(double *)(MEMORY[0x24BDBF070] + 8);
      v34 = *(double *)(MEMORY[0x24BDBF070] + 24);
      v73 = *(double *)(MEMORY[0x24BDBF070] + 16);
      v75 = *MEMORY[0x24BDBF070];
      CharIndexData = (_QWORD *)TSWPLineFragment::getCharIndexData(this);
      v36 = CharIndexData[1] - *CharIndexData;
      if (v36)
      {
        v37 = v36 >> 6;
        if (v37 <= 1)
          v37 = 1;
        v38 = (double *)(*CharIndexData + 40);
        v39 = v34;
        v40 = v73;
        v41 = v75;
        v42 = v33;
        do
        {
          v43 = *((_QWORD *)v38 - 5);
          v44 = *((_QWORD *)v38 - 4);
          v45 = a3 < v43 || a3 - v43 >= v44;
          v46 = !v45;
          if (v45 && (a4 < v43 || a4 - v43 >= v44))
            goto LABEL_44;
          v48 = *(v38 - 1);
          v49 = *v38 - v48;
          v50 = v48 + *((double *)this + 6);
          v51 = *(double *)(v25 + 8);
          v52 = *(double *)(v25 + 16);
          v53 = v50 + v51;
          v54 = v23 + v52;
          if (v46)
          {
            v73 = v49;
            v75 = v50 + v51;
            v33 = v23 + v52;
            v34 = v22;
          }
          v45 = a4 >= v43;
          v55 = a4 - v43;
          if (!v45 || v55 >= v44)
          {
LABEL_44:
            v53 = v41;
            v54 = v42;
            v49 = v40;
          }
          else
          {
            v39 = v22;
          }
          v38 += 8;
          v40 = v49;
          v42 = v54;
          v41 = v53;
          --v37;
        }
        while (v37);
      }
      else
      {
        v49 = v73;
        v53 = v75;
        v54 = v33;
        v39 = v34;
      }
      v57 = *((_DWORD *)this + 6);
      v81.size.width = v73;
      v81.origin.x = v75;
      v81.origin.y = v33;
      v81.size.height = v34;
      if (CGRectIsEmpty(v81))
      {
        v58 = width + -1.0;
        if ((v57 & 0x1000) == 0)
          v58 = -0.0;
        v73 = 1.0;
        v75 = v71 + v58;
        v33 = v23;
        v34 = v22;
      }
      v82.origin.x = v53;
      v82.origin.y = v54;
      v82.size.width = v49;
      v82.size.height = v39;
      if (CGRectIsEmpty(v82))
      {
        v59 = width + -1.0;
        if ((v57 & 0x1000) != 0)
          v59 = -0.0;
        v53 = v71 + v59;
        v49 = 1.0;
        v54 = v23;
        v39 = v22;
      }
      v83.size.width = v73;
      v83.origin.x = v75;
      v83.origin.y = v33;
      v83.size.height = v34;
      v85.origin.x = v53;
      v85.origin.y = v54;
      v85.size.width = v49;
      v85.size.height = v39;
      v84 = CGRectUnion(v83, v85);
      width = v84.size.width;
      v71 = v84.origin.x;
      v23 = v84.origin.y;
      v22 = v84.size.height;
    }
  }
  else
  {
    v71 = TSWPLineFragment::wpOffsetForCharIndex(this, location, 0, 1, 0);
    width = 0.0;
  }
  *a8 = 0;
  a8[1] = 0;
  a8[2] = 0;
  v60 = (double *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>((uint64_t)(a8 + 2), 1uLL);
  v61 = *a8;
  v62 = a8[1];
  v64 = &v60[4 * v63];
  *v60 = v71;
  v60[1] = v23;
  v60[2] = width;
  v60[3] = v22;
  v65 = v60 + 4;
  if (v62 != v61)
  {
    v66 = v60;
    do
    {
      v67 = *((_OWORD *)v62 - 1);
      v60 = v66 - 4;
      *((_OWORD *)v66 - 2) = *((_OWORD *)v62 - 2);
      *((_OWORD *)v66 - 1) = v67;
      v62 -= 4;
      v66 -= 4;
    }
    while (v62 != v61);
  }
  *a8 = v60;
  a8[1] = v65;
  a8[2] = v64;
  if (v61)
    operator delete(v61);
  a8[1] = v65;
  if (a9)
  {
    if (a3 <= a4)
      v68 = a4;
    else
      v68 = a3;
    if (a3 >= a4)
      v69 = a4;
    else
      v69 = a3;
    v78[0] = objc_msgSend(MEMORY[0x24BDD1968], "valueWithRange:", v69, v68 - v69, *(_QWORD *)&width);
    *a9 = (NSArray *)objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v78, 1);
  }
}

void sub_217B17004(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSWPLineFragment::GetFakeContext(TSWPLineFragment *this)
{
  if (TSWPLineFragment::GetFakeContext(void)::onceToken != -1)
    dispatch_once(&TSWPLineFragment::GetFakeContext(void)::onceToken, &__block_literal_global_67);
  return TSWPLineFragment::GetFakeContext(void)::sFakeContext;
}

CGContextRef ___ZN16TSWPLineFragment14GetFakeContextEv_block_invoke()
{
  CGColorSpace *v0;
  CGContextRef result;

  v0 = (CGColorSpace *)TSUDeviceRGBColorSpace();
  result = CGBitmapContextCreate(0, 1uLL, 1uLL, 8uLL, 4uLL, v0, 5u);
  TSWPLineFragment::GetFakeContext(void)::sFakeContext = (uint64_t)result;
  return result;
}

double TSWPLineFragment::glyphRectForLineRange(TSWPLineFragment *this, _NSRange a2, TSWPStorage *a3, int a4)
{
  double v5;
  CGFloat v6;
  CGFloat v7;
  CGFloat v8;
  double v9;
  CTLineRef *v10;
  char v11;
  NSUInteger v12;
  NSUInteger v13;
  void *v14;
  void *v15;
  uint64_t v16;
  NSUInteger v17;
  NSRange v18;
  uint64_t i;
  const __CTRun *v20;
  CFIndex GlyphCount;
  CFIndex j;
  NSUInteger v23;
  NSUInteger v24;
  BOOL v25;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  uint64_t v30;
  unint64_t v31;
  NSUInteger length;
  NSUInteger location;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const __CTRun *v37;
  CFIndex v38;
  char Status;
  double v40;
  const __CFDictionary *Attributes;
  const __CTFont *Value;
  CFIndex v43;
  double v44;
  void *v45;
  uint64_t v46;
  CFIndex *v47;
  unint64_t v48;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  double v53;
  double v54;
  uint64_t v55;
  double v56;
  double v57;
  CGFloat v58;
  CGFloat v59;
  CGFloat v60;
  void *v61;
  uint64_t v62;
  void *key;
  CGFloat cf;
  CTLineRef *v68;
  CFArrayRef GlyphRuns;
  CFArrayRef obj;
  id obja;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  double v76;
  CGFloat leading;
  CGFloat descent;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  CGAffineTransform v83;
  CGAffineTransform v84;
  CGAffineTransform v85;
  CGAffineTransform v86;
  CGAffineTransform v87;
  CGPoint r2;
  CGPoint v89;
  CFIndex *buffer;
  CFIndex *v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  _BYTE v96[128];
  _BYTE v97[128];
  uint64_t v98;
  NSRange v99;
  NSRange v100;
  CFRange v101;
  CFRange v102;
  CFRange v103;
  CFRange v104;
  CFRange v105;
  CFRange v106;
  CFRange v107;
  CFRange v108;
  NSRange v109;
  CFRange v110;
  CFRange v111;
  CGRect ImageBounds;
  CGRect v113;
  CGRect v114;
  CGRect v115;
  CGRect v116;
  CGRect v117;
  CGRect v118;
  CGRect v119;
  CGRect v120;
  CGRect v121;
  CGRect v122;
  CGRect v123;
  CGRect v124;
  CGRect v125;
  CGRect v126;
  CGRect v127;

  v98 = *MEMORY[0x24BDAC8D0];
  v5 = *MEMORY[0x24BDBF070];
  v6 = *(double *)(MEMORY[0x24BDBF070] + 8);
  v7 = *(double *)(MEMORY[0x24BDBF070] + 16);
  v8 = *(double *)(MEMORY[0x24BDBF070] + 24);
  v9 = *((double *)this + 4) + *((double *)this + 5);
  v76 = v9
      + TSWPLineFragment::baselineAdjustAtCharIndex((TSWPLineFragment *)a2.location, (void *)-[TSWPStorage storage](a3, "storage"), a3, 0, -[TSWPStorage scaleTextPercent](a3, "scaleTextPercent"));
  v10 = (CTLineRef *)*((_QWORD *)this + 31);
  v68 = (CTLineRef *)*((_QWORD *)this + 32);
  if (v10 == v68)
    goto LABEL_98;
  v11 = 0;
  do
  {
    v13 = (NSUInteger)v10[3];
    v12 = (NSUInteger)v10[4];
    v14 = (void *)*((_QWORD *)this + 23);
    if (!v14)
    {
      v15 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v16 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGRect TSWPLineFragment::glyphRectForLineRange(NSRange, TSWPColumn *, BOOL) const");
      objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 631, CFSTR("invalid nil value for '%s'"), "_textSource");
      v14 = (void *)*((_QWORD *)this + 23);
    }
    v109.location = objc_msgSend(v14, "charRangeMappedFromStorage:", a2.location, a2.length);
    v109.length = v17;
    v99.location = v13;
    v99.length = v12;
    v18 = NSIntersectionRange(v99, v109);
    if (v18.length)
    {
      obj = CTLineGetGlyphRuns(*v10);
      v94 = 0u;
      v95 = 0u;
      v92 = 0u;
      v93 = 0u;
      v74 = -[__CFArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v92, v97, 16);
      if (v74)
      {
        v72 = *(_QWORD *)v93;
        do
        {
          for (i = 0; i != v74; ++i)
          {
            if (*(_QWORD *)v93 != v72)
              objc_enumerationMutation(obj);
            v20 = *(const __CTRun **)(*((_QWORD *)&v92 + 1) + 8 * i);
            GlyphCount = CTRunGetGlyphCount(v20);
            std::vector<long>::vector(&buffer, GlyphCount);
            v101.location = 0;
            v101.length = GlyphCount;
            CTRunGetStringIndices(v20, v101, buffer);
            std::vector<unsigned short>::vector(&v89, GlyphCount);
            v102.location = 0;
            v102.length = GlyphCount;
            CTRunGetGlyphs(v20, v102, *(CGGlyph **)&v89.x);
            CTRunGetStringRange(v20);
            v103.location = 0;
            v103.length = 1;
            CTRunGetPositions(v20, v103, &r2);
            if (GlyphCount >= 1)
            {
              for (j = 0; j != GlyphCount; ++j)
              {
                v23 = buffer[j] + v13;
                v25 = v23 >= v18.location;
                v24 = v23 - v18.location;
                v25 = !v25 || v24 >= v18.length;
                if (!v25 && *(__int16 *)(*(_QWORD *)&v89.x + 2 * j) != -1)
                {
                  if (TSWPLineFragment::GetFakeContext(void)::onceToken != -1)
                    dispatch_once(&TSWPLineFragment::GetFakeContext(void)::onceToken, &__block_literal_global_67);
                  v110.location = j;
                  v110.length = 1;
                  ImageBounds = CTRunGetImageBounds(v20, (CGContextRef)TSWPLineFragment::GetFakeContext(void)::sFakeContext, v110);
                  x = ImageBounds.origin.x;
                  y = ImageBounds.origin.y;
                  width = ImageBounds.size.width;
                  height = ImageBounds.size.height;
                  memset(&v87, 0, sizeof(v87));
                  CGAffineTransformMakeTranslation(&v87, *((double *)this + 6) + *((double *)v10 + 1), v76 + *((double *)v10 + 2));
                  v85 = v87;
                  CGAffineTransformRotate(&v86, &v85, -1.57079633);
                  v87 = v86;
                  v84 = v86;
                  CGAffineTransformScale(&v86, &v84, 1.0, -1.0);
                  v87 = v86;
                  v83 = v86;
                  v113.origin.x = x;
                  v113.origin.y = y;
                  v113.size.width = width;
                  v113.size.height = height;
                  v114 = CGRectApplyAffineTransform(v113, &v83);
                  v124.origin.x = v114.origin.x;
                  v124.size.width = v114.size.width;
                  v124.size.height = v114.size.height;
                  v124.origin.y = v114.origin.y - r2.x;
                  v114.origin.x = v5;
                  v114.origin.y = v6;
                  v114.size.width = v7;
                  v114.size.height = v8;
                  v115 = CGRectUnion(v114, v124);
                  v5 = v115.origin.x;
                  v6 = v115.origin.y;
                  v7 = v115.size.width;
                  v8 = v115.size.height;
                }
              }
            }
            if (*(_QWORD *)&v89.x)
            {
              v89.y = v89.x;
              operator delete(*(void **)&v89.x);
            }
            if (buffer)
            {
              v91 = buffer;
              operator delete(buffer);
            }
          }
          v74 = -[__CFArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v92, v97, 16);
        }
        while (v74);
      }
      v11 = 1;
    }
    v10 += 6;
  }
  while (v10 != v68);
  if ((v11 & 1) == 0)
  {
LABEL_98:
    if (*((_QWORD *)this + 25) != *((_QWORD *)this + 24))
    {
      if (TSWPLineFragment::GetFakeContext(void)::onceToken != -1)
        dispatch_once(&TSWPLineFragment::GetFakeContext(void)::onceToken, &__block_literal_global_67);
      CGContextSetTextPosition((CGContextRef)TSWPLineFragment::GetFakeContext(void)::sFakeContext, 0.0, 0.0);
      v30 = *((_QWORD *)this + 25) - *((_QWORD *)this + 24);
      if (v30)
      {
        v31 = 0xAAAAAAAAAAAAAAABLL * (v30 >> 4);
        key = (void *)*MEMORY[0x24BDC4C28];
        location = a2.location;
        length = a2.length;
        do
        {
          --v31;
          v34 = *((_QWORD *)this + 24) + 48 * v31;
          v87.a = *(CGFloat *)v34;
          *(_OWORD *)&v87.b = *(_OWORD *)(v34 + 8);
          *(_OWORD *)&v87.d = *(_OWORD *)(v34 + 24);
          LODWORD(v87.ty) = *(_DWORD *)(v34 + 40);
          cf = v87.a;
          if (*(_QWORD *)&v87.a)
          {
            CFRetain(*(CFTypeRef *)&v87.a);
            location = a2.location;
            length = a2.length;
          }
          if (v31)
          {
            v100.location = location;
            v100.length = length;
            if (!NSIntersectionRange(v100, *(NSRange *)(&v87 + 24)).length)
              goto LABEL_89;
          }
          else if ((*((_BYTE *)this + 24) & 1) != 0)
          {
            v120.origin.x = v5;
            v120.origin.y = v6;
            v120.size.width = v7;
            v120.size.height = v8;
            v121 = CGRectUnion(v120, *(CGRect *)((char *)this + 48));
            v5 = v121.origin.x;
            v6 = v121.origin.y;
            v7 = v121.size.width;
            v8 = v121.size.height;
            goto LABEL_89;
          }
          v81 = 0u;
          v82 = 0u;
          v79 = 0u;
          v80 = 0u;
          GlyphRuns = CTLineGetGlyphRuns(*(CTLineRef *)&cf);
          v35 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v79, v96, 16);
          if (!v35)
            goto LABEL_89;
          v73 = *(_QWORD *)v80;
          do
          {
            v36 = 0;
            obja = (id)v35;
            do
            {
              if (*(_QWORD *)v80 != v73)
                objc_enumerationMutation(GlyphRuns);
              v75 = v36;
              v37 = *(const __CTRun **)(*((_QWORD *)&v79 + 1) + 8 * v36);
              v38 = CTRunGetGlyphCount(v37);
              if ((unint64_t)(v38 - 65537) <= 0xFFFFFFFFFFFEFFFFLL)
              {
                v61 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                v62 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGRect TSWPLineFragment::glyphRectForLineRange(NSRange, TSWPColumn *, BOOL) const");
                objc_msgSend(v61, "handleFailureInFunction:file:lineNumber:description:", v62, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 701, CFSTR("bad glyph count: %ld"), v38);
                goto LABEL_89;
              }
              std::vector<long>::vector(&v86, v38);
              v104.location = 0;
              v104.length = v38;
              CTRunGetStringIndices(v37, v104, *(CFIndex **)&v86.a);
              std::vector<unsigned short>::vector(&buffer, v38);
              v105.location = 0;
              v105.length = v38;
              CTRunGetGlyphs(v37, v105, (CGGlyph *)buffer);
              Status = CTRunGetStatus(v37);
              v106.location = 0;
              v106.length = 1;
              CTRunGetPositions(v37, v106, &v89);
              v40 = 0.0;
              if ((*((_BYTE *)this + 25) & 0x20) != 0)
              {
                if ((Status & 4) != 0)
                {
                  Attributes = CTRunGetAttributes(v37);
                  Value = (const __CTFont *)CFDictionaryGetValue(Attributes, key);
                  CTFontGetVerticalTranslationsForGlyphs(Value, (const CGGlyph *)buffer, (CGSize *)&r2, 1);
                  v89.x = r2.y - v89.y;
                }
                else
                {
                  r2.x = 0.0;
                  leading = 0.0;
                  descent = 0.0;
                  v107.location = 0;
                  v107.length = 0;
                  CTRunGetTypographicBounds(v37, v107, &r2.x, &descent, &leading);
                  v40 = (r2.x - descent) * 0.5;
                }
              }
              v43 = 0;
              v44 = v76 + v40;
              do
              {
                if (!*((_QWORD *)this + 23))
                {
                  v45 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                  v46 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGRect TSWPLineFragment::glyphRectForLineRange(NSRange, TSWPColumn *, BOOL) const");
                  objc_msgSend(v45, "handleFailureInFunction:file:lineNumber:description:", v46, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 738, CFSTR("invalid nil value for '%s'"), "_textSource");
                }
                if (v31)
                {
                  v47 = buffer;
LABEL_57:
                  if (*((__int16 *)v47 + v43) == -1)
                    goto LABEL_67;
                  if (TSWPLineFragment::GetFakeContext(void)::onceToken != -1)
                    dispatch_once(&TSWPLineFragment::GetFakeContext(void)::onceToken, &__block_literal_global_67);
                  v111.location = v43;
                  v111.length = 1;
                  v116 = CTRunGetImageBounds(v37, (CGContextRef)TSWPLineFragment::GetFakeContext(void)::sFakeContext, v111);
                  v125.size.width = v116.size.width;
                  v125.size.height = v116.size.height;
                  v125.origin.x = v116.origin.x + v89.x + *((double *)this + 6) + v87.b;
                  v125.origin.y = v44 - v116.origin.y - v116.size.height + v87.c;
                  v116.origin.x = v5;
                  v116.origin.y = v6;
                  v116.size.width = v7;
                  v116.size.height = v8;
                  v117 = CGRectUnion(v116, v125);
LABEL_61:
                  v5 = v117.origin.x;
                  v6 = v117.origin.y;
                  v7 = v117.size.width;
                  v8 = v117.size.height;
                  goto LABEL_67;
                }
                v48 = objc_msgSend(*((id *)this + 23), "charIndexMappedToStorage:", *(_QWORD *)(*(_QWORD *)&v86.a + 8 * v43));
                if (v48 >= location && v48 - location < length)
                {
                  v47 = buffer;
                  if ((*((_BYTE *)this + 24) & 4) == 0
                    || objc_msgSend(*((id *)this + 23), "characterAtIndex:", *(_QWORD *)(*(_QWORD *)&v86.a + 8 * v43)) != 65532)
                  {
                    goto LABEL_57;
                  }
                  v50 = (void *)objc_msgSend(*((id *)this + 23), "attachmentAtCharIndex:", *(_QWORD *)(*(_QWORD *)&v86.a + 8 * v43));
                  objc_opt_class();
                  if ((objc_opt_isKindOfClass() & 1) != 0)
                  {
                    v51 = *((_QWORD *)this + 46);
                    v52 = *((_QWORD *)this + 47);
                    if (v51 != v52)
                    {
                      while (*(_QWORD *)(v51 + 24) != *(_QWORD *)(*(_QWORD *)&v86.a + 8 * v43))
                      {
                        v51 += 32;
                        if (v51 == v52)
                          goto LABEL_67;
                      }
                      v53 = *(double *)(v51 + 8);
                      v54 = *(double *)(v51 + 16);
                      v55 = objc_msgSend(*(id *)v51, "size");
                      v127.origin.x = TSDRectWithOriginAndSize(v55, v53, v54, v56, v57);
                      v127.origin.y = v58;
                      v127.size.width = v59;
                      v127.size.height = v60;
                      v119.origin.x = v5;
                      v119.origin.y = v6;
                      v119.size.width = v7;
                      v119.size.height = v8;
                      v117 = CGRectUnion(v119, v127);
                      goto LABEL_61;
                    }
                  }
                  else if (objc_msgSend(v50, "isDrawable") && (objc_msgSend(v50, "isAnchored") & 1) == 0)
                  {
                    r2 = (CGPoint)*MEMORY[0x24BDBF148];
                    v108.location = v43;
                    v108.length = 1;
                    CTRunGetAdvances(v37, v108, (CGSize *)&r2);
                    v126.size.height = *((CGFloat *)this + 15);
                    v126.size.width = r2.x;
                    v126.origin.x = v89.x + *((double *)this + 6) + v87.b;
                    v126.origin.y = v44 - v126.size.height + v87.c;
                    v118.origin.x = v5;
                    v118.origin.y = v6;
                    v118.size.width = v7;
                    v118.size.height = v8;
                    v117 = CGRectUnion(v118, v126);
                    goto LABEL_61;
                  }
                }
LABEL_67:
                ++v43;
              }
              while (v43 != v38);
              if (buffer)
              {
                v91 = buffer;
                operator delete(buffer);
              }
              if (*(_QWORD *)&v86.a)
              {
                v86.b = v86.a;
                operator delete(*(void **)&v86.a);
              }
              v36 = v75 + 1;
            }
            while ((id)(v75 + 1) != obja);
            v35 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v79, v96, 16);
          }
          while (v35);
LABEL_89:
          if (cf != 0.0)
            CFRelease(*(CFTypeRef *)&cf);
        }
        while (v31);
      }
    }
  }
  if (a4)
  {
    v122.origin.x = v5;
    v122.origin.y = v6;
    v122.size.width = v7;
    v122.size.height = v8;
    if (!CGRectIsEmpty(v122))
    {
      v123.origin.x = v5;
      v123.origin.y = v6;
      v123.size.width = v7;
      v123.size.height = v8;
      *(_QWORD *)&v5 = (unint64_t)CGRectInset(v123, -1.0, -1.0);
    }
  }
  return v5;
}

void sub_217B17B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,const void *a57)
{
  TSWPLineRef::~TSWPLineRef(&a57);
  _Unwind_Resume(a1);
}

void TSWPLineRef::~TSWPLineRef(const void **this)
{
  const void *v1;

  v1 = *this;
  if (v1)
    CFRelease(v1);
}

double TSWPLineFragment::glyphRectForRubyField(TSWPLineFragment *this, uint64_t a2, _NSRange a3)
{
  double x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  uint64_t v7;
  uint64_t v8;
  CFArrayRef GlyphRuns;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t i;
  const __CTRun *v16;
  NSUInteger GlyphCount;
  unsigned int v18;
  NSRange v19;
  CFIndex v20;
  CFArrayRef obj;
  CGPoint buffer;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _BYTE v29[128];
  uint64_t v30;
  CFRange v31;
  NSRange v32;
  CFRange v33;
  CGRect ImageBounds;
  CGRect v35;
  CGRect v36;

  v30 = *MEMORY[0x24BDAC8D0];
  x = *MEMORY[0x24BDBF070];
  y = *(double *)(MEMORY[0x24BDBF070] + 8);
  width = *(double *)(MEMORY[0x24BDBF070] + 16);
  height = *(double *)(MEMORY[0x24BDBF070] + 24);
  v8 = *((_QWORD *)this + 28);
  v7 = *((_QWORD *)this + 29);
  if (v8 != v7)
  {
    while (*(_QWORD *)(v8 + 24) != a2)
    {
      v8 += 48;
      if (v8 == v7)
        return x;
    }
    GlyphRuns = CTLineGetGlyphRuns(*(CTLineRef *)v8);
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    v28 = 0u;
    obj = GlyphRuns;
    v11 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
    if (v11)
    {
      v12 = v11;
      v13 = 0;
      v14 = *(_QWORD *)v26;
      do
      {
        for (i = 0; i != v12; ++i)
        {
          if (*(_QWORD *)v26 != v14)
            objc_enumerationMutation(obj);
          v16 = *(const __CTRun **)(*((_QWORD *)&v25 + 1) + 8 * i);
          GlyphCount = CTRunGetGlyphCount(v16);
          v18 = v13;
          v32.location = v13;
          v32.length = GlyphCount;
          v19 = NSIntersectionRange(a3, v32);
          if (v19.length)
          {
            v20 = v19.location - v13;
            v31.location = v20;
            v31.length = 1;
            CTRunGetPositions(v16, v31, &buffer);
            if (TSWPLineFragment::GetFakeContext(void)::onceToken != -1)
              dispatch_once(&TSWPLineFragment::GetFakeContext(void)::onceToken, &__block_literal_global_67);
            v33.location = v20;
            v33.length = v19.length;
            ImageBounds = CTRunGetImageBounds(v16, (CGContextRef)TSWPLineFragment::GetFakeContext(void)::sFakeContext, v33);
            v36.size.width = ImageBounds.size.width;
            v36.size.height = ImageBounds.size.height;
            v36.origin.x = *((double *)this + 6) + ImageBounds.origin.x + *(double *)(v8 + 8) + buffer.x;
            v36.origin.y = *(double *)(v8 + 16)
                         + *((double *)this + 4)
                         + *((double *)this + 5)
                         - ImageBounds.origin.y
                         - ImageBounds.size.height;
            ImageBounds.origin.x = x;
            ImageBounds.origin.y = y;
            ImageBounds.size.width = width;
            ImageBounds.size.height = height;
            v35 = CGRectUnion(ImageBounds, v36);
            x = v35.origin.x;
            y = v35.origin.y;
            width = v35.size.width;
            height = v35.size.height;
          }
          v13 = GlyphCount + v18;
        }
        v12 = -[__CFArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
      }
      while (v12);
    }
  }
  return x;
}

void TSWPLineFragment::emphasisMarkRectForLineRange(TSWPLineFragment *this, _NSRange a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSUInteger length;
  NSUInteger location;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  double v16;
  double v17;
  unsigned int v18;
  NSUInteger v19;
  NSUInteger v20;
  BOOL v21;
  uint64_t v22;
  CGRect v23;

  v2 = *MEMORY[0x24BDBF070];
  v3 = *(_QWORD *)(MEMORY[0x24BDBF070] + 8);
  v4 = *(_QWORD *)(MEMORY[0x24BDBF070] + 16);
  v5 = *(_QWORD *)(MEMORY[0x24BDBF070] + 24);
  v6 = *((_QWORD *)this + 55);
  v7 = *((_QWORD *)this + 56);
  if (v7 != v6 && *((_QWORD *)this + 25) != *((_QWORD *)this + 24))
  {
    length = a2.length;
    location = a2.location;
    v11 = 0;
    v12 = 0;
    do
    {
      if (*(_DWORD *)(v6 + 200 * v11) == 4)
      {
        v13 = v6 + 200 * v11;
        v14 = *(_QWORD *)(v13 + 104);
        if (*(_QWORD *)(v13 + 112) != v14)
        {
          v15 = 0;
          v16 = *(double *)(v13 + 176);
          v17 = *(double *)(v13 + 184);
          v18 = 1;
          do
          {
            v19 = *(_QWORD *)(*(_QWORD *)(v6 + 200 * v11 + 32) + 8 * v15);
            v21 = v19 >= location;
            v20 = v19 - location;
            v21 = !v21 || v20 >= length;
            if (!v21)
            {
              v22 = v6 + 200 * v11;
              v23.size.height = *(CGFloat *)(v22 + 152);
              v23.size.width = *(CGFloat *)(v22 + 168);
              v23.origin.x = *(double *)(v14 + 16 * v15)
                           + v16
                           + *((double *)this + 6)
                           + *(double *)(*((_QWORD *)this + 24) + 8);
              v23.origin.y = v17 + *((double *)this + 4) + *((double *)this + 5) - v23.size.height;
              *(CGRect *)&v2 = CGRectUnion(*(CGRect *)&v2, v23);
              v6 = *((_QWORD *)this + 55);
            }
            v15 = v18;
            v14 = *(_QWORD *)(v6 + 200 * v11 + 104);
            ++v18;
          }
          while (v15 < (*(_QWORD *)(v6 + 200 * v11 + 112) - v14) >> 4);
          v7 = *((_QWORD *)this + 56);
        }
      }
      v11 = ++v12;
    }
    while (0x8F5C28F5C28F5C29 * ((v7 - v6) >> 3) > v12);
  }
}

BOOL TSWPLineFragment::requiresGlyphVectorsForHeightMeasurement(TSWPLineFragment *this)
{
  _BOOL8 result;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unsigned int v6;
  BOOL v7;

  if ((*((_BYTE *)this + 24) & 0x80) != 0 || *((_QWORD *)this + 29) != *((_QWORD *)this + 28))
    return 1;
  v2 = *((_QWORD *)this + 55);
  v3 = *((_QWORD *)this + 56) - v2;
  if (!v3)
    return 0;
  v4 = 0;
  v5 = 0x8F5C28F5C28F5C29 * (v3 >> 3);
  v6 = 1;
  do
  {
    v7 = *(_DWORD *)(v2 + 200 * v4) == 4;
    result = v7;
    v4 = v6++;
  }
  while (!v7 && v5 > v4);
  return result;
}

void TSWPLineFragment::labelRect(TSWPLineFragment *this)
{
  uint64_t v1;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  CGRect v8;
  CGRect v9;

  v1 = *((_QWORD *)this + 22);
  if (v1 && (*(_DWORD *)(v1 + 64) - 1) <= 2)
  {
    v3 = *(double *)v1;
    v4 = *(double *)(v1 + 8);
    v6 = -*(double *)(v1 + 56);
    v7 = *(double *)(v1 + 72);
    if (*(_BYTE *)(v1 + 80))
      v7 = *((double *)this + 8) - v7 - v3;
    v5 = *((double *)this + 14) + (*((double *)this + 16) + *((double *)this + 17) - v4) * 0.5;
    v8 = CGRectOffset(*(CGRect *)&v7, 0.0, *((CGFloat *)this + 18));
    v9 = CGRectOffset(v8, 0.0, v6);
    CGRectOffset(v9, *((CGFloat *)this + 6), *((CGFloat *)this + 7));
  }
}

double TSWPLineFragment::labelTextPosition(TSWPLineFragment *this)
{
  double v1;
  uint64_t v2;
  double v4;
  const __CTFont *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFString *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _OWORD v16[4];

  v1 = *MEMORY[0x24BDBEFB0];
  v2 = *((_QWORD *)this + 22);
  if (!v2)
    return v1;
  if ((*(_DWORD *)(v2 + 64) & 0xFFFFFFFE) != 2)
  {
    v6 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGPoint TSWPLineFragment::labelTextPosition() const");
    v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm");
    v9 = CFSTR("Text position only applies to text and numbers.");
    v10 = (void *)v6;
    v11 = v7;
    v12 = 992;
    goto LABEL_9;
  }
  TSWPLineFragment::labelRect(this);
  v1 = v4;
  if ((*((_BYTE *)this + 25) & 0x20) == 0)
  {
    v5 = (const __CTFont *)TSWPListLabel::labelFont((CTLineRef *)v2);
    if (v5)
    {
      if (*(_DWORD *)(v2 + 64) == 2)
      {
        memset(v16, 0, sizeof(v16));
        TSWPFontHeightInfoForFont(v5, v16);
      }
      return v1;
    }
    if (!CTLineGetGlyphCount(*(CTLineRef *)(v2 + 16)))
      return v1;
    v13 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGPoint TSWPLineFragment::labelTextPosition() const");
    v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm");
    v9 = CFSTR("No label font but we need to render something");
    v10 = (void *)v13;
    v11 = v14;
    v12 = 968;
LABEL_9:
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, v8, v12, v9);
    return v1;
  }
  if (*(_BYTE *)(v2 + 81))
  {
    *(_QWORD *)&v16[0] = 0;
    CTLineGetTypographicBounds(*(CTLineRef *)(v2 + 16), (CGFloat *)v16, 0, 0);
    return v1 + *(double *)v16;
  }
  return v1;
}

uint64_t TSWPLineFragment::leftMostCharIndex(TSWPLineFragment *this)
{
  TSWPLineFragment **CharIndexData;
  TSWPLineFragment *v3;

  CharIndexData = (TSWPLineFragment **)TSWPLineFragment::getCharIndexData(this);
  v3 = *CharIndexData;
  if (*CharIndexData == CharIndexData[1])
    v3 = this;
  return *(_QWORD *)v3;
}

uint64_t TSWPLineFragment::rightMostCharIndex(TSWPLineFragment *this)
{
  _QWORD *CharIndexData;
  uint64_t v3;
  TSWPLineFragment *v4;

  CharIndexData = (_QWORD *)TSWPLineFragment::getCharIndexData(this);
  v3 = CharIndexData[1];
  if (*CharIndexData == v3)
    v4 = this;
  else
    v4 = (TSWPLineFragment *)(v3 - 64);
  return *(_QWORD *)v4;
}

double TSWPLineFragment::wpOffsetForCharIndexForVisualSelection(TSWPLineFragment *this, unint64_t a2, int a3)
{
  int v4;
  CTLineRef *v5;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  double v14;
  uint64_t *CharIndexData;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  double *v19;
  unint64_t v20;
  unint64_t v21;
  BOOL v22;
  double *v23;
  double v24;
  double v25;
  double v26;
  int v27;
  double v28;
  double v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  double v35;
  uint64_t v36;
  unsigned int v37;
  int v38;
  double v39;

  v4 = *((_DWORD *)this + 6);
  v5 = (CTLineRef *)*((_QWORD *)this + 24);
  if (*((CTLineRef **)this + 25) != v5 && CTLineGetGlyphCount(*v5))
  {
    if (*((_QWORD *)this + 1) + *(_QWORD *)this <= a2)
    {
      v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSWPLineFragment::wpOffsetForCharIndexForVisualSelection(TSWPCharIndex, BOOL) const");
      objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1206, CFSTR("Bad char index"));
    }
    v11 = *((_QWORD *)this + 24);
    v10 = *((_QWORD *)this + 25);
    if (v10 == v11)
    {
      v12 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v13 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSWPLineFragment::wpOffsetForCharIndexForVisualSelection(TSWPCharIndex, BOOL) const");
      objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1207, CFSTR("Expected Line Refs"));
      v11 = *((_QWORD *)this + 24);
      v10 = *((_QWORD *)this + 25);
    }
    v14 = 0.0;
    if (v10 == v11)
      goto LABEL_51;
    CharIndexData = (uint64_t *)TSWPLineFragment::getCharIndexData(this);
    v16 = *CharIndexData;
    v17 = CharIndexData[1];
    if (*CharIndexData == v17)
    {
      if ((a3 & 1) != 0)
      {
        v14 = *(double *)(v11 + 8);
      }
      else
      {
        v36 = objc_msgSend(*((id *)this + 23), "characterAtIndex:", objc_msgSend(*((id *)this + 23), "charIndexMappedFromStorage:", a2));
        v37 = v36;
        v38 = IsParagraphBreakingCharacter(v36);
        if (v37 == 8232 || v38)
        {
          if (v37 > 0xC || ((1 << v37) & 0x1030) == 0)
          {
            v39 = 7.0;
            if ((v4 & 0x1000) != 0)
              v39 = -7.0;
            v14 = v39 + *(double *)(v11 + 8);
            goto LABEL_51;
          }
LABEL_46:
          if ((v4 & 0x1000) == 0)
            v14 = *((double *)this + 8);
        }
      }
    }
    else
    {
      v18 = (v17 - v16) >> 6;
      if (v18 <= 1)
        v18 = 1;
      v19 = (double *)(v16 + 32);
      while (1)
      {
        v20 = *((_QWORD *)v19 - 4);
        v22 = a2 >= v20;
        v21 = a2 - v20;
        v22 = !v22 || v21 >= *((_QWORD *)v19 - 3);
        if (!v22)
          break;
        v19 += 8;
        if (!--v18)
          goto LABEL_51;
      }
      v25 = *v19;
      v24 = v19[1];
      v26 = v24 - *v19;
      v27 = a3 ^ ((unsigned __int16)(v4 & 0x1000) >> 12);
      if (v27)
        v28 = v26;
      else
        v28 = -v26;
      if (v27)
        v24 = v25;
      v29 = v24 + *(double *)(v11 + 8);
      if ((a3 & 1) == 0)
      {
        v30 = objc_msgSend(*((id *)this + 23), "characterAtIndex:", objc_msgSend(*((id *)this + 23), "charIndexMappedFromStorage:", a2));
        v31 = v30;
        v32 = IsParagraphBreakingCharacter(v30);
        if (v31 == 8232 || v32 != 0)
        {
          if (v31 > 0xC || ((1 << v31) & 0x1030) == 0)
          {
            v35 = 7.0;
            if ((v4 & 0x1000) != 0)
              v35 = -7.0;
            v14 = v29 + v35 + v28;
            goto LABEL_51;
          }
          goto LABEL_46;
        }
      }
      v14 = v29;
    }
LABEL_51:
    v23 = (double *)((char *)this + 48);
    return v14 + *v23;
  }
  v14 = *((double *)this + 6);
  if ((v4 & 0x1000) != 0)
  {
    v23 = (double *)((char *)this + 64);
    return v14 + *v23;
  }
  return v14;
}

double TSWPLineFragment::wpOffsetForGlyphIndex(TSWPLineFragment *this, unint64_t a2, int a3)
{
  int v4;
  CTLineRef *v5;
  CTLineRef *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  CFArrayRef GlyphRuns;
  uint64_t v14;
  uint64_t v15;
  CFIndex v16;
  uint64_t v17;
  uint64_t v18;
  CFIndex v19;
  const __CTRun *v20;
  CFIndex GlyphCount;
  CFIndex v22;
  double *v23;
  void *v24;
  uint64_t v25;
  CFIndex v26;
  double TypographicBounds;
  uint64_t v28;
  unsigned int v29;
  int v30;
  double v31;
  int v33;
  __int16 v34;
  CFIndex v35;
  CGPoint buffer;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _BYTE v41[128];
  uint64_t v42;
  CFRange v43;
  CFRange v44;
  CFRange v45;

  v42 = *MEMORY[0x24BDAC8D0];
  v4 = *((_DWORD *)this + 6);
  v5 = (CTLineRef *)*((_QWORD *)this + 24);
  if (*((CTLineRef **)this + 25) != v5 && CTLineGetGlyphCount(*v5))
  {
    v8 = (CTLineRef *)*((_QWORD *)this + 24);
    if (*((CTLineRef **)this + 25) == v8 || CTLineGetGlyphCount(*v8) <= a2)
    {
      v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSWPLineFragment::wpOffsetForGlyphIndex(NSUInteger, BOOL) const");
      objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1308, CFSTR("Bad glyph index"));
    }
    v11 = *((_QWORD *)this + 24);
    v12 = 0.0;
    if (*((_QWORD *)this + 25) != v11)
    {
      v39 = 0u;
      v40 = 0u;
      v37 = 0u;
      v38 = 0u;
      GlyphRuns = CTLineGetGlyphRuns(*(CTLineRef *)v11);
      v14 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v37, v41, 16);
      if (v14)
      {
        v15 = v14;
        v33 = a3;
        v34 = v4;
        v16 = 0;
        v17 = *(_QWORD *)v38;
        while (2)
        {
          v18 = 0;
          v19 = v16;
          do
          {
            if (*(_QWORD *)v38 != v17)
              objc_enumerationMutation(GlyphRuns);
            v20 = *(const __CTRun **)(*((_QWORD *)&v37 + 1) + 8 * v18);
            GlyphCount = CTRunGetGlyphCount(v20);
            v22 = GlyphCount;
            if ((unint64_t)(GlyphCount - 65537) <= 0xFFFFFFFFFFFEFFFFLL)
            {
              v24 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
              v25 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSWPLineFragment::wpOffsetForGlyphIndex(NSUInteger, BOOL) const");
              objc_msgSend(v24, "handleFailureInFunction:file:lineNumber:description:", v25, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1321, CFSTR("bad glyph count: %ld"), v22);
              goto LABEL_33;
            }
            v16 = GlyphCount + v19;
            if (GlyphCount + v19 > a2)
            {
              v26 = a2 - v19;
              v43.location = v26;
              v43.length = 1;
              TypographicBounds = CTRunGetTypographicBounds(v20, v43, 0, 0, 0);
              v44.location = v26;
              v44.length = 1;
              CTRunGetPositions(v20, v44, &buffer);
              if (v33 == (unsigned __int16)(v34 & 0x1000) >> 12)
              {
                v12 = TypographicBounds + buffer.x + *(double *)(v11 + 8);
                TypographicBounds = -TypographicBounds;
              }
              else
              {
                v12 = buffer.x + *(double *)(v11 + 8);
              }
              if ((v33 & 1) == 0)
              {
                v35 = 0;
                v45.location = v26;
                v45.length = 1;
                CTRunGetStringIndices(v20, v45, &v35);
                v28 = objc_msgSend(*((id *)this + 23), "characterAtIndex:", v35);
                v29 = v28;
                v30 = IsParagraphBreakingCharacter(v28);
                if (v29 == 8232 || v30)
                {
                  if (v29 <= 0xC && ((1 << v29) & 0x1030) != 0)
                  {
                    v12 = 0.0;
                    if ((v34 & 0x1000) == 0)
                      v12 = *((double *)this + 8);
                  }
                  else
                  {
                    v31 = 7.0;
                    if ((v34 & 0x1000) != 0)
                      v31 = -7.0;
                    v12 = v12 + v31 + TypographicBounds;
                  }
                }
              }
              goto LABEL_33;
            }
            ++v18;
            v19 += GlyphCount;
          }
          while (v15 != v18);
          v15 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v37, v41, 16);
          if (v15)
            continue;
          break;
        }
      }
    }
LABEL_33:
    v23 = (double *)((char *)this + 48);
    return v12 + *v23;
  }
  v12 = *((double *)this + 6);
  if ((v4 & 0x1000) != 0)
  {
    v23 = (double *)((char *)this + 64);
    return v12 + *v23;
  }
  return v12;
}

double TSWPLineFragment::wpOffsetForCharIndex(TSWPLineFragment *this, unint64_t a2, int a3)
{
  double v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  CTLineRef *v11;
  CFArrayRef GlyphRuns;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t i;
  const __CTRun *v17;
  CFIndex GlyphCount;
  CFIndex v19;
  int v20;
  int v21;
  int v22;
  unint64_t v23;
  BOOL v24;
  BOOL v25;
  _BOOL4 v26;
  int v27;
  int v28;
  int v29;
  int v30;
  void *v31;
  uint64_t v32;
  CFIndex *buffer[3];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  double v39;
  _BYTE v40[128];
  uint64_t v41;
  CFRange v42;

  v41 = *MEMORY[0x24BDAC8D0];
  v39 = 0.0;
  v6 = TSWPLineFragment::wpOffsetForCharIndex(this, a2, 0, 0, &v39);
  v7 = (void *)*((_QWORD *)this + 23);
  if (!v7)
  {
    if ((*((_BYTE *)this + 24) & 1) != 0)
    {
      v7 = 0;
    }
    else
    {
      v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSWPLineFragment::wpOffsetForCharIndex(TSWPCharIndex, BOOL) const");
      objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1383, CFSTR("Unexpected nil _textSource"));
      v7 = (void *)*((_QWORD *)this + 23);
    }
  }
  v10 = objc_msgSend(v7, "charIndexMappedFromStorage:", a2);
  v11 = (CTLineRef *)*((_QWORD *)this + 24);
  if (*((CTLineRef **)this + 25) != v11)
  {
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    GlyphRuns = CTLineGetGlyphRuns(*v11);
    v13 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v35, v40, 16);
    if (v13)
    {
      v14 = v10 - ((v10 != 0) & ~a3);
      v15 = *(_QWORD *)v36;
      while (2)
      {
        for (i = 0; i != v13; ++i)
        {
          if (*(_QWORD *)v36 != v15)
            objc_enumerationMutation(GlyphRuns);
          v17 = *(const __CTRun **)(*((_QWORD *)&v35 + 1) + 8 * i);
          GlyphCount = CTRunGetGlyphCount(v17);
          if ((unint64_t)(GlyphCount - 65537) < 0xFFFFFFFFFFFF0000)
          {
            v31 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
            v32 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CGFloat TSWPLineFragment::wpOffsetForCharIndex(TSWPCharIndex, BOOL) const");
            objc_msgSend(v31, "handleFailureInFunction:file:lineNumber:description:", v32, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1403, CFSTR("bad glyph count: %ld"), GlyphCount);
            return v6;
          }
          std::vector<long>::vector(buffer, GlyphCount);
          v42.location = 0;
          v42.length = GlyphCount;
          CTRunGetStringIndices(v17, v42, buffer[0]);
          v19 = 0;
          v20 = 0;
          v21 = 0;
          v22 = 0;
          do
          {
            v23 = buffer[0][v19];
            v24 = v23 == v14;
            v25 = v23 > v14;
            v26 = v23 == v14;
            v27 = !v25;
            v28 = v25;
            v29 = v28 | v21;
            v30 = v27 | v20;
            v22 |= v26;
            if (!v24)
            {
              v21 = v29;
              v20 = v30;
            }
            ++v19;
          }
          while (v19 < GlyphCount && (v22 & (v21 | v20) & 1) == 0);
          if (((v22 | v21 & v20) & 1) != 0
            && ((CTRunGetStatus(v17) & 1) == 0) == (*((_BYTE *)this + 25) & 0x10) >> 4)
          {
            v6 = v39;
          }
          if (buffer[0])
          {
            buffer[1] = buffer[0];
            operator delete(buffer[0]);
          }
        }
        v13 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v35, v40, 16);
        if (v13)
          continue;
        break;
      }
    }
  }
  return v6;
}

void sub_217B18C34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

const void *TSWPLineFragment::fontAtCharIndex(TSWPLineFragment *this, unint64_t a2, BOOL *a3)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  CFArrayRef GlyphRuns;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  const __CTRun *v18;
  CFRange StringRange;
  const void *v21;
  const __CFDictionary *Attributes;
  const void *Value;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _BYTE v29[128];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v7 = *((_QWORD *)this + 24);
  v6 = *((_QWORD *)this + 25);
  if (v6 == v7)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CTFontRef TSWPLineFragment::fontAtCharIndex(TSWPCharIndex, BOOL &) const");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1442, CFSTR("No line refs"));
    v7 = *((_QWORD *)this + 24);
    v6 = *((_QWORD *)this + 25);
  }
  if (v6 == v7)
    return 0;
  v10 = *(_QWORD *)this;
  if (*(_QWORD *)this <= a2)
    v10 = a2;
  v11 = *((_QWORD *)this + 1) + *(_QWORD *)this >= v10 ? v10 : *((_QWORD *)this + 1) + *(_QWORD *)this;
  v12 = objc_msgSend(*((id *)this + 23), "charIndexMappedFromStorage:", v11);
  *a3 = 0;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  GlyphRuns = CTLineGetGlyphRuns(**((CTLineRef **)this + 24));
  v14 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
  if (!v14)
    return 0;
  v15 = v14;
  v16 = *(_QWORD *)v26;
  while (2)
  {
    for (i = 0; i != v15; ++i)
    {
      if (*(_QWORD *)v26 != v16)
        objc_enumerationMutation(GlyphRuns);
      v18 = *(const __CTRun **)(*((_QWORD *)&v25 + 1) + 8 * i);
      StringRange = CTRunGetStringRange(v18);
      if (v12 >= StringRange.location && v12 - StringRange.location < StringRange.length)
      {
        Attributes = CTRunGetAttributes(v18);
        Value = CFDictionaryGetValue(Attributes, CFSTR("TSWPUnadjustedFont"));
        v21 = Value;
        if (!Value)
          v21 = CFDictionaryGetValue(Attributes, (const void *)*MEMORY[0x24BDC4C28]);
        *a3 = (CTRunGetStatus(v18) & 4) != 0;
        return v21;
      }
    }
    v15 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
    v21 = 0;
    if (v15)
      continue;
    break;
  }
  return v21;
}

void TSWPLineFragment::wpOffsetForInsertionPoint(TSWPLineFragment *this, unint64_t a2, BOOL a3, int a4, char a5)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *CharIndexData;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  int v19;
  double v20;
  double v21;
  BOOL v22;

  v22 = a3;
  v7 = TSWPLineFragment::glyphIndexForInsertionPoint(this, a2, &v22, a4);
  v8 = *((_QWORD *)this + 24);
  if (*((_QWORD *)this + 25) == v8)
  {
    v16 = 0.0;
    if ((a5 & 1) != 0)
      return;
    goto LABEL_9;
  }
  v9 = v7;
  CharIndexData = (uint64_t *)TSWPLineFragment::getCharIndexData(this);
  v12 = *CharIndexData;
  v11 = CharIndexData[1];
  if (v11 == *CharIndexData)
  {
    v18 = *(double *)(v8 + 8);
    v19 = *((_DWORD *)this + 6);
    if ((v19 & 0x800) != 0)
    {
      v20 = -7.0;
      if ((v19 & 0x1000) == 0)
        v20 = 7.0;
      v21 = v18 + v20;
      if (!v22)
        v18 = v21;
    }
  }
  else
  {
    v13 = (v11 - *CharIndexData) >> 6;
    if (v9 < v13 && *(_BYTE *)(v12 + (v9 << 6) + 48) != v22)
      ++v9;
    if (v9 == v13)
    {
      v14 = *(double *)(v8 + 8);
      v15 = *(double *)(v11 - 24);
    }
    else
    {
      v14 = *(double *)(v12 + (v9 << 6) + 32);
      v15 = *(double *)(v8 + 8);
    }
    v18 = v14 + v15;
  }
  v16 = v18 + *((double *)this + 6);
  if ((a5 & 1) == 0)
  {
LABEL_9:
    v17 = fmin(v16, CGRectGetMaxX(*(CGRect *)((char *)this + 48)) + -1.0);
    fmax(v17, CGRectGetMinX(*(CGRect *)((char *)this + 48)));
  }
}

uint64_t TSWPLineFragment::glyphIndexForInsertionPoint(TSWPLineFragment *this, unint64_t a2, BOOL *a3, int a4)
{
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BOOL4 v15;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t CharIndexData;
  uint64_t *v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  int v28;
  uint64_t *v29;
  void *v31;
  uint64_t v32;

  if (objc_msgSend(*((id *)this + 23), "length"))
  {
    v8 = *((_DWORD *)this + 6) & 0x1000;
    v9 = objc_msgSend(*((id *)this + 23), "charIndexRemappedFromStorage:", *(_QWORD *)this);
    v10 = v9;
    v11 = 0;
    v12 = *((_QWORD *)this + 1);
    if ((a4 & 1) == 0 && v9 < a2)
    {
      v13 = TSWPPreviousCharFromTextSource(a2, *((void **)this + 23));
      v11 = TSWPLineFragment::writingDirectionForCharIndex(this, v13) != 0;
    }
    v14 = v12 + v10;
    v15 = *a3;
    if (v12 + v10 == a2 && v15)
    {
      if (!a4)
      {
        v25 = TSWPPreviousCharFromTextSource(a2, *((void **)this + 23));
        v28 = TSWPLineFragment::writingDirectionForCharIndex(this, v25);
        if (v28 != v8 >> 12 && v28 == v11)
        {
          v26 = 0;
LABEL_38:
          *a3 = v26;
          a2 = v25;
          return TSWPLineFragment::visualIndexForCharIndex(this, a2);
        }
      }
LABEL_22:
      CharIndexData = TSWPLineFragment::getCharIndexData(this);
      v21 = *(uint64_t **)CharIndexData;
      v22 = *(uint64_t **)(CharIndexData + 8);
      if (!v8)
        goto LABEL_23;
      goto LABEL_28;
    }
    if (v10 > a2 && !v15)
    {
      v27 = TSWPLineFragment::getCharIndexData(this);
      v21 = *(uint64_t **)v27;
      v22 = *(uint64_t **)(v27 + 8);
      if (v8)
      {
        if (v21 == v22)
          v29 = (uint64_t *)this;
        else
          v29 = v22 - 8;
        v25 = *v29;
        v26 = TSWPLineFragment::writingDirectionForCharIndex(this, *v29) != 0;
        goto LABEL_38;
      }
      goto LABEL_28;
    }
    if ((a4 & 1) == 0)
    {
      v18 = TSWPLineFragment::writingDirectionForCharIndex(this, a2);
      v19 = v18;
      if (v10 == a2 && *a3)
      {
        if (v18 != v8 >> 12 && v18 != v11)
        {
          v20 = TSWPLineFragment::getCharIndexData(this);
          v21 = *(uint64_t **)v20;
          v22 = *(uint64_t **)(v20 + 8);
          if (v8)
          {
LABEL_23:
            if (v21 == v22)
              v24 = (uint64_t *)this;
            else
              v24 = v22 - 8;
            v25 = *v24;
            v26 = TSWPLineFragment::writingDirectionForCharIndex(this, *v24);
            goto LABEL_38;
          }
LABEL_28:
          if (v21 == v22)
            v21 = (uint64_t *)this;
          v25 = *v21;
          v26 = TSWPLineFragment::writingDirectionForCharIndex(this, *v21) == 0;
          goto LABEL_38;
        }
      }
      else if (v14 - 1 != a2 || *a3)
      {
        v31 = (void *)*((_QWORD *)this + 23);
        if (*a3)
          v32 = TSWPPreviousCharFromTextSource(a2, v31);
        else
          v32 = TSWPNextCharFromTextSource(a2, v31);
        v25 = v32;
        if (v19 != TSWPLineFragment::writingDirectionForCharIndex(this, v32) && v19 != v11)
        {
          v26 = !*a3;
          goto LABEL_38;
        }
      }
      else if (v18 != v8 >> 12 && v18 != v11)
      {
        goto LABEL_22;
      }
    }
  }
  return TSWPLineFragment::visualIndexForCharIndex(this, a2);
}

uint64_t TSWPLineFragment::writingDirectionForCharIndex(TSWPLineFragment *this, uint64_t a2)
{
  unsigned int v2;
  uint64_t v5;
  uint64_t result;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  CTLineRef *v12;
  CTLineRef *v13;
  void *v14;
  uint64_t v15;
  CFArrayRef GlyphRuns;
  uint64_t v17;
  uint64_t v18;
  uint64_t i;
  const __CTRun *v20;
  CFRange StringRange;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v2 = *((_DWORD *)this + 6);
  if ((v2 & 1) != 0)
    return 0;
  v5 = *((_QWORD *)this + 1) + *(_QWORD *)this;
  if (v5 == a2 || (v2 & 0x800) != 0 && v5 - 1 == a2)
    return (v2 >> 12) & 1;
  v7 = (void *)*((_QWORD *)this + 23);
  if (!v7)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPWritingDirection TSWPLineFragment::writingDirectionForCharIndex(TSWPCharIndex) const");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2462, CFSTR("invalid nil value for '%s'"), "_textSource");
    v7 = (void *)*((_QWORD *)this + 23);
  }
  v10 = objc_msgSend(v7, "charIndexMappedFromStorage:", a2);
  v11 = v10;
  v12 = (CTLineRef *)*((_QWORD *)this + 24);
  v13 = (CTLineRef *)*((_QWORD *)this + 25);
  if (v13 == v12 && v10 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPWritingDirection TSWPLineFragment::writingDirectionForCharIndex(TSWPCharIndex) const");
    objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2466, CFSTR("bad character index: %d"), a2);
    return 0;
  }
  result = 0;
  if (v13 != v12 && v11 != 0x7FFFFFFFFFFFFFFFLL)
  {
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    GlyphRuns = CTLineGetGlyphRuns(*v12);
    result = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
    if (result)
    {
      v17 = result;
      v18 = *(_QWORD *)v24;
      do
      {
        for (i = 0; i != v17; ++i)
        {
          if (*(_QWORD *)v24 != v18)
            objc_enumerationMutation(GlyphRuns);
          v20 = *(const __CTRun **)(*((_QWORD *)&v23 + 1) + 8 * i);
          StringRange = CTRunGetStringRange(v20);
          if (v11 >= StringRange.location && v11 - StringRange.location < StringRange.length)
            return CTRunGetStatus(v20) & 1;
        }
        v17 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
        result = 0;
      }
      while (v17);
    }
  }
  return result;
}

uint64_t TSWPLineFragment::visualIndexForCharIndex(TSWPLineFragment *this, unint64_t a2)
{
  uint64_t *CharIndexData;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t *i;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;

  CharIndexData = (uint64_t *)TSWPLineFragment::getCharIndexData(this);
  v5 = CharIndexData;
  if ((*((_BYTE *)this + 25) & 0x10) != 0)
  {
    result = 0;
    v6 = *v5;
    v7 = v5[1];
  }
  else
  {
    v6 = *CharIndexData;
    v7 = CharIndexData[1];
    if (*CharIndexData == v7)
      return 0;
    result = ((v7 - v6) >> 6) - 1;
  }
  v9 = v7 - v6;
  if (v9)
  {
    v10 = 0;
    v11 = v9 >> 6;
    if (v11 <= 1)
      v11 = 1;
    for (i = (unint64_t *)(v6 + 8); ; i += 8)
    {
      v13 = *(i - 1);
      v15 = a2 >= v13;
      v14 = a2 - v13;
      v15 = !v15 || v14 >= *i;
      if (!v15)
        break;
      if (v11 == ++v10)
        return result;
    }
    return v10;
  }
  return result;
}

unint64_t TSWPLineFragment::charIndexForWPOffsetWithDirection(TSWPLineFragment *this, int a2, int a3, double a4)
{
  uint64_t v6;
  double v7;
  double v8;
  double v9;
  unint64_t v11;
  double **CharIndexData;
  double *v13;
  uint64_t v14;
  double v15;
  double v16;
  double v17;
  BOOL v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  double *v23;
  double v24;
  double v25;
  BOOL v27;
  _BOOL4 v28;
  BOOL v30;
  void *v32;
  uint64_t v33;

  v6 = *((_QWORD *)this + 24);
  if (*((_QWORD *)this + 25) == v6)
    goto LABEL_42;
  v7 = *((double *)this + 6);
  v8 = a4 - v7;
  v9 = v8 - *(double *)(v6 + 8);
  if (v9 <= *((double *)this + 10) - v7 + 1.0)
  {
    v11 = *(_QWORD *)this;
    if ((*((_BYTE *)this + 25) & 0x10) != 0)
      v11 = v11 + *((_QWORD *)this + 1) - 1;
    goto LABEL_43;
  }
  if (v9 >= 0.0)
  {
    if (v8 >= *((double *)this + 27) && (a3 & 1) != 0)
      goto LABEL_42;
  }
  else if ((a3 & 1) != 0)
  {
    v11 = 0x7FFFFFFFFFFFFFFFLL;
    goto LABEL_47;
  }
  CharIndexData = (double **)TSWPLineFragment::getCharIndexData(this);
  v13 = *CharIndexData;
  v14 = (char *)CharIndexData[1] - (char *)*CharIndexData;
  if (v14)
  {
    v15 = v13[4];
    v16 = v13[5];
    v17 = v15 + (v16 - v15) * 0.5;
    v18 = v9 > v17;
    if (a2 || (v9 <= v17 ? (v19 = v9 < v15) : (v19 = 1), v19))
    {
      v21 = 0;
      v22 = v14 >> 6;
      v23 = v13 + 13;
      v24 = 0.0;
      while (1)
      {
        v20 = v21;
        v25 = v17;
        if (!a2 && v9 >= v17 && v9 <= v16)
          break;
        v27 = a2 != 1 || v18 || v9 < v24;
        v28 = v9 > v15 || a2 != 1;
        if (!v27)
          break;
        if (!v28 || v21 + 1 >= v22)
          break;
        v15 = *(v23 - 1);
        v16 = *v23;
        v17 = v15 + (*v23 - v15) * 0.5;
        v18 = v9 > v17;
        v23 += 8;
        ++v21;
        v24 = v25;
        if (!a2)
        {
          v30 = v9 > v17 || v9 < v15;
          v24 = v25;
          if (!v30)
            break;
        }
      }
    }
    else
    {
      v20 = -1;
    }
    if (v9 < 0.0 && a3 == 0)
    {
      v20 = 0;
    }
    else if (v20 == -1)
    {
      goto LABEL_42;
    }
    v11 = *(_QWORD *)&v13[8 * v20];
    if ((*((_BYTE *)this + 25) & 0x40) != 0)
      v11 = *(_QWORD *)this + v11 - *((_QWORD *)this + 2);
    goto LABEL_43;
  }
LABEL_42:
  v11 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_43:
  if ((a3 & 1) == 0 && v11 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v11 = *(_QWORD *)this;
    if ((*((_BYTE *)this + 25) & 0x10) != 0)
      v11 += *((_QWORD *)this + 1);
  }
LABEL_47:
  if ((v11 != 0x7FFFFFFFFFFFFFFFLL || (a3 & 1) == 0)
    && (v11 < *(_QWORD *)this || v11 > *((_QWORD *)this + 1) + *(_QWORD *)this))
  {
    v32 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v33 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPCharIndex TSWPLineFragment::charIndexForWPOffsetWithDirection(CGFloat, TSWPWritingDirection, BOOL) const");
    objc_msgSend(v32, "handleFailureInFunction:file:lineNumber:description:", v33, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1763, CFSTR("TSWPLineFragment::charIndexForWPOffset: out-of-bounds result"));
  }
  return v11;
}

unint64_t TSWPLineFragment::charIndexForWPOffset(TSWPLineFragment *this, double a2, int a3, char a4, BOOL *a5, char a6)
{
  uint64_t v9;
  double v11;
  double v12;
  unint64_t v13;
  char v14;
  _BOOL4 v15;
  uint64_t v16;
  uint64_t *v17;
  void *v18;
  uint64_t v19;
  CFIndex StringIndexForPosition;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  BOOL v25;
  uint64_t *CharIndexData;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  double v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  CGPoint v35;

  v9 = *((_QWORD *)this + 24);
  if (*((_QWORD *)this + 25) != v9)
  {
    v11 = a2 - *((double *)this + 6);
    v12 = v11 - *(double *)(v9 + 8);
    if ((v12 < 0.0 || v11 >= *((double *)this + 27)) && (a4 & 1) != 0)
      goto LABEL_5;
    if (a3 && (a6 & 1) == 0)
    {
      v35.y = 0.0;
      v35.x = v11 - *(double *)(v9 + 8);
      StringIndexForPosition = CTLineGetStringIndexForPosition(*(CTLineRef *)v9, v35);
      if ((StringIndexForPosition & 0x8000000000000000) == 0)
      {
        v22 = StringIndexForPosition;
        v23 = objc_msgSend(*((id *)this + 23), "charRangeMappedFromStorage:", *(_QWORD *)this, *((_QWORD *)this + 1));
        v25 = v22 < v23 || v22 - v23 >= v24;
        if (!v25 || v23 + v24 == v22)
        {
          v13 = objc_msgSend(*((id *)this + 23), "charIndexMappedToStorage:", v22);
          goto LABEL_6;
        }
      }
LABEL_5:
      v13 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_6:
      v14 = 1;
      goto LABEL_7;
    }
    CharIndexData = (uint64_t *)TSWPLineFragment::getCharIndexData(this);
    v27 = *CharIndexData;
    v28 = CharIndexData[1] - *CharIndexData;
    if (!v28)
      goto LABEL_5;
    v29 = v28 >> 6;
    if (v29 <= 1)
      v29 = 1;
    v30 = *(double *)(v27 + 32);
    if (v30 <= v12)
    {
      v32 = 0;
      v33 = v29 - 1;
      v34 = v27 + 40;
      while (1)
      {
        v31 = v32;
        if ((v30 + *(double *)v34) * 0.5 > v12 && (a3 & 1) != 0)
        {
          v14 = *(_BYTE *)(v34 + 8);
          goto LABEL_53;
        }
        if (v33 == v32)
          break;
        v30 = *(double *)(v34 + 56);
        v34 += 64;
        ++v32;
        if (v30 > v12)
        {
          v14 = *(_BYTE *)(v34 - 56) ^ 1;
          if (!a3)
            v14 = 1;
          goto LABEL_47;
        }
      }
      v14 = *(_BYTE *)(v34 + 8) ^ 1;
      if (!a3)
        v14 = 1;
      v31 = v33;
    }
    else
    {
      v14 = 1;
      v31 = -1;
LABEL_47:
      if (v31 == -1)
      {
        v13 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_7;
      }
    }
LABEL_53:
    v13 = *(_QWORD *)(v27 + (v31 << 6));
    if ((*((_BYTE *)this + 25) & 0x40) != 0)
      v13 = *(_QWORD *)this + v13 - *((_QWORD *)this + 2);
LABEL_7:
    v15 = v14 != 0;
    if ((a4 & 1) != 0)
      goto LABEL_14;
    goto LABEL_10;
  }
  v13 = 0x7FFFFFFFFFFFFFFFLL;
  v15 = 1;
  if ((a4 & 1) != 0)
    goto LABEL_14;
LABEL_10:
  if (v13 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v16 = TSWPLineFragment::getCharIndexData(this);
    v17 = *(uint64_t **)v16;
    if (*(_QWORD *)v16 == *(_QWORD *)(v16 + 8))
      v17 = (uint64_t *)this;
    v13 = *v17;
    v15 = TSWPLineFragment::writingDirectionForCharIndex(this, *v17) == 0;
  }
LABEL_14:
  if ((v13 != 0x7FFFFFFFFFFFFFFFLL || (a4 & 1) == 0)
    && (v13 < *(_QWORD *)this || v13 > *((_QWORD *)this + 1) + *(_QWORD *)this))
  {
    v18 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v19 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPCharIndex TSWPLineFragment::charIndexForWPOffset(CGFloat, BOOL, BOOL, BOOL *, BOOL) const");
    objc_msgSend(v18, "handleFailureInFunction:file:lineNumber:description:", v19, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 1855, CFSTR("TSWPLineFragment::charIndexForWPOffset: out-of-bounds result: %lu {%lu, %lu}"), v13, *(_QWORD *)this, *((_QWORD *)this + 1));
  }
  if (a5)
  {
    *a5 = v15;
  }
  else if (v13 == 0x7FFFFFFFFFFFFFFFLL)
  {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    v13 += !v15;
  }
  return v13;
}

double TSWPLineFragment::getLocalRunOffsetForCharIndex(TSWPLineFragment *this, unint64_t a2, double *a3)
{
  CTLineRef *v3;
  double v4;
  CFArrayRef GlyphRuns;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  const __CTRun *v11;
  CFRange StringRange;
  CFIndex GlyphCount;
  CFIndex v15;
  CFIndex v16;
  CFIndex v17;
  CFIndex v18;
  CFIndex v19;
  double TypographicBounds;
  double x;
  double TrailingWhitespaceWidth;
  double v23;
  CGPoint v25;
  CFIndex *buffer[3];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _BYTE v31[128];
  uint64_t v32;
  CFRange v33;
  CFRange v34;
  CFRange v35;

  v32 = *MEMORY[0x24BDAC8D0];
  *a3 = 0.0;
  v3 = (CTLineRef *)*((_QWORD *)this + 24);
  v4 = 0.0;
  if (*((CTLineRef **)this + 25) != v3 && (*((_BYTE *)this + 25) & 0x40) == 0)
  {
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    GlyphRuns = CTLineGetGlyphRuns(*v3);
    v8 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
    if (v8)
    {
      v9 = *(_QWORD *)v28;
      while (2)
      {
        for (i = 0; i != v8; ++i)
        {
          if (*(_QWORD *)v28 != v9)
            objc_enumerationMutation(GlyphRuns);
          v11 = *(const __CTRun **)(*((_QWORD *)&v27 + 1) + 8 * i);
          StringRange = CTRunGetStringRange(v11);
          if (a2 >= StringRange.location && a2 - StringRange.location < StringRange.length)
          {
            GlyphCount = CTRunGetGlyphCount(v11);
            v15 = GlyphCount;
            if (GlyphCount >= 1)
            {
              std::vector<long>::vector(buffer, GlyphCount);
              v33.location = 0;
              v33.length = v15;
              CTRunGetStringIndices(v11, v33, buffer[0]);
              v16 = 0;
              do
              {
                v17 = v16 + 1;
                if (v16 >= v15)
                  break;
                v18 = buffer[0][v16++];
              }
              while (v18 != a2);
              v19 = v17 - 1;
              v34.location = v17 - 1;
              v34.length = 1;
              TypographicBounds = CTRunGetTypographicBounds(v11, v34, 0, 0, 0);
              v35.location = v19;
              v35.length = 1;
              CTRunGetPositions(v11, v35, &v25);
              x = v25.x;
              *a3 = v25.x;
              TrailingWhitespaceWidth = CTLineGetTrailingWhitespaceWidth(*v3);
              v23 = TypographicBounds + x;
              if (buffer[0])
              {
                buffer[1] = buffer[0];
                operator delete(buffer[0]);
              }
              return v23 - TrailingWhitespaceWidth;
            }
            return v4;
          }
        }
        v8 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
        if (v8)
          continue;
        break;
      }
    }
  }
  return v4;
}

void sub_217B19BDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t TSWPLineFragment::layoutOrderCharIndexForCaretCharIndex(TSWPLineFragment *this, uint64_t a2, TSWPStorage *a3)
{
  unint64_t v5;
  __n128 v6;
  unint64_t v7;
  uint64_t v8;
  __n128 v9;
  __int128 *v10;
  unsigned int v11;
  __int128 *v12;
  void *__p;
  char *v15;
  uint64_t v16;
  uint64_t (*v17)(__int128 *, __int128 *);

  v5 = *((_QWORD *)this + 1);
  __p = 0;
  v15 = 0;
  v16 = 0;
  std::vector<TSWPLFCharIndexData>::reserve(&__p, v5);
  TSWPLineFragment::fillCharIndicesAndOffsets((uint64_t)this, (uint64_t)&__p);
  v7 = 126 - 2 * __clz((v15 - (_BYTE *)__p) >> 6);
  v17 = (uint64_t (*)(__int128 *, __int128 *))compareByCaretPosition;
  if (v15 == __p)
    v8 = 0;
  else
    v8 = v7;
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*,false>((__int128 *)__p, (__int128 *)v15, &v17, v8, 1, v6);
  v10 = (__int128 *)__p;
  if (__p == v15)
  {
LABEL_8:
    if (!__p)
      return a2;
  }
  else
  {
    v11 = 0;
    v12 = (__int128 *)__p;
    while (*(_QWORD *)v12 != a2)
    {
      ++v11;
      v12 += 4;
      if (v12 == (__int128 *)v15)
        goto LABEL_8;
    }
    v17 = (uint64_t (*)(__int128 *, __int128 *))compareByGlyphPosition;
    std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*,false>((__int128 *)__p, (__int128 *)v15, &v17, 126 - 2 * __clz((v15 - (_BYTE *)__p) >> 6), 1, v9);
    v10 = (__int128 *)__p;
    a2 = *((_QWORD *)__p + 8 * (unint64_t)v11);
  }
  v15 = (char *)v10;
  operator delete(v10);
  return a2;
}

void sub_217B19D00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<TSWPLFCharIndexData>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 6)
  {
    if (a2 >> 58)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPLFCharIndexData>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFC0];
    v9 = &v6[64 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_OWORD *)v10 - 4);
        v14 = *((_OWORD *)v10 - 3);
        v15 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v15;
        *((_OWORD *)v12 - 4) = v13;
        *((_OWORD *)v12 - 3) = v14;
        v12 -= 64;
        v10 -= 64;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void TSWPLineFragment::fillCharIndicesAndOffsets(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t CharIndexData;
  int v7;
  double v8;
  unint64_t v9;
  _OWORD *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _OWORD *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  char *v25;
  char *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  void *__p;
  _BYTE *v35;
  uint64_t v36;

  if (*(_QWORD *)(a1 + 200) != *(_QWORD *)(a1 + 192) && (*(_BYTE *)(a1 + 25) & 0x40) == 0)
  {
    if (!*(_QWORD *)(a1 + 184))
    {
      v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPLineFragment::fillCharIndicesAndOffsets(std::vector<TSWPLFCharIndexData> &) const");
      objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2201, CFSTR("invalid nil value for '%s'"), "_textSource");
    }
    __p = 0;
    v35 = 0;
    v36 = 0;
    TSWPLineFragment::fillWritingDirectionRuns((uint64_t *)a1, &__p);
    CharIndexData = TSWPLineFragment::getCharIndexData((TSWPLineFragment *)a1);
    if (CharIndexData != a2)
      std::vector<TSWPLFCharIndexData>::__assign_with_size[abi:ne180100]<TSWPLFCharIndexData*,TSWPLFCharIndexData*>((char *)a2, *(char **)CharIndexData, *(_QWORD *)(CharIndexData + 8), (uint64_t)(*(_QWORD *)(CharIndexData + 8) - *(_QWORD *)CharIndexData) >> 6);
    v7 = *(_DWORD *)(a1 + 24);
    if ((v7 & 0x200000) != 0)
    {
      *(_QWORD *)&v30 = *(_QWORD *)(a1 + 8) + *(_QWORD *)a1;
      *((_QWORD *)&v30 + 1) = 1;
      v8 = *(double *)(a1 + 48);
      if ((v7 & 0x1000) != 0)
      {
        *(_QWORD *)&v31 = *(_QWORD *)(a1 + 48);
        *((double *)&v31 + 1) = v8;
        *(double *)&v32 = v8;
        *((double *)&v32 + 1) = v8;
        LOBYTE(v33) = 0;
        *((_QWORD *)&v33 + 1) = 0;
        std::vector<TSWPLFCharIndexData>::insert(a2, *(char **)a2, (char *)&v30);
      }
      else
      {
        *(double *)&v31 = v8 + *(double *)(a1 + 64);
        *((_QWORD *)&v31 + 1) = v31;
        *(_QWORD *)&v32 = v31;
        *((_QWORD *)&v32 + 1) = v31;
        LOBYTE(v33) = 1;
        *((_QWORD *)&v33 + 1) = 0xCCCCCCCCCCCCCCCDLL * ((v35 - (_BYTE *)__p) >> 3) - 1;
        v9 = *(_QWORD *)(a2 + 16);
        v10 = *(_OWORD **)(a2 + 8);
        if ((unint64_t)v10 >= v9)
        {
          v15 = ((uint64_t)v10 - *(_QWORD *)a2) >> 6;
          v16 = v15 + 1;
          if ((unint64_t)(v15 + 1) >> 58)
            std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
          v17 = v9 - *(_QWORD *)a2;
          if (v17 >> 5 > v16)
            v16 = v17 >> 5;
          if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFC0)
            v18 = 0x3FFFFFFFFFFFFFFLL;
          else
            v18 = v16;
          if (v18)
            v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPLFCharIndexData>>(a2 + 16, v18);
          else
            v19 = 0;
          v20 = &v19[64 * v15];
          v21 = &v19[64 * v18];
          v22 = v30;
          v23 = v31;
          v24 = v33;
          *((_OWORD *)v20 + 2) = v32;
          *((_OWORD *)v20 + 3) = v24;
          *(_OWORD *)v20 = v22;
          *((_OWORD *)v20 + 1) = v23;
          v14 = v20 + 64;
          v26 = *(char **)a2;
          v25 = *(char **)(a2 + 8);
          if (v25 != *(char **)a2)
          {
            do
            {
              v27 = *((_OWORD *)v25 - 4);
              v28 = *((_OWORD *)v25 - 3);
              v29 = *((_OWORD *)v25 - 1);
              *((_OWORD *)v20 - 2) = *((_OWORD *)v25 - 2);
              *((_OWORD *)v20 - 1) = v29;
              *((_OWORD *)v20 - 4) = v27;
              *((_OWORD *)v20 - 3) = v28;
              v20 -= 64;
              v25 -= 64;
            }
            while (v25 != v26);
            v25 = *(char **)a2;
          }
          *(_QWORD *)a2 = v20;
          *(_QWORD *)(a2 + 8) = v14;
          *(_QWORD *)(a2 + 16) = v21;
          if (v25)
            operator delete(v25);
        }
        else
        {
          v11 = v30;
          v12 = v31;
          v13 = v33;
          v10[2] = v32;
          v10[3] = v13;
          *v10 = v11;
          v10[1] = v12;
          v14 = v10 + 4;
        }
        *(_QWORD *)(a2 + 8) = v14;
      }
    }
    if (__p)
    {
      v35 = __p;
      operator delete(__p);
    }
  }
}

void sub_217B1A028(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL compareByCaretPosition(double *a1, double *a2)
{
  double v2;
  double v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  unint64_t v8;

  v2 = a1[2];
  v3 = a2[2];
  if (v2 != v3)
    return v2 < v3;
  v4 = *((_QWORD *)a1 + 7);
  v5 = *((_QWORD *)a2 + 7);
  v6 = v4 >= v5;
  if (v4 == v5)
  {
    if (*((_BYTE *)a1 + 48))
    {
      v7 = *(_QWORD *)a1;
      v8 = *(_QWORD *)a2;
    }
    else
    {
      v7 = *(_QWORD *)a2;
      v8 = *(_QWORD *)a1;
    }
    v6 = v7 >= v8;
  }
  return !v6;
}

uint64_t TSWPLineFragment::caretCharIndexForLayoutOrderCharIndex(TSWPLineFragment *this, uint64_t a2, TSWPStorage *a3)
{
  unint64_t v5;
  __n128 v6;
  __int128 *v7;
  unsigned int v8;
  __int128 *v9;
  void *__p;
  __int128 *v12;
  uint64_t v13;
  BOOL (*v14)(double *, double *);

  v5 = *((_QWORD *)this + 1);
  __p = 0;
  v12 = 0;
  v13 = 0;
  std::vector<TSWPLFCharIndexData>::reserve(&__p, v5);
  TSWPLineFragment::fillCharIndicesAndOffsets((uint64_t)this, (uint64_t)&__p);
  v7 = (__int128 *)__p;
  if (__p == v12)
  {
LABEL_5:
    if (!__p)
      return a2;
  }
  else
  {
    v8 = 0;
    v9 = (__int128 *)__p;
    while (*(_QWORD *)v9 != a2)
    {
      ++v8;
      v9 += 4;
      if (v9 == v12)
        goto LABEL_5;
    }
    v14 = compareByCaretPosition;
    std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*,false>((__int128 *)__p, v12, (uint64_t (**)(__int128 *, __int128 *))&v14, 126 - 2 * __clz(((char *)v12 - (_BYTE *)__p) >> 6), 1, v6);
    v7 = (__int128 *)__p;
    a2 = *((_QWORD *)__p + 8 * (unint64_t)v8);
  }
  v12 = v7;
  operator delete(v7);
  return a2;
}

void sub_217B1A160(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *std::vector<TSWPLFCharIndexData>::insert(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _OWORD *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  char *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  char *v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  void *__p;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v15 = *(char **)a1;
    v16 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 6) + 1;
    if (v16 >> 58)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v17 = __src - v15;
    v18 = (__src - v15) >> 6;
    v19 = v7 - (_QWORD)v15;
    if (v19 >> 5 > v16)
      v16 = v19 >> 5;
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFC0)
      v20 = 0x3FFFFFFFFFFFFFFLL;
    else
      v20 = v16;
    v41 = a1 + 16;
    if (v20)
      v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPLFCharIndexData>>(a1 + 16, v20);
    else
      v21 = 0;
    v28 = &v21[64 * v18];
    __p = v21;
    v38 = v28;
    v39 = v28;
    v40 = &v21[64 * v20];
    if (v18 == v20)
    {
      if (v17 < 1)
      {
        if (v15 == v4)
          v30 = 1;
        else
          v30 = v17 >> 5;
        v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPLFCharIndexData>>(v8, v30);
        v28 = &v31[64 * (v30 >> 2)];
        __p = v31;
        v38 = v28;
        v40 = &v31[64 * v32];
        if (v21)
          operator delete(v21);
      }
      else
      {
        v29 = v18 + 2;
        if (v18 >= -1)
          v29 = v18 + 1;
        v28 -= 64 * (v29 >> 1);
        v38 = v28;
      }
    }
    v33 = *((_OWORD *)v3 + 2);
    v34 = *((_OWORD *)v3 + 3);
    v35 = *((_OWORD *)v3 + 1);
    *(_OWORD *)v28 = *(_OWORD *)v3;
    *((_OWORD *)v28 + 1) = v35;
    *((_OWORD *)v28 + 2) = v33;
    *((_OWORD *)v28 + 3) = v34;
    v39 = v28 + 64;
    v4 = (char *)std::vector<TSWPLFCharIndexData>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v39 != v38)
      v39 += (v38 - v39 + 63) & 0xFFFFFFFFFFFFFFC0;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    v25 = *(_OWORD *)a3;
    v26 = *((_OWORD *)a3 + 1);
    v27 = *((_OWORD *)a3 + 3);
    *((_OWORD *)__src + 2) = *((_OWORD *)a3 + 2);
    *((_OWORD *)__src + 3) = v27;
    *(_OWORD *)__src = v25;
    *((_OWORD *)__src + 1) = v26;
    *(_QWORD *)(a1 + 8) = __src + 64;
  }
  else
  {
    v9 = __src + 64;
    v10 = v6 - 64;
    v11 = *(_OWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_OWORD *)v10;
      v13 = *((_OWORD *)v10 + 1);
      v14 = *((_OWORD *)v10 + 3);
      v11[2] = *((_OWORD *)v10 + 2);
      v11[3] = v14;
      *v11 = v12;
      v11[1] = v13;
      v11 += 4;
      v10 += 64;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-64 * ((v6 - v9) >> 6)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 64 * (unint64_t)(*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    v22 = *(_OWORD *)v3;
    v23 = *((_OWORD *)v3 + 1);
    v24 = *((_OWORD *)v3 + 3);
    *((_OWORD *)v4 + 2) = *((_OWORD *)v3 + 2);
    *((_OWORD *)v4 + 3) = v24;
    *(_OWORD *)v4 = v22;
    *((_OWORD *)v4 + 1) = v23;
  }
  return v4;
}

void sub_217B1A3B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unint64_t TSWPLineFragment::nextOrPreviousNonAnchoredDataIndexForDirection(uint64_t a1, unint64_t a2, _QWORD *a3, int a4, void *a5)
{
  uint64_t v5;
  unint64_t v7;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  unint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v19;

  v5 = 0x7FFFFFFFFFFFFFFFLL;
  if (a2 == 0x7FFFFFFFFFFFFFFFLL)
    return v5;
  v7 = a2;
  if (a3[1] == *a3)
    return v7;
  v10 = objc_msgSend(a5, "length");
  v11 = v10;
  if (a4 != 2)
  {
    if (a4 == 3)
    {
      v12 = (v7 << 6) - 64;
      do
      {
        v5 = v7;
        if (!v7)
          break;
        if (*(_QWORD *)(*a3 + v12) >= v11)
          break;
        v12 -= 64;
        --v7;
      }
      while ((objc_msgSend(a5, "anchoredDrawableAttachmentCharacterAtCharIndex:") & 1) != 0);
      return v5;
    }
    v16 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v17 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPCharIndex TSWPLineFragment::nextOrPreviousNonAnchoredDataIndexForDirection(TSWPCharIndex, vector<TSWPLFCharIndexData> &, TSWPTextLayoutDirection, TSWPStorage *) const");
    objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2530, CFSTR("This routine supports left and right only."));
    return v7;
  }
  if (v7 >= (uint64_t)(a3[1] - *a3) >> 6)
    goto LABEL_22;
  if (*(_QWORD *)(*a3 + (v7 << 6)) >= v10)
  {
    v13 = 0;
  }
  else
  {
    v13 = 0;
    v14 = (v7 << 6) + 64;
    do
    {
      if (!objc_msgSend(a5, "anchoredDrawableAttachmentCharacterAtCharIndex:"))
        break;
      if (++v7 >= (uint64_t)(a3[1] - *a3) >> 6)
        return v7;
      v15 = *(_QWORD *)(*a3 + v14);
      v14 += 64;
      v13 = 1;
    }
    while (v15 < v11);
  }
  v5 = v7;
  if ((v13 & 1) == 0)
  {
LABEL_22:
    v19 = (v7 << 6) + 64;
    do
    {
      v5 = v7++;
      if (v7 >= (uint64_t)(a3[1] - *a3) >> 6)
        break;
      if (*(_QWORD *)(*a3 + v19) >= v11)
        break;
      v19 += 64;
    }
    while ((objc_msgSend(a5, "anchoredDrawableAttachmentCharacterAtCharIndex:") & 1) != 0);
  }
  return v5;
}

uint64_t TSWPLineFragment::nextOrPreviousCharIndexForDirection(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  unint64_t v8;
  void *v9;
  uint64_t v10;
  _BYTE *v11;
  _BYTE *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unsigned int v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  BOOL v21;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _BYTE *v27;
  char *v28;
  void *v29;
  uint64_t v30;
  void *__p;
  _BYTE *v33;
  uint64_t v34;

  if ((*(_BYTE *)(a1 + 24) & 1) != 0)
    return 0x7FFFFFFFFFFFFFFFLL;
  v8 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(a1 + 184))
  {
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPCharIndex TSWPLineFragment::nextOrPreviousCharIndexForDirection(TSWPCharIndex, TSWPTextLayoutDirection, TSWPStorage *) const");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2547, CFSTR("invalid nil value for '%s'"), "_textSource");
  }
  __p = 0;
  v33 = 0;
  v34 = 0;
  std::vector<TSWPLFCharIndexData>::reserve(&__p, v8);
  TSWPLineFragment::fillCharIndicesAndOffsets(a1, (uint64_t)&__p);
  v12 = __p;
  v11 = v33;
  v13 = objc_msgSend(*(id *)(a1 + 184), "charIndexRemappedFromStorage:", a2);
  v14 = (v11 - v12) >> 6;
  if (v11 == v12)
  {
    v15 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    v15 = 0;
    v16 = 1;
    while (1)
    {
      v17 = (unint64_t *)((char *)__p + 64 * v15);
      v19 = *v17;
      v18 = v17[1];
      v21 = v13 >= v19;
      v20 = v13 - v19;
      v21 = !v21 || v20 >= v18;
      if (!v21)
        break;
      v15 = v16;
      if (v14 <= v16++)
      {
        if ((*(_BYTE *)(a1 + 25) & 0x10) != 0)
          v15 = 0;
        else
          v15 = v14 - 1;
        break;
      }
    }
  }
  v24 = TSWPLineFragment::nextOrPreviousNonAnchoredDataIndexForDirection(v13, v15, &__p, a3, a4);
  v25 = v24;
  if (v24 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (a3 == 3)
    {
      if (v24)
      {
        v27 = __p;
        v28 = (char *)__p + 64 * v25 - 64;
        goto LABEL_24;
      }
    }
    else if (a3 == 2)
    {
      v26 = v24 + 1;
      if (v24 + 1 < v14)
      {
        v27 = __p;
        v28 = (char *)__p + 64 * v26;
LABEL_24:
        v23 = *(_QWORD *)v28;
LABEL_27:
        v33 = v27;
        operator delete(v27);
        return v23;
      }
    }
    else
    {
      v29 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v30 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPCharIndex TSWPLineFragment::nextOrPreviousCharIndexForDirection(TSWPCharIndex, TSWPTextLayoutDirection, TSWPStorage *) const");
      objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2601, CFSTR("This routine supports left and right only."));
    }
  }
  v27 = __p;
  v23 = 0x7FFFFFFFFFFFFFFFLL;
  if (__p)
    goto LABEL_27;
  return v23;
}

void sub_217B1A7AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t TSWPLineFragment::countOfGlyphRuns(TSWPLineFragment *this)
{
  CTLineRef *v1;

  v1 = (CTLineRef *)*((_QWORD *)this + 24);
  if (*((CTLineRef **)this + 25) == v1)
    return 0;
  else
    return -[__CFArray count](CTLineGetGlyphRuns(*v1), "count");
}

CFIndex TSWPLineFragment::glyphCountForRunIndex(TSWPLineFragment *this, unsigned int a2)
{
  CTLineRef *v2;
  CFArrayRef GlyphRuns;

  v2 = (CTLineRef *)*((_QWORD *)this + 24);
  if (*((CTLineRef **)this + 25) == v2)
    return 0;
  GlyphRuns = CTLineGetGlyphRuns(*v2);
  if (-[__CFArray count](GlyphRuns, "count") <= (unint64_t)a2)
    return 0;
  else
    return CTRunGetGlyphCount((CTRunRef)-[__CFArray objectAtIndexedSubscript:](GlyphRuns, "objectAtIndexedSubscript:", a2));
}

BOOL TSWPLineFragment::isRunIndexLeftToRight(TSWPLineFragment *this, unsigned int a2)
{
  CTLineRef *v2;
  CFArrayRef GlyphRuns;

  v2 = (CTLineRef *)*((_QWORD *)this + 24);
  if (*((CTLineRef **)this + 25) == v2)
    return 1;
  GlyphRuns = CTLineGetGlyphRuns(*v2);
  return -[__CFArray count](GlyphRuns, "count") <= (unint64_t)a2
      || (CTRunGetStatus((CTRunRef)-[__CFArray objectAtIndexedSubscript:](GlyphRuns, "objectAtIndexedSubscript:", a2)) & 1) == 0;
}

uint64_t TSWPLineFragment::characterCountOfGlyphAtCharIndex(TSWPLineFragment *this, uint64_t a2)
{
  const __CTLine **v2;
  unint64_t v4;
  unint64_t v5;
  CFArrayRef GlyphRuns;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  const __CTRun *v10;
  CFIndex GlyphCount;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  void *v16;
  uint64_t v17;
  unint64_t v19;
  const __CTLine *line;
  unsigned int v21;
  CFIndex *buffer[3];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];
  uint64_t v28;
  CFRange v29;

  v28 = *MEMORY[0x24BDAC8D0];
  v2 = (const __CTLine **)*((_QWORD *)this + 24);
  if (*((const __CTLine ***)this + 25) == v2)
    return 1;
  if (*((_QWORD *)this + 1) < 2uLL)
    return 1;
  line = *v2;
  v4 = TSWPNextCharFromTextSource(a2, *((void **)this + 23));
  v19 = *((_QWORD *)this + 1) + *(_QWORD *)this;
  if (v4 >= v19)
  {
    return 1;
  }
  else
  {
    v5 = v4;
    v21 = 1;
    do
    {
      v25 = 0u;
      v26 = 0u;
      v23 = 0u;
      v24 = 0u;
      GlyphRuns = CTLineGetGlyphRuns(line);
      v7 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
      if (v7)
      {
        v8 = *(_QWORD *)v24;
        while (2)
        {
          for (i = 0; i != v7; ++i)
          {
            if (*(_QWORD *)v24 != v8)
              objc_enumerationMutation(GlyphRuns);
            v10 = *(const __CTRun **)(*((_QWORD *)&v23 + 1) + 8 * i);
            GlyphCount = CTRunGetGlyphCount(v10);
            if ((unint64_t)(GlyphCount - 65537) <= 0xFFFFFFFFFFFEFFFFLL)
            {
              v16 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
              v17 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "uint TSWPLineFragment::characterCountOfGlyphAtCharIndex(TSWPCharIndex) const");
              objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2694, CFSTR("bad glyph count: %ld"), GlyphCount);
              goto LABEL_23;
            }
            std::vector<long>::vector(buffer, GlyphCount);
            v29.location = 0;
            v29.length = GlyphCount;
            CTRunGetStringIndices(v10, v29, buffer[0]);
            if (!*((_QWORD *)this + 23))
            {
              v12 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
              v13 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "uint TSWPLineFragment::characterCountOfGlyphAtCharIndex(TSWPCharIndex) const");
              objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v13, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2700, CFSTR("invalid nil value for '%s'"), "_textSource");
            }
            v14 = 0;
            v15 = 1;
            do
            {
              if (objc_msgSend(*((id *)this + 23), "charIndexMappedToStorage:", buffer[0][v14]) == v5)
                break;
              v15 = GlyphCount > ++v14;
            }
            while (GlyphCount != v14);
            if (buffer[0])
            {
              buffer[1] = buffer[0];
              operator delete(buffer[0]);
            }
            if (v15)
              return v21;
          }
          v7 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
          if (v7)
            continue;
          break;
        }
      }
LABEL_23:
      v5 = TSWPNextCharFromTextSource(v5, *((void **)this + 23));
      ++v21;
    }
    while (v5 < v19);
  }
  return v21;
}

void sub_217B1AB80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t TSWPLineFragment::isInsideTateChuYokoLineAtCharIndex(TSWPLineFragment *this, uint64_t a2, double *a3, double *a4, double *a5, double *a6, double *a7)
{
  void *v14;
  void *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v28;
  unint64_t v29;
  CFArrayRef GlyphRuns;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t i;
  const __CTRun *v35;
  CFRange StringRange;
  BOOL v37;
  void *v38;
  uint64_t v39;
  const __CFDictionary *Attributes;
  const __CTFont *Value;
  uint64_t v42;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  _BYTE v52[128];
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 32) != *((_QWORD *)this + 31))
  {
    v14 = (void *)*((_QWORD *)this + 23);
    if (!v14)
    {
      v15 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v16 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPLineFragment::isInsideTateChuYokoLineAtCharIndex(TSWPCharIndex, CGFloat &, CGFloat &, CGFloat &, CGFloat &, CGFloat &) const");
      objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2821, CFSTR("invalid nil value for '%s'"), "_textSource");
      v14 = (void *)*((_QWORD *)this + 23);
    }
    v17 = objc_msgSend(v14, "charIndexMappedFromStorage:", a2);
    v19 = *((_QWORD *)this + 31);
    v18 = *((_QWORD *)this + 32);
    v20 = v18 - v19;
    if (v18 != v19)
    {
      v21 = 0;
      v22 = 0xAAAAAAAAAAAAAAABLL * (v20 >> 4);
      v23 = 1;
      while (1)
      {
        v24 = v19 + 48 * v21;
        v25 = *(_QWORD *)(v24 + 24);
        v26 = *(_QWORD *)(v24 + 32) + v25;
        if (v17 > v25 && v17 < v26)
          break;
        v21 = v23;
        v37 = v22 > v23++;
        if (!v37)
          return 0;
      }
      v28 = 48 * v21;
      v29 = v17 - v25 + CTLineGetStringRange((CTLineRef)*(_QWORD *)(v19 + 48 * v21)).location;
      *a3 = CTLineGetOffsetForStringIndex(*(CTLineRef *)(v19 + v28), v29, 0);
      *a4 = CTLineGetTypographicBounds(*(CTLineRef *)(v19 + v28), 0, 0, 0);
      CTLineGetGlyphRuns(*(CTLineRef *)(v19 + v28));
      v48 = 0u;
      v49 = 0u;
      v50 = 0u;
      v51 = 0u;
      GlyphRuns = CTLineGetGlyphRuns(*(CTLineRef *)(v19 + v28));
      v31 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v48, v52, 16);
      if (v31)
      {
        v32 = v31;
        v33 = *(_QWORD *)v49;
        do
        {
          for (i = 0; i != v32; ++i)
          {
            if (*(_QWORD *)v49 != v33)
              objc_enumerationMutation(GlyphRuns);
            v35 = *(const __CTRun **)(*((_QWORD *)&v48 + 1) + 8 * i);
            StringRange = CTRunGetStringRange(v35);
            v37 = StringRange.location >= v29 || v29 > StringRange.location + StringRange.length;
            if (!v37)
            {
              Attributes = CTRunGetAttributes(v35);
              Value = (const __CTFont *)CFDictionaryGetValue(Attributes, (const void *)*MEMORY[0x24BDC4C28]);
              v46 = 0u;
              v47 = 0u;
              v44 = 0u;
              v45 = 0u;
              TSWPFontHeightInfoForFont(Value, &v44);
              v42 = *((_QWORD *)&v45 + 1);
              *(_QWORD *)a5 = v45;
              *(_QWORD *)a6 = v42;
              *(_QWORD *)a7 = v46;
              return 1;
            }
          }
          v32 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v48, v52, 16);
        }
        while (v32);
      }
      v38 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v39 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPLineFragment::isInsideTateChuYokoLineAtCharIndex(TSWPCharIndex, CGFloat &, CGFloat &, CGFloat &, CGFloat &, CGFloat &) const");
      objc_msgSend(v38, "handleFailureInFunction:file:lineNumber:description:", v39, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 2860, CFSTR("Could not find the CTRun for the tate chu yoko run."));
    }
  }
  return 0;
}

TSWPLineFragment *TSWPLineFragment::setHyphenated(TSWPLineFragment *this, int a2)
{
  int v2;

  if (a2)
    v2 = 2;
  else
    v2 = 0;
  *((_DWORD *)this + 6) = *((_DWORD *)this + 6) & 0xFFFFFFFD | v2;
  return this;
}

TSWPLineFragment *TSWPLineFragment::setWasReused(TSWPLineFragment *this)
{
  *((_DWORD *)this + 6) |= 0x400000u;
  return this;
}

BOOL TSWPLineFragment::isDifferentFromLineFragment(TSWPLineFragment *this, const TSWPLineFragment *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unsigned int v10;
  TSWPListLabel *v12;
  const TSWPListLabel *v13;
  CGRect v15;
  CGRect v16;

  if (a2 == this)
    return 0;
  v15.origin.x = *((CGFloat *)this + 6);
  v15.origin.y = *((CGFloat *)this + 7);
  v15.size.width = *((CGFloat *)this + 8);
  v15.size.height = *((CGFloat *)this + 9);
  v16.origin.x = *((CGFloat *)a2 + 6);
  v16.origin.y = *((CGFloat *)a2 + 7);
  v16.size.width = *((CGFloat *)a2 + 8);
  v16.size.height = *((CGFloat *)a2 + 9);
  if (!CGRectEqualToRect(v15, v16))
    return 1;
  if (!CGRectEqualToRect(*(CGRect *)((char *)this + 80), *(CGRect *)((char *)a2 + 80)))
    return 1;
  if (*((double *)this + 4) != *((double *)a2 + 4))
    return 1;
  if (*((double *)this + 5) != *((double *)a2 + 5))
    return 1;
  if (*(_QWORD *)this != *(_QWORD *)a2 + a3)
    return 1;
  if (*((_QWORD *)this + 2) != *((_QWORD *)a2 + 2) + a3)
    return 1;
  if (*((_QWORD *)this + 1) != *((_QWORD *)a2 + 1))
    return 1;
  if (*((_DWORD *)this + 6) != *((_DWORD *)a2 + 6))
    return 1;
  v7 = *((_QWORD *)a2 + 24);
  v6 = *((_QWORD *)a2 + 25);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 4);
  if (v8 != 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 25) - *((_QWORD *)this + 24)) >> 4))
    return 1;
  if (v6 != v7)
  {
    v9 = 0;
    v10 = 1;
    while (!operator!=(*((_QWORD *)a2 + 24) + 48 * v9, *((_QWORD *)this + 24) + 48 * v9))
    {
      v9 = v10;
      if (v8 <= v10++)
        goto LABEL_15;
    }
    return 1;
  }
LABEL_15:
  v12 = (TSWPListLabel *)*((_QWORD *)this + 22);
  v13 = (const TSWPListLabel *)*((_QWORD *)a2 + 22);
  if (!v12)
    return v13 || (*((_BYTE *)this + 24) & 1) != 0;
  return !v13 || (TSWPListLabel::isEqual(v12, v13) & 1) == 0;
}

BOOL operator!=(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  BOOL v5;

  v2 = *(double *)(a1 + 8) == *(double *)(a2 + 8) && *(double *)(a1 + 16) == *(double *)(a2 + 16);
  if (v2
    && CFEqual(*(CFTypeRef *)a1, *(CFTypeRef *)a2)
    && (*(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24) ? (v5 = *(_QWORD *)(a1 + 32) == *(_QWORD *)(a2 + 32)) : (v5 = 0), v5))
  {
    return *(_DWORD *)(a1 + 40) != *(_DWORD *)(a2 + 40);
  }
  else
  {
    return 1;
  }
}

BOOL TSWPLineFragment::preventWidowCorrection(TSWPLineFragment *this, CGRect a2)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  double v7;
  double v9;
  CGRect v10;
  CGRect v11;
  CGRect v12;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  v10.origin.x = *((CGFloat *)this + 6);
  v10.origin.y = *((CGFloat *)this + 7);
  v10.size.width = *((CGFloat *)this + 8);
  v10.size.height = *((CGFloat *)this + 9);
  v7 = round(CGRectGetMinX(v10));
  v11.origin.x = x;
  v11.origin.y = y;
  v11.size.width = width;
  v11.size.height = height;
  if (v7 != round(CGRectGetMinX(v11)))
    return 1;
  v9 = round(CGRectGetMaxX(*(CGRect *)((char *)this + 48)));
  v12.origin.x = x;
  v12.origin.y = y;
  v12.size.width = width;
  v12.size.height = height;
  return v9 != round(CGRectGetMaxX(v12));
}

CGFloat TSWPLineFragment::offsetBy(TSWPLineFragment *this, CGPoint a2)
{
  CGFloat v2;
  CGFloat v3;
  CGFloat result;

  v2 = a2.y + *((double *)this + 7);
  *((double *)this + 6) = a2.x + *((double *)this + 6);
  *((CGFloat *)this + 7) = v2;
  v3 = a2.y + *((double *)this + 11);
  *((double *)this + 10) = a2.x + *((double *)this + 10);
  *((CGFloat *)this + 11) = v3;
  result = a2.y + *((double *)this + 4);
  *((CGFloat *)this + 4) = result;
  return result;
}

uint64_t TSWPLineFragment::hintForAttachmentLayout(TSWPLineFragment *this)
{
  uint64_t v1;

  if ((*((_BYTE *)this + 24) & 1) != 0 && (v1 = *((_QWORD *)this + 54)) != 0)
    return objc_msgSend((id)objc_msgSend((id)objc_msgSend(*((id *)this + 54), "info"), "partitioner"), "hintForLayout:", v1);
  else
    return 0;
}

void TSWPLineFragment::setHyphenInfo(TSWPLineFragment *this, CFTypeRef cf, int a3)
{
  _QWORD *v6;
  const void *v7;

  v6 = (_QWORD *)*((_QWORD *)this + 49);
  if (v6)
  {
    if (!cf)
      goto LABEL_4;
    goto LABEL_3;
  }
  v6 = (_QWORD *)operator new();
  v6[1] = 0;
  v6[2] = 0;
  *v6 = 0;
  *(_QWORD *)((char *)v6 + 21) = 0;
  *((_QWORD *)this + 49) = v6;
  if (cf)
LABEL_3:
    CFRetain(cf);
LABEL_4:
  v7 = (const void *)v6[2];
  if (v7)
    CFRelease(v7);
  v6[2] = cf;
  *(_DWORD *)(*((_QWORD *)this + 49) + 24) = a3;
}

TSWPLineFragment *TSWPLineFragment::getHyphenInfo(TSWPLineFragment *this, const __CFDictionary **a2, unsigned int *a3)
{
  TSWPLineFragment *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;

  v5 = this;
  v6 = *((_QWORD *)this + 49);
  if (v6
    || (v7 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler"),
        v8 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPLineFragment::getHyphenInfo(CFDictionaryRef &, UTF32Char &) const"), this = (TSWPLineFragment *)objc_msgSend(v7, "handleFailureInFunction:file:lineNumber:description:", v8, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.mm"), 3104, CFSTR("Typesetter state not initialized")), (v6 = *((_QWORD *)v5 + 49)) != 0))
  {
    *a2 = *(const __CFDictionary **)(v6 + 16);
    LODWORD(v6) = *(_DWORD *)(*((_QWORD *)v5 + 49) + 24);
  }
  else
  {
    *a2 = 0;
  }
  *a3 = v6;
  return this;
}

uint64_t TSWPLineFragment::setOikomiSquish(TSWPLineFragment *this, char a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 49);
  if (!result)
  {
    result = operator new();
    *(_QWORD *)(result + 8) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)result = 0;
    *(_QWORD *)(result + 21) = 0;
    *((_QWORD *)this + 49) = result;
  }
  *(_BYTE *)(result + 28) = a2;
  return result;
}

void TSWPLineFragment::restoreLayoutState(TSWPLineFragment *this)
{
  CFTypeRef *i;
  CFTypeRef *v3;
  uint64_t j;
  uint64_t v5;
  uint64_t k;
  uint64_t v7;
  uint64_t m;
  uint64_t v9;
  uint64_t n;
  uint64_t v11;
  uint64_t ii;
  uint64_t v13;
  uint64_t v14;

  *((_DWORD *)this + 6) = *((_DWORD *)this + 120) & 0xFFFFFFFD;
  v3 = (CFTypeRef *)*((_QWORD *)this + 24);
  for (i = (CFTypeRef *)*((_QWORD *)this + 25);
        i != v3;
        std::allocator<TSWPLineRef>::destroy[abi:ne180100]((uint64_t)this + 208, i))
  {
    i -= 6;
  }
  *((_QWORD *)this + 25) = v3;
  v5 = *((_QWORD *)this + 55);
  for (j = *((_QWORD *)this + 56); j != v5; TSWPAdornments::~TSWPAdornments((CGColorRef *)(j - 200)))
    ;
  *((_QWORD *)this + 56) = v5;
  v7 = *((_QWORD *)this + 34);
  for (k = *((_QWORD *)this + 35);
        k != v7;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 288, k))
  {
    k -= 80;
  }
  *((_QWORD *)this + 35) = v7;
  v9 = *((_QWORD *)this + 37);
  for (m = *((_QWORD *)this + 38);
        m != v9;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 312, m))
  {
    m -= 80;
  }
  *((_QWORD *)this + 38) = v9;
  v11 = *((_QWORD *)this + 40);
  for (n = *((_QWORD *)this + 41);
        n != v11;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 336, n))
  {
    n -= 80;
  }
  *((_QWORD *)this + 41) = v11;
  v13 = *((_QWORD *)this + 43);
  for (ii = *((_QWORD *)this + 44);
        ii != v13;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)this + 360, ii))
  {
    ii -= 80;
  }
  *((_QWORD *)this + 44) = v13;

  *((_QWORD *)this + 64) = 0;
  v14 = *((_QWORD *)this + 58);
  if (v14)
  {
    CGColorRelease(*(CGColorRef *)(v14 + 24));

    MEMORY[0x219A153B8](v14, 0x10A0C406E8A3FE5);
    *((_QWORD *)this + 58) = 0;
  }
}

uint64_t TSWPLineFragment::appendAdornment(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  id v4;

  if (a2)
  {
    v3 = result;
    v4 = *(id *)(result + 528);
    if (!v4)
    {
      v4 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
      *(_QWORD *)(v3 + 528) = v4;
    }
    return objc_msgSend(v4, "addObject:", a2);
  }
  return result;
}

uint64_t TSWPLineFragment::defaultMarkupColor(TSWPLineFragment *this)
{
  if (TSWPLineFragment::defaultMarkupColor(void)const::onceChangeTrackingColor != -1)
    dispatch_once(&TSWPLineFragment::defaultMarkupColor(void)const::onceChangeTrackingColor, &__block_literal_global_74);
  return TSWPLineFragment::defaultMarkupColor(void)const::sDefaultChangeTrackingColor;
}

id ___ZNK16TSWPLineFragment18defaultMarkupColorEv_block_invoke()
{
  id result;

  result = (id)objc_msgSend(MEMORY[0x24BEB3C40], "colorWithWhite:alpha:", 0.156800002, 1.0);
  TSWPLineFragment::defaultMarkupColor(void)const::sDefaultChangeTrackingColor = (uint64_t)result;
  return result;
}

uint64_t TSWPLineFragment::changeAdornmentMarkupColor(TSWPLineFragment *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 59);
  if (!result)
  {
    if (TSWPLineFragment::defaultMarkupColor(void)const::onceChangeTrackingColor != -1)
      dispatch_once(&TSWPLineFragment::defaultMarkupColor(void)const::onceChangeTrackingColor, &__block_literal_global_74);
    return TSWPLineFragment::defaultMarkupColor(void)const::sDefaultChangeTrackingColor;
  }
  return result;
}

TSWPLineFragment *TSWPLineFragment::setChangeAdornmentMarkupColor(TSWPLineFragment *this, TSUColor *a2)
{
  TSUColor *v2;
  TSWPLineFragment *v4;

  v2 = (TSUColor *)*((_QWORD *)this + 59);
  if (v2 != a2)
  {
    v4 = this;

    this = a2;
    *((_QWORD *)v4 + 59) = this;
  }
  return this;
}

BOOL TSWPLineFragment::markupColorIsDefault(TSWPLineFragment *this)
{
  return *((_QWORD *)this + 59) == 0;
}

void std::vector<TSWPLineRef>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  CFTypeRef *v2;
  CFTypeRef *v4;
  void *v5;

  v1 = *a1;
  v2 = (CFTypeRef *)**a1;
  if (v2)
  {
    v4 = (CFTypeRef *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 6;
        std::allocator<TSWPLineRef>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<TSWPLineRef>::destroy[abi:ne180100](uint64_t a1, CFTypeRef *a2)
{
  if (*a2)
    CFRelease(*a2);
}

void std::vector<TSWPAdornmentLine>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80;
        std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<TSWPAdornmentLine>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  CGColorRelease(*(CGColorRef *)(a2 + 24));

}

void std::vector<TSWPUIAttachmentData>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<TSWPUIAttachmentData>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }
}

void std::vector<TSWPUIAttachmentData>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;
  void *v5;

  for (i = *(_QWORD *)(a1 + 8); i != a2; i -= 32)
  {
    v5 = *(void **)(i - 32);

  }
  *(_QWORD *)(a1 + 8) = a2;
}

void std::vector<TSWPAdornments>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  CGColorRef *v2;
  CGColorRef *v4;
  void *v5;

  v1 = *a1;
  v2 = (CGColorRef *)**a1;
  if (v2)
  {
    v4 = (CGColorRef *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        TSWPAdornments::~TSWPAdornments(v4 - 25);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::vector<unsigned short>::vector(_QWORD *a1, uint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned short>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_217B1B8B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned short>::__vallocate[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 < 0)
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(2 * a2);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPLFCharIndexData>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(a2 << 6);
}

uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(uint64_t result, _OWORD *a2, uint64_t (**a3)(_OWORD *, _QWORD))
{
  uint64_t v3;
  uint64_t v4;
  _OWORD *v6;
  _OWORD *v7;
  uint64_t v9;
  _OWORD *v10;
  _OWORD *v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  _OWORD *v15;
  __int128 v16;
  __int128 v17;
  _OWORD *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;

  if ((_OWORD *)result != a2)
  {
    v25 = v3;
    v26 = v4;
    v6 = (_OWORD *)result;
    v7 = (_OWORD *)(result + 64);
    if ((_OWORD *)(result + 64) != a2)
    {
      v9 = 0;
      v10 = (_OWORD *)result;
      do
      {
        v11 = v10;
        v10 = v7;
        result = (*a3)(v7, v11);
        if ((_DWORD)result)
        {
          v12 = v10[1];
          v21 = *v10;
          v22 = v12;
          v13 = v10[3];
          v23 = v10[2];
          v24 = v13;
          v14 = v9;
          while (1)
          {
            v15 = (_OWORD *)((char *)v6 + v14);
            v16 = *(_OWORD *)((char *)v6 + v14 + 16);
            v15[4] = *(_OWORD *)((char *)v6 + v14);
            v15[5] = v16;
            v17 = *(_OWORD *)((char *)v6 + v14 + 48);
            v15[6] = *(_OWORD *)((char *)v6 + v14 + 32);
            v15[7] = v17;
            if (!v14)
              break;
            v14 -= 64;
            result = (*a3)(&v21, (char *)v6 + v14);
            if ((result & 1) == 0)
            {
              v18 = (_OWORD *)((char *)v6 + v14 + 64);
              goto LABEL_10;
            }
          }
          v18 = v6;
LABEL_10:
          v19 = v22;
          *v18 = v21;
          v18[1] = v19;
          v20 = v24;
          v18[2] = v23;
          v18[3] = v20;
        }
        v7 = v10 + 4;
        v9 += 64;
      }
      while (v10 + 4 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(uint64_t result, _OWORD *a2, uint64_t (**a3)(__int128 *, _OWORD *))
{
  uint64_t v3;
  uint64_t v4;
  _OWORD *v6;
  _OWORD *v7;
  _OWORD *v9;
  _OWORD *v10;
  __int128 v11;
  __int128 v12;
  _OWORD *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;

  if ((_OWORD *)result != a2)
  {
    v22 = v3;
    v23 = v4;
    v6 = (_OWORD *)result;
    v7 = (_OWORD *)(result + 64);
    if ((_OWORD *)(result + 64) != a2)
    {
      v9 = (_OWORD *)(result - 64);
      do
      {
        v10 = v6;
        v6 = v7;
        result = (*a3)(v7, v10);
        if ((_DWORD)result)
        {
          v11 = v6[1];
          v18 = *v6;
          v19 = v11;
          v12 = v6[3];
          v20 = v6[2];
          v21 = v12;
          v13 = v9;
          do
          {
            v14 = v13[5];
            v13[8] = v13[4];
            v13[9] = v14;
            v15 = v13[7];
            v13[10] = v13[6];
            v13[11] = v15;
            result = (*a3)(&v18, v13);
            v13 -= 4;
          }
          while ((result & 1) != 0);
          v16 = v19;
          v13[8] = v18;
          v13[9] = v16;
          v17 = v21;
          v13[10] = v20;
          v13[11] = v17;
        }
        v7 = v6 + 4;
        v9 += 4;
      }
      while (v6 + 4 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(__int128 *a1, __int128 *a2, __int128 *a3, uint64_t (**a4)(__int128 *, __int128 *))
{
  char v8;
  uint64_t result;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;

  v8 = (*a4)(a2, a1);
  result = (*a4)(a3, a2);
  if ((v8 & 1) != 0)
  {
    if ((_DWORD)result)
    {
      v11 = a1[2];
      v10 = a1[3];
      v13 = *a1;
      v12 = a1[1];
      v14 = a3[3];
      v16 = *a3;
      v15 = a3[1];
      a1[2] = a3[2];
      a1[3] = v14;
      *a1 = v16;
      a1[1] = v15;
      *a3 = v13;
      a3[1] = v12;
      result = 1;
LABEL_9:
      a3[2] = v11;
      a3[3] = v10;
      return result;
    }
    v32 = a1[2];
    v31 = a1[3];
    v34 = *a1;
    v33 = a1[1];
    v35 = a2[3];
    v37 = *a2;
    v36 = a2[1];
    a1[2] = a2[2];
    a1[3] = v35;
    *a1 = v37;
    a1[1] = v36;
    *a2 = v34;
    a2[1] = v33;
    a2[2] = v32;
    a2[3] = v31;
    if ((*a4)(a3, a2))
    {
      v11 = a2[2];
      v10 = a2[3];
      v39 = *a2;
      v38 = a2[1];
      v40 = a3[3];
      v42 = *a3;
      v41 = a3[1];
      a2[2] = a3[2];
      a2[3] = v40;
      *a2 = v42;
      a2[1] = v41;
      *a3 = v39;
      a3[1] = v38;
      result = 2;
      goto LABEL_9;
    }
  }
  else
  {
    if (!(_DWORD)result)
      return result;
    v18 = a2[2];
    v17 = a2[3];
    v20 = *a2;
    v19 = a2[1];
    v21 = a3[3];
    v23 = *a3;
    v22 = a3[1];
    a2[2] = a3[2];
    a2[3] = v21;
    *a2 = v23;
    a2[1] = v22;
    *a3 = v20;
    a3[1] = v19;
    a3[2] = v18;
    a3[3] = v17;
    if ((*a4)(a2, a1))
    {
      v25 = a1[2];
      v24 = a1[3];
      v27 = *a1;
      v26 = a1[1];
      v28 = a2[3];
      v30 = *a2;
      v29 = a2[1];
      a1[2] = a2[2];
      a1[3] = v28;
      *a1 = v30;
      a1[1] = v29;
      *a2 = v27;
      a2[1] = v26;
      result = 2;
      a2[2] = v25;
      a2[3] = v24;
      return result;
    }
  }
  return 1;
}

__int128 *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,TSWPLFCharIndexData *,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&)>(__int128 *a1, __int128 *a2, uint64_t (**a3)(__int128 *, __int128 *))
{
  __int128 *v4;
  __int128 v6;
  __int128 v7;
  __int128 *v8;
  __int128 *v9;
  int v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;

  v4 = a2;
  v6 = a1[1];
  v28 = *a1;
  v29 = v6;
  v7 = a1[3];
  v30 = a1[2];
  v31 = v7;
  if (((*a3)(&v28, a2 - 4) & 1) != 0)
  {
    v8 = a1;
    do
      v8 += 4;
    while (((*a3)(&v28, v8) & 1) == 0);
  }
  else
  {
    v9 = a1 + 4;
    do
    {
      v8 = v9;
      if (v9 >= v4)
        break;
      v10 = (*a3)(&v28, v9);
      v9 = v8 + 4;
    }
    while (!v10);
  }
  if (v8 < v4)
  {
    do
      v4 -= 4;
    while (((*a3)(&v28, v4) & 1) != 0);
  }
  while (v8 < v4)
  {
    v11 = *v8;
    v12 = v8[1];
    v13 = v8[3];
    v34 = v8[2];
    v35 = v13;
    v32 = v11;
    v33 = v12;
    v14 = *v4;
    v15 = v4[1];
    v16 = v4[3];
    v8[2] = v4[2];
    v8[3] = v16;
    *v8 = v14;
    v8[1] = v15;
    v17 = v32;
    v18 = v33;
    v19 = v35;
    v4[2] = v34;
    v4[3] = v19;
    *v4 = v17;
    v4[1] = v18;
    do
      v8 += 4;
    while (!(*a3)(&v28, v8));
    do
      v4 -= 4;
    while (((*a3)(&v28, v4) & 1) != 0);
  }
  v20 = v8 - 4;
  if (v8 - 4 != a1)
  {
    v21 = *v20;
    v22 = *(v8 - 3);
    v23 = *(v8 - 1);
    a1[2] = *(v8 - 2);
    a1[3] = v23;
    *a1 = v21;
    a1[1] = v22;
  }
  v24 = v28;
  v25 = v29;
  v26 = v31;
  *(v8 - 2) = v30;
  *(v8 - 1) = v26;
  *v20 = v24;
  *(v8 - 3) = v25;
  return v8;
}

__int128 *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,TSWPLFCharIndexData *,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&)>(__int128 *a1, __int128 *a2, uint64_t (**a3)(__int128 *, __int128 *))
{
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 *v9;
  __int128 *v10;
  __int128 *v11;
  __int128 *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;

  v6 = 0;
  v7 = a1[1];
  v27 = *a1;
  v28 = v7;
  v8 = a1[3];
  v29 = a1[2];
  v30 = v8;
  do
    v6 += 4;
  while (((*a3)(&a1[v6], &v27) & 1) != 0);
  v9 = &a1[v6];
  v10 = &a1[v6 - 4];
  if (v6 == 4)
  {
    do
    {
      if (v9 >= a2)
        break;
      a2 -= 4;
    }
    while (((*a3)(a2, &v27) & 1) == 0);
  }
  else
  {
    do
      a2 -= 4;
    while (!(*a3)(a2, &v27));
  }
  if (v9 < a2)
  {
    v11 = &a1[v6];
    v12 = a2;
    do
    {
      v14 = v11[1];
      v31 = *v11;
      v13 = v31;
      v32 = v14;
      v16 = v11[3];
      v33 = v11[2];
      v15 = v33;
      v34 = v16;
      v18 = v12[2];
      v17 = v12[3];
      v19 = v12[1];
      *v11 = *v12;
      v11[1] = v19;
      v11[2] = v18;
      v11[3] = v17;
      v12[2] = v15;
      v12[3] = v16;
      *v12 = v13;
      v12[1] = v14;
      do
        v11 += 4;
      while (((*a3)(v11, &v27) & 1) != 0);
      do
        v12 -= 4;
      while (!(*a3)(v12, &v27));
    }
    while (v11 < v12);
    v10 = v11 - 4;
  }
  if (v10 != a1)
  {
    v20 = *v10;
    v21 = v10[1];
    v22 = v10[3];
    a1[2] = v10[2];
    a1[3] = v22;
    *a1 = v20;
    a1[1] = v21;
  }
  v23 = v27;
  v24 = v28;
  v25 = v30;
  v10[2] = v29;
  v10[3] = v25;
  *v10 = v23;
  v10[1] = v24;
  return v10;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(__int128 *a1, __int128 *a2, uint64_t (**a3)(__int128 *, __int128 *))
{
  uint64_t v6;
  _BOOL8 result;
  __int128 *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 *v16;
  __int128 *v17;
  uint64_t v18;
  int v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  _OWORD *v23;
  __int128 v24;
  __int128 v25;
  __int128 *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;

  v6 = ((char *)a2 - (char *)a1) >> 6;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v8 = a2 - 4;
      if (!(*a3)(a2 - 4, a1))
        return 1;
      v10 = a1[2];
      v9 = a1[3];
      v12 = *a1;
      v11 = a1[1];
      v13 = *(a2 - 1);
      v15 = *v8;
      v14 = *(a2 - 3);
      a1[2] = *(a2 - 2);
      a1[3] = v13;
      *a1 = v15;
      a1[1] = v14;
      *v8 = v12;
      *(a2 - 3) = v11;
      result = 1;
      *(a2 - 2) = v10;
      *(a2 - 1) = v9;
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(a1, a1 + 4, a2 - 4, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>((uint64_t)a1, a1 + 4, a1 + 8, a2 - 4, a3);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>((uint64_t)a1, a1 + 4, a1 + 8, a1 + 12, a2 - 4, a3);
      return 1;
    default:
      v16 = a1 + 8;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(a1, a1 + 4, a1 + 8, a3);
      v17 = a1 + 12;
      if (a1 + 12 == a2)
        return 1;
      v18 = 0;
      v19 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(v17, v16))
    {
      v20 = v17[1];
      v29 = *v17;
      v30 = v20;
      v21 = v17[3];
      v31 = v17[2];
      v32 = v21;
      v22 = v18;
      while (1)
      {
        v23 = (__int128 *)((char *)a1 + v22);
        v24 = *(__int128 *)((char *)a1 + v22 + 144);
        v23[12] = *(__int128 *)((char *)a1 + v22 + 128);
        v23[13] = v24;
        v25 = *(__int128 *)((char *)a1 + v22 + 176);
        v23[14] = *(__int128 *)((char *)a1 + v22 + 160);
        v23[15] = v25;
        if (v22 == -128)
          break;
        v22 -= 64;
        if (((*a3)(&v29, v23 + 4) & 1) == 0)
        {
          v26 = (__int128 *)((char *)a1 + v22 + 192);
          goto LABEL_12;
        }
      }
      v26 = a1;
LABEL_12:
      v27 = v30;
      *v26 = v29;
      v26[1] = v27;
      v28 = v32;
      v26[2] = v31;
      v26[3] = v28;
      if (++v19 == 8)
        return v17 + 4 == a2;
    }
    v16 = v17;
    v18 += 64;
    v17 += 4;
    if (v17 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(uint64_t a1, __int128 *a2, __int128 *a3, __int128 *a4, uint64_t (**a5)(__int128 *, __int128 *))
{
  __n128 result;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>((__int128 *)a1, a2, a3, a5);
  if ((*a5)(a4, a3))
  {
    v12 = a3[2];
    v11 = a3[3];
    v14 = *a3;
    v13 = a3[1];
    v15 = a4[3];
    v17 = *a4;
    v16 = a4[1];
    a3[2] = a4[2];
    a3[3] = v15;
    *a3 = v17;
    a3[1] = v16;
    *a4 = v14;
    a4[1] = v13;
    a4[2] = v12;
    a4[3] = v11;
    if ((*a5)(a3, a2))
    {
      v19 = a2[2];
      v18 = a2[3];
      v21 = *a2;
      v20 = a2[1];
      v22 = a3[3];
      v24 = *a3;
      v23 = a3[1];
      a2[2] = a3[2];
      a2[3] = v22;
      *a2 = v24;
      a2[1] = v23;
      *a3 = v21;
      a3[1] = v20;
      a3[2] = v19;
      a3[3] = v18;
      if ((*a5)(a2, (__int128 *)a1))
      {
        v25 = *(_OWORD *)(a1 + 32);
        result = *(__n128 *)(a1 + 48);
        v27 = *(_OWORD *)a1;
        v26 = *(_OWORD *)(a1 + 16);
        v28 = a2[3];
        v30 = *a2;
        v29 = a2[1];
        *(_OWORD *)(a1 + 32) = a2[2];
        *(_OWORD *)(a1 + 48) = v28;
        *(_OWORD *)a1 = v30;
        *(_OWORD *)(a1 + 16) = v29;
        *a2 = v27;
        a2[1] = v26;
        a2[2] = v25;
        a2[3] = (__int128)result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(uint64_t a1, __int128 *a2, __int128 *a3, __int128 *a4, __int128 *a5, uint64_t (**a6)(__int128 *, __int128 *))
{
  __n128 v12;
  __n128 result;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;

  v12 = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(a1, a2, a3, a4, a6);
  if (((unsigned int (*)(__int128 *, __int128 *, __n128))*a6)(a5, a4, v12))
  {
    v15 = a4[2];
    v14 = a4[3];
    v17 = *a4;
    v16 = a4[1];
    v18 = a5[3];
    v20 = *a5;
    v19 = a5[1];
    a4[2] = a5[2];
    a4[3] = v18;
    *a4 = v20;
    a4[1] = v19;
    *a5 = v17;
    a5[1] = v16;
    a5[2] = v15;
    a5[3] = v14;
    if ((*a6)(a4, a3))
    {
      v22 = a3[2];
      v21 = a3[3];
      v24 = *a3;
      v23 = a3[1];
      v25 = a4[3];
      v27 = *a4;
      v26 = a4[1];
      a3[2] = a4[2];
      a3[3] = v25;
      *a3 = v27;
      a3[1] = v26;
      *a4 = v24;
      a4[1] = v23;
      a4[2] = v22;
      a4[3] = v21;
      if ((*a6)(a3, a2))
      {
        v29 = a2[2];
        v28 = a2[3];
        v31 = *a2;
        v30 = a2[1];
        v32 = a3[3];
        v34 = *a3;
        v33 = a3[1];
        a2[2] = a3[2];
        a2[3] = v32;
        *a2 = v34;
        a2[1] = v33;
        *a3 = v31;
        a3[1] = v30;
        a3[2] = v29;
        a3[3] = v28;
        if ((*a6)(a2, (__int128 *)a1))
        {
          v35 = *(_OWORD *)(a1 + 32);
          result = *(__n128 *)(a1 + 48);
          v37 = *(_OWORD *)a1;
          v36 = *(_OWORD *)(a1 + 16);
          v38 = a2[3];
          v40 = *a2;
          v39 = a2[1];
          *(_OWORD *)(a1 + 32) = a2[2];
          *(_OWORD *)(a1 + 48) = v38;
          *(_OWORD *)a1 = v40;
          *(_OWORD *)(a1 + 16) = v39;
          *a2 = v37;
          a2[1] = v36;
          a2[2] = v35;
          a2[3] = (__int128)result;
        }
      }
    }
  }
  return result;
}

__n128 *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*,TSWPLFCharIndexData*>(uint64_t a1, __n128 *a2, __n128 *a3, unsigned int (**a4)(__n128 *, __n128 *), __n128 a5)
{
  __n128 *v7;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  __n128 *v13;
  __n128 *v14;
  __n128 *v15;
  __n128 v16;
  __n128 v17;
  __n128 v18;
  __n128 v19;
  __n128 v20;
  __n128 v21;
  __n128 v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD *v25;
  __n128 *v26;
  uint64_t v27;
  uint64_t v28;
  __n128 v29;
  __n128 v30;
  __n128 v31;
  __n128 v32;
  __n128 v33;
  __n128 v34;
  __n128 *v37;
  __n128 v38;
  __n128 v39;
  __n128 v40;
  __n128 v41;

  if ((__n128 *)a1 != a2)
  {
    v7 = a2;
    v9 = (uint64_t)a2 - a1;
    v10 = ((uint64_t)a2 - a1) >> 6;
    if ((uint64_t)a2 - a1 >= 65)
    {
      v11 = (unint64_t)(v10 - 2) >> 1;
      v12 = v11 + 1;
      v13 = (__n128 *)(a1 + (v11 << 6));
      do
      {
        a5 = std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(a1, a4, v10, v13);
        v13 -= 4;
        --v12;
      }
      while (v12);
    }
    v14 = v7;
    if (v7 != a3)
    {
      v15 = v7;
      do
      {
        if (((unsigned int (*)(__n128 *, uint64_t, __n128))*a4)(v15, a1, a5))
        {
          v17 = v15[2];
          v16 = v15[3];
          v19 = *v15;
          v18 = v15[1];
          v20 = *(__n128 *)(a1 + 48);
          v22 = *(__n128 *)a1;
          v21 = *(__n128 *)(a1 + 16);
          v15[2] = *(__n128 *)(a1 + 32);
          v15[3] = v20;
          *v15 = v22;
          v15[1] = v21;
          *(__n128 *)a1 = v19;
          *(__n128 *)(a1 + 16) = v18;
          *(__n128 *)(a1 + 32) = v17;
          *(__n128 *)(a1 + 48) = v16;
          a5 = std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(a1, a4, v10, (__n128 *)a1);
        }
        v15 += 4;
      }
      while (v15 != a3);
      v14 = a3;
    }
    if (v9 < 65)
    {
      return v14;
    }
    else
    {
      v37 = v14;
      v23 = (unint64_t)v9 >> 6;
      do
      {
        v24 = 0;
        v38 = *(__n128 *)a1;
        v39 = *(__n128 *)(a1 + 16);
        v40 = *(__n128 *)(a1 + 32);
        v41 = *(__n128 *)(a1 + 48);
        v25 = (_OWORD *)a1;
        do
        {
          v26 = (__n128 *)&v25[4 * v24 + 4];
          v27 = (2 * v24) | 1;
          v28 = 2 * v24 + 2;
          if (v28 < v23 && (*a4)((__n128 *)&v25[4 * v24 + 4], (__n128 *)&v25[4 * v24 + 8]))
          {
            v26 += 4;
            v27 = v28;
          }
          v29 = *v26;
          v30 = v26[1];
          v31 = v26[3];
          v25[2] = v26[2];
          v25[3] = v31;
          *v25 = v29;
          v25[1] = v30;
          v25 = v26;
          v24 = v27;
        }
        while (v27 <= (uint64_t)((unint64_t)(v23 - 2) >> 1));
        v7 -= 4;
        if (v26 == v7)
        {
          v26[2] = v40;
          v26[3] = v41;
          *v26 = v38;
          v26[1] = v39;
        }
        else
        {
          v32 = *v7;
          v33 = v7[1];
          v34 = v7[3];
          v26[2] = v7[2];
          v26[3] = v34;
          *v26 = v32;
          v26[1] = v33;
          *v7 = v38;
          v7[1] = v39;
          v7[2] = v40;
          v7[3] = v41;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(a1, (uint64_t)&v26[4], (uint64_t (**)(__int128 *, __int128 *))a4, ((uint64_t)&v26[4] - a1) >> 6);
        }
      }
      while (v23-- > 2);
      return v37;
    }
  }
  return a3;
}

__n128 std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(uint64_t a1, unsigned int (**a2)(__n128 *, __n128 *), uint64_t a3, __n128 *a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  __n128 *v7;
  int64_t v9;
  uint64_t v12;
  uint64_t v13;
  __n128 *v14;
  uint64_t v15;
  __n128 result;
  __n128 v17;
  __n128 v18;
  __n128 *v19;
  __n128 v20;
  __n128 v21;
  __n128 v22;
  uint64_t v23;
  uint64_t v24;
  __n128 v25;
  __n128 v26;
  __n128 v27;
  __n128 v28;
  __n128 v29;
  __n128 v30;
  uint64_t v31;
  uint64_t v32;

  v6 = a3 - 2;
  if (a3 >= 2)
  {
    v31 = v4;
    v32 = v5;
    v7 = a4;
    v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= ((uint64_t)a4 - a1) >> 6)
    {
      v12 = ((uint64_t)a4 - a1) >> 5;
      v13 = v12 + 1;
      v14 = (__n128 *)(a1 + ((v12 + 1) << 6));
      v15 = v12 + 2;
      if (v12 + 2 < a3 && (*a2)(v14, v14 + 4))
      {
        v14 += 4;
        v13 = v15;
      }
      if ((((uint64_t (*)(__n128 *, __n128 *))*a2)(v14, v7) & 1) == 0)
      {
        v17 = v7[1];
        v27 = *v7;
        v28 = v17;
        v18 = v7[3];
        v29 = v7[2];
        v30 = v18;
        do
        {
          v19 = v14;
          v20 = *v14;
          v21 = v14[1];
          v22 = v14[3];
          v7[2] = v14[2];
          v7[3] = v22;
          *v7 = v20;
          v7[1] = v21;
          if (v9 < v13)
            break;
          v23 = (2 * v13) | 1;
          v14 = (__n128 *)(a1 + (v23 << 6));
          v24 = 2 * v13 + 2;
          if (v24 < a3)
          {
            if ((*a2)((__n128 *)(a1 + (v23 << 6)), v14 + 4))
            {
              v14 += 4;
              v23 = v24;
            }
          }
          v7 = v19;
          v13 = v23;
        }
        while (!(*a2)(v14, &v27));
        result = v27;
        v25 = v28;
        v26 = v30;
        v19[2] = v29;
        v19[3] = v26;
        *v19 = result;
        v19[1] = v25;
      }
    }
  }
  return result;
}

double std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(TSWPLFCharIndexData const&,TSWPLFCharIndexData const&),TSWPLFCharIndexData*>(uint64_t a1, uint64_t a2, uint64_t (**a3)(__int128 *, __int128 *), uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v9;
  __int128 *v10;
  __int128 *v11;
  double result;
  __int128 v13;
  __int128 v14;
  __int128 *v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;

  v6 = a4 - 2;
  if (a4 >= 2)
  {
    v25 = v4;
    v26 = v5;
    v9 = v6 >> 1;
    v10 = (__int128 *)(a1 + (v6 >> 1 << 6));
    v11 = (__int128 *)(a2 - 64);
    if ((*a3)(v10, (__int128 *)(a2 - 64)))
    {
      v13 = v11[1];
      v21 = *v11;
      v22 = v13;
      v14 = v11[3];
      v23 = v11[2];
      v24 = v14;
      do
      {
        v15 = v10;
        v16 = *v10;
        v17 = v10[1];
        v18 = v10[3];
        v11[2] = v10[2];
        v11[3] = v18;
        *v11 = v16;
        v11[1] = v17;
        if (!v9)
          break;
        v9 = (v9 - 1) >> 1;
        v10 = (__int128 *)(a1 + (v9 << 6));
        v11 = v15;
      }
      while (((*a3)(v10, &v21) & 1) != 0);
      v19 = v22;
      *v15 = v21;
      v15[1] = v19;
      result = *(double *)&v23;
      v20 = v24;
      v15[2] = v23;
      v15[3] = v20;
    }
  }
  return result;
}

char *std::vector<TSWPLFCharIndexData>::__assign_with_size[abi:ne180100]<TSWPLFCharIndexData*,TSWPLFCharIndexData*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 6)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 58)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    if (v8 >> 5 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFC0)
      v11 = 0x3FFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<TSWPLFCharIndexData>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 6;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[64 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

char *std::vector<TSWPLFCharIndexData>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 58)
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPLFCharIndexData>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[64 * v4];
  return result;
}

void *std::vector<TSWPLFCharIndexData>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  void *v5;
  char *v6;
  void *v7;
  char *v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _BYTE *v13;
  uint64_t v14;
  int64_t v15;
  char *v16;
  void *v17;
  void *v18;

  v5 = *(void **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v9 = *(_QWORD *)(a2 + 8);
    do
    {
      v10 = *((_OWORD *)v8 - 4);
      v11 = *((_OWORD *)v8 - 3);
      v12 = *((_OWORD *)v8 - 1);
      v7 = (void *)(v9 - 64);
      *(_OWORD *)(v9 - 32) = *((_OWORD *)v8 - 2);
      *(_OWORD *)(v9 - 16) = v12;
      *(_OWORD *)(v9 - 64) = v10;
      *(_OWORD *)(v9 - 48) = v11;
      v8 -= 64;
      v9 -= 64;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v13 = a1[1];
  v14 = *(_QWORD *)(a2 + 16);
  v15 = v13 - __src;
  if (v13 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v13 - __src);
    v7 = *(void **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v14 + v15;
  v16 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v16;
  v17 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v17;
  v18 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v18;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

void std::vector<TSWPLineRef>::__assign_with_size[abi:ne180100]<TSWPLineRef*,TSWPLineRef*>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8;
  CFTypeRef *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFTypeRef *v14;
  CFTypeRef *v15;
  CFTypeRef *v16;
  char v17;
  char v18;

  v8 = a1 + 16;
  v9 = *(CFTypeRef **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 4) < a4)
  {
    std::vector<TSWPLineRef>::__vdeallocate((CFTypeRef **)a1);
    if (a4 > 0x555555555555555)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v10 = 0x5555555555555556 * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 4);
    if (v10 <= a4)
      v10 = a4;
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 4) >= 0x2AAAAAAAAAAAAAALL)
      v11 = 0x555555555555555;
    else
      v11 = v10;
    std::vector<TSWPLineRef>::__vallocate[abi:ne180100]((_QWORD *)a1, v11);
    v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TSWPLineRef>,TSWPLineRef*,TSWPLineRef*,TSWPLineRef*>(v8, a2, a3, *(_QWORD *)(a1 + 8));
    goto LABEL_11;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v9) >> 4) < a4)
  {
    v13 = a2 + 16 * ((uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v9) >> 4);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TSWPLineRef *,TSWPLineRef *,TSWPLineRef *>((uint64_t)&v17, a2, v13, (uint64_t)v9);
    v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TSWPLineRef>,TSWPLineRef*,TSWPLineRef*,TSWPLineRef*>(v8, v13, a3, *(_QWORD *)(a1 + 8));
LABEL_11:
    *(_QWORD *)(a1 + 8) = v12;
    return;
  }
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TSWPLineRef *,TSWPLineRef *,TSWPLineRef *>((uint64_t)&v18, a2, a3, (uint64_t)v9);
  v15 = v14;
  v16 = *(CFTypeRef **)(a1 + 8);
  if (v16 != v14)
  {
    do
    {
      v16 -= 6;
      std::allocator<TSWPLineRef>::destroy[abi:ne180100](v8, v16);
    }
    while (v16 != v15);
  }
  *(_QWORD *)(a1 + 8) = v15;
}

void sub_217B1CAB4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_217B1CABC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

char *std::vector<TSWPLineRef>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x555555555555556)
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::voronoi_edge<double>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TSWPLineRef>,TSWPLineRef*,TSWPLineRef*,TSWPLineRef*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  const void *v7;
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      v7 = *(const void **)v6;
      *(_QWORD *)v4 = *(_QWORD *)v6;
      *(_OWORD *)(v4 + 8) = *(_OWORD *)(v6 + 8);
      *(_OWORD *)(v4 + 24) = *(_OWORD *)(v6 + 24);
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v6 + 40);
      if (v7)
      {
        CFRetain(v7);
        v4 = v12;
      }
      v4 += 48;
      v12 = v4;
      v6 += 48;
    }
    while (v6 != a3);
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,TSWPLineRef*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_217B1CBBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,TSWPLineRef*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,TSWPLineRef*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,TSWPLineRef*>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<TSWPLineRef>,TSWPLineRef*>::operator()[abi:ne180100](uint64_t *a1)
{
  CFTypeRef **v1;
  CFTypeRef **v2;
  CFTypeRef *v3;
  CFTypeRef *v4;
  uint64_t v5;

  v2 = (CFTypeRef **)a1[1];
  v1 = (CFTypeRef **)a1[2];
  v3 = *v1;
  v4 = *v2;
  if (*v1 != *v2)
  {
    v5 = *a1;
    do
    {
      v3 -= 6;
      std::allocator<TSWPLineRef>::destroy[abi:ne180100](v5, v3);
    }
    while (v3 != v4);
  }
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TSWPLineRef *,TSWPLineRef *,TSWPLineRef *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;

  v5 = a2;
  if (a2 == a3)
    return a2;
  v6 = a3;
  do
  {
    if (*(_QWORD *)v5)
      CFRetain(*(CFTypeRef *)v5);
    if (*(_QWORD *)a4)
      CFRelease(*(CFTypeRef *)a4);
    *(_QWORD *)a4 = *(_QWORD *)v5;
    *(_DWORD *)(a4 + 40) = *(_DWORD *)(v5 + 40);
    *(_OWORD *)(a4 + 8) = *(_OWORD *)(v5 + 8);
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(v5 + 24);
    a4 += 48;
    v5 += 48;
  }
  while (v5 != v6);
  return v6;
}

uint64_t compareHyperlinkRangeValues(void *a1, void *a2)
{
  unint64_t v3;
  unint64_t v4;

  v3 = objc_msgSend((id)objc_msgSend(a1, "objectForKeyedSubscript:", kTSWPDataDetectorRangeKey), "rangeValue");
  v4 = objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", kTSWPDataDetectorRangeKey), "rangeValue");
  if (v3 < v4)
    return -1;
  else
    return v3 > v4;
}

const __CFString *NSStringFromTSWPSelectionType(uint64_t a1)
{
  void *v3;
  uint64_t v4;

  if (a1 < 8)
    return off_24D82D8B0[(int)a1];
  v3 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v4 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *NSStringFromTSWPSelectionType(TSWPSelectionType)");
  objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPSelection.mm"), 53, CFSTR("Unknown selection type: %d"), a1);
  return CFSTR("<UNKNOWN SELECTION TYPE>");
}

void sub_217B219CC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 120);
  if (v3)
  {
    *(_QWORD *)(v1 - 112) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_217B22958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  TSWPAttributeEnumerator::~TSWPAttributeEnumerator((TSWPAttributeEnumerator *)va);
  _Unwind_Resume(a1);
}

void sub_217B23BFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 96), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__21(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__21(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_217B24738(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_217B25114(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_217B25518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

int *polygonFromRect(CGRect a1)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  int *v5;
  CGFloat MinX;
  CGFloat MinY;
  CGFloat MaxX;
  CGFloat v9;
  CGFloat v10;
  CGFloat MaxY;
  CGFloat v12;
  CGFloat v13;
  int v15;
  _QWORD *v16;
  _QWORD v17[9];
  CGRect v18;
  CGRect v19;
  CGRect v20;
  CGRect v21;
  CGRect v22;
  CGRect v23;
  CGRect v24;
  CGRect v25;

  height = a1.size.height;
  width = a1.size.width;
  y = a1.origin.y;
  x = a1.origin.x;
  v17[8] = *MEMORY[0x24BDAC8D0];
  v5 = (int *)malloc_type_calloc(1uLL, 0x18uLL, 0x1030040B05087B7uLL);
  v15 = 4;
  v16 = v17;
  v18.origin.x = x;
  v18.origin.y = y;
  v18.size.width = width;
  v18.size.height = height;
  MinX = CGRectGetMinX(v18);
  v19.origin.x = x;
  v19.origin.y = y;
  v19.size.width = width;
  v19.size.height = height;
  MinY = CGRectGetMinY(v19);
  *(CGFloat *)v17 = MinX;
  *(CGFloat *)&v17[1] = MinY;
  v20.origin.x = x;
  v20.origin.y = y;
  v20.size.width = width;
  v20.size.height = height;
  MaxX = CGRectGetMaxX(v20);
  v21.origin.x = x;
  v21.origin.y = y;
  v21.size.width = width;
  v21.size.height = height;
  v9 = CGRectGetMinY(v21);
  *(CGFloat *)&v17[2] = MaxX;
  *(CGFloat *)&v17[3] = v9;
  v22.origin.x = x;
  v22.origin.y = y;
  v22.size.width = width;
  v22.size.height = height;
  v10 = CGRectGetMaxX(v22);
  v23.origin.x = x;
  v23.origin.y = y;
  v23.size.width = width;
  v23.size.height = height;
  MaxY = CGRectGetMaxY(v23);
  *(CGFloat *)&v17[4] = v10;
  *(CGFloat *)&v17[5] = MaxY;
  v24.origin.x = x;
  v24.origin.y = y;
  v24.size.width = width;
  v24.size.height = height;
  v12 = CGRectGetMinX(v24);
  v25.origin.x = x;
  v25.origin.y = y;
  v25.size.width = width;
  v25.size.height = height;
  v13 = CGRectGetMaxY(v25);
  *(CGFloat *)&v17[6] = v12;
  *(CGFloat *)&v17[7] = v13;
  TSDgpc_add_contour(v5, &v15, 0);
  return v5;
}

uint64_t compareRects(objc_object *a1, objc_object *a2, void *a3)
{
  double v4;
  CGFloat v5;
  double v6;
  CGFloat v7;
  double v8;
  CGFloat v9;
  double v10;
  CGFloat v11;
  double v12;
  CGFloat v13;
  double v14;
  CGFloat v15;
  double v16;
  CGFloat v17;
  double v18;
  CGFloat v19;
  double MinX;
  double v22;
  CGFloat rect;
  CGRect v24;
  CGRect v25;
  CGRect v26;
  CGRect v27;

  -[objc_object CGRectValue](a1, "CGRectValue", a3);
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  -[objc_object CGRectValue](a2, "CGRectValue");
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v19 = v18;
  rect = v5;
  v24.origin.x = v5;
  v24.origin.y = v7;
  v24.size.width = v9;
  v24.size.height = v11;
  MinX = CGRectGetMinX(v24);
  v25.origin.x = v13;
  v25.origin.y = v15;
  v25.size.width = v17;
  v25.size.height = v19;
  if (MinX < CGRectGetMinX(v25))
    return -1;
  v26.origin.x = rect;
  v26.origin.y = v7;
  v26.size.width = v9;
  v26.size.height = v11;
  v22 = CGRectGetMinX(v26);
  v27.origin.x = v13;
  v27.origin.y = v15;
  v27.size.width = v17;
  v27.size.height = v19;
  return v22 > CGRectGetMinX(v27);
}

uint64_t TSWPOverlapsRectHorizontally(CGRect a1, CGRect a2)
{
  uint64_t result;

  result = 0;
  if (a1.size.width > 0.0 && a2.size.width > 0.0)
  {
    if (a1.origin.x >= a2.origin.x)
    {
      if (a2.origin.x + a2.size.width <= a1.origin.x)
        return 0;
    }
    else if (a1.origin.x + a1.size.width <= a2.origin.x)
    {
      return 0;
    }
    return 1;
  }
  return result;
}

void *mergeRects(NSArray *a1)
{
  void *v2;
  NSEnumerator *v3;
  id v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  id v13;
  double x;
  CGFloat y;
  double width;
  CGFloat height;
  CGRect v19;
  CGRect v20;
  CGRect v21;
  CGRect v22;

  v2 = (void *)objc_msgSend(MEMORY[0x24BDBCEB8], "array");
  v3 = -[NSArray objectEnumerator](a1, "objectEnumerator");
  v4 = -[NSEnumerator nextObject](v3, "nextObject");
  if (v4)
  {
    objc_msgSend(v4, "CGRectValue");
    v6 = v5;
    v8 = v7;
    v10 = v9;
    v12 = v11;
    while (1)
    {
      do
      {
        v13 = -[NSEnumerator nextObject](v3, "nextObject");
        if (!v13)
        {
          objc_msgSend(v2, "addObject:", objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGRect:", v6, v8, v10, v12));
          return v2;
        }
        objc_msgSend(v13, "CGRectValue");
        x = v19.origin.x;
        y = v19.origin.y;
        width = v19.size.width;
        height = v19.size.height;
      }
      while (CGRectGetWidth(v19) == 0.0);
      if (width <= 0.0 || v10 <= 0.0)
        goto LABEL_9;
      if (x >= v6)
      {
        if (v6 + v10 > x)
          goto LABEL_11;
LABEL_9:
        objc_msgSend(v2, "addObject:", objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGRect:", v6, v8, v10, v12));
        v6 = x;
        v8 = y;
        v10 = width;
        v12 = height;
      }
      else
      {
        if (x + width <= v6)
          goto LABEL_9;
LABEL_11:
        v20.origin.x = x;
        v20.origin.y = y;
        v20.size.width = width;
        v20.size.height = height;
        v22.origin.x = v6;
        v22.origin.y = v8;
        v22.size.width = v10;
        v22.size.height = v12;
        v21 = CGRectUnion(v20, v22);
        v6 = v21.origin.x;
        v8 = v21.origin.y;
        v10 = v21.size.width;
        v12 = v21.size.height;
      }
    }
  }
  return v2;
}

unint64_t wrappedSubrectsFromPolygon(int *a1, double *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  NSArray *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  size_t v17;
  void *v18;
  double *v19;
  void *v20;
  CGFloat *v21;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  unint64_t v26;
  double *v27;
  unint64_t v28;
  double v29;
  CGFloat MinX;
  CGFloat MinY;
  double v32;
  double v33;
  CGFloat v34;
  double *v35;
  double *v36;
  double *v37;
  double v38;
  double v39;
  CGFloat v40;
  CGFloat v41;
  CGFloat v42;
  double *v43;
  CGRect v45;
  CGRect v46;
  CGRect v47;
  CGRect v48;
  CGRect v49;
  CGRect v50;
  CGRect v51;
  CGRect v52;
  CGRect v53;
  CGRect v54;
  CGRect v55;
  CGRect v56;

  v12 = (NSArray *)objc_msgSend(MEMORY[0x24BDBCEB8], "array");
  if (*a1 >= 1)
  {
    v13 = 0;
    v14 = 0;
    do
    {
      -[NSArray addObject:](v12, "addObject:", objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGRect:", boundsForVertexList(*((_QWORD *)a1 + 2) + v13)));
      ++v14;
      v13 += 16;
    }
    while (v14 < *a1);
  }
  -[NSArray sortUsingFunction:context:](v12, "sortUsingFunction:context:", compareRects, 0);
  v15 = mergeRects(v12);
  v16 = objc_msgSend(v15, "count");
  if (!v16)
  {
    *a2 = a3;
    a2[1] = a4;
    v26 = 1;
    a2[2] = a5;
    a2[3] = a6;
    return v26;
  }
  v17 = v16;
  v18 = (void *)objc_msgSend(v15, "objectEnumerator");
  v19 = (double *)malloc_type_calloc(v17, 0x10uLL, 0x1000040451B5BE8uLL);
  v20 = (void *)objc_msgSend(v18, "nextObject");
  if (v20)
  {
    v21 = v19 + 1;
    do
    {
      objc_msgSend(v20, "CGRectValue");
      x = v45.origin.x;
      y = v45.origin.y;
      width = v45.size.width;
      height = v45.size.height;
      *(v21 - 1) = CGRectGetMinX(v45);
      v46.origin.x = x;
      v46.origin.y = y;
      v46.size.width = width;
      v46.size.height = height;
      *v21 = CGRectGetMaxX(v46);
      v21 += 2;
      v20 = (void *)objc_msgSend(v18, "nextObject");
    }
    while (v20);
  }
  v26 = 0;
  v27 = v19 - 1;
  v28 = 1;
  do
  {
    if (v28 != 1)
    {
      MinX = *v27;
      v51.origin.x = a3;
      v51.origin.y = a4;
      v51.size.width = a5;
      v51.size.height = a6;
      MinY = CGRectGetMinY(v51);
      v33 = v27[1] - *v27;
      goto LABEL_13;
    }
    v29 = *v19;
    v47.origin.x = a3;
    v47.origin.y = a4;
    v47.size.width = a5;
    v47.size.height = a6;
    if (v29 > CGRectGetMinX(v47))
    {
      v48.origin.x = a3;
      v48.origin.y = a4;
      v48.size.width = a5;
      v48.size.height = a6;
      MinX = CGRectGetMinX(v48);
      v49.origin.x = a3;
      v49.origin.y = a4;
      v49.size.width = a5;
      v49.size.height = a6;
      MinY = CGRectGetMinY(v49);
      v32 = *v19;
      v50.origin.x = a3;
      v50.origin.y = a4;
      v50.size.width = a5;
      v50.size.height = a6;
      v33 = v32 - CGRectGetMinX(v50);
LABEL_13:
      v52.origin.x = a3;
      v52.origin.y = a4;
      v52.size.width = a5;
      v52.size.height = a6;
      v34 = CGRectGetHeight(v52);
      v35 = &a2[4 * v26];
      *v35 = MinX;
      v35[1] = MinY;
      ++v26;
      v35[2] = v33;
      v35[3] = v34;
    }
    if (v28 >= v17)
      break;
    ++v28;
    v27 += 2;
  }
  while (v26 < 0x80);
  v36 = &v19[2 * v17];
  v38 = *(v36 - 1);
  v37 = v36 - 1;
  v53.origin.x = a3;
  v53.origin.y = a4;
  v53.size.width = a5;
  v53.size.height = a6;
  if (v38 < CGRectGetMaxX(v53) && v26 < 0x80)
  {
    v39 = *v37;
    v54.origin.x = a3;
    v54.origin.y = a4;
    v54.size.width = a5;
    v54.size.height = a6;
    v40 = CGRectGetMinY(v54);
    v55.origin.x = a3;
    v55.origin.y = a4;
    v55.size.width = a5;
    v55.size.height = a6;
    v41 = CGRectGetMaxX(v55) - *v37;
    v56.origin.x = a3;
    v56.origin.y = a4;
    v56.size.width = a5;
    v56.size.height = a6;
    v42 = CGRectGetHeight(v56);
    v43 = &a2[4 * v26];
    *v43 = v39;
    v43[1] = v40;
    ++v26;
    v43[2] = v41;
    v43[3] = v42;
  }
  free(v19);
  return v26;
}

CGFloat xIntersection(double a1, CGPoint a2, CGPoint a3)
{
  return a3.x + (a1 - a3.y) / (a2.y - a3.y) * (a2.x - a3.x);
}

uint64_t TSWPTextWrapMarkerCompare(double *a1, double *a2)
{
  double v2;
  double v3;

  v2 = a1[1];
  v3 = a2[1];
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  else
    return v2 > v3;
}

void sub_217B28938(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, TSWPParagraphEnumerator *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a21);
  _Unwind_Resume(a1);
}

void std::shared_ptr<TSWPLineFragmentArray>::reset[abi:ne180100]<TSWPLineFragmentArray,void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  std::shared_ptr<TSWPLineFragmentArray>::shared_ptr[abi:ne180100]<TSWPLineFragmentArray,void>(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void std::shared_ptr<TSWPLineFragmentArray>::reset[abi:ne180100](_QWORD *a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)a1[1];
  *a1 = 0;
  a1[1] = 0;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void sub_217B2AF2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_217B2B150(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_217B2B2C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_217B2C198(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *__p,uint64_t a51)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_217B2D624(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_217B2D6C8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 40);
  if (v3)
  {
    *(_QWORD *)(v1 - 32) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void TSWPDrawingState::~TSWPDrawingState(TSWPDrawingState *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 15);
  if (v2)
  {
    *((_QWORD *)this + 16) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 12);
  if (v3)
  {
    *((_QWORD *)this + 13) = v3;
    operator delete(v3);
  }
}

_QWORD *std::shared_ptr<TSWPLineFragmentArray>::shared_ptr[abi:ne180100]<TSWPLineFragmentArray,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  void **v6;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_24D82DA10;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  v6 = 0;
  std::unique_ptr<TSWPLineFragmentArray>::reset[abi:ne180100](&v6, 0);
  return a1;
}

void sub_217B2D908(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<TSWPLineFragmentArray>::reset[abi:ne180100]((void ***)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<TSWPLineFragmentArray *,std::shared_ptr<TSWPLineFragmentArray>::__shared_ptr_default_delete<TSWPLineFragmentArray,TSWPLineFragmentArray>,std::allocator<TSWPLineFragmentArray>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x219A153B8);
}

uint64_t std::default_delete<TSWPLineFragmentArray>::operator()[abi:ne180100](uint64_t a1, void **a2)
{
  uint64_t result;
  void **v4;

  if (a2)
  {
    v4 = a2;
    std::vector<std::shared_ptr<EQKit::OpticalKern::Edge::Segment const>>::__destroy_vector::operator()[abi:nn180100](&v4);
    return MEMORY[0x219A153B8](a2, 0x1020C40D1034F40);
  }
  return result;
}

void ***std::unique_ptr<TSWPLineFragmentArray>::reset[abi:ne180100](void ***result, void **a2)
{
  void **v2;
  void **v3;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v3 = v2;
    std::vector<std::shared_ptr<EQKit::OpticalKern::Edge::Segment const>>::__destroy_vector::operator()[abi:nn180100](&v3);
    return (void ***)MEMORY[0x219A153B8](v2, 0x1020C40D1034F40);
  }
  return result;
}

void std::vector<TSWPAdornmentRect>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 56;
        std::allocator<TSWPAdornmentRect>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<TSWPAdornmentRect>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{

}

__n128 std::vector<TSWPAdornmentRect>::__construct_one_at_end[abi:ne180100]<TSWPAdornmentRect const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __n128 result;

  v4 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)v4 = *(_DWORD *)a2;
  *(_QWORD *)(v4 + 8) = *(id *)(a2 + 8);
  *(_QWORD *)(v4 + 16) = *(id *)(a2 + 16);
  result = *(__n128 *)(a2 + 24);
  *(_OWORD *)(v4 + 40) = *(_OWORD *)(a2 + 40);
  *(__n128 *)(v4 + 24) = result;
  *(_QWORD *)(a1 + 8) = v4 + 56;
  return result;
}

void sub_217B2DAFC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPAdornmentRect>::__push_back_slow_path<TSWPAdornmentRect const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  id v11;
  char *v12;
  __int128 v13;
  uint64_t v14;
  void *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t *v20;

  v3 = *a1;
  v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x492492492492492)
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x249249249249249)
    v9 = 0x492492492492492;
  else
    v9 = v5;
  v20 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPAdornmentRect>>(v7, v9);
  else
    v10 = 0;
  v16 = v10;
  v17 = &v10[56 * v4];
  v18 = v17;
  v19 = &v10[56 * v9];
  *(_DWORD *)v17 = *(_DWORD *)a2;
  *(_QWORD *)&v10[56 * v4 + 8] = *(id *)(a2 + 8);
  v11 = *(id *)(a2 + 16);
  v12 = &v10[56 * v4];
  *((_QWORD *)v12 + 2) = v11;
  v13 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(v12 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(v12 + 24) = v13;
  v18 += 56;
  std::vector<TSWPAdornmentRect>::__swap_out_circular_buffer(a1, &v16);
  v14 = a1[1];
  std::__split_buffer<TSWPAdornmentRect>::~__split_buffer(&v16);
  return v14;
}

void sub_217B2DC44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSWPAdornmentRect>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPAdornmentRect>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPAdornmentRect>,std::reverse_iterator<TSWPAdornmentRect*>,std::reverse_iterator<TSWPAdornmentRect*>,std::reverse_iterator<TSWPAdornmentRect*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPAdornmentRect>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(56 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPAdornmentRect>,std::reverse_iterator<TSWPAdornmentRect*>,std::reverse_iterator<TSWPAdornmentRect*>,std::reverse_iterator<TSWPAdornmentRect*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  int v11;
  __int128 v12;
  uint64_t v13;
  _QWORD v15[3];
  char v16;
  __int128 v17;
  __int128 v18;

  v7 = a7;
  *(_QWORD *)&v18 = a6;
  *((_QWORD *)&v18 + 1) = a7;
  v17 = v18;
  v15[0] = a1;
  v15[1] = &v17;
  v15[2] = &v18;
  v16 = 0;
  if (a3 == a5)
  {
    v13 = a6;
  }
  else
  {
    v9 = a3;
    v10 = a3;
    do
    {
      v11 = *(_DWORD *)(v10 - 56);
      v10 -= 56;
      *(_DWORD *)(v7 - 56) = v11;
      *(_QWORD *)(v7 - 48) = *(id *)(v10 + 8);
      *(_QWORD *)(v7 - 40) = *(id *)(v9 - 40);
      v12 = *(_OWORD *)(v9 - 16);
      *(_OWORD *)(v7 - 32) = *(_OWORD *)(v9 - 32);
      *(_OWORD *)(v7 - 16) = v12;
      v7 = *((_QWORD *)&v18 + 1) - 56;
      *((_QWORD *)&v18 + 1) -= 56;
      v9 = v10;
    }
    while (v10 != a5);
    v13 = v18;
  }
  v16 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentRect>,std::reverse_iterator<TSWPAdornmentRect*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v15);
  return v13;
}

void sub_217B2DDD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentRect>,std::reverse_iterator<TSWPAdornmentRect*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentRect>,std::reverse_iterator<TSWPAdornmentRect*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentRect>,std::reverse_iterator<TSWPAdornmentRect*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<TSWPAdornmentRect>,std::reverse_iterator<TSWPAdornmentRect*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<TSWPAdornmentRect>::destroy[abi:ne180100](v3, v1);
      v1 += 56;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<TSWPAdornmentRect>::~__split_buffer(void **a1)
{
  std::__split_buffer<TSWPAdornmentRect>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<TSWPAdornmentRect>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 56;
    std::allocator<TSWPAdornmentRect>::destroy[abi:ne180100](v4, i - 56);
  }
}

char *std::vector<CGRect>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CGRect*>,std::__wrap_iter<CGRect*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  __int128 v27;
  __int128 v28;
  char *v29;
  uint64_t v30;
  char *v31;
  __int128 v32;
  __int128 v33;
  void *__p;
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 5)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 5);
    if (v14 >> 59)
      std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
    v15 = (__dst - (uint64_t)v13) >> 5;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 4 > v14)
      v14 = v16 >> 4;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFE0)
      v17 = 0x7FFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v39 = v9;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::polygon::segment_data<double>>>(v9, v17);
    else
      v18 = 0;
    v29 = &v18[32 * v15];
    __p = v18;
    v36 = v29;
    v38 = &v18[32 * v17];
    v30 = 32 * a5;
    v31 = &v29[32 * a5];
    do
    {
      v32 = *(_OWORD *)v7;
      v33 = *((_OWORD *)v7 + 1);
      v7 += 32;
      *(_OWORD *)v29 = v32;
      *((_OWORD *)v29 + 1) = v33;
      v29 += 32;
      v30 -= 32;
    }
    while (v30);
    v37 = v31;
    v5 = (char *)std::vector<CGRect>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v37 != v36)
      v37 += (v36 - v37 + 31) & 0xFFFFFFFFFFFFFFE0;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 5;
  if (v20 >= a5)
  {
    v21 = &__src[32 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[32 * a5];
    v25 = &v23[-32 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_OWORD *)v25;
        v28 = *((_OWORD *)v25 + 1);
        v25 += 32;
        *(_OWORD *)v26 = v27;
        *((_OWORD *)v26 + 1) = v28;
        v26 += 32;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-32 * ((v23 - v24) >> 5)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[32 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[32 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_217B2E0B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *std::vector<CGRect>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  void *v5;
  char *v6;
  void *v7;
  char *v8;
  uint64_t v9;
  __int128 v10;
  _BYTE *v11;
  uint64_t v12;
  int64_t v13;
  char *v14;
  void *v15;
  void *v16;

  v5 = *(void **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v9 = *(_QWORD *)(a2 + 8);
    do
    {
      v10 = *((_OWORD *)v8 - 1);
      v7 = (void *)(v9 - 32);
      *(_OWORD *)(v9 - 32) = *((_OWORD *)v8 - 2);
      *(_OWORD *)(v9 - 16) = v10;
      v8 -= 32;
      v9 -= 32;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v11 = a1[1];
  v12 = *(_QWORD *)(a2 + 16);
  v13 = v11 - __src;
  if (v11 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v11 - __src);
    v7 = *(void **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v12 + v13;
  v14 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v14;
  v15 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v15;
  v16 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v16;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

BOOL attributeCompareFunction(const TSWPAttributeRecord *a1, unint64_t a2)
{
  return *(_QWORD *)a1 < a2;
}

TSWPAttributeArray *TSWPAttributeArray::setCapacity(TSWPAttributeArray *this, unint64_t a2)
{
  TSWPAttributeArray *v2;

  if (this->var2 < a2)
  {
    v2 = this;
    this->var3 = a2;
    this = (TSWPAttributeArray *)malloc_type_realloc(this->var4, 16 * a2, 0x10820408DE112D3uLL);
    v2->var4 = (TSWPAttributeRecord *)this;
  }
  return this;
}

unint64_t TSWPAttributeArray::exactAttributeIndexForCharIndex(TSWPAttributeArray *this, unint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;

  v4 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(this, a2);
  v5 = 0x7FFFFFFFFFFFFFFFLL;
  if (v4 != 0x7FFFFFFFFFFFFFFFLL)
  {
    v6 = v4;
    if (TSWPAttributeArray::charIndexForAttributeIndex(this, v4) == a2)
      return v6;
  }
  return v5;
}

void *TSWPAttributeArray::p_deleteAttributes(TSWPAttributeArray *this, unint64_t a2, uint64_t a3, TSWPStorageTransaction *a4)
{
  unint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *result;

  v8 = a3 + a2;
  if (a3 + a2 > this->var2)
  {
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPAttributeArray::p_deleteAttributes(TSWPAttributeIndex, TSWPAttributeCount, TSWPStorageTransaction *)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPAttributeArray.mm"), 355, CFSTR("deleteAttributes: bad input."));
  }
  if (v8 > a2)
  {
    v11 = 16 * a2;
    v12 = a3;
    do
    {
      (*((void (**)(TSWPAttributeArray *, char *, TSWPStorageTransaction *))this->var0 + 32))(this, (char *)this->var4 + v11, a4);
      (*((void (**)(TSWPAttributeArray *, char *))this->var0 + 24))(this, (char *)this->var4 + v11);
      v11 += 16;
      --v12;
    }
    while (v12);
  }
  result = memmove((char *)this->var4 + 16 * a2, (char *)this->var4 + 16 * v8, 16 * (this->var2 - v8));
  this->var2 -= a3;
  return result;
}

void TSWPAttributeArray::deleteAttributes(TSWPAttributeArray *this, unint64_t a2, unint64_t a3, TSWPStorageTransaction *a4)
{
  unsigned int var1;
  BOOL v9;
  int v10;
  BOOL v11;
  id v12;
  unint64_t v13;
  void *v14;
  id v15;
  char *v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  id *v26;
  id *v27;
  id v28;
  char *v29;
  char *v30;
  char *v31;

  var1 = this->var1;
  v9 = var1 > 0x11;
  v10 = (1 << var1) & 0x38100;
  v11 = v9 || v10 == 0;
  if (v11 || objc_msgSend(this->var5, "isDOLCSuppressed"))
  {
    TSWPAttributeArray::p_deleteAttributes(this, a2, a3, a4);
  }
  else if (a3 == 1)
  {
    v28 = (id)*((_QWORD *)this->var4 + 2 * a2 + 1);
    v12 = v28;
    TSWPAttributeArray::p_deleteAttributes(this, a2, 1, a4);
    (*((void (**)(TSWPAttributeArray *, id, TSWPStorageTransaction *))this->var0 + 33))(this, v28, a4);

  }
  else
  {
    v29 = 0;
    v30 = 0;
    v31 = 0;
    std::vector<objc_object *>::reserve((void **)&v29, a3);
    if (a3 + a2 > a2)
    {
      v13 = a2;
      do
      {
        v14 = (void *)*((_QWORD *)this->var4 + 2 * v13 + 1);
        if (v14)
        {
          v15 = v14;
          v16 = v30;
          if (v30 >= v31)
          {
            v18 = (v30 - v29) >> 3;
            if ((unint64_t)(v18 + 1) >> 61)
              abort();
            v19 = (v31 - v29) >> 2;
            if (v19 <= v18 + 1)
              v19 = v18 + 1;
            if ((unint64_t)(v31 - v29) >= 0x7FFFFFFFFFFFFFF8)
              v20 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v20 = v19;
            if (v20)
              v21 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>((uint64_t)&v31, v20);
            else
              v21 = 0;
            v22 = &v21[8 * v18];
            *(_QWORD *)v22 = v14;
            v17 = v22 + 8;
            v24 = v29;
            v23 = v30;
            if (v30 != v29)
            {
              do
              {
                v25 = *((_QWORD *)v23 - 1);
                v23 -= 8;
                *((_QWORD *)v22 - 1) = v25;
                v22 -= 8;
              }
              while (v23 != v24);
              v23 = v29;
            }
            v29 = v22;
            v30 = v17;
            v31 = &v21[8 * v20];
            if (v23)
              operator delete(v23);
          }
          else
          {
            *(_QWORD *)v30 = v14;
            v17 = v16 + 8;
          }
          v30 = v17;
        }
        ++v13;
      }
      while (v13 != a3 + a2);
    }
    TSWPAttributeArray::p_deleteAttributes(this, a2, a3, a4);
    v26 = (id *)v29;
    v27 = (id *)v30;
    if (v29 != v30)
    {
      do
      {
        (*((void (**)(TSWPAttributeArray *, id, TSWPStorageTransaction *))this->var0 + 33))(this, *v26, a4);

      }
      while (v26 != v27);
      v26 = (id *)v29;
    }
    if (v26)
    {
      v30 = (char *)v26;
      operator delete(v26);
    }
  }
}

void sub_217B2E60C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<objc_object *>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      abort();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLayoutContext *>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_QWORD *)v10 - 1);
        v10 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

TSWPAttributeArray *TSWPAttributeArray::replaceCharIndexForAttributeIndex(TSWPAttributeArray *this, uint64_t a2, uint64_t a3, TSWPStorageTransaction *a4)
{
  *((_QWORD *)this->var4 + 2 * a3) = a2;
  return this;
}

TSWPAttributeArray *TSWPAttributeArray::replaceObjectForAttributeIndexForShallowCopy(TSWPAttributeArray *this, objc_object *a2, uint64_t a3)
{
  char *v3;
  TSWPAttributeArray *v5;

  v3 = (char *)this->var4 + 16 * a3;
  if (*((objc_object **)v3 + 1) != a2)
  {
    v5 = this;
    (*((void (**)(TSWPAttributeArray *, char *))this->var0 + 24))(this, (char *)this->var4 + 16 * a3);
    *((_QWORD *)v3 + 1) = a2;
    return (TSWPAttributeArray *)(*((uint64_t (**)(TSWPAttributeArray *, char *))v5->var0 + 23))(v5, v3);
  }
  return this;
}

TSWPAttributeArray *TSWPAttributeArray::willBeAddedToDocumentRoot(TSWPAttributeArray *this, TSKDocumentRoot *a2, TSKAddedToDocumentContext *a3)
{
  unsigned int var1;
  BOOL v4;
  int v5;
  TSWPAttributeArray *v7;
  unint64_t var2;
  unint64_t v11;
  uint64_t v12;

  var1 = this->var1;
  v4 = var1 > 0x11;
  v5 = (1 << var1) & 0x38100;
  if (!v4 && v5 != 0)
  {
    v7 = this;
    var2 = this->var2;
    if (var2)
    {
      v11 = 0;
      v12 = 8;
      do
      {
        this = *(TSWPAttributeArray **)((char *)v7->var4 + v12);
        if (this)
        {
          this = (TSWPAttributeArray *)-[TSWPAttributeArray willBeAddedToDocumentRoot:context:](this, "willBeAddedToDocumentRoot:context:", a2, a3);
          var2 = v7->var2;
        }
        ++v11;
        v12 += 16;
      }
      while (v11 < var2);
    }
  }
  return this;
}

TSWPAttributeArray *TSWPAttributeArray::wasAddedToDocumentRoot(TSWPAttributeArray *this, TSKDocumentRoot *a2, TSKAddedToDocumentContext *a3)
{
  unsigned int var1;
  BOOL v4;
  int v5;
  TSWPAttributeArray *v7;
  unint64_t var2;
  unint64_t v11;
  uint64_t v12;

  var1 = this->var1;
  v4 = var1 > 0x11;
  v5 = (1 << var1) & 0x38100;
  if (!v4 && v5 != 0)
  {
    v7 = this;
    var2 = this->var2;
    if (var2)
    {
      v11 = 0;
      v12 = 8;
      do
      {
        this = *(TSWPAttributeArray **)((char *)v7->var4 + v12);
        if (this)
        {
          this = (TSWPAttributeArray *)-[TSWPAttributeArray wasAddedToDocumentRoot:context:](this, "wasAddedToDocumentRoot:context:", a2, a3);
          var2 = v7->var2;
        }
        ++v11;
        v12 += 16;
      }
      while (v11 < var2);
    }
  }
  return this;
}

TSWPAttributeArray *TSWPAttributeArray::willBeRemovedFromDocumentRoot(TSWPAttributeArray *this, TSKDocumentRoot *a2)
{
  unsigned int var1;
  BOOL v3;
  int v4;
  TSWPAttributeArray *v6;
  unint64_t var2;
  unint64_t v9;
  uint64_t v10;

  var1 = this->var1;
  v3 = var1 > 0x11;
  v4 = (1 << var1) & 0x38100;
  if (!v3 && v4 != 0)
  {
    v6 = this;
    var2 = this->var2;
    if (var2)
    {
      v9 = 0;
      v10 = 8;
      do
      {
        this = *(TSWPAttributeArray **)((char *)v6->var4 + v10);
        if (this)
        {
          this = (TSWPAttributeArray *)-[TSWPAttributeArray willBeRemovedFromDocumentRoot:](this, "willBeRemovedFromDocumentRoot:", a2);
          var2 = v6->var2;
        }
        ++v9;
        v10 += 16;
      }
      while (v9 < var2);
    }
  }
  return this;
}

TSWPAttributeArray *TSWPAttributeArray::wasRemovedFromDocumentRoot(TSWPAttributeArray *this, TSKDocumentRoot *a2)
{
  unsigned int var1;
  BOOL v3;
  int v4;
  TSWPAttributeArray *v6;
  unint64_t var2;
  unint64_t v9;
  uint64_t v10;

  var1 = this->var1;
  v3 = var1 > 0x11;
  v4 = (1 << var1) & 0x38100;
  if (!v3 && v4 != 0)
  {
    v6 = this;
    var2 = this->var2;
    if (var2)
    {
      v9 = 0;
      v10 = 8;
      do
      {
        this = *(TSWPAttributeArray **)((char *)v6->var4 + v10);
        if (this)
        {
          this = (TSWPAttributeArray *)-[TSWPAttributeArray wasRemovedFromDocumentRoot:](this, "wasRemovedFromDocumentRoot:", a2);
          var2 = v6->var2;
        }
        ++v9;
        v10 += 16;
      }
      while (v9 < var2);
    }
  }
  return this;
}

const char *TSWPAttributeArray::className(TSWPAttributeArray *this)
{
  return "TSWPAttributeArray";
}

void *TSWPAttributeArray::description(TSWPAttributeArray *this)
{
  void *v2;
  unsigned int var1;
  __CFString *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  const __CFString *v10;

  v2 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
  var1 = this->var1;
  if (var1 >= 0x13)
    v4 = (__CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("TSWPAttributeArrayKind-%lu"), this->var1);
  else
    v4 = off_24D82DB58[var1];
  objc_msgSend(v2, "appendFormat:", CFSTR("%s <%p> %@: Count: %lu.\n"), (*((uint64_t (**)(TSWPAttributeArray *))this->var0 + 22))(this), this, v4, this->var2);
  if (this->var2)
  {
    v5 = 0;
    v6 = 0;
    do
    {
      if ((*((unsigned int (**)(TSWPAttributeArray *))this->var0 + 3))(this))
        v7 = *((_QWORD *)this->var4 + 2 * v5 + 1);
      else
        v7 = 0;
      v8 = this->var1 - 13;
      v9 = TSWPAttributeArray::charIndexForAttributeIndex(this, v5);
      if (v8 >= 2)
        v10 = CFSTR("\t%d) CharIndex: %lu, Object: %p\n");
      else
        v10 = CFSTR("\t%d) CharIndex: %lu, Object: %@\n");
      objc_msgSend(v2, "appendFormat:", v10, v6, v9, v7);
      v5 = (v6 + 1);
      v6 = v5;
    }
    while (this->var2 > v5);
  }
  return v2;
}

uint64_t TSWPAttributeArray::canCollapseAttributes(TSWPAttributeArray *this, const TSWPAttributeRecord *a2, const TSWPAttributeRecord *a3)
{
  return 0;
}

uint64_t TSWPAttributeArray::canCollapseEmptyAttribute(TSWPAttributeArray *this, const TSWPAttributeRecord *a2)
{
  return 0;
}

BOOL TSWPAttributeArray::isEmpty(TSWPAttributeArray *this)
{
  return this->var2 == 0;
}

TSWPAttributeArray *TSWPAttributeArray::enumerateObjectAttributes(TSWPAttributeArray *this, uint64_t a2)
{
  TSWPAttributeArray *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  v3 = this;
  v4 = 0;
  v10 = 0;
  v5 = 8;
  do
  {
    if (v4 >= v3->var2)
      break;
    v6 = TSWPAttributeArray::rangeForAttributeIndex(v3, v4);
    v8 = v7;
    v9 = (*((unsigned int (**)(TSWPAttributeArray *))v3->var0 + 2))(v3) ? v8 : 1;
    this = (TSWPAttributeArray *)(*(uint64_t (**)(uint64_t, _QWORD, unint64_t, uint64_t, uint64_t, char *))(a2 + 16))(a2, *(_QWORD *)((char *)v3->var4 + v5), v4++, v6, v9, &v10);
    v5 += 16;
  }
  while (!v10);
  return this;
}

unint64_t TSWPAttributeArray::begin@<X0>(TSWPAttributeArray *this@<X0>, const _NSRange *a2@<X1>, TSWPAttributeArray **a3@<X8>)
{
  unint64_t result;
  unint64_t v6;

  result = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(this, a2->location);
  if (result == 0x7FFFFFFFFFFFFFFFLL)
    v6 = 0;
  else
    v6 = result;
  *a3 = this;
  a3[1] = (TSWPAttributeArray *)v6;
  return result;
}

unint64_t TSWPAttributeArray::end@<X0>(TSWPAttributeArray *this@<X0>, const _NSRange *a2@<X1>, TSWPAttributeArray **a3@<X8>)
{
  NSUInteger v6;
  unint64_t result;
  unint64_t var2;

  v6 = a2->length + a2->location;
  result = objc_msgSend(this->var5, "length");
  if (v6 == result)
  {
    var2 = this->var2;
  }
  else
  {
    result = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(this, v6 - (a2->length != 0));
    if (result == 0x7FFFFFFFFFFFFFFFLL)
      var2 = 0;
    else
      var2 = result + 1;
  }
  *a3 = this;
  a3[1] = (TSWPAttributeArray *)var2;
  return result;
}

uint64_t TSWPAttributeArray::ownsObjects(TSWPAttributeArray *this)
{
  return (this->var1 > 0x12) | (0x3F7FDu >> this->var1) & 1;
}

uint64_t TSWPAttributeArray::allowsNilObjects(TSWPAttributeArray *this)
{
  return 1;
}

uint64_t TSWPAttributeArray::supportsAttributeCollapsing(TSWPAttributeArray *this)
{
  return 0;
}

void sub_217B301A8(_Unwind_Exception *a1)
{
  CGColor *v1;

  CGColorRelease(v1);
  _Unwind_Resume(a1);
}

void sub_217B30460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  std::__list_imp<TSWPRepBoundsAnalyzer::Span>::clear((uint64_t *)va);
  _Unwind_Resume(a1);
}

void TSWPRepBoundsAnalyzer::addSingleColorBounds(TSWPRepBoundsAnalyzer *this, CGColor *a2, CGRect a3)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  double v9;
  _QWORD v10[2];
  CGColorRef color;
  char v12;
  CGRect v13;

  height = a3.size.height;
  width = a3.size.width;
  y = a3.origin.y;
  x = a3.origin.x;
  v9 = floor(CGRectGetMinY(a3));
  v13.origin.x = x;
  v13.origin.y = y;
  v13.size.width = width;
  v13.size.height = height;
  *(double *)v10 = v9;
  v10[1] = ceil(CGRectGetMaxY(v13));
  color = CGColorRetain(a2);
  v12 = 0;
  TSWPRepBoundsAnalyzer::insertSpan((uint64_t)this, (uint64_t)v10);
  CGColorRelease(color);
}

void sub_217B30540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CGColorRef color)
{
  CGColorRelease(color);
  _Unwind_Resume(a1);
}

void TSWPRepBoundsAnalyzer::addMultipleColorBounds(TSWPRepBoundsAnalyzer *this, CGRect a2)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  double v7;
  _QWORD v8[2];
  CGColorRef color;
  char v10;
  CGRect v11;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  v7 = floor(CGRectGetMinY(a2));
  v11.origin.x = x;
  v11.origin.y = y;
  v11.size.width = width;
  v11.size.height = height;
  *(double *)v8 = v7;
  v8[1] = ceil(CGRectGetMaxY(v11));
  color = CGColorRetain(0);
  v10 = 0;
  TSWPRepBoundsAnalyzer::insertSpan((uint64_t)this, (uint64_t)v8);
  CGColorRelease(color);
}

void sub_217B305E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CGColorRef color)
{
  CGColorRelease(color);
  _Unwind_Resume(a1);
}

void TSWPRepBoundsAnalyzer::finalize(uint64_t a1, uint64_t a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, double a7, double a8)
{
  uint64_t v16;
  CGColor *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  CGColor *v22;
  CGColor *v23;
  CGColor *v24;
  CGFloat v25;
  CGFloat Width;
  CGFloat v27;
  CGFloat v28;
  CGRect v29;
  CGRect v30;

  std::vector<TSWPRepBoundsAnalyzer::Info>::erase(a2, *(_QWORD *)a2, *(__int128 **)(a2 + 8));
  v16 = *(_QWORD *)(a1 + 8);
  v17 = *(CGColor **)(v16 + 32);
  if (v16 != a1)
  {
    v18 = *(_QWORD *)(a1 + 8);
    v19 = v18;
    while (1)
    {
      v20 = v19;
      v19 = v18;
      if (v18 != v20)
      {
        v21 = *(unsigned __int8 *)(v18 + 40);
        if (*(unsigned __int8 *)(v20 + 40) == v21)
        {
          v22 = *(CGColor **)(v20 + 32);
          v23 = *(CGColor **)(v19 + 32);
          if (v22 == v23 || CGColorEqualToColor(v22, v23))
            goto LABEL_16;
          v21 = *(unsigned __int8 *)(v19 + 40);
        }
        if (v21)
        {
          if (*(_BYTE *)(v20 + 40))
            goto LABEL_15;
          v24 = *(CGColor **)(v20 + 32);
          if (!v24)
            goto LABEL_15;
        }
        else if (!*(_BYTE *)(v20 + 40) || (v24 = *(CGColor **)(v19 + 32)) == 0)
        {
LABEL_15:
          v25 = *(double *)(v16 + 16);
          v29.origin.x = a3;
          v29.origin.y = a4;
          v29.size.width = a5;
          v29.size.height = a6;
          Width = CGRectGetWidth(v29);
          TSWPRepBoundsAnalyzer::insertTilesForRect(a1, (uint64_t *)a2, v17, a3, v25, Width, *(double *)(v20 + 24) - *(double *)(v16 + 16), a7, a8);
          v17 = *(CGColor **)(v19 + 32);
          v16 = v19;
          goto LABEL_16;
        }
        v17 = v24;
      }
LABEL_16:
      v18 = *(_QWORD *)(v19 + 8);
      if (v18 == a1)
        goto LABEL_19;
    }
  }
  v19 = a1;
  v16 = a1;
LABEL_19:
  v27 = *(double *)(v16 + 16);
  v30.origin.x = a3;
  v30.origin.y = a4;
  v30.size.width = a5;
  v30.size.height = a6;
  v28 = CGRectGetWidth(v30);
  TSWPRepBoundsAnalyzer::insertTilesForRect(a1, (uint64_t *)a2, v17, a3, v27, v28, *(double *)(v19 + 24) - *(double *)(v16 + 16), a7, a8);
}

void TSWPRepBoundsAnalyzer::TSWPRepBoundsAnalyzer(TSWPRepBoundsAnalyzer *this, CGRect a2)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  double MinY;
  _QWORD *v8;
  uint64_t v9;
  _QWORD v10[2];
  CGColorRef color;
  char v12;
  CGRect v13;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  *(_QWORD *)this = this;
  *((_QWORD *)this + 1) = this;
  *((_QWORD *)this + 2) = 0;
  MinY = CGRectGetMinY(a2);
  v13.origin.x = x;
  v13.origin.y = y;
  v13.size.width = width;
  v13.size.height = height;
  v10[0] = floor(MinY);
  v10[1] = ceil(CGRectGetMaxY(v13));
  color = CGColorRetain(0);
  v12 = 1;
  v8 = std::__list_imp<TSWPRepBoundsAnalyzer::Span>::__create_node[abi:nn180100]<TSWPRepBoundsAnalyzer::Span>((uint64_t)this, 0, 0, (uint64_t)v10);
  v9 = *(_QWORD *)this;
  *(_QWORD *)(v9 + 8) = v8;
  *v8 = v9;
  *(_QWORD *)this = v8;
  v8[1] = this;
  ++*((_QWORD *)this + 2);
  CGColorRelease(color);
}

void sub_217B30984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CGColorRef color)
{
  uint64_t *v11;

  CGColorRelease(color);
  std::__list_imp<TSWPRepBoundsAnalyzer::Span>::clear(v11);
  _Unwind_Resume(a1);
}

_QWORD *std::__list_imp<TSWPRepBoundsAnalyzer::Span>::__create_node[abi:nn180100]<TSWPRepBoundsAnalyzer::Span>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  CGColor *v8;

  v7 = operator new(0x30uLL);
  *v7 = a2;
  v7[1] = a3;
  *((_OWORD *)v7 + 1) = *(_OWORD *)a4;
  *((_BYTE *)v7 + 40) = *(_BYTE *)(a4 + 24);
  v8 = *(CGColor **)(a4 + 16);
  v7[4] = v8;
  CGColorRetain(v8);
  return v7;
}

void sub_217B30A04(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__list_imp<TSWPRepBoundsAnalyzer::Span>::clear(uint64_t *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;

  if (a1[2])
  {
    v2 = *a1;
    v3 = (uint64_t *)a1[1];
    v4 = *v3;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(*a1 + 8);
    **(_QWORD **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        v5 = (uint64_t *)v3[1];
        CGColorRelease((CGColorRef)v3[4]);
        operator delete(v3);
        v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void TSWPRepBoundsAnalyzer::insertSpan(uint64_t a1, uint64_t a2)
{
  double v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  CGColor *v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t *v20;
  CGColor *v21;
  uint64_t i;
  __int128 v23;
  double v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  CGColorRef color;
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v4 = *(double *)(a2 + 8);
  v24 = *(double *)a2;
  v5 = *(_QWORD *)(a1 + 8);
  v25 = 0;
  v6 = std::__lower_bound[abi:nn180100]<std::_ClassicAlgPolicy,std::__list_iterator<EQKit::StemStretch::FeatureRange::Span,void *>,std::__list_iterator<EQKit::StemStretch::FeatureRange::Span,void *>,double,std::__identity,std::__less<void,void>>(v5, a1, &v24);
  v7 = (uint64_t *)v6;
  if (v6 != a1)
  {
    v8 = 0;
    v9 = v6;
    while (*(double *)(v9 + 16) < v4)
    {
      v26 = 0;
      v27 = 0;
      v29 = 0;
      color = 0;
      v31 = 0;
      v32 = 0;
      v30 = 0;
      v33 = 0;
      v35 = 0;
      v36 = 0;
      v34 = 0;
      v37 = 0;
      v10 = TSWPRepBoundsAnalyzer::Span::split(v9 + 16, a2, (uint64_t)&v26);
      v11 = v10;
      if (v10)
      {
        v12 = v10 - 1;
        if (v10 == 1)
        {
          v13 = v26;
          v14 = v27;
          v15 = v29;
          v16 = color;
          CGColorRetain(color);
          *(_QWORD *)(v9 + 16) = v13;
          *(_QWORD *)(v9 + 24) = v14;
        }
        else
        {
          v17 = &v26;
          do
          {
            v18 = std::__list_imp<TSWPRepBoundsAnalyzer::Span>::__create_node[abi:nn180100]<TSWPRepBoundsAnalyzer::Span const&>(a1, 0, 0, (uint64_t)v17);
            v19 = *(_QWORD *)v9;
            *(_QWORD *)(v19 + 8) = v18;
            *v18 = v19;
            *(_QWORD *)v9 = v18;
            v18[1] = v9;
            ++*(_QWORD *)(a1 + 16);
            v17 += 4;
            --v12;
          }
          while (v12);
          v20 = &v26 + 4 * v11;
          v23 = *((_OWORD *)v20 - 2);
          v15 = *((_BYTE *)v20 - 8);
          v16 = (CGColor *)*(v20 - 2);
          CGColorRetain(v16);
          *(_OWORD *)(v9 + 16) = v23;
        }
        *(_BYTE *)(v9 + 40) = v15;
        v21 = *(CGColor **)(v9 + 32);
        *(_QWORD *)(v9 + 32) = v16;
        CGColorRelease(v21);
        v8 = 1;
      }
      for (i = 80; i != -16; i -= 32)
        CGColorRelease(*(CGColorRef *)((char *)&v26 + i));
      v9 = *(_QWORD *)(v9 + 8);
      if (v9 == a1)
      {
        v9 = a1;
        break;
      }
    }
    if ((v8 & 1) != 0)
      TSWPRepBoundsAnalyzer::collapse(a1, v7, v9);
  }
}

void sub_217B30C74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(exception_object);
}

uint64_t TSWPRepBoundsAnalyzer::Span::split(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  CGColor *v7;
  CGColor *v8;
  double v9;
  double v10;
  double v11;
  double v12;
  int v13;
  CGColor *v14;
  CGColor *v15;
  uint64_t v16;
  CGColorRef v18;
  CGColor *v19;
  uint64_t v20;
  int v21;
  CGColor *v22;
  CGColor *v23;
  _BOOL4 v24;
  CGColor *v25;
  int v26;
  CGColor *v27;
  int v28;
  BOOL v29;
  BOOL v30;
  CGColor *v31;
  uint64_t v32;
  int8x16_t v33;
  int8x16_t v34;
  CGColorRef v35;
  CGColor *v36;
  double v37;
  double v38;
  CGColor *v39;
  char v40;
  CGColorRef v41;
  uint64_t v42;
  CGColor *v43;
  CGColor *v44;
  char v45;
  CGColor *v46;
  CGColor *v47;
  _BOOL4 v48;
  int8x16_t v49;

  if (*(double *)(a2 + 8) <= *(double *)a1 || *(double *)a2 >= *(double *)(a1 + 8))
    return 0;
  v6 = *(unsigned __int8 *)(a1 + 24);
  if (v6 == *(unsigned __int8 *)(a2 + 24))
  {
    v7 = *(CGColor **)(a1 + 16);
    v8 = *(CGColor **)(a2 + 16);
    if (v7 == v8 || CGColorEqualToColor(v7, v8))
      return 0;
    v6 = *(unsigned __int8 *)(a1 + 24);
  }
  if (!v6 && !*(_QWORD *)(a1 + 16))
    return 0;
  v9 = *(double *)a1;
  v10 = *(double *)a2;
  if (*(double *)a1 == *(double *)a2)
  {
    v11 = *(double *)(a1 + 8);
    v12 = *(double *)(a2 + 8);
    if (v11 == v12)
    {
      if (v6)
      {
        v13 = *(unsigned __int8 *)(a2 + 24);
        v14 = *(CGColor **)(a2 + 16);
        if (v13 || v14)
        {
          CGColorRetain(v14);
          *(double *)a3 = v10;
          *(double *)(a3 + 8) = v12;
          *(_BYTE *)(a3 + 24) = v13;
LABEL_15:
          v15 = *(CGColor **)(a3 + 16);
          *(_QWORD *)(a3 + 16) = v14;
          CGColorRelease(v15);
          return 1;
        }
        goto LABEL_28;
      }
      v25 = *(CGColor **)(a1 + 16);
      if (!v25)
      {
        v27 = 0;
        goto LABEL_42;
      }
      v26 = *(unsigned __int8 *)(a2 + 24);
      v14 = *(CGColor **)(a2 + 16);
      if (!v26 && !v14)
      {
LABEL_28:
        v27 = *(CGColor **)(a1 + 16);
LABEL_42:
        CGColorRetain(v27);
        *(double *)a3 = v9;
        *(double *)(a3 + 8) = v11;
        *(_BYTE *)(a3 + 24) = v6;
        v44 = *(CGColor **)(a3 + 16);
        *(_QWORD *)(a3 + 16) = v27;
        CGColorRelease(v44);
        CGColorRelease(*(CGColorRef *)(a3 + 16));
        *(_QWORD *)(a3 + 16) = 0;
        *(_BYTE *)(a3 + 24) = 0;
        return 1;
      }
      if (v26)
      {
        v45 = 0;
LABEL_46:
        v46 = *(CGColor **)(a1 + 16);
        CGColorRetain(v46);
        *(double *)a3 = v9;
        *(double *)(a3 + 8) = v11;
        *(_BYTE *)(a3 + 24) = v45;
        v47 = *(CGColor **)(a3 + 16);
        *(_QWORD *)(a3 + 16) = v46;
        CGColorRelease(v47);
        CGColorRelease(*(CGColorRef *)(a3 + 16));
        v16 = 0;
        *(_QWORD *)(a3 + 16) = 0;
        *(_BYTE *)(a3 + 24) = 0;
        return v16;
      }
      if (v25 == v14)
      {
        v45 = 0;
      }
      else
      {
        v48 = CGColorEqualToColor(v25, v14);
        v9 = *(double *)a1;
        v11 = *(double *)(a1 + 8);
        v45 = *(_BYTE *)(a1 + 24);
        if (!v48)
          goto LABEL_46;
        v14 = *(CGColor **)(a1 + 16);
      }
      CGColorRetain(v14);
      *(double *)a3 = v9;
      *(double *)(a3 + 8) = v11;
      *(_BYTE *)(a3 + 24) = v45;
      goto LABEL_15;
    }
  }
  if (v9 >= v10)
  {
    v20 = 0;
  }
  else
  {
    v18 = CGColorRetain(*(CGColorRef *)(a1 + 16));
    *(double *)a3 = v9;
    *(double *)(a3 + 8) = v10;
    *(_BYTE *)(a3 + 24) = v6 != 0;
    v19 = *(CGColor **)(a3 + 16);
    *(_QWORD *)(a3 + 16) = v18;
    CGColorRelease(v19);
    v6 = *(unsigned __int8 *)(a1 + 24);
    v20 = 1;
  }
  v21 = *(unsigned __int8 *)(a2 + 24);
  if (v6 == v21)
  {
    v22 = *(CGColor **)(a1 + 16);
    v23 = *(CGColor **)(a2 + 16);
    if (v22 == v23)
    {
      v24 = 1;
      v21 = v6;
    }
    else
    {
      v24 = CGColorEqualToColor(v22, v23);
      v6 = *(unsigned __int8 *)(a1 + 24);
      v21 = *(unsigned __int8 *)(a2 + 24);
    }
  }
  else
  {
    v24 = 0;
  }
  if (v6)
    v28 = 1;
  else
    v28 = v24;
  if (v21)
    v29 = v6 != 0;
  else
    v29 = 0;
  v30 = v29 && v24;
  if (v28)
    v31 = *(CGColor **)(a2 + 16);
  else
    v31 = 0;
  v32 = a3 + 32 * v20;
  v33 = *(int8x16_t *)a2;
  v34.i64[0] = *(_QWORD *)a1;
  v34.i64[1] = *(_QWORD *)(a2 + 8);
  v33.i64[1] = *(_QWORD *)(a1 + 8);
  v49 = vbslq_s8((int8x16_t)vcgtq_f64(*(float64x2_t *)a1, *(float64x2_t *)a2), v34, v33);
  v35 = CGColorRetain(v31);
  *(int8x16_t *)v32 = v49;
  *(_BYTE *)(v32 + 24) = v30;
  v36 = *(CGColor **)(v32 + 16);
  *(_QWORD *)(v32 + 16) = v35;
  CGColorRelease(v36);
  v16 = v20 + 1;
  v37 = *(double *)(a2 + 8);
  v38 = *(double *)(a1 + 8);
  if (v37 < v38)
  {
    v39 = *(CGColor **)(a1 + 16);
    v40 = *(_BYTE *)(a1 + 24);
    v41 = CGColorRetain(v39);
    v42 = a3 + 32 * v16;
    *(double *)v42 = v37;
    *(double *)(v42 + 8) = v38;
    *(_BYTE *)(v42 + 24) = v40;
    v43 = *(CGColor **)(v42 + 16);
    *(_QWORD *)(v42 + 16) = v41;
    CGColorRelease(v43);
    return v20 | 2;
  }
  return v16;
}

uint64_t TSWPRepBoundsAnalyzer::collapse(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  CGColor *v7;
  CGColor *v8;

  v3 = a2;
  v4 = result;
  if (*(uint64_t **)(result + 8) != a2)
    v3 = (uint64_t *)*a2;
  v5 = result;
  if (a3 != result)
    v5 = *(_QWORD *)(a3 + 8);
  while (v3 != (uint64_t *)v5)
  {
    v6 = v3;
    v3 = (uint64_t *)v3[1];
    if (v3 != (uint64_t *)v4 && *((unsigned __int8 *)v6 + 40) == *((unsigned __int8 *)v3 + 40))
    {
      v7 = (CGColor *)v6[4];
      v8 = (CGColor *)v3[4];
      if (v7 == v8 || (result = CGColorEqualToColor(v7, v8), (_DWORD)result))
      {
        v3[2] = v6[2];
        result = std::list<TSWPRepBoundsAnalyzer::Span>::erase(v4, v6);
      }
    }
  }
  return result;
}

_QWORD *std::__list_imp<TSWPRepBoundsAnalyzer::Span>::__create_node[abi:nn180100]<TSWPRepBoundsAnalyzer::Span const&>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  CGColor *v8;

  v7 = operator new(0x30uLL);
  *v7 = a2;
  v7[1] = a3;
  *((_OWORD *)v7 + 1) = *(_OWORD *)a4;
  *((_BYTE *)v7 + 40) = *(_BYTE *)(a4 + 24);
  v8 = *(CGColor **)(a4 + 16);
  v7[4] = v8;
  CGColorRetain(v8);
  return v7;
}

void sub_217B310A0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::list<TSWPRepBoundsAnalyzer::Span>::erase(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *a2;
  v4 = a2[1];
  *(_QWORD *)(v3 + 8) = v4;
  *(_QWORD *)a2[1] = v3;
  --*(_QWORD *)(a1 + 16);
  CGColorRelease((CGColorRef)a2[4]);
  operator delete(a2);
  return v4;
}

uint64_t std::vector<TSWPRepBoundsAnalyzer::Info>::erase(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v10;

  if ((__int128 *)a2 != a3)
  {
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *>((uint64_t)&v10, a3, *(__int128 **)(a1 + 8), a2);
    v6 = v5;
    v7 = *(_QWORD *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        v8 = v7 - 40;
        CGColorRelease(*(CGColorRef *)(v7 - 8));
        v7 = v8;
      }
      while (v8 != v6);
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  return a2;
}

void TSWPRepBoundsAnalyzer::insertTilesForRect(int a1, uint64_t *a2, CGColorRef color, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, double a8, double a9)
{
  double v15;
  CGFloat v17;
  double MinY;
  double MaxY;
  double MinX;
  double v21;
  _OWORD *v22;
  _OWORD *v23;
  double v24;
  double v25;
  double v26;
  CGFloat v27;
  CGFloat v28;
  double v29;
  double v30;
  CGColorRef colora;
  CGRect v32;
  CGRect v33;
  CGRect v34;
  CGRect v35;
  CGRect v36;
  CGRect v37;
  CGRect v38;

  v15 = fmax(ceil(a9), 32.0);
  v26 = fmax(ceil(a8), 32.0);
  v24 = v15;
  if (a6 > v26 || a6 > v15)
  {
    v17 = a4;
    MinY = CGRectGetMinY(*(CGRect *)(&a5 - 1));
    v32.origin.x = a4;
    v32.origin.y = a5;
    v32.size.width = a6;
    v32.size.height = a7;
    MaxY = CGRectGetMaxY(v32);
    while (MinY < MaxY)
    {
      v33.origin.x = a4;
      v33.origin.y = a5;
      v33.size.width = a6;
      v33.size.height = a7;
      v25 = fmin(CGRectGetMaxY(v33), v24 + MinY);
      v34.origin.x = a4;
      v34.origin.y = a5;
      v34.size.width = a6;
      v34.size.height = a7;
      MinX = CGRectGetMinX(v34);
      v35.origin.x = a4;
      v35.origin.y = a5;
      v35.size.width = a6;
      v35.size.height = a7;
      if (MinX < CGRectGetMaxX(v35))
      {
        do
        {
          v21 = MinX;
          v36.origin.x = a4;
          v36.origin.y = a5;
          v36.size.width = a6;
          v36.size.height = a7;
          MinX = fmin(CGRectGetMaxX(v36), v26 + MinX);
          v22 = (_OWORD *)a2[1];
          v27 = v21;
          v28 = MinY;
          v29 = MinX - v21;
          v30 = v25 - MinY;
          colora = CGColorRetain(color);
          std::vector<TSWPRepBoundsAnalyzer::Info>::insert(a2, v22, (uint64_t)&v27);
          CGColorRelease(colora);
          v37.origin.x = a4;
          v37.origin.y = a5;
          v37.size.width = a6;
          v37.size.height = a7;
        }
        while (MinX < CGRectGetMaxX(v37));
      }
      v38.origin.x = a4;
      v38.origin.y = a5;
      v38.size.width = a6;
      v38.size.height = a7;
      MaxY = CGRectGetMaxY(v38);
      MinY = v25;
    }
  }
  else
  {
    v23 = (_OWORD *)a2[1];
    v27 = a4;
    v28 = a5;
    v29 = a6;
    v30 = a7;
    colora = CGColorRetain(color);
    std::vector<TSWPRepBoundsAnalyzer::Info>::insert(a2, v23, (uint64_t)&v27);
    CGColorRelease(colora);
  }
}

void sub_217B31360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CGColorRef color)
{
  CGColorRelease(color);
  _Unwind_Resume(a1);
}

__int128 *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *>(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  __int128 *v5;
  __int128 *v6;
  CGColorRef v7;
  CGColor *v8;
  __int128 v10;
  __int128 v11;

  v5 = a2;
  if (a2 == a3)
    return a2;
  v6 = a3;
  do
  {
    v10 = *v5;
    v11 = v5[1];
    v7 = CGColorRetain(*((CGColorRef *)v5 + 4));
    *(_OWORD *)a4 = v10;
    *(_OWORD *)(a4 + 16) = v11;
    v8 = *(CGColor **)(a4 + 32);
    *(_QWORD *)(a4 + 32) = v7;
    CGColorRelease(v8);
    a4 += 40;
    v5 = (__int128 *)((char *)v5 + 40);
  }
  while (v5 != v6);
  return v6;
}

_OWORD *std::vector<TSWPRepBoundsAnalyzer::Info>::insert(uint64_t *a1, _OWORD *a2, uint64_t a3)
{
  _OWORD *v4;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int128 v12;
  CGColorRef v13;
  __int128 v14;
  unint64_t v15;
  CGColor *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  __int128 v21;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;

  v4 = a2;
  v7 = *a1;
  v6 = a1[1];
  v8 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)a2 - *a1) >> 3);
  v11 = a1[2];
  v9 = (uint64_t)(a1 + 2);
  v10 = v11;
  if (v6 >= v11)
  {
    v17 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v6 - v7) >> 3) + 1;
    if (v17 > 0x666666666666666)
      abort();
    v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - v7) >> 3);
    if (2 * v18 > v17)
      v17 = 2 * v18;
    if (v18 >= 0x333333333333333)
      v19 = 0x666666666666666;
    else
      v19 = v17;
    v27 = v9;
    if (v19)
      v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<EQKit::StemStretch::Key,unsigned long>>>(v9, v19);
    else
      v20 = 0;
    v23 = v20;
    v24 = &v20[40 * v8];
    v25 = v24;
    v26 = &v20[40 * v19];
    std::__split_buffer<TSWPRepBoundsAnalyzer::Info>::push_back(&v23, a3);
    v4 = (_OWORD *)std::vector<TSWPRepBoundsAnalyzer::Info>::__swap_out_circular_buffer(a1, &v23, (uint64_t)v4);
    std::__split_buffer<TSWPRepBoundsAnalyzer::Info>::~__split_buffer((uint64_t)&v23);
  }
  else if (a2 == (_OWORD *)v6)
  {
    v21 = *(_OWORD *)(a3 + 16);
    *a2 = *(_OWORD *)a3;
    a2[1] = v21;
    *(_QWORD *)(v7 + 40 * v8 + 32) = CGColorRetain(*(CGColorRef *)(a3 + 32));
    a1[1] = (uint64_t)v4 + 40;
  }
  else
  {
    std::vector<TSWPRepBoundsAnalyzer::Info>::__move_range((uint64_t)a1, (uint64_t)a2, v6, (uint64_t)a2 + 40);
    v12 = *(_OWORD *)(a3 + 16);
    v28 = *(_OWORD *)a3;
    v29 = v12;
    v13 = CGColorRetain(*(CGColorRef *)(a3 + 32));
    v14 = v29;
    *v4 = v28;
    v4[1] = v14;
    v15 = v7 + 40 * v8;
    v16 = *(CGColor **)(v15 + 32);
    *(_QWORD *)(v15 + 32) = v13;
    CGColorRelease(v16);
  }
  return v4;
}

void sub_217B31580(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v11 + 8) = v10;
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<TSWPRepBoundsAnalyzer::Info>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v10;
  __int128 v11;
  char v13;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = a2 + v6 - a4;
  v8 = v6;
  if (v7 < a3)
  {
    v10 = a2 + v6 - a4;
    v8 = *(_QWORD *)(a1 + 8);
    do
    {
      v11 = *(_OWORD *)(v10 + 16);
      *(_OWORD *)v8 = *(_OWORD *)v10;
      *(_OWORD *)(v8 + 16) = v11;
      *(_QWORD *)(v8 + 32) = CGColorRetain(*(CGColorRef *)(v10 + 32));
      v8 += 40;
      v10 += 40;
    }
    while (v10 < a3);
  }
  *(_QWORD *)(a1 + 8) = v8;
  return std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *>((uint64_t)&v13, a2, v7, v6);
}

void sub_217B31640(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

CGColorRef std::__split_buffer<TSWPRepBoundsAnalyzer::Info>::push_back(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  __int128 *v5;
  int64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  unint64_t v17;
  int64_t v18;
  char *v19;
  uint64_t v20;
  __int128 v21;
  int64x2_t v22;
  char *v23;
  __int128 v24;
  CGColorRef result;
  char *v26;
  int64x2_t v27;
  char *v28;
  uint64_t v29;

  v4 = a1[2];
  if (v4 == a1[3])
  {
    v5 = (__int128 *)a1[1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == *a1)
        v10 = 1;
      else
        v10 = 0x999999999999999ALL * ((v4 - *a1) >> 3);
      v11 = v10 >> 2;
      v12 = a1[4];
      v29 = a1[4];
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<EQKit::StemStretch::Key,unsigned long>>>(v12, v10);
      v14 = &v13[40 * v11];
      v26 = v13;
      v27.i64[0] = (uint64_t)v14;
      v16 = &v13[40 * v15];
      v27.i64[1] = (uint64_t)v14;
      v28 = v16;
      v17 = a1[1];
      v18 = a1[2] - v17;
      if (v18)
      {
        v19 = &v14[40 * (v18 / 40)];
        v20 = 40 * (v18 / 40);
        do
        {
          v21 = *(_OWORD *)(v17 + 16);
          *(_OWORD *)v14 = *(_OWORD *)v17;
          *((_OWORD *)v14 + 1) = v21;
          *((_QWORD *)v14 + 4) = CGColorRetain(*(CGColorRef *)(v17 + 32));
          v14 += 40;
          v17 += 40;
          v20 -= 40;
        }
        while (v20);
        v13 = v26;
        v14 = (char *)v27.i64[0];
        v22 = *(int64x2_t *)(a1 + 1);
        v16 = v28;
      }
      else
      {
        v22 = vdupq_n_s64(v17);
        v19 = v14;
      }
      v26 = (char *)*a1;
      *a1 = v13;
      a1[1] = v14;
      v27 = v22;
      v23 = (char *)a1[3];
      a1[2] = v19;
      a1[3] = v16;
      v28 = v23;
      std::__split_buffer<TSWPRepBoundsAnalyzer::Info>::~__split_buffer((uint64_t)&v26);
      v4 = a1[2];
    }
    else
    {
      v6 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v5 - *a1) >> 3);
      if (v6 >= -1)
        v7 = v6 + 1;
      else
        v7 = v6 + 2;
      v8 = -5 * (v7 >> 1);
      std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *>((uint64_t)&v26, v5, (__int128 *)v4, (uint64_t)v5 - 40 * (v7 >> 1));
      v4 = v9;
      a1[1] += 8 * v8;
      a1[2] = v9;
    }
  }
  v24 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)v4 = *(_OWORD *)a2;
  *(_OWORD *)(v4 + 16) = v24;
  result = CGColorRetain(*(CGColorRef *)(a2 + 32));
  *(_QWORD *)(v4 + 32) = result;
  a1[2] += 40;
  return result;
}

void sub_217B317D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSWPRepBoundsAnalyzer::Info>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPRepBoundsAnalyzer::Info>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v3 = a3;
  v6 = a2[1];
  v7 = *a1;
  v8 = v6;
  if (*a1 != a3)
  {
    v9 = a3;
    v10 = a2[1];
    do
    {
      v8 = v10 - 40;
      v11 = v9 - 40;
      v12 = *(_OWORD *)(v9 - 40);
      *(_OWORD *)(v10 - 24) = *(_OWORD *)(v9 - 24);
      *(_OWORD *)(v10 - 40) = v12;
      *(_QWORD *)(v10 - 8) = CGColorRetain(*(CGColorRef *)(v9 - 8));
      v9 = v11;
      v10 -= 40;
    }
    while (v11 != v7);
  }
  a2[1] = v8;
  v13 = a1[1];
  v14 = a2[2];
  if (v13 != v3)
  {
    do
    {
      v15 = *(_OWORD *)(v3 + 16);
      *(_OWORD *)v14 = *(_OWORD *)v3;
      *(_OWORD *)(v14 + 16) = v15;
      *(_QWORD *)(v14 + 32) = CGColorRetain(*(CGColorRef *)(v3 + 32));
      v14 += 40;
      v3 += 40;
    }
    while (v3 != v13);
    v8 = a2[1];
  }
  a2[2] = v14;
  v16 = *a1;
  *a1 = v8;
  a2[1] = v16;
  v17 = a1[1];
  a1[1] = a2[2];
  a2[2] = v17;
  v18 = a1[2];
  a1[2] = a2[3];
  a2[3] = v18;
  *a2 = a2[1];
  return v6;
}

uint64_t std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *,TSWPRepBoundsAnalyzer::Info *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  CGColorRef v9;
  CGColor *v10;
  __int128 v12;
  __int128 v13;

  if (a3 != a2)
  {
    v7 = a3;
    do
    {
      v8 = v7 - 40;
      v12 = *(_OWORD *)(v7 - 40);
      v13 = *(_OWORD *)(v7 - 24);
      v9 = CGColorRetain(*(CGColorRef *)(v7 - 8));
      *(_OWORD *)(a4 - 40) = v12;
      *(_OWORD *)(a4 - 24) = v13;
      v10 = *(CGColor **)(a4 - 8);
      *(_QWORD *)(a4 - 8) = v9;
      CGColorRelease(v10);
      a4 -= 40;
      v7 = v8;
    }
    while (v8 != a2);
  }
  return a3;
}

uint64_t std::__split_buffer<TSWPRepBoundsAnalyzer::Info>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 40;
    CGColorRelease(*(CGColorRef *)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<TSWPRepBoundsAnalyzer::Info>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  CGColorRef *v2;
  CGColorRef *v4;
  void *v5;
  CGColorRef *v6;

  v1 = *a1;
  v2 = (CGColorRef *)**a1;
  if (v2)
  {
    v4 = (CGColorRef *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 5;
        CGColorRelease(*(v4 - 1));
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t _shapePackageStringByPresetKind(void)
{
  if (_shapePackageStringByPresetKindonceToken != -1)
    dispatch_once(&_shapePackageStringByPresetKindonceToken, &__block_literal_global_69);
  return _shapePackageStringByPresetKindsingleton;
}

id ___Z31_shapePackageStringByPresetKindv_block_invoke()
{
  id result;
  _QWORD v1[4];
  _QWORD v2[5];

  v2[4] = *MEMORY[0x24BDAC8D0];
  v1[0] = String;
  v1[1] = String;
  v2[0] = CFSTR("line");
  v2[1] = CFSTR("shape");
  v1[2] = String;
  v1[3] = TSWPFieldEditorPresetKind;
  v2[2] = CFSTR("textbox");
  v2[3] = CFSTR("fieldeditor");
  result = (id)objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v2, v1, 4);
  _shapePackageStringByPresetKindsingleton = (uint64_t)result;
  return result;
}

uint64_t _presetKindByShapePackageString(void)
{
  if (_presetKindByShapePackageStringonceToken != -1)
    dispatch_once(&_presetKindByShapePackageStringonceToken, &__block_literal_global_8);
  return _presetKindByShapePackageStringsingleton;
}

id ___Z31_presetKindByShapePackageStringv_block_invoke()
{
  void *v0;
  id result;

  v0 = (void *)MEMORY[0x24BDBCE70];
  if (_shapePackageStringByPresetKindonceToken != -1)
    dispatch_once(&_shapePackageStringByPresetKindonceToken, &__block_literal_global_69);
  result = (id)objc_msgSend(v0, "tsu_dictionaryByInvertingDictionary:", _shapePackageStringByPresetKindsingleton);
  _presetKindByShapePackageStringsingleton = (uint64_t)result;
  return result;
}

uint64_t TSWPShapePackageStringForPresetKind(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;

  if (_shapePackageStringByPresetKindonceToken != -1)
    dispatch_once(&_shapePackageStringByPresetKindonceToken, &__block_literal_global_69);
  v2 = objc_msgSend((id)_shapePackageStringByPresetKindsingleton, "objectForKeyedSubscript:", a1);
  if (!v2)
  {
    v3 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v4 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSWPShapePackageStringForPresetKind(TSSPresetKind)");
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPShapeInfo.mm"), 97, CFSTR("Unexpected preset kind %@ in TSWPShapeStylePackageStringForPresetKind()"), a1);
  }
  return v2;
}

uint64_t TSWPShapePresetKindForPackageString(void *a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;

  if (_presetKindByShapePackageStringonceToken != -1)
    dispatch_once(&_presetKindByShapePackageStringonceToken, &__block_literal_global_8);
  v2 = objc_msgSend((id)_presetKindByShapePackageStringsingleton, "objectForKeyedSubscript:", a1);
  if (!v2)
  {
    v2 = String;
    if ((objc_msgSend(a1, "isEqualToString:", CFSTR("tableName")) & 1) == 0)
    {
      v3 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v4 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSSPresetKind TSWPShapePresetKindForPackageString(NSString *)");
      objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPShapeInfo.mm"), 124, CFSTR("Unknown package string %@."), a1);
    }
  }
  return v2;
}

uint64_t TSWPLayoutChore::setStorageRange(TSWPLayoutChore *this, _NSRange a2)
{
  NSUInteger length;
  NSUInteger location;
  void *v5;
  uint64_t v6;
  __int128 v7;
  uint64_t result;
  uint64_t v9;
  TSWPParagraphEnumerator v10;

  length = a2.length;
  location = a2.location;
  *((_QWORD *)this + 8) = a2.location + a2.length;
  v5 = (void *)*((_QWORD *)this + 1);
  v6 = objc_msgSend(*((id *)this + 3), "styleProvider");
  if (v5)
    objc_msgSend(v5, "paragraphEnumeratorForCharRange:styleProvider:", location, length, v6);
  else
    memset(&v10, 0, sizeof(v10));
  v7 = *(_OWORD *)&v10.var2;
  *(_OWORD *)((char *)this + 104) = *(_OWORD *)&v10.var0;
  *(_OWORD *)((char *)this + 120) = v7;
  *(_OWORD *)((char *)this + 136) = *(_OWORD *)&v10.var4;
  *((_BYTE *)this + 152) = v10.var6;
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v10);
  result = objc_msgSend(*((id *)this + 1), "attachmentIndexRangeForTextRange:", 0, *((_QWORD *)this + 8));
  *((_QWORD *)this + 9) = v9;
  *((_QWORD *)this + 10) = location;
  return result;
}

uint64_t TSWPLayoutChore::pStyleProvider(id *this)
{
  return objc_msgSend(this[3], "styleProvider");
}

uint64_t TSWPLayoutChore::clearDelta(uint64_t this)
{
  *(_QWORD *)(this + 2048) = 0;
  return this;
}

TSWPTopicNumberHints *TSWPLayoutChore::setTopicNumbers(TSWPLayoutChore *this, TSWPTopicNumberHints *a2)
{
  TSWPTopicNumberHints *v3;

  v3 = (TSWPTopicNumberHints *)((char *)this + 816);
  TSWPTopicNumberHints::operator=((TSWPTopicNumberHints *)this + 17, a2);
  TSWPTopicNumberHints::advanceToCharIndex(v3, *((_QWORD *)this + 10), *((TSWPStorage **)this + 1));
  return TSWPTopicNumberHints::operator=((TSWPTopicNumberHints *)this + 16, v3);
}

uint64_t TSWPLayoutChore::pPerformIterativeAttachmentPositioning(uint64_t a1, _DWORD *a2, void *a3)
{
  uint64_t v5;
  TSWPDrawableAttachment *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  void *v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  void *v25;
  TSWPDrawableAttachment *v26;
  double v27;
  double v28;
  uint64_t v29;
  double v30;
  double v31;
  int v32;
  double v33;
  double v34;
  double v35;
  double v36;
  float v37;
  double v38;
  float v39;
  float v40;
  uint64_t v41;
  TSWPIterativeAttachmentPositioningState *v43;
  void *v44;
  TSWPIterativeAttachmentPositioningState *v45;
  void *v46;
  double v47;
  double v48;
  void *v49;
  double v50;
  double v51;
  double v52;
  char v55;
  unint64_t v56;

  if (objc_msgSend(*(id *)(a1 + 8), "attachmentCount"))
  {
    v5 = 0;
    v55 = 1;
    while (1)
    {
      v56 = 0;
      objc_msgSend(*(id *)(a1 + 8), "attachmentAtAttachmentIndex:outCharIndex:", v5, &v56);
      objc_opt_class();
      v6 = (TSWPDrawableAttachment *)TSUDynamicCast();
      v7 = objc_msgSend(*(id *)(a1 + 2056), "validatedLayoutForAnchoredDrawable:", -[TSWPDrawableAttachment drawable](v6, "drawable"));
      if (v6)
      {
        v8 = (void *)v7;
        v9 = objc_msgSend(*(id *)(a1 + 2056), "iterativeAttachmentPositioningMaxPassCount");
        v10 = (void *)objc_msgSend(v8, "iterativePositioningState");
        if (objc_msgSend(v10, "passCount") != v9 && !objc_msgSend(v8, "hasFinishedIterativePositioning"))
        {
          if ((objc_opt_respondsToSelector() & 1) != 0)
            objc_msgSend(a3, "drawableAttachment:willStartNewIterationWithIndex:", v6, objc_msgSend(v10, "passCount"));
          v11 = (void *)objc_msgSend(a3, "validatedLayoutForAnchoredDrawable:", -[TSWPDrawableAttachment drawable](v6, "drawable"));
          if (!objc_msgSend((id)objc_msgSend(a3, "columns"), "count"))
            goto LABEL_7;
          v12 = 0;
          while (1)
          {
            v13 = (void *)objc_msgSend((id)objc_msgSend(a3, "columns"), "objectAtIndex:", v12);
            v14 = objc_msgSend(v13, "range");
            if (v14 <= v56)
            {
              v15 = objc_msgSend(v13, "range");
              objc_msgSend(v13, "range");
              v17 = v16 + v15;
              v18 = v56;
              if (v17 > v56)
                break;
            }
            if (++v12 >= (unint64_t)objc_msgSend((id)objc_msgSend(a3, "columns"), "count"))
              goto LABEL_7;
          }
          v19 = (void *)objc_msgSend(v8, "iterativePositioningState");
          if (objc_msgSend(v19, "hasLoopInLastPasses"))
          {
            objc_msgSend(v19, "bestPosition");
            v21 = v20;
            v23 = round(v22 + 0.5);
            objc_msgSend(v8, "finishIterativePositioning");
            if (v23 < 0.0)
            {
              *(double *)(a1 + 744) = -v23;
              v23 = 0.0;
            }
            objc_msgSend(v19, "smallestMismatch");
            objc_msgSend(v19, "setPosition:mismatch:", v21, v23, v24);
            if ((objc_opt_respondsToSelector() & 1) != 0)
            {
              v25 = a3;
              v26 = v6;
              v27 = v21;
              v28 = v23;
              goto LABEL_39;
            }
          }
          else
          {
            if (v18)
              v29 = v18 - 1;
            else
              v29 = 1;
            objc_msgSend(v13, "topOfLineAtCharIndex:", v29);
            v31 = TSWPLayoutChore::pAdjustAnchorYPositionForVerticalAlignment((id *)a1, v6, v29, v30);
            if ((objc_opt_respondsToSelector() & 1) != 0)
              v32 = objc_msgSend(a3, "drawableAttachment:withLayout:shouldPositionIterativelyInColumn:", v6, v8, v13);
            else
              v32 = 1;
            -[TSWPDrawableAttachment attachmentAnchorY](v6, "attachmentAnchorY");
            v34 = v33;
            objc_msgSend(v11, "frame");
            v36 = v31 - v34 * v35;
            v37 = v36;
            *(float *)&v34 = roundf(v37);
            objc_msgSend(v11, "frame");
            v39 = v38;
            v40 = roundf(v39);
            v41 = objc_msgSend(v8, "iterativePositioningState");
            if (*(float *)&v34 == v40 || v32 == 0)
            {
              if (!v41)
              {
                if ((objc_opt_respondsToSelector() & 1) != 0)
                  objc_msgSend(a3, "startedIterativePositioningProcessForDrawableAttachment:", v6);
                v43 = objc_alloc_init(TSWPIterativeAttachmentPositioningState);
                objc_msgSend(v8, "setIterativePositioningState:", v43);

              }
              objc_msgSend(v8, "finishIterativePositioning");
              v44 = (void *)objc_msgSend(v8, "iterativePositioningState");
              objc_msgSend(v11, "frame");
              objc_msgSend(v44, "setPosition:mismatch:");
              if ((objc_opt_respondsToSelector() & 1) != 0)
              {
                objc_msgSend(v11, "frame");
                v25 = a3;
                v26 = v6;
LABEL_39:
                objc_msgSend(v25, "drawableAttachment:didFinalizePosition:", v26, v27, v28);
              }
            }
            else
            {
              if (!v41)
              {
                if ((objc_opt_respondsToSelector() & 1) != 0)
                  objc_msgSend(a3, "startedIterativePositioningProcessForDrawableAttachment:", v6);
                v45 = objc_alloc_init(TSWPIterativeAttachmentPositioningState);
                objc_msgSend(v8, "setIterativePositioningState:", v45);

                v46 = (void *)objc_msgSend(v8, "iterativePositioningState");
                objc_msgSend(v11, "frame");
                objc_msgSend(v46, "setPosition:mismatch:");
              }
              objc_msgSend(v11, "frame");
              v48 = v36 - v47;
              v49 = (void *)objc_msgSend(v8, "iterativePositioningState");
              objc_msgSend(v11, "frame");
              v51 = v50;
              objc_msgSend(v11, "frame");
              objc_msgSend(v49, "setPosition:mismatch:", v51, v48 + v52, v48);
            }
          }
          v55 = 0;
          goto LABEL_7;
        }
        objc_msgSend(v8, "finishIterativePositioning");
      }
LABEL_7:
      if (++v5 >= (unint64_t)objc_msgSend(*(id *)(a1 + 8), "attachmentCount"))
        goto LABEL_47;
    }
  }
  v55 = 1;
LABEL_47:
  ++*a2;
  return v55 & 1;
}

id *TSWPLayoutChore::pRestoreStateFromOldState(TSWPLayoutChore *this, id *a2)
{
  id *v4;
  char v5;
  void *v6;
  uint64_t v7;
  id *result;
  unint64_t v10;
  __int16 v11;
  unint64_t v12;
  unint64_t v13;
  void *v14;
  uint64_t v15;

  v4 = (id *)((char *)this + 80);
  v5 = *((_BYTE *)this + 640);
  if ((id *)((char *)this + 80) == a2)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPLayoutChore::pRestoreStateFromOldState(const TSWPLayoutState &)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 6152, CFSTR("We should not restore from our own object."));
  }
  if (a2[10] == *((id *)this + 20) && a2[11] == *((id *)this + 21))
  {
    v11 = *((_WORD *)this + 284);
    v12 = *((_QWORD *)this + 73);
    result = TSWPLayoutState::operator=(v4, a2);
    *((_WORD *)this + 284) = v11;
    v10 = *((_QWORD *)this + 72);
    if (!v10)
    {
      *((_QWORD *)this + 72) = v12;
      v10 = v12;
    }
  }
  else
  {
    result = TSWPLayoutState::operator=(v4, a2);
    v10 = *((_QWORD *)this + 72);
  }
  *((_BYTE *)this + 640) = v5;
  v13 = *((_QWORD *)this + 21);
  if (v10 > v13 || *((_QWORD *)this + 73) > v13)
  {
    v14 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v15 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPLayoutChore::pRestoreStateFromOldState(const TSWPLayoutState &)");
    return (id *)objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", v15, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 6175, CFSTR("Bad _typesetterCharIndex"));
  }
  return result;
}

BOOL TSWPLayoutChore::pIsLayingOutBody(TSWPLayoutChore *this)
{
  return *((_DWORD *)this + 14) == 0;
}

unint64_t TSWPLayoutChore::pUpdateSmartFieldsForCurrentColumn(id *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t result;

  v2 = objc_msgSend(a1[23], "range");
  v4 = v3;
  result = objc_msgSend(a1[1], "characterCount");
  if (v2 + v4 < result)
    return TSWPLayoutChore::pIsLastColumn(a1);
  return result;
}

uint64_t TSWPLayoutChore::validatedLayoutForAnchoredAttachment(id *this, TSWPDrawableAttachment *a2)
{
  return objc_msgSend(this[257], "validatedLayoutForAnchoredDrawable:", -[TSWPDrawableAttachment drawable](a2, "drawable"));
}

uint64_t TSWPLayoutChore::protectedLayoutColumnsWithFlags(NSUInteger a1, char a2, unint64_t a3, uint64_t a4, void *a5)
{
  BOOL v7;
  __int16 v8;
  __int16 v9;

  v9 = 0;
  v8 = 0;
  v7 = 0;
  TSWPLayoutChore::pLayoutColumns(a1, a2, a3, a4, a5, &v9, (_BYTE *)&v8 + 1, (BOOL *)&v8, &v7);
  return objc_msgSend(a5, "setNeedsDisplay");
}

uint64_t TSWPLayoutChore::pResetPrevLineBlockEnd(uint64_t this)
{
  uint64_t v1;
  unint64_t v2;

  v1 = this;
  if (*(_DWORD *)(this + 56) >= 3u)
  {
    this = *(_QWORD *)(this + 184);
    if (this)
      this = objc_msgSend((id)this, "frameBounds");
    else
      v2 = 0;
  }
  else
  {
    v2 = 0xFFF0000000000000;
  }
  *(_QWORD *)(v1 + 400) = v2;
  return this;
}

uint64_t TSWPLayoutChore::pCompareLineFragments(NSUInteger isDifferentFromLineFragment, TSWPLineFragmentArray **a2, TSWPLineFragmentArray **a3, TSWPColumn *a4, char a5, double a6)
{
  double v10;
  CGFloat v11;
  CGFloat v12;
  CGFloat v13;
  TSWPLineFragment **v14;
  TSWPLineFragment **v15;
  const TSWPLineFragment **v16;
  const TSWPLineFragment **v17;
  TSWPLineFragment *v18;
  const TSWPLineFragment *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  CGFloat v25;
  CGFloat v26;
  CGFloat v27;
  TSWPColumn *v28;
  int v29;
  double v30;
  double v31;
  double v32;
  int v33;
  unsigned int v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  NSUInteger v42;
  uint64_t v43;
  NSRange *v44;
  NSUInteger location;
  NSUInteger v46;
  NSRange v47;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double v52;
  double v53;
  double v54;
  NSRange *v55;
  double v56;
  CGFloat v57;
  double v58;
  double v59;
  double v60;
  CGFloat v61;
  TSWPLayoutChore *v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  NSUInteger v69;
  NSUInteger v70;
  NSRange *v72;
  CGAffineTransform v73;
  NSRange v74;
  CGRect v75;
  CGRect v76;
  CGRect v77;
  CGRect v78;
  CGRect v79;
  CGRect v80;
  CGRect v81;

  v72 = (NSRange *)isDifferentFromLineFragment;
  v10 = *MEMORY[0x24BDBF070];
  v11 = *(double *)(MEMORY[0x24BDBF070] + 8);
  v12 = *(double *)(MEMORY[0x24BDBF070] + 16);
  v13 = *(double *)(MEMORY[0x24BDBF070] + 24);
  v14 = *(TSWPLineFragment ***)*a3;
  v15 = (TSWPLineFragment **)*((_QWORD *)*a3 + 1);
  v17 = *(const TSWPLineFragment ***)*a2;
  v16 = (const TSWPLineFragment **)*((_QWORD *)*a2 + 1);
  while (1)
  {
    while (v14 != v15)
    {
      v18 = *v14;
      if (v17 == v16)
      {
        if (v18)
        {
          v33 = (*((unsigned __int8 *)v18 + 24) >> 3) & 1;
          goto LABEL_19;
        }
      }
      else
      {
        v19 = *v17;
        if (v18)
        {
          v34 = *((_DWORD *)v18 + 6);
          v33 = (v34 >> 3) & 1;
          if (!v19)
            goto LABEL_19;
          v35 = *((double *)v19 + 7);
          v36 = *((double *)v18 + 7);
          if (v35 < v36)
            goto LABEL_20;
          if (v35 > v36)
            goto LABEL_19;
          v37 = *((double *)v19 + 6);
          v38 = *((double *)v18 + 6);
          if (v37 < v38)
          {
LABEL_20:
            v20 = *((_QWORD *)v19 + 10);
            v21 = *((_QWORD *)v19 + 11);
            v22 = *((_QWORD *)v19 + 12);
            v23 = *((_QWORD *)v19 + 13);
            v24 = v10;
            v25 = v11;
            v26 = v12;
            v27 = v13;
            v28 = a4;
            v29 = (v34 >> 3) & 1;
            goto LABEL_10;
          }
          if (v37 <= v38)
          {
            if ((a5 & 0x40) == 0)
            {
              v42 = *(_QWORD *)v18;
              v43 = *((_QWORD *)v18 + 1);
              v44 = v72;
              location = v72[127].location;
              if (location == 0x7FFFFFFFFFFFFFFFLL)
                goto LABEL_26;
              v46 = v43 + v42;
              if (v43 + v42 >= location || v46 > v72[4].location)
              {
                v44 = v72;
                if (v46 <= v72[127].length + location)
                  goto LABEL_30;
LABEL_26:
                v69 = *((_QWORD *)v18 + 1);
                v70 = *(_QWORD *)v18;
                if (TSWPLineFragment::isDifferentFromLineFragment(v18, v19, v44[128].location))
                  goto LABEL_30;
                v74.length = v69;
                v74.location = v70;
                v47 = NSIntersectionRange(v74, v72[127]);
                isDifferentFromLineFragment = v47.location;
                if (v47.length)
                {
                  x = *((double *)v18 + 10);
                  y = *((double *)v18 + 11);
                  width = *((double *)v18 + 12);
                  height = *((double *)v18 + 13);
LABEL_31:
                  v77.origin.x = v10;
                  v77.origin.y = v11;
                  v77.size.width = v12;
                  v77.size.height = v13;
                  v10 = TSWPLayoutChore::pInvalidateRect((TSWPLayoutChore *)isDifferentFromLineFragment, v77, *(CGRect *)&x, a4, 1, v33);
                  v11 = v52;
                  v12 = v53;
                  v13 = v54;
                  goto LABEL_32;
                }
                goto LABEL_32;
              }
            }
            isDifferentFromLineFragment = TSWPLineFragment::isDifferentFromLineFragment(*v14, *v17, 0);
            if ((_DWORD)isDifferentFromLineFragment)
            {
LABEL_30:
              v76 = CGRectUnion(*(CGRect *)((char *)v19 + 80), *(CGRect *)((char *)v18 + 80));
              x = v76.origin.x;
              y = v76.origin.y;
              width = v76.size.width;
              height = v76.size.height;
              goto LABEL_31;
            }
LABEL_32:
            v14 += 2;
LABEL_11:
            v17 += 2;
          }
          else
          {
LABEL_19:
            v75.origin.x = v10;
            v75.origin.y = v11;
            v75.size.width = v12;
            v75.size.height = v13;
            v10 = TSWPLayoutChore::pInvalidateRect((TSWPLayoutChore *)isDifferentFromLineFragment, v75, *(CGRect *)((char *)v18 + 80), a4, 1, v33);
            v11 = v39;
            v12 = v40;
            v13 = v41;
            v14 += 2;
          }
        }
        else if (v19)
        {
          goto LABEL_9;
        }
      }
    }
    if (v17 == v16)
      break;
    v19 = *v17;
    if (*v17)
    {
LABEL_9:
      v20 = *((_QWORD *)v19 + 10);
      v21 = *((_QWORD *)v19 + 11);
      v22 = *((_QWORD *)v19 + 12);
      v23 = *((_QWORD *)v19 + 13);
      v24 = v10;
      v25 = v11;
      v26 = v12;
      v27 = v13;
      v28 = a4;
      v29 = 0;
LABEL_10:
      v10 = TSWPLayoutChore::pInvalidateRect((TSWPLayoutChore *)isDifferentFromLineFragment, *(CGRect *)&v24, *(CGRect *)&v20, v28, 1, v29);
      v11 = v30;
      v12 = v31;
      v13 = v32;
      goto LABEL_11;
    }
  }
  if (TSWPLineFragmentArray::count(*a2) && TSWPLineFragmentArray::count(*a3))
  {
    v55 = v72;
  }
  else
  {
    -[TSWPColumn wpBounds](a4, "wpBounds", v69, v70);
    v57 = v56;
    v59 = v58;
    v61 = v60;
    v62 = (TSWPLayoutChore *)-[TSWPColumn contentBottom](a4, "contentBottom");
    v55 = v72;
    if (v63 >= a6)
    {
      v62 = (TSWPLayoutChore *)-[TSWPColumn contentBottom](a4, "contentBottom");
      a6 = v64;
    }
    if (a6 - v59 != 0.0)
    {
      v78.origin.x = v10;
      v78.origin.y = v11;
      v78.size.width = v12;
      v78.size.height = v13;
      v81.origin.x = v57;
      v81.origin.y = v59;
      v81.size.width = v61;
      v81.size.height = a6 - v59;
      v10 = TSWPLayoutChore::pInvalidateRect(v62, v78, v81, a4, 1, 0);
      v11 = v65;
      v12 = v66;
      v13 = v67;
    }
  }
  if (a4)
    -[TSWPColumn transformFromWP](a4, "transformFromWP");
  else
    memset(&v73, 0, sizeof(v73));
  v79.origin.x = v10;
  v79.origin.y = v11;
  v79.size.width = v12;
  v79.size.height = v13;
  v80 = CGRectApplyAffineTransform(v79, &v73);
  return objc_msgSend((id)v55[128].length, "setNeedsDisplayInTargetRect:", v80.origin.x, v80.origin.y, v80.size.width, v80.size.height);
}

void TSWPAdornmentRect::~TSWPAdornmentRect(TSWPAdornmentRect *this)
{

}

id pChangeBarColorFillForLineFragment(TSWPLineFragment *a1)
{
  return +[TSDColorFill colorWithColor:](TSDColorFill, "colorWithColor:", TSWPLineFragment::changeAdornmentMarkupColor(a1));
}

double pChangeBarRectForLineFragment(uint64_t a1, void *a2, void *a3)
{
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  CGRect v18;
  CGRect v19;
  CGRect v20;

  objc_msgSend(a2, "wpBounds");
  v6 = v5;
  v8 = v7;
  if (a3)
  {
    objc_msgSend(a3, "adjustedInsets");
  }
  else
  {
    v9 = *MEMORY[0x24BDBF148];
    v10 = *(double *)(MEMORY[0x24BDBF148] + 8);
  }
  v11 = v6 + v9;
  v12 = v8 - TSDMultiplySizeScalar(v9, v10, 2.0);
  v13 = *(double *)(a1 + 56);
  v14 = *(double *)(a1 + 160) + *(double *)(a1 + 136) + *(double *)(a1 + 32) + *(double *)(a1 + 40) - v13;
  if ((*(_BYTE *)(a1 + 25) & 0x10) != 0)
  {
    v18.origin.x = v11;
    v18.origin.y = *(CGFloat *)(a1 + 56);
    v18.size.width = v12;
    v18.size.height = *(double *)(a1 + 160) + *(double *)(a1 + 136) + *(double *)(a1 + 32) + *(double *)(a1 + 40) - v13;
    CGRectGetMaxX(v18);
  }
  TSURound();
  v16 = v15;
  v19.origin.x = v11;
  v19.origin.y = v13;
  v19.size.width = v12;
  v19.size.height = v14;
  CGRectGetMinY(v19);
  TSURound();
  v20.origin.x = v11;
  v20.origin.y = v13;
  v20.size.width = v12;
  v20.size.height = v14;
  CGRectGetMaxY(v20);
  TSURound();
  return v16;
}

void pAddChangeBarAdornmentRect(void *a1, void *a2, void *a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  double v13;
  CGFloat v14;
  double v15;
  double v16;
  double v17;
  CGFloat v18;
  double v19;
  CGFloat v20;
  double v21;
  double v22;
  double v23;
  double MaxY;
  int v26;
  id v27;
  id v28;
  CGFloat v29;
  CGFloat v30;
  CGFloat v31;
  CGFloat v32;
  CGRect v33;
  CGRect v34;
  CGRect v35;
  CGRect v36;

  objc_msgSend(a1, "wpBounds");
  v14 = v13;
  v16 = v15;
  v18 = v17;
  v20 = v19;
  if (a2)
  {
    objc_msgSend(a2, "adjustedInsets");
    v22 = v21;
  }
  else
  {
    v22 = *(double *)(MEMORY[0x24BDBF148] + 8);
  }
  v33.origin.x = v14;
  v33.origin.y = v16;
  v33.size.width = v18;
  v33.size.height = v20;
  v23 = v22 + CGRectGetMaxY(v33) - v16;
  v34.origin.x = a4;
  v34.origin.y = a5;
  v34.size.width = a6;
  v34.size.height = a7;
  MaxY = CGRectGetMaxY(v34);
  v35.origin.x = v14;
  v35.origin.y = v16;
  v35.size.width = v18;
  v35.size.height = v23;
  if (MaxY > floor(CGRectGetMaxY(v35)))
  {
    v36.origin.x = v14;
    v36.origin.y = v16;
    v36.size.width = v18;
    v36.size.height = v23;
    a7 = floor(CGRectGetMaxY(v36)) - a5;
  }
  v26 = 3;
  v27 = 0;
  v28 = a3;
  v29 = a4;
  v30 = a5;
  v31 = a6;
  v32 = a7;
  objc_msgSend(a1, "addAdornmentRect:", &v26);

}

void sub_217B3448C(_Unwind_Exception *a1, TSWPAdornmentRect *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  TSWPAdornmentRect::~TSWPAdornmentRect((TSWPAdornmentRect *)&a10);
  _Unwind_Resume(a1);
}

TSWPLineFragment *TSWPLayoutChore::pFillAnchoredDrawableLineFragment@<X0>(uint64_t a1@<X0>, uint64_t **a2@<X1>, uint64_t **a3@<X2>, TSWPLineFragment **a4@<X8>, CGFloat a5@<D0>, CGFloat a6@<D1>, CGFloat a7@<D2>, CGFloat a8@<D3>)
{
  uint64_t *v15;
  unint64_t v16;
  double *v17;
  unint64_t v18;
  BOOL v19;
  BOOL v20;
  TSWPLineFragment *v21;
  TSWPLineFragment *v22;
  CGFloat MaxY;
  TSWPLineFragment *v24;
  CGFloat Height;
  TSWPLineFragment *v26;
  TSWPLineFragment *v27;
  TSWPLineFragment *result;
  CGRect v29;
  CGRect v30;

  *a4 = 0;
  a4[1] = 0;
  v15 = *a2;
  if (v15 == *a3)
    goto LABEL_19;
  v16 = *(_QWORD *)(a1 + 80);
  while (1)
  {
    v17 = (double *)*v15;
    v18 = *(_QWORD *)*v15;
    if (v18 >= v16)
      break;
    v15 += 2;
    *a2 = v15;
    if (v15 == *a3)
      goto LABEL_19;
  }
  v19 = *((_QWORD *)v17 + 25) == *((_QWORD *)v17 + 24) && v16 == v18;
  if (!v19
    || ((*((unsigned __int8 *)v17 + 25) >> 5) & 1) != (*(_BYTE *)(a1 + 32) & 0x10) >> 4
    || (v17[6] == *(double *)(a1 + 600) ? (v20 = v17[7] == *(double *)(a1 + 608)) : (v20 = 0),
        !v20
     || v17[8] != *(double *)(a1 + 616)
     || (std::shared_ptr<EQKit::StemStretch::Glyph>::operator=[abi:nn180100](a4, v15),
         TSWPLineFragment::setWasReused(*a4),
         (v21 = *a4) == 0)))
  {
LABEL_19:
    v22 = (TSWPLineFragment *)operator new();
    TSWPLineFragment::TSWPLineFragment(v22);
    std::shared_ptr<TSWPLineFragment>::reset[abi:ne180100]<TSWPLineFragment,void>(a4, (uint64_t)v22);
    v21 = *a4;
  }
  *(_QWORD *)v21 = *(_QWORD *)(a1 + 80);
  *((_QWORD *)v21 + 1) = 1;
  *((_DWORD *)v21 + 6) = 72;
  v29.origin.x = a5;
  v29.origin.y = a6;
  v29.size.width = a7;
  v29.size.height = a8;
  MaxY = CGRectGetMaxY(v29);
  v24 = *a4;
  *((CGFloat *)v24 + 4) = MaxY;
  *((CGFloat *)v24 + 6) = a5;
  *((CGFloat *)v24 + 7) = a6;
  *((CGFloat *)v24 + 8) = a7;
  *((CGFloat *)v24 + 9) = a8;
  *((CGFloat *)v24 + 10) = a5;
  *((CGFloat *)v24 + 11) = a6;
  *((CGFloat *)v24 + 12) = a7;
  *((CGFloat *)v24 + 13) = a8;
  *((_QWORD *)v24 + 14) = 0;
  *((_QWORD *)v24 + 15) = 0;
  v30.origin.x = a5;
  v30.origin.y = a6;
  v30.size.width = a7;
  v30.size.height = a8;
  Height = CGRectGetHeight(v30);
  v26 = *a4;
  *((CGFloat *)v26 + 16) = Height;
  *((_QWORD *)v26 + 22) = 0;
  *((_QWORD *)v26 + 52) = 0;
  *(_OWORD *)((char *)v26 + 136) = 0u;
  *(_OWORD *)((char *)v26 + 152) = 0u;
  TSWPCoreTextTypesetter::createLineRefForEmptyLineFragment(*(id **)(a1 + 2024), (id *)(a1 + 80), v26, 0, 0.0, 0.0);
  v27 = *a4;
  *((_QWORD *)v27 + 27) = 0;
  result = TSWPLineFragment::clearTypesetterState(v27);
  ++*(_QWORD *)(a1 + 80);
  return result;
}

void sub_217B34670(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<EQKit::StemStretch::Glyph>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void std::shared_ptr<TSWPLineFragment>::reset[abi:ne180100]<TSWPLineFragment,void>(_QWORD *a1, uint64_t a2)
{
  std::__shared_weak_count *v3;
  __int128 v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  __int128 v7;

  std::shared_ptr<TSWPLineFragment>::shared_ptr[abi:ne180100]<TSWPLineFragment,void>(&v7, a2);
  v3 = (std::__shared_weak_count *)a1[1];
  v4 = v7;
  *(_QWORD *)&v7 = *a1;
  *((_QWORD *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

double TSWPLayoutChore::pDropCapElevationHeight(id *this)
{
  uint64_t v2;
  id v3;
  const __CTFont *FontForStyle;
  void *v5;
  int v6;
  double v7;
  double Line;
  unint64_t v9;
  _OWORD v11[4];

  v2 = objc_msgSend((id)objc_msgSend(this[1], "textSourceForLayoutInRange:", this[20], this[21]), "characterStyleAtCharIndex:effectiveRange:", this[113], 0);
  v3 = this[22];
  FontForStyle = TSWPFastCreateFontForStyle(v2, v3, objc_msgSend(this[23], "scaleTextPercent"));
  v5 = (void *)objc_msgSend(v3, "valueForProperty:", 85);
  memset(v11, 0, sizeof(v11));
  v6 = objc_msgSend(v5, "mode", TSWPFontHeightInfoForFont(FontForStyle, v11));
  objc_msgSend(v5, "amount");
  Line = TSWPLineFragmentCalculateOffsetForNextLine((double *)v11, 0, v6, v7);
  v9 = (unint64_t)this[116];
  if (FontForStyle)
    CFRelease(FontForStyle);
  return Line * (double)v9;
}

void TSWPLayoutChore::pLayoutDropCap(uint64_t a1@<X0>, NSUInteger a2@<X1>, NSUInteger a3@<X2>, _OWORD *a4@<X5>, float64x2_t **a5@<X8>, CGFloat a6@<D0>, double a7@<D1>, double a8@<D2>, double a9@<D3>)
{
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  const __CTFont *FontForStyle;
  double v30;
  double v31;
  __CFString *v32;
  void *v33;
  int v34;
  double v35;
  double Line;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  TSWPLineFragment *v43;
  TSWPLineFragment *v44;
  int v45;
  double v46;
  double v47;
  double v48;
  double v49;
  uint64_t v50;
  double v51;
  double v52;
  CGFloat v53;
  CGFloat v54;
  CGFloat v55;
  double v56;
  double Height;
  double v58;
  CGFloat Width;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  TSWPLineFragment *v66;
  CGFloat x;
  CGFloat y;
  CGFloat v69;
  CGFloat v70;
  double v71;
  double MaxY;
  double MinY;
  double v74;
  double v75;
  double v76;
  double v77;
  double v78;
  float64x2_t *v79;
  double v80;
  float64x2_t v81;
  float64x2_t v82;
  double v83;
  double v84;
  float64_t v85;
  float64_t v86;
  float64x2_t v87;
  double MaxX;
  uint64_t v89;
  TSWPDropCapBackgroundAdornment *v90;
  TSWPDropCapBackgroundAdornment *v91;
  uint64_t v92;
  unint64_t i;
  uint64_t v94;
  std::__shared_weak_count *v95;
  unint64_t *p_shared_owners;
  unint64_t v97;
  double v98;
  double v99;
  double v100;
  double v101;
  double v102;
  CGFloat rect;
  double rect_8;
  CGFloat rect_8a;
  double rect_24;
  double v108;
  TSWPLineFragment *v109;
  std::__shared_weak_count *v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  _QWORD v115[2];
  _OWORD v116[9];
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  _NSRange v122;
  _NSRange v123;
  CGRect v124;
  CGRect v125;
  CGRect v126;
  CGRect v127;
  CGRect v128;
  CGRect v129;
  CGRect v130;
  CGRect v131;
  CGRect v132;
  CGRect v133;
  CGRect v134;
  CGRect v135;

  v16 = a4[11];
  v118 = a4[10];
  v119 = v16;
  v17 = a4[13];
  v120 = a4[12];
  v121 = v17;
  v18 = a4[7];
  v116[6] = a4[6];
  v116[7] = v18;
  v19 = a4[9];
  v116[8] = a4[8];
  v117 = v19;
  v20 = a4[3];
  v116[2] = a4[2];
  v116[3] = v20;
  v21 = a4[5];
  v116[4] = a4[4];
  v116[5] = v21;
  v22 = a4[1];
  v116[0] = *a4;
  v116[1] = v22;
  v23 = a1 + 864;
  v24 = *(_QWORD *)(a1 + 904);
  v25 = *(void **)(a1 + 864);
  v26 = (void *)objc_msgSend(*(id *)(a1 + 8), "textSourceForLayoutInRange:", *(_QWORD *)(a1 + 160), *(_QWORD *)(a1 + 168));
  v27 = objc_msgSend(v26, "characterStyleAtCharIndex:effectiveRange:", v24, 0);
  v28 = *(void **)(a1 + 176);
  FontForStyle = TSWPFastCreateFontForStyle(v27, v28, objc_msgSend(*(id *)(a1 + 184), "scaleTextPercent"));
  v115[0] = v24;
  v115[1] = 1;
  objc_msgSend(v26, "filteredCoreTextAttributesFontScaleEffectiveRange:filterDelegate:", v115, TSWPParagraphEnumerator::coreTextPropertiesFilterDelegate((TSWPParagraphEnumerator *)(a1 + 104)));
  if (v30 != 1.0 && v30 > 0.0 && FontForStyle)
  {
    v31 = v30 * CTFontGetSize(FontForStyle);
    v32 = (__CFString *)CTFontCopyPostScriptName(FontForStyle);
    CFRelease(FontForStyle);
    FontForStyle = (const __CTFont *)TSWPCreateFontWithName((uint64_t)v32, v31);

  }
  v113 = 0u;
  v114 = 0u;
  v111 = 0u;
  v112 = 0u;
  v33 = (void *)objc_msgSend(v28, "valueForProperty:", 85, TSWPFontHeightInfoForFont(FontForStyle, &v111));
  v34 = objc_msgSend(v33, "mode");
  objc_msgSend(v33, "amount");
  Line = TSWPLineFragmentCalculateOffsetForNextLine((double *)&v111, 0, v34, v35);
  if (*(_DWORD *)(a1 + 336) == 2)
  {
    v37 = *(double *)&v111 + *(double *)(a1 + 376) * *(double *)(a1 + 344);
    v38 = *(double *)&v112;
  }
  else
  {
    v38 = *(double *)&v112;
    v37 = *(double *)&v111 + *(double *)&v113 + fmax(*(double *)&v112, *((double *)&v111 + 1));
  }
  TSWPDropCapLayoutState::dropCapHeightWithGuess(v23, v37 + (double)(unint64_t)(*(_QWORD *)(a1 + 920) - 1) * Line);
  v40 = v39;
  TSWPDropCapLayoutState::lineCapHeightWithGuess(v23, *((double *)&v114 + 1));
  v42 = fmax(v37 - v41, 0.0);
  if ((*(_QWORD *)(a1 + 960) & 0x40) == 0)
    v42 = 0.0;
  rect_24 = v37;
  v108 = v42;
  v109 = 0;
  v110 = 0;
  v43 = (TSWPLineFragment *)operator new();
  TSWPLineFragment::TSWPLineFragment(v43);
  std::shared_ptr<TSWPLineFragment>::reset[abi:ne180100]<TSWPLineFragment,void>(&v109, (uint64_t)v43);
  v44 = v109;
  *((_QWORD *)v109 + 4) = 0;
  *((_QWORD *)&v120 + 1) = v44;
  *(_QWORD *)&v119 = a2;
  *((_QWORD *)&v119 + 1) = a3;
  *((_QWORD *)&v117 + 1) = 0;
  *(CGFloat *)(a1 + 600) = a6;
  *(double *)(a1 + 608) = a7;
  *(double *)(a1 + 616) = a8;
  *(double *)(a1 + 624) = a9;
  if (TSWPParagraphEnumerator::paragraphRunsRightToLeft((TSWPParagraphEnumerator *)(a1 + 104)))
    *((_DWORD *)v109 + 6) |= 0x1000u;
  v45 = *(_DWORD *)(a1 + 468);
  *(_DWORD *)(a1 + 468) = 4;
  TSWPCoreTextTypesetter::layoutLine(*(_QWORD *)(a1 + 2024), a1 + 80, (uint64_t)v116);
  v122.location = a2;
  v122.length = a3;
  v49 = TSWPLineFragment::glyphRectForLineRange(v109, v122, *(TSWPStorage **)(a1 + 184), 0);
  rect_8 = *(double *)(a1 + 952);
  v50 = *(_QWORD *)(a1 + 960);
  v102 = v38;
  if ((v50 & 1) != 0)
  {
    v53 = v46;
    v54 = v47;
    v55 = v48;
    v56 = v49;
    Height = CGRectGetHeight(*(CGRect *)(&v46 - 1));
    v58 = *(double *)(a1 + 888);
    v124.origin.x = v49;
    v124.origin.y = v53;
    v124.size.width = v54;
    v124.size.height = v55;
    Width = CGRectGetWidth(v124);
    v52 = Height / v58;
    v51 = Width / *(double *)(a1 + 888);
  }
  else
  {
    v51 = 0.0;
    if ((v50 & 2) != 0)
      v52 = *((double *)v109 + 21) / *(double *)(a1 + 888);
    else
      v52 = 0.0;
  }
  v60 = v40 - v108;
  v61 = fmax(v40 - v108 + rect_8 * -2.0, 1.0);
  v62 = v61 / v52;
  if (v52 == 0.0)
    v62 = 0.0;
  if (v51 == 0.0)
    v63 = 0.0;
  else
    v63 = v61 / v51;
  v64 = fmin(v62, v63);
  if (v63 == 0.0)
  {
    v63 = 1.0;
    v64 = v62;
  }
  if (v62 == 0.0)
    v65 = v63;
  else
    v65 = v64;
  v66 = (TSWPLineFragment *)operator new();
  TSWPLineFragment::TSWPLineFragment(v66);
  *a5 = 0;
  a5[1] = 0;
  std::shared_ptr<TSWPLineFragment>::reset[abi:ne180100]<TSWPLineFragment,void>(a5, (uint64_t)v66);
  (*a5)[2].f64[0] = 0.0;
  *(double *)(a1 + 888) = v65;
  TSWPLayoutChore::pSetupTypesetterIfNeeded((TSWPLayoutChore *)a1, *(CGSize *)(*(_QWORD *)(a1 + 2024) + 136), *MEMORY[0x24BDBF148]);
  *((_QWORD *)&v120 + 1) = *a5;
  *(_QWORD *)&v119 = a2;
  *((_QWORD *)&v119 + 1) = a3;
  if (TSWPParagraphEnumerator::paragraphRunsRightToLeft((TSWPParagraphEnumerator *)(a1 + 104)))
    LODWORD((*a5)[1].f64[1]) |= 0x1000u;
  *(_DWORD *)(a1 + 468) = 4;
  v101 = Line;
  *(_QWORD *)(a1 + 80) = TSWPCoreTextTypesetter::layoutLine(*(_QWORD *)(a1 + 2024), a1 + 80, (uint64_t)v116);
  *(_DWORD *)(a1 + 468) = v45;
  v123.location = a2;
  v123.length = a3;
  v125.origin.x = TSWPLineFragment::glyphRectForLineRange((TSWPLineFragment *)*a5, v123, *(TSWPStorage **)(a1 + 184), 0);
  x = v125.origin.x;
  y = v125.origin.y;
  v69 = v125.size.width;
  v70 = v125.size.height;
  if (CGRectIsEmpty(v125))
  {
    x = *MEMORY[0x24BDBF090];
    y = *(double *)(MEMORY[0x24BDBF090] + 8);
    v69 = *(double *)(MEMORY[0x24BDBF090] + 16);
    v70 = *(double *)(MEMORY[0x24BDBF090] + 24);
  }
  v71 = v60 - rect_24;
  if ((*(_BYTE *)(a1 + 960) & 1) != 0)
  {
    v126.origin.x = x;
    v126.origin.y = y;
    v126.size.width = v69;
    v126.size.height = v70;
    MaxY = CGRectGetMaxY(v126);
    v127.origin.x = x;
    v127.origin.y = y;
    v127.size.width = v69;
    v127.size.height = v70;
    v71 = v71 - MaxY + (v61 - CGRectGetHeight(v127)) * -0.5;
  }
  v128.origin.x = x;
  v128.origin.y = y;
  v128.size.width = v69;
  v128.size.height = v70;
  MinY = CGRectGetMinY(v128);
  v74 = v108 + v71 - rect_8;
  v75 = fmax(-fmin(MinY, 0.0) - v60, 0.0);
  *(double *)(a1 + 1064) = v75;
  (*a5)[2].f64[1] = v74 + v75;
  rect = x;
  v129.origin.x = x;
  v129.origin.y = y;
  v129.size.width = v69;
  v129.size.height = v70;
  v130 = CGRectInset(v129, -rect_8, -rect_8);
  v98 = v61;
  v99 = v130.origin.x;
  if ((*(_QWORD *)(a1 + 960) & 0x10) != 0)
  {
    v130.size.width = v60;
    v130.size.height = v60;
  }
  rect_8a = v130.origin.y;
  v76 = v130.size.width;
  v100 = v130.size.height;
  v77 = CGRectGetHeight(v130);
  v131.origin.x = rect;
  v131.origin.y = y;
  v131.size.width = v69;
  v131.size.height = v70;
  v78 = fmax(v77, CGRectGetMaxY(v131) + rect_24 + (*a5)[2].f64[0] + (*a5)[2].f64[1]);
  v79 = *a5;
  v80 = fmax(v101 - v102, 0.0);
  v81.f64[0] = v80 + v76;
  v82 = (*a5)[4];
  v79[4].f64[0] = v80 + v76;
  v79[4].f64[1] = v78;
  v81.f64[1] = v78;
  v79[6] = vaddq_f64(v79[6], vsubq_f64(v81, v82));
  v83 = v75 + *(double *)(a1 + 1056);
  v79[5].f64[1] = v79[5].f64[1] - v83;
  v79[3].f64[1] = v79[3].f64[1] - v83;
  v84 = 0.0;
  if ((*(_BYTE *)(a1 + 960) & 0x10) != 0)
  {
    v132.origin.x = rect;
    v132.origin.y = y;
    v132.size.width = v69;
    v132.size.height = v70;
    v84 = fmax((v98 - CGRectGetWidth(v132)) * 0.5, 0.0);
    v79 = *a5;
  }
  v85 = v79[12].f64[0];
  v86 = v79[12].f64[1];
  if (*(_QWORD *)&v85 != *(_QWORD *)&v86)
  {
    v87.f64[1] = 0.0;
    v87.f64[0] = a6 - v99 + 0.0 + v84;
    do
    {
      *(float64x2_t *)(*(_QWORD *)&v85 + 8) = vaddq_f64(v87, *(float64x2_t *)(*(_QWORD *)&v85 + 8));
      *(_QWORD *)&v85 += 48;
    }
    while (*(_QWORD *)&v85 != *(_QWORD *)&v86);
  }
  LODWORD(v79[1].f64[1]) |= 0x2000000u;
  v133.origin.x = a6;
  v133.origin.y = rect_8a;
  v133.size.width = v76;
  v133.size.height = v100;
  *(CGFloat *)(a1 + 1072) = CGRectGetWidth(v133);
  v134.origin.x = a6;
  v134.origin.y = rect_8a;
  v134.size.width = v76;
  v134.size.height = v100;
  MaxX = CGRectGetMaxX(v134);
  objc_msgSend(*(id *)(a1 + 184), "frameBounds");
  *(double *)(a1 + 1048) = v80 + MaxX - CGRectGetMinX(v135);
  *(double *)(a1 + 1040) = rect_24;
  objc_opt_class();
  objc_msgSend((id)objc_msgSend(v25, "characterStyleOverridePropertyMap"), "objectForProperty:", 38);
  v89 = TSUDynamicCast();
  if (v89)
  {
    v90 = [TSWPDropCapBackgroundAdornment alloc];
    v91 = -[TSWPDropCapBackgroundAdornment initWithColor:bounds:](v90, "initWithColor:bounds:", v89, TSDRectWithOriginAndSize(v90, 0.0, v108, v76, v100));
    TSWPLineFragment::appendAdornment((uint64_t)*a5, (uint64_t)v91);

    v92 = (uint64_t)*a5;
    *(_DWORD *)(v92 + 24) = LODWORD((*a5)[1].f64[1]) & 0xF7FFFFFF;
    TSWPLineFragment::setSingleColor((TSWPLineFragment *)v92, 0);
  }
  (*a5)[34].f64[0] = v108;
  for (i = *(_QWORD *)(a1 + 80); i < *(_QWORD *)(a1 + 168) + *(_QWORD *)(a1 + 160); *(_QWORD *)(a1 + 80) = i)
  {
    v94 = objc_msgSend(*(id *)(a1 + 8), "characterAtIndex:");
    if (!IsWhitespaceCharacter(v94) || (IsParagraphBreakingCharacter(v94) & 1) != 0)
      break;
    i = *(_QWORD *)(a1 + 80) + 1;
  }
  if (FontForStyle)
    CFRelease(FontForStyle);
  v95 = v110;
  if (v110)
  {
    p_shared_owners = (unint64_t *)&v110->__shared_owners_;
    do
      v97 = __ldaxr(p_shared_owners);
    while (__stlxr(v97 - 1, p_shared_owners));
    if (!v97)
    {
      ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
      std::__shared_weak_count::__release_weak(v95);
    }
  }
}

void sub_217B34FF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  std::shared_ptr<EQKit::StemStretch::Glyph>::~shared_ptr[abi:nn180100](v11);
  std::shared_ptr<EQKit::StemStretch::Glyph>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL TSWPLayoutChore::pSetupNextParagraph(TSWPLayoutChore *this)
{
  TSWPParagraphEnumerator *v2;
  _BOOL4 isLastParagraph;

  v2 = (TSWPParagraphEnumerator *)((char *)this + 104);
  isLastParagraph = TSWPParagraphEnumerator::isLastParagraph((TSWPParagraphEnumerator *)((char *)this + 104));
  if (!isLastParagraph)
  {
    TSWPParagraphEnumerator::operator++(v2);
    *((_QWORD *)this + 10) = TSWPParagraphEnumerator::paragraphTextRange(v2);
    *((_BYTE *)this + 411) = *((_BYTE *)this + 410);
    TSWPLayoutChore::pSetupStateForParagraphIndex(this, 0);
  }
  return !isLastParagraph;
}

id TSWPLayoutChore::pSetupTextSource(id *this)
{
  id result;

  result = this[1];
  this[35] = result;
  return result;
}

id *TSWPLayoutChore::pSetupStateForLineBalancing(id *this, id *a2, double a3, int a4, int a5, double a6)
{
  return TSWPLineBalancingLayoutState::prepareForRestore(a2, this + 10, (objc_msgSend(this[257], "autosizeFlags") & 0xC) != 0, a3, a4, a5, a6);
}

uint64_t TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(TSWPLayoutChore *this, CGFloat a2, CGSize a3, int a4, BOOL *a5)
{
  double height;
  double width;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  double v20;
  double v21;
  double v22;
  uint64_t v23;
  void *v24;
  BOOL v25;
  uint64_t v26;
  BOOL v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  void *v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  void *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const __CFString *v53;
  void *v54;
  uint64_t v55;
  uint64_t v56;
  int v58;
  uint64_t CharacterStyleAtCharIndex;
  const __CTFont *FontForStyle;
  double v61;
  double v62;
  BOOL v63;
  double v64;
  double v65;
  int v66;
  uint64_t Object;
  double MaxY;
  double v69;
  int v70;
  uint64_t v71;
  _QWORD rect[5];
  __int128 v73;
  __int128 v74;
  __int128 v75;
  BOOL v76;
  CGRect v77;

  height = a3.height;
  width = a3.width;
  if (!*((_QWORD *)this + 67))
  {
    v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPLineFragment *TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(CGFloat, CGSize, uint, BOOL &)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 4334, CFSTR("Bad _state.attachmentBeingPaginated"));
  }
  v13 = *((_QWORD *)this + 10);
  v14 = TSWPLayoutChore::pCalculateSpaceBefore(this, a4);
  if (a4)
    v15 = v14 + 1.0;
  else
    v15 = v14;
  objc_msgSend(*((id *)this + 23), "wpBounds");
  v17 = v16;
  rect[2] = v18;
  v19 = v15 + a2;
  v20 = *((double *)this + 36);
  if (width - (v20 + *((double *)this + 37)) >= 18.0)
    v21 = width - (v20 + *((double *)this + 37));
  else
    v21 = 18.0;
  if (height - v19 >= 0.0)
    v22 = height - v19;
  else
    v22 = 0.0;
  v76 = 0;
  if ((objc_opt_respondsToSelector() & 1) != 0)
    v23 = objc_msgSend(*((id *)this + 257), "parentLayoutForInlineAttachments");
  else
    v23 = 0;
  v24 = (void *)objc_msgSend(*((id *)this + 68), "nextLayoutForSize:parentLayout:previousHint:horizontally:outFinished:", v23, *((_QWORD *)this + 95), 0, &v76, v21, v22);
  v25 = (objc_opt_respondsToSelector() & 1) == 0
     || !objc_msgSend(*((id *)this + 2), "shouldAllowFinishingPartionedAttachmentLayout")
     || v76;
  v76 = v25;
  if (!v24)
  {
    v48 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v49 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPLineFragment *TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(CGFloat, CGSize, uint, BOOL &)");
    v52 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm");
    v53 = CFSTR("partitioner failed to create layout");
    v54 = (void *)v48;
    v55 = v49;
    v56 = 4361;
    goto LABEL_39;
  }
  v26 = objc_msgSend(v24, "parent");
  if (v26)
    v27 = v26 == v23;
  else
    v27 = 1;
  if (!v27)
  {
    v50 = objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v51 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPLineFragment *TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(CGFloat, CGSize, uint, BOOL &)");
    v52 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm");
    v53 = CFSTR("Partitioned layout already has a different parent.");
    v54 = (void *)v50;
    v55 = v51;
    v56 = 4368;
LABEL_39:
    objc_msgSend(v54, "handleFailureInFunction:file:lineNumber:description:", v55, v52, v56, v53);
    return 0;
  }
  rect[0] = v17;
  objc_msgSend(*((id *)this + 257), "addAttachmentLayout:", v24);
  objc_msgSend(v24, "validate");
  *a5 = !v76;
  objc_msgSend(v24, "frame");
  v29 = v28;
  objc_msgSend(v24, "alignmentFrame");
  v31 = v30;
  *(double *)&rect[1] = v32;
  if (v32 > v21 + 1.0)
  {
    v33 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v34 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPLineFragment *TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(CGFloat, CGSize, uint, BOOL &)");
    objc_msgSend(v33, "handleFailureInFunction:file:lineNumber:description:", v34, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 4381, CFSTR("%@ returned too wide a layout for a partitioned attachment (%g > %g)."), objc_opt_class(), rect[1], v21 + 1.0);
  }
  if (v29 <= 0.0)
  {
    v35 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v36 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPLineFragment *TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(CGFloat, CGSize, uint, BOOL &)");
    objc_msgSend(v35, "handleFailureInFunction:file:lineNumber:description:", v36, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 4385, CFSTR("Illegal partition layout height"));
  }
  v37 = operator new();
  TSWPLineFragment::TSWPLineFragment((TSWPLineFragment *)v37);
  v38 = *((_QWORD *)this + 67);
  *((_QWORD *)this + 70) = v24;
  *(_QWORD *)(v37 + 424) = v38;
  *(_QWORD *)(v37 + 432) = v24;
  *(double *)(v37 + 112) = v15;
  *(double *)(v37 + 120) = v31;
  *(double *)(v37 + 32) = v15 + v31 + a2;
  if (!*a5)
  {
    *((_QWORD *)this + 67) = 0;
    *((_QWORD *)this + 70) = 0;
    v39 = *((_QWORD *)this + 69);
    if (v39 == 0x7FFFFFFFFFFFFFFFLL)
    {
      v40 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v41 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPLineFragment *TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(CGFloat, CGSize, uint, BOOL &)");
      objc_msgSend(v40, "handleFailureInFunction:file:lineNumber:description:", v41, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 4409, CFSTR("Typesetter expected to have an attachmentCharIndex"));
      v39 = *((_QWORD *)this + 69);
    }
    v42 = v39 + 1;
    *((_QWORD *)this + 10) = v42;
    v43 = *((_QWORD *)this + 20);
    if (v42 < v43 || v42 > *((_QWORD *)this + 21) + v43)
    {
      v44 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v45 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPLineFragment *TSWPLayoutChore::pCreateAttachmentPartitionLineFragment(CGFloat, CGSize, uint, BOOL &)");
      objc_msgSend(v44, "handleFailureInFunction:file:lineNumber:description:", v45, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 4411, CFSTR("Bad _state.charIndex"));
    }
    *((_QWORD *)this + 69) = 0x7FFFFFFFFFFFFFFFLL;
    ++*((_QWORD *)this + 72);
  }
  v46 = *((_QWORD *)this + 10);
  if (v46 >= *((_QWORD *)this + 8))
  {
    v47 = 0;
  }
  else
  {
    v47 = objc_msgSend(*((id *)this + 1), "characterAtIndex:", *((_QWORD *)this + 10));
    v46 = *((_QWORD *)this + 10);
  }
  if (IsParagraphBreakingCharacter(v47))
    ++*((_QWORD *)this + 10);
  v58 = TSWPLayoutChore::pApplySpaceAfterToLineFragment(this, (const TSWPLineFragment *)v37, (TSWPLineFragment *)v37, v47, v46);
  *(double *)(v37 + 160) = *(double *)(v37 + 160) + 1.0;
  CharacterStyleAtCharIndex = TSWPLayoutChore::pGetCharacterStyleAtCharIndex((id *)this, *((_QWORD *)this + 10));
  FontForStyle = TSWPFastCreateFontForStyle(CharacterStyleAtCharIndex, *((void **)this + 22), objc_msgSend(*((id *)this + 23), "scaleTextPercent"));
  v74 = 0u;
  v75 = 0u;
  *(_OWORD *)&rect[3] = 0u;
  v73 = 0u;
  TSWPFontHeightInfoForFont(FontForStyle, &rect[3]);
  CFRelease(FontForStyle);
  v61 = *(double *)(v37 + 120) + *(double *)(v37 + 112) + *(double *)(v37 + 152) + *(double *)(v37 + 160);
  if (!*((_DWORD *)this + 84))
  {
    v62 = *((double *)this + 47);
    v63 = v62 <= 1.0;
    v64 = v62 + -1.0;
    if (!v63)
      v61 = v61 + v64 * (*(double *)&v74 + *(double *)&v73 + *((double *)&v73 + 1));
  }
  v65 = *(double *)&rect[1];
  if (*(double *)&rect[1] < v21)
  {
    v66 = *((_DWORD *)this + 117);
    if (v66 == 1)
    {
      v65 = v21 - *(double *)&rect[1];
    }
    else
    {
      if (v66 != 2)
        goto LABEL_53;
      v65 = (v21 - *(double *)&rect[1]) * 0.5;
    }
    v20 = v20 + v65;
  }
LABEL_53:
  Object = TSWPLineFragmentArray::lastObject(*(TSWPLineFragmentArray **)objc_msgSend(*((id *)this + 23), "lineFragmentArray", v65));
  if (Object)
  {
    MaxY = CGRectGetMaxY(*(CGRect *)(Object + 48));
    if (MaxY > a2)
      a2 = MaxY;
  }
  objc_msgSend(*((id *)this + 23), "wpBounds");
  objc_msgSend(v24, "setAdjustedInterimPositionX:", v20 + v69);
  objc_msgSend(v24, "setAdjustedInterimPositionY:", v19);
  objc_msgSend(v24, "fixTransformFromInterimPosition");
  *(_QWORD *)&v77.origin.x = rect[0];
  *(_QWORD *)(v37 + 48) = rect[0];
  *(CGFloat *)(v37 + 56) = a2;
  *(_QWORD *)(v37 + 64) = rect[2];
  *(double *)(v37 + 72) = v61;
  v77.origin.y = a2;
  *(_QWORD *)&v77.size.width = rect[2];
  v77.size.height = v61;
  *(CGRect *)(v37 + 80) = CGRectInset(v77, -1.0, -1.0);
  TSWPCoreTextTypesetter::createLineRefForEmptyLineFragment(*((id **)this + 253), (id *)this + 10, (TSWPLineFragment *)v37, 0, v20, 0.0);
  if (*((_QWORD *)this + 95))
    v70 = 1;
  else
    v70 = 513;
  *(_DWORD *)(v37 + 24) |= v70 | (v76 << 8);
  v71 = *((_QWORD *)this + 10) - v13;
  *(_QWORD *)v37 = v13;
  *(_QWORD *)(v37 + 8) = v71;
  if (v58)
    TSWPLayoutChore::pSetupNextParagraph(this);
  return v37;
}

void sub_217B35868(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x219A153B8](v1, 0x10A0C409F2EA496);
  _Unwind_Resume(a1);
}

uint64_t TSWPLayoutChore::pGetAlignmentForParagraphStyle(TSWPLayoutChore *this, TSWPParagraphStyle *a2)
{
  uint64_t result;
  BOOL v4;

  result = -[TSSStyle intValueForProperty:](a2, "intValueForProperty:", 86);
  if (*((_QWORD *)this + 257))
    v4 = (_DWORD)result == 4;
  else
    v4 = 0;
  if (v4)
    return objc_msgSend(*((id *)this + 257), "naturalAlignment");
  return result;
}

uint64_t TSWPLayoutChore::pCreateFullContainerAnchoredDrawableLineFragment(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGFloat *a9, _BYTE *a10)
{
  uint64_t v10;
  uint64_t v11;
  const TSWPLayoutState *v12;
  uint64_t **v13;
  uint64_t **v14;
  int64x2_t **v15;
  _DWORD *v16;
  _DWORD *v17;
  uint64_t v18;
  _DWORD *v19;
  _DWORD *v20;
  int64x2_t **v21;
  uint64_t **v22;
  uint64_t **v23;
  const TSWPLayoutState *v24;
  uint64_t v25;
  TSWPDrawableAttachment *v26;
  TSDDrawableInfo *v27;
  id v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  double MaxY;
  double v34;
  double v35;
  double v36;
  double v37;
  uint64_t v38;
  __int128 v39;
  double v40;
  __int128 v41;
  __int128 v42;
  int v43;
  uint64_t v44;
  _BYTE v45[4096];
  uint64_t v46;

  v10 = MEMORY[0x24BDAC7A8]();
  v46 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(v10 + 80) != *(_QWORD *)(v10 + 88))
    return 0;
  v18 = v11;
  if (*(double *)(v11 + 88) != *(double *)(v11 + 80))
    return 0;
  v19 = v17;
  v20 = v16;
  v21 = v15;
  v22 = v14;
  v23 = v13;
  v24 = v12;
  v25 = v10;
  objc_opt_class();
  objc_msgSend(*(id *)(v25 + 8), "attachmentAtCharIndex:", *(_QWORD *)(v25 + 80));
  v26 = (TSWPDrawableAttachment *)TSUDynamicCast();
  if (!-[TSWPDrawableAttachment isAnchored](v26, "isAnchored"))
    return 0;
  v27 = -[TSWPDrawableAttachment drawable](v26, "drawable");
  if ((objc_msgSend(*(id *)(v18 + 128), "containsObject:", v27) & 1) != 0
    || !-[TSDExteriorTextWrap type](-[TSDDrawableInfo exteriorTextWrap](v27, "exteriorTextWrap"), "type")
    || -[TSDExteriorTextWrap type](-[TSDDrawableInfo exteriorTextWrap](v27, "exteriorTextWrap"), "type") == 5
    || -[TSDExteriorTextWrap isHTMLWrap](-[TSDDrawableInfo exteriorTextWrap](v27, "exteriorTextWrap"), "isHTMLWrap")
    || (objc_opt_respondsToSelector() & 1) != 0
    && (objc_msgSend(*(id *)(v25 + 2056), "siblingTargetIsManipulatingDrawable:", v27) & 1) != 0)
  {
    return 0;
  }
  if (!objc_msgSend(*(id *)(v18 + 112), "splitLine:lineSegmentRects:wrappableAttachments:ignoreFloatingGraphics:floatingCausedWrap:skipHint:userInfo:", v45, 0, (*(_DWORD *)(v25 + 56) & 0xFFFFFFFB) == 1, 0, 0, *(_QWORD *)(v18 + 120), *(double *)(v18 + 48), *(double *)(v18 + 56), *(double *)(v18 + 64), *(double *)(v18 + 72)))return 0;
  v28 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
  v43 = 0;
  v42 = *MEMORY[0x24BDBEFB0];
  v41 = *MEMORY[0x24BDBF148];
  if (!TSWPLayoutChore::pPositionAnchoredAttachment(v25, *(CGFloat *)v18, *(CGFloat *)(v18 + 8), *(CGFloat *)(v18 + 16), *(CGFloat *)(v18 + 24), *(double *)(v18 + 88), *(CGFloat *)(v18 + 96), *(CGFloat *)(v18 + 104), v29, v30, v26, *(_QWORD *)(v25 + 80), v24, 1, &v44, v28, &v43, (double *)&v42, (uint64_t)&v41,
                        0))
    goto LABEL_13;
  v40 = 0.0;
  if (objc_msgSend(*(id *)(v18 + 112), "splitLine:lineSegmentRects:wrappableAttachments:ignoreFloatingGraphics:floatingCausedWrap:skipHint:userInfo:", v45, v28, (*(_DWORD *)(v25 + 56) & 0xFFFFFFFB) == 1, 0, &v40, *(_QWORD *)(v18 + 120), *(double *)(v18 + 48), *(double *)(v18 + 56), *(double *)(v18 + 64), *(double *)(v18 + 72)))goto LABEL_13;
  MaxY = CGRectGetMaxY(*(CGRect *)v18);
  v34 = *(double *)(v18 + 88);
  v35 = v40;
  if (v40 < 1.0)
    v35 = 1.0;
  v36 = floor(v34 + v35);
  if (MaxY <= v36)
  {
    v37 = *(double *)(v18 + 40);
LABEL_23:
    TSWPLayoutChore::pFillAnchoredDrawableLineFragment(v25, v23, v22, (TSWPLineFragment **)&v39, *(CGFloat *)(v18 + 48), v34, *(CGFloat *)(v18 + 64), *(double *)(v18 + 32) + v37);
    TSWPLineFragmentArray::appendObject(*v21, &v39);
    ++*v20;
    v38 = *(_QWORD *)(v25 + 80);
    *(_QWORD *)(v25 + 88) = v38;
    *(_QWORD *)v24 = v38;
    *((_QWORD *)v24 + 1) = v38;
    *v19 = 0;
    *a9 = CGRectGetMaxY(*(CGRect *)v18);
    v31 = 1;
    *a10 = 1;
    std::shared_ptr<EQKit::StemStretch::Glyph>::~shared_ptr[abi:nn180100]((uint64_t)&v39);
    goto LABEL_14;
  }
  v37 = *(double *)(v18 + 40);
  if (MaxY - v36 < v37)
    goto LABEL_23;
LABEL_13:
  v31 = 0;
LABEL_14:

  return v31;
}

void sub_217B35BF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::shared_ptr<EQKit::StemStretch::Glyph>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TSWPDropCapLayoutState::maxWidthFactor(TSWPDropCapLayoutState *this)
{
  unint64_t v2;
  void *v3;

  v2 = *((_QWORD *)this + 6);
  if (v2 >= objc_msgSend((id)objc_msgSend(*(id *)this, "spacings"), "count"))
    v3 = 0;
  else
    v3 = (void *)objc_msgSend((id)objc_msgSend(*(id *)this, "spacings"), "objectAtIndexedSubscript:", *((_QWORD *)this + 6));
  return objc_msgSend(v3, "maxWidthFactor");
}

uint64_t TSWPLayoutChore::pAddFootnotesForLineRange(id *this, _NSRange a2, double a3, int a4)
{
  unint64_t location;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  double v12;
  unint64_t v15;
  _NSRange v16;
  uint64_t v17;

  location = a2.location;
  v8 = objc_msgSend(this[1], "footnoteRangeForTextRange:", a2.location, a2.length);
  if (v8 >= v8 + v9)
    return 0x7FFFFFFFFFFFFFFFLL;
  v10 = v8;
  v11 = v9;
  while (1)
  {
    v17 = 0;
    objc_msgSend(this[85], "addFootnoteReferenceStorage:", objc_msgSend((id)objc_msgSend(this[1], "footnoteAtFootnoteIndex:outCharIndex:", v10, &v17), "containedStorage"));
    if (a4)
    {
      objc_msgSend(this[85], "footnoteHeight");
      if (v12 > a3 && v17 != location)
        break;
    }
    ++v10;
    if (!--v11)
      return 0x7FFFFFFFFFFFFFFFLL;
  }
  if (location <= v17 + 1)
    v15 = v17 + 1;
  else
    v15 = location;
  if (location >= v17 + 1)
    v16.location = v17 + 1;
  else
    v16.location = location;
  v16.length = v15 - v16.location;
  TSWPLayoutChore::removeFootnotesInRange(this, v16);
  return v17;
}

uint64_t TSWPLayoutChore::pFindCharIndexOfRunThatMadeUsGrowToLineHeightGuess(TSWPLayoutChore *this, double a2, double a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  void *v12;
  void *v13;
  void *v14;
  double v15;
  uint64_t v17;

  v7 = *((_QWORD *)this + 21) + *((_QWORD *)this + 20);
  v8 = objc_msgSend(*((id *)this + 1), "attachmentIndexRangeForTextRange:", a4, v7 - a4);
  if (v8 < v8 + v9)
  {
    v10 = v8;
    v11 = v9;
    while (1)
    {
      v17 = 0;
      objc_opt_class();
      objc_msgSend(*((id *)this + 1), "attachmentAtAttachmentIndex:outCharIndex:", v10, &v17);
      v12 = (void *)TSUDynamicCast();
      if (v12)
      {
        v13 = v12;
        if ((objc_msgSend(v12, "isAnchored") & 1) == 0)
        {
          v14 = (void *)objc_msgSend(*((id *)this + 257), "layoutForInlineDrawable:", objc_msgSend(v13, "drawable"));
          objc_msgSend((id)objc_msgSend(v14, "layoutController"), "validateLayoutWithDependencies:", v14);
          objc_msgSend(v14, "alignmentFrame");
          if (vabdd_f64(v15 + a3, a2) <= 1.0)
            break;
        }
      }
      ++v10;
      if (!--v11)
        return v7;
    }
    return v17;
  }
  return v7;
}

BOOL TSWPLayoutChore::pAnchoredGraphicInLineRange(uint64_t a1, unint64_t a2, uint64_t a3, TSWPLineFragmentArray **a4)
{
  unint64_t v4;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;

  v4 = a2 + a3;
  if (a2 >= a2 + a3)
    return 0;
  if ((*(_BYTE *)(TSWPLineFragmentArray::objectAtIndex(*a4, a2) + 24) & 8) != 0)
    return 1;
  v8 = a2 + 1;
  v9 = a3 - 1;
  do
  {
    v10 = v8;
    if (!v9)
      break;
    v11 = TSWPLineFragmentArray::objectAtIndex(*a4, v8);
    v8 = v10 + 1;
    --v9;
  }
  while ((*(_BYTE *)(v11 + 24) & 8) == 0);
  return v10 < v4;
}

unint64_t TSWPLayoutChore::removeFootnotesInRange(id *this, _NSRange a2)
{
  unint64_t result;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;

  result = objc_msgSend(this[1], "footnoteRangeForTextRange:", a2.location, a2.length);
  if (result < result + v4)
  {
    v5 = result;
    v6 = v4;
    do
    {
      result = objc_msgSend(this[85], "removeFootnoteReferenceStorage:", objc_msgSend((id)objc_msgSend(this[1], "footnoteAtFootnoteIndex:outCharIndex:", v5++, 0), "containedStorage"));
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t TSWPLayoutChore::pPullDownWidowsFromPreviousColumn(TSWPLayoutChore *this, TSWPLayoutState *a2)
{
  uint64_t v4;
  void *v5;
  void *v6;
  TSWPTopicNumberHints *v7;
  char *location;
  uint64_t v9;
  NSUInteger v11;
  void *v12;
  uint64_t v13;
  char i;
  void *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  TSWPTopicNumberHints *v21;
  char *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  void *v27;
  void *v28;
  CGFloat v29;
  CGFloat v30;
  CGFloat v31;
  CGFloat v32;
  void *v33;
  TSWPTopicNumberHints *v34;
  unint64_t v35;
  unint64_t v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  id *v41;
  _NSRange v42;
  TSWPParagraphEnumerator v43;
  id v44[3];
  _OWORD v45[3];
  char v46;
  id v47[52];
  char *v48;
  BOOL v49;

  v4 = *((_QWORD *)this + 30);
  v5 = (void *)*((_QWORD *)this + 257);
  if (v4)
  {
    v6 = (void *)objc_msgSend((id)objc_msgSend(v5, "columns"), "objectAtIndexedSubscript:", *((_QWORD *)this + 30) - 1);
    v7 = 0;
    if (!v6)
      return 0;
  }
  else
  {
    v6 = (void *)objc_msgSend(v5, "previousTargetLastColumn");
    v7 = (TSWPTopicNumberHints *)objc_msgSend(*((id *)this + 257), "previousTargetTopicNumbers");
    if (!v6)
      return 0;
  }
  location = (char *)objc_msgSend(v6, "nextWidowPullsDownFromCharIndex");
  v9 = objc_msgSend(v6, "startCharIndex");
  if (location == *(char **)a2)
    return 0;
  v11 = v9;
  TSWPLayoutState::TSWPLayoutState((TSWPLayoutState *)v44, a2);
  v12 = (void *)*((_QWORD *)this + 1);
  v13 = objc_msgSend(*((id *)this + 3), "styleProvider");
  if (v12)
    objc_msgSend(v12, "paragraphEnumeratorAtCharIndex:styleProvider:", location, v13);
  else
    memset(&v43, 0, sizeof(v43));
  if ((char *)TSWPParagraphEnumerator::paragraphTextRange(&v43) == location)
  {
    for (i = 0; !TSWPParagraphEnumerator::isFirstParagraph(&v43); i = 1)
    {
      TSWPParagraphEnumerator::operator--(&v43);
      v15 = (void *)TSWPParagraphEnumerator::paragraphStyle(&v43, &v42);
      if (v42.location <= v11 || !objc_msgSend(v15, "intValueForProperty:", 90))
        break;
      location = (char *)v42.location;
      TSWPParagraphEnumerator::operator--(v45);
      *(_NSRange *)v47 = v42;
      if (!v7)
        v7 = (TSWPTopicNumberHints *)((char *)this + 816);
      TSWPTopicNumberHints::backUpByOneParagraph((TSWPTopicNumberHints *)this + 16, v7, *((TSWPStorage **)this + 1));
      v16 = *((_QWORD *)this + 105);
      if (*((_QWORD *)this + 99) < v16 && v16 != 0x7FFFFFFFFFFFFFFFLL)
        TSWPTopicNumberHints::operator=((TSWPTopicNumberHints *)this + 17, (TSWPTopicNumberHints *)this + 16);
    }
  }
  else
  {
    i = 0;
  }
  v17 = objc_msgSend(v6, "range");
  if ((unint64_t)location <= v17 + v18)
    v19 = (char *)(v17 + v18);
  else
    v19 = location;
  if ((unint64_t)location >= v17 + v18)
    v20 = (char *)(v17 + v18);
  else
    v20 = location;
  objc_msgSend(v6, "trimToCharIndex:inTarget:removeAutoNumberFootnoteCount:", location, *((_QWORD *)this + 257), objc_msgSend(*((id *)this + 1), "autoNumberFootnoteCountForRange:", v20, v19 - v20));
  if ((i & 1) != 0)
  {
    *(_OWORD *)((char *)this + 104) = v45[0];
    *(_OWORD *)((char *)this + 120) = v45[1];
    *(_OWORD *)((char *)this + 136) = v45[2];
    *((_BYTE *)this + 152) = v46;
    *((_OWORD *)this + 10) = *(_OWORD *)v47;
    *((_QWORD *)this + 10) = location;
    TSWPLayoutChore::pSetupStateForParagraphIndex(this, 0);
    if (v7)
      v21 = v7;
    else
      v21 = (TSWPTopicNumberHints *)((char *)this + 816);
    TSWPTopicNumberHints::operator=((TSWPTopicNumberHints *)this + 16, v21);
    TSWPTopicNumberHints::advanceToCharIndex((TSWPTopicNumberHints *)this + 16, *((_QWORD *)this + 10), *((TSWPStorage **)this + 1));
  }
  else
  {
    v22 = (char *)(location - (char *)v47[0]);
    if (location >= v47[0])
    {
      v44[0] = location;
      v48 = (char *)(location - (char *)v47[0]);
      if ((unint64_t)location > *((_QWORD *)this + 8))
      {
        v23 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v24 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPLayoutChore::pPullDownWidowsFromPreviousColumn(TSWPLayoutState *)");
        objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v24, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 4591, CFSTR("Bad backUpLayoutState.charIndex"));
        v22 = v48;
      }
      if (v22 >= v47[1])
      {
        v25 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v26 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPLayoutChore::pPullDownWidowsFromPreviousColumn(TSWPLayoutState *)");
        objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", v26, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 4592, CFSTR("Bad typesetterCharIndex"));
      }
      v49 = v44[0] == v47[0];
      objc_opt_class();
      v27 = (void *)TSUDynamicCast();
      v28 = v27;
      if (v27)
      {
        objc_msgSend(v27, "wpBounds");
        fixSpaceAfterForParagraphBorder((uint64_t)this + 80, (TSWPLineFragmentArray **)objc_msgSend(v28, "lineFragmentArray"), v29, v30, v31, v32);
        objc_msgSend(v28, "clearAdornments");
        TSWPLayoutChore::addParagraphAdornmentsToColumn(v28, *((void **)this + 24), objc_msgSend(*((id *)this + 3), "styleProvider"));
        v33 = (void *)*((_QWORD *)this + 24);
        objc_msgSend(*((id *)this + 3), "styleProvider");
        TSWPLayoutChore::addChangeBarAdornmentsToColumn(v28, v33);
      }
      TSWPLayoutChore::pRestoreStateFromOldState(this, v44);
      (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 253) + 32))(*((_QWORD *)this + 253), *((_QWORD *)this + 72));
      if (location == (char *)TSWPParagraphEnumerator::paragraphTextRange((TSWPParagraphEnumerator *)((char *)this + 104)))
      {
        if (v7)
          v34 = v7;
        else
          v34 = (TSWPTopicNumberHints *)((char *)this + 816);
        TSWPTopicNumberHints::backUpByOneParagraph((TSWPTopicNumberHints *)this + 16, v34, *((TSWPStorage **)this + 1));
      }
      TSWPTopicNumberHints::advanceToCharIndex((TSWPTopicNumberHints *)this + 16, *((_QWORD *)this + 10), *((TSWPStorage **)this + 1));
    }
  }
  v35 = *((_QWORD *)this + 99);
  v36 = *((_QWORD *)this + 105);
  v37 = v35 < v36 || v35 == 0x7FFFFFFFFFFFFFFFLL;
  if (v37 && v36 != 0x7FFFFFFFFFFFFFFFLL)
    TSWPTopicNumberHints::operator=((TSWPTopicNumberHints *)this + 17, (TSWPTopicNumberHints *)this + 16);
  objc_msgSend(*((id *)this + 23), "setStartCharIndex:", *((_QWORD *)this + 10));
  v38 = *((_QWORD *)this + 251) - *((_QWORD *)this + 250);
  if (v38)
  {
    v39 = v38 / 688;
    v40 = 688 * (v38 / 688) - 688;
    do
    {
      v41 = (id *)(*((_QWORD *)this + 250) + v40);
      if ((unint64_t)*v41 > *((_QWORD *)this + 10))
        TSWPLayoutState::operator=(v41, (id *)this + 10);
      v40 -= 688;
      --v39;
    }
    while (v39);
  }
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v43);
  TSWPLayoutState::~TSWPLayoutState((TSWPLayoutState *)v44);
  return 1;
}

void sub_217B36458(_Unwind_Exception *a1, uint64_t a2, TSWPParagraphEnumerator *a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)va);
  TSWPLayoutState::~TSWPLayoutState((TSWPLayoutState *)va1);
  _Unwind_Resume(a1);
}

uint64_t TSWPLayoutChore::pHandleOrphanAndKeepTogether(uint64_t a1, TSWPLineFragmentArray **a2, _WORD *a3, _BYTE *a4, NSUInteger a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9)
{
  uint64_t Object;
  TSWPLineFragment *v19;
  unint64_t v20;
  _BOOL4 v21;
  uint64_t v23;
  NSUInteger v24;
  unint64_t LineIndexForCharIndex;
  NSUInteger v26;
  NSUInteger v27;
  uint64_t v28;
  int v29;
  char v30;
  char v31;
  void *v32;
  int v33;
  void *v34;
  uint64_t v35;
  uint64_t i;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __int16 v41;
  uint64_t v42;
  NSUInteger v43;
  _QWORD *v44;
  uint64_t v45;
  NSUInteger v46;
  NSUInteger v47;
  _NSRange v48;
  unint64_t v50;
  _WORD *v51;
  _BYTE *v52;
  TSWPParagraphEnumerator v53;
  TSWPParagraphEnumerator v54;
  _NSRange v55;
  TSWPParagraphEnumerator v56;
  _NSRange v57;
  CGRect v58;
  CGRect v59;

  Object = TSWPLineFragmentArray::lastObject(*a2);
  v19 = (TSWPLineFragment *)Object;
  v21 = Object
     && (v20 = *(_QWORD *)(a1 + 160), *(_QWORD *)Object >= v20)
     && *(_QWORD *)(Object + 8) + *(_QWORD *)Object < *(_QWORD *)(a1 + 168) + v20;
  if (!*(_BYTE *)(a1 + 409) && !*(_BYTE *)(a1 + 408) && !*(_BYTE *)(a1 + 410) && (!*(_BYTE *)(a1 + 411) || v21))
    return 0x7FFFFFFFFFFFFFFFLL;
  if (Object && (*(_BYTE *)(Object + 24) & 1) != 0)
    return 0x7FFFFFFFFFFFFFFFLL;
  v51 = a3;
  v52 = a4;
  v23 = TSWPLineFragmentArray::count(*a2);
  v24 = *(_QWORD *)(a1 + 80);
  if (v21)
  {
    LineIndexForCharIndex = TSWPLineFragmentArray::findLineIndexForCharIndex(*a2, *(_QWORD *)(a1 + 160));
    v26 = *(_QWORD *)TSWPLineFragmentArray::objectAtIndex(*a2, LineIndexForCharIndex);
    if (v26 > a5 && (*(_BYTE *)(a1 + 410) || *(_BYTE *)(a1 + 409)))
    {
      v27 = v23 - LineIndexForCharIndex;
      v24 = *(_QWORD *)(a1 + 160);
      goto LABEL_23;
    }
    if (*(_BYTE *)(a1 + 408))
    {
      v58.origin.x = a6;
      v58.origin.y = a7;
      v58.size.width = a8;
      v58.size.height = a9;
      if (!TSWPLineFragment::preventWidowCorrection(v19, v58))
      {
        v50 = v23 - LineIndexForCharIndex;
        if (v23 - LineIndexForCharIndex == 1 && v26 > a5)
        {
          v24 = *(_QWORD *)(a1 + 160);
          v28 = 0x7FFFFFFFFFFFFFFFLL;
          v27 = 1;
          goto LABEL_24;
        }
        if (v50 == 2 && v26 > a5)
        {
          v19 = (TSWPLineFragment *)TSWPLineFragmentArray::objectAtIndex(*a2, LineIndexForCharIndex);
          v59.origin.x = a6;
          v59.origin.y = a7;
          v59.size.width = a8;
          v59.size.height = a9;
          if (TSWPLineFragment::preventWidowCorrection(v19, v59))
            goto LABEL_18;
        }
        else if (v50 < 3)
        {
          goto LABEL_18;
        }
        v27 = 0;
        LineIndexForCharIndex = v23 - 1;
        v28 = *(_QWORD *)v19;
        goto LABEL_24;
      }
    }
  }
LABEL_18:
  v27 = 0;
  LineIndexForCharIndex = v23 - 1;
LABEL_23:
  v28 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_24:
  TSWPParagraphEnumerator::TSWPParagraphEnumerator(&v56, (const TSWPParagraphEnumerator *)(a1 + 104));
  v29 = !v21;
  if (v27)
    v29 = 1;
  if (v29 == 1 && v24 && v24 < *(_QWORD *)(a1 + 64))
  {
    v55 = *(_NSRange *)(a1 + 160);
    TSWPParagraphEnumerator::TSWPParagraphEnumerator(&v54, &v56);
    v30 = 0;
    while (1)
    {
      v31 = v30;
      if (TSWPParagraphEnumerator::isFirstParagraph(&v54))
        break;
      TSWPParagraphEnumerator::operator--(&v54);
      v32 = (void *)TSWPParagraphEnumerator::paragraphStyle(&v54, &v55);
      if (v55.length + v55.location <= a5)
        break;
      v33 = objc_msgSend(v32, "intValueForProperty:", 90);
      v30 = 1;
      if (!v33)
      {
        if ((v31 & 1) != 0)
        {
          v24 = v55.length + v55.location;
          LineIndexForCharIndex = TSWPLineFragmentArray::findLineIndexForCharIndex(*a2, v55.length + v55.location);
          TSWPParagraphEnumerator::next(&v54, (uint64_t)&v53);
          v27 = v23 - LineIndexForCharIndex;
          v56 = v53;
          TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v53);
        }
        break;
      }
    }
    TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v54);
  }
  if (v27)
  {
    if (!LineIndexForCharIndex)
    {
      v34 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v35 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TSWPCharIndex TSWPLayoutChore::pHandleOrphanAndKeepTogether(const line_fragment_array_ptr &, unichar *, BOOL *, CGRect, TSWPCharIndex)");
      objc_msgSend(v34, "handleFailureInFunction:file:lineNumber:description:", v35, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 5557, CFSTR("Trying to push down the first line of a column"));
    }
    for (i = 0; i != v27; ++i)
    {
      if (*(_QWORD *)(TSWPLineFragmentArray::objectAtIndex(*a2, LineIndexForCharIndex + i) + 176))
        TSWPTopicNumberHints::backUpByOneParagraph((TSWPTopicNumberHints *)(a1 + 768), (TSWPTopicNumberHints *)(a1 + 816), *(TSWPStorage **)(a1 + 8));
    }
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 2024) + 24))(*(_QWORD *)(a1 + 2024));
    *(_QWORD *)(a1 + 80) = v24;
    v37 = *(_OWORD *)&v56.var2;
    *(_OWORD *)(a1 + 104) = *(_OWORD *)&v56.var0;
    *(_OWORD *)(a1 + 120) = v37;
    *(_OWORD *)(a1 + 136) = *(_OWORD *)&v56.var4;
    *(_BYTE *)(a1 + 152) = v56.var6;
    TSWPLayoutChore::pSetupStateForParagraphIndex((TSWPLayoutChore *)a1, 0);
    v38 = *(_QWORD *)(a1 + 160);
    if (v38)
    {
      v39 = v38 - 1;
      v40 = objc_msgSend(*(id *)(a1 + 8), "characterAtIndex:", v38 - 1);
      v41 = v40;
      v42 = IsParagraphBreakingCharacter(v40);
      if ((_DWORD)v42)
      {
        if ((objc_msgSend(*(id *)(a1 + 8), "hasColumnStyleForParagraphBreakAtCharIndex:", v39) & 1) != 0)
          v42 = 1;
        else
          v42 = objc_msgSend(*(id *)(a1 + 8), "hasSectionForParagraphBreakAtCharIndex:", v39);
      }
    }
    else
    {
      v41 = 0;
      v42 = 0;
    }
    *v51 = v41;
    *v52 = v42;
    if (TSWPLayoutChore::pAnchoredGraphicInLineRange(v42, LineIndexForCharIndex, v27, a2))
      *(_BYTE *)(a1 + 640) = 1;
    v43 = *(_QWORD *)TSWPLineFragmentArray::objectAtIndex(*a2, LineIndexForCharIndex);
    v44 = (_QWORD *)TSWPLineFragmentArray::objectAtIndex(*a2, v27 + LineIndexForCharIndex - 1);
    v45 = v44[1];
    v46 = v45 + *v44;
    if (v43 <= v46)
      v47 = v45 + *v44;
    else
      v47 = v43;
    if (v43 >= v46)
      v48.location = v46;
    else
      v48.location = v43;
    v48.length = v47 - v48.location;
    TSWPLayoutChore::removeFootnotesInRange((id *)a1, v48);
    v57.location = LineIndexForCharIndex;
    v57.length = v27;
    TSWPLineFragmentArray::removeObjectsInRange(*a2, v57);
  }
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v56);
  return v28;
}

void sub_217B36920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, TSWPParagraphEnumerator *a10, uint64_t a11, uint64_t a12, TSWPParagraphEnumerator *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a18);
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a27);
  _Unwind_Resume(a1);
}

uint64_t TSWPLayoutChore::pParagraphRunsRightToLeftAtCharIndex(TSWPLayoutChore *this, NSUInteger a2)
{
  TSWPParagraphEnumerator *v4;
  NSUInteger v5;
  NSUInteger v6;
  void *v8;
  uint64_t v9;
  uint64_t v11;
  TSWPParagraphEnumerator v12;

  v4 = (TSWPParagraphEnumerator *)((char *)this + 104);
  v5 = TSWPParagraphEnumerator::paragraphTextRange((TSWPParagraphEnumerator *)((char *)this + 104));
  if (a2 >= v5 && a2 - v5 < v6)
    return TSWPParagraphEnumerator::paragraphRunsRightToLeft(v4);
  v8 = (void *)*((_QWORD *)this + 1);
  v9 = objc_msgSend(*((id *)this + 3), "styleProvider");
  if (v8)
    objc_msgSend(v8, "paragraphEnumeratorAtCharIndex:styleProvider:", a2, v9);
  else
    memset(&v12, 0, sizeof(v12));
  v11 = TSWPParagraphEnumerator::paragraphRunsRightToLeft(&v12);
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v12);
  return v11;
}

void sub_217B36A1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a9);
  _Unwind_Resume(a1);
}

double TSWPLayoutChore::pMinimumLayoutHeightForColumnRange(id *this, _NSRange a2, BOOL *a3)
{
  NSUInteger v3;
  NSUInteger location;
  char v6;
  double v7;
  void *v8;
  double v9;
  double Height;
  unint64_t v11;
  NSUInteger v12;
  NSUInteger v13;
  NSUInteger v14;
  NSUInteger v15;
  NSUInteger v16;
  NSRange v17;
  void *v18;
  BOOL *v20;
  NSUInteger v21;
  NSRange v22;
  NSRange v23;
  CGRect v24;

  v20 = a3;
  v3 = a2.location + a2.length;
  if (a2.location >= a2.location + a2.length)
  {
    v6 = 0;
    v7 = 0.0;
    goto LABEL_17;
  }
  location = a2.location;
  v6 = 0;
  v7 = 0.0;
  v21 = a2.location + a2.length;
  do
  {
    v8 = (void *)objc_msgSend((id)objc_msgSend(this[257], "columns", v20), "objectAtIndexedSubscript:", location);
    objc_msgSend(v8, "minimumHeightForLayoutOnPage");
    Height = v9;
    if (v9 > 0.0)
      goto LABEL_14;
    v11 = objc_msgSend(v8, "range");
    v13 = v11 + v12;
    if (v11 >= v11 + v12)
      goto LABEL_14;
    v14 = v11;
    v15 = v12;
    v16 = v11;
    while (1)
    {
      v22.location = objc_msgSend(this[1], "attachmentRangeForCharIndex:forwards:", v16, 1);
      v23.location = v14;
      v23.length = v15;
      v17 = NSIntersectionRange(v22, v23);
      if (v17.length != 1)
      {
        if (!v17.length)
          goto LABEL_13;
        goto LABEL_10;
      }
      objc_opt_class();
      objc_msgSend(this[1], "attachmentAtCharIndex:", v17.location);
      v18 = (void *)TSUDynamicCast();
      if (objc_msgSend(v18, "isHTMLWrap"))
        break;
LABEL_10:
      v16 = v17.location + v17.length;
      if (v17.location + v17.length >= v13)
        goto LABEL_13;
    }
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(this[257], "validatedLayoutForAnchoredDrawable:", objc_msgSend(v18, "drawable")), "geometry"), "frame");
    Height = CGRectGetHeight(v24);
LABEL_13:
    v3 = v21;
LABEL_14:
    v7 = fmax(v7, Height);
    v6 |= objc_msgSend(v8, "countLines") != 0;
    ++location;
  }
  while (location != v3);
LABEL_17:
  if (v20)
    *v20 = v6 & 1;
  return v7;
}

void TSWPLayoutChore::pCreateLineRefsAfterColumnBalancing(uint64_t a1, uint64_t a2, int a3)
{
  char v5;
  unint64_t v6;
  char v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  TSWPLineFragment *v12;
  TSWPLineFragment *v13;
  NSUInteger v14;
  NSUInteger v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  __int128 v19;
  TSWPCoreTextTypesetter *v20;
  double v21;
  double v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  TSWPParagraphEnumerator v27;
  uint64_t v28[2];

  v5 = objc_msgSend(*(id *)(a1 + 2056), "autosizeFlags");
  v6 = *(_QWORD *)(a2 + 144);
  if (v6 < *(_QWORD *)(a2 + 152) + v6)
  {
    v7 = 0;
    v25 = v5 & 0xC;
    v24 = a1 + 768;
    while (1)
    {
      v8 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 2056), "columns", v24), "objectAtIndexedSubscript:", v6);
      *(_QWORD *)(a2 + 104) = v8;
      *(_QWORD *)(a2 + 160) = v6;
      v9 = objc_msgSend(v8, "countLines");
      if (v9)
        break;
LABEL_15:
      TSWPLayoutChore::pPostProcessAttachments(a1, (TSWPLineFragment ****)objc_msgSend(v8, "lineFragmentArray"));
      if (++v6 >= *(_QWORD *)(a2 + 152) + *(_QWORD *)(a2 + 144))
        return;
    }
    v10 = v9;
    v11 = 0;
    while (1)
    {
      v12 = (TSWPLineFragment *)objc_msgSend(v8, "lineFragmentAtIndex:", v11);
      if (*((_QWORD *)v12 + 25) == *((_QWORD *)v12 + 24))
        break;
LABEL_14:
      if (v10 == ++v11)
        goto LABEL_15;
    }
    v13 = v12;
    v14 = *(_QWORD *)v12;
    *(_QWORD *)a2 = *(_QWORD *)v12;
    if ((v7 & 1) != 0)
    {
      v15 = TSWPParagraphEnumerator::paragraphTextRange((TSWPParagraphEnumerator *)(a2 + 24));
      if (v14 < v15 + v16)
      {
LABEL_13:
        TSWPCoreTextTypesetter::createLineRefsForLineFragment(*(_QWORD *)(a1 + 2024), v13, a2, v25 != 0, a3);
        v7 = 1;
        goto LABEL_14;
      }
      v14 = *(_QWORD *)a2;
    }
    v28[0] = a1 + 872;
    v28[1] = a1 + 1936;
    v17 = *(void **)(a1 + 8);
    v18 = objc_msgSend(*(id *)(a1 + 24), "styleProvider");
    if (v17)
      objc_msgSend(v17, "paragraphEnumeratorAtCharIndex:styleProvider:", v14, v18);
    else
      memset(&v27, 0, sizeof(v27));
    v19 = *(_OWORD *)&v27.var2;
    *(_OWORD *)(a2 + 24) = *(_OWORD *)&v27.var0;
    *(_OWORD *)(a2 + 40) = v19;
    *(_OWORD *)(a2 + 56) = *(_OWORD *)&v27.var4;
    *(_BYTE *)(a2 + 72) = v27.var6;
    TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v27);
    TSWPLayoutChore::pSetupStateForParagraphIndex((TSWPLayoutChore *)a1, (TSWPLayoutState *)a2);
    v20 = *(TSWPCoreTextTypesetter **)(a1 + 2024);
    v21 = *MEMORY[0x24BDBF148];
    v22 = *(double *)(MEMORY[0x24BDBF148] + 8);
    v23 = TSWPParagraphEnumerator::relevantParagraphIndex((TSWPParagraphEnumerator *)(a2 + 24));
    TSWPCoreTextTypesetter::beginParagraphLayout(v20, a2, v24, v28, v23, v21, v22);
    goto LABEL_13;
  }
}

double TSWPLayoutChore::pInvalidateRect(TSWPLayoutChore *this, CGRect a2, CGRect a3, TSWPColumn *a4, int a5, int a6)
{
  double height;
  CGFloat width;
  double y;
  CGFloat x;
  CGFloat v11;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  double v15;
  double v16;
  CGFloat v17;
  CGFloat v18;
  double result;
  CGRect v20;
  CGRect v21;
  CGRect v22;
  CGRect v23;

  height = a3.size.height;
  width = a3.size.width;
  y = a3.origin.y;
  x = a3.origin.x;
  v11 = a2.size.height;
  v12 = a2.size.width;
  v13 = a2.origin.y;
  v14 = a2.origin.x;
  if (a5)
  {
    -[TSWPColumn wpBounds](a4, "wpBounds");
    v20.origin.y = y;
    v20.size.height = height;
    v23.origin.x = x;
    v23.origin.y = y;
    v23.size.width = width;
    v23.size.height = height;
    v21 = CGRectUnion(v20, v23);
    x = v21.origin.x;
    y = v21.origin.y;
    width = v21.size.width;
    height = v21.size.height;
  }
  if (a6)
    v15 = y + -6.0;
  else
    v15 = y;
  if (a6)
    v16 = height + 12.0;
  else
    v16 = height;
  v22.origin.x = v14;
  v22.origin.y = v13;
  v22.size.width = v12;
  v22.size.height = v11;
  v17 = x;
  v18 = width;
  *(_QWORD *)&result = (unint64_t)CGRectUnion(v22, *(CGRect *)(&v15 - 1));
  return result;
}

uint64_t TSWPLayoutChore::pGetColumnMetricsAtCharIndex(id *this, uint64_t a2, _NSRange *a3)
{
  return objc_msgSend(this[257], "columnMetricsForCharIndex:outRange:", a2, a3);
}

uint64_t pLayoutGeometryIsBeingManipulated(TSDLayout *a1)
{
  uint64_t result;
  objc_class *v3;
  void *v4;

  result = -[TSDLayout isBeingManipulated](a1, "isBeingManipulated");
  if ((_DWORD)result)
  {
    if ((objc_msgSend((id)objc_msgSend((id)objc_msgSend(-[TSDLayout layoutController](a1, "layoutController"), "canvas"), "canvasController"), "isInInspectorDynamicOperation") & 1) != 0)
    {
      return 0;
    }
    else
    {
      v3 = (objc_class *)objc_opt_class();
      if (!-[NSString isEqualToString:](NSStringFromClass(v3), "isEqualToString:", CFSTR("TSTLayout"))
        || (result = objc_msgSend((id)objc_msgSend((id)objc_msgSend(-[TSDLayout layoutController](a1, "layoutController"), "canvas"), "canvasController"), "isInDynamicOperation"), (_DWORD)result))
      {
        objc_opt_class();
        v4 = (void *)TSUDynamicCast();
        if (v4)
          return objc_msgSend(v4, "isStrokeBeingManipulated") ^ 1;
        else
          return 1;
      }
    }
  }
  return result;
}

double TSWPLayoutChore::pCalculateAttachmentPosition(id *a1, TSWPDrawableAttachment *a2, unint64_t a3, const TSWPLayoutState *a4, char a5, double *a6, CGFloat a7, CGFloat a8, CGFloat a9, CGFloat a10, double a11, CGFloat a12, CGFloat a13, double a14, double a15)
{
  TSDExteriorTextWrap *v28;
  int v29;
  double MinX;
  int v31;
  CGFloat v32;
  double v33;
  void *v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  int v40;
  void *v41;
  CGSize v43;
  CGRect v44;
  CGRect v45;
  CGRect v46;
  CGRect v47;
  CGRect v48;

  v28 = -[TSDDrawableInfo exteriorTextWrap](-[TSWPDrawableAttachment drawable](a2, "drawable"), "exteriorTextWrap");
  if (-[TSDExteriorTextWrap isHTMLWrap](v28, "isHTMLWrap"))
  {
    v29 = -[TSDExteriorTextWrap direction](v28, "direction");
    if (v29)
    {
      if (v29 == 2)
      {
        v44.origin.x = a7;
        v44.origin.y = a8;
        v44.size.width = a9;
        v44.size.height = a10;
        MinX = CGRectGetMidX(v44) + a15 * -0.5;
      }
      else if (v29 == 1)
      {
        MinX = *a6;
        *a6 = a15 + *a6;
      }
      else
      {
        v46.origin.x = a7;
        v46.origin.y = a8;
        v46.size.width = a9;
        v46.size.height = a10;
        MinX = CGRectGetMinX(v46);
      }
    }
    else
    {
      MinX = a6[1] - a15;
      a6[1] = MinX;
    }
  }
  else
  {
    -[TSWPDrawableAttachment hOffset](a2, "hOffset");
    -[TSWPDrawableAttachment vOffset](a2, "vOffset");
    v31 = -[TSWPDrawableAttachment hOffsetType](a2, "hOffsetType");
    if (v31 == 2)
    {
      v32 = a10;
      objc_opt_class();
      v34 = (void *)TSUDynamicCast();
      -[TSWPDrawableAttachment hOffset](a2, "hOffset");
      v36 = v35;
      if (v34)
        objc_msgSend(v34, "frame");
      else
        v37 = 0.0;
      MinX = v36 - v37;
    }
    else if (v31 == 1)
    {
      v45.origin.x = a7;
      v45.origin.y = a8;
      v45.size.width = a9;
      v32 = a10;
      v45.size.height = a10;
      v38 = CGRectGetMinX(v45);
      -[TSWPDrawableAttachment hOffset](a2, "hOffset");
      MinX = v38 + v39;
    }
    else
    {
      if (v31)
      {
        v47.origin.x = a7;
        v47.origin.y = a8;
        v47.size.width = a9;
        v32 = a10;
        v47.size.height = a10;
        v33 = CGRectGetMinX(v47);
      }
      else
      {
        v32 = a10;
        -[TSWPDrawableAttachment hOffset](a2, "hOffset");
      }
      MinX = v33;
    }
    v40 = -[TSWPDrawableAttachment vOffsetType](a2, "vOffsetType");
    if (v40 == 1)
    {
      objc_opt_class();
      v41 = (void *)TSUDynamicCast();
      -[TSWPDrawableAttachment vOffset](a2, "vOffset");
      if (v41)
        objc_msgSend(v41, "frame");
    }
    else if (v40)
    {
      v48.origin.x = a7;
      v48.origin.y = a8;
      v48.size.width = a9;
      v48.size.height = v32;
      CGRectGetMinY(v48);
    }
    else if (objc_msgSend(a1[23], "startCharIndex") <= a3)
    {
      -[TSWPDrawableAttachment vOffset](a2, "vOffset");
    }
  }
  v43.width = a12;
  v43.height = a13;
  TSWPLayoutChore::pAnchoredDrawableVerticalAdjustment(a1, a2, a4, v43, a5);
  return MinX;
}

double TSWPLayoutChore::pAnchoredDrawableVerticalAdjustment(id *this, TSWPDrawableAttachment *a2, const TSWPLayoutState *a3, CGSize a4, char a5)
{
  double height;
  double v10;
  TSDExteriorTextWrap *v11;
  double v12;
  double v13;
  double v14;
  double v15;
  BOOL isFirstParagraph;
  double v17;
  void *v18;
  float v19;
  double v20;
  void *v21;
  double v22;
  uint64_t CharacterStyleAtCharIndex;
  TSWPParagraphEnumerator v25;

  height = a4.height;
  v10 = 0.0;
  if (-[TSWPDrawableAttachment vOffsetType](a2, "vOffsetType", a4.width) != 1)
  {
    v11 = -[TSDDrawableInfo exteriorTextWrap](-[TSWPDrawableAttachment drawable](a2, "drawable"), "exteriorTextWrap");
    -[TSDExteriorTextWrap margin](v11, "margin");
    v13 = fmin(v12, height * 0.5);
    if (!-[TSDExteriorTextWrap isHTMLWrap](v11, "isHTMLWrap"))
    {
      v14 = 0.0;
LABEL_9:
      v10 = v13 + v14;
      goto LABEL_10;
    }
    if ((a5 & 1) == 0)
    {
      v14 = 0.0;
      if (*(_QWORD *)a3 == *((_QWORD *)a3 + 10))
      {
        v15 = *((double *)a3 + 38);
        isFirstParagraph = TSWPParagraphEnumerator::isFirstParagraph((TSWPParagraphEnumerator *)((char *)a3 + 24));
        v17 = v15;
        if (!isFirstParagraph)
        {
          TSWPParagraphEnumerator::previous((TSWPParagraphEnumerator *)((char *)a3 + 24), (uint64_t)&v25);
          v18 = (void *)TSWPParagraphEnumerator::paragraphStyle(&v25, 0);
          TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v25);
          objc_msgSend(v18, "floatValueForProperty:", 88);
          v20 = (float)(v19 * (float)((float)(unint64_t)objc_msgSend(this[23], "scaleTextPercent") / 100.0));
          v15 = fmax(*((double *)a3 + 38), v20);
          v17 = v15 - v20;
        }
        v14 = v17 + 0.0;
        v13 = fmax(v13 - v15, 0.0);
      }
      goto LABEL_9;
    }
  }
LABEL_10:
  -[TSWPDrawableAttachment drawable](a2, "drawable");
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v21 = (void *)-[TSDDrawableInfo stroke](-[TSWPDrawableAttachment drawable](a2, "drawable"), "stroke");
    if (v21)
    {
      objc_msgSend(v21, "outsets");
      v10 = v10 + v22;
    }
  }
  CharacterStyleAtCharIndex = TSWPLayoutChore::pGetCharacterStyleAtCharIndex(this, *(_QWORD *)a3);
  return v10
       + TSWPAttachmentVAlignmentCorrection(-[TSWPDrawableAttachment vAlignment](a2, "vAlignment"), CharacterStyleAtCharIndex, *((void **)a3 + 12), objc_msgSend(*((id *)a3 + 13), "scaleTextPercent"));
}

void sub_217B373B4(_Unwind_Exception *a1, TSWPParagraphEnumerator *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a10);
  _Unwind_Resume(a1);
}

uint64_t TSWPLayoutChore::pPositionAnchoredAttachment(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, double a6, CGFloat a7, CGFloat a8, uint64_t a9, uint64_t a10, TSWPDrawableAttachment *a11, unint64_t a12, const TSWPLayoutState *a13, char a14, _QWORD *a15, void *a16, _DWORD *a17, double *a18, uint64_t a19, uint64_t a20)
{
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t i;
  TSDLayout *v35;
  TSDLayout *v36;
  double v37;
  uint64_t v38;
  double v39;
  uint64_t v40;
  id v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  double v47;
  double v48;
  uint64_t v49;
  uint64_t v50;
  double MaxY;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  double MinY;
  double v63;
  double v64;
  double v65;
  double v66;
  TSDExteriorTextWrap *v68;
  id v69;
  CGFloat v70;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  _BYTE v78[128];
  uint64_t v79;
  CGSize v80;
  CGSize v81;
  CGRect v82;
  CGRect v83;
  CGRect v84;
  CGRect v85;

  v79 = *MEMORY[0x24BDAC8D0];
  v30 = (void *)objc_msgSend(*(id *)(a1 + 2056), "currentAnchoredDrawableLayouts");
  v74 = 0u;
  v75 = 0u;
  v76 = 0u;
  v77 = 0u;
  v31 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v74, v78, 16);
  if (v31)
  {
    v32 = v31;
    v33 = *(_QWORD *)v75;
    while (2)
    {
      for (i = 0; i != v32; ++i)
      {
        if (*(_QWORD *)v75 != v33)
          objc_enumerationMutation(v30);
        v35 = *(TSDLayout **)(*((_QWORD *)&v74 + 1) + 8 * i);
        if ((TSWPDrawableAttachment *)-[TSDInfo owningAttachment](-[TSDLayout info](v35, "info"), "owningAttachment") == a11
          && pLayoutGeometryIsBeingManipulated(v35))
        {
          *a15 = a12 + 1;
          if (-[TSWPDrawableAttachment drawable](a11, "drawable"))
            objc_msgSend(a16, "addObject:", -[TSWPDrawableAttachment drawable](a11, "drawable"));
          ++*a17;
          -[TSDAbstractLayout alignmentFrame](v35, "alignmentFrame");
          *(_QWORD *)a18 = v52;
          *((_QWORD *)a18 + 1) = v53;
          v80.width = a7;
          v80.height = a8;
          a18[1] = a18[1] - TSWPLayoutChore::pAnchoredDrawableVerticalAdjustment((id *)a1, a11, a13, v80, a14);
          if ((objc_opt_respondsToSelector() & 1) != 0)
          {
            objc_msgSend(*(id *)(a1 + 2056), "anchoredAttachmentPositionFromLayoutPosition:", *a18, a18[1]);
            *(_QWORD *)a18 = v54;
            *((_QWORD *)a18 + 1) = v55;
          }
          *(double *)a19 = adjustedLayoutSize(v35);
          *(_QWORD *)(a19 + 8) = v56;
          return 1;
        }
      }
      v32 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v74, v78, 16);
      if (v32)
        continue;
      break;
    }
  }
  v36 = (TSDLayout *)objc_msgSend(*(id *)(a1 + 2056), "validatedLayoutForAnchoredDrawable:", -[TSWPDrawableAttachment drawable](a11, "drawable"));
  v37 = adjustedLayoutSize(v36);
  *(double *)a19 = v37;
  *(_QWORD *)(a19 + 8) = v38;
  *a18 = TSWPLayoutChore::pCalculateAttachmentPosition((id *)a1, a11, a12, a13, a14, (double *)a20, a2, a3, a4, a5, a6, a7, a8, v39, v37);
  *((_QWORD *)a18 + 1) = v40;
  v41 = -[TSDLayout iterativePositioningState](v36, "iterativePositioningState");
  v42 = v41;
  if (v41)
  {
    objc_msgSend(v41, "position");
    *(_QWORD *)a18 = v43;
    *((_QWORD *)a18 + 1) = v44;
  }
  if (-[TSDLayout hasFinishedIterativePositioning](v36, "hasFinishedIterativePositioning"))
  {
    objc_msgSend(v42, "position");
    *(_QWORD *)a18 = v45;
    *((_QWORD *)a18 + 1) = v46;
  }
  if (-[TSDLayout attachmentLayoutDisplacedByDropCap](v36, "attachmentLayoutDisplacedByDropCap"))
  {
    v47 = *(double *)(a1 + 752);
    v48 = a18[1];
    if (v47 > v48)
    {
      a18[1] = v47;
      v48 = v47;
    }
    v49 = *(_QWORD *)a18;
    *a18 = TSWPDropCapLayoutState::adjustedAttachmentPosition((TSWPDropCapLayoutState *)(a1 + 864), *(CGPoint *)(&v48 - 1), v36, a12);
    *((_QWORD *)a18 + 1) = v50;
  }
  v70 = a5;
  if (-[TSWPDrawableAttachment isHTMLWrap](a11, "isHTMLWrap"))
  {
    v82.origin.x = a2;
    v82.origin.y = a3;
    v82.size.width = a4;
    v82.size.height = a5;
    MaxY = CGRectGetMaxY(v82);
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 2056), "maxAnchorY");
  }
  v57 = MaxY;
  if (-[TSWPDrawableAttachment vOffsetType](a11, "vOffsetType") != 1)
  {
    v58 = a6;
    v59 = a18[1];
    v60 = v59 + *(double *)(a19 + 8) - v57;
    if (v60 > 0.0)
    {
      -[TSWPDrawableAttachment vOffset](a11, "vOffset");
      v59 = a18[1];
      if (v60 <= v61)
      {
        v59 = v59 - v60;
        a18[1] = v59;
      }
    }
    if (v59 + *(double *)(a19 + 8) > v57)
    {
      v81.width = a7;
      v81.height = a8;
      if (a18[1] - TSWPLayoutChore::pAnchoredDrawableVerticalAdjustment((id *)a1, a11, a13, v81, a14) != v58)
        return 0;
      v83.origin.x = a2;
      v83.origin.y = a3;
      v83.size.width = a4;
      v83.size.height = v70;
      if (CGRectGetMinY(v83) != v58)
        return 0;
      v84.origin.x = a2;
      v84.origin.y = a3;
      v84.size.width = a4;
      v84.size.height = v70;
      MinY = CGRectGetMinY(v84);
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 2056), "columns"), "objectAtIndexedSubscript:", 0), "wpBounds");
      if (MinY != CGRectGetMinY(v85))
        return 0;
    }
  }
  if (*(_QWORD *)(a1 + 48) <= a12)
    return 0;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    objc_msgSend(*(id *)(a1 + 2056), "layoutPositionFromAnchoredAttachmentPosition:", *a18, a18[1]);
    v64 = v63;
    v66 = v65;
  }
  else
  {
    v64 = *a18;
    v66 = a18[1];
  }
  -[TSDLayout setAdjustedInterimPositionY:](v36, "setAdjustedInterimPositionY:", v66);
  v68 = -[TSDDrawableInfo exteriorTextWrap](-[TSWPDrawableAttachment drawable](a11, "drawable"), "exteriorTextWrap");
  if (-[TSDExteriorTextWrap isHTMLWrap](v68, "isHTMLWrap") && -[TSDExteriorTextWrap direction](v68, "direction") == 2)
  {
    -[TSDLayout setAdjustedInterimPositionY:](v36, "setAdjustedInterimPositionY:", v66);
    if (a20)
    {
      v69 = *(id *)(a20 + 24);
      if (!v69)
      {
        v69 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
        *(_QWORD *)(a20 + 24) = v69;
      }
      objc_msgSend(v69, "addObject:", a11);
    }
  }
  else
  {
    -[TSDLayout setAdjustedInterimPositionX:](v36, "setAdjustedInterimPositionX:", v64);
    -[TSDAbstractLayout fixTransformFromInterimPosition](v36, "fixTransformFromInterimPosition");
  }
  if (-[TSWPDrawableAttachment drawable](a11, "drawable"))
    objc_msgSend(a16, "addObject:", -[TSWPDrawableAttachment drawable](a11, "drawable"));
  ++*a17;
  *a15 = a12 + 1;
  return 1;
}

double adjustedLayoutSize(TSDLayout *a1)
{
  double v2;
  double v3;
  void *v4;
  double v5;
  double v6;
  double v7;

  -[TSDAbstractLayout alignmentFrame](a1, "alignmentFrame");
  v3 = v2;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v4 = (void *)-[TSDLayout performSelector:](a1, "performSelector:", sel_stroke);
    if (!v4)
      goto LABEL_7;
LABEL_6:
    objc_msgSend(v4, "outsets", v5, v6, v7);
    return v3 - (v6 + v5);
  }
  -[TSDLayout info](a1, "info");
  if ((objc_opt_respondsToSelector() & 1) == 0)
  {
LABEL_7:
    v6 = 0.0;
    v5 = 0.0;
    return v3 - (v6 + v5);
  }
  v4 = (void *)-[TSDInfo performSelector:](-[TSDLayout info](a1, "info"), "performSelector:", sel_stroke);
  v7 = 0.0;
  v6 = 0.0;
  v5 = 0.0;
  if (v4)
    goto LABEL_6;
  return v3 - (v6 + v5);
}

double TSWPLayoutChore::pAdjustAnchorYPositionForVerticalAlignment(id *this, TSWPDrawableAttachment *a2, uint64_t a3, double a4)
{
  uint64_t CharacterStyleAtCharIndex;

  CharacterStyleAtCharIndex = TSWPLayoutChore::pGetCharacterStyleAtCharIndex(this, a3);
  return TSWPAttachmentVAlignmentCorrection(-[TSWPDrawableAttachment vAlignment](a2, "vAlignment"), CharacterStyleAtCharIndex, this[22], objc_msgSend(this[23], "scaleTextPercent"))+ a4;
}

uint64_t TSWPLayoutChore::pAnchoredGraphicAndTextCollisionsInTarget()
{
  uint64_t v0;
  void *v1;
  void *v2;
  uint64_t v3;
  void *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  void *v15;
  unint64_t v16;
  unint64_t v17;
  void *v18;
  uint64_t v19;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t i;
  void *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  void *v32;
  double v33;
  CGFloat v34;
  CGFloat v35;
  CGFloat v36;
  double v37;
  double v38;
  CGFloat v39;
  double v40;
  CGFloat v41;
  double v42;
  CGFloat v43;
  void *v44;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  uint64_t v48;
  uint64_t **v49;
  uint64_t v50;
  uint64_t v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  CGFloat v60;
  double v61;
  CGFloat v62;
  double v63;
  CGFloat v64;
  uint64_t v65;
  double v66;
  double v67;
  CGFloat v68;
  double v69;
  CGFloat v70;
  double v71;
  CGFloat v72;
  char v73;
  CGFloat *v74;
  CGFloat v75;
  CGFloat v76;
  CGFloat v77;
  uint64_t v79;
  void *v80;
  void *v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  void *v89;
  void *v90;
  uint64_t v91;
  _QWORD rect2[5];
  __int128 v93;
  __int128 v94;
  CGAffineTransform v95;
  CGAffineTransform v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  double v105[2];
  CGFloat v106[510];
  _BYTE v107[128];
  _BYTE v108[128];
  _QWORD v109[18];
  CGRect v110;
  CGRect v111;
  CGRect v112;
  CGRect v113;
  CGRect v114;
  CGRect v115;
  CGRect v116;
  CGRect v117;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v3 = v0;
  v109[16] = *MEMORY[0x24BDAC8D0];
  v4 = (void *)objc_msgSend(*(id *)(v0 + 2056), "columns");
  v5 = objc_msgSend((id)objc_msgSend(v4, "firstObject"), "anchoredRange");
  v6 = objc_msgSend((id)objc_msgSend(v4, "lastObject"), "anchoredRange");
  if (v5 <= v6 + v7)
    v8 = v6 + v7;
  else
    v8 = v5;
  if (v5 >= v6 + v7)
    v9 = v6 + v7;
  else
    v9 = v5;
  if (v9 != 0x7FFFFFFFFFFFFFFFLL && v8 != v9)
  {
    v11 = objc_msgSend(*(id *)(v3 + 8), "attachmentIndexRangeForTextRange:", v9, v8 - v9);
    if (v12)
    {
      v13 = v11;
      v14 = v12;
      v89 = v4;
      v15 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDBCEB8]), "initWithCapacity:", v12);
      v16 = v13 + v14;
      v91 = v3;
      if (v13 < v13 + v14)
      {
        v17 = v13;
        v90 = v2;
        do
        {
          objc_opt_class();
          objc_msgSend(*(id *)(v3 + 8), "attachmentAtAttachmentIndex:outCharIndex:", v17, 0);
          v18 = (void *)TSUDynamicCast();
          if (objc_msgSend(v18, "isAnchored"))
          {
            if ((objc_msgSend(v18, "isHTMLWrap") & 1) == 0)
            {
              v19 = objc_msgSend(v18, "drawable");
              if ((objc_opt_respondsToSelector() & 1) == 0
                || (objc_msgSend(*(id *)(v3 + 2056), "siblingTargetIsManipulatingDrawable:", v19) & 1) == 0)
              {
                if (objc_msgSend(*(id *)(v3 + 2056), "validatedLayoutForAnchoredDrawable:", objc_msgSend(v18, "drawable")))
                {
                  v20 = (void *)TSUProtocolCast();
                  if (v20)
                  {
                    v103 = 0u;
                    v104 = 0u;
                    v101 = 0u;
                    v102 = 0u;
                    v21 = (void *)objc_msgSend(v20, "descendentWrappables");
                    v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v101, v109, 16);
                    if (v22)
                    {
                      v23 = v22;
                      v24 = *(_QWORD *)v102;
                      do
                      {
                        for (i = 0; i != v23; ++i)
                        {
                          if (*(_QWORD *)v102 != v24)
                            objc_enumerationMutation(v21);
                          v26 = *(void **)(*((_QWORD *)&v101 + 1) + 8 * i);
                          if (objc_msgSend(v26, "wrapType")
                            && objc_msgSend(v26, "wrapType") != 5)
                          {
                            objc_msgSend(v15, "addObject:", v26);
                          }
                        }
                        v23 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v101, v109, 16);
                      }
                      while (v23);
                    }
                  }
                  v27 = (void *)TSUProtocolCast();
                  v2 = v90;
                  v3 = v91;
                  v16 = v13 + v14;
                  if (objc_msgSend(v27, "wrapType") && objc_msgSend(v27, "wrapType") != 5)
                    objc_msgSend(v15, "addObject:", v27);
                }
              }
            }
          }
          ++v17;
        }
        while (v17 != v16);
      }
      v99 = 0u;
      v100 = 0u;
      v97 = 0u;
      v98 = 0u;
      v28 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v97, v108, 16);
      if (v28)
      {
        v29 = *(_QWORD *)v98;
        v84 = *(_QWORD *)v98;
        do
        {
          v30 = 0;
          v31 = v89;
          v85 = v28;
          do
          {
            if (*(_QWORD *)v98 != v29)
              objc_enumerationMutation(v15);
            v86 = v30;
            v32 = *(void **)(*((_QWORD *)&v97 + 1) + 8 * v30);
            objc_msgSend(v32, "boundsInfluencingExteriorWrap");
            v37 = TSDRoundedRect(v33, v34, v35, v36);
            v39 = v38;
            v41 = v40;
            v43 = v42;
            v44 = *(void **)(v3 + 2056);
            if (v44)
              objc_msgSend(v44, "transformInRoot");
            else
              memset(&v95, 0, sizeof(v95));
            CGAffineTransformInvert(&v96, &v95);
            v110.origin.x = v37;
            v110.origin.y = v39;
            v110.size.width = v41;
            v110.size.height = v43;
            v111 = CGRectApplyAffineTransform(v110, &v96);
            rect2[0] = *(_QWORD *)&v111.origin.x;
            y = v111.origin.y;
            width = v111.size.width;
            height = v111.size.height;
            memset(&rect2[1], 0, 32);
            v93 = 0u;
            v94 = 0u;
            v87 = objc_msgSend(v31, "countByEnumeratingWithState:objects:count:", &rect2[1], v107, 16);
            if (v87)
            {
              v88 = *(_QWORD *)rect2[3];
              do
              {
                v48 = 0;
                while (2)
                {
                  if (*(_QWORD *)rect2[3] != v88)
                    objc_enumerationMutation(v31);
                  v49 = (uint64_t **)objc_msgSend(*(id *)(rect2[2] + 8 * v48), "lineFragmentArray");
                  v50 = **v49;
                  v51 = (*v49)[1];
                  while (v50 != v51)
                  {
                    v52 = *(double *)(*(_QWORD *)v50 + 48);
                    v53 = *(double *)(*(_QWORD *)v50 + 64);
                    v54 = *(double *)(*(_QWORD *)v50 + 128);
                    if (v54 < *(double *)(*(_QWORD *)v50 + 120))
                      v54 = *(double *)(*(_QWORD *)v50 + 120);
                    v55 = *(double *)(*(_QWORD *)v50 + 144) + *(double *)(*(_QWORD *)v50 + 136) + v54;
                    v56 = *(double *)(*(_QWORD *)v50 + 56) + *(double *)(*(_QWORD *)v50 + 112);
                    v112.origin.x = TSDRoundedRect(*(double *)(*(_QWORD *)v50 + 48), v56, *(CGFloat *)(*(_QWORD *)v50 + 64), v55);
                    *(_QWORD *)&v115.origin.x = rect2[0];
                    v115.origin.y = y;
                    v115.size.width = width;
                    v115.size.height = height;
                    if (CGRectIntersectsRect(v112, v115))
                    {
                      objc_msgSend(v2, "rectInRoot:", v52, v56, v53, v55);
                      v58 = v57;
                      v60 = v59;
                      v62 = v61;
                      v64 = v63;
                      LODWORD(v65) = +[TSWPTextWrapper splitLine:lineSegmentRects:polygon:type:skipHint:](TSWPTextWrapper, "splitLine:lineSegmentRects:polygon:type:skipHint:", v105, objc_msgSend(v32, "wrapPolygon"), 1, 0, v57, v59, v61, v63);
                      v66 = TSDRoundedRect(v58, v60, v62, v64);
                      v68 = v67;
                      v70 = v69;
                      v72 = v71;
                      if ((_DWORD)v65 != 1)
                      {
                        if ((_DWORD)v65)
                        {
                          v73 = 0;
                          v65 = v65;
                          v74 = v106;
                          do
                          {
                            if (*v74 >= 18.0)
                            {
                              v113.origin.x = TSDRoundedRect(*(v74 - 2), *(v74 - 1), *v74, v74[1]);
                              v116.origin.x = v66;
                              v116.origin.y = v68;
                              v116.size.width = v70;
                              v116.size.height = v72;
                              if (!CGRectEqualToRect(v113, v116))
                              {
                                v16 = v13 + v14;
                                goto LABEL_70;
                              }
                              v73 = 1;
                            }
                            v74 += 4;
                            --v65;
                          }
                          while (v65);
                          v16 = v13 + v14;
                          if ((v73 & 1) != 0)
                            goto LABEL_62;
                        }
LABEL_70:

                        v79 = objc_msgSend(v2, "anchoredDrawablesForRelayout");
                        if (v13 < v16)
                        {
                          v80 = (void *)v79;
                          do
                          {
                            objc_opt_class();
                            objc_msgSend(*(id *)(v91 + 8), "attachmentAtAttachmentIndex:outCharIndex:", v13, 0);
                            v81 = (void *)TSUDynamicCast();
                            if (objc_msgSend(v81, "isAnchored")
                              && (objc_msgSend(v80, "containsObject:", objc_msgSend(v81, "drawable")) & 1) == 0)
                            {
                              objc_msgSend(v80, "addObject:", objc_msgSend(v81, "drawable"));
                            }
                            ++v13;
                            --v14;
                          }
                          while (v14);
                        }
                        if (!objc_msgSend((id)objc_msgSend(v2, "anchoredDrawablesForRelayout"), "count"))
                        {
                          v82 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                          v83 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPLayoutChore::pAnchoredGraphicAndTextCollisionsInTarget(TSDLayout<TSWPLayoutTarget> *, NSString *&)");
                          objc_msgSend(v82, "handleFailureInFunction:file:lineNumber:description:", v83, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLayoutChore.mm"), 6715, CFSTR("Found collision but no anchored drawables"));
                        }
                        return 1;
                      }
                      v117.origin.x = TSDRoundedRect(v105[0], v105[1], v106[0], v106[1]);
                      v117.origin.y = v75;
                      v117.size.width = v76;
                      v117.size.height = v77;
                      v114.origin.x = v66;
                      v114.origin.y = v68;
                      v114.size.width = v70;
                      v114.size.height = v72;
                      if (!CGRectEqualToRect(v114, v117))
                        goto LABEL_70;
                    }
LABEL_62:
                    v50 += 16;
                  }
                  ++v48;
                  v3 = v91;
                  v31 = v89;
                  if (v48 != v87)
                    continue;
                  break;
                }
                v29 = v84;
                v87 = objc_msgSend(v89, "countByEnumeratingWithState:objects:count:", &rect2[1], v107, 16);
              }
              while (v87);
            }
            v30 = v86 + 1;
          }
          while (v86 + 1 != v85);
          v28 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v97, v108, 16);
        }
        while (v28);
      }

    }
  }
  return 0;
}

void std::vector<TSWPLayoutState>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        TSWPLayoutState::~TSWPLayoutState((TSWPLayoutState *)(v4 - 688));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<TSWPLayoutState>::__push_back_slow_path<TSWPLayoutState const&>(uint64_t *a1, const TSWPLayoutState *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v13;
  TSWPLayoutState *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0x82FA0BE82FA0BE83 * ((a1[1] - *a1) >> 4);
  v5 = v4 + 1;
  if (v4 + 1 > 0x5F417D05F417D0)
    std::vector<CGPoint>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x82FA0BE82FA0BE83 * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x2FA0BE82FA0BE8)
    v9 = 0x5F417D05F417D0;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPLayoutState>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (TSWPLayoutState *)&v10[688 * v4];
  v16 = &v10[688 * v9];
  TSWPLayoutState::TSWPLayoutState(v14, a2);
  v15 = (char *)v14 + 688;
  std::vector<TSWPLayoutState>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<TSWPLayoutState>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_217B382B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSWPLayoutState>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TSWPLayoutState>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x5F417D05F417D1)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(688 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TSWPLayoutState>,std::reverse_iterator<TSWPLayoutState*>,std::reverse_iterator<TSWPLayoutState*>,std::reverse_iterator<TSWPLayoutState*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  TSWPLayoutState *v12;

  v10 = 0;
  v11 = a7 - 688;
  while (a3 + v10 != a5)
  {
    v12 = (TSWPLayoutState *)(v11 + v10);
    v10 -= 688;
    TSWPLayoutState::TSWPLayoutState(v12, (const TSWPLayoutState *)(v10 + a3));
  }
  return a6;
}

id *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,TSWPLayoutState *,TSWPLayoutState *,TSWPLayoutState *,0>(id *a1, id *a2, id *a3)
{
  id *v4;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      TSWPLayoutState::operator=(a3, v4);
      v4 += 86;
      a3 += 86;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

_QWORD *std::shared_ptr<TSWPLineFragment>::shared_ptr[abi:ne180100]<TSWPLineFragment,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_24D82DC60;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_217B38464(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<TSWPLineFragment>::reset[abi:ne180100]((TSWPLineFragment **)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<TSWPLineFragment *,std::shared_ptr<TSWPLineFragment>::__shared_ptr_default_delete<TSWPLineFragment,TSWPLineFragment>,std::allocator<TSWPLineFragment>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x219A153B8);
}

TSWPLineFragment *std::unique_ptr<TSWPLineFragment>::reset[abi:ne180100](TSWPLineFragment **a1, TSWPLineFragment *a2)
{
  TSWPLineFragment *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    TSWPLineFragment::~TSWPLineFragment(result);
    JUMPOUT(0x219A153B8);
  }
  return result;
}

void TSWPLayoutChore::pCacheErasableInfos(std::__shared_weak_count *a1)
{
  unint64_t *p_shared_owners;
  unint64_t v3;

  p_shared_owners = (unint64_t *)&a1->__shared_owners_;
  do
    v3 = __ldaxr(p_shared_owners);
  while (__stlxr(v3 - 1, p_shared_owners));
  if (!v3)
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

uint64_t TSWPShapeStyleIdentifierString(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = TSWPShapePackageStringForPresetKind(a1);
  return String(v3, a2, (uint64_t)CFSTR("shapestyle"));
}

void sub_217B3D5E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28)
{
  uint64_t v28;
  void *v30;

  _Block_object_dispose(&a21, 8);
  if (__p)
  {
    a28 = (uint64_t)__p;
    operator delete(__p);
  }
  _Block_object_dispose((const void *)(v28 - 176), 8);
  v30 = *(void **)(v28 - 128);
  if (v30)
  {
    *(_QWORD *)(v28 - 120) = v30;
    operator delete(v30);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__22(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__22(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_217B3E70C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 112);
  if (v3)
  {
    *(_QWORD *)(v1 - 104) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t `anonymous namespace'::TSWPNumberFromArabicString(_anonymous_namespace_ *this, NSString *a2)
{
  void *v3;
  unint64_t result;
  void *v5;
  int v6;
  float v7;
  unsigned int v8;

  v3 = (void *)objc_msgSend(MEMORY[0x24BDD17A8], "scannerWithString:", this);
  v8 = 0;
  if (!objc_msgSend(v3, "scanInt:", &v8)
    || !objc_msgSend(v3, "isAtEnd")
    || (result = v8, (v8 & 0x80000000) != 0))
  {
    v7 = 0.0;
    v5 = (void *)objc_msgSend(MEMORY[0x24BDD17A8], "scannerWithString:", this);
    if (objc_msgSend(v5, "scanFloat:", &v7))
    {
      v6 = objc_msgSend(v5, "isAtEnd");
      result = 0x7FFFFFFFFFFFFFFFLL;
      if (v6)
      {
        if (v7 >= 0.0)
          return vcvtas_u32_f32(v7);
      }
    }
    else
    {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t `anonymous namespace'::TSWPNumberFromRomanUpperLabel(_anonymous_namespace_ *this, NSString *a2)
{
  char *v2;
  int v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = (char *)-[_anonymous_namespace_ UTF8String](this, "UTF8String");
  LOBYTE(v3) = *v2;
  if (!*v2)
    return 0;
  v4 = v2;
  v5 = 0;
  v6 = MEMORY[0x24BDAC740];
  while (1)
  {
    if ((v3 & 0x80) != 0)
    {
      if (!__maskrune((char)v3, 0x100uLL))
        return 0x7FFFFFFFFFFFFFFFLL;
    }
    else if ((*(_DWORD *)(v6 + 4 * (char)v3 + 60) & 0x100) == 0)
    {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    v7 = (*v4 & 0xFFFFFFFFFFFFFFDFLL) - 65;
    if (((0x34FE4F3uLL >> v7) & 1) != 0)
      return 0x7FFFFFFFFFFFFFFFLL;
    if (!v4[1])
      break;
    if (v9 <= v8)
    {
      v3 = v4[1];
    }
    else
    {
      v8 = v9 - v8;
      v3 = v4[2];
      ++v4;
    }
    v5 += v8;
    ++v4;
    if (!v3)
      return v5;
  }
  v5 += v8;
  return v5;
}

uint64_t `anonymous namespace'::TSWPNumberFromAlphaUpperLabel(_anonymous_namespace_ *this, NSString *a2)
{
  uint64_t v3;
  char *v4;
  char v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = -[_anonymous_namespace_ length](this, "length");
  v4 = (char *)-[_anonymous_namespace_ UTF8String](this, "UTF8String");
  v5 = *v4;
  if (!v3)
    return 26 * v3 + (char)(v5 & 0xDF) - 90;
  v6 = v4;
  v7 = 0;
  v8 = MEMORY[0x24BDAC740];
  while (1)
  {
    if (v5 < 0)
    {
      if (!__maskrune(v5, 0x100uLL))
        return 0x7FFFFFFFFFFFFFFFLL;
    }
    else if ((*(_DWORD *)(v8 + 4 * v5 + 60) & 0x100) == 0)
    {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    v5 = *v6;
    if (((v6[v7] ^ *v6) & 0xDF) != 0)
      break;
    if (v3 == ++v7)
      return 26 * v3 + (char)(v5 & 0xDF) - 90;
  }
  return 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t `anonymous namespace'::TSWPArabicLabelFromNumber(_anonymous_namespace_ *this)
{
  unsigned int v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;

  v1 = this;
  if (!(_DWORD)this)
  {
    v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *(anonymous namespace)::TSWPArabicLabelFromNumber");
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 468, CFSTR("Illegal value for arabic numeral topic label <= 0"));
  }
  if (v1 <= 1)
    v4 = 1;
  else
    v4 = v1;
  return objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%d"), v4);
}

void *`anonymous namespace'::TSWPRomanUpperLabelFromNumber(_anonymous_namespace_ *this)
{
  unsigned int v1;
  void *v2;
  uint64_t v3;
  unsigned int v4;
  void *v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  BOOL v10;

  v1 = this;
  if (!(_DWORD)this)
  {
    v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *(anonymous namespace)::TSWPRomanUpperLabelFromNumber");
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 579, CFSTR("Illegal value for roman numeral topic label <= 0"));
  }
  if (v1 <= 1)
    v4 = 1;
  else
    v4 = v1;
  v5 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
  v6 = 12;
  do
  {
    if (v4 >= v7)
    {
      do
      {
        objc_msgSend(v5, "appendString:", v8);
        v4 -= v7;
      }
      while (v4 >= v7);
    }
    v10 = v6-- != 0;
  }
  while (v4 && v10);
  return v5;
}

void *`anonymous namespace'::TSWPFootnoteSymbolFromNumber(_anonymous_namespace_ *this)
{
  int v1;
  void *v2;
  uint64_t v3;
  unint64_t v4;

  v1 = (int)this;
  v2 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
  v4 = ((unint64_t)(v1 - 1) >> 2) + 1;
  do
  {
    objc_msgSend(v2, "appendFormat:", CFSTR("%C"), v3);
    --v4;
  }
  while (v4);
  return v2;
}

id `anonymous namespace'::ideographicNumberStringForValue(uint64_t a1, unsigned int a2)
{
  void *v4;
  id v5;
  uint64_t v6;
  uint64_t (*v7)(_anonymous_namespace_ *__hidden, NSMutableString *, unsigned int);
  char *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  int v12;
  int v13;
  unsigned __int16 v15;
  void *v16;
  unsigned int v17;
  char v18;
  uint64_t (*v19)(_anonymous_namespace_ *__hidden, NSMutableString *, unsigned int);

  v4 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
  v5 = v4;
  v6 = a2;
  if ((_DWORD)a1)
  {
    v16 = v4;
    v17 = a2;
    v18 = 1;
    v19 = v7;
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithCharacters:length:", &v15, 1);
    if (a2 && a2 != 3)
    {
      v11 = (void *)objc_msgSend(MEMORY[0x24BDBCEB8], "arrayWithArray:", objc_msgSend(v5, "componentsSeparatedByString:", v10));
      objc_msgSend(v11, "removeObject:", &stru_24D82FEB0);
      v5 = (id)objc_msgSend((id)objc_msgSend(v11, "componentsJoinedByString:", v10), "mutableCopy");
      if ((unint64_t)objc_msgSend(v5, "length") >= 2)
      {
        v12 = objc_msgSend(v5, "characterAtIndex:", 0);
        v13 = objc_msgSend(v5, "characterAtIndex:", 1);
          && (v13 == *((unsigned __int16 *)v8 + 2)
        {
          objc_msgSend(v5, "deleteCharactersInRange:", 0, 1);
        }
      }
    }
    else
    {
      return (id)objc_msgSend((id)objc_msgSend(v5, "stringByReplacingOccurrencesOfString:withString:", v10, &stru_24D82FEB0), "mutableCopy");
    }
  }
  else
  {
  }
  return v5;
}

uint64_t `anonymous namespace'::TSWPCircledNumberLabelFromNumber(_anonymous_namespace_ *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t result;
  __int16 v7;

  if (!(_DWORD)this)
  {
    v2 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *(anonymous namespace)::TSWPCircledNumberLabelFromNumber");
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 891, CFSTR("Illegal value for circled number numeral topic label <= 0"));
  }
  v4 = 0;
  while (1)
  {
      break;
    if (++v4 == 3)
  }
  result = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithCharacters:length:", &v7, 1);
  if (!result)
  return result;
}

uint64_t `anonymous namespace'::TSWPArabicLabelFromNumberAndLocale(_anonymous_namespace_ *this, uint64_t a2, NSString *a3)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  id v7;
  uint64_t v8;

  LODWORD(v4) = (_DWORD)this;
  if (!(_DWORD)this)
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler", a3);
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *(anonymous namespace)::TSWPArabicLabelFromNumberAndLocale(unsigned int, NSString *)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 481, CFSTR("Illegal value for arabic numeral topic label <= 0"));
  }
  if (v4 <= 1)
    v4 = 1;
  else
    v4 = v4;
  v7 = objc_alloc_init(MEMORY[0x24BDD16F0]);
  objc_msgSend(v7, "setLocale:", (id)objc_msgSend(objc_alloc(MEMORY[0x24BDBCEA0]), "initWithLocaleIdentifier:", a2));
  v8 = objc_msgSend(v7, "stringFromNumber:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", v4));

  return v8;
}

uint64_t `anonymous namespace'::TSWPArabianAbjadLabelFromNumber(_anonymous_namespace_ *this, unsigned int a2, unsigned __int16 *a3)
{
  _anonymous_namespace_ *v3;
  int v4;
  void *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  _WORD __b[11];
  uint64_t v13;

  v3 = this;
  v13 = *MEMORY[0x24BDAC8D0];
  if (this >= 0xF4240)
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *(anonymous namespace)::TSWPArabianAbjadLabelFromNumber(uint)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 820, CFSTR("number out of bounds for algorithm"));
LABEL_6:
    v4 = v7 + 1;
    __b[v7] = 39;
    v3 = (_anonymous_namespace_ *)(v3 % 0x3E8);
    goto LABEL_7;
  }
  if (!(_DWORD)this)
  if (this >= 0x3E8)
    goto LABEL_6;
  v4 = 0;
LABEL_7:
  if (v8 >= 0xC)
  {
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *(anonymous namespace)::TSWPArabianAbjadLabelFromNumber(uint)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 844, CFSTR("string out of bounds"));
  }
  return objc_msgSend(MEMORY[0x24BDD17C8], "stringWithCharacters:length:", __b, v8);
}

uint64_t `anonymous namespace'::TSWPHebrewBiblicalLabelFromNumber(_anonymous_namespace_ *this, unsigned int a2, unsigned __int16 *a3)
{
  _anonymous_namespace_ *v3;
  int v4;
  void *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  _WORD __b[11];
  uint64_t v13;

  v3 = this;
  v13 = *MEMORY[0x24BDAC8D0];
  if (this >= 0xF4240)
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *(anonymous namespace)::TSWPHebrewBiblicalLabelFromNumber(uint)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 750, CFSTR("Hebrew number out of bounds for algorithm"));
LABEL_6:
    v4 = v7 + 1;
    __b[v7] = 39;
    v3 = (_anonymous_namespace_ *)(v3 % 0x3E8);
    goto LABEL_7;
  }
  if (!(_DWORD)this)
  if (this >= 0x3E8)
    goto LABEL_6;
  v4 = 0;
LABEL_7:
  if (v8 >= 0xC)
  {
    v9 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v10 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *(anonymous namespace)::TSWPHebrewBiblicalLabelFromNumber(uint)");
    objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 773, CFSTR("string out of bounds"));
  }
  return objc_msgSend(MEMORY[0x24BDD17C8], "stringWithCharacters:length:", __b, v8);
}

void *`anonymous namespace'::alphabeticLabelStringForValue(_anonymous_namespace_ *this, uint64_t a2, unint64_t a3)
{
  int v5;
  void *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  BOOL v11;

  v5 = (int)this;
  v6 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
  if (v5)
  {
    v7 = (v5 - 1);
    v8 = v7 / a3;
    if ((v7 / a3) <= 0x7FFFFFFE)
    {
      v9 = *(unsigned __int16 *)(a2 + 2 * (v7 % a3));
      if ((int)v8 >= 99)
        LODWORD(v8) = 99;
      v10 = v8 + 1;
      do
      {
        objc_msgSend(v6, "tsu_appendCharacter:", v9);
        v11 = v10-- != 0;
      }
      while (v10 != 0 && v11);
    }
  }
  return v6;
}

uint64_t std::accumulate[abi:nn180100]<`anonymous namespace'::IdeographicNumber *,unsigned int,`anonymous namespace'::BinderConvertIdeographicPowerOfTen<void (*)(NSMutableString *,unsigned int)>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  void *v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  BOOL v12;
  unsigned int v13;

  if (a1 != a2)
  {
    v7 = a1;
    do
    {
      v8 = *(void **)a4;
      v9 = *(_DWORD *)(a4 + 8);
      v10 = *(_DWORD *)v7;
      v11 = a3 / *(_DWORD *)v7;
      if ((_DWORD)a3 || !v10)
      {
        v12 = v11 == 1 && *(_BYTE *)(a4 + 12) == 0;
        if (!v12 || v9 && v9 != 3)
          (*(void (**)(_QWORD, _QWORD))(a4 + 16))(*(_QWORD *)a4, a3 / v10);
      }
      if (v10 <= a3)
        objc_msgSend(v8, "tsu_appendCharacter:", *(unsigned __int16 *)(v7 + 4));
      v13 = *(_DWORD *)v7;
      v7 += 8;
      a3 = a3 - v13 * v11;
    }
    while (v7 != a2);
  }
  return a3;
}

void *`anonymous namespace'::ideographicNumberStringForSmallValue(uint64_t a1, unsigned int a2)
{
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t (*v7)(_anonymous_namespace_ *__hidden, NSMutableString *, unsigned int);
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  void *v11;
  uint64_t v12;
  void *v14;
  unsigned int v15;
  char v16;
  uint64_t (*v17)(_anonymous_namespace_ *__hidden, NSMutableString *, unsigned int);

  if (a1 >> 4 >= 0x271)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSMutableString *(anonymous namespace)::ideographicNumberStringForSmallValue(unsigned int, TSWPListIdeographicType, BOOL)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 334, CFSTR("inValue too large for ideographicNumberStringForSmallValue"));
  }
  v6 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
  v14 = v6;
  v15 = a2;
  v16 = 0;
  v17 = v7;
  if (v8)
  {
    v9 = v8;
    v10 = a2;
    if (v8 >= 0xA)
    {
      v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
      objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, CFSTR("inDigit is larger than single digit"));
    }
  }
  return v6;
}

uint64_t `anonymous namespace'::appendMultipleIdeographicDigitsJapanese(_anonymous_namespace_ *this, NSMutableString *a2)
{
}

uint64_t `anonymous namespace'::appendMultipleIdeographicDigitsSimplifiedChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
}

uint64_t `anonymous namespace'::appendMultipleIdeographicDigitsTraditionalChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
}

uint64_t `anonymous namespace'::appendMultipleIdeographicDigitsFormalJapanese(_anonymous_namespace_ *this, NSMutableString *a2)
{
}

uint64_t `anonymous namespace'::appendMultipleIdeographicDigitsFormalSimplifiedChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
}

uint64_t `anonymous namespace'::appendMultipleIdeographicDigitsFormalTraditionalChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
}

uint64_t `anonymous namespace'::appendIdeographicDigitJapanese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  int v2;
  void *v4;
  uint64_t v5;

  v2 = (int)a2;
  if (a2 >= 0xA)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, CFSTR("inDigit is larger than single digit"));
  }
}

uint64_t `anonymous namespace'::appendIdeographicDigitSimplifiedChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  int v2;
  void *v4;
  uint64_t v5;

  v2 = (int)a2;
  if (a2 >= 0xA)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, CFSTR("inDigit is larger than single digit"));
  }
}

uint64_t `anonymous namespace'::appendIdeographicDigitTraditionalChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  int v2;
  void *v4;
  uint64_t v5;

  v2 = (int)a2;
  if (a2 >= 0xA)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, CFSTR("inDigit is larger than single digit"));
  }
}

uint64_t `anonymous namespace'::appendIdeographicDigitFormalJapanese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  int v2;
  void *v4;
  uint64_t v5;

  v2 = (int)a2;
  if (a2 >= 0xA)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, CFSTR("inDigit is larger than single digit"));
  }
}

uint64_t `anonymous namespace'::appendIdeographicDigitFormalSimplifiedChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  int v2;
  void *v4;
  uint64_t v5;

  v2 = (int)a2;
  if (a2 >= 0xA)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, CFSTR("inDigit is larger than single digit"));
  }
}

uint64_t `anonymous namespace'::appendIdeographicDigitFormalTraditionalChinese(_anonymous_namespace_ *this, NSMutableString *a2)
{
  int v2;
  void *v4;
  uint64_t v5;

  v2 = (int)a2;
  if (a2 >= 0xA)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v5 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void (anonymous namespace)::appendIdeographicDigit(NSMutableString *, unsigned int, TSWPListIdeographicType)");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 206, CFSTR("inDigit is larger than single digit"));
  }
}

void *`anonymous namespace'::cjkLabelStringForValue(_anonymous_namespace_ *this, uint64_t a2, unint64_t a3, int a4)
{
  unint64_t v7;
  void *v8;
  unsigned int v9;
  unint64_t v10;
  unsigned __int16 v11;

  LODWORD(v7) = (_DWORD)this;
  v8 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
  if ((_DWORD)v7)
  {
    v9 = 0;
    do
    {
      v10 = (v7 - 1);
      if (a4)
        v11 = *(_WORD *)(a2 + 2 * (v10 % a3)) + 96;
      else
        v11 = *(_WORD *)(a2 + 2 * (v10 % a3));
      objc_msgSend(v8, "tsu_insertCharacter:atIndex:", v11, 0);
      v7 = (v10 - (v10 % a3)) / a3;
      if (!(_DWORD)v7)
        break;
    }
    while (v9++ < 0x64);
  }
  return v8;
}

unint64_t `anonymous namespace'::toAbjadUnder1000(_anonymous_namespace_ *this, void *__b, unsigned __int16 *a3)
{
  unsigned int v4;
  unint64_t v5;
  void *v6;
  uint64_t v7;
  unsigned int v8;
  unint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;

  v4 = this;
  if (this >= 0x3E8)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler", a3);
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "uint (anonymous namespace)::toAbjadUnder1000(uint, unichar *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 785, CFSTR("number out of range"));
  }
  else if (this < 0x190)
  {
    v5 = 0;
    goto LABEL_6;
  }
  v5 = v4 / 0x190uLL;
  memset_pattern16(__b, &unk_217C2B170, (2 * v5));
LABEL_6:
  if (v4 % 0x190 >= 0x64)
  {
    v5 = (v5 + 1);
  }
  v8 = v4 % 0x190 % 0x64;
  if (v8 - 15 <= 1)
  {
    *((_WORD *)__b + v5) = 1610;
    v9 = (v5 + 2);
    v10 = v8 - 11;
    LODWORD(v5) = v5 + 1;
LABEL_14:
    v5 = v9;
    goto LABEL_15;
  }
  if (v8 >= 0xA)
  {
    v5 = (v5 + 1);
  }
  if (v4 % 0x190 % 0x64 % 0xA)
  {
    v10 = v4 % 0x190 % 0x64 % 0xA - 1;
    v9 = (v5 + 1);
    goto LABEL_14;
  }
LABEL_15:
  if (v5 >= 6)
  {
    v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler", a3);
    v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "uint (anonymous namespace)::toAbjadUnder1000(uint, unichar *)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 814, CFSTR("string out of range"));
  }
  return v5;
}

unint64_t `anonymous namespace'::toHebrewUnder1000(_anonymous_namespace_ *this, void *__b, unsigned __int16 *a3)
{
  unsigned int v4;
  unint64_t v5;
  void *v6;
  uint64_t v7;
  unsigned __int16 v8;
  unint64_t v9;
  __int16 v10;
  void *v11;
  uint64_t v12;

  v4 = this;
  if (this >= 0x3E8)
  {
    v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler", a3);
    v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "uint (anonymous namespace)::toHebrewUnder1000(uint, unichar *)");
    objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 715, CFSTR("number out of range"));
  }
  else if (this < 0x190)
  {
    v5 = 0;
    goto LABEL_6;
  }
  v5 = v4 / 0x190uLL;
  memset_pattern16(__b, &unk_217C2B180, (2 * v5));
LABEL_6:
  if (v4 % 0x190 >= 0x64)
  {
    *((_WORD *)__b + v5) = v4 % 0x190 / 0x64 + 1510;
    v5 = (v5 + 1);
  }
  v8 = v4 % 0x190 % 0x64;
  if (v8 - 15 <= 1)
  {
    *((_WORD *)__b + v5) = 1497;
    v9 = (v5 + 2);
    v10 = v8 + 1477;
    LODWORD(v5) = v5 + 1;
LABEL_14:
    *((_WORD *)__b + v5) = v10;
    v5 = v9;
    goto LABEL_15;
  }
  if (v4 % 0x190 % 0x64 >= 0xA)
  {
    v5 = (v5 + 1);
  }
  if (v4 % 0x190 % 0x64 % 0xA)
  {
    v10 = v4 % 0x190 % 0x64 % 0xA + 1487;
    v9 = (v5 + 1);
    goto LABEL_14;
  }
LABEL_15:
  if (v5 >= 6)
  {
    v11 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler", a3);
    v12 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "uint (anonymous namespace)::toHebrewUnder1000(uint, unichar *)");
    objc_msgSend(v11, "handleFailureInFunction:file:lineNumber:description:", v12, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/NSStringAdditions.mm"), 744, CFSTR("string out of range"));
  }
  return v5;
}

void sub_217B425E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__23(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__23(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_217B42808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void TSWPListLabel::TSWPListLabel(TSWPListLabel *this, TSDImageProvider *a2)
{
  *(_OWORD *)this = *MEMORY[0x24BDBF148];
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = a2;
  *((_QWORD *)this + 9) = 0;
  *((_WORD *)this + 40) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
}

{
  *(_OWORD *)this = *MEMORY[0x24BDBF148];
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = a2;
  *((_QWORD *)this + 9) = 0;
  *((_WORD *)this + 40) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
}

void TSWPListLabel::TSWPListLabel(TSWPListLabel *this, CFTypeRef cf, uint64_t a3)
{
  CGFloat *v4;
  CGFloat *v5;
  double TypographicBounds;
  CGFloat v7;
  CGFloat leading;

  *(_OWORD *)this = *MEMORY[0x24BDBF148];
  *((_QWORD *)this + 2) = cf;
  v4 = (CGFloat *)((char *)this + 48);
  *((_QWORD *)this + 9) = 0;
  *((_WORD *)this + 40) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 52) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  v5 = (CGFloat *)((char *)this + 40);
  *((_QWORD *)this + 11) = a3;
  *((_QWORD *)this + 12) = 0;
  CFRetain(cf);
  leading = 0.0;
  TypographicBounds = CTLineGetTypographicBounds(*((CTLineRef *)this + 2), v5, v4, &leading);
  v7 = *v5 + *((double *)this + 6);
  *(double *)this = TypographicBounds;
  *((CGFloat *)this + 1) = v7;
}

void TSWPListLabel::~TSWPListLabel(TSWPListLabel *this)
{
  const void *v2;
  const void *v3;

  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 12);
  if (v3)
    CFRelease(v3);

}

uint64_t TSWPListLabel::isEqual(TSWPListLabel *this, const TSWPListLabel *a2)
{
  BOOL v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  const void *v8;
  uint64_t result;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;

  if (!a2)
    return 0;
  v4 = *(double *)this == *(double *)a2 && *((double *)this + 1) == *((double *)a2 + 1);
  if (!v4
    || *((double *)this + 7) != *((double *)a2 + 7)
    || *((_DWORD *)this + 16) != *((_DWORD *)a2 + 16)
    || *((double *)this + 9) != *((double *)a2 + 9)
    || *((unsigned __int8 *)this + 81) != *((unsigned __int8 *)a2 + 81)
    || *((_QWORD *)this + 11) != *((_QWORD *)a2 + 11))
  {
    return 0;
  }
  v5 = *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 2))
  {
    if (v5)
    {
      v6 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v7 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPListLabel::isEqual(const TSWPListLabel *) const");
      objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPListLabel.mm"), 59, CFSTR("shouldn't have a text line and an image"));
    }
    v8 = (const void *)*((_QWORD *)a2 + 2);
    if (v8)
    {
      result = CFEqual(*((CFTypeRef *)this + 2), v8);
      if (!(_DWORD)result)
        return result;
      goto LABEL_17;
    }
    return 0;
  }
  if (v5)
  {
    v11 = *((_QWORD *)a2 + 3);
    v12 = objc_msgSend(*((id *)this + 3), "imageData");
    v13 = v12;
    if (v5 == v11)
    {
      if (!v12)
      {
        v17 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v18 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPListLabel::isEqual(const TSWPListLabel *) const");
        objc_msgSend(v17, "handleFailureInFunction:file:lineNumber:description:", v18, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPListLabel.mm"), 68, CFSTR("we assume that imageData will be non-nil and then compare by pointer, and so may end up with a false-positive here"));
      }
    }
    else
    {
      v14 = objc_msgSend(*((id *)a2 + 3), "imageData");
      if (!objc_msgSend(*((id *)this + 3), "imageData"))
      {
        v15 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v16 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPListLabel::isEqual(const TSWPListLabel *) const");
        objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPListLabel.mm"), 68, CFSTR("we assume that imageData will be non-nil and then compare by pointer, and so may end up with a false-positive here"));
      }
      if (v13 != v14)
        return 0;
    }
  }
  else if (*((_QWORD *)a2 + 2) || *((_QWORD *)a2 + 3))
  {
    return 0;
  }
LABEL_17:
  v10 = (void *)*((_QWORD *)this + 4);
  if (v10 == *((void **)a2 + 4))
    return 1;
  else
    return objc_msgSend(v10, "isEqual:");
}

double TSWPListLabel::naturalImageSize(TSWPListLabel *this)
{
  void *v1;
  double result;

  v1 = (void *)*((_QWORD *)this + 3);
  if (!v1)
    return *MEMORY[0x24BDBF148];
  objc_msgSend(v1, "naturalSize");
  return result;
}

const void *TSWPListLabel::labelFont(CTLineRef *this)
{
  CFArrayRef GlyphRuns;
  const void *result;
  const __CFDictionary *Attributes;

  GlyphRuns = CTLineGetGlyphRuns(this[2]);
  result = (const void *)-[__CFArray count](GlyphRuns, "count");
  if (result)
  {
    Attributes = CTRunGetAttributes((CTRunRef)-[__CFArray objectAtIndexedSubscript:](GlyphRuns, "objectAtIndexedSubscript:", 0));
    return CFDictionaryGetValue(Attributes, (const void *)*MEMORY[0x24BDC4C28]);
  }
  return result;
}

uint64_t comparePairs(objc_object *a1, objc_object *a2, void *a3)
{
  unint64_t v4;
  unint64_t v5;

  v4 = objc_msgSend((id)-[objc_object objectAtIndexedSubscript:](a1, "objectAtIndexedSubscript:", 1), "unsignedIntegerValue");
  v5 = objc_msgSend((id)-[objc_object objectAtIndexedSubscript:](a2, "objectAtIndexedSubscript:", 1), "unsignedIntegerValue");
  if (v4 < v5)
    return -1;
  else
    return v4 > v5;
}

BOOL TSWPAdornmentLine::merge(TSWPAdornmentLine *this, const TSWPAdornmentLine *a2)
{
  double y;
  double x;
  double v6;
  double v7;
  int var5;
  _BOOL8 result;
  int var6;
  double var3;
  BOOL v12;
  double v13;

  if (a2->var4 != this->var4)
    return 0;
  x = this->var0.x;
  y = this->var0.y;
  v7 = a2->var0.x;
  v6 = a2->var0.y;
  var5 = this->var5;
  result = CGColorEqualToColor(this->var2, a2->var2);
  if (!result)
    return result;
  if (vabdd_f64(x + this->var1, v7) >= 0.00999999978)
    return 0;
  if (a2->var5 != this->var5)
    return 0;
  var6 = a2->var6;
  if (var6 != this->var6
    || !var5 && (vabdd_f64(this->var3, a2->var3) >= 0.00999999978 || vabdd_f64(y, v6) >= 0.00999999978))
  {
    return 0;
  }
  if (a2->var9 != this->var9)
    return 0;
  this->var1 = v7 - x + a2->var1;
  if (!var5)
    goto LABEL_18;
  if (this->var8 && !a2->var8)
  {
    this->var0.y = v6;
    var3 = a2->var3;
LABEL_26:
    this->var3 = var3;
    goto LABEL_27;
  }
  if (this->var8 || !a2->var8)
  {
LABEL_18:
    if (var6 == 1)
      v12 = v6 < y;
    else
      v12 = y < v6;
    if (v12)
      v13 = v6;
    else
      v13 = y;
    this->var0.y = v13;
    var3 = this->var3;
    if (var3 < a2->var3)
      var3 = a2->var3;
    goto LABEL_26;
  }
LABEL_27:
  result = 1;
  if (this->var8 && !a2->var8)
    this->var8 = 0;
  return result;
}

void sub_217B462C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  TSWPAttributeEnumerator::~TSWPAttributeEnumerator((TSWPAttributeEnumerator *)va);
  _Unwind_Resume(a1);
}

void sub_217B469C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a9);
  _Unwind_Resume(a1);
}

void sub_217B46CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a9);
  _Unwind_Resume(a1);
}

void sub_217B47A38(_Unwind_Exception *a1, TSWPParagraphEnumerator *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a10);
  _Unwind_Resume(a1);
}

void sub_217B480E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  TSWPAttributeEnumerator::~TSWPAttributeEnumerator((TSWPAttributeEnumerator *)va);
  _Unwind_Resume(a1);
}

void sub_217B486F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  TSWPAttributeEnumerator::~TSWPAttributeEnumerator((TSWPAttributeEnumerator *)va);
  _Unwind_Resume(a1);
}

void sub_217B489D0(_Unwind_Exception *a1, TSWPParagraphEnumerator *a2, TSWPParagraphEnumerator *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a17);
  _Unwind_Resume(a1);
}

void sub_217B49774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a9);
  _Unwind_Resume(a1);
}

void sub_217B499A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, TSWPParagraphEnumerator *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a16);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__24(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

void sub_217B4B990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  TSWPAttributeEnumerator::~TSWPAttributeEnumerator((TSWPAttributeEnumerator *)va);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__199(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__200(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_217B4EDBC(_Unwind_Exception *a1, uint64_t a2, TSWPParagraphEnumerator *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a11);
  _Unwind_Resume(a1);
}

void sub_217B4F150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a9);
  _Unwind_Resume(a1);
}

void sub_217B4F4B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TSWPParagraphEnumerator *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a17);
  _Unwind_Resume(a1);
}

void sub_217B50D98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *std::__tree<std::__value_type<unsigned long,std::shared_ptr<TSWPParagraphTypesetter>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::shared_ptr<TSWPParagraphTypesetter>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::shared_ptr<TSWPParagraphTypesetter>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  uint64_t **v8;
  uint64_t **v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  _QWORD v14[2];
  char v15;

  v7 = a1 + 1;
  v6 = a1[1];
  v8 = a1 + 1;
  v9 = a1 + 1;
  if (v6)
  {
    v10 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v11 = v6[4];
        if (v10 >= v11)
          break;
        v6 = *v9;
        v8 = v9;
        if (!*v9)
          goto LABEL_9;
      }
      if (v11 >= v10)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    v12 = (uint64_t *)operator new(0x38uLL);
    v14[1] = v7;
    v12[4] = **a4;
    v12[5] = 0;
    v12[6] = 0;
    v15 = 1;
    std::__tree<std::__value_type<std::string,unsigned short>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned short>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned short>>>::__insert_node_at(a1, (uint64_t)v9, v8, v12);
    v14[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<unsigned long,std::shared_ptr<TSWPParagraphTypesetter>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned long,std::shared_ptr<TSWPParagraphTypesetter>>,void *>>>>::reset[abi:nn180100]((uint64_t)v14, 0);
    return v12;
  }
  return (uint64_t *)v9;
}

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned long,std::shared_ptr<TSWPParagraphTypesetter>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned long,std::shared_ptr<TSWPParagraphTypesetter>>,void *>>>>::reset[abi:nn180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::shared_ptr<EQKit::StemStretch::Glyph>::~shared_ptr[abi:nn180100]((uint64_t)v2 + 40);
    operator delete(v2);
  }
}

void TSWPParagraphTypesetter::pSetupTateChuYokoForParagraph(TSWPParagraphTypesetter *this)
{
  uint64_t *v2;
  void *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  void *v9;
  BOOL v10;
  _BOOL4 v11;
  __CFString *v12;
  unint64_t v13;
  const __CFAttributedString *v14;
  const __CFString *v15;
  const __CFString *Attribute;
  const __CFString *v17;
  _BOOL4 v18;
  char v19;
  unint64_t v20;
  CFTypeRef v21;
  uint64_t v22;
  const __CFAttributedString *Mutable;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  __CFString *v28;
  void *v29;
  const __CFDictionary *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  NSRange *v35;
  CFIndex location;
  NSUInteger length;
  unint64_t v38;
  CFIndex v39;
  uint64_t v40;
  uint64_t v41;
  const __CFDictionary *v42;
  const __CTFont *FontForStyle;
  double v44;
  double v45;
  const __CTTypesetter *v46;
  char *v47;
  CFIndex v48;
  const __CFString *v49;
  CFIndex v50;
  unint64_t v51;
  void *v52;
  uint64_t v53;
  const __CTLine *Line;
  double TypographicBounds;
  const __CFString *v56;
  CTRunDelegateRef v57;
  CTRunDelegateRef v58;
  char *v59;
  CFIndex v60;
  char *v61;
  char *v62;
  const void *v63;
  const __CFAllocator *alloc;
  unint64_t v65;
  uint64_t *contentsDeallocator;
  const __CFAllocator *contentsDeallocatora;
  __CFAttributedString *aStr;
  CFRange effectiveRange;
  CFTypeRef cf[5];
  CFRange v71;
  CFRange v72;
  CFRange v73;
  CFRange v74;
  CFRange v75;
  CFRange v76;
  CFRange v77;

  v2 = (uint64_t *)((char *)this + 104);
  if (*((_QWORD *)this + 13) != *((_QWORD *)this + 14))
  {
    v3 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v4 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPParagraphTypesetter::pSetupTateChuYokoForParagraph()");
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphTypesetter.mm"), 556, CFSTR("Should be no tate chu yoko runs prior to setup"));
    std::vector<_TSWPTateChuYokoRun>::__clear[abi:nn180100](v2);
  }
  v5 = 0;
  v6 = (uint64_t)(*((_QWORD *)this + 5) - *((_QWORD *)this + 4)) >> 1;
  contentsDeallocator = v2;
  v7 = 0x7FFFFFFFFFFFFFFFLL;
  do
  {
    if (v5 < v6
      && TSWPIsPotentialTateChuYokoCharacter(*(unsigned __int16 *)(*((_QWORD *)this + 4) + 2 * v5)))
    {
      if (v7 == 0x7FFFFFFFFFFFFFFFLL)
        v8 = v5;
      else
        v8 = v7;
      goto LABEL_50;
    }
    v8 = 0x7FFFFFFFFFFFFFFFLL;
    if (v7 == 0x7FFFFFFFFFFFFFFFLL)
      goto LABEL_50;
    v9 = (void *)objc_msgSend(*(id *)this, "smartFieldsWithAttributeKind:intersectingRange:", 7, v7, v5 - v7);
    if (v9)
      v10 = objc_msgSend(v9, "count") != 0;
    else
      v10 = 0;
    if (v5 <= v7)
    {
LABEL_30:
      v19 = 0;
      if (!v10)
        goto LABEL_33;
      goto LABEL_36;
    }
    v11 = 0;
    v12 = 0;
    v13 = v7;
    while (1)
    {
      v14 = (const __CFAttributedString *)*((_QWORD *)this + 7);
      v15 = (const __CFString *)String(45);
      Attribute = (const __CFString *)CFAttributedStringGetAttribute(v14, v13, v15, &effectiveRange);
      if (!Attribute)
        break;
      v17 = Attribute;
      v18 = CFStringGetLength(Attribute) != 0;
      if (v13 == v7)
      {
        v12 = (__CFString *)v17;
        v11 = v18;
      }
      if (((v18 ^ v11) & 1) != 0 || v12 && (-[__CFString isEqualToString:](v12, "isEqualToString:", v17) & 1) == 0)
        goto LABEL_32;
LABEL_26:
      if (effectiveRange.length)
        v13 = effectiveRange.location + effectiveRange.length;
      else
        ++v13;
      if (v13 >= v5)
        goto LABEL_30;
    }
    if (v13 == v7)
      v12 = 0;
    if (v13 == v7 || !v11)
    {
      v11 = 0;
      goto LABEL_26;
    }
LABEL_32:
    v19 = 1;
    if (v10)
      goto LABEL_36;
LABEL_33:
    if (v5 - v7 - 6 < 0xFFFFFFFFFFFFFFFCLL)
      v19 = 1;
    if ((v19 & 1) != 0)
    {
LABEL_36:
      if (v5 > v7)
      {
        do
          TSWPParagraphTypesetter::pConvertCharacterIndexToFullWidthNumber(this, v7++);
        while (v5 != v7);
      }
    }
    else
    {
      memset(cf, 0, sizeof(cf));
      effectiveRange.location = v7;
      effectiveRange.length = v5 - v7;
      v20 = *((_QWORD *)this + 14);
      if (v20 >= *((_QWORD *)this + 15))
      {
        v22 = std::vector<_TSWPTateChuYokoRun>::__push_back_slow_path<_TSWPTateChuYokoRun const&>(contentsDeallocator, (uint64_t)&effectiveRange);
      }
      else
      {
        *(CFRange *)v20 = effectiveRange;
        *(_QWORD *)(v20 + 16) = 0;
        *(_OWORD *)(v20 + 24) = *(_OWORD *)&cf[1];
        *(_OWORD *)(v20 + 40) = *(_OWORD *)&cf[3];
        if (cf[0])
        {
          CFRetain(cf[0]);
          v21 = cf[0];
        }
        else
        {
          v21 = 0;
        }
        *(_QWORD *)(v20 + 16) = v21;
        v22 = v20 + 56;
        *((_QWORD *)this + 14) = v20 + 56;
      }
      *((_QWORD *)this + 14) = v22;
      if (v5 > v7)
      {
        do
          TSWPParagraphTypesetter::pConvertCharacterIndexToNormalWidthNumber(this, v7++);
        while (v5 != v7);
      }
      if (cf[0])
        CFRelease(cf[0]);
    }
    v8 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_50:
    ++v5;
    v7 = v8;
  }
  while (v5 <= v6);
  if (*((_QWORD *)this + 13) != *((_QWORD *)this + 14))
  {
    alloc = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    Mutable = CFAttributedStringCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
    v24 = *((_QWORD *)this + 14) - *((_QWORD *)this + 13);
    if (v24)
    {
      v25 = 0;
      v26 = v24 / 56;
      if (v26 <= 1)
        v27 = 1;
      else
        v27 = v26;
      do
      {
        v28 = (__CFString *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCharactersNoCopy:length:freeWhenDone:", *((_QWORD *)this + 4) + 2 * *(_QWORD *)(*((_QWORD *)this + 13) + v25), *(_QWORD *)(*((_QWORD *)this + 13) + v25 + 8), 0);
        v71.location = CFAttributedStringGetLength(Mutable);
        v71.length = 0;
        CFAttributedStringReplaceString(Mutable, v71, v28);

        v25 += 56;
        --v27;
      }
      while (v27);
    }
    v29 = (void *)objc_msgSend(*(id *)this, "paragraphStyleAtCharIndex:effectiveRange:", 0, 0);
    v30 = (const __CFDictionary *)objc_msgSend(v29, "getTypesetterAttributes:scalePercent:isRightToLeft:", 0, *((_QWORD *)this + 1), 0);
    v72.length = CFAttributedStringGetLength(Mutable);
    aStr = Mutable;
    v72.location = 0;
    CFAttributedStringSetAttributes(Mutable, v72, v30, 1u);
    v31 = *((_QWORD *)this + 14) - *((_QWORD *)this + 13);
    if (v31)
    {
      v32 = 0;
      v33 = 0;
      v34 = v31 / 56;
      if (v34 <= 1)
        v34 = 1;
      v65 = v34;
      do
      {
        v35 = (NSRange *)(*contentsDeallocator + 56 * v33);
        location = v35->location;
        length = v35->length;
        v38 = length + v35->location;
        if (v35->location < v38)
        {
          v39 = v32 - location;
          do
          {
            v40 = objc_msgSend(*(id *)this, "characterStyleAtCharIndex:effectiveRange:", location, &effectiveRange);
            if (v40)
            {
              v41 = v40;
              effectiveRange = (CFRange)NSIntersectionRange(*v35, (NSRange)effectiveRange);
              v42 = (const __CFDictionary *)objc_msgSend(v29, "getTypesetterAttributes:scalePercent:isRightToLeft:", v41, *((_QWORD *)this + 1), 0);
              v73.location = v39 + location;
              v73.length = effectiveRange.length;
              CFAttributedStringSetAttributes(aStr, v73, v42, 1u);
            }
            location = effectiveRange.length + effectiveRange.location;
          }
          while (effectiveRange.length + effectiveRange.location < v38);
        }
        v32 += length;
        ++v33;
      }
      while (v33 != v65);
    }
    FontForStyle = TSWPFastCreateFontForStyle(0, v29, 0x64uLL);
    TSWPFontGetLineHeight();
    v45 = v44;
    CFRelease(FontForStyle);
    v46 = CTTypesetterCreateWithAttributedString(aStr);
    v47 = (char *)*((_QWORD *)this + 13);
    if (v47 != *((char **)this + 14))
    {
      v48 = 0;
      contentsDeallocatora = (const __CFAllocator *)*MEMORY[0x24BDBD258];
      v49 = (const __CFString *)*MEMORY[0x24BDC4F28];
      do
      {
        v51 = *(_QWORD *)v47;
        v50 = *((_QWORD *)v47 + 1);
        if (*((_QWORD *)v47 + 2))
        {
          v52 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v53 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPParagraphTypesetter::pSetupTateChuYokoForParagraph()");
          objc_msgSend(v52, "handleFailureInFunction:file:lineNumber:description:", v53, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphTypesetter.mm"), 702, CFSTR("Tate chu yoko line ref should be null"));
        }
        v74.location = v48;
        v74.length = v50;
        Line = CTTypesetterCreateLine(v46, v74);
        *((_QWORD *)v47 + 2) = Line;
        TypographicBounds = CTLineGetTypographicBounds(Line, (CGFloat *)v47 + 4, (CGFloat *)v47 + 5, (CGFloat *)v47 + 6);
        *((double *)v47 + 3) = TypographicBounds;
        if (TypographicBounds >= v45)
        {
          v60 = v50;
          if (v51 < v50 + v51)
          {
            do
            {
              TSWPParagraphTypesetter::pConvertCharacterIndexToFullWidthNumber(this, v51++);
              --v60;
            }
            while (v60);
          }
          std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,_TSWPTateChuYokoRun *,_TSWPTateChuYokoRun *,_TSWPTateChuYokoRun *,0>((uint64_t)(v47 + 56), *((_QWORD *)this + 14), (uint64_t)v47);
          v59 = v61;
          v62 = (char *)*((_QWORD *)this + 14);
          if (v62 != v61)
          {
            do
            {
              v63 = (const void *)*((_QWORD *)v62 - 5);
              if (v63)
                CFRelease(v63);
              v62 -= 56;
            }
            while (v62 != v59);
          }
          *((_QWORD *)this + 14) = v59;
        }
        else
        {
          LOWORD(effectiveRange.location) = 32;
          v56 = CFStringCreateWithCharactersNoCopy(alloc, (const UniChar *)&effectiveRange, 1, contentsDeallocatora);
          v75.location = v51;
          v75.length = 1;
          CFAttributedStringReplaceString(*((CFMutableAttributedStringRef *)this + 7), v75, v56);
          *(_WORD *)(*((_QWORD *)this + 4) + 2 * v51) = effectiveRange.location;
          CFRelease(v56);
          v57 = CTRunDelegateCreate(&gTateChuYokoWidthRunDelegateCallBacks, v47);
          v76.location = v51;
          v76.length = 1;
          CFAttributedStringSetAttribute(*((CFMutableAttributedStringRef *)this + 7), v76, v49, v57);
          CFRelease(v57);
          v58 = CTRunDelegateCreate(&gTateChuYokoWidthRunDelegateCallBacks, 0);
          v77.location = v51 + 1;
          v77.length = v50 - 1;
          CFAttributedStringSetAttribute(*((CFMutableAttributedStringRef *)this + 7), v77, v49, v58);
          CFRelease(v58);
          v47 += 56;
          v59 = (char *)*((_QWORD *)this + 14);
        }
        v48 += v50;
      }
      while (v47 != v59);
    }
    CFRelease(v46);
    CFRelease(aStr);
  }
}

void sub_217B53424(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf)
{
  uint64_t v16;
  uint64_t v17;

  *(_QWORD *)(v16 + 112) = v17;
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

double TSWPParagraphTypesetter::getPositionForLocalCharIndex(TSWPParagraphTypesetter *this, const TSWPLineFragment *a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  double v5;
  CFRange StringRange;
  double v9;

  v3 = *((_QWORD *)a2 + 24);
  v4 = *((_QWORD *)a2 + 25);
  v5 = 0.0;
  if (v3 != v4)
  {
    while (1)
    {
      StringRange = CTLineGetStringRange((CTLineRef)*(_QWORD *)v3);
      if (StringRange.location <= a3 && StringRange.location + StringRange.length >= a3)
        break;
      v3 += 48;
      if (v3 == v4)
        return v5;
    }
    v9 = *(double *)(v3 + 8);
    return v9 + CTLineGetOffsetForStringIndex(*(CTLineRef *)v3, a3, 0);
  }
  return v5;
}

unint64_t TSWPParagraphTypesetter::pCalculateRubyOverlap(uint64_t a1, unint64_t *a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v10;
  uint64_t v11;
  unint64_t result;
  const __CTLine *v13;
  double length;
  double v15;
  uint64_t v16;
  _BOOL4 v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  double v22;
  uint64_t v23;

  *a5 = 0;
  *a4 = 0;
  v10 = *(_QWORD *)(a3 + 8);
  v11 = *(_QWORD *)(a3 + 16);
  result = objc_msgSend(*(id *)a3, "baseTextScript");
  if ((_DWORD)result == 6)
  {
    v13 = *(const __CTLine **)(a3 + 24);
    if (v13)
      length = (double)(unint64_t)CTLineGetStringRange(v13).length;
    else
      length = 0.0;
    v15 = *(double *)(a3 + 32);
    result = objc_msgSend(*(id *)a1, "charRangeMappedToStorage:", v10, v11);
    v18 = result > *a2 && v10 != 0;
    v19 = result + v16 < a2[1] + *a2 && (unint64_t)(v11 + v10) < *(_QWORD *)(a1 + 24) + *(_QWORD *)(a1 + 16);
    v20 = 0;
    v21 = 0;
    v22 = v15 / length;
    if (v18)
      result = TSWPParagraphTypesetter::pAllowableRubyOverlapAtIndex((TSWPParagraphTypesetter *)a1, v22, v10 - 1);
    *a4 = v21;
    if (v19)
    {
      result = TSWPParagraphTypesetter::pAllowableRubyOverlapAtIndex((TSWPParagraphTypesetter *)a1, v22, v11 + v10);
      v20 = v23;
    }
    *a5 = v20;
  }
  return result;
}

BOOL TSWPParagraphTypesetter::rubyLayoutIsDisabledForField(TSWPParagraphTypesetter *this, TSWPRubyField *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  TSWPRubyField **i;

  v2 = *((_QWORD *)this + 10);
  v3 = *((_QWORD *)this + 11) - v2;
  if (!v3)
    return 0;
  v4 = v3 / 72;
  if (v4 <= 1)
    v4 = 1;
  for (i = (TSWPRubyField **)(v2 + 64); *(i - 8) != a2; i += 9)
  {
    if (!--v4)
      return 0;
  }
  return *(_BYTE *)i != 0;
}

TSWPParagraphTypesetter *TSWPParagraphTypesetter::disableRubyLayoutForField(TSWPParagraphTypesetter *this, TSWPRubyField *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  _BYTE *v5;

  v2 = *((_QWORD *)this + 10);
  v3 = *((_QWORD *)this + 11) - v2;
  if (v3)
  {
    v4 = v3 / 72;
    if (v4 <= 1)
      v4 = 1;
    v5 = (_BYTE *)(v2 + 64);
    do
    {
      if (*((TSWPRubyField **)v5 - 8) == a2)
        *v5 = 1;
      v5 += 72;
      --v4;
    }
    while (v4);
  }
  return this;
}

TSWPParagraphTypesetter *TSWPParagraphTypesetter::enableRubyLayoutForField(TSWPParagraphTypesetter *this, TSWPRubyField *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  TSWPRubyField **v5;

  v2 = *((_QWORD *)this + 10);
  v3 = *((_QWORD *)this + 11) - v2;
  if (v3)
  {
    v4 = v3 / 72;
    if (v4 <= 1)
      v4 = 1;
    v5 = (TSWPRubyField **)(v2 + 64);
    do
    {
      if (*(v5 - 8) == a2)
        *(_BYTE *)v5 = 0;
      v5 += 9;
      --v4;
    }
    while (v4);
  }
  return this;
}

uint64_t TSWPParagraphTypesetter::isZeroWidthTrailingSpace(TSWPParagraphTypesetter *this, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double *v5;
  unint64_t v6;

  v2 = *((_QWORD *)this + 10);
  v3 = *((_QWORD *)this + 11) - v2;
  if (v3)
  {
    v4 = v3 / 72;
    if (v4 <= 1)
      v4 = 1;
    v5 = (double *)(v2 + 56);
    do
    {
      v6 = *((_QWORD *)v5 - 5) + *((_QWORD *)v5 - 6);
      if (v6 <= a2)
        break;
      if (v6 - 1 == a2 && *v5 == 0.0)
        return 1;
      v5 += 9;
      --v4;
    }
    while (v4);
  }
  return 0;
}

void TSWPParagraphTypesetter::pAddRubyRunDelegateAtIndexForRun(uint64_t a1, CFIndex a2, uint64_t a3)
{
  _QWORD *v6;
  CTRunDelegateRef v7;
  CFRange v8;
  CFRange v9;

  v6 = (_QWORD *)operator new();
  *v6 = a1;
  v6[1] = a3;
  v7 = CTRunDelegateCreate(&TSWPParagraphTypesetter::pAddRubyRunDelegateAtIndexForRun(long,_TSWPRubyRun *)::rubyRunDelegateCallBacks, v6);
  v8.location = a2;
  v8.length = 1;
  CFAttributedStringSetAttribute(*(CFMutableAttributedStringRef *)(a1 + 56), v8, (CFStringRef)*MEMORY[0x24BDC4F28], v7);
  v9.location = a2;
  v9.length = 1;
  CFAttributedStringSetAttribute(*(CFMutableAttributedStringRef *)(a1 + 56), v9, CFSTR("TSWPRubySpacingRunAttribute"), MEMORY[0x24BDBD1C8]);
  CFRelease(v7);
}

TSWPParagraphTypesetter *TSWPParagraphTypesetter::TSWPRubyRunDelegateDeallocateCallback(TSWPParagraphTypesetter *this, void *a2)
{
  if (this)
    JUMPOUT(0x219A153B8);
  return this;
}

double TSWPParagraphTypesetter::TSWPRubyRunDelegateGetWidthCallback(TSWPParagraphTypesetter *this, void *a2)
{
  double result;
  uint64_t v3;

  result = 0.0;
  if (this)
  {
    v3 = *((_QWORD *)this + 1);
    if (v3)
    {
      if (!*(_BYTE *)(v3 + 64))
        return *(double *)(v3 + 56) * 0.5;
    }
  }
  return result;
}

void TSWPParagraphTypesetter::pConvertCharacterIndexToFullWidthNumber(TSWPParagraphTypesetter *this, unint64_t a2)
{
  uint64_t v2;
  int v5;
  int v6;
  const __CFString *v7;
  void *v8;
  uint64_t v9;
  UniChar chars;
  CFRange v11;

  v2 = *((_QWORD *)this + 4);
  if (a2 >= (*((_QWORD *)this + 5) - v2) >> 1)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPParagraphTypesetter::pConvertCharacterIndexToFullWidthNumber(const NSUInteger)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphTypesetter.mm"), 518, CFSTR("Access outside array"));
  }
  else
  {
    v5 = *(unsigned __int16 *)(v2 + 2 * a2);
    v6 = TSWPFullWidthCharacterForCharacter(*(unsigned __int16 *)(v2 + 2 * a2));
    chars = v6;
    if (v5 != v6)
    {
      v7 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], &chars, 1, (CFAllocatorRef)*MEMORY[0x24BDBD258]);
      v11.location = a2;
      v11.length = 1;
      CFAttributedStringReplaceString(*((CFMutableAttributedStringRef *)this + 7), v11, v7);
      *(_WORD *)(*((_QWORD *)this + 4) + 2 * a2) = chars;
      CFRelease(v7);
    }
  }
}

void TSWPParagraphTypesetter::pConvertCharacterIndexToNormalWidthNumber(TSWPParagraphTypesetter *this, unint64_t a2)
{
  uint64_t v2;
  int v5;
  int v6;
  const __CFString *v7;
  void *v8;
  uint64_t v9;
  UniChar chars;
  CFRange v11;

  v2 = *((_QWORD *)this + 4);
  if (a2 >= (*((_QWORD *)this + 5) - v2) >> 1)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPParagraphTypesetter::pConvertCharacterIndexToNormalWidthNumber(const NSUInteger)");
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphTypesetter.mm"), 536, CFSTR("Access outside array"));
  }
  else
  {
    v5 = *(unsigned __int16 *)(v2 + 2 * a2);
    v6 = TSWPNormalWidthCharacterForCharacter(*(unsigned __int16 *)(v2 + 2 * a2));
    chars = v6;
    if (v5 != v6)
    {
      v7 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], &chars, 1, (CFAllocatorRef)*MEMORY[0x24BDBD258]);
      v11.location = a2;
      v11.length = 1;
      CFAttributedStringReplaceString(*((CFMutableAttributedStringRef *)this + 7), v11, v7);
      *(_WORD *)(*((_QWORD *)this + 4) + 2 * a2) = chars;
      CFRelease(v7);
    }
  }
}

const __CTRun *TSWPParagraphTypesetter::pGetRunForLocalCharIndex(TSWPParagraphTypesetter *this, const TSWPLineFragment *a2, unint64_t a3)
{
  CTLineRef *v3;
  CTLineRef *v4;
  CFRange StringRange;
  CFArrayRef GlyphRuns;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CTRun *v13;
  CFRange v14;
  void *v16;
  uint64_t v17;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _BYTE v23[128];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v3 = (CTLineRef *)*((_QWORD *)a2 + 24);
  v4 = (CTLineRef *)*((_QWORD *)a2 + 25);
  if (v3 != v4)
  {
    while (1)
    {
      StringRange = CTLineGetStringRange(*v3);
      if (StringRange.location <= a3 && StringRange.location + StringRange.length > a3)
        break;
      v3 += 6;
      if (v3 == v4)
        goto LABEL_21;
    }
    GlyphRuns = CTLineGetGlyphRuns(*v3);
    v19 = 0u;
    v20 = 0u;
    v21 = 0u;
    v22 = 0u;
    v9 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v19, v23, 16);
    if (v9)
    {
      v10 = v9;
      v11 = *(_QWORD *)v20;
LABEL_10:
      v12 = 0;
      while (1)
      {
        if (*(_QWORD *)v20 != v11)
          objc_enumerationMutation(GlyphRuns);
        v13 = *(const __CTRun **)(*((_QWORD *)&v19 + 1) + 8 * v12);
        v14 = CTRunGetStringRange(v13);
        if (v14.location <= a3 && v14.location + v14.length > a3)
          break;
        if (v10 == ++v12)
        {
          v10 = -[__CFArray countByEnumeratingWithState:objects:count:](GlyphRuns, "countByEnumeratingWithState:objects:count:", &v19, v23, 16);
          if (v10)
            goto LABEL_10;
          goto LABEL_21;
        }
      }
      if (v13)
        return v13;
    }
  }
LABEL_21:
  v16 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v17 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "CTRunRef TSWPParagraphTypesetter::pGetRunForLocalCharIndex(const TSWPLineFragment *, NSUInteger) const");
  objc_msgSend(v16, "handleFailureInFunction:file:lineNumber:description:", v17, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPParagraphTypesetter.mm"), 793, CFSTR("Could not find run for local char index in line fragment"));
  return 0;
}

uint64_t TSWPParagraphTypesetter::pAllowableRubyOverlapAtIndex(TSWPParagraphTypesetter *this, double a2, uint64_t a3)
{
  UChar32 v3;
  uint64_t result;

  v3 = *(unsigned __int16 *)(*((_QWORD *)this + 4) + 2 * a3);
  result = TSWPScriptForCharacter(v3);
  if ((result - 3) < 2)
    return result;
  if (v3 <= 12288)
  {
    if (v3 <= 0x3B && ((1 << v3) & 0xC00500000000000) != 0)
      return result;
    if ((v3 - 8212) <= 0x12 && ((1 << (v3 - 20)) & 0x60001) != 0)
      return result;
LABEL_22:
    result = IsOpeningBracketCharacter(v3);
    if ((result & 1) == 0)
      return IsClosingBracketCharacter(v3);
    return result;
  }
  if (((v3 - 12289) > 0x34 || ((1 << (v3 - 1)) & 0x1C000000000003) == 0)
    && (v3 - 12539) >= 2)
  {
    goto LABEL_22;
  }
  return result;
}

uint64_t IsOpeningBracketCharacter(int a1)
{
  uint64_t result;
  int v3;

  result = 1;
  if (a1 <= 8219)
  {
    if (a1 <= 122)
    {
      if (a1 != 40 && a1 != 91)
        return 0;
      return result;
    }
    if (a1 == 123 || a1 == 171)
      return result;
    v3 = 8216;
  }
  else
  {
    if ((a1 - 12296) <= 0x15 && ((1 << (a1 - 8)) & 0x215155) != 0 || a1 == 8220)
      return result;
    v3 = 10629;
  }
  if (a1 != v3)
    return 0;
  return result;
}

uint64_t IsClosingBracketCharacter(int a1)
{
  uint64_t result;
  int v3;

  result = 1;
  if (a1 <= 8220)
  {
    if (a1 <= 124)
    {
      if (a1 != 41 && a1 != 93)
        return 0;
      return result;
    }
    if (a1 == 125 || a1 == 187)
      return result;
    v3 = 8217;
  }
  else
  {
    if ((a1 - 12297) <= 0x16 && ((1 << (a1 - 9)) & 0x415155) != 0 || a1 == 8221)
      return result;
    v3 = 10630;
  }
  if (a1 != v3)
    return 0;
  return result;
}

double TSWPParagraphTypesetter::pRubyRunDelegateGetWidth(uint64_t a1, uint64_t a2)
{
  double result;

  result = 0.0;
  if (a2)
  {
    if (!*(_BYTE *)(a2 + 64))
      return *(double *)(a2 + 56) * 0.5;
  }
  return result;
}

double TSWPTateChuYokoRunDelegateGetWidthCallback(double *a1)
{
  if (a1)
    return a1[4] + a1[5];
  else
    return 0.0;
}

CFTypeRef std::vector<TSWPLineRef>::__construct_one_at_end[abi:nn180100]<TSWPLineRef const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  CFTypeRef result;

  v3 = *(_QWORD *)(a1 + 8);
  result = *(CFTypeRef *)a2;
  *(_QWORD *)v3 = *(_QWORD *)a2;
  *(_OWORD *)(v3 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(v3 + 24) = *(_OWORD *)(a2 + 24);
  *(_DWORD *)(v3 + 40) = *(_DWORD *)(a2 + 40);
  if (result)
    result = CFRetain(result);
  *(_QWORD *)(a1 + 8) = v3 + 48;
  return result;
}

void sub_217B53EA0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPLineRef>::__push_back_slow_path<TSWPLineRef const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  void *v17[2];
  char *v18;
  char *v19;
  uint64_t v20;

  v2 = *a1;
  v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  v4 = v3 + 1;
  if (v3 + 1 > 0x555555555555555)
    abort();
  v8 = a1[2];
  v7 = (uint64_t)(a1 + 2);
  v9 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v2) >> 4);
  if (2 * v9 > v4)
    v4 = 2 * v9;
  if (v9 >= 0x2AAAAAAAAAAAAAALL)
    v10 = 0x555555555555555;
  else
    v10 = v4;
  v20 = v7;
  v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TSWPLineRef>>(v7, v10);
  v12 = &v11[48 * v3];
  v17[0] = v11;
  v17[1] = v12;
  v18 = v12;
  v19 = &v11[48 * v13];
  v14 = *(const void **)a2;
  *(_QWORD *)v12 = *(_QWORD *)a2;
  *(_OWORD *)(v12 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(v12 + 24) = *(_OWORD *)(a2 + 24);
  *((_DWORD *)v12 + 10) = *(_DWORD *)(a2 + 40);
  if (v14)
  {
    CFRetain(v14);
    v12 = v18;
  }
  v18 = v12 + 48;
  std::vector<TSWPLineRef>::__swap_out_circular_buffer(a1, v17);
  v15 = a1[1];
  std::__split_buffer<TSWPLineRef>::~__split_buffer(v17);
  return v15;
}

void sub_217B53FA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<TSWPLineRef>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<TSWPLineRef>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>,std::reverse_iterator<TSWPLineRef*>,std::reverse_iterator<TSWPLineRef*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<TSWPLineRef>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(48 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<TSWPLineRef>,std::reverse_iterator<TSWPLineRef*>,std::reverse_iterator<TSWPLineRef*>,std::reverse_iterator<TSWPLineRef*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  const void *v13;

  v7 = a7;
  if (a3 != a5)
  {
    v10 = a3;
    v11 = a7 - 24;
    do
    {
      v13 = *(const void **)(v10 - 48);
      v10 -= 48;
      v12 = v13;
      *(_QWORD *)(v11 - 24) = v13;
      *(_OWORD *)(v11 - 16) = *(_OWORD *)(v10 + 8);
      *(_OWORD *)v11 = *(_OWORD *)(v10 + 24);
      *(_DWORD *)(v11 + 16) = *(_DWORD *)(v10 + 40);
      if (v13)
        CFRetain(v12);
      v11 -= 48;
      v7 -= 48;
    }
    while (v10 != a5);
  }
  return a6;
}

void **std::__split_buffer<TSWPLineRef>::~__split_buffer(void **a1)
{
  std::__split_buffer<TSWPLineRef>::clear[abi:nn180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<TSWPLineRef>::clear[abi:nn180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  const void *v4;
  const void *v5;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  while (v1 != v2)
  {
    v5 = *(const void **)(v1 - 48);
    v1 -= 48;
    v4 = v5;
    *(_QWORD *)(a1 + 16) = v1;
    if (v5)
    {
      CFRelease(v4);
      v1 = *(_QWORD *)(a1 + 16);
    }
  }
}

void std::vector<_TSWPRubyRun>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<_TSWPRubyRun>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<_TSWPRubyRun>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  const void *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 72)
  {
    v4 = *(const void **)(i - 48);
    if (v4)
      CFRelease(v4);
  }
  a1[1] = v2;
}

void std::vector<_TSWPTateChuYokoRun>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<_TSWPTateChuYokoRun>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<_TSWPTateChuYokoRun>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  const void *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 56)
  {
    v4 = *(const void **)(i - 40);
    if (v4)
      CFRelease(v4);
  }
  a1[1] = v2;
}

uint64_t std::vector<_TSWPRubyRun>::__push_back_slow_path<_TSWPRubyRun const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  void *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v2 = *a1;
  v3 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  v4 = v3 + 1;
  if (v3 + 1 > 0x38E38E38E38E38ELL)
    abort();
  v8 = a1[2];
  v7 = (uint64_t)(a1 + 2);
  v9 = 0x8E38E38E38E38E39 * ((v8 - v2) >> 3);
  if (2 * v9 > v4)
    v4 = 2 * v9;
  if (v9 >= 0x1C71C71C71C71C7)
    v10 = 0x38E38E38E38E38ELL;
  else
    v10 = v4;
  v18 = v7;
  if (v10)
    v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::OpticalKern::Spec::Entry>>(v7, v10);
  else
    v11 = 0;
  v14 = v11;
  v15 = &v11[72 * v3];
  v17 = &v11[72 * v10];
  _TSWPRubyRun::_TSWPRubyRun((uint64_t)v15, a2);
  v16 = v15 + 72;
  std::vector<_TSWPRubyRun>::__swap_out_circular_buffer(a1, &v14);
  v12 = a1[1];
  std::__split_buffer<_TSWPRubyRun>::~__split_buffer(&v14);
  return v12;
}

void sub_217B54374(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<_TSWPRubyRun>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t _TSWPRubyRun::_TSWPRubyRun(uint64_t a1, uint64_t a2)
{
  const void *v3;
  uint64_t v5;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
  v3 = *(const void **)(a2 + 24);
  if (v3)
  {
    CFRetain(v3);
    v5 = *(_QWORD *)(a2 + 24);
  }
  else
  {
    v5 = 0;
  }
  *(_QWORD *)(a1 + 24) = v5;
  return a1;
}

uint64_t std::vector<_TSWPRubyRun>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  result = a2[1];
  while (v4 != v5)
  {
    v4 -= 72;
    result = _TSWPRubyRun::_TSWPRubyRun(result - 72, v4);
  }
  a2[1] = result;
  v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void **std::__split_buffer<_TSWPRubyRun>::~__split_buffer(void **a1)
{
  std::__split_buffer<_TSWPRubyRun>::clear[abi:nn180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<_TSWPRubyRun>::clear[abi:nn180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  const void *v4;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  while (v1 != v2)
  {
    *(_QWORD *)(a1 + 16) = v1 - 72;
    v4 = *(const void **)(v1 - 48);
    if (v4)
    {
      CFRelease(v4);
      v1 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v1 -= 72;
    }
  }
}

uint64_t std::vector<_TSWPTateChuYokoRun>::__push_back_slow_path<_TSWPTateChuYokoRun const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  void *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v2 = *a1;
  v3 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0x492492492492492)
    abort();
  v8 = a1[2];
  v7 = (uint64_t)(a1 + 2);
  v9 = 0x6DB6DB6DB6DB6DB7 * ((v8 - v2) >> 3);
  if (2 * v9 > v4)
    v4 = 2 * v9;
  if (v9 >= 0x249249249249249)
    v10 = 0x492492492492492;
  else
    v10 = v4;
  v18 = v7;
  if (v10)
    v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKit::ILayout>>(v7, v10);
  else
    v11 = 0;
  v14 = v11;
  v15 = &v11[56 * v3];
  v17 = &v11[56 * v10];
  _TSWPTateChuYokoRun::_TSWPTateChuYokoRun((uint64_t)v15, a2);
  v16 = v15 + 56;
  std::vector<_TSWPTateChuYokoRun>::__swap_out_circular_buffer(a1, &v14);
  v12 = a1[1];
  std::__split_buffer<_TSWPTateChuYokoRun>::~__split_buffer(&v14);
  return v12;
}

void sub_217B545F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<_TSWPTateChuYokoRun>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t _TSWPTateChuYokoRun::_TSWPTateChuYokoRun(uint64_t a1, uint64_t a2)
{
  const void *v3;
  uint64_t v5;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  v3 = *(const void **)(a2 + 16);
  if (v3)
  {
    CFRetain(v3);
    v5 = *(_QWORD *)(a2 + 16);
  }
  else
  {
    v5 = 0;
  }
  *(_QWORD *)(a1 + 16) = v5;
  return a1;
}

uint64_t std::vector<_TSWPTateChuYokoRun>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  result = a2[1];
  while (v4 != v5)
  {
    v4 -= 56;
    result = _TSWPTateChuYokoRun::_TSWPTateChuYokoRun(result - 56, v4);
  }
  a2[1] = result;
  v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void **std::__split_buffer<_TSWPTateChuYokoRun>::~__split_buffer(void **a1)
{
  std::__split_buffer<_TSWPTateChuYokoRun>::clear[abi:nn180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<_TSWPTateChuYokoRun>::clear[abi:nn180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  const void *v4;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  while (v1 != v2)
  {
    *(_QWORD *)(a1 + 16) = v1 - 56;
    v4 = *(const void **)(v1 - 40);
    if (v4)
    {
      CFRelease(v4);
      v1 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v1 -= 56;
    }
  }
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,_TSWPTateChuYokoRun *,_TSWPTateChuYokoRun *,_TSWPTateChuYokoRun *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      _TSWPTateChuYokoRun::operator=(a3, v4);
      v4 += 56;
      a3 += 56;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t _TSWPTateChuYokoRun::operator=(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  v4 = *(const void **)(a2 + 16);
  if (v4)
    CFRetain(v4);
  v5 = *(const void **)(a1 + 16);
  if (v5)
    CFRelease(v5);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  return a1;
}

uint64_t TSWPReplaceActionComparator_block_invoke(uint64_t a1, void *a2, void *a3)
{
  unint64_t v4;
  unint64_t v5;

  v4 = objc_msgSend(a2, "targetCharIndex");
  v5 = objc_msgSend(a3, "targetCharIndex");
  if (v4 < v5)
    return -1;
  else
    return v4 > v5;
}

void TSWPStyleAttributeArray::~TSWPStyleAttributeArray(TSWPAttributeArray *this)
{
  uint64_t v2;
  unint64_t v3;

  this->var0 = (void **)&off_24D82E248;
  if (this->var2)
  {
    v2 = 0;
    v3 = 0;
    do
    {
      (*((void (**)(TSWPAttributeArray *, char *))this->var0 + 24))(this, (char *)this->var4 + v2);
      ++v3;
      v2 += 16;
    }
    while (v3 < this->var2);
  }
  TSWPAttributeArray::~TSWPAttributeArray(this);
}

{
  TSWPStyleAttributeArray::~TSWPStyleAttributeArray(this);
  JUMPOUT(0x219A153B8);
}

void sub_217B5514C(_Unwind_Exception *a1)
{
  TSWPAttributeArray *v1;

  TSWPAttributeArray::~TSWPAttributeArray(v1);
  _Unwind_Resume(a1);
}

const char *TSWPStyleAttributeArray::className(TSWPStyleAttributeArray *this)
{
  return "TSWPStyleAttributeArray";
}

BOOL TSWPStyleAttributeArray::canCollapseAttributes(TSWPStyleAttributeArray *this, const TSWPAttributeRecord *a2, const TSWPAttributeRecord *a3)
{
  return *((_QWORD *)a2 + 1) == *((_QWORD *)a3 + 1);
}

uint64_t TSWPStyleAttributeArray::deleteAttributesInRangeWithString(uint64_t a1, _NSRange a2, uint64_t a3, uint64_t a4, uint64_t a5, TSWPStorageTransaction *a6)
{
  NSUInteger length;
  unint64_t location;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  NSUInteger v20;
  NSUInteger v21;
  NSRange v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  BOOL v44;
  unint64_t v45;
  void *v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  void *v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  NSRange v55;
  NSRange v56;
  NSRange v57;

  if (!(a2.length | a4))
    return 1;
  length = a2.length;
  location = a2.location;
  v10 = TSWPAttributeArray::calculateAttributeRangeForCharacterRange((TSWPAttributeArray *)a1, a2);
  v11 = v10;
  v13 = v12;
  if (v10
    && v10 < *(_QWORD *)(a1 + 16)
    && TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)a1, v10) > location)
  {
    --v11;
    ++v13;
    goto LABEL_12;
  }
  v14 = *(_QWORD *)(a1 + 16);
  if (!v14 || v11 != v14 || v13)
  {
LABEL_12:
    if (!v13)
      goto LABEL_91;
    goto LABEL_13;
  }
  --v11;
  if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * v11 + 8))
    goto LABEL_91;
  v55.location = TSWPAttributeArray::rangeForAttributeIndex((TSWPAttributeArray *)a1, v11);
  v57.location = location;
  v57.length = length;
  if (NSIntersectionRange(v55, v57).length)
    goto LABEL_11;
  if (length)
    goto LABEL_91;
  v48 = TSWPAttributeArray::rangeForAttributeIndex((TSWPAttributeArray *)a1, v11);
  v18 = 1;
  if (location >= v48 && location - v48 < v49)
  {
LABEL_11:
    v13 = 1;
LABEL_13:
    v15 = v13 + v11;
    if (a4)
    {
      if (v11 < v15)
      {
        v16 = 0;
        v17 = (16 * v11) | 8;
        v18 = 1;
        v19 = 0x7FFFFFFFFFFFFFFFLL;
        while (1)
        {
          v20 = TSWPAttributeArray::rangeForAttributeIndex((TSWPAttributeArray *)a1, v11);
          v22.location = v20;
          v22.length = v21;
          if (length)
          {
            v56.location = location;
            v56.length = length;
            if (NSIntersectionRange(v56, v22).length)
              goto LABEL_21;
          }
          else if (location >= v20 && location - v20 < v21)
          {
LABEL_21:
            if (v11)
            {
              if (v19 == 0x7FFFFFFFFFFFFFFFLL)
              {
                v18 = 0;
                if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + v17))
                {
                  v16 = 1;
                  v19 = v11;
                }
                else
                {
                  v19 = 0x7FFFFFFFFFFFFFFFLL;
                }
              }
              else
              {
                v18 = 0;
                ++v16;
              }
            }
            else
            {
              if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8))
                TSWPAttributeArray::replaceObjectForAttributeIndex((TSWPAttributeArray *)a1, 0, 0, 0, a6);
              v18 = 0;
            }
          }
          ++v11;
          v17 += 16;
          if (!--v13)
          {
            if (!v16)
              return v18 & 1;
LABEL_89:
            *(_BYTE *)(a1 + 56) = 0;
            (*(void (**)(uint64_t, uint64_t, unint64_t, TSWPStorageTransaction *))(*(_QWORD *)a1 + 56))(a1, v19, v16, a6);
            (*(void (**)(uint64_t, uint64_t, TSWPStorageTransaction *))(*(_QWORD *)a1 + 232))(a1, v19, a6);
            return v18 & 1;
          }
        }
      }
LABEL_91:
      v18 = 1;
      return v18 & 1;
    }
    if (v11 >= v15)
      goto LABEL_91;
    v51 = location;
    v52 = v13 + v11;
    v24 = 0;
    v16 = 0;
    v53 = location + length;
    v25 = (16 * v11) | 8;
    v26 = 0x7FFFFFFFFFFFFFFFLL;
    while (1)
    {
      v27 = v16;
      v28 = v11 + v24;
      v29 = TSWPAttributeArray::rangeForAttributeIndex((TSWPAttributeArray *)a1, v11 + v24);
      if (v29 >= location)
      {
        if (v29 != location)
        {
          if (v29 >= v53)
          {
            if (v29 > v53 && v28 && !*(_QWORD *)(*(_QWORD *)(a1 + 32) + v25))
            {
              v45 = v26;
              if (TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)a1, v11 + v24 - 1) < v53)
              {
                if (v26 == 0x7FFFFFFFFFFFFFFFLL)
                  v16 = 1;
                else
                  ++v16;
                if (v26 == 0x7FFFFFFFFFFFFFFFLL)
                  v45 = v11 + v24;
                if (v45 > v28 || v11 + v24 - v45 >= v16)
                {
                  v46 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
                  v47 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPStyleAttributeArray::deleteAttributesInRangeWithString(NSRange, NSString *, NSUInteger, markerArray &, TSWPStorageTransaction *)");
                  objc_msgSend(v46, "handleFailureInFunction:file:lineNumber:description:", v47, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStyleAttributeArray.mm"), 619, CFSTR("Deletion range should have been sequential and therefore incrementing it above should include this iteration(i)"));
                }
              }
              v26 = v45;
            }
            goto LABEL_81;
          }
LABEL_58:
          v44 = v26 == 0x7FFFFFFFFFFFFFFFLL;
          if (v26 == 0x7FFFFFFFFFFFFFFFLL)
            v16 = 1;
          else
            v16 = v27 + 1;
LABEL_61:
          if (v44)
            v26 = v11 + v24;
          goto LABEL_81;
        }
        v37 = v30;
        if (v28 != *(_QWORD *)(a1 + 16) - 1
          && TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)a1, v11 + v24 + 1) <= location)
        {
          v50 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v38 = v26;
          v39 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPStyleAttributeArray::deleteAttributesInRangeWithString(NSRange, NSString *, NSUInteger, markerArray &, TSWPStorageTransaction *)");
          v40 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStyleAttributeArray.mm");
          v41 = v39;
          v26 = v38;
          location = v51;
          objc_msgSend(v50, "handleFailureInFunction:file:lineNumber:description:", v41, v40, 549, CFSTR("Bad attributeRange."));
        }
        if (v52 < *(_QWORD *)(a1 + 16)
          && TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)a1, v52) == v53)
        {
          goto LABEL_58;
        }
        if (!v28)
          goto LABEL_54;
        if (v28 == *(_QWORD *)(a1 + 16) - 1)
        {
          v42 = objc_msgSend(*(id *)(a1 + 40), "length");
          v43 = *(_QWORD *)(a1 + 32);
          if (location + v37 >= v42 && *(_QWORD *)(v43 + v25))
            goto LABEL_58;
        }
        else
        {
          v43 = *(_QWORD *)(a1 + 32);
        }
        v16 = v27;
        if (!*(_QWORD *)(v43 + v25 - 16))
        {
          v44 = v26 == 0x7FFFFFFFFFFFFFFFLL;
          if (v26 == 0x7FFFFFFFFFFFFFFFLL)
            v16 = 1;
          else
            v16 = v27 + 1;
          goto LABEL_61;
        }
        if (*(_QWORD *)(v43 + v25))
LABEL_80:
          TSWPAttributeArray::replaceObjectForAttributeIndex((TSWPAttributeArray *)a1, 0, v11 + v24, 0, a6);
      }
      else
      {
        if (v28 + 1 != *(_QWORD *)(a1 + 16)
          && TSWPAttributeArray::charIndexForAttributeIndex((TSWPAttributeArray *)a1, v28 + 1) <= location)
        {
          v31 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
          v32 = v26;
          v33 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BOOL TSWPStyleAttributeArray::deleteAttributesInRangeWithString(NSRange, NSString *, NSUInteger, markerArray &, TSWPStorageTransaction *)");
          v34 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPStyleAttributeArray.mm");
          v35 = v33;
          v26 = v32;
          location = v51;
          objc_msgSend(v31, "handleFailureInFunction:file:lineNumber:description:", v35, v34, 516, CFSTR("Bad attributeRange."));
        }
        if (!v28)
        {
LABEL_54:
          if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8))
            TSWPAttributeArray::replaceObjectForAttributeIndex((TSWPAttributeArray *)a1, 0, 0, 0, a6);
          v16 = v27;
          goto LABEL_81;
        }
        v36 = *(_QWORD *)(a1 + 32);
        if (!*(_QWORD *)(v36 + v25 - 16))
          goto LABEL_58;
        v16 = v27;
        if (*(_QWORD *)(v36 + v25))
          goto LABEL_80;
      }
LABEL_81:
      ++v24;
      v25 += 16;
      if (v13 == v24)
      {
        v19 = v26;
        v18 = 0;
        if (!v16)
          return v18 & 1;
        goto LABEL_89;
      }
    }
  }
  return v18 & 1;
}

void TSWPStyleAttributeArray::adoptStylesheetWithMapper(TSWPAttributeArray *a1, uint64_t a2, void *a3)
{
  unint64_t var2;
  unint64_t v6;
  uint64_t v7;

  var2 = a1->var2;
  if (var2)
  {
    v6 = 0;
    v7 = 8;
    do
    {
      if (*(_QWORD *)((char *)a1->var4 + v7))
      {
        TSWPAttributeArray::replaceObjectForAttributeIndex(a1, (objc_object *)objc_msgSend(a3, "mappedStyleForStyle:"), v6, 0, 0);
        var2 = a1->var2;
      }
      ++v6;
      v7 += 16;
    }
    while (v6 < var2);
  }
}

uint64_t TSWPStyleAttributeArray::shouldDeleteAttributeBeforeReplace(TSWPStyleAttributeArray *this)
{
  return 1;
}

const char *TSWPStringAttributeArray::className(TSWPStringAttributeArray *this)
{
  return "TSWPStringAttributeArray";
}

void TSWPStringAttributeArray::~TSWPStringAttributeArray(TSWPAttributeArray *this)
{
  TSWPStyleAttributeArray::~TSWPStyleAttributeArray(this);
  JUMPOUT(0x219A153B8);
}

void TSWPLineBalancingRestoreLayoutInfo::TSWPLineBalancingRestoreLayoutInfo(TSWPLineBalancingRestoreLayoutInfo *this)
{
  TSWPParagraphEnumerator::TSWPParagraphEnumerator((TSWPParagraphEnumerator *)((char *)this + 24));
  bzero(this, 0x2B0uLL);
  *((_OWORD *)this + 43) = 0u;
}

{
  TSWPParagraphEnumerator::TSWPParagraphEnumerator((TSWPParagraphEnumerator *)((char *)this + 24));
  bzero(this, 0x2B0uLL);
  *((_OWORD *)this + 43) = 0u;
}

id *TSWPLineBalancingRestoreLayoutInfo::prepareForRestore(id *this, id *a2, int a3, int a4, double a5)
{
  id *result;

  result = TSWPLayoutState::operator=(this, a2);
  *((_DWORD *)this + 172) = a3;
  *((_DWORD *)this + 173) = a4;
  *((double *)this + 87) = a5;
  return result;
}

double TSWPLineBalancingRestoreLayoutInfo::restoreLocalState(uint64_t a1, TSWPLineFragmentArray **a2, _DWORD *a3, _DWORD *a4, double *a5)
{
  int v10;
  double result;
  _NSRange v12;

  v10 = TSWPLineFragmentArray::count(*a2);
  v12.location = *(unsigned int *)(a1 + 688);
  v12.length = (v10 - LODWORD(v12.location));
  TSWPLineFragmentArray::removeObjectsInRange(*a2, v12);
  *a3 = *(_DWORD *)(a1 + 688);
  *a4 = *(_DWORD *)(a1 + 692);
  result = *(double *)(a1 + 696);
  *a5 = result;
  return result;
}

void TSWPLineBalancingLayoutState::restoreLocalState(uint64_t a1, TSWPLineFragmentArray **a2, _DWORD *a3, _DWORD *a4, double *a5)
{
  TSWPLineBalancingRestoreLayoutInfo::restoreLocalState(a1, a2, a3, a4, a5);
  *(_DWORD *)(a1 + 732) = *a3;
  *(_QWORD *)(a1 + 744) = *(_QWORD *)(a1 + 736);
}

double TSWPLineBalancingLayoutState::pMaxLineWidth(TSWPLineBalancingLayoutState *this)
{
  double *v1;
  double *v2;
  double *v3;
  double v4;
  double *v5;
  double v6;
  double v7;

  v1 = (double *)*((_QWORD *)this + 92);
  v2 = (double *)*((_QWORD *)this + 93);
  if (v1 == v2)
    return 0.0;
  v3 = v1 + 1;
  if (v1 + 1 != v2)
  {
    v4 = *v1;
    v5 = v1 + 1;
    do
    {
      v6 = *v5++;
      v7 = v6;
      if (v4 < v6)
      {
        v4 = v7;
        v1 = v3;
      }
      v3 = v5;
    }
    while (v5 != v2);
  }
  return *v1;
}

double TSWPLineBalancingLayoutState::pComputeScore(TSWPLineBalancingLayoutState *this)
{
  double *v1;
  double result;
  double v3;

  v1 = (double *)*((_QWORD *)this + 92);
  result = 0.0;
  while (v1 != *((double **)this + 93))
  {
    v3 = *v1++;
    result = result + v3 * v3;
  }
  return result;
}

uint64_t TSWPLineBalancingLayoutState::forceCompletion(uint64_t this)
{
  int v1;
  double *v2;
  double *v3;
  double *v4;
  double *v5;
  double v6;
  double *v7;
  double v8;
  double v9;
  double v10;
  double v11;
  _QWORD *v12;
  int v13;

  v1 = *(_DWORD *)(this + 728);
  if (v1 == 2)
  {
    v12 = (_QWORD *)(this + 776);
    v13 = 3;
LABEL_15:
    *(_QWORD *)(this + 768) = *v12;
    *(_DWORD *)(this + 728) = v13;
    goto LABEL_16;
  }
  if (v1 == 1)
  {
    v2 = *(double **)(this + 736);
    v3 = *(double **)(this + 744);
    if (v2 == v3)
    {
      *(_QWORD *)(this + 776) = 0;
      v10 = 0.0;
    }
    else
    {
      v4 = v2 + 1;
      v5 = *(double **)(this + 736);
      if (v2 + 1 != v3)
      {
        v6 = *v2;
        v5 = *(double **)(this + 736);
        v7 = v2 + 1;
        do
        {
          v8 = *v7++;
          v9 = v8;
          if (v6 < v8)
          {
            v6 = v9;
            v5 = v4;
          }
          v4 = v7;
        }
        while (v7 != v3);
      }
      *(double *)(this + 776) = *v5;
      v10 = 0.0;
      do
      {
        v11 = *v2++;
        v10 = v10 + v11 * v11;
      }
      while (v2 != v3);
    }
    v13 = 0;
    *(double *)(this + 784) = v10;
    v12 = (_QWORD *)(this + 704);
    goto LABEL_15;
  }
LABEL_16:
  *(_BYTE *)(this + 792) = 1;
  return this;
}

double TSWPLineBalancingLayoutState::pUpdateWithEndOfParagraphOrColumn(TSWPLineBalancingLayoutState *this, uint64_t a2, int a3, double result)
{
  int v5;
  double *v6;
  double *v7;
  double *v8;
  double *v9;
  double v10;
  double *v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double *v16;
  double v17;
  double v18;
  void *v19;
  uint64_t v20;
  double *v21;
  double *v22;
  double *v23;
  double *v24;
  double v25;
  double *v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double *v31;
  double v32;
  int v33;
  uint64_t v34;
  double v35;
  double *v36;
  double v37;
  double *v38;
  double v39;
  double v40;
  double v41;

  v5 = *((_DWORD *)this + 182);
  switch(v5)
  {
    case 3:
      if (!*((_BYTE *)this + 792) && *((_QWORD *)this + 90) != a2)
      {
        v19 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v20 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPLineBalancingLayoutState::pUpdateWithEndOfParagraphOrColumn(const TSWPCharIndex, BOOL)");
        objc_msgSend(v19, "handleFailureInFunction:file:lineNumber:description:", v20, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineBalancingLayoutState.mm"), 224, CFSTR("Unexpected char index in final phase when layouting line balancing."));
      }
      *((_DWORD *)this + 182) = 0;
      result = *((double *)this + 88);
      goto LABEL_17;
    case 2:
      v21 = (double *)*((_QWORD *)this + 93);
      v22 = (double *)*((_QWORD *)this + 92);
      if (*((_QWORD *)this + 89) != v21 - v22 || *((_QWORD *)this + 90) != a2)
      {
        result = *((double *)this + 97);
        *((double *)this + 96) = result;
        v33 = 3;
LABEL_37:
        *((_DWORD *)this + 182) = v33;
        return result;
      }
      if (v22 == v21)
      {
        v29 = *((double *)this + 96);
        v30 = 0.0;
        if (v29 >= 0.0)
          goto LABEL_42;
      }
      else
      {
        v23 = v22 + 1;
        v24 = (double *)*((_QWORD *)this + 92);
        if (v22 + 1 != v21)
        {
          v25 = *v22;
          v24 = (double *)*((_QWORD *)this + 92);
          v26 = v22 + 1;
          do
          {
            v27 = *v26++;
            v28 = v27;
            if (v25 < v27)
            {
              v25 = v28;
              v24 = v23;
            }
            v23 = v26;
          }
          while (v26 != v21);
        }
        v29 = *((double *)this + 96);
        if (*v24 <= v29)
        {
          v30 = 0.0;
          v31 = (double *)*((_QWORD *)this + 92);
          do
          {
            v32 = *v31++;
            v30 = v30 + v32 * v32;
          }
          while (v31 != v21);
LABEL_42:
          if (v30 < *((double *)this + 98))
          {
            *((double *)this + 97) = v29;
            *((double *)this + 98) = v30;
          }
          goto LABEL_44;
        }
      }
      *((double *)this + 95) = *((double *)this + 95) + 1.0;
LABEL_44:
      result = 0.0;
      v35 = 0.0;
      if (v22 != v21)
      {
        v36 = v22 + 1;
        if (v22 + 1 != v21)
        {
          v37 = *v22;
          v38 = v22 + 1;
          do
          {
            v39 = *v38++;
            v40 = v39;
            if (v37 < v39)
            {
              v37 = v40;
              v22 = v36;
            }
            v36 = v38;
          }
          while (v38 != v21);
        }
        v35 = *v22;
      }
      v41 = v35 - *((double *)this + 95);
      if (v41 >= 0.0)
        result = v41;
LABEL_17:
      *((double *)this + 96) = result;
      return result;
    case 1:
      *((_QWORD *)this + 95) = 0x3FF0000000000000;
      v6 = (double *)*((_QWORD *)this + 92);
      v7 = (double *)*((_QWORD *)this + 93);
      if (v6 == v7)
      {
        *((_QWORD *)this + 97) = 0;
        v15 = 0.0;
        v18 = -1.0;
      }
      else
      {
        v8 = v6 + 1;
        v9 = (double *)*((_QWORD *)this + 92);
        if (v6 + 1 != v7)
        {
          v10 = *v6;
          v9 = (double *)*((_QWORD *)this + 92);
          v11 = v6 + 1;
          do
          {
            v12 = *v11++;
            v13 = v12;
            if (v10 < v12)
            {
              v10 = v13;
              v9 = v8;
            }
            v8 = v11;
          }
          while (v11 != v7);
        }
        v14 = *v9;
        *((double *)this + 97) = *v9;
        v15 = 0.0;
        v16 = v6;
        do
        {
          v17 = *v16++;
          v15 = v15 + v17 * v17;
        }
        while (v16 != v7);
        v18 = v14 + -1.0;
      }
      *((double *)this + 98) = v15;
      v34 = (char *)v7 - (char *)v6;
      *((_QWORD *)this + 89) = v34 >> 3;
      *((_QWORD *)this + 90) = a2;
      if (v34 != 8 && !a3)
      {
        result = 0.0;
        if (v18 >= 0.0)
          result = v18;
        *((double *)this + 96) = result;
        v33 = 2;
        goto LABEL_37;
      }
      result = *((double *)this + 88);
      *((double *)this + 96) = result;
      *((_DWORD *)this + 182) = 0;
      break;
  }
  return result;
}

double TSWPLineBalancingLayoutState::updateWithEndOfColumn(TSWPLineBalancingLayoutState *this, uint64_t a2, double a3)
{
  return TSWPLineBalancingLayoutState::pUpdateWithEndOfParagraphOrColumn(this, a2, 0, a3);
}

BOOL FloatArraysEqual(double *a1, double *a2, unint64_t a3)
{
  unint64_t v3;
  unsigned int v4;
  double v5;
  double v6;
  _BOOL8 v7;

  if (!a3)
    return 1;
  v3 = 0;
  v4 = 1;
  do
  {
    v5 = a1[v3];
    v6 = a2[v3];
    v7 = v5 == v6;
    v3 = v4++;
  }
  while (v5 == v6 && v3 < a3);
  return v7;
}

TSWPLineFragmentArray *TSWPLineFragmentArray::disableClippingForObjectAtIndex(TSWPLineFragmentArray *this, unint64_t a2)
{
  if (a2 < (uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 4)
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)this + 16 * a2) + 24) |= 0x1000000u;
  return this;
}

uint64_t TSWPLineFragmentArray::firstObject(TSWPLineFragmentArray *this)
{
  if (*((_QWORD *)this + 1) == *(_QWORD *)this)
    return 0;
  else
    return **(_QWORD **)this;
}

uint64_t TSWPLineFragmentArray::removeLastObject(TSWPLineFragmentArray *this)
{
  uint64_t v2;
  uint64_t result;
  __int16 v4;

  v2 = *((_QWORD *)this + 1);
  result = std::shared_ptr<EQKit::StemStretch::Glyph>::~shared_ptr[abi:nn180100](v2 - 16);
  *((_QWORD *)this + 1) = result;
  if (*(_QWORD *)this == result)
    v4 = 0;
  else
    v4 = *(_WORD *)(*(_QWORD *)(v2 - 32) + 552);
  *((_WORD *)this + 12) = v4;
  return result;
}

uint64_t TSWPLineFragmentArray::removeObjectsInRange(TSWPLineFragmentArray *this, _NSRange a2)
{
  uint64_t result;
  uint64_t *v4;
  uint64_t *v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  result = std::vector<std::shared_ptr<TSWPLineFragment>>::erase((uint64_t)this, *(_QWORD *)this + 16 * a2.location, *(_QWORD *)this + 16 * a2.location + 16 * a2.length);
  *((_WORD *)this + 12) = 0;
  v4 = *(uint64_t **)this;
  v5 = (uint64_t *)*((_QWORD *)this + 1);
  if (*(uint64_t **)this != v5)
  {
    v6 = 0;
    v7 = 0x7FFFFFFFFFFFFFFFLL;
    do
    {
      v9 = *v4;
      v4 += 2;
      v8 = v9;
      v10 = *(unsigned __int16 *)(v9 + 552);
      if (v7 != v10)
        ++v6;
      *(_WORD *)(v8 + 552) = v6 - 1;
      v7 = v10;
    }
    while (v4 != v5);
    *((_WORD *)this + 12) = v6;
  }
  return result;
}

uint64_t std::vector<std::shared_ptr<TSWPLineFragment>>::erase(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a2 != a3)
  {
    v5 = a3;
    v6 = *(_QWORD *)(a1 + 8);
    if (a3 == v6)
    {
      v8 = a2;
    }
    else
    {
      v7 = 16 * ((a3 - a2) >> 4);
      v8 = a2;
      do
      {
        std::shared_ptr<EQKit::OpticalKern::Edge::Path>::operator=[abi:nn180100](v8, (__int128 *)(v8 + v7));
        v8 += 16;
      }
      while (v8 + v7 != v6);
      v5 = *(_QWORD *)(a1 + 8);
    }
    while (v5 != v8)
      v5 = std::shared_ptr<EQKit::StemStretch::Glyph>::~shared_ptr[abi:nn180100](v5 - 16);
    *(_QWORD *)(a1 + 8) = v8;
  }
  return a2;
}

uint64_t TSWPLineFragmentArray::removeAllObjects(TSWPLineFragmentArray *this)
{
  uint64_t result;
  uint64_t v3;

  result = *((_QWORD *)this + 1);
  v3 = *(_QWORD *)this;
  while (result != v3)
    result = std::shared_ptr<EQKit::StemStretch::Glyph>::~shared_ptr[abi:nn180100](result - 16);
  *((_QWORD *)this + 1) = v3;
  *((_WORD *)this + 12) = 0;
  return result;
}

__n64 TSWPLineFragmentArray::boundsRect(TSWPLineFragmentArray *this)
{
  __n64 result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;

  result.n64_u64[0] = *MEMORY[0x24BDBF070];
  v2 = *(_QWORD *)(MEMORY[0x24BDBF070] + 8);
  v3 = *(_QWORD *)(MEMORY[0x24BDBF070] + 16);
  v4 = *(_QWORD *)(MEMORY[0x24BDBF070] + 24);
  v5 = *(uint64_t **)this;
  v6 = (uint64_t *)*((_QWORD *)this + 1);
  while (v5 != v6)
  {
    v7 = *v5;
    v5 += 2;
    *(CGRect *)result.n64_u64 = CGRectUnion(*(CGRect *)result.n64_u64, *(CGRect *)(v7 + 48));
  }
  return result;
}

TSWPLineFragmentArray *TSWPLineFragmentArray::incrementStartCharIndexes(TSWPLineFragmentArray *this, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v5;

  v2 = *(uint64_t **)this;
  v3 = (uint64_t *)*((_QWORD *)this + 1);
  if (*(uint64_t **)this != v3)
  {
    do
    {
      v5 = *v2;
      v2 += 2;
      *(_QWORD *)v5 += a2;
      *(_QWORD *)(v5 + 16) += a2;
      this = (TSWPLineFragmentArray *)objc_msgSend(*(id *)(v5 + 184), "adjustRangesByDelta:", a2);
      *(_QWORD *)(v5 + 496) = *(_QWORD *)(v5 + 488);
    }
    while (v2 != v3);
  }
  return this;
}

void TSWPLineFragmentArray::offsetLineFragmentsBy(TSWPLineFragmentArray *this, CGPoint a2)
{
  TSWPLineFragment **v2;
  TSWPLineFragment **v3;
  CGFloat y;
  CGFloat x;
  TSWPLineFragment *v6;
  CGPoint v7;

  v2 = *(TSWPLineFragment ***)this;
  v3 = (TSWPLineFragment **)*((_QWORD *)this + 1);
  if (*(TSWPLineFragment ***)this != v3)
  {
    y = a2.y;
    x = a2.x;
    do
    {
      v6 = *v2;
      v2 += 2;
      v7.x = x;
      v7.y = y;
      TSWPLineFragment::offsetBy(v6, v7);
    }
    while (v2 != v3);
  }
}

void TSWPLineFragmentArray::setStorage(TSWPLineFragmentArray *this, TSWPStorage *a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t *v4;
  id v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;

  v3 = *(uint64_t **)this;
  v4 = (uint64_t *)*((_QWORD *)this + 1);
  if (*(uint64_t **)this != v4)
  {
    v7 = 0;
    do
    {
      v9 = *v3;
      v8 = (std::__shared_weak_count *)v3[1];
      v15 = *v3;
      v16 = v8;
      if (v8)
      {
        p_shared_owners = (unint64_t *)&v8->__shared_owners_;
        do
          v11 = __ldxr(p_shared_owners);
        while (__stxr(v11 + 1, p_shared_owners));
      }

      *(_QWORD *)(v9 + 184) = 0;
      *(_QWORD *)v9 += a3;
      *(_QWORD *)(v9 + 16) += a3;
      objc_msgSend(0, "adjustRangesByDelta:", a3);
      *(_QWORD *)(v9 + 496) = *(_QWORD *)(v9 + 488);
      v12 = *(_QWORD *)(v9 + 16);
      if (!v7 || v12)
        v7 = -[TSWPStorage textSourceForLayoutInRange:](a2, "textSourceForLayoutInRange:", v12, objc_msgSend(*(id *)(v9 + 512), "length", v15, v16));
      *(_QWORD *)(v15 + 184) = v7;
      if (v16)
      {
        v13 = (unint64_t *)&v16->__shared_owners_;
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v3 += 2;
    }
    while (v3 != v4);
  }
}

void sub_217B56C98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<EQKit::StemStretch::Glyph>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t TSWPLineFragmentArray::lineFragmentCountForBaseline(TSWPLineFragmentArray *this, double a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  double v5;

  v2 = *(_QWORD *)this;
  v3 = *((_QWORD *)this + 1);
  if (*(_QWORD *)this == v3)
  {
    return 0;
  }
  else
  {
    v4 = 0;
    do
    {
      v5 = *(double *)(*(_QWORD *)v2 + 32) + *(double *)(*(_QWORD *)v2 + 40);
      if (v5 == a2)
      {
        ++v4;
      }
      else if (v5 > a2)
      {
        return v4;
      }
      v2 += 16;
    }
    while (v2 != v3);
  }
  return v4;
}

uint64_t TSWPLineFragmentArray::findLineIndexForCharIndex(TSWPLineFragmentArray *this, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;

  v2 = *((_QWORD *)this + 1);
  v3 = v2 - *(_QWORD *)this + 16;
  while (v2 != *(_QWORD *)this)
  {
    v4 = *(unint64_t **)(v2 - 16);
    v2 -= 16;
    v3 -= 16;
    if (*v4 < a2)
      return v3 >> 4;
  }
  return 0;
}

void TSWPChangeEnumerator::TSWPChangeEnumerator(TSWPChangeEnumerator *this, TSWPStorage *a2)
{
  NSUInteger v4;
  _NSRange v5;

  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  v5.location = -[TSWPStorage range](a2, "range");
  v5.length = v4;
  TSWPChangeEnumerator::setupWithStorageAndRange(this, a2, v5);
}

{
  NSUInteger v4;
  _NSRange v5;

  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  v5.location = -[TSWPStorage range](a2, "range");
  v5.length = v4;
  TSWPChangeEnumerator::setupWithStorageAndRange(this, a2, v5);
}

TSWPAttributeArray **TSWPChangeEnumerator::setupWithStorageAndRange(TSWPChangeEnumerator *this, TSWPStorage *a2, _NSRange a3)
{
  TSWPChangeAttributeArray *v5;
  TSWPAttributeArray *v6;
  uint64_t v7;
  uint64_t v8;
  TSWPChangeAttributeArray *v9;
  TSWPAttributeArray *v10;
  uint64_t v11;
  uint64_t v12;
  TSWPAttributeArray *v14;
  uint64_t v15;
  _NSRange v16;

  v16 = a3;
  v5 = -[TSWPStorage insertionChangesTable](a2, "insertionChangesTable");
  if (v5)
  {
    v6 = (TSWPAttributeArray *)v5;
    TSWPAttributeArray::begin((TSWPAttributeArray *)v5, &v16, &v14);
    v7 = v15;
    *(_QWORD *)this = v14;
    *((_QWORD *)this + 1) = v7;
    TSWPAttributeArray::end(v6, &v16, &v14);
    v8 = v15;
    *((_QWORD *)this + 2) = v14;
    *((_QWORD *)this + 3) = v8;
  }
  v9 = -[TSWPStorage deletionChangesTable](a2, "deletionChangesTable");
  if (v9)
  {
    v10 = (TSWPAttributeArray *)v9;
    TSWPAttributeArray::begin((TSWPAttributeArray *)v9, &v16, &v14);
    v11 = v15;
    *((_QWORD *)this + 4) = v14;
    *((_QWORD *)this + 5) = v11;
    TSWPAttributeArray::end(v10, &v16, &v14);
    v12 = v15;
    *((_QWORD *)this + 6) = v14;
    *((_QWORD *)this + 7) = v12;
  }
  return TSWPChangeEnumerator::advanceToNonNilObject(this);
}

void TSWPChangeEnumerator::TSWPChangeEnumerator(TSWPChangeEnumerator *this, TSWPStorage *a2, _NSRange a3)
{
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  TSWPChangeEnumerator::setupWithStorageAndRange(this, a2, a3);
}

{
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  TSWPChangeEnumerator::setupWithStorageAndRange(this, a2, a3);
}

TSWPChangeEnumerator *TSWPChangeEnumerator::operator++(TSWPChangeEnumerator *a1)
{
  TSWPAttributeArray **v2;

  v2 = TSWPChangeEnumerator::iter(a1);
  if (v2)
  {
    v2[1] = (TSWPAttributeArray *)((char *)v2[1] + 1);
    TSWPChangeEnumerator::advanceToNonNilObject(a1);
  }
  return a1;
}

TSWPAttributeArray **TSWPChangeEnumerator::iter(TSWPChangeEnumerator *this)
{
  TSWPChangeEnumerator *v1;
  unint64_t v2;
  TSWPChangeEnumerator *v3;
  TSWPAttributeArray **v4;
  unint64_t v5;

  if (*((_QWORD *)this + 1) == *((_QWORD *)this + 3))
    v1 = 0;
  else
    v1 = this;
  v2 = *((_QWORD *)this + 5);
  if (v2 == *((_QWORD *)this + 7))
    return (TSWPAttributeArray **)v1;
  v3 = this;
  v4 = (TSWPAttributeArray **)((char *)this + 32);
  if (!v1)
    return v4;
  v5 = TSWPAttributeArray::charIndexForAttributeIndex(*v4, v2);
  if (v5 < TSWPAttributeArray::charIndexForAttributeIndex(*(TSWPAttributeArray **)v1, *((_QWORD *)v1 + 1)))
    return v4;
  return (TSWPAttributeArray **)v3;
}

TSWPAttributeArray **TSWPChangeEnumerator::advanceToNonNilObject(TSWPChangeEnumerator *this)
{
  TSWPChangeEnumerator *i;
  TSWPAttributeArray **result;
  TSWPAttributeArray *v3;

  for (i = this; ; this = i)
  {
    result = TSWPChangeEnumerator::iter(this);
    if (!result)
      break;
    v3 = result[1];
    if (*((_QWORD *)(*result)->var4 + 2 * (_QWORD)v3 + 1))
      break;
    result[1] = (TSWPAttributeArray *)((char *)&v3->var0 + 1);
  }
  return result;
}

TSWPAttributeArray **TSWPChangeEnumerator::change(TSWPChangeEnumerator *this)
{
  TSWPAttributeArray **result;

  result = TSWPChangeEnumerator::iter(this);
  if (result)
    return (TSWPAttributeArray **)*((_QWORD *)(*result)->var4 + 2 * (_QWORD)result[1] + 1);
  return result;
}

uint64_t TSWPChangeEnumerator::changeRange(TSWPChangeEnumerator *this)
{
  TSWPAttributeArray **v1;

  v1 = TSWPChangeEnumerator::iter(this);
  if (v1)
    return TSWPAttributeArray::rangeForAttributeIndex(*v1, (unint64_t)v1[1]);
  else
    return 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t TSWPChangeEnumerator::changeIsHidden(TSWPChangeEnumerator *this)
{
  TSWPAttributeArray **v1;

  v1 = TSWPChangeEnumerator::iter(this);
  if (v1)
    v1 = (TSWPAttributeArray **)*((_QWORD *)(*v1)->var4 + 2 * (_QWORD)v1[1] + 1);
  return objc_msgSend(v1, "isHidden");
}

uint64_t TSWPChangeEnumerator::changeIsDeletion(TSWPChangeEnumerator *this)
{
  TSWPAttributeArray **v1;

  v1 = TSWPChangeEnumerator::iter(this);
  if (v1)
    v1 = (TSWPAttributeArray **)*((_QWORD *)(*v1)->var4 + 2 * (_QWORD)v1[1] + 1);
  return objc_msgSend(v1, "isDeletion");
}

NSUInteger NSIntersectionRangeWithEdge(_NSRange a1, _NSRange a2, int a3)
{
  NSUInteger length;
  NSUInteger location;
  NSUInteger v6;
  NSUInteger v7;
  NSRange v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  NSUInteger v12;
  NSUInteger v13;
  NSUInteger v14;

  length = a2.length;
  location = a2.location;
  v6 = a1.length;
  v7 = a1.location;
  v8 = NSIntersectionRange(a1, a2);
  if (length)
    v9 = v6 == 0;
  else
    v9 = 1;
  if (v9)
    v10 = 0;
  else
    v10 = 0x7FFFFFFFFFFFFFFFLL;
  if (v7 | location)
    v11 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v11 = v10;
  if (v8 == 0uLL)
    v12 = v11;
  else
    v12 = v8.location;
  if (location + length == v7)
    v13 = v7;
  else
    v13 = v12;
  if (v7 + v6 == location)
    v14 = location;
  else
    v14 = v13;
  if (a3)
    return v14;
  else
    return v12;
}

uint64_t TSWPRangeVector::characterCount(TSWPRangeVector *this)
{
  _NSRange *begin;
  _NSRange *end;
  uint64_t result;

  begin = this->__begin_;
  end = this->__end_;
  if (this->__begin_ == end)
    return 0;
  result = 0;
  do
  {
    result += begin->length;
    ++begin;
  }
  while (begin != end);
  return result;
}

uint64_t TSWPRangeVector::containsCharacterAtIndex(TSWPRangeVector *this, NSUInteger a2, int a3)
{
  int64_t v3;
  unint64_t v4;
  _NSRange *begin;
  unint64_t v6;
  _NSRange *v7;
  _NSRange *v8;
  NSUInteger location;
  NSUInteger v10;
  NSUInteger length;
  uint64_t result;

  v3 = (char *)this->__end_ - (char *)this->__begin_;
  if (!v3)
    return 0;
  v4 = v3 >> 4;
  begin = this->__begin_;
  do
  {
    v6 = v4 >> 1;
    v7 = &begin[v4 >> 1];
    location = v7->location;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (location > a2)
      v4 = v6;
    else
      begin = v8;
  }
  while (v4);
  if (begin == this->__begin_)
    return 0;
  v10 = begin[-1].location;
  length = begin[-1].length;
  if (a2 >= v10 && a2 - v10 < length)
    return 1;
  result = 0;
  if (a3)
  {
    if (length + v10 == a2)
      return 1;
  }
  return result;
}

BOOL TSWPRangeVector::containsRange(TSWPRangeVector *this, const _NSRange *a2)
{
  NSUInteger location;
  uint64_t v4;
  NSUInteger v5;
  _BOOL8 result;

  location = a2->location;
  v5 = TSWPRangeVector::rangeContainingPosition(this, a2->location, 0);
  result = 0;
  if (v5 != 0x7FFFFFFFFFFFFFFFLL && v5 <= location)
    return v5 + v4 >= a2->length + location;
  return result;
}

NSUInteger TSWPRangeVector::rangeContainingPosition(TSWPRangeVector *this, NSUInteger a2, unsigned __int8 a3)
{
  NSUInteger result;
  _NSRange *begin;
  int64_t v6;
  unint64_t v7;
  _NSRange *v8;
  unint64_t v9;
  _NSRange *v10;
  _NSRange *v11;
  NSUInteger location;
  NSUInteger length;
  NSUInteger v14;
  BOOL v15;

  result = *MEMORY[0x24BEB3BF0];
  begin = this->__begin_;
  v6 = (char *)this->__end_ - (char *)this->__begin_;
  if (v6)
  {
    v7 = v6 >> 4;
    v8 = begin;
    do
    {
      v9 = v7 >> 1;
      v10 = &v8[v7 >> 1];
      location = v10->location;
      v11 = v10 + 1;
      v7 += ~(v7 >> 1);
      if (location > a2)
        v7 = v9;
      else
        v8 = v11;
    }
    while (v7);
    if (v8 != begin)
    {
      v14 = v8[-1].location;
      length = v8[-1].length;
      v15 = a2 < v14 || a2 - v14 >= length;
      if (!v15 && ((a2 == v14) & a3) == 0)
        return v14;
    }
  }
  return result;
}

BOOL TSWPRangeVector::hasExactRange(TSWPRangeVector *this, const _NSRange *a2)
{
  NSUInteger location;
  uint64_t v4;
  NSUInteger v5;
  _BOOL8 result;

  location = a2->location;
  v5 = TSWPRangeVector::rangeContainingPosition(this, a2->location, 0);
  result = 0;
  if (v5 != 0x7FFFFFFFFFFFFFFFLL)
    return location == v5 && a2->length == v4;
  return result;
}

BOOL TSWPRangeVector::intersectsRange(TSWPRangeVector *this, const _NSRange *a2)
{
  _NSRange *end;
  _NSRange *begin;
  unint64_t v5;
  _NSRange *v6;
  unint64_t v7;
  NSUInteger *p_location;
  _NSRange *v9;
  NSUInteger v10;

  begin = this->__begin_;
  end = this->__end_;
  if (end == this->__begin_)
  {
    v6 = this->__begin_;
  }
  else
  {
    v5 = end - this->__begin_;
    v6 = this->__begin_;
    do
    {
      v7 = v5 >> 1;
      p_location = &v6[v5 >> 1].location;
      v10 = *p_location;
      v9 = (_NSRange *)(p_location + 2);
      v5 += ~(v5 >> 1);
      if (a2->location < v10)
        v5 = v7;
      else
        v6 = v9;
    }
    while (v5);
  }
  if (v6 != end && NSIntersectionRange(*a2, *v6).length)
    return 1;
  if (v6 == begin)
    return 0;
  return NSIntersectionRange(*a2, *(v6 - 16)).length != 0;
}

uint64_t TSWPRangeVector::indexForRange(TSWPRangeVector *this, _NSRange a2)
{
  _NSRange *end;
  unint64_t v3;
  _NSRange *begin;
  unint64_t v5;
  _NSRange *v6;
  _NSRange *v7;
  NSUInteger location;

  end = this->__end_;
  if (end == this->__begin_)
  {
    begin = this->__begin_;
  }
  else
  {
    v3 = end - this->__begin_;
    begin = this->__begin_;
    do
    {
      v5 = v3 >> 1;
      v6 = &begin[v3 >> 1];
      location = v6->location;
      v7 = v6 + 1;
      v3 += ~(v3 >> 1);
      if (location < a2.location)
        begin = v7;
      else
        v3 = v5;
    }
    while (v3);
  }
  if (begin == end)
  {
    begin = this->__end_;
  }
  else if (begin->location == a2.location)
  {
    begin += a2.length < begin->length;
  }
  return begin - this->__begin_;
}

void TSWPRangeVector::addRange(TSWPRangeVector *this, const _NSRange *a2)
{
  char *end;
  _NSRange *begin;
  NSUInteger location;
  NSUInteger length;
  unint64_t v8;
  _NSRange *v9;
  unint64_t v10;
  _NSRange *v11;
  _NSRange *v12;
  NSUInteger v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  NSUInteger *v17;
  char *v18;
  NSUInteger v19;
  int v20;
  __compressed_pair<_NSRange *, std::allocator<_NSRange>> *p_end_cap;
  _NSRange *value;
  _NSRange *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  _NSRange *v27;
  uint64_t v28;
  _NSRange *v29;
  _NSRange *v30;
  _NSRange *v31;
  NSRange v32;
  NSRange v33;
  uint64_t v35;
  _NSRange *v36;
  _NSRange *v37;
  size_t v38;
  _NSRange *v39;
  _NSRange *v40;
  _NSRange *v41;
  _NSRange *v42;
  _NSRange v43;
  _NSRange v44;
  NSRange v45;
  _NSRange v46;
  NSRange v47;
  NSRange v48;

  if (a2->location != 0x7FFFFFFFFFFFFFFFLL)
  {
    begin = this->__begin_;
    end = (char *)this->__end_;
    if ((char *)this->__begin_ != end)
    {
      if (!a2->length)
        return;
      v43 = *a2;
      length = v43.length;
      location = v43.location;
      v8 = (end - (char *)begin) >> 4;
      v9 = begin;
      do
      {
        v10 = v8 >> 1;
        v11 = &v9[v8 >> 1];
        v13 = v11->location;
        v12 = v11 + 1;
        v8 += ~(v8 >> 1);
        if (v13 < v43.location)
          v9 = v12;
        else
          v8 = v10;
      }
      while (v8);
      if (end == (char *)v9)
      {
        v20 = 0;
        v15 = end;
        v9 = (_NSRange *)end;
      }
      else
      {
        v14 = (end - (char *)v9) >> 4;
        v15 = (char *)v9;
        do
        {
          v16 = v14 >> 1;
          v17 = (NSUInteger *)&v15[16 * (v14 >> 1)];
          v19 = *v17;
          v18 = (char *)(v17 + 2);
          v14 += ~(v14 >> 1);
          if (v19 < v43.length + v43.location)
            v15 = v18;
          else
            v14 = v16;
        }
        while (v14);
        if (NSIntersectionRangeWithEdge(v43, *v9, 1) == 0x7FFFFFFFFFFFFFFFLL)
        {
          v20 = 0;
        }
        else
        {
          v32 = NSUnionRange(v43, *v9);
          location = v32.location;
          length = v32.length;
          v43 = v32;
          v20 = 1;
        }
      }
      if (v9 == begin)
      {
        v9 = begin;
      }
      else
      {
        v44.location = location;
        v44.length = length;
        if (NSIntersectionRangeWithEdge(v44, v9[-1], 1) != 0x7FFFFFFFFFFFFFFFLL)
        {
          v45.location = location;
          v45.length = length;
          v33 = NSUnionRange(v45, v9[-1]);
          location = v33.location;
          length = v33.length;
          v43 = v33;
          v20 = 1;
          --v9;
        }
      }
      v35 = v15 == end && v15 != (char *)begin;
      v36 = (_NSRange *)&v15[16 * (v35 << 63 >> 63)];
      if (v36 == (_NSRange *)end
        || (v46.location = location,
            v46.length = length,
            NSIntersectionRangeWithEdge(v46, *v36, 1) == 0x7FFFFFFFFFFFFFFFLL))
      {
        if (!v20)
          goto LABEL_59;
      }
      else
      {
        v48 = *v36++;
        v47.location = location;
        v47.length = length;
        v43 = NSUnionRange(v47, v48);
      }
      if (v9 >= v36)
      {
        if (v36 < v9)
        {
          v41 = this->__end_;
          v38 = (char *)v41 - (char *)v9;
          if (v41 != v9)
            memmove(v36, v9, (char *)v41 - (char *)v9);
          v9 = v36;
          goto LABEL_58;
        }
        if (v9 == (_NSRange *)end)
        {
LABEL_60:
          std::vector<_NSRange>::insert((uint64_t)this, end, (char *)&v43);
          return;
        }
        v40 = v9 + 1;
        v42 = this->__end_;
        v38 = (char *)v42 - (char *)&v9[1];
        if (v42 == &v9[1])
          goto LABEL_58;
        v39 = v9;
      }
      else
      {
        v37 = this->__end_;
        v38 = (char *)v37 - (char *)v36;
        if (v37 == v36)
        {
LABEL_58:
          this->__end_ = (_NSRange *)((char *)v9 + v38);
LABEL_59:
          end = (char *)v9;
          goto LABEL_60;
        }
        v39 = v9;
        v40 = v36;
      }
      memmove(v39, v40, v38);
      goto LABEL_58;
    }
    p_end_cap = &this->__end_cap_;
    value = this->__end_cap_.__value_;
    if (begin >= value)
    {
      v24 = (char *)value - (char *)begin;
      v25 = v24 >> 3;
      if ((unint64_t)(v24 >> 3) <= 1)
        v25 = 1;
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF0)
        v26 = 0xFFFFFFFFFFFFFFFLL;
      else
        v26 = v25;
      v27 = (_NSRange *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>((uint64_t)p_end_cap, v26);
      v29 = &v27[v28];
      *v27 = *a2;
      v23 = v27 + 1;
      v31 = this->__begin_;
      v30 = this->__end_;
      if (v30 != this->__begin_)
      {
        do
        {
          v27[-1] = v30[-1];
          --v27;
          --v30;
        }
        while (v30 != v31);
        v30 = this->__begin_;
      }
      this->__begin_ = v27;
      this->__end_ = v23;
      this->__end_cap_.__value_ = v29;
      if (v30)
        operator delete(v30);
    }
    else
    {
      *begin = *a2;
      v23 = begin + 1;
    }
    this->__end_ = v23;
  }
}

char *std::vector<_NSRange>::insert(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _OWORD *v11;
  __int128 v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 4) + 1;
    if (v14 >> 60)
      abort();
    v15 = __src - v13;
    v16 = (__src - v13) >> 4;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 3 > v14)
      v14 = v17 >> 3;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0)
      v18 = 0xFFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v30 = a1 + 16;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[16 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[16 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 3;
        v23 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<EQKitLength>>(v8, v22);
        v20 = &v23[16 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[16 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 16 * (v21 >> 1);
        v27 = v20;
      }
    }
    *(_OWORD *)v20 = *(_OWORD *)v3;
    v28 = v20 + 16;
    v4 = (char *)std::vector<EQKitPath::PathElement>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27)
      v28 += (v27 - v28 + 15) & 0xFFFFFFFFFFFFFFF0;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_OWORD *)__src = *(_OWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 16;
  }
  else
  {
    v9 = __src + 16;
    v10 = v6 - 16;
    v11 = *(_OWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_OWORD *)v10;
      v10 += 16;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-16 * ((v6 - v9) >> 4)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 16 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_OWORD *)v4 = *(_OWORD *)v3;
  }
  return v4;
}

void sub_217B57F18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL TSWPRangeVector::removeRange(TSWPRangeVector *this, const _NSRange *a2)
{
  _NSRange *end;
  _NSRange *begin;
  NSUInteger length;
  NSUInteger location;
  NSUInteger v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  char *v12;
  char *v13;
  NSUInteger v14;
  _NSRange *v15;
  unint64_t v16;
  _NSRange *v17;
  _NSRange *v18;
  NSUInteger v19;
  _BOOL8 result;
  NSUInteger v21;
  NSUInteger v22;
  NSUInteger v23;
  NSUInteger v24;
  NSUInteger v25;
  NSUInteger v26;
  NSUInteger v27;
  NSUInteger v28;
  NSUInteger v29;
  NSUInteger v30;
  BOOL v31;
  NSUInteger v32;
  NSUInteger v33;
  NSUInteger v34;
  NSUInteger v35;
  NSUInteger v37;
  NSUInteger v38;
  int64_t v39;
  _NSRange v40;

  begin = this->__begin_;
  end = this->__end_;
  location = a2->location;
  length = a2->length;
  v7 = a2->location;
  if (end == this->__begin_)
  {
    result = 0;
    v15 = begin;
  }
  else
  {
    v8 = end - this->__begin_;
    v9 = v8;
    v10 = (char *)this->__begin_;
    do
    {
      v11 = v9 >> 1;
      v12 = &v10[16 * (v9 >> 1)];
      v14 = *(_QWORD *)v12;
      v13 = v12 + 16;
      v9 += ~(v9 >> 1);
      if (v14 > location)
        v9 = v11;
      else
        v10 = v13;
    }
    while (v9);
    v15 = this->__begin_;
    do
    {
      v16 = v8 >> 1;
      v17 = &v15[v8 >> 1];
      v19 = v17->location;
      v18 = v17 + 1;
      v8 += ~(v8 >> 1);
      if (v19 < length + location)
        v15 = v18;
      else
        v8 = v16;
    }
    while (v8);
    if (v10 == (char *)begin)
    {
      result = 0;
    }
    else
    {
      result = 0;
      begin = (_NSRange *)(v10 - 16);
      v21 = *((_QWORD *)v10 - 2);
      v22 = location - v21;
      if (location < v21 || (v23 = *((_QWORD *)v10 - 1), v22 >= v23))
      {
        begin = (_NSRange *)v10;
      }
      else
      {
        result = location != v21;
        if (location != v21)
        {
          *((_QWORD *)v10 - 1) = v22;
          v7 = a2->location;
          length = a2->length;
          begin = (_NSRange *)v10;
        }
        v24 = length + v7;
        if (length + v7 >= v21 && length + v7 - v21 < v23)
        {
          v25 = v23 + v21;
          if (v24 <= v23 + v21)
            v26 = v23 + v21;
          else
            v26 = length + v7;
          if (v24 < v23 + v21)
            v25 = length + v7;
          v40.location = v25;
          v40.length = v26 - v25;
          if (location == v21)
            *begin = v40;
          else
            std::vector<_NSRange>::insert((uint64_t)this, v10, (char *)&v40);
          return 1;
        }
      }
    }
  }
  if (v15 != end)
  {
    v27 = v15->location;
    v28 = v15->length;
    v29 = length + v7;
    v31 = length + v7 >= v15->location;
    v30 = length + v7 - v15->location;
    v31 = v30 == 0 || !v31 || v30 >= v28;
    if (!v31)
    {
      if (v29 <= v28 + v27)
        v32 = v28 + v27;
      else
        v32 = v29;
      if (v29 >= v28 + v27)
        v29 = v28 + v27;
      v15->location = v29;
      v15->length = v32 - v29;
      result = 1;
    }
  }
  if (begin != v15)
  {
    v33 = v15[-1].location;
    v34 = v15[-1].length;
    v35 = a2->length + a2->location;
    if (v35 >= v33 && v35 - v33 < v34)
    {
      v37 = v34 + v33;
      if (v35 <= v37)
        v38 = v37;
      else
        v38 = a2->length + a2->location;
      if (v35 < v37)
        v37 = a2->length + a2->location;
      v15[-1].location = v37;
      v15[-1].length = v38 - v37;
      --v15;
    }
    if (begin != v15)
    {
      v39 = (char *)end - (char *)v15;
      if (end != v15)
        memmove(begin, v15, (char *)end - (char *)v15);
      this->__end_ = (_NSRange *)((char *)begin + v39);
    }
    return 1;
  }
  return result;
}

TSWPRangeVector *TSWPRangeVector::removeCharacterAtIndex(TSWPRangeVector *this, unint64_t a2)
{
  int64_t v2;
  TSWPRangeVector *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _NSRange *begin;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v15;
  _NSRange *v16;
  _NSRange *end;
  int64_t v18;
  uint64_t v19;
  __int128 v20;

  v2 = (char *)this->__end_ - (char *)this->__begin_;
  if (v2)
  {
    v4 = this;
    v5 = v2 >> 4;
    v6 = a2 + 1;
    v7 = v2 & 0xFFFFFFFFFFFFFFF0;
    v8 = -(uint64_t)(v2 & 0xFFFFFFFFFFFFFFF0);
    do
    {
      begin = v4->__begin_;
      v10 = (char *)v4->__begin_ + v7;
      this = (TSWPRangeVector *)(v10 - 16);
      v11 = *((_QWORD *)v10 - 2);
      v12 = *((_QWORD *)v10 - 1);
      v13 = a2 - v11;
      if (a2 >= v11 && v13 < v12)
      {
        v15 = v12 + v11;
        *(_QWORD *)&v20 = v6;
        *((_QWORD *)&v20 + 1) = v15 - v6;
        if (a2 == v11)
        {
          if (v15 == v6)
          {
            v16 = (_NSRange *)((char *)begin + v7);
            end = v4->__end_;
            v18 = (char *)end - (char *)begin;
            v19 = v8 + v18;
            if (v16 != end)
              this = (TSWPRangeVector *)memmove(this, v16, v8 + v18);
            v4->__end_ = (_NSRange *)((char *)v16 + (v19 & 0xFFFFFFFFFFFFFFF0) - 16);
          }
          else
          {
            *(_OWORD *)&this->__begin_ = v20;
          }
        }
        else
        {
          *((_QWORD *)v10 - 2) = v11;
          *((_QWORD *)v10 - 1) = v13;
          if (*((_QWORD *)&v20 + 1))
            this = (TSWPRangeVector *)std::vector<_NSRange>::insert((uint64_t)v4, (char *)begin + v7, (char *)&v20);
        }
      }
      v7 -= 16;
      v8 += 16;
      --v5;
    }
    while (v5);
  }
  return this;
}

TSWPRangeVector *TSWPRangeVector::insertedTextAtIndex(TSWPRangeVector *this, NSUInteger a2, uint64_t a3)
{
  int64_t v3;
  unint64_t v4;
  NSUInteger *p_length;
  NSUInteger v6;
  uint64_t v7;
  NSUInteger v8;
  uint64_t v9;

  v3 = (char *)this->__end_ - (char *)this->__begin_;
  if (v3)
  {
    v4 = v3 >> 4;
    if (v4 <= 1)
      v4 = 1;
    p_length = &this->__begin_->length;
    do
    {
      v6 = *(p_length - 1);
      if (*p_length + v6 >= a2)
      {
        if (v6 <= a2)
          v7 = a3;
        else
          v7 = 0;
        v8 = v7 + *p_length;
        if (v6 <= a2)
          v9 = 0;
        else
          v9 = a3;
        *(p_length - 1) = v9 + v6;
        *p_length = v8;
      }
      p_length += 2;
      --v4;
    }
    while (v4);
  }
  return this;
}

TSWPRangeVector *TSWPRangeVector::insertGapAtIndex(TSWPRangeVector *this, NSUInteger a2, uint64_t a3)
{
  int64_t v3;
  TSWPRangeVector *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _NSRange *begin;
  _NSRange *v11;
  NSUInteger location;
  NSUInteger v13;
  BOOL v14;
  NSUInteger v15;
  _QWORD v16[2];

  v3 = (char *)this->__end_ - (char *)this->__begin_;
  if (v3)
  {
    v6 = this;
    v7 = 0;
    v8 = v3 >> 4;
    v9 = a3 + a2;
    do
    {
      begin = v6->__begin_;
      v11 = &v6->__begin_[v7];
      location = v11->location;
      v13 = v11->length + v11->location;
      v14 = v13 > a2;
      v15 = v13 - a2;
      if (v14)
      {
        if (a2 <= location)
        {
          v11->location = location + a3;
        }
        else
        {
          v16[0] = v9;
          v16[1] = v15;
          v11->location = location;
          v11->length = a2 - location;
          this = (TSWPRangeVector *)std::vector<_NSRange>::insert((uint64_t)v6, (char *)&begin[++v7], (char *)v16);
          ++v8;
        }
      }
      ++v7;
    }
    while (v7 < v8);
  }
  return this;
}

TSWPRangeVector *TSWPRangeVector::deletedTextAtRange(TSWPRangeVector *this, const _NSRange *a2)
{
  _NSRange *end;
  TSWPRangeVector *v4;
  unint64_t v5;
  unint64_t v6;
  _NSRange *v7;
  NSUInteger location;
  NSUInteger length;
  NSUInteger v10;
  NSUInteger v11;
  NSUInteger v12;
  NSUInteger v13;
  NSUInteger v14;
  NSUInteger v15;
  NSUInteger v16;
  BOOL v17;
  NSUInteger v18;
  uint64_t v19;
  _QWORD *v20;
  NSUInteger v21;
  uint64_t v22;
  NSUInteger v23;
  NSUInteger v24;
  NSUInteger v25;
  int64_t v26;

  end = this->__end_;
  if (end != this->__begin_)
  {
    v4 = this;
    v5 = 0;
    v6 = end - this->__begin_;
    do
    {
      v7 = &v4->__begin_[v5];
      location = v7->location;
      length = v7->length;
      v10 = length + v7->location;
      v11 = a2->location;
      if (v10 > a2->location)
      {
        v12 = a2->length;
        v13 = v12 + v11;
        if (v11 <= location)
        {
          v17 = v10 > v13;
          v15 = v10 - v13;
          if (!v17)
            goto LABEL_33;
          v16 = location - v12;
          v17 = v13 > location;
          if (v13 <= location)
            v18 = v16;
          else
            v18 = a2->location;
          if (v17)
            length = v15;
          if (v5)
          {
            v19 = (uint64_t)&v4->__begin_[v5];
            v21 = *(_QWORD *)(v19 - 16);
            v22 = *(_QWORD *)(v19 - 8);
            v20 = (_QWORD *)(v19 - 16);
            if (v18 <= v22 + v21)
            {
              v24 = v18 + length;
              if (v21 <= v24)
                v25 = v24;
              else
                v25 = v21;
              if (v21 < v24)
                v24 = v21;
              *v20 = v24;
              v20[1] = v25 - v24;
LABEL_33:
              v26 = (char *)end - (char *)&v7[1];
              if (end != &v7[1])
                this = (TSWPRangeVector *)memmove(v7, &v7[1], (char *)end - (char *)&v7[1]);
              end = (_NSRange *)((char *)v7 + v26);
              v4->__end_ = (_NSRange *)((char *)v7 + v26);
              --v6;
              continue;
            }
          }
          v7->location = v18;
          v7->length = length;
        }
        else
        {
          if (v10 <= v13)
          {
            if (location <= v11)
              v23 = a2->location;
            else
              v23 = v7->location;
            if (location >= v11)
              location = a2->location;
            v14 = v23 - location;
            v7->location = location;
          }
          else
          {
            v14 = length - v12;
          }
          v7->length = v14;
        }
      }
      ++v5;
    }
    while (v5 < v6);
  }
  return this;
}

TSWPRangeVector *TSWPRangeVector::replacedTextAtRange(TSWPRangeVector *this, const _NSRange *a2, uint64_t a3)
{
  _NSRange *end;
  TSWPRangeVector *v6;
  unint64_t v7;
  unint64_t v8;
  _NSRange *v9;
  NSUInteger location;
  NSUInteger length;
  NSUInteger v12;
  NSUInteger v13;
  NSUInteger v14;
  NSUInteger v15;
  NSUInteger v16;
  NSUInteger v17;
  NSUInteger v18;
  NSUInteger v19;
  int64_t v20;

  end = this->__end_;
  if (end != this->__begin_)
  {
    v6 = this;
    v7 = 0;
    v8 = end - this->__begin_;
    do
    {
      v9 = &v6->__begin_[v7];
      location = v9->location;
      length = v9->length;
      v12 = length + v9->location;
      v13 = a2->location;
      if (v12 >= a2->location)
      {
        v14 = a2->length;
        v15 = v14 + v13;
        if (v13 <= location)
        {
          if (v15 < v12)
          {
            v16 = v12 + a3 - v15;
            v17 = location + a3 - v14;
            if (v15 > location)
            {
              v18 = v16;
            }
            else
            {
              v13 = v17;
              v18 = v9->length;
            }
LABEL_17:
            v9->location = v13;
            v9->length = v18;
            goto LABEL_20;
          }
          if (!a3)
          {
            v20 = (char *)end - (char *)&v9[1];
            if (end != &v9[1])
              this = (TSWPRangeVector *)memmove(&v6->__begin_[v7], &v9[1], (char *)end - (char *)&v9[1]);
            end = (_NSRange *)((char *)v9 + v20);
            v6->__end_ = (_NSRange *)((char *)v9 + v20);
            --v8;
            continue;
          }
          v9->location = v13;
          v9->length = a3;
        }
        else
        {
          if (v15 >= v12)
          {
            if (location <= v13)
              v19 = a2->location;
            else
              v19 = v9->location;
            if (location < v13)
              v13 = v9->location;
            v18 = v19 - v13;
            goto LABEL_17;
          }
          v9->length = length - v14 + a3;
        }
      }
LABEL_20:
      ++v7;
    }
    while (v7 < v8);
  }
  return this;
}

NSUInteger TSWPRangeVector::changedRange(TSWPRangeVector *this, _NSRange a2, uint64_t a3)
{
  NSUInteger v3;
  NSUInteger length;
  int64_t v6;
  NSUInteger location;
  NSUInteger v8;
  NSUInteger v9;
  unint64_t v10;
  uint64_t v11;
  _NSRange *begin;
  char *v13;
  char *v14;
  NSUInteger v15;
  uint64_t v16;
  _NSRange *v17;
  _NSRange *end;
  int64_t v19;
  uint64_t v20;
  NSRange v21;
  NSRange v24;
  NSRange v25;

  v3 = *MEMORY[0x24BEB3BF0];
  length = *(_QWORD *)(MEMORY[0x24BEB3BF0] + 8);
  if (a3)
  {
    v6 = (char *)this->__end_ - (char *)this->__begin_;
    if (v6)
    {
      location = a2.location;
      v8 = a2.length - a3 + a2.location;
      v9 = (v6 >> 4) - 1;
      v10 = v6 & 0xFFFFFFFFFFFFFFF0;
      v11 = -(uint64_t)(v6 & 0xFFFFFFFFFFFFFFF0);
      do
      {
        begin = this->__begin_;
        v13 = (char *)this->__begin_ + v10;
        v15 = *((_QWORD *)v13 - 2);
        v16 = *((_QWORD *)v13 - 1);
        v14 = v13 - 16;
        if (v16 + v15 <= location)
          break;
        if (v15 >= v8)
        {
          *(_QWORD *)v14 = v15 + a3;
        }
        else
        {
          v17 = (_NSRange *)((char *)begin + v10);
          end = this->__end_;
          v19 = (char *)end - (char *)begin;
          v20 = v11 + v19;
          if (v17 != end)
            memmove(v14, v17, v11 + v19);
          this->__end_ = (_NSRange *)((char *)v17 + (v20 & 0xFFFFFFFFFFFFFFF0) - 16);
          if (v3 == 0x7FFFFFFFFFFFFFFFLL)
          {
            v3 = v9;
            length = 1;
          }
          else
          {
            v24.location = v3;
            v24.length = length;
            v25.location = v9;
            v25.length = 1;
            v21 = NSUnionRange(v24, v25);
            v3 = v21.location;
            length = v21.length;
          }
        }
        --v9;
        v10 -= 16;
        v11 += 16;
      }
      while (v9 != -1);
    }
  }
  return v3;
}

void TSWPRangeVector::unionWith(TSWPRangeVector *this, const TSWPRangeVector *a2)
{
  int64_t v2;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;

  v2 = (char *)a2->__end_ - (char *)a2->__begin_;
  if (v2)
  {
    v5 = 0;
    v6 = v2 >> 4;
    if (v6 <= 1)
      v7 = 1;
    else
      v7 = v6;
    do
    {
      TSWPRangeVector::addRange(this, &a2->__begin_[v5++]);
      --v7;
    }
    while (v7);
  }
}

TSWPRangeVector *TSWPRangeVector::intersection@<X0>(TSWPRangeVector *this@<X0>, TSWPRangeVector *a2@<X8>)
{
  _NSRange *begin;
  _NSRange *end;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  NSUInteger location;
  NSUInteger length;
  _NSRange v13;

  a2->__begin_ = 0;
  a2->__end_ = 0;
  a2->__end_cap_.__value_ = 0;
  begin = this->__begin_;
  end = this->__end_;
  if (this->__begin_ != end)
  {
    v6 = v5;
    this = *(TSWPRangeVector **)v5;
    v8 = *(_QWORD *)(v5 + 8);
    do
    {
      v13 = NSIntersectionRange(*(NSRange *)&this, *begin);
      if (v13.length)
        TSWPRangeVector::addRange(a2, &v13);
      this = *(TSWPRangeVector **)v6;
      v9 = *(_QWORD *)(v6 + 8);
      location = begin->location;
      length = begin->length;
      ++begin;
    }
    while (v9 + *(_QWORD *)v6 >= length + location && begin != end);
  }
  return this;
}

void sub_217B58798(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

TSWPRangeVector *TSWPRangeVector::rangesIntersecting@<X0>(TSWPRangeVector *this@<X0>, TSWPRangeVector *a2@<X8>)
{
  _NSRange *begin;
  _NSRange *end;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  NSUInteger location;
  NSUInteger length;

  a2->__begin_ = 0;
  a2->__end_ = 0;
  a2->__end_cap_.__value_ = 0;
  begin = this->__begin_;
  end = this->__end_;
  if (this->__begin_ != end)
  {
    v6 = v5;
    this = *(TSWPRangeVector **)v5;
    v8 = *(_QWORD *)(v5 + 8);
    do
    {
      if (NSIntersectionRange(*(NSRange *)&this, *begin).length)
        TSWPRangeVector::addRange(a2, begin);
      this = *(TSWPRangeVector **)v6;
      v9 = *(_QWORD *)(v6 + 8);
      location = begin->location;
      length = begin->length;
      ++begin;
    }
    while (v9 + *(_QWORD *)v6 >= length + location && begin != end);
  }
  return this;
}

void sub_217B58828(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void TSWPRangeVector::intersectWith(TSWPRangeVector *this, const _NSRange *a2)
{
  TSWPRangeVector v3;
  void *__p;
  _BYTE *v5;

  if (this->__begin_ != this->__end_)
  {
    TSWPRangeVector::intersection(this, &v3);
    std::vector<CGPoint>::vector(&__p, (uint64_t)this);
    if (&v3 != this)
      std::vector<EQKitLength>::__assign_with_size[abi:nn180100]<EQKitLength*,EQKitLength*>((char *)this, (char *)v3.__begin_, (uint64_t)v3.__end_, v3.__end_ - v3.__begin_);
    std::vector<EQKitLength>::__assign_with_size[abi:nn180100]<EQKitLength*,EQKitLength*>((char *)&v3, (char *)__p, (uint64_t)v5, (v5 - (_BYTE *)__p) >> 4);
    if (__p)
    {
      v5 = __p;
      operator delete(__p);
    }
    if (v3.__begin_)
    {
      v3.__end_ = v3.__begin_;
      operator delete(v3.__begin_);
    }
  }
}

void sub_217B588DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void TSWPRangeVector::intersectWith(TSWPRangeVector *this, const TSWPRangeVector *a2)
{
  _NSRange *begin;
  int64_t v4;
  int64_t v5;
  uint64_t v6;
  unint64_t v7;
  NSUInteger location;
  NSUInteger length;
  uint64_t v10;
  _NSRange *v11;
  NSUInteger v12;
  NSUInteger v13;
  NSUInteger v14;
  uint64_t i;
  _NSRange *v16;
  unint64_t v17;
  const TSWPRangeVector *v18;
  TSWPRangeVector v19;
  _NSRange __p;
  NSRange v21;
  NSRange v22;

  memset(&v19, 0, sizeof(v19));
  begin = this->__begin_;
  v4 = (char *)this->__end_ - (char *)this->__begin_;
  if (v4)
  {
    v5 = (char *)a2->__end_ - (char *)a2->__begin_;
    if (v5)
    {
      v6 = 0;
      v7 = 0;
      v17 = v5 >> 4;
      v18 = a2;
      location = begin->location;
      length = begin->length;
      v10 = (v4 >> 4) - 1;
      do
      {
        v11 = &a2->__begin_[v7];
        v12 = v11->location;
        v13 = v11->length;
        v14 = v13 + v11->location;
        for (i = v6; ; ++i)
        {
          v21.location = v12;
          v21.length = v13;
          v22.location = location;
          v22.length = length;
          __p = NSIntersectionRange(v21, v22);
          if (__p.length)
            TSWPRangeVector::addRange(&v19, &__p);
          if (v14 < length + location)
            break;
          if (v10 == v6)
            goto LABEL_11;
          v16 = &this->__begin_[i];
          location = v16[1].location;
          length = v16[1].length;
          ++v6;
        }
        ++v7;
        a2 = v18;
      }
      while (v7 < v17);
    }
  }
LABEL_11:
  std::vector<CGPoint>::vector(&__p, (uint64_t)this);
  if (&v19 != this)
    std::vector<EQKitLength>::__assign_with_size[abi:nn180100]<EQKitLength*,EQKitLength*>((char *)this, (char *)v19.__begin_, (uint64_t)v19.__end_, v19.__end_ - v19.__begin_);
  std::vector<EQKitLength>::__assign_with_size[abi:nn180100]<EQKitLength*,EQKitLength*>((char *)&v19, (char *)__p.location, __p.length, (uint64_t)(__p.length - __p.location) >> 4);
  if (__p.location)
  {
    __p.length = __p.location;
    operator delete((void *)__p.location);
  }
  if (v19.__begin_)
  {
    v19.__end_ = v19.__begin_;
    operator delete(v19.__begin_);
  }
}

void sub_217B58A68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void TSWPRangeVector::diff(TSWPRangeVector *this, const TSWPRangeVector *a2)
{
  _NSRange *end;
  uint64_t v5;
  int64_t v6;
  TSWPRangeVector __p;

  std::vector<CGPoint>::vector(&__p, (uint64_t)this);
  TSWPRangeVector::intersectWith(&__p, a2);
  TSWPRangeVector::unionWith(this, a2);
  end = __p.__end_;
  if (__p.__end_ != __p.__begin_)
  {
    v5 = 0;
    if ((unint64_t)(__p.__end_ - __p.__begin_) <= 1)
      v6 = 1;
    else
      v6 = __p.__end_ - __p.__begin_;
    do
    {
      TSWPRangeVector::removeRange(this, &__p.__begin_[v5++]);
      --v6;
    }
    while (v6);
    end = __p.__begin_;
  }
  if (end)
  {
    __p.__end_ = end;
    operator delete(end);
  }
}

void sub_217B58B3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t TSWPRangeVector::subtract(TSWPRangeVector *this, const TSWPRangeVector *a2)
{
  int64_t v3;
  uint64_t v5;
  char v6;
  unint64_t v7;
  uint64_t v8;

  if (this->__end_ == this->__begin_)
    return 0;
  v3 = (char *)a2->__end_ - (char *)a2->__begin_;
  if (!v3)
    return 0;
  v5 = 0;
  v6 = 0;
  v7 = v3 >> 4;
  if (v7 <= 1)
    v8 = 1;
  else
    v8 = v7;
  do
  {
    if (TSWPRangeVector::removeRange(this, &a2->__begin_[v5]))
      v6 = 1;
    ++v5;
    --v8;
  }
  while (v8);
  return v6 & 1;
}

void *TSWPRangeVector::description(TSWPRangeVector *this)
{
  void *v2;
  _NSRange *end;
  _NSRange *begin;
  NSRange v6;

  v2 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "stringWithFormat:", CFSTR("<TSWPRangeVector %p> RangeCount: %ld {"), this, this->__end_ - this->__begin_);
  begin = this->__begin_;
  end = this->__end_;
  while (begin != end)
  {
    v6 = *begin++;
    objc_msgSend(v2, "appendString:", NSStringFromRange(v6));
  }
  objc_msgSend(v2, "appendString:", CFSTR("}"));
  return v2;
}

uint64_t TSWPRangeVector::shortDescription(TSWPRangeVector *this)
{
  _NSRange *end;
  _NSRange *begin;
  NSUInteger location;
  NSUInteger v5;
  uint64_t v6;
  NSUInteger v7;
  NSRange v8;

  begin = this->__begin_;
  end = this->__end_;
  if (this->__begin_ == end)
  {
    location = 0;
    v5 = 0;
  }
  else
  {
    location = begin->location;
    v5 = end[-1].length + end[-1].location;
  }
  v6 = end - begin;
  if (location <= v5)
    v7 = v5;
  else
    v7 = location;
  if (location >= v5)
    v8.location = v5;
  else
    v8.location = location;
  v8.length = v7 - v8.location;
  return objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("<TSWPRangeVector %p> count: %ld super: %@"), this, v6, NSStringFromRange(v8));
}

void TSWPChangeAttributeArray::TSWPChangeAttributeArray(uint64_t a1, int a2)
{
  uint64_t v2;

  TSWPAttributeArray::TSWPAttributeArray(a1, a2);
  *(_BYTE *)(v2 + 56) = 0;
  *(_QWORD *)(v2 + 64) = 0;
  *(_QWORD *)v2 = &off_24D82E498;
  *(_DWORD *)(v2 + 72) = 0;
}

{
  uint64_t v2;

  TSWPAttributeArray::TSWPAttributeArray(a1, a2);
  *(_BYTE *)(v2 + 56) = 0;
  *(_QWORD *)(v2 + 64) = 0;
  *(_QWORD *)v2 = &off_24D82E498;
  *(_DWORD *)(v2 + 72) = 0;
}

uint64_t TSWPChangeAttributeArray::setInsertionBehavior(uint64_t result, int a2)
{
  *(_DWORD *)(result + 72) = a2;
  return result;
}

const char *TSWPChangeAttributeArray::className(TSWPChangeAttributeArray *this)
{
  return "TSWPChangeAttributeArray";
}

void TSWPChangeAttributeArray::willReplaceCharactersInRangeWithString(TSWPAttributeArray *this, _NSRange a2, uint64_t a3, uint64_t a4, uint64_t a5, TSWPStorageTransaction *a6)
{
  NSUInteger length;
  NSUInteger location;
  unint64_t v10;
  unint64_t v11;
  _NSRange v12;
  _NSRange v13;
  _NSRange v14;

  length = a2.length;
  location = a2.location;
  if (a2.length && a2.location != 0x7FFFFFFFFFFFFFFFLL && a4)
  {
    LOBYTE(this[1].var0) = 0;
    v10 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(this, a2.location);
    v13.location = location;
    v13.length = length;
    TSWPChangeAttributeArray::clipObjectForReplacement((TSWPChangeAttributeArray *)this, v10, v13, a6);
    v11 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex(this, length + location - 1);
    v14.location = location;
    v14.length = length;
    TSWPChangeAttributeArray::clipObjectForReplacement((TSWPChangeAttributeArray *)this, v11, v14, a6);
    v12.location = location;
    v12.length = length;
    TSWPChangeAttributeArray::deleteInnerObjectsForReplacement((TSWPChangeAttributeArray *)this, v12, a6);
  }
  else
  {
    TSWPSmartFieldAttributeArray::willReplaceCharactersInRangeWithString(this, a2, a3, a4, a5, a6);
  }
}

TSWPChangeAttributeArray *TSWPChangeAttributeArray::clipObjectForReplacement(TSWPChangeAttributeArray *this, unint64_t a2, _NSRange a3, TSWPStorageTransaction *a4)
{
  NSUInteger length;
  NSUInteger location;
  unint64_t v7;
  TSWPAttributeArray *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  TSWPChangeAttributeArray *v13;
  _QWORD v14[2];

  if (*((_QWORD *)this->var4 + 2 * a2 + 1))
  {
    length = a3.length;
    location = a3.location;
    v7 = a2;
    v8 = (TSWPAttributeArray *)this;
    this = (TSWPChangeAttributeArray *)TSWPAttributeArray::rangeForAttributeIndex((TSWPAttributeArray *)this, a2);
    v10 = v9;
    v11 = location + length;
    v12 = (char *)this + v10;
    if (location <= (unint64_t)this)
    {
      if (v11 >= (unint64_t)v12)
      {
        TSWPAttributeArray::replaceObjectForAttributeIndex(v8, 0, v7, 0, a4);
        return (TSWPChangeAttributeArray *)(*((uint64_t (**)(TSWPAttributeArray *, unint64_t, TSWPStorageTransaction *))v8->var0
                                            + 29))(v8, v7, a4);
      }
      v13 = this;
      TSWPAttributeArray::replaceCharIndexForAttributeIndex(v8, v11, v7, a4);
      v14[0] = v13;
    }
    else
    {
      if (v11 < (unint64_t)v12)
        return this;
      ++v7;
      v14[0] = location;
    }
    v14[1] = 0;
    TSWPAttributeArray::insertAttribute(v8, (const TSWPAttributeRecord *)v14, v7, 0, a4);
    return (TSWPChangeAttributeArray *)(*((uint64_t (**)(TSWPAttributeArray *, unint64_t, TSWPStorageTransaction *))v8->var0
                                        + 29))(v8, v7, a4);
  }
  return this;
}

unint64_t TSWPChangeAttributeArray::deleteInnerObjectsForReplacement(TSWPChangeAttributeArray *this, _NSRange a2, TSWPStorageTransaction *a3)
{
  NSUInteger length;
  NSUInteger location;
  unint64_t v7;
  unint64_t result;

  length = a2.length;
  location = a2.location;
  v7 = TSWPAttributeArray::effectiveAttributeIndexForCharIndex((TSWPAttributeArray *)this, a2.location);
  result = TSWPAttributeArray::effectiveAttributeIndexForCharIndex((TSWPAttributeArray *)this, length + location - 1);
  if (result > v7 + 1)
  {
    (*((void (**)(TSWPChangeAttributeArray *, unint64_t, unint64_t, TSWPStorageTransaction *))this->var0
     + 7))(this, v7 + 1, result - (v7 + 1), a3);
    return (*((uint64_t (**)(TSWPChangeAttributeArray *, unint64_t, TSWPStorageTransaction *))this->var0
            + 29))(this, v7, a3);
  }
  return result;
}

uint64_t TSWPChangeAttributeArray::styleInsertionBehaviorForReplacingSelection(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void TSWPChangeAttributeArray::~TSWPChangeAttributeArray(TSWPChangeAttributeArray *this)
{
  TSWPStyleAttributeArray::~TSWPStyleAttributeArray((TSWPAttributeArray *)this);
  JUMPOUT(0x219A153B8);
}

void sub_217B59D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

TSSStyle *TSWPAddNonNilStyleToArray(TSSStyle *result, TSSStyle **a2, unsigned int *a3)
{
  uint64_t v3;

  if (result)
  {
    v3 = *a3;
    *a3 = v3 + 1;
    a2[v3] = result;
  }
  return result;
}

void TSWPCoreTextTypesetter::pChangeTextToUppercaseForRange(TSWPCoreTextTypesetter *this, _NSRange a2)
{
  int64_t length;
  NSUInteger location;
  void *v5;
  uint64_t v6;
  CFLocaleRef System;
  const __CFLocale *v8;
  UniChar *v9;
  const __CFAllocator *v10;
  uint64_t v11;
  UniChar v12;
  __CFString *MutableWithExternalCharactersNoCopy;
  const __CFString *v14;
  void *v15;
  uint64_t v16;

  length = a2.length;
  location = a2.location;
  if (a2.location + a2.length > *((_QWORD *)this + 7))
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPCoreTextTypesetter::pChangeTextToUppercaseForRange(NSRange)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3761, CFSTR("Invalid local range"));
  }
  System = CFLocaleGetSystem();
  if (length >= 1)
  {
    v8 = System;
    v9 = (UniChar *)(*((_QWORD *)this + 10) + 2 * location);
    v10 = (const __CFAllocator *)*MEMORY[0x24BDBD258];
    v11 = length + 1;
    do
    {
      v12 = *v9;
      MutableWithExternalCharactersNoCopy = CFStringCreateMutableWithExternalCharactersNoCopy(0, v9, 1, 1, v10);
      if (MutableWithExternalCharactersNoCopy)
      {
        v14 = MutableWithExternalCharactersNoCopy;
        CFStringUppercase(MutableWithExternalCharactersNoCopy, v8);
        if (CFStringGetLength(v14) != 1)
          *v9 = v12;
        CFRelease(v14);
      }
      else
      {
        v15 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v16 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPCoreTextTypesetter::pChangeTextToUppercaseForRange(NSRange)");
        objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", v16, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3774, CFSTR("Failed to create temporary string for _textBuffer"));
      }
      ++v9;
      --v11;
    }
    while (v11 > 1);
  }
}

uint64_t TSWPCoreTextTypesetter::pChangeToSmallCapsForRange(TSWPCoreTextTypesetter *this, _NSRange a2, int a3, int a4)
{
  NSUInteger length;
  NSUInteger location;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  NSUInteger v12;
  CFCharacterSetRef Predefined;
  const __CFCharacterSet *v14;
  CTFontRef v15;
  int IsCharacterMember;
  uint64_t v17;
  NSUInteger v18;
  NSUInteger v19;
  int v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  const __CTFontDescriptor *v24;
  double Size;
  CGFloat v26;
  uint64_t v27;
  const __CFDictionary *v28;
  const __CTFontDescriptor *CopyWithAttributes;
  const __CTFontDescriptor *v30;
  double v31;
  const __CTFontDescriptor *v32;
  const __CTFontDescriptor *v33;
  __CFDictionary *MutableCopy;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  CFTypeRef v39;
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  unsigned int v43;
  unsigned int v44;
  void *v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  void *key;
  const __CFAllocator *allocator;
  const __CFDictionary *theDict;
  uint64_t v58;
  const __CTFont *font;
  CTFontRef v60;
  _OWORD v61[4];
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  const __CFString *v67;
  _QWORD v68[2];
  _QWORD v69[2];
  _QWORD v70[4];
  _NSRange v71;

  length = a2.length;
  location = a2.location;
  v70[2] = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    if (a2.length)
      goto LABEL_3;
  }
  else
  {
    v46 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v47 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "uint TSWPCoreTextTypesetter::pChangeToSmallCapsForRange(NSRange, uint, BOOL)");
    objc_msgSend(v46, "handleFailureInFunction:file:lineNumber:description:", v47, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3814, CFSTR("runIndex should >= 1"));
    if (length)
      goto LABEL_3;
  }
  v48 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
  v49 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "uint TSWPCoreTextTypesetter::pChangeToSmallCapsForRange(NSRange, uint, BOOL)");
  objc_msgSend(v48, "handleFailureInFunction:file:lineNumber:description:", v49, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3815, CFSTR("localRange.length must be >= 1"));
LABEL_3:
  v8 = (a3 - 1);
  v9 = *((_QWORD *)this + 15) + 104 * v8;
  v58 = *(_QWORD *)(v9 + 16);
  font = *(const __CTFont **)(v9 + 24);
  theDict = *(const __CFDictionary **)(v9 + 32);
  v10 = *(_OWORD *)(v9 + 56);
  v62 = *(_OWORD *)(v9 + 40);
  v63 = v10;
  v11 = *(_OWORD *)(v9 + 88);
  v64 = *(_OWORD *)(v9 + 72);
  v65 = v11;
  v12 = location + length;
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
  if (location < location + length)
  {
    v14 = Predefined;
    v15 = 0;
    v53 = *MEMORY[0x24BDC4D28];
    v52 = *MEMORY[0x24BDC4D18];
    v51 = *MEMORY[0x24BDC4D78];
    v50 = *MEMORY[0x24BDC4D20];
    allocator = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    key = (void *)*MEMORY[0x24BDC4C28];
    do
    {
      v60 = v15;
      IsCharacterMember = CFCharacterSetIsCharacterMember(v14, *(_WORD *)(*((_QWORD *)this + 10) + 2 * location));
      v17 = 1;
      do
      {
        v18 = v17;
        v19 = location + v17;
        if (location + v17 >= v12)
          break;
        v20 = CFCharacterSetIsCharacterMember(v14, *(_WORD *)(*((_QWORD *)this + 10) + 2 * location + 2 * v17));
        v17 = v18 + 1;
      }
      while (IsCharacterMember == v20);
      if (v8 >= *((_DWORD *)this + 28))
      {
        v21 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
        v22 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "uint TSWPCoreTextTypesetter::pChangeToSmallCapsForRange(NSRange, uint, BOOL)");
        objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", v22, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3835, CFSTR("Bad runIndex"));
      }
      *(_QWORD *)(*((_QWORD *)this + 16) + 8 * v8) = v18;
      v23 = *((_QWORD *)this + 15) + 104 * v8;
      *(_QWORD *)v23 = location;
      *(_QWORD *)(v23 + 16) = v58;
      *(_DWORD *)(v23 + 8) = 2 * (IsCharacterMember != 0);
      if (IsCharacterMember)
      {
        if (a4 && TSWPCTFontSupportsNativeSmallCaps(font))
        {
          v24 = CTFontCopyFontDescriptor(font);
          Size = CTFontGetSize(font);
          if (v24)
          {
            v26 = Size;
            v68[0] = v53;
            v68[1] = v52;
            v69[0] = &unk_24D8FB070;
            v69[1] = &unk_24D8FB088;
            v70[0] = objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v69, v68, 2);
            v66 = v51;
            v67 = CFSTR("smcp");
            v70[1] = objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v67, &v66, 1);
            v27 = objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v70, 2);
            v28 = (const __CFDictionary *)objc_msgSend(objc_alloc(MEMORY[0x24BDBCE70]), "initWithObjectsAndKeys:", v27, v50, 0);
            CopyWithAttributes = CTFontDescriptorCreateCopyWithAttributes(v24, v28);
            if (CopyWithAttributes)
            {
              v30 = CopyWithAttributes;
              v60 = CTFontCreateWithFontDescriptor(CopyWithAttributes, v26, 0);
              CFRelease(v30);
            }
            CFRelease(v24);

          }
          v15 = v60;
        }
        else
        {
          v71.location = location;
          v71.length = v18;
          TSWPCoreTextTypesetter::pChangeTextToUppercaseForRange(this, v71);
          v31 = CTFontGetSize(font);
          v32 = CTFontCopyFontDescriptor(font);
          v15 = v60;
          if (v32)
          {
            v33 = v32;
            v15 = CTFontCreateWithFontDescriptor(v32, v31 * 0.800000012, 0);
            CFRelease(v33);
          }
        }
        if (v15)
        {
          MutableCopy = CFDictionaryCreateMutableCopy(allocator, 0, theDict);
          CFDictionarySetValue(MutableCopy, key, v15);
          *(_QWORD *)(*((_QWORD *)this + 15) + 104 * v8 + 32) = MutableCopy;
          *(_QWORD *)(*((_QWORD *)this + 15) + 104 * v8 + 24) = CFRetain(v15);
          TSWPFontHeightInfoForFont(v15, v61);
          v35 = *((_QWORD *)this + 15) + 104 * v8;
          v36 = v61[0];
          v37 = v61[1];
          v38 = v61[2];
          *(_OWORD *)(v35 + 88) = v61[3];
          *(_OWORD *)(v35 + 72) = v38;
          *(_OWORD *)(v35 + 56) = v37;
          *(_OWORD *)(v35 + 40) = v36;
        }
      }
      else
      {
        *(_QWORD *)(*((_QWORD *)this + 15) + 104 * v8 + 32) = CFRetain(theDict);
        v39 = CFRetain(font);
        v40 = *((_QWORD *)this + 15) + 104 * v8;
        *(_QWORD *)(v40 + 24) = v39;
        v41 = v64;
        *(_OWORD *)(v40 + 88) = v65;
        *(_OWORD *)(v40 + 72) = v41;
        v42 = v62;
        *(_OWORD *)(v40 + 56) = v63;
        *(_OWORD *)(v40 + 40) = v42;
        v15 = v60;
      }
      v8 = (v8 + 1);
      v43 = *((_DWORD *)this + 28);
      if (v8 >= v43)
      {
        v44 = 2 * v43;
        *((_DWORD *)this + 28) = v44;
        *((_QWORD *)this + 15) = malloc_type_realloc(*((void **)this + 15), 104 * v44, 0x10E0040261DCC7AuLL);
        *((_QWORD *)this + 16) = malloc_type_realloc(*((void **)this + 16), 8 * *((unsigned int *)this + 28), 0x100004000313F17uLL);
      }
      location = v19;
    }
    while (v19 < v12);
    if (v15)
      CFRelease(v15);
  }
  CFRelease(font);
  CFRelease(theDict);
  return v8;
}

void TSWPCoreTextTypesetter::pChangeTextToTitledForRange(TSWPCoreTextTypesetter *this, _NSRange a2)
{
  NSUInteger length;
  NSUInteger location;
  void *v5;
  uint64_t v6;
  const __CFLocale *System;
  __CFString *MutableWithExternalCharactersNoCopy;
  __CFString *v9;
  void *v10;
  uint64_t v11;

  length = a2.length;
  location = a2.location;
  if (a2.location + a2.length > *((_QWORD *)this + 7))
  {
    v5 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v6 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPCoreTextTypesetter::pChangeTextToTitledForRange(NSRange)");
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3796, CFSTR("Invalid local range"));
  }
  System = CFLocaleGetSystem();
  MutableWithExternalCharactersNoCopy = CFStringCreateMutableWithExternalCharactersNoCopy(0, (UniChar *)(*((_QWORD *)this + 10) + 2 * location), length, length, (CFAllocatorRef)*MEMORY[0x24BDBD258]);
  if (MutableWithExternalCharactersNoCopy)
  {
    v9 = MutableWithExternalCharactersNoCopy;
    CFStringCapitalize(MutableWithExternalCharactersNoCopy, System);
    CFRelease(v9);
  }
  else
  {
    v10 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v11 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPCoreTextTypesetter::pChangeTextToTitledForRange(NSRange)");
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 3802, CFSTR("Failed to create temporary string for _textBuffer"));
  }
}

const __CFString *TSWPCoreTextTypesetter::pNumberedListLabel(TSWPCoreTextTypesetter *this, const TSWPLayoutState *a2, TSWPParagraphEnumerator *a3, unint64_t a4, _BOOL8 a5)
{
  TSWPListStyle *v10;
  id v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  const __CFString *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t TopicNumberForList;
  _BOOL4 v19;
  uint64_t v20;
  id v21;
  char v22;
  char v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  void *v29;
  uint64_t v30;
  TSWPParagraphEnumerator v31;
  TSWPParagraphEnumerator v32;
  _DWORD v33[6];

  if (a4 >= 9)
  {
    v13 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler", a3);
    v14 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSWPCoreTextTypesetter::pNumberedListLabel(const TSWPLayoutState *, TSWPParagraphEnumerator, TSWPParagraphLevel, BOOL)");
    objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", v14, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 1797, CFSTR("illegal list level"));
    return &stru_24D82FEB0;
  }
  v10 = (TSWPListStyle *)TSWPParagraphEnumerator::paragraphListStyle(a3);
  v11 = -[TSSStyle valueForProperty:](v10, "valueForProperty:", 184);
  if (v11)
    v12 = objc_msgSend((id)objc_msgSend(v11, "objectAtIndexedSubscript:", a4), "intValue");
  else
    v12 = +[TSWPListStyle defaultLabelNumberType](TSWPListStyle, "defaultLabelNumberType");
  v16 = v12;
  v17 = TSWPParagraphEnumerator::paragraphListNumber(a3, v33);
  if (v17 == 0x7FFFFFFFFFFFFFFFLL)
  {
    TopicNumberForList = TSWPParagraphEnumerator::paragraphListStart(a3);
    if (!TopicNumberForList)
    {
      TopicNumberForList = TSWPTopicNumberHints::nextTopicNumberForList(*((TSWPTopicNumberHints **)this + 35), v10, a4);
      v19 = TSWPParagraphEnumerator::operator!=(a3, (_QWORD *)a2 + 3);
      v20 = TopicNumberForList - 1;
      if (TopicNumberForList - 1 <= 1)
        v20 = 1;
      if (v19)
        TopicNumberForList = v20;
    }
    goto LABEL_15;
  }
  TopicNumberForList = v17;
  if (!v33[0])
    return &stru_24D82FEB0;
LABEL_15:
  v21 = -[TSSStyle valueForProperty:](v10, "valueForProperty:", 185);
  if (v21)
    v22 = objc_msgSend((id)objc_msgSend(v21, "objectAtIndexedSubscript:", a4), "BOOLValue");
  else
    v22 = +[TSWPListStyle defaultTieredNumber](TSWPListStyle, "defaultTieredNumber");
  v23 = v22;
  if (HIDWORD(TopicNumberForList))
  {
    v29 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
    v30 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NSString *TSWPCoreTextTypesetter::pNumberedListLabel(const TSWPLayoutState *, TSWPParagraphEnumerator, TSWPParagraphLevel, BOOL)");
    objc_msgSend(v29, "handleFailureInFunction:file:lineNumber:description:", v30, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPCoreTextTypesetter.mm"), 1843, CFSTR("Out-of-bounds type assignment was clamped to max"));
    TopicNumberForList = 0xFFFFFFFFLL;
  }
  if (-[TSWPListStyle labelTypeForLevel:](v10, "labelTypeForLevel:", a4) == 3)
    v15 = (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringForValue:withListNumberFormat:includeFormatting:", TopicNumberForList, v16, a5);
  else
    v15 = &stru_24D82FEB0;
  v24 = v23 ^ 1;
  if (!a4)
    v24 = 1;
  if ((v24 & 1) == 0)
  {
    v25 = TSWPTopicNumberHints::previousCharIndexForList(*((TSWPTopicNumberHints **)this + 35), v10, a4 - 1);
    if (v25 != 0x7FFFFFFFFFFFFFFFLL)
    {
      v26 = objc_msgSend(*((id *)this + 2), "paragraphIndexAtCharIndex:", v25);
      TSWPParagraphEnumerator::TSWPParagraphEnumerator((uint64_t)&v32, *((_QWORD *)this + 2), objc_msgSend(*((id *)a2 + 13), "styleProvider"), v26, v26 + 1, 1);
      if (TSWPParagraphEnumerator::paragraphLevel(&v32) < a4
        && objc_msgSend((id)TSWPParagraphEnumerator::paragraphListStyle(&v32), "labelTypeForLevel:", a4 - 1) == 3)
      {
        TSWPParagraphEnumerator::TSWPParagraphEnumerator(&v31, &v32);
        v27 = (void *)TSWPCoreTextTypesetter::pNumberedListLabel(this, a2, &v31, a4 - 1, a5);
        TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v31);
        v15 = (const __CFString *)objc_msgSend(v27, "stringByAppendingString:", v15);
      }
      TSWPParagraphEnumerator::~TSWPParagraphEnumerator(&v32);
    }
  }
  return v15;
}

void sub_217B5AA58(_Unwind_Exception *a1, TSWPParagraphEnumerator *a2, TSWPParagraphEnumerator *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a10);
  TSWPParagraphEnumerator::~TSWPParagraphEnumerator((TSWPParagraphEnumerator *)&a17);
  _Unwind_Resume(a1);
}

uint64_t TSWPCoreTextTypesetter::pLabelFont(TSWPCoreTextTypesetter *this, NSString *a2, CFTypeRef cf2, CGFloat a4)
{
  CGFloat v4;
  const __CFString *v8;
  const __CTFontDescriptor *v9;
  NSString *v11;
  const void *v12;

  v4 = a4;
  if (!*((_QWORD *)this + 31)
    || *((double *)this + 34) != a4
    || (v11 = (NSString *)*((_QWORD *)this + 32), v11 != a2) && !-[NSString isEqual:](v11, "isEqual:", a2)
    || (v12 = (const void *)*((_QWORD *)this + 33)) == 0
    || !CFEqual(v12, cf2))
  {
    TSWPCoreTextTypesetter::pDestroyCachedLabelFont((id *)this);
    *((_QWORD *)this + 32) = a2;
    *((_QWORD *)this + 33) = cf2;
    CFRetain(cf2);
    *((CGFloat *)this + 34) = v4;
    v8 = (const __CFString *)*((_QWORD *)this + 32);
    if (v8)
    {
      v9 = CTFontDescriptorCreateWithNameAndSize(v8, 0.0);
      v4 = *((double *)this + 34);
    }
    else
    {
      v9 = 0;
    }
    *((_QWORD *)this + 31) = CTFontCreateCopyWithAttributes(*((CTFontRef *)this + 33), v4, 0, v9);
    if (v9)
      CFRelease(v9);
  }
  return *((_QWORD *)this + 31);
}

CFStringRef TSWPListLabel::setListLabelString(TSWPListLabel *this, CFStringRef theString)
{
  const void *v4;
  CFStringRef result;

  v4 = (const void *)*((_QWORD *)this + 12);
  if (v4)
    CFRelease(v4);
  result = CFStringCreateCopy(0, theString);
  *((_QWORD *)this + 12) = result;
  return result;
}

void TSWPCoreTextTypesetter::createLineRefForEmptyLineFragment(id *this, id *a2, TSWPLineFragment *a3, int a4, double a5, double a6)
{
  char *v11;
  CFTypeRef *v12;
  CFTypeRef *v13;
  double v14;
  _OWORD *v15;
  void *v16;
  CTFontRef UIFontForLanguage;
  uint64_t v18;
  const void *v19;
  const __CFAttributedString *v20;
  CTLineRef v21;
  void *v22;
  uint64_t v23;
  TSWPCoreTextTypesetter *v24;
  const void *v25;
  const __CFAttributedString *v26;
  void *v27;
  uint64_t v28;
  CFTypeRef cf[2];
  _OWORD v30[7];
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  _BYTE v34[11];
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v13 = (CFTypeRef *)*((_QWORD *)a3 + 24);
  v12 = (CFTypeRef *)*((_QWORD *)a3 + 25);
  v11 = (char *)a3 + 192;
  while (v12 != v13)
  {
    v12 -= 6;
    std::allocator<TSWPLineRef>::destroy[abi:ne180100]((uint64_t)a3 + 208, v12);
  }
  *((_QWORD *)a3 + 25) = v13;
  v14 = TSWPCoreTextTypesetter::pLineRefStartForLineFragment((TSWPCoreTextTypesetter *)this, a2, a3, a5);
  v15 = (_OWORD *)MEMORY[0x24BEB3BF0];
  if (a4)
  {
    v16 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDBCED8]), "initWithCapacity:", 2);
    UIFontForLanguage = CTFontCreateUIFontForLanguage(kCTFontUIFontSystem, 25.1950798, 0);
    objc_msgSend(v16, "setObject:forKeyedSubscript:", UIFontForLanguage, *MEMORY[0x24BDC4C28]);
    CFRelease(UIFontForLanguage);
    v18 = objc_msgSend((id)objc_msgSend(a2[13], "storage"), "createFontAtCharIndex:scaleTextPercent:effectiveRange:styleProvider:", *(_QWORD *)a3, objc_msgSend(a2[13], "scaleTextPercent"), 0, objc_msgSend(a2[13], "styleProvider"));
    if (v18)
    {
      v19 = (const void *)v18;
      objc_msgSend(v16, "setObject:forKeyedSubscript:", v18, CFSTR("TSWPUnadjustedFont"));
      CFRelease(v19);
    }
    v20 = CFAttributedStringCreate(0, CFSTR("\n"), (CFDictionaryRef)v16);
    v21 = CTLineCreateWithAttributedString(v20);
    if (v20)
      CFRelease(v20);

    cf[0] = v21;
    cf[1] = *(CFTypeRef *)&v14;
    *(_QWORD *)&v30[0] = 0;
    *(_OWORD *)((char *)v30 + 8) = *MEMORY[0x24BEB3BF0];
    DWORD2(v30[1]) = 0;
    if (v21)
      CFRetain(v21);
    if (*((_QWORD *)a3 + 25) != *((_QWORD *)a3 + 24))
    {
      v22 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v23 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPLineFragment::setLineRef(const TSWPLineRef &)");
      objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", v23, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.h"), 518, CFSTR("Line ref is already set"));
    }
    std::vector<TSWPLineRef>::assign((uint64_t)v11, 1uLL, (uint64_t)cf);
    if (cf[0])
      CFRelease(cf[0]);
    *(_DWORD *)&v34[7] = 0x10000;
    v33 = 0;
    *(_QWORD *)v34 = 0;
    v32 = 0;
    v31 = 0u;
    memset(v30, 0, sizeof(v30));
    *(_OWORD *)cf = 0u;
    objc_msgSend(this[8], "attributesAtCharIndex:attributesOfInterest:attributesTable:effectiveRange:", objc_msgSend(this[8], "charIndexMappedFromStorage:", *(_QWORD *)a3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0,
        0,
        0,
        0),
      &v33,
      cf,
      0);
    v24 = (TSWPCoreTextTypesetter *)objc_msgSend(*((id *)&v31 + 1), "author");
    if (v24)
      TSWPCoreTextTypesetter::pAddHighlightAdornmentToLineFragment(v24, a3, 7.0, a5, (TSKAnnotationAuthor *)v24);
    if (v21)
      CFRelease(v21);
    if (*((_QWORD *)a3 + 1))
    {
      *((_DWORD *)a3 + 6) |= 0x800u;
      TSWPCoreTextTypesetter::pAddInvisibleBreakToLineFragment(this, (const TSWPLayoutState *)a2, a3, a4, 0.0, 0);
    }
  }
  else
  {
    v25 = (const void *)TSWPCoreTextTypesetter::createLineRefForEmptyLineFragment(TSWPLayoutState const*,TSWPLineFragment *,unsigned short,double,double)const::emptyLine;
    if (!TSWPCoreTextTypesetter::createLineRefForEmptyLineFragment(TSWPLayoutState const*,TSWPLineFragment *,unsigned short,double,double)const::emptyLine)
    {
      v26 = CFAttributedStringCreate(0, &stru_24D82FEB0, 0);
      TSWPCoreTextTypesetter::createLineRefForEmptyLineFragment(TSWPLayoutState const*,TSWPLineFragment *,unsigned short,double,double)const::emptyLine = (uint64_t)CTLineCreateWithAttributedString(v26);
      CFRelease(v26);
      v25 = (const void *)TSWPCoreTextTypesetter::createLineRefForEmptyLineFragment(TSWPLayoutState const*,TSWPLineFragment *,unsigned short,double,double)const::emptyLine;
    }
    cf[0] = v25;
    cf[1] = *(CFTypeRef *)&v14;
    *(_QWORD *)&v30[0] = 0;
    *(_OWORD *)((char *)v30 + 8) = *v15;
    DWORD2(v30[1]) = 0;
    if (v25)
      CFRetain(v25);
    if (*((_QWORD *)a3 + 25) != *((_QWORD *)a3 + 24))
    {
      v27 = (void *)objc_msgSend(MEMORY[0x24BEB3C28], "currentHandler");
      v28 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "void TSWPLineFragment::setLineRef(const TSWPLineRef &)");
      objc_msgSend(v27, "handleFailureInFunction:file:lineNumber:description:", v28, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "/Library/Caches/com.apple.xbs/Sources/AlderShared/text/TSWPLineFragment.h"), 518, CFSTR("Line ref is already set"));
    }
    std::vector<TSWPLineRef>::assign((uint64_t)v11, 1uLL, (uint64_t)cf);
    if (cf[0])
      CFRelease(cf[0]);
    *((double *)a3 + 27) = a5;
  }
  *((_DWORD *)a3 + 6) |= 0x4000u;
  TSWPCoreTextTypesetter::pApplyChangeTrackingToLineFragment(this, a3);
}

void sub_217B5AFA8(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

unint64_t TSWPCoreTextTypesetter::pNextCharIndex(TSWPCoreTextTypesetter *this, unint64_t a2)
{
  unint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = a2;
  v3 = *(void **)(*((_QWORD *)this + 29) + 56);
  if (objc_msgSend(v3, "length") > a2)
  {
    v4 = objc_msgSend((id)objc_msgSend(v3, "string"), "rangeOfComposedCharacterSequenceAtIndex:", v2);
    return v4 + v5;
  }
  return v2;
}

uint64_t TSWPCoreTextTypesetter::pKinsokuCanBreak(TSWPCoreTextTypesetter *this, unint64_t *a2, _NSRange *a3)
{
  unint64_t v6;
  unint64_t v7;
  _NSRange *v8;
  uint64_t v9;
  TSWPRubyField *v10;
  unint64_t location;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  NSUInteger v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t result;
  BOOL v25;
  _NSRange v26;
  _NSRange v27;

  v6 = *a2;
  if (*a2)
  {
    v6 = objc_msgSend((id)objc_msgSend(*(id *)(*((_QWORD *)this + 29) + 56), "string"), "rangeOfComposedCharacterSequenceAtIndex:", v6 - 1);
    v7 = *a2;
  }
  else
  {
    v7 = 0;
  }
  if (v7 == *((_QWORD *)this + 7))
    return 1;
  v8 = (_NSRange *)MEMORY[0x24BEB3BF0];
  v27 = (_NSRange)*MEMORY[0x24BEB3BF0];
  objc_opt_class();
  objc_msgSend(*((id *)this + 8), "smartFieldAtCharIndex:attributeKind:effectiveRange:", v7, 7, &v27);
  v9 = TSUDynamicCast();
  v10 = (TSWPRubyField *)v9;
  if (v9)
  {
    v26 = v27;
    location = v27.location;
    if (v7 + 1 == v27.length + v27.location)
    {
      v12 = *(void **)(*((_QWORD *)this + 29) + 56);
      if (objc_msgSend(v12, "length") > v7)
      {
        v13 = objc_msgSend((id)objc_msgSend(v12, "string"), "rangeOfComposedCharacterSequenceAtIndex:", v7);
        v7 = v13 + v14;
      }
      objc_opt_class();
      objc_msgSend(*((id *)this + 8), "smartFieldAtCharIndex:attributeKind:effectiveRange:", v7, 7, &v26);
      v9 = TSUDynamicCast();
      location = v26.location;
    }
    v15 = v7;
    if (v9)
    {
      v15 = v7;
      if (v7 == location)
      {
        v16 = *(void **)(*((_QWORD *)this + 29) + 56);
        if (objc_msgSend(v16, "length") <= location)
        {
          v15 = location;
        }
        else
        {
          v17 = objc_msgSend((id)objc_msgSend(v16, "string"), "rangeOfComposedCharacterSequenceAtIndex:", location);
          v15 = v17 + v18;
        }
      }
    }
  }
  else
  {
    v15 = v7;
  }
  v26 = *v8;
  objc_opt_class();
  objc_msgSend(*((id *)this + 8), "smartFieldAtCharIndex:attributeKind:effectiveRange:", v6, 7, &v26);
  if (TSUDynamicCast())
  {
    v19 = v26.location;
    if (v6 == v26.location)
    {
      if (v6)
        v20 = objc_msgSend((id)objc_msgSend(*(id *)(*((_QWORD *)this + 29) + 56), "string"), "rangeOfComposedCharacterSequenceAtIndex:", v6 - 1);
      else
        v20 = 0;
      objc_opt_class();
      objc_msgSend(*((id *)this + 8), "smartFieldAtCharIndex:attributeKind:effectiveRange:", v20, 7, &v26);
      if (!TSUDynamicCast())
        goto LABEL_27;
      v19 = v26.location;
    }
    else
    {
      v20 = v6;
      v6 = v7;
    }
    if (v20 + 1 == v26.length + v19)
    {
      v7 = v6;
      if (v20)
        v6 = objc_msgSend((id)objc_msgSend(*(id *)(*((_QWORD *)this + 29) + 56), "string"), "rangeOfComposedCharacterSequenceAtIndex:", v20 - 1);
      else
        v6 = 0;
      goto LABEL_29;
    }
LABEL_27:
    v7 = v6;
    v6 = v20;
  }
LABEL_29:
  v21 = TSWPCoreTextTypesetter::pComposedCharacterAtIndex((id *)this, v6);
  v22 = TSWPCoreTextTypesetter::pComposedCharacterAtIndex((id *)this, v15);
  if (a3)
    *a3 = *v8;
  v23 = IsParagraphBreakingCharacter(v21);
  if ((_DWORD)v21 == 8232
    || (v23 & 1) != 0
    || !KinsokuIllegalEndChar(v21) && !KinsokuIllegalStartChar(v22) && KinsokuAllowSplit(v21, v22))
  {
    if (a3)
      *a3 = v27;
    if (!v10
      || TSWPParagraphTypesetter::rubyLayoutIsDisabledForField(*((TSWPParagraphTypesetter **)this + 29), v10)
      || v7 <= v27.location
      || v7 >= v27.length + v27.location)
    {
LABEL_42:
      *a2 = v7;
      return 1;
    }
    return 0;
  }
  result = IsWhitespaceCharacter(v21);
  if ((_DWORD)result)
  {
    if ((IsWhitespaceCharacter(v22) & 1) != 0)
      return 0;
    v25 = IsBreakingSpaceCharacter(*(unsigned __int16 *)(*((_QWORD *)this + 10) + 2 * v6));
    result = 0;
    if (v6 && !v25)
    {
      do
      {
        result = IsWhitespaceCharacter(*(unsigned __int16 *)(*((_QWORD *)this + 10) + 2 * v6));
        if (!(_DWORD)result)
          break;
        if (IsBreakingSpaceCharacter(*(unsigned __int16 *)(*((_QWORD *)this + 10) + 2 * v6)))
          goto LABEL_42;
        v6 = objc_msgSend((id)objc_msgSend(*(id *)(*((_QWORD *)this + 29) + 56), "string"), "rangeOfComposedCharacterSequenceAtIndex:", v6 - 1);
        result = 0;
      }
      while (v6);
    }
  }
  return result;
}

